{"sha": "e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ZWZiNDdiOWQyM2E5NmZmNDY4NGRmODAzNjBiYmVkMGVjNjhiYzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-19T20:43:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-19T20:43:14Z"}, "message": "Auto merge of #26351 - eddyb:tls-tcx, r=nikomatsakis\n\nPre-requisite for splitting the type context into global and local parts.\r\nThe `Repr` and `UserString` traits were also replaced by `Debug` and `Display`.", "tree": {"sha": "73901ba3b10563a5e7949ab7c2c71ea8a35788e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73901ba3b10563a5e7949ab7c2c71ea8a35788e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "html_url": "https://github.com/rust-lang/rust/commit/e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89485b2b6b643019c1748d456898c8774e2331de", "url": "https://api.github.com/repos/rust-lang/rust/commits/89485b2b6b643019c1748d456898c8774e2331de", "html_url": "https://github.com/rust-lang/rust/commit/89485b2b6b643019c1748d456898c8774e2331de"}, {"sha": "6eed1662af4b72a829b65d7227bdcbdff1220be9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6eed1662af4b72a829b65d7227bdcbdff1220be9", "html_url": "https://github.com/rust-lang/rust/commit/6eed1662af4b72a829b65d7227bdcbdff1220be9"}], "stats": {"total": 8002, "additions": 3525, "deletions": 4477}, "files": [{"sha": "c19ba19f5b76bed5d8a48e471ae95c488303eadf", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -51,6 +51,7 @@\n #![feature(ref_slice)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n+#![feature(scoped_tls)]\n #![feature(slice_bytes)]\n #![feature(slice_extras)]\n #![feature(slice_patterns)]"}, {"sha": "693ccc13f1e4645318d035cc1e1e399a735475cb", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -898,7 +898,7 @@ fn parse_builtin_bounds<F>(st: &mut PState, mut _conv: F) -> ty::BuiltinBounds w\n fn parse_builtin_bounds_<F>(st: &mut PState, _conv: &mut F) -> ty::BuiltinBounds where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n-    let mut builtin_bounds = ty::empty_builtin_bounds();\n+    let mut builtin_bounds = ty::BuiltinBounds::empty();\n \n     loop {\n         match next(st) {"}, {"sha": "33d37b285890add380cb4af184013d386dba25db", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -17,7 +17,6 @@\n use middle::def;\n use middle::ty::{self, Ty};\n use syntax::ast;\n-use util::ppaux::Repr;\n \n pub const NO_REGIONS: usize = 1;\n pub const NO_TPS: usize = 2;\n@@ -63,7 +62,7 @@ pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n         let def = match tcx.def_map.borrow().get(&ast_ty.id) {\n             None => {\n                 tcx.sess.span_bug(ast_ty.span,\n-                                  &format!(\"unbound path {}\", path.repr(tcx)))\n+                                  &format!(\"unbound path {:?}\", path))\n             }\n             Some(d) => d.full_def()\n         };"}, {"sha": "21e2ad198810efc4a62bfc0f76b538a52ec2a78b", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -31,7 +31,6 @@ use middle::privacy::{AllPublic, LastMod};\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::ty::{self, Ty, MethodCall, MethodCallee, MethodOrigin};\n-use util::ppaux::ty_to_string;\n \n use syntax::{ast, ast_util, codemap, fold};\n use syntax::codemap::Span;\n@@ -1623,8 +1622,8 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     }\n                     c::tag_table_node_type => {\n                         let ty = val_dsr.read_ty(dcx);\n-                        debug!(\"inserting ty for node {}: {}\",\n-                               id, ty_to_string(dcx.tcx, ty));\n+                        debug!(\"inserting ty for node {}: {:?}\",\n+                               id,  ty);\n                         dcx.tcx.node_type_insert(id, ty);\n                     }\n                     c::tag_table_item_subst => {"}, {"sha": "8af6946d3c3b13981348069d19c9375274bb47aa", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -33,7 +33,6 @@ use middle::mem_categorization as mc;\n use middle::traits;\n use middle::ty::{self, Ty};\n use util::nodemap::NodeMap;\n-use util::ppaux::Repr;\n \n use syntax::ast;\n use syntax::codemap::Span;\n@@ -300,7 +299,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item) {\n-        debug!(\"visit_item(item={})\", i.repr(self.tcx));\n+        debug!(\"visit_item(item={})\", self.tcx.map.node_to_string(i.id));\n         match i.node {\n             ast::ItemStatic(_, ast::MutImmutable, ref expr) => {\n                 self.check_static_type(&**expr);"}, {"sha": "e1f8e24253b39689fb3130126f3f4fd68a00224e", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -36,7 +36,6 @@ use syntax::print::pprust::pat_to_string;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax::visit::{self, Visitor, FnKind};\n-use util::ppaux::ty_to_string;\n use util::nodemap::FnvHashMap;\n \n pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n@@ -209,9 +208,8 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                 if !type_is_empty(cx.tcx, pat_ty) {\n                     // We know the type is inhabited, so this must be wrong\n                     span_err!(cx.tcx.sess, ex.span, E0002,\n-                        \"non-exhaustive patterns: type {} is non-empty\",\n-                        ty_to_string(cx.tcx, pat_ty)\n-                    );\n+                              \"non-exhaustive patterns: type {} is non-empty\",\n+                              pat_ty);\n                 }\n                 // If the type *is* empty, it's vacuously exhaustive\n                 return;\n@@ -244,11 +242,11 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n                             span_warn!(cx.tcx.sess, p.span, E0170,\n                                 \"pattern binding `{}` is named the same as one \\\n                                  of the variants of the type `{}`\",\n-                                &token::get_ident(ident.node), ty_to_string(cx.tcx, pat_ty));\n+                                &token::get_ident(ident.node), pat_ty);\n                             fileline_help!(cx.tcx.sess, p.span,\n                                 \"if you meant to match on a variant, \\\n                                  consider making the path in the pattern qualified: `{}::{}`\",\n-                                ty_to_string(cx.tcx, pat_ty), &token::get_ident(ident.node));\n+                                pat_ty, &token::get_ident(ident.node));\n                         }\n                     }\n                 }"}, {"sha": "f5934751c58b282528c85fd6de0a76eb5aaeca3c", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -15,7 +15,6 @@ use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n use middle::ty::ParameterEnvironment;\n use middle::ty;\n-use util::ppaux::ty_to_string;\n \n use syntax::ast;\n use syntax::codemap::Span;\n@@ -59,11 +58,11 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'tcx> {\n                span: Span,\n                cmt: mc::cmt<'tcx>,\n                _: euv::ConsumeMode) {\n-        debug!(\"consume; cmt: {:?}; type: {}\", *cmt, ty_to_string(self.tcx, cmt.ty));\n+        debug!(\"consume; cmt: {:?}; type: {:?}\", *cmt, cmt.ty);\n         if !ty::type_is_sized(Some(self.param_env), self.tcx, span, cmt.ty) {\n             span_err!(self.tcx.sess, span, E0161,\n                 \"cannot move a value of type {0}: the size of {0} cannot be statically determined\",\n-                ty_to_string(self.tcx, cmt.ty));\n+                cmt.ty);\n         }\n     }\n "}, {"sha": "23ad3f0d4b904357c32f8150cd3e54b27bf9eb8f", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -23,7 +23,6 @@ use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty};\n use middle::astconv_util::ast_ty_to_prim_ty;\n use util::num::ToPrimitive;\n-use util::ppaux::Repr;\n \n use syntax::ast::{self, Expr};\n use syntax::ast_util;\n@@ -1030,8 +1029,8 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                                                            rcvr_self,\n                                                            Vec::new()));\n     let trait_substs = tcx.mk_substs(trait_substs);\n-    debug!(\"resolve_trait_associated_const: trait_substs={}\",\n-           trait_substs.repr(tcx));\n+    debug!(\"resolve_trait_associated_const: trait_substs={:?}\",\n+           trait_substs);\n     let trait_ref = ty::Binder(ty::TraitRef { def_id: trait_id,\n                                               substs: trait_substs });\n \n@@ -1052,10 +1051,10 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n         }\n         Err(e) => {\n             tcx.sess.span_bug(ti.span,\n-                              &format!(\"Encountered error `{}` when trying \\\n+                              &format!(\"Encountered error `{:?}` when trying \\\n                                         to select an implementation for \\\n                                         constant trait item reference.\",\n-                                       e.repr(tcx)))\n+                                       e))\n         }\n     };\n "}, {"sha": "bb63ec42d8c0cb9c87473545e46ea77e8f5b6cdb", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -15,7 +15,6 @@ use self::UnsafeContext::*;\n use middle::def;\n use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n-use util::ppaux;\n \n use syntax::ast;\n use syntax::codemap::Span;\n@@ -66,8 +65,8 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n             ast::ExprIndex(ref base, _) => ty::node_id_to_type(self.tcx, base.id),\n             _ => return\n         };\n-        debug!(\"effect: checking index with base type {}\",\n-                ppaux::ty_to_string(self.tcx, base_type));\n+        debug!(\"effect: checking index with base type {:?}\",\n+                 base_type);\n         match base_type.sty {\n             ty::TyBox(ty) | ty::TyRef(_, ty::mt{ty, ..}) => if ty::TyStr == ty.sty {\n                 span_err!(self.tcx.sess, e.span, E0134,\n@@ -142,25 +141,25 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n             ast::ExprMethodCall(_, _, _) => {\n                 let method_call = MethodCall::expr(expr.id);\n                 let base_type = self.tcx.method_map.borrow().get(&method_call).unwrap().ty;\n-                debug!(\"effect: method call case, base type is {}\",\n-                       ppaux::ty_to_string(self.tcx, base_type));\n+                debug!(\"effect: method call case, base type is {:?}\",\n+                        base_type);\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span,\n                                         \"invocation of unsafe method\")\n                 }\n             }\n             ast::ExprCall(ref base, _) => {\n                 let base_type = ty::node_id_to_type(self.tcx, base.id);\n-                debug!(\"effect: call case, base type is {}\",\n-                       ppaux::ty_to_string(self.tcx, base_type));\n+                debug!(\"effect: call case, base type is {:?}\",\n+                        base_type);\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span, \"call to unsafe function\")\n                 }\n             }\n             ast::ExprUnary(ast::UnDeref, ref base) => {\n                 let base_type = ty::node_id_to_type(self.tcx, base.id);\n-                debug!(\"effect: unary case, base type is {}\",\n-                       ppaux::ty_to_string(self.tcx, base_type));\n+                debug!(\"effect: unary case, base type is {:?}\",\n+                        base_type);\n                 if let ty::TyRawPtr(_) = base_type.sty {\n                     self.require_unsafe(expr.span, \"dereference of raw pointer\")\n                 }"}, {"sha": "ab67c68be124bd0938f31f5f5e52776acc99b481", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -27,7 +27,6 @@ use middle::ty::{self};\n use middle::ty::{MethodCall, MethodObject, MethodTraitObject};\n use middle::ty::{MethodOrigin, MethodParam, MethodTypeParam};\n use middle::ty::{MethodStatic, MethodStaticClosure};\n-use util::ppaux::Repr;\n \n use syntax::{ast, ast_util};\n use syntax::ptr::P;\n@@ -362,8 +361,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         consume_id: ast::NodeId,\n                         consume_span: Span,\n                         cmt: mc::cmt<'tcx>) {\n-        debug!(\"delegate_consume(consume_id={}, cmt={})\",\n-               consume_id, cmt.repr(self.tcx()));\n+        debug!(\"delegate_consume(consume_id={}, cmt={:?})\",\n+               consume_id, cmt);\n \n         let mode = copy_or_move(self.typer, &cmt, DirectRefMove);\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n@@ -376,7 +375,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     }\n \n     pub fn consume_expr(&mut self, expr: &ast::Expr) {\n-        debug!(\"consume_expr(expr={})\", expr.repr(self.tcx()));\n+        debug!(\"consume_expr(expr={:?})\", expr);\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n         self.delegate_consume(expr.id, expr.span, cmt);\n@@ -397,8 +396,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                    r: ty::Region,\n                    bk: ty::BorrowKind,\n                    cause: LoanCause) {\n-        debug!(\"borrow_expr(expr={}, r={}, bk={})\",\n-               expr.repr(self.tcx()), r.repr(self.tcx()), bk.repr(self.tcx()));\n+        debug!(\"borrow_expr(expr={:?}, r={:?}, bk={:?})\",\n+               expr, r, bk);\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n         self.delegate.borrow(expr.id, expr.span, cmt, r, bk, cause);\n@@ -414,7 +413,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     }\n \n     pub fn walk_expr(&mut self, expr: &ast::Expr) {\n-        debug!(\"walk_expr(expr={})\", expr.repr(self.tcx()));\n+        debug!(\"walk_expr(expr={:?})\", expr);\n \n         self.walk_adjustment(expr);\n \n@@ -618,8 +617,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n     fn walk_callee(&mut self, call: &ast::Expr, callee: &ast::Expr) {\n         let callee_ty = return_if_err!(self.typer.expr_ty_adjusted(callee));\n-        debug!(\"walk_callee: callee={} callee_ty={}\",\n-               callee.repr(self.tcx()), callee_ty.repr(self.tcx()));\n+        debug!(\"walk_callee: callee={:?} callee_ty={:?}\",\n+               callee, callee_ty);\n         let call_scope = region::CodeExtent::from_node_id(call.id);\n         match callee_ty.sty {\n             ty::TyBareFn(..) => {\n@@ -637,7 +636,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         None => {\n                             self.tcx().sess.span_bug(\n                                 callee.span,\n-                                &format!(\"unexpected callee type {}\", callee_ty.repr(self.tcx())))\n+                                &format!(\"unexpected callee type {}\", callee_ty))\n                         }\n                     };\n                 match overloaded_call_type {\n@@ -811,7 +810,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     fn walk_autoderefs(&mut self,\n                        expr: &ast::Expr,\n                        autoderefs: usize) {\n-        debug!(\"walk_autoderefs expr={} autoderefs={}\", expr.repr(self.tcx()), autoderefs);\n+        debug!(\"walk_autoderefs expr={:?} autoderefs={}\", expr, autoderefs);\n \n         for i in 0..autoderefs {\n             let deref_id = ty::MethodCall::autoderef(expr.id, i as u32);\n@@ -828,8 +827,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     let (m, r) = match self_ty.sty {\n                         ty::TyRef(r, ref m) => (m.mutbl, r),\n                         _ => self.tcx().sess.span_bug(expr.span,\n-                                &format!(\"bad overloaded deref type {}\",\n-                                    method_ty.repr(self.tcx())))\n+                                &format!(\"bad overloaded deref type {:?}\",\n+                                    method_ty))\n                     };\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.delegate.borrow(expr.id, expr.span, cmt,\n@@ -842,9 +841,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     fn walk_autoderefref(&mut self,\n                          expr: &ast::Expr,\n                          adj: &ty::AutoDerefRef<'tcx>) {\n-        debug!(\"walk_autoderefref expr={} adj={}\",\n-               expr.repr(self.tcx()),\n-               adj.repr(self.tcx()));\n+        debug!(\"walk_autoderefref expr={:?} adj={:?}\",\n+               expr,\n+               adj);\n \n         self.walk_autoderefs(expr, adj.autoderefs);\n \n@@ -875,9 +874,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     opt_autoref: Option<ty::AutoRef<'tcx>>)\n                     -> mc::cmt<'tcx>\n     {\n-        debug!(\"walk_autoref(expr.id={} cmt_derefd={} opt_autoref={:?})\",\n+        debug!(\"walk_autoref(expr.id={} cmt_derefd={:?} opt_autoref={:?})\",\n                expr.id,\n-               cmt_base.repr(self.tcx()),\n+               cmt_base,\n                opt_autoref);\n \n         let cmt_base_ty = cmt_base.ty;\n@@ -901,9 +900,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ty::AutoUnsafe(m) => {\n-                debug!(\"walk_autoref: expr.id={} cmt_base={}\",\n+                debug!(\"walk_autoref: expr.id={} cmt_base={:?}\",\n                        expr.id,\n-                       cmt_base.repr(self.tcx()));\n+                       cmt_base);\n \n                 // Converting from a &T to *T (or &mut T to *mut T) is\n                 // treated as borrowing it for the enclosing temporary\n@@ -1011,8 +1010,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                cmt_discr: mc::cmt<'tcx>,\n                                pat: &ast::Pat,\n                                mode: &mut TrackMatchMode) {\n-        debug!(\"determine_pat_move_mode cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n-               pat.repr(self.tcx()));\n+        debug!(\"determine_pat_move_mode cmt_discr={:?} pat={:?}\", cmt_discr,\n+               pat);\n         return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n             let tcx = self.tcx();\n             let def_map = &self.tcx().def_map;\n@@ -1043,8 +1042,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 cmt_discr: mc::cmt<'tcx>,\n                 pat: &ast::Pat,\n                 match_mode: MatchMode) {\n-        debug!(\"walk_pat cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n-               pat.repr(self.tcx()));\n+        debug!(\"walk_pat cmt_discr={:?} pat={:?}\", cmt_discr,\n+               pat);\n \n         let mc = &self.mc;\n         let typer = self.typer;\n@@ -1054,9 +1053,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             if pat_util::pat_is_binding(def_map, pat) {\n                 let tcx = typer.tcx();\n \n-                debug!(\"binding cmt_pat={} pat={} match_mode={:?}\",\n-                       cmt_pat.repr(tcx),\n-                       pat.repr(tcx),\n+                debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\",\n+                       cmt_pat,\n+                       pat,\n                        match_mode);\n \n                 // pat_ty: the type of the binding being produced.\n@@ -1160,9 +1159,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                     mc.cat_downcast(pat, cmt_pat, cmt_pat_ty, variant_did)\n                                 };\n \n-                            debug!(\"variant downcast_cmt={} pat={}\",\n-                                   downcast_cmt.repr(tcx),\n-                                   pat.repr(tcx));\n+                            debug!(\"variant downcast_cmt={:?} pat={:?}\",\n+                                   downcast_cmt,\n+                                   pat);\n \n                             delegate.matched_pat(pat, downcast_cmt, match_mode);\n                         }\n@@ -1172,9 +1171,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             // namespace; we encounter the former on\n                             // e.g. patterns for unit structs).\n \n-                            debug!(\"struct cmt_pat={} pat={}\",\n-                                   cmt_pat.repr(tcx),\n-                                   pat.repr(tcx));\n+                            debug!(\"struct cmt_pat={:?} pat={:?}\",\n+                                   cmt_pat,\n+                                   pat);\n \n                             delegate.matched_pat(pat, cmt_pat, match_mode);\n                         }\n@@ -1192,9 +1191,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             // pattern.\n \n                             if !tcx.sess.has_errors() {\n-                                let msg = format!(\"Pattern has unexpected type: {:?} and type {}\",\n+                                let msg = format!(\"Pattern has unexpected type: {:?} and type {:?}\",\n                                                   def,\n-                                                  cmt_pat.ty.repr(tcx));\n+                                                  cmt_pat.ty);\n                                 tcx.sess.span_bug(pat.span, &msg)\n                             }\n                         }\n@@ -1209,9 +1208,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             // reported.\n \n                             if !tcx.sess.has_errors() {\n-                                let msg = format!(\"Pattern has unexpected def: {:?} and type {}\",\n+                                let msg = format!(\"Pattern has unexpected def: {:?} and type {:?}\",\n                                                   def,\n-                                                  cmt_pat.ty.repr(tcx));\n+                                                  cmt_pat.ty);\n                                 tcx.sess.span_bug(pat.span, &msg[..])\n                             }\n                         }\n@@ -1237,7 +1236,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     }\n \n     fn walk_captures(&mut self, closure_expr: &ast::Expr) {\n-        debug!(\"walk_captures({})\", closure_expr.repr(self.tcx()));\n+        debug!(\"walk_captures({:?})\", closure_expr);\n \n         ty::with_freevars(self.tcx(), closure_expr.id, |freevars| {\n             for freevar in freevars {"}, {"sha": "e08da94c7314a0b5c364c9181a44f8ecfaef604c", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -14,7 +14,6 @@ use middle::implicator::Implication;\n use middle::ty::{self, FreeRegion};\n use util::common::can_reach;\n use util::nodemap::FnvHashMap;\n-use util::ppaux::Repr;\n \n #[derive(Clone)]\n pub struct FreeRegionMap {\n@@ -29,11 +28,10 @@ impl FreeRegionMap {\n     }\n \n     pub fn relate_free_regions_from_implications<'tcx>(&mut self,\n-                                                       tcx: &ty::ctxt<'tcx>,\n                                                        implications: &[Implication<'tcx>])\n     {\n         for implication in implications {\n-            debug!(\"implication: {}\", implication.repr(tcx));\n+            debug!(\"implication: {:?}\", implication);\n             match *implication {\n                 Implication::RegionSubRegion(_, ty::ReFree(free_a), ty::ReFree(free_b)) => {\n                     self.relate_free_regions(free_a, free_b);\n@@ -50,7 +48,7 @@ impl FreeRegionMap {\n     pub fn relate_free_regions_from_predicates<'tcx>(&mut self,\n                                                      tcx: &ty::ctxt<'tcx>,\n                                                      predicates: &[ty::Predicate<'tcx>]) {\n-        debug!(\"relate_free_regions_from_predicates(predicates={})\", predicates.repr(tcx));\n+        debug!(\"relate_free_regions_from_predicates(predicates={:?})\", predicates);\n         for predicate in predicates {\n             match *predicate {\n                 ty::Predicate::Projection(..) |\n@@ -68,9 +66,9 @@ impl FreeRegionMap {\n                         _ => {\n                             // All named regions are instantiated with free regions.\n                             tcx.sess.bug(\n-                                &format!(\"record_region_bounds: non free region: {} / {}\",\n-                                         r_a.repr(tcx),\n-                                         r_b.repr(tcx)));\n+                                &format!(\"record_region_bounds: non free region: {:?} / {:?}\",\n+                                         r_a,\n+                                         r_b));\n                         }\n                     }\n                 }"}, {"sha": "d26df43286d9c8db04bc43834ca7e86485d31c25", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 14, "deletions": 45, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -21,10 +21,10 @@ use syntax::codemap::Span;\n \n use util::common::ErrorReported;\n use util::nodemap::FnvHashSet;\n-use util::ppaux::Repr;\n \n // Helper functions related to manipulating region types.\n \n+#[derive(Debug)]\n pub enum Implication<'tcx> {\n     RegionSubRegion(Option<Ty<'tcx>>, ty::Region, ty::Region),\n     RegionSubGeneric(Option<Ty<'tcx>>, ty::Region, GenericKind<'tcx>),\n@@ -53,10 +53,10 @@ pub fn implications<'a,'tcx>(\n     span: Span)\n     -> Vec<Implication<'tcx>>\n {\n-    debug!(\"implications(body_id={}, ty={}, outer_region={})\",\n+    debug!(\"implications(body_id={}, ty={:?}, outer_region={:?})\",\n            body_id,\n-           ty.repr(closure_typer.tcx()),\n-           outer_region.repr(closure_typer.tcx()));\n+           ty,\n+           outer_region);\n \n     let mut stack = Vec::new();\n     stack.push((outer_region, None));\n@@ -68,7 +68,7 @@ pub fn implications<'a,'tcx>(\n                               out: Vec::new(),\n                               visited: FnvHashSet() };\n     wf.accumulate_from_ty(ty);\n-    debug!(\"implications: out={}\", wf.out.repr(closure_typer.tcx()));\n+    debug!(\"implications: out={:?}\", wf.out);\n     wf.out\n }\n \n@@ -78,8 +78,8 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n     }\n \n     fn accumulate_from_ty(&mut self, ty: Ty<'tcx>) {\n-        debug!(\"accumulate_from_ty(ty={})\",\n-               ty.repr(self.tcx()));\n+        debug!(\"accumulate_from_ty(ty={:?})\",\n+               ty);\n \n         // When expanding out associated types, we can visit a cyclic\n         // set of types. Issue #23003.\n@@ -312,8 +312,8 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n     fn accumulate_from_assoc_types_transitive(&mut self,\n                                               data: &ty::PolyTraitPredicate<'tcx>)\n     {\n-        debug!(\"accumulate_from_assoc_types_transitive({})\",\n-               data.repr(self.tcx()));\n+        debug!(\"accumulate_from_assoc_types_transitive({:?})\",\n+               data);\n \n         for poly_trait_ref in traits::supertraits(self.tcx(), data.to_poly_trait_ref()) {\n             match ty::no_late_bound_regions(self.tcx(), &poly_trait_ref) {\n@@ -326,8 +326,8 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n     fn accumulate_from_assoc_types(&mut self,\n                                    trait_ref: ty::TraitRef<'tcx>)\n     {\n-        debug!(\"accumulate_from_assoc_types({})\",\n-               trait_ref.repr(self.tcx()));\n+        debug!(\"accumulate_from_assoc_types({:?})\",\n+               trait_ref);\n \n         let trait_def_id = trait_ref.def_id;\n         let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n@@ -336,8 +336,8 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                      .iter()\n                      .map(|&name| ty::mk_projection(self.tcx(), trait_ref.clone(), name))\n                      .collect();\n-        debug!(\"accumulate_from_assoc_types: assoc_type_projections={}\",\n-               assoc_type_projections.repr(self.tcx()));\n+        debug!(\"accumulate_from_assoc_types: assoc_type_projections={:?}\",\n+               assoc_type_projections);\n         let tys = match self.fully_normalize(&assoc_type_projections) {\n             Ok(tys) => { tys }\n             Err(ErrorReported) => { return; }\n@@ -400,7 +400,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n     }\n \n     fn fully_normalize<T>(&self, value: &T) -> Result<T,ErrorReported>\n-        where T : TypeFoldable<'tcx> + ty::HasProjectionTypes + Clone + Repr<'tcx>\n+        where T : TypeFoldable<'tcx> + ty::HasProjectionTypes\n     {\n         let value =\n             traits::fully_normalize(self.infcx,\n@@ -454,34 +454,3 @@ pub fn object_region_bounds<'tcx>(\n     let predicates = ty::predicates(tcx, open_ty, &param_bounds);\n     ty::required_region_bounds(tcx, open_ty, predicates)\n }\n-\n-impl<'tcx> Repr<'tcx> for Implication<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        match *self {\n-            Implication::RegionSubRegion(_, ref r_a, ref r_b) => {\n-                format!(\"RegionSubRegion({}, {})\",\n-                        r_a.repr(tcx),\n-                        r_b.repr(tcx))\n-            }\n-\n-            Implication::RegionSubGeneric(_, ref r, ref p) => {\n-                format!(\"RegionSubGeneric({}, {})\",\n-                        r.repr(tcx),\n-                        p.repr(tcx))\n-            }\n-\n-            Implication::RegionSubClosure(_, ref a, ref b, ref c) => {\n-                format!(\"RegionSubClosure({}, {}, {})\",\n-                        a.repr(tcx),\n-                        b.repr(tcx),\n-                        c.repr(tcx))\n-            }\n-\n-            Implication::Predicate(ref def_id, ref p) => {\n-                format!(\"Predicate({}, {})\",\n-                        def_id.repr(tcx),\n-                        p.repr(tcx))\n-            }\n-        }\n-    }\n-}"}, {"sha": "742ad3f29b7808aea72c87fba94d39eb94bdd7b3", "filename": "src/librustc/middle/infer/bivariate.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -31,7 +31,6 @@ use super::type_variable::{BiTo};\n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n-use util::ppaux::{Repr};\n \n pub struct Bivariate<'a, 'tcx: 'a> {\n     fields: CombineFields<'a, 'tcx>\n@@ -73,8 +72,8 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx> {\n     }\n \n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"{}.tys({}, {})\", self.tag(),\n-               a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n+        debug!(\"{}.tys({:?}, {:?})\", self.tag(),\n+               a, b);\n         if a == b { return Ok(a); }\n \n         let infcx = self.fields.infcx;"}, {"sha": "17d545212c281184c43f37b5b43b6670ed4f0197", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -47,7 +47,6 @@ use middle::ty::{self, Ty};\n use middle::ty_fold;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use middle::ty_relate::{self, Relate, RelateResult, TypeRelation};\n-use util::ppaux::Repr;\n \n use syntax::ast;\n use syntax::codemap::Span;\n@@ -187,7 +186,6 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n                        b_vid: ty::TyVid)\n                        -> RelateResult<'tcx, ()>\n     {\n-        let tcx = self.infcx.tcx;\n         let mut stack = Vec::new();\n         stack.push((a_ty, dir, b_vid));\n         loop {\n@@ -213,10 +211,10 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n                 Some(e) => e,\n             };\n \n-            debug!(\"instantiate(a_ty={} dir={:?} b_vid={})\",\n-                   a_ty.repr(tcx),\n+            debug!(\"instantiate(a_ty={:?} dir={:?} b_vid={:?})\",\n+                   a_ty,\n                    dir,\n-                   b_vid.repr(tcx));\n+                   b_vid);\n \n             // Check whether `vid` has been instantiated yet.  If not,\n             // make a generalized form of `ty` and instantiate with\n@@ -230,10 +228,10 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n                         EqTo => self.generalize(a_ty, b_vid, false),\n                         BiTo | SupertypeOf | SubtypeOf => self.generalize(a_ty, b_vid, true),\n                     });\n-                    debug!(\"instantiate(a_ty={}, dir={:?}, \\\n-                                        b_vid={}, generalized_ty={})\",\n-                           a_ty.repr(tcx), dir, b_vid.repr(tcx),\n-                           generalized_ty.repr(tcx));\n+                    debug!(\"instantiate(a_ty={:?}, dir={:?}, \\\n+                                        b_vid={:?}, generalized_ty={:?})\",\n+                           a_ty, dir, b_vid,\n+                           generalized_ty);\n                     self.infcx.type_variables\n                         .borrow_mut()\n                         .instantiate_and_push(\n@@ -335,8 +333,8 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n             ty::ReEarlyBound(..) => {\n                 self.tcx().sess.span_bug(\n                     self.span,\n-                    &format!(\"Encountered early bound region when generalizing: {}\",\n-                            r.repr(self.tcx())));\n+                    &format!(\"Encountered early bound region when generalizing: {:?}\",\n+                            r));\n             }\n \n             // Always make a fresh region variable for skolemized regions;"}, {"sha": "cbbf73d942073c2714bf30bcc84f169526a2f4ce", "filename": "src/librustc/middle/infer/equate.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -16,7 +16,6 @@ use super::type_variable::{EqTo};\n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n-use util::ppaux::{Repr};\n \n pub struct Equate<'a, 'tcx: 'a> {\n     fields: CombineFields<'a, 'tcx>\n@@ -45,8 +44,8 @@ impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {\n     }\n \n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"{}.tys({}, {})\", self.tag(),\n-               a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n+        debug!(\"{}.tys({:?}, {:?})\", self.tag(),\n+               a, b);\n         if a == b { return Ok(a); }\n \n         let infcx = self.fields.infcx;\n@@ -75,10 +74,10 @@ impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {\n     }\n \n     fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n-        debug!(\"{}.regions({}, {})\",\n+        debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n-               a.repr(self.fields.infcx.tcx),\n-               b.repr(self.fields.infcx.tcx));\n+               a,\n+               b);\n         let origin = Subtype(self.fields.trace.clone());\n         self.fields.infcx.region_vars.make_eqregion(origin, a, b);\n         Ok(a)"}, {"sha": "4ae618d45b7280b644059a1f2d06ed7745dc6a33", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 148, "deletions": 27, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -75,25 +75,141 @@ use std::collections::HashSet;\n use ast_map;\n use middle::def;\n use middle::infer;\n+use middle::region;\n use middle::subst;\n use middle::ty::{self, Ty};\n use middle::ty::{Region, ReFree};\n+\n use std::cell::{Cell, RefCell};\n use std::char::from_u32;\n-use std::string::String;\n+use std::fmt;\n use syntax::ast;\n use syntax::ast_util::name_to_dummy_lifetime;\n use syntax::owned_slice::OwnedSlice;\n-use syntax::codemap;\n+use syntax::codemap::{Pos, Span};\n use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ptr::P;\n-use util::ppaux::bound_region_to_string;\n-use util::ppaux::note_and_explain_region;\n \n-// Note: only import UserString, not Repr, since user-facing error\n-// messages shouldn't include debug serializations.\n-use util::ppaux::UserString;\n+pub fn note_and_explain_region(tcx: &ty::ctxt,\n+                               prefix: &str,\n+                               region: ty::Region,\n+                               suffix: &str) {\n+    fn item_scope_tag(item: &ast::Item) -> &'static str {\n+        match item.node {\n+            ast::ItemImpl(..) => \"impl\",\n+            ast::ItemStruct(..) => \"struct\",\n+            ast::ItemEnum(..) => \"enum\",\n+            ast::ItemTrait(..) => \"trait\",\n+            ast::ItemFn(..) => \"function body\",\n+            _ => \"item\"\n+        }\n+    }\n+\n+    fn explain_span(tcx: &ty::ctxt, heading: &str, span: Span)\n+                    -> (String, Option<Span>) {\n+        let lo = tcx.sess.codemap().lookup_char_pos_adj(span.lo);\n+        (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize()),\n+         Some(span))\n+    }\n+\n+    let (description, span) = match region {\n+        ty::ReScope(scope) => {\n+            let new_string;\n+            let unknown_scope = || {\n+                format!(\"{}unknown scope: {:?}{}.  Please report a bug.\",\n+                        prefix, scope, suffix)\n+            };\n+            let span = match scope.span(&tcx.map) {\n+                Some(s) => s,\n+                None => return tcx.sess.note(&unknown_scope())\n+            };\n+            let tag = match tcx.map.find(scope.node_id()) {\n+                Some(ast_map::NodeBlock(_)) => \"block\",\n+                Some(ast_map::NodeExpr(expr)) => match expr.node {\n+                    ast::ExprCall(..) => \"call\",\n+                    ast::ExprMethodCall(..) => \"method call\",\n+                    ast::ExprMatch(_, _, ast::MatchSource::IfLetDesugar { .. }) => \"if let\",\n+                    ast::ExprMatch(_, _, ast::MatchSource::WhileLetDesugar) =>  \"while let\",\n+                    ast::ExprMatch(_, _, ast::MatchSource::ForLoopDesugar) =>  \"for\",\n+                    ast::ExprMatch(..) => \"match\",\n+                    _ => \"expression\",\n+                },\n+                Some(ast_map::NodeStmt(_)) => \"statement\",\n+                Some(ast_map::NodeItem(it)) => item_scope_tag(&*it),\n+                Some(_) | None => {\n+                    return tcx.sess.span_note(span, &unknown_scope());\n+                }\n+            };\n+            let scope_decorated_tag = match scope {\n+                region::CodeExtent::Misc(_) => tag,\n+                region::CodeExtent::ParameterScope { .. } => {\n+                    \"scope of parameters for function\"\n+                }\n+                region::CodeExtent::DestructionScope(_) => {\n+                    new_string = format!(\"destruction scope surrounding {}\", tag);\n+                    &new_string[..]\n+                }\n+                region::CodeExtent::Remainder(r) => {\n+                    new_string = format!(\"block suffix following statement {}\",\n+                                         r.first_statement_index);\n+                    &new_string[..]\n+                }\n+            };\n+            explain_span(tcx, scope_decorated_tag, span)\n+        }\n+\n+        ty::ReFree(ref fr) => {\n+            let prefix = match fr.bound_region {\n+                ty::BrAnon(idx) => {\n+                    format!(\"the anonymous lifetime #{} defined on\", idx + 1)\n+                }\n+                ty::BrFresh(_) => \"an anonymous lifetime defined on\".to_owned(),\n+                _ => {\n+                    format!(\"the lifetime {} as defined on\",\n+                            fr.bound_region)\n+                }\n+            };\n+\n+            match tcx.map.find(fr.scope.node_id) {\n+                Some(ast_map::NodeBlock(ref blk)) => {\n+                    let (msg, opt_span) = explain_span(tcx, \"block\", blk.span);\n+                    (format!(\"{} {}\", prefix, msg), opt_span)\n+                }\n+                Some(ast_map::NodeItem(it)) => {\n+                    let tag = item_scope_tag(&*it);\n+                    let (msg, opt_span) = explain_span(tcx, tag, it.span);\n+                    (format!(\"{} {}\", prefix, msg), opt_span)\n+                }\n+                Some(_) | None => {\n+                    // this really should not happen\n+                    (format!(\"{} unknown free region bounded by scope {:?}\",\n+                             prefix, fr.scope), None)\n+                }\n+            }\n+        }\n+\n+        ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n+\n+        ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n+\n+        ty::ReEarlyBound(ref data) => {\n+            (format!(\"{}\", token::get_name(data.name)), None)\n+        }\n+\n+        // I believe these cases should not occur (except when debugging,\n+        // perhaps)\n+        ty::ReInfer(_) | ty::ReLateBound(..) => {\n+            (format!(\"lifetime {:?}\", region), None)\n+        }\n+    };\n+    let message = format!(\"{}{}{}\", prefix, description, suffix);\n+    if let Some(span) = span {\n+        tcx.sess.span_note(span, &message);\n+    } else {\n+        tcx.sess.note(&message);\n+    }\n+}\n \n pub trait ErrorReporting<'tcx> {\n     fn report_region_errors(&self,\n@@ -110,7 +226,7 @@ pub trait ErrorReporting<'tcx> {\n \n     fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<String>;\n \n-    fn expected_found_str<T: UserString<'tcx> + Resolvable<'tcx>>(\n+    fn expected_found_str<T: fmt::Display + Resolvable<'tcx>>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<String>;\n@@ -162,7 +278,7 @@ trait ErrorReportingHelpers<'tcx> {\n                                 ident: ast::Ident,\n                                 opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                                 generics: &ast::Generics,\n-                                span: codemap::Span);\n+                                span: Span);\n }\n \n impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n@@ -361,7 +477,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             \"{}: {} ({})\",\n                  trace.origin,\n                  expected_found_str,\n-                 ty::type_err_to_str(self.tcx, terr));\n+                 terr);\n \n         match trace.origin {\n             infer::MatchExpressionArm(_, arm_span) =>\n@@ -388,7 +504,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn expected_found_str<T: UserString<'tcx> + Resolvable<'tcx>>(\n+    fn expected_found_str<T: fmt::Display + Resolvable<'tcx>>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<String>\n@@ -404,8 +520,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n \n         Some(format!(\"expected `{}`, found `{}`\",\n-                     expected.user_string(self.tcx),\n-                     found.user_string(self.tcx)))\n+                     expected,\n+                     found))\n     }\n \n     fn report_generic_bound_failure(&self,\n@@ -421,9 +537,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) =>\n-                format!(\"the parameter type `{}`\", p.user_string(self.tcx)),\n+                format!(\"the parameter type `{}`\", p),\n             GenericKind::Projection(ref p) =>\n-                format!(\"the associated type `{}`\", p.user_string(self.tcx)),\n+                format!(\"the associated type `{}`\", p),\n         };\n \n         match sub {\n@@ -435,8 +551,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     origin.span(),\n                     &format!(\n                         \"consider adding an explicit lifetime bound `{}: {}`...\",\n-                        bound_kind.user_string(self.tcx),\n-                        sub.user_string(self.tcx)));\n+                        bound_kind,\n+                        sub));\n             }\n \n             ty::ReStatic => {\n@@ -447,7 +563,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     origin.span(),\n                     &format!(\n                         \"consider adding an explicit lifetime bound `{}: 'static`...\",\n-                        bound_kind.user_string(self.tcx)));\n+                        bound_kind));\n             }\n \n             _ => {\n@@ -459,7 +575,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     origin.span(),\n                     &format!(\n                         \"consider adding an explicit lifetime bound for `{}`\",\n-                        bound_kind.user_string(self.tcx)));\n+                        bound_kind));\n                 note_and_explain_region(\n                     self.tcx,\n                     &format!(\"{} must be valid for \", labeled_user_string),\n@@ -1431,7 +1547,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                                 ident: ast::Ident,\n                                 opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                                 generics: &ast::Generics,\n-                                span: codemap::Span) {\n+                                span: Span) {\n         let suggested_fn = pprust::fun_to_string(decl, unsafety, constness, ident,\n                                                  opt_explicit_self, generics);\n         let msg = format!(\"consider using an explicit lifetime \\\n@@ -1441,24 +1557,29 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn report_inference_failure(&self,\n                                 var_origin: RegionVariableOrigin) {\n+        let br_string = |br: ty::BoundRegion| {\n+            let mut s = br.to_string();\n+            if !s.is_empty() {\n+                s.push_str(\" \");\n+            }\n+            s\n+        };\n         let var_description = match var_origin {\n             infer::MiscVariable(_) => \"\".to_string(),\n             infer::PatternRegion(_) => \" for pattern\".to_string(),\n             infer::AddrOfRegion(_) => \" for borrow expression\".to_string(),\n             infer::Autoref(_) => \" for autoref\".to_string(),\n             infer::Coercion(_) => \" for automatic coercion\".to_string(),\n             infer::LateBoundRegion(_, br, infer::FnCall) => {\n-                format!(\" for {}in function call\",\n-                        bound_region_to_string(self.tcx, \"lifetime parameter \", true, br))\n+                format!(\" for lifetime parameter {}in function call\",\n+                        br_string(br))\n             }\n             infer::LateBoundRegion(_, br, infer::HigherRankedType) => {\n-                format!(\" for {}in generic type\",\n-                        bound_region_to_string(self.tcx, \"lifetime parameter \", true, br))\n+                format!(\" for lifetime parameter {}in generic type\", br_string(br))\n             }\n             infer::LateBoundRegion(_, br, infer::AssocTypeProjection(type_name)) => {\n-                format!(\" for {}in trait containing associated type `{}`\",\n-                        bound_region_to_string(self.tcx, \"lifetime parameter \", true, br),\n-                        token::get_name(type_name))\n+                format!(\" for lifetime parameter {}in trait containing associated type `{}`\",\n+                        br_string(br), token::get_name(type_name))\n             }\n             infer::EarlyBoundRegion(_, name) => {\n                 format!(\" for lifetime parameter `{}`\","}, {"sha": "d6b03266b1fe74e32d4d58cc2d2f5ef0cb316bb3", "filename": "src/librustc/middle/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -16,7 +16,6 @@ use super::Subtype;\n \n use middle::ty::{self, Ty};\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n-use util::ppaux::Repr;\n \n /// \"Greatest lower bound\" (common subtype)\n pub struct Glb<'a, 'tcx: 'a> {\n@@ -55,10 +54,10 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Glb<'a, 'tcx> {\n     }\n \n     fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n-        debug!(\"{}.regions({}, {})\",\n+        debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n-               a.repr(self.fields.infcx.tcx),\n-               b.repr(self.fields.infcx.tcx));\n+               a,\n+               b);\n \n         let origin = Subtype(self.fields.trace.clone());\n         Ok(self.fields.infcx.region_vars.glb_regions(origin, a, b))"}, {"sha": "7b26f6b153733a7f13e8125ead80914a9a48c08c", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 40, "deletions": 43, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -20,7 +20,6 @@ use middle::ty_fold::{self, TypeFoldable};\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use syntax::codemap::Span;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n-use util::ppaux::Repr;\n \n pub trait HigherRankedRelations<'a,'tcx> {\n     fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n@@ -46,10 +45,8 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n                             -> RelateResult<'tcx, Binder<T>>\n         where T: Relate<'a,'tcx>\n     {\n-        let tcx = self.infcx.tcx;\n-\n-        debug!(\"higher_ranked_sub(a={}, b={})\",\n-               a.repr(tcx), b.repr(tcx));\n+        debug!(\"higher_ranked_sub(a={:?}, b={:?})\",\n+               a, b);\n \n         // Rather than checking the subtype relationship between `a` and `b`\n         // as-is, we need to do some extra work here in order to make sure\n@@ -75,8 +72,8 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n             let (b_prime, skol_map) =\n                 self.infcx.skolemize_late_bound_regions(b, snapshot);\n \n-            debug!(\"a_prime={}\", a_prime.repr(tcx));\n-            debug!(\"b_prime={}\", b_prime.repr(tcx));\n+            debug!(\"a_prime={:?}\", a_prime);\n+            debug!(\"b_prime={:?}\", b_prime);\n \n             // Compare types now that bound regions have been replaced.\n             let result = try!(self.sub().relate(&a_prime, &b_prime));\n@@ -98,8 +95,8 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n                 }\n             }\n \n-            debug!(\"higher_ranked_sub: OK result={}\",\n-                   result.repr(tcx));\n+            debug!(\"higher_ranked_sub: OK result={:?}\",\n+                   result);\n \n             Ok(ty::Binder(result))\n         });\n@@ -125,7 +122,7 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n                 try!(self.lub().relate(&a_with_fresh, &b_with_fresh));\n             let result0 =\n                 self.infcx.resolve_type_vars_if_possible(&result0);\n-            debug!(\"lub result0 = {}\", result0.repr(self.tcx()));\n+            debug!(\"lub result0 = {:?}\", result0);\n \n             // Generalize the regions appearing in result0 if possible\n             let new_vars = self.infcx.region_vars_confined_to_snapshot(snapshot);\n@@ -137,10 +134,10 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n                     |r, debruijn| generalize_region(self.infcx, span, snapshot, debruijn,\n                                                     &new_vars, &a_map, r));\n \n-            debug!(\"lub({},{}) = {}\",\n-                   a.repr(self.tcx()),\n-                   b.repr(self.tcx()),\n-                   result1.repr(self.tcx()));\n+            debug!(\"lub({:?},{:?}) = {:?}\",\n+                   a,\n+                   b,\n+                   result1);\n \n             Ok(ty::Binder(result1))\n         });\n@@ -198,8 +195,8 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n     fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n         where T: Relate<'a,'tcx>\n     {\n-        debug!(\"higher_ranked_glb({}, {})\",\n-               a.repr(self.tcx()), b.repr(self.tcx()));\n+        debug!(\"higher_ranked_glb({:?}, {:?})\",\n+               a, b);\n \n         // Make a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n@@ -219,7 +216,7 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n                 try!(self.glb().relate(&a_with_fresh, &b_with_fresh));\n             let result0 =\n                 self.infcx.resolve_type_vars_if_possible(&result0);\n-            debug!(\"glb result0 = {}\", result0.repr(self.tcx()));\n+            debug!(\"glb result0 = {:?}\", result0);\n \n             // Generalize the regions appearing in result0 if possible\n             let new_vars = self.infcx.region_vars_confined_to_snapshot(snapshot);\n@@ -233,10 +230,10 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n                                                     &a_map, &a_vars, &b_vars,\n                                                     r));\n \n-            debug!(\"glb({},{}) = {}\",\n-                   a.repr(self.tcx()),\n-                   b.repr(self.tcx()),\n-                   result1.repr(self.tcx()));\n+            debug!(\"glb({:?},{:?}) = {:?}\",\n+                   a,\n+                   b,\n+                   result1);\n \n             Ok(ty::Binder(result1))\n         });\n@@ -451,9 +448,9 @@ impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n             !escaping_region_vars.contains(&r)\n         });\n \n-        debug!(\"region_vars_confined_to_snapshot: region_vars={} escaping_types={}\",\n-               region_vars.repr(self.tcx),\n-               escaping_types.repr(self.tcx));\n+        debug!(\"region_vars_confined_to_snapshot: region_vars={:?} escaping_types={:?}\",\n+               region_vars,\n+               escaping_types);\n \n         region_vars\n     }\n@@ -520,7 +517,7 @@ pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                                binder: &ty::Binder<T>,\n                                                snapshot: &CombinedSnapshot)\n                                                -> (T, SkolemizationMap)\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    where T : TypeFoldable<'tcx>\n {\n     /*!\n      * Replace all regions bound by `binder` with skolemized regions and\n@@ -534,10 +531,10 @@ pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n         infcx.region_vars.new_skolemized(br, &snapshot.region_vars_snapshot)\n     });\n \n-    debug!(\"skolemize_bound_regions(binder={}, result={}, map={})\",\n-           binder.repr(infcx.tcx),\n-           result.repr(infcx.tcx),\n-           map.repr(infcx.tcx));\n+    debug!(\"skolemize_bound_regions(binder={:?}, result={:?}, map={:?})\",\n+           binder,\n+           result,\n+           map);\n \n     (result, map)\n }\n@@ -555,8 +552,8 @@ pub fn leak_check<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n      * hold. See `README.md` for more details.\n      */\n \n-    debug!(\"leak_check: skol_map={}\",\n-           skol_map.repr(infcx.tcx));\n+    debug!(\"leak_check: skol_map={:?}\",\n+           skol_map);\n \n     let new_vars = infcx.region_vars_confined_to_snapshot(snapshot);\n     for (&skol_br, &skol) in skol_map {\n@@ -573,10 +570,10 @@ pub fn leak_check<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                 }\n             };\n \n-            debug!(\"{} (which replaced {}) is tainted by {}\",\n-                   skol.repr(infcx.tcx),\n-                   skol_br.repr(infcx.tcx),\n-                   tainted_region.repr(infcx.tcx));\n+            debug!(\"{:?} (which replaced {:?}) is tainted by {:?}\",\n+                   skol,\n+                   skol_br,\n+                   tainted_region);\n \n             // A is not as polymorphic as B:\n             return Err((skol_br, tainted_region));\n@@ -618,13 +615,13 @@ pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                              snapshot: &CombinedSnapshot,\n                              value: &T)\n                              -> T\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    where T : TypeFoldable<'tcx>\n {\n     debug_assert!(leak_check(infcx, &skol_map, snapshot).is_ok());\n \n-    debug!(\"plug_leaks(skol_map={}, value={})\",\n-           skol_map.repr(infcx.tcx),\n-           value.repr(infcx.tcx));\n+    debug!(\"plug_leaks(skol_map={:?}, value={:?})\",\n+           skol_map,\n+           value);\n \n     // Compute a mapping from the \"taint set\" of each skolemized\n     // region back to the `ty::BoundRegion` that it originally\n@@ -640,8 +637,8 @@ pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n         })\n         .collect();\n \n-    debug!(\"plug_leaks: inv_skol_map={}\",\n-           inv_skol_map.repr(infcx.tcx));\n+    debug!(\"plug_leaks: inv_skol_map={:?}\",\n+           inv_skol_map);\n \n     // Remove any instantiated type variables from `value`; those can hide\n     // references to regions from the `fold_regions` code below.\n@@ -669,8 +666,8 @@ pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n         }\n     });\n \n-    debug!(\"plug_leaks: result={}\",\n-           result.repr(infcx.tcx));\n+    debug!(\"plug_leaks: result={:?}\",\n+           result);\n \n     result\n }"}, {"sha": "7b34fda24064ef7fff78846eae32b6dc220b7230", "filename": "src/librustc/middle/infer/lattice.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -35,7 +35,6 @@ use super::InferCtxt;\n use middle::ty::TyVar;\n use middle::ty::{self, Ty};\n use middle::ty_relate::{RelateResult, TypeRelation};\n-use util::ppaux::Repr;\n \n pub trait LatticeDir<'f,'tcx> : TypeRelation<'f,'tcx> {\n     fn infcx(&self) -> &'f InferCtxt<'f, 'tcx>;\n@@ -51,10 +50,10 @@ pub fn super_lattice_tys<'a,'tcx,L:LatticeDir<'a,'tcx>>(this: &mut L,\n                                                         -> RelateResult<'tcx, Ty<'tcx>>\n     where 'tcx: 'a\n {\n-    debug!(\"{}.lattice_tys({}, {})\",\n+    debug!(\"{}.lattice_tys({:?}, {:?})\",\n            this.tag(),\n-           a.repr(this.tcx()),\n-           b.repr(this.tcx()));\n+           a,\n+           b);\n \n     if a == b {\n         return Ok(a);"}, {"sha": "9d993ead5ca20039e78c396c394866d7ec0fc416", "filename": "src/librustc/middle/infer/lub.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -16,7 +16,6 @@ use super::Subtype;\n \n use middle::ty::{self, Ty};\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n-use util::ppaux::Repr;\n \n /// \"Least upper bound\" (common supertype)\n pub struct Lub<'a, 'tcx: 'a> {\n@@ -55,10 +54,10 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Lub<'a, 'tcx> {\n     }\n \n     fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n-        debug!(\"{}.regions({}, {})\",\n+        debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()));\n+               a,\n+               b);\n \n         let origin = Subtype(self.fields.trace.clone());\n         Ok(self.fields.infcx.region_vars.lub_regions(origin, a, b))"}, {"sha": "2df335b5c3c0a89dd1ab7df0ab9f2476fb00aac4", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 31, "deletions": 167, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -36,8 +36,6 @@ use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::Span;\n use util::nodemap::FnvHashMap;\n-use util::ppaux::ty_to_string;\n-use util::ppaux::{Repr, UserString};\n \n use self::combine::CombineFields;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n@@ -161,7 +159,7 @@ pub enum ValuePairs<'tcx> {\n /// encounter an error or subtyping constraint.\n ///\n /// See `error_reporting.rs` for more details.\n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n pub struct TypeTrace<'tcx> {\n     origin: TypeOrigin,\n     values: ValuePairs<'tcx>,\n@@ -331,8 +329,8 @@ pub fn common_supertype<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                   b: Ty<'tcx>)\n                                   -> Ty<'tcx>\n {\n-    debug!(\"common_supertype({}, {})\",\n-           a.repr(cx.tcx), b.repr(cx.tcx));\n+    debug!(\"common_supertype({:?}, {:?})\",\n+           a, b);\n \n     let trace = TypeTrace {\n         origin: origin,\n@@ -356,15 +354,15 @@ pub fn mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                           b: Ty<'tcx>)\n                           -> UnitResult<'tcx>\n {\n-    debug!(\"mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n+    debug!(\"mk_subty({:?} <: {:?})\", a, b);\n     cx.sub_types(a_is_expected, origin, a, b)\n }\n \n pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                               a: Ty<'tcx>,\n                               b: Ty<'tcx>)\n                               -> UnitResult<'tcx> {\n-    debug!(\"can_mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n+    debug!(\"can_mk_subty({:?} <: {:?})\", a, b);\n     cx.probe(|_| {\n         let trace = TypeTrace {\n             origin: Misc(codemap::DUMMY_SP),\n@@ -384,7 +382,7 @@ pub fn mk_subr<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                          origin: SubregionOrigin<'tcx>,\n                          a: ty::Region,\n                          b: ty::Region) {\n-    debug!(\"mk_subr({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n+    debug!(\"mk_subr({:?} <: {:?})\", a, b);\n     let snapshot = cx.region_vars.start_snapshot();\n     cx.region_vars.make_subregion(origin, a, b);\n     cx.region_vars.commit(snapshot);\n@@ -397,7 +395,7 @@ pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                          b: Ty<'tcx>)\n                          -> UnitResult<'tcx>\n {\n-    debug!(\"mk_eqty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n+    debug!(\"mk_eqty({:?} <: {:?})\", a, b);\n     cx.commit_if_ok(|_| cx.eq_types(a_is_expected, origin, a, b))\n }\n \n@@ -408,8 +406,8 @@ pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                    b: ty::PolyTraitRef<'tcx>)\n                                    -> UnitResult<'tcx>\n {\n-    debug!(\"mk_sub_trait_refs({} <: {})\",\n-           a.repr(cx.tcx), b.repr(cx.tcx));\n+    debug!(\"mk_sub_trait_refs({:?} <: {:?})\",\n+           a, b);\n     cx.commit_if_ok(|_| cx.sub_poly_trait_refs(a_is_expected, origin, a.clone(), b.clone()))\n }\n \n@@ -638,7 +636,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                      b: Ty<'tcx>)\n                      -> UnitResult<'tcx>\n     {\n-        debug!(\"sub_types({} <: {})\", a.repr(self.tcx), b.repr(self.tcx));\n+        debug!(\"sub_types({:?} <: {:?})\", a, b);\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(origin, a_is_expected, a, b);\n             self.sub(a_is_expected, trace).relate(&a, &b).map(|_| ())\n@@ -665,9 +663,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                           b: ty::TraitRef<'tcx>)\n                           -> UnitResult<'tcx>\n     {\n-        debug!(\"sub_trait_refs({} <: {})\",\n-               a.repr(self.tcx),\n-               b.repr(self.tcx));\n+        debug!(\"sub_trait_refs({:?} <: {:?})\",\n+               a,\n+               b);\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace {\n                 origin: origin,\n@@ -684,9 +682,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                b: ty::PolyTraitRef<'tcx>)\n                                -> UnitResult<'tcx>\n     {\n-        debug!(\"sub_poly_trait_refs({} <: {})\",\n-               a.repr(self.tcx),\n-               b.repr(self.tcx));\n+        debug!(\"sub_poly_trait_refs({:?} <: {:?})\",\n+               a,\n+               b);\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace {\n                 origin: origin,\n@@ -709,7 +707,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                            value: &ty::Binder<T>,\n                                            snapshot: &CombinedSnapshot)\n                                            -> (T, SkolemizationMap)\n-        where T : TypeFoldable<'tcx> + Repr<'tcx>\n+        where T : TypeFoldable<'tcx>\n     {\n         /*! See `higher_ranked::skolemize_late_bound_regions` */\n \n@@ -734,7 +732,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                          snapshot: &CombinedSnapshot,\n                          value: &T)\n                          -> T\n-        where T : TypeFoldable<'tcx> + Repr<'tcx>\n+        where T : TypeFoldable<'tcx>\n     {\n         /*! See `higher_ranked::plug_leaks` */\n \n@@ -862,8 +860,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n-        ty_to_string(self.tcx,\n-                     self.resolve_type_vars_if_possible(&t))\n+        self.resolve_type_vars_if_possible(&t).to_string()\n     }\n \n     pub fn tys_to_string(&self, ts: &[Ty<'tcx>]) -> String {\n@@ -872,8 +869,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn trait_ref_to_string(&self, t: &ty::TraitRef<'tcx>) -> String {\n-        let t = self.resolve_type_vars_if_possible(t);\n-        t.user_string(self.tcx)\n+        self.resolve_type_vars_if_possible(t).to_string()\n     }\n \n     pub fn shallow_resolve(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n@@ -981,7 +977,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             Some(t) if ty::type_is_error(t) => (),\n             _ => {\n                 let error_str = err.map_or(\"\".to_string(), |t_err| {\n-                    format!(\" ({})\", ty::type_err_to_str(self.tcx, t_err))\n+                    format!(\" ({})\", t_err)\n                 });\n \n                 self.tcx.sess.span_err(sp, &format!(\"{}{}\",\n@@ -1035,7 +1031,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         lbrct: LateBoundRegionConversionTime,\n         value: &ty::Binder<T>)\n         -> (T, FnvHashMap<ty::BoundRegion,ty::Region>)\n-        where T : TypeFoldable<'tcx> + Repr<'tcx>\n+        where T : TypeFoldable<'tcx>\n     {\n         ty_fold::replace_late_bound_regions(\n             self.tcx,\n@@ -1049,18 +1045,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                 kind: GenericKind<'tcx>,\n                                 a: ty::Region,\n                                 bs: Vec<ty::Region>) {\n-        debug!(\"verify_generic_bound({}, {} <: {})\",\n-               kind.repr(self.tcx),\n-               a.repr(self.tcx),\n-               bs.repr(self.tcx));\n+        debug!(\"verify_generic_bound({:?}, {:?} <: {:?})\",\n+               kind,\n+               a,\n+               bs);\n \n         self.region_vars.verify_generic_bound(origin, kind, a, bs);\n     }\n \n     pub fn can_equate<'b,T>(&'b self, a: &T, b: &T) -> UnitResult<'tcx>\n-        where T: Relate<'b,'tcx> + Repr<'tcx>\n+        where T: Relate<'b,'tcx> + fmt::Debug\n     {\n-        debug!(\"can_equate({}, {})\", a.repr(self.tcx), b.repr(self.tcx));\n+        debug!(\"can_equate({:?}, {:?})\", a, b);\n         self.probe(|_| {\n             // Gin up a dummy trace, since this won't be committed\n             // anyhow. We should make this typetrace stuff more\n@@ -1101,9 +1097,9 @@ impl<'tcx> TypeTrace<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for TypeTrace<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n-        format!(\"TypeTrace({})\", self.origin.repr(tcx))\n+impl<'tcx> fmt::Debug for TypeTrace<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"TypeTrace({:?})\", self.origin)\n     }\n }\n \n@@ -1125,44 +1121,6 @@ impl TypeOrigin {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for TypeOrigin {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n-        match *self {\n-            MethodCompatCheck(a) => {\n-                format!(\"MethodCompatCheck({})\", a.repr(tcx))\n-            }\n-            ExprAssignable(a) => {\n-                format!(\"ExprAssignable({})\", a.repr(tcx))\n-            }\n-            Misc(a) => format!(\"Misc({})\", a.repr(tcx)),\n-            RelateTraitRefs(a) => {\n-                format!(\"RelateTraitRefs({})\", a.repr(tcx))\n-            }\n-            RelateSelfType(a) => {\n-                format!(\"RelateSelfType({})\", a.repr(tcx))\n-            }\n-            RelateOutputImplTypes(a) => {\n-                format!(\"RelateOutputImplTypes({})\", a.repr(tcx))\n-            }\n-            MatchExpressionArm(a, b) => {\n-                format!(\"MatchExpressionArm({}, {})\", a.repr(tcx), b.repr(tcx))\n-            }\n-            IfExpression(a) => {\n-                format!(\"IfExpression({})\", a.repr(tcx))\n-            }\n-            IfExpressionWithNoElse(a) => {\n-                format!(\"IfExpressionWithNoElse({})\", a.repr(tcx))\n-            }\n-            RangeExpression(a) => {\n-                format!(\"RangeExpression({})\", a.repr(tcx))\n-            }\n-            EquatePredicate(a) => {\n-                format!(\"EquatePredicate({})\", a.repr(tcx))\n-            }\n-        }\n-    }\n-}\n-\n impl<'tcx> SubregionOrigin<'tcx> {\n     pub fn span(&self) -> Span {\n         match *self {\n@@ -1192,70 +1150,6 @@ impl<'tcx> SubregionOrigin<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for SubregionOrigin<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        match *self {\n-            Subtype(ref a) => {\n-                format!(\"Subtype({})\", a.repr(tcx))\n-            }\n-            InfStackClosure(a) => {\n-                format!(\"InfStackClosure({})\", a.repr(tcx))\n-            }\n-            InvokeClosure(a) => {\n-                format!(\"InvokeClosure({})\", a.repr(tcx))\n-            }\n-            DerefPointer(a) => {\n-                format!(\"DerefPointer({})\", a.repr(tcx))\n-            }\n-            FreeVariable(a, b) => {\n-                format!(\"FreeVariable({}, {})\", a.repr(tcx), b)\n-            }\n-            IndexSlice(a) => {\n-                format!(\"IndexSlice({})\", a.repr(tcx))\n-            }\n-            RelateObjectBound(a) => {\n-                format!(\"RelateObjectBound({})\", a.repr(tcx))\n-            }\n-            RelateParamBound(a, b) => {\n-                format!(\"RelateParamBound({},{})\",\n-                        a.repr(tcx),\n-                        b.repr(tcx))\n-            }\n-            RelateRegionParamBound(a) => {\n-                format!(\"RelateRegionParamBound({})\",\n-                        a.repr(tcx))\n-            }\n-            RelateDefaultParamBound(a, b) => {\n-                format!(\"RelateDefaultParamBound({},{})\",\n-                        a.repr(tcx),\n-                        b.repr(tcx))\n-            }\n-            Reborrow(a) => format!(\"Reborrow({})\", a.repr(tcx)),\n-            ReborrowUpvar(a, b) => {\n-                format!(\"ReborrowUpvar({},{:?})\", a.repr(tcx), b)\n-            }\n-            ReferenceOutlivesReferent(_, a) => {\n-                format!(\"ReferenceOutlivesReferent({})\", a.repr(tcx))\n-            }\n-            ExprTypeIsNotInScope(a, b) => {\n-                format!(\"ExprTypeIsNotInScope({}, {})\",\n-                        a.repr(tcx),\n-                        b.repr(tcx))\n-            }\n-            BindingTypeIsNotValidAtDecl(a) => {\n-                format!(\"BindingTypeIsNotValidAtDecl({})\", a.repr(tcx))\n-            }\n-            CallRcvr(a) => format!(\"CallRcvr({})\", a.repr(tcx)),\n-            CallArg(a) => format!(\"CallArg({})\", a.repr(tcx)),\n-            CallReturn(a) => format!(\"CallReturn({})\", a.repr(tcx)),\n-            Operand(a) => format!(\"Operand({})\", a.repr(tcx)),\n-            AddrOf(a) => format!(\"AddrOf({})\", a.repr(tcx)),\n-            AutoBorrow(a) => format!(\"AutoBorrow({})\", a.repr(tcx)),\n-            SafeDestructor(a) => format!(\"SafeDestructor({})\", a.repr(tcx)),\n-        }\n-    }\n-}\n-\n impl RegionVariableOrigin {\n     pub fn span(&self) -> Span {\n         match *self {\n@@ -1271,33 +1165,3 @@ impl RegionVariableOrigin {\n         }\n     }\n }\n-\n-impl<'tcx> Repr<'tcx> for RegionVariableOrigin {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        match *self {\n-            MiscVariable(a) => {\n-                format!(\"MiscVariable({})\", a.repr(tcx))\n-            }\n-            PatternRegion(a) => {\n-                format!(\"PatternRegion({})\", a.repr(tcx))\n-            }\n-            AddrOfRegion(a) => {\n-                format!(\"AddrOfRegion({})\", a.repr(tcx))\n-            }\n-            Autoref(a) => format!(\"Autoref({})\", a.repr(tcx)),\n-            Coercion(a) => format!(\"Coercion({})\", a.repr(tcx)),\n-            EarlyBoundRegion(a, b) => {\n-                format!(\"EarlyBoundRegion({},{})\", a.repr(tcx), b.repr(tcx))\n-            }\n-            LateBoundRegion(a, b, c) => {\n-                format!(\"LateBoundRegion({},{},{:?})\", a.repr(tcx), b.repr(tcx), c)\n-            }\n-            BoundRegionInCoherence(a) => {\n-                format!(\"bound_regionInCoherence({})\", a.repr(tcx))\n-            }\n-            UpvarRegion(a, b) => {\n-                format!(\"UpvarRegion({}, {})\", a.repr(tcx), b.repr(tcx))\n-            }\n-        }\n-    }\n-}"}, {"sha": "869f4d011cefe18218eb3752c41f029e3cfdafc3", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -24,7 +24,6 @@ use super::Constraint;\n use middle::infer::SubregionOrigin;\n use middle::infer::region_inference::RegionVarBindings;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n-use util::ppaux::Repr;\n \n use std::borrow::Cow;\n use std::collections::hash_map::Entry::Vacant;\n@@ -191,13 +190,13 @@ impl<'a, 'tcx> dot::Labeller<'a, Node, Edge> for ConstraintGraph<'a, 'tcx> {\n             Node::RegionVid(n_vid) =>\n                 dot::LabelText::label(format!(\"{:?}\", n_vid)),\n             Node::Region(n_rgn) =>\n-                dot::LabelText::label(format!(\"{}\", n_rgn.repr(self.tcx))),\n+                dot::LabelText::label(format!(\"{:?}\", n_rgn)),\n         }\n     }\n     fn edge_label(&self, e: &Edge) -> dot::LabelText {\n         match *e {\n             Edge::Constraint(ref c) =>\n-                dot::LabelText::label(format!(\"{}\", self.map.get(c).unwrap().repr(self.tcx))),\n+                dot::LabelText::label(format!(\"{:?}\", self.map.get(c).unwrap())),\n             Edge::EnclScope(..) =>\n                 dot::LabelText::label(format!(\"(enclosed)\")),\n         }"}, {"sha": "ddd352fcb430aaefbb0098266e6eadf2665e2e1b", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 86, "deletions": 113, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -30,10 +30,10 @@ use middle::ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n use middle::ty_relate::RelateResult;\n use util::common::indenter;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n-use util::ppaux::{Repr, UserString};\n \n use std::cell::{Cell, RefCell};\n use std::cmp::Ordering::{self, Less, Greater, Equal};\n+use std::fmt;\n use std::iter::repeat;\n use std::u32;\n use syntax::ast;\n@@ -68,7 +68,7 @@ pub enum Verify<'tcx> {\n     VerifyGenericBound(GenericKind<'tcx>, SubregionOrigin<'tcx>, Region, Vec<Region>),\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq)]\n pub enum GenericKind<'tcx> {\n     Param(ty::ParamTy),\n     Projection(ty::ProjectionTy<'tcx>),\n@@ -323,8 +323,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         if self.in_snapshot() {\n             self.undo_log.borrow_mut().push(AddVar(vid));\n         }\n-        debug!(\"created new region variable {:?} with origin {}\",\n-               vid, origin.repr(self.tcx));\n+        debug!(\"created new region variable {:?} with origin {:?}\",\n+               vid, origin);\n         return vid;\n     }\n \n@@ -391,8 +391,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n-        debug!(\"RegionVarBindings: add_constraint({})\",\n-               constraint.repr(self.tcx));\n+        debug!(\"RegionVarBindings: add_constraint({:?})\",\n+               constraint);\n \n         if self.constraints.borrow_mut().insert(constraint, origin).is_none() {\n             if self.in_snapshot() {\n@@ -406,8 +406,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // cannot add verifys once regions are resolved\n         assert!(self.values_are_none());\n \n-        debug!(\"RegionVarBindings: add_verify({})\",\n-               verify.repr(self.tcx));\n+        debug!(\"RegionVarBindings: add_verify({:?})\",\n+               verify);\n \n         let mut verifys = self.verifys.borrow_mut();\n         let index = verifys.len();\n@@ -425,8 +425,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         let mut givens = self.givens.borrow_mut();\n         if givens.insert((sub, sup)) {\n-            debug!(\"add_given({} <= {:?})\",\n-                   sub.repr(self.tcx),\n+            debug!(\"add_given({:?} <= {:?})\",\n+                   sub,\n                    sup);\n \n             self.undo_log.borrow_mut().push(AddGiven(sub, sup));\n@@ -452,10 +452,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n-        debug!(\"RegionVarBindings: make_subregion({}, {}) due to {}\",\n-               sub.repr(self.tcx),\n-               sup.repr(self.tcx),\n-               origin.repr(self.tcx));\n+        debug!(\"RegionVarBindings: make_subregion({:?}, {:?}) due to {:?}\",\n+               sub,\n+               sup,\n+               origin);\n \n         match (sub, sup) {\n           (ReEarlyBound(..), ReEarlyBound(..)) => {\n@@ -471,9 +471,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n           (_, ReLateBound(..)) => {\n             self.tcx.sess.span_bug(\n                 origin.span(),\n-                &format!(\"cannot relate bound region: {} <= {}\",\n-                        sub.repr(self.tcx),\n-                        sup.repr(self.tcx)));\n+                &format!(\"cannot relate bound region: {:?} <= {:?}\",\n+                        sub,\n+                        sup));\n           }\n           (_, ReStatic) => {\n             // all regions are subregions of static, so we can ignore this\n@@ -510,9 +510,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n-        debug!(\"RegionVarBindings: lub_regions({}, {})\",\n-               a.repr(self.tcx),\n-               b.repr(self.tcx));\n+        debug!(\"RegionVarBindings: lub_regions({:?}, {:?})\",\n+               a,\n+               b);\n         match (a, b) {\n             (ReStatic, _) | (_, ReStatic) => {\n                 ReStatic // nothing lives longer than static\n@@ -535,9 +535,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n-        debug!(\"RegionVarBindings: glb_regions({}, {})\",\n-               a.repr(self.tcx),\n-               b.repr(self.tcx));\n+        debug!(\"RegionVarBindings: glb_regions({:?}, {:?})\",\n+               a,\n+               b);\n         match (a, b) {\n             (ReStatic, r) | (r, ReStatic) => {\n                 // static lives longer than everything else\n@@ -563,7 +563,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             }\n             Some(ref values) => {\n                 let r = lookup(values, rid);\n-                debug!(\"resolve_var({:?}) = {}\", rid, r.repr(self.tcx));\n+                debug!(\"resolve_var({:?}) = {:?}\", rid, r);\n                 r\n             }\n         }\n@@ -620,7 +620,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     /// made---`r0` itself will be the first entry. This is used when checking whether skolemized\n     /// regions are being improperly related to other regions.\n     pub fn tainted(&self, mark: &RegionSnapshot, r0: Region) -> Vec<Region> {\n-        debug!(\"tainted(mark={:?}, r0={})\", mark, r0.repr(self.tcx));\n+        debug!(\"tainted(mark={:?}, r0={:?})\", mark, r0);\n         let _indenter = indenter();\n \n         // `result_set` acts as a worklist: we explore all outgoing\n@@ -731,9 +731,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n           (ReEarlyBound(..), _) |\n           (_, ReEarlyBound(..)) => {\n             self.tcx.sess.bug(\n-                &format!(\"cannot relate bound region: LUB({}, {})\",\n-                        a.repr(self.tcx),\n-                        b.repr(self.tcx)));\n+                &format!(\"cannot relate bound region: LUB({:?}, {:?})\",\n+                        a,\n+                        b));\n           }\n \n           (ReStatic, _) | (_, ReStatic) => {\n@@ -836,9 +836,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             (ReEarlyBound(..), _) |\n             (_, ReEarlyBound(..)) => {\n               self.tcx.sess.bug(\n-                  &format!(\"cannot relate bound region: GLB({}, {})\",\n-                          a.repr(self.tcx),\n-                          b.repr(self.tcx)));\n+                  &format!(\"cannot relate bound region: GLB({:?}, {:?})\",\n+                          a,\n+                          b));\n             }\n \n             (ReStatic, r) | (r, ReStatic) => {\n@@ -959,7 +959,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n #[derive(Copy, Clone, PartialEq, Debug)]\n enum Classification { Expanding, Contracting }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub enum VarValue { NoValue, Value(Region), ErrorValue }\n \n struct VarData {\n@@ -1013,18 +1013,18 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn dump_constraints(&self) {\n         debug!(\"----() Start constraint listing ()----\");\n         for (idx, (constraint, _)) in self.constraints.borrow().iter().enumerate() {\n-            debug!(\"Constraint {} => {}\", idx, constraint.repr(self.tcx));\n+            debug!(\"Constraint {} => {:?}\", idx, constraint);\n         }\n     }\n \n     fn expansion(&self, free_regions: &FreeRegionMap, var_data: &mut [VarData]) {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint| {\n-            debug!(\"expansion: constraint={} origin={}\",\n-                   constraint.repr(self.tcx),\n+            debug!(\"expansion: constraint={:?} origin={:?}\",\n+                   constraint,\n                    self.constraints.borrow()\n                                    .get(constraint)\n                                    .unwrap()\n-                                   .repr(self.tcx));\n+                                   );\n             match *constraint {\n               ConstrainRegSubVar(a_region, b_vid) => {\n                 let b_data = &mut var_data[b_vid.index as usize];\n@@ -1054,10 +1054,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                    b_data: &mut VarData)\n                    -> bool\n     {\n-        debug!(\"expand_node({}, {:?} == {})\",\n-               a_region.repr(self.tcx),\n+        debug!(\"expand_node({:?}, {:?} == {:?})\",\n+               a_region,\n                b_vid,\n-               b_data.value.repr(self.tcx));\n+               b_data.value);\n \n         // Check if this relationship is implied by a given.\n         match a_region {\n@@ -1073,8 +1073,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         b_data.classification = Expanding;\n         match b_data.value {\n           NoValue => {\n-            debug!(\"Setting initial value of {:?} to {}\",\n-                   b_vid, a_region.repr(self.tcx));\n+            debug!(\"Setting initial value of {:?} to {:?}\",\n+                   b_vid, a_region);\n \n             b_data.value = Value(a_region);\n             return true;\n@@ -1086,10 +1086,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 return false;\n             }\n \n-            debug!(\"Expanding value of {:?} from {} to {}\",\n+            debug!(\"Expanding value of {:?} from {:?} to {:?}\",\n                    b_vid,\n-                   cur_region.repr(self.tcx),\n-                   lub.repr(self.tcx));\n+                   cur_region,\n+                   lub);\n \n             b_data.value = Value(lub);\n             return true;\n@@ -1105,12 +1105,12 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                    free_regions: &FreeRegionMap,\n                    var_data: &mut [VarData]) {\n         self.iterate_until_fixed_point(\"Contraction\", |constraint| {\n-            debug!(\"contraction: constraint={} origin={}\",\n-                   constraint.repr(self.tcx),\n+            debug!(\"contraction: constraint={:?} origin={:?}\",\n+                   constraint,\n                    self.constraints.borrow()\n                                    .get(constraint)\n                                    .unwrap()\n-                                   .repr(self.tcx));\n+                                   );\n             match *constraint {\n               ConstrainRegSubVar(..) => {\n                 // This is an expansion constraint.  Ignore.\n@@ -1139,9 +1139,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                      a_data: &mut VarData,\n                      b_region: Region)\n                      -> bool {\n-        debug!(\"contract_node({:?} == {}/{:?}, {})\",\n-               a_vid, a_data.value.repr(self.tcx),\n-               a_data.classification, b_region.repr(self.tcx));\n+        debug!(\"contract_node({:?} == {:?}/{:?}, {:?})\",\n+               a_vid, a_data.value,\n+               a_data.classification, b_region);\n \n         return match a_data.value {\n             NoValue => {\n@@ -1171,10 +1171,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                       -> bool\n         {\n             if !free_regions.is_subregion_of(this.tcx, a_region, b_region) {\n-                debug!(\"Setting {:?} to ErrorValue: {} not subregion of {}\",\n+                debug!(\"Setting {:?} to ErrorValue: {:?} not subregion of {:?}\",\n                        a_vid,\n-                       a_region.repr(this.tcx),\n-                       b_region.repr(this.tcx));\n+                       a_region,\n+                       b_region);\n                 a_data.value = ErrorValue;\n             }\n             false\n@@ -1192,19 +1192,19 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     if glb == a_region {\n                         false\n                     } else {\n-                        debug!(\"Contracting value of {:?} from {} to {}\",\n+                        debug!(\"Contracting value of {:?} from {:?} to {:?}\",\n                                a_vid,\n-                               a_region.repr(this.tcx),\n-                               glb.repr(this.tcx));\n+                               a_region,\n+                               glb);\n                         a_data.value = Value(glb);\n                         true\n                     }\n                 }\n                 Err(_) => {\n-                    debug!(\"Setting {:?} to ErrorValue: no glb of {}, {}\",\n+                    debug!(\"Setting {:?} to ErrorValue: no glb of {:?}, {:?}\",\n                            a_vid,\n-                           a_region.repr(this.tcx),\n-                           b_region.repr(this.tcx));\n+                           a_region,\n+                           b_region);\n                     a_data.value = ErrorValue;\n                     false\n                 }\n@@ -1229,9 +1229,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                         continue;\n                     }\n \n-                    debug!(\"ConcreteFailure: !(sub <= sup): sub={}, sup={}\",\n-                           sub.repr(self.tcx),\n-                           sup.repr(self.tcx));\n+                    debug!(\"ConcreteFailure: !(sub <= sup): sub={:?}, sup={:?}\",\n+                           sub,\n+                           sup);\n                     errors.push(ConcreteFailure((*origin).clone(), sub, sup));\n                 }\n \n@@ -1431,10 +1431,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.tcx.sess.span_bug(\n             (*self.var_origins.borrow())[node_idx.index as usize].span(),\n             &format!(\"collect_error_for_expanding_node() could not find error \\\n-                    for var {:?}, lower_bounds={}, upper_bounds={}\",\n+                    for var {:?}, lower_bounds={:?}, upper_bounds={:?}\",\n                     node_idx,\n-                    lower_bounds.repr(self.tcx),\n-                    upper_bounds.repr(self.tcx)));\n+                    lower_bounds,\n+                    upper_bounds));\n     }\n \n     fn collect_error_for_contracting_node(\n@@ -1478,9 +1478,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.tcx.sess.span_bug(\n             (*self.var_origins.borrow())[node_idx.index as usize].span(),\n             &format!(\"collect_error_for_contracting_node() could not find error \\\n-                     for var {:?}, upper_bounds={}\",\n+                     for var {:?}, upper_bounds={:?}\",\n                     node_idx,\n-                    upper_bounds.repr(self.tcx)));\n+                    upper_bounds));\n     }\n \n     fn collect_concrete_regions(&self,\n@@ -1578,8 +1578,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             for (constraint, _) in self.constraints.borrow().iter() {\n                 let edge_changed = body(constraint);\n                 if edge_changed {\n-                    debug!(\"Updated due to constraint {}\",\n-                           constraint.repr(self.tcx));\n+                    debug!(\"Updated due to constraint {:?}\",\n+                           constraint);\n                     changed = true;\n                 }\n             }\n@@ -1589,31 +1589,14 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n }\n \n-impl<'tcx> Repr<'tcx> for Constraint {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n-        match *self {\n-            ConstrainVarSubVar(a, b) => {\n-                format!(\"ConstrainVarSubVar({}, {})\", a.repr(tcx), b.repr(tcx))\n-            }\n-            ConstrainRegSubVar(a, b) => {\n-                format!(\"ConstrainRegSubVar({}, {})\", a.repr(tcx), b.repr(tcx))\n-            }\n-            ConstrainVarSubReg(a, b) => {\n-                format!(\"ConstrainVarSubReg({}, {})\", a.repr(tcx), b.repr(tcx))\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for Verify<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> fmt::Debug for Verify<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             VerifyRegSubReg(_, ref a, ref b) => {\n-                format!(\"VerifyRegSubReg({}, {})\", a.repr(tcx), b.repr(tcx))\n+                write!(f, \"VerifyRegSubReg({:?}, {:?})\", a, b)\n             }\n             VerifyGenericBound(_, ref p, ref a, ref bs) => {\n-                format!(\"VerifyGenericBound({}, {}, {})\",\n-                        p.repr(tcx), a.repr(tcx), bs.repr(tcx))\n+                write!(f, \"VerifyGenericBound({:?}, {:?}, {:?})\", p, a, bs)\n             }\n         }\n     }\n@@ -1634,38 +1617,28 @@ fn lookup(values: &Vec<VarValue>, rid: ty::RegionVid) -> ty::Region {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for VarValue {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n-        match *self {\n-            NoValue => format!(\"NoValue\"),\n-            Value(r) => format!(\"Value({})\", r.repr(tcx)),\n-            ErrorValue => format!(\"ErrorValue\"),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for RegionAndOrigin<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"RegionAndOrigin({},{})\",\n-                self.region.repr(tcx),\n-                self.origin.repr(tcx))\n+impl<'tcx> fmt::Debug for RegionAndOrigin<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"RegionAndOrigin({:?},{:?})\",\n+               self.region,\n+               self.origin)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for GenericKind<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> fmt::Debug for GenericKind<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            GenericKind::Param(ref p) => p.repr(tcx),\n-            GenericKind::Projection(ref p) => p.repr(tcx),\n+            GenericKind::Param(ref p) => write!(f, \"{:?}\", p),\n+            GenericKind::Projection(ref p) => write!(f, \"{:?}\", p),\n         }\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for GenericKind<'tcx> {\n-    fn user_string(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> fmt::Display for GenericKind<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            GenericKind::Param(ref p) => p.user_string(tcx),\n-            GenericKind::Projection(ref p) => p.user_string(tcx),\n+            GenericKind::Param(ref p) => write!(f, \"{}\", p),\n+            GenericKind::Projection(ref p) => write!(f, \"{}\", p),\n         }\n     }\n }"}, {"sha": "b67437fd12781d0c2e9791e01504e0eca95fa779", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -11,7 +11,6 @@\n use super::{InferCtxt, fixup_err, fres, unresolved_ty, unresolved_int_ty, unresolved_float_ty};\n use middle::ty::{self, Ty};\n use middle::ty_fold::{self, TypeFoldable};\n-use util::ppaux::Repr;\n \n ///////////////////////////////////////////////////////////////////////////\n // OPPORTUNISTIC TYPE RESOLVER\n@@ -95,8 +94,8 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n                 }\n                 ty::TyInfer(_) => {\n                     self.infcx.tcx.sess.bug(\n-                        &format!(\"Unexpected type in full type resolver: {}\",\n-                                t.repr(self.infcx.tcx)));\n+                        &format!(\"Unexpected type in full type resolver: {:?}\",\n+                                t));\n                 }\n                 _ => {\n                     ty_fold::super_fold_ty(self, t)"}, {"sha": "2b7f9a74b8bd5af568beb401d22f9a0445a3f751", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -16,7 +16,6 @@ use super::type_variable::{SubtypeOf, SupertypeOf};\n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n-use util::ppaux::{Repr};\n \n /// \"Greatest lower bound\" (common subtype)\n pub struct Sub<'a, 'tcx: 'a> {\n@@ -49,7 +48,7 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n     }\n \n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"{}.tys({}, {})\", self.tag(), a.repr(self.tcx()), b.repr(self.tcx()));\n+        debug!(\"{}.tys({:?}, {:?})\", self.tag(), a, b);\n \n         if a == b { return Ok(a); }\n \n@@ -85,10 +84,10 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n     }\n \n     fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n-        debug!(\"{}.regions({}, {})\",\n+        debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()));\n+               a,\n+               b);\n         let origin = Subtype(self.fields.trace.clone());\n         self.fields.infcx.region_vars.make_subregion(origin, a, b);\n         Ok(a)"}, {"sha": "c4d924d676c89ff93d8bd0999c546c9e46801a17", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -14,7 +14,8 @@ use middle::def::DefFn;\n use middle::subst::{Subst, Substs, EnumeratedItems};\n use middle::ty::{TransmuteRestriction, ctxt, TyBareFn};\n use middle::ty::{self, Ty};\n-use util::ppaux::Repr;\n+\n+use std::fmt;\n \n use syntax::abi::RustIntrinsic;\n use syntax::ast::DefId;\n@@ -202,15 +203,15 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n \n         match types_in_scope.next() {\n             None => {\n-                debug!(\"with_each_combination(substs={})\",\n-                       substs.repr(self.tcx));\n+                debug!(\"with_each_combination(substs={:?})\",\n+                       substs);\n \n                 callback(substs);\n             }\n \n             Some((space, index, &param_ty)) => {\n-                debug!(\"with_each_combination: space={:?}, index={}, param_ty={}\",\n-                       space, index, param_ty.repr(self.tcx));\n+                debug!(\"with_each_combination: space={:?}, index={}, param_ty={:?}\",\n+                       space, index, param_ty);\n \n                 if !ty::type_is_sized(Some(param_env), self.tcx, span, param_ty) {\n                     debug!(\"with_each_combination: param_ty is not known to be sized\");\n@@ -228,7 +229,7 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n     }\n \n     fn push_transmute_restriction(&self, restriction: TransmuteRestriction<'tcx>) {\n-        debug!(\"Pushing transmute restriction: {}\", restriction.repr(self.tcx));\n+        debug!(\"Pushing transmute restriction: {:?}\", restriction);\n         self.tcx.transmute_restrictions.borrow_mut().push(restriction);\n     }\n }\n@@ -277,13 +278,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for TransmuteRestriction<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"TransmuteRestriction(id={}, original=({},{}), substituted=({},{}))\",\n-                self.id,\n-                self.original_from.repr(tcx),\n-                self.original_to.repr(tcx),\n-                self.substituted_from.repr(tcx),\n-                self.substituted_to.repr(tcx))\n+impl<'tcx> fmt::Debug for TransmuteRestriction<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"TransmuteRestriction(id={}, original=({:?},{:?}), substituted=({:?},{:?}))\",\n+               self.id,\n+               self.original_from,\n+               self.original_to,\n+               self.substituted_from,\n+               self.substituted_to)\n     }\n }"}, {"sha": "ca8de74b35bda68072c5cff84a29a139bd9f977a", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 81, "deletions": 93, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -78,18 +78,16 @@ use middle::def;\n use middle::region;\n use middle::ty::{self, Ty};\n use util::nodemap::NodeMap;\n-use util::ppaux::{Repr, UserString};\n \n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::print::pprust;\n-use syntax::parse::token;\n \n use std::cell::RefCell;\n+use std::fmt;\n use std::rc::Rc;\n \n-#[derive(Clone, PartialEq, Debug)]\n+#[derive(Clone, PartialEq)]\n pub enum categorization<'tcx> {\n     cat_rvalue(ty::Region),                    // temporary val, argument is its scope\n     cat_static_item,\n@@ -103,14 +101,14 @@ pub enum categorization<'tcx> {\n }\n \n // Represents any kind of upvar\n-#[derive(Clone, Copy, PartialEq, Debug)]\n+#[derive(Clone, Copy, PartialEq)]\n pub struct Upvar {\n     pub id: ty::UpvarId,\n     pub kind: ty::ClosureKind\n }\n \n // different kinds of pointers:\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum PointerKind {\n     /// `Box<T>`\n     Unique,\n@@ -127,7 +125,7 @@ pub enum PointerKind {\n \n // We use the term \"interior\" to mean \"something reachable from the\n // base without a pointer dereference\", e.g. a field\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum InteriorKind {\n     InteriorField(FieldName),\n     InteriorElement(InteriorOffsetKind, ElementKind),\n@@ -184,7 +182,7 @@ pub enum Note {\n // dereference, but its type is the type *before* the dereference\n // (`@T`). So use `cmt.ty` to find the type of the value in a consistent\n // fashion. For more details, see the method `cat_pattern`\n-#[derive(Clone, PartialEq, Debug)]\n+#[derive(Clone, PartialEq)]\n pub struct cmt_<'tcx> {\n     pub id: ast::NodeId,           // id of expr/pat producing this value\n     pub span: Span,                // span of same expr/pat\n@@ -418,7 +416,6 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     }\n \n     fn pat_ty(&self, pat: &ast::Pat) -> McResult<Ty<'tcx>> {\n-        let tcx = self.typer.tcx();\n         let base_ty = try!(self.typer.node_ty(pat.id));\n         // FIXME (Issue #18207): This code detects whether we are\n         // looking at a `ref x`, and if so, figures out what the type\n@@ -436,8 +433,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             }\n             _ => base_ty,\n         };\n-        debug!(\"pat_ty(pat={}) base_ty={} ret_ty={}\",\n-               pat.repr(tcx), base_ty.repr(tcx), ret_ty.repr(tcx));\n+        debug!(\"pat_ty(pat={:?}) base_ty={:?} ret_ty={:?}\",\n+               pat, base_ty, ret_ty);\n         Ok(ret_ty)\n     }\n \n@@ -460,9 +457,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     ty::AdjustReifyFnPointer |\n                     ty::AdjustUnsafeFnPointer |\n                     ty::AdjustDerefRef(_) => {\n-                        debug!(\"cat_expr({}): {}\",\n-                               adjustment.repr(self.tcx()),\n-                               expr.repr(self.tcx()));\n+                        debug!(\"cat_expr({:?}): {:?}\",\n+                               adjustment,\n+                               expr);\n                         // Result is an rvalue.\n                         let expr_ty = try!(self.expr_ty_adjusted(expr));\n                         Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n@@ -477,17 +474,17 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                autoderefs: usize)\n                                -> McResult<cmt<'tcx>> {\n         let mut cmt = try!(self.cat_expr_unadjusted(expr));\n-        debug!(\"cat_expr_autoderefd: autoderefs={}, cmt={}\",\n+        debug!(\"cat_expr_autoderefd: autoderefs={}, cmt={:?}\",\n                autoderefs,\n-               cmt.repr(self.tcx()));\n+               cmt);\n         for deref in 1..autoderefs + 1 {\n             cmt = try!(self.cat_deref(expr, cmt, deref, None));\n         }\n         return Ok(cmt);\n     }\n \n     pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n-        debug!(\"cat_expr: id={} expr={}\", expr.id, expr.repr(self.tcx()));\n+        debug!(\"cat_expr: id={} expr={:?}\", expr.id, expr);\n \n         let expr_ty = try!(self.expr_ty(expr));\n         match expr.node {\n@@ -498,10 +495,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n           ast::ExprField(ref base, f_name) => {\n             let base_cmt = try!(self.cat_expr(&**base));\n-            debug!(\"cat_expr(cat_field): id={} expr={} base={}\",\n+            debug!(\"cat_expr(cat_field): id={} expr={:?} base={:?}\",\n                    expr.id,\n-                   expr.repr(self.tcx()),\n-                   base_cmt.repr(self.tcx()));\n+                   expr,\n+                   base_cmt);\n             Ok(self.cat_field(expr, base_cmt, f_name.node.name, expr_ty))\n           }\n \n@@ -524,8 +521,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     let elem_ty = match ret_ty.sty {\n                         ty::TyRef(_, mt) => mt.ty,\n                         _ => {\n-                            debug!(\"cat_expr_unadjusted: return type of overloaded index is {}?\",\n-                                   ret_ty.repr(self.tcx()));\n+                            debug!(\"cat_expr_unadjusted: return type of overloaded index is {:?}?\",\n+                                   ret_ty);\n                             return Err(());\n                         }\n                     };\n@@ -583,8 +580,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                    expr_ty: Ty<'tcx>,\n                    def: def::Def)\n                    -> McResult<cmt<'tcx>> {\n-        debug!(\"cat_def: id={} expr={} def={:?}\",\n-               id, expr_ty.repr(self.tcx()), def);\n+        debug!(\"cat_def: id={} expr={:?} def={:?}\",\n+               id, expr_ty, def);\n \n         match def {\n           def::DefStruct(..) | def::DefVariant(..) | def::DefConst(..) |\n@@ -635,9 +632,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                   _ => {\n                       self.tcx().sess.span_bug(\n                           span,\n-                          &format!(\"Upvar of non-closure {} - {}\",\n+                          &format!(\"Upvar of non-closure {} - {:?}\",\n                                   fn_node_id,\n-                                  ty.repr(self.tcx())));\n+                                  ty));\n                   }\n               }\n           }\n@@ -746,7 +743,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         };\n \n         let ret = Rc::new(cmt_result);\n-        debug!(\"cat_upvar ret={}\", ret.repr(self.tcx()));\n+        debug!(\"cat_upvar ret={:?}\", ret);\n         Ok(ret)\n     }\n \n@@ -817,7 +814,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             note: NoteClosureEnv(upvar_id)\n         };\n \n-        debug!(\"env_deref ret {}\", ret.repr(self.tcx()));\n+        debug!(\"env_deref ret {:?}\", ret);\n \n         ret\n     }\n@@ -855,7 +852,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             ty::ReStatic\n         };\n         let ret = self.cat_rvalue(id, span, re, expr_ty);\n-        debug!(\"cat_rvalue_node ret {}\", ret.repr(self.tcx()));\n+        debug!(\"cat_rvalue_node ret {:?}\", ret);\n         ret\n     }\n \n@@ -872,7 +869,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             ty:expr_ty,\n             note: NoteNone\n         });\n-        debug!(\"cat_rvalue ret {}\", ret.repr(self.tcx()));\n+        debug!(\"cat_rvalue ret {:?}\", ret);\n         ret\n     }\n \n@@ -890,7 +887,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             ty: f_ty,\n             note: NoteNone\n         });\n-        debug!(\"cat_field ret {}\", ret.repr(self.tcx()));\n+        debug!(\"cat_field ret {:?}\", ret);\n         ret\n     }\n \n@@ -908,7 +905,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             ty: f_ty,\n             note: NoteNone\n         });\n-        debug!(\"cat_tup_field ret {}\", ret.repr(self.tcx()));\n+        debug!(\"cat_tup_field ret {:?}\", ret);\n         ret\n     }\n \n@@ -925,7 +922,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let method_ty = self.typer.node_method_ty(method_call);\n \n         debug!(\"cat_deref: method_call={:?} method_ty={:?}\",\n-               method_call, method_ty.map(|ty| ty.repr(self.tcx())));\n+               method_call, method_ty.map(|ty| ty));\n \n         let base_cmt = match method_ty {\n             Some(method_ty) => {\n@@ -943,12 +940,12 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                               mt.ty,\n                                               deref_context,\n                                                 /* implicit: */ false);\n-                debug!(\"cat_deref ret {}\", ret.repr(self.tcx()));\n+                debug!(\"cat_deref ret {:?}\", ret);\n                 ret\n             }\n             None => {\n-                debug!(\"Explicit deref of non-derefable type: {}\",\n-                       base_cmt_ty.repr(self.tcx()));\n+                debug!(\"Explicit deref of non-derefable type: {:?}\",\n+                       base_cmt_ty);\n                 return Err(());\n             }\n         }\n@@ -991,7 +988,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             ty: deref_ty,\n             note: NoteNone\n         });\n-        debug!(\"cat_deref_common ret {}\", ret.repr(self.tcx()));\n+        debug!(\"cat_deref_common ret {:?}\", ret);\n         Ok(ret)\n     }\n \n@@ -1042,7 +1039,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let m = base_cmt.mutbl.inherit();\n         let ret = interior(elt, base_cmt.clone(), base_cmt.ty,\n                            m, context, element_ty);\n-        debug!(\"cat_index ret {}\", ret.repr(self.tcx()));\n+        debug!(\"cat_index ret {:?}\", ret);\n         return Ok(ret);\n \n         fn interior<'tcx, N: ast_node>(elt: &N,\n@@ -1096,7 +1093,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 base_cmt\n             }\n         };\n-        debug!(\"deref_vec ret {}\", ret.repr(self.tcx()));\n+        debug!(\"deref_vec ret {:?}\", ret);\n         Ok(ret)\n     }\n \n@@ -1155,7 +1152,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             ty: interior_ty,\n             note: NoteNone\n         });\n-        debug!(\"cat_imm_interior ret={}\", ret.repr(self.tcx()));\n+        debug!(\"cat_imm_interior ret={:?}\", ret);\n         ret\n     }\n \n@@ -1173,7 +1170,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             ty: downcast_ty,\n             note: NoteNone\n         });\n-        debug!(\"cat_downcast ret={}\", ret.repr(self.tcx()));\n+        debug!(\"cat_downcast ret={:?}\", ret);\n         ret\n     }\n \n@@ -1233,9 +1230,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         // step out of sync again. So you'll see below that we always\n         // get the type of the *subpattern* and use that.\n \n-        debug!(\"cat_pattern: id={} pat={} cmt={}\",\n-               pat.id, pprust::pat_to_string(pat),\n-               cmt.repr(self.tcx()));\n+        debug!(\"cat_pattern: {:?} cmt={:?}\",\n+               pat,\n+               cmt);\n \n         (*op)(self, cmt.clone(), pat);\n \n@@ -1521,7 +1518,7 @@ impl<'tcx> cmt_<'tcx> {\n                 let upvar = self.upvar();\n                 match upvar.as_ref().map(|i| &i.cat) {\n                     Some(&cat_upvar(ref var)) => {\n-                        var.user_string(tcx)\n+                        var.to_string()\n                     }\n                     Some(_) => unreachable!(),\n                     None => {\n@@ -1561,7 +1558,7 @@ impl<'tcx> cmt_<'tcx> {\n                 \"pattern-bound indexed content\".to_string()\n             }\n             cat_upvar(ref var) => {\n-                var.user_string(tcx)\n+                var.to_string()\n             }\n             cat_downcast(ref cmt, _) => {\n                 cmt.descriptive_string(tcx)\n@@ -1570,33 +1567,36 @@ impl<'tcx> cmt_<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for cmt_<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"{{{} id:{} m:{:?} ty:{}}}\",\n-                self.cat.repr(tcx),\n-                self.id,\n-                self.mutbl,\n-                self.ty.repr(tcx))\n+impl<'tcx> fmt::Debug for cmt_<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{{{:?} id:{} m:{:?} ty:{:?}}}\",\n+               self.cat,\n+               self.id,\n+               self.mutbl,\n+               self.ty)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for categorization<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> fmt::Debug for categorization<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            cat_static_item |\n-            cat_rvalue(..) |\n-            cat_local(..) |\n-            cat_upvar(..) => {\n-                format!(\"{:?}\", *self)\n+            cat_static_item => write!(f, \"static\"),\n+            cat_rvalue(r) => write!(f, \"rvalue({:?})\", r),\n+            cat_local(id) => {\n+               let name = ty::tls::with(|tcx| ty::local_var_name_str(tcx, id));\n+               write!(f, \"local({})\", name)\n+            }\n+            cat_upvar(upvar) => {\n+                write!(f, \"upvar({:?})\", upvar)\n             }\n             cat_deref(ref cmt, derefs, ptr) => {\n-                format!(\"{}-{}{}->\", cmt.cat.repr(tcx), ptr.repr(tcx), derefs)\n+                write!(f, \"{:?}-{:?}{}->\", cmt.cat, ptr, derefs)\n             }\n             cat_interior(ref cmt, interior) => {\n-                format!(\"{}.{}\", cmt.cat.repr(tcx), interior.repr(tcx))\n+                write!(f, \"{:?}.{:?}\", cmt.cat, interior)\n             }\n             cat_downcast(ref cmt, _) => {\n-                format!(\"{}->(enum)\", cmt.cat.repr(tcx))\n+                write!(f, \"{:?}->(enum)\", cmt.cat)\n             }\n         }\n     }\n@@ -1615,39 +1615,33 @@ pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for PointerKind {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl fmt::Debug for PointerKind {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            Unique => {\n-                format!(\"Box\")\n-            }\n+            Unique => write!(f, \"Box\"),\n             BorrowedPtr(ty::ImmBorrow, ref r) |\n             Implicit(ty::ImmBorrow, ref r) => {\n-                format!(\"&{}\", r.repr(tcx))\n+                write!(f, \"&{:?}\", r)\n             }\n             BorrowedPtr(ty::MutBorrow, ref r) |\n             Implicit(ty::MutBorrow, ref r) => {\n-                format!(\"&{} mut\", r.repr(tcx))\n+                write!(f, \"&{:?} mut\", r)\n             }\n             BorrowedPtr(ty::UniqueImmBorrow, ref r) |\n             Implicit(ty::UniqueImmBorrow, ref r) => {\n-                format!(\"&{} uniq\", r.repr(tcx))\n-            }\n-            UnsafePtr(_) => {\n-                format!(\"*\")\n+                write!(f, \"&{:?} uniq\", r)\n             }\n+            UnsafePtr(_) => write!(f, \"*\")\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for InteriorKind {\n-    fn repr(&self, _tcx: &ty::ctxt) -> String {\n+impl fmt::Debug for InteriorKind {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            InteriorField(NamedField(fld)) => {\n-                token::get_name(fld).to_string()\n-            }\n-            InteriorField(PositionalField(i)) => format!(\"#{}\", i),\n-            InteriorElement(..) => \"[]\".to_string(),\n+            InteriorField(NamedField(fld)) => write!(f, \"{}\", fld),\n+            InteriorField(PositionalField(i)) => write!(f, \"#{}\", i),\n+            InteriorElement(..) => write!(f, \"[]\"),\n         }\n     }\n }\n@@ -1664,25 +1658,19 @@ fn element_kind(t: Ty) -> ElementKind {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ClosureKind {\n-    fn repr(&self, _: &ty::ctxt) -> String {\n-        format!(\"Upvar({:?})\", self)\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for Upvar {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n-        format!(\"Upvar({})\", self.kind.repr(tcx))\n+impl fmt::Debug for Upvar {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{:?}/{:?}\", self.id, self.kind)\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for Upvar {\n-    fn user_string(&self, _: &ty::ctxt) -> String {\n+impl fmt::Display for Upvar {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let kind = match self.kind {\n             ty::FnClosureKind => \"Fn\",\n             ty::FnMutClosureKind => \"FnMut\",\n             ty::FnOnceClosureKind => \"FnOnce\",\n         };\n-        format!(\"captured outer variable in an `{}` closure\", kind)\n+        write!(f, \"captured outer variable in an `{}` closure\", kind)\n     }\n }"}, {"sha": "3f00d9ba5e98d149cd9c5d94b7bce402d533a76f", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -28,7 +28,6 @@ use syntax::attr::{Stability, AttrMetaMethods};\n use syntax::visit::{FnKind, Visitor};\n use syntax::feature_gate::emit_feature_err;\n use util::nodemap::{DefIdMap, FnvHashSet, FnvHashMap};\n-use util::ppaux::Repr;\n \n use std::mem::replace;\n \n@@ -450,7 +449,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n                     tcx.sess.span_bug(e.span,\n                                       &format!(\"stability::check_expr: struct construction \\\n                                                 of non-struct, type {:?}\",\n-                                               type_.repr(tcx)));\n+                                               type_));\n                 }\n             }\n         }\n@@ -551,7 +550,7 @@ pub fn lookup<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stability>\n }\n \n fn lookup_uncached<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stability> {\n-    debug!(\"lookup(id={})\", id.repr(tcx));\n+    debug!(\"lookup(id={:?})\", id);\n \n     // is this definition the implementation of a trait method?\n     match ty::trait_item_of_item(tcx, id) {"}, {"sha": "c3c29d0ade8dfb0e64b5403f1c902bb48111ec86", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -15,7 +15,6 @@ pub use self::RegionSubsts::*;\n \n use middle::ty::{self, Ty};\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n-use util::ppaux::Repr;\n \n use std::fmt;\n use std::iter::IntoIterator;\n@@ -29,7 +28,7 @@ use syntax::codemap::{Span, DUMMY_SP};\n /// identify each in-scope parameter by an *index* and a *parameter\n /// space* (which indices where the parameter is defined; see\n /// `ParamSpace`).\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash)]\n pub struct Substs<'tcx> {\n     pub types: VecPerParamSpace<Ty<'tcx>>,\n     pub regions: RegionSubsts,\n@@ -38,7 +37,7 @@ pub struct Substs<'tcx> {\n /// Represents the values to use when substituting lifetime parameters.\n /// If the value is `ErasedRegions`, then this subst is occurring during\n /// trans, and all region parameters will be replaced with `ty::ReStatic`.\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash)]\n pub enum RegionSubsts {\n     ErasedRegions,\n     NonerasedRegions(VecPerParamSpace<ty::Region>)\n@@ -240,13 +239,11 @@ pub struct SeparateVecsPerParamSpace<T> {\n }\n \n impl<T: fmt::Debug> fmt::Debug for VecPerParamSpace<T> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(fmt, \"VecPerParamSpace {{\"));\n-        for space in &ParamSpace::all() {\n-            try!(write!(fmt, \"{:?}: {:?}, \", *space, self.get_slice(*space)));\n-        }\n-        try!(write!(fmt, \"}}\"));\n-        Ok(())\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"[{:?};{:?};{:?}]\",\n+               self.get_slice(TypeSpace),\n+               self.get_slice(SelfSpace),\n+               self.get_slice(FnSpace))\n     }\n }\n \n@@ -620,10 +617,10 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                                 self.tcx().sess.span_bug(\n                                     span,\n                                     &format!(\"Type parameter out of range \\\n-                                              when substituting in region {} (root type={}) \\\n+                                              when substituting in region {} (root type={:?}) \\\n                                               (space={:?}, index={})\",\n-                                             data.name.as_str(),\n-                                             self.root_ty.repr(self.tcx()),\n+                                             data.name,\n+                                             self.root_ty,\n                                              data.space,\n                                              data.index));\n                             }\n@@ -675,14 +672,14 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n                 let span = self.span.unwrap_or(DUMMY_SP);\n                 self.tcx().sess.span_bug(\n                     span,\n-                    &format!(\"Type parameter `{}` ({}/{:?}/{}) out of range \\\n-                                 when substituting (root type={}) substs={}\",\n-                            p.repr(self.tcx()),\n-                            source_ty.repr(self.tcx()),\n+                    &format!(\"Type parameter `{:?}` ({:?}/{:?}/{}) out of range \\\n+                                 when substituting (root type={:?}) substs={:?}\",\n+                            p,\n+                            source_ty,\n                             p.space,\n                             p.idx,\n-                            self.root_ty.repr(self.tcx()),\n-                            self.substs.repr(self.tcx())));\n+                            self.root_ty,\n+                            self.substs));\n             }\n         };\n \n@@ -733,14 +730,14 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n     /// is that only in the second case have we passed through a fn binder.\n     fn shift_regions_through_binders(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         debug!(\"shift_regions(ty={:?}, region_binders_passed={:?}, type_has_escaping_regions={:?})\",\n-               ty.repr(self.tcx()), self.region_binders_passed, ty::type_has_escaping_regions(ty));\n+               ty, self.region_binders_passed, ty::type_has_escaping_regions(ty));\n \n         if self.region_binders_passed == 0 || !ty::type_has_escaping_regions(ty) {\n             return ty;\n         }\n \n         let result = ty_fold::shift_regions(self.tcx(), self.region_binders_passed, &ty);\n-        debug!(\"shift_regions: shifted result = {:?}\", result.repr(self.tcx()));\n+        debug!(\"shift_regions: shifted result = {:?}\", result);\n \n         result\n     }"}, {"sha": "a826836b10c62c181accd85e1c82eef74bc5b9a4", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -22,7 +22,6 @@ use middle::ty::{self, ToPolyTraitRef, Ty};\n use middle::infer::{self, InferCtxt};\n use syntax::ast;\n use syntax::codemap::{DUMMY_SP, Span};\n-use util::ppaux::Repr;\n \n #[derive(Copy, Clone)]\n struct InferIsLocal(bool);\n@@ -34,10 +33,10 @@ pub fn overlapping_impls(infcx: &InferCtxt,\n                          -> bool\n {\n     debug!(\"impl_can_satisfy(\\\n-           impl1_def_id={}, \\\n-           impl2_def_id={})\",\n-           impl1_def_id.repr(infcx.tcx),\n-           impl2_def_id.repr(infcx.tcx));\n+           impl1_def_id={:?}, \\\n+           impl2_def_id={:?})\",\n+           impl1_def_id,\n+           impl2_def_id);\n \n     let param_env = &ty::empty_parameter_environment(infcx.tcx);\n     let selcx = &mut SelectionContext::intercrate(infcx, param_env);\n@@ -53,9 +52,9 @@ fn overlap(selcx: &mut SelectionContext,\n            b_def_id: ast::DefId)\n            -> bool\n {\n-    debug!(\"overlap(a_def_id={}, b_def_id={})\",\n-           a_def_id.repr(selcx.tcx()),\n-           b_def_id.repr(selcx.tcx()));\n+    debug!(\"overlap(a_def_id={:?}, b_def_id={:?})\",\n+           a_def_id,\n+           b_def_id);\n \n     let (a_trait_ref, a_obligations) = impl_trait_ref_and_oblig(selcx,\n                                                                 a_def_id,\n@@ -65,9 +64,9 @@ fn overlap(selcx: &mut SelectionContext,\n                                                                 b_def_id,\n                                                                 util::fresh_type_vars_for_impl);\n \n-    debug!(\"overlap: a_trait_ref={}\", a_trait_ref.repr(selcx.tcx()));\n+    debug!(\"overlap: a_trait_ref={:?}\", a_trait_ref);\n \n-    debug!(\"overlap: b_trait_ref={}\", b_trait_ref.repr(selcx.tcx()));\n+    debug!(\"overlap: b_trait_ref={:?}\", b_trait_ref);\n \n     // Does `a <: b` hold? If not, no overlap.\n     if let Err(_) = infer::mk_sub_poly_trait_refs(selcx.infcx(),\n@@ -81,7 +80,6 @@ fn overlap(selcx: &mut SelectionContext,\n     debug!(\"overlap: subtraitref check succeeded\");\n \n     // Are any of the obligations unsatisfiable? If so, no overlap.\n-    let tcx = selcx.tcx();\n     let infcx = selcx.infcx();\n     let opt_failing_obligation =\n         a_obligations.iter()\n@@ -90,7 +88,7 @@ fn overlap(selcx: &mut SelectionContext,\n                      .find(|o| !selcx.evaluate_obligation(o));\n \n     if let Some(failing_obligation) = opt_failing_obligation {\n-        debug!(\"overlap: obligation unsatisfiable {}\", failing_obligation.repr(tcx));\n+        debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);\n         return false\n     }\n \n@@ -99,7 +97,7 @@ fn overlap(selcx: &mut SelectionContext,\n \n pub fn trait_ref_is_knowable<'tcx>(tcx: &ty::ctxt<'tcx>, trait_ref: &ty::TraitRef<'tcx>) -> bool\n {\n-    debug!(\"trait_ref_is_knowable(trait_ref={})\", trait_ref.repr(tcx));\n+    debug!(\"trait_ref_is_knowable(trait_ref={:?})\", trait_ref);\n \n     // if the orphan rules pass, that means that no ancestor crate can\n     // impl this, so it's up to us.\n@@ -155,7 +153,7 @@ fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n     let Normalized { value: predicates, obligations: normalization_obligations2 } =\n         project::normalize(selcx, ObligationCause::dummy(), &predicates);\n     let impl_obligations =\n-        util::predicates_for_generics(selcx.tcx(), ObligationCause::dummy(), 0, &predicates);\n+        util::predicates_for_generics(ObligationCause::dummy(), 0, &predicates);\n \n     let impl_obligations: Vec<_> =\n         impl_obligations.into_iter()\n@@ -181,17 +179,17 @@ pub fn orphan_check<'tcx>(tcx: &ty::ctxt<'tcx>,\n                           impl_def_id: ast::DefId)\n                           -> Result<(), OrphanCheckErr<'tcx>>\n {\n-    debug!(\"orphan_check({})\", impl_def_id.repr(tcx));\n+    debug!(\"orphan_check({:?})\", impl_def_id);\n \n     // We only except this routine to be invoked on implementations\n     // of a trait, not inherent implementations.\n     let trait_ref = ty::impl_trait_ref(tcx, impl_def_id).unwrap();\n-    debug!(\"orphan_check: trait_ref={}\", trait_ref.repr(tcx));\n+    debug!(\"orphan_check: trait_ref={:?}\", trait_ref);\n \n     // If the *trait* is local to the crate, ok.\n     if trait_ref.def_id.krate == ast::LOCAL_CRATE {\n-        debug!(\"trait {} is local to current crate\",\n-               trait_ref.def_id.repr(tcx));\n+        debug!(\"trait {:?} is local to current crate\",\n+               trait_ref.def_id);\n         return Ok(());\n     }\n \n@@ -203,8 +201,8 @@ fn orphan_check_trait_ref<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                 infer_is_local: InferIsLocal)\n                                 -> Result<(), OrphanCheckErr<'tcx>>\n {\n-    debug!(\"orphan_check_trait_ref(trait_ref={}, infer_is_local={})\",\n-           trait_ref.repr(tcx), infer_is_local.0);\n+    debug!(\"orphan_check_trait_ref(trait_ref={:?}, infer_is_local={})\",\n+           trait_ref, infer_is_local.0);\n \n     // First, create an ordered iterator over all the type parameters to the trait, with the self\n     // type appearing first.\n@@ -215,14 +213,14 @@ fn orphan_check_trait_ref<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // some local type.\n     for input_ty in input_tys {\n         if ty_is_local(tcx, input_ty, infer_is_local) {\n-            debug!(\"orphan_check_trait_ref: ty_is_local `{}`\", input_ty.repr(tcx));\n+            debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n \n             // First local input type. Check that there are no\n             // uncovered type parameters.\n             let uncovered_tys = uncovered_tys(tcx, input_ty, infer_is_local);\n             for uncovered_ty in uncovered_tys {\n                 if let Some(param) = uncovered_ty.walk().find(|t| is_type_parameter(t)) {\n-                    debug!(\"orphan_check_trait_ref: uncovered type `{}`\", param.repr(tcx));\n+                    debug!(\"orphan_check_trait_ref: uncovered type `{:?}`\", param);\n                     return Err(OrphanCheckErr::UncoveredTy(param));\n                 }\n             }\n@@ -235,7 +233,7 @@ fn orphan_check_trait_ref<'tcx>(tcx: &ty::ctxt<'tcx>,\n         // parameters reachable.\n         if !infer_is_local.0 {\n             if let Some(param) = input_ty.walk().find(|t| is_type_parameter(t)) {\n-                debug!(\"orphan_check_trait_ref: uncovered type `{}`\", param.repr(tcx));\n+                debug!(\"orphan_check_trait_ref: uncovered type `{:?}`\", param);\n                 return Err(OrphanCheckErr::UncoveredTy(param));\n             }\n         }\n@@ -295,7 +293,7 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                  infer_is_local: InferIsLocal)\n                                  -> bool\n {\n-    debug!(\"ty_is_local_constructor({})\", ty.repr(tcx));\n+    debug!(\"ty_is_local_constructor({:?})\", ty);\n \n     match ty.sty {\n         ty::TyBool |\n@@ -336,8 +334,8 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n         ty::TyClosure(..) |\n         ty::TyError => {\n             tcx.sess.bug(\n-                &format!(\"ty_is_local invoked on unexpected type: {}\",\n-                        ty.repr(tcx)))\n+                &format!(\"ty_is_local invoked on unexpected type: {:?}\",\n+                        ty))\n         }\n     }\n }"}, {"sha": "8618f5215290769924d31ce6813b1b6171de2b40", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -28,9 +28,9 @@ use middle::infer::InferCtxt;\n use middle::ty::{self, AsPredicate, ReferencesError, ToPolyTraitRef, TraitRef};\n use middle::ty_fold::TypeFoldable;\n use std::collections::HashMap;\n+use std::fmt;\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n-use util::ppaux::{Repr, UserString};\n \n pub fn report_fulfillment_errors<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                            errors: &Vec<FulfillmentError<'tcx>>) {\n@@ -68,8 +68,8 @@ pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     if !infcx.tcx.sess.has_errors() || !predicate.references_error() {\n         span_err!(infcx.tcx.sess, obligation.cause.span, E0271,\n                 \"type mismatch resolving `{}`: {}\",\n-                predicate.user_string(infcx.tcx),\n-                ty::type_err_to_str(infcx.tcx, &error.err));\n+                predicate,\n+                error.err);\n         note_obligation_cause(infcx, obligation);\n     }\n }\n@@ -87,16 +87,16 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                 item.meta().span\n             };\n             let def = ty::lookup_trait_def(infcx.tcx, def_id);\n-            let trait_str = def.trait_ref.user_string(infcx.tcx);\n+            let trait_str = def.trait_ref.to_string();\n             if let Some(ref istring) = item.value_str() {\n                 let mut generic_map = def.generics.types.iter_enumerated()\n                                          .map(|(param, i, gen)| {\n                                                (gen.name.as_str().to_string(),\n                                                 trait_ref.substs.types.get(param, i)\n-                                                         .user_string(infcx.tcx))\n+                                                         .to_string())\n                                               }).collect::<HashMap<String, String>>();\n                 generic_map.insert(\"Self\".to_string(),\n-                                   trait_ref.self_ty().user_string(infcx.tcx));\n+                                   trait_ref.self_ty().to_string());\n                 let parser = Parser::new(&istring);\n                 let mut errored = false;\n                 let err: String = parser.filter_map(|p| {\n@@ -157,13 +157,13 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n pub fn report_overflow_error<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                           obligation: &Obligation<'tcx, T>)\n                                           -> !\n-    where T: UserString<'tcx> + TypeFoldable<'tcx>\n+    where T: fmt::Display + TypeFoldable<'tcx>\n {\n     let predicate =\n         infcx.resolve_type_vars_if_possible(&obligation.predicate);\n     span_err!(infcx.tcx.sess, obligation.cause.span, E0275,\n               \"overflow evaluating the requirement `{}`\",\n-              predicate.user_string(infcx.tcx));\n+              predicate);\n \n     suggest_new_overflow_limit(infcx.tcx, obligation.cause.span);\n \n@@ -184,7 +184,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                     span_err!(infcx.tcx.sess, obligation.cause.span, E0276,\n                             \"the requirement `{}` appears on the impl \\\n                             method but not on the corresponding trait method\",\n-                            obligation.predicate.user_string(infcx.tcx));;\n+                            obligation.predicate);;\n                 }\n                 _ => {\n                     match obligation.predicate {\n@@ -197,8 +197,8 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                 let trait_ref = trait_predicate.to_poly_trait_ref();\n                                 span_err!(infcx.tcx.sess, obligation.cause.span, E0277,\n                                         \"the trait `{}` is not implemented for the type `{}`\",\n-                                        trait_ref.user_string(infcx.tcx),\n-                                        trait_ref.self_ty().user_string(infcx.tcx));\n+                                        trait_ref,\n+                                        trait_ref.self_ty());\n                                 // Check if it has a custom \"#[rustc_on_unimplemented]\"\n                                 // error message, report with that message if it does\n                                 let custom_note = report_on_unimplemented(infcx, &trait_ref.0,\n@@ -216,8 +216,8 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                                                &predicate).err().unwrap();\n                             span_err!(infcx.tcx.sess, obligation.cause.span, E0278,\n                                     \"the requirement `{}` is not satisfied (`{}`)\",\n-                                    predicate.user_string(infcx.tcx),\n-                                    ty::type_err_to_str(infcx.tcx, &err));\n+                                    predicate,\n+                                    err);\n                         }\n \n                         ty::Predicate::RegionOutlives(ref predicate) => {\n@@ -226,16 +226,16 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                                                       &predicate).err().unwrap();\n                             span_err!(infcx.tcx.sess, obligation.cause.span, E0279,\n                                     \"the requirement `{}` is not satisfied (`{}`)\",\n-                                    predicate.user_string(infcx.tcx),\n-                                    ty::type_err_to_str(infcx.tcx, &err));\n+                                    predicate,\n+                                    err);\n                         }\n \n                         ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n                                 let predicate =\n                                     infcx.resolve_type_vars_if_possible(&obligation.predicate);\n                                 span_err!(infcx.tcx.sess, obligation.cause.span, E0280,\n                                         \"the requirement `{}` is not satisfied\",\n-                                        predicate.user_string(infcx.tcx));\n+                                        predicate);\n                         }\n                     }\n                 }\n@@ -249,10 +249,10 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                 span_err!(infcx.tcx.sess, obligation.cause.span, E0281,\n                         \"type mismatch: the type `{}` implements the trait `{}`, \\\n                         but the trait `{}` is required ({})\",\n-                        expected_trait_ref.self_ty().user_string(infcx.tcx),\n-                        expected_trait_ref.user_string(infcx.tcx),\n-                        actual_trait_ref.user_string(infcx.tcx),\n-                        ty::type_err_to_str(infcx.tcx, e));\n+                        expected_trait_ref.self_ty(),\n+                        expected_trait_ref,\n+                        actual_trait_ref,\n+                        e);\n                     note_obligation_cause(infcx, obligation);\n             }\n         }\n@@ -282,7 +282,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         infcx.tcx.sess.span_note(\n                             obligation.cause.span,\n                             &format!(\"method `{}` has no receiver\",\n-                                    method.name.user_string(infcx.tcx)));\n+                                    method.name));\n                     }\n \n                     ObjectSafetyViolation::Method(method,\n@@ -291,15 +291,15 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             obligation.cause.span,\n                             &format!(\"method `{}` references the `Self` type \\\n                                     in its arguments or return type\",\n-                                    method.name.user_string(infcx.tcx)));\n+                                    method.name));\n                     }\n \n                     ObjectSafetyViolation::Method(method,\n                             MethodViolationCode::Generic) => {\n                         infcx.tcx.sess.span_note(\n                             obligation.cause.span,\n                             &format!(\"method `{}` has generic type parameters\",\n-                                    method.name.user_string(infcx.tcx)));\n+                                    method.name));\n                     }\n                 }\n             }\n@@ -316,9 +316,9 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n     let predicate = infcx.resolve_type_vars_if_possible(&obligation.predicate);\n \n-    debug!(\"maybe_report_ambiguity(predicate={}, obligation={})\",\n-           predicate.repr(infcx.tcx),\n-           obligation.repr(infcx.tcx));\n+    debug!(\"maybe_report_ambiguity(predicate={:?}, obligation={:?})\",\n+           predicate,\n+           obligation);\n \n     match predicate {\n         ty::Predicate::Trait(ref data) => {\n@@ -349,11 +349,11 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         span_err!(infcx.tcx.sess, obligation.cause.span, E0282,\n                                 \"unable to infer enough type information about `{}`; \\\n                                  type annotations or generic parameter binding required\",\n-                                self_ty.user_string(infcx.tcx));\n+                                self_ty);\n                     } else {\n                         span_err!(infcx.tcx.sess, obligation.cause.span, E0283,\n                                 \"type annotations required: cannot resolve `{}`\",\n-                                predicate.user_string(infcx.tcx));;\n+                                predicate);;\n                         note_obligation_cause(infcx, obligation);\n                     }\n                 }\n@@ -365,16 +365,16 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         \"coherence failed to report ambiguity: \\\n                          cannot locate the impl of the trait `{}` for \\\n                          the type `{}`\",\n-                        trait_ref.user_string(infcx.tcx),\n-                        self_ty.user_string(infcx.tcx)));\n+                        trait_ref,\n+                        self_ty));\n             }\n         }\n \n         _ => {\n             if !infcx.tcx.sess.has_errors() {\n                 span_err!(infcx.tcx.sess, obligation.cause.span, E0284,\n                         \"type annotations required: cannot resolve `{}`\",\n-                        predicate.user_string(infcx.tcx));;\n+                        predicate);;\n                 note_obligation_cause(infcx, obligation);\n             }\n         }\n@@ -383,7 +383,7 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n fn note_obligation_cause<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                       obligation: &Obligation<'tcx, T>)\n-    where T: UserString<'tcx>\n+    where T: fmt::Display\n {\n     note_obligation_cause_code(infcx,\n                                &obligation.predicate,\n@@ -395,7 +395,7 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                            predicate: &T,\n                                            cause_span: Span,\n                                            cause_code: &ObligationCauseCode<'tcx>)\n-    where T: UserString<'tcx>\n+    where T: fmt::Display\n {\n     let tcx = infcx.tcx;\n     match *cause_code {\n@@ -463,24 +463,24 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n             let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n             span_note!(tcx.sess, cause_span,\n                        \"required because it appears within the type `{}`\",\n-                       parent_trait_ref.0.self_ty().user_string(infcx.tcx));\n+                       parent_trait_ref.0.self_ty());\n             let parent_predicate = parent_trait_ref.as_predicate();\n             note_obligation_cause_code(infcx, &parent_predicate, cause_span, &*data.parent_code);\n         }\n         ObligationCauseCode::ImplDerivedObligation(ref data) => {\n             let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n             span_note!(tcx.sess, cause_span,\n                        \"required because of the requirements on the impl of `{}` for `{}`\",\n-                       parent_trait_ref.user_string(infcx.tcx),\n-                       parent_trait_ref.0.self_ty().user_string(infcx.tcx));\n+                       parent_trait_ref,\n+                       parent_trait_ref.0.self_ty());\n             let parent_predicate = parent_trait_ref.as_predicate();\n             note_obligation_cause_code(infcx, &parent_predicate, cause_span, &*data.parent_code);\n         }\n         ObligationCauseCode::CompareImplMethodObligation => {\n             span_note!(tcx.sess, cause_span,\n                       \"the requirement `{}` appears on the impl method \\\n                       but not on the corresponding trait method\",\n-                      predicate.user_string(infcx.tcx));\n+                      predicate);\n         }\n     }\n }"}, {"sha": "593a71a30fe2a11ae5dd86609b4df3e2b088d4d7", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -10,11 +10,11 @@\n \n use middle::infer::InferCtxt;\n use middle::ty::{self, RegionEscape, Ty};\n+\n use std::collections::HashSet;\n-use std::default::Default;\n+use std::fmt;\n use syntax::ast;\n use util::common::ErrorReported;\n-use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n \n use super::CodeAmbiguity;\n@@ -137,8 +137,8 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                                          cause: ObligationCause<'tcx>)\n                                          -> Ty<'tcx>\n     {\n-        debug!(\"normalize_associated_type(projection_ty={})\",\n-               projection_ty.repr(infcx.tcx));\n+        debug!(\"normalize_associated_type(projection_ty={:?})\",\n+               projection_ty);\n \n         assert!(!projection_ty.has_escaping_regions());\n \n@@ -151,7 +151,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n             self.register_predicate_obligation(infcx, obligation);\n         }\n \n-        debug!(\"normalize_associated_type: result={}\", normalized.value.repr(infcx.tcx));\n+        debug!(\"normalize_associated_type: result={:?}\", normalized.value);\n \n         normalized.value\n     }\n@@ -171,12 +171,11 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     }\n \n     pub fn register_region_obligation<'a>(&mut self,\n-                                          infcx: &InferCtxt<'a,'tcx>,\n                                           t_a: Ty<'tcx>,\n                                           r_b: ty::Region,\n                                           cause: ObligationCause<'tcx>)\n     {\n-        register_region_obligation(infcx.tcx, t_a, r_b, cause, &mut self.region_obligations);\n+        register_region_obligation(t_a, r_b, cause, &mut self.region_obligations);\n     }\n \n     pub fn register_predicate_obligation<'a>(&mut self,\n@@ -190,11 +189,11 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         assert!(!obligation.has_escaping_regions());\n \n         if self.is_duplicate_or_add(infcx.tcx, &obligation.predicate) {\n-            debug!(\"register_predicate({}) -- already seen, skip\", obligation.repr(infcx.tcx));\n+            debug!(\"register_predicate({:?}) -- already seen, skip\", obligation);\n             return;\n         }\n \n-        debug!(\"register_predicate({})\", obligation.repr(infcx.tcx));\n+        debug!(\"register_predicate({:?})\", obligation);\n         self.predicates.push(obligation);\n     }\n \n@@ -366,7 +365,6 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n      * type inference.\n      */\n \n-    let tcx = selcx.tcx();\n     match obligation.predicate {\n         ty::Predicate::Trait(ref data) => {\n             let trait_obligation = obligation.with(data.clone());\n@@ -379,9 +377,9 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                     true\n                 }\n                 Err(selection_err) => {\n-                    debug!(\"predicate: {} error: {}\",\n-                           obligation.repr(tcx),\n-                           selection_err.repr(tcx));\n+                    debug!(\"predicate: {:?} error: {:?}\",\n+                           obligation,\n+                           selection_err);\n                     errors.push(\n                         FulfillmentError::new(\n                             obligation.clone(),\n@@ -430,7 +428,7 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                         CodeSelectionError(Unimplemented)));\n             } else {\n                 let ty::OutlivesPredicate(t_a, r_b) = binder.0;\n-                register_region_obligation(tcx, t_a, r_b,\n+                register_region_obligation(t_a, r_b,\n                                            obligation.cause.clone(),\n                                            region_obligations);\n             }\n@@ -440,9 +438,9 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n         ty::Predicate::Projection(ref data) => {\n             let project_obligation = obligation.with(data.clone());\n             let result = project::poly_project_and_unify_type(selcx, &project_obligation);\n-            debug!(\"process_predicate: poly_project_and_unify_type({}) returned {}\",\n-                   project_obligation.repr(tcx),\n-                   result.repr(tcx));\n+            debug!(\"process_predicate: poly_project_and_unify_type({:?}) returned {:?}\",\n+                   project_obligation,\n+                   result);\n             match result {\n                 Ok(Some(obligations)) => {\n                     new_obligations.extend(obligations);\n@@ -463,16 +461,15 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for RegionObligation<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"RegionObligation(sub_region={}, sup_type={})\",\n-                self.sub_region.repr(tcx),\n-                self.sup_type.repr(tcx))\n+impl<'tcx> fmt::Debug for RegionObligation<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"RegionObligation(sub_region={:?}, sup_type={:?})\",\n+               self.sub_region,\n+               self.sup_type)\n     }\n }\n \n-fn register_region_obligation<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                    t_a: Ty<'tcx>,\n+fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n                                     r_b: ty::Region,\n                                     cause: ObligationCause<'tcx>,\n                                     region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n@@ -481,8 +478,8 @@ fn register_region_obligation<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                sub_region: r_b,\n                                                cause: cause };\n \n-    debug!(\"register_region_obligation({})\",\n-           region_obligation.repr(tcx));\n+    debug!(\"register_region_obligation({:?})\",\n+           region_obligation);\n \n     region_obligations.entry(region_obligation.cause.body_id).or_insert(vec![])\n         .push(region_obligation);"}, {"sha": "e3c122e2f1f59319f6dc3291c0510af5f8a50222", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -23,7 +23,6 @@ use middle::infer::{self, fixup_err_to_string, InferCtxt};\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n-use util::ppaux::Repr;\n \n pub use self::error_reporting::report_fulfillment_errors;\n pub use self::error_reporting::report_overflow_error;\n@@ -219,7 +218,7 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n /// ### The type parameter `N`\n ///\n /// See explanation on `VtableImplData`.\n-#[derive(Debug,Clone)]\n+#[derive(Clone)]\n pub enum Vtable<'tcx, N> {\n     /// Vtable identifying a particular impl.\n     VtableImpl(VtableImplData<'tcx, N>),\n@@ -277,13 +276,13 @@ pub struct VtableClosureData<'tcx, N> {\n     pub nested: Vec<N>\n }\n \n-#[derive(Debug, Clone)]\n+#[derive(Clone)]\n pub struct VtableDefaultImplData<N> {\n     pub trait_def_id: ast::DefId,\n     pub nested: Vec<N>\n }\n \n-#[derive(Debug,Clone)]\n+#[derive(Clone)]\n pub struct VtableBuiltinData<N> {\n     pub nested: Vec<N>\n }\n@@ -300,12 +299,11 @@ pub struct VtableObjectData<'tcx> {\n }\n \n /// Creates predicate obligations from the generic bounds.\n-pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                     cause: ObligationCause<'tcx>,\n+pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n                                      generic_bounds: &ty::InstantiatedPredicates<'tcx>)\n                                      -> PredicateObligations<'tcx>\n {\n-    util::predicates_for_generics(tcx, cause, 0, generic_bounds)\n+    util::predicates_for_generics(cause, 0, generic_bounds)\n }\n \n /// Determines whether the type `ty` is known to meet `bound` and\n@@ -320,8 +318,8 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                                                  span: Span)\n                                                  -> bool\n {\n-    debug!(\"type_known_to_meet_builtin_bound(ty={}, bound={:?})\",\n-           ty.repr(infcx.tcx),\n+    debug!(\"type_known_to_meet_builtin_bound(ty={:?}, bound={:?})\",\n+           ty,\n            bound);\n \n     let mut fulfill_cx = FulfillmentContext::new(false);\n@@ -338,16 +336,16 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n     // assume it is move; linear is always ok.\n     match fulfill_cx.select_all_or_error(infcx, typer) {\n         Ok(()) => {\n-            debug!(\"type_known_to_meet_builtin_bound: ty={} bound={:?} success\",\n-                   ty.repr(infcx.tcx),\n+            debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} success\",\n+                   ty,\n                    bound);\n             true\n         }\n         Err(e) => {\n-            debug!(\"type_known_to_meet_builtin_bound: ty={} bound={:?} errors={}\",\n-                   ty.repr(infcx.tcx),\n+            debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} errors={:?}\",\n+                   ty,\n                    bound,\n-                   e.repr(infcx.tcx));\n+                   e);\n             false\n         }\n     }\n@@ -377,8 +375,8 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n     let span = cause.span;\n     let body_id = cause.body_id;\n \n-    debug!(\"normalize_param_env_or_error(unnormalized_env={})\",\n-           unnormalized_env.repr(tcx));\n+    debug!(\"normalize_param_env_or_error(unnormalized_env={:?})\",\n+           unnormalized_env);\n \n     let predicates: Vec<_> =\n         util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.clone())\n@@ -393,8 +391,8 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n     // constructed, but I am not currently doing so out of laziness.\n     // -nmatsakis\n \n-    debug!(\"normalize_param_env_or_error: elaborated-predicates={}\",\n-           predicates.repr(tcx));\n+    debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\",\n+           predicates);\n \n     let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n \n@@ -434,25 +432,23 @@ pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                   cause: ObligationCause<'tcx>,\n                                   value: &T)\n                                   -> Result<T, Vec<FulfillmentError<'tcx>>>\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr<'tcx>\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes\n {\n-    let tcx = closure_typer.tcx();\n-\n-    debug!(\"normalize_param_env(value={})\", value.repr(tcx));\n+    debug!(\"normalize_param_env(value={:?})\", value);\n \n     let mut selcx = &mut SelectionContext::new(infcx, closure_typer);\n     let mut fulfill_cx = FulfillmentContext::new(false);\n     let Normalized { value: normalized_value, obligations } =\n         project::normalize(selcx, cause, value);\n-    debug!(\"normalize_param_env: normalized_value={} obligations={}\",\n-           normalized_value.repr(tcx),\n-           obligations.repr(tcx));\n+    debug!(\"normalize_param_env: normalized_value={:?} obligations={:?}\",\n+           normalized_value,\n+           obligations);\n     for obligation in obligations {\n         fulfill_cx.register_predicate_obligation(selcx.infcx(), obligation);\n     }\n     try!(fulfill_cx.select_all_or_error(infcx, closure_typer));\n     let resolved_value = infcx.resolve_type_vars_if_possible(&normalized_value);\n-    debug!(\"normalize_param_env: resolved_value={}\", resolved_value.repr(tcx));\n+    debug!(\"normalize_param_env: resolved_value={:?}\", resolved_value);\n     Ok(resolved_value)\n }\n "}, {"sha": "afb30716c36697b50955d1f5fcb4ec0f4c0fa07c", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -25,8 +25,8 @@ use middle::traits;\n use middle::ty::{self, ToPolyTraitRef, Ty};\n use std::rc::Rc;\n use syntax::ast;\n-use util::ppaux::Repr;\n \n+#[derive(Debug)]\n pub enum ObjectSafetyViolation<'tcx> {\n     /// Self : Sized declared on the trait\n     SizedSelf,\n@@ -70,7 +70,7 @@ pub fn is_object_safe<'tcx>(tcx: &ty::ctxt<'tcx>,\n         result\n     });\n \n-    debug!(\"is_object_safe({}) = {}\", trait_def_id.repr(tcx), result);\n+    debug!(\"is_object_safe({:?}) = {}\", trait_def_id, result);\n \n     result\n }\n@@ -111,9 +111,9 @@ fn object_safety_violations_for_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n         violations.push(ObjectSafetyViolation::SupertraitSelf);\n     }\n \n-    debug!(\"object_safety_violations_for_trait(trait_def_id={}) = {}\",\n-           trait_def_id.repr(tcx),\n-           violations.repr(tcx));\n+    debug!(\"object_safety_violations_for_trait(trait_def_id={:?}) = {:?}\",\n+           trait_def_id,\n+           violations);\n \n     violations\n }\n@@ -352,19 +352,6 @@ fn contains_illegal_self_type_reference<'tcx>(tcx: &ty::ctxt<'tcx>,\n     error\n }\n \n-impl<'tcx> Repr<'tcx> for ObjectSafetyViolation<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        match *self {\n-            ObjectSafetyViolation::SizedSelf =>\n-                format!(\"SizedSelf\"),\n-            ObjectSafetyViolation::SupertraitSelf =>\n-                format!(\"SupertraitSelf\"),\n-            ObjectSafetyViolation::Method(ref m, code) =>\n-                format!(\"Method({},{:?})\", m.repr(tcx), code),\n-        }\n-    }\n-}\n-\n fn is_self<'tcx>(ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         ty::TyParam(ref data) => data.space == subst::SelfSpace,"}, {"sha": "3ac58dafa4a7a25807825eb90ad3e5784cd772d5", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 63, "deletions": 92, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -28,7 +28,8 @@ use middle::ty::{self, AsPredicate, ReferencesError, RegionEscape,\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n use syntax::parse::token;\n use util::common::FN_OUTPUT_NAME;\n-use util::ppaux::Repr;\n+\n+use std::fmt;\n \n pub type PolyProjectionObligation<'tcx> =\n     Obligation<'tcx, ty::PolyProjectionPredicate<'tcx>>;\n@@ -40,6 +41,7 @@ pub type ProjectionTyObligation<'tcx> =\n     Obligation<'tcx, ty::ProjectionTy<'tcx>>;\n \n /// When attempting to resolve `<T as TraitRef>::Name` ...\n+#[derive(Debug)]\n pub enum ProjectionTyError<'tcx> {\n     /// ...we found multiple sources of information and couldn't resolve the ambiguity.\n     TooManyCandidates,\n@@ -53,7 +55,7 @@ pub struct MismatchedProjectionTypes<'tcx> {\n     pub err: ty::type_err<'tcx>\n }\n \n-#[derive(PartialEq, Eq)]\n+#[derive(PartialEq, Eq, Debug)]\n enum ProjectionTyCandidate<'tcx> {\n     ParamEnv(ty::PolyProjectionPredicate<'tcx>),\n     Impl(VtableImplData<'tcx, PredicateObligation<'tcx>>),\n@@ -76,8 +78,8 @@ pub fn poly_project_and_unify_type<'cx,'tcx>(\n     obligation: &PolyProjectionObligation<'tcx>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>>\n {\n-    debug!(\"poly_project_and_unify_type(obligation={})\",\n-           obligation.repr(selcx.tcx()));\n+    debug!(\"poly_project_and_unify_type(obligation={:?})\",\n+           obligation);\n \n     let infcx = selcx.infcx();\n     infcx.commit_if_ok(|snapshot| {\n@@ -109,8 +111,8 @@ fn project_and_unify_type<'cx,'tcx>(\n     obligation: &ProjectionObligation<'tcx>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>>\n {\n-    debug!(\"project_and_unify_type(obligation={})\",\n-           obligation.repr(selcx.tcx()));\n+    debug!(\"project_and_unify_type(obligation={:?})\",\n+           obligation);\n \n     let Normalized { value: normalized_ty, obligations } =\n         match opt_normalize_projection_type(selcx,\n@@ -124,9 +126,9 @@ fn project_and_unify_type<'cx,'tcx>(\n             }\n         };\n \n-    debug!(\"project_and_unify_type: normalized_ty={} obligations={}\",\n-           normalized_ty.repr(selcx.tcx()),\n-           obligations.repr(selcx.tcx()));\n+    debug!(\"project_and_unify_type: normalized_ty={:?} obligations={:?}\",\n+           normalized_ty,\n+           obligations);\n \n     let infcx = selcx.infcx();\n     let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n@@ -138,8 +140,8 @@ fn project_and_unify_type<'cx,'tcx>(\n \n fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext<'cx,'tcx>,\n                                                     obligation: &ProjectionObligation<'tcx>) {\n-    debug!(\"consider_unification_despite_ambiguity(obligation={})\",\n-           obligation.repr(selcx.tcx()));\n+    debug!(\"consider_unification_despite_ambiguity(obligation={:?})\",\n+           obligation);\n \n     let def_id = obligation.predicate.projection_ty.trait_ref.def_id;\n     match selcx.tcx().lang_items.fn_trait_kind(def_id) {\n@@ -173,7 +175,7 @@ fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext\n                     &ty::Binder(ret_type));\n \n             debug!(\"consider_unification_despite_ambiguity: ret_type={:?}\",\n-                   ret_type.repr(selcx.tcx()));\n+                   ret_type);\n             let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n             let obligation_ty = obligation.predicate.ty;\n             match infer::mk_eqty(infcx, true, origin, obligation_ty, ret_type) {\n@@ -193,7 +195,7 @@ pub fn normalize<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n                                cause: ObligationCause<'tcx>,\n                                value: &T)\n                                -> Normalized<'tcx, T>\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr<'tcx>\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes\n {\n     normalize_with_depth(selcx, cause, 0, value)\n }\n@@ -204,7 +206,7 @@ pub fn normalize_with_depth<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tc\n                                           depth: usize,\n                                           value: &T)\n                                           -> Normalized<'tcx, T>\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr<'tcx>\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes\n {\n     let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth);\n     let result = normalizer.fold(value);\n@@ -236,7 +238,7 @@ impl<'a,'b,'tcx> AssociatedTypeNormalizer<'a,'b,'tcx> {\n         }\n     }\n \n-    fn fold<T:TypeFoldable<'tcx> + HasProjectionTypes + Clone>(&mut self, value: &T) -> T {\n+    fn fold<T:TypeFoldable<'tcx> + HasProjectionTypes>(&mut self, value: &T) -> T {\n         let value = self.selcx.infcx().resolve_type_vars_if_possible(value);\n \n         if !value.has_projection_types() {\n@@ -354,9 +356,9 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n     -> Option<NormalizedTy<'tcx>>\n {\n     debug!(\"normalize_projection_type(\\\n-           projection_ty={}, \\\n+           projection_ty={:?}, \\\n            depth={})\",\n-           projection_ty.repr(selcx.tcx()),\n+           projection_ty,\n            depth);\n \n     let obligation = Obligation::with_depth(cause.clone(), depth, projection_ty.clone());\n@@ -367,18 +369,17 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n             // an impl, where-clause etc) and hence we must\n             // re-normalize it\n \n-            debug!(\"normalize_projection_type: projected_ty={} depth={} obligations={}\",\n-                   projected_ty.repr(selcx.tcx()),\n+            debug!(\"normalize_projection_type: projected_ty={:?} depth={} obligations={:?}\",\n+                   projected_ty,\n                    depth,\n-                   obligations.repr(selcx.tcx()));\n+                   obligations);\n \n             if ty::type_has_projection(projected_ty) {\n-                let tcx = selcx.tcx();\n                 let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth);\n                 let normalized_ty = normalizer.fold(&projected_ty);\n \n-                debug!(\"normalize_projection_type: normalized_ty={} depth={}\",\n-                       normalized_ty.repr(tcx),\n+                debug!(\"normalize_projection_type: normalized_ty={:?} depth={}\",\n+                       normalized_ty,\n                        depth);\n \n                 obligations.extend(normalizer.obligations);\n@@ -394,8 +395,8 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n             }\n         }\n         Ok(ProjectedTy::NoProgress(projected_ty)) => {\n-            debug!(\"normalize_projection_type: projected_ty={} no progress\",\n-                   projected_ty.repr(selcx.tcx()));\n+            debug!(\"normalize_projection_type: projected_ty={:?} no progress\",\n+                   projected_ty);\n             Some(Normalized {\n                 value: projected_ty,\n                 obligations: vec!()\n@@ -449,8 +450,8 @@ fn project_type<'cx,'tcx>(\n     obligation: &ProjectionTyObligation<'tcx>)\n     -> Result<ProjectedTy<'tcx>, ProjectionTyError<'tcx>>\n {\n-    debug!(\"project(obligation={})\",\n-           obligation.repr(selcx.tcx()));\n+    debug!(\"project(obligation={:?})\",\n+           obligation);\n \n     let recursion_limit = selcx.tcx().sess.recursion_limit.get();\n     if obligation.recursion_depth >= recursion_limit {\n@@ -461,7 +462,7 @@ fn project_type<'cx,'tcx>(\n     let obligation_trait_ref =\n         selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate.trait_ref);\n \n-    debug!(\"project: obligation_trait_ref={}\", obligation_trait_ref.repr(selcx.tcx()));\n+    debug!(\"project: obligation_trait_ref={:?}\", obligation_trait_ref);\n \n     if obligation_trait_ref.references_error() {\n         return Ok(ProjectedTy::Progress(selcx.tcx().types.err, vec!()));\n@@ -589,12 +590,12 @@ fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n     env_predicates: I)\n     where I: Iterator<Item=ty::Predicate<'tcx>>\n {\n-    debug!(\"assemble_candidates_from_predicates(obligation={})\",\n-           obligation.repr(selcx.tcx()));\n+    debug!(\"assemble_candidates_from_predicates(obligation={:?})\",\n+           obligation);\n     let infcx = selcx.infcx();\n     for predicate in env_predicates {\n-        debug!(\"assemble_candidates_from_predicates: predicate={}\",\n-               predicate.repr(selcx.tcx()));\n+        debug!(\"assemble_candidates_from_predicates: predicate={:?}\",\n+               predicate);\n         match predicate {\n             ty::Predicate::Projection(ref data) => {\n                 let same_name = data.item_name() == obligation.predicate.item_name;\n@@ -611,10 +612,9 @@ fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n                                               obligation_poly_trait_ref).is_ok()\n                 });\n \n-                debug!(\"assemble_candidates_from_predicates: candidate {} is_match {} same_name {}\",\n-                       data.repr(selcx.tcx()),\n-                       is_match,\n-                       same_name);\n+                debug!(\"assemble_candidates_from_predicates: candidate={:?} \\\n+                                                             is_match={} same_name={}\",\n+                       data, is_match, same_name);\n \n                 if is_match {\n                     candidate_set.vec.push(\n@@ -633,16 +633,15 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n     object_ty: Ty<'tcx>)\n {\n-    let infcx = selcx.infcx();\n-    debug!(\"assemble_candidates_from_object_type(object_ty={})\",\n-           object_ty.repr(infcx.tcx));\n+    debug!(\"assemble_candidates_from_object_type(object_ty={:?})\",\n+           object_ty);\n     let data = match object_ty.sty {\n         ty::TyTrait(ref data) => data,\n         _ => {\n             selcx.tcx().sess.span_bug(\n                 obligation.cause.span,\n-                &format!(\"assemble_candidates_from_object_type called with non-object: {}\",\n-                         object_ty.repr(selcx.tcx())));\n+                &format!(\"assemble_candidates_from_object_type called with non-object: {:?}\",\n+                         object_ty));\n         }\n     };\n     let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), object_ty);\n@@ -672,16 +671,16 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n             return Ok(());\n         }\n         Err(e) => {\n-            debug!(\"assemble_candidates_from_impls: selection error {}\",\n-                   e.repr(selcx.tcx()));\n+            debug!(\"assemble_candidates_from_impls: selection error {:?}\",\n+                   e);\n             return Err(e);\n         }\n     };\n \n     match vtable {\n         super::VtableImpl(data) => {\n-            debug!(\"assemble_candidates_from_impls: impl candidate {}\",\n-                   data.repr(selcx.tcx()));\n+            debug!(\"assemble_candidates_from_impls: impl candidate {:?}\",\n+                   data);\n \n             candidate_set.vec.push(\n                 ProjectionTyCandidate::Impl(data));\n@@ -731,8 +730,8 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n             // These traits have no associated types.\n             selcx.tcx().sess.span_bug(\n                 obligation.cause.span,\n-                &format!(\"Cannot project an associated type from `{}`\",\n-                         vtable.repr(selcx.tcx())));\n+                &format!(\"Cannot project an associated type from `{:?}`\",\n+                         vtable));\n         }\n     }\n \n@@ -745,11 +744,9 @@ fn confirm_candidate<'cx,'tcx>(\n     candidate: ProjectionTyCandidate<'tcx>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n {\n-    let infcx = selcx.infcx();\n-\n-    debug!(\"confirm_candidate(candidate={}, obligation={})\",\n-           candidate.repr(infcx.tcx),\n-           obligation.repr(infcx.tcx));\n+    debug!(\"confirm_candidate(candidate={:?}, obligation={:?})\",\n+           candidate,\n+           obligation);\n \n     match candidate {\n         ProjectionTyCandidate::ParamEnv(poly_projection) => {\n@@ -813,9 +810,9 @@ fn confirm_callable_candidate<'cx,'tcx>(\n {\n     let tcx = selcx.tcx();\n \n-    debug!(\"confirm_callable_candidate({},{})\",\n-           obligation.repr(tcx),\n-           fn_sig.repr(tcx));\n+    debug!(\"confirm_callable_candidate({:?},{:?})\",\n+           obligation,\n+           fn_sig);\n \n     // the `Output` associated type is declared on `FnOnce`\n     let fn_once_def_id = tcx.lang_items.fn_once_trait().unwrap();\n@@ -865,10 +862,10 @@ fn confirm_param_env_candidate<'cx,'tcx>(\n         Err(e) => {\n             selcx.tcx().sess.span_bug(\n                 obligation.cause.span,\n-                &format!(\"Failed to unify `{}` and `{}` in projection: {}\",\n-                         obligation.repr(selcx.tcx()),\n-                         projection.repr(selcx.tcx()),\n-                         ty::type_err_to_str(selcx.tcx(), &e)));\n+                &format!(\"Failed to unify `{:?}` and `{:?}` in projection: {}\",\n+                         obligation,\n+                         projection,\n+                         e));\n         }\n     }\n \n@@ -915,34 +912,8 @@ fn confirm_impl_candidate<'cx,'tcx>(\n     }\n \n     selcx.tcx().sess.span_bug(obligation.cause.span,\n-                              &format!(\"No associated type for {}\",\n-                                       trait_ref.repr(selcx.tcx())));\n-}\n-\n-impl<'tcx> Repr<'tcx> for ProjectionTyError<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        match *self {\n-            ProjectionTyError::TooManyCandidates =>\n-                format!(\"NoCandidate\"),\n-            ProjectionTyError::TraitSelectionError(ref e) =>\n-                format!(\"TraitSelectionError({})\", e.repr(tcx)),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ProjectionTyCandidate<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        match *self {\n-            ProjectionTyCandidate::ParamEnv(ref data) =>\n-                format!(\"ParamEnv({})\", data.repr(tcx)),\n-            ProjectionTyCandidate::Impl(ref data) =>\n-                format!(\"Impl({})\", data.repr(tcx)),\n-            ProjectionTyCandidate::Closure(ref data) =>\n-                format!(\"Closure({})\", data.repr(tcx)),\n-            ProjectionTyCandidate::FnPointer(a) =>\n-                format!(\"FnPointer(({}))\", a.repr(tcx)),\n-        }\n-    }\n+                              &format!(\"No associated type for {:?}\",\n+                                       trait_ref));\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n@@ -954,10 +925,10 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n     }\n }\n \n-impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Normalized<'tcx, T> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"Normalized({},{})\",\n-                self.value.repr(tcx),\n-                self.obligations.repr(tcx))\n+impl<'tcx, T:fmt::Debug> fmt::Debug for Normalized<'tcx, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Normalized({:?},{:?})\",\n+               self.value,\n+               self.obligations)\n     }\n }"}, {"sha": "1653cac68e6e05a435c0fb6bd93b7d6a1e1eddb3", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 149, "deletions": 174, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -44,12 +44,13 @@ use middle::infer::{InferCtxt, TypeFreshener};\n use middle::ty_fold::TypeFoldable;\n use middle::ty_match;\n use middle::ty_relate::TypeRelation;\n+\n use std::cell::RefCell;\n+use std::fmt;\n use std::rc::Rc;\n use syntax::{abi, ast};\n use util::common::ErrorReported;\n use util::nodemap::FnvHashMap;\n-use util::ppaux::Repr;\n \n pub struct SelectionContext<'cx, 'tcx:'cx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n@@ -298,7 +299,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// type environment by performing unification.\n     pub fn select(&mut self, obligation: &TraitObligation<'tcx>)\n                   -> SelectionResult<'tcx, Selection<'tcx>> {\n-        debug!(\"select({})\", obligation.repr(self.tcx()));\n+        debug!(\"select({:?})\", obligation);\n         assert!(!obligation.predicate.has_escaping_regions());\n \n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n@@ -387,8 +388,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                obligation: &PredicateObligation<'tcx>)\n                                -> bool\n     {\n-        debug!(\"evaluate_obligation({})\",\n-               obligation.repr(self.tcx()));\n+        debug!(\"evaluate_obligation({:?})\",\n+               obligation);\n \n         self.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n             .may_apply()\n@@ -440,8 +441,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                           obligation: &PredicateObligation<'tcx>)\n                                            -> EvaluationResult<'tcx>\n     {\n-        debug!(\"evaluate_predicate_recursively({})\",\n-               obligation.repr(self.tcx()));\n+        debug!(\"evaluate_predicate_recursively({:?})\",\n+               obligation);\n \n         // Check the cache from the tcx of predicates that we know\n         // have been proven elsewhere. This cache only contains\n@@ -499,8 +500,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                            obligation: &TraitObligation<'tcx>)\n                                            -> EvaluationResult<'tcx>\n     {\n-        debug!(\"evaluate_obligation_recursively({})\",\n-               obligation.repr(self.tcx()));\n+        debug!(\"evaluate_obligation_recursively({:?})\",\n+               obligation);\n \n         let stack = self.push_stack(previous_stack, obligation);\n \n@@ -547,8 +548,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                   |prev| self.match_fresh_trait_refs(&stack.fresh_trait_ref,\n                                                      &prev.fresh_trait_ref)))\n         {\n-            debug!(\"evaluate_stack({}) --> unbound argument, recursion -->  ambiguous\",\n-                   stack.fresh_trait_ref.repr(self.tcx()));\n+            debug!(\"evaluate_stack({:?}) --> unbound argument, recursion -->  ambiguous\",\n+                   stack.fresh_trait_ref);\n             return EvaluatedToAmbig;\n         }\n \n@@ -576,8 +577,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .skip(1) // skip top-most frame\n             .any(|prev| stack.fresh_trait_ref == prev.fresh_trait_ref)\n         {\n-            debug!(\"evaluate_stack({}) --> recursive\",\n-                   stack.fresh_trait_ref.repr(self.tcx()));\n+            debug!(\"evaluate_stack({:?}) --> recursive\",\n+                   stack.fresh_trait_ref);\n             return EvaluatedToOk;\n         }\n \n@@ -595,9 +596,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                          obligation: &TraitObligation<'tcx>)\n                          -> bool\n     {\n-        debug!(\"evaluate_impl(impl_def_id={}, obligation={})\",\n-               impl_def_id.repr(self.tcx()),\n-               obligation.repr(self.tcx()));\n+        debug!(\"evaluate_impl(impl_def_id={:?}, obligation={:?})\",\n+               impl_def_id,\n+               obligation);\n \n         self.infcx.probe(|snapshot| {\n             match self.match_impl(impl_def_id, obligation, snapshot) {\n@@ -643,16 +644,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // with fresh skolemized types starting from index 0.\n         let cache_fresh_trait_pred =\n             self.infcx.freshen(stack.obligation.predicate.clone());\n-        debug!(\"candidate_from_obligation(cache_fresh_trait_pred={}, obligation={})\",\n-               cache_fresh_trait_pred.repr(self.tcx()),\n-               stack.repr(self.tcx()));\n+        debug!(\"candidate_from_obligation(cache_fresh_trait_pred={:?}, obligation={:?})\",\n+               cache_fresh_trait_pred,\n+               stack);\n         assert!(!stack.obligation.predicate.has_escaping_regions());\n \n         match self.check_candidate_cache(&cache_fresh_trait_pred) {\n             Some(c) => {\n-                debug!(\"CACHE HIT: cache_fresh_trait_pred={}, candidate={}\",\n-                       cache_fresh_trait_pred.repr(self.tcx()),\n-                       c.repr(self.tcx()));\n+                debug!(\"CACHE HIT: cache_fresh_trait_pred={:?}, candidate={:?}\",\n+                       cache_fresh_trait_pred,\n+                       c);\n                 return c;\n             }\n             None => { }\n@@ -662,8 +663,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let candidate = self.candidate_from_obligation_no_cache(stack);\n \n         if self.should_update_candidate_cache(&cache_fresh_trait_pred, &candidate) {\n-            debug!(\"CACHE MISS: cache_fresh_trait_pred={}, candidate={}\",\n-                   cache_fresh_trait_pred.repr(self.tcx()), candidate.repr(self.tcx()));\n+            debug!(\"CACHE MISS: cache_fresh_trait_pred={:?}, candidate={:?}\",\n+                   cache_fresh_trait_pred, candidate);\n             self.insert_candidate_cache(cache_fresh_trait_pred, candidate.clone());\n         }\n \n@@ -692,10 +693,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let mut candidates = candidate_set.vec;\n \n-        debug!(\"assembled {} candidates for {}: {}\",\n+        debug!(\"assembled {} candidates for {:?}: {:?}\",\n                candidates.len(),\n-               stack.repr(self.tcx()),\n-               candidates.repr(self.tcx()));\n+               stack,\n+               candidates);\n \n         // At this point, we know that each of the entries in the\n         // candidate set is *individually* applicable. Now we have to\n@@ -735,12 +736,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     .any(|j| self.candidate_should_be_dropped_in_favor_of(&candidates[i],\n                                                                           &candidates[j]));\n                 if is_dup {\n-                    debug!(\"Dropping candidate #{}/{}: {}\",\n-                           i, candidates.len(), candidates[i].repr(self.tcx()));\n+                    debug!(\"Dropping candidate #{}/{}: {:?}\",\n+                           i, candidates.len(), candidates[i]);\n                     candidates.swap_remove(i);\n                 } else {\n-                    debug!(\"Retaining candidate #{}/{}: {}\",\n-                           i, candidates.len(), candidates[i].repr(self.tcx()));\n+                    debug!(\"Retaining candidate #{}/{}: {:?}\",\n+                           i, candidates.len(), candidates[i]);\n                     i += 1;\n                 }\n             }\n@@ -906,8 +907,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         match self.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n             Some(ty::BoundCopy) => {\n-                debug!(\"obligation self ty is {}\",\n-                       obligation.predicate.0.self_ty().repr(self.tcx()));\n+                debug!(\"obligation self ty is {:?}\",\n+                       obligation.predicate.0.self_ty());\n \n                 // User-defined copy impls are permitted, but only for\n                 // structs and enums.\n@@ -957,9 +958,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let poly_trait_predicate =\n             self.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n \n-        debug!(\"assemble_candidates_for_projected_tys({},{})\",\n-               obligation.repr(self.tcx()),\n-               poly_trait_predicate.repr(self.tcx()));\n+        debug!(\"assemble_candidates_for_projected_tys({:?},{:?})\",\n+               obligation,\n+               poly_trait_predicate);\n \n         // FIXME(#20297) -- just examining the self-type is very simplistic\n \n@@ -981,8 +982,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => { return; }\n         };\n \n-        debug!(\"assemble_candidates_for_projected_tys: trait_def_id={}\",\n-               trait_def_id.repr(self.tcx()));\n+        debug!(\"assemble_candidates_for_projected_tys: trait_def_id={:?}\",\n+               trait_def_id);\n \n         let result = self.infcx.probe(|snapshot| {\n             self.match_projection_obligation_against_bounds_from_trait(obligation,\n@@ -1005,29 +1006,29 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let (skol_trait_predicate, skol_map) =\n             self.infcx().skolemize_late_bound_regions(&poly_trait_predicate, snapshot);\n         debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n-                skol_trait_predicate={} skol_map={}\",\n-               skol_trait_predicate.repr(self.tcx()),\n-               skol_map.repr(self.tcx()));\n+                skol_trait_predicate={:?} skol_map={:?}\",\n+               skol_trait_predicate,\n+               skol_map);\n \n         let projection_trait_ref = match skol_trait_predicate.trait_ref.self_ty().sty {\n             ty::TyProjection(ref data) => &data.trait_ref,\n             _ => {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n                     &format!(\"match_projection_obligation_against_bounds_from_trait() called \\\n-                              but self-ty not a projection: {}\",\n-                             skol_trait_predicate.trait_ref.self_ty().repr(self.tcx())));\n+                              but self-ty not a projection: {:?}\",\n+                             skol_trait_predicate.trait_ref.self_ty()));\n             }\n         };\n         debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n-                projection_trait_ref={}\",\n-               projection_trait_ref.repr(self.tcx()));\n+                projection_trait_ref={:?}\",\n+               projection_trait_ref);\n \n         let trait_predicates = ty::lookup_predicates(self.tcx(), projection_trait_ref.def_id);\n         let bounds = trait_predicates.instantiate(self.tcx(), projection_trait_ref.substs);\n         debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n-                bounds={}\",\n-               bounds.repr(self.tcx()));\n+                bounds={:?}\",\n+               bounds);\n \n         let matching_bound =\n             util::elaborate_predicates(self.tcx(), bounds.predicates.into_vec())\n@@ -1041,8 +1042,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                               snapshot)));\n \n         debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n-                matching_bound={}\",\n-               matching_bound.repr(self.tcx()));\n+                matching_bound={:?}\",\n+               matching_bound);\n         match matching_bound {\n             None => false,\n             Some(bound) => {\n@@ -1088,8 +1089,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                   candidates: &mut SelectionCandidateSet<'tcx>)\n                                                   -> Result<(),SelectionError<'tcx>>\n     {\n-        debug!(\"assemble_candidates_from_caller_bounds({})\",\n-               stack.obligation.repr(self.tcx()));\n+        debug!(\"assemble_candidates_from_caller_bounds({:?})\",\n+               stack.obligation);\n \n         let all_bounds =\n             self.param_env().caller_bounds\n@@ -1155,10 +1156,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => { return Ok(()); }\n         };\n \n-        debug!(\"assemble_unboxed_candidates: self_ty={} kind={:?} obligation={}\",\n-               self_ty.repr(self.tcx()),\n+        debug!(\"assemble_unboxed_candidates: self_ty={:?} kind={:?} obligation={:?}\",\n+               self_ty,\n                kind,\n-               obligation.repr(self.tcx()));\n+               obligation);\n \n         match self.closure_typer.closure_kind(closure_def_id) {\n             Some(closure_kind) => {\n@@ -1221,7 +1222,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                       candidates: &mut SelectionCandidateSet<'tcx>)\n                                       -> Result<(), SelectionError<'tcx>>\n     {\n-        debug!(\"assemble_candidates_from_impls(obligation={})\", obligation.repr(self.tcx()));\n+        debug!(\"assemble_candidates_from_impls(obligation={:?})\", obligation);\n \n         let def = ty::lookup_trait_def(self.tcx(), obligation.predicate.def_id());\n \n@@ -1247,7 +1248,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         // OK to skip binder here because the tests we do below do not involve bound regions\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n-        debug!(\"assemble_candidates_from_default_impls(self_ty={})\", self_ty.repr(self.tcx()));\n+        debug!(\"assemble_candidates_from_default_impls(self_ty={:?})\", self_ty);\n \n         let def_id = obligation.predicate.def_id();\n \n@@ -1316,8 +1317,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                           obligation: &TraitObligation<'tcx>,\n                                           candidates: &mut SelectionCandidateSet<'tcx>)\n     {\n-        debug!(\"assemble_candidates_from_object_ty(self_ty={})\",\n-               self.infcx.shallow_resolve(*obligation.self_ty().skip_binder()).repr(self.tcx()));\n+        debug!(\"assemble_candidates_from_object_ty(self_ty={:?})\",\n+               self.infcx.shallow_resolve(*obligation.self_ty().skip_binder()));\n \n         // Object-safety candidates are only applicable to object-safe\n         // traits. Including this check is useful because it helps\n@@ -1362,8 +1363,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             };\n \n-            debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={}\",\n-                   poly_trait_ref.repr(self.tcx()));\n+            debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={:?}\",\n+                   poly_trait_ref);\n \n             // see whether the object trait can be upcast to the trait we are looking for\n             let upcast_trait_refs = self.upcast(poly_trait_ref, obligation);\n@@ -1406,8 +1407,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let source = self.infcx.shallow_resolve(self_ty);\n         let target = self.infcx.shallow_resolve(obligation.predicate.0.input_types()[0]);\n \n-        debug!(\"assemble_candidates_for_unsizing(source={}, target={})\",\n-               source.repr(self.tcx()), target.repr(self.tcx()));\n+        debug!(\"assemble_candidates_for_unsizing(source={:?}, target={:?})\",\n+               source, target);\n \n         let may_apply = match (&source.sty, &target.sty) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n@@ -1473,7 +1474,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             candidate: &SelectionCandidate<'tcx>)\n                             -> EvaluationResult<'tcx>\n     {\n-        debug!(\"winnow_candidate: candidate={}\", candidate.repr(self.tcx()));\n+        debug!(\"winnow_candidate: candidate={:?}\", candidate);\n         let result = self.infcx.probe(|_| {\n             let candidate = (*candidate).clone();\n             match self.confirm_candidate(stack.obligation, candidate) {\n@@ -1565,8 +1566,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         match self.builtin_bound(bound, stack.obligation) {\n             Ok(If(..)) => {\n-                debug!(\"builtin_bound: bound={}\",\n-                       bound.repr(self.tcx()));\n+                debug!(\"builtin_bound: bound={:?}\",\n+                       bound);\n                 candidates.vec.push(BuiltinCandidate(bound));\n                 Ok(())\n             }\n@@ -1774,8 +1775,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::TyInfer(ty::FreshFloatTy(_)) => {\n                 self.tcx().sess.bug(\n                     &format!(\n-                        \"asked to assemble builtin bounds of unexpected type: {}\",\n-                        self_ty.repr(self.tcx())));\n+                        \"asked to assemble builtin bounds of unexpected type: {:?}\",\n+                        self_ty));\n             }\n         };\n \n@@ -1837,8 +1838,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::TyInfer(ty::FreshFloatTy(_)) => {\n                 self.tcx().sess.bug(\n                     &format!(\n-                        \"asked to assemble constituent types of unexpected type: {}\",\n-                        t.repr(self.tcx())));\n+                        \"asked to assemble constituent types of unexpected type: {:?}\",\n+                        t));\n             }\n \n             ty::TyBox(referent_ty) => {  // Box<T>\n@@ -1972,9 +1973,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                          candidate: SelectionCandidate<'tcx>)\n                          -> Result<Selection<'tcx>,SelectionError<'tcx>>\n     {\n-        debug!(\"confirm_candidate({}, {})\",\n-               obligation.repr(self.tcx()),\n-               candidate.repr(self.tcx()));\n+        debug!(\"confirm_candidate({:?}, {:?})\",\n+               obligation,\n+               candidate);\n \n         match candidate {\n             BuiltinCandidate(builtin_bound) => {\n@@ -2064,9 +2065,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                param: ty::PolyTraitRef<'tcx>)\n                                -> Vec<PredicateObligation<'tcx>>\n     {\n-        debug!(\"confirm_param_candidate({},{})\",\n-               obligation.repr(self.tcx()),\n-               param.repr(self.tcx()));\n+        debug!(\"confirm_param_candidate({:?},{:?})\",\n+               obligation,\n+               param);\n \n         // During evaluation, we already checked that this\n         // where-clause trait-ref could be unified with the obligation\n@@ -2076,9 +2077,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             Ok(obligations) => obligations,\n             Err(()) => {\n                 self.tcx().sess.bug(\n-                    &format!(\"Where clause `{}` was applicable to `{}` but now is not\",\n-                             param.repr(self.tcx()),\n-                             obligation.repr(self.tcx())));\n+                    &format!(\"Where clause `{:?}` was applicable to `{:?}` but now is not\",\n+                             param,\n+                             obligation));\n             }\n         }\n     }\n@@ -2089,16 +2090,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                  -> Result<VtableBuiltinData<PredicateObligation<'tcx>>,\n                                            SelectionError<'tcx>>\n     {\n-        debug!(\"confirm_builtin_candidate({})\",\n-               obligation.repr(self.tcx()));\n+        debug!(\"confirm_builtin_candidate({:?})\",\n+               obligation);\n \n         match try!(self.builtin_bound(bound, obligation)) {\n             If(nested) => Ok(self.vtable_builtin_data(obligation, bound, nested)),\n             AmbiguousBuiltin | ParameterBuiltin => {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n-                    &format!(\"builtin bound for {} was ambig\",\n-                            obligation.repr(self.tcx())));\n+                    &format!(\"builtin bound for {:?} was ambig\",\n+                            obligation));\n             }\n         }\n     }\n@@ -2118,8 +2119,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let obligations = self.collect_predicates_for_types(obligation, trait_def, nested);\n \n-        debug!(\"vtable_builtin_data: obligations={}\",\n-               obligations.repr(self.tcx()));\n+        debug!(\"vtable_builtin_data: obligations={:?}\",\n+               obligations);\n \n         VtableBuiltinData { nested: obligations }\n     }\n@@ -2134,9 +2135,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                       trait_def_id: ast::DefId)\n                                       -> VtableDefaultImplData<PredicateObligation<'tcx>>\n     {\n-        debug!(\"confirm_default_impl_candidate({}, {})\",\n-               obligation.repr(self.tcx()),\n-               trait_def_id.repr(self.tcx()));\n+        debug!(\"confirm_default_impl_candidate({:?}, {:?})\",\n+               obligation,\n+               trait_def_id);\n \n         // binder is moved below\n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.skip_binder().self_ty());\n@@ -2145,8 +2146,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             None => {\n                 self.tcx().sess.bug(\n                     &format!(\n-                        \"asked to confirm default implementation for ambiguous type: {}\",\n-                        self_ty.repr(self.tcx())));\n+                        \"asked to confirm default implementation for ambiguous type: {:?}\",\n+                        self_ty));\n             }\n         }\n     }\n@@ -2156,9 +2157,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                              trait_def_id: ast::DefId)\n                                              -> VtableDefaultImplData<PredicateObligation<'tcx>>\n     {\n-        debug!(\"confirm_default_impl_object_candidate({}, {})\",\n-               obligation.repr(self.tcx()),\n-               trait_def_id.repr(self.tcx()));\n+        debug!(\"confirm_default_impl_object_candidate({:?}, {:?})\",\n+               obligation,\n+               trait_def_id);\n \n         assert!(ty::has_attr(self.tcx(), trait_def_id, \"rustc_reflect_like\"));\n \n@@ -2184,8 +2185,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => {\n                 self.tcx().sess.bug(\n                     &format!(\n-                        \"asked to confirm default object implementation for non-object type: {}\",\n-                        self_ty.repr(self.tcx())));\n+                        \"asked to confirm default object implementation for non-object type: {:?}\",\n+                        self_ty));\n             }\n         }\n     }\n@@ -2197,7 +2198,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                            nested: ty::Binder<Vec<Ty<'tcx>>>)\n                            -> VtableDefaultImplData<PredicateObligation<'tcx>>\n     {\n-        debug!(\"vtable_default_impl_data: nested={}\", nested.repr(self.tcx()));\n+        debug!(\"vtable_default_impl_data: nested={:?}\", nested);\n \n         let mut obligations = self.collect_predicates_for_types(obligation,\n                                                                 trait_def_id,\n@@ -2218,7 +2219,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // no Errors in that code above\n         obligations.append(&mut trait_obligations.unwrap());\n \n-        debug!(\"vtable_default_impl_data: obligations={}\", obligations.repr(self.tcx()));\n+        debug!(\"vtable_default_impl_data: obligations={:?}\", obligations);\n \n         VtableDefaultImplData {\n             trait_def_id: trait_def_id,\n@@ -2232,17 +2233,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                               -> Result<VtableImplData<'tcx, PredicateObligation<'tcx>>,\n                                         SelectionError<'tcx>>\n     {\n-        debug!(\"confirm_impl_candidate({},{})\",\n-               obligation.repr(self.tcx()),\n-               impl_def_id.repr(self.tcx()));\n+        debug!(\"confirm_impl_candidate({:?},{:?})\",\n+               obligation,\n+               impl_def_id);\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n         self.infcx.commit_if_ok(|snapshot| {\n             let (substs, skol_map) =\n                 self.rematch_impl(impl_def_id, obligation,\n                                   snapshot);\n-            debug!(\"confirm_impl_candidate substs={}\", substs.repr(self.tcx()));\n+            debug!(\"confirm_impl_candidate substs={:?}\", substs);\n             Ok(self.vtable_impl(impl_def_id, substs, obligation.cause.clone(),\n                                 obligation.recursion_depth + 1, skol_map, snapshot))\n         })\n@@ -2257,11 +2258,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                    snapshot: &infer::CombinedSnapshot)\n                    -> VtableImplData<'tcx, PredicateObligation<'tcx>>\n     {\n-        debug!(\"vtable_impl(impl_def_id={}, substs={}, recursion_depth={}, skol_map={})\",\n-               impl_def_id.repr(self.tcx()),\n-               substs.repr(self.tcx()),\n+        debug!(\"vtable_impl(impl_def_id={:?}, substs={:?}, recursion_depth={}, skol_map={:?})\",\n+               impl_def_id,\n+               substs,\n                recursion_depth,\n-               skol_map.repr(self.tcx()));\n+               skol_map);\n \n         let mut impl_obligations =\n             self.impl_or_trait_obligations(cause,\n@@ -2271,9 +2272,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                            skol_map,\n                                            snapshot);\n \n-        debug!(\"vtable_impl: impl_def_id={} impl_obligations={}\",\n-               impl_def_id.repr(self.tcx()),\n-               impl_obligations.repr(self.tcx()));\n+        debug!(\"vtable_impl: impl_def_id={:?} impl_obligations={:?}\",\n+               impl_def_id,\n+               impl_obligations);\n \n         impl_obligations.append(&mut substs.obligations);\n \n@@ -2286,8 +2287,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                 obligation: &TraitObligation<'tcx>)\n                                 -> VtableObjectData<'tcx>\n     {\n-        debug!(\"confirm_object_candidate({})\",\n-               obligation.repr(self.tcx()));\n+        debug!(\"confirm_object_candidate({:?})\",\n+               obligation);\n \n         // FIXME skipping binder here seems wrong -- we should\n         // probably flatten the binder from the obligation and the\n@@ -2328,8 +2329,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                     obligation: &TraitObligation<'tcx>)\n                                     -> Result<ty::Ty<'tcx>,SelectionError<'tcx>>\n     {\n-        debug!(\"confirm_fn_pointer_candidate({})\",\n-               obligation.repr(self.tcx()));\n+        debug!(\"confirm_fn_pointer_candidate({:?})\",\n+               obligation);\n \n         // ok to skip binder; it is reintroduced below\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n@@ -2355,20 +2356,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                  -> Result<VtableClosureData<'tcx, PredicateObligation<'tcx>>,\n                                            SelectionError<'tcx>>\n     {\n-        debug!(\"confirm_closure_candidate({},{},{})\",\n-               obligation.repr(self.tcx()),\n-               closure_def_id.repr(self.tcx()),\n-               substs.repr(self.tcx()));\n+        debug!(\"confirm_closure_candidate({:?},{:?},{:?})\",\n+               obligation,\n+               closure_def_id,\n+               substs);\n \n         let Normalized {\n             value: trait_ref,\n             obligations\n         } = self.closure_trait_ref(obligation, closure_def_id, substs);\n \n-        debug!(\"confirm_closure_candidate(closure_def_id={}, trait_ref={}, obligations={})\",\n-               closure_def_id.repr(self.tcx()),\n-               trait_ref.repr(self.tcx()),\n-               obligations.repr(self.tcx()));\n+        debug!(\"confirm_closure_candidate(closure_def_id={:?}, trait_ref={:?}, obligations={:?})\",\n+               closure_def_id,\n+               trait_ref,\n+               obligations);\n \n         try!(self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                           obligation.predicate.to_poly_trait_ref(),\n@@ -2436,8 +2437,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::no_late_bound_regions(tcx, &obligation.self_ty()).unwrap());\n         let target = self.infcx.shallow_resolve(obligation.predicate.0.input_types()[0]);\n \n-        debug!(\"confirm_builtin_unsize_candidate(source={}, target={})\",\n-               source.repr(tcx), target.repr(tcx));\n+        debug!(\"confirm_builtin_unsize_candidate(source={:?}, target={:?})\",\n+               source, target);\n \n         let mut nested = vec![];\n         match (&source.sty, &target.sty) {\n@@ -2613,9 +2614,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             Ok((substs, skol_map)) => (substs, skol_map),\n             Err(()) => {\n                 self.tcx().sess.bug(\n-                    &format!(\"Impl {} was matchable against {} but now is not\",\n-                            impl_def_id.repr(self.tcx()),\n-                            obligation.repr(self.tcx())));\n+                    &format!(\"Impl {:?} was matchable against {:?} but now is not\",\n+                            impl_def_id,\n+                            obligation));\n             }\n         }\n     }\n@@ -2654,30 +2655,28 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                           obligation.recursion_depth + 1,\n                                           &impl_trait_ref);\n \n-        debug!(\"match_impl(impl_def_id={}, obligation={}, \\\n-               impl_trait_ref={}, skol_obligation_trait_ref={})\",\n-               impl_def_id.repr(self.tcx()),\n-               obligation.repr(self.tcx()),\n-               impl_trait_ref.repr(self.tcx()),\n-               skol_obligation_trait_ref.repr(self.tcx()));\n+        debug!(\"match_impl(impl_def_id={:?}, obligation={:?}, \\\n+               impl_trait_ref={:?}, skol_obligation_trait_ref={:?})\",\n+               impl_def_id,\n+               obligation,\n+               impl_trait_ref,\n+               skol_obligation_trait_ref);\n \n         let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n         if let Err(e) = self.infcx.sub_trait_refs(false,\n                                                   origin,\n                                                   impl_trait_ref.value.clone(),\n                                                   skol_obligation_trait_ref) {\n-            debug!(\"match_impl: failed sub_trait_refs due to `{}`\",\n-                   ty::type_err_to_str(self.tcx(), &e));\n+            debug!(\"match_impl: failed sub_trait_refs due to `{}`\", e);\n             return Err(());\n         }\n \n         if let Err(e) = self.infcx.leak_check(&skol_map, snapshot) {\n-            debug!(\"match_impl: failed leak check due to `{}`\",\n-                   ty::type_err_to_str(self.tcx(), &e));\n+            debug!(\"match_impl: failed leak check due to `{}`\", e);\n             return Err(());\n         }\n \n-        debug!(\"match_impl: success impl_substs={}\", impl_substs.repr(self.tcx()));\n+        debug!(\"match_impl: success impl_substs={:?}\", impl_substs);\n         Ok((Normalized {\n             value: impl_substs,\n             obligations: impl_trait_ref.obligations\n@@ -2728,9 +2727,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             poly_trait_ref: ty::PolyTraitRef<'tcx>)\n                             -> Result<(),()>\n     {\n-        debug!(\"match_poly_trait_ref: obligation={} poly_trait_ref={}\",\n-               obligation.repr(self.tcx()),\n-               poly_trait_ref.repr(self.tcx()));\n+        debug!(\"match_poly_trait_ref: obligation={:?} poly_trait_ref={:?}\",\n+               obligation,\n+               poly_trait_ref);\n \n         let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n         match self.infcx.sub_poly_trait_refs(false,\n@@ -2769,15 +2768,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let impl_self_ty = ty::lookup_item_type(self.tcx(), impl_def_id).ty;\n         let impl_self_ty = impl_self_ty.subst(self.tcx(), &impl_substs);\n \n-        debug!(\"match_impl_self_types(obligation_self_ty={}, impl_self_ty={})\",\n-               obligation_self_ty.repr(self.tcx()),\n-               impl_self_ty.repr(self.tcx()));\n+        debug!(\"match_impl_self_types(obligation_self_ty={:?}, impl_self_ty={:?})\",\n+               obligation_self_ty,\n+               impl_self_ty);\n \n         match self.match_self_types(obligation_cause,\n                                     impl_self_ty,\n                                     obligation_self_ty) {\n             Ok(()) => {\n-                debug!(\"Matched impl_substs={}\", impl_substs.repr(self.tcx()));\n+                debug!(\"Matched impl_substs={:?}\", impl_substs);\n                 Ok(impl_substs)\n             }\n             Err(()) => {\n@@ -2889,15 +2888,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                  snapshot: &infer::CombinedSnapshot)\n                                  -> Vec<PredicateObligation<'tcx>>\n     {\n-        debug!(\"impl_or_trait_obligations(def_id={})\", def_id.repr(self.tcx()));\n+        debug!(\"impl_or_trait_obligations(def_id={:?})\", def_id);\n \n         let predicates = ty::lookup_predicates(self.tcx(), def_id);\n         let predicates = predicates.instantiate(self.tcx(), substs);\n         let predicates = normalize_with_depth(self, cause.clone(), recursion_depth, &predicates);\n         let mut predicates = self.infcx().plug_leaks(skol_map, snapshot, &predicates);\n         let mut obligations =\n-            util::predicates_for_generics(self.tcx(),\n-                                          cause,\n+            util::predicates_for_generics(cause,\n                                           recursion_depth,\n                                           &predicates.value);\n         obligations.append(&mut predicates.obligations);\n@@ -2940,9 +2938,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn upcast(&mut self, obj_trait_ref: ty::PolyTraitRef<'tcx>, obligation: &TraitObligation<'tcx>)\n               -> Vec<ty::PolyTraitRef<'tcx>>\n     {\n-        debug!(\"upcast(obj_trait_ref={}, obligation={})\",\n-               obj_trait_ref.repr(self.tcx()),\n-               obligation.repr(self.tcx()));\n+        debug!(\"upcast(obj_trait_ref={:?}, obligation={:?})\",\n+               obj_trait_ref,\n+               obligation);\n \n         let obligation_def_id = obligation.predicate.def_id();\n         let mut upcast_trait_refs = util::upcast(self.tcx(), obj_trait_ref, obligation_def_id);\n@@ -2958,33 +2956,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             self.infcx.probe(|_| self.match_poly_trait_ref(obligation, upcast_trait_ref)).is_ok()\n         });\n \n-        debug!(\"upcast: upcast_trait_refs={}\", upcast_trait_refs.repr(self.tcx()));\n+        debug!(\"upcast: upcast_trait_refs={:?}\", upcast_trait_refs);\n         upcast_trait_refs\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        match *self {\n-            PhantomFnCandidate => format!(\"PhantomFnCandidate\"),\n-            ErrorCandidate => format!(\"ErrorCandidate\"),\n-            BuiltinCandidate(b) => format!(\"BuiltinCandidate({:?})\", b),\n-            BuiltinObjectCandidate => format!(\"BuiltinObjectCandidate\"),\n-            BuiltinUnsizeCandidate => format!(\"BuiltinUnsizeCandidate\"),\n-            ParamCandidate(ref a) => format!(\"ParamCandidate({})\", a.repr(tcx)),\n-            ImplCandidate(a) => format!(\"ImplCandidate({})\", a.repr(tcx)),\n-            DefaultImplCandidate(t) => format!(\"DefaultImplCandidate({:?})\", t),\n-            DefaultImplObjectCandidate(t) => format!(\"DefaultImplObjectCandidate({:?})\", t),\n-            ProjectionCandidate => format!(\"ProjectionCandidate\"),\n-            FnPointerCandidate => format!(\"FnPointerCandidate\"),\n-            ObjectCandidate => format!(\"ObjectCandidate\"),\n-            ClosureCandidate(c, ref s) => {\n-                format!(\"ClosureCandidate({:?},{})\", c, s.repr(tcx))\n-            }\n-        }\n-    }\n-}\n-\n impl<'tcx> SelectionCache<'tcx> {\n     pub fn new() -> SelectionCache<'tcx> {\n         SelectionCache {\n@@ -3032,10 +3008,9 @@ impl<'o,'tcx> Iterator for TraitObligationStackList<'o,'tcx>{\n     }\n }\n \n-impl<'o,'tcx> Repr<'tcx> for TraitObligationStack<'o,'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"TraitObligationStack({})\",\n-                self.obligation.repr(tcx))\n+impl<'o,'tcx> fmt::Debug for TraitObligationStack<'o,'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"TraitObligationStack({:?})\", self.obligation)\n     }\n }\n "}, {"sha": "54bcd9d7e66abc792ed9ea848779661b45d32895", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 48, "deletions": 108, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -16,7 +16,6 @@ use syntax::ast;\n use syntax::codemap::Span;\n use util::common::ErrorReported;\n use util::nodemap::FnvHashSet;\n-use util::ppaux::Repr;\n \n use super::{Obligation, ObligationCause, PredicateObligation,\n             VtableImpl, VtableParam, VtableImplData, VtableDefaultImplData};\n@@ -125,8 +124,8 @@ impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n                               .map(|p| p.subst_supertrait(self.tcx, &data.to_poly_trait_ref()))\n                               .collect();\n \n-                debug!(\"super_predicates: data={} predicates={}\",\n-                       data.repr(self.tcx), predicates.repr(self.tcx));\n+                debug!(\"super_predicates: data={:?} predicates={:?}\",\n+                       data, predicates);\n \n                 // Only keep those bounds that we haven't already\n                 // seen.  This is necessary to prevent infinite\n@@ -302,33 +301,14 @@ pub fn fresh_type_vars_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     infcx.fresh_substs_for_generics(span, &impl_generics)\n }\n \n-impl<'tcx, N> fmt::Debug for VtableImplData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableImpl({:?})\", self.impl_def_id)\n-    }\n-}\n-\n-impl<'tcx, N> fmt::Debug for super::VtableClosureData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableClosure({:?})\", self.closure_def_id)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for super::VtableObjectData<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableObject(...)\")\n-    }\n-}\n-\n /// See `super::obligations_for_generics`\n-pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                     cause: ObligationCause<'tcx>,\n+pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n                                      recursion_depth: usize,\n                                      generic_bounds: &ty::InstantiatedPredicates<'tcx>)\n                                      -> Vec<PredicateObligation<'tcx>>\n {\n-    debug!(\"predicates_for_generics(generic_bounds={})\",\n-           generic_bounds.repr(tcx));\n+    debug!(\"predicates_for_generics(generic_bounds={:?})\",\n+           generic_bounds);\n \n     generic_bounds.predicates.iter().map(|predicate| {\n         Obligation { cause: cause.clone(),\n@@ -486,118 +466,84 @@ pub fn closure_trait_ref_and_return_type<'tcx>(\n     ty::Binder((trait_ref, sig.0.output.unwrap_or(ty::mk_nil(tcx))))\n }\n \n-impl<'tcx,O:Repr<'tcx>> Repr<'tcx> for super::Obligation<'tcx, O> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"Obligation(predicate={},depth={})\",\n-                self.predicate.repr(tcx),\n-                self.recursion_depth)\n+impl<'tcx,O:fmt::Debug> fmt::Debug for super::Obligation<'tcx, O> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Obligation(predicate={:?},depth={})\",\n+               self.predicate,\n+               self.recursion_depth)\n     }\n }\n \n-impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::Vtable<'tcx, N> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx, N:fmt::Debug> fmt::Debug for super::Vtable<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             super::VtableImpl(ref v) =>\n-                v.repr(tcx),\n+                write!(f, \"{:?}\", v),\n \n             super::VtableDefaultImpl(ref t) =>\n-                t.repr(tcx),\n+                write!(f, \"{:?}\", t),\n \n             super::VtableClosure(ref d) =>\n-                d.repr(tcx),\n+                write!(f, \"{:?}\", d),\n \n             super::VtableFnPointer(ref d) =>\n-                format!(\"VtableFnPointer({})\",\n-                        d.repr(tcx)),\n+                write!(f, \"VtableFnPointer({:?})\", d),\n \n             super::VtableObject(ref d) =>\n-                format!(\"VtableObject({})\",\n-                        d.repr(tcx)),\n+                write!(f, \"VtableObject({:?})\", d),\n \n             super::VtableParam(ref n) =>\n-                format!(\"VtableParam({})\",\n-                        n.repr(tcx)),\n+                write!(f, \"VtableParam({:?})\", n),\n \n             super::VtableBuiltin(ref d) =>\n-                d.repr(tcx)\n+                write!(f, \"{:?}\", d)\n         }\n     }\n }\n \n-impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableImplData<'tcx, N> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"VtableImpl(impl_def_id={}, substs={}, nested={})\",\n-                self.impl_def_id.repr(tcx),\n-                self.substs.repr(tcx),\n-                self.nested.repr(tcx))\n-    }\n-}\n-\n-impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableClosureData<'tcx, N> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"VtableClosure(closure_def_id={}, substs={}, nested={})\",\n-                self.closure_def_id.repr(tcx),\n-                self.substs.repr(tcx),\n-                self.nested.repr(tcx))\n-    }\n-}\n-\n-impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableBuiltinData<N> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"VtableBuiltin(nested={})\",\n-                self.nested.repr(tcx))\n+impl<'tcx, N:fmt::Debug> fmt::Debug for super::VtableImplData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableImpl(impl_def_id={:?}, substs={:?}, nested={:?})\",\n+               self.impl_def_id,\n+               self.substs,\n+               self.nested)\n     }\n }\n \n-impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableDefaultImplData<N> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"VtableDefaultImplData(trait_def_id={}, nested={})\",\n-                self.trait_def_id.repr(tcx),\n-                self.nested.repr(tcx))\n+impl<'tcx, N:fmt::Debug> fmt::Debug for super::VtableClosureData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableClosure(closure_def_id={:?}, substs={:?}, nested={:?})\",\n+               self.closure_def_id,\n+               self.substs,\n+               self.nested)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for super::VtableObjectData<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"VtableObject(object_ty={})\",\n-                self.object_ty.repr(tcx))\n+impl<'tcx, N:fmt::Debug> fmt::Debug for super::VtableBuiltinData<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableBuiltin(nested={:?})\", self.nested)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for super::SelectionError<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        match *self {\n-            super::Unimplemented =>\n-                format!(\"Unimplemented\"),\n-\n-            super::OutputTypeParameterMismatch(ref a, ref b, ref c) =>\n-                format!(\"OutputTypeParameterMismatch({},{},{})\",\n-                        a.repr(tcx),\n-                        b.repr(tcx),\n-                        c.repr(tcx)),\n-\n-            super::TraitNotObjectSafe(ref tr) =>\n-                format!(\"TraitNotObjectSafe({})\",\n-                        tr.repr(tcx))\n-        }\n+impl<'tcx, N:fmt::Debug> fmt::Debug for super::VtableDefaultImplData<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableDefaultImplData(trait_def_id={:?}, nested={:?})\",\n+               self.trait_def_id,\n+               self.nested)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for super::FulfillmentError<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"FulfillmentError({},{})\",\n-                self.obligation.repr(tcx),\n-                self.code.repr(tcx))\n+impl<'tcx> fmt::Debug for super::VtableObjectData<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableObject(object_ty={:?})\", self.object_ty)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for super::FulfillmentErrorCode<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        match *self {\n-            super::CodeSelectionError(ref o) => o.repr(tcx),\n-            super::CodeProjectionError(ref o) => o.repr(tcx),\n-            super::CodeAmbiguity => format!(\"Ambiguity\")\n-        }\n+impl<'tcx> fmt::Debug for super::FulfillmentError<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"FulfillmentError({:?},{:?})\",\n+               self.obligation,\n+               self.code)\n     }\n }\n \n@@ -611,14 +557,8 @@ impl<'tcx> fmt::Debug for super::FulfillmentErrorCode<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for super::MismatchedProjectionTypes<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        self.err.repr(tcx)\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for super::MismatchedProjectionTypes<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"MismatchedProjectionTypes(..)\")\n+        write!(f, \"MismatchedProjectionTypes({:?})\", self.err)\n     }\n }"}, {"sha": "170b98b88310ff1678c9926e50fdc799c8a7d41c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 488, "deletions": 311, "changes": 799, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -12,7 +12,6 @@\n \n pub use self::terr_vstore_kind::*;\n pub use self::type_err::*;\n-pub use self::BuiltinBound::*;\n pub use self::InferTy::*;\n pub use self::InferRegion::*;\n pub use self::ImplOrTraitItemId::*;\n@@ -35,6 +34,11 @@ pub use self::IntVarValue::*;\n pub use self::MethodOrigin::*;\n pub use self::CopyImplementationError::*;\n \n+pub use self::BuiltinBound::Send as BoundSend;\n+pub use self::BuiltinBound::Sized as BoundSized;\n+pub use self::BuiltinBound::Copy as BoundCopy;\n+pub use self::BuiltinBound::Sync as BoundSync;\n+\n use ast_map::{self, LinkedPath};\n use back::svh::Svh;\n use session::Session;\n@@ -48,6 +52,7 @@ use middle::def::{self, DefMap, ExportMap};\n use middle::dependency_format;\n use middle::fast_reject;\n use middle::free_region::FreeRegionMap;\n+use middle::infer::error_reporting::note_and_explain_region;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::mem_categorization as mc;\n use middle::region;\n@@ -61,9 +66,6 @@ use middle::traits;\n use middle::ty;\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n use middle::ty_walk::{self, TypeWalker};\n-use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n-use util::ppaux::ty_to_string;\n-use util::ppaux::{Repr, UserString};\n use util::common::{memoized, ErrorReported};\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n use util::nodemap::FnvHashMap;\n@@ -79,7 +81,7 @@ use std::mem;\n use std::ops;\n use std::rc::Rc;\n use std::vec::IntoIter;\n-use collections::enum_set::{EnumSet, CLike};\n+use collections::enum_set::{self, EnumSet, CLike};\n use std::collections::{HashMap, HashSet};\n use syntax::abi;\n use syntax::ast::{CrateNum, DefId, ItemImpl, ItemTrait, LOCAL_CRATE};\n@@ -101,11 +103,10 @@ pub const INITIAL_DISCRIMINANT_VALUE: Disr = 0;\n \n /// The complete set of all analyses described in this module. This is\n /// produced by the driver and fed to trans and later passes.\n-pub struct CrateAnalysis<'tcx> {\n+pub struct CrateAnalysis {\n     pub export_map: ExportMap,\n     pub exported_items: middle::privacy::ExportedItems,\n     pub public_items: middle::privacy::PublicItems,\n-    pub ty_cx: ty::ctxt<'tcx>,\n     pub reachable: NodeSet,\n     pub name: String,\n     pub glob_map: Option<GlobMap>,\n@@ -132,7 +133,7 @@ impl ImplOrTraitItemContainer {\n     }\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n pub enum ImplOrTraitItem<'tcx> {\n     ConstTraitItem(Rc<AssociatedConst<'tcx>>),\n     MethodTraitItem(Rc<Method<'tcx>>),\n@@ -295,15 +296,15 @@ pub struct ItemVariances {\n     pub regions: VecPerParamSpace<Variance>,\n }\n \n-#[derive(Clone, PartialEq, RustcDecodable, RustcEncodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcDecodable, RustcEncodable, Copy)]\n pub enum Variance {\n     Covariant,      // T<A> <: T<B> iff A <: B -- e.g., function return type\n     Invariant,      // T<A> <: T<B> iff B == A -- e.g., type of mutable cell\n     Contravariant,  // T<A> <: T<B> iff B <: A -- e.g., function param type\n     Bivariant,      // T<A> <: T<B>            -- e.g., unused type parameter\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone)]\n pub enum AutoAdjustment<'tcx> {\n     AdjustReifyFnPointer,   // go from a fn-item type to a fn-pointer type\n     AdjustUnsafeFnPointer,  // go from a safe fn pointer to an unsafe fn pointer\n@@ -372,7 +373,7 @@ pub enum AutoAdjustment<'tcx> {\n ///     unsize: Some(Box<[i32]>),\n /// }\n /// ```\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone)]\n pub struct AutoDerefRef<'tcx> {\n     /// Step 1. Apply a number of dereferences, producing an lvalue.\n     pub autoderefs: usize,\n@@ -402,7 +403,7 @@ pub enum CustomCoerceUnsized {\n     Struct(usize)\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n pub enum MethodOrigin<'tcx> {\n     // fully statically resolved method\n     MethodStatic(ast::DefId),\n@@ -420,7 +421,7 @@ pub enum MethodOrigin<'tcx> {\n \n // details for a method invoked with a receiver whose type is a type parameter\n // with a bounded trait.\n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n pub struct MethodParam<'tcx> {\n     // the precise trait reference that occurs as a bound -- this may\n     // be a supertrait of what the user actually typed. Note that it\n@@ -441,7 +442,7 @@ pub struct MethodParam<'tcx> {\n }\n \n // details for a method invoked with a receiver whose type is an object\n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n pub struct MethodObject<'tcx> {\n     // the (super)trait containing the method to be invoked\n     pub trait_ref: TraitRef<'tcx>,\n@@ -804,6 +805,201 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn free_region_map(&self, id: NodeId) -> FreeRegionMap {\n         self.free_region_maps.borrow()[&id].clone()\n     }\n+\n+    pub fn lift<T: ?Sized + Lift<'tcx>>(&self, value: &T) -> Option<T::Lifted> {\n+        value.lift_to_tcx(self)\n+    }\n+}\n+\n+/// A trait implemented for all X<'a> types which can be safely and\n+/// efficiently converted to X<'tcx> as long as they are part of the\n+/// provided ty::ctxt<'tcx>.\n+/// This can be done, for example, for Ty<'tcx> or &'tcx Substs<'tcx>\n+/// by looking them up in their respective interners.\n+/// None is returned if the value or one of the components is not part\n+/// of the provided context.\n+/// For Ty, None can be returned if either the type interner doesn't\n+/// contain the TypeVariants key or if the address of the interned\n+/// pointer differs. The latter case is possible if a primitive type,\n+/// e.g. `()` or `u8`, was interned in a different context.\n+pub trait Lift<'tcx> {\n+    type Lifted;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<Self::Lifted>;\n+}\n+\n+impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n+    type Lifted = (A::Lifted, B::Lifted);\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.0).and_then(|a| tcx.lift(&self.1).map(|b| (a, b)))\n+    }\n+}\n+\n+impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n+    type Lifted = Vec<T::Lifted>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<Self::Lifted> {\n+        let mut result = Vec::with_capacity(self.len());\n+        for x in self {\n+            if let Some(value) = tcx.lift(x) {\n+                result.push(value);\n+            } else {\n+                return None;\n+            }\n+        }\n+        Some(result)\n+    }\n+}\n+\n+impl<'tcx> Lift<'tcx> for Region {\n+    type Lifted = Self;\n+    fn lift_to_tcx(&self, _: &ctxt<'tcx>) -> Option<Region> {\n+        Some(*self)\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n+    type Lifted = Ty<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<Ty<'tcx>> {\n+        if let Some(&ty) = tcx.interner.borrow().get(&self.sty) {\n+            if *self as *const _ == ty as *const _ {\n+                return Some(ty);\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n+    type Lifted = &'tcx Substs<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<&'tcx Substs<'tcx>> {\n+        if let Some(&substs) = tcx.substs_interner.borrow().get(*self) {\n+            if *self as *const _ == substs as *const _ {\n+                return Some(substs);\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for TraitRef<'a> {\n+    type Lifted = TraitRef<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<TraitRef<'tcx>> {\n+        tcx.lift(&self.substs).map(|substs| TraitRef {\n+            def_id: self.def_id,\n+            substs: substs\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for TraitPredicate<'a> {\n+    type Lifted = TraitPredicate<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<TraitPredicate<'tcx>> {\n+        tcx.lift(&self.trait_ref).map(|trait_ref| TraitPredicate {\n+            trait_ref: trait_ref\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for EquatePredicate<'a> {\n+    type Lifted = EquatePredicate<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<EquatePredicate<'tcx>> {\n+        tcx.lift(&(self.0, self.1)).map(|(a, b)| EquatePredicate(a, b))\n+    }\n+}\n+\n+impl<'tcx, A: Copy+Lift<'tcx>, B: Copy+Lift<'tcx>> Lift<'tcx> for OutlivesPredicate<A, B> {\n+    type Lifted = OutlivesPredicate<A::Lifted, B::Lifted>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&(self.0, self.1)).map(|(a, b)| OutlivesPredicate(a, b))\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ProjectionPredicate<'a> {\n+    type Lifted = ProjectionPredicate<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<ProjectionPredicate<'tcx>> {\n+        tcx.lift(&(self.projection_ty.trait_ref, self.ty)).map(|(trait_ref, ty)| {\n+            ProjectionPredicate {\n+                projection_ty: ProjectionTy {\n+                    trait_ref: trait_ref,\n+                    item_name: self.projection_ty.item_name\n+                },\n+                ty: ty\n+            }\n+        })\n+    }\n+}\n+\n+impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Binder<T> {\n+    type Lifted = Binder<T::Lifted>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.0).map(|x| Binder(x))\n+    }\n+}\n+\n+pub mod tls {\n+    use ast_map;\n+    use middle::ty;\n+    use session::Session;\n+\n+    use std::fmt;\n+    use syntax::ast;\n+    use syntax::codemap;\n+\n+    /// Marker type used for the scoped TLS slot.\n+    /// The type context cannot be used directly because the scoped TLS\n+    /// in libstd doesn't allow types generic over lifetimes.\n+    struct ThreadLocalTyCx;\n+\n+    scoped_thread_local!(static TLS_TCX: ThreadLocalTyCx);\n+\n+    fn def_id_debug(def_id: ast::DefId, f: &mut fmt::Formatter) -> fmt::Result {\n+        // Unfortunately, there seems to be no way to attempt to print\n+        // a path for a def-id, so I'll just make a best effort for now\n+        // and otherwise fallback to just printing the crate/node pair\n+        with(|tcx| {\n+            if def_id.krate == ast::LOCAL_CRATE {\n+                match tcx.map.find(def_id.node) {\n+                    Some(ast_map::NodeItem(..)) |\n+                    Some(ast_map::NodeForeignItem(..)) |\n+                    Some(ast_map::NodeImplItem(..)) |\n+                    Some(ast_map::NodeTraitItem(..)) |\n+                    Some(ast_map::NodeVariant(..)) |\n+                    Some(ast_map::NodeStructCtor(..)) => {\n+                        return write!(f, \"{}\", ty::item_path_str(tcx, def_id));\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            Ok(())\n+        })\n+    }\n+\n+    fn span_debug(span: codemap::Span, f: &mut fmt::Formatter) -> fmt::Result {\n+        with(|tcx| {\n+            write!(f, \"{}\", tcx.sess.codemap().span_to_string(span))\n+        })\n+    }\n+\n+    pub fn enter<'tcx, F: FnOnce(&ty::ctxt<'tcx>) -> R, R>(tcx: ty::ctxt<'tcx>, f: F)\n+                                                           -> (Session, R) {\n+        let result = ast::DEF_ID_DEBUG.with(|def_id_dbg| {\n+            codemap::SPAN_DEBUG.with(|span_dbg| {\n+                let original_def_id_debug = def_id_dbg.get();\n+                def_id_dbg.set(def_id_debug);\n+                let original_span_debug = span_dbg.get();\n+                span_dbg.set(span_debug);\n+                let tls_ptr = &tcx as *const _ as *const ThreadLocalTyCx;\n+                let result = TLS_TCX.set(unsafe { &*tls_ptr }, || f(&tcx));\n+                def_id_dbg.set(original_def_id_debug);\n+                span_dbg.set(original_span_debug);\n+                result\n+            })\n+        });\n+        (tcx.sess, result)\n+    }\n+\n+    pub fn with<F: FnOnce(&ty::ctxt) -> R, R>(f: F) -> R {\n+        TLS_TCX.with(|tcx| f(unsafe { &*(tcx as *const _ as *const ty::ctxt) }))\n+    }\n }\n \n // Flags that we track on types. These flags are propagated upwards\n@@ -928,7 +1124,6 @@ impl<'tcx> ctxt<'tcx> {\n     }\n }\n \n-#[derive(Debug)]\n pub struct TyS<'tcx> {\n     pub sty: TypeVariants<'tcx>,\n     pub flags: Cell<TypeFlags>,\n@@ -1051,7 +1246,7 @@ pub struct BareFnTy<'tcx> {\n     pub sig: PolyFnSig<'tcx>,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash)]\n pub struct ClosureTy<'tcx> {\n     pub unsafety: ast::Unsafety,\n     pub abi: abi::Abi,\n@@ -1122,7 +1317,7 @@ impl<'tcx> PolyFnSig<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ParamTy {\n     pub space: subst::ParamSpace,\n     pub idx: u32,\n@@ -1176,7 +1371,7 @@ pub struct DebruijnIndex {\n }\n \n /// Representation of regions:\n-#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Copy)]\n pub enum Region {\n     // Region bound in a type or fn declaration which will be\n     // substituted 'early' -- that is, at the same time when type\n@@ -1224,7 +1419,7 @@ pub struct EarlyBoundRegion {\n /// Upvars do not get their own node-id. Instead, we use the pair of\n /// the original var id (that is, the root variable that is referenced\n /// by the upvar) and the id of the closure expression.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct UpvarId {\n     pub var_id: ast::NodeId,\n     pub closure_expr_id: ast::NodeId,\n@@ -1289,7 +1484,7 @@ pub enum UpvarCapture {\n     ByRef(UpvarBorrow),\n }\n \n-#[derive(PartialEq, Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(PartialEq, Clone, RustcEncodable, RustcDecodable, Copy)]\n pub struct UpvarBorrow {\n     /// The kind of borrow: by-ref upvars have access to shared\n     /// immutable borrows, which are not part of the normal language\n@@ -1329,7 +1524,7 @@ impl Region {\n }\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n-         RustcEncodable, RustcDecodable, Debug, Copy)]\n+         RustcEncodable, RustcDecodable, Copy)]\n /// A \"free\" region `fr` can be interpreted as \"some region\n /// at least as big as the scope `fr.scope`\".\n pub struct FreeRegion {\n@@ -1338,7 +1533,7 @@ pub struct FreeRegion {\n }\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n-         RustcEncodable, RustcDecodable, Debug, Copy)]\n+         RustcEncodable, RustcDecodable, Copy, Debug)]\n pub enum BoundRegion {\n     /// An anonymous region parameter for a given fn (&T)\n     BrAnon(u32),\n@@ -1449,7 +1644,7 @@ pub enum TypeVariants<'tcx> {\n     TyError,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash)]\n pub struct TraitTy<'tcx> {\n     pub principal: ty::PolyTraitRef<'tcx>,\n     pub bounds: ExistentialBounds<'tcx>,\n@@ -1520,7 +1715,7 @@ impl<'tcx> TraitTy<'tcx> {\n /// Note that a `TraitRef` introduces a level of region binding, to\n /// account for higher-ranked trait bounds like `T : for<'a> Foo<&'a\n /// U>` or higher-ranked object types.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n     pub substs: &'tcx Substs<'tcx>,\n@@ -1655,7 +1850,7 @@ pub enum type_err<'tcx> {\n \n /// Bounds suitable for a named type parameter like `A` in `fn foo<A>`\n /// as well as the existential type parameter in an object type.\n-#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n+#[derive(PartialEq, Eq, Hash, Clone)]\n pub struct ParamBounds<'tcx> {\n     pub region_bounds: Vec<ty::Region>,\n     pub builtin_bounds: BuiltinBounds,\n@@ -1668,41 +1863,57 @@ pub struct ParamBounds<'tcx> {\n /// major difference between this case and `ParamBounds` is that\n /// general purpose trait bounds are omitted and there must be\n /// *exactly one* region.\n-#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n+#[derive(PartialEq, Eq, Hash, Clone)]\n pub struct ExistentialBounds<'tcx> {\n     pub region_bound: ty::Region,\n     pub builtin_bounds: BuiltinBounds,\n     pub projection_bounds: Vec<PolyProjectionPredicate<'tcx>>,\n }\n \n-pub type BuiltinBounds = EnumSet<BuiltinBound>;\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub struct BuiltinBounds(EnumSet<BuiltinBound>);\n \n-#[derive(Clone, RustcEncodable, PartialEq, Eq, RustcDecodable, Hash,\n-           Debug, Copy)]\n-#[repr(usize)]\n-pub enum BuiltinBound {\n-    BoundSend,\n-    BoundSized,\n-    BoundCopy,\n-    BoundSync,\n+impl BuiltinBounds {\n+    pub fn empty() -> BuiltinBounds {\n+        BuiltinBounds(EnumSet::new())\n+    }\n+\n+    pub fn iter(&self) -> enum_set::Iter<BuiltinBound> {\n+        self.into_iter()\n+    }\n+}\n+\n+impl ops::Deref for BuiltinBounds {\n+    type Target = EnumSet<BuiltinBound>;\n+    fn deref(&self) -> &Self::Target { &self.0 }\n+}\n+\n+impl ops::DerefMut for BuiltinBounds {\n+    fn deref_mut(&mut self) -> &mut Self::Target { &mut self.0 }\n }\n \n-pub fn empty_builtin_bounds() -> BuiltinBounds {\n-    EnumSet::new()\n+impl<'a> IntoIterator for &'a BuiltinBounds {\n+    type Item = BuiltinBound;\n+    type IntoIter = enum_set::Iter<BuiltinBound>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        (**self).into_iter()\n+    }\n }\n \n-pub fn all_builtin_bounds() -> BuiltinBounds {\n-    let mut set = EnumSet::new();\n-    set.insert(BoundSend);\n-    set.insert(BoundSized);\n-    set.insert(BoundSync);\n-    set\n+#[derive(Clone, RustcEncodable, PartialEq, Eq, RustcDecodable, Hash,\n+           Debug, Copy)]\n+#[repr(usize)]\n+pub enum BuiltinBound {\n+    Send,\n+    Sized,\n+    Copy,\n+    Sync,\n }\n \n /// An existential bound that does not implement any traits.\n pub fn region_existential_bound<'tcx>(r: ty::Region) -> ExistentialBounds<'tcx> {\n     ty::ExistentialBounds { region_bound: r,\n-                            builtin_bounds: empty_builtin_bounds(),\n+                            builtin_bounds: BuiltinBounds::empty(),\n                             projection_bounds: Vec::new() }\n }\n \n@@ -1781,7 +1992,7 @@ impl cmp::PartialEq for InferRegion {\n }\n \n impl fmt::Debug for TyVid {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"_#{}t\", self.index)\n     }\n }\n@@ -1837,7 +2048,7 @@ impl fmt::Debug for IntVarValue {\n /// from `T:'a` annotations appearing in the type definition.  If\n /// this is `None`, then the default is inherited from the\n /// surrounding context. See RFC #599 for details.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone)]\n pub enum ObjectLifetimeDefault {\n     /// Require an explicit annotation. Occurs when multiple\n     /// `T:'a` constraints are found.\n@@ -1847,7 +2058,7 @@ pub enum ObjectLifetimeDefault {\n     Specific(Region),\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n pub struct TypeParameterDef<'tcx> {\n     pub name: ast::Name,\n     pub def_id: ast::DefId,\n@@ -1910,7 +2121,7 @@ impl<'tcx> Generics<'tcx> {\n }\n \n /// Bounds on generics.\n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n pub struct GenericPredicates<'tcx> {\n     pub predicates: VecPerParamSpace<Predicate<'tcx>>,\n }\n@@ -1940,7 +2151,7 @@ impl<'tcx> GenericPredicates<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash)]\n pub enum Predicate<'tcx> {\n     /// Corresponds to `where Foo : Bar<A,B,C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n@@ -2071,7 +2282,7 @@ impl<'tcx> Predicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash)]\n pub struct TraitPredicate<'tcx> {\n     pub trait_ref: TraitRef<'tcx>\n }\n@@ -2119,7 +2330,7 @@ pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, ty::R\n /// equality between arbitrary types. Processing an instance of Form\n /// #2 eventually yields one of these `ProjectionPredicate`\n /// instances to normalize the LHS.\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash)]\n pub struct ProjectionPredicate<'tcx> {\n     pub projection_ty: ProjectionTy<'tcx>,\n     pub ty: Ty<'tcx>,\n@@ -2308,7 +2519,7 @@ impl<'tcx> Predicate<'tcx> {\n /// `[[], [U:Bar<T>]]`.  Now if there were some particular reference\n /// like `Foo<isize,usize>`, then the `InstantiatedPredicates` would be `[[],\n /// [usize:Bar<isize>]]`.\n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n pub struct InstantiatedPredicates<'tcx> {\n     pub predicates: VecPerParamSpace<Predicate<'tcx>>,\n }\n@@ -2642,8 +2853,8 @@ impl<'tcx> TraitDef<'tcx> {\n                        tcx: &ctxt<'tcx>,\n                        impl_def_id: DefId,\n                        impl_trait_ref: TraitRef<'tcx>) {\n-        debug!(\"TraitDef::record_impl for {}, from {}\",\n-               self.repr(tcx), impl_trait_ref.repr(tcx));\n+        debug!(\"TraitDef::record_impl for {:?}, from {:?}\",\n+               self, impl_trait_ref);\n \n         // We don't want to borrow_mut after we already populated all impls,\n         // so check if an impl is present with an immutable borrow first.\n@@ -2811,20 +3022,26 @@ impl<'tcx> CommonTypes<'tcx> {\n     }\n }\n \n-pub fn mk_ctxt<'tcx>(s: Session,\n-                     arenas: &'tcx CtxtArenas<'tcx>,\n-                     def_map: DefMap,\n-                     named_region_map: resolve_lifetime::NamedRegionMap,\n-                     map: ast_map::Map<'tcx>,\n-                     freevars: RefCell<FreevarMap>,\n-                     region_maps: RegionMaps,\n-                     lang_items: middle::lang_items::LanguageItems,\n-                     stability: stability::Index<'tcx>) -> ctxt<'tcx>\n+/// Create a type context and call the closure with a `&ty::ctxt` reference\n+/// to the context. The closure enforces that the type context and any interned\n+/// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n+/// reference to the context, to allow formatting values that need it.\n+pub fn with_ctxt<'tcx, F, R>(s: Session,\n+                             arenas: &'tcx CtxtArenas<'tcx>,\n+                             def_map: DefMap,\n+                             named_region_map: resolve_lifetime::NamedRegionMap,\n+                             map: ast_map::Map<'tcx>,\n+                             freevars: RefCell<FreevarMap>,\n+                             region_maps: RegionMaps,\n+                             lang_items: middle::lang_items::LanguageItems,\n+                             stability: stability::Index<'tcx>,\n+                             f: F) -> (Session, R)\n+                             where F: FnOnce(&ctxt<'tcx>) -> R\n {\n     let mut interner = FnvHashMap();\n     let common_types = CommonTypes::new(&arenas.type_, &mut interner);\n \n-    ctxt {\n+    tls::enter(ctxt {\n         arenas: arenas,\n         interner: RefCell::new(interner),\n         substs_interner: RefCell::new(FnvHashMap()),\n@@ -2886,7 +3103,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         const_qualif_map: RefCell::new(NodeMap()),\n         custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n         cast_kinds: RefCell::new(NodeMap()),\n-   }\n+   }, f)\n }\n \n // Type constructors\n@@ -3490,7 +3707,7 @@ impl<'tcx> ItemSubsts<'tcx> {\n impl<'tcx> ParamBounds<'tcx> {\n     pub fn empty() -> ParamBounds<'tcx> {\n         ParamBounds {\n-            builtin_bounds: empty_builtin_bounds(),\n+            builtin_bounds: BuiltinBounds::empty(),\n             trait_bounds: Vec::new(),\n             region_bounds: Vec::new(),\n             projection_bounds: Vec::new(),\n@@ -3565,7 +3782,7 @@ pub fn sequence_element_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n         TyArray(ty, _) | TySlice(ty) => ty,\n         TyStr => mk_mach_uint(cx, ast::TyU8),\n         _ => cx.sess.bug(&format!(\"sequence_element_type called on non-sequence value: {}\",\n-                                 ty_to_string(cx, ty))),\n+                                  ty)),\n     }\n }\n \n@@ -4034,8 +4251,8 @@ fn type_impls_bound<'a,'tcx>(param_env: Option<&ParameterEnvironment<'a,'tcx>>,\n \n     let is_impld = traits::type_known_to_meet_builtin_bound(&infcx, param_env, ty, bound, span);\n \n-    debug!(\"type_impls_bound({}, {:?}) = {:?}\",\n-           ty.repr(tcx),\n+    debug!(\"type_impls_bound({:?}, {:?}) = {:?}\",\n+           ty,\n            bound,\n            is_impld);\n \n@@ -4137,23 +4354,19 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n     fn type_requires<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<DefId>,\n                            r_ty: Ty<'tcx>, ty: Ty<'tcx>) -> bool {\n         debug!(\"type_requires({:?}, {:?})?\",\n-               ::util::ppaux::ty_to_string(cx, r_ty),\n-               ::util::ppaux::ty_to_string(cx, ty));\n+               r_ty, ty);\n \n         let r = r_ty == ty || subtypes_require(cx, seen, r_ty, ty);\n \n         debug!(\"type_requires({:?}, {:?})? {:?}\",\n-               ::util::ppaux::ty_to_string(cx, r_ty),\n-               ::util::ppaux::ty_to_string(cx, ty),\n-               r);\n+               r_ty, ty, r);\n         return r;\n     }\n \n     fn subtypes_require<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<DefId>,\n                               r_ty: Ty<'tcx>, ty: Ty<'tcx>) -> bool {\n         debug!(\"subtypes_require({:?}, {:?})?\",\n-               ::util::ppaux::ty_to_string(cx, r_ty),\n-               ::util::ppaux::ty_to_string(cx, ty));\n+               r_ty, ty);\n \n         let r = match ty.sty {\n             // fixed length vectors need special treatment compared to\n@@ -4232,9 +4445,7 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n         };\n \n         debug!(\"subtypes_require({:?}, {:?})? {:?}\",\n-               ::util::ppaux::ty_to_string(cx, r_ty),\n-               ::util::ppaux::ty_to_string(cx, ty),\n-               r);\n+               r_ty, ty, r);\n \n         return r;\n     }\n@@ -4340,8 +4551,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n     fn is_type_structurally_recursive<'tcx>(cx: &ctxt<'tcx>, sp: Span,\n                                             seen: &mut Vec<Ty<'tcx>>,\n                                             ty: Ty<'tcx>) -> Representability {\n-        debug!(\"is_type_structurally_recursive: {:?}\",\n-               ::util::ppaux::ty_to_string(cx, ty));\n+        debug!(\"is_type_structurally_recursive: {:?}\", ty);\n \n         match ty.sty {\n             TyStruct(did, _) | TyEnum(did, _) => {\n@@ -4361,8 +4571,8 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n                         Some(&seen_type) => {\n                             if same_struct_or_enum_def_id(seen_type, did) {\n                                 debug!(\"SelfRecursive: {:?} contains {:?}\",\n-                                       ::util::ppaux::ty_to_string(cx, seen_type),\n-                                       ::util::ppaux::ty_to_string(cx, ty));\n+                                       seen_type,\n+                                       ty);\n                                 return SelfRecursive;\n                             }\n                         }\n@@ -4381,8 +4591,8 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n                     for &seen_type in iter {\n                         if same_type(ty, seen_type) {\n                             debug!(\"ContainsRecursive: {:?} contains {:?}\",\n-                                   ::util::ppaux::ty_to_string(cx, seen_type),\n-                                   ::util::ppaux::ty_to_string(cx, ty));\n+                                   seen_type,\n+                                   ty);\n                             return ContainsRecursive;\n                         }\n                     }\n@@ -4402,16 +4612,14 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n         }\n     }\n \n-    debug!(\"is_type_representable: {:?}\",\n-           ::util::ppaux::ty_to_string(cx, ty));\n+    debug!(\"is_type_representable: {:?}\", ty);\n \n     // To avoid a stack overflow when checking an enum variant or struct that\n     // contains a different, structurally recursive type, maintain a stack\n     // of seen types and check recursion for each of them (issues #3008, #3779).\n     let mut seen: Vec<Ty> = Vec::new();\n     let r = is_type_structurally_recursive(cx, sp, &mut seen, ty);\n-    debug!(\"is_type_representable: {:?} is {:?}\",\n-           ::util::ppaux::ty_to_string(cx, ty), r);\n+    debug!(\"is_type_representable: {:?} is {:?}\", ty, r);\n     r\n }\n \n@@ -4813,7 +5021,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                         _ => {\n                             cx.sess.bug(\n                                 &format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n-                                          {}\", unadjusted_ty.repr(cx)));\n+                                          {:?}\", unadjusted_ty));\n                         }\n                     }\n                 }\n@@ -4854,7 +5062,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                                         span,\n                                         &format!(\"the {}th autoderef failed: {}\",\n                                                 i,\n-                                                ty_to_string(cx, adjusted_ty))\n+                                                 adjusted_ty)\n                                         );\n                                 }\n                             }\n@@ -5096,13 +5304,11 @@ pub fn impl_or_trait_item_idx(id: ast::Name, trait_items: &[ImplOrTraitItem])\n     trait_items.iter().position(|m| m.name() == id)\n }\n \n-pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n+pub fn ty_sort_string(cx: &ctxt, ty: Ty) -> String {\n     match ty.sty {\n         TyBool | TyChar | TyInt(_) |\n-        TyUint(_) | TyFloat(_) | TyStr => {\n-            ::util::ppaux::ty_to_string(cx, ty)\n-        }\n-        TyTuple(ref tys) if tys.is_empty() => ::util::ppaux::ty_to_string(cx, ty),\n+        TyUint(_) | TyFloat(_) | TyStr => ty.to_string(),\n+        TyTuple(ref tys) if tys.is_empty() => ty.to_string(),\n \n         TyEnum(id, _) => format!(\"enum `{}`\", item_path_str(cx, id)),\n         TyBox(_) => \"box\".to_string(),\n@@ -5138,138 +5344,132 @@ pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::type_err<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        ty::type_err_to_str(tcx, self)\n-    }\n-}\n-\n /// Explains the source of a type err in a short, human readable way. This is meant to be placed\n /// in parentheses after some larger message. You should also invoke `note_and_explain_type_err()`\n /// afterwards to present additional details, particularly when it comes to lifetime-related\n /// errors.\n-pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n-    match *err {\n-        terr_cyclic_ty => \"cyclic type of infinite size\".to_string(),\n-        terr_mismatch => \"types differ\".to_string(),\n-        terr_unsafety_mismatch(values) => {\n-            format!(\"expected {} fn, found {} fn\",\n-                    values.expected,\n-                    values.found)\n-        }\n-        terr_abi_mismatch(values) => {\n-            format!(\"expected {} fn, found {} fn\",\n-                    values.expected,\n-                    values.found)\n-        }\n-        terr_mutability => \"values differ in mutability\".to_string(),\n-        terr_box_mutability => {\n-            \"boxed values differ in mutability\".to_string()\n-        }\n-        terr_vec_mutability => \"vectors differ in mutability\".to_string(),\n-        terr_ptr_mutability => \"pointers differ in mutability\".to_string(),\n-        terr_ref_mutability => \"references differ in mutability\".to_string(),\n-        terr_ty_param_size(values) => {\n-            format!(\"expected a type with {} type params, \\\n-                     found one with {} type params\",\n-                    values.expected,\n-                    values.found)\n-        }\n-        terr_fixed_array_size(values) => {\n-            format!(\"expected an array with a fixed size of {} elements, \\\n-                     found one with {} elements\",\n-                    values.expected,\n-                    values.found)\n-        }\n-        terr_tuple_size(values) => {\n-            format!(\"expected a tuple with {} elements, \\\n-                     found one with {} elements\",\n-                    values.expected,\n-                    values.found)\n-        }\n-        terr_arg_count => {\n-            \"incorrect number of function parameters\".to_string()\n-        }\n-        terr_regions_does_not_outlive(..) => {\n-            \"lifetime mismatch\".to_string()\n-        }\n-        terr_regions_not_same(..) => {\n-            \"lifetimes are not the same\".to_string()\n-        }\n-        terr_regions_no_overlap(..) => {\n-            \"lifetimes do not intersect\".to_string()\n-        }\n-        terr_regions_insufficiently_polymorphic(br, _) => {\n-            format!(\"expected bound lifetime parameter {}, \\\n-                     found concrete lifetime\",\n-                    bound_region_ptr_to_string(cx, br))\n-        }\n-        terr_regions_overly_polymorphic(br, _) => {\n-            format!(\"expected concrete lifetime, \\\n-                     found bound lifetime parameter {}\",\n-                    bound_region_ptr_to_string(cx, br))\n-        }\n-        terr_sorts(values) => {\n-            // A naive approach to making sure that we're not reporting silly errors such as:\n-            // (expected closure, found closure).\n-            let expected_str = ty_sort_string(cx, values.expected);\n-            let found_str = ty_sort_string(cx, values.found);\n-            if expected_str == found_str {\n-                format!(\"expected {}, found a different {}\", expected_str, found_str)\n-            } else {\n-                format!(\"expected {}, found {}\", expected_str, found_str)\n+impl<'tcx> fmt::Display for type_err<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            terr_cyclic_ty => write!(f, \"cyclic type of infinite size\"),\n+            terr_mismatch => write!(f, \"types differ\"),\n+            terr_unsafety_mismatch(values) => {\n+                write!(f, \"expected {} fn, found {} fn\",\n+                       values.expected,\n+                       values.found)\n             }\n-        }\n-        terr_traits(values) => {\n-            format!(\"expected trait `{}`, found trait `{}`\",\n-                    item_path_str(cx, values.expected),\n-                    item_path_str(cx, values.found))\n-        }\n-        terr_builtin_bounds(values) => {\n-            if values.expected.is_empty() {\n-                format!(\"expected no bounds, found `{}`\",\n-                        values.found.user_string(cx))\n-            } else if values.found.is_empty() {\n-                format!(\"expected bounds `{}`, found no bounds\",\n-                        values.expected.user_string(cx))\n-            } else {\n-                format!(\"expected bounds `{}`, found bounds `{}`\",\n-                        values.expected.user_string(cx),\n-                        values.found.user_string(cx))\n+            terr_abi_mismatch(values) => {\n+                write!(f, \"expected {} fn, found {} fn\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            terr_mutability => write!(f, \"values differ in mutability\"),\n+            terr_box_mutability => {\n+                write!(f, \"boxed values differ in mutability\")\n+            }\n+            terr_vec_mutability => write!(f, \"vectors differ in mutability\"),\n+            terr_ptr_mutability => write!(f, \"pointers differ in mutability\"),\n+            terr_ref_mutability => write!(f, \"references differ in mutability\"),\n+            terr_ty_param_size(values) => {\n+                write!(f, \"expected a type with {} type params, \\\n+                           found one with {} type params\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            terr_fixed_array_size(values) => {\n+                write!(f, \"expected an array with a fixed size of {} elements, \\\n+                           found one with {} elements\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            terr_tuple_size(values) => {\n+                write!(f, \"expected a tuple with {} elements, \\\n+                           found one with {} elements\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            terr_arg_count => {\n+                write!(f, \"incorrect number of function parameters\")\n+            }\n+            terr_regions_does_not_outlive(..) => {\n+                write!(f, \"lifetime mismatch\")\n+            }\n+            terr_regions_not_same(..) => {\n+                write!(f, \"lifetimes are not the same\")\n+            }\n+            terr_regions_no_overlap(..) => {\n+                write!(f, \"lifetimes do not intersect\")\n+            }\n+            terr_regions_insufficiently_polymorphic(br, _) => {\n+                write!(f, \"expected bound lifetime parameter {}, \\\n+                           found concrete lifetime\", br)\n+            }\n+            terr_regions_overly_polymorphic(br, _) => {\n+                write!(f, \"expected concrete lifetime, \\\n+                           found bound lifetime parameter {}\", br)\n+            }\n+            terr_sorts(values) => tls::with(|tcx| {\n+                // A naive approach to making sure that we're not reporting silly errors such as:\n+                // (expected closure, found closure).\n+                let expected_str = ty_sort_string(tcx, values.expected);\n+                let found_str = ty_sort_string(tcx, values.found);\n+                if expected_str == found_str {\n+                    write!(f, \"expected {}, found a different {}\", expected_str, found_str)\n+                } else {\n+                    write!(f, \"expected {}, found {}\", expected_str, found_str)\n+                }\n+            }),\n+            terr_traits(values) => tls::with(|tcx| {\n+                write!(f, \"expected trait `{}`, found trait `{}`\",\n+                       item_path_str(tcx, values.expected),\n+                       item_path_str(tcx, values.found))\n+            }),\n+            terr_builtin_bounds(values) => {\n+                if values.expected.is_empty() {\n+                    write!(f, \"expected no bounds, found `{}`\",\n+                           values.found)\n+                } else if values.found.is_empty() {\n+                    write!(f, \"expected bounds `{}`, found no bounds\",\n+                           values.expected)\n+                } else {\n+                    write!(f, \"expected bounds `{}`, found bounds `{}`\",\n+                           values.expected,\n+                           values.found)\n+                }\n+            }\n+            terr_integer_as_char => {\n+                write!(f, \"expected an integral type, found `char`\")\n+            }\n+            terr_int_mismatch(ref values) => {\n+                write!(f, \"expected `{:?}`, found `{:?}`\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            terr_float_mismatch(ref values) => {\n+                write!(f, \"expected `{:?}`, found `{:?}`\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            terr_variadic_mismatch(ref values) => {\n+                write!(f, \"expected {} fn, found {} function\",\n+                       if values.expected { \"variadic\" } else { \"non-variadic\" },\n+                       if values.found { \"variadic\" } else { \"non-variadic\" })\n+            }\n+            terr_convergence_mismatch(ref values) => {\n+                write!(f, \"expected {} fn, found {} function\",\n+                       if values.expected { \"converging\" } else { \"diverging\" },\n+                       if values.found { \"converging\" } else { \"diverging\" })\n+            }\n+            terr_projection_name_mismatched(ref values) => {\n+                write!(f, \"expected {}, found {}\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            terr_projection_bounds_length(ref values) => {\n+                write!(f, \"expected {} associated type bindings, found {}\",\n+                       values.expected,\n+                       values.found)\n             }\n-        }\n-        terr_integer_as_char => {\n-            \"expected an integral type, found `char`\".to_string()\n-        }\n-        terr_int_mismatch(ref values) => {\n-            format!(\"expected `{:?}`, found `{:?}`\",\n-                    values.expected,\n-                    values.found)\n-        }\n-        terr_float_mismatch(ref values) => {\n-            format!(\"expected `{:?}`, found `{:?}`\",\n-                    values.expected,\n-                    values.found)\n-        }\n-        terr_variadic_mismatch(ref values) => {\n-            format!(\"expected {} fn, found {} function\",\n-                    if values.expected { \"variadic\" } else { \"non-variadic\" },\n-                    if values.found { \"variadic\" } else { \"non-variadic\" })\n-        }\n-        terr_convergence_mismatch(ref values) => {\n-            format!(\"expected {} fn, found {} function\",\n-                    if values.expected { \"converging\" } else { \"diverging\" },\n-                    if values.found { \"converging\" } else { \"diverging\" })\n-        }\n-        terr_projection_name_mismatched(ref values) => {\n-            format!(\"expected {}, found {}\",\n-                    token::get_name(values.expected),\n-                    token::get_name(values.found))\n-        }\n-        terr_projection_bounds_length(ref values) => {\n-            format!(\"expected {} associated type bindings, found {}\",\n-                    values.expected,\n-                    values.found)\n         }\n     }\n }\n@@ -5876,7 +6076,7 @@ fn report_discrim_overflow(cx: &ctxt,\n     let computed_value = repr_type.disr_wrap_incr(Some(prev_val));\n     let computed_value = repr_type.disr_string(computed_value);\n     let prev_val = repr_type.disr_string(prev_val);\n-    let repr_type = repr_type.to_ty(cx).user_string(cx);\n+    let repr_type = repr_type.to_ty(cx);\n     span_err!(cx.sess, variant_span, E0370,\n               \"enum discriminant overflowed on value after {}: {}; \\\n                set explicitly via {} = {} if that is desired outcome\",\n@@ -6369,8 +6569,8 @@ pub fn required_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n                                     -> Vec<ty::Region>\n {\n     debug!(\"required_region_bounds(erased_self_ty={:?}, predicates={:?})\",\n-           erased_self_ty.repr(tcx),\n-           predicates.repr(tcx));\n+           erased_self_ty,\n+           predicates);\n \n     assert!(!erased_self_ty.has_escaping_regions());\n \n@@ -6488,7 +6688,7 @@ pub fn populate_implementations_for_trait_if_necessary(tcx: &ctxt, trait_id: ast\n         return;\n     }\n \n-    debug!(\"populate_implementations_for_trait_if_necessary: searching for {}\", def.repr(tcx));\n+    debug!(\"populate_implementations_for_trait_if_necessary: searching for {:?}\", def);\n \n     if csearch::is_defaulted_trait(&tcx.sess.cstore, trait_id) {\n         record_trait_has_default_impl(tcx, trait_id);\n@@ -6736,14 +6936,14 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n     }\n }\n \n-impl Variance {\n-    pub fn to_string(self) -> &'static str {\n-        match self {\n+impl fmt::Debug for Variance {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(match *self {\n             Covariant => \"+\",\n             Contravariant => \"-\",\n             Invariant => \"o\",\n             Bivariant => \"*\",\n-        }\n+        })\n     }\n }\n \n@@ -6797,7 +6997,7 @@ pub fn construct_free_substs<'a,'tcx>(\n                                   defs: &[TypeParameterDef<'tcx>]) {\n         for def in defs {\n             debug!(\"construct_parameter_environment(): push_types_from_defs: def={:?}\",\n-                   def.repr(tcx));\n+                   def);\n             let ty = ty::mk_param_from_def(tcx, def);\n             types.push(def.space, ty);\n        }\n@@ -6830,8 +7030,8 @@ pub fn construct_parameter_environment<'a,'tcx>(\n \n     debug!(\"construct_parameter_environment: free_id={:?} free_subst={:?} predicates={:?}\",\n            free_id,\n-           free_substs.repr(tcx),\n-           predicates.repr(tcx));\n+           free_substs,\n+           predicates);\n \n     //\n     // Finally, we have to normalize the bounds in the environment, in\n@@ -7087,7 +7287,7 @@ pub fn liberate_late_bound_regions<'tcx, T>(\n     all_outlive_scope: region::DestructionScopeData,\n     value: &Binder<T>)\n     -> T\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    where T : TypeFoldable<'tcx>\n {\n     ty_fold::replace_late_bound_regions(\n         tcx, value,\n@@ -7098,7 +7298,7 @@ pub fn count_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     value: &Binder<T>)\n     -> usize\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    where T : TypeFoldable<'tcx>\n {\n     let (_, skol_map) = ty_fold::replace_late_bound_regions(tcx, value, |_| ty::ReStatic);\n     skol_map.len()\n@@ -7108,7 +7308,7 @@ pub fn binds_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     value: &Binder<T>)\n     -> bool\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    where T : TypeFoldable<'tcx>\n {\n     count_late_bound_regions(tcx, value) > 0\n }\n@@ -7119,7 +7319,7 @@ pub fn flatten_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     bound2_value: &Binder<Binder<T>>)\n     -> Binder<T>\n-    where T: TypeFoldable<'tcx> + Repr<'tcx>\n+    where T: TypeFoldable<'tcx>\n {\n     let bound0_value = bound2_value.skip_binder().skip_binder();\n     let value = ty_fold::fold_regions(tcx, bound0_value, |region, current_depth| {\n@@ -7141,7 +7341,7 @@ pub fn no_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     value: &Binder<T>)\n     -> Option<T>\n-    where T : TypeFoldable<'tcx> + Repr<'tcx> + Clone\n+    where T : TypeFoldable<'tcx>\n {\n     if binds_late_bound_regions(tcx, value) {\n         None\n@@ -7156,7 +7356,7 @@ pub fn erase_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     value: &Binder<T>)\n     -> T\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    where T : TypeFoldable<'tcx>\n {\n     ty_fold::replace_late_bound_regions(tcx, value, |_| ty::ReStatic).0\n }\n@@ -7173,7 +7373,7 @@ pub fn anonymize_late_bound_regions<'tcx, T>(\n     tcx: &ctxt<'tcx>,\n     sig: &Binder<T>)\n     -> Binder<T>\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>,\n+    where T : TypeFoldable<'tcx>,\n {\n     let mut counter = 0;\n     ty::Binder(ty_fold::replace_late_bound_regions(tcx, sig, |_| {\n@@ -7193,58 +7393,45 @@ impl DebruijnIndex {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for AutoAdjustment<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> fmt::Debug for AutoAdjustment<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             AdjustReifyFnPointer => {\n-                format!(\"AdjustReifyFnPointer\")\n+                write!(f, \"AdjustReifyFnPointer\")\n             }\n             AdjustUnsafeFnPointer => {\n-                format!(\"AdjustUnsafeFnPointer\")\n+                write!(f, \"AdjustUnsafeFnPointer\")\n             }\n             AdjustDerefRef(ref data) => {\n-                data.repr(tcx)\n+                write!(f, \"{:?}\", data)\n             }\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for AutoDerefRef<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"AutoDerefRef({}, unsize={}, {})\",\n-                self.autoderefs, self.unsize.repr(tcx), self.autoref.repr(tcx))\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for AutoRef<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        match *self {\n-            AutoPtr(a, b) => {\n-                format!(\"AutoPtr({},{:?})\", a.repr(tcx), b)\n-            }\n-            AutoUnsafe(ref a) => {\n-                format!(\"AutoUnsafe({:?})\", a)\n-            }\n-        }\n+impl<'tcx> fmt::Debug for AutoDerefRef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"AutoDerefRef({}, unsize={:?}, {:?})\",\n+               self.autoderefs, self.unsize, self.autoref)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for TraitTy<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"TraitTy({},{})\",\n-                self.principal.repr(tcx),\n-                self.bounds.repr(tcx))\n+impl<'tcx> fmt::Debug for TraitTy<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"TraitTy({:?},{:?})\",\n+               self.principal,\n+               self.bounds)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::Predicate<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> fmt::Debug for ty::Predicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            Predicate::Trait(ref a) => a.repr(tcx),\n-            Predicate::Equate(ref pair) => pair.repr(tcx),\n-            Predicate::RegionOutlives(ref pair) => pair.repr(tcx),\n-            Predicate::TypeOutlives(ref pair) => pair.repr(tcx),\n-            Predicate::Projection(ref pair) => pair.repr(tcx),\n+            Predicate::Trait(ref a) => write!(f, \"{:?}\", a),\n+            Predicate::Equate(ref pair) => write!(f, \"{:?}\", pair),\n+            Predicate::RegionOutlives(ref pair) => write!(f, \"{:?}\", pair),\n+            Predicate::TypeOutlives(ref pair) => write!(f, \"{:?}\", pair),\n+            Predicate::Projection(ref pair) => write!(f, \"{:?}\", pair),\n         }\n     }\n }\n@@ -7450,14 +7637,6 @@ impl<'tcx> RegionEscape for ProjectionTy<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ProjectionPredicate<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"ProjectionPredicate({}, {})\",\n-                self.projection_ty.repr(tcx),\n-                self.ty.repr(tcx))\n-    }\n-}\n-\n pub trait HasProjectionTypes {\n     fn has_projection_types(&self) -> bool;\n }\n@@ -7692,48 +7871,46 @@ impl ReferencesError for Region\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ClosureTy<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"ClosureTy({},{},{})\",\n-                self.unsafety,\n-                self.sig.repr(tcx),\n-                self.abi)\n+impl<'tcx> fmt::Debug for ClosureTy<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ClosureTy({},{:?},{})\",\n+               self.unsafety,\n+               self.sig,\n+               self.abi)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ClosureUpvar<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"ClosureUpvar({},{})\",\n-                self.def.repr(tcx),\n-                self.ty.repr(tcx))\n+impl<'tcx> fmt::Debug for ClosureUpvar<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ClosureUpvar({:?},{:?})\",\n+               self.def,\n+               self.ty)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for field<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"field({},{})\",\n-                self.name.repr(tcx),\n-                self.mt.repr(tcx))\n+impl<'tcx> fmt::Debug for field<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"field({},{})\", self.name, self.mt)\n     }\n }\n \n-impl<'a, 'tcx> Repr<'tcx> for ParameterEnvironment<'a, 'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"ParameterEnvironment(\\\n-            free_substs={}, \\\n-            implicit_region_bound={}, \\\n-            caller_bounds={})\",\n-            self.free_substs.repr(tcx),\n-            self.implicit_region_bound.repr(tcx),\n-            self.caller_bounds.repr(tcx))\n+impl<'a, 'tcx> fmt::Debug for ParameterEnvironment<'a, 'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ParameterEnvironment(\\\n+            free_substs={:?}, \\\n+            implicit_region_bound={:?}, \\\n+            caller_bounds={:?})\",\n+            self.free_substs,\n+            self.implicit_region_bound,\n+            self.caller_bounds)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ObjectLifetimeDefault {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> fmt::Debug for ObjectLifetimeDefault {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            ObjectLifetimeDefault::Ambiguous => format!(\"Ambiguous\"),\n-            ObjectLifetimeDefault::Specific(ref r) => r.repr(tcx),\n+            ObjectLifetimeDefault::Ambiguous => write!(f, \"Ambiguous\"),\n+            ObjectLifetimeDefault::Specific(ref r) => write!(f, \"{:?}\", r),\n         }\n     }\n }"}, {"sha": "63c46032479a4f775bd3fbcb088a868a700aef8e", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -38,19 +38,20 @@ use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::ty::{self, Ty};\n use middle::traits;\n+\n+use std::fmt;\n use std::rc::Rc;\n use syntax::abi;\n use syntax::ast;\n use syntax::owned_slice::OwnedSlice;\n use util::nodemap::FnvHashMap;\n-use util::ppaux::Repr;\n \n ///////////////////////////////////////////////////////////////////////////\n // Two generic traits\n \n /// The TypeFoldable trait is implemented for every type that can be folded.\n /// Basically, every type that has a corresponding method in TypeFolder.\n-pub trait TypeFoldable<'tcx>: Repr<'tcx> + Clone {\n+pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n }\n \n@@ -74,7 +75,7 @@ pub trait TypeFolder<'tcx> : Sized {\n     fn exit_region_binder(&mut self) { }\n \n     fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n-        where T : TypeFoldable<'tcx> + Repr<'tcx> + Clone\n+        where T : TypeFoldable<'tcx>\n     {\n         // FIXME(#20526) this should replace `enter_region_binder`/`exit_region_binder`.\n         super_fold_binder(self, t)\n@@ -197,7 +198,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n     }\n }\n \n-impl<'tcx, T:TypeFoldable<'tcx>+Repr<'tcx>+Clone> TypeFoldable<'tcx> for ty::Binder<T> {\n+impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n         folder.fold_binder(self)\n     }\n@@ -842,13 +843,13 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n         match r {\n             ty::ReLateBound(debruijn, _) if debruijn.depth < self.current_depth => {\n-                debug!(\"RegionFolder.fold_region({}) skipped bound region (current depth={})\",\n-                       r.repr(self.tcx()), self.current_depth);\n+                debug!(\"RegionFolder.fold_region({:?}) skipped bound region (current depth={})\",\n+                       r, self.current_depth);\n                 r\n             }\n             _ => {\n-                debug!(\"RegionFolder.fold_region({}) folding free region (current_depth={})\",\n-                       r.repr(self.tcx()), self.current_depth);\n+                debug!(\"RegionFolder.fold_region({:?}) folding free region (current_depth={})\",\n+                       r, self.current_depth);\n                 (self.fld_r)(r, self.current_depth)\n             }\n         }\n@@ -885,9 +886,9 @@ pub fn replace_late_bound_regions<'tcx,T,F>(tcx: &ty::ctxt<'tcx>,\n                                             mut f: F)\n                                             -> (T, FnvHashMap<ty::BoundRegion, ty::Region>)\n     where F : FnMut(ty::BoundRegion) -> ty::Region,\n-          T : TypeFoldable<'tcx> + Repr<'tcx>,\n+          T : TypeFoldable<'tcx>,\n {\n-    debug!(\"replace_late_bound_regions({})\", value.repr(tcx));\n+    debug!(\"replace_late_bound_regions({:?})\", value);\n     let mut replacer = RegionReplacer::new(tcx, &mut f);\n     let result = value.skip_binder().fold_with(&mut replacer);\n     (result, replacer.map)\n@@ -916,8 +917,8 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx>\n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n         match r {\n             ty::ReLateBound(debruijn, br) if debruijn.depth == self.current_depth => {\n-                debug!(\"RegionReplacer.fold_region({}) folding region (current_depth={})\",\n-                       r.repr(self.tcx()), self.current_depth);\n+                debug!(\"RegionReplacer.fold_region({:?}) folding region (current_depth={})\",\n+                       r, self.current_depth);\n                 let fld_r = &mut self.fld_r;\n                 let region = *self.map.entry(br).or_insert_with(|| fld_r(br));\n                 if let ty::ReLateBound(debruijn1, br) = region {\n@@ -994,10 +995,10 @@ pub fn shift_region(region: ty::Region, amount: u32) -> ty::Region {\n     }\n }\n \n-pub fn shift_regions<'tcx, T:TypeFoldable<'tcx>+Repr<'tcx>>(tcx: &ty::ctxt<'tcx>,\n-                                                            amount: u32, value: &T) -> T {\n-    debug!(\"shift_regions(value={}, amount={})\",\n-           value.repr(tcx), amount);\n+pub fn shift_regions<'tcx, T:TypeFoldable<'tcx>>(tcx: &ty::ctxt<'tcx>,\n+                                                 amount: u32, value: &T) -> T {\n+    debug!(\"shift_regions(value={:?}, amount={})\",\n+           value, amount);\n \n     value.fold_with(&mut RegionFolder::new(tcx, &mut |region, _current_depth| {\n         shift_region(region, amount)"}, {"sha": "135118820a771fae4eada9a2be38175051916c9a", "filename": "src/librustc/middle/ty_match.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fty_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fty_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_match.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -10,7 +10,6 @@\n \n use middle::ty::{self, Ty};\n use middle::ty_relate::{self, Relate, TypeRelation, RelateResult};\n-use util::ppaux::Repr;\n \n /// A type \"A\" *matches* \"B\" if the fresh types in B could be\n /// substituted with values so as to make it equal to A. Matching is\n@@ -53,16 +52,16 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Match<'a, 'tcx> {\n     }\n \n     fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n-        debug!(\"{}.regions({}, {})\",\n+        debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()));\n+               a,\n+               b);\n         Ok(a)\n     }\n \n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"{}.tys({}, {})\", self.tag(),\n-               a.repr(self.tcx()), b.repr(self.tcx()));\n+        debug!(\"{}.tys({:?}, {:?})\", self.tag(),\n+               a, b);\n         if a == b { return Ok(a); }\n \n         match (&a.sty, &b.sty) {"}, {"sha": "b8c212fe3f20b1a33296890628c93c0dd895b5ed", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -19,7 +19,6 @@ use middle::ty_fold::TypeFoldable;\n use std::rc::Rc;\n use syntax::abi;\n use syntax::ast;\n-use util::ppaux::Repr;\n \n pub type RelateResult<'tcx, T> = Result<T, ty::type_err<'tcx>>;\n \n@@ -79,10 +78,10 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::mt<'tcx> {\n                  -> RelateResult<'tcx, ty::mt<'tcx>>\n         where R: TypeRelation<'a,'tcx>\n     {\n-        debug!(\"{}.mts({}, {})\",\n+        debug!(\"{}.mts({:?}, {:?})\",\n                relation.tag(),\n-               a.repr(relation.tcx()),\n-               b.repr(relation.tcx()));\n+               a,\n+               b);\n         if a.mutbl != b.mutbl {\n             Err(ty::terr_mutability)\n         } else {\n@@ -107,10 +106,10 @@ fn relate_item_substs<'a,'tcx:'a,R>(relation: &mut R,\n                                     -> RelateResult<'tcx, Substs<'tcx>>\n     where R: TypeRelation<'a,'tcx>\n {\n-    debug!(\"substs: item_def_id={} a_subst={} b_subst={}\",\n-           item_def_id.repr(relation.tcx()),\n-           a_subst.repr(relation.tcx()),\n-           b_subst.repr(relation.tcx()));\n+    debug!(\"substs: item_def_id={:?} a_subst={:?} b_subst={:?}\",\n+           item_def_id,\n+           a_subst,\n+           b_subst);\n \n     let variances;\n     let opt_variances = if relation.tcx().variance_computed.get() {\n@@ -191,14 +190,13 @@ fn relate_region_params<'a,'tcx:'a,R>(relation: &mut R,\n                                       -> RelateResult<'tcx, Vec<ty::Region>>\n     where R: TypeRelation<'a,'tcx>\n {\n-    let tcx = relation.tcx();\n     let num_region_params = a_rs.len();\n \n-    debug!(\"relate_region_params(a_rs={}, \\\n-            b_rs={}, variances={})\",\n-           a_rs.repr(tcx),\n-           b_rs.repr(tcx),\n-           variances.repr(tcx));\n+    debug!(\"relate_region_params(a_rs={:?}, \\\n+            b_rs={:?}, variances={:?})\",\n+           a_rs,\n+           b_rs,\n+           variances);\n \n     assert_eq!(num_region_params,\n                variances.map_or(num_region_params,"}, {"sha": "485d856ac2508a914e3c2e65e5c2621a71c0d07c", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 547, "deletions": 1261, "changes": 1808, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -9,16 +9,12 @@\n // except according to those terms.\n \n \n-use ast_map;\n-use middle::def;\n-use middle::region;\n-use middle::subst::{VecPerParamSpace,Subst};\n-use middle::subst;\n+use middle::subst::{self, Subst};\n use middle::ty::{BoundRegion, BrAnon, BrNamed};\n use middle::ty::{ReEarlyBound, BrFresh, ctxt};\n use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region, ReEmpty};\n use middle::ty::{ReSkolemized, ReVar, BrEnv};\n-use middle::ty::{mt, Ty, ParamTy};\n+use middle::ty::{mt, Ty};\n use middle::ty::{TyBool, TyChar, TyStruct, TyEnum};\n use middle::ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyBareFn};\n use middle::ty::{TyParam, TyRawPtr, TyRef, TyTuple};\n@@ -27,484 +23,117 @@ use middle::ty::{TyBox, TyTrait, TyInt, TyUint, TyInfer};\n use middle::ty;\n use middle::ty_fold::{self, TypeFoldable};\n \n-use std::collections::HashMap;\n-use std::collections::hash_state::HashState;\n-use std::hash::Hash;\n-use std::rc::Rc;\n+use std::fmt;\n use syntax::abi;\n-use syntax::codemap::{Span, Pos};\n use syntax::parse::token;\n-use syntax::print::pprust;\n-use syntax::ptr::P;\n use syntax::{ast, ast_util};\n-use syntax::owned_slice::OwnedSlice;\n \n-/// Produces a string suitable for debugging output.\n-pub trait Repr<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String;\n+pub fn verbose() -> bool {\n+    ty::tls::with(|tcx| tcx.sess.verbose())\n }\n \n-/// Produces a string suitable for showing to the user.\n-pub trait UserString<'tcx> : Repr<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String;\n-}\n-\n-pub fn note_and_explain_region(cx: &ctxt,\n-                               prefix: &str,\n-                               region: ty::Region,\n-                               suffix: &str) -> Option<Span> {\n-    match explain_region_and_span(cx, region) {\n-      (ref str, Some(span)) => {\n-        cx.sess.span_note(\n-            span,\n-            &format!(\"{}{}{}\", prefix, *str, suffix));\n-        Some(span)\n-      }\n-      (ref str, None) => {\n-        cx.sess.note(\n-            &format!(\"{}{}{}\", prefix, *str, suffix));\n-        None\n-      }\n-    }\n-}\n-\n-/// When a free region is associated with `item`, how should we describe the item in the error\n-/// message.\n-fn item_scope_tag(item: &ast::Item) -> &'static str {\n-    match item.node {\n-        ast::ItemImpl(..) => \"impl\",\n-        ast::ItemStruct(..) => \"struct\",\n-        ast::ItemEnum(..) => \"enum\",\n-        ast::ItemTrait(..) => \"trait\",\n-        ast::ItemFn(..) => \"function body\",\n-        _ => \"item\"\n-    }\n-}\n-\n-pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n-                            -> (String, Option<Span>) {\n-    return match region {\n-      ReScope(scope) => {\n-        let new_string;\n-        let on_unknown_scope = || {\n-          (format!(\"unknown scope: {:?}.  Please report a bug.\", scope), None)\n-        };\n-        let span = match scope.span(&cx.map) {\n-          Some(s) => s,\n-          None => return on_unknown_scope(),\n-        };\n-        let tag = match cx.map.find(scope.node_id()) {\n-          Some(ast_map::NodeBlock(_)) => \"block\",\n-          Some(ast_map::NodeExpr(expr)) => match expr.node {\n-              ast::ExprCall(..) => \"call\",\n-              ast::ExprMethodCall(..) => \"method call\",\n-              ast::ExprMatch(_, _, ast::MatchSource::IfLetDesugar { .. }) => \"if let\",\n-              ast::ExprMatch(_, _, ast::MatchSource::WhileLetDesugar) =>  \"while let\",\n-              ast::ExprMatch(_, _, ast::MatchSource::ForLoopDesugar) =>  \"for\",\n-              ast::ExprMatch(..) => \"match\",\n-              _ => \"expression\",\n-          },\n-          Some(ast_map::NodeStmt(_)) => \"statement\",\n-          Some(ast_map::NodeItem(it)) => item_scope_tag(&*it),\n-          Some(_) | None => {\n-            // this really should not happen\n-            return on_unknown_scope();\n-          }\n-        };\n-        let scope_decorated_tag = match scope {\n-            region::CodeExtent::Misc(_) => tag,\n-            region::CodeExtent::ParameterScope { .. } => {\n-                \"scope of parameters for function\"\n-            }\n-            region::CodeExtent::DestructionScope(_) => {\n-                new_string = format!(\"destruction scope surrounding {}\", tag);\n-                &*new_string\n-            }\n-            region::CodeExtent::Remainder(r) => {\n-                new_string = format!(\"block suffix following statement {}\",\n-                                     r.first_statement_index);\n-                &*new_string\n-            }\n-        };\n-        explain_span(cx, scope_decorated_tag, span)\n-\n-      }\n-\n-      ReFree(ref fr) => {\n-        let prefix = match fr.bound_region {\n-          BrAnon(idx) => {\n-              format!(\"the anonymous lifetime #{} defined on\", idx + 1)\n-          }\n-          BrFresh(_) => \"an anonymous lifetime defined on\".to_string(),\n-          _ => {\n-              format!(\"the lifetime {} as defined on\",\n-                      bound_region_ptr_to_string(cx, fr.bound_region))\n-          }\n-        };\n-\n-        match cx.map.find(fr.scope.node_id) {\n-          Some(ast_map::NodeBlock(ref blk)) => {\n-              let (msg, opt_span) = explain_span(cx, \"block\", blk.span);\n-              (format!(\"{} {}\", prefix, msg), opt_span)\n-          }\n-          Some(ast_map::NodeItem(it)) => {\n-              let tag = item_scope_tag(&*it);\n-              let (msg, opt_span) = explain_span(cx, tag, it.span);\n-              (format!(\"{} {}\", prefix, msg), opt_span)\n-          }\n-          Some(_) | None => {\n-              // this really should not happen\n-              (format!(\"{} unknown free region bounded by scope {:?}\", prefix, fr.scope), None)\n-          }\n+fn fn_sig(f: &mut fmt::Formatter,\n+          inputs: &[Ty],\n+          variadic: bool,\n+          output: ty::FnOutput)\n+          -> fmt::Result {\n+    try!(write!(f, \"(\"));\n+    let mut inputs = inputs.iter();\n+    if let Some(&ty) = inputs.next() {\n+        try!(write!(f, \"{}\", ty));\n+        for &ty in inputs {\n+            try!(write!(f, \", {}\", ty));\n         }\n-      }\n-\n-      ReStatic => { (\"the static lifetime\".to_string(), None) }\n-\n-      ReEmpty => { (\"the empty lifetime\".to_string(), None) }\n-\n-      ReEarlyBound(ref data) => {\n-        (format!(\"{}\", token::get_name(data.name)), None)\n-      }\n-\n-      // I believe these cases should not occur (except when debugging,\n-      // perhaps)\n-      ty::ReInfer(_) | ty::ReLateBound(..) => {\n-        (format!(\"lifetime {:?}\", region), None)\n-      }\n-    };\n-\n-    fn explain_span(cx: &ctxt, heading: &str, span: Span)\n-                    -> (String, Option<Span>) {\n-        let lo = cx.sess.codemap().lookup_char_pos_adj(span.lo);\n-        (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize()),\n-         Some(span))\n-    }\n-}\n-\n-pub fn bound_region_ptr_to_string(cx: &ctxt, br: BoundRegion) -> String {\n-    bound_region_to_string(cx, \"\", false, br)\n-}\n-\n-pub fn bound_region_to_string(cx: &ctxt,\n-                           prefix: &str, space: bool,\n-                           br: BoundRegion) -> String {\n-    let space_str = if space { \" \" } else { \"\" };\n-\n-    if cx.sess.verbose() {\n-        return format!(\"{}{}{}\", prefix, br.repr(cx), space_str)\n-    }\n-\n-    match br {\n-        BrNamed(_, name) => {\n-            format!(\"{}{}{}\", prefix, token::get_name(name), space_str)\n+        if variadic {\n+            try!(write!(f, \", ...\"));\n         }\n-        BrAnon(_) | BrFresh(_) | BrEnv => prefix.to_string()\n-    }\n-}\n-\n-// In general, if you are giving a region error message,\n-// you should use `explain_region()` or, better yet,\n-// `note_and_explain_region()`\n-pub fn region_ptr_to_string(cx: &ctxt, region: Region) -> String {\n-    region_to_string(cx, \"&\", true, region)\n-}\n-\n-pub fn region_to_string(cx: &ctxt, prefix: &str, space: bool, region: Region) -> String {\n-    let space_str = if space { \" \" } else { \"\" };\n-\n-    if cx.sess.verbose() {\n-        return format!(\"{}{}{}\", prefix, region.repr(cx), space_str)\n     }\n+    try!(write!(f, \")\"));\n \n-    // These printouts are concise.  They do not contain all the information\n-    // the user might want to diagnose an error, but there is basically no way\n-    // to fit that into a short string.  Hence the recommendation to use\n-    // `explain_region()` or `note_and_explain_region()`.\n-    match region {\n-        ty::ReScope(_) => prefix.to_string(),\n-        ty::ReEarlyBound(ref data) => {\n-            token::get_name(data.name).to_string()\n+    match output {\n+        ty::FnConverging(ty) => {\n+            if !ty::type_is_nil(ty) {\n+                try!(write!(f, \" -> {}\", ty));\n+            }\n+            Ok(())\n         }\n-        ty::ReLateBound(_, br) => bound_region_to_string(cx, prefix, space, br),\n-        ty::ReFree(ref fr) => bound_region_to_string(cx, prefix, space, fr.bound_region),\n-        ty::ReInfer(ReSkolemized(_, br)) => {\n-            bound_region_to_string(cx, prefix, space, br)\n+        ty::FnDiverging => {\n+            write!(f, \" -> !\")\n         }\n-        ty::ReInfer(ReVar(_)) => prefix.to_string(),\n-        ty::ReStatic => format!(\"{}'static{}\", prefix, space_str),\n-        ty::ReEmpty => format!(\"{}'<empty>{}\", prefix, space_str),\n     }\n }\n \n-pub fn mutability_to_string(m: ast::Mutability) -> String {\n-    match m {\n-        ast::MutMutable => \"mut \".to_string(),\n-        ast::MutImmutable => \"\".to_string(),\n-    }\n-}\n-\n-pub fn mt_to_string<'tcx>(cx: &ctxt<'tcx>, m: &mt<'tcx>) -> String {\n-    format!(\"{}{}\",\n-        mutability_to_string(m.mutbl),\n-        ty_to_string(cx, m.ty))\n-}\n-\n-pub fn vec_map_to_string<T, F>(ts: &[T], f: F) -> String where\n-    F: FnMut(&T) -> String,\n+fn parameterized<GG>(f: &mut fmt::Formatter,\n+                     substs: &subst::Substs,\n+                     did: ast::DefId,\n+                     projections: &[ty::ProjectionPredicate],\n+                     get_generics: GG)\n+                     -> fmt::Result\n+    where GG: for<'tcx> FnOnce(&ty::ctxt<'tcx>) -> ty::Generics<'tcx>\n {\n-    let tstrs = ts.iter().map(f).collect::<Vec<String>>();\n-    format!(\"[{}]\", tstrs.connect(\", \"))\n-}\n-\n-pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n-    fn bare_fn_to_string<'tcx>(cx: &ctxt<'tcx>,\n-                               opt_def_id: Option<ast::DefId>,\n-                               unsafety: ast::Unsafety,\n-                               abi: abi::Abi,\n-                               ident: Option<ast::Ident>,\n-                               sig: &ty::PolyFnSig<'tcx>)\n-                               -> String {\n-        let mut s = String::new();\n-\n-        match unsafety {\n-            ast::Unsafety::Normal => {}\n-            ast::Unsafety::Unsafe => {\n-                s.push_str(&unsafety.to_string());\n-                s.push(' ');\n-            }\n-        };\n-\n-        if abi != abi::Rust {\n-            s.push_str(&format!(\"extern {} \", abi.to_string()));\n-        };\n-\n-        s.push_str(\"fn\");\n-\n-        match ident {\n-            Some(i) => {\n-                s.push(' ');\n-                s.push_str(&token::get_ident(i));\n-            }\n-            _ => { }\n-        }\n-\n-        push_sig_to_string(cx, &mut s, '(', ')', sig);\n-\n-        match opt_def_id {\n-            Some(def_id) => {\n-                s.push_str(\" {\");\n-                let path_str = ty::item_path_str(cx, def_id);\n-                s.push_str(&path_str[..]);\n-                s.push_str(\"}\");\n-            }\n-            None => { }\n-        }\n-\n-        s\n-    }\n-\n-    fn closure_to_string<'tcx>(cx: &ctxt<'tcx>,\n-                               cty: &ty::ClosureTy<'tcx>,\n-                               did: &ast::DefId)\n-                               -> String {\n-        let mut s = String::new();\n-        s.push_str(\"[closure\");\n-        push_sig_to_string(cx, &mut s, '(', ')', &cty.sig);\n-        if cx.sess.verbose() {\n-            s.push_str(&format!(\" id={:?}]\", did));\n+    let (fn_trait_kind, verbose) = try!(ty::tls::with(|tcx| {\n+        try!(write!(f, \"{}\", ty::item_path_str(tcx, did)));\n+        Ok((tcx.lang_items.fn_trait_kind(did), tcx.sess.verbose()))\n+    }));\n+\n+    let mut empty = true;\n+    let mut start_or_continue = |f: &mut fmt::Formatter, start: &str, cont: &str| {\n+        if empty {\n+            empty = false;\n+            write!(f, \"{}\", start)\n         } else {\n-            s.push(']');\n-        }\n-        s\n-    }\n-\n-    fn push_sig_to_string<'tcx>(cx: &ctxt<'tcx>,\n-                                s: &mut String,\n-                                bra: char,\n-                                ket: char,\n-                                sig: &ty::PolyFnSig<'tcx>) {\n-        s.push(bra);\n-        let strs = sig.0.inputs\n-            .iter()\n-            .map(|a| ty_to_string(cx, *a))\n-            .collect::<Vec<_>>();\n-        s.push_str(&strs.connect(\", \"));\n-        if sig.0.variadic {\n-            s.push_str(\", ...\");\n-        }\n-        s.push(ket);\n-\n-        match sig.0.output {\n-            ty::FnConverging(t) => {\n-                if !ty::type_is_nil(t) {\n-                   s.push_str(\" -> \");\n-                   s.push_str(&ty_to_string(cx, t));\n-                }\n-            }\n-            ty::FnDiverging => {\n-                s.push_str(\" -> !\");\n-            }\n-        }\n-    }\n-\n-    fn infer_ty_to_string(cx: &ctxt, ty: ty::InferTy) -> String {\n-        let print_var_ids = cx.sess.verbose();\n-        match ty {\n-            ty::TyVar(ref vid) if print_var_ids => vid.repr(cx),\n-            ty::IntVar(ref vid) if print_var_ids => vid.repr(cx),\n-            ty::FloatVar(ref vid) if print_var_ids => vid.repr(cx),\n-            ty::TyVar(_) | ty::IntVar(_) | ty::FloatVar(_) => format!(\"_\"),\n-            ty::FreshTy(v) => format!(\"FreshTy({})\", v),\n-            ty::FreshIntTy(v) => format!(\"FreshIntTy({})\", v),\n-            ty::FreshFloatTy(v) => format!(\"FreshFloatTy({})\", v)\n-        }\n-    }\n-\n-    // pretty print the structural type representation:\n-    match typ.sty {\n-        TyBool => \"bool\".to_string(),\n-        TyChar => \"char\".to_string(),\n-        TyInt(t) => ast_util::int_ty_to_string(t, None).to_string(),\n-        TyUint(t) => ast_util::uint_ty_to_string(t, None).to_string(),\n-        TyFloat(t) => ast_util::float_ty_to_string(t).to_string(),\n-        TyBox(typ) => format!(\"Box<{}>\", ty_to_string(cx, typ)),\n-        TyRawPtr(ref tm) => {\n-            format!(\"*{} {}\", match tm.mutbl {\n-                ast::MutMutable => \"mut\",\n-                ast::MutImmutable => \"const\",\n-            }, ty_to_string(cx, tm.ty))\n-        }\n-        TyRef(r, ref tm) => {\n-            let mut buf = region_ptr_to_string(cx, *r);\n-            buf.push_str(&mt_to_string(cx, tm));\n-            buf\n-        }\n-        TyTuple(ref elems) => {\n-            let strs = elems\n-                .iter()\n-                .map(|elem| ty_to_string(cx, *elem))\n-                .collect::<Vec<_>>();\n-            match &strs[..] {\n-                [ref string] => format!(\"({},)\", string),\n-                strs => format!(\"({})\", strs.connect(\", \"))\n-            }\n-        }\n-        TyBareFn(opt_def_id, ref f) => {\n-            bare_fn_to_string(cx, opt_def_id, f.unsafety, f.abi, None, &f.sig)\n-        }\n-        TyInfer(infer_ty) => infer_ty_to_string(cx, infer_ty),\n-        TyError => \"[type error]\".to_string(),\n-        TyParam(ref param_ty) => param_ty.user_string(cx),\n-        TyEnum(did, substs) | TyStruct(did, substs) => {\n-            let base = ty::item_path_str(cx, did);\n-            parameterized(cx, &base, substs, did, &[],\n-                          || ty::lookup_item_type(cx, did).generics)\n-        }\n-        TyTrait(ref data) => {\n-            data.user_string(cx)\n-        }\n-        ty::TyProjection(ref data) => {\n-            format!(\"<{} as {}>::{}\",\n-                    data.trait_ref.self_ty().user_string(cx),\n-                    data.trait_ref.user_string(cx),\n-                    data.item_name.user_string(cx))\n-        }\n-        TyStr => \"str\".to_string(),\n-        TyClosure(ref did, substs) => {\n-            let closure_tys = cx.closure_tys.borrow();\n-            closure_tys.get(did).map(|closure_type| {\n-                closure_to_string(cx, &closure_type.subst(cx, substs), did)\n-            }).unwrap_or_else(|| {\n-                let id_str = if cx.sess.verbose() {\n-                    format!(\" id={:?}\", did)\n-                } else {\n-                    \"\".to_owned()\n-                };\n-\n-\n-                if did.krate == ast::LOCAL_CRATE {\n-                    let span = cx.map.span(did.node);\n-                    format!(\"[closure {}{}]\", span.repr(cx), id_str)\n-                } else {\n-                    format!(\"[closure{}]\", id_str)\n-                }\n-            })\n+            write!(f, \"{}\", cont)\n         }\n-        TyArray(t, sz) => {\n-            format!(\"[{}; {}]\", ty_to_string(cx, t), sz)\n-        }\n-        TySlice(t) => {\n-            format!(\"[{}]\", ty_to_string(cx, t))\n-        }\n-    }\n-}\n-\n-pub fn explicit_self_category_to_str(category: &ty::ExplicitSelfCategory)\n-                                     -> &'static str {\n-    match *category {\n-        ty::StaticExplicitSelfCategory => \"static\",\n-        ty::ByValueExplicitSelfCategory => \"self\",\n-        ty::ByReferenceExplicitSelfCategory(_, ast::MutMutable) => {\n-            \"&mut self\"\n-        }\n-        ty::ByReferenceExplicitSelfCategory(_, ast::MutImmutable) => \"&self\",\n-        ty::ByBoxExplicitSelfCategory => \"Box<self>\",\n-    }\n-}\n+    };\n \n-pub fn parameterized<'tcx,GG>(cx: &ctxt<'tcx>,\n-                              base: &str,\n-                              substs: &subst::Substs<'tcx>,\n-                              did: ast::DefId,\n-                              projections: &[ty::ProjectionPredicate<'tcx>],\n-                              get_generics: GG)\n-                              -> String\n-    where GG : FnOnce() -> ty::Generics<'tcx>\n-{\n-    if cx.sess.verbose() {\n-        let mut strings = vec![];\n+    if verbose {\n         match substs.regions {\n             subst::ErasedRegions => {\n-                strings.push(format!(\"..\"));\n+                try!(start_or_continue(f, \"<\", \", \"));\n+                try!(write!(f, \"..\"));\n             }\n             subst::NonerasedRegions(ref regions) => {\n                 for region in regions {\n-                    strings.push(region.repr(cx));\n+                    try!(start_or_continue(f, \"<\", \", \"));\n+                    try!(write!(f, \"{:?}\", region));\n                 }\n             }\n         }\n-        for ty in &substs.types {\n-            strings.push(ty.repr(cx));\n+        for &ty in &substs.types {\n+            try!(start_or_continue(f, \"<\", \", \"));\n+            try!(write!(f, \"{}\", ty));\n         }\n         for projection in projections {\n-            strings.push(format!(\"{}={}\",\n-                                 projection.projection_ty.item_name.user_string(cx),\n-                                 projection.ty.user_string(cx)));\n+            try!(start_or_continue(f, \"<\", \", \"));\n+            try!(write!(f, \"{}={}\",\n+                        projection.projection_ty.item_name,\n+                        projection.ty));\n         }\n-        return if strings.is_empty() {\n-            format!(\"{}\", base)\n-        } else {\n-            format!(\"{}<{}>\", base, strings.connect(\",\"))\n-        };\n+        return start_or_continue(f, \"\", \">\");\n     }\n \n-    let mut strs = Vec::new();\n+    if fn_trait_kind.is_some() && projections.len() == 1 {\n+        let projection_ty = projections[0].ty;\n+        if let TyTuple(ref args) = substs.types.get_slice(subst::TypeSpace)[0].sty {\n+            return fn_sig(f, args, false, ty::FnConverging(projection_ty));\n+        }\n+    }\n \n     match substs.regions {\n         subst::ErasedRegions => { }\n         subst::NonerasedRegions(ref regions) => {\n             for &r in regions {\n-                let s = region_to_string(cx, \"\", false, r);\n+                try!(start_or_continue(f, \"<\", \", \"));\n+                let s = r.to_string();\n                 if s.is_empty() {\n                     // This happens when the value of the region\n                     // parameter is not easily serialized. This may be\n                     // because the user omitted it in the first place,\n                     // or because it refers to some block in the code,\n                     // etc. I'm not sure how best to serialize this.\n-                    strs.push(format!(\"'_\"));\n+                    try!(write!(f, \"'_\"));\n                 } else {\n-                    strs.push(s)\n+                    try!(write!(f, \"{}\", s));\n                 }\n             }\n         }\n@@ -515,162 +144,99 @@ pub fn parameterized<'tcx,GG>(cx: &ctxt<'tcx>,\n     // ICEs trying to fetch the generics early in the pipeline. This\n     // is kind of a hacky workaround in that -Z verbose is required to\n     // avoid those ICEs.\n-    let generics = get_generics();\n-\n-    let has_self = substs.self_ty().is_some();\n     let tps = substs.types.get_slice(subst::TypeSpace);\n-    let ty_params = generics.types.get_slice(subst::TypeSpace);\n-    let has_defaults = ty_params.last().map_or(false, |def| def.default.is_some());\n-    let num_defaults = if has_defaults {\n-        ty_params.iter().zip(tps).rev().take_while(|&(def, &actual)| {\n-            match def.default {\n-                Some(default) => {\n-                    if !has_self && ty::type_has_self(default) {\n-                        // In an object type, there is no `Self`, and\n-                        // thus if the default value references Self,\n-                        // the user will be required to give an\n-                        // explicit value. We can't even do the\n-                        // substitution below to check without causing\n-                        // an ICE. (#18956).\n-                        false\n-                    } else {\n-                        default.subst(cx, substs) == actual\n+    let num_defaults = ty::tls::with(|tcx| {\n+        let generics = get_generics(tcx);\n+\n+        let has_self = substs.self_ty().is_some();\n+        let ty_params = generics.types.get_slice(subst::TypeSpace);\n+        if ty_params.last().map_or(false, |def| def.default.is_some()) {\n+            let substs = tcx.lift(&substs);\n+            ty_params.iter().zip(tps).rev().take_while(|&(def, &actual)| {\n+                match def.default {\n+                    Some(default) => {\n+                        if !has_self && ty::type_has_self(default) {\n+                            // In an object type, there is no `Self`, and\n+                            // thus if the default value references Self,\n+                            // the user will be required to give an\n+                            // explicit value. We can't even do the\n+                            // substitution below to check without causing\n+                            // an ICE. (#18956).\n+                            false\n+                        } else {\n+                            let default = tcx.lift(&default);\n+                            substs.and_then(|substs| default.subst(tcx, substs)) == Some(actual)\n+                        }\n                     }\n+                    None => false\n                 }\n-                None => false\n-            }\n-        }).count()\n-    } else {\n-        0\n-    };\n+            }).count()\n+        } else {\n+            0\n+        }\n+    });\n \n-    for t in &tps[..tps.len() - num_defaults] {\n-        strs.push(ty_to_string(cx, *t))\n+    for &ty in &tps[..tps.len() - num_defaults] {\n+        try!(start_or_continue(f, \"<\", \", \"));\n+        try!(write!(f, \"{}\", ty));\n     }\n \n     for projection in projections {\n-        strs.push(format!(\"{}={}\",\n-                          projection.projection_ty.item_name.user_string(cx),\n-                          projection.ty.user_string(cx)));\n-    }\n-\n-    if cx.lang_items.fn_trait_kind(did).is_some() && projections.len() == 1 {\n-        let projection_ty = projections[0].ty;\n-        let tail =\n-            if ty::type_is_nil(projection_ty) {\n-                format!(\"\")\n-            } else {\n-                format!(\" -> {}\", projection_ty.user_string(cx))\n-            };\n-        format!(\"{}({}){}\",\n-                base,\n-                if strs[0].starts_with(\"(\") && strs[0].ends_with(\",)\") {\n-                    &strs[0][1 .. strs[0].len() - 2] // Remove '(' and ',)'\n-                } else if strs[0].starts_with(\"(\") && strs[0].ends_with(\")\") {\n-                    &strs[0][1 .. strs[0].len() - 1] // Remove '(' and ')'\n-                } else {\n-                    &strs[0][..]\n-                },\n-                tail)\n-    } else if !strs.is_empty() {\n-        format!(\"{}<{}>\", base, strs.connect(\", \"))\n-    } else {\n-        format!(\"{}\", base)\n+        try!(start_or_continue(f, \"<\", \", \"));\n+        try!(write!(f, \"{}={}\",\n+                    projection.projection_ty.item_name,\n+                    projection.ty));\n     }\n-}\n \n-pub fn ty_to_short_str<'tcx>(cx: &ctxt<'tcx>, typ: Ty<'tcx>) -> String {\n-    let mut s = typ.repr(cx).to_string();\n-    if s.len() >= 32 {\n-        s = (&s[0..32]).to_string();\n-    }\n-    return s;\n-}\n-\n-impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Option<T> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        match self {\n-            &None => \"None\".to_string(),\n-            &Some(ref t) => t.repr(tcx),\n-        }\n-    }\n+    start_or_continue(f, \"\", \">\")\n }\n \n-impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for P<T> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        (**self).repr(tcx)\n-    }\n-}\n+fn in_binder<'tcx, T, U>(f: &mut fmt::Formatter,\n+                         tcx: &ty::ctxt<'tcx>,\n+                         original: &ty::Binder<T>,\n+                         lifted: Option<ty::Binder<U>>) -> fmt::Result\n+    where T: fmt::Display, U: fmt::Display + TypeFoldable<'tcx>\n+{\n+    // Replace any anonymous late-bound regions with named\n+    // variants, using gensym'd identifiers, so that we can\n+    // clearly differentiate between named and unnamed regions in\n+    // the output. We'll probably want to tweak this over time to\n+    // decide just how much information to give.\n+    let value = if let Some(v) = lifted {\n+        v\n+    } else {\n+        return write!(f, \"{}\", original.0);\n+    };\n \n-impl<'tcx,T:Repr<'tcx>,U:Repr<'tcx>> Repr<'tcx> for Result<T,U> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        match self {\n-            &Ok(ref t) => t.repr(tcx),\n-            &Err(ref u) => format!(\"Err({})\", u.repr(tcx))\n+    let mut empty = true;\n+    let mut start_or_continue = |f: &mut fmt::Formatter, start: &str, cont: &str| {\n+        if empty {\n+            empty = false;\n+            write!(f, \"{}\", start)\n+        } else {\n+            write!(f, \"{}\", cont)\n         }\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for () {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        \"()\".to_string()\n-    }\n-}\n-\n-impl<'a, 'tcx, T: ?Sized +Repr<'tcx>> Repr<'tcx> for &'a T {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        Repr::repr(*self, tcx)\n-    }\n-}\n-\n-impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Rc<T> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        (&**self).repr(tcx)\n-    }\n-}\n-\n-impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Box<T> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        (&**self).repr(tcx)\n-    }\n-}\n-\n-fn repr_vec<'tcx, T:Repr<'tcx>>(tcx: &ctxt<'tcx>, v: &[T]) -> String {\n-    vec_map_to_string(v, |t| t.repr(tcx))\n-}\n-\n-impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for [T] {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, self)\n-    }\n-}\n-\n-impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for OwnedSlice<T> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, &self[..])\n-    }\n-}\n-\n-// This is necessary to handle types like Option<Vec<T>>, for which\n-// autoderef cannot convert the &[T] handler\n-impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Vec<T> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, &self[..])\n-    }\n-}\n+    };\n \n-impl<'tcx, T:UserString<'tcx>> UserString<'tcx> for Vec<T> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        let strs: Vec<String> =\n-            self.iter().map(|t| t.user_string(tcx)).collect();\n-        strs.connect(\", \")\n-    }\n-}\n+    let new_value = ty_fold::replace_late_bound_regions(tcx, &value, |br| {\n+        let _ = start_or_continue(f, \"for<\", \", \");\n+        ty::ReLateBound(ty::DebruijnIndex::new(1), match br {\n+            ty::BrNamed(_, name) => {\n+                let _ = write!(f, \"{}\", name);\n+                br\n+            }\n+            ty::BrAnon(_) |\n+            ty::BrFresh(_) |\n+            ty::BrEnv => {\n+                let name = token::intern(\"'r\");\n+                let _ = write!(f, \"{}\", name);\n+                ty::BrNamed(ast_util::local_def(ast::DUMMY_NODE_ID), name)\n+            }\n+        })\n+    }).0;\n \n-impl<'tcx> Repr<'tcx> for def::Def {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n+    try!(start_or_continue(f, \"\", \"> \"));\n+    write!(f, \"{}\", new_value)\n }\n \n /// This curious type is here to help pretty-print trait objects. In\n@@ -684,904 +250,624 @@ impl<'tcx> Repr<'tcx> for def::Def {\n /// Right now there is only one trait in an object that can have\n /// projection bounds, so we just stuff them altogether. But in\n /// reality we should eventually sort things out better.\n-type TraitAndProjections<'tcx> =\n-    (ty::TraitRef<'tcx>, Vec<ty::ProjectionPredicate<'tcx>>);\n-\n-impl<'tcx> UserString<'tcx> for TraitAndProjections<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        let &(ref trait_ref, ref projection_bounds) = self;\n-        let base = ty::item_path_str(tcx, trait_ref.def_id);\n-        parameterized(tcx,\n-                      &base,\n-                      trait_ref.substs,\n-                      trait_ref.def_id,\n-                      &projection_bounds[..],\n-                      || ty::lookup_trait_def(tcx, trait_ref.def_id).generics.clone())\n+#[derive(Clone, Debug)]\n+struct TraitAndProjections<'tcx>(ty::TraitRef<'tcx>, Vec<ty::ProjectionPredicate<'tcx>>);\n+\n+impl<'tcx> TypeFoldable<'tcx> for TraitAndProjections<'tcx> {\n+    fn fold_with<F:ty_fold::TypeFolder<'tcx>>(&self, folder: &mut F)\n+                                              -> TraitAndProjections<'tcx> {\n+        TraitAndProjections(self.0.fold_with(folder), self.1.fold_with(folder))\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::TraitTy<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        let &ty::TraitTy { ref principal, ref bounds } = self;\n-\n-        let mut components = vec![];\n+impl<'tcx> fmt::Display for TraitAndProjections<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let TraitAndProjections(ref trait_ref, ref projection_bounds) = *self;\n+        parameterized(f, trait_ref.substs,\n+                      trait_ref.def_id,\n+                      projection_bounds,\n+                      |tcx| ty::lookup_trait_def(tcx, trait_ref.def_id).generics.clone())\n+    }\n+}\n \n-        let tap: ty::Binder<TraitAndProjections<'tcx>> =\n-            ty::Binder((principal.0.clone(),\n-                        bounds.projection_bounds.iter().map(|x| x.0.clone()).collect()));\n+impl<'tcx> fmt::Display for ty::TraitTy<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let bounds = &self.bounds;\n \n         // Generate the main trait ref, including associated types.\n-        components.push(tap.user_string(tcx));\n+        try!(ty::tls::with(|tcx| {\n+            let principal = tcx.lift(&self.principal.0)\n+                               .expect(\"could not lift TraitRef for printing\");\n+            let projections = tcx.lift(&bounds.projection_bounds[..])\n+                                 .expect(\"could not lift projections for printing\");\n+            let projections = projections.map_in_place(|p| p.0);\n+\n+            let tap = ty::Binder(TraitAndProjections(principal, projections));\n+            in_binder(f, tcx, &ty::Binder(\"\"), Some(tap))\n+        }));\n \n         // Builtin bounds.\n         for bound in &bounds.builtin_bounds {\n-            components.push(bound.user_string(tcx));\n+            try!(write!(f, \" + {:?}\", bound));\n         }\n \n         // Region, if not obviously implied by builtin bounds.\n         if bounds.region_bound != ty::ReStatic {\n             // Region bound is implied by builtin bounds:\n-            components.push(bounds.region_bound.user_string(tcx));\n+            let bound = bounds.region_bound.to_string();\n+            if !bound.is_empty() {\n+                try!(write!(f, \" + {}\", bound));\n+            }\n         }\n \n-        components.retain(|s| !s.is_empty());\n-\n-        components.connect(\" + \")\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ty::TypeParameterDef<'tcx> {\n-    fn repr(&self, _tcx: &ctxt<'tcx>) -> String {\n-        format!(\"TypeParameterDef({:?}, {:?}/{})\",\n-                self.def_id,\n-                self.space,\n-                self.index)\n+        Ok(())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::RegionParameterDef {\n-    fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"RegionParameterDef(name={}, def_id={}, bounds={})\",\n-                token::get_name(self.name),\n-                self.def_id.repr(tcx),\n-                self.bounds.repr(tcx))\n+impl<'tcx> fmt::Debug for ty::TypeParameterDef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"TypeParameterDef({:?}, {:?}/{})\",\n+               self.def_id, self.space, self.index)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::TyS<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        ty_to_string(tcx, self)\n+impl<'tcx> fmt::Debug for ty::TyS<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", *self)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::mt<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        mt_to_string(tcx, self)\n+impl<'tcx> fmt::Display for ty::mt<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}{}\",\n+               if self.mutbl == ast::MutMutable { \"mut \" } else { \"\" },\n+               self.ty)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for subst::Substs<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"Substs[types={}, regions={}]\",\n-                       self.types.repr(tcx),\n-                       self.regions.repr(tcx))\n+impl<'tcx> fmt::Debug for subst::Substs<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Substs[types={:?}, regions={:?}]\",\n+               self.types, self.regions)\n     }\n }\n \n-impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for subst::VecPerParamSpace<T> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"[{};{};{}]\",\n-                self.get_slice(subst::TypeSpace).repr(tcx),\n-                self.get_slice(subst::SelfSpace).repr(tcx),\n-                self.get_slice(subst::FnSpace).repr(tcx))\n+impl<'tcx> fmt::Debug for ty::ItemSubsts<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ItemSubsts({:?})\", self.substs)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ItemSubsts<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"ItemSubsts({})\", self.substs.repr(tcx))\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for subst::RegionSubsts {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl fmt::Debug for subst::RegionSubsts {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            subst::ErasedRegions => \"erased\".to_string(),\n-            subst::NonerasedRegions(ref regions) => regions.repr(tcx)\n+            subst::ErasedRegions => write!(f, \"erased\"),\n+            subst::NonerasedRegions(ref regions) => write!(f, \"{:?}\", regions)\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::BuiltinBounds {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        let mut res = Vec::new();\n-        for b in self {\n-            res.push(match b {\n-                ty::BoundSend => \"Send\".to_string(),\n-                ty::BoundSized => \"Sized\".to_string(),\n-                ty::BoundCopy => \"Copy\".to_string(),\n-                ty::BoundSync => \"Sync\".to_string(),\n-            });\n-        }\n-        res.connect(\"+\")\n-    }\n-}\n \n-impl<'tcx> Repr<'tcx> for ty::ParamBounds<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        let mut res = Vec::new();\n-        res.push(self.builtin_bounds.repr(tcx));\n-        for t in &self.trait_bounds {\n-            res.push(t.repr(tcx));\n+impl<'tcx> fmt::Debug for ty::ParamBounds<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{:?}\", self.builtin_bounds));\n+        let mut bounds = self.trait_bounds.iter();\n+        if self.builtin_bounds.is_empty() {\n+            if let Some(bound) = bounds.next() {\n+                try!(write!(f, \"{:?}\", bound));\n+            }\n+        }\n+        for bound in bounds {\n+            try!(write!(f, \" + {:?}\", bound));\n         }\n-        res.connect(\"+\")\n+        Ok(())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::TraitRef<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> fmt::Debug for ty::TraitRef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // when printing out the debug representation, we don't need\n         // to enumerate the `for<...>` etc because the debruijn index\n         // tells you everything you need to know.\n-        let base = ty::item_path_str(tcx, self.def_id);\n-        let result = parameterized(tcx, &base, self.substs, self.def_id, &[],\n-                      || ty::lookup_trait_def(tcx, self.def_id).generics.clone());\n         match self.substs.self_ty() {\n-            None => result,\n-            Some(sty) => format!(\"<{} as {}>\", sty.repr(tcx), result)\n+            None => write!(f, \"{}\", *self),\n+            Some(self_ty) => write!(f, \"<{:?} as {}>\", self_ty, *self)\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::TraitDef<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"TraitDef(generics={}, trait_ref={})\",\n-                self.generics.repr(tcx),\n-                self.trait_ref.repr(tcx))\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ast::TraitItem {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        let kind = match self.node {\n-            ast::ConstTraitItem(..) => \"ConstTraitItem\",\n-            ast::MethodTraitItem(..) => \"MethodTraitItem\",\n-            ast::TypeTraitItem(..) => \"TypeTraitItem\",\n-        };\n-        format!(\"{}({}, id={})\", kind, self.ident, self.id)\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ast::Expr {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"expr({}: {})\", self.id, pprust::expr_to_string(self))\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ast::Path {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"path({})\", pprust::path_to_string(self))\n-    }\n-}\n-\n-impl<'tcx> UserString<'tcx> for ast::Path {\n-    fn user_string(&self, _tcx: &ctxt) -> String {\n-        pprust::path_to_string(self)\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ast::Ty {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"type({})\", pprust::ty_to_string(self))\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ast::Item {\n-    fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"item({})\", tcx.map.node_to_string(self.id))\n+impl<'tcx> fmt::Debug for ty::TraitDef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"TraitDef(generics={:?}, trait_ref={:?})\",\n+               self.generics, self.trait_ref)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ast::Lifetime {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"lifetime({}: {})\", self.id, pprust::lifetime_to_string(self))\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ast::Stmt {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"stmt({}: {})\",\n-                ast_util::stmt_id(self),\n-                pprust::stmt_to_string(self))\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ast::Pat {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"pat({}: {})\", self.id, pprust::pat_to_string(self))\n-    }\n-}\n+impl fmt::Display for ty::BoundRegion {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if verbose() {\n+            return write!(f, \"{:?}\", *self);\n+        }\n \n-impl<'tcx> Repr<'tcx> for ty::BoundRegion {\n-    fn repr(&self, tcx: &ctxt) -> String {\n         match *self {\n-            ty::BrAnon(id) => format!(\"BrAnon({})\", id),\n-            ty::BrNamed(id, name) => {\n-                format!(\"BrNamed({}, {})\", id.repr(tcx), token::get_name(name))\n-            }\n-            ty::BrFresh(id) => format!(\"BrFresh({})\", id),\n-            ty::BrEnv => \"BrEnv\".to_string()\n+            BrNamed(_, name) => write!(f, \"{}\", name),\n+            BrAnon(_) | BrFresh(_) | BrEnv => Ok(())\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::Region {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl fmt::Debug for ty::Region {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ty::ReEarlyBound(ref data) => {\n-                format!(\"ReEarlyBound({}, {:?}, {}, {})\",\n-                        data.param_id,\n-                        data.space,\n-                        data.index,\n-                        token::get_name(data.name))\n+                write!(f, \"ReEarlyBound({}, {:?}, {}, {})\",\n+                       data.param_id,\n+                       data.space,\n+                       data.index,\n+                       data.name)\n             }\n \n             ty::ReLateBound(binder_id, ref bound_region) => {\n-                format!(\"ReLateBound({:?}, {})\",\n-                        binder_id,\n-                        bound_region.repr(tcx))\n+                write!(f, \"ReLateBound({:?}, {:?})\",\n+                       binder_id,\n+                       bound_region)\n             }\n \n-            ty::ReFree(ref fr) => fr.repr(tcx),\n+            ty::ReFree(ref fr) => write!(f, \"{:?}\", fr),\n \n             ty::ReScope(id) => {\n-                format!(\"ReScope({:?})\", id)\n+                write!(f, \"ReScope({:?})\", id)\n             }\n \n-            ty::ReStatic => {\n-                \"ReStatic\".to_string()\n-            }\n+            ty::ReStatic => write!(f, \"ReStatic\"),\n \n             ty::ReInfer(ReVar(ref vid)) => {\n-                format!(\"{:?}\", vid)\n+                write!(f, \"{:?}\", vid)\n             }\n \n             ty::ReInfer(ReSkolemized(id, ref bound_region)) => {\n-                format!(\"re_skolemized({}, {})\", id, bound_region.repr(tcx))\n+                write!(f, \"ReSkolemized({}, {:?})\", id, bound_region)\n             }\n \n-            ty::ReEmpty => {\n-                \"ReEmpty\".to_string()\n-            }\n+            ty::ReEmpty => write!(f, \"ReEmpty\")\n         }\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::Region {\n-    fn user_string(&self, tcx: &ctxt) -> String {\n-        region_to_string(tcx, \"\", false, *self)\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ty::FreeRegion {\n-    fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"ReFree({}, {})\",\n-                self.scope.repr(tcx),\n-                self.bound_region.repr(tcx))\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for region::CodeExtent {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        match *self {\n-            region::CodeExtent::ParameterScope { fn_id, body_id } =>\n-                format!(\"ParameterScope({}, {})\", fn_id, body_id),\n-            region::CodeExtent::Misc(node_id) =>\n-                format!(\"Misc({})\", node_id),\n-            region::CodeExtent::DestructionScope(node_id) =>\n-                format!(\"DestructionScope({})\", node_id),\n-            region::CodeExtent::Remainder(rem) =>\n-                format!(\"Remainder({}, {})\", rem.block, rem.first_statement_index),\n+impl fmt::Display for ty::Region {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if verbose() {\n+            return write!(f, \"{:?}\", *self);\n         }\n-    }\n-}\n \n-impl<'tcx> Repr<'tcx> for region::DestructionScopeData {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+        // These printouts are concise.  They do not contain all the information\n+        // the user might want to diagnose an error, but there is basically no way\n+        // to fit that into a short string.  Hence the recommendation to use\n+        // `explain_region()` or `note_and_explain_region()`.\n         match *self {\n-            region::DestructionScopeData{ node_id } =>\n-                format!(\"DestructionScopeData {{ node_id: {} }}\", node_id),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ast::DefId {\n-    fn repr(&self, tcx: &ctxt) -> String {\n-        // Unfortunately, there seems to be no way to attempt to print\n-        // a path for a def-id, so I'll just make a best effort for now\n-        // and otherwise fallback to just printing the crate/node pair\n-        if self.krate == ast::LOCAL_CRATE {\n-            match tcx.map.find(self.node) {\n-                Some(ast_map::NodeItem(..)) |\n-                Some(ast_map::NodeForeignItem(..)) |\n-                Some(ast_map::NodeImplItem(..)) |\n-                Some(ast_map::NodeTraitItem(..)) |\n-                Some(ast_map::NodeVariant(..)) |\n-                Some(ast_map::NodeStructCtor(..)) => {\n-                    return format!(\n-                                \"{:?}:{}\",\n-                                *self,\n-                                ty::item_path_str(tcx, *self))\n-                }\n-                _ => {}\n+            ty::ReEarlyBound(ref data) => {\n+                write!(f, \"{}\", data.name)\n+            }\n+            ty::ReLateBound(_, br) |\n+            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n+            ty::ReInfer(ReSkolemized(_, br)) => {\n+                write!(f, \"{}\", br)\n             }\n+            ty::ReScope(_) |\n+            ty::ReInfer(ReVar(_)) => Ok(()),\n+            ty::ReStatic => write!(f, \"'static\"),\n+            ty::ReEmpty => write!(f, \"'<empty>\"),\n         }\n-        return format!(\"{:?}\", *self)\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ty::TypeScheme<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"TypeScheme {{generics: {}, ty: {}}}\",\n-                self.generics.repr(tcx),\n-                self.ty.repr(tcx))\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ty::Generics<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"Generics(types: {}, regions: {})\",\n-                self.types.repr(tcx),\n-                self.regions.repr(tcx))\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ty::GenericPredicates<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"GenericPredicates(predicates: {})\",\n-                self.predicates.repr(tcx))\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::InstantiatedPredicates<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"InstantiatedPredicates({})\",\n-                self.predicates.repr(tcx))\n+impl fmt::Debug for ty::FreeRegion {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ReFree({:?}, {:?})\",\n+               self.scope, self.bound_region)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ItemVariances {\n-    fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"ItemVariances(types={}, \\\n-                regions={})\",\n-                self.types.repr(tcx),\n-                self.regions.repr(tcx))\n+impl fmt::Debug for ty::ItemVariances {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ItemVariances(types={:?}, regions={:?})\",\n+               self.types, self.regions)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::Variance {\n-    fn repr(&self, _: &ctxt) -> String {\n-        // The first `.to_string()` returns a &'static str (it is not an implementation\n-        // of the ToString trait). Because of that, we need to call `.to_string()` again\n-        // if we want to have a `String`.\n-        let result: &'static str = (*self).to_string();\n-        result.to_string()\n+impl<'tcx> fmt::Debug for ty::GenericPredicates<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"GenericPredicates({:?})\", self.predicates)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ImplOrTraitItem<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"ImplOrTraitItem({})\",\n-                match *self {\n-                    ty::ImplOrTraitItem::MethodTraitItem(ref i) => i.repr(tcx),\n-                    ty::ImplOrTraitItem::ConstTraitItem(ref i) => i.repr(tcx),\n-                    ty::ImplOrTraitItem::TypeTraitItem(ref i) => i.repr(tcx),\n-                })\n+impl<'tcx> fmt::Debug for ty::InstantiatedPredicates<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"InstantiatedPredicates({:?})\",\n+               self.predicates)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::AssociatedConst<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"AssociatedConst(name: {}, ty: {}, vis: {}, def_id: {})\",\n-                self.name.repr(tcx),\n-                self.ty.repr(tcx),\n-                self.vis.repr(tcx),\n-                self.def_id.repr(tcx))\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ty::AssociatedType<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"AssociatedType(name: {}, vis: {}, def_id: {})\",\n-                self.name.repr(tcx),\n-                self.vis.repr(tcx),\n-                self.def_id.repr(tcx))\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ty::Method<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"Method(name: {}, generics: {}, predicates: {}, fty: {}, \\\n-                 explicit_self: {}, vis: {}, def_id: {})\",\n-                self.name.repr(tcx),\n-                self.generics.repr(tcx),\n-                self.predicates.repr(tcx),\n-                self.fty.repr(tcx),\n-                self.explicit_self.repr(tcx),\n-                self.vis.repr(tcx),\n-                self.def_id.repr(tcx))\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ast::Name {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        token::get_name(*self).to_string()\n-    }\n-}\n-\n-impl<'tcx> UserString<'tcx> for ast::Name {\n-    fn user_string(&self, _tcx: &ctxt) -> String {\n-        token::get_name(*self).to_string()\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ast::Ident {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        token::get_ident(*self).to_string()\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ast::ExplicitSelf_ {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ast::Visibility {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ty::BareFnTy<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"BareFnTy {{unsafety: {}, abi: {}, sig: {}}}\",\n-                self.unsafety,\n-                self.abi.to_string(),\n-                self.sig.repr(tcx))\n+impl<'tcx> fmt::Debug for ty::ImplOrTraitItem<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"ImplOrTraitItem(\"));\n+        try!(match *self {\n+            ty::ImplOrTraitItem::MethodTraitItem(ref i) => write!(f, \"{:?}\", i),\n+            ty::ImplOrTraitItem::ConstTraitItem(ref i) => write!(f, \"{:?}\", i),\n+            ty::ImplOrTraitItem::TypeTraitItem(ref i) => write!(f, \"{:?}\", i),\n+        });\n+        write!(f, \")\")\n     }\n }\n \n-\n-impl<'tcx> Repr<'tcx> for ty::FnSig<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"fn{} -> {}\", self.inputs.repr(tcx), self.output.repr(tcx))\n+impl<'tcx> fmt::Display for ty::FnSig<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"fn\"));\n+        fn_sig(f, &self.inputs, self.variadic, self.output)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::FnOutput<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> fmt::Debug for ty::MethodOrigin<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            ty::FnConverging(ty) =>\n-                format!(\"FnConverging({0})\", ty.repr(tcx)),\n-            ty::FnDiverging =>\n-                \"FnDiverging\".to_string()\n-        }\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ty::MethodCallee<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"MethodCallee {{origin: {}, ty: {}, {}}}\",\n-                self.origin.repr(tcx),\n-                self.ty.repr(tcx),\n-                self.substs.repr(tcx))\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ty::MethodOrigin<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        match self {\n-            &ty::MethodStatic(def_id) => {\n-                format!(\"MethodStatic({})\", def_id.repr(tcx))\n-            }\n-            &ty::MethodStaticClosure(def_id) => {\n-                format!(\"MethodStaticClosure({})\", def_id.repr(tcx))\n+            ty::MethodStatic(def_id) => {\n+                write!(f, \"MethodStatic({:?})\", def_id)\n             }\n-            &ty::MethodTypeParam(ref p) => {\n-                p.repr(tcx)\n+            ty::MethodStaticClosure(def_id) => {\n+                write!(f, \"MethodStaticClosure({:?})\", def_id)\n             }\n-            &ty::MethodTraitObject(ref p) => {\n-                p.repr(tcx)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ty::MethodParam<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"MethodParam({},{})\",\n-                self.trait_ref.repr(tcx),\n-                self.method_num)\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ty::MethodObject<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"MethodObject({},{},{})\",\n-                self.trait_ref.repr(tcx),\n-                self.method_num,\n-                self.vtable_index)\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ty::BuiltinBound {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n-\n-impl<'tcx> UserString<'tcx> for ty::BuiltinBound {\n-    fn user_string(&self, _tcx: &ctxt) -> String {\n-        match *self {\n-            ty::BoundSend => \"Send\".to_string(),\n-            ty::BoundSized => \"Sized\".to_string(),\n-            ty::BoundCopy => \"Copy\".to_string(),\n-            ty::BoundSync => \"Sync\".to_string(),\n+            ty::MethodTypeParam(ref p) => write!(f, \"{:?}\", p),\n+            ty::MethodTraitObject(ref p) => write!(f, \"{:?}\", p)\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for Span {\n-    fn repr(&self, tcx: &ctxt) -> String {\n-        tcx.sess.codemap().span_to_string(*self).to_string()\n+impl<'tcx> fmt::Debug for ty::MethodParam<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"MethodParam({:?},{})\",\n+               self.trait_ref,\n+               self.method_num)\n     }\n }\n \n-impl<'tcx, A:UserString<'tcx>> UserString<'tcx> for Rc<A> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        let this: &A = &**self;\n-        this.user_string(tcx)\n+impl<'tcx> fmt::Debug for ty::MethodObject<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"MethodObject({:?},{},{})\",\n+               self.trait_ref,\n+               self.method_num,\n+               self.vtable_index)\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::ParamBounds<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        let mut result = Vec::new();\n-        let s = self.builtin_bounds.user_string(tcx);\n-        if !s.is_empty() {\n-            result.push(s);\n+impl<'tcx> fmt::Display for ty::ParamBounds<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{}\", self.builtin_bounds));\n+        let mut bounds = self.trait_bounds.iter();\n+        if self.builtin_bounds.is_empty() {\n+            if let Some(bound) = bounds.next() {\n+                try!(write!(f, \"{}\", bound));\n+            }\n         }\n-        for n in &self.trait_bounds {\n-            result.push(n.user_string(tcx));\n+        for bound in bounds {\n+            try!(write!(f, \" + {}\", bound));\n         }\n-        result.connect(\" + \")\n+        Ok(())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ExistentialBounds<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        let mut res = Vec::new();\n+impl<'tcx> fmt::Debug for ty::ExistentialBounds<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let mut empty = true;\n+        let mut maybe_continue = |f: &mut fmt::Formatter| {\n+            if empty {\n+                empty = false;\n+                Ok(())\n+            } else {\n+                write!(f, \" + \")\n+            }\n+        };\n \n-        let region_str = self.region_bound.repr(tcx);\n+        let region_str = format!(\"{:?}\", self.region_bound);\n         if !region_str.is_empty() {\n-            res.push(region_str);\n+            try!(maybe_continue(f));\n+            try!(write!(f, \"{}\", region_str));\n         }\n \n         for bound in &self.builtin_bounds {\n-            res.push(bound.repr(tcx));\n+            try!(maybe_continue(f));\n+            try!(write!(f, \"{:?}\", bound));\n         }\n \n         for projection_bound in &self.projection_bounds {\n-            res.push(projection_bound.repr(tcx));\n+            try!(maybe_continue(f));\n+            try!(write!(f, \"{:?}\", projection_bound));\n         }\n \n-        res.connect(\"+\")\n-    }\n-}\n-\n-impl<'tcx> UserString<'tcx> for ty::BuiltinBounds {\n-    fn user_string(&self, tcx: &ctxt) -> String {\n-        self.iter()\n-            .map(|bb| bb.user_string(tcx))\n-            .collect::<Vec<String>>()\n-            .connect(\"+\")\n-            .to_string()\n+        Ok(())\n     }\n }\n \n-impl<'tcx, T> UserString<'tcx> for ty::Binder<T>\n-    where T : UserString<'tcx> + TypeFoldable<'tcx>\n-{\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        // Replace any anonymous late-bound regions with named\n-        // variants, using gensym'd identifiers, so that we can\n-        // clearly differentiate between named and unnamed regions in\n-        // the output. We'll probably want to tweak this over time to\n-        // decide just how much information to give.\n-        let mut names = Vec::new();\n-        let (unbound_value, _) = ty_fold::replace_late_bound_regions(tcx, self, |br| {\n-            ty::ReLateBound(ty::DebruijnIndex::new(1), match br {\n-                ty::BrNamed(_, name) => {\n-                    names.push(token::get_name(name));\n-                    br\n-                }\n-                ty::BrAnon(_) |\n-                ty::BrFresh(_) |\n-                ty::BrEnv => {\n-                    let name = token::gensym(\"'r\");\n-                    names.push(token::get_name(name));\n-                    ty::BrNamed(ast_util::local_def(ast::DUMMY_NODE_ID), name)\n-                }\n-            })\n-        });\n-        let names: Vec<_> = names.iter().map(|s| &s[..]).collect();\n-\n-        let value_str = unbound_value.user_string(tcx);\n-        if names.is_empty() {\n-            value_str\n-        } else {\n-            format!(\"for<{}> {}\", names.connect(\",\"), value_str)\n+impl fmt::Display for ty::BuiltinBounds {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let mut bounds = self.iter();\n+        if let Some(bound) = bounds.next() {\n+            try!(write!(f, \"{:?}\", bound));\n+            for bound in bounds {\n+                try!(write!(f, \" + {:?}\", bound));\n+            }\n         }\n+        Ok(())\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::TraitRef<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        let path_str = ty::item_path_str(tcx, self.def_id);\n-        parameterized(tcx, &path_str, self.substs, self.def_id, &[],\n-                      || ty::lookup_trait_def(tcx, self.def_id).generics.clone())\n+// The generic impl doesn't work yet because projections are not\n+// normalized under HRTB.\n+/*impl<T> fmt::Display for ty::Binder<T>\n+    where T: fmt::Display + for<'a> ty::Lift<'a>,\n+          for<'a> <T as ty::Lift<'a>>::Lifted: fmt::Display + TypeFoldable<'a>\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }\n-}\n+}*/\n \n-impl<'tcx> UserString<'tcx> for Ty<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        ty_to_string(tcx, *self)\n+impl<'tcx> fmt::Display for ty::Binder<ty::TraitRef<'tcx>> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ast::Ident {\n-    fn user_string(&self, _tcx: &ctxt) -> String {\n-        token::get_name(self.name).to_string()\n+impl<'tcx> fmt::Display for ty::Binder<ty::TraitPredicate<'tcx>> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for abi::Abi {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        self.to_string()\n+impl<'tcx> fmt::Display for ty::Binder<ty::EquatePredicate<'tcx>> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for abi::Abi {\n-    fn user_string(&self, _tcx: &ctxt) -> String {\n-        self.to_string()\n+impl<'tcx> fmt::Display for ty::Binder<ty::ProjectionPredicate<'tcx>> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::UpvarId {\n-    fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"UpvarId({};`{}`;{})\",\n-                self.var_id,\n-                ty::local_var_name_str(tcx, self.var_id),\n-                self.closure_expr_id)\n+impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region>> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ast::Mutability {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+impl fmt::Display for ty::Binder<ty::OutlivesPredicate<ty::Region, ty::Region>> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::BorrowKind {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+impl<'tcx> fmt::Display for ty::TraitRef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        parameterized(f, self.substs, self.def_id, &[],\n+                      |tcx| ty::lookup_trait_def(tcx, self.def_id).generics.clone())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::UpvarBorrow {\n-    fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"UpvarBorrow({}, {})\",\n-                self.kind.repr(tcx),\n-                self.region.repr(tcx))\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ty::UpvarCapture {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            ty::UpvarCapture::ByValue => format!(\"ByValue\"),\n-            ty::UpvarCapture::ByRef(ref data) => format!(\"ByRef({})\", data.repr(tcx)),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ty::IntVid {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", self)\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ty::FloatVid {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", self)\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ty::RegionVid {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", self)\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ty::TyVid {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", self)\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ty::IntVarValue {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n+            TyBool => write!(f, \"bool\"),\n+            TyChar => write!(f, \"char\"),\n+            TyInt(t) => write!(f, \"{}\", ast_util::int_ty_to_string(t, None)),\n+            TyUint(t) => write!(f, \"{}\", ast_util::uint_ty_to_string(t, None)),\n+            TyFloat(t) => write!(f, \"{}\", ast_util::float_ty_to_string(t)),\n+            TyBox(typ) => write!(f, \"Box<{}>\",  typ),\n+            TyRawPtr(ref tm) => {\n+                write!(f, \"*{} {}\", match tm.mutbl {\n+                    ast::MutMutable => \"mut\",\n+                    ast::MutImmutable => \"const\",\n+                },  tm.ty)\n+            }\n+            TyRef(r, ref tm) => {\n+                try!(write!(f, \"&\"));\n+                let s = r.to_string();\n+                try!(write!(f, \"{}\", s));\n+                if !s.is_empty() {\n+                    try!(write!(f, \" \"));\n+                }\n+                write!(f, \"{}\", tm)\n+            }\n+            TyTuple(ref tys) => {\n+                try!(write!(f, \"(\"));\n+                let mut tys = tys.iter();\n+                if let Some(&ty) = tys.next() {\n+                    try!(write!(f, \"{},\", ty));\n+                    if let Some(&ty) = tys.next() {\n+                        try!(write!(f, \" {}\", ty));\n+                        for &ty in tys {\n+                            try!(write!(f, \", {}\", ty));\n+                        }\n+                    }\n+                }\n+                write!(f, \")\")\n+            }\n+            TyBareFn(opt_def_id, ref bare_fn) => {\n+                if bare_fn.unsafety == ast::Unsafety::Unsafe {\n+                    try!(write!(f, \"unsafe \"));\n+                }\n \n-impl<'tcx> Repr<'tcx> for ast::IntTy {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n+                if bare_fn.abi != abi::Rust {\n+                    try!(write!(f, \"extern {} \", bare_fn.abi));\n+                }\n \n-impl<'tcx> Repr<'tcx> for ast::UintTy {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n+                try!(write!(f, \"{}\", bare_fn.sig.0));\n \n-impl<'tcx> Repr<'tcx> for ast::FloatTy {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+                if let Some(def_id) = opt_def_id {\n+                    try!(write!(f, \" {{{}}}\", ty::tls::with(|tcx| {\n+                        ty::item_path_str(tcx, def_id)\n+                    })));\n+                }\n+                Ok(())\n+            }\n+            TyInfer(infer_ty) => write!(f, \"{}\", infer_ty),\n+            TyError => write!(f, \"[type error]\"),\n+            TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n+            TyEnum(did, substs) | TyStruct(did, substs) => {\n+                parameterized(f, substs, did, &[],\n+                              |tcx| ty::lookup_item_type(tcx, did).generics)\n+            }\n+            TyTrait(ref data) => write!(f, \"{}\", data),\n+            ty::TyProjection(ref data) => write!(f, \"{}\", data),\n+            TyStr => write!(f, \"str\"),\n+            TyClosure(ref did, substs) => ty::tls::with(|tcx| {\n+                try!(write!(f, \"[closure\"));\n+                let closure_tys = tcx.closure_tys.borrow();\n+                try!(closure_tys.get(did).map(|cty| &cty.sig).and_then(|sig| {\n+                    tcx.lift(&substs).map(|substs| sig.subst(tcx, substs))\n+                }).map(|sig| {\n+                    fn_sig(f, &sig.0.inputs, false, sig.0.output)\n+                }).unwrap_or_else(|| {\n+                    if did.krate == ast::LOCAL_CRATE {\n+                        try!(write!(f, \" {:?}\", tcx.map.span(did.node)));\n+                    }\n+                    Ok(())\n+                }));\n+                if verbose() {\n+                    try!(write!(f, \" id={:?}\", did));\n+                }\n+                write!(f, \"]\")\n+            }),\n+            TyArray(ty, sz) => write!(f, \"[{}; {}]\",  ty, sz),\n+            TySlice(ty) => write!(f, \"[{}]\",  ty)\n+        }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ExplicitSelfCategory {\n-    fn repr(&self, _: &ctxt) -> String {\n-        explicit_self_category_to_str(self).to_string()\n+impl<'tcx> fmt::Display for ty::TyS<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.sty)\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ParamTy {\n-    fn user_string(&self, _tcx: &ctxt) -> String {\n-        format!(\"{}\", token::get_name(self.name))\n+impl fmt::Debug for ty::UpvarId {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"UpvarId({};`{}`;{})\",\n+               self.var_id,\n+               ty::tls::with(|tcx| ty::local_var_name_str(tcx, self.var_id)),\n+               self.closure_expr_id)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ParamTy {\n-    fn repr(&self, tcx: &ctxt) -> String {\n-        let ident = self.user_string(tcx);\n-        format!(\"{}/{:?}.{}\", ident, self.space, self.idx)\n+impl fmt::Debug for ty::UpvarBorrow {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"UpvarBorrow({:?}, {:?})\",\n+               self.kind, self.region)\n     }\n }\n \n-impl<'tcx, A:Repr<'tcx>, B:Repr<'tcx>> Repr<'tcx> for (A,B) {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        let &(ref a, ref b) = self;\n-        format!(\"({},{})\", a.repr(tcx), b.repr(tcx))\n+impl fmt::Display for ty::InferTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let print_var_ids = verbose();\n+        match *self {\n+            ty::TyVar(ref vid) if print_var_ids => write!(f, \"{:?}\", vid),\n+            ty::IntVar(ref vid) if print_var_ids => write!(f, \"{:?}\", vid),\n+            ty::FloatVar(ref vid) if print_var_ids => write!(f, \"{:?}\", vid),\n+            ty::TyVar(_) | ty::IntVar(_) | ty::FloatVar(_) => write!(f, \"_\"),\n+            ty::FreshTy(v) => write!(f, \"FreshTy({})\", v),\n+            ty::FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n+            ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v)\n+        }\n     }\n }\n \n-impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for ty::Binder<T> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"Binder({})\", self.0.repr(tcx))\n+impl fmt::Display for ty::ExplicitSelfCategory {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(match *self {\n+            ty::StaticExplicitSelfCategory => \"static\",\n+            ty::ByValueExplicitSelfCategory => \"self\",\n+            ty::ByReferenceExplicitSelfCategory(_, ast::MutMutable) => {\n+                \"&mut self\"\n+            }\n+            ty::ByReferenceExplicitSelfCategory(_, ast::MutImmutable) => \"&self\",\n+            ty::ByBoxExplicitSelfCategory => \"Box<self>\",\n+        })\n     }\n }\n \n-impl<'tcx, S, K, V> Repr<'tcx> for HashMap<K, V, S>\n-    where K: Hash + Eq + Repr<'tcx>,\n-          V: Repr<'tcx>,\n-          S: HashState,\n-{\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"HashMap({})\",\n-                self.iter()\n-                    .map(|(k,v)| format!(\"{} => {}\", k.repr(tcx), v.repr(tcx)))\n-                    .collect::<Vec<String>>()\n-                    .connect(\", \"))\n+impl fmt::Display for ty::ParamTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.name)\n     }\n }\n \n-impl<'tcx, T, U> Repr<'tcx> for ty::OutlivesPredicate<T,U>\n-    where T : Repr<'tcx> + TypeFoldable<'tcx>,\n-          U : Repr<'tcx> + TypeFoldable<'tcx>,\n-{\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"OutlivesPredicate({}, {})\",\n-                self.0.repr(tcx),\n-                self.1.repr(tcx))\n+impl fmt::Debug for ty::ParamTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}/{:?}.{}\", self, self.space, self.idx)\n     }\n }\n \n-impl<'tcx, T, U> UserString<'tcx> for ty::OutlivesPredicate<T,U>\n-    where T : UserString<'tcx> + TypeFoldable<'tcx>,\n-          U : UserString<'tcx> + TypeFoldable<'tcx>,\n+impl<'tcx, T, U> fmt::Display for ty::OutlivesPredicate<T,U>\n+    where T: fmt::Display, U: fmt::Display\n {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"{} : {}\",\n-                self.0.user_string(tcx),\n-                self.1.user_string(tcx))\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for ty::EquatePredicate<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"EquatePredicate({}, {})\",\n-                self.0.repr(tcx),\n-                self.1.repr(tcx))\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{} : {}\", self.0, self.1)\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::EquatePredicate<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"{} == {}\",\n-                self.0.user_string(tcx),\n-                self.1.user_string(tcx))\n+impl<'tcx> fmt::Display for ty::EquatePredicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{} == {}\", self.0, self.1)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::TraitPredicate<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"TraitPredicate({})\",\n-                self.trait_ref.repr(tcx))\n+impl<'tcx> fmt::Debug for ty::TraitPredicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"TraitPredicate({:?})\",\n+               self.trait_ref)\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::TraitPredicate<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"{} : {}\",\n-                self.trait_ref.self_ty().user_string(tcx),\n-                self.trait_ref.user_string(tcx))\n+impl<'tcx> fmt::Display for ty::TraitPredicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{} : {}\",\n+               self.trait_ref.self_ty(),\n+               self.trait_ref)\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::ProjectionPredicate<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"{} == {}\",\n-                self.projection_ty.user_string(tcx),\n-                self.ty.user_string(tcx))\n+impl<'tcx> fmt::Debug for ty::ProjectionPredicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ProjectionPredicate({:?}, {:?})\",\n+               self.projection_ty,\n+               self.ty)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ProjectionTy<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"{}::{}\",\n-                self.trait_ref.repr(tcx),\n-                self.item_name.repr(tcx))\n+impl<'tcx> fmt::Display for ty::ProjectionPredicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{} == {}\",\n+               self.projection_ty,\n+               self.ty)\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::ProjectionTy<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"<{} as {}>::{}\",\n-                self.trait_ref.self_ty().user_string(tcx),\n-                self.trait_ref.user_string(tcx),\n-                self.item_name.user_string(tcx))\n+impl<'tcx> fmt::Display for ty::ProjectionTy<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{:?}::{}\",\n+               self.trait_ref,\n+               self.item_name)\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::Predicate<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> fmt::Display for ty::Predicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            ty::Predicate::Trait(ref data) => data.user_string(tcx),\n-            ty::Predicate::Equate(ref predicate) => predicate.user_string(tcx),\n-            ty::Predicate::RegionOutlives(ref predicate) => predicate.user_string(tcx),\n-            ty::Predicate::TypeOutlives(ref predicate) => predicate.user_string(tcx),\n-            ty::Predicate::Projection(ref predicate) => predicate.user_string(tcx),\n+            ty::Predicate::Trait(ref data) => write!(f, \"{}\", data),\n+            ty::Predicate::Equate(ref predicate) => write!(f, \"{}\", predicate),\n+            ty::Predicate::RegionOutlives(ref predicate) => write!(f, \"{}\", predicate),\n+            ty::Predicate::TypeOutlives(ref predicate) => write!(f, \"{}\", predicate),\n+            ty::Predicate::Projection(ref predicate) => write!(f, \"{}\", predicate),\n         }\n     }\n }\n-\n-impl<'tcx> Repr<'tcx> for ast::Unsafety {\n-    fn repr(&self, _: &ctxt<'tcx>) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}"}, {"sha": "49933441cf01ec4b1b76160e9ded6c7842b4d812", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -24,7 +24,6 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::region;\n use rustc::middle::ty;\n-use rustc::util::ppaux::Repr;\n use syntax::ast;\n use syntax::codemap::Span;\n \n@@ -97,8 +96,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                consume_span: Span,\n                cmt: mc::cmt<'tcx>,\n                mode: euv::ConsumeMode) {\n-        debug!(\"consume(consume_id={}, cmt={}, mode={:?})\",\n-               consume_id, cmt.repr(self.tcx()), mode);\n+        debug!(\"consume(consume_id={}, cmt={:?}, mode={:?})\",\n+               consume_id, cmt, mode);\n \n         self.consume_common(consume_id, consume_span, cmt, mode);\n     }\n@@ -112,9 +111,9 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                    consume_pat: &ast::Pat,\n                    cmt: mc::cmt<'tcx>,\n                    mode: euv::ConsumeMode) {\n-        debug!(\"consume_pat(consume_pat={}, cmt={}, mode={:?})\",\n-               consume_pat.repr(self.tcx()),\n-               cmt.repr(self.tcx()),\n+        debug!(\"consume_pat(consume_pat={:?}, cmt={:?}, mode={:?})\",\n+               consume_pat,\n+               cmt,\n                mode);\n \n         self.consume_common(consume_pat.id, consume_pat.span, cmt, mode);\n@@ -128,9 +127,9 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n     {\n-        debug!(\"borrow(borrow_id={}, cmt={}, loan_region={:?}, \\\n+        debug!(\"borrow(borrow_id={}, cmt={:?}, loan_region={:?}, \\\n                bk={:?}, loan_cause={:?})\",\n-               borrow_id, cmt.repr(self.tcx()), loan_region,\n+               borrow_id, cmt, loan_region,\n                bk, loan_cause);\n \n         match opt_loan_path(&cmt) {\n@@ -153,8 +152,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n               assignee_cmt: mc::cmt<'tcx>,\n               mode: euv::MutateMode)\n     {\n-        debug!(\"mutate(assignment_id={}, assignee_cmt={})\",\n-               assignment_id, assignee_cmt.repr(self.tcx()));\n+        debug!(\"mutate(assignment_id={}, assignee_cmt={:?})\",\n+               assignment_id, assignee_cmt);\n \n         match opt_loan_path(&assignee_cmt) {\n             Some(lp) => {\n@@ -384,9 +383,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         //! Checks whether `old_loan` and `new_loan` can safely be issued\n         //! simultaneously.\n \n-        debug!(\"report_error_if_loans_conflict(old_loan={}, new_loan={})\",\n-               old_loan.repr(self.tcx()),\n-               new_loan.repr(self.tcx()));\n+        debug!(\"report_error_if_loans_conflict(old_loan={:?}, new_loan={:?})\",\n+               old_loan,\n+               new_loan);\n \n         // Should only be called for loans that are in scope at the same time.\n         assert!(self.tcx().region_maps.scopes_intersect(old_loan.kill_scope,\n@@ -408,9 +407,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         //! prohibit `loan2`. Returns false if an error is reported.\n \n         debug!(\"report_error_if_loan_conflicts_with_restriction(\\\n-                loan1={}, loan2={})\",\n-               loan1.repr(self.tcx()),\n-               loan2.repr(self.tcx()));\n+                loan1={:?}, loan2={:?})\",\n+               loan1,\n+               loan2);\n \n         if compatible_borrow_kinds(loan1.kind, loan2.kind) {\n             return true;\n@@ -672,9 +671,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                        use_path: &LoanPath<'tcx>,\n                                        borrow_kind: ty::BorrowKind)\n                                        -> UseError<'tcx> {\n-        debug!(\"analyze_restrictions_on_use(expr_id={}, use_path={})\",\n+        debug!(\"analyze_restrictions_on_use(expr_id={}, use_path={:?})\",\n                self.tcx().map.node_to_string(expr_id),\n-               use_path.repr(self.tcx()));\n+               use_path);\n \n         let mut ret = UseOk;\n \n@@ -698,8 +697,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                               span: Span,\n                               use_kind: MovedValueUseKind,\n                               lp: &Rc<LoanPath<'tcx>>) {\n-        debug!(\"check_if_path_is_moved(id={}, use_kind={:?}, lp={})\",\n-               id, use_kind, lp.repr(self.bccx.tcx));\n+        debug!(\"check_if_path_is_moved(id={}, use_kind={:?}, lp={:?})\",\n+               id, use_kind, lp);\n \n         // FIXME (22079): if you find yourself tempted to cut and paste\n         // the body below and then specializing the error reporting,\n@@ -792,7 +791,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         assignment_span: Span,\n                         assignee_cmt: mc::cmt<'tcx>,\n                         mode: euv::MutateMode) {\n-        debug!(\"check_assignment(assignee_cmt={})\", assignee_cmt.repr(self.tcx()));\n+        debug!(\"check_assignment(assignee_cmt={:?})\", assignee_cmt);\n \n         // Mutable values can be assigned, as long as they obey loans\n         // and aliasing restrictions:\n@@ -884,7 +883,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             //! `used_mut_nodes` table here.\n \n             loop {\n-                debug!(\"mark_variable_as_used_mut(cmt={})\", cmt.repr(this.tcx()));\n+                debug!(\"mark_variable_as_used_mut(cmt={:?})\", cmt);\n                 match cmt.cat.clone() {\n                     mc::cat_upvar(mc::Upvar { id: ty::UpvarId { var_id: id, .. }, .. }) |\n                     mc::cat_local(id) => {\n@@ -929,8 +928,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             //! Safety checks related to writes to aliasable, mutable locations\n \n             let guarantor = cmt.guarantor();\n-            debug!(\"check_for_aliasable_mutable_writes(cmt={}, guarantor={})\",\n-                   cmt.repr(this.tcx()), guarantor.repr(this.tcx()));\n+            debug!(\"check_for_aliasable_mutable_writes(cmt={:?}, guarantor={:?})\",\n+                   cmt, guarantor);\n             if let mc::cat_deref(ref b, _, mc::BorrowedPtr(ty::MutBorrow, _)) = guarantor.cat {\n                 // Statically prohibit writes to `&mut` when aliasable\n                 check_for_aliasability_violation(this, span, b.clone());"}, {"sha": "93f5ac529d3fd2032ddea1b425e00fc7f3dbc9b3", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -22,7 +22,7 @@ use borrowck::move_data::InvalidMovePathIndex;\n use borrowck::move_data::{MoveData, MovePathIndex};\n use rustc::middle::ty;\n use rustc::middle::mem_categorization as mc;\n-use rustc::util::ppaux::{Repr, UserString};\n+\n use std::mem;\n use std::rc::Rc;\n use syntax::ast;\n@@ -42,21 +42,19 @@ enum Fragment {\n }\n \n impl Fragment {\n-    fn loan_path_repr<'tcx>(&self, move_data: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) -> String {\n-        let repr = |mpi| move_data.path_loan_path(mpi).repr(tcx);\n+    fn loan_path_repr(&self, move_data: &MoveData) -> String {\n+        let lp = |mpi| move_data.path_loan_path(mpi);\n         match *self {\n-            Just(mpi) => repr(mpi),\n-            AllButOneFrom(mpi) => format!(\"$(allbutone {})\", repr(mpi)),\n+            Just(mpi) => format!(\"{:?}\", lp(mpi)),\n+            AllButOneFrom(mpi) => format!(\"$(allbutone {:?})\", lp(mpi)),\n         }\n     }\n \n-    fn loan_path_user_string<'tcx>(&self,\n-                                   move_data: &MoveData<'tcx>,\n-                                   tcx: &ty::ctxt<'tcx>) -> String {\n-        let user_string = |mpi| move_data.path_loan_path(mpi).user_string(tcx);\n+    fn loan_path_user_string(&self, move_data: &MoveData) -> String {\n+        let lp = |mpi| move_data.path_loan_path(mpi);\n         match *self {\n-            Just(mpi) => user_string(mpi),\n-            AllButOneFrom(mpi) => format!(\"$(allbutone {})\", user_string(mpi)),\n+            Just(mpi) => lp(mpi).to_string(),\n+            AllButOneFrom(mpi) => format!(\"$(allbutone {})\", lp(mpi)),\n         }\n     }\n }\n@@ -126,19 +124,19 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n \n     let instrument_all_paths = |kind, vec_rc: &Vec<MovePathIndex>| {\n         for (i, mpi) in vec_rc.iter().enumerate() {\n-            let render = || this.path_loan_path(*mpi).user_string(tcx);\n+            let lp = || this.path_loan_path(*mpi);\n             if span_err {\n-                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, render()));\n+                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, lp()));\n             }\n             if print {\n-                println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n+                println!(\"id:{} {}[{}] `{}`\", id, kind, i, lp());\n             }\n         }\n     };\n \n     let instrument_all_fragments = |kind, vec_rc: &Vec<Fragment>| {\n         for (i, f) in vec_rc.iter().enumerate() {\n-            let render = || f.loan_path_user_string(this, tcx);\n+            let render = || f.loan_path_user_string(this);\n             if span_err {\n                 tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, render()));\n             }\n@@ -172,11 +170,11 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     let mut assigned = mem::replace(&mut fragments.assigned_leaf_paths, vec![]);\n \n     let path_lps = |mpis: &[MovePathIndex]| -> Vec<String> {\n-        mpis.iter().map(|mpi| this.path_loan_path(*mpi).repr(tcx)).collect()\n+        mpis.iter().map(|mpi| format!(\"{:?}\", this.path_loan_path(*mpi))).collect()\n     };\n \n     let frag_lps = |fs: &[Fragment]| -> Vec<String> {\n-        fs.iter().map(|f| f.loan_path_repr(this, tcx)).collect()\n+        fs.iter().map(|f| f.loan_path_repr(this)).collect()\n     };\n \n     // First, filter out duplicates\n@@ -343,8 +341,8 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             let tuple_idx = match *origin_field_name {\n                 mc::PositionalField(tuple_idx) => tuple_idx,\n                 mc::NamedField(_) =>\n-                    panic!(\"tuple type {} should not have named fields.\",\n-                           parent_ty.repr(tcx)),\n+                    panic!(\"tuple type {:?} should not have named fields.\",\n+                           parent_ty),\n             };\n             let tuple_len = v.len();\n             for i in 0..tuple_len {\n@@ -418,8 +416,8 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n         }\n \n         ref sty_and_variant_info => {\n-            let msg = format!(\"type {} ({:?}) is not fragmentable\",\n-                              parent_ty.repr(tcx), sty_and_variant_info);\n+            let msg = format!(\"type {:?} ({:?}) is not fragmentable\",\n+                              parent_ty, sty_and_variant_info);\n             let opt_span = origin_id.and_then(|id|tcx.map.opt_span(id));\n             tcx.sess.opt_span_bug(opt_span, &msg[..])\n         }\n@@ -450,8 +448,8 @@ fn add_fragment_sibling_core<'tcx>(this: &MoveData<'tcx>,\n     };\n     let new_lp_variant = LpExtend(parent, mc, loan_path_elem);\n     let new_lp = LoanPath::new(new_lp_variant, new_lp_type.unwrap());\n-    debug!(\"add_fragment_sibling_core(new_lp={}, origin_lp={})\",\n-           new_lp.repr(tcx), origin_lp.repr(tcx));\n+    debug!(\"add_fragment_sibling_core(new_lp={:?}, origin_lp={:?})\",\n+           new_lp, origin_lp);\n     let mp = this.move_path(tcx, Rc::new(new_lp));\n \n     // Do not worry about checking for duplicates here; we will sort"}, {"sha": "7b6c54dbaca44945fa2ba02cc411743836e34e4f", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -18,7 +18,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n use rustc::middle::ty;\n-use rustc::util::ppaux::Repr;\n+\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -66,8 +66,8 @@ pub fn gather_match_variant<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       cmt: mc::cmt<'tcx>,\n                                       mode: euv::MatchMode) {\n     let tcx = bccx.tcx;\n-    debug!(\"gather_match_variant(move_pat={}, cmt={}, mode={:?})\",\n-           move_pat.id, cmt.repr(tcx), mode);\n+    debug!(\"gather_match_variant(move_pat={}, cmt={:?}, mode={:?})\",\n+           move_pat.id, cmt, mode);\n \n     let opt_lp = opt_loan_path(&cmt);\n     match opt_lp {\n@@ -115,14 +115,14 @@ fn gather_move<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                          move_data: &MoveData<'tcx>,\n                          move_error_collector: &MoveErrorCollector<'tcx>,\n                          move_info: GatherMoveInfo<'tcx>) {\n-    debug!(\"gather_move(move_id={}, cmt={})\",\n-           move_info.id, move_info.cmt.repr(bccx.tcx));\n+    debug!(\"gather_move(move_id={}, cmt={:?})\",\n+           move_info.id, move_info.cmt);\n \n     let potentially_illegal_move =\n                 check_and_get_illegal_move_origin(bccx, &move_info.cmt);\n     match potentially_illegal_move {\n         Some(illegal_move_origin) => {\n-            debug!(\"illegal_move_origin={}\", illegal_move_origin.repr(bccx.tcx));\n+            debug!(\"illegal_move_origin={:?}\", illegal_move_origin);\n             let error = MoveError::with_move_info(illegal_move_origin,\n                                                   move_info.span_path_opt);\n             move_error_collector.add_error(error);"}, {"sha": "427d78e89b3e2dbe11a787298ac418e45c1f7d5d", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -16,7 +16,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::region;\n use rustc::middle::ty;\n-use rustc::util::ppaux::Repr;\n+\n use syntax::ast;\n use syntax::codemap::Span;\n \n@@ -33,8 +33,8 @@ pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     //! Reports error if `loan_region` is larger than S\n     //! where S is `item_scope` if `cmt` is an upvar,\n     //! and is scope of `cmt` otherwise.\n-    debug!(\"guarantee_lifetime(cmt={}, loan_region={})\",\n-           cmt.repr(bccx.tcx), loan_region.repr(bccx.tcx));\n+    debug!(\"guarantee_lifetime(cmt={:?}, loan_region={:?})\",\n+           cmt, loan_region);\n     let ctxt = GuaranteeLifetimeContext {bccx: bccx,\n                                          item_scope: item_scope,\n                                          span: span,\n@@ -65,9 +65,9 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n         //! Main routine. Walks down `cmt` until we find the\n         //! \"guarantor\".  Reports an error if `self.loan_region` is\n         //! larger than scope of `cmt`.\n-        debug!(\"guarantee_lifetime.check(cmt={}, loan_region={})\",\n-               cmt.repr(self.bccx.tcx),\n-               self.loan_region.repr(self.bccx.tcx));\n+        debug!(\"guarantee_lifetime.check(cmt={:?}, loan_region={:?})\",\n+               cmt,\n+               self.loan_region);\n \n         match cmt.cat {\n             mc::cat_rvalue(..) |"}, {"sha": "f00eb872642f4e5173c447878e7f23caf7b108d2", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -22,7 +22,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::region;\n use rustc::middle::ty;\n-use rustc::util::ppaux::Repr;\n+\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::visit;\n@@ -76,8 +76,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                _consume_span: Span,\n                cmt: mc::cmt<'tcx>,\n                mode: euv::ConsumeMode) {\n-        debug!(\"consume(consume_id={}, cmt={}, mode={:?})\",\n-               consume_id, cmt.repr(self.tcx()), mode);\n+        debug!(\"consume(consume_id={}, cmt={:?}, mode={:?})\",\n+               consume_id, cmt, mode);\n \n         match mode {\n             euv::Move(move_reason) => {\n@@ -93,9 +93,9 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                    matched_pat: &ast::Pat,\n                    cmt: mc::cmt<'tcx>,\n                    mode: euv::MatchMode) {\n-        debug!(\"matched_pat(matched_pat={}, cmt={}, mode={:?})\",\n-               matched_pat.repr(self.tcx()),\n-               cmt.repr(self.tcx()),\n+        debug!(\"matched_pat(matched_pat={:?}, cmt={:?}, mode={:?})\",\n+               matched_pat,\n+               cmt,\n                mode);\n \n         if let mc::cat_downcast(..) = cmt.cat {\n@@ -109,9 +109,9 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                    consume_pat: &ast::Pat,\n                    cmt: mc::cmt<'tcx>,\n                    mode: euv::ConsumeMode) {\n-        debug!(\"consume_pat(consume_pat={}, cmt={}, mode={:?})\",\n-               consume_pat.repr(self.tcx()),\n-               cmt.repr(self.tcx()),\n+        debug!(\"consume_pat(consume_pat={:?}, cmt={:?}, mode={:?})\",\n+               consume_pat,\n+               cmt,\n                mode);\n \n         match mode {\n@@ -132,9 +132,9 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n     {\n-        debug!(\"borrow(borrow_id={}, cmt={}, loan_region={:?}, \\\n+        debug!(\"borrow(borrow_id={}, cmt={:?}, loan_region={:?}, \\\n                bk={:?}, loan_cause={:?})\",\n-               borrow_id, cmt.repr(self.tcx()), loan_region,\n+               borrow_id, cmt, loan_region,\n                bk, loan_cause);\n \n         self.guarantee_valid(borrow_id,\n@@ -152,8 +152,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n               mode: euv::MutateMode)\n     {\n         let opt_lp = opt_loan_path(&assignee_cmt);\n-        debug!(\"mutate(assignment_id={}, assignee_cmt={}) opt_lp={:?}\",\n-               assignment_id, assignee_cmt.repr(self.tcx()), opt_lp);\n+        debug!(\"mutate(assignment_id={}, assignee_cmt={:?}) opt_lp={:?}\",\n+               assignment_id, assignee_cmt, opt_lp);\n \n         match opt_lp {\n             Some(lp) => {\n@@ -234,10 +234,10 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                        req_kind: ty::BorrowKind,\n                        loan_region: ty::Region,\n                        cause: euv::LoanCause) {\n-        debug!(\"guarantee_valid(borrow_id={}, cmt={}, \\\n+        debug!(\"guarantee_valid(borrow_id={}, cmt={:?}, \\\n                 req_mutbl={:?}, loan_region={:?})\",\n                borrow_id,\n-               cmt.repr(self.tcx()),\n+               cmt,\n                req_kind,\n                loan_region);\n \n@@ -336,8 +336,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             }\n         };\n \n-        debug!(\"guarantee_valid(borrow_id={}), loan={}\",\n-               borrow_id, loan.repr(self.tcx()));\n+        debug!(\"guarantee_valid(borrow_id={}), loan={:?}\",\n+               borrow_id, loan);\n \n         // let loan_path = loan.loan_path;\n         // let loan_gen_scope = loan.gen_scope;\n@@ -376,8 +376,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                                       req_kind: ty::BorrowKind)\n                                       -> Result<(),()> {\n             //! Implements the M-* rules in README.md.\n-            debug!(\"check_mutability(cause={:?} cmt={} req_kind={:?}\",\n-                   cause, cmt.repr(bccx.tcx), req_kind);\n+            debug!(\"check_mutability(cause={:?} cmt={:?} req_kind={:?}\",\n+                   cause, cmt, req_kind);\n             match req_kind {\n                 ty::UniqueImmBorrow | ty::ImmBorrow => {\n                     match cmt.mutbl {\n@@ -507,7 +507,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n \n pub fn gather_loans_in_static_initializer(bccx: &mut BorrowckCtxt, expr: &ast::Expr) {\n \n-    debug!(\"gather_loans_in_static_initializer(expr={})\", expr.repr(bccx.tcx));\n+    debug!(\"gather_loans_in_static_initializer(expr={:?})\", expr);\n \n     let mut sicx = StaticInitializerCtxt {\n         bccx: bccx"}, {"sha": "9a29ed91339e2468646da1c59d408dc1b7b35870", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -12,7 +12,6 @@ use borrowck::BorrowckCtxt;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n use rustc::middle::ty;\n-use rustc::util::ppaux::UserString;\n use std::cell::RefCell;\n use syntax::ast;\n use syntax::codemap;\n@@ -130,7 +129,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                 bccx.span_err(move_from.span,\n                               &format!(\"cannot move out of type `{}`, \\\n                                         a non-copy fixed-size array\",\n-                                       b.ty.user_string(bccx.tcx)));\n+                                       b.ty));\n             }\n         }\n \n@@ -143,7 +142,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                         move_from.span,\n                         &format!(\"cannot move out of type `{}`, \\\n                                  which defines the `Drop` trait\",\n-                                b.ty.user_string(bccx.tcx)));\n+                                b.ty));\n                 },\n                 _ => {\n                     bccx.span_bug(move_from.span, \"this path should not cause illegal move\")"}, {"sha": "345f5378f69e106c0fd3142f66d31f94229f3de1", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -16,7 +16,6 @@ use borrowck::*;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::ty;\n-use rustc::util::ppaux::Repr;\n use syntax::codemap::Span;\n \n use borrowck::ToInteriorKind;\n@@ -58,7 +57,7 @@ struct RestrictionsContext<'a, 'tcx: 'a> {\n impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n     fn restrict(&self,\n                 cmt: mc::cmt<'tcx>) -> RestrictionResult<'tcx> {\n-        debug!(\"restrict(cmt={})\", cmt.repr(self.bccx.tcx));\n+        debug!(\"restrict(cmt={:?})\", cmt);\n \n         let new_lp = |v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n "}, {"sha": "6369621779cbd5ed3e99eb557328e1c9ff8de881", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 58, "deletions": 64, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -28,14 +28,15 @@ use rustc::middle::dataflow::BitwiseOperator;\n use rustc::middle::dataflow::DataFlowOperator;\n use rustc::middle::dataflow::KillFrom;\n use rustc::middle::expr_use_visitor as euv;\n-use rustc::middle::mem_categorization as mc;\n use rustc::middle::free_region::FreeRegionMap;\n+use rustc::middle::infer::error_reporting::note_and_explain_region;\n+use rustc::middle::mem_categorization as mc;\n use rustc::middle::region;\n use rustc::middle::ty::{self, Ty};\n-use rustc::util::ppaux::{note_and_explain_region, Repr, UserString};\n+\n+use std::fmt;\n use std::mem;\n use std::rc::Rc;\n-use std::string::String;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n@@ -328,7 +329,7 @@ impl<'tcx> Loan<'tcx> {\n     }\n }\n \n-#[derive(Eq, Hash, Debug)]\n+#[derive(Eq, Hash)]\n pub struct LoanPath<'tcx> {\n     kind: LoanPathKind<'tcx>,\n     ty: ty::Ty<'tcx>,\n@@ -368,7 +369,7 @@ const DOWNCAST_PRINTED_OPERATOR: &'static str = \" as \";\n // information that is not relevant to loan-path analysis. (In\n // particular, the distinction between how precisely a array-element\n // is tracked is irrelevant here.)\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum InteriorKind {\n     InteriorField(mc::FieldName),\n     InteriorElement(mc::ElementKind),\n@@ -681,15 +682,15 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                   which is {}\",\n                                  ol,\n                                  moved_lp_msg,\n-                                 expr_ty.user_string(self.tcx),\n+                                 expr_ty,\n                                  suggestion));\n                 } else {\n                     self.tcx.sess.span_note(\n                         expr_span,\n                         &format!(\"`{}` moved here{} because it has type `{}`, which is {}\",\n                                  ol,\n                                  moved_lp_msg,\n-                                 expr_ty.user_string(self.tcx),\n+                                 expr_ty,\n                                  suggestion));\n                 }\n             }\n@@ -702,7 +703,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                              which is moved by default\",\n                             ol,\n                             moved_lp_msg,\n-                            pat_ty.user_string(self.tcx)));\n+                            pat_ty));\n                 self.tcx.sess.fileline_help(span,\n                     \"use `ref` to override\");\n             }\n@@ -733,7 +734,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             has type `{}`, which is {}\",\n                             ol,\n                             moved_lp_msg,\n-                            expr_ty.user_string(self.tcx),\n+                            expr_ty,\n                             suggestion));\n                 self.tcx.sess.fileline_help(expr_span, help);\n             }\n@@ -1001,20 +1002,14 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     \"reference must be valid for \",\n                     sub_scope,\n                     \"...\");\n-                let suggestion = if is_statement_scope(self.tcx, super_scope) {\n-                    Some(\"consider using a `let` binding to increase its lifetime\")\n-                } else {\n-                    None\n-                };\n-                let span = note_and_explain_region(\n+                note_and_explain_region(\n                     self.tcx,\n                     \"...but borrowed value is only valid for \",\n                     super_scope,\n                     \"\");\n-                match (span, suggestion) {\n-                    (_, None) => {},\n-                    (Some(span), Some(msg)) => self.tcx.sess.span_help(span, msg),\n-                    (None, Some(msg)) => self.tcx.sess.help(msg),\n+                if let Some(span) = statement_scope_span(self.tcx, super_scope) {\n+                    self.tcx.sess.span_help(span,\n+                        \"consider using a `let` binding to increase its lifetime\");\n                 }\n             }\n \n@@ -1127,16 +1122,16 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n-fn is_statement_scope(tcx: &ty::ctxt, region: ty::Region) -> bool {\n-     match region {\n-         ty::ReScope(scope) => {\n-             match tcx.map.find(scope.node_id()) {\n-                 Some(ast_map::NodeStmt(_)) => true,\n-                 _ => false\n-             }\n-         }\n-         _ => false\n-     }\n+fn statement_scope_span(tcx: &ty::ctxt, region: ty::Region) -> Option<Span> {\n+    match region {\n+        ty::ReScope(scope) => {\n+            match tcx.map.find(scope.node_id()) {\n+                Some(ast_map::NodeStmt(stmt)) => Some(stmt.span),\n+                _ => None\n+            }\n+        }\n+        _ => None\n+    }\n }\n \n impl BitwiseOperator for LoanDataFlowOperator {\n@@ -1153,88 +1148,87 @@ impl DataFlowOperator for LoanDataFlowOperator {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for InteriorKind {\n-    fn repr(&self, _tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> fmt::Debug for InteriorKind {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            InteriorField(mc::NamedField(fld)) =>\n-                format!(\"{}\", token::get_name(fld)),\n-            InteriorField(mc::PositionalField(i)) => format!(\"#{}\", i),\n-            InteriorElement(..) => \"[]\".to_string(),\n+            InteriorField(mc::NamedField(fld)) => write!(f, \"{}\", fld),\n+            InteriorField(mc::PositionalField(i)) => write!(f, \"#{}\", i),\n+            InteriorElement(..) => write!(f, \"[]\"),\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for Loan<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"Loan_{}({}, {:?}, {:?}-{:?}, {})\",\n-                 self.index,\n-                 self.loan_path.repr(tcx),\n-                 self.kind,\n-                 self.gen_scope,\n-                 self.kill_scope,\n-                 self.restricted_paths.repr(tcx))\n+impl<'tcx> fmt::Debug for Loan<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Loan_{}({:?}, {:?}, {:?}-{:?}, {:?})\",\n+               self.index,\n+               self.loan_path,\n+               self.kind,\n+               self.gen_scope,\n+               self.kill_scope,\n+               self.restricted_paths)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for LoanPath<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.kind {\n             LpVar(id) => {\n-                format!(\"$({})\", tcx.map.node_to_string(id))\n+                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.map.node_to_string(id)))\n             }\n \n             LpUpvar(ty::UpvarId{ var_id, closure_expr_id }) => {\n-                let s = tcx.map.node_to_string(var_id);\n-                format!(\"$({} captured by id={})\", s, closure_expr_id)\n+                let s = ty::tls::with(|tcx| tcx.map.node_to_string(var_id));\n+                write!(f, \"$({} captured by id={})\", s, closure_expr_id)\n             }\n \n             LpDowncast(ref lp, variant_def_id) => {\n                 let variant_str = if variant_def_id.krate == ast::LOCAL_CRATE {\n-                    ty::item_path_str(tcx, variant_def_id)\n+                    ty::tls::with(|tcx| ty::item_path_str(tcx, variant_def_id))\n                 } else {\n-                    variant_def_id.repr(tcx)\n+                    format!(\"{:?}\", variant_def_id)\n                 };\n-                format!(\"({}{}{})\", lp.repr(tcx), DOWNCAST_PRINTED_OPERATOR, variant_str)\n+                write!(f, \"({:?}{}{})\", lp, DOWNCAST_PRINTED_OPERATOR, variant_str)\n             }\n \n             LpExtend(ref lp, _, LpDeref(_)) => {\n-                format!(\"{}.*\", lp.repr(tcx))\n+                write!(f, \"{:?}.*\", lp)\n             }\n \n             LpExtend(ref lp, _, LpInterior(ref interior)) => {\n-                format!(\"{}.{}\", lp.repr(tcx), interior.repr(tcx))\n+                write!(f, \"{:?}.{:?}\", lp, interior)\n             }\n         }\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for LoanPath<'tcx> {\n-    fn user_string(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> fmt::Display for LoanPath<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.kind {\n             LpVar(id) => {\n-                format!(\"$({})\", tcx.map.node_to_user_string(id))\n+                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.map.node_to_user_string(id)))\n             }\n \n             LpUpvar(ty::UpvarId{ var_id, closure_expr_id: _ }) => {\n-                let s = tcx.map.node_to_user_string(var_id);\n-                format!(\"$({} captured by closure)\", s)\n+                let s = ty::tls::with(|tcx| tcx.map.node_to_user_string(var_id));\n+                write!(f, \"$({} captured by closure)\", s)\n             }\n \n             LpDowncast(ref lp, variant_def_id) => {\n                 let variant_str = if variant_def_id.krate == ast::LOCAL_CRATE {\n-                    ty::item_path_str(tcx, variant_def_id)\n+                    ty::tls::with(|tcx| ty::item_path_str(tcx, variant_def_id))\n                 } else {\n-                    variant_def_id.repr(tcx)\n+                    format!(\"{:?}\", variant_def_id)\n                 };\n-                format!(\"({}{}{})\", lp.user_string(tcx), DOWNCAST_PRINTED_OPERATOR, variant_str)\n+                write!(f, \"({}{}{})\", lp, DOWNCAST_PRINTED_OPERATOR, variant_str)\n             }\n \n             LpExtend(ref lp, _, LpDeref(_)) => {\n-                format!(\"{}.*\", lp.user_string(tcx))\n+                write!(f, \"{}.*\", lp)\n             }\n \n             LpExtend(ref lp, _, LpInterior(ref interior)) => {\n-                format!(\"{}.{}\", lp.user_string(tcx), interior.repr(tcx))\n+                write!(f, \"{}.{:?}\", lp, interior)\n             }\n         }\n     }"}, {"sha": "b38915612c5b0c453d83b30148a024e473acd553", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -22,7 +22,7 @@ use rustc::middle::dataflow::KillFrom;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::ty;\n use rustc::util::nodemap::{FnvHashMap, NodeSet};\n-use rustc::util::ppaux::Repr;\n+\n use std::cell::RefCell;\n use std::rc::Rc;\n use std::usize;\n@@ -313,8 +313,8 @@ impl<'tcx> MoveData<'tcx> {\n             }\n         };\n \n-        debug!(\"move_path(lp={}, index={:?})\",\n-               lp.repr(tcx),\n+        debug!(\"move_path(lp={:?}, index={:?})\",\n+               lp,\n                index);\n \n         assert_eq!(index.get(), self.paths.borrow().len() - 1);\n@@ -364,8 +364,8 @@ impl<'tcx> MoveData<'tcx> {\n                     lp: Rc<LoanPath<'tcx>>,\n                     id: ast::NodeId,\n                     kind: MoveKind) {\n-        debug!(\"add_move(lp={}, id={}, kind={:?})\",\n-               lp.repr(tcx),\n+        debug!(\"add_move(lp={:?}, id={}, kind={:?})\",\n+               lp,\n                id,\n                kind);\n \n@@ -394,8 +394,8 @@ impl<'tcx> MoveData<'tcx> {\n                           span: Span,\n                           assignee_id: ast::NodeId,\n                           mode: euv::MutateMode) {\n-        debug!(\"add_assignment(lp={}, assign_id={}, assignee_id={}\",\n-               lp.repr(tcx), assign_id, assignee_id);\n+        debug!(\"add_assignment(lp={:?}, assign_id={}, assignee_id={}\",\n+               lp, assign_id, assignee_id);\n \n         let path_index = self.move_path(tcx, lp.clone());\n \n@@ -415,13 +415,13 @@ impl<'tcx> MoveData<'tcx> {\n         };\n \n         if self.is_var_path(path_index) {\n-            debug!(\"add_assignment[var](lp={}, assignment={}, path_index={:?})\",\n-                   lp.repr(tcx), self.var_assignments.borrow().len(), path_index);\n+            debug!(\"add_assignment[var](lp={:?}, assignment={}, path_index={:?})\",\n+                   lp, self.var_assignments.borrow().len(), path_index);\n \n             self.var_assignments.borrow_mut().push(assignment);\n         } else {\n-            debug!(\"add_assignment[path](lp={}, path_index={:?})\",\n-                   lp.repr(tcx), path_index);\n+            debug!(\"add_assignment[path](lp={:?}, path_index={:?})\",\n+                   lp, path_index);\n \n             self.path_assignments.borrow_mut().push(assignment);\n         }\n@@ -437,8 +437,8 @@ impl<'tcx> MoveData<'tcx> {\n                              pattern_id: ast::NodeId,\n                              base_lp: Rc<LoanPath<'tcx>>,\n                              mode: euv::MatchMode) {\n-        debug!(\"add_variant_match(lp={}, pattern_id={})\",\n-               lp.repr(tcx), pattern_id);\n+        debug!(\"add_variant_match(lp={:?}, pattern_id={})\",\n+               lp, pattern_id);\n \n         let path_index = self.move_path(tcx, lp.clone());\n         let base_path_index = self.move_path(tcx, base_lp.clone());"}, {"sha": "a834ed4cb5f67e1bdc4ca5e0b4abb37fbfade1a8", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 144, "deletions": 128, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -65,7 +65,7 @@ pub fn compile_input(sess: Session,\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n-    let (outputs, trans, sess) = {\n+    let (sess, result) = {\n         let (outputs, expanded_crate, id) = {\n             let krate = phase_1_parse_input(&sess, cfg, input);\n \n@@ -119,37 +119,52 @@ pub fn compile_input(sess: Session,\n                                                                      &ast_map.krate(),\n                                                                      &id[..]));\n \n-        let analysis = phase_3_run_analysis_passes(sess,\n-                                                   ast_map,\n-                                                   &arenas,\n-                                                   id,\n-                                                   control.make_glob_map);\n-\n-        controller_entry_point!(after_analysis,\n-                                analysis.ty_cx.sess,\n-                                CompileState::state_after_analysis(input,\n-                                                                   &analysis.ty_cx.sess,\n-                                                                   outdir,\n-                                                                   analysis.ty_cx.map.krate(),\n-                                                                   &analysis,\n-                                                                   &analysis.ty_cx));\n-\n-        if log_enabled!(::log::INFO) {\n-            println!(\"Pre-trans\");\n-            analysis.ty_cx.print_debug_stats();\n-        }\n-        let (tcx, trans) = phase_4_translate_to_llvm(analysis);\n+        phase_3_run_analysis_passes(sess,\n+                                    ast_map,\n+                                    &arenas,\n+                                    id,\n+                                    control.make_glob_map,\n+                                    |tcx, analysis| {\n+\n+            {\n+                let state = CompileState::state_after_analysis(input,\n+                                                               &tcx.sess,\n+                                                               outdir,\n+                                                               tcx.map.krate(),\n+                                                               &analysis,\n+                                                               tcx);\n+                (control.after_analysis.callback)(state);\n+\n+                tcx.sess.abort_if_errors();\n+                if control.after_analysis.stop == Compilation::Stop {\n+                    return Err(());\n+                }\n+            }\n \n-        if log_enabled!(::log::INFO) {\n-            println!(\"Post-trans\");\n-            tcx.print_debug_stats();\n-        }\n+            if log_enabled!(::log::INFO) {\n+                println!(\"Pre-trans\");\n+                tcx.print_debug_stats();\n+            }\n+            let trans = phase_4_translate_to_llvm(tcx, analysis);\n+\n+            if log_enabled!(::log::INFO) {\n+                println!(\"Post-trans\");\n+                tcx.print_debug_stats();\n+            }\n+\n+            // Discard interned strings as they are no longer required.\n+            token::get_ident_interner().clear();\n \n-        // Discard interned strings as they are no longer required.\n-        token::get_ident_interner().clear();\n+            Ok((outputs, trans))\n+        })\n+    };\n \n-        (outputs, trans, tcx.sess)\n+    let (outputs, trans) = if let Ok(out) = result {\n+        out\n+    } else {\n+        return;\n     };\n+\n     phase_5_run_llvm_passes(&sess, &trans, &outputs);\n \n     controller_entry_point!(after_llvm,\n@@ -240,7 +255,7 @@ pub struct CompileState<'a, 'ast: 'a, 'tcx: 'a> {\n     pub out_dir: Option<&'a Path>,\n     pub expanded_crate: Option<&'a ast::Crate>,\n     pub ast_map: Option<&'a ast_map::Map<'ast>>,\n-    pub analysis: Option<&'a ty::CrateAnalysis<'tcx>>,\n+    pub analysis: Option<&'a ty::CrateAnalysis>,\n     pub tcx: Option<&'a ty::ctxt<'tcx>>,\n     pub trans: Option<&'a trans::CrateTranslation>,\n }\n@@ -309,7 +324,7 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n                             session: &'a Session,\n                             out_dir: &'a Option<PathBuf>,\n                             expanded_crate: &'a ast::Crate,\n-                            analysis: &'a ty::CrateAnalysis<'tcx>,\n+                            analysis: &'a ty::CrateAnalysis,\n                             tcx: &'a ty::ctxt<'tcx>)\n                             -> CompileState<'a, 'ast, 'tcx> {\n         CompileState {\n@@ -578,12 +593,16 @@ pub fn assign_node_ids_and_map<'ast>(sess: &Session,\n /// Run the resolution, typechecking, region checking and other\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n-pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n-                                         ast_map: ast_map::Map<'tcx>,\n-                                         arenas: &'tcx ty::CtxtArenas<'tcx>,\n-                                         name: String,\n-                                         make_glob_map: resolve::MakeGlobMap)\n-                                         -> ty::CrateAnalysis<'tcx> {\n+pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n+                                               ast_map: ast_map::Map<'tcx>,\n+                                               arenas: &'tcx ty::CtxtArenas<'tcx>,\n+                                               name: String,\n+                                               make_glob_map: resolve::MakeGlobMap,\n+                                               f: F)\n+                                               -> (Session, R)\n+                                               where F: FnOnce(&ty::ctxt<'tcx>,\n+                                                               ty::CrateAnalysis) -> R\n+{\n     let time_passes = sess.time_passes();\n     let krate = ast_map.krate();\n \n@@ -602,11 +621,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n         glob_map,\n     } =\n         time(time_passes, \"resolution\", (),\n-             |_| resolve::resolve_crate(&sess,\n-                                        &ast_map,\n-                                        &lang_items,\n-                                        krate,\n-                                        make_glob_map));\n+             |_| resolve::resolve_crate(&sess, &ast_map, make_glob_map));\n \n     // Discard MTWT tables that aren't required past resolution.\n     syntax::ext::mtwt::clear_tables();\n@@ -631,102 +646,103 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     time(time_passes, \"static item recursion checking\", (), |_|\n          middle::check_static_recursion::check_crate(&sess, krate, &def_map, &ast_map));\n \n-    let ty_cx = ty::mk_ctxt(sess,\n-                            arenas,\n-                            def_map,\n-                            named_region_map,\n-                            ast_map,\n-                            freevars,\n-                            region_map,\n-                            lang_items,\n-                            stability::Index::new(krate));\n-\n-    // passes are timed inside typeck\n-    typeck::check_crate(&ty_cx, trait_map);\n-\n-    time(time_passes, \"const checking\", (), |_|\n-         middle::check_const::check_crate(&ty_cx));\n-\n-    let (exported_items, public_items) =\n-            time(time_passes, \"privacy checking\", (), |_|\n-                 rustc_privacy::check_crate(&ty_cx, &export_map, external_exports));\n-\n-    // Do not move this check past lint\n-    time(time_passes, \"stability index\", (), |_|\n-         ty_cx.stability.borrow_mut().build(&ty_cx, krate, &public_items));\n-\n-    time(time_passes, \"intrinsic checking\", (), |_|\n-         middle::intrinsicck::check_crate(&ty_cx));\n-\n-    time(time_passes, \"effect checking\", (), |_|\n-         middle::effect::check_crate(&ty_cx));\n-\n-    time(time_passes, \"match checking\", (), |_|\n-         middle::check_match::check_crate(&ty_cx));\n-\n-    time(time_passes, \"liveness checking\", (), |_|\n-         middle::liveness::check_crate(&ty_cx));\n-\n-    time(time_passes, \"borrow checking\", (), |_|\n-         borrowck::check_crate(&ty_cx));\n-\n-    time(time_passes, \"rvalue checking\", (), |_|\n-         middle::check_rvalues::check_crate(&ty_cx, krate));\n-\n-    // Avoid overwhelming user with errors if type checking failed.\n-    // I'm not sure how helpful this is, to be honest, but it avoids a\n-    // lot of annoying errors in the compile-fail tests (basically,\n-    // lint warnings and so on -- kindck used to do this abort, but\n-    // kindck is gone now). -nmatsakis\n-    ty_cx.sess.abort_if_errors();\n-\n-    let reachable_map =\n-        time(time_passes, \"reachability checking\", (), |_|\n-             reachable::find_reachable(&ty_cx, &exported_items));\n-\n-    time(time_passes, \"death checking\", (), |_| {\n-        middle::dead::check_crate(&ty_cx,\n-                                  &exported_items,\n-                                  &reachable_map)\n-    });\n-\n-    let ref lib_features_used =\n-        time(time_passes, \"stability checking\", (), |_|\n-             stability::check_unstable_api_usage(&ty_cx));\n-\n-    time(time_passes, \"unused lib feature checking\", (), |_|\n-         stability::check_unused_or_stable_features(\n-             &ty_cx.sess, lib_features_used));\n-\n-    time(time_passes, \"lint checking\", (), |_|\n-         lint::check_crate(&ty_cx, &exported_items));\n-\n-    // The above three passes generate errors w/o aborting\n-    ty_cx.sess.abort_if_errors();\n-\n-    ty::CrateAnalysis {\n-        export_map: export_map,\n-        ty_cx: ty_cx,\n-        exported_items: exported_items,\n-        public_items: public_items,\n-        reachable: reachable_map,\n-        name: name,\n-        glob_map: glob_map,\n-    }\n+    ty::with_ctxt(sess,\n+                  arenas,\n+                  def_map,\n+                  named_region_map,\n+                  ast_map,\n+                  freevars,\n+                  region_map,\n+                  lang_items,\n+                  stability::Index::new(krate),\n+                  |tcx| {\n+\n+        // passes are timed inside typeck\n+        typeck::check_crate(tcx, trait_map);\n+\n+        time(time_passes, \"const checking\", (), |_|\n+            middle::check_const::check_crate(tcx));\n+\n+        let (exported_items, public_items) =\n+                time(time_passes, \"privacy checking\", (), |_|\n+                    rustc_privacy::check_crate(tcx, &export_map, external_exports));\n+\n+        // Do not move this check past lint\n+        time(time_passes, \"stability index\", (), |_|\n+            tcx.stability.borrow_mut().build(tcx, krate, &public_items));\n+\n+        time(time_passes, \"intrinsic checking\", (), |_|\n+            middle::intrinsicck::check_crate(tcx));\n+\n+        time(time_passes, \"effect checking\", (), |_|\n+            middle::effect::check_crate(tcx));\n+\n+        time(time_passes, \"match checking\", (), |_|\n+            middle::check_match::check_crate(tcx));\n+\n+        time(time_passes, \"liveness checking\", (), |_|\n+            middle::liveness::check_crate(tcx));\n+\n+        time(time_passes, \"borrow checking\", (), |_|\n+            borrowck::check_crate(tcx));\n+\n+        time(time_passes, \"rvalue checking\", (), |_|\n+            middle::check_rvalues::check_crate(tcx, krate));\n+\n+        // Avoid overwhelming user with errors if type checking failed.\n+        // I'm not sure how helpful this is, to be honest, but it avoids a\n+        // lot of annoying errors in the compile-fail tests (basically,\n+        // lint warnings and so on -- kindck used to do this abort, but\n+        // kindck is gone now). -nmatsakis\n+        tcx.sess.abort_if_errors();\n+\n+        let reachable_map =\n+            time(time_passes, \"reachability checking\", (), |_|\n+                reachable::find_reachable(tcx, &exported_items));\n+\n+        time(time_passes, \"death checking\", (), |_| {\n+            middle::dead::check_crate(tcx,\n+                                      &exported_items,\n+                                      &reachable_map)\n+        });\n+\n+        let ref lib_features_used =\n+            time(time_passes, \"stability checking\", (), |_|\n+                stability::check_unstable_api_usage(tcx));\n+\n+        time(time_passes, \"unused lib feature checking\", (), |_|\n+            stability::check_unused_or_stable_features(\n+                &tcx.sess, lib_features_used));\n+\n+        time(time_passes, \"lint checking\", (), |_|\n+            lint::check_crate(tcx, &exported_items));\n+\n+        // The above three passes generate errors w/o aborting\n+        tcx.sess.abort_if_errors();\n+\n+        f(tcx, ty::CrateAnalysis {\n+            export_map: export_map,\n+            exported_items: exported_items,\n+            public_items: public_items,\n+            reachable: reachable_map,\n+            name: name,\n+            glob_map: glob_map,\n+        })\n+    })\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n-pub fn phase_4_translate_to_llvm<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n-                                       -> (ty::ctxt<'tcx>, trans::CrateTranslation) {\n-    let time_passes = analysis.ty_cx.sess.time_passes();\n+pub fn phase_4_translate_to_llvm(tcx: &ty::ctxt, analysis: ty::CrateAnalysis)\n+                                 -> trans::CrateTranslation {\n+    let time_passes = tcx.sess.time_passes();\n \n     time(time_passes, \"resolving dependency formats\", (), |_|\n-         dependency_format::calculate(&analysis.ty_cx));\n+         dependency_format::calculate(tcx));\n \n     // Option dance to work around the lack of stack once closures.\n     time(time_passes, \"translation\", analysis, |analysis|\n-         trans::trans_crate(analysis))\n+         trans::trans_crate(tcx, analysis))\n }\n \n /// Run LLVM itself, producing a bitcode file, assembly file or object file"}, {"sha": "96d1ab23ad5239983e9701171be469b9c331a7cd", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -377,12 +377,10 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n         if sess.opts.debugging_opts.save_analysis {\n             control.after_analysis.callback = box |state| {\n                 time(state.session.time_passes(),\n-                     \"save analysis\",\n-                     state.expanded_crate.unwrap(),\n-                     |krate| save::process_crate(state.session,\n-                                                 krate,\n-                                                 state.analysis.unwrap(),\n-                                                 state.out_dir));\n+                     \"save analysis\", (),\n+                     |_| save::process_crate(state.tcx.unwrap(),\n+                                             state.analysis.unwrap(),\n+                                             state.out_dir));\n             };\n             control.make_glob_map = resolve::MakeGlobMap::Yes;\n         }"}, {"sha": "a40cb94204d9c82b34fb14eff8b409adf69d4bac", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -25,7 +25,6 @@ use rustc::middle::cfg;\n use rustc::middle::cfg::graphviz::LabelledCFG;\n use rustc::session::Session;\n use rustc::session::config::Input;\n-use rustc::util::ppaux;\n use rustc_borrowck as borrowck;\n use rustc_borrowck::graphviz as borrowck_dot;\n use rustc_resolve as resolve;\n@@ -148,13 +147,15 @@ impl PpSourceMode {\n             }\n             PpmTyped => {\n                 let ast_map = ast_map.expect(\"--pretty=typed missing ast_map\");\n-                let analysis = driver::phase_3_run_analysis_passes(sess,\n-                                                                   ast_map,\n-                                                                   arenas,\n-                                                                   id,\n-                                                                   resolve::MakeGlobMap::No);\n-                let annotation = TypedAnnotation { analysis: analysis };\n-                f(&annotation, payload)\n+                driver::phase_3_run_analysis_passes(sess,\n+                                                    ast_map,\n+                                                    arenas,\n+                                                    id,\n+                                                    resolve::MakeGlobMap::No,\n+                                                    |tcx, _| {\n+                    let annotation = TypedAnnotation { tcx: tcx };\n+                    f(&annotation, payload)\n+                }).1\n             }\n         }\n     }\n@@ -284,21 +285,21 @@ impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n }\n \n \n-struct TypedAnnotation<'tcx> {\n-    analysis: ty::CrateAnalysis<'tcx>,\n+struct TypedAnnotation<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n }\n \n-impl<'tcx> PrinterSupport<'tcx> for TypedAnnotation<'tcx> {\n-    fn sess<'a>(&'a self) -> &'a Session { &self.analysis.ty_cx.sess }\n+impl<'b, 'tcx> PrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n+    fn sess<'a>(&'a self) -> &'a Session { &self.tcx.sess }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'tcx>> {\n-        Some(&self.analysis.ty_cx.map)\n+        Some(&self.tcx.map)\n     }\n \n     fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n }\n \n-impl<'tcx> pprust::PpAnn for TypedAnnotation<'tcx> {\n+impl<'a, 'tcx> pprust::PpAnn for TypedAnnotation<'a, 'tcx> {\n     fn pre(&self,\n            s: &mut pprust::State,\n            node: pprust::AnnNode) -> io::Result<()> {\n@@ -310,16 +311,13 @@ impl<'tcx> pprust::PpAnn for TypedAnnotation<'tcx> {\n     fn post(&self,\n             s: &mut pprust::State,\n             node: pprust::AnnNode) -> io::Result<()> {\n-        let tcx = &self.analysis.ty_cx;\n         match node {\n             pprust::NodeExpr(expr) => {\n                 try!(pp::space(&mut s.s));\n                 try!(pp::word(&mut s.s, \"as\"));\n                 try!(pp::space(&mut s.s));\n                 try!(pp::word(&mut s.s,\n-                              &ppaux::ty_to_string(\n-                                  tcx,\n-                                  ty::expr_ty(tcx, expr))));\n+                              &ty::expr_ty(self.tcx, expr).to_string()));\n                 s.pclose()\n             }\n             _ => Ok(())\n@@ -646,12 +644,14 @@ pub fn pretty_print_input(sess: Session,\n             match code {\n                 Some(code) => {\n                     let variants = gather_flowgraph_variants(&sess);\n-                    let analysis = driver::phase_3_run_analysis_passes(sess,\n-                                                                       ast_map,\n-                                                                       &arenas,\n-                                                                       id,\n-                                                                       resolve::MakeGlobMap::No);\n-                    print_flowgraph(variants, analysis, code, mode, out)\n+                    driver::phase_3_run_analysis_passes(sess,\n+                                                        ast_map,\n+                                                        &arenas,\n+                                                        id,\n+                                                        resolve::MakeGlobMap::No,\n+                                                        |tcx, _| {\n+                        print_flowgraph(variants, tcx, code, mode, out)\n+                    }).1\n                 }\n                 None => {\n                     let message = format!(\"--pretty=flowgraph needs \\\n@@ -682,18 +682,17 @@ pub fn pretty_print_input(sess: Session,\n }\n \n fn print_flowgraph<W: Write>(variants: Vec<borrowck_dot::Variant>,\n-                             analysis: ty::CrateAnalysis,\n+                             tcx: &ty::ctxt,\n                              code: blocks::Code,\n                              mode: PpFlowGraphMode,\n                              mut out: W) -> io::Result<()> {\n-    let ty_cx = &analysis.ty_cx;\n     let cfg = match code {\n-        blocks::BlockCode(block) => cfg::CFG::new(ty_cx, &*block),\n-        blocks::FnLikeCode(fn_like) => cfg::CFG::new(ty_cx, &*fn_like.body()),\n+        blocks::BlockCode(block) => cfg::CFG::new(tcx, &*block),\n+        blocks::FnLikeCode(fn_like) => cfg::CFG::new(tcx, &*fn_like.body()),\n     };\n     let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n     let lcfg = LabelledCFG {\n-        ast_map: &ty_cx.map,\n+        ast_map: &tcx.map,\n         cfg: &cfg,\n         name: format!(\"node_{}\", code.id()),\n         labelled_edges: labelled_edges,\n@@ -705,14 +704,14 @@ fn print_flowgraph<W: Write>(variants: Vec<borrowck_dot::Variant>,\n             return expand_err_details(r);\n         }\n         blocks::BlockCode(_) => {\n-            ty_cx.sess.err(\"--pretty flowgraph with -Z flowgraph-print \\\n-                            annotations requires fn-like node id.\");\n+            tcx.sess.err(\"--pretty flowgraph with -Z flowgraph-print \\\n+                          annotations requires fn-like node id.\");\n             return Ok(())\n         }\n         blocks::FnLikeCode(fn_like) => {\n             let fn_parts = borrowck::FnPartsWithCFG::from_fn_like(&fn_like, &cfg);\n             let (bccx, analysis_data) =\n-                borrowck::build_borrowck_dataflow_data_for_fn(ty_cx, fn_parts);\n+                borrowck::build_borrowck_dataflow_data_for_fn(tcx, fn_parts);\n \n             let lcfg = borrowck_dot::DataflowLabeller {\n                 inner: lcfg,"}, {"sha": "5183fa01a8ac414425809ab051b0033969d2b51a", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 46, "deletions": 57, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -28,7 +28,6 @@ use rustc_typeck::middle::infer;\n use rustc_typeck::middle::infer::lub::Lub;\n use rustc_typeck::middle::infer::glb::Glb;\n use rustc_typeck::middle::infer::sub::Sub;\n-use rustc_typeck::util::ppaux::{ty_to_string, Repr, UserString};\n use rustc::ast_map;\n use rustc::session::{self,config};\n use syntax::{abi, ast};\n@@ -126,23 +125,25 @@ fn test_env<F>(source_string: &str,\n     // run just enough stuff to build a tcx:\n     let lang_items = lang_items::collect_language_items(krate, &sess);\n     let resolve::CrateMap { def_map, freevars, .. } =\n-        resolve::resolve_crate(&sess, &ast_map, &lang_items, krate, resolve::MakeGlobMap::No);\n+        resolve::resolve_crate(&sess, &ast_map, resolve::MakeGlobMap::No);\n     let named_region_map = resolve_lifetime::krate(&sess, krate, &def_map);\n     let region_map = region::resolve_crate(&sess, krate);\n-    let tcx = ty::mk_ctxt(sess,\n-                          &arenas,\n-                          def_map,\n-                          named_region_map,\n-                          ast_map,\n-                          freevars,\n-                          region_map,\n-                          lang_items,\n-                          stability::Index::new(krate));\n-    let infcx = infer::new_infer_ctxt(&tcx);\n-    body(Env { infcx: &infcx });\n-    let free_regions = FreeRegionMap::new();\n-    infcx.resolve_regions_and_report_errors(&free_regions, ast::CRATE_NODE_ID);\n-    assert_eq!(tcx.sess.err_count(), expected_err_count);\n+    ty::with_ctxt(sess,\n+                  &arenas,\n+                  def_map,\n+                  named_region_map,\n+                  ast_map,\n+                  freevars,\n+                  region_map,\n+                  lang_items,\n+                  stability::Index::new(krate),\n+                  |tcx| {\n+        let infcx = infer::new_infer_ctxt(tcx);\n+        body(Env { infcx: &infcx });\n+        let free_regions = FreeRegionMap::new();\n+        infcx.resolve_regions_and_report_errors(&free_regions, ast::CRATE_NODE_ID);\n+        assert_eq!(tcx.sess.err_count(), expected_err_count);\n+    });\n }\n \n impl<'a, 'tcx> Env<'a, 'tcx> {\n@@ -186,7 +187,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                       -> Option<ast::NodeId> {\n             assert!(idx < names.len());\n             for item in &m.items {\n-                if item.ident.user_string(this.infcx.tcx) == names[idx] {\n+                if item.ident.to_string() == names[idx] {\n                     return search(this, &**item, idx+1, names);\n                 }\n             }\n@@ -225,8 +226,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     pub fn make_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         match infer::mk_subty(self.infcx, true, infer::Misc(DUMMY_SP), a, b) {\n             Ok(_) => true,\n-            Err(ref e) => panic!(\"Encountered error: {}\",\n-                                ty::type_err_to_str(self.infcx.tcx, e))\n+            Err(ref e) => panic!(\"Encountered error: {}\", e)\n         }\n     }\n \n@@ -239,9 +239,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     pub fn assert_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) {\n         if !self.is_subtype(a, b) {\n-            panic!(\"{} is not a subtype of {}, but it should be\",\n-                  self.ty_to_string(a),\n-                  self.ty_to_string(b));\n+            panic!(\"{} is not a subtype of {}, but it should be\", a, b);\n         }\n     }\n \n@@ -250,10 +248,6 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         self.assert_subtype(b, a);\n     }\n \n-    pub fn ty_to_string(&self, a: Ty<'tcx>) -> String {\n-        ty_to_string(self.infcx.tcx, a)\n-    }\n-\n     pub fn t_fn(&self,\n                 input_tys: &[Ty<'tcx>],\n                 output_ty: Ty<'tcx>)\n@@ -374,8 +368,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     pub fn make_lub_ty(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> Ty<'tcx> {\n         match self.lub().relate(&t1, &t2) {\n             Ok(t) => t,\n-            Err(ref e) => panic!(\"unexpected error computing LUB: {}\",\n-                                ty::type_err_to_str(self.infcx.tcx, e))\n+            Err(ref e) => panic!(\"unexpected error computing LUB: {}\", e)\n         }\n     }\n \n@@ -385,10 +378,10 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         match self.sub().relate(&t1, &t2) {\n             Ok(_) => { }\n             Err(ref e) => {\n-                panic!(\"unexpected error computing sub({},{}): {}\",\n-                       t1.repr(self.infcx.tcx),\n-                       t2.repr(self.infcx.tcx),\n-                       ty::type_err_to_str(self.infcx.tcx, e));\n+                panic!(\"unexpected error computing sub({:?},{:?}): {}\",\n+                       t1,\n+                       t2,\n+                       e);\n             }\n         }\n     }\n@@ -399,9 +392,9 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         match self.sub().relate(&t1, &t2) {\n             Err(_) => { }\n             Ok(_) => {\n-                panic!(\"unexpected success computing sub({},{})\",\n-                       t1.repr(self.infcx.tcx),\n-                       t2.repr(self.infcx.tcx));\n+                panic!(\"unexpected success computing sub({:?},{:?})\",\n+                       t1,\n+                       t2);\n             }\n         }\n     }\n@@ -413,18 +406,14 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                 self.assert_eq(t, t_lub);\n             }\n             Err(ref e) => {\n-                panic!(\"unexpected error in LUB: {}\",\n-                      ty::type_err_to_str(self.infcx.tcx, e))\n+                panic!(\"unexpected error in LUB: {}\", e)\n             }\n         }\n     }\n \n     /// Checks that `GLB(t1,t2) == t_glb`\n     pub fn check_glb(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_glb: Ty<'tcx>) {\n-        debug!(\"check_glb(t1={}, t2={}, t_glb={})\",\n-               self.ty_to_string(t1),\n-               self.ty_to_string(t2),\n-               self.ty_to_string(t_glb));\n+        debug!(\"check_glb(t1={}, t2={}, t_glb={})\", t1, t2, t_glb);\n         match self.glb().relate(&t1, &t2) {\n             Err(e) => {\n                 panic!(\"unexpected error computing LUB: {:?}\", e)\n@@ -657,7 +646,7 @@ fn glb_bound_free_infer() {\n         let t_resolve1 = env.infcx.shallow_resolve(t_infer1);\n         match t_resolve1.sty {\n             ty::TyRef(..) => { }\n-            _ => { panic!(\"t_resolve1={}\", t_resolve1.repr(env.infcx.tcx)); }\n+            _ => { panic!(\"t_resolve1={:?}\", t_resolve1); }\n         }\n     })\n }\n@@ -699,11 +688,11 @@ fn subst_ty_renumber_bound() {\n             env.t_fn(&[t_ptr_bound2], env.t_nil())\n         };\n \n-        debug!(\"subst_bound: t_source={} substs={} t_substituted={} t_expected={}\",\n-               t_source.repr(env.infcx.tcx),\n-               substs.repr(env.infcx.tcx),\n-               t_substituted.repr(env.infcx.tcx),\n-               t_expected.repr(env.infcx.tcx));\n+        debug!(\"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n+               t_source,\n+               substs,\n+               t_substituted,\n+               t_expected);\n \n         assert_eq!(t_substituted, t_expected);\n     })\n@@ -736,11 +725,11 @@ fn subst_ty_renumber_some_bounds() {\n             env.t_pair(t_rptr_bound1, env.t_fn(&[t_rptr_bound2], env.t_nil()))\n         };\n \n-        debug!(\"subst_bound: t_source={} substs={} t_substituted={} t_expected={}\",\n-               t_source.repr(env.infcx.tcx),\n-               substs.repr(env.infcx.tcx),\n-               t_substituted.repr(env.infcx.tcx),\n-               t_expected.repr(env.infcx.tcx));\n+        debug!(\"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n+               t_source,\n+               substs,\n+               t_substituted,\n+               t_expected);\n \n         assert_eq!(t_substituted, t_expected);\n     })\n@@ -797,11 +786,11 @@ fn subst_region_renumber_region() {\n             env.t_fn(&[t_rptr_bound2], env.t_nil())\n         };\n \n-        debug!(\"subst_bound: t_source={} substs={} t_substituted={} t_expected={}\",\n-               t_source.repr(env.infcx.tcx),\n-               substs.repr(env.infcx.tcx),\n-               t_substituted.repr(env.infcx.tcx),\n-               t_expected.repr(env.infcx.tcx));\n+        debug!(\"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n+               t_source,\n+               substs,\n+               t_substituted,\n+               t_expected);\n \n         assert_eq!(t_substituted, t_expected);\n     })"}, {"sha": "47713859dd8cbda4196051f0ecb7d8f9c66956b2", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -36,7 +36,6 @@ use middle::{def, pat_util, stability};\n use middle::const_eval::{eval_const_expr_partial, const_int, const_uint};\n use middle::cfg;\n use rustc::ast_map;\n-use util::ppaux::ty_to_string;\n use util::nodemap::{FnvHashMap, NodeSet};\n use lint::{Level, Context, LintPass, LintArray, Lint};\n \n@@ -495,8 +494,7 @@ impl BoxPointers {\n         });\n \n         if n_uniq > 0 {\n-            let s = ty_to_string(cx.tcx, ty);\n-            let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n+            let m = format!(\"type uses owned (Box type) pointers: {}\", ty);\n             cx.span_lint(BOX_POINTERS, span, &m[..]);\n         }\n     }"}, {"sha": "5d10b0d9a57b80b31990b6221e44f1cc87370e54", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -55,7 +55,6 @@ use rustc::lint;\n use rustc::metadata::csearch;\n use rustc::metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n use rustc::middle::def::*;\n-use rustc::middle::lang_items::LanguageItems;\n use rustc::middle::pat_util::pat_bindings;\n use rustc::middle::privacy::*;\n use rustc::middle::subst::{ParamSpace, FnSpace, TypeSpace};\n@@ -3689,10 +3688,9 @@ pub enum MakeGlobMap {\n /// Entry point to crate resolution.\n pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n                                ast_map: &'a ast_map::Map<'tcx>,\n-                               _: &LanguageItems,\n-                               krate: &Crate,\n                                make_glob_map: MakeGlobMap)\n                                -> CrateMap {\n+    let krate = ast_map.krate();\n     let mut resolver = Resolver::new(session, ast_map, krate.span, make_glob_map);\n \n     build_reduced_graph::build_reduced_graph(&mut resolver, krate);"}, {"sha": "f6f9afa02215a9a35b494a60e2ae691ce98bf3be", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -25,7 +25,6 @@ use middle::ty::{self, Ty};\n use rustc::ast_map::{PathElem, PathElems, PathName};\n use trans::{CrateContext, CrateTranslation, gensym_name};\n use util::common::time;\n-use util::ppaux;\n use util::sha2::{Digest, Sha256};\n use util::fs::fix_windows_verbatim_for_gcc;\n use rustc_back::tempdir::TempDir;\n@@ -347,8 +346,7 @@ pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: PathEl\n pub fn mangle_internal_name_by_type_and_seq<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                       t: Ty<'tcx>,\n                                                       name: &str) -> String {\n-    let s = ppaux::ty_to_string(ccx.tcx(), t);\n-    let path = [PathName(token::intern(&s[..])),\n+    let path = [PathName(token::intern(&t.to_string())),\n                 gensym_name(name)];\n     let hash = get_symbol_hash(ccx, t);\n     mangle(path.iter().cloned(), Some(&hash[..]))"}, {"sha": "65d9d9809c926ce8ef1afc98512bb79d70470089", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 49, "deletions": 70, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -52,8 +52,6 @@ use syntax::ptr::P;\n use super::span_utils::SpanUtils;\n use super::recorder::{Recorder, FmtStrs};\n \n-use util::ppaux;\n-\n macro_rules! down_cast_data {\n     ($id:ident, $kind:ident, $this:ident, $sp:expr) => {\n         let $id = if let super::Data::$kind(data) = $id {\n@@ -67,7 +65,8 @@ macro_rules! down_cast_data {\n pub struct DumpCsvVisitor<'l, 'tcx: 'l> {\n     save_ctxt: SaveContext<'l, 'tcx>,\n     sess: &'l Session,\n-    analysis: &'l ty::CrateAnalysis<'tcx>,\n+    tcx: &'l ty::ctxt<'tcx>,\n+    analysis: &'l ty::CrateAnalysis,\n \n     span: SpanUtils<'l>,\n     fmt: FmtStrs<'l>,\n@@ -76,28 +75,23 @@ pub struct DumpCsvVisitor<'l, 'tcx: 'l> {\n }\n \n impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n-    pub fn new(sess: &'l Session,\n-               analysis: &'l ty::CrateAnalysis<'tcx>,\n+    pub fn new(tcx: &'l ty::ctxt<'tcx>,\n+               analysis: &'l ty::CrateAnalysis,\n                output_file: Box<File>) -> DumpCsvVisitor<'l, 'tcx> {\n+        let span_utils = SpanUtils {\n+            sess: &tcx.sess,\n+            err_count: Cell::new(0)\n+        };\n         DumpCsvVisitor {\n-            sess: sess,\n-            save_ctxt: SaveContext::new(sess, analysis, SpanUtils {\n-                sess: sess,\n-                err_count: Cell::new(0)\n-            }),\n+            sess: &tcx.sess,\n+            tcx: tcx,\n+            save_ctxt: SaveContext::new(tcx, span_utils.clone()),\n             analysis: analysis,\n-            span: SpanUtils {\n-                sess: sess,\n-                err_count: Cell::new(0)\n-            },\n+            span: span_utils.clone(),\n             fmt: FmtStrs::new(box Recorder {\n                                 out: output_file,\n                                 dump_spans: false,\n-                            },\n-                            SpanUtils {\n-                                sess: sess,\n-                                err_count: Cell::new(0)\n-                            }),\n+                              }, span_utils),\n             cur_scope: 0\n         }\n     }\n@@ -237,19 +231,19 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n     // looks up anything, not just a type\n     fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n-        if !self.analysis.ty_cx.def_map.borrow().contains_key(&ref_id) {\n+        if !self.tcx.def_map.borrow().contains_key(&ref_id) {\n             self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n                                   ref_id));\n         }\n-        let def = self.analysis.ty_cx.def_map.borrow().get(&ref_id).unwrap().full_def();\n+        let def = self.tcx.def_map.borrow().get(&ref_id).unwrap().full_def();\n         match def {\n             def::DefPrimTy(_) => None,\n             _ => Some(def.def_id()),\n         }\n     }\n \n     fn lookup_def_kind(&self, ref_id: NodeId, span: Span) -> Option<recorder::Row> {\n-        let def_map = self.analysis.ty_cx.def_map.borrow();\n+        let def_map = self.tcx.def_map.borrow();\n         if !def_map.contains_key(&ref_id) {\n             self.sess.span_bug(span, &format!(\"def_map has no key for {} in lookup_def_kind\",\n                                              ref_id));\n@@ -291,10 +285,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             collector.visit_pat(&arg.pat);\n             let span_utils = self.span.clone();\n             for &(id, ref p, _, _) in &collector.collected_paths {\n-                let typ =\n-                    ppaux::ty_to_string(\n-                        &self.analysis.ty_cx,\n-                        *self.analysis.ty_cx.node_types().get(&id).unwrap());\n+                let typ = self.tcx.node_types().get(&id).unwrap().to_string();\n                 // get the span only for the name of the variable (I hope the path is only ever a\n                 // variable name, but who knows?)\n                 self.fmt.formal_str(p.span,\n@@ -320,22 +311,20 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         let mut scope_id;\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n-        let qualname = match ty::impl_of_method(&self.analysis.ty_cx,\n-                                                ast_util::local_def(id)) {\n-            Some(impl_id) => match self.analysis.ty_cx.map.get(impl_id.node) {\n+        let qualname = match ty::impl_of_method(self.tcx, ast_util::local_def(id)) {\n+            Some(impl_id) => match self.tcx.map.get(impl_id.node) {\n                 NodeItem(item) => {\n                     scope_id = item.id;\n                     match item.node {\n                         ast::ItemImpl(_, _, _, _, ref ty, _) => {\n                             let mut result = String::from(\"<\");\n                             result.push_str(&ty_to_string(&**ty));\n \n-                            match ty::trait_of_item(&self.analysis.ty_cx,\n-                                                    ast_util::local_def(id)) {\n+                            match ty::trait_of_item(self.tcx, ast_util::local_def(id)) {\n                                 Some(def_id) => {\n                                     result.push_str(\" as \");\n                                     result.push_str(\n-                                        &ty::item_path_str(&self.analysis.ty_cx, def_id));\n+                                        &ty::item_path_str(self.tcx, def_id));\n                                 },\n                                 None => {}\n                             }\n@@ -352,16 +341,15 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                 _ => {\n                     self.sess.span_bug(span,\n                         &format!(\"Container {} for method {} is not a node item {:?}\",\n-                                 impl_id.node, id, self.analysis.ty_cx.map.get(impl_id.node)));\n+                                 impl_id.node, id, self.tcx.map.get(impl_id.node)));\n                 },\n             },\n-            None => match ty::trait_of_item(&self.analysis.ty_cx,\n-                                            ast_util::local_def(id)) {\n+            None => match ty::trait_of_item(self.tcx, ast_util::local_def(id)) {\n                 Some(def_id) => {\n                     scope_id = def_id.node;\n-                    match self.analysis.ty_cx.map.get(def_id.node) {\n+                    match self.tcx.map.get(def_id.node) {\n                         NodeItem(_) => {\n-                            format!(\"::{}\", ty::item_path_str(&self.analysis.ty_cx, def_id))\n+                            format!(\"::{}\", ty::item_path_str(self.tcx, def_id))\n                         }\n                         _ => {\n                             self.sess.span_bug(span,\n@@ -380,8 +368,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         let qualname = &format!(\"{}::{}\", qualname, &token::get_name(name));\n \n         // record the decl for this def (if it has one)\n-        let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n-                                             ast_util::local_def(id))\n+        let decl_id = ty::trait_item_of_item(self.tcx, ast_util::local_def(id))\n             .and_then(|new_id| {\n                 let def_id = new_id.def_id();\n                 if def_id.node != 0 && def_id != ast_util::local_def(id) {\n@@ -538,7 +525,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                      typ: &ast::Ty,\n                      expr: &ast::Expr)\n     {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(id));\n+        let qualname = format!(\"::{}\", self.tcx.map.path_to_string(id));\n \n         let sub_span = self.span.sub_span_after_keyword(span,\n                                                         keywords::Const);\n@@ -561,7 +548,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                       item: &ast::Item,\n                       def: &ast::StructDef,\n                       ty_params: &ast::Generics) {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+        let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n \n         let ctor_id = match def.ctor_id {\n             Some(node_id) => node_id,\n@@ -691,7 +678,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                      generics: &ast::Generics,\n                      trait_refs: &OwnedSlice<ast::TyParamBound>,\n                      methods: &[P<ast::TraitItem>]) {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+        let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n         let val = self.span.snippet(item.span);\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n         self.fmt.trait_str(item.span,\n@@ -758,7 +745,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             return\n         }\n \n-        let def_map = self.analysis.ty_cx.def_map.borrow();\n+        let def_map = self.tcx.def_map.borrow();\n         if !def_map.contains_key(&id) {\n             self.sess.span_bug(span,\n                                &format!(\"def_map has no key for {} in visit_expr\", id));\n@@ -789,12 +776,10 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             def::DefMethod(declid, provenence) => {\n                 let sub_span = self.span.sub_span_for_meth_name(span);\n                 let defid = if declid.krate == ast::LOCAL_CRATE {\n-                    let ti = ty::impl_or_trait_item(&self.analysis.ty_cx,\n-                                                    declid);\n+                    let ti = ty::impl_or_trait_item(self.tcx, declid);\n                     match provenence {\n                         def::FromTrait(def_id) => {\n-                            Some(ty::trait_items(&self.analysis.ty_cx,\n-                                                 def_id)\n+                            Some(ty::trait_items(self.tcx, def_id)\n                                     .iter()\n                                     .find(|mr| {\n                                         mr.name() == ti.name()\n@@ -803,16 +788,13 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                     .def_id())\n                         }\n                         def::FromImpl(def_id) => {\n-                            let impl_items = self.analysis\n-                                                 .ty_cx\n-                                                 .impl_items\n-                                                 .borrow();\n+                            let impl_items = self.tcx.impl_items.borrow();\n                             Some(impl_items.get(&def_id)\n                                            .unwrap()\n                                            .iter()\n                                            .find(|mr| {\n                                                 ty::impl_or_trait_item(\n-                                                    &self.analysis.ty_cx,\n+                                                    self.tcx,\n                                                     mr.def_id()\n                                                 ).name() == ti.name()\n                                             })\n@@ -844,7 +826,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         // modules or types in the path prefix\n         match def {\n             def::DefMethod(did, _) => {\n-                let ti = ty::impl_or_trait_item(&self.analysis.ty_cx, did);\n+                let ti = ty::impl_or_trait_item(self.tcx, did);\n                 if let ty::MethodTraitItem(m) = ti {\n                     if m.explicit_self == ty::StaticExplicitSelfCategory {\n                         self.write_sub_path_trait_truncated(path);\n@@ -906,24 +888,21 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     fn process_method_call(&mut self,\n                            ex: &ast::Expr,\n                            args: &Vec<P<ast::Expr>>) {\n-        let method_map = self.analysis.ty_cx.method_map.borrow();\n+        let method_map = self.tcx.method_map.borrow();\n         let method_callee = method_map.get(&ty::MethodCall::expr(ex.id)).unwrap();\n         let (def_id, decl_id) = match method_callee.origin {\n             ty::MethodStatic(def_id) |\n             ty::MethodStaticClosure(def_id) => {\n                 // method invoked on an object with a concrete type (not a static method)\n                 let decl_id =\n-                    match ty::trait_item_of_item(&self.analysis.ty_cx,\n-                                                 def_id) {\n+                    match ty::trait_item_of_item(self.tcx, def_id) {\n                         None => None,\n                         Some(decl_id) => Some(decl_id.def_id()),\n                     };\n \n                 // This incantation is required if the method referenced is a\n                 // trait's default implementation.\n-                let def_id = match ty::impl_or_trait_item(&self.analysis\n-                                                               .ty_cx,\n-                                                          def_id) {\n+                let def_id = match ty::impl_or_trait_item(self.tcx, def_id) {\n                     ty::MethodTraitItem(method) => {\n                         method.provided_source.unwrap_or(def_id)\n                     }\n@@ -936,14 +915,14 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             }\n             ty::MethodTypeParam(ref mp) => {\n                 // method invoked on a type parameter\n-                let trait_item = ty::trait_item(&self.analysis.ty_cx,\n+                let trait_item = ty::trait_item(self.tcx,\n                                                 mp.trait_ref.def_id,\n                                                 mp.method_num);\n                 (None, Some(trait_item.def_id()))\n             }\n             ty::MethodTraitObject(ref mo) => {\n                 // method invoked on a trait instance\n-                let trait_item = ty::trait_item(&self.analysis.ty_cx,\n+                let trait_item = ty::trait_item(self.tcx,\n                                                 mo.trait_ref.def_id,\n                                                 mo.method_num);\n                 (None, Some(trait_item.def_id()))\n@@ -969,12 +948,12 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             ast::PatStruct(ref path, ref fields, _) => {\n                 visit::walk_path(self, path);\n \n-                let def = self.analysis.ty_cx.def_map.borrow().get(&p.id).unwrap().full_def();\n+                let def = self.tcx.def_map.borrow().get(&p.id).unwrap().full_def();\n                 let struct_def = match def {\n                     def::DefConst(..) | def::DefAssociatedConst(..) => None,\n                     def::DefVariant(_, variant_id, _) => Some(variant_id),\n                     _ => {\n-                        match ty::ty_to_def_id(ty::node_id_to_type(&self.analysis.ty_cx, p.id)) {\n+                        match ty::ty_to_def_id(ty::node_id_to_type(self.tcx, p.id)) {\n                             None => {\n                                 self.sess.span_bug(p.span,\n                                                    &format!(\"Could not find struct_def for `{}`\",\n@@ -986,7 +965,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                 };\n \n                 if let Some(struct_def) = struct_def {\n-                    let struct_fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_def);\n+                    let struct_fields = ty::lookup_struct_fields(self.tcx, struct_def);\n                     for &Spanned { node: ref field, span } in fields {\n                         let sub_span = self.span.span_for_first_ident(span);\n                         for f in &struct_fields {\n@@ -1145,7 +1124,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 self.nest(item.id, |v| visit::walk_mod(v, m));\n             }\n             ast::ItemTy(ref ty, ref ty_params) => {\n-                let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+                let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n                 let value = ty_to_string(&**ty);\n                 let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n                 self.fmt.typedef_str(item.span,\n@@ -1273,10 +1252,10 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n \n                 self.visit_expr(&**sub_ex);\n \n-                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty;\n+                let ty = &ty::expr_ty_adjusted(self.tcx, &**sub_ex).sty;\n                 match *ty {\n                     ty::TyStruct(def_id, _) => {\n-                        let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n+                        let fields = ty::lookup_struct_fields(self.tcx, def_id);\n                         for (i, f) in fields.iter().enumerate() {\n                             if i == idx.node {\n                                 let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n@@ -1342,7 +1321,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n         let mut paths_to_process = vec![];\n         // process collected paths\n         for &(id, ref p, immut, ref_kind) in &collector.collected_paths {\n-            let def_map = self.analysis.ty_cx.def_map.borrow();\n+            let def_map = self.tcx.def_map.borrow();\n             if !def_map.contains_key(&id) {\n                 self.sess.span_bug(p.span,\n                                    &format!(\"def_map has no key for {} in visit_arm\",\n@@ -1410,8 +1389,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n             } else {\n                 \"<mutable>\".to_string()\n             };\n-            let types = self.analysis.ty_cx.node_types();\n-            let typ = ppaux::ty_to_string(&self.analysis.ty_cx, *types.get(&id).unwrap());\n+            let types = self.tcx.node_types();\n+            let typ = types.get(&id).unwrap().to_string();\n             // Get the span only for the name of the variable (I hope the path\n             // is only ever a variable name, but who knows?).\n             let sub_span = self.span.span_for_last_ident(p.span);"}, {"sha": "fdfb101ed78cc4be6485a13a7caa40a30869469d", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 41, "deletions": 50, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use session::Session;\n use middle::ty;\n use middle::def;\n \n@@ -24,8 +23,6 @@ use syntax::parse::token::{self, get_ident, keywords};\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::ty_to_string;\n \n-use util::ppaux;\n-\n use self::span_utils::SpanUtils;\n \n \n@@ -35,8 +32,7 @@ mod recorder;\n mod dump_csv;\n \n pub struct SaveContext<'l, 'tcx: 'l> {\n-    sess: &'l Session,\n-    analysis: &'l ty::CrateAnalysis<'tcx>,\n+    tcx: &'l ty::ctxt<'tcx>,\n     span_utils: SpanUtils<'l>,\n }\n \n@@ -143,13 +139,11 @@ pub struct TypeRefData {\n \n \n impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n-    pub fn new(sess: &'l Session,\n-               analysis: &'l ty::CrateAnalysis<'tcx>,\n+    pub fn new(tcx: &'l ty::ctxt<'tcx>,\n                span_utils: SpanUtils<'l>)\n                -> SaveContext<'l, 'tcx> {\n         SaveContext {\n-            sess: sess,\n-            analysis: analysis,\n+            tcx: tcx,\n             span_utils: span_utils,\n         }\n     }\n@@ -158,7 +152,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_external_crates(&self) -> Vec<CrateData> {\n         let mut result = Vec::new();\n \n-        self.sess.cstore.iter_crate_data(|n, cmd| {\n+        self.tcx.sess.cstore.iter_crate_data(|n, cmd| {\n             result.push(CrateData { name: cmd.name.clone(), number: n });\n         });\n \n@@ -168,7 +162,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_item_data(&self, item: &ast::Item) -> Data {\n         match item.node {\n             ast::ItemFn(..) => {\n-                let name = self.analysis.ty_cx.map.path_to_string(item.id);\n+                let name = self.tcx.map.path_to_string(item.id);\n                 let qualname = format!(\"::{}\", name);\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Fn);\n \n@@ -178,11 +172,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     qualname: qualname,\n                     declaration: None,\n                     span: sub_span.unwrap(),\n-                    scope: self.analysis.ty_cx.map.get_parent(item.id),\n+                    scope: self.tcx.map.get_parent(item.id),\n                 })\n             }\n             ast::ItemStatic(ref typ, mt, ref expr) => {\n-                let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+                let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n \n                 // If the variable is immutable, save the initialising expression.\n                 let (value, keyword) = match mt {\n@@ -197,29 +191,29 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     name: get_ident(item.ident).to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n-                    scope: self.analysis.ty_cx.map.get_parent(item.id),\n+                    scope: self.tcx.map.get_parent(item.id),\n                     value: value,\n                     type_value: ty_to_string(&typ),\n                 })\n             }\n             ast::ItemConst(ref typ, ref expr) => {\n-                let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+                let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Const);\n \n                 Data::VariableData(VariableData {\n                     id: item.id,\n                     name: get_ident(item.ident).to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n-                    scope: self.analysis.ty_cx.map.get_parent(item.id),\n+                    scope: self.tcx.map.get_parent(item.id),\n                     value: self.span_utils.snippet(expr.span),\n                     type_value: ty_to_string(&typ),\n                 })\n             }\n             ast::ItemMod(ref m) => {\n-                let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+                let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n \n-                let cm = self.sess.codemap();\n+                let cm = self.tcx.sess.codemap();\n                 let filename = cm.span_to_filename(m.inner);\n \n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Mod);\n@@ -229,12 +223,12 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     name: get_ident(item.ident).to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n-                    scope: self.analysis.ty_cx.map.get_parent(item.id),\n+                    scope: self.tcx.map.get_parent(item.id),\n                     filename: filename,\n                 })\n             },\n             ast::ItemEnum(..) => {\n-                let enum_name = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+                let enum_name = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n                 let val = self.span_utils.snippet(item.span);\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Enum);\n \n@@ -243,14 +237,14 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     value: val,\n                     span: sub_span.unwrap(),\n                     qualname: enum_name,\n-                    scope: self.analysis.ty_cx.map.get_parent(item.id),\n+                    scope: self.tcx.map.get_parent(item.id),\n                 })\n             },\n             ast::ItemImpl(_, _, _, ref trait_ref, ref typ, _) => {\n                 let mut type_data = None;\n                 let sub_span;\n \n-                let parent = self.analysis.ty_cx.map.get_parent(item.id);\n+                let parent = self.tcx.map.get_parent(item.id);\n \n                 match typ.node {\n                     // Common case impl for a struct or something basic.\n@@ -294,11 +288,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             ast::NamedField(ident, _) => {\n                 let name = get_ident(ident);\n                 let qualname = format!(\"::{}::{}\",\n-                                       self.analysis.ty_cx.map.path_to_string(parent),\n+                                       self.tcx.map.path_to_string(parent),\n                                        name);\n-                let typ = ppaux::ty_to_string(&self.analysis.ty_cx,\n-                                              *self.analysis.ty_cx.node_types()\n-                                                  .get(&field.node.id).unwrap());\n+                let typ = self.tcx.node_types().get(&field.node.id).unwrap()\n+                                               .to_string();\n                 let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n                 Some(Data::VariableData(VariableData {\n                     id: field.node.id,\n@@ -334,26 +327,25 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n         match expr.node {\n             ast::ExprField(ref sub_ex, ident) => {\n-                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &sub_ex).sty;\n+                let ty = &ty::expr_ty_adjusted(self.tcx, &sub_ex).sty;\n                 match *ty {\n                     ty::TyStruct(def_id, _) => {\n-                        let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n+                        let fields = ty::lookup_struct_fields(self.tcx, def_id);\n                         for f in &fields {\n                             if f.name == ident.node.name {\n                                 let sub_span = self.span_utils.span_for_last_ident(expr.span);\n                                 return Some(Data::VariableRefData(VariableRefData {\n                                     name: get_ident(ident.node).to_string(),\n                                     span: sub_span.unwrap(),\n-                                    scope: self.analysis.ty_cx.map.get_parent(expr.id),\n+                                    scope: self.tcx.map.get_parent(expr.id),\n                                     ref_id: f.id,\n                                 }));\n                             }\n                         }\n \n-                        self.sess.span_bug(expr.span,\n-                                           &format!(\"Couldn't find field {} on {:?}\",\n-                                                    &get_ident(ident.node),\n-                                                    ty))\n+                        self.tcx.sess.span_bug(expr.span,\n+                                               &format!(\"Couldn't find field {} on {:?}\",\n+                                                        &get_ident(ident.node), ty))\n                     }\n                     _ => {\n                         debug!(\"Expected struct type, found {:?}\", ty);\n@@ -362,13 +354,13 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprStruct(ref path, _, _) => {\n-                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, expr).sty;\n+                let ty = &ty::expr_ty_adjusted(&self.tcx, expr).sty;\n                 match *ty {\n                     ty::TyStruct(def_id, _) => {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n                         Some(Data::TypeRefData(TypeRefData {\n                             span: sub_span.unwrap(),\n-                            scope: self.analysis.ty_cx.map.get_parent(expr.id),\n+                            scope: self.tcx.map.get_parent(expr.id),\n                             ref_id: def_id,\n                         }))\n                     }\n@@ -392,7 +384,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                               struct_id: DefId,\n                               parent: NodeId)\n                               -> VariableRefData {\n-        let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_id);\n+        let fields = ty::lookup_struct_fields(&self.tcx, struct_id);\n         let field_name = get_ident(field_ref.ident.node).to_string();\n         for f in &fields {\n             if f.name == field_ref.ident.node.name {\n@@ -407,8 +399,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n         }\n \n-        self.sess.span_bug(field_ref.span,\n-                           &format!(\"Couldn't find field {}\", field_name));\n+        self.tcx.sess.span_bug(field_ref.span,\n+                               &format!(\"Couldn't find field {}\", field_name));\n     }\n \n     pub fn get_data_for_id(&self, _id: &NodeId) -> Data {\n@@ -417,11 +409,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n \n     fn lookup_ref_id(&self, ref_id: NodeId) -> Option<DefId> {\n-        if !self.analysis.ty_cx.def_map.borrow().contains_key(&ref_id) {\n-            self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n-                                  ref_id));\n+        if !self.tcx.def_map.borrow().contains_key(&ref_id) {\n+            self.tcx.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n+                                       ref_id));\n         }\n-        let def = self.analysis.ty_cx.def_map.borrow().get(&ref_id).unwrap().full_def();\n+        let def = self.tcx.def_map.borrow().get(&ref_id).unwrap().full_def();\n         match def {\n             def::DefPrimTy(_) => None,\n             _ => Some(def.def_id()),\n@@ -484,10 +476,10 @@ impl<'v> Visitor<'v> for PathCollector {\n }\n \n #[allow(deprecated)]\n-pub fn process_crate(sess: &Session,\n-                     krate: &ast::Crate,\n+pub fn process_crate(tcx: &ty::ctxt,\n                      analysis: &ty::CrateAnalysis,\n                      odir: Option<&Path>) {\n+    let krate = tcx.map.krate();\n     if generated_code(krate.span) {\n         return;\n     }\n@@ -512,10 +504,9 @@ pub fn process_crate(sess: &Session,\n         },\n     };\n \n-    match fs::create_dir_all(&root_path) {\n-        Err(e) => sess.err(&format!(\"Could not create directory {}: {}\",\n-                           root_path.display(), e)),\n-        _ => (),\n+    if let Err(e) = fs::create_dir_all(&root_path) {\n+        tcx.sess.err(&format!(\"Could not create directory {}: {}\",\n+                              root_path.display(), e));\n     }\n \n     {\n@@ -531,12 +522,12 @@ pub fn process_crate(sess: &Session,\n         Ok(f) => box f,\n         Err(e) => {\n             let disp = root_path.display();\n-            sess.fatal(&format!(\"Could not open {}: {}\", disp, e));\n+            tcx.sess.fatal(&format!(\"Could not open {}: {}\", disp, e));\n         }\n     };\n     root_path.pop();\n \n-    let mut visitor = dump_csv::DumpCsvVisitor::new(sess, analysis, output_file);\n+    let mut visitor = dump_csv::DumpCsvVisitor::new(tcx, analysis, output_file);\n \n     visitor.dump_crate_info(&cratename, krate);\n     visit::walk_crate(&mut visitor, krate);"}, {"sha": "05672153b018a5899f3d0b2860d0def701860a1f", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -217,10 +217,11 @@ use middle::ty::{self, Ty};\n use session::config::{NoDebugInfo, FullDebugInfo};\n use util::common::indenter;\n use util::nodemap::FnvHashMap;\n-use util::ppaux::{Repr, vec_map_to_string};\n+use util::ppaux;\n \n use std;\n use std::cmp::Ordering;\n+use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::ast::{DUMMY_NODE_ID, NodeId};\n@@ -371,13 +372,13 @@ struct Match<'a, 'p: 'a, 'blk: 'a, 'tcx: 'blk> {\n     pat_renaming_map: Option<&'a FnvHashMap<(NodeId, Span), NodeId>>\n }\n \n-impl<'a, 'p, 'blk, 'tcx> Repr<'tcx> for Match<'a, 'p, 'blk, 'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n-        if tcx.sess.verbose() {\n+impl<'a, 'p, 'blk, 'tcx> fmt::Debug for Match<'a, 'p, 'blk, 'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if ppaux::verbose() {\n             // for many programs, this just take too long to serialize\n-            self.pats.repr(tcx)\n+            write!(f, \"{:?}\", self.pats)\n         } else {\n-            format!(\"{} pats\", self.pats.len())\n+            write!(f, \"{} pats\", self.pats.len())\n         }\n     }\n }\n@@ -397,9 +398,9 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                               col: usize,\n                                               val: ValueRef)\n                                               -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n-    debug!(\"expand_nested_bindings(bcx={}, m={}, col={}, val={})\",\n+    debug!(\"expand_nested_bindings(bcx={}, m={:?}, col={}, val={})\",\n            bcx.to_str(),\n-           m.repr(bcx.tcx()),\n+           m,\n            col,\n            bcx.val_to_string(val));\n     let _indenter = indenter();\n@@ -437,9 +438,9 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                           -> Vec<Match<'a, 'p, 'blk, 'tcx>> where\n     F: FnMut(&[&'p ast::Pat]) -> Option<Vec<&'p ast::Pat>>,\n {\n-    debug!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n+    debug!(\"enter_match(bcx={}, m={:?}, col={}, val={})\",\n            bcx.to_str(),\n-           m.repr(bcx.tcx()),\n+           m,\n            col,\n            bcx.val_to_string(val));\n     let _indenter = indenter();\n@@ -480,9 +481,9 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      col: usize,\n                                      val: ValueRef)\n                                      -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n-    debug!(\"enter_default(bcx={}, m={}, col={}, val={})\",\n+    debug!(\"enter_default(bcx={}, m={:?}, col={}, val={})\",\n            bcx.to_str(),\n-           m.repr(bcx.tcx()),\n+           m,\n            col,\n            bcx.val_to_string(val));\n     let _indenter = indenter();\n@@ -537,9 +538,9 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n              variant_size: usize,\n              val: ValueRef)\n              -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n-    debug!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n+    debug!(\"enter_opt(bcx={}, m={:?}, opt={:?}, col={}, val={})\",\n            bcx.to_str(),\n-           m.repr(bcx.tcx()),\n+           m,\n            *opt,\n            col,\n            bcx.val_to_string(val));\n@@ -825,8 +826,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                -> Result<'blk, 'tcx> {\n         let did = langcall(cx,\n                            None,\n-                           &format!(\"comparison of `{}`\",\n-                                   cx.ty_to_string(rhs_t)),\n+                           &format!(\"comparison of `{}`\", rhs_t),\n                            StrEqFnLangItem);\n         let t = ty::mk_str_slice(cx.tcx(), cx.tcx().mk_region(ty::ReStatic), ast::MutImmutable);\n         // The comparison function gets the slices by value, so we have to make copies here. Even\n@@ -937,11 +937,11 @@ fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      chk: &FailureHandler,\n                                      has_genuine_default: bool)\n                                      -> Block<'blk, 'tcx> {\n-    debug!(\"compile_guard(bcx={}, guard_expr={}, m={}, vals={})\",\n+    debug!(\"compile_guard(bcx={}, guard_expr={:?}, m={:?}, vals=[{}])\",\n            bcx.to_str(),\n-           bcx.expr_to_string(guard_expr),\n-           m.repr(bcx.tcx()),\n-           vec_map_to_string(vals, |v| bcx.val_to_string(*v)));\n+           guard_expr,\n+           m,\n+           vals.iter().map(|v| bcx.val_to_string(*v)).collect::<Vec<_>>().connect(\", \"));\n     let _indenter = indenter();\n \n     let mut bcx = insert_lllocals(bcx, &data.bindings_map, None);\n@@ -983,10 +983,10 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         vals: &[ValueRef],\n                                         chk: &FailureHandler,\n                                         has_genuine_default: bool) {\n-    debug!(\"compile_submatch(bcx={}, m={}, vals={})\",\n+    debug!(\"compile_submatch(bcx={}, m={:?}, vals=[{}])\",\n            bcx.to_str(),\n-           m.repr(bcx.tcx()),\n-           vec_map_to_string(vals, |v| bcx.val_to_string(*v)));\n+           m,\n+           vals.iter().map(|v| bcx.val_to_string(*v)).collect::<Vec<_>>().connect(\", \"));\n     let _indenter = indenter();\n     let _icx = push_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n@@ -1696,13 +1696,13 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     val: ValueRef,\n                                     cleanup_scope: cleanup::ScopeId)\n                                     -> Block<'blk, 'tcx> {\n-    debug!(\"bind_irrefutable_pat(bcx={}, pat={})\",\n+    debug!(\"bind_irrefutable_pat(bcx={}, pat={:?})\",\n            bcx.to_str(),\n-           pat.repr(bcx.tcx()));\n+           pat);\n \n     if bcx.sess().asm_comments() {\n-        add_comment(bcx, &format!(\"bind_irrefutable_pat(pat={})\",\n-                                 pat.repr(bcx.tcx())));\n+        add_comment(bcx, &format!(\"bind_irrefutable_pat(pat={:?})\",\n+                                 pat));\n     }\n \n     let _indenter = indenter();"}, {"sha": "2a1c2457b9d32d5a6d7d287a07710698809ae5a8", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -66,7 +66,6 @@ use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n-use util::ppaux::ty_to_string;\n \n type Hint = attr::ReprAttr;\n \n@@ -143,7 +142,7 @@ pub fn represent_node<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn represent_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 t: Ty<'tcx>)\n                                 -> Rc<Repr<'tcx>> {\n-    debug!(\"Representing: {}\", ty_to_string(cx.tcx(), t));\n+    debug!(\"Representing: {}\", t);\n     match cx.adt_reprs().borrow().get(&t) {\n         Some(repr) => return repr.clone(),\n         None => {}\n@@ -381,8 +380,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             General(ity, fields, dtor_to_init_u8(dtor))\n         }\n-        _ => cx.sess().bug(&format!(\"adt::represent_type called on non-ADT type: {}\",\n-                           ty_to_string(cx.tcx(), t)))\n+        _ => cx.sess().bug(&format!(\"adt::represent_type called on non-ADT type: {}\", t))\n     }\n }\n "}, {"sha": "0b212cbeb86a2506656f3a49398eb3afa28f9c76", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -80,7 +80,6 @@ use trans::type_of;\n use trans::type_of::*;\n use trans::value::Value;\n use util::common::indenter;\n-use util::ppaux::{Repr, ty_to_string};\n use util::sha2::Sha256;\n use util::nodemap::NodeMap;\n \n@@ -250,9 +249,7 @@ fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     match bcx.tcx().lang_items.require(it) {\n         Ok(id) => id,\n         Err(s) => {\n-            bcx.sess().fatal(&format!(\"allocation of `{}` {}\",\n-                                     bcx.ty_to_string(info_ty),\n-                                     s));\n+            bcx.sess().fatal(&format!(\"allocation of `{}` {}\", info_ty, s));\n         }\n     }\n }\n@@ -530,8 +527,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n           }\n       }\n       _ => {\n-          cx.sess().unimpl(&format!(\"type in iter_structural_ty: {}\",\n-                                   ty_to_string(cx.tcx(), t)))\n+          cx.sess().unimpl(&format!(\"type in iter_structural_ty: {}\", t))\n       }\n     }\n     return cx;\n@@ -640,8 +636,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n             (res, false)\n         }\n         _ => {\n-            cx.sess().bug(&format!(\"fail-if-zero on unexpected type: {}\",\n-                                  ty_to_string(cx.tcx(), rhs_t)));\n+            cx.sess().bug(&format!(\"fail-if-zero on unexpected type: {}\", rhs_t));\n         }\n     };\n     let bcx = with_cond(cx, is_zero, |bcx| {\n@@ -1192,13 +1187,13 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n                              -> FunctionContext<'a, 'tcx> {\n     common::validate_substs(param_substs);\n \n-    debug!(\"new_fn_ctxt(path={}, id={}, param_substs={})\",\n+    debug!(\"new_fn_ctxt(path={}, id={}, param_substs={:?})\",\n            if id == !0 {\n                \"\".to_string()\n            } else {\n                ccx.tcx().map.path_to_string(id).to_string()\n            },\n-           id, param_substs.repr(ccx.tcx()));\n+           id, param_substs);\n \n     let uses_outptr = match output_type {\n         ty::FnConverging(output_type) => {\n@@ -1515,8 +1510,8 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let _icx = push_ctxt(\"trans_closure\");\n     attributes::emit_uwtable(llfndecl, true);\n \n-    debug!(\"trans_closure(..., param_substs={})\",\n-           param_substs.repr(ccx.tcx()));\n+    debug!(\"trans_closure(..., param_substs={:?})\",\n+           param_substs);\n \n     let has_env = match closure_env {\n         closure::ClosureEnv::Closure(_) => true,\n@@ -1558,8 +1553,8 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     };\n     for monomorphized_arg_type in &monomorphized_arg_types {\n-        debug!(\"trans_closure: monomorphized_arg_type: {}\",\n-               ty_to_string(ccx.tcx(), *monomorphized_arg_type));\n+        debug!(\"trans_closure: monomorphized_arg_type: {:?}\",\n+               monomorphized_arg_type);\n     }\n     debug!(\"trans_closure: function lltype: {}\",\n            bcx.fcx.ccx.tn().val_to_string(bcx.fcx.llfn));\n@@ -1641,7 +1636,7 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                           id: ast::NodeId,\n                           attrs: &[ast::Attribute]) {\n     let _s = StatRecorder::new(ccx, ccx.tcx().map.path_to_string(id).to_string());\n-    debug!(\"trans_fn(param_substs={})\", param_substs.repr(ccx.tcx()));\n+    debug!(\"trans_fn(param_substs={:?})\", param_substs);\n     let _icx = push_ctxt(\"trans_fn\");\n     let fn_ty = ty::node_id_to_type(ccx.tcx(), id);\n     let output_type = ty::erase_late_bound_regions(ccx.tcx(), &ty::ty_fn_ret(fn_ty));\n@@ -1676,7 +1671,6 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                  -> Result<'blk, 'tcx> {\n \n     let ccx = bcx.fcx.ccx;\n-    let tcx = ccx.tcx();\n \n     let result_ty = match ctor_ty.sty {\n         ty::TyBareFn(_, ref bft) => {\n@@ -1685,7 +1679,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         _ => ccx.sess().bug(\n             &format!(\"trans_enum_variant_constructor: \\\n                      unexpected ctor return type {}\",\n-                     ctor_ty.repr(tcx)))\n+                     ctor_ty))\n     };\n \n     // Get location to store the result. If the user does not care about\n@@ -1763,7 +1757,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n         _ => ccx.sess().bug(\n             &format!(\"trans_enum_variant_or_tuple_like_struct: \\\n                      unexpected ctor return type {}\",\n-                    ty_to_string(ccx.tcx(), ctor_ty)))\n+                    ctor_ty))\n     };\n \n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n@@ -2496,7 +2490,7 @@ fn register_method(ccx: &CrateContext, id: ast::NodeId,\n     }\n }\n \n-pub fn crate_ctxt_to_encode_parms<'a, 'tcx>(cx: &'a SharedCrateContext<'tcx>,\n+pub fn crate_ctxt_to_encode_parms<'a, 'tcx>(cx: &'a SharedCrateContext<'a, 'tcx>,\n                                             ie: encoder::EncodeInlinedItem<'a>)\n                                             -> encoder::EncodeParams<'a, 'tcx> {\n     encoder::EncodeParams {\n@@ -2632,9 +2626,8 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n     }\n }\n \n-pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n-                         -> (ty::ctxt<'tcx>, CrateTranslation) {\n-    let ty::CrateAnalysis { ty_cx: tcx, export_map, reachable, name, .. } = analysis;\n+pub fn trans_crate(tcx: &ty::ctxt, analysis: ty::CrateAnalysis) -> CrateTranslation {\n+    let ty::CrateAnalysis { export_map, reachable, name, .. } = analysis;\n     let krate = tcx.map.krate();\n \n     let check_overflow = if let Some(v) = tcx.sess.opts.debugging_opts.force_overflow_checks {\n@@ -2774,15 +2767,13 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n     let formats = shared_ccx.tcx().dependency_formats.borrow().clone();\n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n \n-    let translation = CrateTranslation {\n+    CrateTranslation {\n         modules: modules,\n         metadata_module: metadata_module,\n         link: link_meta,\n         metadata: metadata,\n         reachable: reachable,\n         crate_formats: formats,\n         no_builtins: no_builtins,\n-    };\n-\n-    (shared_ccx.take_tcx(), translation)\n+    }\n }"}, {"sha": "46f762a5195851877ab1ae8bcf55545d544780a1", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -54,8 +54,6 @@ use trans::type_of;\n use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n use rustc::ast_map;\n-use util::ppaux::Repr;\n-use util::ppaux::ty_to_string;\n \n use syntax::abi as synabi;\n use syntax::ast;\n@@ -90,7 +88,7 @@ pub struct Callee<'blk, 'tcx: 'blk> {\n fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                      -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_callee\");\n-    debug!(\"callee::trans(expr={})\", expr.repr(bcx.tcx()));\n+    debug!(\"callee::trans(expr={:?})\", expr);\n \n     // pick out special kinds of expressions that can be called:\n     match expr.node {\n@@ -118,7 +116,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 bcx.tcx().sess.span_bug(\n                     expr.span,\n                     &format!(\"type of callee is neither bare-fn nor closure: {}\",\n-                             bcx.ty_to_string(datum.ty)));\n+                             datum.ty));\n             }\n         }\n     }\n@@ -135,7 +133,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                              def: def::Def,\n                              ref_expr: &ast::Expr)\n                              -> Callee<'blk, 'tcx> {\n-        debug!(\"trans_def(def={}, ref_expr={})\", def.repr(bcx.tcx()), ref_expr.repr(bcx.tcx()));\n+        debug!(\"trans_def(def={:?}, ref_expr={:?})\", def, ref_expr);\n         let expr_ty = common::node_id_type(bcx, ref_expr.id);\n         match def {\n             def::DefFn(did, _) if {\n@@ -229,10 +227,10 @@ pub fn trans_fn_ref<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let _icx = push_ctxt(\"trans_fn_ref\");\n \n     let substs = common::node_id_substs(ccx, node, param_substs);\n-    debug!(\"trans_fn_ref(def_id={}, node={:?}, substs={})\",\n-           def_id.repr(ccx.tcx()),\n+    debug!(\"trans_fn_ref(def_id={:?}, node={:?}, substs={:?})\",\n+           def_id,\n            node,\n-           substs.repr(ccx.tcx()));\n+           substs);\n     trans_fn_ref_with_substs(ccx, def_id, node, param_substs, substs)\n }\n \n@@ -292,8 +290,8 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n         None => { }\n     }\n \n-    debug!(\"trans_fn_pointer_shim(bare_fn_ty={})\",\n-           bare_fn_ty.repr(tcx));\n+    debug!(\"trans_fn_pointer_shim(bare_fn_ty={:?})\",\n+           bare_fn_ty);\n \n     // Construct the \"tuply\" version of `bare_fn_ty`. It takes two arguments: `self`,\n     // which is the fn pointer, and `args`, which is the arguments tuple.\n@@ -308,7 +306,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n \n             _ => {\n                 tcx.sess.bug(&format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n-                                           bare_fn_ty.repr(tcx)));\n+                                      bare_fn_ty));\n             }\n         };\n     let sig = ty::erase_late_bound_regions(tcx, sig);\n@@ -324,7 +322,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                                              output: sig.output,\n                                              variadic: false\n                                          })}));\n-    debug!(\"tuple_fn_ty: {}\", tuple_fn_ty.repr(tcx));\n+    debug!(\"tuple_fn_ty: {:?}\", tuple_fn_ty);\n \n     //\n     let function_name = link::mangle_internal_name_by_type_and_seq(ccx, bare_fn_ty,\n@@ -402,12 +400,12 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     let _icx = push_ctxt(\"trans_fn_ref_with_substs\");\n     let tcx = ccx.tcx();\n \n-    debug!(\"trans_fn_ref_with_substs(def_id={}, node={:?}, \\\n-            param_substs={}, substs={})\",\n-           def_id.repr(tcx),\n+    debug!(\"trans_fn_ref_with_substs(def_id={:?}, node={:?}, \\\n+            param_substs={:?}, substs={:?})\",\n+           def_id,\n            node,\n-           param_substs.repr(tcx),\n-           substs.repr(tcx));\n+           param_substs,\n+           substs);\n \n     assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n     assert!(substs.types.all(|t| !ty::type_has_escaping_regions(*t)));\n@@ -458,10 +456,10 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n                     let new_substs = tcx.mk_substs(first_subst.subst(tcx, &substs));\n \n                     debug!(\"trans_fn_with_vtables - default method: \\\n-                            substs = {}, trait_subst = {}, \\\n-                            first_subst = {}, new_subst = {}\",\n-                           substs.repr(tcx), trait_ref.substs.repr(tcx),\n-                           first_subst.repr(tcx), new_substs.repr(tcx));\n+                            substs = {:?}, trait_subst = {:?}, \\\n+                            first_subst = {:?}, new_subst = {:?}\",\n+                           substs, trait_ref.substs,\n+                           first_subst, new_substs);\n \n                     (true, source_id, new_substs)\n                 }\n@@ -505,8 +503,8 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n         false\n     };\n \n-    debug!(\"trans_fn_ref_with_substs({}) must_monomorphise: {}\",\n-           def_id.repr(tcx), must_monomorphise);\n+    debug!(\"trans_fn_ref_with_substs({:?}) must_monomorphise: {}\",\n+           def_id, must_monomorphise);\n \n     // Create a monomorphic version of generic functions\n     if must_monomorphise {\n@@ -616,7 +614,7 @@ pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                          dest: expr::Dest)\n                                          -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_method_call\");\n-    debug!(\"trans_method_call(call_expr={})\", call_expr.repr(bcx.tcx()));\n+    debug!(\"trans_method_call(call_expr={:?})\", call_expr);\n     let method_call = MethodCall::expr(call_expr.id);\n     let method_ty = match bcx.tcx().method_map.borrow().get(&method_call) {\n         Some(method) => match method.origin {\n@@ -1126,8 +1124,8 @@ pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = bcx;\n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_arg_datum({})\",\n-           formal_arg_ty.repr(bcx.tcx()));\n+    debug!(\"trans_arg_datum({:?})\",\n+           formal_arg_ty);\n \n     let arg_datum_ty = arg_datum.ty;\n \n@@ -1166,8 +1164,8 @@ pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, formal_arg_ty);\n         debug!(\"casting actual type ({}) to match formal ({})\",\n                bcx.val_to_string(val), bcx.llty_str(llformal_arg_ty));\n-        debug!(\"Rust types: {}; {}\", ty_to_string(bcx.tcx(), arg_datum_ty),\n-                                     ty_to_string(bcx.tcx(), formal_arg_ty));\n+        debug!(\"Rust types: {:?}; {:?}\", arg_datum_ty,\n+                                     formal_arg_ty);\n         val = PointerCast(bcx, val, llformal_arg_ty);\n     }\n "}, {"sha": "6355a713a2ce61b1898062f89b5fd57598d3a955", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -133,7 +133,6 @@ use trans::type_::Type;\n use middle::ty::{self, Ty};\n use std::fmt;\n use syntax::ast;\n-use util::ppaux::Repr;\n \n pub struct CleanupScope<'blk, 'tcx: 'blk> {\n     // The id of this cleanup scope. If the id is None,\n@@ -397,10 +396,10 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             skip_dtor: false,\n         };\n \n-        debug!(\"schedule_drop_mem({:?}, val={}, ty={}) fill_on_drop={} skip_dtor={}\",\n+        debug!(\"schedule_drop_mem({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n-               ty.repr(self.ccx.tcx()),\n+               ty,\n                drop.fill_on_drop,\n                drop.skip_dtor);\n \n@@ -423,10 +422,10 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             skip_dtor: false,\n         };\n \n-        debug!(\"schedule_drop_and_fill_mem({:?}, val={}, ty={}, fill_on_drop={}, skip_dtor={})\",\n+        debug!(\"schedule_drop_and_fill_mem({:?}, val={}, ty={:?}, fill_on_drop={}, skip_dtor={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n-               ty.repr(self.ccx.tcx()),\n+               ty,\n                drop.fill_on_drop,\n                drop.skip_dtor);\n \n@@ -455,10 +454,10 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             skip_dtor: true,\n         };\n \n-        debug!(\"schedule_drop_adt_contents({:?}, val={}, ty={}) fill_on_drop={} skip_dtor={}\",\n+        debug!(\"schedule_drop_adt_contents({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n-               ty.repr(self.ccx.tcx()),\n+               ty,\n                drop.fill_on_drop,\n                drop.skip_dtor);\n \n@@ -484,7 +483,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         debug!(\"schedule_drop_immediate({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n-               ty.repr(self.ccx.tcx()),\n+               ty,\n                drop.fill_on_drop,\n                drop.skip_dtor);\n "}, {"sha": "91b0a6c00696fb08998c15f402d869b3f603c481", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -28,7 +28,6 @@ use trans::type_of::*;\n use middle::ty::{self, ClosureTyper};\n use middle::subst::Substs;\n use session::config::FullDebugInfo;\n-use util::ppaux::Repr;\n \n use syntax::abi::RustCall;\n use syntax::ast;\n@@ -353,9 +352,9 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     llreffn: ValueRef)\n     -> ValueRef\n {\n-    debug!(\"trans_fn_once_adapter_shim(closure_def_id={}, substs={}, llreffn={})\",\n-           closure_def_id.repr(ccx.tcx()),\n-           substs.repr(ccx.tcx()),\n+    debug!(\"trans_fn_once_adapter_shim(closure_def_id={:?}, substs={:?}, llreffn={})\",\n+           closure_def_id,\n+           substs,\n            ccx.tn().val_to_string(llreffn));\n \n     let tcx = ccx.tcx();\n@@ -374,8 +373,8 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n                                                                abi: abi,\n                                                                sig: sig.clone() });\n     let llref_fn_ty = ty::mk_bare_fn(tcx, None, llref_bare_fn_ty);\n-    debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={}\",\n-           llref_fn_ty.repr(tcx));\n+    debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={:?}\",\n+           llref_fn_ty);\n \n     // Make a version of the closure type with the same arguments, but\n     // with argument #0 being by value.\n@@ -423,8 +422,8 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let input_tys = match sig.inputs[1].sty {\n         ty::TyTuple(ref tys) => &**tys,\n         _ => bcx.sess().bug(&format!(\"trans_fn_once_adapter_shim: not rust-call! \\\n-                                      closure_def_id={}\",\n-                                     closure_def_id.repr(tcx)))\n+                                      closure_def_id={:?}\",\n+                                     closure_def_id))\n     };\n     let llargs: Vec<_> =\n         input_tys.iter()"}, {"sha": "5dddf161e69fbf802adf6622a01923356213f7f4", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 25, "deletions": 34, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -41,7 +41,6 @@ use middle::ty::{self, HasProjectionTypes, Ty};\n use middle::ty_fold;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use rustc::ast_map::{PathElem, PathName};\n-use util::ppaux::Repr;\n use util::nodemap::{FnvHashMap, NodeMap};\n \n use arena::TypedArena;\n@@ -64,11 +63,11 @@ pub use trans::context::CrateContext;\n /// subtyping, but they are anonymized and normalized as well). This\n /// is a stronger, caching version of `ty_fold::erase_regions`.\n pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    where T : TypeFoldable<'tcx>\n {\n     let value1 = value.fold_with(&mut RegionEraser(cx));\n-    debug!(\"erase_regions({}) = {}\",\n-           value.repr(cx), value1.repr(cx));\n+    debug!(\"erase_regions({:?}) = {:?}\",\n+           value, value1);\n     return value1;\n \n     struct RegionEraser<'a, 'tcx: 'a>(&'a ty::ctxt<'tcx>);\n@@ -88,7 +87,7 @@ pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n         }\n \n         fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n-            where T : TypeFoldable<'tcx> + Repr<'tcx>\n+            where T : TypeFoldable<'tcx>\n         {\n             let u = ty::anonymize_late_bound_regions(self.tcx(), t);\n             ty_fold::super_fold_binder(self, &u)\n@@ -212,7 +211,7 @@ fn type_needs_drop_given_env<'a,'tcx>(cx: &ty::ctxt<'tcx>,\n     // destructor (e.g. zero its memory on move).\n \n     let contents = ty::type_contents(cx, ty);\n-    debug!(\"type_needs_drop ty={} contents={:?}\", ty.repr(cx), contents);\n+    debug!(\"type_needs_drop ty={:?} contents={:?}\", ty, contents);\n     contents.needs_drop(cx)\n }\n \n@@ -518,7 +517,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     }\n \n     pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+        where T : TypeFoldable<'tcx> + HasProjectionTypes\n     {\n         monomorphize::apply_param_substs(self.ccx.tcx(),\n                                          self.param_substs,\n@@ -593,10 +592,6 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n         self.tcx().map.node_to_string(id).to_string()\n     }\n \n-    pub fn expr_to_string(&self, e: &ast::Expr) -> String {\n-        e.repr(self.tcx())\n-    }\n-\n     pub fn def(&self, nid: ast::NodeId) -> def::Def {\n         match self.tcx().def_map.borrow().get(&nid) {\n             Some(v) => v.full_def(),\n@@ -615,16 +610,12 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n         self.ccx().tn().type_to_string(ty)\n     }\n \n-    pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n-        t.repr(self.tcx())\n-    }\n-\n     pub fn to_str(&self) -> String {\n         format!(\"[block {:p}]\", self)\n     }\n \n     pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+        where T : TypeFoldable<'tcx> + HasProjectionTypes\n     {\n         monomorphize::apply_param_substs(self.tcx(),\n                                          self.fcx.param_substs,\n@@ -994,14 +985,14 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // First check the cache.\n     match ccx.trait_cache().borrow().get(&trait_ref) {\n         Some(vtable) => {\n-            info!(\"Cache hit: {}\", trait_ref.repr(ccx.tcx()));\n+            info!(\"Cache hit: {:?}\", trait_ref);\n             return (*vtable).clone();\n         }\n         None => { }\n     }\n \n-    debug!(\"trans fulfill_obligation: trait_ref={} def_id={:?}\",\n-           trait_ref.repr(ccx.tcx()), trait_ref.def_id());\n+    debug!(\"trans fulfill_obligation: trait_ref={:?} def_id={:?}\",\n+           trait_ref, trait_ref.def_id());\n \n     ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n     let infcx = infer::new_infer_ctxt(tcx);\n@@ -1022,19 +1013,19 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // leading to an ambiguous result. So report this as an\n             // overflow bug, since I believe this is the only case\n             // where ambiguity can result.\n-            debug!(\"Encountered ambiguity selecting `{}` during trans, \\\n+            debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n                     presuming due to overflow\",\n-                   trait_ref.repr(tcx));\n+                   trait_ref);\n             ccx.sess().span_fatal(\n                 span,\n                 \"reached the recursion limit during monomorphization\");\n         }\n         Err(e) => {\n             tcx.sess.span_bug(\n                 span,\n-                &format!(\"Encountered error `{}` selecting `{}` during trans\",\n-                        e.repr(tcx),\n-                        trait_ref.repr(tcx)))\n+                &format!(\"Encountered error `{:?}` selecting `{:?}` during trans\",\n+                        e,\n+                        trait_ref))\n         }\n     };\n \n@@ -1047,7 +1038,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     });\n     let vtable = drain_fulfillment_cx_or_panic(span, &infcx, &mut fulfill_cx, &vtable);\n \n-    info!(\"Cache miss: {}\", trait_ref.repr(ccx.tcx()));\n+    info!(\"Cache miss: {:?}\", trait_ref);\n     ccx.trait_cache().borrow_mut().insert(trait_ref,\n                                           vtable.clone());\n \n@@ -1062,8 +1053,8 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                predicates: Vec<ty::Predicate<'tcx>>)\n                                                -> bool\n {\n-    debug!(\"normalize_and_test_predicates(predicates={})\",\n-           predicates.repr(ccx.tcx()));\n+    debug!(\"normalize_and_test_predicates(predicates={:?})\",\n+           predicates);\n \n     let tcx = ccx.tcx();\n     let infcx = infer::new_infer_ctxt(tcx);\n@@ -1135,15 +1126,15 @@ pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n                                                 fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n                                                 result: &T)\n                                                 -> T\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    where T : TypeFoldable<'tcx>\n {\n     match drain_fulfillment_cx(infcx, fulfill_cx, result) {\n         Ok(v) => v,\n         Err(errors) => {\n             infcx.tcx.sess.span_bug(\n                 span,\n-                &format!(\"Encountered errors `{}` fulfilling during trans\",\n-                         errors.repr(infcx.tcx)));\n+                &format!(\"Encountered errors `{:?}` fulfilling during trans\",\n+                         errors));\n         }\n     }\n }\n@@ -1159,10 +1150,10 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &infer::InferCtxt<'a,'tcx>,\n                                        fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n                                        result: &T)\n                                        -> StdResult<T,Vec<traits::FulfillmentError<'tcx>>>\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    where T : TypeFoldable<'tcx>\n {\n-    debug!(\"drain_fulfillment_cx(result={})\",\n-           result.repr(infcx.tcx));\n+    debug!(\"drain_fulfillment_cx(result={:?})\",\n+           result);\n \n     // In principle, we only need to do this so long as `result`\n     // contains unbound type parameters. It could be a slight\n@@ -1210,7 +1201,7 @@ pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     if substs.types.any(|t| ty::type_needs_infer(*t)) {\n             tcx.sess.bug(&format!(\"type parameters for node {:?} include inference types: {:?}\",\n-                                 node, substs.repr(tcx)));\n+                                 node, substs));\n         }\n \n         monomorphize::apply_param_substs(tcx,"}, {"sha": "ad6358e057367fbf270a65f8d5a580a4144717e8", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -32,7 +32,6 @@ use trans::type_of;\n use middle::cast::{CastTy,IntTy};\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n-use util::ppaux::{Repr, ty_to_string};\n use util::nodemap::NodeMap;\n \n use std::iter::repeat;\n@@ -66,9 +65,9 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n                     C_integral(Type::uint_from_ty(cx, t), i as u64, false)\n                 }\n                 _ => cx.sess().span_bug(lit.span,\n-                        &format!(\"integer literal has type {} (expected int \\\n+                        &format!(\"integer literal has type {:?} (expected int \\\n                                  or usize)\",\n-                                ty_to_string(cx.tcx(), lit_int_ty)))\n+                                lit_int_ty))\n             }\n         }\n         ast::LitFloat(ref fs, t) => {\n@@ -160,8 +159,8 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n         }\n         None => {\n-            cx.sess().bug(&format!(\"unexpected dereferenceable type {}\",\n-                                   ty_to_string(cx.tcx(), ty)))\n+            cx.sess().bug(&format!(\"unexpected dereferenceable type {:?}\",\n+                                   ty))\n         }\n     }\n }\n@@ -368,8 +367,8 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             llvm::LLVMDumpValue(llconst);\n             llvm::LLVMDumpValue(C_undef(llty));\n         }\n-        cx.sess().bug(&format!(\"const {} of type {} has size {} instead of {}\",\n-                         e.repr(cx.tcx()), ty_to_string(cx.tcx(), ety_adjusted),\n+        cx.sess().bug(&format!(\"const {:?} of type {:?} has size {} instead of {}\",\n+                         e, ety_adjusted,\n                          csize, tsize));\n     }\n     (llconst, ety_adjusted)\n@@ -476,10 +475,10 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    fn_args: FnArgMap)\n                                    -> ValueRef\n {\n-    debug!(\"const_expr_unadjusted(e={}, ety={}, param_substs={})\",\n-           e.repr(cx.tcx()),\n-           ety.repr(cx.tcx()),\n-           param_substs.repr(cx.tcx()));\n+    debug!(\"const_expr_unadjusted(e={:?}, ety={:?}, param_substs={:?})\",\n+           e,\n+           ety,\n+           param_substs);\n \n     let map_list = |exprs: &[P<ast::Expr>]| -> Vec<ValueRef> {\n         exprs.iter()\n@@ -496,9 +495,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             /* Neither type is bottom, and we expect them to be unified\n              * already, so the following is safe. */\n             let (te1, ty) = const_expr(cx, &**e1, param_substs, fn_args);\n-            debug!(\"const_expr_unadjusted: te1={}, ty={}\",\n+            debug!(\"const_expr_unadjusted: te1={}, ty={:?}\",\n                    cx.tn().val_to_string(te1),\n-                   ty.repr(cx.tcx()));\n+                   ty);\n             let is_simd = ty::type_is_simd(cx.tcx(), ty);\n             let intype = if is_simd {\n                 ty::simd_type(cx.tcx(), ty)\n@@ -620,13 +619,13 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       },\n                       _ => cx.sess().span_bug(base.span,\n                                               &format!(\"index-expr base must be a vector \\\n-                                                       or string type, found {}\",\n-                                                      ty_to_string(cx.tcx(), bt)))\n+                                                       or string type, found {:?}\",\n+                                                      bt))\n                   },\n                   _ => cx.sess().span_bug(base.span,\n                                           &format!(\"index-expr base must be a vector \\\n-                                                   or string type, found {}\",\n-                                                  ty_to_string(cx.tcx(), bt)))\n+                                                   or string type, found {:?}\",\n+                                                  bt))\n               };\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n@@ -654,7 +653,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let t_cast = ety;\n             let llty = type_of::type_of(cx, t_cast);\n             let (v, t_expr) = const_expr(cx, &**base, param_substs, fn_args);\n-            debug!(\"trans_const_cast({} as {})\", t_expr.repr(cx.tcx()), t_cast.repr(cx.tcx()));\n+            debug!(\"trans_const_cast({:?} as {:?})\", t_expr, t_cast);\n             if expr::cast_is_noop(cx.tcx(), base, t_expr, t_cast) {\n                 return v;\n             }"}, {"sha": "0ae69682f914ac591276604014a3ec698dea5ebf", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -28,7 +28,6 @@ use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use session::config::NoDebugInfo;\n use session::Session;\n-use util::ppaux::Repr;\n use util::sha2::Sha256;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, FnvHashMap, FnvHashSet};\n \n@@ -57,7 +56,7 @@ pub struct Stats {\n /// per crate.  The data here is shared between all compilation units of the\n /// crate, so it must not contain references to any LLVM data structures\n /// (aside from metadata-related ones).\n-pub struct SharedCrateContext<'tcx> {\n+pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     local_ccxs: Vec<LocalCrateContext<'tcx>>,\n \n     metadata_llmod: ModuleRef,\n@@ -68,7 +67,7 @@ pub struct SharedCrateContext<'tcx> {\n     item_symbols: RefCell<NodeMap<String>>,\n     link_meta: LinkMeta,\n     symbol_hasher: RefCell<Sha256>,\n-    tcx: ty::ctxt<'tcx>,\n+    tcx: &'a ty::ctxt<'tcx>,\n     stats: Stats,\n     check_overflow: bool,\n     check_drop_flag_for_sanity: bool,\n@@ -159,15 +158,15 @@ pub struct LocalCrateContext<'tcx> {\n }\n \n pub struct CrateContext<'a, 'tcx: 'a> {\n-    shared: &'a SharedCrateContext<'tcx>,\n+    shared: &'a SharedCrateContext<'a, 'tcx>,\n     local: &'a LocalCrateContext<'tcx>,\n     /// The index of `local` in `shared.local_ccxs`.  This is used in\n     /// `maybe_iter(true)` to identify the original `LocalCrateContext`.\n     index: usize,\n }\n \n pub struct CrateContextIterator<'a, 'tcx: 'a> {\n-    shared: &'a SharedCrateContext<'tcx>,\n+    shared: &'a SharedCrateContext<'a, 'tcx>,\n     index: usize,\n }\n \n@@ -192,7 +191,7 @@ impl<'a, 'tcx> Iterator for CrateContextIterator<'a,'tcx> {\n \n /// The iterator produced by `CrateContext::maybe_iter`.\n pub struct CrateContextMaybeIterator<'a, 'tcx: 'a> {\n-    shared: &'a SharedCrateContext<'tcx>,\n+    shared: &'a SharedCrateContext<'a, 'tcx>,\n     index: usize,\n     single: bool,\n     origin: usize,\n@@ -237,17 +236,17 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n     (llcx, llmod)\n }\n \n-impl<'tcx> SharedCrateContext<'tcx> {\n+impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     pub fn new(crate_name: &str,\n                local_count: usize,\n-               tcx: ty::ctxt<'tcx>,\n+               tcx: &'b ty::ctxt<'tcx>,\n                export_map: ExportMap,\n                symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n                reachable: NodeSet,\n                check_overflow: bool,\n                check_drop_flag_for_sanity: bool)\n-               -> SharedCrateContext<'tcx> {\n+               -> SharedCrateContext<'b, 'tcx> {\n         let (metadata_llcx, metadata_llmod) = unsafe {\n             create_context_and_module(&tcx.sess, \"metadata\")\n         };\n@@ -397,10 +396,6 @@ impl<'tcx> SharedCrateContext<'tcx> {\n     }\n \n     pub fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n-        &self.tcx\n-    }\n-\n-    pub fn take_tcx(self) -> ty::ctxt<'tcx> {\n         self.tcx\n     }\n \n@@ -418,7 +413,7 @@ impl<'tcx> SharedCrateContext<'tcx> {\n }\n \n impl<'tcx> LocalCrateContext<'tcx> {\n-    fn new(shared: &SharedCrateContext<'tcx>,\n+    fn new<'a>(shared: &SharedCrateContext<'a, 'tcx>,\n            name: &str)\n            -> LocalCrateContext<'tcx> {\n         unsafe {\n@@ -505,7 +500,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n     /// This is used in the `LocalCrateContext` constructor to allow calling\n     /// functions that expect a complete `CrateContext`, even before the local\n     /// portion is fully initialized and attached to the `SharedCrateContext`.\n-    fn dummy_ccx<'a>(&'a self, shared: &'a SharedCrateContext<'tcx>)\n+    fn dummy_ccx<'a>(&'a self, shared: &'a SharedCrateContext<'a, 'tcx>)\n                      -> CrateContext<'a, 'tcx> {\n         CrateContext {\n             shared: shared,\n@@ -516,7 +511,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n }\n \n impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n-    pub fn shared(&self) -> &'b SharedCrateContext<'tcx> {\n+    pub fn shared(&self) -> &'b SharedCrateContext<'b, 'tcx> {\n         self.shared\n     }\n \n@@ -548,7 +543,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n \n \n     pub fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n-        &self.shared.tcx\n+        self.shared.tcx\n     }\n \n     pub fn sess<'a>(&'a self) -> &'a Session {\n@@ -770,8 +765,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n \n     pub fn report_overbig_object(&self, obj: Ty<'tcx>) -> ! {\n         self.sess().fatal(\n-            &format!(\"the type `{}` is too big for the current architecture\",\n-                    obj.repr(self.tcx())))\n+            &format!(\"the type `{:?}` is too big for the current architecture\",\n+                    obj))\n     }\n \n     pub fn check_overflow(&self) -> bool {"}, {"sha": "ceef07207acb837f92a38ea58a66027d63156d4e", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -24,7 +24,6 @@ use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::expr;\n use trans;\n use middle::ty;\n-use util::ppaux::Repr;\n \n use syntax::ast;\n use syntax::ast_util;\n@@ -36,14 +35,14 @@ pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                               -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_stmt\");\n     let fcx = cx.fcx;\n-    debug!(\"trans_stmt({})\", s.repr(cx.tcx()));\n+    debug!(\"trans_stmt({:?})\", s);\n \n     if cx.unreachable.get() {\n         return cx;\n     }\n \n     if cx.sess().asm_comments() {\n-        add_span_comment(cx, s.span, &s.repr(cx.tcx()));\n+        add_span_comment(cx, s.span, &format!(\"{:?}\", s));\n     }\n \n     let mut bcx = cx;\n@@ -151,8 +150,8 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             els: Option<&ast::Expr>,\n                             dest: expr::Dest)\n                             -> Block<'blk, 'tcx> {\n-    debug!(\"trans_if(bcx={}, if_id={}, cond={}, thn={}, dest={})\",\n-           bcx.to_str(), if_id, bcx.expr_to_string(cond), thn.id,\n+    debug!(\"trans_if(bcx={}, if_id={}, cond={:?}, thn={}, dest={})\",\n+           bcx.to_str(), if_id, cond, thn.id,\n            dest.to_string(bcx.ccx()));\n     let _icx = push_ctxt(\"trans_if\");\n "}, {"sha": "e60e4e4abe05336712dda9d90333015cb4a68833", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -102,7 +102,6 @@ use trans::expr;\n use trans::tvec;\n use trans::type_of;\n use middle::ty::{self, Ty};\n-use util::ppaux::ty_to_string;\n \n use std::fmt;\n use syntax::ast;\n@@ -614,9 +613,9 @@ impl<'tcx, K: KindOps + fmt::Debug> Datum<'tcx, K> {\n \n     #[allow(dead_code)] // useful for debugging\n     pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n-        format!(\"Datum({}, {}, {:?})\",\n+        format!(\"Datum({}, {:?}, {:?})\",\n                 ccx.tn().val_to_string(self.val),\n-                ty_to_string(ccx.tcx(), self.ty),\n+                self.ty,\n                 self.kind)\n     }\n "}, {"sha": "7660f59e1d08b0061bd79a92b0164083f8354cbe", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -34,7 +34,6 @@ use trans::type_::Type;\n use middle::ty::{self, Ty, ClosureTyper};\n use session::config::{self, FullDebugInfo};\n use util::nodemap::FnvHashMap;\n-use util::ppaux;\n use util::common::path2cstr;\n \n use libc::{c_uint, c_longlong};\n@@ -105,7 +104,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                        metadata: DIType) {\n         if self.type_to_metadata.insert(type_, metadata).is_some() {\n             cx.sess().bug(&format!(\"Type metadata for Ty '{}' is already in the TypeMap!\",\n-                                   ppaux::ty_to_string(cx.tcx(), type_)));\n+                                   type_));\n         }\n     }\n \n@@ -297,9 +296,8 @@ impl<'tcx> TypeMap<'tcx> {\n                                                         &mut unique_type_id);\n             },\n             _ => {\n-                cx.sess().bug(&format!(\"get_unique_type_id_of_type() - unexpected type: {}, {:?}\",\n-                                      &ppaux::ty_to_string(cx.tcx(), type_),\n-                                      type_.sty))\n+                cx.sess().bug(&format!(\"get_unique_type_id_of_type() - unexpected type: {:?}\",\n+                                       type_))\n             }\n         };\n \n@@ -489,8 +487,8 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                     if type_map.find_metadata_for_unique_id(unique_type_id).is_none() ||\n                        type_map.find_metadata_for_type(unfinished_type).is_none() {\n                         cx.sess().bug(&format!(\"Forward declaration of potentially recursive type \\\n-                                              '{}' was not found in TypeMap!\",\n-                                              ppaux::ty_to_string(cx.tcx(), unfinished_type))\n+                                              '{:?}' was not found in TypeMap!\",\n+                                              unfinished_type)\n                                       );\n                     }\n                 }\n@@ -676,10 +674,9 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let def_id = match trait_type.sty {\n         ty::TyTrait(ref data) => data.principal_def_id(),\n         _ => {\n-            let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_type);\n             cx.sess().bug(&format!(\"debuginfo: Unexpected trait-object type in \\\n-                                   trait_pointer_metadata(): {}\",\n-                                   &pp_type_name[..]));\n+                                   trait_pointer_metadata(): {:?}\",\n+                                   trait_type));\n         }\n     };\n \n@@ -841,7 +838,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                  the debuginfo::TypeMap but it \\\n                                                  was not. (Ty = {})\",\n                                                 &unique_type_id_str[..],\n-                                                ppaux::ty_to_string(cx.tcx(), t));\n+                                                t);\n                     cx.sess().span_bug(usage_site_span, &error_message[..]);\n                 }\n             };\n@@ -856,7 +853,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                      debuginfo::TypeMap. \\\n                                                      UniqueTypeId={}, Ty={}\",\n                             &unique_type_id_str[..],\n-                            ppaux::ty_to_string(cx.tcx(), t));\n+                            t);\n                         cx.sess().span_bug(usage_site_span, &error_message[..]);\n                     }\n                 }"}, {"sha": "5ba5ecb02c024c1b9f51cd63d0b78fc77bf527df", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -15,9 +15,9 @@ use super::namespace::crate_root_namespace;\n use trans::common::CrateContext;\n use middle::subst::{self, Substs};\n use middle::ty::{self, Ty, ClosureTyper};\n+\n use syntax::ast;\n use syntax::parse::token;\n-use util::ppaux;\n \n \n // Compute the name of the type as it should be stored in debuginfo. Does not do\n@@ -162,7 +162,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyProjection(..) |\n         ty::TyParam(_) => {\n             cx.sess().bug(&format!(\"debuginfo: Trying to create type name for \\\n-                unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t)));\n+                unexpected type: {:?}\", t));\n         }\n     }\n "}, {"sha": "8bc3326d30093ea598f9b11f0ed6dcde339faf5f", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -29,7 +29,6 @@ use trans::context::CrateContext;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n-use util::ppaux::Repr;\n \n use std::ffi::CString;\n use libc::c_uint;\n@@ -106,11 +105,11 @@ pub fn declare_cfn(ccx: &CrateContext, name: &str, fn_type: Type,\n /// update the declaration and return existing ValueRef instead.\n pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n                                  fn_type: ty::Ty<'tcx>) -> ValueRef {\n-    debug!(\"declare_rust_fn(name={:?}, fn_type={})\", name,\n-           fn_type.repr(ccx.tcx()));\n+    debug!(\"declare_rust_fn(name={:?}, fn_type={:?})\", name,\n+           fn_type);\n     let fn_type = monomorphize::normalize_associated_type(ccx.tcx(), &fn_type);\n-    debug!(\"declare_rust_fn (after normalised associated types) fn_type={}\",\n-           fn_type.repr(ccx.tcx()));\n+    debug!(\"declare_rust_fn (after normalised associated types) fn_type={:?}\",\n+           fn_type);\n \n     let function_type; // placeholder so that the memory ownership works out ok\n     let (sig, abi, env) = match fn_type.sty {\n@@ -122,15 +121,15 @@ pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n             function_type = typer.closure_type(closure_did, substs);\n             let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);\n             let llenvironment_type = type_of::type_of_explicit_arg(ccx, self_type);\n-            debug!(\"declare_rust_fn function_type={} self_type={}\",\n-                   function_type.repr(ccx.tcx()), self_type.repr(ccx.tcx()));\n+            debug!(\"declare_rust_fn function_type={:?} self_type={:?}\",\n+                   function_type, self_type);\n             (&function_type.sig, abi::RustCall, Some(llenvironment_type))\n         }\n         _ => ccx.sess().bug(\"expected closure or fn\")\n     };\n \n     let sig = ty::Binder(ty::erase_late_bound_regions(ccx.tcx(), sig));\n-    debug!(\"declare_rust_fn (after region erasure) sig={}\", sig.repr(ccx.tcx()));\n+    debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n     let llfty = type_of::type_of_rust_fn(ccx, env, &sig, abi);\n     debug!(\"declare_rust_fn llfty={}\", ccx.tn().type_to_string(llfty));\n "}, {"sha": "48deceeeef73f5b839b56d2f56c5cb72b21ac11b", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -78,7 +78,6 @@ use middle::ty::{AdjustDerefRef, AdjustReifyFnPointer, AdjustUnsafeFnPointer};\n use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n use util::common::indenter;\n-use util::ppaux::Repr;\n use trans::machine::{llsize_of, llsize_of_alloc};\n use trans::type_::Type;\n \n@@ -181,7 +180,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    debug!(\"trans_into() expr={}\", expr.repr(bcx.tcx()));\n+    debug!(\"trans_into() expr={:?}\", expr);\n \n     let cleanup_debug_loc = debuginfo::get_cleanup_debug_loc_for_ast_node(bcx.ccx(),\n                                                                           expr.id,\n@@ -211,7 +210,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                          expr: &ast::Expr)\n                          -> DatumBlock<'blk, 'tcx, Expr> {\n-    debug!(\"trans(expr={})\", bcx.expr_to_string(expr));\n+    debug!(\"trans(expr={:?})\", expr);\n \n     let mut bcx = bcx;\n     let fcx = bcx.fcx;\n@@ -329,9 +328,9 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n             consts::ptrcast(meth::get_vtable(ccx, trait_ref, param_substs),\n                             Type::vtable_ptr(ccx))\n         }\n-        _ => ccx.sess().bug(&format!(\"unsized_info: invalid unsizing {} -> {}\",\n-                                     source.repr(ccx.tcx()),\n-                                     target.repr(ccx.tcx())))\n+        _ => ccx.sess().bug(&format!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n+                                     source,\n+                                     target))\n     }\n }\n \n@@ -350,8 +349,8 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         Some(adj) => { adj }\n     };\n-    debug!(\"unadjusted datum for expr {}: {} adjustment={:?}\",\n-           expr.repr(bcx.tcx()),\n+    debug!(\"unadjusted datum for expr {:?}: {} adjustment={:?}\",\n+           expr,\n            datum.to_string(bcx.ccx()),\n            adjustment);\n     match adjustment {\n@@ -501,8 +500,8 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     ty::custom_coerce_unsized_kind(bcx.tcx(), impl_def_id)\n                 }\n                 vtable => {\n-                    bcx.sess().span_bug(span, &format!(\"invalid CoerceUnsized vtable: {}\",\n-                                                       vtable.repr(bcx.tcx())));\n+                    bcx.sess().span_bug(span, &format!(\"invalid CoerceUnsized vtable: {:?}\",\n+                                                       vtable));\n                 }\n             };\n \n@@ -545,9 +544,9 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n             }\n         }\n-        _ => bcx.sess().bug(&format!(\"coerce_unsized: invalid coercion {} -> {}\",\n-                                     source.ty.repr(bcx.tcx()),\n-                                     target.ty.repr(bcx.tcx())))\n+        _ => bcx.sess().bug(&format!(\"coerce_unsized: invalid coercion {:?} -> {:?}\",\n+                                     source.ty,\n+                                     target.ty))\n     }\n     bcx\n }\n@@ -575,7 +574,7 @@ fn trans_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 -> DatumBlock<'blk, 'tcx, Expr> {\n     let mut bcx = bcx;\n \n-    debug!(\"trans_unadjusted(expr={})\", bcx.expr_to_string(expr));\n+    debug!(\"trans_unadjusted(expr={:?})\", expr);\n     let _indenter = indenter();\n \n     debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n@@ -1281,9 +1280,9 @@ pub fn trans_def_fn_unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         _ => {\n             ccx.tcx().sess.span_bug(ref_expr.span, &format!(\n-                    \"trans_def_fn_unadjusted invoked on: {:?} for {}\",\n+                    \"trans_def_fn_unadjusted invoked on: {:?} for {:?}\",\n                     def,\n-                    ref_expr.repr(ccx.tcx())));\n+                    ref_expr));\n         }\n     }\n }\n@@ -1317,7 +1316,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n             };\n             debug!(\"take_local(nid={}, v={}, ty={})\",\n-                   nid, bcx.val_to_string(datum.val), bcx.ty_to_string(datum.ty));\n+                   nid, bcx.val_to_string(datum.val), datum.ty);\n             datum\n         }\n         _ => {\n@@ -1354,9 +1353,9 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n             match node_id_opt {\n                 None => {\n                     tcx.sess.bug(&format!(\n-                        \"cannot get field types from the enum type {} \\\n+                        \"cannot get field types from the enum type {:?} \\\n                          without a node ID\",\n-                        ty.repr(tcx)));\n+                        ty));\n                 }\n                 Some(node_id) => {\n                     let def = tcx.def_map.borrow().get(&node_id).unwrap().full_def();\n@@ -1378,8 +1377,8 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n \n         _ => {\n             tcx.sess.bug(&format!(\n-                \"cannot get field types from the type {}\",\n-                ty.repr(tcx)));\n+                \"cannot get field types from the type {:?}\",\n+                ty));\n         }\n     }\n }\n@@ -2060,7 +2059,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let t_in = expr_ty_adjusted(bcx, expr);\n     let t_out = node_id_type(bcx, id);\n \n-    debug!(\"trans_cast({} as {})\", t_in.repr(bcx.tcx()), t_out.repr(bcx.tcx()));\n+    debug!(\"trans_cast({:?} as {:?})\", t_in, t_out);\n     let mut ll_t_in = type_of::arg_type_of(ccx, t_in);\n     let ll_t_out = type_of::arg_type_of(ccx, t_out);\n     // Convert the value to be cast into a ValueRef, either by-ref or\n@@ -2123,9 +2122,9 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         _ => ccx.sess().span_bug(expr.span,\n                                   &format!(\"translating unsupported cast: \\\n-                                            {} -> {}\",\n-                                           t_in.repr(bcx.tcx()),\n-                                           t_out.repr(bcx.tcx()))\n+                                            {:?} -> {:?}\",\n+                                           t_in,\n+                                           t_out)\n                                  )\n     };\n     return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n@@ -2140,7 +2139,7 @@ fn trans_assign_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_assign_op\");\n     let mut bcx = bcx;\n \n-    debug!(\"trans_assign_op(expr={})\", bcx.expr_to_string(expr));\n+    debug!(\"trans_assign_op(expr={:?})\", expr);\n \n     // User-defined operator methods cannot be used with `+=` etc right now\n     assert!(!bcx.tcx().method_map.borrow().contains_key(&MethodCall::expr(expr.id)));\n@@ -2210,8 +2209,8 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                           -> DatumBlock<'blk, 'tcx, Expr> {\n     let ccx = bcx.ccx();\n \n-    debug!(\"deref_once(expr={}, datum={}, method_call={:?})\",\n-           expr.repr(bcx.tcx()),\n+    debug!(\"deref_once(expr={:?}, datum={}, method_call={:?})\",\n+           expr,\n            datum.to_string(ccx),\n            method_call);\n \n@@ -2295,8 +2294,8 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                &format!(\"deref invoked on expr of illegal type {}\",\n-                        datum.ty.repr(bcx.tcx())));\n+                &format!(\"deref invoked on expr of illegal type {:?}\",\n+                        datum.ty));\n         }\n     };\n "}, {"sha": "977d636d253e4cee7053ca35e257e1c84b68edd3", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -40,7 +40,6 @@ use syntax::parse::token;\n use syntax::ast;\n use syntax::attr;\n use syntax::print::pprust;\n-use util::ppaux::Repr;\n \n ///////////////////////////////////////////////////////////////////////////\n // Type definitions\n@@ -183,11 +182,11 @@ pub fn get_extern_fn(ccx: &CrateContext,\n pub fn register_foreign_item_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                           abi: Abi, fty: Ty<'tcx>,\n                                           name: &str) -> ValueRef {\n-    debug!(\"register_foreign_item_fn(abi={}, \\\n-            ty={}, \\\n+    debug!(\"register_foreign_item_fn(abi={:?}, \\\n+            ty={:?}, \\\n             name={})\",\n-           abi.repr(ccx.tcx()),\n-           fty.repr(ccx.tcx()),\n+           abi,\n+           fty,\n            name);\n \n     let cc = llvm_calling_convention(ccx, abi);\n@@ -233,12 +232,11 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      -> Block<'blk, 'tcx>\n {\n     let ccx = bcx.ccx();\n-    let tcx = bcx.tcx();\n \n-    debug!(\"trans_native_call(callee_ty={}, \\\n+    debug!(\"trans_native_call(callee_ty={:?}, \\\n             llfn={}, \\\n             llretptr={})\",\n-           callee_ty.repr(tcx),\n+           callee_ty,\n            ccx.tn().val_to_string(llfn),\n            ccx.tn().val_to_string(llretptr));\n \n@@ -610,16 +608,16 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 assert!(f.abi != Rust && f.abi != RustIntrinsic);\n             }\n             _ => {\n-                ccx.sess().bug(&format!(\"build_rust_fn: extern fn {} has ty {}, \\\n+                ccx.sess().bug(&format!(\"build_rust_fn: extern fn {} has ty {:?}, \\\n                                         expected a bare fn ty\",\n                                        ccx.tcx().map.path_to_string(id),\n-                                       t.repr(tcx)));\n+                                       t));\n             }\n         };\n \n-        debug!(\"build_rust_fn: path={} id={} t={}\",\n+        debug!(\"build_rust_fn: path={} id={} t={:?}\",\n                ccx.tcx().map.path_to_string(id),\n-               id, t.repr(tcx));\n+               id, t);\n \n         let llfn = declare::define_internal_rust_fn(ccx, &ps[..], t).unwrap_or_else(||{\n             ccx.sess().bug(&format!(\"symbol `{}` already defined\", ps));\n@@ -636,12 +634,11 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                       t: Ty<'tcx>) {\n         let _icx = push_ctxt(\n             \"foreign::trans_rust_fn_with_foreign_abi::build_wrap_fn\");\n-        let tcx = ccx.tcx();\n \n-        debug!(\"build_wrap_fn(llrustfn={}, llwrapfn={}, t={})\",\n+        debug!(\"build_wrap_fn(llrustfn={}, llwrapfn={}, t={:?})\",\n                ccx.tn().val_to_string(llrustfn),\n                ccx.tn().val_to_string(llwrapfn),\n-               t.repr(ccx.tcx()));\n+               t);\n \n         // Avoid all the Rust generation stuff and just generate raw\n         // LLVM here.\n@@ -723,10 +720,10 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     debug!(\"out pointer, \\\n                             allocad={}, \\\n                             llrust_ret_ty={}, \\\n-                            return_ty={}\",\n+                            return_ty={:?}\",\n                            ccx.tn().val_to_string(slot),\n                            ccx.tn().type_to_string(llrust_ret_ty),\n-                           tys.fn_sig.output.repr(tcx));\n+                           tys.fn_sig.output);\n                     llrust_args.push(slot);\n                     return_alloca = Some(slot);\n                 }\n@@ -817,8 +814,8 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n \n         // Perform the call itself\n-        debug!(\"calling llrustfn = {}, t = {}\",\n-               ccx.tn().val_to_string(llrustfn), t.repr(ccx.tcx()));\n+        debug!(\"calling llrustfn = {}, t = {:?}\",\n+               ccx.tn().val_to_string(llrustfn), t);\n         let attributes = attributes::from_fn_type(ccx, t);\n         let llrust_ret_val = builder.call(llrustfn, &llrust_args, Some(attributes));\n \n@@ -936,11 +933,11 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                        llsig.llret_ty,\n                                        llsig.ret_def);\n     debug!(\"foreign_types_for_fn_ty(\\\n-           ty={}, \\\n+           ty={:?}, \\\n            llsig={} -> {}, \\\n            fn_ty={} -> {}, \\\n            ret_def={}\",\n-           ty.repr(ccx.tcx()),\n+           ty,\n            ccx.tn().types_to_str(&llsig.llarg_tys),\n            ccx.tn().type_to_string(llsig.llret_ty),\n            ccx.tn().types_to_str(&fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>()),"}, {"sha": "6caf00634b63aa65b6fb7d4e487b5da47287ab47", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -39,8 +39,6 @@ use trans::machine::*;\n use trans::monomorphize;\n use trans::type_of::{type_of, type_of_dtor, sizing_type_of, align_of};\n use trans::type_::Type;\n-use util::ppaux;\n-use util::ppaux::{ty_to_short_str, Repr};\n \n use arena::TypedArena;\n use libc::c_uint;\n@@ -141,7 +139,7 @@ pub fn drop_ty_core<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 debug_loc: DebugLoc,\n                                 skip_dtor: bool) -> Block<'blk, 'tcx> {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    debug!(\"drop_ty_core(t={}, skip_dtor={})\", t.repr(bcx.tcx()), skip_dtor);\n+    debug!(\"drop_ty_core(t={:?}, skip_dtor={})\", t, skip_dtor);\n     let _icx = push_ctxt(\"drop_ty\");\n     if bcx.fcx.type_needs_drop(t) {\n         let ccx = bcx.ccx();\n@@ -204,21 +202,13 @@ impl<'tcx> DropGlueKind<'tcx> {\n             DropGlueKind::TyContents(t) => DropGlueKind::TyContents(f(t)),\n         }\n     }\n-\n-    fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n-        let t_str = ppaux::ty_to_string(ccx.tcx(), self.ty());\n-        match *self {\n-            DropGlueKind::Ty(_) => format!(\"DropGlueKind::Ty({})\", t_str),\n-            DropGlueKind::TyContents(_) => format!(\"DropGlueKind::TyContents({})\", t_str),\n-        }\n-    }\n }\n \n fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 g: DropGlueKind<'tcx>) -> ValueRef {\n-    debug!(\"make drop glue for {}\", g.to_string(ccx));\n+    debug!(\"make drop glue for {:?}\", g);\n     let g = g.map_ty(|t| get_drop_glue_type(ccx, t));\n-    debug!(\"drop glue type {}\", g.to_string(ccx));\n+    debug!(\"drop glue type {:?}\", g);\n     match ccx.drop_glues().borrow().get(&g) {\n         Some(&glue) => return glue,\n         _ => { }\n@@ -247,7 +237,7 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     });\n     ccx.available_drop_glues().borrow_mut().insert(g, fn_nm);\n \n-    let _s = StatRecorder::new(ccx, format!(\"drop {}\", ty_to_short_str(ccx.tcx(), t)));\n+    let _s = StatRecorder::new(ccx, format!(\"drop {:?}\", t));\n \n     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n@@ -355,7 +345,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  substs: &subst::Substs<'tcx>)\n                                  -> Block<'blk, 'tcx>\n {\n-    debug!(\"trans_struct_drop t: {}\", bcx.ty_to_string(t));\n+    debug!(\"trans_struct_drop t: {}\", t);\n \n     // Find and call the actual destructor\n     let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did, t, class_did, substs);\n@@ -390,7 +380,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n                                          -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {}\",\n-           bcx.ty_to_string(t), bcx.val_to_string(info));\n+           t, bcx.val_to_string(info));\n     if type_is_sized(bcx.tcx(), t) {\n         let sizing_type = sizing_type_of(bcx.ccx(), t);\n         let size = C_uint(bcx.ccx(), llsize_of_alloc(bcx.ccx(), sizing_type));\n@@ -445,8 +435,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             (Mul(bcx, info, C_uint(bcx.ccx(), unit_size), DebugLoc::None),\n              C_uint(bcx.ccx(), unit_align))\n         }\n-        _ => bcx.sess().bug(&format!(\"Unexpected unsized type, found {}\",\n-                                    bcx.ty_to_string(t)))\n+        _ => bcx.sess().bug(&format!(\"Unexpected unsized type, found {}\", t))\n     }\n }\n \n@@ -520,8 +509,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n                         // stupid and dangerous.\n                         bcx.sess().warn(&format!(\"Ignoring drop flag in destructor for {}\\\n                                                  because the struct is unsized. See issue\\\n-                                                 #16758\",\n-                                                bcx.ty_to_string(t)));\n+                                                 #16758\", t));\n                         trans_struct_drop(bcx, t, v0, dtor, did, substs)\n                     }\n                 }"}, {"sha": "41d150ac265c93f6a278e0acd1c5033a450eb1df", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -34,7 +34,6 @@ use middle::ty::{self, Ty};\n use syntax::abi::RustIntrinsic;\n use syntax::ast;\n use syntax::parse::token;\n-use util::ppaux::{Repr, ty_to_string};\n \n pub fn get_simple_intrinsic(ccx: &CrateContext, item: &ast::ForeignItem) -> Option<ValueRef> {\n     let name = match &token::get_ident(item.ident)[..] {\n@@ -102,7 +101,7 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n             continue;\n         }\n \n-        debug!(\"transmute_restriction: {}\", transmute_restriction.repr(ccx.tcx()));\n+        debug!(\"transmute_restriction: {:?}\", transmute_restriction);\n \n         assert!(!ty::type_has_params(transmute_restriction.substituted_from));\n         assert!(!ty::type_has_params(transmute_restriction.substituted_to));\n@@ -121,21 +120,21 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n                     transmute_restriction.span,\n                     &format!(\"transmute called on types with potentially different sizes: \\\n                               {} (could be {} bit{}) to {} (could be {} bit{})\",\n-                             ty_to_string(ccx.tcx(), transmute_restriction.original_from),\n+                             transmute_restriction.original_from,\n                              from_type_size as usize,\n                              if from_type_size == 1 {\"\"} else {\"s\"},\n-                             ty_to_string(ccx.tcx(), transmute_restriction.original_to),\n+                             transmute_restriction.original_to,\n                              to_type_size as usize,\n                              if to_type_size == 1 {\"\"} else {\"s\"}));\n             } else {\n                 ccx.sess().span_err(\n                     transmute_restriction.span,\n                     &format!(\"transmute called on types with different sizes: \\\n                               {} ({} bit{}) to {} ({} bit{})\",\n-                             ty_to_string(ccx.tcx(), transmute_restriction.original_from),\n+                             transmute_restriction.original_from,\n                              from_type_size as usize,\n                              if from_type_size == 1 {\"\"} else {\"s\"},\n-                             ty_to_string(ccx.tcx(), transmute_restriction.original_to),\n+                             transmute_restriction.original_to,\n                              to_type_size as usize,\n                              if to_type_size == 1 {\"\"} else {\"s\"}));\n             }\n@@ -405,7 +404,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         (_, \"type_name\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            let ty_name = token::intern_and_get_ident(&ty_to_string(ccx.tcx(), tp_ty));\n+            let ty_name = token::intern_and_get_ident(&tp_ty.to_string());\n             C_str_slice(ccx, ty_name)\n         }\n         (_, \"type_id\") => {"}, {"sha": "eca6eecff4279294d1d11d6dc5602be3ec69f8f7", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -39,7 +39,6 @@ use trans::type_::Type;\n use trans::type_of::*;\n use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n-use util::ppaux::Repr;\n \n use syntax::abi::{Rust, RustCall};\n use syntax::parse::token;\n@@ -62,7 +61,7 @@ pub fn trans_impl(ccx: &CrateContext,\n     let _icx = push_ctxt(\"meth::trans_impl\");\n     let tcx = ccx.tcx();\n \n-    debug!(\"trans_impl(name={}, id={})\", name.repr(tcx), id);\n+    debug!(\"trans_impl(name={}, id={})\", name, id);\n \n     let mut v = TransItemVisitor { ccx: ccx };\n \n@@ -136,15 +135,15 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }) => {\n             let trait_ref = ty::Binder(bcx.monomorphize(trait_ref));\n             let span = bcx.tcx().map.span(method_call.expr_id);\n-            debug!(\"method_call={:?} trait_ref={} trait_ref id={:?} substs={:?}\",\n+            debug!(\"method_call={:?} trait_ref={:?} trait_ref id={:?} substs={:?}\",\n                    method_call,\n-                   trait_ref.repr(bcx.tcx()),\n+                   trait_ref,\n                    trait_ref.0.def_id,\n                    trait_ref.0.substs);\n             let origin = fulfill_obligation(bcx.ccx(),\n                                             span,\n                                             trait_ref.clone());\n-            debug!(\"origin = {}\", origin.repr(bcx.tcx()));\n+            debug!(\"origin = {:?}\", origin);\n             trans_monomorphized_callee(bcx,\n                                        method_call,\n                                        trait_ref.def_id(),\n@@ -234,7 +233,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                              rcvr_self,\n                                              Vec::new()));\n     let trait_substs = tcx.mk_substs(trait_substs);\n-    debug!(\"trait_substs={}\", trait_substs.repr(tcx));\n+    debug!(\"trait_substs={:?}\", trait_substs);\n     let trait_ref = ty::Binder(ty::TraitRef { def_id: trait_id,\n                                               substs: trait_substs });\n     let vtbl = fulfill_obligation(ccx,\n@@ -296,8 +295,8 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             immediate_rvalue(llfn, ty)\n         }\n         _ => {\n-            tcx.sess.bug(&format!(\"static call to invalid vtable: {}\",\n-                                 vtbl.repr(tcx)));\n+            tcx.sess.bug(&format!(\"static call to invalid vtable: {:?}\",\n+                                 vtbl));\n         }\n     }\n }\n@@ -390,8 +389,8 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         traits::VtableDefaultImpl(..) |\n         traits::VtableParam(..) => {\n             bcx.sess().bug(\n-                &format!(\"resolved vtable bad vtable {} in trans\",\n-                        vtable.repr(bcx.tcx())));\n+                &format!(\"resolved vtable bad vtable {:?} in trans\",\n+                        vtable));\n         }\n     }\n }\n@@ -415,8 +414,8 @@ fn combine_impl_and_methods_tps<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let node_substs = node_id_substs(ccx, node, bcx.fcx.param_substs);\n \n-    debug!(\"rcvr_substs={}\", rcvr_substs.repr(ccx.tcx()));\n-    debug!(\"node_substs={}\", node_substs.repr(ccx.tcx()));\n+    debug!(\"rcvr_substs={:?}\", rcvr_substs);\n+    debug!(\"node_substs={:?}\", node_substs);\n \n     // Break apart the type parameters from the node and type\n     // parameters from the receiver.\n@@ -484,7 +483,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Load the data pointer from the object.\n     debug!(\"trans_trait_callee_from_llval(callee_ty={}, vtable_index={}, llpair={})\",\n-           callee_ty.repr(ccx.tcx()),\n+           callee_ty,\n            vtable_index,\n            bcx.val_to_string(llpair));\n     let llboxptr = GEPi(bcx, llpair, &[0, abi::FAT_PTR_ADDR]);\n@@ -556,9 +555,9 @@ pub fn trans_object_shim<'a, 'tcx>(\n     let tcx = ccx.tcx();\n     let trait_id = upcast_trait_ref.def_id();\n \n-    debug!(\"trans_object_shim(object_ty={}, upcast_trait_ref={}, method_offset_in_trait={})\",\n-           object_ty.repr(tcx),\n-           upcast_trait_ref.repr(tcx),\n+    debug!(\"trans_object_shim(object_ty={:?}, upcast_trait_ref={:?}, method_offset_in_trait={})\",\n+           object_ty,\n+           upcast_trait_ref,\n            method_offset_in_trait);\n \n     let object_trait_ref =\n@@ -567,15 +566,15 @@ pub fn trans_object_shim<'a, 'tcx>(\n                 data.principal_trait_ref_with_self_ty(tcx, object_ty)\n             }\n             _ => {\n-                tcx.sess.bug(&format!(\"trans_object_shim() called on non-object: {}\",\n-                                      object_ty.repr(tcx)));\n+                tcx.sess.bug(&format!(\"trans_object_shim() called on non-object: {:?}\",\n+                                      object_ty));\n             }\n         };\n \n     // Upcast to the trait in question and extract out the substitutions.\n     let upcast_trait_ref = ty::erase_late_bound_regions(tcx, &upcast_trait_ref);\n     let object_substs = upcast_trait_ref.substs.clone().erase_regions();\n-    debug!(\"trans_object_shim: object_substs={}\", object_substs.repr(tcx));\n+    debug!(\"trans_object_shim: object_substs={:?}\", object_substs);\n \n     // Lookup the type of this method as declared in the trait and apply substitutions.\n     let method_ty = match ty::trait_item(tcx, trait_id, method_offset_in_trait) {\n@@ -587,7 +586,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n     let fty = monomorphize::apply_param_substs(tcx, &object_substs, &method_ty.fty);\n     let fty = tcx.mk_bare_fn(fty);\n     let method_ty = opaque_method_ty(tcx, fty);\n-    debug!(\"trans_object_shim: fty={} method_ty={}\", fty.repr(tcx), method_ty.repr(tcx));\n+    debug!(\"trans_object_shim: fty={:?} method_ty={:?}\", fty, method_ty);\n \n     //\n     let shim_fn_ty = ty::mk_bare_fn(tcx, None, fty);\n@@ -627,8 +626,8 @@ pub fn trans_object_shim<'a, 'tcx>(\n                     ty::TyTuple(ref tys) => &**tys,\n                     _ => {\n                         bcx.sess().bug(\n-                            &format!(\"rust-call expects a tuple not {}\",\n-                                     sig.inputs[1].repr(tcx)));\n+                            &format!(\"rust-call expects a tuple not {:?}\",\n+                                     sig.inputs[1]));\n                     }\n                 }\n             }\n@@ -692,7 +691,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let tcx = ccx.tcx();\n     let _icx = push_ctxt(\"meth::get_vtable\");\n \n-    debug!(\"get_vtable(trait_ref={})\", trait_ref.repr(tcx));\n+    debug!(\"get_vtable(trait_ref={:?})\", trait_ref);\n \n     // Check the cache.\n     match ccx.vtables().borrow().get(&trait_ref) {\n@@ -739,14 +738,14 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 // an object type; this cannot happen because we\n                 // cannot cast an unsized type into a trait object\n                 tcx.sess.bug(\n-                    &format!(\"cannot get vtable for an object type: {}\",\n-                            data.repr(tcx)));\n+                    &format!(\"cannot get vtable for an object type: {:?}\",\n+                            data));\n             }\n             traits::VtableParam(..) => {\n                 tcx.sess.bug(\n-                    &format!(\"resolved vtable for {} to bad vtable {} in trans\",\n-                            trait_ref.repr(tcx),\n-                            vtable.repr(tcx)));\n+                    &format!(\"resolved vtable for {:?} to bad vtable {:?} in trans\",\n+                            trait_ref,\n+                            vtable));\n             }\n         }\n     });\n@@ -776,10 +775,10 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n {\n     let tcx = ccx.tcx();\n \n-    debug!(\"emit_vtable_methods(impl_id={}, substs={}, param_substs={})\",\n-           impl_id.repr(tcx),\n-           substs.repr(tcx),\n-           param_substs.repr(tcx));\n+    debug!(\"emit_vtable_methods(impl_id={:?}, substs={:?}, param_substs={:?})\",\n+           impl_id,\n+           substs,\n+           param_substs);\n \n     let trt_id = match ty::impl_trait_ref(tcx, impl_id) {\n         Some(t_id) => t_id.def_id,\n@@ -806,8 +805,8 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // method could never be called from this object, just supply\n         // null.\n         .map(|trait_method_def_id| {\n-            debug!(\"emit_vtable_methods: trait_method_def_id={}\",\n-                   trait_method_def_id.repr(tcx));\n+            debug!(\"emit_vtable_methods: trait_method_def_id={:?}\",\n+                   trait_method_def_id);\n \n             let trait_method_type = match ty::impl_or_trait_item(tcx, trait_method_def_id) {\n                 ty::MethodTraitItem(m) => m,\n@@ -821,8 +820,8 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 return nullptr;\n             }\n \n-            debug!(\"emit_vtable_methods: trait_method_type={}\",\n-                   trait_method_type.repr(tcx));\n+            debug!(\"emit_vtable_methods: trait_method_type={:?}\",\n+                   trait_method_type);\n \n             // The substitutions we have are on the impl, so we grab\n             // the method type from the impl to substitute into.\n@@ -832,8 +831,8 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 _ => ccx.sess().bug(\"should be a method, not other assoc item\"),\n             };\n \n-            debug!(\"emit_vtable_methods: impl_method_type={}\",\n-                   impl_method_type.repr(tcx));\n+            debug!(\"emit_vtable_methods: impl_method_type={:?}\",\n+                   impl_method_type);\n \n             // If this is a default method, it's possible that it\n             // relies on where clauses that do not hold for this"}, {"sha": "f4bad313bafb1c95e2772b3655a6e8250d096a7d", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -26,7 +26,6 @@ use trans::common::*;\n use trans::declare;\n use trans::foreign;\n use middle::ty::{self, HasProjectionTypes, Ty};\n-use util::ppaux::Repr;\n \n use syntax::abi;\n use syntax::ast;\n@@ -41,11 +40,11 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 ref_id: Option<ast::NodeId>)\n     -> (ValueRef, Ty<'tcx>, bool) {\n     debug!(\"monomorphic_fn(\\\n-            fn_id={}, \\\n-            real_substs={}, \\\n+            fn_id={:?}, \\\n+            real_substs={:?}, \\\n             ref_id={:?})\",\n-           fn_id.repr(ccx.tcx()),\n-           psubsts.repr(ccx.tcx()),\n+           fn_id,\n+           psubsts,\n            ref_id);\n \n     assert!(psubsts.types.all(|t| {\n@@ -61,7 +60,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let item_ty = ty::lookup_item_type(ccx.tcx(), fn_id).ty;\n \n-    debug!(\"monomorphic_fn about to subst into {}\", item_ty.repr(ccx.tcx()));\n+    debug!(\"monomorphic_fn about to subst into {:?}\", item_ty);\n     let mono_ty = item_ty.subst(ccx.tcx(), psubsts);\n \n     match ccx.monomorphized().borrow().get(&hash_id) {\n@@ -74,11 +73,11 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n \n     debug!(\"monomorphic_fn(\\\n-            fn_id={}, \\\n-            psubsts={}, \\\n+            fn_id={:?}, \\\n+            psubsts={:?}, \\\n             hash_id={:?})\",\n-           fn_id.repr(ccx.tcx()),\n-           psubsts.repr(ccx.tcx()),\n+           fn_id,\n+           psubsts,\n            hash_id);\n \n \n@@ -99,10 +98,10 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n-    debug!(\"mono_ty = {} (post-substitution)\", mono_ty.repr(ccx.tcx()));\n+    debug!(\"mono_ty = {:?} (post-substitution)\", mono_ty);\n \n     let mono_ty = normalize_associated_type(ccx.tcx(), &mono_ty);\n-    debug!(\"mono_ty = {} (post-normalization)\", mono_ty.repr(ccx.tcx()));\n+    debug!(\"mono_ty = {:?} (post-normalization)\", mono_ty);\n \n     ccx.stats().n_monos.set(ccx.stats().n_monos.get() + 1);\n \n@@ -303,7 +302,7 @@ pub fn apply_param_substs<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n                                   param_substs: &Substs<'tcx>,\n                                   value: &T)\n                                   -> T\n-    where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes\n {\n     let substituted = value.subst(tcx, param_substs);\n     normalize_associated_type(tcx, &substituted)\n@@ -314,9 +313,9 @@ pub fn apply_param_substs<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n /// and hence we can be sure that all associated types will be\n /// completely normalized away.\n pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n-    where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes\n {\n-    debug!(\"normalize_associated_type(t={})\", value.repr(tcx));\n+    debug!(\"normalize_associated_type(t={:?})\", value);\n \n     let value = erase_regions(tcx, value);\n \n@@ -333,9 +332,9 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n     let traits::Normalized { value: result, obligations } =\n         traits::normalize(&mut selcx, cause, &value);\n \n-    debug!(\"normalize_associated_type: result={} obligations={}\",\n-           result.repr(tcx),\n-           obligations.repr(tcx));\n+    debug!(\"normalize_associated_type: result={:?} obligations={:?}\",\n+           result,\n+           obligations);\n \n     let mut fulfill_cx = traits::FulfillmentContext::new(true);\n     for obligation in obligations {"}, {"sha": "bba0f6d26083a6d04e4fd1e7c72a7dd4c0540835", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -28,7 +28,6 @@ use trans::machine::llsize_of_alloc;\n use trans::type_::Type;\n use trans::type_of;\n use middle::ty::{self, Ty};\n-use util::ppaux::ty_to_string;\n \n use syntax::ast;\n use syntax::parse::token::InternedString;\n@@ -42,7 +41,7 @@ struct VecTypes<'tcx> {\n impl<'tcx> VecTypes<'tcx> {\n     pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n         format!(\"VecTypes {{unit_ty={}, llunit_ty={}}}\",\n-                ty_to_string(ccx.tcx(), self.unit_ty),\n+                self.unit_ty,\n                 ccx.tn().type_to_string(self.llunit_ty))\n     }\n }\n@@ -58,8 +57,8 @@ pub fn trans_fixed_vstore<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // to store the array of the suitable size, so all we have to do is\n     // generate the content.\n \n-    debug!(\"trans_fixed_vstore(expr={}, dest={})\",\n-           bcx.expr_to_string(expr), dest.to_string(bcx.ccx()));\n+    debug!(\"trans_fixed_vstore(expr={:?}, dest={})\",\n+           expr, dest.to_string(bcx.ccx()));\n \n     let vt = vec_types_from_expr(bcx, expr);\n \n@@ -85,8 +84,8 @@ pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let ccx = fcx.ccx;\n     let mut bcx = bcx;\n \n-    debug!(\"trans_slice_vec(slice_expr={})\",\n-           bcx.expr_to_string(slice_expr));\n+    debug!(\"trans_slice_vec(slice_expr={:?})\",\n+           slice_expr);\n \n     let vec_ty = node_id_type(bcx, slice_expr.id);\n \n@@ -139,8 +138,8 @@ pub fn trans_lit_str<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  str_lit: InternedString,\n                                  dest: Dest)\n                                  -> Block<'blk, 'tcx> {\n-    debug!(\"trans_lit_str(lit_expr={}, dest={})\",\n-           bcx.expr_to_string(lit_expr),\n+    debug!(\"trans_lit_str(lit_expr={:?}, dest={})\",\n+           lit_expr,\n            dest.to_string(bcx.ccx()));\n \n     match dest {\n@@ -167,10 +166,10 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n \n-    debug!(\"write_content(vt={}, dest={}, vstore_expr={})\",\n+    debug!(\"write_content(vt={}, dest={}, vstore_expr={:?})\",\n            vt.to_string(bcx.ccx()),\n            dest.to_string(bcx.ccx()),\n-           bcx.expr_to_string(vstore_expr));\n+           vstore_expr);\n \n     match content_expr.node {\n         ast::ExprLit(ref lit) => {"}, {"sha": "26b54142d63160b403736cda7bd4a8c673698869", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -16,8 +16,6 @@ use trans::common::*;\n use trans::foreign;\n use trans::machine;\n use middle::ty::{self, RegionEscape, Ty};\n-use util::ppaux;\n-use util::ppaux::Repr;\n \n use trans::type_::Type;\n \n@@ -100,8 +98,8 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                  abi: abi::Abi)\n                                  -> Type\n {\n-    debug!(\"type_of_rust_fn(sig={},abi={:?})\",\n-           sig.repr(cx.tcx()),\n+    debug!(\"type_of_rust_fn(sig={:?},abi={:?})\",\n+           sig,\n            abi);\n \n     let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n@@ -229,8 +227,8 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         }\n \n         ty::TyProjection(..) | ty::TyInfer(..) | ty::TyParam(..) | ty::TyError(..) => {\n-            cx.sess().bug(&format!(\"fictitious type {} in sizing_type_of()\",\n-                                  ppaux::ty_to_string(cx.tcx(), t)))\n+            cx.sess().bug(&format!(\"fictitious type {:?} in sizing_type_of()\",\n+                                   t))\n         }\n         ty::TySlice(_) | ty::TyTrait(..) | ty::TyStr => unreachable!()\n     };\n@@ -299,7 +297,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n         None => ()\n     }\n \n-    debug!(\"type_of {} {:?}\", t.repr(cx.tcx()), t.sty);\n+    debug!(\"type_of {:?}\", t);\n \n     assert!(!t.has_escaping_regions());\n \n@@ -312,10 +310,10 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n \n     if t != t_norm {\n         let llty = in_memory_type_of(cx, t_norm);\n-        debug!(\"--> normalized {} {:?} to {} {:?} llty={}\",\n-                t.repr(cx.tcx()),\n+        debug!(\"--> normalized {:?} {:?} to {:?} {:?} llty={}\",\n                 t,\n-                t_norm.repr(cx.tcx()),\n+                t,\n+                t_norm,\n                 t_norm,\n                 cx.tn().type_to_string(llty));\n         cx.lltypes().borrow_mut().insert(t, llty);\n@@ -364,8 +362,8 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n                       }\n                       ty::TyTrait(_) => Type::vtable_ptr(cx),\n                       _ => panic!(\"Unexpected type returned from \\\n-                                   struct_tail: {} for ty={}\",\n-                                  unsized_part.repr(cx.tcx()), ty.repr(cx.tcx()))\n+                                   struct_tail: {:?} for ty={:?}\",\n+                                  unsized_part, ty)\n                   };\n                   Type::struct_(cx, &[ptr_ty, info_ty], false)\n               }\n@@ -419,8 +417,8 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       ty::TyError(..) => cx.sess().bug(\"type_of with TyError\"),\n     };\n \n-    debug!(\"--> mapped t={} {:?} to llty={}\",\n-            t.repr(cx.tcx()),\n+    debug!(\"--> mapped t={:?} {:?} to llty={}\",\n+            t,\n             t,\n             cx.tn().type_to_string(llty));\n \n@@ -450,7 +448,7 @@ fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             tps: &[Ty<'tcx>])\n                             -> String {\n     let base = ty::item_path_str(cx.tcx(), did);\n-    let strings: Vec<String> = tps.iter().map(|t| t.repr(cx.tcx())).collect();\n+    let strings: Vec<String> = tps.iter().map(|t| t.to_string()).collect();\n     let tstr = if strings.is_empty() {\n         base\n     } else {"}, {"sha": "8e838d991fbe7df35e1d28b0b6dca4ddb693ec5d", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -61,7 +61,6 @@ use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope, ExplicitRscope\n              ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope};\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::FnvHashSet;\n-use util::ppaux::{self, Repr, UserString};\n \n use std::iter::repeat;\n use std::slice;\n@@ -178,10 +177,10 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n         }\n     };\n \n-    debug!(\"ast_region_to_region(lifetime={} id={}) yields {}\",\n-           lifetime.repr(tcx),\n+    debug!(\"ast_region_to_region(lifetime={:?} id={}) yields {:?}\",\n+           lifetime,\n            lifetime.id,\n-           r.repr(tcx));\n+           r);\n \n     r\n }\n@@ -256,9 +255,9 @@ pub fn opt_ast_region_to_region<'tcx>(\n         }\n     };\n \n-    debug!(\"opt_ast_region_to_region(opt_lifetime={}) yields {}\",\n-            opt_lifetime.repr(this.tcx()),\n-            r.repr(this.tcx()));\n+    debug!(\"opt_ast_region_to_region(opt_lifetime={:?}) yields {:?}\",\n+            opt_lifetime,\n+            r);\n \n     r\n }\n@@ -373,10 +372,10 @@ fn create_substs_for_ast_path<'tcx>(\n {\n     let tcx = this.tcx();\n \n-    debug!(\"create_substs_for_ast_path(decl_generics={}, self_ty={}, \\\n-           types_provided={}, region_substs={}\",\n-           decl_generics.repr(tcx), self_ty.repr(tcx), types_provided.repr(tcx),\n-           region_substs.repr(tcx));\n+    debug!(\"create_substs_for_ast_path(decl_generics={:?}, self_ty={:?}, \\\n+           types_provided={:?}, region_substs={:?}\",\n+           decl_generics, self_ty, types_provided,\n+           region_substs);\n \n     assert_eq!(region_substs.regions().len(TypeSpace), decl_generics.regions.len(TypeSpace));\n     assert!(region_substs.types.is_empty());\n@@ -441,8 +440,8 @@ fn create_substs_for_ast_path<'tcx>(\n                           \"the type parameter `{}` must be explicitly specified \\\n                            in an object type because its default value `{}` references \\\n                            the type `Self`\",\n-                          param.name.user_string(tcx),\n-                          default.user_string(tcx));\n+                          param.name,\n+                          default);\n                 substs.types.push(TypeSpace, tcx.types.err);\n             } else {\n                 // This is a default type parameter.\n@@ -649,7 +648,7 @@ fn trait_def_id<'tcx>(this: &AstConv<'tcx>, trait_ref: &ast::TraitRef) -> ast::D\n         def::DefTrait(trait_def_id) => trait_def_id,\n         _ => {\n             span_fatal!(this.tcx().sess, path.span, E0245, \"`{}` is not a trait\",\n-                        path.user_string(this.tcx()));\n+                        path);\n         }\n     }\n }\n@@ -879,7 +878,7 @@ fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n \n     let candidate = try!(one_bound_for_assoc_type(tcx,\n                                                   candidates,\n-                                                  &trait_ref.user_string(tcx),\n+                                                  &trait_ref.to_string(),\n                                                   &token::get_name(binding.item_name),\n                                                   binding.span));\n \n@@ -985,19 +984,21 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n             });\n             match (&ty.node, full_span) {\n                 (&ast::TyRptr(None, ref mut_ty), Some(full_span)) => {\n+                    let mutbl_str = if mut_ty.mutbl == ast::MutMutable { \"mut \" } else { \"\" };\n                     this.tcx().sess\n                         .span_suggestion(full_span, \"try adding parentheses (per RFC 438):\",\n                                          format!(\"&{}({} +{})\",\n-                                                 ppaux::mutability_to_string(mut_ty.mutbl),\n+                                                 mutbl_str,\n                                                  pprust::ty_to_string(&*mut_ty.ty),\n                                                  pprust::bounds_to_string(bounds)));\n                 }\n                 (&ast::TyRptr(Some(ref lt), ref mut_ty), Some(full_span)) => {\n+                    let mutbl_str = if mut_ty.mutbl == ast::MutMutable { \"mut \" } else { \"\" };\n                     this.tcx().sess\n                         .span_suggestion(full_span, \"try adding parentheses (per RFC 438):\",\n                                          format!(\"&{} {}({} +{})\",\n                                                  pprust::lifetime_to_string(lt),\n-                                                 ppaux::mutability_to_string(mut_ty.mutbl),\n+                                                 mutbl_str,\n                                                  pprust::ty_to_string(&*mut_ty.ty),\n                                                  pprust::bounds_to_string(bounds)));\n                 }\n@@ -1028,8 +1029,8 @@ fn trait_ref_to_object_type<'tcx>(this: &AstConv<'tcx>,\n                                                      bounds);\n \n     let result = make_object_type(this, span, trait_ref, existential_bounds);\n-    debug!(\"trait_ref_to_object_type: result={}\",\n-           result.repr(this.tcx()));\n+    debug!(\"trait_ref_to_object_type: result={:?}\",\n+           result);\n \n     result\n }\n@@ -1072,7 +1073,7 @@ fn make_object_type<'tcx>(this: &AstConv<'tcx>,\n     for (trait_def_id, name) in associated_types {\n         span_err!(tcx.sess, span, E0191,\n             \"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n-                    name.user_string(tcx),\n+                    name,\n                     ty::item_path_str(tcx, trait_def_id));\n     }\n \n@@ -1158,7 +1159,7 @@ fn one_bound_for_assoc_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n             span_note!(tcx.sess, span,\n                        \"associated type `{}` could derive from `{}`\",\n                        ty_param_name,\n-                       bound.user_string(tcx));\n+                       bound);\n         }\n     }\n \n@@ -1181,7 +1182,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n     let tcx = this.tcx();\n     let assoc_name = item_segment.identifier.name;\n \n-    debug!(\"associated_path_def_to_ty: {}::{}\", ty.repr(tcx), token::get_name(assoc_name));\n+    debug!(\"associated_path_def_to_ty: {:?}::{}\", ty, assoc_name);\n \n     check_path_args(tcx, slice::ref_slice(item_segment), NO_TPS | NO_REGIONS);\n \n@@ -1237,7 +1238,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         _ => {\n             report_ambiguous_associated_type(tcx,\n                                              span,\n-                                             &ty.user_string(tcx),\n+                                             &ty.to_string(),\n                                              \"Trait\",\n                                              &token::get_name(assoc_name));\n             return (tcx.types.err, ty_path_def);\n@@ -1294,7 +1295,7 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n         return tcx.types.err;\n     };\n \n-    debug!(\"qpath_to_ty: self_type={}\", self_ty.repr(tcx));\n+    debug!(\"qpath_to_ty: self_type={:?}\", self_ty);\n \n     let trait_ref = ast_path_to_mono_trait_ref(this,\n                                                rscope,\n@@ -1304,7 +1305,7 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                                Some(self_ty),\n                                                trait_segment);\n \n-    debug!(\"qpath_to_ty: trait_ref={}\", trait_ref.repr(tcx));\n+    debug!(\"qpath_to_ty: trait_ref={:?}\", trait_ref);\n \n     this.projected_ty(span, trait_ref, item_segment.identifier.name)\n }\n@@ -1493,8 +1494,8 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                           ast_ty: &ast::Ty)\n                           -> Ty<'tcx>\n {\n-    debug!(\"ast_ty_to_ty(ast_ty={})\",\n-           ast_ty.repr(this.tcx()));\n+    debug!(\"ast_ty_to_ty(ast_ty={:?})\",\n+           ast_ty);\n \n     let tcx = this.tcx();\n \n@@ -1529,7 +1530,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n         }\n         ast::TyRptr(ref region, ref mt) => {\n             let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n-            debug!(\"TyRef r={}\", r.repr(this.tcx()));\n+            debug!(\"TyRef r={:?}\", r);\n             let rscope1 =\n                 &ObjectLifetimeDefaultRscope::new(\n                     rscope,\n@@ -1566,8 +1567,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                     depth: path.segments.len()\n                 }\n             } else {\n-                tcx.sess.span_bug(ast_ty.span,\n-                                  &format!(\"unbound path {}\", ast_ty.repr(tcx)))\n+                tcx.sess.span_bug(ast_ty.span, &format!(\"unbound path {:?}\", ast_ty))\n             };\n             let def = path_res.base_def;\n             let base_ty_end = path.segments.len() - path_res.depth;\n@@ -1841,11 +1841,11 @@ fn determine_explicit_self_category<'a, 'tcx>(this: &AstConv<'tcx>,\n             let impl_modifiers = count_modifiers(self_info.untransformed_self_ty);\n             let method_modifiers = count_modifiers(explicit_type);\n \n-            debug!(\"determine_explicit_self_category(self_info.untransformed_self_ty={} \\\n-                   explicit_type={} \\\n+            debug!(\"determine_explicit_self_category(self_info.untransformed_self_ty={:?} \\\n+                   explicit_type={:?} \\\n                    modifiers=({},{})\",\n-                   self_info.untransformed_self_ty.repr(this.tcx()),\n-                   explicit_type.repr(this.tcx()),\n+                   self_info.untransformed_self_ty,\n+                   explicit_type,\n                    impl_modifiers,\n                    method_modifiers);\n \n@@ -1878,8 +1878,8 @@ pub fn ty_of_closure<'tcx>(\n     expected_sig: Option<ty::FnSig<'tcx>>)\n     -> ty::ClosureTy<'tcx>\n {\n-    debug!(\"ty_of_closure(expected_sig={})\",\n-           expected_sig.repr(this.tcx()));\n+    debug!(\"ty_of_closure(expected_sig={:?})\",\n+           expected_sig);\n \n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n@@ -1917,8 +1917,8 @@ pub fn ty_of_closure<'tcx>(\n         ast::NoReturn(..) => ty::FnDiverging\n     };\n \n-    debug!(\"ty_of_closure: input_tys={}\", input_tys.repr(this.tcx()));\n-    debug!(\"ty_of_closure: output_ty={}\", output_ty.repr(this.tcx()));\n+    debug!(\"ty_of_closure: input_tys={:?}\", input_tys);\n+    debug!(\"ty_of_closure: output_ty={:?}\", output_ty);\n \n     ty::ClosureTy {\n         unsafety: unsafety,\n@@ -2035,10 +2035,10 @@ fn compute_object_lifetime_bound<'tcx>(\n     let tcx = this.tcx();\n \n     debug!(\"compute_opt_region_bound(explicit_region_bounds={:?}, \\\n-           principal_trait_ref={}, builtin_bounds={})\",\n+           principal_trait_ref={:?}, builtin_bounds={:?})\",\n            explicit_region_bounds,\n-           principal_trait_ref.repr(tcx),\n-           builtin_bounds.repr(tcx));\n+           principal_trait_ref,\n+           builtin_bounds);\n \n     if explicit_region_bounds.len() > 1 {\n         span_err!(tcx.sess, explicit_region_bounds[1].span, E0226,\n@@ -2104,7 +2104,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n                             ast_bounds: &'a [ast::TyParamBound])\n                             -> PartitionedBounds<'a>\n {\n-    let mut builtin_bounds = ty::empty_builtin_bounds();\n+    let mut builtin_bounds = ty::BuiltinBounds::empty();\n     let mut region_bounds = Vec::new();\n     let mut trait_bounds = Vec::new();\n     for ast_bound in ast_bounds {"}, {"sha": "cf086a32ae599b27803a0437e3b973ced446c067", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -22,7 +22,6 @@ use check::{check_expr_with_lvalue_pref, LvaluePreference};\n use check::{instantiate_path, resolve_ty_and_def_ufcs, structurally_resolved_type};\n use require_same_types;\n use util::nodemap::FnvHashMap;\n-use util::ppaux::Repr;\n \n use std::cmp::{self, Ordering};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n@@ -40,9 +39,9 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    debug!(\"check_pat(pat={},expected={})\",\n-           pat.repr(tcx),\n-           expected.repr(tcx));\n+    debug!(\"check_pat(pat={:?},expected={:?})\",\n+           pat,\n+           expected);\n \n     match pat.node {\n         ast::PatWild(_) => {\n@@ -222,7 +221,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 }\n             } else {\n                 tcx.sess.span_bug(pat.span,\n-                                  &format!(\"unbound path {}\", pat.repr(tcx)))\n+                                  &format!(\"unbound path {:?}\", pat))\n             };\n             if let Some((opt_ty, segments, def)) =\n                     resolve_ty_and_def_ufcs(fcx, path_res, Some(self_ty),"}, {"sha": "df9fe6b002efba6efaeee2a74779a969eb4d366a", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -12,10 +12,9 @@ use middle::infer::InferCtxt;\n use middle::traits::{self, FulfillmentContext, Normalized, MiscObligation,\n                      SelectionContext, ObligationCause};\n use middle::ty::{self, HasProjectionTypes};\n-use middle::ty_fold::{TypeFoldable, TypeFolder};\n+use middle::ty_fold::TypeFoldable;\n use syntax::ast;\n use syntax::codemap::Span;\n-use util::ppaux::Repr;\n \n pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                                 typer: &(ty::ClosureTyper<'tcx>+'a),\n@@ -24,15 +23,15 @@ pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                                 body_id: ast::NodeId,\n                                                 value: &T)\n                                                 -> T\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr<'tcx>\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes\n {\n-    debug!(\"normalize_associated_types_in(value={})\", value.repr(infcx.tcx));\n+    debug!(\"normalize_associated_types_in(value={:?})\", value);\n     let mut selcx = SelectionContext::new(infcx, typer);\n     let cause = ObligationCause::new(span, body_id, MiscObligation);\n     let Normalized { value: result, obligations } = traits::normalize(&mut selcx, cause, value);\n-    debug!(\"normalize_associated_types_in: result={} predicates={}\",\n-           result.repr(infcx.tcx),\n-           obligations.repr(infcx.tcx));\n+    debug!(\"normalize_associated_types_in: result={:?} predicates={:?}\",\n+           result,\n+           obligations);\n     for obligation in obligations {\n         fulfillment_cx.register_predicate_obligation(infcx, obligation);\n     }"}, {"sha": "e7271d2fa88cf1ef123f12f452208d5292567e57", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -32,7 +32,6 @@ use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::ptr::P;\n-use util::ppaux::Repr;\n \n /// Check that it is legal to call methods of the trait corresponding\n /// to `trait_id` (this only cares about the trait, not the specific\n@@ -120,9 +119,9 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                       autoderefs: usize)\n                                       -> Option<CallStep<'tcx>>\n {\n-    debug!(\"try_overloaded_call_step(call_expr={}, adjusted_ty={}, autoderefs={})\",\n-           call_expr.repr(fcx.tcx()),\n-           adjusted_ty.repr(fcx.tcx()),\n+    debug!(\"try_overloaded_call_step(call_expr={:?}, adjusted_ty={:?}, autoderefs={})\",\n+           call_expr,\n+           adjusted_ty,\n            autoderefs);\n \n     // If the callee is a bare function or a closure, then we're all set.\n@@ -328,6 +327,7 @@ fn write_overloaded_call_method_map<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     fcx.inh.method_map.borrow_mut().insert(method_call, method_callee);\n }\n \n+#[derive(Debug)]\n struct CallResolution<'tcx> {\n     call_expr: &'tcx ast::Expr,\n     callee_expr: &'tcx ast::Expr,\n@@ -337,23 +337,10 @@ struct CallResolution<'tcx> {\n     closure_def_id: ast::DefId,\n }\n \n-impl<'tcx> Repr<'tcx> for CallResolution<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"CallResolution(call_expr={}, callee_expr={}, adjusted_ty={}, \\\n-                autoderefs={}, fn_sig={}, closure_def_id={})\",\n-                self.call_expr.repr(tcx),\n-                self.callee_expr.repr(tcx),\n-                self.adjusted_ty.repr(tcx),\n-                self.autoderefs,\n-                self.fn_sig.repr(tcx),\n-                self.closure_def_id.repr(tcx))\n-    }\n-}\n-\n impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n     fn resolve<'a>(&mut self, fcx: &FnCtxt<'a,'tcx>) {\n-        debug!(\"DeferredCallResolution::resolve() {}\",\n-               self.repr(fcx.tcx()));\n+        debug!(\"DeferredCallResolution::resolve() {:?}\",\n+               self);\n \n         // we should not be invoked until the closure kind has been\n         // determined by upvar inference\n@@ -375,8 +362,8 @@ impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n                     ty::no_late_bound_regions(fcx.tcx(),\n                                               ty::ty_fn_sig(method_callee.ty)).unwrap();\n \n-                debug!(\"attempt_resolution: method_callee={}\",\n-                       method_callee.repr(fcx.tcx()));\n+                debug!(\"attempt_resolution: method_callee={:?}\",\n+                       method_callee);\n \n                 for (&method_arg_ty, &self_arg_ty) in\n                     method_sig.inputs[1..].iter().zip(&self.fn_sig.inputs)"}, {"sha": "9522a21b69ec663d0b19f9aecc7fd73b010a6a6c", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -45,7 +45,6 @@ use middle::ty::Ty;\n use syntax::ast;\n use syntax::ast::UintTy::{TyU8};\n use syntax::codemap::Span;\n-use util::ppaux::Repr;\n \n /// Reifies a cast check to be checked once we have full type information for\n /// a function context.\n@@ -192,8 +191,8 @@ impl<'tcx> CastCheck<'tcx> {\n         self.expr_ty = structurally_resolved_type(fcx, self.span, self.expr_ty);\n         self.cast_ty = structurally_resolved_type(fcx, self.span, self.cast_ty);\n \n-        debug!(\"check_cast({}, {} as {})\", self.expr.id, self.expr_ty.repr(fcx.tcx()),\n-               self.cast_ty.repr(fcx.tcx()));\n+        debug!(\"check_cast({}, {:?} as {:?})\", self.expr.id, self.expr_ty,\n+               self.cast_ty);\n \n         if ty::type_is_error(self.expr_ty) || ty::type_is_error(self.cast_ty) {\n             // No sense in giving duplicate error messages\n@@ -273,8 +272,8 @@ impl<'tcx> CastCheck<'tcx> {\n                               m_cast: &'tcx ty::mt<'tcx>)\n                               -> Result<CastKind, CastError>\n     {\n-        debug!(\"check_ptr_ptr_cast m_expr={} m_cast={}\",\n-               m_expr.repr(fcx.tcx()), m_cast.repr(fcx.tcx()));\n+        debug!(\"check_ptr_ptr_cast m_expr={:?} m_cast={:?}\",\n+               m_expr, m_cast);\n         // ptr-ptr cast. vtables must match.\n \n         // Cast to sized is OK"}, {"sha": "10b2459b220f2a8ffeb62d94c425d98a9b216553", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -20,17 +20,16 @@ use std::cmp;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_util;\n-use util::ppaux::Repr;\n \n pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                    expr: &ast::Expr,\n                                    _capture: ast::CaptureClause,\n                                    decl: &'tcx ast::FnDecl,\n                                    body: &'tcx ast::Block,\n                                    expected: Expectation<'tcx>) {\n-    debug!(\"check_expr_closure(expr={},expected={})\",\n-           expr.repr(fcx.tcx()),\n-           expected.repr(fcx.tcx()));\n+    debug!(\"check_expr_closure(expr={:?},expected={:?})\",\n+           expr,\n+           expected);\n \n     // It's always helpful for inference if we know the kind of\n     // closure sooner rather than later, so first examine the expected\n@@ -50,9 +49,9 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                           expected_sig: Option<ty::FnSig<'tcx>>) {\n     let expr_def_id = ast_util::local_def(expr.id);\n \n-    debug!(\"check_closure opt_kind={:?} expected_sig={}\",\n+    debug!(\"check_closure opt_kind={:?} expected_sig={:?}\",\n            opt_kind,\n-           expected_sig.repr(fcx.tcx()));\n+           expected_sig);\n \n     let mut fn_ty = astconv::ty_of_closure(\n         fcx,\n@@ -86,9 +85,9 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     // the `closures` table.\n     fn_ty.sig.0.inputs = vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.0.inputs)];\n \n-    debug!(\"closure for {} --> sig={} opt_kind={:?}\",\n-           expr_def_id.repr(fcx.tcx()),\n-           fn_ty.sig.repr(fcx.tcx()),\n+    debug!(\"closure for {:?} --> sig={:?} opt_kind={:?}\",\n+           expr_def_id,\n+           fn_ty.sig,\n            opt_kind);\n \n     fcx.inh.closure_tys.borrow_mut().insert(expr_def_id, fn_ty);\n@@ -103,8 +102,8 @@ fn deduce_expectations_from_expected_type<'a,'tcx>(\n     expected_ty: Ty<'tcx>)\n     -> (Option<ty::FnSig<'tcx>>,Option<ty::ClosureKind>)\n {\n-    debug!(\"deduce_expectations_from_expected_type(expected_ty={})\",\n-           expected_ty.repr(fcx.tcx()));\n+    debug!(\"deduce_expectations_from_expected_type(expected_ty={:?})\",\n+           expected_ty);\n \n     match expected_ty.sty {\n         ty::TyTrait(ref object_type) => {\n@@ -138,8 +137,8 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n         .pending_obligations()\n         .iter()\n         .filter_map(|obligation| {\n-            debug!(\"deduce_expectations_from_obligations: obligation.predicate={}\",\n-                   obligation.predicate.repr(fcx.tcx()));\n+            debug!(\"deduce_expectations_from_obligations: obligation.predicate={:?}\",\n+                   obligation.predicate);\n \n             match obligation.predicate {\n                 // Given a Projection predicate, we can potentially infer\n@@ -200,8 +199,8 @@ fn deduce_sig_from_projection<'a,'tcx>(\n {\n     let tcx = fcx.tcx();\n \n-    debug!(\"deduce_sig_from_projection({})\",\n-           projection.repr(tcx));\n+    debug!(\"deduce_sig_from_projection({:?})\",\n+           projection);\n \n     let trait_ref = projection.to_poly_trait_ref();\n \n@@ -211,24 +210,24 @@ fn deduce_sig_from_projection<'a,'tcx>(\n \n     let arg_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 0);\n     let arg_param_ty = fcx.infcx().resolve_type_vars_if_possible(&arg_param_ty);\n-    debug!(\"deduce_sig_from_projection: arg_param_ty {}\", arg_param_ty.repr(tcx));\n+    debug!(\"deduce_sig_from_projection: arg_param_ty {:?}\", arg_param_ty);\n \n     let input_tys = match arg_param_ty.sty {\n         ty::TyTuple(ref tys) => { (*tys).clone() }\n         _ => { return None; }\n     };\n-    debug!(\"deduce_sig_from_projection: input_tys {}\", input_tys.repr(tcx));\n+    debug!(\"deduce_sig_from_projection: input_tys {:?}\", input_tys);\n \n     let ret_param_ty = projection.0.ty;\n     let ret_param_ty = fcx.infcx().resolve_type_vars_if_possible(&ret_param_ty);\n-    debug!(\"deduce_sig_from_projection: ret_param_ty {}\", ret_param_ty.repr(tcx));\n+    debug!(\"deduce_sig_from_projection: ret_param_ty {:?}\", ret_param_ty);\n \n     let fn_sig = ty::FnSig {\n         inputs: input_tys,\n         output: ty::FnConverging(ret_param_ty),\n         variadic: false\n     };\n-    debug!(\"deduce_sig_from_projection: fn_sig {}\", fn_sig.repr(tcx));\n+    debug!(\"deduce_sig_from_projection: fn_sig {:?}\", fn_sig);\n \n     Some(fn_sig)\n }\n@@ -240,9 +239,9 @@ fn self_type_matches_expected_vid<'a,'tcx>(\n     -> Option<ty::PolyTraitRef<'tcx>>\n {\n     let self_ty = fcx.infcx().shallow_resolve(trait_ref.self_ty());\n-    debug!(\"self_type_matches_expected_vid(trait_ref={}, self_ty={})\",\n-           trait_ref.repr(fcx.tcx()),\n-           self_ty.repr(fcx.tcx()));\n+    debug!(\"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?})\",\n+           trait_ref,\n+           self_ty);\n     match self_ty.sty {\n         ty::TyInfer(ty::TyVar(v)) if expected_vid == v => Some(trait_ref),\n         _ => None,"}, {"sha": "785202de92159e03302f641caebf0f9f4790518b", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -69,7 +69,6 @@ use middle::ty::{AutoDerefRef, AdjustDerefRef};\n use middle::ty::{self, mt, Ty};\n use middle::ty_relate::RelateResult;\n use util::common::indent;\n-use util::ppaux::Repr;\n \n use std::cell::RefCell;\n use std::collections::VecDeque;\n@@ -104,9 +103,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n               a: Ty<'tcx>,\n               b: Ty<'tcx>)\n               -> CoerceResult<'tcx> {\n-        debug!(\"Coerce.tys({} => {})\",\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()));\n+        debug!(\"Coerce.tys({:?} => {:?})\",\n+               a,\n+               b);\n \n         // Consider coercing the subtype to a DST\n         let unsize = self.unpack_actual_value(a, |a| {\n@@ -166,9 +165,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                b: Ty<'tcx>,\n                                mutbl_b: ast::Mutability)\n                                -> CoerceResult<'tcx> {\n-        debug!(\"coerce_borrowed_pointer(a={}, b={})\",\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()));\n+        debug!(\"coerce_borrowed_pointer(a={:?}, b={:?})\",\n+               a,\n+               b);\n \n         // If we have a parameter of type `&M T_a` and the value\n         // provided is `expr`, we will be adding an implicit borrow,\n@@ -238,9 +237,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                       source: Ty<'tcx>,\n                       target: Ty<'tcx>)\n                       -> CoerceResult<'tcx> {\n-        debug!(\"coerce_unsized(source={}, target={})\",\n-               source.repr(self.tcx()),\n-               target.repr(self.tcx()));\n+        debug!(\"coerce_unsized(source={:?}, target={:?})\",\n+               source,\n+               target);\n \n         let traits = (self.tcx().lang_items.unsize_trait(),\n                       self.tcx().lang_items.coerce_unsized_trait());\n@@ -294,7 +293,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // inference might unify those two inner type variables later.\n         let traits = [coerce_unsized_did, unsize_did];\n         while let Some(obligation) = queue.pop_front() {\n-            debug!(\"coerce_unsized resolve step: {}\", obligation.repr(self.tcx()));\n+            debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n             let trait_ref =  match obligation.predicate {\n                 ty::Predicate::Trait(ref tr) if traits.contains(&tr.def_id()) => {\n                     tr.clone()\n@@ -336,7 +335,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             autoref: reborrow,\n             unsize: Some(target)\n         };\n-        debug!(\"Success, coerced with {}\", adjustment.repr(self.tcx()));\n+        debug!(\"Success, coerced with {:?}\", adjustment);\n         Ok(Some(AdjustDerefRef(adjustment)))\n     }\n \n@@ -352,8 +351,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n          */\n \n         self.unpack_actual_value(b, |b| {\n-            debug!(\"coerce_from_fn_pointer(a={}, b={})\",\n-                   a.repr(self.tcx()), b.repr(self.tcx()));\n+            debug!(\"coerce_from_fn_pointer(a={:?}, b={:?})\",\n+                   a, b);\n \n             if let ty::TyBareFn(None, fn_ty_b) = b.sty {\n                 match (fn_ty_a.unsafety, fn_ty_b.unsafety) {\n@@ -380,8 +379,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n          */\n \n         self.unpack_actual_value(b, |b| {\n-            debug!(\"coerce_from_fn_item(a={}, b={})\",\n-                   a.repr(self.tcx()), b.repr(self.tcx()));\n+            debug!(\"coerce_from_fn_item(a={:?}, b={:?})\",\n+                   a, b);\n \n             match b.sty {\n                 ty::TyBareFn(None, _) => {\n@@ -399,9 +398,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                          b: Ty<'tcx>,\n                          mutbl_b: ast::Mutability)\n                          -> CoerceResult<'tcx> {\n-        debug!(\"coerce_unsafe_ptr(a={}, b={})\",\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()));\n+        debug!(\"coerce_unsafe_ptr(a={:?}, b={:?})\",\n+               a,\n+               b);\n \n         let (is_ref, mt_a) = match a.sty {\n             ty::TyRef(_, mt) => (true, mt),\n@@ -436,7 +435,7 @@ pub fn mk_assignty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              a: Ty<'tcx>,\n                              b: Ty<'tcx>)\n                              -> RelateResult<'tcx, ()> {\n-    debug!(\"mk_assignty({} -> {})\", a.repr(fcx.tcx()), b.repr(fcx.tcx()));\n+    debug!(\"mk_assignty({:?} -> {:?})\", a, b);\n     let mut unsizing_obligations = vec![];\n     let adjustment = try!(indent(|| {\n         fcx.infcx().commit_if_ok(|_| {\n@@ -460,7 +459,7 @@ pub fn mk_assignty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     if let Some(adjustment) = adjustment {\n-        debug!(\"Success, coerced with {}\", adjustment.repr(fcx.tcx()));\n+        debug!(\"Success, coerced with {:?}\", adjustment);\n         fcx.write_adjustment(expr.id, adjustment);\n     }\n     Ok(())"}, {"sha": "7cd5e4548ec2b74b4c6c54227274dcd093cf50f9", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 42, "deletions": 45, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -13,7 +13,6 @@ use middle::infer;\n use middle::traits;\n use middle::ty::{self};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace};\n-use util::ppaux::{self, Repr};\n \n use syntax::ast;\n use syntax::codemap::Span;\n@@ -38,11 +37,11 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                  impl_m_body_id: ast::NodeId,\n                                  trait_m: &ty::Method<'tcx>,\n                                  impl_trait_ref: &ty::TraitRef<'tcx>) {\n-    debug!(\"compare_impl_method(impl_trait_ref={})\",\n-           impl_trait_ref.repr(tcx));\n+    debug!(\"compare_impl_method(impl_trait_ref={:?})\",\n+           impl_trait_ref);\n \n-    debug!(\"compare_impl_method: impl_trait_ref (liberated) = {}\",\n-           impl_trait_ref.repr(tcx));\n+    debug!(\"compare_impl_method: impl_trait_ref (liberated) = {:?}\",\n+           impl_trait_ref);\n \n     let infcx = infer::new_infer_ctxt(tcx);\n     let mut fulfillment_cx = traits::FulfillmentContext::new(true);\n@@ -63,18 +62,16 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             span_err!(tcx.sess, impl_m_span, E0185,\n                 \"method `{}` has a `{}` declaration in the impl, \\\n                         but not in the trait\",\n-                        token::get_name(trait_m.name),\n-                        ppaux::explicit_self_category_to_str(\n-                            &impl_m.explicit_self));\n+                        trait_m.name,\n+                        impl_m.explicit_self);\n             return;\n         }\n         (_, &ty::StaticExplicitSelfCategory) => {\n             span_err!(tcx.sess, impl_m_span, E0186,\n                 \"method `{}` has a `{}` declaration in the trait, \\\n                         but not in the impl\",\n-                        token::get_name(trait_m.name),\n-                        ppaux::explicit_self_category_to_str(\n-                            &trait_m.explicit_self));\n+                        trait_m.name,\n+                        trait_m.explicit_self);\n             return;\n         }\n         _ => {\n@@ -185,8 +182,8 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .subst(tcx, impl_to_skol_substs)\n         .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n                      impl_to_skol_substs.regions().get_slice(subst::FnSpace).to_vec());\n-    debug!(\"compare_impl_method: trait_to_skol_substs={}\",\n-           trait_to_skol_substs.repr(tcx));\n+    debug!(\"compare_impl_method: trait_to_skol_substs={:?}\",\n+           trait_to_skol_substs);\n \n     // Check region bounds. FIXME(@jroesch) refactor this away when removing\n     // ParamBounds.\n@@ -213,8 +210,8 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             impl_m_span,\n             infer::HigherRankedType,\n             &ty::Binder(impl_bounds));\n-    debug!(\"compare_impl_method: impl_bounds={}\",\n-           impl_bounds.repr(tcx));\n+    debug!(\"compare_impl_method: impl_bounds={:?}\",\n+           impl_bounds);\n \n     // Normalize the associated types in the trait_bounds.\n     let trait_bounds = trait_m.predicates.instantiate(tcx, &trait_to_skol_substs);\n@@ -244,8 +241,8 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let trait_param_env = traits::normalize_param_env_or_error(trait_param_env,\n                                                                normalize_cause.clone());\n \n-    debug!(\"compare_impl_method: trait_bounds={}\",\n-        trait_param_env.caller_bounds.repr(tcx));\n+    debug!(\"compare_impl_method: trait_bounds={:?}\",\n+        trait_param_env.caller_bounds);\n \n     let mut selcx = traits::SelectionContext::new(&infcx, &trait_param_env);\n \n@@ -305,8 +302,8 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                            tcx.mk_bare_fn(ty::BareFnTy { unsafety: impl_m.fty.unsafety,\n                                                          abi: impl_m.fty.abi,\n                                                          sig: ty::Binder(impl_sig) }));\n-        debug!(\"compare_impl_method: impl_fty={}\",\n-               impl_fty.repr(tcx));\n+        debug!(\"compare_impl_method: impl_fty={:?}\",\n+               impl_fty);\n \n         let (trait_sig, skol_map) =\n             infcx.skolemize_late_bound_regions(&trait_m.fty.sig, snapshot);\n@@ -326,8 +323,8 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                          abi: trait_m.fty.abi,\n                                                          sig: ty::Binder(trait_sig) }));\n \n-        debug!(\"compare_impl_method: trait_fty={}\",\n-               trait_fty.repr(tcx));\n+        debug!(\"compare_impl_method: trait_fty={:?}\",\n+               trait_fty);\n \n         try!(infer::mk_subty(&infcx, false, origin, impl_fty, trait_fty));\n \n@@ -337,13 +334,13 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     match err {\n         Ok(()) => { }\n         Err(terr) => {\n-            debug!(\"checking trait method for compatibility: impl ty {}, trait ty {}\",\n-                   impl_fty.repr(tcx),\n-                   trait_fty.repr(tcx));\n+            debug!(\"checking trait method for compatibility: impl ty {:?}, trait ty {:?}\",\n+                   impl_fty,\n+                   trait_fty);\n             span_err!(tcx.sess, impl_m_span, E0053,\n                       \"method `{}` has an incompatible type for trait: {}\",\n                       token::get_name(trait_m.name),\n-                      ty::type_err_to_str(tcx, &terr));\n+                      terr);\n             return;\n         }\n     }\n@@ -383,14 +380,14 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         let impl_params = impl_generics.regions.get_slice(subst::FnSpace);\n \n         debug!(\"check_region_bounds_on_impl_method: \\\n-               trait_generics={} \\\n-               impl_generics={} \\\n-               trait_to_skol_substs={} \\\n-               impl_to_skol_substs={}\",\n-               trait_generics.repr(tcx),\n-               impl_generics.repr(tcx),\n-               trait_to_skol_substs.repr(tcx),\n-               impl_to_skol_substs.repr(tcx));\n+               trait_generics={:?} \\\n+               impl_generics={:?} \\\n+               trait_to_skol_substs={:?} \\\n+               impl_to_skol_substs={:?}\",\n+               trait_generics,\n+               impl_generics,\n+               trait_to_skol_substs,\n+               impl_to_skol_substs);\n \n         // Must have same number of early-bound lifetime parameters.\n         // Unfortunately, if the user screws up the bounds, then this\n@@ -418,8 +415,8 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                 impl_c_span: Span,\n                                 trait_c: &ty::AssociatedConst<'tcx>,\n                                 impl_trait_ref: &ty::TraitRef<'tcx>) {\n-    debug!(\"compare_const_impl(impl_trait_ref={})\",\n-           impl_trait_ref.repr(tcx));\n+    debug!(\"compare_const_impl(impl_trait_ref={:?})\",\n+           impl_trait_ref);\n \n     let infcx = infer::new_infer_ctxt(tcx);\n     let mut fulfillment_cx = traits::FulfillmentContext::new(true);\n@@ -445,8 +442,8 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .subst(tcx, impl_to_skol_substs)\n         .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n                      impl_to_skol_substs.regions().get_slice(subst::FnSpace).to_vec());\n-    debug!(\"compare_const_impl: trait_to_skol_substs={}\",\n-           trait_to_skol_substs.repr(tcx));\n+    debug!(\"compare_const_impl: trait_to_skol_substs={:?}\",\n+           trait_to_skol_substs);\n \n     // Compute skolemized form of impl and trait const tys.\n     let impl_ty = impl_c.ty.subst(tcx, impl_to_skol_substs);\n@@ -463,8 +460,8 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                  impl_c_span,\n                                                  0,\n                                                  &impl_ty);\n-        debug!(\"compare_const_impl: impl_ty={}\",\n-               impl_ty.repr(tcx));\n+        debug!(\"compare_const_impl: impl_ty={:?}\",\n+               impl_ty);\n \n         let trait_ty =\n             assoc::normalize_associated_types_in(&infcx,\n@@ -473,23 +470,23 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                  impl_c_span,\n                                                  0,\n                                                  &trait_ty);\n-        debug!(\"compare_const_impl: trait_ty={}\",\n-               trait_ty.repr(tcx));\n+        debug!(\"compare_const_impl: trait_ty={:?}\",\n+               trait_ty);\n \n         infer::mk_subty(&infcx, false, origin, impl_ty, trait_ty)\n     });\n \n     match err {\n         Ok(()) => { }\n         Err(terr) => {\n-            debug!(\"checking associated const for compatibility: impl ty {}, trait ty {}\",\n-                   impl_ty.repr(tcx),\n-                   trait_ty.repr(tcx));\n+            debug!(\"checking associated const for compatibility: impl ty {:?}, trait ty {:?}\",\n+                   impl_ty,\n+                   trait_ty);\n             span_err!(tcx.sess, impl_c_span, E0326,\n                       \"implemented const `{}` has an incompatible type for \\\n                       trait: {}\",\n                       token::get_name(trait_c.name),\n-                      ty::type_err_to_str(tcx, &terr));\n+                      terr);\n             return;\n         }\n     }"}, {"sha": "392515926da0c9b71735ffd7423f62b9e92e8877", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -16,7 +16,6 @@ use middle::infer;\n use std::result::Result::{Err, Ok};\n use syntax::ast;\n use syntax::codemap::Span;\n-use util::ppaux::Repr;\n \n // Requires that the two types unify, and prints an error message if\n // they don't.\n@@ -59,9 +58,9 @@ pub fn coerce<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         expected: Ty<'tcx>,\n                         expr: &ast::Expr) {\n     let expr_ty = fcx.expr_ty(expr);\n-    debug!(\"demand::coerce(expected = {}, expr_ty = {})\",\n-           expected.repr(fcx.ccx.tcx),\n-           expr_ty.repr(fcx.ccx.tcx));\n+    debug!(\"demand::coerce(expected = {:?}, expr_ty = {:?})\",\n+           expected,\n+           expr_ty);\n     let expr_ty = fcx.resolve_type_vars_if_possible(expr_ty);\n     let expected = fcx.resolve_type_vars_if_possible(expected);\n     match coercion::mk_assignty(fcx, expr, expr_ty, expected) {"}, {"sha": "fb17f41d88d9a354c4f0bc9898062a61259803b5", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -14,7 +14,6 @@ use middle::infer;\n use middle::region;\n use middle::subst::{self, Subst};\n use middle::ty::{self, Ty};\n-use util::ppaux::{Repr, UserString};\n \n use syntax::ast;\n use syntax::codemap::{self, Span};\n@@ -38,7 +37,7 @@ use syntax::codemap::{self, Span};\n ///\n pub fn check_drop_impl(tcx: &ty::ctxt, drop_impl_did: ast::DefId) -> Result<(), ()> {\n     let ty::TypeScheme { generics: ref dtor_generics,\n-                         ty: ref dtor_self_type } = ty::lookup_item_type(tcx, drop_impl_did);\n+                         ty: dtor_self_type } = ty::lookup_item_type(tcx, drop_impl_did);\n     let dtor_predicates = ty::lookup_predicates(tcx, drop_impl_did);\n     match dtor_self_type.sty {\n         ty::TyEnum(self_type_did, self_to_impl_substs) |\n@@ -47,7 +46,7 @@ pub fn check_drop_impl(tcx: &ty::ctxt, drop_impl_did: ast::DefId) -> Result<(),\n             try!(ensure_drop_params_and_item_params_correspond(tcx,\n                                                                drop_impl_did,\n                                                                dtor_generics,\n-                                                               dtor_self_type,\n+                                                               &dtor_self_type,\n                                                                self_type_did));\n \n             ensure_drop_predicates_are_implied_by_item_defn(tcx,\n@@ -62,7 +61,7 @@ pub fn check_drop_impl(tcx: &ty::ctxt, drop_impl_did: ast::DefId) -> Result<(),\n             let span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n             tcx.sess.span_bug(\n                 span, &format!(\"should have been rejected by coherence check: {}\",\n-                               dtor_self_type.repr(tcx)));\n+                               dtor_self_type));\n         }\n     }\n }\n@@ -212,9 +211,8 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n \n         if !assumptions_in_impl_context.contains(&predicate) {\n             let item_span = tcx.map.span(self_type_did.node);\n-            let req = predicate.user_string(tcx);\n             span_err!(tcx.sess, drop_impl_span, E0367,\n-                      \"The requirement `{}` is added only by the Drop impl.\", req);\n+                      \"The requirement `{}` is added only by the Drop impl.\", predicate);\n             tcx.sess.span_note(item_span,\n                                \"The same requirement must be part of \\\n                                 the struct/enum definition\");\n@@ -257,8 +255,8 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n                                                      typ: ty::Ty<'tcx>,\n                                                      span: Span,\n                                                      scope: region::CodeExtent) {\n-    debug!(\"check_safety_of_destructor_if_necessary typ: {} scope: {:?}\",\n-           typ.repr(rcx.tcx()), scope);\n+    debug!(\"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\",\n+           typ, scope);\n \n     // types that have been traversed so far by `traverse_type_if_unseen`\n     let mut breadcrumbs: Vec<Ty<'tcx>> = Vec::new();\n@@ -277,8 +275,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n         Err(Error::Overflow(ref ctxt, ref detected_on_typ)) => {\n             let tcx = rcx.tcx();\n             span_err!(tcx.sess, span, E0320,\n-                      \"overflow while adding drop-check rules for {}\",\n-                      typ.user_string(rcx.tcx()));\n+                      \"overflow while adding drop-check rules for {}\", typ);\n             match *ctxt {\n                 TypeContext::Root => {\n                     // no need for an additional note if the overflow\n@@ -294,7 +291,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n                         ty::item_path_str(tcx, def_id),\n                         variant,\n                         arg_index,\n-                        detected_on_typ.user_string(rcx.tcx()));\n+                        detected_on_typ);\n                 }\n                 TypeContext::Struct { def_id, field } => {\n                     span_note!(\n@@ -303,7 +300,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n                         \"overflowed on struct {} field {} type: {}\",\n                         ty::item_path_str(tcx, def_id),\n                         field,\n-                        detected_on_typ.user_string(rcx.tcx()));\n+                        detected_on_typ);\n                 }\n             }\n         }\n@@ -372,8 +369,8 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n                     let tp_def = item_type.generics.types\n                         .opt_get(subst::TypeSpace, 0).unwrap();\n                     let new_typ = substs.type_for_def(tp_def);\n-                    debug!(\"replacing phantom {} with {}\",\n-                           typ.repr(rcx.tcx()), new_typ.repr(rcx.tcx()));\n+                    debug!(\"replacing phantom {:?} with {:?}\",\n+                           typ, new_typ);\n                     (new_typ, xref_depth_orig + 1)\n                 } else {\n                     (typ, xref_depth_orig)\n@@ -384,8 +381,8 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n             // definition of `Box<T>` must carry a PhantomData that\n             // puts us into the previous case.\n             ty::TyBox(new_typ) => {\n-                debug!(\"replacing TyBox {} with {}\",\n-                       typ.repr(rcx.tcx()), new_typ.repr(rcx.tcx()));\n+                debug!(\"replacing TyBox {:?} with {:?}\",\n+                       typ, new_typ);\n                 (new_typ, xref_depth_orig + 1)\n             }\n \n@@ -411,7 +408,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n         debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n                 {}typ: {} scope: {:?} xref: {}\",\n                (0..depth).map(|_| ' ').collect::<String>(),\n-               typ.repr(rcx.tcx()), scope, xref_depth);\n+               typ, scope, xref_depth);\n \n         // If `typ` has a destructor, then we must ensure that all\n         // borrowed data reachable via `typ` must outlive the parent\n@@ -467,8 +464,8 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n \n             match typ.sty {\n                 ty::TyStruct(struct_did, substs) => {\n-                    debug!(\"typ: {} is struct; traverse structure and not type-expression\",\n-                           typ.repr(rcx.tcx()));\n+                    debug!(\"typ: {:?} is struct; traverse structure and not type-expression\",\n+                           typ);\n                     // Don't recurse; we extract type's substructure,\n                     // so do not process subparts of type expression.\n                     walker.skip_current_subtree();\n@@ -497,8 +494,8 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n                 }\n \n                 ty::TyEnum(enum_did, substs) => {\n-                    debug!(\"typ: {} is enum; traverse structure and not type-expression\",\n-                           typ.repr(rcx.tcx()));\n+                    debug!(\"typ: {:?} is enum; traverse structure and not type-expression\",\n+                           typ);\n                     // Don't recurse; we extract type's substructure,\n                     // so do not process subparts of type expression.\n                     walker.skip_current_subtree();\n@@ -571,24 +568,24 @@ fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n     match dtor_kind {\n         DtorKind::PureRecur => {\n             has_dtor_of_interest = false;\n-            debug!(\"typ: {} has no dtor, and thus is uninteresting\",\n-                   typ.repr(tcx));\n+            debug!(\"typ: {:?} has no dtor, and thus is uninteresting\",\n+                   typ);\n         }\n         DtorKind::Unknown(bounds) => {\n             match bounds.region_bound {\n                 ty::ReStatic => {\n-                    debug!(\"trait: {} has 'static bound, and thus is uninteresting\",\n-                           typ.repr(tcx));\n+                    debug!(\"trait: {:?} has 'static bound, and thus is uninteresting\",\n+                           typ);\n                     has_dtor_of_interest = false;\n                 }\n                 ty::ReEmpty => {\n-                    debug!(\"trait: {} has empty region bound, and thus is uninteresting\",\n-                           typ.repr(tcx));\n+                    debug!(\"trait: {:?} has empty region bound, and thus is uninteresting\",\n+                           typ);\n                     has_dtor_of_interest = false;\n                 }\n                 r => {\n-                    debug!(\"trait: {} has non-static bound: {}; assumed interesting\",\n-                           typ.repr(tcx), r.repr(tcx));\n+                    debug!(\"trait: {:?} has non-static bound: {:?}; assumed interesting\",\n+                           typ, r);\n                     has_dtor_of_interest = true;\n                 }\n             }\n@@ -645,8 +642,8 @@ fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n                     if result {\n                         has_pred_of_interest = true;\n-                        debug!(\"typ: {} has interesting dtor due to generic preds, e.g. {}\",\n-                               typ.repr(tcx), pred.repr(tcx));\n+                        debug!(\"typ: {:?} has interesting dtor due to generic preds, e.g. {:?}\",\n+                               typ, pred);\n                         break 'items;\n                     }\n                 }\n@@ -670,14 +667,14 @@ fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 has_pred_of_interest;\n \n             if has_dtor_of_interest {\n-                debug!(\"typ: {} has interesting dtor, due to \\\n+                debug!(\"typ: {:?} has interesting dtor, due to \\\n                         region params: {} or pred: {}\",\n-                       typ.repr(tcx),\n+                       typ,\n                        has_region_param_of_interest,\n                        has_pred_of_interest);\n             } else {\n-                debug!(\"typ: {} has dtor, but it is uninteresting\",\n-                       typ.repr(tcx));\n+                debug!(\"typ: {:?} has dtor, but it is uninteresting\",\n+                       typ);\n             }\n         }\n     }"}, {"sha": "fd93a2493db5aac32ba00ba579696fabd73946e3", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 37, "deletions": 39, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -24,7 +24,6 @@ use middle::infer::InferCtxt;\n use syntax::ast;\n use syntax::codemap::Span;\n use std::iter::repeat;\n-use util::ppaux::Repr;\n \n struct ConfirmContext<'a, 'tcx:'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n@@ -56,10 +55,10 @@ pub fn confirm<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                          supplied_method_types: Vec<Ty<'tcx>>)\n                          -> MethodCallee<'tcx>\n {\n-    debug!(\"confirm(unadjusted_self_ty={}, pick={}, supplied_method_types={})\",\n-           unadjusted_self_ty.repr(fcx.tcx()),\n-           pick.repr(fcx.tcx()),\n-           supplied_method_types.repr(fcx.tcx()));\n+    debug!(\"confirm(unadjusted_self_ty={:?}, pick={:?}, supplied_method_types={:?})\",\n+           unadjusted_self_ty,\n+           pick,\n+           supplied_method_types);\n \n     let mut confirm_cx = ConfirmContext::new(fcx, span, self_expr, call_expr);\n     confirm_cx.confirm(unadjusted_self_ty, pick, supplied_method_types)\n@@ -93,7 +92,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         let (method_types, method_regions) =\n             self.instantiate_method_substs(&pick, supplied_method_types);\n         let all_substs = rcvr_substs.with_method(method_types, method_regions);\n-        debug!(\"all_substs={}\", all_substs.repr(self.tcx()));\n+        debug!(\"all_substs={:?}\", all_substs);\n \n         // Create the final signature for the method, replacing late-bound regions.\n         let InstantiatedMethodSig {\n@@ -225,10 +224,10 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         this.upcast(original_poly_trait_ref.clone(), trait_def_id);\n                     let upcast_trait_ref =\n                         this.replace_late_bound_regions_with_fresh_var(&upcast_poly_trait_ref);\n-                    debug!(\"original_poly_trait_ref={} upcast_trait_ref={} target_trait={}\",\n-                           original_poly_trait_ref.repr(this.tcx()),\n-                           upcast_trait_ref.repr(this.tcx()),\n-                           trait_def_id.repr(this.tcx()));\n+                    debug!(\"original_poly_trait_ref={:?} upcast_trait_ref={:?} target_trait={:?}\",\n+                           original_poly_trait_ref,\n+                           upcast_trait_ref,\n+                           trait_def_id);\n                     let substs = upcast_trait_ref.substs.clone();\n                     let origin = MethodTraitObject(MethodObject {\n                         trait_ref: upcast_trait_ref,\n@@ -322,7 +321,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 self.tcx().sess.span_bug(\n                     self.span,\n                     &format!(\"self-type `{}` for ObjectPick never dereferenced to an object\",\n-                            self_ty.repr(self.tcx())))\n+                            self_ty))\n             }\n         }\n     }\n@@ -376,10 +375,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             Err(_) => {\n                 self.tcx().sess.span_bug(\n                     self.span,\n-                    &format!(\n-                        \"{} was a subtype of {} but now is not?\",\n-                        self_ty.repr(self.tcx()),\n-                        method_self_ty.repr(self.tcx())));\n+                    &format!(\"{} was a subtype of {} but now is not?\",\n+                             self_ty, method_self_ty));\n             }\n         }\n     }\n@@ -392,9 +389,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                               all_substs: subst::Substs<'tcx>)\n                               -> InstantiatedMethodSig<'tcx>\n     {\n-        debug!(\"instantiate_method_sig(pick={}, all_substs={})\",\n-               pick.repr(self.tcx()),\n-               all_substs.repr(self.tcx()));\n+        debug!(\"instantiate_method_sig(pick={:?}, all_substs={:?})\",\n+               pick,\n+               all_substs);\n \n         // Instantiate the bounds on the method with the\n         // type/early-bound-regions substitutions performed. There can\n@@ -404,8 +401,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         let method_predicates = self.fcx.normalize_associated_types_in(self.span,\n                                                                        &method_predicates);\n \n-        debug!(\"method_predicates after subst = {}\",\n-               method_predicates.repr(self.tcx()));\n+        debug!(\"method_predicates after subst = {:?}\",\n+               method_predicates);\n \n         // Instantiate late-bound regions and substitute the trait\n         // parameters into the method type to get the actual method type.\n@@ -415,12 +412,12 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // may reference those regions.\n         let method_sig = self.replace_late_bound_regions_with_fresh_var(\n             &pick.item.as_opt_method().unwrap().fty.sig);\n-        debug!(\"late-bound lifetimes from method instantiated, method_sig={}\",\n-               method_sig.repr(self.tcx()));\n+        debug!(\"late-bound lifetimes from method instantiated, method_sig={:?}\",\n+               method_sig);\n \n         let method_sig = self.fcx.instantiate_type_scheme(self.span, &all_substs, &method_sig);\n-        debug!(\"type scheme substituted, method_sig={}\",\n-               method_sig.repr(self.tcx()));\n+        debug!(\"type scheme substituted, method_sig={:?}\",\n+               method_sig);\n \n         InstantiatedMethodSig {\n             method_sig: method_sig,\n@@ -433,10 +430,10 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                        pick: &probe::Pick<'tcx>,\n                        all_substs: &subst::Substs<'tcx>,\n                        method_predicates: &ty::InstantiatedPredicates<'tcx>) {\n-        debug!(\"add_obligations: pick={} all_substs={} method_predicates={}\",\n-               pick.repr(self.tcx()),\n-               all_substs.repr(self.tcx()),\n-               method_predicates.repr(self.tcx()));\n+        debug!(\"add_obligations: pick={:?} all_substs={:?} method_predicates={:?}\",\n+               pick,\n+               all_substs,\n+               method_predicates);\n \n         self.fcx.add_obligations_for_parameters(\n             traits::ObligationCause::misc(self.span, self.fcx.body_id),\n@@ -483,8 +480,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             }\n         }\n \n-        debug!(\"fixup_derefs_on_method_receiver_if_necessary: exprs={}\",\n-               exprs.repr(self.tcx()));\n+        debug!(\"fixup_derefs_on_method_receiver_if_necessary: exprs={:?}\",\n+               exprs);\n \n         // Fix up autoderefs and derefs.\n         for (i, &expr) in exprs.iter().rev().enumerate() {\n@@ -498,8 +495,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 Some(_) | None => 0,\n             };\n \n-            debug!(\"fixup_derefs_on_method_receiver_if_necessary: i={} expr={} autoderef_count={}\",\n-                   i, expr.repr(self.tcx()), autoderef_count);\n+            debug!(\"fixup_derefs_on_method_receiver_if_necessary: i={} expr={:?} \\\n+                                                                  autoderef_count={}\",\n+                   i, expr, autoderef_count);\n \n             if autoderef_count > 0 {\n                 check::autoderef(self.fcx,\n@@ -545,8 +543,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                 Some(_) => {\n                                     self.tcx().sess.span_bug(\n                                         base_expr.span,\n-                                        &format!(\"unexpected adjustment autoref {}\",\n-                                                adr.repr(self.tcx())));\n+                                        &format!(\"unexpected adjustment autoref {:?}\",\n+                                                adr));\n                                 }\n                             },\n                             None => (0, None),\n@@ -647,17 +645,17 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         if upcast_trait_refs.len() != 1 {\n             self.tcx().sess.span_bug(\n                 self.span,\n-                &format!(\"cannot uniquely upcast `{}` to `{}`: `{}`\",\n-                         source_trait_ref.repr(self.tcx()),\n-                         target_trait_def_id.repr(self.tcx()),\n-                         upcast_trait_refs.repr(self.tcx())));\n+                &format!(\"cannot uniquely upcast `{:?}` to `{:?}`: `{:?}`\",\n+                         source_trait_ref,\n+                         target_trait_def_id,\n+                         upcast_trait_refs));\n         }\n \n         upcast_trait_refs.into_iter().next().unwrap()\n     }\n \n     fn replace_late_bound_regions_with_fresh_var<T>(&self, value: &ty::Binder<T>) -> T\n-        where T : TypeFoldable<'tcx> + Repr<'tcx>\n+        where T : TypeFoldable<'tcx>\n     {\n         self.infcx().replace_late_bound_regions_with_fresh_var(\n             self.span, infer::FnCall, value).0"}, {"sha": "85a4b02cf804e5bf36f4f96f4a51c8a45cce59fd", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -18,7 +18,6 @@ use middle::subst;\n use middle::traits;\n use middle::ty::{self, AsPredicate, ToPolyTraitRef};\n use middle::infer;\n-use util::ppaux::Repr;\n \n use syntax::ast::DefId;\n use syntax::ast;\n@@ -96,11 +95,11 @@ pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         self_expr: &'tcx ast::Expr)\n                         -> Result<ty::MethodCallee<'tcx>, MethodError>\n {\n-    debug!(\"lookup(method_name={}, self_ty={}, call_expr={}, self_expr={})\",\n-           method_name.repr(fcx.tcx()),\n-           self_ty.repr(fcx.tcx()),\n-           call_expr.repr(fcx.tcx()),\n-           self_expr.repr(fcx.tcx()));\n+    debug!(\"lookup(method_name={}, self_ty={:?}, call_expr={:?}, self_expr={:?})\",\n+           method_name,\n+           self_ty,\n+           call_expr,\n+           self_expr);\n \n     let mode = probe::Mode::MethodCall;\n     let self_ty = fcx.infcx().resolve_type_vars_if_possible(&self_ty);\n@@ -141,11 +140,11 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                           opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n                                           -> Option<ty::MethodCallee<'tcx>>\n {\n-    debug!(\"lookup_in_trait_adjusted(self_ty={}, self_expr={}, m_name={}, trait_def_id={})\",\n-           self_ty.repr(fcx.tcx()),\n-           self_expr.repr(fcx.tcx()),\n-           m_name.repr(fcx.tcx()),\n-           trait_def_id.repr(fcx.tcx()));\n+    debug!(\"lookup_in_trait_adjusted(self_ty={:?}, self_expr={:?}, m_name={}, trait_def_id={:?})\",\n+           self_ty,\n+           self_expr,\n+           m_name,\n+           trait_def_id);\n \n     let trait_def = ty::lookup_trait_def(fcx.tcx(), trait_def_id);\n \n@@ -190,8 +189,8 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     assert_eq!(method_ty.generics.types.len(subst::FnSpace), 0);\n     assert_eq!(method_ty.generics.regions.len(subst::FnSpace), 0);\n \n-    debug!(\"lookup_in_trait_adjusted: method_num={} method_ty={}\",\n-           method_num, method_ty.repr(fcx.tcx()));\n+    debug!(\"lookup_in_trait_adjusted: method_num={} method_ty={:?}\",\n+           method_num, method_ty);\n \n     // Instantiate late-bound regions and substitute the trait\n     // parameters into the method type to get the actual method type.\n@@ -210,9 +209,9 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         abi: method_ty.fty.abi.clone(),\n     }));\n \n-    debug!(\"lookup_in_trait_adjusted: matched method fty={} obligation={}\",\n-           fty.repr(fcx.tcx()),\n-           obligation.repr(fcx.tcx()));\n+    debug!(\"lookup_in_trait_adjusted: matched method fty={:?} obligation={:?}\",\n+           fty,\n+           obligation);\n \n     // Register obligations for the parameters.  This will include the\n     // `Self` parameter, which in turn has a bound of the main trait,\n@@ -272,7 +271,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                 span,\n                                 &format!(\n                                     \"trait method is &self but first arg is: {}\",\n-                                    transformed_self_ty.repr(fcx.tcx())));\n+                                    transformed_self_ty));\n                         }\n                     }\n                 }\n@@ -296,7 +295,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         substs: trait_ref.substs.clone()\n     };\n \n-    debug!(\"callee = {}\", callee.repr(fcx.tcx()));\n+    debug!(\"callee = {:?}\", callee);\n \n     Some(callee)\n }"}, {"sha": "ecf6cad32be76430544ca03e6b736665197d543a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 61, "deletions": 114, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -28,7 +28,6 @@ use syntax::codemap::{Span, DUMMY_SP};\n use std::collections::HashSet;\n use std::mem;\n use std::rc::Rc;\n-use util::ppaux::Repr;\n \n use self::CandidateKind::*;\n pub use self::PickKind::*;\n@@ -46,18 +45,21 @@ struct ProbeContext<'a, 'tcx:'a> {\n     static_candidates: Vec<CandidateSource>,\n }\n \n+#[derive(Debug)]\n struct CandidateStep<'tcx> {\n     self_ty: Ty<'tcx>,\n     autoderefs: usize,\n     unsize: bool\n }\n \n+#[derive(Debug)]\n struct Candidate<'tcx> {\n     xform_self_ty: Ty<'tcx>,\n     item: ty::ImplOrTraitItem<'tcx>,\n     kind: CandidateKind<'tcx>,\n }\n \n+#[derive(Debug)]\n enum CandidateKind<'tcx> {\n     InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>,\n                           /* Normalize obligations */ Vec<traits::PredicateObligation<'tcx>>),\n@@ -70,6 +72,7 @@ enum CandidateKind<'tcx> {\n     ProjectionCandidate(ast::DefId, ItemIndex),\n }\n \n+#[derive(Debug)]\n pub struct Pick<'tcx> {\n     pub item: ty::ImplOrTraitItem<'tcx>,\n     pub kind: PickKind<'tcx>,\n@@ -123,8 +126,8 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                        scope_expr_id: ast::NodeId)\n                        -> PickResult<'tcx>\n {\n-    debug!(\"probe(self_ty={}, item_name={}, scope_expr_id={})\",\n-           self_ty.repr(fcx.tcx()),\n+    debug!(\"probe(self_ty={:?}, item_name={}, scope_expr_id={})\",\n+           self_ty,\n            item_name,\n            scope_expr_id);\n \n@@ -163,9 +166,9 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             Some(simplified_steps)\n         };\n \n-    debug!(\"ProbeContext: steps for self_ty={} are {}\",\n-           self_ty.repr(fcx.tcx()),\n-           steps.repr(fcx.tcx()));\n+    debug!(\"ProbeContext: steps for self_ty={:?} are {:?}\",\n+           self_ty,\n+           steps);\n \n     // this creates one big transaction so that all type variables etc\n     // that we create during the probe process are removed later\n@@ -268,8 +271,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn assemble_probe(&mut self, self_ty: Ty<'tcx>) {\n-        debug!(\"assemble_probe: self_ty={}\",\n-               self_ty.repr(self.tcx()));\n+        debug!(\"assemble_probe: self_ty={:?}\",\n+               self_ty);\n \n         match self_ty.sty {\n             ty::TyTrait(box ref data) => {\n@@ -412,7 +415,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let traits::Normalized { value: xform_self_ty, obligations } =\n             traits::normalize(selcx, cause, &xform_self_ty);\n         debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}\",\n-               xform_self_ty.repr(self.tcx()));\n+               xform_self_ty);\n \n         self.inherent_candidates.push(Candidate {\n             xform_self_ty: xform_self_ty,\n@@ -424,8 +427,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn assemble_inherent_candidates_from_object(&mut self,\n                                                 self_ty: Ty<'tcx>,\n                                                 data: &ty::TraitTy<'tcx>) {\n-        debug!(\"assemble_inherent_candidates_from_object(self_ty={})\",\n-               self_ty.repr(self.tcx()));\n+        debug!(\"assemble_inherent_candidates_from_object(self_ty={:?})\",\n+               self_ty);\n \n         let tcx = self.tcx();\n \n@@ -496,10 +499,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                    trait_ref.substs);\n \n             if let Some(ref m) = item.as_opt_method() {\n-                debug!(\"found match: trait_ref={} substs={} m={}\",\n-                       trait_ref.repr(this.tcx()),\n-                       trait_ref.substs.repr(this.tcx()),\n-                       m.repr(this.tcx()));\n+                debug!(\"found match: trait_ref={:?} substs={:?} m={:?}\",\n+                       trait_ref,\n+                       trait_ref.substs,\n+                       m);\n                 assert_eq!(m.generics.types.get_slice(subst::TypeSpace).len(),\n                            trait_ref.substs.types.get_slice(subst::TypeSpace).len());\n                 assert_eq!(m.generics.regions.get_slice(subst::TypeSpace).len(),\n@@ -539,7 +542,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             usize,\n         ),\n     {\n-        debug!(\"elaborate_bounds(bounds={})\", bounds.repr(self.tcx()));\n+        debug!(\"elaborate_bounds(bounds={:?})\", bounds);\n \n         let tcx = self.tcx();\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n@@ -588,8 +591,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                trait_def_id: ast::DefId)\n                                                -> Result<(),MethodError>\n     {\n-        debug!(\"assemble_extension_candidates_for_trait(trait_def_id={})\",\n-               trait_def_id.repr(self.tcx()));\n+        debug!(\"assemble_extension_candidates_for_trait(trait_def_id={:?})\",\n+               trait_def_id);\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n         let trait_items =\n@@ -638,24 +641,25 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         // FIXME(arielb1): can we use for_each_relevant_impl here?\n         trait_def.for_each_impl(self.tcx(), |impl_def_id| {\n-            debug!(\"assemble_extension_candidates_for_trait_impl: trait_def_id={} impl_def_id={}\",\n-                   trait_def_id.repr(self.tcx()),\n-                   impl_def_id.repr(self.tcx()));\n+            debug!(\"assemble_extension_candidates_for_trait_impl: trait_def_id={:?} \\\n+                                                                  impl_def_id={:?}\",\n+                   trait_def_id,\n+                   impl_def_id);\n \n             if !self.impl_can_possibly_match(impl_def_id) {\n                 return;\n             }\n \n             let (_, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n \n-            debug!(\"impl_substs={}\", impl_substs.repr(self.tcx()));\n+            debug!(\"impl_substs={:?}\", impl_substs);\n \n             let impl_trait_ref =\n                 ty::impl_trait_ref(self.tcx(), impl_def_id)\n                 .unwrap() // we know this is a trait impl\n                 .subst(self.tcx(), &impl_substs);\n \n-            debug!(\"impl_trait_ref={}\", impl_trait_ref.repr(self.tcx()));\n+            debug!(\"impl_trait_ref={:?}\", impl_trait_ref);\n \n             // Determine the receiver type that the method itself expects.\n             let xform_self_ty =\n@@ -671,7 +675,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             let traits::Normalized { value: xform_self_ty, obligations } =\n                 traits::normalize(selcx, cause, &xform_self_ty);\n \n-            debug!(\"xform_self_ty={}\", xform_self_ty.repr(self.tcx()));\n+            debug!(\"xform_self_ty={:?}\", xform_self_ty);\n \n             self.extension_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n@@ -769,50 +773,50 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                       item_index: usize)\n     {\n         debug!(\"assemble_projection_candidates(\\\n-               trait_def_id={}, \\\n-               item={}, \\\n+               trait_def_id={:?}, \\\n+               item={:?}, \\\n                item_index={})\",\n-               trait_def_id.repr(self.tcx()),\n-               item.repr(self.tcx()),\n+               trait_def_id,\n+               item,\n                item_index);\n \n         for step in self.steps.iter() {\n-            debug!(\"assemble_projection_candidates: step={}\",\n-                   step.repr(self.tcx()));\n+            debug!(\"assemble_projection_candidates: step={:?}\",\n+                   step);\n \n             let projection_trait_ref = match step.self_ty.sty {\n                 ty::TyProjection(ref data) => &data.trait_ref,\n                 _ => continue,\n             };\n \n-            debug!(\"assemble_projection_candidates: projection_trait_ref={}\",\n-                   projection_trait_ref.repr(self.tcx()));\n+            debug!(\"assemble_projection_candidates: projection_trait_ref={:?}\",\n+                   projection_trait_ref);\n \n             let trait_predicates = ty::lookup_predicates(self.tcx(),\n                                                          projection_trait_ref.def_id);\n             let bounds = trait_predicates.instantiate(self.tcx(), projection_trait_ref.substs);\n             let predicates = bounds.predicates.into_vec();\n-            debug!(\"assemble_projection_candidates: predicates={}\",\n-                   predicates.repr(self.tcx()));\n+            debug!(\"assemble_projection_candidates: predicates={:?}\",\n+                   predicates);\n             for poly_bound in\n                 traits::elaborate_predicates(self.tcx(), predicates)\n                 .filter_map(|p| p.to_opt_poly_trait_ref())\n                 .filter(|b| b.def_id() == trait_def_id)\n             {\n                 let bound = self.erase_late_bound_regions(&poly_bound);\n \n-                debug!(\"assemble_projection_candidates: projection_trait_ref={} bound={}\",\n-                       projection_trait_ref.repr(self.tcx()),\n-                       bound.repr(self.tcx()));\n+                debug!(\"assemble_projection_candidates: projection_trait_ref={:?} bound={:?}\",\n+                       projection_trait_ref,\n+                       bound);\n \n                 if self.infcx().can_equate(&step.self_ty, &bound.self_ty()).is_ok() {\n                     let xform_self_ty = self.xform_self_ty(&item,\n                                                            bound.self_ty(),\n                                                            bound.substs);\n \n-                    debug!(\"assemble_projection_candidates: bound={} xform_self_ty={}\",\n-                           bound.repr(self.tcx()),\n-                           xform_self_ty.repr(self.tcx()));\n+                    debug!(\"assemble_projection_candidates: bound={:?} xform_self_ty={:?}\",\n+                           bound,\n+                           xform_self_ty);\n \n                     self.extension_candidates.push(Candidate {\n                         xform_self_ty: xform_self_ty,\n@@ -829,8 +833,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                         item: ty::ImplOrTraitItem<'tcx>,\n                                         item_index: usize)\n     {\n-        debug!(\"assemble_where_clause_candidates(trait_def_id={})\",\n-               trait_def_id.repr(self.tcx()));\n+        debug!(\"assemble_where_clause_candidates(trait_def_id={:?})\",\n+               trait_def_id);\n \n         let caller_predicates = self.fcx.inh.param_env.caller_bounds.clone();\n         for poly_bound in traits::elaborate_predicates(self.tcx(), caller_predicates)\n@@ -842,9 +846,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                    bound.self_ty(),\n                                                    bound.substs);\n \n-            debug!(\"assemble_where_clause_candidates: bound={} xform_self_ty={}\",\n-                   bound.repr(self.tcx()),\n-                   xform_self_ty.repr(self.tcx()));\n+            debug!(\"assemble_where_clause_candidates: bound={:?} xform_self_ty={:?}\",\n+                   bound,\n+                   xform_self_ty);\n \n             self.extension_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n@@ -910,7 +914,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn pick_step(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> {\n-        debug!(\"pick_step: step={}\", step.repr(self.tcx()));\n+        debug!(\"pick_step: step={:?}\", step);\n \n         if ty::type_is_error(step.self_ty) {\n             return None;\n@@ -1008,7 +1012,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                   .filter(|&probe| self.consider_probe(self_ty, probe))\n                   .collect();\n \n-        debug!(\"applicable_candidates: {}\", applicable_candidates.repr(self.tcx()));\n+        debug!(\"applicable_candidates: {:?}\", applicable_candidates);\n \n         if applicable_candidates.len() > 1 {\n             match self.collapse_candidates_to_trait_pick(&applicable_candidates[..]) {\n@@ -1029,9 +1033,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn consider_probe(&self, self_ty: Ty<'tcx>, probe: &Candidate<'tcx>) -> bool {\n-        debug!(\"consider_probe: self_ty={} probe={}\",\n-               self_ty.repr(self.tcx()),\n-               probe.repr(self.tcx()));\n+        debug!(\"consider_probe: self_ty={:?} probe={:?}\",\n+               self_ty,\n+               probe);\n \n         self.infcx().probe(|_| {\n             // First check that the self type can be related.\n@@ -1062,10 +1066,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n                     // Convert the bounds into obligations.\n                     let obligations =\n-                        traits::predicates_for_generics(self.tcx(),\n-                                                        cause.clone(),\n+                        traits::predicates_for_generics(cause.clone(),\n                                                         &impl_bounds);\n-                    debug!(\"impl_obligations={}\", obligations.repr(self.tcx()));\n+                    debug!(\"impl_obligations={:?}\", obligations);\n \n                     // Evaluate those obligations to see if they might possibly hold.\n                     obligations.iter()\n@@ -1177,10 +1180,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                             substs: &subst::Substs<'tcx>)\n                             -> Ty<'tcx>\n     {\n-        debug!(\"xform_self_ty(impl_ty={}, self_ty={}, substs={})\",\n-               impl_ty.repr(self.tcx()),\n-               method.fty.sig.0.inputs.get(0).repr(self.tcx()),\n-               substs.repr(self.tcx()));\n+        debug!(\"xform_self_ty(impl_ty={:?}, self_ty={:?}, substs={:?})\",\n+               impl_ty,\n+               method.fty.sig.0.inputs.get(0),\n+               substs);\n \n         assert!(!substs.has_escaping_regions());\n \n@@ -1265,7 +1268,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     ///    and/or tracking the substitution and\n     ///    so forth.\n     fn erase_late_bound_regions<T>(&self, value: &ty::Binder<T>) -> T\n-        where T : TypeFoldable<'tcx> + Repr<'tcx>\n+        where T : TypeFoldable<'tcx>\n     {\n         ty::erase_late_bound_regions(self.tcx(), value)\n     }\n@@ -1371,59 +1374,3 @@ impl<'tcx> Candidate<'tcx> {\n         }\n     }\n }\n-\n-impl<'tcx> Repr<'tcx> for Candidate<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"Candidate(xform_self_ty={}, kind={})\",\n-                self.xform_self_ty.repr(tcx),\n-                self.kind.repr(tcx))\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for CandidateKind<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        match *self {\n-            InherentImplCandidate(ref a, ref b, ref c) =>\n-                format!(\"InherentImplCandidate({},{},{})\", a.repr(tcx), b.repr(tcx),\n-                        c.repr(tcx)),\n-            ObjectCandidate(a, b, c) =>\n-                format!(\"ObjectCandidate({},{},{})\", a.repr(tcx), b, c),\n-            ExtensionImplCandidate(ref a, ref b, ref c, ref d, ref e) =>\n-                format!(\"ExtensionImplCandidate({},{},{},{},{})\", a.repr(tcx), b.repr(tcx),\n-                        c.repr(tcx), d, e.repr(tcx)),\n-            ClosureCandidate(ref a, ref b) =>\n-                format!(\"ClosureCandidate({},{})\", a.repr(tcx), b),\n-            WhereClauseCandidate(ref a, ref b) =>\n-                format!(\"WhereClauseCandidate({},{})\", a.repr(tcx), b),\n-            ProjectionCandidate(ref a, ref b) =>\n-                format!(\"ProjectionCandidate({},{})\", a.repr(tcx), b),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for CandidateStep<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"CandidateStep({}, autoderefs={}, unsize={})\",\n-                self.self_ty.repr(tcx),\n-                self.autoderefs,\n-                self.unsize)\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for PickKind<'tcx> {\n-    fn repr(&self, _tcx: &ty::ctxt) -> String {\n-        format!(\"{:?}\", self)\n-    }\n-}\n-\n-impl<'tcx> Repr<'tcx> for Pick<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"Pick(item={}, autoderefs={},\n-                 autoref={}, unsize={}, kind={:?})\",\n-                self.item.repr(tcx),\n-                self.autoderefs,\n-                self.autoref.repr(tcx),\n-                self.unsize.repr(tcx),\n-                self.kind)\n-    }\n-}"}, {"sha": "b098fb56d4db62b20365cdc5d39cc0d7ea02f5d9", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -18,7 +18,6 @@ use check::{self, FnCtxt};\n use middle::ty::{self, Ty};\n use middle::def;\n use metadata::{csearch, cstore, decoder};\n-use util::ppaux::UserString;\n \n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n@@ -45,7 +44,6 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     match error {\n         MethodError::NoMatch(static_sources, out_of_scope_traits, mode) => {\n             let cx = fcx.tcx();\n-            let item_ustring = item_name.user_string(cx);\n \n             fcx.type_error_message(\n                 span,\n@@ -54,7 +52,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              in the current scope\",\n                             if mode == Mode::MethodCall { \"method\" }\n                             else { \"associated item\" },\n-                            item_ustring,\n+                            item_name,\n                             actual)\n                 },\n                 rcvr_ty,\n@@ -66,7 +64,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 if fields.iter().any(|f| f.name == item_name) {\n                     cx.sess.span_note(span,\n                         &format!(\"use `(s.{0})(...)` if you meant to call the \\\n-                                 function stored in the `{0}` field\", item_ustring));\n+                                 function stored in the `{0}` field\", item_name));\n                 }\n             }\n \n@@ -93,7 +91,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             let msg = format!(\"the `{}` method from the `{}` trait cannot be explicitly \\\n                                invoked on this closure as we have not yet inferred what \\\n                                kind of closure it is\",\n-                               item_name.user_string(fcx.tcx()),\n+                               item_name,\n                                ty::item_path_str(fcx.tcx(), trait_def_id));\n             let msg = if let Some(callee) = rcvr_expr {\n                 format!(\"{}; use overloaded call notation instead (e.g., `{}()`)\",\n@@ -134,7 +132,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                \"candidate #{} is defined in an impl{} for the type `{}`\",\n                                idx + 1,\n                                insertion,\n-                               impl_ty.user_string(fcx.tcx()));\n+                               impl_ty);\n                 }\n                 CandidateSource::TraitSource(trait_did) => {\n                     let (_, item) = trait_item(fcx.tcx(), trait_did, item_name).unwrap();\n@@ -160,7 +158,6 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                       valid_out_of_scope_traits: Vec<ast::DefId>)\n {\n     let tcx = fcx.tcx();\n-    let item_ustring = item_name.user_string(tcx);\n \n     if !valid_out_of_scope_traits.is_empty() {\n         let mut candidates = valid_out_of_scope_traits;\n@@ -217,7 +214,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n              perhaps you need to implement {one_of_them}:\",\n             traits_define = if candidates.len() == 1 {\"trait defines\"} else {\"traits define\"},\n             one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"},\n-            name = item_ustring);\n+            name = item_name);\n \n         fcx.sess().fileline_help(span, &msg[..]);\n "}, {"sha": "34df349b7a3db373c885c57ea970eb468f85cf45", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 83, "deletions": 106, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -106,7 +106,6 @@ use {CrateCtxt, lookup_full_def, require_same_types};\n use TypeAndSubsts;\n use lint;\n use util::common::{block_query, ErrorReported, indenter, loop_query};\n-use util::ppaux::{self, Repr};\n use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n use util::lev_distance::lev_distance;\n \n@@ -193,7 +192,7 @@ type DeferredCallResolutionHandler<'tcx> = Box<DeferredCallResolution<'tcx>+'tcx\n \n /// When type-checking an expression, we propagate downward\n /// whatever type hint we are able in the form of an `Expectation`.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub enum Expectation<'tcx> {\n     /// We know nothing about what type this expression should have.\n     NoExpectation,\n@@ -398,7 +397,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n                                         body_id: ast::NodeId,\n                                         value: &T)\n                                         -> T\n-        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes + Repr<'tcx>\n+        where T : TypeFoldable<'tcx> + HasProjectionTypes\n     {\n         let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n         assoc::normalize_associated_types_in(&self.infcx,\n@@ -567,8 +566,8 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n             None => None\n         };\n         self.assign(local.span, local.id, o_ty);\n-        debug!(\"Local variable {} is assigned type {}\",\n-               self.fcx.pat_to_string(&*local.pat),\n+        debug!(\"Local variable {:?} is assigned type {}\",\n+               local.pat,\n                self.fcx.infcx().ty_to_string(\n                    self.fcx.inh.locals.borrow().get(&local.id).unwrap().clone()));\n         visit::walk_local(self, local);\n@@ -583,11 +582,11 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n                 self.fcx.require_type_is_sized(var_ty, p.span,\n                                                traits::VariableType(p.id));\n \n-                debug!(\"Pattern binding {} is assigned to {} with type {}\",\n+                debug!(\"Pattern binding {} is assigned to {} with type {:?}\",\n                        token::get_ident(path1.node),\n                        self.fcx.infcx().ty_to_string(\n                            self.fcx.inh.locals.borrow().get(&p.id).unwrap().clone()),\n-                       var_ty.repr(self.fcx.tcx()));\n+                       var_ty);\n             }\n         }\n         visit::walk_pat(self, p);\n@@ -641,9 +640,9 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n     let arg_tys = &fn_sig.inputs;\n     let ret_ty = fn_sig.output;\n \n-    debug!(\"check_fn(arg_tys={}, ret_ty={}, fn_id={})\",\n-           arg_tys.repr(tcx),\n-           ret_ty.repr(tcx),\n+    debug!(\"check_fn(arg_tys={:?}, ret_ty={:?}, fn_id={})\",\n+           arg_tys,\n+           ret_ty,\n            fn_id);\n \n     // Create the function context.  This is either derived from scratch or,\n@@ -669,9 +668,9 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n         fn_sig_tys.push(ret_ty);\n     }\n \n-    debug!(\"fn-sig-map: fn_id={} fn_sig_tys={}\",\n+    debug!(\"fn-sig-map: fn_id={} fn_sig_tys={:?}\",\n            fn_id,\n-           fn_sig_tys.repr(tcx));\n+           fn_sig_tys);\n \n     inherited.fn_sig_map.borrow_mut().insert(fn_id, fn_sig_tys);\n \n@@ -918,12 +917,12 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                sig: &'tcx ast::MethodSig,\n                                body: &'tcx ast::Block,\n                                id: ast::NodeId, span: Span) {\n-    debug!(\"check_method_body(item_generics={}, id={})\",\n-            item_generics.repr(ccx.tcx), id);\n+    debug!(\"check_method_body(item_generics={:?}, id={})\",\n+            item_generics, id);\n     let param_env = ParameterEnvironment::for_item(ccx.tcx, id);\n \n     let fty = ty::node_id_to_type(ccx.tcx, id);\n-    debug!(\"check_method_body: fty={}\", fty.repr(ccx.tcx));\n+    debug!(\"check_method_body: fty={:?}\", fty);\n \n     check_bare_fn(ccx, &sig.decl, body, id, span, fty, param_env);\n }\n@@ -963,9 +962,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             _ => {\n                                 span_err!(tcx.sess, impl_item.span, E0323,\n                                           \"item `{}` is an associated const, \\\n-                                          which doesn't match its trait `{}`\",\n+                                          which doesn't match its trait `{:?}`\",\n                                           token::get_name(impl_const_ty.name()),\n-                                          impl_trait_ref.repr(tcx))\n+                                          impl_trait_ref)\n                             }\n                         }\n                     }\n@@ -976,9 +975,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             impl_item.span,\n                             &format!(\n                                 \"associated const `{}` is not a member of \\\n-                                 trait `{}`\",\n+                                 trait `{:?}`\",\n                                 token::get_name(impl_const_ty.name()),\n-                                impl_trait_ref.repr(tcx)));\n+                                impl_trait_ref));\n                     }\n                 }\n             }\n@@ -1009,9 +1008,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             _ => {\n                                 span_err!(tcx.sess, impl_item.span, E0324,\n                                           \"item `{}` is an associated method, \\\n-                                          which doesn't match its trait `{}`\",\n+                                          which doesn't match its trait `{:?}`\",\n                                           token::get_name(impl_item_ty.name()),\n-                                          impl_trait_ref.repr(tcx))\n+                                          impl_trait_ref)\n                             }\n                         }\n                     }\n@@ -1020,9 +1019,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         // caught in resolve.\n                         tcx.sess.span_bug(\n                             impl_item.span,\n-                            &format!(\"method `{}` is not a member of trait `{}`\",\n+                            &format!(\"method `{}` is not a member of trait `{:?}`\",\n                                      token::get_name(impl_item_ty.name()),\n-                                     impl_trait_ref.repr(tcx)));\n+                                     impl_trait_ref));\n                     }\n                 }\n             }\n@@ -1043,9 +1042,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             _ => {\n                                 span_err!(tcx.sess, impl_item.span, E0325,\n                                           \"item `{}` is an associated type, \\\n-                                          which doesn't match its trait `{}`\",\n+                                          which doesn't match its trait `{:?}`\",\n                                           token::get_name(typedef_ty.name()),\n-                                          impl_trait_ref.repr(tcx))\n+                                          impl_trait_ref)\n                             }\n                         }\n                     }\n@@ -1056,9 +1055,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             impl_item.span,\n                             &format!(\n                                 \"associated type `{}` is not a member of \\\n-                                 trait `{}`\",\n+                                 trait `{:?}`\",\n                                 token::get_name(typedef_ty.name()),\n-                                impl_trait_ref.repr(tcx)));\n+                                impl_trait_ref));\n                     }\n                 }\n             }\n@@ -1295,26 +1294,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// version, this version will also select obligations if it seems\n     /// useful, in an effort to get more type information.\n     fn resolve_type_vars_if_possible(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n-        debug!(\"resolve_type_vars_if_possible(ty={})\", ty.repr(self.tcx()));\n+        debug!(\"resolve_type_vars_if_possible(ty={:?})\", ty);\n \n         // No ty::infer()? Nothing needs doing.\n         if !ty::type_has_ty_infer(ty) {\n-            debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr(self.tcx()));\n+            debug!(\"resolve_type_vars_if_possible: ty={:?}\", ty);\n             return ty;\n         }\n \n         // If `ty` is a type variable, see whether we already know what it is.\n         ty = self.infcx().resolve_type_vars_if_possible(&ty);\n         if !ty::type_has_ty_infer(ty) {\n-            debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr(self.tcx()));\n+            debug!(\"resolve_type_vars_if_possible: ty={:?}\", ty);\n             return ty;\n         }\n \n         // If not, try resolving any new fcx obligations that have cropped up.\n         self.select_new_obligations();\n         ty = self.infcx().resolve_type_vars_if_possible(&ty);\n         if !ty::type_has_ty_infer(ty) {\n-            debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr(self.tcx()));\n+            debug!(\"resolve_type_vars_if_possible: ty={:?}\", ty);\n             return ty;\n         }\n \n@@ -1325,7 +1324,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.select_obligations_where_possible();\n         ty = self.infcx().resolve_type_vars_if_possible(&ty);\n \n-        debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr(self.tcx()));\n+        debug!(\"resolve_type_vars_if_possible: ty={:?}\", ty);\n         ty\n     }\n \n@@ -1395,16 +1394,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     #[inline]\n     pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty<'tcx>) {\n-        debug!(\"write_ty({}, {}) in fcx {}\",\n-               node_id, ppaux::ty_to_string(self.tcx(), ty), self.tag());\n+        debug!(\"write_ty({}, {:?}) in fcx {}\",\n+               node_id, ty, self.tag());\n         self.inh.node_types.borrow_mut().insert(node_id, ty);\n     }\n \n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) {\n         if !substs.substs.is_noop() {\n-            debug!(\"write_substs({}, {}) in fcx {}\",\n+            debug!(\"write_substs({}, {:?}) in fcx {}\",\n                    node_id,\n-                   substs.repr(self.tcx()),\n+                   substs,\n                    self.tag());\n \n             self.inh.item_substs.borrow_mut().insert(node_id, substs);\n@@ -1427,7 +1426,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn write_adjustment(&self,\n                             node_id: ast::NodeId,\n                             adj: ty::AutoAdjustment<'tcx>) {\n-        debug!(\"write_adjustment(node_id={}, adj={})\", node_id, adj.repr(self.tcx()));\n+        debug!(\"write_adjustment(node_id={}, adj={:?})\", node_id, adj);\n \n         if adj.is_identity() {\n             return;\n@@ -1444,14 +1443,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                   substs: &Substs<'tcx>,\n                                   value: &T)\n                                   -> T\n-        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes + Repr<'tcx>\n+        where T : TypeFoldable<'tcx> + HasProjectionTypes\n     {\n         let value = value.subst(self.tcx(), substs);\n         let result = self.normalize_associated_types_in(span, &value);\n-        debug!(\"instantiate_type_scheme(value={}, substs={}) = {}\",\n-               value.repr(self.tcx()),\n-               substs.repr(self.tcx()),\n-               result.repr(self.tcx()));\n+        debug!(\"instantiate_type_scheme(value={:?}, substs={:?}) = {:?}\",\n+               value,\n+               substs,\n+               result);\n         result\n     }\n \n@@ -1470,7 +1469,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n \n     fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes + Repr<'tcx>\n+        where T : TypeFoldable<'tcx> + HasProjectionTypes\n     {\n         self.inh.normalize_associated_types_in(self, span, self.body_id, value)\n     }\n@@ -1615,8 +1614,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn register_predicate(&self,\n                               obligation: traits::PredicateObligation<'tcx>)\n     {\n-        debug!(\"register_predicate({})\",\n-               obligation.repr(self.tcx()));\n+        debug!(\"register_predicate({:?})\",\n+               obligation);\n         self.inh.fulfillment_cx\n             .borrow_mut()\n             .register_predicate_obligation(self.infcx(), obligation);\n@@ -1633,10 +1632,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         t\n     }\n \n-    pub fn pat_to_string(&self, pat: &ast::Pat) -> String {\n-        pat.repr(self.tcx())\n-    }\n-\n     pub fn expr_ty(&self, ex: &ast::Expr) -> Ty<'tcx> {\n         match self.inh.node_types.borrow().get(&ex.id) {\n             Some(&t) => t,\n@@ -1745,7 +1740,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                       cause: traits::ObligationCause<'tcx>)\n     {\n         let mut fulfillment_cx = self.inh.fulfillment_cx.borrow_mut();\n-        fulfillment_cx.register_region_obligation(self.infcx(), ty, region, cause);\n+        fulfillment_cx.register_region_obligation(ty, region, cause);\n     }\n \n     pub fn add_default_region_param_bounds(&self,\n@@ -1784,12 +1779,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     {\n         assert!(!predicates.has_escaping_regions());\n \n-        debug!(\"add_obligations_for_parameters(predicates={})\",\n-               predicates.repr(self.tcx()));\n+        debug!(\"add_obligations_for_parameters(predicates={:?})\",\n+               predicates);\n \n-        for obligation in traits::predicates_for_generics(self.tcx(),\n-                                                          cause,\n-                                                          predicates) {\n+        for obligation in traits::predicates_for_generics(cause, predicates) {\n             self.register_predicate(obligation);\n         }\n     }\n@@ -1942,9 +1935,9 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                  -> (Ty<'tcx>, usize, Option<T>)\n     where F: FnMut(Ty<'tcx>, usize) -> Option<T>,\n {\n-    debug!(\"autoderef(base_ty={}, opt_expr={}, lvalue_pref={:?})\",\n-           base_ty.repr(fcx.tcx()),\n-           opt_expr.repr(fcx.tcx()),\n+    debug!(\"autoderef(base_ty={:?}, opt_expr={:?}, lvalue_pref={:?})\",\n+           base_ty,\n+           opt_expr,\n            lvalue_pref);\n \n     let mut t = base_ty;\n@@ -2004,8 +1997,8 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // We've reached the recursion limit, error gracefully.\n     span_err!(fcx.tcx().sess, sp, E0055,\n-        \"reached the recursion limit while auto-dereferencing {}\",\n-        base_ty.repr(fcx.tcx()));\n+        \"reached the recursion limit while auto-dereferencing {:?}\",\n+        base_ty);\n     (fcx.tcx().types.err, 0, None)\n }\n \n@@ -2120,14 +2113,14 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                             -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)>\n {\n     let tcx = fcx.tcx();\n-    debug!(\"try_index_step(expr={}, base_expr.id={}, adjusted_ty={}, \\\n-                           autoderefs={}, unsize={}, index_ty={})\",\n-           expr.repr(tcx),\n-           base_expr.repr(tcx),\n-           adjusted_ty.repr(tcx),\n+    debug!(\"try_index_step(expr={:?}, base_expr.id={:?}, adjusted_ty={:?}, \\\n+                           autoderefs={}, unsize={}, index_ty={:?})\",\n+           expr,\n+           base_expr,\n+           adjusted_ty,\n            autoderefs,\n            unsize,\n-           index_ty.repr(tcx));\n+           index_ty);\n \n     let input_ty = fcx.infcx().next_ty_var();\n \n@@ -2606,9 +2599,9 @@ fn expected_types_for_fn_args<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             None\n         }\n     }).unwrap_or(vec![]);\n-    debug!(\"expected_types_for_fn_args(formal={} -> {}, expected={} -> {})\",\n-           formal_args.repr(fcx.tcx()), formal_ret.repr(fcx.tcx()),\n-           expected_args.repr(fcx.tcx()), expected_ret.repr(fcx.tcx()));\n+    debug!(\"expected_types_for_fn_args(formal={:?} -> {:?}, expected={:?} -> {:?})\",\n+           formal_args, formal_ret,\n+           expected_args, expected_ret);\n     expected_args\n }\n \n@@ -2629,8 +2622,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                         unifier: F) where\n     F: FnOnce(),\n {\n-    debug!(\">> typechecking: expr={} expected={}\",\n-           expr.repr(fcx.tcx()), expected.repr(fcx.tcx()));\n+    debug!(\">> typechecking: expr={:?} expected={:?}\",\n+           expr, expected);\n \n     // Checks a method call.\n     fn check_method_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -2746,7 +2739,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   |base_t, _| {\n                 match base_t.sty {\n                     ty::TyStruct(base_id, substs) => {\n-                        debug!(\"struct named {}\", ppaux::ty_to_string(tcx, base_t));\n+                        debug!(\"struct named {:?}\",  base_t);\n                         let fields = ty::lookup_struct_fields(tcx, base_id);\n                         fcx.lookup_field_ty(expr.span, base_id, &fields[..],\n                                             field.node.name, &(*substs))\n@@ -2850,7 +2843,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     ty::TyStruct(base_id, substs) => {\n                         tuple_like = ty::is_tuple_struct(tcx, base_id);\n                         if tuple_like {\n-                            debug!(\"tuple struct named {}\", ppaux::ty_to_string(tcx, base_t));\n+                            debug!(\"tuple struct named {:?}\",  base_t);\n                             let fields = ty::lookup_struct_fields(tcx, base_id);\n                             fcx.lookup_tup_field_ty(expr.span, base_id, &fields[..],\n                                                     idx.node, &(*substs))\n@@ -3276,7 +3269,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 }\n             } else {\n               tcx.sess.span_bug(expr.span,\n-                                &format!(\"unbound path {}\", expr.repr(tcx)))\n+                                &format!(\"unbound path {:?}\", expr))\n           };\n \n           if let Some((opt_ty, segments, def)) =\n@@ -3607,8 +3600,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                type_and_substs.ty) {\n                 Ok(()) => {}\n                 Err(type_error) => {\n-                    let type_error_description =\n-                        ty::type_err_to_str(tcx, &type_error);\n                     span_err!(fcx.tcx().sess, path.span, E0235,\n                                  \"structure constructor specifies a \\\n                                          structure of type `{}`, but this \\\n@@ -3618,7 +3609,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                          fcx.infcx()\n                                             .ty_to_string(\n                                                 actual_structure_type),\n-                                         type_error_description);\n+                                         type_error);\n                     ty::note_and_explain_type_err(tcx, &type_error, path.span);\n                 }\n             }\n@@ -3748,9 +3739,9 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n     debug!(\"type of expr({}) {} is...\", expr.id,\n            syntax::print::pprust::expr_to_string(expr));\n-    debug!(\"... {}, expected is {}\",\n-           ppaux::ty_to_string(tcx, fcx.expr_ty(expr)),\n-           expected.repr(tcx));\n+    debug!(\"... {:?}, expected is {:?}\",\n+           fcx.expr_ty(expr),\n+           expected);\n \n     unifier();\n }\n@@ -3909,20 +3900,6 @@ impl<'tcx> Expectation<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for Expectation<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        match *self {\n-            NoExpectation => format!(\"NoExpectation\"),\n-            ExpectHasType(t) => format!(\"ExpectHasType({})\",\n-                                        t.repr(tcx)),\n-            ExpectCastableToType(t) => format!(\"ExpectCastableToType({})\",\n-                                               t.repr(tcx)),\n-            ExpectRvalueLikeUnsized(t) => format!(\"ExpectRvalueLikeUnsized({})\",\n-                                                  t.repr(tcx)),\n-        }\n-    }\n-}\n-\n pub fn check_decl_initializer<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                        local: &'tcx ast::Local,\n                                        init: &'tcx ast::Expr)\n@@ -4197,8 +4174,8 @@ pub fn check_instantiable(tcx: &ty::ctxt,\n         span_err!(tcx.sess, sp, E0073,\n             \"this type cannot be instantiated without an \\\n              instance of itself\");\n-        fileline_help!(tcx.sess, sp, \"consider using `Option<{}>`\",\n-            ppaux::ty_to_string(tcx, item_ty));\n+        fileline_help!(tcx.sess, sp, \"consider using `Option<{:?}>`\",\n+             item_ty);\n         false\n     } else {\n         true\n@@ -4389,11 +4366,11 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   def: def::Def,\n                                   span: Span,\n                                   node_id: ast::NodeId) {\n-    debug!(\"instantiate_path(path={:?}, def={}, node_id={}, type_scheme={})\",\n+    debug!(\"instantiate_path(path={:?}, def={:?}, node_id={}, type_scheme={:?})\",\n            segments,\n-           def.repr(fcx.tcx()),\n+           def,\n            node_id,\n-           type_scheme.repr(fcx.tcx()));\n+           type_scheme);\n \n     // We need to extract the type parameters supplied by the user in\n     // the path `path`. Due to the current setup, this is a bit of a\n@@ -4633,9 +4610,9 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         if fcx.mk_subty(false, infer::Misc(span), self_ty, impl_ty).is_err() {\n             fcx.tcx().sess.span_bug(span,\n             &format!(\n-                \"instantiate_path: (UFCS) {} was a subtype of {} but now is not?\",\n-                self_ty.repr(fcx.tcx()),\n-                impl_ty.repr(fcx.tcx())));\n+                \"instantiate_path: (UFCS) {:?} was a subtype of {:?} but now is not?\",\n+                self_ty,\n+                impl_ty));\n         }\n     }\n \n@@ -4840,7 +4817,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n         assert_eq!(substs.types.len(space), desired.len());\n \n-        debug!(\"Final substs: {}\", substs.repr(fcx.tcx()));\n+        debug!(\"Final substs: {:?}\", substs);\n     }\n \n     fn adjust_region_parameters(\n@@ -4949,8 +4926,8 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                        span: Span,\n                                        tps: &OwnedSlice<ast::TyParam>,\n                                        ty: Ty<'tcx>) {\n-    debug!(\"check_bounds_are_used(n_tps={}, ty={})\",\n-           tps.len(), ppaux::ty_to_string(ccx.tcx, ty));\n+    debug!(\"check_bounds_are_used(n_tps={}, ty={:?})\",\n+           tps.len(),  ty);\n \n     // make a vector of booleans initially false, set to true when used\n     if tps.is_empty() { return; }\n@@ -5273,7 +5250,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                            fty,\n                            || {\n                 format!(\"intrinsic has wrong type: expected `{}`\",\n-                        ppaux::ty_to_string(ccx.tcx, fty))\n+                         fty)\n             });\n     }\n }"}, {"sha": "a5e4e0fab5963795012ea8be23f324817368e787", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -25,7 +25,6 @@ use middle::ty::{self, Ty};\n use syntax::ast;\n use syntax::ast_util;\n use syntax::parse::token;\n-use util::ppaux::{Repr, UserString};\n \n /// Check a `a <op>= b`\n pub fn check_binop_assign<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n@@ -51,8 +50,8 @@ pub fn check_binop_assign<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         span_err!(tcx.sess, lhs_expr.span, E0368,\n                   \"binary assignment operation `{}=` cannot be applied to types `{}` and `{}`\",\n                   ast_util::binop_to_string(op.node),\n-                  lhs_ty.user_string(fcx.tcx()),\n-                  rhs_ty.user_string(fcx.tcx()));\n+                  lhs_ty,\n+                  rhs_ty);\n         fcx.write_error(expr.id);\n     }\n \n@@ -73,12 +72,12 @@ pub fn check_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n {\n     let tcx = fcx.ccx.tcx;\n \n-    debug!(\"check_binop(expr.id={}, expr={}, op={:?}, lhs_expr={}, rhs_expr={})\",\n+    debug!(\"check_binop(expr.id={}, expr={:?}, op={:?}, lhs_expr={:?}, rhs_expr={:?})\",\n            expr.id,\n-           expr.repr(tcx),\n+           expr,\n            op,\n-           lhs_expr.repr(tcx),\n-           rhs_expr.repr(tcx));\n+           lhs_expr,\n+           rhs_expr);\n \n     check_expr(fcx, lhs_expr);\n     let lhs_ty = fcx.resolve_type_vars_if_possible(fcx.expr_ty(lhs_expr));\n@@ -180,16 +179,16 @@ fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // if this is simd, result is same as lhs, else bool\n             if ty::type_is_simd(tcx, lhs_ty) {\n                 let unit_ty = ty::simd_type(tcx, lhs_ty);\n-                debug!(\"enforce_builtin_binop_types: lhs_ty={} unit_ty={}\",\n-                       lhs_ty.repr(tcx),\n-                       unit_ty.repr(tcx));\n+                debug!(\"enforce_builtin_binop_types: lhs_ty={:?} unit_ty={:?}\",\n+                       lhs_ty,\n+                       unit_ty);\n                 if !ty::type_is_integral(unit_ty) {\n                     tcx.sess.span_err(\n                         lhs_expr.span,\n                         &format!(\"binary comparison operation `{}` not supported \\\n                                   for floating point SIMD vector `{}`\",\n                                  ast_util::binop_to_string(op.node),\n-                                 lhs_ty.user_string(tcx)));\n+                                 lhs_ty));\n                     tcx.types.err\n                 } else {\n                     lhs_ty\n@@ -209,9 +208,9 @@ fn check_overloaded_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                     op: ast::BinOp)\n                                     -> (Ty<'tcx>, Ty<'tcx>)\n {\n-    debug!(\"check_overloaded_binop(expr.id={}, lhs_ty={})\",\n+    debug!(\"check_overloaded_binop(expr.id={}, lhs_ty={:?})\",\n            expr.id,\n-           lhs_ty.repr(fcx.tcx()));\n+           lhs_ty);\n \n     let (name, trait_def_id) = name_and_trait_def_id(fcx, op);\n \n@@ -233,7 +232,7 @@ fn check_overloaded_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 span_err!(fcx.tcx().sess, lhs_expr.span, E0369,\n                           \"binary operation `{}` cannot be applied to type `{}`\",\n                           ast_util::binop_to_string(op.node),\n-                          lhs_ty.user_string(fcx.tcx()));\n+                          lhs_ty);\n             }\n             fcx.tcx().types.err\n         }\n@@ -304,12 +303,12 @@ fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                               lhs_expr: &'a ast::Expr)\n                               -> Result<Ty<'tcx>,()>\n {\n-    debug!(\"lookup_op_method(expr={}, lhs_ty={}, opname={:?}, trait_did={}, lhs_expr={})\",\n-           expr.repr(fcx.tcx()),\n-           lhs_ty.repr(fcx.tcx()),\n+    debug!(\"lookup_op_method(expr={:?}, lhs_ty={:?}, opname={:?}, trait_did={:?}, lhs_expr={:?})\",\n+           expr,\n+           lhs_ty,\n            opname,\n-           trait_did.repr(fcx.tcx()),\n-           lhs_expr.repr(fcx.tcx()));\n+           trait_did,\n+           lhs_expr);\n \n     let method = match trait_did {\n         Some(trait_did) => {"}, {"sha": "a96e7864fe679c8a4d63e69d16c8e79e4100f48c", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 82, "deletions": 86, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -94,7 +94,6 @@ use middle::traits;\n use middle::ty::{self, ClosureTyper, ReScope, Ty, MethodCall};\n use middle::infer::{self, GenericKind};\n use middle::pat_util;\n-use util::ppaux::{ty_to_string, Repr};\n \n use std::mem;\n use syntax::{ast, ast_util};\n@@ -321,8 +320,8 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                                        .to_vec();\n \n         for r_o in &region_obligations {\n-            debug!(\"visit_region_obligations: r_o={}\",\n-                   r_o.repr(self.tcx()));\n+            debug!(\"visit_region_obligations: r_o={:?}\",\n+                   r_o);\n             let sup_type = self.resolve_type(r_o.sup_type);\n             let origin = infer::RelateParamBound(r_o.cause.span, sup_type);\n             type_must_outlive(self, origin, sup_type, r_o.sub_region);\n@@ -348,33 +347,32 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                            body_id: ast::NodeId,\n                            span: Span) {\n         debug!(\"relate_free_regions >>\");\n-        let tcx = self.tcx();\n \n         for &ty in fn_sig_tys {\n             let ty = self.resolve_type(ty);\n-            debug!(\"relate_free_regions(t={})\", ty.repr(tcx));\n+            debug!(\"relate_free_regions(t={:?})\", ty);\n             let body_scope = CodeExtent::from_node_id(body_id);\n             let body_scope = ty::ReScope(body_scope);\n             let implications = implicator::implications(self.fcx.infcx(), self.fcx, body_id,\n                                                         ty, body_scope, span);\n \n             // Record any relations between free regions that we observe into the free-region-map.\n-            self.free_region_map.relate_free_regions_from_implications(tcx, &implications);\n+            self.free_region_map.relate_free_regions_from_implications(&implications);\n \n             // But also record other relationships, such as `T:'x`,\n             // that don't go into the free-region-map but which we use\n             // here.\n             for implication in implications {\n-                debug!(\"implication: {}\", implication.repr(tcx));\n+                debug!(\"implication: {:?}\", implication);\n                 match implication {\n                     implicator::Implication::RegionSubRegion(_,\n                                                              ty::ReFree(free_a),\n                                                              ty::ReInfer(ty::ReVar(vid_b))) => {\n                         self.fcx.inh.infcx.add_given(free_a, vid_b);\n                     }\n                     implicator::Implication::RegionSubGeneric(_, r_a, ref generic_b) => {\n-                        debug!(\"RegionSubGeneric: {} <= {}\",\n-                               r_a.repr(tcx), generic_b.repr(tcx));\n+                        debug!(\"RegionSubGeneric: {:?} <= {:?}\",\n+                               r_a, generic_b);\n \n                         self.region_bound_pairs.push((r_a, generic_b.clone()));\n                     }\n@@ -465,7 +463,7 @@ fn visit_local(rcx: &mut Rcx, l: &ast::Local) {\n \n fn constrain_bindings_in_pat(pat: &ast::Pat, rcx: &mut Rcx) {\n     let tcx = rcx.fcx.tcx();\n-    debug!(\"regionck::visit_pat(pat={})\", pat.repr(tcx));\n+    debug!(\"regionck::visit_pat(pat={:?})\", pat);\n     pat_util::pat_bindings(&tcx.def_map, pat, |_, id, span, _| {\n         // If we have a variable that contains region'd data, that\n         // data will be accessible from anywhere that the variable is\n@@ -502,8 +500,8 @@ fn constrain_bindings_in_pat(pat: &ast::Pat, rcx: &mut Rcx) {\n }\n \n fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n-    debug!(\"regionck::visit_expr(e={}, repeating_scope={})\",\n-           expr.repr(rcx.fcx.tcx()), rcx.repeating_scope);\n+    debug!(\"regionck::visit_expr(e={:?}, repeating_scope={})\",\n+           expr, rcx.repeating_scope);\n \n     // No matter what, the type of each expression must outlive the\n     // scope of that expression. This also guarantees basic WF.\n@@ -745,9 +743,9 @@ fn constrain_cast(rcx: &mut Rcx,\n                   cast_expr: &ast::Expr,\n                   source_expr: &ast::Expr)\n {\n-    debug!(\"constrain_cast(cast_expr={}, source_expr={})\",\n-           cast_expr.repr(rcx.tcx()),\n-           source_expr.repr(rcx.tcx()));\n+    debug!(\"constrain_cast(cast_expr={:?}, source_expr={:?})\",\n+           cast_expr,\n+           source_expr);\n \n     let source_ty = rcx.resolve_node_type(source_expr.id);\n     let target_ty = rcx.resolve_node_type(cast_expr.id);\n@@ -758,9 +756,9 @@ fn constrain_cast(rcx: &mut Rcx,\n                            cast_expr: &ast::Expr,\n                            from_ty: Ty<'tcx>,\n                            to_ty: Ty<'tcx>) {\n-        debug!(\"walk_cast(from_ty={}, to_ty={})\",\n-               from_ty.repr(rcx.tcx()),\n-               to_ty.repr(rcx.tcx()));\n+        debug!(\"walk_cast(from_ty={:?}, to_ty={:?})\",\n+               from_ty,\n+               to_ty);\n         match (&from_ty.sty, &to_ty.sty) {\n             /*From:*/ (&ty::TyRef(from_r, ref from_mt),\n             /*To:  */  &ty::TyRef(to_r, ref to_mt)) => {\n@@ -808,7 +806,7 @@ fn constrain_callee(rcx: &mut Rcx,\n             //\n             // tcx.sess.span_bug(\n             //     callee_expr.span,\n-            //     format!(\"Calling non-function: {}\", callee_ty.repr(tcx)));\n+            //     format!(\"Calling non-function: {}\", callee_ty));\n         }\n     }\n }\n@@ -823,12 +821,11 @@ fn constrain_call<'a, I: Iterator<Item=&'a ast::Expr>>(rcx: &mut Rcx,\n     //! in the type of the function. Also constrains the regions that\n     //! appear in the arguments appropriately.\n \n-    let tcx = rcx.fcx.tcx();\n-    debug!(\"constrain_call(call_expr={}, \\\n-            receiver={}, \\\n+    debug!(\"constrain_call(call_expr={:?}, \\\n+            receiver={:?}, \\\n             implicitly_ref_args={})\",\n-            call_expr.repr(tcx),\n-            receiver.repr(tcx),\n+            call_expr,\n+            receiver,\n             implicitly_ref_args);\n \n     // `callee_region` is the scope representing the time in which the\n@@ -838,10 +835,10 @@ fn constrain_call<'a, I: Iterator<Item=&'a ast::Expr>>(rcx: &mut Rcx,\n     let callee_scope = CodeExtent::from_node_id(call_expr.id);\n     let callee_region = ty::ReScope(callee_scope);\n \n-    debug!(\"callee_region={}\", callee_region.repr(tcx));\n+    debug!(\"callee_region={:?}\", callee_region);\n \n     for arg_expr in arg_exprs {\n-        debug!(\"Argument: {}\", arg_expr.repr(tcx));\n+        debug!(\"Argument: {:?}\", arg_expr);\n \n         // ensure that any regions appearing in the argument type are\n         // valid for at least the lifetime of the function:\n@@ -860,7 +857,7 @@ fn constrain_call<'a, I: Iterator<Item=&'a ast::Expr>>(rcx: &mut Rcx,\n \n     // as loop above, but for receiver\n     if let Some(r) = receiver {\n-        debug!(\"receiver: {}\", r.repr(tcx));\n+        debug!(\"receiver: {:?}\", r);\n         type_of_node_must_outlive(\n             rcx, infer::CallRcvr(r.span),\n             r.id, callee_region);\n@@ -877,10 +874,10 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                   derefs: usize,\n                                   mut derefd_ty: Ty<'tcx>)\n {\n-    debug!(\"constrain_autoderefs(deref_expr={}, derefs={}, derefd_ty={})\",\n-           deref_expr.repr(rcx.tcx()),\n+    debug!(\"constrain_autoderefs(deref_expr={:?}, derefs={}, derefd_ty={:?})\",\n+           deref_expr,\n            derefs,\n-           derefd_ty.repr(rcx.tcx()));\n+           derefd_ty);\n \n     let r_deref_expr = ty::ReScope(CodeExtent::from_node_id(deref_expr.id));\n     for i in 0..derefs {\n@@ -889,8 +886,8 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n \n         derefd_ty = match rcx.fcx.inh.method_map.borrow().get(&method_call) {\n             Some(method) => {\n-                debug!(\"constrain_autoderefs: #{} is overloaded, method={}\",\n-                       i, method.repr(rcx.tcx()));\n+                debug!(\"constrain_autoderefs: #{} is overloaded, method={:?}\",\n+                       i, method);\n \n                 // Treat overloaded autoderefs as if an AutoRef adjustment\n                 // was applied on the base type, as that is always the case.\n@@ -903,19 +900,19 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                     _ => {\n                         rcx.tcx().sess.span_bug(\n                             deref_expr.span,\n-                            &format!(\"bad overloaded deref type {}\",\n-                                     method.ty.repr(rcx.tcx())))\n+                            &format!(\"bad overloaded deref type {:?}\",\n+                                     method.ty))\n                     }\n                 };\n \n                 debug!(\"constrain_autoderefs: receiver r={:?} m={:?}\",\n-                       r.repr(rcx.tcx()), m);\n+                       r, m);\n \n                 {\n                     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n                     let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n                     debug!(\"constrain_autoderefs: self_cmt={:?}\",\n-                           self_cmt.repr(rcx.tcx()));\n+                           self_cmt);\n                     link_region(rcx, deref_expr.span, r,\n                                 ty::BorrowKind::from_mutbl(m), self_cmt);\n                 }\n@@ -976,8 +973,8 @@ fn check_safety_of_rvalue_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 't\n                        .sess\n                        .span_bug(span,\n                                  &format!(\"unexpected rvalue region in rvalue \\\n-                                           destructor safety checking: `{}`\",\n-                                          region.repr(rcx.tcx())));\n+                                           destructor safety checking: `{:?}`\",\n+                                          region));\n                 }\n             }\n         }\n@@ -1025,7 +1022,7 @@ fn type_of_node_must_outlive<'a, 'tcx>(\n                            |method_call| rcx.resolve_method_type(method_call));\n     debug!(\"constrain_regions_in_type_of_node(\\\n             ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n-           ty_to_string(tcx, ty), ty_to_string(tcx, ty0),\n+            ty,  ty0,\n            id, minimum_lifetime);\n     type_must_outlive(rcx, origin, ty, minimum_lifetime);\n }\n@@ -1034,14 +1031,14 @@ fn type_of_node_must_outlive<'a, 'tcx>(\n /// resulting pointer is linked to the lifetime of its guarantor (if any).\n fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n                 mutability: ast::Mutability, base: &ast::Expr) {\n-    debug!(\"link_addr_of(expr={}, base={})\", expr.repr(rcx.tcx()), base.repr(rcx.tcx()));\n+    debug!(\"link_addr_of(expr={:?}, base={:?})\", expr, base);\n \n     let cmt = {\n         let mc = mc::MemCategorizationContext::new(rcx.fcx);\n         ignore_err!(mc.cat_expr(base))\n     };\n \n-    debug!(\"link_addr_of: cmt={}\", cmt.repr(rcx.tcx()));\n+    debug!(\"link_addr_of: cmt={:?}\", cmt);\n \n     link_region_from_node_type(rcx, expr.span, expr.id, mutability, cmt);\n }\n@@ -1067,7 +1064,7 @@ fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n     debug!(\"regionck::for_match()\");\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     let discr_cmt = ignore_err!(mc.cat_expr(discr));\n-    debug!(\"discr_cmt={}\", discr_cmt.repr(rcx.tcx()));\n+    debug!(\"discr_cmt={:?}\", discr_cmt);\n     for arm in arms {\n         for root_pat in &arm.pats {\n             link_pattern(rcx, mc, discr_cmt.clone(), &**root_pat);\n@@ -1085,9 +1082,9 @@ fn link_fn_args(rcx: &Rcx, body_scope: CodeExtent, args: &[ast::Arg]) {\n         let arg_ty = rcx.fcx.node_ty(arg.id);\n         let re_scope = ty::ReScope(body_scope);\n         let arg_cmt = mc.cat_rvalue(arg.id, arg.ty.span, re_scope, arg_ty);\n-        debug!(\"arg_ty={} arg_cmt={}\",\n-               arg_ty.repr(rcx.tcx()),\n-               arg_cmt.repr(rcx.tcx()));\n+        debug!(\"arg_ty={:?} arg_cmt={:?}\",\n+               arg_ty,\n+               arg_cmt);\n         link_pattern(rcx, mc, arg_cmt, &*arg.pat);\n     }\n }\n@@ -1098,9 +1095,9 @@ fn link_pattern<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                           mc: mc::MemCategorizationContext<FnCtxt<'a, 'tcx>>,\n                           discr_cmt: mc::cmt<'tcx>,\n                           root_pat: &ast::Pat) {\n-    debug!(\"link_pattern(discr_cmt={}, root_pat={})\",\n-           discr_cmt.repr(rcx.tcx()),\n-           root_pat.repr(rcx.tcx()));\n+    debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\",\n+           discr_cmt,\n+           root_pat);\n     let _ = mc.cat_pattern(discr_cmt, root_pat, |mc, sub_cmt, sub_pat| {\n             match sub_pat.node {\n                 // `ref x` pattern\n@@ -1136,7 +1133,7 @@ fn link_autoref(rcx: &Rcx,\n     debug!(\"link_autoref(autoref={:?})\", autoref);\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n-    debug!(\"expr_cmt={}\", expr_cmt.repr(rcx.tcx()));\n+    debug!(\"expr_cmt={:?}\", expr_cmt);\n \n     match *autoref {\n         ty::AutoPtr(r, m) => {\n@@ -1156,9 +1153,8 @@ fn link_autoref(rcx: &Rcx,\n fn link_by_ref(rcx: &Rcx,\n                expr: &ast::Expr,\n                callee_scope: CodeExtent) {\n-    let tcx = rcx.tcx();\n-    debug!(\"link_by_ref(expr={}, callee_scope={:?})\",\n-           expr.repr(tcx), callee_scope);\n+    debug!(\"link_by_ref(expr={:?}, callee_scope={:?})\",\n+           expr, callee_scope);\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     let expr_cmt = ignore_err!(mc.cat_expr(expr));\n     let borrow_region = ty::ReScope(callee_scope);\n@@ -1172,13 +1168,13 @@ fn link_region_from_node_type<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                         id: ast::NodeId,\n                                         mutbl: ast::Mutability,\n                                         cmt_borrowed: mc::cmt<'tcx>) {\n-    debug!(\"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={})\",\n-           id, mutbl, cmt_borrowed.repr(rcx.tcx()));\n+    debug!(\"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\",\n+           id, mutbl, cmt_borrowed);\n \n     let rptr_ty = rcx.resolve_node_type(id);\n     if !ty::type_is_error(rptr_ty) {\n         let tcx = rcx.fcx.ccx.tcx;\n-        debug!(\"rptr_ty={}\", ty_to_string(tcx, rptr_ty));\n+        debug!(\"rptr_ty={}\",  rptr_ty);\n         let r = ty::ty_region(tcx, span, rptr_ty);\n         link_region(rcx, span, &r, ty::BorrowKind::from_mutbl(mutbl),\n                     cmt_borrowed);\n@@ -1197,10 +1193,10 @@ fn link_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     let mut borrow_kind = borrow_kind;\n \n     loop {\n-        debug!(\"link_region(borrow_region={}, borrow_kind={}, borrow_cmt={})\",\n-               borrow_region.repr(rcx.tcx()),\n-               borrow_kind.repr(rcx.tcx()),\n-               borrow_cmt.repr(rcx.tcx()));\n+        debug!(\"link_region(borrow_region={:?}, borrow_kind={:?}, borrow_cmt={:?})\",\n+               borrow_region,\n+               borrow_kind,\n+               borrow_cmt);\n         match borrow_cmt.cat.clone() {\n             mc::cat_deref(ref_cmt, _,\n                           mc::Implicit(ref_kind, ref_region)) |\n@@ -1310,8 +1306,8 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                 _ => {\n                     rcx.tcx().sess.span_bug(\n                         span,\n-                        &format!(\"Illegal upvar id: {}\",\n-                                upvar_id.repr(rcx.tcx())));\n+                        &format!(\"Illegal upvar id: {:?}\",\n+                                upvar_id));\n                 }\n             }\n         }\n@@ -1326,9 +1322,9 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n         }\n     };\n \n-    debug!(\"link_reborrowed_region: {} <= {}\",\n-           borrow_region.repr(rcx.tcx()),\n-           ref_region.repr(rcx.tcx()));\n+    debug!(\"link_reborrowed_region: {:?} <= {:?}\",\n+           borrow_region,\n+           ref_region);\n     rcx.fcx.mk_subr(cause, *borrow_region, ref_region);\n \n     // If we end up needing to recurse and establish a region link\n@@ -1401,14 +1397,14 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                ty: Ty<'tcx>,\n                                region: ty::Region)\n {\n-    debug!(\"type_must_outlive(ty={}, region={})\",\n-           ty.repr(rcx.tcx()),\n-           region.repr(rcx.tcx()));\n+    debug!(\"type_must_outlive(ty={:?}, region={:?})\",\n+           ty,\n+           region);\n \n     let implications = implicator::implications(rcx.fcx.infcx(), rcx.fcx, rcx.body_id,\n                                                 ty, region, origin.span());\n     for implication in implications {\n-        debug!(\"implication: {}\", implication.repr(rcx.tcx()));\n+        debug!(\"implication: {:?}\", implication);\n         match implication {\n             implicator::Implication::RegionSubRegion(None, r_a, r_b) => {\n                 rcx.fcx.mk_subr(origin.clone(), r_a, r_b);\n@@ -1443,8 +1439,8 @@ fn closure_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                   region: ty::Region,\n                                   def_id: ast::DefId,\n                                   substs: &'tcx Substs<'tcx>) {\n-    debug!(\"closure_must_outlive(region={}, def_id={}, substs={})\",\n-           region.repr(rcx.tcx()), def_id.repr(rcx.tcx()), substs.repr(rcx.tcx()));\n+    debug!(\"closure_must_outlive(region={:?}, def_id={:?}, substs={:?})\",\n+           region, def_id, substs);\n \n     let upvars = rcx.fcx.closure_upvars(def_id, substs).unwrap();\n     for upvar in upvars {\n@@ -1461,9 +1457,9 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                   generic: &GenericKind<'tcx>) {\n     let param_env = &rcx.fcx.inh.param_env;\n \n-    debug!(\"param_must_outlive(region={}, generic={})\",\n-           region.repr(rcx.tcx()),\n-           generic.repr(rcx.tcx()));\n+    debug!(\"param_must_outlive(region={:?}, generic={:?})\",\n+           region,\n+           generic);\n \n     // To start, collect bounds from user:\n     let mut param_bounds =\n@@ -1496,9 +1492,9 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     // well-formed, then, A must be lower-generic by `'a`, but we\n     // don't know that this holds from first principles.\n     for &(ref r, ref p) in &rcx.region_bound_pairs {\n-        debug!(\"generic={} p={}\",\n-               generic.repr(rcx.tcx()),\n-               p.repr(rcx.tcx()));\n+        debug!(\"generic={:?} p={:?}\",\n+               generic,\n+               p);\n         if generic == p {\n             param_bounds.push(*r);\n         }\n@@ -1521,8 +1517,8 @@ fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n     let tcx = fcx.tcx();\n     let infcx = fcx.infcx();\n \n-    debug!(\"projection_bounds(projection_ty={})\",\n-           projection_ty.repr(tcx));\n+    debug!(\"projection_bounds(projection_ty={:?})\",\n+           projection_ty);\n \n     let ty = ty::mk_projection(tcx, projection_ty.trait_ref.clone(), projection_ty.item_name);\n \n@@ -1546,16 +1542,16 @@ fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n                 _ => { return None; }\n             };\n \n-            debug!(\"projection_bounds: outlives={} (1)\",\n-                   outlives.repr(tcx));\n+            debug!(\"projection_bounds: outlives={:?} (1)\",\n+                   outlives);\n \n             // apply the substitutions (and normalize any projected types)\n             let outlives = fcx.instantiate_type_scheme(span,\n                                                        projection_ty.trait_ref.substs,\n                                                        &outlives);\n \n-            debug!(\"projection_bounds: outlives={} (2)\",\n-                   outlives.repr(tcx));\n+            debug!(\"projection_bounds: outlives={:?} (2)\",\n+                   outlives);\n \n             let region_result = infcx.commit_if_ok(|_| {\n                 let (outlives, _) =\n@@ -1564,8 +1560,8 @@ fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n                         infer::AssocTypeProjection(projection_ty.item_name),\n                         &outlives);\n \n-                debug!(\"projection_bounds: outlives={} (3)\",\n-                       outlives.repr(tcx));\n+                debug!(\"projection_bounds: outlives={:?} (3)\",\n+                       outlives);\n \n                 // check whether this predicate applies to our current projection\n                 match infer::mk_eqty(infcx, false, infer::Misc(span), ty, outlives.0) {\n@@ -1574,8 +1570,8 @@ fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n                 }\n             });\n \n-            debug!(\"projection_bounds: region_result={}\",\n-                   region_result.repr(tcx));\n+            debug!(\"projection_bounds: region_result={:?}\",\n+                   region_result);\n \n             region_result.ok()\n         })"}, {"sha": "99e6309918c9728860f23de91cd4efafc41b10ab", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -51,7 +51,6 @@ use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::visit::{self, Visitor};\n-use util::ppaux::Repr;\n \n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS\n@@ -133,8 +132,8 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n         if !self.fcx.inh.closure_kinds.borrow().contains_key(&closure_def_id) {\n             self.closures_with_inferred_kinds.insert(expr.id);\n             self.fcx.inh.closure_kinds.borrow_mut().insert(closure_def_id, ty::FnClosureKind);\n-            debug!(\"check_closure: adding closure_id={} to closures_with_inferred_kinds\",\n-                   closure_def_id.repr(self.tcx()));\n+            debug!(\"check_closure: adding closure_id={:?} to closures_with_inferred_kinds\",\n+                   closure_def_id);\n         }\n \n         ty::with_freevars(self.tcx(), expr.id, |freevars| {\n@@ -178,10 +177,6 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         AdjustBorrowKind { fcx: fcx, closures_with_inferred_kinds: closures_with_inferred_kinds }\n     }\n \n-    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n-        self.fcx.tcx()\n-    }\n-\n     fn analyze_closure(&mut self, id: ast::NodeId, decl: &ast::FnDecl, body: &ast::Block) {\n         /*!\n          * Analysis starting point.\n@@ -245,8 +240,8 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n                                             cmt: mc::cmt<'tcx>,\n                                             mode: euv::ConsumeMode)\n     {\n-        debug!(\"adjust_upvar_borrow_kind_for_consume(cmt={}, mode={:?})\",\n-               cmt.repr(self.tcx()), mode);\n+        debug!(\"adjust_upvar_borrow_kind_for_consume(cmt={:?}, mode={:?})\",\n+               cmt, mode);\n \n         // we only care about moves\n         match mode {\n@@ -258,8 +253,8 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         // for that to be legal, the upvar would have to be borrowed\n         // by value instead\n         let guarantor = cmt.guarantor();\n-        debug!(\"adjust_upvar_borrow_kind_for_consume: guarantor={}\",\n-               guarantor.repr(self.tcx()));\n+        debug!(\"adjust_upvar_borrow_kind_for_consume: guarantor={:?}\",\n+               guarantor);\n         match guarantor.cat {\n             mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n             mc::cat_deref(_, _, mc::Implicit(..)) => {\n@@ -296,8 +291,8 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n     /// to). If cmt contains any by-ref upvars, this implies that\n     /// those upvars must be borrowed using an `&mut` borrow.\n     fn adjust_upvar_borrow_kind_for_mut(&mut self, cmt: mc::cmt<'tcx>) {\n-        debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={})\",\n-               cmt.repr(self.tcx()));\n+        debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={:?})\",\n+               cmt);\n \n         match cmt.cat.clone() {\n             mc::cat_deref(base, _, mc::Unique) |\n@@ -330,8 +325,8 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n     }\n \n     fn adjust_upvar_borrow_kind_for_unique(&self, cmt: mc::cmt<'tcx>) {\n-        debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={})\",\n-               cmt.repr(self.tcx()));\n+        debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={:?})\",\n+               cmt);\n \n         match cmt.cat.clone() {\n             mc::cat_deref(base, _, mc::Unique) |\n@@ -498,7 +493,7 @@ impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx> {\n                cmt: mc::cmt<'tcx>,\n                mode: euv::ConsumeMode)\n     {\n-        debug!(\"consume(cmt={},mode={:?})\", cmt.repr(self.tcx()), mode);\n+        debug!(\"consume(cmt={:?},mode={:?})\", cmt, mode);\n         self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n     }\n \n@@ -513,7 +508,7 @@ impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx> {\n                    cmt: mc::cmt<'tcx>,\n                    mode: euv::ConsumeMode)\n     {\n-        debug!(\"consume_pat(cmt={},mode={:?})\", cmt.repr(self.tcx()), mode);\n+        debug!(\"consume_pat(cmt={:?},mode={:?})\", cmt, mode);\n         self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n     }\n \n@@ -525,8 +520,8 @@ impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx> {\n               bk: ty::BorrowKind,\n               _loan_cause: euv::LoanCause)\n     {\n-        debug!(\"borrow(borrow_id={}, cmt={}, bk={:?})\",\n-               borrow_id, cmt.repr(self.tcx()), bk);\n+        debug!(\"borrow(borrow_id={}, cmt={:?}, bk={:?})\",\n+               borrow_id, cmt, bk);\n \n         match bk {\n             ty::ImmBorrow => { }\n@@ -550,8 +545,8 @@ impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx> {\n               assignee_cmt: mc::cmt<'tcx>,\n               _mode: euv::MutateMode)\n     {\n-        debug!(\"mutate(assignee_cmt={})\",\n-               assignee_cmt.repr(self.tcx()));\n+        debug!(\"mutate(assignee_cmt={:?})\",\n+               assignee_cmt);\n \n         self.adjust_upvar_borrow_kind_for_mut(assignee_cmt);\n     }"}, {"sha": "c048845892c4b7f1d364958bdc65526647da6d35", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -18,7 +18,6 @@ use middle::traits;\n use middle::ty::{self, Ty};\n use middle::ty::liberate_late_bound_regions;\n use middle::ty_fold::{TypeFolder, TypeFoldable, super_fold_ty};\n-use util::ppaux::{Repr, UserString};\n \n use std::collections::HashSet;\n use syntax::ast;\n@@ -350,15 +349,15 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                          param_name: ast::Name)\n     {\n         span_err!(self.tcx().sess, span, E0392,\n-            \"parameter `{}` is never used\", param_name.user_string(self.tcx()));\n+            \"parameter `{}` is never used\", param_name);\n \n         let suggested_marker_id = self.tcx().lang_items.phantom_data();\n         match suggested_marker_id {\n             Some(def_id) => {\n                 self.tcx().sess.fileline_help(\n                     span,\n                     &format!(\"consider removing `{}` or using a marker such as `{}`\",\n-                             param_name.user_string(self.tcx()),\n+                             param_name,\n                              ty::item_path_str(self.tcx(), def_id)));\n             }\n             None => {\n@@ -395,7 +394,7 @@ fn reject_non_type_param_bounds<'tcx>(tcx: &ty::ctxt<'tcx>,\n             \"cannot bound type `{}`, where clause \\\n                 bounds may only be attached to types involving \\\n                 type parameters\",\n-                bounded_ty.repr(tcx))\n+                bounded_ty)\n     }\n \n     fn is_ty_param(ty: ty::Ty) -> bool {\n@@ -536,23 +535,23 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n     }\n \n     fn fold_binder<T>(&mut self, binder: &ty::Binder<T>) -> ty::Binder<T>\n-        where T : TypeFoldable<'tcx> + Repr<'tcx>\n+        where T : TypeFoldable<'tcx>\n     {\n         self.binding_count += 1;\n         let value = liberate_late_bound_regions(\n             self.fcx.tcx(),\n             region::DestructionScopeData::new(self.scope),\n             binder);\n-        debug!(\"BoundsChecker::fold_binder: late-bound regions replaced: {} at scope: {:?}\",\n-               value.repr(self.tcx()), self.scope);\n+        debug!(\"BoundsChecker::fold_binder: late-bound regions replaced: {:?} at scope: {:?}\",\n+               value, self.scope);\n         let value = value.fold_with(self);\n         self.binding_count -= 1;\n         ty::Binder(value)\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        debug!(\"BoundsChecker t={}\",\n-               t.repr(self.tcx()));\n+        debug!(\"BoundsChecker t={:?}\",\n+               t);\n \n         match self.cache {\n             Some(ref mut cache) => {"}, {"sha": "05cc3077fc9fbb6d706fa2174d66cb8a5bdda35a", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -21,7 +21,6 @@ use middle::ty_fold::{TypeFolder,TypeFoldable};\n use middle::infer;\n use write_substs_to_tcx;\n use write_ty_to_tcx;\n-use util::ppaux::Repr;\n \n use std::cell::Cell;\n \n@@ -169,10 +168,10 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n \n         self.visit_node_id(ResolvingPattern(p.span), p.id);\n \n-        debug!(\"Type for pattern binding {} (id {}) resolved to {}\",\n+        debug!(\"Type for pattern binding {} (id {}) resolved to {:?}\",\n                pat_to_string(p),\n                p.id,\n-               ty::node_id_to_type(self.tcx(), p.id).repr(self.tcx()));\n+               ty::node_id_to_type(self.tcx(), p.id));\n \n         visit::walk_pat(self, p);\n     }\n@@ -215,9 +214,9 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                         ty::UpvarBorrow { kind: upvar_borrow.kind, region: r })\n                 }\n             };\n-            debug!(\"Upvar capture for {} resolved to {}\",\n-                   upvar_id.repr(self.tcx()),\n-                   new_upvar_capture.repr(self.tcx()));\n+            debug!(\"Upvar capture for {:?} resolved to {:?}\",\n+                   upvar_id,\n+                   new_upvar_capture);\n             self.fcx.tcx().upvar_capture_map.borrow_mut().insert(*upvar_id, new_upvar_capture);\n         }\n     }\n@@ -245,7 +244,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         let n_ty = self.fcx.node_ty(id);\n         let n_ty = self.resolve(&n_ty, reason);\n         write_ty_to_tcx(self.tcx(), id, n_ty);\n-        debug!(\"Node {} has type {}\", id, n_ty.repr(self.tcx()));\n+        debug!(\"Node {} has type {:?}\", id, n_ty);\n \n         // Resolve any substitutions\n         self.fcx.opt_node_ty_substs(id, |item_substs| {\n@@ -294,9 +293,9 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         // Resolve any method map entry\n         match self.fcx.inh.method_map.borrow_mut().remove(&method_call) {\n             Some(method) => {\n-                debug!(\"writeback::resolve_method_map_entry(call={:?}, entry={})\",\n+                debug!(\"writeback::resolve_method_map_entry(call={:?}, entry={:?})\",\n                        method_call,\n-                       method.repr(self.tcx()));\n+                       method);\n                 let new_method = MethodCallee {\n                     origin: self.resolve(&method.origin, reason),\n                     ty: self.resolve(&method.ty, reason),\n@@ -427,8 +426,8 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n         match self.infcx.fully_resolve(&t) {\n             Ok(t) => t,\n             Err(e) => {\n-                debug!(\"Resolver::fold_ty: input type `{}` not fully resolvable\",\n-                       t.repr(self.tcx));\n+                debug!(\"Resolver::fold_ty: input type `{:?}` not fully resolvable\",\n+                       t);\n                 self.report_error(e);\n                 self.tcx().types.err\n             }"}, {"sha": "b66c76048c639db3b0e7531602e3a6396f59c8cb", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -44,7 +44,6 @@ use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::visit;\n use util::nodemap::{DefIdMap, FnvHashMap};\n-use util::ppaux::Repr;\n \n mod orphan;\n mod overlap;\n@@ -82,7 +81,7 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n             inference_context.tcx.sess.span_bug(\n                 span,\n                 &format!(\"coherence encountered unexpected type searching for base type: {}\",\n-                        ty.repr(inference_context.tcx)));\n+                         ty));\n         }\n     }\n }\n@@ -149,9 +148,9 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n         if let Some(trait_ref) = ty::impl_trait_ref(self.crate_context.tcx,\n                                                     impl_did) {\n-            debug!(\"(checking implementation) adding impl for trait '{}', item '{}'\",\n-                   trait_ref.repr(self.crate_context.tcx),\n-                   token::get_ident(item.ident));\n+            debug!(\"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n+                   trait_ref,\n+                   item.ident);\n \n             enforce_trait_manually_implementable(self.crate_context.tcx,\n                                                  item.span,\n@@ -179,8 +178,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             trait_ref: &ty::TraitRef<'tcx>,\n             all_impl_items: &mut Vec<ImplOrTraitItemId>) {\n         let tcx = self.crate_context.tcx;\n-        debug!(\"instantiate_default_methods(impl_id={:?}, trait_ref={})\",\n-               impl_id, trait_ref.repr(tcx));\n+        debug!(\"instantiate_default_methods(impl_id={:?}, trait_ref={:?})\",\n+               impl_id, trait_ref);\n \n         let impl_type_scheme = ty::lookup_item_type(tcx, impl_id);\n \n@@ -190,7 +189,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             let new_id = tcx.sess.next_node_id();\n             let new_did = local_def(new_id);\n \n-            debug!(\"new_did={:?} trait_method={}\", new_did, trait_method.repr(tcx));\n+            debug!(\"new_did={:?} trait_method={:?}\", new_did, trait_method);\n \n             // Create substitutions for the various trait parameters.\n             let new_method_ty =\n@@ -203,7 +202,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     &**trait_method,\n                     Some(trait_method.def_id)));\n \n-            debug!(\"new_method_ty={}\", new_method_ty.repr(tcx));\n+            debug!(\"new_method_ty={:?}\", new_method_ty);\n             all_impl_items.push(MethodTraitItemId(new_did));\n \n             // construct the polytype for the method based on the\n@@ -214,7 +213,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 ty: ty::mk_bare_fn(tcx, Some(new_did),\n                                    tcx.mk_bare_fn(new_method_ty.fty.clone()))\n             };\n-            debug!(\"new_polytype={}\", new_polytype.repr(tcx));\n+            debug!(\"new_polytype={:?}\", new_polytype);\n \n             tcx.tcache.borrow_mut().insert(new_did, new_polytype);\n             tcx.predicates.borrow_mut().insert(new_did, new_method_ty.predicates.clone());\n@@ -360,8 +359,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         let copy_trait = ty::lookup_trait_def(tcx, copy_trait);\n \n         copy_trait.for_each_impl(tcx, |impl_did| {\n-            debug!(\"check_implementations_of_copy: impl_did={}\",\n-                   impl_did.repr(tcx));\n+            debug!(\"check_implementations_of_copy: impl_did={:?}\",\n+                   impl_did);\n \n             if impl_did.krate != ast::LOCAL_CRATE {\n                 debug!(\"check_implementations_of_copy(): impl not in this \\\n@@ -370,16 +369,16 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             }\n \n             let self_type = ty::lookup_item_type(tcx, impl_did);\n-            debug!(\"check_implementations_of_copy: self_type={} (bound)\",\n-                   self_type.repr(tcx));\n+            debug!(\"check_implementations_of_copy: self_type={:?} (bound)\",\n+                   self_type);\n \n             let span = tcx.map.span(impl_did.node);\n             let param_env = ParameterEnvironment::for_item(tcx, impl_did.node);\n             let self_type = self_type.ty.subst(tcx, &param_env.free_substs);\n             assert!(!self_type.has_escaping_regions());\n \n-            debug!(\"check_implementations_of_copy: self_type={} (free)\",\n-                   self_type.repr(tcx));\n+            debug!(\"check_implementations_of_copy: self_type={:?} (free)\",\n+                   self_type);\n \n             match ty::can_type_implement_copy(&param_env, span, self_type) {\n                 Ok(()) => {}\n@@ -429,8 +428,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         let trait_def = ty::lookup_trait_def(tcx, coerce_unsized_trait);\n \n         trait_def.for_each_impl(tcx, |impl_did| {\n-            debug!(\"check_implementations_of_coerce_unsized: impl_did={}\",\n-                   impl_did.repr(tcx));\n+            debug!(\"check_implementations_of_coerce_unsized: impl_did={:?}\",\n+                   impl_did);\n \n             if impl_did.krate != ast::LOCAL_CRATE {\n                 debug!(\"check_implementations_of_coerce_unsized(): impl not \\\n@@ -442,17 +441,17 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             let trait_ref = ty::impl_trait_ref(self.crate_context.tcx,\n                                                impl_did).unwrap();\n             let target = *trait_ref.substs.types.get(subst::TypeSpace, 0);\n-            debug!(\"check_implementations_of_coerce_unsized: {} -> {} (bound)\",\n-                   source.repr(tcx), target.repr(tcx));\n+            debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (bound)\",\n+                   source, target);\n \n             let span = tcx.map.span(impl_did.node);\n             let param_env = ParameterEnvironment::for_item(tcx, impl_did.node);\n             let source = source.subst(tcx, &param_env.free_substs);\n             let target = target.subst(tcx, &param_env.free_substs);\n             assert!(!source.has_escaping_regions());\n \n-            debug!(\"check_implementations_of_coerce_unsized: {} -> {} (free)\",\n-                   source.repr(tcx), target.repr(tcx));\n+            debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (free)\",\n+                   source, target);\n \n             let infcx = new_infer_ctxt(tcx);\n \n@@ -518,10 +517,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                                 if name == token::special_names::unnamed_field {\n                                                     i.to_string()\n                                                 } else {\n-                                                    token::get_name(name).to_string()\n-                                                },\n-                                                a.repr(tcx),\n-                                                b.repr(tcx))\n+                                                    name.to_string()\n+                                                }, a, b)\n                                    }).collect::<Vec<_>>().connect(\", \"));\n                         return;\n                     }\n@@ -597,8 +594,8 @@ fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n {\n     let combined_substs = ty::make_substs_for_receiver_types(tcx, trait_ref, method);\n \n-    debug!(\"subst_receiver_types_in_method_ty: combined_substs={}\",\n-           combined_substs.repr(tcx));\n+    debug!(\"subst_receiver_types_in_method_ty: combined_substs={:?}\",\n+           combined_substs);\n \n     let method_predicates = method.predicates.subst(tcx, &combined_substs);\n     let mut method_generics = method.generics.subst(tcx, &combined_substs);\n@@ -614,13 +611,13 @@ fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n             impl_type_scheme.generics.regions.get_slice(space).to_vec());\n     }\n \n-    debug!(\"subst_receiver_types_in_method_ty: method_generics={}\",\n-           method_generics.repr(tcx));\n+    debug!(\"subst_receiver_types_in_method_ty: method_generics={:?}\",\n+           method_generics);\n \n     let method_fty = method.fty.subst(tcx, &combined_substs);\n \n-    debug!(\"subst_receiver_types_in_method_ty: method_ty={}\",\n-           method.fty.repr(tcx));\n+    debug!(\"subst_receiver_types_in_method_ty: method_ty={:?}\",\n+           method.fty);\n \n     ty::Method::new(\n         method.name,"}, {"sha": "8376b92da3dea667c3926ad14c169d0b7de6af51", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -18,7 +18,6 @@ use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::visit;\n-use util::ppaux::{Repr, UserString};\n \n pub fn check(tcx: &ty::ctxt) {\n     let mut orphan = OrphanChecker { tcx: tcx };\n@@ -66,7 +65,8 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n             ast::ItemImpl(_, _, _, None, _, _) => {\n                 // For inherent impls, self type must be a nominal type\n                 // defined in this crate.\n-                debug!(\"coherence2::orphan check: inherent impl {}\", item.repr(self.tcx));\n+                debug!(\"coherence2::orphan check: inherent impl {}\",\n+                       self.tcx.map.node_to_string(item.id));\n                 let self_ty = ty::lookup_item_type(self.tcx, def_id).ty;\n                 match self_ty.sty {\n                     ty::TyEnum(def_id, _) |\n@@ -208,7 +208,8 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n             }\n             ast::ItemImpl(_, _, _, Some(_), _, _) => {\n                 // \"Trait\" impl\n-                debug!(\"coherence2::orphan check: trait impl {}\", item.repr(self.tcx));\n+                debug!(\"coherence2::orphan check: trait impl {}\",\n+                       self.tcx.map.node_to_string(item.id));\n                 let trait_ref = ty::impl_trait_ref(self.tcx, def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n                 match traits::orphan_check(self.tcx, def_id) {\n@@ -227,7 +228,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                                 \"type parameter `{}` must be used as the type parameter for \\\n                                  some local type (e.g. `MyStruct<T>`); only traits defined in \\\n                                  the current crate can be implemented for a type parameter\",\n-                                param_ty.user_string(self.tcx));\n+                                param_ty);\n                         return;\n                     }\n                 }\n@@ -265,9 +266,9 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 // This final impl is legal according to the orpan\n                 // rules, but it invalidates the reasoning from\n                 // `two_foos` above.\n-                debug!(\"trait_ref={} trait_def_id={} trait_has_default_impl={}\",\n-                       trait_ref.repr(self.tcx),\n-                       trait_def_id.repr(self.tcx),\n+                debug!(\"trait_ref={:?} trait_def_id={:?} trait_has_default_impl={}\",\n+                       trait_ref,\n+                       trait_def_id,\n                        ty::trait_has_default_impl(self.tcx, trait_def_id));\n                 if\n                     ty::trait_has_default_impl(self.tcx, trait_def_id) &&\n@@ -305,7 +306,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                                  can only be implemented for a struct/enum type, \\\n                                  not `{}`\",\n                                 ty::item_path_str(self.tcx, trait_def_id),\n-                                self_ty.user_string(self.tcx)))\n+                                self_ty))\n                         }\n                     };\n \n@@ -329,7 +330,8 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n             }\n             ast::ItemDefaultImpl(..) => {\n                 // \"Trait\" impl\n-                debug!(\"coherence2::orphan check: default trait impl {}\", item.repr(self.tcx));\n+                debug!(\"coherence2::orphan check: default trait impl {}\",\n+                       self.tcx.map.node_to_string(item.id));\n                 let trait_ref = ty::impl_trait_ref(self.tcx, def_id).unwrap();\n                 if trait_ref.def_id.krate != ast::LOCAL_CRATE {\n                     span_err!(self.tcx.sess, item.span, E0318,"}, {"sha": "0e8067e7181bd4d821ce364639c46710c384b2b0", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -21,7 +21,6 @@ use syntax::ast_util;\n use syntax::visit;\n use syntax::codemap::Span;\n use util::nodemap::DefIdMap;\n-use util::ppaux::{Repr, UserString};\n \n pub fn check(tcx: &ty::ctxt) {\n     let mut overlap = OverlapChecker { tcx: tcx, default_impls: DefIdMap() };\n@@ -61,8 +60,8 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n     fn check_for_overlapping_impls_of_trait(&self,\n                                             trait_def: &'tcx ty::TraitDef<'tcx>)\n     {\n-        debug!(\"check_for_overlapping_impls_of_trait(trait_def={})\",\n-               trait_def.repr(self.tcx));\n+        debug!(\"check_for_overlapping_impls_of_trait(trait_def={:?})\",\n+               trait_def);\n \n         // We should already know all impls of this trait, so these\n         // borrows are safe.\n@@ -131,10 +130,10 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         if let Some((impl1_def_id, impl2_def_id)) = self.order_impls(\n             impl1_def_id, impl2_def_id)\n         {\n-            debug!(\"check_if_impls_overlap({}, {}, {})\",\n-                   trait_def_id.repr(self.tcx),\n-                   impl1_def_id.repr(self.tcx),\n-                   impl2_def_id.repr(self.tcx));\n+            debug!(\"check_if_impls_overlap({:?}, {:?}, {:?})\",\n+                   trait_def_id,\n+                   impl1_def_id,\n+                   impl2_def_id);\n \n             let infcx = infer::new_infer_ctxt(self.tcx);\n             if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n@@ -217,7 +216,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                                 span_err!(self.tcx.sess, item.span, E0371,\n                                           \"the object type `{}` automatically \\\n                                            implements the trait `{}`\",\n-                                          trait_ref.self_ty().user_string(self.tcx),\n+                                          trait_ref.self_ty(),\n                                           ty::item_path_str(self.tcx, trait_def_id));\n                             }\n                         }"}, {"sha": "fa39e9d0491f9566136934475229e627fdd18897", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -16,7 +16,6 @@ use syntax::ast::{Item, ItemImpl};\n use syntax::ast;\n use syntax::ast_util;\n use syntax::visit;\n-use util::ppaux::UserString;\n \n pub fn check(tcx: &ty::ctxt) {\n     let mut orphan = UnsafetyChecker { tcx: tcx };\n@@ -55,14 +54,14 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n                     (ast::Unsafety::Normal, ast::Unsafety::Unsafe, _) => {\n                         span_err!(self.tcx.sess, item.span, E0199,\n                                   \"implementing the trait `{}` is not unsafe\",\n-                                  trait_ref.user_string(self.tcx));\n+                                  trait_ref);\n                     }\n \n                     (ast::Unsafety::Unsafe,\n                      ast::Unsafety::Normal, ast::ImplPolarity::Positive) => {\n                         span_err!(self.tcx.sess, item.span, E0200,\n                                   \"the trait `{}` requires an `unsafe impl` declaration\",\n-                                  trait_ref.user_string(self.tcx));\n+                                  trait_ref);\n                     }\n \n                     (ast::Unsafety::Unsafe,"}, {"sha": "13d2cf25e0665352106c7a28c26440666dc0c04f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -80,8 +80,6 @@ use rscope::*;\n use rustc::ast_map;\n use util::common::{ErrorReported, memoized};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n-use util::ppaux;\n-use util::ppaux::{Repr,UserString};\n use write_ty_to_tcx;\n \n use std::cell::{Cell, RefCell};\n@@ -256,7 +254,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n                 tcx.sess.note(\n                     &format!(\"the cycle begins when computing the bounds \\\n                               for type parameter `{}`...\",\n-                             def.name.user_string(tcx)));\n+                             def.name));\n             }\n         }\n \n@@ -278,7 +276,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n                     tcx.sess.note(\n                         &format!(\"...which then requires computing the bounds \\\n                                   for type parameter `{}`...\",\n-                                 def.name.user_string(tcx)));\n+                                 def.name));\n                 }\n             }\n         }\n@@ -301,7 +299,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n                 tcx.sess.note(\n                     &format!(\"...which then again requires computing the bounds \\\n                               for type parameter `{}`, completing the cycle.\",\n-                             def.name.user_string(tcx)));\n+                             def.name));\n             }\n         }\n     }\n@@ -318,7 +316,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n \n         let item = match tcx.map.get(trait_id.node) {\n             ast_map::NodeItem(item) => item,\n-            _ => tcx.sess.bug(&format!(\"get_trait_def({}): not an item\", trait_id.repr(tcx)))\n+            _ => tcx.sess.bug(&format!(\"get_trait_def({:?}): not an item\", trait_id))\n         };\n \n         trait_def_of_item(self, &*item)\n@@ -372,8 +370,8 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n                                trait_def_id: ast::DefId)\n                                -> Result<(), ErrorReported>\n     {\n-        debug!(\"ensure_super_predicates(trait_def_id={})\",\n-               trait_def_id.repr(self.tcx()));\n+        debug!(\"ensure_super_predicates(trait_def_id={:?})\",\n+               trait_def_id);\n \n         self.ccx.ensure_super_predicates(span, trait_def_id)\n     }\n@@ -635,8 +633,8 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let fty = ty::mk_bare_fn(ccx.tcx, Some(def_id),\n                              ccx.tcx.mk_bare_fn(ty_method.fty.clone()));\n-    debug!(\"method {} (id {}) has type {}\",\n-            ident.repr(ccx.tcx), id, fty.repr(ccx.tcx));\n+    debug!(\"method {} (id {}) has type {:?}\",\n+            ident, id, fty);\n     ccx.tcx.tcache.borrow_mut().insert(def_id,TypeScheme {\n         generics: ty_method.generics.clone(),\n         ty: fty\n@@ -645,8 +643,8 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     write_ty_to_tcx(ccx.tcx, id, fty);\n \n-    debug!(\"writing method type: def_id={:?} mty={}\",\n-            def_id, ty_method.repr(ccx.tcx));\n+    debug!(\"writing method type: def_id={:?} mty={:?}\",\n+            def_id, ty_method);\n \n     ccx.tcx.impl_or_trait_items.borrow_mut().insert(def_id,\n         ty::MethodTraitItem(Rc::new(ty_method)));\n@@ -743,10 +741,11 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n                                  rcvr_ty_predicates: &ty::GenericPredicates<'tcx>)\n     where I: Iterator<Item=(&'i ast::MethodSig, ast::NodeId, ast::Ident, ast::Visibility, Span)>\n {\n-    debug!(\"convert_methods(untransformed_rcvr_ty={}, rcvr_ty_generics={}, rcvr_ty_predicates={})\",\n-           untransformed_rcvr_ty.repr(ccx.tcx),\n-           rcvr_ty_generics.repr(ccx.tcx),\n-           rcvr_ty_predicates.repr(ccx.tcx));\n+    debug!(\"convert_methods(untransformed_rcvr_ty={:?}, rcvr_ty_generics={:?}, \\\n+                            rcvr_ty_predicates={:?})\",\n+           untransformed_rcvr_ty,\n+           rcvr_ty_generics,\n+           rcvr_ty_predicates);\n \n     let tcx = ccx.tcx;\n     let mut seen_methods = FnvHashSet();\n@@ -1140,7 +1139,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n {\n     let tcx = ccx.tcx;\n \n-    debug!(\"ensure_super_predicates_step(trait_def_id={})\", trait_def_id.repr(tcx));\n+    debug!(\"ensure_super_predicates_step(trait_def_id={:?})\", trait_def_id);\n \n     if trait_def_id.krate != ast::LOCAL_CRATE {\n         // If this trait comes from an external crate, then all of the\n@@ -1192,9 +1191,9 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n         let superpredicates = ty::GenericPredicates {\n             predicates: VecPerParamSpace::new(superbounds, vec![], vec![])\n         };\n-        debug!(\"superpredicates for trait {} = {}\",\n-               local_def(item.id).repr(ccx.tcx),\n-               superpredicates.repr(ccx.tcx));\n+        debug!(\"superpredicates for trait {:?} = {:?}\",\n+               local_def(item.id),\n+               superpredicates);\n \n         tcx.super_predicates.borrow_mut().insert(trait_def_id, superpredicates.clone());\n \n@@ -1207,7 +1206,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n                                          .map(|tr| tr.def_id())\n                                          .collect();\n \n-    debug!(\"ensure_super_predicates_step: def_ids={}\", def_ids.repr(tcx));\n+    debug!(\"ensure_super_predicates_step: def_ids={:?}\", def_ids);\n \n     def_ids\n }\n@@ -1533,9 +1532,8 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             scheme.generics.types.iter()\n                                  .map(|t| match t.object_lifetime_default {\n                                      Some(ty::ObjectLifetimeDefault::Specific(r)) =>\n-                                         r.user_string(tcx),\n-                                     d =>\n-                                         d.repr(ccx.tcx),\n+                                         r.to_string(),\n+                                     d => format!(\"{:?}\", d),\n                                  })\n                                  .collect::<Vec<String>>()\n                                  .connect(\",\");\n@@ -1621,8 +1619,8 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    ast_generics: &ast::Generics)\n                                    -> ty::Generics<'tcx>\n {\n-    debug!(\"ty_generics_for_trait(trait_id={}, substs={})\",\n-           local_def(trait_id).repr(ccx.tcx), substs.repr(ccx.tcx));\n+    debug!(\"ty_generics_for_trait(trait_id={:?}, substs={:?})\",\n+           local_def(trait_id), substs);\n \n     let mut generics = ty_generics_for_type_or_impl(ccx, ast_generics);\n \n@@ -2201,12 +2199,12 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n                 &ty::liberate_late_bound_regions(\n                     tcx, body_scope, &ty::Binder(base_type)));\n \n-        debug!(\"required_type={} required_type_free={} \\\n-                base_type={} base_type_free={}\",\n-               required_type.repr(tcx),\n-               required_type_free.repr(tcx),\n-               base_type.repr(tcx),\n-               base_type_free.repr(tcx));\n+        debug!(\"required_type={:?} required_type_free={:?} \\\n+                base_type={:?} base_type_free={:?}\",\n+               required_type,\n+               required_type_free,\n+               base_type,\n+               base_type_free);\n \n         let infcx = infer::new_infer_ctxt(tcx);\n         drop(::require_same_types(tcx,\n@@ -2217,7 +2215,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n                                   required_type_free,\n                                   || {\n                 format!(\"mismatched self type: expected `{}`\",\n-                        ppaux::ty_to_string(tcx, required_type))\n+                         required_type)\n         }));\n \n         // We could conceviably add more free-region relations here,\n@@ -2236,7 +2234,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n         scope: region::DestructionScopeData,\n         value: &T)\n         -> T\n-        where T : TypeFoldable<'tcx> + Repr<'tcx>\n+        where T : TypeFoldable<'tcx>\n     {\n         /*!\n          * Convert early-bound regions into free regions; normally this is done by\n@@ -2287,7 +2285,7 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      idx: index as u32,\n                                      name: ty_param.ident.name };\n         if !input_parameters.contains(&ctp::Parameter::Type(param_ty)) {\n-            report_unused_parameter(tcx, ty_param.span, \"type\", &param_ty.user_string(tcx));\n+            report_unused_parameter(tcx, ty_param.span, \"type\", &param_ty.to_string());\n         }\n     }\n \n@@ -2317,7 +2315,7 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n             !input_parameters.contains(&ctp::Parameter::Region(region))\n         {\n             report_unused_parameter(tcx, lifetime_def.lifetime.span,\n-                                    \"lifetime\", &region.name.user_string(tcx));\n+                                    \"lifetime\", &region.name.to_string());\n         }\n     }\n "}, {"sha": "8feecd15613119931074cec6ad343c157bedb675", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -109,8 +109,6 @@ use middle::ty::{self, Ty};\n use rustc::ast_map;\n use session::config;\n use util::common::time;\n-use util::ppaux::Repr;\n-use util::ppaux;\n \n use syntax::codemap::Span;\n use syntax::print::pprust::*;\n@@ -149,7 +147,7 @@ pub struct CrateCtxt<'a, 'tcx: 'a> {\n \n // Functions that write types into the node type table\n fn write_ty_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>, node_id: ast::NodeId, ty: Ty<'tcx>) {\n-    debug!(\"write_ty_to_tcx({}, {})\", node_id, ppaux::ty_to_string(tcx, ty));\n+    debug!(\"write_ty_to_tcx({}, {:?})\", node_id,  ty);\n     assert!(!ty::type_needs_infer(ty));\n     tcx.node_type_insert(node_id, ty);\n }\n@@ -158,9 +156,9 @@ fn write_substs_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                  node_id: ast::NodeId,\n                                  item_substs: ty::ItemSubsts<'tcx>) {\n     if !item_substs.is_noop() {\n-        debug!(\"write_substs_to_tcx({}, {})\",\n+        debug!(\"write_substs_to_tcx({}, {:?})\",\n                node_id,\n-               item_substs.repr(tcx));\n+               item_substs);\n \n         assert!(item_substs.substs.types.all(|t| !ty::type_needs_infer(*t)));\n \n@@ -200,11 +198,7 @@ fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n     match result {\n         Ok(_) => true,\n         Err(ref terr) => {\n-            span_err!(tcx.sess, span, E0211,\n-                              \"{}: {}\",\n-                                      msg(),\n-                                      ty::type_err_to_str(tcx,\n-                                                          terr));\n+            span_err!(tcx.sess, span, E0211, \"{}: {}\", msg(), terr);\n             ty::note_and_explain_type_err(tcx, terr, span);\n             false\n         }\n@@ -245,15 +239,13 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n             require_same_types(tcx, None, false, main_span, main_t, se_ty,\n                 || {\n                     format!(\"main function expects type: `{}`\",\n-                            ppaux::ty_to_string(ccx.tcx, se_ty))\n+                             se_ty)\n                 });\n         }\n         _ => {\n             tcx.sess.span_bug(main_span,\n-                              &format!(\"main has a non-function type: found \\\n-                                       `{}`\",\n-                                      ppaux::ty_to_string(tcx,\n-                                                       main_t)));\n+                              &format!(\"main has a non-function type: found `{}`\",\n+                                       main_t));\n         }\n     }\n }\n@@ -296,15 +288,14 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             require_same_types(tcx, None, false, start_span, start_t, se_ty,\n                 || {\n                     format!(\"start function expects type: `{}`\",\n-                            ppaux::ty_to_string(ccx.tcx, se_ty))\n+                             se_ty)\n                 });\n \n         }\n         _ => {\n             tcx.sess.span_bug(start_span,\n-                              &format!(\"start has a non-function type: found \\\n-                                       `{}`\",\n-                                      ppaux::ty_to_string(tcx, start_t)));\n+                              &format!(\"start has a non-function type: found `{}`\",\n+                                       start_t));\n         }\n     }\n }"}, {"sha": "1f4e13436512179f729084b162d2d566b81e2a33", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -278,7 +278,6 @@ use syntax::ast_util;\n use syntax::visit;\n use syntax::visit::Visitor;\n use util::nodemap::NodeMap;\n-use util::ppaux::Repr;\n \n pub fn infer_variance(tcx: &ty::ctxt) {\n     let krate = tcx.map.krate();\n@@ -518,7 +517,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        debug!(\"add_inferreds for item {}\", item.repr(self.tcx));\n+        debug!(\"add_inferreds for item {}\", self.tcx.map.node_to_string(item.id));\n \n         match item.node {\n             ast::ItemEnum(_, ref generics) |\n@@ -600,8 +599,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n         let did = ast_util::local_def(item.id);\n         let tcx = self.terms_cx.tcx;\n \n-        debug!(\"visit_item item={}\",\n-               item.repr(tcx));\n+        debug!(\"visit_item item={}\", tcx.map.node_to_string(item.id));\n \n         match item.node {\n             ast::ItemEnum(ref enum_definition, _) => {\n@@ -846,8 +844,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                       generics: &ty::Generics<'tcx>,\n                                       trait_ref: ty::TraitRef<'tcx>,\n                                       variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraints_from_trait_ref: trait_ref={} variance={:?}\",\n-               trait_ref.repr(self.tcx()),\n+        debug!(\"add_constraints_from_trait_ref: trait_ref={:?} variance={:?}\",\n+               trait_ref,\n                variance);\n \n         let trait_def = ty::lookup_trait_def(self.tcx(), trait_ref.def_id);\n@@ -868,8 +866,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                generics: &ty::Generics<'tcx>,\n                                ty: Ty<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraints_from_ty(ty={}, variance={:?})\",\n-               ty.repr(self.tcx()),\n+        debug!(\"add_constraints_from_ty(ty={:?}, variance={:?})\",\n+               ty,\n                variance);\n \n         match ty.sty {\n@@ -982,8 +980,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             ty::TyInfer(..) => {\n                 self.tcx().sess.bug(\n                     &format!(\"unexpected type encountered in \\\n-                            variance inference: {}\",\n-                            ty.repr(self.tcx())));\n+                              variance inference: {}\", ty));\n             }\n         }\n     }\n@@ -998,9 +995,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    region_param_defs: &[ty::RegionParameterDef],\n                                    substs: &subst::Substs<'tcx>,\n                                    variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraints_from_substs(def_id={}, substs={}, variance={:?})\",\n-               def_id.repr(self.tcx()),\n-               substs.repr(self.tcx()),\n+        debug!(\"add_constraints_from_substs(def_id={:?}, substs={:?}, variance={:?})\",\n+               def_id,\n+               substs,\n                variance);\n \n         for p in type_param_defs {\n@@ -1067,8 +1064,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.tcx()\n                     .sess\n                     .bug(&format!(\"unexpected region encountered in variance \\\n-                                  inference: {}\",\n-                                 region.repr(self.tcx())));\n+                                  inference: {:?}\",\n+                                 region));\n             }\n         }\n     }\n@@ -1195,17 +1192,16 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                 types: types,\n                 regions: regions\n             };\n-            debug!(\"item_id={} item_variances={}\",\n+            debug!(\"item_id={} item_variances={:?}\",\n                     item_id,\n-                    item_variances.repr(tcx));\n+                    item_variances);\n \n             let item_def_id = ast_util::local_def(item_id);\n \n             // For unit testing: check for a special \"rustc_variance\"\n             // attribute and report an error with various results if found.\n             if ty::has_attr(tcx, item_def_id, \"rustc_variance\") {\n-                let found = item_variances.repr(tcx);\n-                span_err!(tcx.sess, tcx.map.span(item_id), E0208, \"{}\", &found[..]);\n+                span_err!(tcx.sess, tcx.map.span(item_id), E0208, \"{:?}\", item_variances);\n             }\n \n             let newly_added = tcx.item_variance_map.borrow_mut()"}, {"sha": "d40a9522f23a9e44da1c9ff841559071af940be2", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -522,7 +522,7 @@ pub enum TyParamBound {\n impl TyParamBound {\n     fn maybe_sized(cx: &DocContext) -> TyParamBound {\n         use syntax::ast::TraitBoundModifier as TBM;\n-        let mut sized_bound = ty::BuiltinBound::BoundSized.clean(cx);\n+        let mut sized_bound = ty::BoundSized.clean(cx);\n         if let TyParamBound::TraitBound(_, ref mut tbm) = sized_bound {\n             *tbm = TBM::Maybe\n         };"}, {"sha": "13022fd43efb82446efc229ceb5f504d62227621", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 52, "deletions": 51, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -32,17 +32,17 @@ pub use rustc::session::config::Input;\n pub use rustc::session::search_paths::SearchPaths;\n \n /// Are we generating documentation (`Typed`) or tests (`NotTyped`)?\n-pub enum MaybeTyped<'tcx> {\n-    Typed(ty::ctxt<'tcx>),\n+pub enum MaybeTyped<'a, 'tcx: 'a> {\n+    Typed(&'a ty::ctxt<'tcx>),\n     NotTyped(session::Session)\n }\n \n pub type ExternalPaths = RefCell<Option<HashMap<ast::DefId,\n                                                 (Vec<String>, clean::TypeKind)>>>;\n \n-pub struct DocContext<'tcx> {\n+pub struct DocContext<'a, 'tcx: 'a> {\n     pub krate: &'tcx ast::Crate,\n-    pub maybe_typed: MaybeTyped<'tcx>,\n+    pub maybe_typed: MaybeTyped<'a, 'tcx>,\n     pub input: Input,\n     pub external_paths: ExternalPaths,\n     pub external_traits: RefCell<Option<HashMap<ast::DefId, clean::Trait>>>,\n@@ -52,17 +52,17 @@ pub struct DocContext<'tcx> {\n     pub deref_trait_did: Cell<Option<ast::DefId>>,\n }\n \n-impl<'tcx> DocContext<'tcx> {\n+impl<'b, 'tcx> DocContext<'b, 'tcx> {\n     pub fn sess<'a>(&'a self) -> &'a session::Session {\n         match self.maybe_typed {\n-            Typed(ref tcx) => &tcx.sess,\n+            Typed(tcx) => &tcx.sess,\n             NotTyped(ref sess) => sess\n         }\n     }\n \n     pub fn tcx_opt<'a>(&'a self) -> Option<&'a ty::ctxt<'tcx>> {\n         match self.maybe_typed {\n-            Typed(ref tcx) => Some(tcx),\n+            Typed(tcx) => Some(tcx),\n             NotTyped(_) => None\n         }\n     }\n@@ -133,48 +133,49 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     let arenas = ty::CtxtArenas::new();\n     let ast_map = driver::assign_node_ids_and_map(&sess, &mut forest);\n \n-    let ty::CrateAnalysis {\n-        exported_items, public_items, ty_cx, ..\n-    } = driver::phase_3_run_analysis_passes(sess,\n-                                            ast_map,\n-                                            &arenas,\n-                                            name,\n-                                            resolve::MakeGlobMap::No);\n-\n-    let ctxt = DocContext {\n-        krate: ty_cx.map.krate(),\n-        maybe_typed: Typed(ty_cx),\n-        input: input,\n-        external_traits: RefCell::new(Some(HashMap::new())),\n-        external_typarams: RefCell::new(Some(HashMap::new())),\n-        external_paths: RefCell::new(Some(HashMap::new())),\n-        inlined: RefCell::new(Some(HashSet::new())),\n-        populated_crate_impls: RefCell::new(HashSet::new()),\n-        deref_trait_did: Cell::new(None),\n-    };\n-    debug!(\"crate: {:?}\", ctxt.krate);\n-\n-    let mut analysis = CrateAnalysis {\n-        exported_items: exported_items,\n-        public_items: public_items,\n-        external_paths: RefCell::new(None),\n-        external_typarams: RefCell::new(None),\n-        inlined: RefCell::new(None),\n-        deref_trait_did: None,\n-    };\n-\n-    let krate = {\n-        let mut v = RustdocVisitor::new(&ctxt, Some(&analysis));\n-        v.visit(ctxt.krate);\n-        v.clean(&ctxt)\n-    };\n-\n-    let external_paths = ctxt.external_paths.borrow_mut().take();\n-    *analysis.external_paths.borrow_mut() = external_paths;\n-    let map = ctxt.external_typarams.borrow_mut().take();\n-    *analysis.external_typarams.borrow_mut() = map;\n-    let map = ctxt.inlined.borrow_mut().take();\n-    *analysis.inlined.borrow_mut() = map;\n-    analysis.deref_trait_did = ctxt.deref_trait_did.get();\n-    (krate, analysis)\n+    driver::phase_3_run_analysis_passes(sess,\n+                                        ast_map,\n+                                        &arenas,\n+                                        name,\n+                                        resolve::MakeGlobMap::No,\n+                                        |tcx, analysis| {\n+        let ty::CrateAnalysis { exported_items, public_items, .. } = analysis;\n+\n+        let ctxt = DocContext {\n+            krate: tcx.map.krate(),\n+            maybe_typed: Typed(tcx),\n+            input: input,\n+            external_traits: RefCell::new(Some(HashMap::new())),\n+            external_typarams: RefCell::new(Some(HashMap::new())),\n+            external_paths: RefCell::new(Some(HashMap::new())),\n+            inlined: RefCell::new(Some(HashSet::new())),\n+            populated_crate_impls: RefCell::new(HashSet::new()),\n+            deref_trait_did: Cell::new(None),\n+        };\n+        debug!(\"crate: {:?}\", ctxt.krate);\n+\n+        let mut analysis = CrateAnalysis {\n+            exported_items: exported_items,\n+            public_items: public_items,\n+            external_paths: RefCell::new(None),\n+            external_typarams: RefCell::new(None),\n+            inlined: RefCell::new(None),\n+            deref_trait_did: None,\n+        };\n+\n+        let krate = {\n+            let mut v = RustdocVisitor::new(&ctxt, Some(&analysis));\n+            v.visit(ctxt.krate);\n+            v.clean(&ctxt)\n+        };\n+\n+        let external_paths = ctxt.external_paths.borrow_mut().take();\n+        *analysis.external_paths.borrow_mut() = external_paths;\n+        let map = ctxt.external_typarams.borrow_mut().take();\n+        *analysis.external_typarams.borrow_mut() = map;\n+        let map = ctxt.inlined.borrow_mut().take();\n+        *analysis.inlined.borrow_mut() = map;\n+        analysis.deref_trait_did = ctxt.deref_trait_did.get();\n+        (krate, analysis)\n+    }).1\n }"}, {"sha": "305747d12824a7fd567b4393d13bf960b17f50c2", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -38,14 +38,14 @@ use doctree::*;\n pub struct RustdocVisitor<'a, 'tcx: 'a> {\n     pub module: Module,\n     pub attrs: Vec<ast::Attribute>,\n-    pub cx: &'a core::DocContext<'tcx>,\n+    pub cx: &'a core::DocContext<'a, 'tcx>,\n     pub analysis: Option<&'a core::CrateAnalysis>,\n     view_item_stack: HashSet<ast::NodeId>,\n     inlining_from_glob: bool,\n }\n \n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n-    pub fn new(cx: &'a core::DocContext<'tcx>,\n+    pub fn new(cx: &'a core::DocContext<'a, 'tcx>,\n                analysis: Option<&'a core::CrateAnalysis>) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is reexported, terminate all recursion.\n         let mut stack = HashSet::new();"}, {"sha": "e844b206cc0a0c0937802d45fda711c9b98dbb47", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 67, "deletions": 9, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -63,8 +63,10 @@ use owned_slice::OwnedSlice;\n use parse::token::{InternedString, str_to_ident};\n use parse::token;\n use parse::lexer;\n+use print::pprust;\n use ptr::P;\n \n+use std::cell::Cell;\n use std::fmt;\n use std::rc::Rc;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n@@ -200,14 +202,19 @@ impl Decodable for Ident {\n /// Function name (not all functions have names)\n pub type FnIdent = Option<Ident>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash,\n-           Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n     pub span: Span,\n     pub name: Name\n }\n \n+impl fmt::Debug for Lifetime {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"lifetime({}: {})\", self.id, pprust::lifetime_to_string(self))\n+    }\n+}\n+\n /// A lifetime definition, eg `'a: 'b+'c+'d`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct LifetimeDef {\n@@ -218,7 +225,7 @@ pub struct LifetimeDef {\n /// A \"Path\" is essentially Rust's notion of a name; for instance:\n /// std::cmp::PartialEq  .  It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct Path {\n     pub span: Span,\n     /// A `::foo` path, is relative to the crate root rather than current\n@@ -228,6 +235,18 @@ pub struct Path {\n     pub segments: Vec<PathSegment>,\n }\n \n+impl fmt::Debug for Path {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"path({})\", pprust::path_to_string(self))\n+    }\n+}\n+\n+impl fmt::Display for Path {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", pprust::path_to_string(self))\n+    }\n+}\n+\n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -358,12 +377,25 @@ pub type CrateNum = u32;\n pub type NodeId = u32;\n \n #[derive(Clone, Eq, Ord, PartialOrd, PartialEq, RustcEncodable,\n-           RustcDecodable, Hash, Debug, Copy)]\n+           RustcDecodable, Hash, Copy)]\n pub struct DefId {\n     pub krate: CrateNum,\n     pub node: NodeId,\n }\n \n+fn default_def_id_debug(_: DefId, _: &mut fmt::Formatter) -> fmt::Result { Ok(()) }\n+\n+thread_local!(pub static DEF_ID_DEBUG: Cell<fn(DefId, &mut fmt::Formatter) -> fmt::Result> =\n+                Cell::new(default_def_id_debug));\n+\n+impl fmt::Debug for DefId {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"DefId {{ krate: {}, node: {} }}\",\n+                    self.krate, self.node));\n+        DEF_ID_DEBUG.with(|def_id_debug| def_id_debug.get()(*self, f))\n+    }\n+}\n+\n impl DefId {\n     /// Read the node id, asserting that this def-id is krate-local.\n     pub fn local_id(&self) -> NodeId {\n@@ -539,13 +571,19 @@ pub struct Block {\n     pub span: Span,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct Pat {\n     pub id: NodeId,\n     pub node: Pat_,\n     pub span: Span,\n }\n \n+impl fmt::Debug for Pat {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"pat({}: {})\", self.id, pprust::pat_to_string(self))\n+    }\n+}\n+\n /// A single field in a struct pattern\n ///\n /// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n@@ -682,7 +720,16 @@ pub enum UnOp {\n /// A statement\n pub type Stmt = Spanned<Stmt_>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+impl fmt::Debug for Stmt {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"stmt({}: {})\",\n+               ast_util::stmt_id(self),\n+               pprust::stmt_to_string(self))\n+    }\n+}\n+\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub enum Stmt_ {\n     /// Could be an item or a local (let) binding:\n     StmtDecl(P<Decl>, NodeId),\n@@ -695,7 +742,6 @@ pub enum Stmt_ {\n \n     StmtMac(P<Mac>, MacStmtStyle),\n }\n-\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum MacStmtStyle {\n     /// The macro statement had a trailing semicolon, e.g. `foo! { ... };`\n@@ -772,13 +818,19 @@ pub enum UnsafeSource {\n }\n \n /// An expression\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash,)]\n pub struct Expr {\n     pub id: NodeId,\n     pub node: Expr_,\n     pub span: Span,\n }\n \n+impl fmt::Debug for Expr {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"expr({}: {})\", self.id, pprust::expr_to_string(self))\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Expr_ {\n     /// First expr is the place; second expr is the value.\n@@ -1357,13 +1409,19 @@ pub struct TypeBinding {\n \n \n // NB PartialEq method appears below.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct Ty {\n     pub id: NodeId,\n     pub node: Ty_,\n     pub span: Span,\n }\n \n+impl fmt::Debug for Ty {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"type({})\", pprust::ty_to_string(self))\n+    }\n+}\n+\n /// Not represented directly in the AST, referred to by name through a ty_path.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum PrimTy {"}, {"sha": "5ddcfaef9ea286e5261faa12f21e045eef7e72b8", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -19,7 +19,7 @@\n \n pub use self::ExpnFormat::*;\n \n-use std::cell::RefCell;\n+use std::cell::{Cell, RefCell};\n use std::ops::{Add, Sub};\n use std::path::Path;\n use std::rc::Rc;\n@@ -115,7 +115,7 @@ impl Sub for CharPos {\n /// are *absolute* positions from the beginning of the codemap, not positions\n /// relative to FileMaps. Methods on the CodeMap can be used to relate spans back\n /// to the original source.\n-#[derive(Clone, Copy, Debug, Hash)]\n+#[derive(Clone, Copy, Hash)]\n pub struct Span {\n     pub lo: BytePos,\n     pub hi: BytePos,\n@@ -164,6 +164,20 @@ impl Decodable for Span {\n     }\n }\n \n+fn default_span_debug(span: Span, f: &mut fmt::Formatter) -> fmt::Result {\n+    write!(f, \"Span {{ lo: {:?}, hi: {:?}, expn_id: {:?} }}\",\n+           span.lo, span.hi, span.expn_id)\n+}\n+\n+thread_local!(pub static SPAN_DEBUG: Cell<fn(Span, &mut fmt::Formatter) -> fmt::Result> =\n+                Cell::new(default_span_debug));\n+\n+impl fmt::Debug for Span {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        SPAN_DEBUG.with(|span_debug| span_debug.get()(*self, f))\n+    }\n+}\n+\n pub fn spanned<T>(lo: BytePos, hi: BytePos, t: T) -> Spanned<T> {\n     respan(mk_sp(lo, hi), t)\n }"}, {"sha": "b71eadd6d08af03d7ce587c39aa1d2811a561d8c", "filename": "src/test/compile-fail/object-lifetime-default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -29,6 +29,6 @@ struct E<'a,'b:'a,T:'b>(&'a T, &'b T); //~ ERROR 'b\n struct F<'a,'b,T:'a,U:'b>(&'a T, &'b U); //~ ERROR 'a,'b\n \n #[rustc_object_lifetime_default]\n-struct G<'a,'b,T:'a,U:'a+'b>(&'a T, &'b U); //~ ERROR 'a,Ambiguous\n+struct G<'a,'b,T:'a,U:'a+'b>(&'a T, &'b U); //~ ERROR 'a,Some(Ambiguous)\n \n fn main() { }"}, {"sha": "8af3844e62eefdee3de563b9c759018b42101a84", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efb47b9d23a96ff4684df80360bbed0ec68bc9/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=e4efb47b9d23a96ff4684df80360bbed0ec68bc9", "patch": "@@ -221,25 +221,26 @@ fn compile_program(input: &str, sysroot: PathBuf)\n         let arenas = ty::CtxtArenas::new();\n         let ast_map = driver::assign_node_ids_and_map(&sess, &mut forest);\n \n-        let analysis = driver::phase_3_run_analysis_passes(\n-            sess, ast_map, &arenas, id, MakeGlobMap::No);\n+        driver::phase_3_run_analysis_passes(\n+            sess, ast_map, &arenas, id, MakeGlobMap::No, |tcx, analysis| {\n \n-        let (tcx, trans) = driver::phase_4_translate_to_llvm(analysis);\n+            let trans = driver::phase_4_translate_to_llvm(tcx, analysis);\n \n-        let crates = tcx.sess.cstore.get_used_crates(RequireDynamic);\n+            let crates = tcx.sess.cstore.get_used_crates(RequireDynamic);\n \n-        // Collect crates used in the session.\n-        // Reverse order finds dependencies first.\n-        let deps = crates.into_iter().rev()\n-            .filter_map(|(_, p)| p).collect();\n+            // Collect crates used in the session.\n+            // Reverse order finds dependencies first.\n+            let deps = crates.into_iter().rev()\n+                .filter_map(|(_, p)| p).collect();\n \n-        assert_eq!(trans.modules.len(), 1);\n-        let llmod = trans.modules[0].llmod;\n+            assert_eq!(trans.modules.len(), 1);\n+            let llmod = trans.modules[0].llmod;\n \n-        // Workaround because raw pointers do not impl Send\n-        let modp = llmod as usize;\n+            // Workaround because raw pointers do not impl Send\n+            let modp = llmod as usize;\n \n-        (modp, deps)\n+            (modp, deps)\n+        }).1\n     }).unwrap();\n \n     match handle.join() {"}]}