{"sha": "c3207ba0cfb78af12bcf1661f74a61578d4e1e45", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMjA3YmEwY2ZiNzhhZjEyYmNmMTY2MWY3NGE2MTU3OGQ0ZTFlNDU=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-11-01T16:38:37Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-11-12T20:38:23Z"}, "message": "JS big updates", "tree": {"sha": "c240665bd6ba86479c05972b9f5b9e053f2d7c2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c240665bd6ba86479c05972b9f5b9e053f2d7c2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3207ba0cfb78af12bcf1661f74a61578d4e1e45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3207ba0cfb78af12bcf1661f74a61578d4e1e45", "html_url": "https://github.com/rust-lang/rust/commit/c3207ba0cfb78af12bcf1661f74a61578d4e1e45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3207ba0cfb78af12bcf1661f74a61578d4e1e45/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2db6ce6e96c12d0c2936ef09a4b28c7baaec31dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/2db6ce6e96c12d0c2936ef09a4b28c7baaec31dc", "html_url": "https://github.com/rust-lang/rust/commit/2db6ce6e96c12d0c2936ef09a4b28c7baaec31dc"}], "stats": {"total": 363, "additions": 254, "deletions": 109}, "files": [{"sha": "0a3411ac4004d2f237cb9a07e29d1413fa133b2b", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 254, "deletions": 109, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/c3207ba0cfb78af12bcf1661f74a61578d4e1e45/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/c3207ba0cfb78af12bcf1661f74a61578d4e1e45/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=c3207ba0cfb78af12bcf1661f74a61578d4e1e45", "patch": "@@ -50,7 +50,7 @@\n         if (elem && className && elem.className) {\n             var elemClass = elem.className;\n             var start = elemClass.indexOf(className);\n-            if (start == -1) {\n+            if (start === -1) {\n                 return false;\n             } else if (elemClass.length === className.length) {\n                 return true;\n@@ -64,6 +64,14 @@\n                 }\n                 return true;\n             }\n+            if (start > 0 && elemClass[start - 1] !== ' ') {\n+                return false;\n+            }\n+            var end = start + className.length;\n+            if (end < elemClass.length && elemClass[end] !== ' ') {\n+                return false;\n+            }\n+            return true;\n         }\n         return false;\n     }\n@@ -390,35 +398,147 @@\n                 return size;\n             }\n \n-            function findArg(obj, val) {\n+            function extractGenerics(val) {\n+                val = val.toLowerCase();\n+                if (val.indexOf('<') !== -1) {\n+                    var values = val.substring(val.indexOf('<') + 1, val.lastIndexOf('>'));\n+                    return {\n+                        name: val.substring(0, val.indexOf('<')),\n+                        generics: values.split(/\\s*,\\s*/),\n+                    };\n+                }\n+                return {\n+                    name: val,\n+                    generics: [],\n+                };\n+            }\n+\n+            function checkGenerics(obj, val) {\n+                // The names match, but we need to be sure that all generics kinda\n+                // match as well.\n                 var lev_distance = MAX_LEV_DISTANCE + 1;\n+                if (val.generics.length > 0) {\n+                    if (obj.generics &&\n+                        obj.generics.length >= val.generics.length) {\n+                        var elems = obj.generics.slice(0);\n+                        for (var y = 0;\n+                             y < val.generics.length;\n+                             ++y) {\n+                            // The point here is to find the type that matches the most.\n+                            var lev = { pos: -1, lev: MAX_LEV_DISTANCE + 1};\n+                            for (var x = 0; x < elems.length; ++x) {\n+                                var tmp_lev = levenshtein(elems[x], val.generics[y]);\n+                                if (tmp_lev < lev.lev) {\n+                                    lev.lev = tmp_lev;\n+                                    lev.pos = x;\n+                                }\n+                            }\n+                            if (lev.pos !== -1) {\n+                                elems.splice(lev.pos, 1);\n+                                lev_distance = min(lev.lev, lev_distance);\n+                            } else {\n+                                return MAX_LEV_DISTANCE + 1;\n+                            }\n+                        }\n+                        return lev_distance;\n+                    }\n+                } else {\n+                    return 0;\n+                }\n+                return MAX_LEV_DISTANCE + 1;\n+            }\n+\n+            // Check for type name and type generics (if any).\n+            function checkType(obj, val, literalSearch) {\n+                var lev_distance = MAX_LEV_DISTANCE + 1;\n+                if (obj.name === val.name) {\n+                    if (literalSearch === true) {\n+                        if (val.generics.length > 0) {\n+                            if (obj.generics && obj.length >= val.generics.length) {\n+                                var elems = obj.generics.slice(0);\n+                                var allFound = true;\n+                                var x;\n+\n+                                for (var y = 0; allFound === true && y < val.generics.length; ++y) {\n+                                    allFound = false;\n+                                    for (x = 0; allFound === false && x < elems.length; ++x) {\n+                                        allFound = elems[x] === val.generics[y];\n+                                    }\n+                                    if (allFound === true) {\n+                                        elems.splice(x - 1, 1);\n+                                    }\n+                                }\n+                                if (allFound === true) {\n+                                    return true;\n+                                }\n+                            } else {\n+                                return false;\n+                            }\n+                        }\n+                        return true;\n+                    }\n+                    // No need to check anything else: we found it. Let's just move on.\n+                    var tmp_lev = checkGenerics(obj, val);\n+                    if (tmp_lev <= MAX_LEV_DISTANCE) {\n+                        return tmp_lev;\n+                    }\n+                }\n+                // Names didn't match so let's check if one of the generic types could.\n+                if (literalSearch === true) {\n+                     if (obj.generics.length > 0) {\n+                        for (var x = 0; x < obj.generics.length; ++x) {\n+                            if (obj.generics[x] === val.name) {\n+                                return true;\n+                            }\n+                        }\n+                    }\n+                    return false;\n+                }\n+                var new_lev = levenshtein(obj.name, val.name);\n+                if (new_lev < lev_distance) {\n+                    if ((lev = checkGenerics(obj, val)) <= MAX_LEV_DISTANCE) {\n+                        lev_distance = min(min(new_lev, lev), lev_distance);\n+                    }\n+                } else if (obj.generics && obj.generics.length > 0) {\n+                    for (var x = 0; x < obj.generics.length; ++x) {\n+                        lev_distance = min(levenshtein(obj.generics[x], val.name), lev_distance);\n+                    }\n+                }\n+                return lev_distance;\n+            }\n+\n+            function findArg(obj, val, literalSearch) {\n+                var lev_distance = MAX_LEV_DISTANCE + 1;\n+\n                 if (obj && obj.type && obj.type.inputs.length > 0) {\n                     for (var i = 0; i < obj.type.inputs.length; i++) {\n-                        if (obj.type.inputs[i].name === val) {\n-                            // No need to check anything else: we found it. Let's just move on.\n-                            return 0;\n+                        var tmp = checkType(obj.type.inputs[i], val, literalSearch);\n+                        if (literalSearch && tmp === true) {\n+                            return true;\n                         }\n-                        lev_distance = min(levenshtein(obj.type.inputs[i].name, val), lev_distance);\n+                        lev_distance = min(tmp, lev_distance);\n                         if (lev_distance === 0) {\n                             return 0;\n                         }\n                     }\n                 }\n-                return lev_distance;\n+                return literalSearch === true ? false : lev_distance;\n             }\n \n-            function checkReturned(obj, val) {\n+            function checkReturned(obj, val, literalSearch) {\n                 var lev_distance = MAX_LEV_DISTANCE + 1;\n+\n                 if (obj && obj.type && obj.type.output) {\n-                    if (obj.type.output.name.toLowerCase() === val) {\n-                        return 0;\n+                    var tmp = checkType(obj.type.output, val, literalSearch);\n+                    if (literalSearch && tmp === true) {\n+                        return true;\n                     }\n-                    lev_distance = min(levenshtein(obj.type.output.name, val));\n+                    lev_distance = min(tmp, lev_distance);\n                     if (lev_distance === 0) {\n                         return 0;\n                     }\n                 }\n-                return lev_distance;\n+                return literalSearch === true ? false : lev_distance;\n             }\n \n             function typePassesFilter(filter, type) {\n@@ -448,24 +568,34 @@\n             if ((val.charAt(0) === \"\\\"\" || val.charAt(0) === \"'\") &&\n                 val.charAt(val.length - 1) === val.charAt(0))\n             {\n-                val = val.substr(1, val.length - 2).toLowerCase();\n+                val = extractGenerics(val.substr(1, val.length - 2));\n                 for (var i = 0; i < nSearchWords; ++i) {\n+                    var param = findArg(searchIndex[i], val, true);\n+                    var returned = checkReturned(searchIndex[i], val, true);\n                     var ty = searchIndex[i];\n-                    if (searchWords[i] === val) {\n+                    if (searchWords[i] === val.name) {\n                         // filter type: ... queries\n-                        if (typePassesFilter(typeFilter, searchIndex[i].ty)) {\n+                        if (typePassesFilter(typeFilter, searchIndex[i].ty) &&\n+                            results[ty.path + ty.name] === undefined) {\n                             results[ty.path + ty.name] = {id: i, index: -1};\n                         }\n-                    } else if (findArg(searchIndex[i], val) ||\n-                               (ty.type &&\n-                                ty.type.output &&\n-                                ty.type.output.name === val)) {\n-                        if (typePassesFilter(typeFilter, searchIndex[i].ty)) {\n+                    } else if ((param === true || returned === true) &&\n+                               typePassesFilter(typeFilter, searchIndex[i].ty)) {\n+                        if (results[ty.path + ty.name] === undefined) {\n                             results[ty.path + ty.name] = {\n                                 id: i,\n                                 index: -1,\n                                 dontValidate: true,\n+                                param: param,\n+                                returned: returned,\n                             };\n+                        } else {\n+                            if (param === true) {\n+                                results[ty.path + ty.name].param = true;\n+                            }\n+                            if (returned === true) {\n+                                results[ty.path + ty.name].returned = true;\n+                            }\n                         }\n                     }\n                     if (nbElements(results) === max) {\n@@ -482,7 +612,10 @@\n                 var input = parts[0];\n                 // sort inputs so that order does not matter\n                 var inputs = input.split(\",\").map(trimmer).sort();\n-                var output = parts[1];\n+                for (var i = 0; i < inputs.length; i++) {\n+                    inputs[i] = extractGenerics(inputs[i]);\n+                }\n+                var output = extractGenerics(parts[1]);\n \n                 for (var i = 0; i < nSearchWords; ++i) {\n                     var type = searchIndex[i].type;\n@@ -491,100 +624,122 @@\n                         continue;\n                     }\n \n-                    // sort index inputs so that order does not matter\n-                    var typeInputs = type.inputs.map(function (input) {\n-                        return input.name;\n-                    }).sort();\n-\n                     // allow searching for void (no output) functions as well\n                     var typeOutput = type.output ? type.output.name : \"\";\n-                    if (output === \"*\" || output == typeOutput) {\n+                    var returned = checkReturned(ty, output, true);\n+                    if (output.name === \"*\" || returned === true) {\n+                        var param = false;\n+                        var module = false;\n+\n                         if (input === \"*\") {\n-                            results[ty.path + ty.name] = {id: i, index: -1, dontValidate: true};\n+                            module = true;\n                         } else {\n                             var allFound = true;\n                             for (var it = 0; allFound === true && it < inputs.length; it++) {\n-                                var found = false;\n-                                for (var y = 0; found === false && y < typeInputs.length; y++) {\n-                                    found = typeInputs[y] === inputs[it];\n-                                }\n-                                allFound = found;\n+                                allFound = checkType(type, inputs[it], true);\n                             }\n-                            if (allFound === true) {\n+                            param = allFound;\n+                        }\n+                        if (param === true || returned === true || module === true) {\n+                            if (results[ty.path + ty.name] !== undefined) {\n+                                if (returned === true) {\n+                                    results[ty.path + ty.name].returned = true;\n+                                }\n+                                if (param === true) {\n+                                    results[ty.path + ty.name].param = true;\n+                                }\n+                            } else {\n                                 results[ty.path + ty.name] = {\n                                     id: i,\n                                     index: -1,\n                                     dontValidate: true,\n+                                    returned: returned,\n+                                    param: param,\n                                 };\n                             }\n                         }\n                     }\n                 }\n-                query.inputs = inputs;\n-                query.output = output;\n+                query.inputs = inputs.map(function(input) {\n+                    return input.name;\n+                });\n+                query.output = output.name;\n             } else {\n                 query.inputs = [val];\n                 query.output = val;\n                 query.search = val;\n                 // gather matching search results up to a certain maximum\n                 val = val.replace(/\\_/g, \"\");\n+                var valGenerics = extractGenerics(val);\n                 for (var i = 0; i < split.length; ++i) {\n                     for (var j = 0; j < nSearchWords; ++j) {\n                         var lev_distance;\n                         var ty = searchIndex[j];\n                         if (!ty) {\n                             continue;\n                         }\n+                        var returned = false;\n+                        var param = false;\n+                        var index = -1;\n+                        // we want lev results to go lower than others\n+                        var lev = 0;\n+\n                         if (searchWords[j].indexOf(split[i]) > -1 ||\n                             searchWords[j].indexOf(val) > -1 ||\n                             searchWords[j].replace(/_/g, \"\").indexOf(val) > -1)\n                         {\n                             // filter type: ... queries\n-                            if (typePassesFilter(typeFilter, searchIndex[j].ty)) {\n+                            if (typePassesFilter(typeFilter, searchIndex[j].ty) &&\n+                                results[ty.path + ty.name] === undefined) {\n+                                index = searchWords[j].replace(/_/g, \"\").indexOf(val);\n+                            }\n+                        }\n+                        if ((lev_distance = levenshtein(searchWords[j], val)) <= MAX_LEV_DISTANCE) {\n+                            if (typePassesFilter(typeFilter, searchIndex[j].ty) &&\n+                                (results[ty.path + ty.name] === undefined ||\n+                                 results[ty.path + ty.name].lev > lev_distance)) {\n+                                lev = lev_distance;\n+                                index = 0;\n+                            }\n+                        }\n+                        if ((lev_distance = findArg(searchIndex[j], valGenerics))\n+                            <= MAX_LEV_DISTANCE) {\n+                            if (typePassesFilter(typeFilter, searchIndex[j].ty) &&\n+                                (results[ty.path + ty.name] === undefined ||\n+                                 results[ty.path + ty.name].lev > lev_distance)) {\n+                                param = true;\n+                                lev = lev_distance;\n+                                index = 0;\n+                            }\n+                        }\n+                        if ((lev_distance = checkReturned(searchIndex[j], valGenerics)) <=\n+                            MAX_LEV_DISTANCE) {\n+                            if (typePassesFilter(typeFilter, searchIndex[j].ty) &&\n+                                (results[ty.path + ty.name] === undefined ||\n+                                 results[ty.path + ty.name].lev > lev_distance)) {\n+                                returned = true;\n+                                lev = lev_distance;\n+                                index = 0;\n+                            }\n+                        }\n+                        if (index !== -1) {\n+                            if (results[ty.path + ty.name] === undefined) {\n                                 results[ty.path + ty.name] = {\n                                     id: j,\n-                                    index: searchWords[j].replace(/_/g, \"\").indexOf(val),\n-                                    lev: 0,\n+                                    index: index,\n+                                    lev: lev,\n+                                    param: param,\n+                                    returned: returned,\n                                 };\n-                            }\n-                        } else if (\n-                            (lev_distance = levenshtein(searchWords[j], val)) <= MAX_LEV_DISTANCE) {\n-                            if (typePassesFilter(typeFilter, searchIndex[j].ty)) {\n-                                if (results[ty.path + ty.name] === undefined ||\n-                                    results[ty.path + ty.name].lev > lev_distance) {\n-                                    results[ty.path + ty.name] = {\n-                                        id: j,\n-                                        index: 0,\n-                                        // we want lev results to go lower than others\n-                                        lev: lev_distance,\n-                                    };\n+                            } else {\n+                                if (results[ty.path + ty.name].lev > lev) {\n+                                    results[ty.path + ty.name].lev = lev;\n                                 }\n-                            }\n-                        } else if (\n-                            (lev_distance = findArg(searchIndex[j], val)) <= MAX_LEV_DISTANCE) {\n-                            if (typePassesFilter(typeFilter, searchIndex[j].ty)) {\n-                                if (results[ty.path + ty.name] === undefined ||\n-                                    results[ty.path + ty.name].lev > lev_distance) {\n-                                    results[ty.path + ty.name] = {\n-                                        id: j,\n-                                        index: 0,\n-                                        // we want lev results to go lower than others\n-                                        lev: lev_distance,\n-                                    };\n+                                if (param === true) {\n+                                    results[ty.path + ty.name].param = true;\n                                 }\n-                            }\n-                        } else if (\n-                            (lev_distance = checkReturned(searchIndex[j], val)) <=\n-                            MAX_LEV_DISTANCE) {\n-                            if (typePassesFilter(typeFilter, searchIndex[j].ty)) {\n-                                if (results[ty.path + ty.name] === undefined ||\n-                                    results[ty.path + ty.name].lev > lev_distance) {\n-                                    results[ty.path + ty.name] = {\n-                                        id: j,\n-                                        index: 0,\n-                                        // we want lev results to go lower than others\n-                                        lev: lev_distance,\n-                                    };\n+                                if (returned === true) {\n+                                    results[ty.path + ty.name].returned = true;\n                                 }\n                             }\n                         }\n@@ -678,18 +833,19 @@\n             });\n \n             for (var i = 0; i < results.length; ++i) {\n-                var result = results[i],\n-                    name = result.item.name.toLowerCase(),\n-                    path = result.item.path.toLowerCase(),\n-                    parent = result.item.parent;\n+                var result = results[i];\n \n                 // this validation does not make sense when searching by types\n                 if (result.dontValidate) {\n                     continue;\n                 }\n+                var name = result.item.name.toLowerCase(),\n+                    path = result.item.path.toLowerCase(),\n+                    parent = result.item.parent;\n \n-                var valid = validateResult(name, path, split, parent);\n-                if (!valid) {\n+                if (result.returned === false && result.param === false &&\n+                    validateResult(name, path, split, parent) === false)\n+                {\n                     result.id = -1;\n                 }\n             }\n@@ -716,14 +872,14 @@\n                 // each check is for validation so we negate the conditions and invalidate\n                 if (!(\n                     // check for an exact name match\n-                    name.toLowerCase().indexOf(keys[i]) > -1 ||\n+                    name.indexOf(keys[i]) > -1 ||\n                     // then an exact path match\n-                    path.toLowerCase().indexOf(keys[i]) > -1 ||\n+                    path.indexOf(keys[i]) > -1 ||\n                     // next if there is a parent, check for exact parent match\n                     (parent !== undefined &&\n                         parent.name.toLowerCase().indexOf(keys[i]) > -1) ||\n                     // lastly check to see if the name was a levenshtein match\n-                    levenshtein(name.toLowerCase(), keys[i]) <= MAX_LEV_DISTANCE)) {\n+                    levenshtein(name, keys[i]) <= MAX_LEV_DISTANCE)) {\n                     return false;\n                 }\n             }\n@@ -1008,33 +1164,18 @@\n                     filterdata.push([obj.name, obj.ty, obj.path, obj.desc]);\n                     if (obj.type) {\n                         if (results['returned'].length < maxResults &&\n-                            obj.type.output &&\n-                            obj.type.output.name.toLowerCase() === query.output) {\n+                            resultIndex[i].returned === true) {\n                             results['returned'].push(obj);\n                             added = true;\n                         }\n-                        if (results['in_args'].length < maxResults && obj.type.inputs.length > 0) {\n-                            var all_founds = true;\n-                            for (var it = 0;\n-                                 all_founds === true && it < query.inputs.length;\n-                                 it++) {\n-                                var found = false;\n-                                for (var y = 0;\n-                                     found === false && y < obj.type.inputs.length;\n-                                     y++) {\n-                                    found = query.inputs[it] === obj.type.inputs[y].name;\n-                                }\n-                                all_founds = found;\n-                            }\n-                            if (all_founds === true) {\n-                                results['in_args'].push(obj);\n-                                added = true;\n-                            }\n+                        if (results['in_args'].length < maxResults && resultIndex[i] === true) {\n+                            results['in_args'].push(obj);\n+                            added = true;\n                         }\n                     }\n                     if (results['others'].length < maxResults &&\n-                        ((query.search && obj.name.indexOf(query.search) !== -1) ||\n-                          added === false)) {\n+                        (added === false ||\n+                         (query.search && obj.name.indexOf(query.search) !== -1))) {\n                         results['others'].push(obj);\n                     }\n                 }\n@@ -1050,7 +1191,9 @@\n \n         function itemTypeFromName(typename) {\n             for (var i = 0; i < itemTypes.length; ++i) {\n-                if (itemTypes[i] === typename) { return i; }\n+                if (itemTypes[i] === typename) {\n+                    return i;\n+                }\n             }\n             return -1;\n         }\n@@ -1141,7 +1284,7 @@\n             var search_input = document.getElementsByClassName(\"search-input\")[0];\n             search_input.onkeyup = callback;\n             search_input.oninput = callback;\n-            document.getElementsByClassName(\"search-form\")[0].onsubmit = function(e){\n+            document.getElementsByClassName(\"search-form\")[0].onsubmit = function(e) {\n                 e.preventDefault();\n                 clearTimeout(searchTimeout);\n                 search();\n@@ -1217,7 +1360,9 @@\n \n             var crates = [];\n             for (var crate in rawSearchIndex) {\n-                if (!rawSearchIndex.hasOwnProperty(crate)) { continue; }\n+                if (!rawSearchIndex.hasOwnProperty(crate)) {\n+                    continue;\n+                }\n                 crates.push(crate);\n             }\n             crates.sort();"}]}