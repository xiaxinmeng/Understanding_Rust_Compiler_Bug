{"sha": "670a0edaa9d80683df8db81554890710e79f8024", "node_id": "C_kwDOAAsO6NoAKDY3MGEwZWRhYTlkODA2ODNkZjhkYjgxNTU0ODkwNzEwZTc5ZjgwMjQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-16T21:14:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-16T21:14:24Z"}, "message": "Auto merge of #112716 - compiler-errors:rollup-h77daia, r=compiler-errors\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #111074 (Relax implicit `T: Sized` bounds on `BufReader<T>`, `BufWriter<T>` and `LineWriter<T>`)\n - #112226 (std: available_parallelism using native netbsd api first)\n - #112474 (Support 128-bit enum variant in debuginfo codegen)\n - #112662 (`#[lang_item]` for `core::ptr::Unique`)\n - #112665 (Make assumption functions in new solver take `Binder<'tcx, Clause<'tcx>>`)\n - #112684 (Disable alignment checks on i686-pc-windows-msvc)\n - #112706 (Add `SyntaxContext::is_root`)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "4bbbcd5f4ab51712cefa538eeaed165118fc94b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bbbcd5f4ab51712cefa538eeaed165118fc94b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/670a0edaa9d80683df8db81554890710e79f8024", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/670a0edaa9d80683df8db81554890710e79f8024", "html_url": "https://github.com/rust-lang/rust/commit/670a0edaa9d80683df8db81554890710e79f8024", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/670a0edaa9d80683df8db81554890710e79f8024/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bba061467f7c2cab04b262b95eb67bf89265587", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bba061467f7c2cab04b262b95eb67bf89265587", "html_url": "https://github.com/rust-lang/rust/commit/6bba061467f7c2cab04b262b95eb67bf89265587"}, {"sha": "56c96d755262be18788191c1f6cddeeae7911379", "url": "https://api.github.com/repos/rust-lang/rust/commits/56c96d755262be18788191c1f6cddeeae7911379", "html_url": "https://github.com/rust-lang/rust/commit/56c96d755262be18788191c1f6cddeeae7911379"}], "stats": {"total": 494, "additions": 331, "deletions": 163}, "files": [{"sha": "b62f4676f70b6c13a1265f50898a47a8f1c53b6c", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -108,6 +108,10 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         self.const_uint(self.type_u64(), i)\n     }\n \n+    fn const_u128(&self, i: u128) -> RValue<'gcc> {\n+        self.const_uint_big(self.type_u128(), i)\n+    }\n+\n     fn const_usize(&self, i: u64) -> RValue<'gcc> {\n         let bit_size = self.data_layout().pointer_size.bits();\n         if bit_size < 64 {\n@@ -254,7 +258,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         // SIMD builtins require a constant value.\n         self.bitcast_if_needed(value, typ)\n     }\n-    \n+\n     fn const_ptr_byte_offset(&self, base_addr: Self::Value, offset: abi::Size) -> Self::Value {\n         self.context.new_array_access(None, base_addr, self.const_usize(offset.bytes())).get_address(None)\n     }"}, {"sha": "a2db59bd6c47be7a09f63f7ab66a2976558f6419", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -168,6 +168,10 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         self.const_uint(self.type_i64(), i)\n     }\n \n+    fn const_u128(&self, i: u128) -> &'ll Value {\n+        self.const_uint_big(self.type_i128(), i)\n+    }\n+\n     fn const_usize(&self, i: u64) -> &'ll Value {\n         let bit_size = self.data_layout().pointer_size.bits();\n         if bit_size < 64 {"}, {"sha": "1a8618e0c55770bdeaa4b17b9530cc72e5d27a8a", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -429,7 +429,7 @@ pub fn type_di_node<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll D\n         return existing_di_node;\n     }\n \n-    debug!(\"type_di_node: {:?}\", t);\n+    debug!(\"type_di_node: {:?} kind: {:?}\", t, t.kind());\n \n     let DINodeCreationResult { di_node, already_stored_in_typemap } = match *t.kind() {\n         ty::Never | ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) => {"}, {"sha": "666b9762f5a76e900a0a5b6f7d30ad6c5c011c3d", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/native.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -412,13 +412,7 @@ fn build_enum_variant_member_di_node<'ll, 'tcx>(\n             enum_type_and_layout.size.bits(),\n             enum_type_and_layout.align.abi.bits() as u32,\n             Size::ZERO.bits(),\n-            discr_value.opt_single_val().map(|value| {\n-                // NOTE(eddyb) do *NOT* remove this assert, until\n-                // we pass the full 128-bit value to LLVM, otherwise\n-                // truncation will be silent and remain undetected.\n-                assert_eq!(value as u64 as u128, value);\n-                cx.const_u64(value as u64)\n-            }),\n+            discr_value.opt_single_val().map(|value| cx.const_u128(value)),\n             DIFlags::FlagZero,\n             variant_member_info.variant_struct_type_di_node,\n         )"}, {"sha": "d6e9bfce1a4fc86cb6bb93f1a5239f9840ef4893", "filename": "compiler/rustc_codegen_ssa/src/traits/consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -15,6 +15,7 @@ pub trait ConstMethods<'tcx>: BackendTypes {\n     fn const_i32(&self, i: i32) -> Self::Value;\n     fn const_u32(&self, i: u32) -> Self::Value;\n     fn const_u64(&self, i: u64) -> Self::Value;\n+    fn const_u128(&self, i: u128) -> Self::Value;\n     fn const_usize(&self, i: u64) -> Self::Value;\n     fn const_u8(&self, i: u8) -> Self::Value;\n     fn const_real(&self, t: Self::Type, val: f64) -> Self::Value;"}, {"sha": "40bfa3715be7b71ffb74ae1490136e66c824811a", "filename": "compiler/rustc_expand/src/mbe/quoted.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -9,7 +9,7 @@ use rustc_session::parse::{feature_err, ParseSess};\n use rustc_span::symbol::{kw, sym, Ident};\n \n use rustc_span::edition::Edition;\n-use rustc_span::{Span, SyntaxContext};\n+use rustc_span::Span;\n \n const VALID_FRAGMENT_NAMES_MSG: &str = \"valid fragment specifiers are \\\n                                         `ident`, `block`, `stmt`, `expr`, `pat`, `ty`, `lifetime`, \\\n@@ -72,7 +72,7 @@ pub(super) fn parse(\n                                             // `SyntaxContext::root()` from a foreign crate will\n                                             // have the edition of that crate (which we manually\n                                             // retrieve via the `edition` parameter).\n-                                            if span.ctxt() == SyntaxContext::root() {\n+                                            if span.ctxt().is_root() {\n                                                 edition\n                                             } else {\n                                                 span.edition()"}, {"sha": "4e23a28b37166dad6f1a629747f2f1c70af4244a", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -260,6 +260,8 @@ language_item_table! {\n     EhCatchTypeinfo,         sym::eh_catch_typeinfo,   eh_catch_typeinfo,          Target::Static,         GenericRequirement::None;\n \n     OwnedBox,                sym::owned_box,           owned_box,                  Target::Struct,         GenericRequirement::Minimum(1);\n+    // Experimental language item for Miri\n+    PtrUnique,               sym::ptr_unique,          ptr_unique,                 Target::Struct,         GenericRequirement::Exact(1);\n \n     PhantomData,             sym::phantom_data,        phantom_data,               Target::Struct,         GenericRequirement::Exact(1);\n "}, {"sha": "6b03619438189d7e99ac598eb7d8d9c43ce1156e", "filename": "compiler/rustc_middle/src/mir/spanview.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -3,7 +3,7 @@ use rustc_middle::hir;\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::MirSpanview;\n-use rustc_span::{BytePos, Pos, Span, SyntaxContext};\n+use rustc_span::{BytePos, Pos, Span};\n \n use std::cmp;\n use std::io::{self, Write};\n@@ -327,7 +327,7 @@ fn compute_block_span(data: &BasicBlockData<'_>, body_span: Span) -> Span {\n     let mut span = data.terminator().source_info.span;\n     for statement_span in data.statements.iter().map(|statement| statement.source_info.span) {\n         // Only combine Spans from the root context, and within the function's body_span.\n-        if statement_span.ctxt() == SyntaxContext::root() && body_span.contains(statement_span) {\n+        if statement_span.ctxt().is_root() && body_span.contains(statement_span) {\n             span = span.to(statement_span);\n         }\n     }"}, {"sha": "ff5d99794f1e2b3c3d89b5445543774d14391b55", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -586,6 +586,24 @@ pub enum Clause<'tcx> {\n     ConstArgHasType(Const<'tcx>, Ty<'tcx>),\n }\n \n+impl<'tcx> Binder<'tcx, Clause<'tcx>> {\n+    pub fn as_trait_clause(self) -> Option<Binder<'tcx, TraitPredicate<'tcx>>> {\n+        if let ty::Clause::Trait(trait_clause) = self.skip_binder() {\n+            Some(self.rebind(trait_clause))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn as_projection_clause(self) -> Option<Binder<'tcx, ProjectionPredicate<'tcx>>> {\n+        if let ty::Clause::Projection(projection_clause) = self.skip_binder() {\n+            Some(self.rebind(projection_clause))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub enum PredicateKind<'tcx> {\n@@ -1203,6 +1221,17 @@ impl<'tcx> ToPredicate<'tcx> for TraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> ToPredicate<'tcx, Binder<'tcx, Clause<'tcx>>> for TraitRef<'tcx> {\n+    #[inline(always)]\n+    fn to_predicate(self, _tcx: TyCtxt<'tcx>) -> Binder<'tcx, Clause<'tcx>> {\n+        Binder::dummy(Clause::Trait(TraitPredicate {\n+            trait_ref: self,\n+            constness: ty::BoundConstness::NotConst,\n+            polarity: ty::ImplPolarity::Positive,\n+        }))\n+    }\n+}\n+\n impl<'tcx> ToPredicate<'tcx> for Binder<'tcx, TraitRef<'tcx>> {\n     #[inline(always)]\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n@@ -1211,6 +1240,14 @@ impl<'tcx> ToPredicate<'tcx> for Binder<'tcx, TraitRef<'tcx>> {\n     }\n }\n \n+impl<'tcx> ToPredicate<'tcx, Binder<'tcx, Clause<'tcx>>> for Binder<'tcx, TraitRef<'tcx>> {\n+    #[inline(always)]\n+    fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Binder<'tcx, Clause<'tcx>> {\n+        let pred: PolyTraitPredicate<'tcx> = self.to_predicate(tcx);\n+        pred.to_predicate(tcx)\n+    }\n+}\n+\n impl<'tcx> ToPredicate<'tcx, PolyTraitPredicate<'tcx>> for Binder<'tcx, TraitRef<'tcx>> {\n     #[inline(always)]\n     fn to_predicate(self, _: TyCtxt<'tcx>) -> PolyTraitPredicate<'tcx> {\n@@ -1240,6 +1277,12 @@ impl<'tcx> ToPredicate<'tcx> for PolyTraitPredicate<'tcx> {\n     }\n }\n \n+impl<'tcx> ToPredicate<'tcx, Binder<'tcx, Clause<'tcx>>> for PolyTraitPredicate<'tcx> {\n+    fn to_predicate(self, _tcx: TyCtxt<'tcx>) -> Binder<'tcx, Clause<'tcx>> {\n+        self.map_bound(|p| Clause::Trait(p))\n+    }\n+}\n+\n impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         self.map_bound(|p| PredicateKind::Clause(Clause::RegionOutlives(p))).to_predicate(tcx)\n@@ -1258,6 +1301,12 @@ impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n     }\n }\n \n+impl<'tcx> ToPredicate<'tcx, Binder<'tcx, Clause<'tcx>>> for PolyProjectionPredicate<'tcx> {\n+    fn to_predicate(self, _tcx: TyCtxt<'tcx>) -> Binder<'tcx, Clause<'tcx>> {\n+        self.map_bound(|p| Clause::Projection(p))\n+    }\n+}\n+\n impl<'tcx> ToPredicate<'tcx> for TraitPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         PredicateKind::Clause(Clause::Trait(self)).to_predicate(tcx)\n@@ -1327,6 +1376,23 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::TypeWellFormedFromEnv(..) => None,\n         }\n     }\n+\n+    pub fn as_clause(self) -> Option<Binder<'tcx, Clause<'tcx>>> {\n+        let predicate = self.kind();\n+        match predicate.skip_binder() {\n+            PredicateKind::Clause(clause) => Some(predicate.rebind(clause)),\n+            PredicateKind::AliasRelate(..)\n+            | PredicateKind::Subtype(..)\n+            | PredicateKind::Coerce(..)\n+            | PredicateKind::WellFormed(..)\n+            | PredicateKind::ObjectSafe(..)\n+            | PredicateKind::ClosureKind(..)\n+            | PredicateKind::ConstEvaluatable(..)\n+            | PredicateKind::ConstEquate(..)\n+            | PredicateKind::Ambiguous\n+            | PredicateKind::TypeWellFormedFromEnv(..) => None,\n+        }\n+    }\n }\n \n /// Represents the bounds declared on a particular set of type"}, {"sha": "fd349c07040fe00e1a017ac0c6efaf9146a427ff", "filename": "compiler/rustc_mir_transform/src/check_alignment.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_alignment.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -15,6 +15,10 @@ pub struct CheckAlignment;\n \n impl<'tcx> MirPass<'tcx> for CheckAlignment {\n     fn is_enabled(&self, sess: &Session) -> bool {\n+        // FIXME(#112480) MSVC and rustc disagree on minimum stack alignment on x86 Windows\n+        if sess.target.llvm_target == \"i686-pc-windows-msvc\" {\n+            return false;\n+        }\n         sess.opts.debug_assertions\n     }\n "}, {"sha": "9f2ff4378425edad21cd47d7446efe7bbf021880", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -507,7 +507,7 @@ impl HygieneData {\n             self.normalize_to_macro_rules(call_site_ctxt)\n         };\n \n-        if call_site_ctxt == SyntaxContext::root() {\n+        if call_site_ctxt.is_root() {\n             return self.apply_mark_internal(ctxt, expn_id, transparency);\n         }\n \n@@ -671,12 +671,17 @@ impl SyntaxContext {\n     }\n \n     #[inline]\n-    pub(crate) fn as_u32(self) -> u32 {\n+    pub const fn is_root(self) -> bool {\n+        self.0 == SyntaxContext::root().as_u32()\n+    }\n+\n+    #[inline]\n+    pub(crate) const fn as_u32(self) -> u32 {\n         self.0\n     }\n \n     #[inline]\n-    pub(crate) fn from_u32(raw: u32) -> SyntaxContext {\n+    pub(crate) const fn from_u32(raw: u32) -> SyntaxContext {\n         SyntaxContext(raw)\n     }\n \n@@ -1500,7 +1505,7 @@ impl<CTX: HashStableContext> HashStable<CTX> for SyntaxContext {\n         const TAG_EXPANSION: u8 = 0;\n         const TAG_NO_EXPANSION: u8 = 1;\n \n-        if *self == SyntaxContext::root() {\n+        if self.is_root() {\n             TAG_NO_EXPANSION.hash_stable(ctx, hasher);\n         } else {\n             TAG_EXPANSION.hash_stable(ctx, hasher);"}, {"sha": "e7a53c63e83bdc7091cfabe5551299054ef7544d", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -826,9 +826,9 @@ impl Span {\n         // Return the macro span on its own to avoid weird diagnostic output. It is preferable to\n         // have an incomplete span than a completely nonsensical one.\n         if span_data.ctxt != end_data.ctxt {\n-            if span_data.ctxt == SyntaxContext::root() {\n+            if span_data.ctxt.is_root() {\n                 return end;\n-            } else if end_data.ctxt == SyntaxContext::root() {\n+            } else if end_data.ctxt.is_root() {\n                 return self;\n             }\n             // Both spans fall within a macro.\n@@ -837,7 +837,7 @@ impl Span {\n         Span::new(\n             cmp::min(span_data.lo, end_data.lo),\n             cmp::max(span_data.hi, end_data.hi),\n-            if span_data.ctxt == SyntaxContext::root() { end_data.ctxt } else { span_data.ctxt },\n+            if span_data.ctxt.is_root() { end_data.ctxt } else { span_data.ctxt },\n             if span_data.parent == end_data.parent { span_data.parent } else { None },\n         )\n     }\n@@ -855,7 +855,7 @@ impl Span {\n         Span::new(\n             span.hi,\n             end.lo,\n-            if end.ctxt == SyntaxContext::root() { end.ctxt } else { span.ctxt },\n+            if end.ctxt.is_root() { end.ctxt } else { span.ctxt },\n             if span.parent == end.parent { span.parent } else { None },\n         )\n     }\n@@ -879,9 +879,9 @@ impl Span {\n         // Return the macro span on its own to avoid weird diagnostic output. It is preferable to\n         // have an incomplete span than a completely nonsensical one.\n         if span_data.ctxt != end_data.ctxt {\n-            if span_data.ctxt == SyntaxContext::root() {\n+            if span_data.ctxt.is_root() {\n                 return end;\n-            } else if end_data.ctxt == SyntaxContext::root() {\n+            } else if end_data.ctxt.is_root() {\n                 return self;\n             }\n             // Both spans fall within a macro.\n@@ -890,7 +890,7 @@ impl Span {\n         Span::new(\n             span_data.lo,\n             end_data.lo,\n-            if end_data.ctxt == SyntaxContext::root() { end_data.ctxt } else { span_data.ctxt },\n+            if end_data.ctxt.is_root() { end_data.ctxt } else { span_data.ctxt },\n             if span_data.parent == end_data.parent { span_data.parent } else { None },\n         )\n     }"}, {"sha": "19d986a3152b47d1df572614973a124862cee91f", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -1156,6 +1156,7 @@ symbols! {\n         ptr_null_mut,\n         ptr_offset_from,\n         ptr_offset_from_unsigned,\n+        ptr_unique,\n         pub_macro_rules,\n         pub_restricted,\n         public,"}, {"sha": "e6eddf24844cfa00cfb71230b821319416d1669c", "filename": "compiler/rustc_trait_selection/src/solve/assembly/mod.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -105,7 +105,7 @@ pub(super) trait GoalKind<'tcx>:\n     fn probe_and_match_goal_against_assumption(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n+        assumption: ty::Binder<'tcx, ty::Clause<'tcx>>,\n         then: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> QueryResult<'tcx>,\n     ) -> QueryResult<'tcx>;\n \n@@ -115,7 +115,7 @@ pub(super) trait GoalKind<'tcx>:\n     fn consider_implied_clause(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n+        assumption: ty::Binder<'tcx, ty::Clause<'tcx>>,\n         requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n     ) -> QueryResult<'tcx> {\n         Self::probe_and_match_goal_against_assumption(ecx, goal, assumption, |ecx| {\n@@ -131,7 +131,7 @@ pub(super) trait GoalKind<'tcx>:\n     fn consider_alias_bound_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n+        assumption: ty::Binder<'tcx, ty::Clause<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         Self::probe_and_match_goal_against_assumption(ecx, goal, assumption, |ecx| {\n             ecx.validate_alias_bound_self_from_param_env(goal)\n@@ -144,7 +144,7 @@ pub(super) trait GoalKind<'tcx>:\n     fn consider_object_bound_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n+        assumption: ty::Binder<'tcx, ty::Clause<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         Self::probe_and_match_goal_against_assumption(ecx, goal, assumption, |ecx| {\n             let tcx = ecx.tcx();\n@@ -467,11 +467,13 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         candidates: &mut Vec<Candidate<'tcx>>,\n     ) {\n         for (i, assumption) in goal.param_env.caller_bounds().iter().enumerate() {\n-            match G::consider_implied_clause(self, goal, assumption, []) {\n-                Ok(result) => {\n-                    candidates.push(Candidate { source: CandidateSource::ParamEnv(i), result })\n+            if let Some(clause) = assumption.as_clause() {\n+                match G::consider_implied_clause(self, goal, clause, []) {\n+                    Ok(result) => {\n+                        candidates.push(Candidate { source: CandidateSource::ParamEnv(i), result })\n+                    }\n+                    Err(NoSolution) => (),\n                 }\n-                Err(NoSolution) => (),\n             }\n         }\n     }\n@@ -517,11 +519,13 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n         for assumption in self.tcx().item_bounds(alias_ty.def_id).subst(self.tcx(), alias_ty.substs)\n         {\n-            match G::consider_alias_bound_candidate(self, goal, assumption) {\n-                Ok(result) => {\n-                    candidates.push(Candidate { source: CandidateSource::AliasBound, result })\n+            if let Some(clause) = assumption.as_clause() {\n+                match G::consider_alias_bound_candidate(self, goal, clause) {\n+                    Ok(result) => {\n+                        candidates.push(Candidate { source: CandidateSource::AliasBound, result })\n+                    }\n+                    Err(NoSolution) => (),\n                 }\n-                Err(NoSolution) => (),\n             }\n         }\n     }\n@@ -675,18 +679,20 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             // projection predicates that we reach by elaborating the principal trait ref,\n             // since that'll cause ambiguity.\n             //\n-            // We can remove this when we have implemented intersections in responses.\n+            // We can remove this when we have implemented lifetime intersections in responses.\n             if assumption.to_opt_poly_projection_pred().is_some()\n                 && !own_bounds.contains(&assumption)\n             {\n                 continue;\n             }\n \n-            match G::consider_object_bound_candidate(self, goal, assumption) {\n-                Ok(result) => {\n-                    candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n+            if let Some(clause) = assumption.as_clause() {\n+                match G::consider_object_bound_candidate(self, goal, clause) {\n+                    Ok(result) => {\n+                        candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n+                    }\n+                    Err(NoSolution) => (),\n                 }\n-                Err(NoSolution) => (),\n             }\n         }\n     }"}, {"sha": "8303bab4c36f3aa71529bfb60365a01041df3df8", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -105,15 +105,15 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n     fn probe_and_match_goal_against_assumption(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n+        assumption: ty::Binder<'tcx, ty::Clause<'tcx>>,\n         then: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> QueryResult<'tcx>,\n     ) -> QueryResult<'tcx> {\n-        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n-            && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n+        if let Some(projection_pred) = assumption.as_projection_clause()\n+            && projection_pred.projection_def_id() == goal.predicate.def_id()\n         {\n             ecx.probe(|ecx| {\n                 let assumption_projection_pred =\n-                    ecx.instantiate_binder_with_infer(poly_projection_pred);\n+                    ecx.instantiate_binder_with_infer(projection_pred);\n                 ecx.eq(\n                     goal.param_env,\n                     goal.predicate.projection_ty,"}, {"sha": "60cf386a289f946b1a632d1647b371f1e14b5a0a", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -81,17 +81,17 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     fn probe_and_match_goal_against_assumption(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n+        assumption: ty::Binder<'tcx, ty::Clause<'tcx>>,\n         then: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> QueryResult<'tcx>,\n     ) -> QueryResult<'tcx> {\n-        if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n-            && poly_trait_pred.def_id() == goal.predicate.def_id()\n-            && poly_trait_pred.polarity() == goal.predicate.polarity\n+        if let Some(trait_clause) = assumption.as_trait_clause()\n+            && trait_clause.def_id() == goal.predicate.def_id()\n+            && trait_clause.polarity() == goal.predicate.polarity\n         {\n             // FIXME: Constness\n             ecx.probe(|ecx| {\n                 let assumption_trait_pred =\n-                    ecx.instantiate_binder_with_infer(poly_trait_pred);\n+                    ecx.instantiate_binder_with_infer(trait_clause);\n                 ecx.eq(\n                     goal.param_env,\n                     goal.predicate.trait_ref,"}, {"sha": "ff7e91d3ec3056e2bb9639411d814c13f4ee4ba8", "filename": "library/core/src/ptr/unique.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/library%2Fcore%2Fsrc%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/library%2Fcore%2Fsrc%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Funique.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -32,6 +32,8 @@ use crate::ptr::NonNull;\n )]\n #[doc(hidden)]\n #[repr(transparent)]\n+// Lang item used experimentally by Miri to define the semantics of `Unique`.\n+#[cfg_attr(not(bootstrap), lang = \"ptr_unique\")]\n pub struct Unique<T: ?Sized> {\n     pointer: NonNull<T>,\n     // NOTE: this marker has no consequences for variance, but is necessary"}, {"sha": "3edf9d747ce895f46e99935507a174817f56fb4d", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -47,9 +47,9 @@ use buffer::Buffer;\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct BufReader<R> {\n-    inner: R,\n+pub struct BufReader<R: ?Sized> {\n     buf: Buffer,\n+    inner: R,\n }\n \n impl<R: Read> BufReader<R> {\n@@ -95,7 +95,7 @@ impl<R: Read> BufReader<R> {\n     }\n }\n \n-impl<R> BufReader<R> {\n+impl<R: ?Sized> BufReader<R> {\n     /// Gets a reference to the underlying reader.\n     ///\n     /// It is inadvisable to directly read from the underlying reader.\n@@ -213,7 +213,10 @@ impl<R> BufReader<R> {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_inner(self) -> R {\n+    pub fn into_inner(self) -> R\n+    where\n+        R: Sized,\n+    {\n         self.inner\n     }\n \n@@ -226,13 +229,13 @@ impl<R> BufReader<R> {\n \n // This is only used by a test which asserts that the initialization-tracking is correct.\n #[cfg(test)]\n-impl<R> BufReader<R> {\n+impl<R: ?Sized> BufReader<R> {\n     pub fn initialized(&self) -> usize {\n         self.buf.initialized()\n     }\n }\n \n-impl<R: Seek> BufReader<R> {\n+impl<R: ?Sized + Seek> BufReader<R> {\n     /// Seeks relative to the current position. If the new position lies within the buffer,\n     /// the buffer will not be flushed, allowing for more efficient seeks.\n     /// This method does not return the location of the underlying reader, so the caller\n@@ -257,7 +260,7 @@ impl<R: Seek> BufReader<R> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<R: Read> Read for BufReader<R> {\n+impl<R: ?Sized + Read> Read for BufReader<R> {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         // If we don't have any buffered data and we're doing a massive read\n         // (larger than our internal buffer), bypass our internal buffer\n@@ -371,7 +374,7 @@ impl<R: Read> Read for BufReader<R> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<R: Read> BufRead for BufReader<R> {\n+impl<R: ?Sized + Read> BufRead for BufReader<R> {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> {\n         self.buf.fill_buf(&mut self.inner)\n     }\n@@ -384,11 +387,11 @@ impl<R: Read> BufRead for BufReader<R> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<R> fmt::Debug for BufReader<R>\n where\n-    R: fmt::Debug,\n+    R: ?Sized + fmt::Debug,\n {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"BufReader\")\n-            .field(\"reader\", &self.inner)\n+            .field(\"reader\", &&self.inner)\n             .field(\n                 \"buffer\",\n                 &format_args!(\"{}/{}\", self.buf.filled() - self.buf.pos(), self.capacity()),\n@@ -398,7 +401,7 @@ where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<R: Seek> Seek for BufReader<R> {\n+impl<R: ?Sized + Seek> Seek for BufReader<R> {\n     /// Seek to an offset, in bytes, in the underlying reader.\n     ///\n     /// The position used for seeking with <code>[SeekFrom::Current]\\(_)</code> is the\n@@ -491,7 +494,7 @@ impl<R: Seek> Seek for BufReader<R> {\n     }\n }\n \n-impl<T> SizeHint for BufReader<T> {\n+impl<T: ?Sized> SizeHint for BufReader<T> {\n     #[inline]\n     fn lower_bound(&self) -> usize {\n         SizeHint::lower_bound(self.get_ref()) + self.buffer().len()"}, {"sha": "0e2450655e5bf0741158f751bfcf09a9718754bd", "filename": "library/std/src/io/buffered/bufwriter.rs", "status": "modified", "additions": 70, "deletions": 68, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -67,8 +67,7 @@ use crate::ptr;\n /// [`TcpStream`]: crate::net::TcpStream\n /// [`flush`]: BufWriter::flush\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct BufWriter<W: Write> {\n-    inner: W,\n+pub struct BufWriter<W: ?Sized + Write> {\n     // The buffer. Avoid using this like a normal `Vec` in common code paths.\n     // That is, don't use `buf.push`, `buf.extend_from_slice`, or any other\n     // methods that require bounds checking or the like. This makes an enormous\n@@ -78,6 +77,7 @@ pub struct BufWriter<W: Write> {\n     // write the buffered data a second time in BufWriter's destructor. This\n     // flag tells the Drop impl if it should skip the flush.\n     panicked: bool,\n+    inner: W,\n }\n \n impl<W: Write> BufWriter<W> {\n@@ -115,6 +115,69 @@ impl<W: Write> BufWriter<W> {\n         BufWriter { inner, buf: Vec::with_capacity(capacity), panicked: false }\n     }\n \n+    /// Unwraps this `BufWriter<W>`, returning the underlying writer.\n+    ///\n+    /// The buffer is written out before returning the writer.\n+    ///\n+    /// # Errors\n+    ///\n+    /// An [`Err`] will be returned if an error occurs while flushing the buffer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // unwrap the TcpStream and flush the buffer\n+    /// let stream = buffer.into_inner().unwrap();\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n+        match self.flush_buf() {\n+            Err(e) => Err(IntoInnerError::new(self, e)),\n+            Ok(()) => Ok(self.into_parts().0),\n+        }\n+    }\n+\n+    /// Disassembles this `BufWriter<W>`, returning the underlying writer, and any buffered but\n+    /// unwritten data.\n+    ///\n+    /// If the underlying writer panicked, it is not known what portion of the data was written.\n+    /// In this case, we return `WriterPanicked` for the buffered data (from which the buffer\n+    /// contents can still be recovered).\n+    ///\n+    /// `into_parts` makes no attempt to flush data and cannot fail.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::{BufWriter, Write};\n+    ///\n+    /// let mut buffer = [0u8; 10];\n+    /// let mut stream = BufWriter::new(buffer.as_mut());\n+    /// write!(stream, \"too much data\").unwrap();\n+    /// stream.flush().expect_err(\"it doesn't fit\");\n+    /// let (recovered_writer, buffered_data) = stream.into_parts();\n+    /// assert_eq!(recovered_writer.len(), 0);\n+    /// assert_eq!(&buffered_data.unwrap(), b\"ata\");\n+    /// ```\n+    #[stable(feature = \"bufwriter_into_parts\", since = \"1.56.0\")]\n+    pub fn into_parts(mut self) -> (W, Result<Vec<u8>, WriterPanicked>) {\n+        let buf = mem::take(&mut self.buf);\n+        let buf = if !self.panicked { Ok(buf) } else { Err(WriterPanicked { buf }) };\n+\n+        // SAFETY: forget(self) prevents double dropping inner\n+        let inner = unsafe { ptr::read(&self.inner) };\n+        mem::forget(self);\n+\n+        (inner, buf)\n+    }\n+}\n+\n+impl<W: ?Sized + Write> BufWriter<W> {\n     /// Send data in our local buffer into the inner writer, looping as\n     /// necessary until either it's all been sent or an error occurs.\n     ///\n@@ -284,67 +347,6 @@ impl<W: Write> BufWriter<W> {\n         self.buf.capacity()\n     }\n \n-    /// Unwraps this `BufWriter<W>`, returning the underlying writer.\n-    ///\n-    /// The buffer is written out before returning the writer.\n-    ///\n-    /// # Errors\n-    ///\n-    /// An [`Err`] will be returned if an error occurs while flushing the buffer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufWriter;\n-    /// use std::net::TcpStream;\n-    ///\n-    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n-    ///\n-    /// // unwrap the TcpStream and flush the buffer\n-    /// let stream = buffer.into_inner().unwrap();\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n-        match self.flush_buf() {\n-            Err(e) => Err(IntoInnerError::new(self, e)),\n-            Ok(()) => Ok(self.into_parts().0),\n-        }\n-    }\n-\n-    /// Disassembles this `BufWriter<W>`, returning the underlying writer, and any buffered but\n-    /// unwritten data.\n-    ///\n-    /// If the underlying writer panicked, it is not known what portion of the data was written.\n-    /// In this case, we return `WriterPanicked` for the buffered data (from which the buffer\n-    /// contents can still be recovered).\n-    ///\n-    /// `into_parts` makes no attempt to flush data and cannot fail.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::io::{BufWriter, Write};\n-    ///\n-    /// let mut buffer = [0u8; 10];\n-    /// let mut stream = BufWriter::new(buffer.as_mut());\n-    /// write!(stream, \"too much data\").unwrap();\n-    /// stream.flush().expect_err(\"it doesn't fit\");\n-    /// let (recovered_writer, buffered_data) = stream.into_parts();\n-    /// assert_eq!(recovered_writer.len(), 0);\n-    /// assert_eq!(&buffered_data.unwrap(), b\"ata\");\n-    /// ```\n-    #[stable(feature = \"bufwriter_into_parts\", since = \"1.56.0\")]\n-    pub fn into_parts(mut self) -> (W, Result<Vec<u8>, WriterPanicked>) {\n-        let buf = mem::take(&mut self.buf);\n-        let buf = if !self.panicked { Ok(buf) } else { Err(WriterPanicked { buf }) };\n-\n-        // SAFETY: forget(self) prevents double dropping inner\n-        let inner = unsafe { ptr::read(&self.inner) };\n-        mem::forget(self);\n-\n-        (inner, buf)\n-    }\n-\n     // Ensure this function does not get inlined into `write`, so that it\n     // remains inlineable and its common path remains as short as possible.\n     // If this function ends up being called frequently relative to `write`,\n@@ -511,7 +513,7 @@ impl fmt::Debug for WriterPanicked {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> Write for BufWriter<W> {\n+impl<W: ?Sized + Write> Write for BufWriter<W> {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         // Use < instead of <= to avoid a needless trip through the buffer in some cases.\n@@ -640,20 +642,20 @@ impl<W: Write> Write for BufWriter<W> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> fmt::Debug for BufWriter<W>\n+impl<W: ?Sized + Write> fmt::Debug for BufWriter<W>\n where\n     W: fmt::Debug,\n {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"BufWriter\")\n-            .field(\"writer\", &self.inner)\n+            .field(\"writer\", &&self.inner)\n             .field(\"buffer\", &format_args!(\"{}/{}\", self.buf.len(), self.buf.capacity()))\n             .finish()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write + Seek> Seek for BufWriter<W> {\n+impl<W: ?Sized + Write + Seek> Seek for BufWriter<W> {\n     /// Seek to the offset, in bytes, in the underlying writer.\n     ///\n     /// Seeking always writes out the internal buffer before seeking.\n@@ -664,7 +666,7 @@ impl<W: Write + Seek> Seek for BufWriter<W> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> Drop for BufWriter<W> {\n+impl<W: ?Sized + Write> Drop for BufWriter<W> {\n     fn drop(&mut self) {\n         if !self.panicked {\n             // dtors should not panic, so we ignore a failed flush"}, {"sha": "3d4ae7041932255181e9ed06ca456b50862c5c75", "filename": "library/std/src/io/buffered/linewriter.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewriter.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -64,7 +64,7 @@ use crate::io::{self, buffered::LineWriterShim, BufWriter, IntoInnerError, IoSli\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct LineWriter<W: Write> {\n+pub struct LineWriter<W: ?Sized + Write> {\n     inner: BufWriter<W>,\n }\n \n@@ -109,27 +109,6 @@ impl<W: Write> LineWriter<W> {\n         LineWriter { inner: BufWriter::with_capacity(capacity, inner) }\n     }\n \n-    /// Gets a reference to the underlying writer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::File;\n-    /// use std::io::LineWriter;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let file = File::create(\"poem.txt\")?;\n-    ///     let file = LineWriter::new(file);\n-    ///\n-    ///     let reference = file.get_ref();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_ref(&self) -> &W {\n-        self.inner.get_ref()\n-    }\n-\n     /// Gets a mutable reference to the underlying writer.\n     ///\n     /// Caution must be taken when calling methods on the mutable reference\n@@ -184,8 +163,31 @@ impl<W: Write> LineWriter<W> {\n     }\n }\n \n+impl<W: ?Sized + Write> LineWriter<W> {\n+    /// Gets a reference to the underlying writer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// use std::io::LineWriter;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let file = File::create(\"poem.txt\")?;\n+    ///     let file = LineWriter::new(file);\n+    ///\n+    ///     let reference = file.get_ref();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_ref(&self) -> &W {\n+        self.inner.get_ref()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> Write for LineWriter<W> {\n+impl<W: ?Sized + Write> Write for LineWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         LineWriterShim::new(&mut self.inner).write(buf)\n     }\n@@ -216,7 +218,7 @@ impl<W: Write> Write for LineWriter<W> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> fmt::Debug for LineWriter<W>\n+impl<W: ?Sized + Write> fmt::Debug for LineWriter<W>\n where\n     W: fmt::Debug,\n {"}, {"sha": "f2a55da05b22eb5368b33403580c7b81d7242027", "filename": "library/std/src/io/buffered/linewritershim.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewritershim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewritershim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewritershim.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -11,11 +11,11 @@ use crate::sys_common::memchr;\n /// `BufWriters` to be temporarily given line-buffering logic; this is what\n /// enables Stdout to be alternately in line-buffered or block-buffered mode.\n #[derive(Debug)]\n-pub struct LineWriterShim<'a, W: Write> {\n+pub struct LineWriterShim<'a, W: ?Sized + Write> {\n     buffer: &'a mut BufWriter<W>,\n }\n \n-impl<'a, W: Write> LineWriterShim<'a, W> {\n+impl<'a, W: ?Sized + Write> LineWriterShim<'a, W> {\n     pub fn new(buffer: &'a mut BufWriter<W>) -> Self {\n         Self { buffer }\n     }\n@@ -49,7 +49,7 @@ impl<'a, W: Write> LineWriterShim<'a, W> {\n     }\n }\n \n-impl<'a, W: Write> Write for LineWriterShim<'a, W> {\n+impl<'a, W: ?Sized + Write> Write for LineWriterShim<'a, W> {\n     /// Write some data into this BufReader with line buffering. This means\n     /// that, if any newlines are present in the data, the data up to the last\n     /// newline is sent directly to the underlying writer, and data after it"}, {"sha": "420fc4007050b256aa6d537c0b8d076693a9bc40", "filename": "library/std/src/io/copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -86,7 +86,7 @@ impl<W: Write + ?Sized> BufferedCopySpec for W {\n     }\n }\n \n-impl<I: Write> BufferedCopySpec for BufWriter<I> {\n+impl<I: ?Sized + Write> BufferedCopySpec for BufWriter<I> {\n     fn copy_to<R: Read + ?Sized>(reader: &mut R, writer: &mut Self) -> Result<u64> {\n         if writer.capacity() < DEFAULT_BUF_SIZE {\n             return stack_buffer_copy(reader, writer);"}, {"sha": "173233d7150b2719613a64a0974620e615d5530e", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -2754,7 +2754,7 @@ trait SizeHint {\n     }\n }\n \n-impl<T> SizeHint for T {\n+impl<T: ?Sized> SizeHint for T {\n     #[inline]\n     default fn lower_bound(&self) -> usize {\n         0"}, {"sha": "7d49bbdcbe063bde033f156cc9711c6fde8a80b4", "filename": "library/std/src/sys/unix/kernel_copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -466,7 +466,7 @@ impl<T: CopyRead> CopyRead for Take<T> {\n     }\n }\n \n-impl<T: CopyRead> CopyRead for BufReader<T> {\n+impl<T: ?Sized + CopyRead> CopyRead for BufReader<T> {\n     fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n         let buf = self.buffer();\n         let buf = &buf[0..min(buf.len(), outer_limit.try_into().unwrap_or(usize::MAX))];\n@@ -495,7 +495,7 @@ impl<T: CopyRead> CopyRead for BufReader<T> {\n     }\n }\n \n-impl<T: CopyWrite> CopyWrite for BufWriter<T> {\n+impl<T: ?Sized + CopyWrite> CopyWrite for BufWriter<T> {\n     fn properties(&self) -> CopyParams {\n         self.get_ref().properties()\n     }"}, {"sha": "010015667f7a2a020a5ea70a336ad3a5e908bf3c", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -344,6 +344,29 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n                 }\n             }\n \n+            #[cfg(target_os = \"netbsd\")]\n+            {\n+                unsafe {\n+                    let set = libc::_cpuset_create();\n+                    if !set.is_null() {\n+                        let mut count: usize = 0;\n+                        if libc::pthread_getaffinity_np(libc::pthread_self(), libc::_cpuset_size(set), set) == 0 {\n+                            for i in 0..u64::MAX {\n+                                match libc::_cpuset_isset(i, set) {\n+                                    -1 => break,\n+                                    0 => continue,\n+                                    _ => count = count + 1,\n+                                }\n+                            }\n+                        }\n+                        libc::_cpuset_destroy(set);\n+                        if let Some(count) = NonZeroUsize::new(count) {\n+                            return Ok(count);\n+                        }\n+                    }\n+                }\n+            }\n+\n             let mut cpus: libc::c_uint = 0;\n             let mut cpus_size = crate::mem::size_of_val(&cpus);\n "}, {"sha": "4b607d5057450943c86c1887603b5dc1db24257f", "filename": "tests/codegen/enum-debug-niche-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/tests%2Fcodegen%2Fenum-debug-niche-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/tests%2Fcodegen%2Fenum-debug-niche-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fenum-debug-niche-2.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -7,8 +7,8 @@\n // compile-flags: -g -C no-prepopulate-passes\n \n // CHECK: {{.*}}DICompositeType{{.*}}tag: DW_TAG_variant_part,{{.*}}size: 32,{{.*}}\n-// CHECK: {{.*}}DIDerivedType{{.*}}tag: DW_TAG_member,{{.*}}name: \"Placeholder\",{{.*}}extraData: i64 4294967295{{[,)].*}}\n-// CHECK: {{.*}}DIDerivedType{{.*}}tag: DW_TAG_member,{{.*}}name: \"Error\",{{.*}}extraData: i64 0{{[,)].*}}\n+// CHECK: {{.*}}DIDerivedType{{.*}}tag: DW_TAG_member,{{.*}}name: \"Placeholder\",{{.*}}extraData: i128 4294967295{{[,)].*}}\n+// CHECK: {{.*}}DIDerivedType{{.*}}tag: DW_TAG_member,{{.*}}name: \"Error\",{{.*}}extraData: i128 0{{[,)].*}}\n \n #![feature(never_type)]\n "}, {"sha": "f50d360ac9f338406c40411fd0980399da083137", "filename": "tests/codegen/enum-u128.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/tests%2Fcodegen%2Fenum-u128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/tests%2Fcodegen%2Fenum-u128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fenum-u128.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -0,0 +1,27 @@\n+// This tests that debug info for \"c-like\" 128bit enums is properly emitted.\n+// This is ignored for the fallback mode on MSVC due to problems with PDB.\n+\n+//\n+// ignore-msvc\n+\n+// compile-flags: -g -C no-prepopulate-passes\n+\n+// CHECK-LABEL: @main\n+// CHECK: {{.*}}DICompositeType{{.*}}tag: DW_TAG_enumeration_type,{{.*}}name: \"Foo\",{{.*}}flags: DIFlagEnumClass,{{.*}}\n+// CHECK: {{.*}}DIEnumerator{{.*}}name: \"Lo\",{{.*}}value: 0,{{.*}}\n+// CHECK: {{.*}}DIEnumerator{{.*}}name: \"Hi\",{{.*}}value: 18446744073709551616,{{.*}}\n+// CHECK: {{.*}}DIEnumerator{{.*}}name: \"Bar\",{{.*}}value: 18446745000000000123,{{.*}}\n+\n+#![allow(incomplete_features)]\n+#![feature(repr128)]\n+\n+#[repr(u128)]\n+pub enum Foo {\n+    Lo,\n+    Hi = 1 << 64,\n+    Bar = 18_446_745_000_000_000_123,\n+}\n+\n+pub fn main() {\n+    let foo = Foo::Bar;\n+}"}, {"sha": "d1bf3d46a7c7abc96adb79ff7b526b3b58326917", "filename": "tests/ui/mir/mir_alignment_check.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/tests%2Fui%2Fmir%2Fmir_alignment_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/tests%2Fui%2Fmir%2Fmir_alignment_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmir%2Fmir_alignment_check.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -1,5 +1,6 @@\n // run-fail\n // ignore-wasm32-bare: No panic messages\n+// ignore-i686-pc-windows-msvc: #112480\n // compile-flags: -C debug-assertions\n // error-pattern: misaligned pointer dereference: address must be a multiple of 0x4 but is\n "}, {"sha": "56388c1047e9adff8280561bafa71ae64d7491ba", "filename": "tests/ui/mir/mir_alignment_check_i686-pc-windows-msvc.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/670a0edaa9d80683df8db81554890710e79f8024/tests%2Fui%2Fmir%2Fmir_alignment_check_i686-pc-windows-msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/670a0edaa9d80683df8db81554890710e79f8024/tests%2Fui%2Fmir%2Fmir_alignment_check_i686-pc-windows-msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmir%2Fmir_alignment_check_i686-pc-windows-msvc.rs?ref=670a0edaa9d80683df8db81554890710e79f8024", "patch": "@@ -0,0 +1,21 @@\n+// run-pass\n+// only-i686-pc-windows-msvc\n+// compile-flags: -Copt-level=0 -Cdebug-assertions=yes\n+\n+// MSVC isn't sure if on 32-bit Windows its u64 type is 8-byte-aligned or 4-byte-aligned.\n+// So this test ensures that on i686-pc-windows-msvc, we do not insert a runtime check\n+// that will fail on dereferencing of a pointer to u64 which is not 8-byte-aligned but is\n+// 4-byte-aligned.\n+\n+#![feature(strict_provenance)]\n+\n+fn main() {\n+    let mut x = [0u64; 2];\n+    let ptr: *mut u8 = x.as_mut_ptr().cast::<u8>();\n+    unsafe {\n+        let misaligned = ptr.add(4).cast::<u64>();\n+        assert!(misaligned.addr() % 8 != 0);\n+        assert!(misaligned.addr() % 4 == 0);\n+        *misaligned = 42;\n+    }\n+}"}]}