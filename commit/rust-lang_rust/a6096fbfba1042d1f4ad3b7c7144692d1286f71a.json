{"sha": "a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MDk2ZmJmYmExMDQyZDFmNGFkM2I3YzcxNDQ2OTJkMTI4NmY3MWE=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-08-09T14:06:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-08-09T14:06:14Z"}, "message": "Merge pull request #292 from oli-obk/static_alloc_ids\n\nPrepare for splitting off static alloc ids from local alloc ids", "tree": {"sha": "d61a90ad0e464e24ef68d3da20df486ffb3ea9d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d61a90ad0e464e24ef68d3da20df486ffb3ea9d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "html_url": "https://github.com/rust-lang/rust/commit/a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14e8f500af85da93e342dced154a0581ee9237ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/14e8f500af85da93e342dced154a0581ee9237ed", "html_url": "https://github.com/rust-lang/rust/commit/14e8f500af85da93e342dced154a0581ee9237ed"}, {"sha": "91db25bdef31781d9ef6878c5c5176975430c703", "url": "https://api.github.com/repos/rust-lang/rust/commits/91db25bdef31781d9ef6878c5c5176975430c703", "html_url": "https://github.com/rust-lang/rust/commit/91db25bdef31781d9ef6878c5c5176975430c703"}], "stats": {"total": 830, "additions": 413, "deletions": 417}, "files": [{"sha": "26263a854dd036472f41f365fe12da2ff6ce629e", "filename": "miri/fn_call.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/miri%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/miri%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ffn_call.rs?ref=a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "patch": "@@ -16,14 +16,14 @@ use super::{\n \n use tls::MemoryExt;\n \n-use super::memory::Kind;\n+use super::memory::MemoryKind;\n \n pub trait EvalContextExt<'tcx> {\n     fn call_c_abi(\n         &mut self,\n         def_id: DefId,\n         arg_operands: &[mir::Operand<'tcx>],\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n         dest_block: mir::BasicBlock,\n     ) -> EvalResult<'tcx>;\n@@ -33,7 +33,7 @@ pub trait EvalContextExt<'tcx> {\n     fn call_missing_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        destination: Option<(Lvalue, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         sig: ty::FnSig<'tcx>,\n         path: String,\n@@ -42,7 +42,7 @@ pub trait EvalContextExt<'tcx> {\n     fn eval_fn_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        destination: Option<(Lvalue, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n         sig: ty::FnSig<'tcx>,\n@@ -53,7 +53,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n     fn eval_fn_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        destination: Option<(Lvalue, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n         sig: ty::FnSig<'tcx>,\n@@ -89,7 +89,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n         &mut self,\n         def_id: DefId,\n         arg_operands: &[mir::Operand<'tcx>],\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n         dest_block: mir::BasicBlock,\n     ) -> EvalResult<'tcx> {\n@@ -113,15 +113,15 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n                     let align = self.memory.pointer_size();\n-                    let ptr = self.memory.allocate(size, align, Kind::C.into())?;\n+                    let ptr = self.memory.allocate(size, align, MemoryKind::C.into())?;\n                     self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n                 }\n             }\n \n             \"free\" => {\n                 let ptr = args[0].into_ptr(&mut self.memory)?;\n                 if !ptr.is_null()? {\n-                    self.memory.deallocate(ptr.to_ptr()?, None, Kind::C.into())?;\n+                    self.memory.deallocate(ptr.to_ptr()?, None, MemoryKind::C.into())?;\n                 }\n             }\n \n@@ -251,7 +251,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 }\n                 if let Some(old) = success {\n                     if let Some(var) = old {\n-                        self.memory.deallocate(var, None, Kind::Env.into())?;\n+                        self.memory.deallocate(var, None, MemoryKind::Env.into())?;\n                     }\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n@@ -274,12 +274,12 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 }\n                 if let Some((name, value)) = new {\n                     // +1 for the null terminator\n-                    let value_copy = self.memory.allocate((value.len() + 1) as u64, 1, Kind::Env.into())?;\n+                    let value_copy = self.memory.allocate((value.len() + 1) as u64, 1, MemoryKind::Env.into())?;\n                     self.memory.write_bytes(value_copy.into(), &value)?;\n                     let trailing_zero_ptr = value_copy.offset(value.len() as u64, &self)?.into();\n                     self.memory.write_bytes(trailing_zero_ptr, &[0])?;\n                     if let Some(var) = self.machine_data.env_vars.insert(name.to_owned(), value_copy) {\n-                        self.memory.deallocate(var, None, Kind::Env.into())?;\n+                        self.memory.deallocate(var, None, MemoryKind::Env.into())?;\n                     }\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n@@ -317,7 +317,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             }\n \n             \"sysconf\" => {\n-                let name = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                let c_int = self.operand_ty(&arg_operands[0]);\n+                let name = self.value_to_primval(args[0], c_int)?.to_u64()?;\n                 trace!(\"sysconf() called with name {}\", name);\n                 // cache the sysconf integers via miri's global cache\n                 let paths = &[\n@@ -329,8 +330,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     if let Ok(instance) = self.resolve_path(path) {\n                         let cid = GlobalId { instance, promoted: None };\n                         // compute global if not cached\n-                        let val = match self.globals.get(&cid).map(|glob| glob.value) {\n-                            Some(value) => self.value_to_primval(value, usize)?.to_u64()?,\n+                        let val = match self.globals.get(&cid).cloned() {\n+                            Some(ptr) => self.value_to_primval(Value::ByRef(ptr), c_int)?.to_u64()?,\n                             None => eval_body_as_primval(self.tcx, instance)?.0.to_u64()?,\n                         };\n                         if val == name {\n@@ -459,7 +460,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n     fn call_missing_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        destination: Option<(Lvalue, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         sig: ty::FnSig<'tcx>,\n         path: String,\n@@ -500,7 +501,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = self.memory.allocate(size, align, Kind::Rust.into())?;\n+                let ptr = self.memory.allocate(size, align, MemoryKind::Rust.into())?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n             \"alloc::heap::::__rust_alloc_zeroed\" => {\n@@ -512,7 +513,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = self.memory.allocate(size, align, Kind::Rust.into())?;\n+                let ptr = self.memory.allocate(size, align, MemoryKind::Rust.into())?;\n                 self.memory.write_repeat(ptr.into(), 0, size)?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n@@ -526,7 +527,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                self.memory.deallocate(ptr, Some((old_size, align)), Kind::Rust.into())?;\n+                self.memory.deallocate(ptr, Some((old_size, align)), MemoryKind::Rust.into())?;\n             }\n             \"alloc::heap::::__rust_realloc\" => {\n                 let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n@@ -543,7 +544,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 if !new_align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(new_align));\n                 }\n-                let new_ptr = self.memory.reallocate(ptr, old_size, old_align, new_size, new_align, Kind::Rust.into())?;\n+                let new_ptr = self.memory.reallocate(ptr, old_size, old_align, new_size, new_align, MemoryKind::Rust.into())?;\n                 self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n             }\n "}, {"sha": "5a609a569bb0b8e47d70c79a9faa926994a0ad39", "filename": "miri/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/miri%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/miri%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fintrinsic.rs?ref=a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "patch": "@@ -8,7 +8,7 @@ use rustc_miri::interpret::{\n     Lvalue, LvalueExtra,\n     PrimVal, PrimValKind, Value, Pointer,\n     HasMemory,\n-    EvalContext,\n+    EvalContext, PtrAndAlign,\n };\n \n use helpers::EvalContextExt as HelperEvalContextExt;\n@@ -18,7 +18,7 @@ pub trait EvalContextExt<'tcx> {\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         args: &[mir::Operand<'tcx>],\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n         dest_layout: &'tcx Layout,\n         target: mir::BasicBlock,\n@@ -30,7 +30,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         args: &[mir::Operand<'tcx>],\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n         dest_layout: &'tcx Layout,\n         target: mir::BasicBlock,\n@@ -266,10 +266,10 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let size = self.type_size(dest_ty)?.expect(\"cannot zero unsized value\");\n                 let init = |this: &mut Self, val: Value| {\n                     let zero_val = match val {\n-                        Value::ByRef { ptr, aligned } => {\n+                        Value::ByRef(PtrAndAlign { ptr, .. }) => {\n                             // These writes have no alignment restriction anyway.\n                             this.memory.write_repeat(ptr, 0, size)?;\n-                            Value::ByRef { ptr, aligned }\n+                            val\n                         },\n                         // TODO(solson): Revisit this, it's fishy to check for Undef here.\n                         Value::ByVal(PrimVal::Undef) => match this.ty_to_primval_kind(dest_ty) {\n@@ -289,9 +289,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 };\n                 match dest {\n                     Lvalue::Local { frame, local } => self.modify_local(frame, local, init)?,\n-                    Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned: true } => self.memory.write_repeat(ptr, 0, size)?,\n+                    Lvalue::Ptr { ptr: PtrAndAlign { ptr, aligned: true }, extra: LvalueExtra::None } => self.memory.write_repeat(ptr, 0, size)?,\n                     Lvalue::Ptr { .. } => bug!(\"init intrinsic tried to write to fat or unaligned ptr target\"),\n-                    Lvalue::Global(cid) => self.modify_global(cid, init)?,\n                 }\n             }\n \n@@ -457,19 +456,18 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let size = dest_layout.size(&self.tcx.data_layout).bytes();\n                 let uninit = |this: &mut Self, val: Value| {\n                     match val {\n-                        Value::ByRef { ptr, aligned } => {\n+                        Value::ByRef(PtrAndAlign { ptr, .. }) => {\n                             this.memory.mark_definedness(ptr, size, false)?;\n-                            Ok(Value::ByRef { ptr, aligned })\n+                            Ok(val)\n                         },\n                         _ => Ok(Value::ByVal(PrimVal::Undef)),\n                     }\n                 };\n                 match dest {\n                     Lvalue::Local { frame, local } => self.modify_local(frame, local, uninit)?,\n-                    Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned: true } =>\n+                    Lvalue::Ptr { ptr: PtrAndAlign { ptr, aligned: true }, extra: LvalueExtra::None } =>\n                         self.memory.mark_definedness(ptr, size, false)?,\n                     Lvalue::Ptr { .. } => bug!(\"uninit intrinsic tried to write to fat or unaligned ptr target\"),\n-                    Lvalue::Global(cid) => self.modify_global(cid, uninit)?,\n                 }\n             }\n "}, {"sha": "c93b938e9bd5a3fecdcb6171cba2595fcb133e43", "filename": "miri/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/miri%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/miri%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flib.rs?ref=a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "patch": "@@ -71,7 +71,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n             // Return value\n             let size = ecx.tcx.data_layout.pointer_size.bytes();\n             let align = ecx.tcx.data_layout.pointer_align.abi();\n-            let ret_ptr = ecx.memory_mut().allocate(size, align, Kind::Stack)?;\n+            let ret_ptr = ecx.memory_mut().allocate(size, align, MemoryKind::Stack)?;\n             cleanup_ptr = Some(ret_ptr);\n \n             // Push our stack frame\n@@ -114,7 +114,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n         while ecx.step()? {}\n         ecx.run_tls_dtors()?;\n         if let Some(cleanup_ptr) = cleanup_ptr {\n-            ecx.memory_mut().deallocate(cleanup_ptr, None, Kind::Stack)?;\n+            ecx.memory_mut().deallocate(cleanup_ptr, None, MemoryKind::Stack)?;\n         }\n         Ok(())\n     }\n@@ -161,13 +161,13 @@ struct MemoryData<'tcx> {\n impl<'tcx> Machine<'tcx> for Evaluator {\n     type Data = EvaluatorData;\n     type MemoryData = MemoryData<'tcx>;\n-    type MemoryKinds = memory::Kind;\n+    type MemoryKinds = memory::MemoryKind;\n \n     /// Returns Ok() when the function was handled, fail otherwise\n     fn eval_fn_call<'a>(\n         ecx: &mut EvalContext<'a, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        destination: Option<(Lvalue, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n         sig: ty::FnSig<'tcx>,\n@@ -179,7 +179,7 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n         ecx: &mut rustc_miri::interpret::EvalContext<'a, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[mir::Operand<'tcx>],\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: ty::Ty<'tcx>,\n         dest_layout: &'tcx Layout,\n         target: mir::BasicBlock,\n@@ -198,8 +198,8 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n         ecx.ptr_op(bin_op, left, left_ty, right, right_ty)\n     }\n \n-    fn mark_static_initialized(m: memory::Kind) -> EvalResult<'tcx> {\n-        use memory::Kind::*;\n+    fn mark_static_initialized(m: memory::MemoryKind) -> EvalResult<'tcx> {\n+        use memory::MemoryKind::*;\n         match m {\n             // FIXME: This could be allowed, but not for env vars set during miri execution\n             Env => err!(Unimplemented(\"statics can't refer to env vars\".to_owned())),\n@@ -218,7 +218,7 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n             Ok(PrimVal::Bytes(align.into()))\n         } else {\n             ecx.memory\n-                .allocate(size, align, Kind::Machine(memory::Kind::Rust))\n+                .allocate(size, align, MemoryKind::Machine(memory::MemoryKind::Rust))\n                 .map(PrimVal::Ptr)\n         }\n     }"}, {"sha": "110540c0cf1d2555c7e9436ae3ffb7d7272d3f17", "filename": "miri/memory.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/miri%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/miri%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fmemory.rs?ref=a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "patch": "@@ -1,6 +1,6 @@\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n-pub enum Kind {\n+pub enum MemoryKind {\n     /// Error if deallocated any other way than `rust_deallocate`\n     Rust,\n     /// Error if deallocated any other way than `free`\n@@ -9,8 +9,8 @@ pub enum Kind {\n     Env,\n }\n \n-impl Into<::rustc_miri::interpret::Kind<Kind>> for Kind {\n-    fn into(self) -> ::rustc_miri::interpret::Kind<Kind> {\n-        ::rustc_miri::interpret::Kind::Machine(self)\n+impl Into<::rustc_miri::interpret::MemoryKind<MemoryKind>> for MemoryKind {\n+    fn into(self) -> ::rustc_miri::interpret::MemoryKind<MemoryKind> {\n+        ::rustc_miri::interpret::MemoryKind::Machine(self)\n     }\n }"}, {"sha": "f11734a588a179d13f3e1ff0a4857043149e2149", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "patch": "@@ -7,9 +7,10 @@ use syntax::codemap::Span;\n \n use super::{\n     EvalResult, EvalError, EvalErrorKind,\n-    Global, GlobalId, Lvalue,\n+    GlobalId, Lvalue, Value,\n     PrimVal,\n-    EvalContext, StackPopCleanup,\n+    EvalContext, StackPopCleanup, PtrAndAlign,\n+    MemoryKind,\n };\n \n use rustc_const_math::ConstInt;\n@@ -30,7 +31,11 @@ pub fn eval_body_as_primval<'a, 'tcx>(\n     \n     let mir = ecx.load_mir(instance.def)?;\n     if !ecx.globals.contains_key(&cid) {\n-        ecx.globals.insert(cid, Global::uninitialized(mir.return_ty));\n+        let size = ecx.type_size_with_substs(mir.return_ty, instance.substs)?.expect(\"unsized global\");\n+        let align = ecx.type_align_with_substs(mir.return_ty, instance.substs)?;\n+        let ptr = ecx.memory.allocate(size, align, MemoryKind::UninitializedStatic)?;\n+        let aligned = !ecx.is_packed(mir.return_ty)?;\n+        ecx.globals.insert(cid, PtrAndAlign { ptr: ptr.into(), aligned });\n         let mutable = !mir.return_ty.is_freeze(\n                 ecx.tcx,\n                 ty::ParamEnv::empty(Reveal::All),\n@@ -42,18 +47,18 @@ pub fn eval_body_as_primval<'a, 'tcx>(\n         };\n         let cleanup = StackPopCleanup::MarkStatic(mutability);\n         let name = ty::tls::with(|tcx| tcx.item_path_str(instance.def_id()));\n-        trace!(\"pushing stack frame for global: {}\", name);\n+        trace!(\"const_eval: pushing stack frame for global: {}\", name);\n         ecx.push_stack_frame(\n             instance,\n             mir.span,\n             mir,\n-            Lvalue::Global(cid),\n+            Lvalue::from_ptr(ptr),\n             cleanup,\n         )?;\n \n         while ecx.step()? {}\n     }\n-    let value = ecx.globals.get(&cid).expect(\"global not cached\").value;\n+    let value = Value::ByRef(*ecx.globals.get(&cid).expect(\"global not cached\"));\n     Ok((ecx.value_to_primval(value, mir.return_ty)?, mir.return_ty))\n }\n \n@@ -132,7 +137,7 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeFunctionEvaluator {\n     fn eval_fn_call<'a>(\n         ecx: &mut EvalContext<'a, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        destination: Option<(Lvalue, mir::BasicBlock)>,\n         _arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n         _sig: ty::FnSig<'tcx>,\n@@ -168,7 +173,7 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeFunctionEvaluator {\n         _ecx: &mut EvalContext<'a, 'tcx, Self>,\n         _instance: ty::Instance<'tcx>,\n         _args: &[mir::Operand<'tcx>],\n-        _dest: Lvalue<'tcx>,\n+        _dest: Lvalue,\n         _dest_ty: Ty<'tcx>,\n         _dest_layout: &'tcx layout::Layout,\n         _target: mir::BasicBlock,"}, {"sha": "96911c10cca80c687bfd0eed3ed25db3ff30ffbb", "filename": "src/librustc_mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ferror.rs?ref=a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "patch": "@@ -139,7 +139,7 @@ impl<'tcx> Error for EvalError<'tcx> {\n             DoubleFree =>\n                 \"tried to deallocate dangling pointer\",\n             InvalidFunctionPointer =>\n-                \"tried to use an integer pointer or a dangling pointer as a function pointer\",\n+                \"tried to use a function pointer after offsetting it\",\n             InvalidBool =>\n                 \"invalid boolean value read\",\n             InvalidDiscriminant =>"}, {"sha": "fd609d5fec1c82d4f0389aa1b0430fa2bf1f8d43", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 138, "deletions": 161, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "patch": "@@ -7,7 +7,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::middle::region::CodeExtent;\n use rustc::mir;\n use rustc::traits::Reveal;\n-use rustc::ty::layout::{self, Layout, Size, Align};\n+use rustc::ty::layout::{self, Layout, Size, Align, HasDataLayout};\n use rustc::ty::subst::{Subst, Substs, Kind};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Binder};\n use rustc::traits;\n@@ -18,9 +18,9 @@ use syntax::abi::Abi;\n \n use super::{\n     EvalError, EvalResult, EvalErrorKind,\n-    Global, GlobalId, Lvalue, LvalueExtra,\n+    GlobalId, Lvalue, LvalueExtra,\n     Memory, MemoryPointer, HasMemory,\n-    Kind as MemoryKind,\n+    MemoryKind,\n     operator,\n     PrimVal, PrimValKind, Value, Pointer,\n     ValidationQuery,\n@@ -41,7 +41,7 @@ pub struct EvalContext<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     pub(crate) suspended: HashMap<DynamicLifetime, Vec<ValidationQuery<'tcx>>>,\n \n     /// Precomputed statics, constants and promoteds.\n-    pub globals: HashMap<GlobalId<'tcx>, Global<'tcx>>,\n+    pub globals: HashMap<GlobalId<'tcx>, PtrAndAlign>,\n \n     /// The virtual call stack.\n     pub(crate) stack: Vec<Frame<'tcx>>,\n@@ -78,7 +78,7 @@ pub struct Frame<'tcx> {\n     pub return_to_block: StackPopCleanup,\n \n     /// The location where the result of the current stack frame should be written to.\n-    pub return_lvalue: Lvalue<'tcx>,\n+    pub return_lvalue: Lvalue,\n \n     /// The list of locals for this stack frame, stored in order as\n     /// `[arguments..., variables..., temporaries...]`. The locals are stored as `Option<Value>`s.\n@@ -143,6 +143,25 @@ pub struct TyAndPacked<'tcx> {\n     pub packed: bool,\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub struct PtrAndAlign {\n+    pub ptr: Pointer,\n+    /// Remember whether this lvalue is *supposed* to be aligned.\n+    pub aligned: bool,\n+}\n+\n+impl PtrAndAlign {\n+    pub fn to_ptr<'tcx>(self) -> EvalResult<'tcx, MemoryPointer> {\n+        self.ptr.to_ptr()\n+    }\n+    pub fn offset<'tcx, C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n+        Ok(PtrAndAlign {\n+            ptr: self.ptr.offset(i, cx)?,\n+            aligned: self.aligned,\n+        })\n+    }\n+}\n+\n impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub fn new(\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -195,20 +214,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         self.stack.len() - 1\n     }\n \n-    /// Returns true if the current frame or any parent frame is part of a ctfe.\n-    ///\n-    /// Used to disable features in const eval, which do not have a rfc enabling\n-    /// them or which can't be written in a way that they produce the same output\n-    /// that evaluating the code at runtime would produce.\n-    pub fn const_env(&self) -> bool {\n-        for frame in self.stack.iter().rev() {\n-            if let StackPopCleanup::MarkStatic(_) = frame.return_to_block {\n-                return true;\n-            }\n-        }\n-        false\n-    }\n-\n     pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n         let ptr = self.memory.allocate_cached(s.as_bytes())?;\n         Ok(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::from_u128(s.len() as u128)))\n@@ -386,7 +391,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         self.type_align_with_substs(ty, self.substs())\n     }\n \n-    fn type_size_with_substs(\n+    pub fn type_size_with_substs(\n         &self,\n         ty: Ty<'tcx>,\n         substs: &'tcx Substs<'tcx>,\n@@ -399,7 +404,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n-    fn type_align_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, u64> {\n+    pub fn type_align_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, u64> {\n         self.type_layout_with_substs(ty, substs).map(|layout| layout.align(&self.tcx.data_layout).abi())\n     }\n \n@@ -419,7 +424,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         instance: ty::Instance<'tcx>,\n         span: codemap::Span,\n         mir: &'tcx mir::Mir<'tcx>,\n-        return_lvalue: Lvalue<'tcx>,\n+        return_lvalue: Lvalue,\n         return_to_block: StackPopCleanup,\n     ) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation += 1;\n@@ -485,31 +490,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             self.memory.set_cur_frame(cur_frame);\n         }\n         match frame.return_to_block {\n-            StackPopCleanup::MarkStatic(mutable) => if let Lvalue::Global(id) = frame.return_lvalue {\n-                let global_value = self.globals.get_mut(&id)\n-                    .expect(\"global should have been cached (static)\");\n-                match global_value.value {\n-                    // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n-                    Value::ByRef { ptr, aligned: _aligned } =>\n-                        // Alignment does not matter for this call\n-                        self.memory.mark_static_initalized(ptr.to_ptr()?.alloc_id, mutable)?,\n-                    Value::ByVal(val) => if let PrimVal::Ptr(ptr) = val {\n-                        self.memory.mark_inner_allocation(ptr.alloc_id, mutable)?;\n-                    },\n-                    Value::ByValPair(val1, val2) => {\n-                        if let PrimVal::Ptr(ptr) = val1 {\n-                            self.memory.mark_inner_allocation(ptr.alloc_id, mutable)?;\n-                        }\n-                        if let PrimVal::Ptr(ptr) = val2 {\n-                            self.memory.mark_inner_allocation(ptr.alloc_id, mutable)?;\n-                        }\n-                    },\n-                }\n-                // see comment on `initialized` field\n-                assert!(!global_value.initialized);\n-                global_value.initialized = true;\n-                assert_eq!(global_value.mutable, Mutability::Mutable);\n-                global_value.mutable = mutable;\n+            StackPopCleanup::MarkStatic(mutable) => if let Lvalue::Ptr{ ptr, .. } = frame.return_lvalue {\n+                // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n+                self.memory.mark_static_initalized(ptr.to_ptr()?.alloc_id, mutable)?\n             } else {\n                 bug!(\"StackPopCleanup::MarkStatic on: {:?}\", frame.return_lvalue);\n             },\n@@ -525,7 +508,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     pub fn deallocate_local(&mut self, local: Option<Value>) -> EvalResult<'tcx> {\n-        if let Some(Value::ByRef { ptr, aligned: _ }) = local {\n+        if let Some(Value::ByRef(ptr)) = local {\n             trace!(\"deallocating local\");\n             let ptr = ptr.to_ptr()?;\n             self.memory.dump_alloc(ptr.alloc_id);\n@@ -543,7 +526,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     pub fn assign_discr_and_fields(\n         &mut self,\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n         discr_offset: u64,\n         operands: &[mir::Operand<'tcx>],\n@@ -558,17 +541,19 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         self.memory.write_uint(discr_dest, discr_val, discr_size)?;\n \n         let dest = Lvalue::Ptr {\n-            ptr: dest_ptr.into(),\n+            ptr: PtrAndAlign {\n+                ptr: dest_ptr.into(),\n+                aligned: true,\n+            },\n             extra: LvalueExtra::DowncastVariant(variant_idx),\n-            aligned: true,\n         };\n \n         self.assign_fields(dest, dest_ty, operands)\n     }\n \n     pub fn assign_fields(\n         &mut self,\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n         operands: &[mir::Operand<'tcx>],\n     ) -> EvalResult<'tcx> {\n@@ -639,7 +624,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 self.inc_step_counter_and_check_limit(operands.len() as u64)?;\n                 use rustc::ty::layout::Layout::*;\n                 match *dest_layout {\n-                    Univariant { .. } | Array { .. } => {\n+                    Univariant { ref variant, .. } => {\n+                        self.write_maybe_aligned_mut(!variant.packed, |ecx| {\n+                            ecx.assign_fields(dest, dest_ty, operands)\n+                        })?;\n+                    }\n+\n+                    Array { .. } => {\n                         self.assign_fields(dest, dest_ty, operands)?;\n                     }\n \n@@ -686,10 +677,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         }\n                     }\n \n-                    StructWrappedNullablePointer { nndiscr, ref discrfield_source, .. } => {\n+                    StructWrappedNullablePointer { nndiscr, ref discrfield_source, ref nonnull, .. } => {\n                         if let mir::AggregateKind::Adt(_, variant, _, _) = **kind {\n                             if nndiscr == variant as u64 {\n-                                self.assign_fields(dest, dest_ty, operands)?;\n+                                self.write_maybe_aligned_mut(!nonnull.packed, |ecx| {\n+                                    ecx.assign_fields(dest, dest_ty, operands)\n+                                })?;\n                             } else {\n                                 for operand in operands {\n                                     let operand_ty = self.operand_ty(operand);\n@@ -704,7 +697,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                                 let dest = dest.offset(offset.bytes(), &self)?;\n                                 let dest_size = self.type_size(ty)?\n                                     .expect(\"bad StructWrappedNullablePointer discrfield\");\n-                                self.memory.write_int(dest, 0, dest_size)?;\n+                                self.memory.write_maybe_aligned_mut(!nonnull.packed, |mem| {\n+                                    mem.write_int(dest, 0, dest_size)\n+                                })?;\n                             }\n                         } else {\n                             bug!(\"tried to assign {:?} to Layout::RawNullablePointer\", kind);\n@@ -729,12 +724,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         self.assign_fields(dest, dest_ty, operands)?;\n                     }\n \n-                    UntaggedUnion { .. } => {\n+                    UntaggedUnion { ref variants } => {\n                         assert_eq!(operands.len(), 1);\n                         let operand = &operands[0];\n                         let value = self.eval_operand(operand)?;\n                         let value_ty = self.operand_ty(operand);\n-                        self.write_value(value, dest, value_ty)?;\n+                        self.write_maybe_aligned_mut(!variants.packed, |ecx| {\n+                            ecx.write_value(value, dest, value_ty)\n+                        })?;\n                     }\n \n                     _ => {\n@@ -778,12 +775,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let src = self.eval_lvalue(lvalue)?;\n                 // We ignore the alignment of the lvalue here -- special handling for packed structs ends\n                 // at the `&` operator.\n-                let (ptr, extra, _aligned) = self.force_allocation(src)?.to_ptr_extra_aligned();\n+                let (ptr, extra) = self.force_allocation(src)?.to_ptr_extra_aligned();\n \n                 let val = match extra {\n-                    LvalueExtra::None => ptr.to_value(),\n-                    LvalueExtra::Length(len) => ptr.to_value_with_len(len),\n-                    LvalueExtra::Vtable(vtable) => ptr.to_value_with_vtable(vtable),\n+                    LvalueExtra::None => ptr.ptr.to_value(),\n+                    LvalueExtra::Length(len) => ptr.ptr.to_value_with_len(len),\n+                    LvalueExtra::Vtable(vtable) => ptr.ptr.to_value_with_vtable(vtable),\n                     LvalueExtra::DowncastVariant(..) =>\n                         bug!(\"attempted to take a reference to an enum downcast lvalue\"),\n                 };\n@@ -1046,15 +1043,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     Literal::Item { def_id, substs } => {\n                         let instance = self.resolve_associated_const(def_id, substs);\n                         let cid = GlobalId { instance, promoted: None };\n-                        self.globals.get(&cid).expect(\"static/const not cached\").value\n+                        Value::ByRef(*self.globals.get(&cid).expect(\"static/const not cached\"))\n                     }\n \n                     Literal::Promoted { index } => {\n                         let cid = GlobalId {\n                             instance: self.frame().instance,\n                             promoted: Some(index),\n                         };\n-                        self.globals.get(&cid).expect(\"promoted not cached\").value\n+                        Value::ByRef(*self.globals.get(&cid).expect(\"promoted not cached\"))\n                     }\n                 };\n \n@@ -1063,6 +1060,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n+    pub fn read_global_as_value(&self, gid: GlobalId) -> Value {\n+        Value::ByRef(*self.globals.get(&gid).expect(\"global not cached\"))\n+    }\n+\n     pub fn operand_ty(&self, operand: &mir::Operand<'tcx>) -> Ty<'tcx> {\n         self.monomorphize(operand.ty(self.mir(), self.tcx), self.substs())\n     }\n@@ -1074,17 +1075,32 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         Ok(())\n     }\n \n+    pub fn is_packed(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, bool> {\n+        let layout = self.type_layout(ty)?;\n+        use rustc::ty::layout::Layout::*;\n+        Ok(match *layout {\n+            Univariant { ref variant, .. } => variant.packed,\n+\n+            StructWrappedNullablePointer { ref nonnull, .. } => nonnull.packed,\n+\n+            UntaggedUnion { ref variants } => variants.packed,\n+\n+            // can only apply #[repr(packed)] to struct and union\n+            _ => false,\n+        })\n+    }\n+\n     pub fn force_allocation(\n         &mut self,\n-        lvalue: Lvalue<'tcx>,\n-    ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+        lvalue: Lvalue,\n+    ) -> EvalResult<'tcx, Lvalue> {\n         let new_lvalue = match lvalue {\n             Lvalue::Local { frame, local } => {\n                 // -1 since we don't store the return value\n                 match self.stack[frame].locals[local.index() - 1] {\n                     None => return err!(DeadLocal),\n-                    Some(Value::ByRef { ptr, aligned }) => {\n-                        Lvalue::Ptr { ptr, aligned, extra: LvalueExtra::None }\n+                    Some(Value::ByRef(ptr)) => {\n+                        Lvalue::Ptr { ptr, extra: LvalueExtra::None }\n                     },\n                     Some(val) => {\n                         let ty = self.stack[frame].mir.local_decls[local].ty;\n@@ -1098,36 +1114,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 }\n             }\n             Lvalue::Ptr { .. } => lvalue,\n-            Lvalue::Global(cid) => {\n-                let global_val = self.globals.get(&cid).expect(\"global not cached\").clone();\n-                match global_val.value {\n-                    Value::ByRef { ptr, aligned } =>\n-                        Lvalue::Ptr { ptr, aligned, extra: LvalueExtra::None },\n-                    _ => {\n-                        let ptr = self.alloc_ptr_with_substs(global_val.ty, cid.instance.substs)?;\n-                        self.memory.mark_static(ptr.alloc_id);\n-                        self.write_value_to_ptr(global_val.value, ptr.into(), global_val.ty)?;\n-                        // see comment on `initialized` field\n-                        if global_val.initialized {\n-                            self.memory.mark_static_initalized(ptr.alloc_id, global_val.mutable)?;\n-                        }\n-                        let lval = self.globals.get_mut(&cid).expect(\"already checked\");\n-                        *lval = Global {\n-                            value: Value::by_ref(ptr.into()),\n-                            .. global_val\n-                        };\n-                        Lvalue::from_ptr(ptr)\n-                    },\n-                }\n-            }\n         };\n         Ok(new_lvalue)\n     }\n \n     /// ensures this Value is not a ByRef\n     pub(super) fn follow_by_ref_value(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         match value {\n-            Value::ByRef { ptr, aligned } => {\n+            Value::ByRef(PtrAndAlign { ptr, aligned }) => {\n                 self.read_maybe_aligned(aligned, |ectx| ectx.read_value(ptr, ty))\n             }\n             other => Ok(other),\n@@ -1149,15 +1143,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     pub fn write_null(\n         &mut self,\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         self.write_primval(dest, PrimVal::Bytes(0), dest_ty)\n     }\n \n     pub fn write_ptr(\n         &mut self,\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         val: Pointer,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n@@ -1166,7 +1160,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     pub fn write_primval(\n         &mut self,\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         val: PrimVal,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n@@ -1176,7 +1170,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub fn write_value(\n         &mut self,\n         src_val: Value,\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         //trace!(\"Writing {:?} to {:?} at type {:?}\", src_val, dest, dest_ty);\n@@ -1185,22 +1179,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         // correct if we never look at this data with the wrong type.\n \n         match dest {\n-            Lvalue::Global(cid) => {\n-                let dest = self.globals.get_mut(&cid).expect(\"global should be cached\").clone();\n-                if dest.mutable == Mutability::Immutable {\n-                    return err!(ModifiedConstantMemory);\n-                }\n-                let write_dest = |this: &mut Self, val| {\n-                    *this.globals.get_mut(&cid).expect(\"already checked\") = Global {\n-                        value: val,\n-                        ..dest\n-                    };\n-                    Ok(())\n-                };\n-                self.write_value_possibly_by_val(src_val, write_dest, dest.value, dest_ty)\n-            },\n-\n-            Lvalue::Ptr { ptr, extra, aligned } => {\n+            Lvalue::Ptr { ptr: PtrAndAlign { ptr, aligned }, extra } => {\n                 assert_eq!(extra, LvalueExtra::None);\n                 self.write_maybe_aligned_mut(aligned,\n                     |ectx| ectx.write_value_to_ptr(src_val, ptr, dest_ty))\n@@ -1226,7 +1205,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         old_dest_val: Value,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        if let Value::ByRef { ptr: dest_ptr, aligned } = old_dest_val {\n+        if let Value::ByRef(PtrAndAlign { ptr: dest_ptr, aligned }) = old_dest_val {\n             // If the value is already `ByRef` (that is, backed by an `Allocation`),\n             // then we must write the new value into this allocation, because there may be\n             // other pointers into the allocation. These other pointers are logically\n@@ -1237,7 +1216,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             self.write_maybe_aligned_mut(aligned,\n                 |ectx| ectx.write_value_to_ptr(src_val, dest_ptr, dest_ty))?;\n \n-        } else if let Value::ByRef { ptr: src_ptr, aligned } = src_val {\n+        } else if let Value::ByRef(PtrAndAlign { ptr: src_ptr, aligned }) = src_val {\n             // If the value is not `ByRef`, then we know there are no pointers to it\n             // and we can simply overwrite the `Value` in the locals array directly.\n             //\n@@ -1275,7 +1254,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         match value {\n-            Value::ByRef { ptr, aligned } => {\n+            Value::ByRef(PtrAndAlign { ptr, aligned }) => {\n                 self.read_maybe_aligned_mut(aligned, |ectx| ectx.copy(ptr, dest, dest_ty))\n             },\n             Value::ByVal(primval) => {\n@@ -1542,7 +1521,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         &mut self,\n         src: Value,\n         src_ty: Ty<'tcx>,\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n         sty: Ty<'tcx>,\n         dty: Ty<'tcx>,\n@@ -1578,7 +1557,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         &mut self,\n         src: Value,\n         src_ty: Ty<'tcx>,\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         match (&src_ty.sty, &dest_ty.sty) {\n@@ -1610,7 +1589,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 //let src = adt::MaybeSizedValue::sized(src);\n                 //let dst = adt::MaybeSizedValue::sized(dst);\n                 let src_ptr = match src {\n-                    Value::ByRef { ptr, aligned: true } => ptr,\n+                    Value::ByRef(PtrAndAlign { ptr, aligned: true }) => ptr,\n                     // TODO: Is it possible for unaligned pointers to occur here?\n                     _ => bug!(\"expected aligned pointer, got {:?}\", src),\n                 };\n@@ -1640,60 +1619,58 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n-    pub fn dump_local(&self, lvalue: Lvalue<'tcx>) {\n+    pub fn dump_local(&self, lvalue: Lvalue) {\n         // Debug output\n-        if let Lvalue::Local { frame, local } = lvalue {\n-            let mut allocs = Vec::new();\n-            let mut msg = format!(\"{:?}\", local);\n-            if frame != self.cur_frame() {\n-                write!(msg, \" ({} frames up)\", self.cur_frame() - frame).unwrap();\n-            }\n-            write!(msg, \":\").unwrap();\n-\n-            match self.stack[frame].get_local(local) {\n-                Err(EvalError{ kind: EvalErrorKind::DeadLocal, ..} ) => {\n-                    write!(msg, \" is dead\").unwrap();\n+        match lvalue {\n+            Lvalue::Local { frame, local } => {\n+                let mut allocs = Vec::new();\n+                let mut msg = format!(\"{:?}\", local);\n+                if frame != self.cur_frame() {\n+                    write!(msg, \" ({} frames up)\", self.cur_frame() - frame).unwrap();\n                 }\n-                Err(err) => {\n-                    panic!(\"Failed to access local: {:?}\", err);\n+                write!(msg, \":\").unwrap();\n+\n+                match self.stack[frame].get_local(local) {\n+                    Err(EvalError{ kind: EvalErrorKind::DeadLocal, ..} ) => {\n+                        write!(msg, \" is dead\").unwrap();\n+                    }\n+                    Err(err) => {\n+                        panic!(\"Failed to access local: {:?}\", err);\n+                    }\n+                    Ok(Value::ByRef(PtrAndAlign{ ptr, aligned })) => match ptr.into_inner_primval() {\n+                        PrimVal::Ptr(ptr) => {\n+                            write!(msg, \" by {}ref:\", if aligned { \"\" } else { \"unaligned \" }).unwrap();\n+                            allocs.push(ptr.alloc_id);\n+                        },\n+                        ptr => write!(msg, \" integral by ref: {:?}\", ptr).unwrap(),\n+                    },\n+                    Ok(Value::ByVal(val)) => {\n+                        write!(msg, \" {:?}\", val).unwrap();\n+                        if let PrimVal::Ptr(ptr) = val { allocs.push(ptr.alloc_id); }\n+                    }\n+                    Ok(Value::ByValPair(val1, val2)) => {\n+                        write!(msg, \" ({:?}, {:?})\", val1, val2).unwrap();\n+                        if let PrimVal::Ptr(ptr) = val1 { allocs.push(ptr.alloc_id); }\n+                        if let PrimVal::Ptr(ptr) = val2 { allocs.push(ptr.alloc_id); }\n+                    }\n                 }\n-                Ok(Value::ByRef { ptr, aligned }) => match ptr.into_inner_primval() {\n+\n+                trace!(\"{}\", msg);\n+                self.memory.dump_allocs(allocs);\n+            }\n+            Lvalue::Ptr { ptr: PtrAndAlign { ptr, aligned }, .. } => {\n+                match ptr.into_inner_primval() {\n                     PrimVal::Ptr(ptr) => {\n-                        write!(msg, \" by {}ref:\", if aligned { \"\" } else { \"unaligned \" }).unwrap();\n-                        allocs.push(ptr.alloc_id);\n+                        trace!(\"by {}ref:\", if aligned { \"\" } else { \"unaligned \" });\n+                        self.memory.dump_alloc(ptr.alloc_id);\n                     },\n-                    ptr => write!(msg, \" integral by ref: {:?}\", ptr).unwrap(),\n-                },\n-                Ok(Value::ByVal(val)) => {\n-                    write!(msg, \" {:?}\", val).unwrap();\n-                    if let PrimVal::Ptr(ptr) = val { allocs.push(ptr.alloc_id); }\n-                }\n-                Ok(Value::ByValPair(val1, val2)) => {\n-                    write!(msg, \" ({:?}, {:?})\", val1, val2).unwrap();\n-                    if let PrimVal::Ptr(ptr) = val1 { allocs.push(ptr.alloc_id); }\n-                    if let PrimVal::Ptr(ptr) = val2 { allocs.push(ptr.alloc_id); }\n+                    ptr => trace!(\" integral by ref: {:?}\", ptr),\n                 }\n             }\n-\n-            trace!(\"{}\", msg);\n-            self.memory.dump_allocs(allocs);\n         }\n     }\n \n-    /// Convenience function to ensure correct usage of globals and code-sharing with locals.\n-    pub fn modify_global<F>(&mut self, cid: GlobalId<'tcx>, f: F) -> EvalResult<'tcx>\n-        where F: FnOnce(&mut Self, Value) -> EvalResult<'tcx, Value>,\n-    {\n-        let mut val = self.globals.get(&cid).expect(\"global not cached\").clone();\n-        if val.mutable == Mutability::Immutable {\n-            return err!(ModifiedConstantMemory);\n-        }\n-        val.value = f(self, val.value)?;\n-        *self.globals.get_mut(&cid).expect(\"already checked\") = val;\n-        Ok(())\n-    }\n-\n-    /// Convenience function to ensure correct usage of locals and code-sharing with globals.\n+    /// Convenience function to ensure correct usage of locals\n     pub fn modify_local<F>(\n         &mut self,\n         frame: usize,"}, {"sha": "02af68d384f835778ff1e29095a17135ab332691", "filename": "src/librustc_mir/interpret/lvalue.rs", "status": "modified", "additions": 48, "deletions": 90, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs?ref=a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "patch": "@@ -2,27 +2,25 @@ use rustc::mir;\n use rustc::ty::layout::{Size, Align};\n use rustc::ty::{self, Ty};\n use rustc_data_structures::indexed_vec::Idx;\n-use syntax::ast::Mutability;\n \n use super::{\n     EvalResult,\n     EvalContext,\n     MemoryPointer,\n     PrimVal, Value, Pointer,\n     Machine,\n+    PtrAndAlign,\n };\n \n #[derive(Copy, Clone, Debug)]\n-pub enum Lvalue<'tcx> {\n+pub enum Lvalue {\n     /// An lvalue referring to a value allocated in the `Memory` system.\n     Ptr {\n         /// An lvalue may have an invalid (integral or undef) pointer,\n         /// since it might be turned back into a reference\n         /// before ever being dereferenced.\n-        ptr: Pointer,\n+        ptr: PtrAndAlign,\n         extra: LvalueExtra,\n-        /// Remember whether this lvalue is *supposed* to be aligned.\n-        aligned: bool,\n     },\n \n     /// An lvalue referring to a value on the stack. Represented by a stack frame index paired with\n@@ -31,9 +29,6 @@ pub enum Lvalue<'tcx> {\n         frame: usize,\n         local: mir::Local,\n     },\n-\n-    /// An lvalue referring to a global\n-    Global(GlobalId<'tcx>),\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -55,42 +50,30 @@ pub struct GlobalId<'tcx> {\n     pub promoted: Option<mir::Promoted>,\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Global<'tcx> {\n-    pub value: Value,\n-    /// Only used in `force_allocation` to ensure we don't mark the memory\n-    /// before the static is initialized. It is possible to convert a\n-    /// global which initially is `Value::ByVal(PrimVal::Undef)` and gets\n-    /// lifted to an allocation before the static is fully initialized\n-    pub(super) initialized: bool,\n-    pub(super) mutable: Mutability,\n-    pub(super) ty: Ty<'tcx>,\n-}\n-\n-impl<'tcx> Lvalue<'tcx> {\n+impl<'tcx> Lvalue {\n     /// Produces an Lvalue that will error if attempted to be read from\n     pub fn undef() -> Self {\n         Self::from_primval_ptr(PrimVal::Undef.into())\n     }\n \n     pub fn from_primval_ptr(ptr: Pointer) -> Self {\n-        Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned: true }\n+        Lvalue::Ptr { ptr: PtrAndAlign { ptr, aligned: true }, extra: LvalueExtra::None }\n     }\n \n     pub fn from_ptr(ptr: MemoryPointer) -> Self {\n         Self::from_primval_ptr(ptr.into())\n     }\n \n-    pub(super) fn to_ptr_extra_aligned(self) -> (Pointer, LvalueExtra, bool) {\n+    pub(super) fn to_ptr_extra_aligned(self) -> (PtrAndAlign, LvalueExtra) {\n         match self {\n-            Lvalue::Ptr { ptr, extra, aligned } => (ptr, extra, aligned),\n+            Lvalue::Ptr { ptr, extra } => (ptr, extra),\n             _ => bug!(\"to_ptr_and_extra: expected Lvalue::Ptr, got {:?}\", self),\n \n         }\n     }\n \n     pub fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n-        let (ptr, extra, _aligned) = self.to_ptr_extra_aligned();\n+        let (ptr, extra) = self.to_ptr_extra_aligned();\n         // At this point, we forget about the alignment information -- the lvalue has been turned into a reference,\n         // and no matter where it came from, it now must be aligned.\n         assert_eq!(extra, LvalueExtra::None);\n@@ -113,26 +96,6 @@ impl<'tcx> Lvalue<'tcx> {\n     }\n }\n \n-impl<'tcx> Global<'tcx> {\n-    pub(super) fn uninitialized(ty: Ty<'tcx>) -> Self {\n-        Global {\n-            value: Value::ByVal(PrimVal::Undef),\n-            mutable: Mutability::Mutable,\n-            ty,\n-            initialized: false,\n-        }\n-    }\n-\n-    pub(super) fn initialized(ty: Ty<'tcx>, value: Value, mutable: Mutability) -> Self {\n-        Global {\n-            value,\n-            mutable,\n-            ty,\n-            initialized: true,\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     /// Reads a value from the lvalue without going through the intermediate step of obtaining\n     /// a `miri::Lvalue`\n@@ -147,7 +110,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             Static(ref static_) => {\n                 let instance = ty::Instance::mono(self.tcx, static_.def_id);\n                 let cid = GlobalId { instance, promoted: None };\n-                Ok(Some(self.globals.get(&cid).expect(\"global not cached\").value))\n+                Ok(Some(Value::ByRef(*self.globals.get(&cid).expect(\"global not cached\"))))\n             },\n             Projection(ref proj) => self.try_read_lvalue_projection(proj),\n         }\n@@ -195,30 +158,31 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         self.read_lvalue(lvalue)\n     }\n \n-    pub fn read_lvalue(&self, lvalue: Lvalue<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub fn read_lvalue(&self, lvalue: Lvalue) -> EvalResult<'tcx, Value> {\n         match lvalue {\n-            Lvalue::Ptr { ptr, extra, aligned } => {\n+            Lvalue::Ptr { ptr, extra } => {\n                 assert_eq!(extra, LvalueExtra::None);\n-                Ok(Value::ByRef { ptr, aligned })\n+                Ok(Value::ByRef(ptr))\n             }\n             Lvalue::Local { frame, local } => {\n                 self.stack[frame].get_local(local)\n             }\n-            Lvalue::Global(cid) => {\n-                Ok(self.globals.get(&cid).expect(\"global not cached\").value)\n-            }\n         }\n     }\n \n-    pub fn eval_lvalue(&mut self, mir_lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+    pub fn eval_lvalue(&mut self, mir_lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue> {\n         use rustc::mir::Lvalue::*;\n         let lvalue = match *mir_lvalue {\n             Local(mir::RETURN_POINTER) => self.frame().return_lvalue,\n             Local(local) => Lvalue::Local { frame: self.cur_frame(), local },\n \n             Static(ref static_) => {\n                 let instance = ty::Instance::mono(self.tcx, static_.def_id);\n-                Lvalue::Global(GlobalId { instance, promoted: None })\n+                let gid = GlobalId { instance, promoted: None };\n+                Lvalue::Ptr {\n+                    ptr: *self.globals.get(&gid).expect(\"uncached global\"),\n+                    extra: LvalueExtra::None,\n+                }\n             }\n \n             Projection(ref proj) => {\n@@ -237,11 +201,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     pub fn lvalue_field(\n         &mut self,\n-        base: Lvalue<'tcx>,\n+        base: Lvalue,\n         field_index: usize,\n         base_ty: Ty<'tcx>,\n         field_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+    ) -> EvalResult<'tcx, Lvalue> {\n         let base_layout = self.type_layout(base_ty)?;\n         use rustc::ty::layout::Layout::*;\n         let (offset, packed) = match *base_layout {\n@@ -250,10 +214,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             },\n \n             General { ref variants, .. } => {\n-                let (_, base_extra, _) = base.to_ptr_extra_aligned();\n+                let (_, base_extra) = base.to_ptr_extra_aligned();\n                 if let LvalueExtra::DowncastVariant(variant_idx) = base_extra {\n                     // +1 for the discriminant, which is field 0\n-                    (variants[variant_idx].offsets[field_index + 1], variants[variant_idx].packed)\n+                    assert!(!variants[variant_idx].packed);\n+                    (variants[variant_idx].offsets[field_index + 1], false)\n                 } else {\n                     bug!(\"field access on enum had no variant index\");\n                 }\n@@ -300,8 +265,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         };\n \n         // Do not allocate in trivial cases\n-        let (base_ptr, base_extra, aligned) = match base {\n-            Lvalue::Ptr { ptr, extra, aligned } => (ptr, extra, aligned),\n+        let (base_ptr, base_extra) = match base {\n+            Lvalue::Ptr { ptr, extra } => (ptr, extra),\n             Lvalue::Local { frame, local } => match self.stack[frame].get_local(local)? {\n                 // in case the type has a single field, just return the value\n                 Value::ByVal(_) if self.get_field_count(base_ty).map(|c| c == 1).unwrap_or(false) => {\n@@ -312,27 +277,20 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 Value::ByValPair(..) |\n                 Value::ByVal(_) => self.force_allocation(base)?.to_ptr_extra_aligned(),\n             },\n-            Lvalue::Global(cid) => match self.globals.get(&cid).expect(\"uncached global\").value {\n-                // in case the type has a single field, just return the value\n-                Value::ByVal(_) if self.get_field_count(base_ty).map(|c| c == 1).unwrap_or(false) => {\n-                    assert_eq!(offset.bytes(), 0, \"ByVal can only have 1 non zst field with offset 0\");\n-                    return Ok(base);\n-                },\n-                Value::ByRef{..} |\n-                Value::ByValPair(..) |\n-                Value::ByVal(_) => self.force_allocation(base)?.to_ptr_extra_aligned(),\n-            },\n         };\n \n         let offset = match base_extra {\n             LvalueExtra::Vtable(tab) => {\n-                let (_, align) = self.size_and_align_of_dst(base_ty, base_ptr.to_value_with_vtable(tab))?;\n+                let (_, align) = self.size_and_align_of_dst(base_ty, base_ptr.ptr.to_value_with_vtable(tab))?;\n                 offset.abi_align(Align::from_bytes(align, align).unwrap()).bytes()\n             }\n             _ => offset.bytes(),\n         };\n \n-        let ptr = base_ptr.offset(offset, &self)?;\n+        let mut ptr = base_ptr.offset(offset, &self)?;\n+        // if we were unaligned, stay unaligned\n+        // no matter what we were, if we are packed, we must not be aligned anymore\n+        ptr.aligned &= !packed;\n \n         let field_ty = self.monomorphize(field_ty, self.substs());\n \n@@ -349,43 +307,43 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             base_extra\n         };\n \n-        Ok(Lvalue::Ptr { ptr, extra, aligned: aligned && !packed })\n+        Ok(Lvalue::Ptr { ptr, extra } )\n     }\n \n-    pub(super) fn val_to_lvalue(&self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+    pub(super) fn val_to_lvalue(&self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Lvalue> {\n         Ok(match self.tcx.struct_tail(ty).sty {\n             ty::TyDynamic(..) => {\n                 let (ptr, vtable) = val.into_ptr_vtable_pair(&self.memory)?;\n-                Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable), aligned: true }\n+                Lvalue::Ptr { ptr: PtrAndAlign { ptr, aligned: true }, extra: LvalueExtra::Vtable(vtable) }\n             },\n             ty::TyStr | ty::TySlice(_) => {\n                 let (ptr, len) = val.into_slice(&self.memory)?;\n-                Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len), aligned: true }\n+                Lvalue::Ptr { ptr: PtrAndAlign { ptr, aligned: true }, extra: LvalueExtra::Length(len) }\n             },\n-            _ => Lvalue::Ptr { ptr: val.into_ptr(&self.memory)?, extra: LvalueExtra::None, aligned: true },\n+            _ => Lvalue::from_primval_ptr(val.into_ptr(&self.memory)?),\n         })\n     }\n \n-    pub(super) fn lvalue_index(&mut self, base: Lvalue<'tcx>, outer_ty: Ty<'tcx>, n: u64) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+    pub(super) fn lvalue_index(&mut self, base: Lvalue, outer_ty: Ty<'tcx>, n: u64) -> EvalResult<'tcx, Lvalue> {\n         // Taking the outer type here may seem odd; it's needed because for array types, the outer type gives away the length.\n         let base = self.force_allocation(base)?;\n-        let (base_ptr, _, aligned) = base.to_ptr_extra_aligned();\n+        let (base_ptr, _) = base.to_ptr_extra_aligned();\n \n         let (elem_ty, len) = base.elem_ty_and_len(outer_ty);\n         let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n         assert!(n < len, \"Tried to access element {} of array/slice with length {}\", n, len);\n         let ptr = base_ptr.offset(n * elem_size, self.memory.layout)?;\n-        Ok(Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned })\n+        Ok(Lvalue::Ptr { ptr, extra: LvalueExtra::None })\n     }\n \n     pub(super) fn eval_lvalue_projection(\n         &mut self,\n-        base: Lvalue<'tcx>,\n+        base: Lvalue,\n         base_ty: Ty<'tcx>,\n         proj_elem: &mir::ProjectionElem<'tcx, mir::Operand<'tcx>, Ty<'tcx>>,\n-    ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+    ) -> EvalResult<'tcx, Lvalue> {\n         use rustc::mir::ProjectionElem::*;\n-        let (ptr, extra, aligned) = match *proj_elem {\n+        let (ptr, extra) = match *proj_elem {\n             Field(field, field_ty) => {\n                 return self.lvalue_field(base, field.index(), base_ty, field_ty);\n             }\n@@ -394,15 +352,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let base_layout = self.type_layout(base_ty)?;\n                 // FIXME(solson)\n                 let base = self.force_allocation(base)?;\n-                let (base_ptr, base_extra, aligned) = base.to_ptr_extra_aligned();\n+                let (base_ptr, base_extra) = base.to_ptr_extra_aligned();\n \n                 use rustc::ty::layout::Layout::*;\n                 let extra = match *base_layout {\n                     General { .. } => LvalueExtra::DowncastVariant(variant),\n                     RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => base_extra,\n                     _ => bug!(\"variant downcast on non-aggregate: {:?}\", base_layout),\n                 };\n-                (base_ptr, extra, aligned)\n+                (base_ptr, extra)\n             }\n \n             Deref => {\n@@ -431,7 +389,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             ConstantIndex { offset, min_length, from_end } => {\n                 // FIXME(solson)\n                 let base = self.force_allocation(base)?;\n-                let (base_ptr, _, aligned) = base.to_ptr_extra_aligned();\n+                let (base_ptr, _) = base.to_ptr_extra_aligned();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n                 let elem_size = self.type_size(elem_ty)?.expect(\"sequence element must be sized\");\n@@ -444,24 +402,24 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 };\n \n                 let ptr = base_ptr.offset(index * elem_size, &self)?;\n-                (ptr, LvalueExtra::None, aligned)\n+                (ptr, LvalueExtra::None)\n             }\n \n             Subslice { from, to } => {\n                 // FIXME(solson)\n                 let base = self.force_allocation(base)?;\n-                let (base_ptr, _, aligned) = base.to_ptr_extra_aligned();\n+                let (base_ptr, _) = base.to_ptr_extra_aligned();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n                 let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n                 assert!(u64::from(from) <= n - u64::from(to));\n                 let ptr = base_ptr.offset(u64::from(from) * elem_size, &self)?;\n                 let extra = LvalueExtra::Length(n - u64::from(to) - u64::from(from));\n-                (ptr, extra, aligned)\n+                (ptr, extra)\n             }\n         };\n \n-        Ok(Lvalue::Ptr { ptr, extra, aligned })\n+        Ok(Lvalue::Ptr { ptr, extra })\n     }\n \n     pub(super) fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {"}, {"sha": "c65c3f2e1038c2aed10e28b4ef0809a0806eb537", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "patch": "@@ -33,7 +33,7 @@ pub trait Machine<'tcx>: Sized {\n     fn eval_fn_call<'a>(\n         ecx: &mut EvalContext<'a, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        destination: Option<(Lvalue, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n         sig: ty::FnSig<'tcx>,\n@@ -44,7 +44,7 @@ pub trait Machine<'tcx>: Sized {\n         ecx: &mut EvalContext<'a, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[mir::Operand<'tcx>],\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: ty::Ty<'tcx>,\n         dest_layout: &'tcx ty::layout::Layout,\n         target: mir::BasicBlock,"}, {"sha": "f068bc839d1eabac29010b050e34ef28ac90ab58", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 115, "deletions": 79, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "patch": "@@ -82,12 +82,55 @@ impl LockInfo {\n // Allocations and pointers\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n-pub struct AllocId(pub u64);\n+#[derive(Copy, Clone, Eq, Hash, Ord, PartialEq, PartialOrd)]\n+pub struct AllocId(u64);\n+\n+#[derive(Debug)]\n+enum AllocIdKind {\n+    /// We can't ever have more than `usize::max_value` functions at the same time\n+    /// since we never \"deallocate\" functions\n+    Function(usize),\n+    /// Locals and heap allocations (also statics for now, but those will get their\n+    /// own variant soonish).\n+    Runtime(u64),\n+}\n+\n+impl AllocIdKind {\n+    fn into_alloc_id(self) -> AllocId {\n+        match self {\n+            AllocIdKind::Function(n) => AllocId(n as u64),\n+            AllocIdKind::Runtime(n) => AllocId((1 << 63) | n),\n+        }\n+    }\n+}\n+\n+impl AllocId {\n+    /// Currently yields the top bit to discriminate the `AllocIdKind`s\n+    fn discriminant(self) -> u64 {\n+        self.0 >> 63\n+    }\n+    /// Yields everything but the discriminant bits\n+    fn index(self) -> u64 {\n+        self.0 & ((1 << 63) - 1)\n+    }\n+    fn into_alloc_id_kind(self) -> AllocIdKind {\n+        match self.discriminant() {\n+            0 => AllocIdKind::Function(self.index() as usize),\n+            1 => AllocIdKind::Runtime(self.index()),\n+            n => bug!(\"got discriminant {} for AllocId\", n),\n+        }\n+    }\n+}\n \n impl fmt::Display for AllocId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.0)\n+        write!(f, \"{:?}\", self.into_alloc_id_kind())\n+    }\n+}\n+\n+impl fmt::Debug for AllocId {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{:?}\", self.into_alloc_id_kind())\n     }\n }\n \n@@ -108,7 +151,7 @@ pub struct Allocation<M> {\n     /// Use the `mark_static_initalized` method of `Memory` to ensure that an error occurs, if the memory of this\n     /// allocation is modified or deallocated in the future.\n     /// Helps guarantee that stack allocations aren't deallocated via `rust_deallocate`\n-    pub kind: Kind<M>,\n+    pub kind: MemoryKind<M>,\n     /// Memory regions that are locked by some function\n     locks: RangeMap<LockInfo>,\n }\n@@ -129,7 +172,7 @@ impl<M> Allocation<M> {\n }\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n-pub enum Kind<T> {\n+pub enum MemoryKind<T> {\n     /// Error if deallocated except during a stack pop\n     Stack,\n     /// Static in the process of being initialized.\n@@ -186,16 +229,10 @@ pub struct Memory<'a, 'tcx, M: Machine<'tcx>> {\n     pub data: M::MemoryData,\n \n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations).\n-    alloc_map: HashMap<AllocId, Allocation<M::MemoryKinds>>,\n+    alloc_map: HashMap<u64, Allocation<M::MemoryKinds>>,\n \n-    /// The AllocId to assign to the next new allocation. Always incremented, never gets smaller.\n-    next_id: AllocId,\n-\n-    /// Set of statics, constants, promoteds, vtables, ... to prevent `mark_static_initalized` from\n-    /// stepping out of its own allocations. This set only contains statics backed by an\n-    /// allocation. If they are ByVal or ByValPair they are not here, but will be inserted once\n-    /// they become ByRef.\n-    static_alloc: HashSet<AllocId>,\n+    /// The AllocId to assign to the next new regular allocation. Always incremented, never gets smaller.\n+    next_alloc_id: u64,\n \n     /// Number of virtual bytes allocated.\n     memory_usage: u64,\n@@ -205,7 +242,7 @@ pub struct Memory<'a, 'tcx, M: Machine<'tcx>> {\n \n     /// Function \"allocations\". They exist solely so pointers have something to point to, and\n     /// we can figure out what they point to.\n-    functions: HashMap<AllocId, ty::Instance<'tcx>>,\n+    functions: Vec<ty::Instance<'tcx>>,\n \n     /// Inverse map of `functions` so we don't allocate a new pointer every time we need one\n     function_alloc_cache: HashMap<ty::Instance<'tcx>, AllocId>,\n@@ -231,42 +268,41 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         Memory {\n             data,\n             alloc_map: HashMap::new(),\n-            functions: HashMap::new(),\n+            functions: Vec::new(),\n             function_alloc_cache: HashMap::new(),\n-            next_id: AllocId(0),\n+            next_alloc_id: 0,\n             layout,\n             memory_size: max_memory,\n             memory_usage: 0,\n-            static_alloc: HashSet::new(),\n             literal_alloc_cache: HashMap::new(),\n             reads_are_aligned: Cell::new(true),\n             writes_are_aligned: Cell::new(true),\n             cur_frame: usize::max_value(),\n         }\n     }\n \n-    pub fn allocations(&self) -> ::std::collections::hash_map::Iter<AllocId, Allocation<M::MemoryKinds>> {\n-        self.alloc_map.iter()\n+    pub fn allocations<'x>(&'x self) -> impl Iterator<Item = (AllocId, &'x Allocation<M::MemoryKinds>)> {\n+        self.alloc_map.iter().map(|(&id, alloc)| (AllocIdKind::Runtime(id).into_alloc_id(), alloc))\n     }\n \n     pub fn create_fn_alloc(&mut self, instance: ty::Instance<'tcx>) -> MemoryPointer {\n         if let Some(&alloc_id) = self.function_alloc_cache.get(&instance) {\n             return MemoryPointer::new(alloc_id, 0);\n         }\n-        let id = self.next_id;\n+        let id = self.functions.len();\n         debug!(\"creating fn ptr: {}\", id);\n-        self.next_id.0 += 1;\n-        self.functions.insert(id, instance);\n-        self.function_alloc_cache.insert(instance, id);\n-        MemoryPointer::new(id, 0)\n+        self.functions.push(instance);\n+        let alloc_id = AllocIdKind::Function(id).into_alloc_id();\n+        self.function_alloc_cache.insert(instance, alloc_id);\n+        MemoryPointer::new(alloc_id, 0)\n     }\n \n     pub fn allocate_cached(&mut self, bytes: &[u8]) -> EvalResult<'tcx, MemoryPointer> {\n         if let Some(&alloc_id) = self.literal_alloc_cache.get(bytes) {\n             return Ok(MemoryPointer::new(alloc_id, 0));\n         }\n \n-        let ptr = self.allocate(bytes.len() as u64, 1, Kind::UninitializedStatic)?;\n+        let ptr = self.allocate(bytes.len() as u64, 1, MemoryKind::UninitializedStatic)?;\n         self.write_bytes(ptr.into(), bytes)?;\n         self.mark_static_initalized(ptr.alloc_id, Mutability::Immutable)?;\n         self.literal_alloc_cache.insert(bytes.to_vec(), ptr.alloc_id);\n@@ -277,7 +313,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         &mut self,\n         size: u64,\n         align: u64,\n-        kind: Kind<M::MemoryKinds>,\n+        kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx, MemoryPointer> {\n         assert_ne!(align, 0);\n         assert!(align.is_power_of_two());\n@@ -300,10 +336,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             mutable: Mutability::Mutable,\n             locks: RangeMap::new(),\n         };\n-        let id = self.next_id;\n-        self.next_id.0 += 1;\n+        let id = self.next_alloc_id;\n+        self.next_alloc_id += 1;\n         self.alloc_map.insert(id, alloc);\n-        Ok(MemoryPointer::new(id, 0))\n+        Ok(MemoryPointer::new(AllocIdKind::Runtime(id).into_alloc_id(), 0))\n     }\n \n     pub fn reallocate(\n@@ -313,7 +349,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         old_align: u64,\n         new_size: u64,\n         new_align: u64,\n-        kind: Kind<M::MemoryKinds>,\n+        kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx, MemoryPointer> {\n         use std::cmp::min;\n \n@@ -338,13 +374,19 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         &mut self,\n         ptr: MemoryPointer,\n         size_and_align: Option<(u64, u64)>,\n-        kind: Kind<M::MemoryKinds>,\n+        kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx> {\n         if ptr.offset != 0 {\n             return err!(DeallocateNonBasePtr);\n         }\n \n-        let alloc = match self.alloc_map.remove(&ptr.alloc_id) {\n+        let alloc_id = match ptr.alloc_id.into_alloc_id_kind() {\n+            AllocIdKind::Function(_) =>\n+                return err!(DeallocatedWrongMemoryKind(\"function\".to_string(), format!(\"{:?}\", kind))),\n+            AllocIdKind::Runtime(id) => id,\n+        };\n+\n+        let alloc = match self.alloc_map.remove(&alloc_id) {\n             Some(alloc) => alloc,\n             None => return err!(DoubleFree),\n         };\n@@ -624,22 +666,22 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n /// Allocation accessors\n impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation<M::MemoryKinds>> {\n-        match self.alloc_map.get(&id) {\n-            Some(alloc) => Ok(alloc),\n-            None => match self.functions.get(&id) {\n-                Some(_) => err!(DerefFunctionPointer),\n+        match id.into_alloc_id_kind() {\n+            AllocIdKind::Function(_) => err!(DerefFunctionPointer),\n+            AllocIdKind::Runtime(id) => match self.alloc_map.get(&id) {\n+                Some(alloc) => Ok(alloc),\n                 None => err!(DanglingPointerDeref),\n-            }\n+            },\n         }\n     }\n     \n     fn get_mut_unchecked(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation<M::MemoryKinds>> {\n-        match self.alloc_map.get_mut(&id) {\n-            Some(alloc) => Ok(alloc),\n-            None => match self.functions.get(&id) {\n-                Some(_) => err!(DerefFunctionPointer),\n+        match id.into_alloc_id_kind() {\n+            AllocIdKind::Function(_) => err!(DerefFunctionPointer),\n+            AllocIdKind::Runtime(id) => match self.alloc_map.get_mut(&id) {\n+                Some(alloc) => Ok(alloc),\n                 None => err!(DanglingPointerDeref),\n-            }\n+            },\n         }\n     }\n \n@@ -657,12 +699,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             return err!(InvalidFunctionPointer);\n         }\n         debug!(\"reading fn ptr: {}\", ptr.alloc_id);\n-        match self.functions.get(&ptr.alloc_id) {\n-            Some(&fndef) => Ok(fndef),\n-            None => match self.alloc_map.get(&ptr.alloc_id) {\n-                Some(_) => err!(ExecuteMemory),\n-                None => err!(InvalidFunctionPointer),\n-            }\n+        match ptr.alloc_id.into_alloc_id_kind() {\n+            AllocIdKind::Function(id) => Ok(self.functions[id]),\n+            AllocIdKind::Runtime(_) => err!(ExecuteMemory),\n         }\n     }\n \n@@ -684,17 +723,18 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             let prefix_len = msg.len();\n             let mut relocations = vec![];\n \n-            let alloc = match (self.alloc_map.get(&id), self.functions.get(&id)) {\n-                (Some(a), None) => a,\n-                (None, Some(instance)) => {\n-                    trace!(\"{} {}\", msg, instance);\n+            let alloc = match id.into_alloc_id_kind() {\n+                AllocIdKind::Function(id) => {\n+                    trace!(\"{} {}\", msg, self.functions[id]);\n                     continue;\n                 },\n-                (None, None) => {\n-                    trace!(\"{} (deallocated)\", msg);\n-                    continue;\n+                AllocIdKind::Runtime(id) => match self.alloc_map.get(&id) {\n+                    Some(a) => a,\n+                    None => {\n+                        trace!(\"{} (deallocated)\", msg);\n+                        continue;\n+                    }\n                 },\n-                (Some(_), Some(_)) => bug!(\"miri invariant broken: an allocation id exists that points to both a function and a memory location\"),\n             };\n \n             for i in 0..(alloc.bytes.len() as u64) {\n@@ -713,11 +753,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             }\n \n             let immutable = match (alloc.kind, alloc.mutable) {\n-                (Kind::UninitializedStatic, _) => \" (static in the process of initialization)\".to_owned(),\n-                (Kind::Static, Mutability::Mutable) => \" (static mut)\".to_owned(),\n-                (Kind::Static, Mutability::Immutable) => \" (immutable)\".to_owned(),\n-                (Kind::Machine(m), _) => format!(\" ({:?})\", m),\n-                (Kind::Stack, _) => \" (stack)\".to_owned(),\n+                (MemoryKind::UninitializedStatic, _) => \" (static in the process of initialization)\".to_owned(),\n+                (MemoryKind::Static, Mutability::Mutable) => \" (static mut)\".to_owned(),\n+                (MemoryKind::Static, Mutability::Immutable) => \" (immutable)\".to_owned(),\n+                (MemoryKind::Machine(m), _) => format!(\" ({:?})\", m),\n+                (MemoryKind::Stack, _) => \" (stack)\".to_owned(),\n             };\n             trace!(\"{}({} bytes, alignment {}){}\", msg, alloc.bytes.len(), alloc.align, immutable);\n \n@@ -744,8 +784,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         let leaks: Vec<_> = self.alloc_map\n             .iter()\n             .filter_map(|(&key, val)| {\n-                if val.kind != Kind::Static {\n-                    Some(key)\n+                if val.kind != MemoryKind::Static {\n+                    Some(AllocIdKind::Runtime(key).into_alloc_id())\n                 } else {\n                     None\n                 }\n@@ -812,18 +852,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n /// Reading and writing\n impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n-    /// mark an allocation as being the entry point to a static (see `static_alloc` field)\n-    pub fn mark_static(&mut self, alloc_id: AllocId) {\n-        trace!(\"mark_static: {:?}\", alloc_id);\n-        if !self.static_alloc.insert(alloc_id) {\n-            bug!(\"tried to mark an allocation ({:?}) as static twice\", alloc_id);\n-        }\n-    }\n \n     /// mark an allocation pointed to by a static as static and initialized\n     pub fn mark_inner_allocation(&mut self, alloc: AllocId, mutability: Mutability) -> EvalResult<'tcx> {\n         // relocations into other statics are not \"inner allocations\"\n-        if !self.static_alloc.contains(&alloc) {\n+        if self.get(alloc).ok().map_or(false, |alloc| alloc.kind != MemoryKind::UninitializedStatic) {\n             self.mark_static_initalized(alloc, mutability)?;\n         }\n         Ok(())\n@@ -834,28 +867,31 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         trace!(\"mark_static_initalized {:?}, mutability: {:?}\", alloc_id, mutability);\n         // do not use `self.get_mut(alloc_id)` here, because we might have already marked a\n         // sub-element or have circular pointers (e.g. `Rc`-cycles)\n+        let alloc_id = match alloc_id.into_alloc_id_kind() {\n+            AllocIdKind::Function(_) => return Ok(()),\n+            AllocIdKind::Runtime(id) => id,\n+        };\n         let relocations = match self.alloc_map.get_mut(&alloc_id) {\n             Some(&mut Allocation { ref mut relocations, ref mut kind, ref mut mutable, .. }) => {\n                 match *kind {\n                     // const eval results can refer to \"locals\".\n                     // E.g. `const Foo: &u32 = &1;` refers to the temp local that stores the `1`\n-                    Kind::Stack |\n+                    MemoryKind::Stack |\n                     // The entire point of this function\n-                    Kind::UninitializedStatic => {},\n-                    Kind::Machine(m) => M::mark_static_initialized(m)?,\n-                    Kind::Static => {\n+                    MemoryKind::UninitializedStatic => {},\n+                    MemoryKind::Machine(m) => M::mark_static_initialized(m)?,\n+                    MemoryKind::Static => {\n                         trace!(\"mark_static_initalized: skipping already initialized static referred to by static currently being initialized\");\n                         return Ok(());\n                     },\n                 }\n-                *kind = Kind::Static;\n+                *kind = MemoryKind::Static;\n                 *mutable = mutability;\n                 // take out the relocations vector to free the borrow on self, so we can call\n                 // mark recursively\n                 mem::replace(relocations, Default::default())\n             },\n-            None if !self.functions.contains_key(&alloc_id) => return err!(DanglingPointerDeref),\n-            _ => return Ok(()),\n+            None => return err!(DanglingPointerDeref),\n         };\n         // recurse into inner allocations\n         for &alloc in relocations.values() {"}, {"sha": "392724757ebeccee68356205a461caafbd5d9fab", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "patch": "@@ -33,20 +33,20 @@ pub use self::eval_context::{\n     StackPopCleanup,\n     DynamicLifetime,\n     TyAndPacked,\n+    PtrAndAlign,\n };\n \n pub use self::lvalue::{\n     Lvalue,\n     LvalueExtra,\n-    Global,\n     GlobalId,\n };\n \n pub use self::memory::{\n     AllocId,\n     Memory,\n     MemoryPointer,\n-    Kind,\n+    MemoryKind,\n     HasMemory,\n };\n "}, {"sha": "8880be6e848fb2b4a3896842461138cb550a3049", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         op: mir::BinOp,\n         left: &mir::Operand<'tcx>,\n         right: &mir::Operand<'tcx>,\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         let (val, overflowed) = self.binop_with_overflow(op, left, right)?;\n@@ -54,7 +54,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         op: mir::BinOp,\n         left: &mir::Operand<'tcx>,\n         right: &mir::Operand<'tcx>,\n-        dest: Lvalue<'tcx>,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, bool> {\n         let (val, overflowed) = self.binop_with_overflow(op, left, right)?;"}, {"sha": "a85d8d05c3269ad4e3fc32b3ec75008017b82f86", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "patch": "@@ -13,10 +13,9 @@ use rustc::ty::subst::Substs;\n \n use super::{\n     EvalResult,\n-    EvalContext, StackPopCleanup, TyAndPacked,\n-    Global, GlobalId, Lvalue,\n-    Value, PrimVal,\n-    HasMemory,\n+    EvalContext, StackPopCleanup, TyAndPacked, PtrAndAlign,\n+    GlobalId, Lvalue,\n+    HasMemory, MemoryKind,\n     Machine,\n };\n \n@@ -179,11 +178,19 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         if self.tcx.has_attr(def_id, \"linkage\") {\n             // FIXME: check that it's `#[linkage = \"extern_weak\"]`\n             trace!(\"Initializing an extern global with NULL\");\n-            self.globals.insert(cid, Global::initialized(self.tcx.type_of(def_id), Value::ByVal(PrimVal::Bytes(0)), mutability));\n+            let ptr_size = self.memory.pointer_size();\n+            let ptr = self.memory.allocate(ptr_size, ptr_size, MemoryKind::UninitializedStatic)?;\n+            self.memory.write_usize(ptr, 0)?;\n+            self.memory.mark_static_initalized(ptr.alloc_id, mutability)?;\n+            self.globals.insert(cid, PtrAndAlign { ptr: ptr.into(), aligned: true });\n             return Ok(false);\n         }\n         let mir = self.load_mir(instance.def)?;\n-        self.globals.insert(cid, Global::uninitialized(mir.return_ty));\n+        let size = self.type_size_with_substs(mir.return_ty, substs)?.expect(\"unsized global\");\n+        let align = self.type_align_with_substs(mir.return_ty, substs)?;\n+        let ptr = self.memory.allocate(size, align, MemoryKind::UninitializedStatic)?;\n+        let aligned = !self.is_packed(mir.return_ty)?;\n+        self.globals.insert(cid, PtrAndAlign { ptr: ptr.into(), aligned });\n         let internally_mutable = !mir.return_ty.is_freeze(\n                 self.tcx,\n                 ty::ParamEnv::empty(Reveal::All),\n@@ -200,7 +207,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             instance,\n             span,\n             mir,\n-            Lvalue::Global(cid),\n+            Lvalue::from_ptr(ptr),\n             cleanup,\n         )?;\n         Ok(true)\n@@ -256,13 +263,16 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n                 }\n                 let mir = &self.mir.promoted[index];\n                 self.try(|this| {\n-                    let ty = this.ecx.monomorphize(mir.return_ty, this.instance.substs);\n-                    this.ecx.globals.insert(cid, Global::uninitialized(ty));\n+                    let size = this.ecx.type_size_with_substs(mir.return_ty, this.instance.substs)?.expect(\"unsized global\");\n+                    let align = this.ecx.type_align_with_substs(mir.return_ty, this.instance.substs)?;\n+                    let ptr = this.ecx.memory.allocate(size, align, MemoryKind::UninitializedStatic)?;\n+                    let aligned = !this.ecx.is_packed(mir.return_ty)?;\n+                    this.ecx.globals.insert(cid, PtrAndAlign { ptr: ptr.into(), aligned });\n                     trace!(\"pushing stack frame for {:?}\", index);\n                     this.ecx.push_stack_frame(this.instance,\n                                               constant.span,\n                                               mir,\n-                                              Lvalue::Global(cid),\n+                                              Lvalue::from_ptr(ptr),\n                                               StackPopCleanup::MarkStatic(Mutability::Immutable),\n                     )?;\n                     Ok(true)"}, {"sha": "36d56511afc5362becdac235b39fc60cefde8948", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "patch": "@@ -11,15 +11,15 @@ use interpret::{\n };\n \n impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n-    pub(crate) fn drop_lvalue(&mut self, lval: Lvalue<'tcx>, instance: ty::Instance<'tcx>, ty: Ty<'tcx>, span: Span) -> EvalResult<'tcx> {\n+    pub(crate) fn drop_lvalue(&mut self, lval: Lvalue, instance: ty::Instance<'tcx>, ty: Ty<'tcx>, span: Span) -> EvalResult<'tcx> {\n         trace!(\"drop_lvalue: {:#?}\", lval);\n         // We take the address of the object.  This may well be unaligned, which is fine for us here.\n         // However, unaligned accesses will probably make the actual drop implementation fail -- a problem shared\n         // by rustc.\n         let val = match self.force_allocation(lval)? {\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable), aligned: _ } => ptr.to_value_with_vtable(vtable),\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len), aligned: _ } => ptr.to_value_with_len(len),\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned: _ } => ptr.to_value(),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } => ptr.ptr.to_value_with_vtable(vtable),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => ptr.ptr.to_value_with_len(len),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::None } => ptr.ptr.to_value(),\n             _ => bug!(\"force_allocation broken\"),\n         };\n         self.drop(val, instance, ty, span)"}, {"sha": "531e1792d9e79d52777ce1083254c7091c42d363", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "patch": "@@ -6,7 +6,7 @@ use syntax::abi::Abi;\n \n use super::{\n     EvalError, EvalResult, EvalErrorKind,\n-    EvalContext, eval_context, TyAndPacked,\n+    EvalContext, eval_context, TyAndPacked, PtrAndAlign,\n     Lvalue,\n     MemoryPointer,\n     PrimVal, Value,\n@@ -204,7 +204,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     fn eval_fn_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        destination: Option<(Lvalue, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n         sig: ty::FnSig<'tcx>,\n@@ -311,10 +311,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                             if self.frame().mir.args_iter().count() == fields.len() + 1 {\n                                 let offsets = variant.offsets.iter().map(|s| s.bytes());\n                                 match arg_val {\n-                                    Value::ByRef { ptr, aligned } => {\n+                                    Value::ByRef(PtrAndAlign { ptr, aligned }) => {\n                                         assert!(aligned, \"Unaligned ByRef-values cannot occur as function arguments\");\n                                         for ((offset, ty), arg_local) in offsets.zip(fields).zip(arg_locals) {\n-                                            let arg = Value::ByRef { ptr: ptr.offset(offset, &self)?, aligned: true};\n+                                            let arg = Value::by_ref(ptr.offset(offset, &self)?);\n                                             let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n                                             trace!(\"writing arg {:?} to {:?} (type: {})\", arg, dest, ty);\n                                             self.write_value(arg, dest, ty)?;"}, {"sha": "3b642591917b342a5428dede84eda456d8e1b75e", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "patch": "@@ -8,7 +8,7 @@ use syntax::ast::{self, Mutability};\n use super::{\n     EvalResult,\n     EvalContext, eval_context,\n-    MemoryPointer, Kind,\n+    MemoryPointer, MemoryKind,\n     Value, PrimVal,\n     Machine,\n };\n@@ -51,7 +51,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n         let ptr_size = self.memory.pointer_size();\n         let methods = ::rustc::traits::get_vtable_methods(self.tcx, trait_ref);\n-        let vtable = self.memory.allocate(ptr_size * (3 + methods.count() as u64), ptr_size, Kind::UninitializedStatic)?;\n+        let vtable = self.memory.allocate(ptr_size * (3 + methods.count() as u64), ptr_size, MemoryKind::UninitializedStatic)?;\n \n         let drop = eval_context::resolve_drop_in_place(self.tcx, ty);\n         let drop = self.memory.create_fn_alloc(drop);"}, {"sha": "b291c639b9ca2f31bf11106d24a69c994f5ff2c7", "filename": "src/librustc_mir/interpret/validation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "patch": "@@ -16,7 +16,7 @@ use super::{\n     Machine,\n };\n \n-pub type ValidationQuery<'tcx> = ValidationOperand<'tcx, Lvalue<'tcx>>;\n+pub type ValidationQuery<'tcx> = ValidationOperand<'tcx, Lvalue>;\n \n #[derive(Copy, Clone, Debug)]\n enum ValidationMode {\n@@ -213,7 +213,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         };\n         if is_owning {\n             match query.lval {\n-                Lvalue::Ptr { ptr, extra, aligned: _ } => {\n+                Lvalue::Ptr { ptr, extra } => {\n                     // Determine the size\n                     // FIXME: Can we reuse size_and_align_of_dst for Lvalues?\n                     let len = match self.type_size(query.ty)? {\n@@ -242,8 +242,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         }\n                     }\n                 }\n-                Lvalue::Local { .. } | Lvalue::Global(..) => {\n-                    // These are not backed by memory, so we have nothing to do.\n+                Lvalue::Local { .. }  => {\n+                    // Not backed by memory, so we have nothing to do.\n                 }\n             }\n         }"}, {"sha": "be6d304d3f5865ec76135f3909cd2427775859f0", "filename": "src/librustc_mir/interpret/value.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs?ref=a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "patch": "@@ -7,6 +7,7 @@ use super::{\n     EvalResult,\n     Memory, MemoryPointer, HasMemory, PointerArithmetic,\n     Machine,\n+    PtrAndAlign,\n };\n \n pub(super) fn bytes_to_f32(bytes: u128) -> f32 {\n@@ -36,7 +37,7 @@ pub(super) fn f64_to_bytes(f: f64) -> u128 {\n /// operations and fat pointers. This idea was taken from rustc's trans.\n #[derive(Clone, Copy, Debug)]\n pub enum Value {\n-    ByRef { ptr: Pointer, aligned: bool},\n+    ByRef(PtrAndAlign),\n     ByVal(PrimVal),\n     ByValPair(PrimVal, PrimVal),\n }\n@@ -166,15 +167,15 @@ pub enum PrimValKind {\n impl<'a, 'tcx: 'a> Value {\n     #[inline]\n     pub fn by_ref(ptr: Pointer) -> Self {\n-        Value::ByRef { ptr, aligned: true }\n+        Value::ByRef(PtrAndAlign { ptr, aligned: true })\n     }\n \n     /// Convert the value into a pointer (or a pointer-sized integer).  If the value is a ByRef,\n     /// this may have to perform a load.\n     pub fn into_ptr<M: Machine<'tcx>>(&self, mem: &Memory<'a, 'tcx, M>) -> EvalResult<'tcx, Pointer> {\n         use self::Value::*;\n         match *self {\n-            ByRef { ptr, aligned } => {\n+            ByRef(PtrAndAlign { ptr, aligned }) => {\n                 mem.read_maybe_aligned(aligned, |mem| mem.read_ptr(ptr.to_ptr()?) )\n             },\n             ByVal(ptr) | ByValPair(ptr, _) => Ok(ptr.into()),\n@@ -187,7 +188,7 @@ impl<'a, 'tcx: 'a> Value {\n     ) -> EvalResult<'tcx, (Pointer, MemoryPointer)> {\n         use self::Value::*;\n         match *self {\n-            ByRef { ptr: ref_ptr, aligned } => {\n+            ByRef(PtrAndAlign { ptr: ref_ptr, aligned }) => {\n                 mem.read_maybe_aligned(aligned, |mem| {\n                     let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n                     let vtable = mem.read_ptr(ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?)?;\n@@ -205,7 +206,7 @@ impl<'a, 'tcx: 'a> Value {\n     pub(super) fn into_slice<M: Machine<'tcx>>(&self, mem: &Memory<'a, 'tcx, M>) -> EvalResult<'tcx, (Pointer, u64)> {\n         use self::Value::*;\n         match *self {\n-            ByRef { ptr: ref_ptr, aligned } => {\n+            ByRef(PtrAndAlign { ptr: ref_ptr, aligned } ) => {\n                 mem.read_maybe_aligned(aligned, |mem| {\n                     let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n                     let len = mem.read_usize(ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?)?;"}, {"sha": "45e32142a8c44a2b723db5410bba8005a6b491a5", "filename": "tests/compile-fail/fn_ptr_offset.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/tests%2Fcompile-fail%2Ffn_ptr_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/tests%2Fcompile-fail%2Ffn_ptr_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffn_ptr_offset.rs?ref=a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "patch": "@@ -10,5 +10,5 @@ fn main() {\n     let y : *mut u8 = unsafe { mem::transmute(x) };\n     let y = y.wrapping_offset(1);\n     let x : fn() = unsafe { mem::transmute(y) };\n-    x(); //~ ERROR: tried to use an integer pointer or a dangling pointer as a function pointer\n+    x(); //~ ERROR: tried to use a function pointer after offsetting it\n }"}, {"sha": "1fa3a369670bbc2512f063a5b158fc8394b88e27", "filename": "tests/run-pass/packed_static.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/tests%2Frun-pass%2Fpacked_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6096fbfba1042d1f4ad3b7c7144692d1286f71a/tests%2Frun-pass%2Fpacked_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpacked_static.rs?ref=a6096fbfba1042d1f4ad3b7c7144692d1286f71a", "patch": "@@ -0,0 +1,10 @@\n+#[repr(packed)]\n+struct Foo {\n+    i: i32\n+}\n+\n+fn main() {\n+    assert_eq!({FOO.i}, 42);\n+}\n+\n+static FOO: Foo = Foo { i: 42 };"}]}