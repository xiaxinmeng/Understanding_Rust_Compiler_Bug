{"sha": "0b34e0e60bb605ac00a3c2a00a687c92675092c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiMzRlMGU2MGJiNjA1YWMwMGEzYzJhMDBhNjg3YzkyNjc1MDkyYzc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-15T07:39:24Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-15T07:49:00Z"}, "message": "Introduce new semicolon rules\n\n- Loop bodies and resource constructors aren't allowed to have\n  trailing expressions anymore.\n\n- An expression that ends* in a block without trailing expression can\n  can not be called, indexed, or subscripted.\n\n- Only expression-statements that end* in a block without trailing\n  expression can omit their semicolon.\n\n*) 'Ending in a trailing expression' is defined as being a block or\n   construct-ending-in-a-block (if, alt) that either ends in an\n   expression itself, or ends in another block-like expression that\n   has a trailing expression (by these same rules).", "tree": {"sha": "89c28c3861aa8295df0d6d223f13cf15ae167b44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89c28c3861aa8295df0d6d223f13cf15ae167b44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b34e0e60bb605ac00a3c2a00a687c92675092c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b34e0e60bb605ac00a3c2a00a687c92675092c7", "html_url": "https://github.com/rust-lang/rust/commit/0b34e0e60bb605ac00a3c2a00a687c92675092c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b34e0e60bb605ac00a3c2a00a687c92675092c7/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7298b8f4bac7687824ef41f6e3f9f114aa070417", "url": "https://api.github.com/repos/rust-lang/rust/commits/7298b8f4bac7687824ef41f6e3f9f114aa070417", "html_url": "https://github.com/rust-lang/rust/commit/7298b8f4bac7687824ef41f6e3f9f114aa070417"}], "stats": {"total": 115, "additions": 44, "deletions": 71}, "files": [{"sha": "1ea3ddbec67bfe5574694cc22be6ff14b3971d9f", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 44, "deletions": 71, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/0b34e0e60bb605ac00a3c2a00a687c92675092c7/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b34e0e60bb605ac00a3c2a00a687c92675092c7/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=0b34e0e60bb605ac00a3c2a00a687c92675092c7", "patch": "@@ -853,14 +853,14 @@ fn parse_bottom_expr(p: parser) -> @ast::expr {\n         expect(p, token::GT);\n \n         /* hack: early return to take advantage of specialized function */\n-        ret mk_mac_expr(p, lo, p.get_hi_pos(), ast::mac_embed_type(ty))\n+        ret mk_mac_expr(p, lo, p.get_hi_pos(), ast::mac_embed_type(ty));\n     } else if p.peek() == token::POUND_LBRACE {\n         p.bump();\n         let blk = ast::mac_embed_block(parse_block_tail(p, lo, ast::checked));\n         ret mk_mac_expr(p, lo, p.get_hi_pos(), blk);\n     } else if p.peek() == token::ELLIPSIS {\n         p.bump();\n-        ret mk_mac_expr(p, lo, p.get_hi_pos(), ast::mac_ellipsis)\n+        ret mk_mac_expr(p, lo, p.get_hi_pos(), ast::mac_ellipsis);\n     } else if p.peek() == token::TILDE {\n         p.bump();\n         ex = ast::expr_uniq(parse_expr(p));\n@@ -1033,7 +1033,9 @@ fn parse_self_method(p: parser) -> @ast::expr {\n }\n \n fn parse_dot_or_call_expr(p: parser) -> @ast::expr {\n-    ret parse_dot_or_call_expr_with(p, parse_bottom_expr(p));\n+    let b = parse_bottom_expr(p);\n+    if expr_has_value(b) { parse_dot_or_call_expr_with(p, b) }\n+    else { b }\n }\n \n fn parse_dot_or_call_expr_with(p: parser, e: @ast::expr) -> @ast::expr {\n@@ -1296,7 +1298,7 @@ fn parse_for_expr(p: parser) -> @ast::expr {\n     let decl = parse_local(p, false);\n     expect_word(p, \"in\");\n     let seq = parse_expr(p);\n-    let body = parse_block(p);\n+    let body = parse_block_no_value(p);\n     let hi = body.span.hi;\n     if is_each {\n         ret mk_expr(p, lo, hi, ast::expr_for_each(decl, seq, body));\n@@ -1306,14 +1308,14 @@ fn parse_for_expr(p: parser) -> @ast::expr {\n fn parse_while_expr(p: parser) -> @ast::expr {\n     let lo = p.get_last_lo_pos();\n     let cond = parse_expr(p);\n-    let body = parse_block(p);\n+    let body = parse_block_no_value(p);\n     let hi = body.span.hi;\n     ret mk_expr(p, lo, hi, ast::expr_while(cond, body));\n }\n \n fn parse_do_while_expr(p: parser) -> @ast::expr {\n     let lo = p.get_last_lo_pos();\n-    let body = parse_block(p);\n+    let body = parse_block_no_value(p);\n     expect_word(p, \"while\");\n     let cond = parse_expr(p);\n     let hi = cond.span.hi;\n@@ -1567,32 +1569,32 @@ fn parse_source_stmt(p: parser) -> @ast::stmt {\n     }\n }\n \n-fn stmt_is_expr(stmt: @ast::stmt) -> bool {\n-    fn expr_is_expr(e: @ast::expr) -> bool {\n-        alt e.node {\n-          ast::expr_if(_, th, els) | ast::expr_if_check(_, th, els) {\n-            if option::is_none(els) { false }\n-            else { !option::is_none(th.node.expr) ||\n-                       expr_is_expr(option::get(els)) }\n-          }\n-          ast::expr_alt(_, arms) {\n-            let found_expr = false;\n-            for arm in arms {\n-                if !option::is_none(arm.body.node.expr) { found_expr = true; }\n-            }\n-            found_expr\n-          }\n-          ast::expr_block(blk) | ast::expr_while(_, blk) |\n-          ast::expr_for(_, _, blk) | ast::expr_for_each(_, _, blk) |\n-          ast::expr_do_while(blk, _) {\n-            !option::is_none(blk.node.expr)\n-          }\n-          _ { true }\n+fn expr_has_value(e: @ast::expr) -> bool {\n+    alt e.node {\n+      ast::expr_if(_, th, els) | ast::expr_if_check(_, th, els) {\n+        if option::is_none(els) { false }\n+        else { !option::is_none(th.node.expr) ||\n+            expr_has_value(option::get(els)) }\n+      }\n+      ast::expr_alt(_, arms) {\n+        let found_expr = false;\n+        for arm in arms {\n+            if !option::is_none(arm.body.node.expr) { found_expr = true; }\n         }\n+        found_expr\n+      }\n+      ast::expr_block(blk) | ast::expr_while(_, blk) |\n+      ast::expr_for(_, _, blk) | ast::expr_for_each(_, _, blk) |\n+      ast::expr_do_while(blk, _) {\n+        !option::is_none(blk.node.expr)\n+      }\n+      _ { true }\n     }\n+}\n \n+fn stmt_is_expr(stmt: @ast::stmt) -> bool {\n     ret alt stmt.node {\n-      ast::stmt_expr(e, _) { expr_is_expr(e) }\n+      ast::stmt_expr(e, _) { expr_has_value(e) }\n       _ { false }\n     };\n }\n@@ -1614,49 +1616,8 @@ fn stmt_ends_with_semi(stmt: ast::stmt) -> bool {\n             }\n       }\n       ast::stmt_expr(e, _) {\n-        ret alt e.node {\n-              ast::expr_vec(_, _) { true }\n-              ast::expr_rec(_, _) { true }\n-              ast::expr_tup(_) { true }\n-              ast::expr_call(_, _) { true }\n-              ast::expr_self_method(_) { false }\n-              ast::expr_bind(_, _) { true }\n-              ast::expr_binary(_, _, _) { true }\n-              ast::expr_unary(_, _) { true }\n-              ast::expr_lit(_) { true }\n-              ast::expr_cast(_, _) { true }\n-              ast::expr_if(_, _, _) { false }\n-              ast::expr_ternary(_, _, _) { true }\n-              ast::expr_for(_, _, _) { false }\n-              ast::expr_for_each(_, _, _) { false }\n-              ast::expr_while(_, _) { false }\n-              ast::expr_do_while(_, _) { false }\n-              ast::expr_alt(_, _) { false }\n-              ast::expr_fn(_) { false }\n-              ast::expr_block(_) { false }\n-              ast::expr_copy(_) { true }\n-              ast::expr_move(_, _) { true }\n-              ast::expr_assign(_, _) { true }\n-              ast::expr_swap(_, _) { true }\n-              ast::expr_assign_op(_, _, _) { true }\n-              ast::expr_field(_, _) { true }\n-              ast::expr_index(_, _) { true }\n-              ast::expr_path(_) { true }\n-              ast::expr_mac(_) { true }\n-              ast::expr_fail(_) { true }\n-              ast::expr_break. { true }\n-              ast::expr_cont. { true }\n-              ast::expr_ret(_) { true }\n-              ast::expr_put(_) { true }\n-              ast::expr_be(_) { true }\n-              ast::expr_log(_, _) { true }\n-              ast::expr_check(_, _) { true }\n-              ast::expr_if_check(_, _, _) { false }\n-              ast::expr_anon_obj(_) { false }\n-              ast::expr_assert(_) { true }\n-            }\n+        ret expr_has_value(e);\n       }\n-\n       // We should not be calling this on a cdir.\n       ast::stmt_crate_directive(cdir) {\n         fail;\n@@ -1674,6 +1635,18 @@ fn parse_block(p: parser) -> ast::blk {\n     }\n }\n \n+fn parse_block_no_value(p: parser) -> ast::blk {\n+    let blk = parse_block(p);\n+    if !option::is_none(blk.node.expr) {\n+        let sp = option::get(blk.node.expr).span;\n+        codemap::emit_error(some(sp),\n+                            \"this block must not return a value\",\n+                            p.get_sess().cm);\n+        fail;\n+    }\n+    ret blk;\n+}\n+\n // Precondition: already parsed the '{' or '#{'\n // I guess that also means \"already parsed the 'impure'\" if\n // necessary, and this should take a qualifier.\n@@ -1870,7 +1843,7 @@ fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     expect(p, token::COLON);\n     let t = parse_ty(p, false);\n     expect(p, token::RPAREN);\n-    let dtor = parse_block(p);\n+    let dtor = parse_block_no_value(p);\n     let decl =\n         {inputs:\n              [{mode: ast::by_ref, ty: t, ident: arg_ident, id: p.get_id()}],"}]}