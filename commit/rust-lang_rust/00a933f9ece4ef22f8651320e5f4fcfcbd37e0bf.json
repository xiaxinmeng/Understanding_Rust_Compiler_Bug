{"sha": "00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwYTkzM2Y5ZWNlNGVmMjJmODY1MTMyMGU1ZjRmY2ZjYmQzN2UwYmY=", "commit": {"author": {"name": "Alfie John", "email": "alfiej@fastmail.fm", "date": "2015-01-25T10:58:43Z"}, "committer": {"name": "Alfie John", "email": "alfiej@fastmail.fm", "date": "2015-02-01T10:34:16Z"}, "message": "More deprecating of i/u suffixes in libraries", "tree": {"sha": "58bfb6b59488471ad7aa1dd9d9b95657f9452e8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58bfb6b59488471ad7aa1dd9d9b95657f9452e8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "html_url": "https://github.com/rust-lang/rust/commit/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/comments", "author": null, "committer": null, "parents": [{"sha": "fe4340ab18abc53af40e40a6696dfbe2375238b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe4340ab18abc53af40e40a6696dfbe2375238b0", "html_url": "https://github.com/rust-lang/rust/commit/fe4340ab18abc53af40e40a6696dfbe2375238b0"}], "stats": {"total": 402, "additions": 201, "deletions": 201}, "files": [{"sha": "21b9c060f6f3bea330c797f205833a77154c374c", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -39,7 +39,7 @@\n //!\n //! let five = Arc::new(5);\n //!\n-//! for _ in 0u..10 {\n+//! for _ in 0..10 {\n //!     let five = five.clone();\n //!\n //!     Thread::spawn(move || {\n@@ -56,7 +56,7 @@\n //!\n //! let five = Arc::new(Mutex::new(5));\n //!\n-//! for _ in 0u..10 {\n+//! for _ in 0..10 {\n //!     let five = five.clone();\n //!\n //!     Thread::spawn(move || {\n@@ -101,7 +101,7 @@ use heap::deallocate;\n ///     let numbers: Vec<_> = (0..100u32).map(|i| i as f32).collect();\n ///     let shared_numbers = Arc::new(numbers);\n ///\n-///     for _ in 0u..10 {\n+///     for _ in 0..10 {\n ///         let child_numbers = shared_numbers.clone();\n ///\n ///         Thread::spawn(move || {\n@@ -661,7 +661,7 @@ mod tests {\n \n     #[test]\n     fn test_cowarc_clone_make_unique() {\n-        let mut cow0 = Arc::new(75u);\n+        let mut cow0 = Arc::new(75);\n         let mut cow1 = cow0.clone();\n         let mut cow2 = cow1.clone();\n \n@@ -685,7 +685,7 @@ mod tests {\n \n     #[test]\n     fn test_cowarc_clone_unique2() {\n-        let mut cow0 = Arc::new(75u);\n+        let mut cow0 = Arc::new(75);\n         let cow1 = cow0.clone();\n         let cow2 = cow1.clone();\n \n@@ -708,7 +708,7 @@ mod tests {\n \n     #[test]\n     fn test_cowarc_clone_weak() {\n-        let mut cow0 = Arc::new(75u);\n+        let mut cow0 = Arc::new(75);\n         let cow1_weak = cow0.downgrade();\n \n         assert!(75 == *cow0);"}, {"sha": "6f6d9ab394d5c3e66e43511790dddb18db1bcc3c", "filename": "src/liballoc/boxed_test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Fliballoc%2Fboxed_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Fliballoc%2Fboxed_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed_test.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -30,19 +30,19 @@ struct Test;\n \n #[test]\n fn any_move() {\n-    let a = Box::new(8u) as Box<Any>;\n+    let a = Box::new(8us) as Box<Any>;\n     let b = Box::new(Test) as Box<Any>;\n \n     match a.downcast::<uint>() {\n-        Ok(a) => { assert!(a == Box::new(8u)); }\n+        Ok(a) => { assert!(a == Box::new(8us)); }\n         Err(..) => panic!()\n     }\n     match b.downcast::<Test>() {\n         Ok(a) => { assert!(a == Box::new(Test)); }\n         Err(..) => panic!()\n     }\n \n-    let a = Box::new(8u) as Box<Any>;\n+    let a = Box::new(8) as Box<Any>;\n     let b = Box::new(Test) as Box<Any>;\n \n     assert!(a.downcast::<Box<Test>>().is_err());\n@@ -51,14 +51,14 @@ fn any_move() {\n \n #[test]\n fn test_show() {\n-    let a = Box::new(8u) as Box<Any>;\n+    let a = Box::new(8) as Box<Any>;\n     let b = Box::new(Test) as Box<Any>;\n     let a_str = format!(\"{:?}\", a);\n     let b_str = format!(\"{:?}\", b);\n     assert_eq!(a_str, \"Box<Any>\");\n     assert_eq!(b_str, \"Box<Any>\");\n \n-    static EIGHT: usize = 8us;\n+    static EIGHT: usize = 8;\n     static TEST: Test = Test;\n     let a = &EIGHT as &Any;\n     let b = &TEST as &Any;"}, {"sha": "464f20e9cac53f03df5344363567837614a4d0f2", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -266,12 +266,12 @@ pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n /// ```\n /// use std::rc::{self, Rc};\n ///\n-/// let x = Rc::new(3u);\n-/// assert_eq!(rc::try_unwrap(x), Ok(3u));\n+/// let x = Rc::new(3);\n+/// assert_eq!(rc::try_unwrap(x), Ok(3));\n ///\n-/// let x = Rc::new(4u);\n+/// let x = Rc::new(4);\n /// let _y = x.clone();\n-/// assert_eq!(rc::try_unwrap(x), Err(Rc::new(4u)));\n+/// assert_eq!(rc::try_unwrap(x), Err(Rc::new(4)));\n /// ```\n #[inline]\n #[unstable(feature = \"alloc\")]\n@@ -300,9 +300,9 @@ pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n /// ```\n /// use std::rc::{self, Rc};\n ///\n-/// let mut x = Rc::new(3u);\n-/// *rc::get_mut(&mut x).unwrap() = 4u;\n-/// assert_eq!(*x, 4u);\n+/// let mut x = Rc::new(3);\n+/// *rc::get_mut(&mut x).unwrap() = 4;\n+/// assert_eq!(*x, 4);\n ///\n /// let _y = x.clone();\n /// assert!(rc::get_mut(&mut x).is_none());\n@@ -845,7 +845,7 @@ mod tests {\n \n     #[test]\n     fn is_unique() {\n-        let x = Rc::new(3u);\n+        let x = Rc::new(3);\n         assert!(super::is_unique(&x));\n         let y = x.clone();\n         assert!(!super::is_unique(&x));\n@@ -893,21 +893,21 @@ mod tests {\n \n     #[test]\n     fn try_unwrap() {\n-        let x = Rc::new(3u);\n-        assert_eq!(super::try_unwrap(x), Ok(3u));\n-        let x = Rc::new(4u);\n+        let x = Rc::new(3);\n+        assert_eq!(super::try_unwrap(x), Ok(3));\n+        let x = Rc::new(4);\n         let _y = x.clone();\n-        assert_eq!(super::try_unwrap(x), Err(Rc::new(4u)));\n-        let x = Rc::new(5u);\n+        assert_eq!(super::try_unwrap(x), Err(Rc::new(4)));\n+        let x = Rc::new(5);\n         let _w = x.downgrade();\n-        assert_eq!(super::try_unwrap(x), Err(Rc::new(5u)));\n+        assert_eq!(super::try_unwrap(x), Err(Rc::new(5)));\n     }\n \n     #[test]\n     fn get_mut() {\n-        let mut x = Rc::new(3u);\n-        *super::get_mut(&mut x).unwrap() = 4u;\n-        assert_eq!(*x, 4u);\n+        let mut x = Rc::new(3);\n+        *super::get_mut(&mut x).unwrap() = 4;\n+        assert_eq!(*x, 4);\n         let y = x.clone();\n         assert!(super::get_mut(&mut x).is_none());\n         drop(y);\n@@ -918,7 +918,7 @@ mod tests {\n \n     #[test]\n     fn test_cowrc_clone_make_unique() {\n-        let mut cow0 = Rc::new(75u);\n+        let mut cow0 = Rc::new(75);\n         let mut cow1 = cow0.clone();\n         let mut cow2 = cow1.clone();\n \n@@ -942,7 +942,7 @@ mod tests {\n \n     #[test]\n     fn test_cowrc_clone_unique2() {\n-        let mut cow0 = Rc::new(75u);\n+        let mut cow0 = Rc::new(75);\n         let cow1 = cow0.clone();\n         let cow2 = cow1.clone();\n \n@@ -965,7 +965,7 @@ mod tests {\n \n     #[test]\n     fn test_cowrc_clone_weak() {\n-        let mut cow0 = Rc::new(75u);\n+        let mut cow0 = Rc::new(75);\n         let cow1_weak = cow0.downgrade();\n \n         assert!(75 == *cow0);\n@@ -979,7 +979,7 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let foo = Rc::new(75u);\n+        let foo = Rc::new(75);\n         assert_eq!(format!(\"{:?}\", foo), \"75\");\n     }\n "}, {"sha": "904c9c3adb567fac1362f3ce88790e50c3882daf", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -493,7 +493,7 @@ pub struct BoxPointers;\n impl BoxPointers {\n     fn check_heap_type<'a, 'tcx>(&self, cx: &Context<'a, 'tcx>,\n                                  span: Span, ty: Ty<'tcx>) {\n-        let mut n_uniq = 0u;\n+        let mut n_uniq = 0us;\n         ty::fold_ty(cx.tcx, ty, |t| {\n             match t.sty {\n                 ty::ty_uniq(_) => {"}, {"sha": "c649ff2635bf005906cbf69d567ef5abab251865", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -490,7 +490,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n         // current dictionary of lint information. Along the way, keep a history\n         // of what we changed so we can roll everything back after invoking the\n         // specified closure\n-        let mut pushed = 0u;\n+        let mut pushed = 0;\n \n         for result in gather_attrs(attrs).into_iter() {\n             let v = match result {"}, {"sha": "94fe99ff07d8e44a2ce85c5d710082d99e229623", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -88,7 +88,7 @@ pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n                            items: rbml::Doc<'a>) -> Option<rbml::Doc<'a>> {\n     fn eq_item(bytes: &[u8], item_id: ast::NodeId) -> bool {\n         return u64_from_be_bytes(\n-            &bytes[0u..4u], 0u, 4u) as ast::NodeId\n+            &bytes[0..4], 0, 4) as ast::NodeId\n             == item_id;\n     }\n     lookup_hash(items,\n@@ -1164,7 +1164,7 @@ fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n-            assert_eq!(meta_items.len(), 1u);\n+            assert_eq!(meta_items.len(), 1);\n             let meta_item = meta_items.into_iter().nth(0).unwrap();\n             attrs.push(\n                 codemap::Spanned {"}, {"sha": "94d133995078d64e5cb5822d5f217eee72edee36", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -1071,7 +1071,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n         encode_attributes(rbml_w, &item.attrs[]);\n-        if tps_len > 0u || should_inline(&item.attrs[]) {\n+        if tps_len > 0 || should_inline(&item.attrs[]) {\n             encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n         }\n         if tps_len == 0 {"}, {"sha": "09957f58bccc29cf17f71c49f5b00bdbe221970e", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -487,7 +487,7 @@ impl<'a> Context<'a> {\n     fn extract_one(&mut self, m: HashMap<Path, PathKind>, flavor: &str,\n                    slot: &mut Option<MetadataBlob>) -> Option<(Path, PathKind)> {\n         let mut ret = None::<(Path, PathKind)>;\n-        let mut error = 0u;\n+        let mut error = 0;\n \n         if slot.is_some() {\n             // FIXME(#10786): for an optimization, we only read one of the"}, {"sha": "ac6d2d0174c131dbe8e6172f8f97fcf0c6d0cc45", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -76,13 +76,13 @@ fn peek(st: &PState) -> char {\n \n fn next(st: &mut PState) -> char {\n     let ch = st.data[st.pos] as char;\n-    st.pos = st.pos + 1u;\n+    st.pos = st.pos + 1;\n     return ch;\n }\n \n fn next_byte(st: &mut PState) -> u8 {\n     let b = st.data[st.pos];\n-    st.pos = st.pos + 1u;\n+    st.pos = st.pos + 1;\n     return b;\n }\n \n@@ -498,7 +498,7 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n         assert_eq!(next(st), '[');\n         let mut params = Vec::new();\n         while peek(st) != ']' { params.push(parse_ty_(st, conv)); }\n-        st.pos = st.pos + 1u;\n+        st.pos = st.pos + 1;\n         return ty::mk_tup(tcx, params);\n       }\n       'F' => {\n@@ -590,7 +590,7 @@ fn parse_uint(st: &mut PState) -> uint {\n     loop {\n         let cur = peek(st);\n         if cur < '0' || cur > '9' { return n; }\n-        st.pos = st.pos + 1u;\n+        st.pos = st.pos + 1;\n         n *= 10;\n         n += (cur as uint) - ('0' as uint);\n     };\n@@ -608,15 +608,15 @@ fn parse_param_space(st: &mut PState) -> subst::ParamSpace {\n }\n \n fn parse_hex(st: &mut PState) -> uint {\n-    let mut n = 0u;\n+    let mut n = 0;\n     loop {\n         let cur = peek(st);\n         if (cur < '0' || cur > '9') && (cur < 'a' || cur > 'f') { return n; }\n-        st.pos = st.pos + 1u;\n-        n *= 16u;\n+        st.pos = st.pos + 1;\n+        n *= 16;\n         if '0' <= cur && cur <= '9' {\n             n += (cur as uint) - ('0' as uint);\n-        } else { n += 10u + (cur as uint) - ('a' as uint); }\n+        } else { n += 10 + (cur as uint) - ('a' as uint); }\n     };\n }\n \n@@ -686,15 +686,15 @@ fn parse_sig_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> ty::PolyF\n     while peek(st) != ']' {\n         inputs.push(parse_ty_(st, conv));\n     }\n-    st.pos += 1u; // eat the ']'\n+    st.pos += 1; // eat the ']'\n     let variadic = match next(st) {\n         'V' => true,\n         'N' => false,\n         r => panic!(format!(\"bad variadic: {}\", r)),\n     };\n     let output = match peek(st) {\n         'z' => {\n-          st.pos += 1u;\n+          st.pos += 1;\n           ty::FnDiverging\n         }\n         _ => ty::FnConverging(parse_ty_(st, conv))\n@@ -706,16 +706,16 @@ fn parse_sig_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> ty::PolyF\n \n // Rust metadata parsing\n pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n-    let mut colon_idx = 0u;\n+    let mut colon_idx = 0;\n     let len = buf.len();\n-    while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1u; }\n+    while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1; }\n     if colon_idx == len {\n         error!(\"didn't find ':' when parsing def id\");\n         panic!();\n     }\n \n-    let crate_part = &buf[0u..colon_idx];\n-    let def_part = &buf[colon_idx + 1u..len];\n+    let crate_part = &buf[0..colon_idx];\n+    let def_part = &buf[colon_idx + 1..len];\n \n     let crate_num = match str::from_utf8(crate_part).ok().and_then(|s| {\n         s.parse::<uint>().ok()"}, {"sha": "7143e3caac208f135dda9d44515bbcdd7dcee59c", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -25,14 +25,14 @@ pub const NO_TPS: uint = 2;\n pub fn check_path_args(tcx: &ty::ctxt,\n                        path: &ast::Path,\n                        flags: uint) {\n-    if (flags & NO_TPS) != 0u {\n+    if (flags & NO_TPS) != 0 {\n         if path.segments.iter().any(|s| s.parameters.has_types()) {\n             span_err!(tcx.sess, path.span, E0109,\n                 \"type parameters are not allowed on this type\");\n         }\n     }\n \n-    if (flags & NO_REGIONS) != 0u {\n+    if (flags & NO_REGIONS) != 0 {\n         if path.segments.iter().any(|s| s.parameters.has_lifetimes()) {\n             span_err!(tcx.sess, path.span, E0110,\n                 \"region parameters are not allowed on this type\");"}, {"sha": "6a5c3b0fc37665fa3e4be6334c0a7eb1ea8c3c4d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -579,16 +579,16 @@ fn encode_method_callee<'a, 'tcx>(ecx: &e::EncodeContext<'a, 'tcx>,\n     use serialize::Encoder;\n \n     rbml_w.emit_struct(\"MethodCallee\", 4, |rbml_w| {\n-        rbml_w.emit_struct_field(\"adjustment\", 0u, |rbml_w| {\n+        rbml_w.emit_struct_field(\"adjustment\", 0, |rbml_w| {\n             adjustment.encode(rbml_w)\n         });\n-        rbml_w.emit_struct_field(\"origin\", 1u, |rbml_w| {\n+        rbml_w.emit_struct_field(\"origin\", 1, |rbml_w| {\n             Ok(rbml_w.emit_method_origin(ecx, &method.origin))\n         });\n-        rbml_w.emit_struct_field(\"ty\", 2u, |rbml_w| {\n+        rbml_w.emit_struct_field(\"ty\", 2, |rbml_w| {\n             Ok(rbml_w.emit_ty(ecx, method.ty))\n         });\n-        rbml_w.emit_struct_field(\"substs\", 3u, |rbml_w| {\n+        rbml_w.emit_struct_field(\"substs\", 3, |rbml_w| {\n             Ok(rbml_w.emit_substs(ecx, &method.substs))\n         })\n     }).unwrap();\n@@ -743,30 +743,30 @@ impl<'tcx, 'a> vtable_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                 Ok(match i {\n                   0 => {\n                     ty::vtable_static(\n-                        this.read_enum_variant_arg(0u, |this| {\n+                        this.read_enum_variant_arg(0, |this| {\n                             Ok(this.read_def_id_nodcx(cdata))\n                         }).unwrap(),\n-                        this.read_enum_variant_arg(1u, |this| {\n+                        this.read_enum_variant_arg(1, |this| {\n                             Ok(this.read_substs_nodcx(tcx, cdata))\n                         }).unwrap(),\n-                        this.read_enum_variant_arg(2u, |this| {\n+                        this.read_enum_variant_arg(2, |this| {\n                             Ok(this.read_vtable_res(tcx, cdata))\n                         }).unwrap()\n                     )\n                   }\n                   1 => {\n                     ty::vtable_param(\n-                        this.read_enum_variant_arg(0u, |this| {\n+                        this.read_enum_variant_arg(0, |this| {\n                             Decodable::decode(this)\n                         }).unwrap(),\n-                        this.read_enum_variant_arg(1u, |this| {\n+                        this.read_enum_variant_arg(1, |this| {\n                             this.read_uint()\n                         }).unwrap()\n                     )\n                   }\n                   2 => {\n                     ty::vtable_closure(\n-                        this.read_enum_variant_arg(0u, |this| {\n+                        this.read_enum_variant_arg(0, |this| {\n                             Ok(this.read_def_id_nodcx(cdata))\n                         }).unwrap()\n                     )"}, {"sha": "6de517b29069d689959431a646966598deb47474", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -68,10 +68,10 @@ impl<'a> fmt::Debug for Matrix<'a> {\n                .collect::<Vec<String>>()\n         }).collect();\n \n-        let column_count = m.iter().map(|row| row.len()).max().unwrap_or(0u);\n+        let column_count = m.iter().map(|row| row.len()).max().unwrap_or(0);\n         assert!(m.iter().all(|row| row.len() == column_count));\n         let column_widths: Vec<uint> = (0..column_count).map(|col| {\n-            pretty_printed_matrix.iter().map(|row| row[col].len()).max().unwrap_or(0u)\n+            pretty_printed_matrix.iter().map(|row| row[col].len()).max().unwrap_or(0)\n         }).collect();\n \n         let total_width = column_widths.iter().map(|n| *n).sum() + column_count * 3 + 1;\n@@ -588,13 +588,13 @@ fn is_useful(cx: &MatchCheckCtxt,\n              -> Usefulness {\n     let &Matrix(ref rows) = matrix;\n     debug!(\"{:?}\", matrix);\n-    if rows.len() == 0u {\n+    if rows.len() == 0 {\n         return match witness {\n             ConstructWitness => UsefulWithWitness(vec!()),\n             LeaveOutWitness => Useful\n         };\n     }\n-    if rows[0].len() == 0u {\n+    if rows[0].len() == 0 {\n         return NotUseful;\n     }\n     let real_pat = match rows.iter().find(|r| (*r)[0].id != DUMMY_NODE_ID) {\n@@ -669,9 +669,9 @@ fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n                          witness: WitnessPreference) -> Usefulness {\n     let arity = constructor_arity(cx, &ctor, lty);\n     let matrix = Matrix(m.iter().filter_map(|r| {\n-        specialize(cx, &r[], &ctor, 0u, arity)\n+        specialize(cx, &r[], &ctor, 0, arity)\n     }).collect());\n-    match specialize(cx, v, &ctor, 0u, arity) {\n+    match specialize(cx, v, &ctor, 0, arity) {\n         Some(v) => is_useful(cx, &matrix, &v[], witness),\n         None => NotUseful\n     }\n@@ -742,20 +742,20 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n /// This computes the arity of a constructor. The arity of a constructor\n /// is how many subpattern patterns of that constructor should be expanded to.\n ///\n-/// For instance, a tuple pattern (_, 42u, Some([])) has the arity of 3.\n+/// For instance, a tuple pattern (_, 42, Some([])) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> uint {\n     match ty.sty {\n         ty::ty_tup(ref fs) => fs.len(),\n-        ty::ty_uniq(_) => 1u,\n+        ty::ty_uniq(_) => 1,\n         ty::ty_rptr(_, ty::mt { ty, .. }) => match ty.sty {\n             ty::ty_vec(_, None) => match *ctor {\n                 Slice(length) => length,\n-                ConstantValue(_) => 0u,\n+                ConstantValue(_) => 0,\n                 _ => unreachable!()\n             },\n-            ty::ty_str => 0u,\n-            _ => 1u\n+            ty::ty_str => 0,\n+            _ => 1\n         },\n         ty::ty_enum(eid, _) => {\n             match *ctor {\n@@ -765,7 +765,7 @@ pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> uin\n         }\n         ty::ty_struct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n         ty::ty_vec(_, Some(n)) => n,\n-        _ => 0u\n+        _ => 0\n     }\n }\n "}, {"sha": "3e2e81077daaee18b0b81877d135dafbcbe422cb", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -352,7 +352,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         for (word_index, &word) in words.iter().enumerate() {\n             if word != 0 {\n                 let base_index = word_index * uint::BITS;\n-                for offset in 0u..uint::BITS {\n+                for offset in 0..uint::BITS {\n                     let bit = 1 << offset;\n                     if (word & bit) != 0 {\n                         // NB: we round up the total number of bits\n@@ -447,7 +447,7 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n                 changed: true\n             };\n \n-            let mut temp: Vec<_> = repeat(0u).take(words_per_id).collect();\n+            let mut temp: Vec<_> = repeat(0).take(words_per_id).collect();\n             while propcx.changed {\n                 propcx.changed = false;\n                 propcx.reset(temp.as_mut_slice());\n@@ -466,7 +466,7 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n                        blk: &ast::Block) -> old_io::IoResult<()> {\n         let mut ps = pprust::rust_printer_annotated(wr, self);\n         try!(ps.cbox(pprust::indent_unit));\n-        try!(ps.ibox(0u));\n+        try!(ps.ibox(0));\n         try!(ps.print_block(blk));\n         pp::eof(&mut ps.s)\n     }\n@@ -552,7 +552,7 @@ fn bits_to_string(words: &[uint]) -> String {\n \n     for &word in words.iter() {\n         let mut v = word;\n-        for _ in 0u..uint::BYTES {\n+        for _ in 0..uint::BYTES {\n             result.push(sep);\n             result.push_str(&format!(\"{:02x}\", v & 0xFF)[]);\n             v >>= 8;\n@@ -593,7 +593,7 @@ fn set_bit(words: &mut [uint], bit: uint) -> bool {\n \n fn bit_str(bit: uint) -> String {\n     let byte = bit >> 8;\n-    let lobits = 1u << (bit & 0xFF);\n+    let lobits = 1 << (bit & 0xFF);\n     format!(\"[{}:{}-{:02x}]\", bit, byte, lobits)\n }\n "}, {"sha": "8952452cb4baed1ea65658bba3f046babb359ebe", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -1259,7 +1259,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         let mut opt_graph = None;\n \n-        for idx in 0u..self.num_vars() as uint {\n+        for idx in 0..self.num_vars() as uint {\n             match var_data[idx].value {\n                 Value(_) => {\n                     /* Inference successful */\n@@ -1548,7 +1548,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn iterate_until_fixed_point<F>(&self, tag: &str, mut body: F) where\n         F: FnMut(&Constraint) -> bool,\n     {\n-        let mut iteration = 0u;\n+        let mut iteration = 0;\n         let mut changed = true;\n         while changed {\n             changed = false;"}, {"sha": "cb0157fed8712c90fcffad595fd92f27f162ebdf", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -540,9 +540,9 @@ struct Specials {\n     clean_exit_var: Variable\n }\n \n-static ACC_READ: uint = 1u;\n-static ACC_WRITE: uint = 2u;\n-static ACC_USE: uint = 4u;\n+static ACC_READ: uint = 1;\n+static ACC_WRITE: uint = 2;\n+static ACC_USE: uint = 4;\n \n struct Liveness<'a, 'tcx: 'a> {\n     ir: &'a mut IrMaps<'a, 'tcx>,\n@@ -672,9 +672,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn indices2<F>(&mut self, ln: LiveNode, succ_ln: LiveNode, mut op: F) where\n         F: FnMut(&mut Liveness<'a, 'tcx>, uint, uint),\n     {\n-        let node_base_idx = self.idx(ln, Variable(0u));\n-        let succ_base_idx = self.idx(succ_ln, Variable(0u));\n-        for var_idx in 0u..self.ir.num_vars {\n+        let node_base_idx = self.idx(ln, Variable(0));\n+        let succ_base_idx = self.idx(succ_ln, Variable(0));\n+        for var_idx in 0..self.ir.num_vars {\n             op(self, node_base_idx + var_idx, succ_base_idx + var_idx);\n         }\n     }\n@@ -687,7 +687,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         F: FnMut(uint) -> LiveNode,\n     {\n         let node_base_idx = self.idx(ln, Variable(0));\n-        for var_idx in 0u..self.ir.num_vars {\n+        for var_idx in 0..self.ir.num_vars {\n             let idx = node_base_idx + var_idx;\n             if test(idx).is_valid() {\n                 try!(write!(wr, \" {:?}\", Variable(var_idx)));\n@@ -847,7 +847,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // hack to skip the loop unless debug! is enabled:\n         debug!(\"^^ liveness computation results for body {} (entry={:?})\",\n                {\n-                   for ln_idx in 0u..self.ir.num_live_nodes {\n+                   for ln_idx in 0..self.ir.num_live_nodes {\n                        debug!(\"{:?}\", self.ln_str(LiveNode(ln_idx)));\n                    }\n                    body.id\n@@ -1303,7 +1303,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         match self.ir.tcx.def_map.borrow()[expr.id].clone() {\n           DefLocal(nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n-            if acc != 0u {\n+            if acc != 0 {\n                 self.init_from_succ(ln, succ);\n                 let var = self.variable(nid, expr.span);\n                 self.acc(ln, var, acc);"}, {"sha": "9363ad22187ca24d59712c5aa2a639d4309247a3", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -454,7 +454,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         debug!(\"cat_expr_autoderefd: autoderefs={}, cmt={}\",\n                autoderefs,\n                cmt.repr(self.tcx()));\n-        for deref in 1u..autoderefs + 1 {\n+        for deref in 1..autoderefs + 1 {\n             cmt = try!(self.cat_deref(expr, cmt, deref));\n         }\n         return Ok(cmt);"}, {"sha": "3f8b7e5a7b37edc3e01c011db24809eb07c683b6", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -461,8 +461,8 @@ impl RegionMaps {\n \n         let a_ancestors = ancestors_of(self, scope_a);\n         let b_ancestors = ancestors_of(self, scope_b);\n-        let mut a_index = a_ancestors.len() - 1u;\n-        let mut b_index = b_ancestors.len() - 1u;\n+        let mut a_index = a_ancestors.len() - 1;\n+        let mut b_index = b_ancestors.len() - 1;\n \n         // Here, ~[ab]_ancestors is a vector going from narrow to broad.\n         // The end of each vector will be the item where the scope is\n@@ -479,10 +479,10 @@ impl RegionMaps {\n         loop {\n             // Loop invariant: a_ancestors[a_index] == b_ancestors[b_index]\n             // for all indices between a_index and the end of the array\n-            if a_index == 0u { return Some(scope_a); }\n-            if b_index == 0u { return Some(scope_b); }\n-            a_index -= 1u;\n-            b_index -= 1u;\n+            if a_index == 0 { return Some(scope_a); }\n+            if b_index == 0 { return Some(scope_b); }\n+            a_index -= 1;\n+            b_index -= 1;\n             if a_ancestors[a_index] != b_ancestors[b_index] {\n                 return Some(a_ancestors[a_index + 1]);\n             }"}, {"sha": "cdcd02ba83a722bbea46dafac817155e8c9a21e8", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -4475,7 +4475,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             match resolve_expr(tcx, expr) {\n                 def::DefVariant(tid, vid, _) => {\n                     let variant_info = enum_variant_with_id(tcx, tid, vid);\n-                    if variant_info.args.len() > 0u {\n+                    if variant_info.args.len() > 0 {\n                         // N-ary variant.\n                         RvalueDatumExpr\n                     } else {\n@@ -4639,8 +4639,8 @@ pub fn stmt_node_id(s: &ast::Stmt) -> ast::NodeId {\n \n pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n                      -> uint {\n-    let mut i = 0u;\n-    for f in fields.iter() { if f.name == name { return i; } i += 1u; }\n+    let mut i = 0;\n+    for f in fields.iter() { if f.name == name { return i; } i += 1; }\n     tcx.sess.bug(&format!(\n         \"no field named `{}` found in the list of fields `{:?}`\",\n         token::get_name(name),"}, {"sha": "54384da33fcd082d414bfdc1df5f6de25b88abf6", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -260,7 +260,7 @@ fn split_msg_into_multilines(msg: &str) -> Option<String> {\n     }).map(|(a, b)| (a - 1, b));\n \n     let mut new_msg = String::new();\n-    let mut head = 0u;\n+    let mut head = 0;\n \n     // Insert `\\n` before expected and found.\n     for (pos1, pos2) in first.zip(second) {"}, {"sha": "b351f7fcef212c99e247b6024fa34909d236ded4", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -531,8 +531,8 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n \n pub fn ty_to_short_str<'tcx>(cx: &ctxt<'tcx>, typ: Ty<'tcx>) -> String {\n     let mut s = typ.repr(cx).to_string();\n-    if s.len() >= 32u {\n-        s = (&s[0u..32u]).to_string();\n+    if s.len() >= 32 {\n+        s = (&s[0u..32]).to_string();\n     }\n     return s;\n }"}, {"sha": "c97d9090441a3d129923734faedc4c9f0e28e423", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -256,7 +256,7 @@ pub fn sanitize(s: &str) -> String {\n     }\n \n     // Underscore-qualify anything that didn't start as an ident.\n-    if result.len() > 0u &&\n+    if result.len() > 0 &&\n         result.as_bytes()[0] != '_' as u8 &&\n         ! (result.as_bytes()[0] as char).is_xid_start() {\n         return format!(\"_{}\", &result[]);"}, {"sha": "5fcf0be4c67f0c35f76b8b81d9e2c796d6d5b006", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -62,7 +62,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n         let file = path.filename_str().unwrap();\n         let file = &file[3..file.len() - 5]; // chop off lib/.rlib\n         debug!(\"reading {}\", file);\n-        for i in iter::count(0u, 1) {\n+        for i in iter::count(0us, 1) {\n             let bc_encoded = time(sess.time_passes(),\n                                   format!(\"check for {}.{}.bytecode.deflate\", name, i).as_slice(),\n                                   (),"}, {"sha": "f6f03887528aec8a8b8343947a192cd126291303", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -272,7 +272,7 @@ impl<'a> FmtStrs<'a> {\n         self.check_and_record(Variable,\n                               span,\n                               sub_span,\n-                              svec!(id, name, qualname, value, typ, 0u));\n+                              svec!(id, name, qualname, value, typ, 0));\n     }\n \n     // formal parameters\n@@ -289,7 +289,7 @@ impl<'a> FmtStrs<'a> {\n         self.check_and_record(Variable,\n                               span,\n                               sub_span,\n-                              svec!(id, name, qualname, \"\", typ, 0u));\n+                              svec!(id, name, qualname, \"\", typ, 0));\n     }\n \n     // value is the initialising expression of the static if it is not mut, otherwise \"\".\n@@ -520,7 +520,7 @@ impl<'a> FmtStrs<'a> {\n                               svec!(base_id.node,\n                                     base_id.krate,\n                                     deriv_id,\n-                                    0u));\n+                                    0));\n     }\n \n     pub fn fn_call_str(&mut self,\n@@ -562,7 +562,7 @@ impl<'a> FmtStrs<'a> {\n         self.record_with_span(ModRef,\n                               span,\n                               sub_span,\n-                              svec!(0u, 0u, qualname, parent));\n+                              svec!(0, 0, qualname, parent));\n     }\n \n     pub fn typedef_str(&mut self,\n@@ -603,7 +603,7 @@ impl<'a> FmtStrs<'a> {\n         self.record_with_span(TypeRef,\n                               span,\n                               sub_span,\n-                              svec!(0u, 0u, qualname, 0u));\n+                              svec!(0, 0, qualname, 0));\n     }\n \n     // A slightly generic function for a reference to an item of any kind."}, {"sha": "beec8071a72baf4f1491864da078b072aae0ca28", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -94,7 +94,7 @@ impl<'a> SpanUtils<'a> {\n         let mut result = None;\n \n         let mut toks = self.retokenise_span(span);\n-        let mut bracket_count = 0u;\n+        let mut bracket_count = 0;\n         loop {\n             let ts = toks.real_token();\n             if ts.tok == token::Eof {\n@@ -117,7 +117,7 @@ impl<'a> SpanUtils<'a> {\n     // Return the span for the first identifier in the path.\n     pub fn span_for_first_ident(&self, span: Span) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n-        let mut bracket_count = 0u;\n+        let mut bracket_count = 0;\n         loop {\n             let ts = toks.real_token();\n             if ts.tok == token::Eof {\n@@ -143,7 +143,7 @@ impl<'a> SpanUtils<'a> {\n         let mut toks = self.retokenise_span(span);\n         let mut prev = toks.real_token();\n         let mut result = None;\n-        let mut bracket_count = 0u;\n+        let mut bracket_count = 0;\n         let mut last_span = None;\n         while prev.tok != token::Eof {\n             last_span = None;\n@@ -191,7 +191,7 @@ impl<'a> SpanUtils<'a> {\n         let mut toks = self.retokenise_span(span);\n         let mut prev = toks.real_token();\n         let mut result = None;\n-        let mut bracket_count = 0u;\n+        let mut bracket_count = 0;\n         loop {\n             let next = toks.real_token();\n "}, {"sha": "b66e2770815c348ec288ca4f60e4cd5e05e57a61", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -32,7 +32,7 @@\n //!     match foo {\n //!         A => ...,\n //!         B(x) => ...,\n-//!         C(1u, 2) => ...,\n+//!         C(1, 2) => ...,\n //!         C(_) => ...\n //!     }\n //!\n@@ -41,7 +41,7 @@\n //! various options and then compile the code for the case where `foo` is an\n //! `A`, a `B`, and a `C`.  When we generate the code for `C`, we would (1)\n //! drop the two matches that do not match a `C` and (2) expand the other two\n-//! into two patterns each.  In the first case, the two patterns would be `1u`\n+//! into two patterns each.  In the first case, the two patterns would be `1`\n //! and `2`, and the in the second case the _ pattern would be expanded into\n //! `_` and `_`.  The two values are of course the arguments to `C`.\n //!\n@@ -638,8 +638,8 @@ fn bind_subslice_pat(bcx: Block,\n                                 ty::mt {ty: vt.unit_ty, mutbl: ast::MutImmutable});\n     let scratch = rvalue_scratch_datum(bcx, slice_ty, \"\");\n     Store(bcx, slice_begin,\n-          GEPi(bcx, scratch.val, &[0u, abi::FAT_PTR_ADDR]));\n-    Store(bcx, slice_len, GEPi(bcx, scratch.val, &[0u, abi::FAT_PTR_EXTRA]));\n+          GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_ADDR]));\n+    Store(bcx, slice_len, GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_EXTRA]));\n     scratch.val\n }\n \n@@ -742,8 +742,8 @@ fn pick_column_to_specialize(def_map: &DefMap, m: &[Match]) -> Option<uint> {\n     fn pat_score(def_map: &DefMap, pat: &ast::Pat) -> uint {\n         match pat.node {\n             ast::PatIdent(_, _, Some(ref inner)) => pat_score(def_map, &**inner),\n-            _ if pat_is_refutable(def_map, pat) => 1u,\n-            _ => 0u\n+            _ if pat_is_refutable(def_map, pat) => 1,\n+            _ => 0\n         }\n     }\n \n@@ -922,7 +922,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _indenter = indenter();\n     let _icx = push_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n-    if m.len() == 0u {\n+    if m.len() == 0 {\n         if chk.is_fallible() {\n             chk.handle_fail(bcx);\n         }\n@@ -982,8 +982,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n     let dm = &tcx.def_map;\n \n-    let mut vals_left = vals[0u..col].to_vec();\n-    vals_left.push_all(&vals[col + 1u..]);\n+    let mut vals_left = vals[0..col].to_vec();\n+    vals_left.push_all(&vals[col + 1..]);\n     let ccx = bcx.fcx.ccx;\n \n     // Find a real id (we're adding placeholder wildcard patterns, but\n@@ -1042,7 +1042,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let mut kind = NoBranch;\n     let mut test_val = val;\n     debug!(\"test_val={}\", bcx.val_to_string(test_val));\n-    if opts.len() > 0u {\n+    if opts.len() > 0 {\n         match opts[0] {\n             ConstantValue(_) | ConstantRange(_, _) => {\n                 test_val = load_if_immediate(bcx, val, left_ty);\n@@ -1082,7 +1082,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     };\n \n     let defaults = enter_default(else_cx, dm, m, col, val);\n-    let exhaustive = chk.is_infallible() && defaults.len() == 0u;\n+    let exhaustive = chk.is_infallible() && defaults.len() == 0;\n     let len = opts.len();\n \n     // Compile subtrees for each option\n@@ -1157,7 +1157,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             Br(bcx, else_cx.llbb, DebugLoc::None);\n         }\n \n-        let mut size = 0u;\n+        let mut size = 0;\n         let mut unpacked = Vec::new();\n         match *opt {\n             Variant(disr_val, ref repr, _) => {"}, {"sha": "254483c226dddaa04d85b8434e1c35b600b015f9", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -401,7 +401,7 @@ pub fn get_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         _ => { }\n     }\n \n-    ccx.stats().n_static_tydescs.set(ccx.stats().n_static_tydescs.get() + 1u);\n+    ccx.stats().n_static_tydescs.set(ccx.stats().n_static_tydescs.get() + 1);\n     let inf = Rc::new(glue::declare_tydesc(ccx, t));\n \n     ccx.tydescs().borrow_mut().insert(t, inf.clone());\n@@ -2879,7 +2879,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     panic!(\"struct variant kind unexpected in get_item_val\")\n                 }\n             };\n-            assert!(args.len() != 0u);\n+            assert!(args.len() != 0);\n             let ty = ty::node_id_to_type(ccx.tcx(), id);\n             let parent = ccx.tcx().map.get_parent(id);\n             let enm = ccx.tcx().map.expect_item(parent);"}, {"sha": "32e16c7bf8d98c07633eee6a0a5142175d4f4671", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -61,32 +61,32 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // Pass 1: scan table mapping str -> rightmost pos.\n                 let mut mm = FnvHashMap();\n                 let len = v.len();\n-                let mut i = 0u;\n+                let mut i = 0;\n                 while i < len {\n                     mm.insert(v[i], i);\n-                    i += 1u;\n+                    i += 1;\n                 }\n \n                 // Pass 2: concat strings for each elt, skipping\n                 // forwards over any cycles by advancing to rightmost\n                 // occurrence of each element in path.\n                 let mut s = String::from_str(\".\");\n-                i = 0u;\n+                i = 0;\n                 while i < len {\n                     i = mm[v[i]];\n                     s.push('/');\n                     s.push_str(v[i]);\n-                    i += 1u;\n+                    i += 1;\n                 }\n \n                 s.push('/');\n                 s.push_str(category);\n \n                 let n = match h.get(&s) {\n                     Some(&n) => n,\n-                    _ => 0u\n+                    _ => 0\n                 };\n-                h.insert(s, n+1u);\n+                h.insert(s, n+1);\n             })\n         }\n     }"}, {"sha": "ce1cf54919cd81879c7908ecc0d4aec27b8321a3", "filename": "src/librustc_trans/trans/cabi_aarch64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -19,7 +19,7 @@ use trans::type_::Type;\n use std::cmp;\n \n fn align_up_to(off: uint, a: uint) -> uint {\n-    return (off + a - 1u) / a * a;\n+    return (off + a - 1) / a * a;\n }\n \n fn align(off: uint, ty: Type) -> uint {"}, {"sha": "ac32ce495118c01b209473bcabdcd7ce10dc76fc", "filename": "src/librustc_trans/trans/cabi_arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -26,7 +26,7 @@ pub enum Flavor {\n type TyAlignFn = fn(ty: Type) -> uint;\n \n fn align_up_to(off: uint, a: uint) -> uint {\n-    return (off + a - 1u) / a * a;\n+    return (off + a - 1) / a * a;\n }\n \n fn align(off: uint, ty: Type, align_fn: TyAlignFn) -> uint {"}, {"sha": "af7956b46be8e7f12ddd340fdc6a64753cdbf119", "filename": "src/librustc_trans/trans/cabi_mips.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -20,7 +20,7 @@ use trans::context::CrateContext;\n use trans::type_::Type;\n \n fn align_up_to(off: uint, a: uint) -> uint {\n-    return (off + a - 1u) / a * a;\n+    return (off + a - 1) / a * a;\n }\n \n fn align(off: uint, ty: Type) -> uint {"}, {"sha": "c3b0026de98cf9d349b3c11e68395ae54c91914c", "filename": "src/librustc_trans/trans/cabi_powerpc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -19,7 +19,7 @@ use trans::type_::Type;\n use std::cmp;\n \n fn align_up_to(off: uint, a: uint) -> uint {\n-    return (off + a - 1u) / a * a;\n+    return (off + a - 1) / a * a;\n }\n \n fn align(off: uint, ty: Type) -> uint {"}, {"sha": "c0ab0d24dab925c6c9c8a542fe71cc9fb05c4a48", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -88,7 +88,7 @@ impl ClassList for [RegClass] {\n fn classify_ty(ty: Type) -> Vec<RegClass> {\n     fn align(off: uint, ty: Type) -> uint {\n         let a = ty_align(ty);\n-        return (off + a - 1u) / a * a;\n+        return (off + a - 1) / a * a;\n     }\n \n     fn ty_align(ty: Type) -> uint {\n@@ -211,30 +211,30 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n         let t_size = ty_size(ty);\n \n         let misalign = off % t_align;\n-        if misalign != 0u {\n-            let mut i = off / 8u;\n-            let e = (off + t_size + 7u) / 8u;\n+        if misalign != 0 {\n+            let mut i = off / 8;\n+            let e = (off + t_size + 7) / 8;\n             while i < e {\n                 unify(cls, ix + i, Memory);\n-                i += 1u;\n+                i += 1;\n             }\n             return;\n         }\n \n         match ty.kind() {\n             Integer |\n             Pointer => {\n-                unify(cls, ix + off / 8u, Int);\n+                unify(cls, ix + off / 8, Int);\n             }\n             Float => {\n-                if off % 8u == 4u {\n-                    unify(cls, ix + off / 8u, SSEFv);\n+                if off % 8 == 4 {\n+                    unify(cls, ix + off / 8, SSEFv);\n                 } else {\n-                    unify(cls, ix + off / 8u, SSEFs);\n+                    unify(cls, ix + off / 8, SSEFs);\n                 }\n             }\n             Double => {\n-                unify(cls, ix + off / 8u, SSEDs);\n+                unify(cls, ix + off / 8, SSEDs);\n             }\n             Struct => {\n                 classify_struct(ty.field_types().as_slice(), cls, ix, off, ty.is_packed());\n@@ -243,10 +243,10 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n                 let len = ty.array_length();\n                 let elt = ty.element_type();\n                 let eltsz = ty_size(elt);\n-                let mut i = 0u;\n+                let mut i = 0;\n                 while i < len {\n                     classify(elt, cls, ix, off + i * eltsz);\n-                    i += 1u;\n+                    i += 1;\n                 }\n             }\n             Vector => {\n@@ -260,33 +260,33 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n                     _ => panic!(\"classify: unhandled vector element type\")\n                 };\n \n-                let mut i = 0u;\n+                let mut i = 0;\n                 while i < len {\n                     unify(cls, ix + (off + i * eltsz) / 8, reg);\n \n                     // everything after the first one is the upper\n                     // half of a register.\n                     reg = SSEUp;\n-                    i += 1u;\n+                    i += 1;\n                 }\n             }\n             _ => panic!(\"classify: unhandled type\")\n         }\n     }\n \n     fn fixup(ty: Type, cls: &mut [RegClass]) {\n-        let mut i = 0u;\n+        let mut i = 0;\n         let ty_kind = ty.kind();\n         let e = cls.len();\n-        if cls.len() > 2u && (ty_kind == Struct || ty_kind == Array || ty_kind == Vector) {\n+        if cls.len() > 2 && (ty_kind == Struct || ty_kind == Array || ty_kind == Vector) {\n             if cls[i].is_sse() {\n-                i += 1u;\n+                i += 1;\n                 while i < e {\n                     if cls[i] != SSEUp {\n                         all_mem(cls);\n                         return;\n                     }\n-                    i += 1u;\n+                    i += 1;\n                 }\n             } else {\n                 all_mem(cls);\n@@ -308,10 +308,10 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n                     cls[i] = SSEDv;\n                 } else if cls[i].is_sse() {\n                     i += 1;\n-                    while i != e && cls[i] == SSEUp { i += 1u; }\n+                    while i != e && cls[i] == SSEUp { i += 1; }\n                 } else if cls[i] == X87 {\n                     i += 1;\n-                    while i != e && cls[i] == X87Up { i += 1u; }\n+                    while i != e && cls[i] == X87Up { i += 1; }\n                 } else {\n                     i += 1;\n                 }\n@@ -332,18 +332,18 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n \n fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n     fn llvec_len(cls: &[RegClass]) -> uint {\n-        let mut len = 1u;\n+        let mut len = 1;\n         for c in cls.iter() {\n             if *c != SSEUp {\n                 break;\n             }\n-            len += 1u;\n+            len += 1;\n         }\n         return len;\n     }\n \n     let mut tys = Vec::new();\n-    let mut i = 0u;\n+    let mut i = 0;\n     let e = cls.len();\n     while i < e {\n         match cls[i] {\n@@ -361,7 +361,7 @@ fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n                     }\n                     _ => unreachable!(),\n                 };\n-                let vec_len = llvec_len(&cls[i + 1u..]);\n+                let vec_len = llvec_len(&cls[i + 1..]);\n                 let vec_ty = Type::vector(&elt_ty, vec_len as u64 * elts_per_word);\n                 tys.push(vec_ty);\n                 i += vec_len;\n@@ -375,7 +375,7 @@ fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n             }\n             _ => panic!(\"llregtype: unhandled class\")\n         }\n-        i += 1u;\n+        i += 1;\n     }\n     if tys.len() == 1 && tys[0].kind() == Vector {\n         // if the type contains only a vector, pass it as that vector."}, {"sha": "5f3cb01d76274c0dfeef4481a4f8e21b647d2e85", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -182,7 +182,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                                             bcx.fcx.param_substs);\n \n                 // Nullary variants are not callable\n-                assert!(vinfo.args.len() > 0u);\n+                assert!(vinfo.args.len() > 0);\n \n                 Callee {\n                     bcx: bcx,"}, {"sha": "096ea22eaac5c9c406b4984eb974716205325e95", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -747,7 +747,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n         };\n \n         // The only landing pad clause will be 'cleanup'\n-        let llretval = build::LandingPad(pad_bcx, llretty, llpersonality, 1u);\n+        let llretval = build::LandingPad(pad_bcx, llretty, llpersonality, 1);\n \n         // The landing pad block is a cleanup\n         build::SetCleanup(pad_bcx, llretval);"}, {"sha": "3a2a1d158642e161ee93b2b25d1db2816b3b42fe", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -258,15 +258,15 @@ impl<'tcx> SharedCrateContext<'tcx> {\n             symbol_hasher: RefCell::new(symbol_hasher),\n             tcx: tcx,\n             stats: Stats {\n-                n_static_tydescs: Cell::new(0u),\n-                n_glues_created: Cell::new(0u),\n-                n_null_glues: Cell::new(0u),\n-                n_real_glues: Cell::new(0u),\n-                n_fns: Cell::new(0u),\n-                n_monos: Cell::new(0u),\n-                n_inlines: Cell::new(0u),\n-                n_closures: Cell::new(0u),\n-                n_llvm_insns: Cell::new(0u),\n+                n_static_tydescs: Cell::new(0),\n+                n_glues_created: Cell::new(0),\n+                n_null_glues: Cell::new(0),\n+                n_real_glues: Cell::new(0),\n+                n_fns: Cell::new(0),\n+                n_monos: Cell::new(0),\n+                n_inlines: Cell::new(0),\n+                n_closures: Cell::new(0),\n+                n_llvm_insns: Cell::new(0),\n                 llvm_insns: RefCell::new(FnvHashMap()),\n                 fn_stats: RefCell::new(Vec::new()),\n             },\n@@ -418,7 +418,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 dbg_cx: dbg_cx,\n                 eh_personality: RefCell::new(None),\n                 intrinsics: RefCell::new(FnvHashMap()),\n-                n_llvm_insns: Cell::new(0u),\n+                n_llvm_insns: Cell::new(0),\n                 trait_cache: RefCell::new(FnvHashMap()),\n             };\n "}, {"sha": "258a6fb958d4fc031c0bcde301af15a8a5657b0f", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -1730,7 +1730,7 @@ fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n     let work_dir = cx.sess().working_dir.as_str().unwrap();\n     let file_name =\n         if full_path.starts_with(work_dir) {\n-            &full_path[work_dir.len() + 1u..full_path.len()]\n+            &full_path[work_dir.len() + 1..full_path.len()]\n         } else {\n             full_path\n         };\n@@ -2268,7 +2268,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 let null_variant_index = (1 - non_null_variant_index) as uint;\n                 let null_variant_name = token::get_name((*self.variants)[null_variant_index].name);\n                 let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n-                                                0u,\n+                                                0,\n                                                 null_variant_name);\n \n                 // Finally create the (singleton) list of descriptions of union\n@@ -3855,7 +3855,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     output.push_str(\"::\");\n                 }\n \n-                let mut path_element_count = 0u;\n+                let mut path_element_count = 0;\n                 for path_element in path {\n                     let name = token::get_name(path_element.name());\n                     output.push_str(name.get());"}, {"sha": "cf85389cd5b578bc608878fa78cd1e17f940e95a", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -153,11 +153,11 @@ pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n pub fn get_len(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n-    GEPi(bcx, fat_ptr, &[0u, abi::FAT_PTR_EXTRA])\n+    GEPi(bcx, fat_ptr, &[0, abi::FAT_PTR_EXTRA])\n }\n \n pub fn get_dataptr(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n-    GEPi(bcx, fat_ptr, &[0u, abi::FAT_PTR_ADDR])\n+    GEPi(bcx, fat_ptr, &[0, abi::FAT_PTR_ADDR])\n }\n \n /// Helper for trans that apply adjustments from `expr` to `datum`, which should be the unadjusted\n@@ -366,7 +366,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }, info),\n             ty::UnsizeLength(..) =>\n                 into_fat_ptr(bcx, expr, datum, dest_ty, |bcx, val| {\n-                    GEPi(bcx, val, &[0u, 0u])\n+                    GEPi(bcx, val, &[0, 0])\n                 }, info),\n             ty::UnsizeVtable(..) =>\n                 into_fat_ptr(bcx, expr, datum, dest_ty, |_bcx, val| {\n@@ -1185,7 +1185,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     match def {\n         def::DefVariant(tid, vid, _) => {\n             let variant_info = ty::enum_variant_with_id(bcx.tcx(), tid, vid);\n-            if variant_info.args.len() > 0u {\n+            if variant_info.args.len() > 0 {\n                 // N-ary variant.\n                 let llfn = callee::trans_fn_ref(bcx.ccx(), vid,\n                                                 ExprId(ref_expr.id),"}, {"sha": "497237da38c45e4e2c234615a29a4a6df96904b9", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -337,8 +337,8 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n             // info points to the vtable and the second entry in the vtable is the\n             // dynamic size of the object.\n             let info = PointerCast(bcx, info, Type::int(bcx.ccx()).ptr_to());\n-            let size_ptr = GEPi(bcx, info, &[1u]);\n-            let align_ptr = GEPi(bcx, info, &[2u]);\n+            let size_ptr = GEPi(bcx, info, &[1]);\n+            let align_ptr = GEPi(bcx, info, &[2]);\n             (Load(bcx, size_ptr), Load(bcx, align_ptr))\n         }\n         ty::ty_vec(_, None) | ty::ty_str => {\n@@ -551,7 +551,7 @@ fn make_generic_glue<'a, 'tcx, F>(ccx: &CrateContext<'a, 'tcx>,\n \n     update_linkage(ccx, llfn, None, OriginalTranslation);\n \n-    ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1u);\n+    ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1);\n     // All glue functions take values passed *by alias*; this is a\n     // requirement since in many contexts glue is invoked indirectly and\n     // the caller has no idea if it's dealing with something that can be"}, {"sha": "335c639df9096bfcf6e26caa0afb9fdac38c4e82", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -78,7 +78,7 @@ pub fn trans_impl(ccx: &CrateContext,\n     for impl_item in impl_items.iter() {\n         match *impl_item {\n             ast::MethodImplItem(ref method) => {\n-                if method.pe_generics().ty_params.len() == 0u {\n+                if method.pe_generics().ty_params.len() == 0 {\n                     let trans_everywhere = attr::requests_inline(&method.attrs[]);\n                     for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n                         let llfn = get_item_val(ccx, method.id);\n@@ -488,7 +488,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            callee_ty.repr(ccx.tcx()),\n            vtable_index,\n            bcx.val_to_string(llpair));\n-    let llboxptr = GEPi(bcx, llpair, &[0u, abi::FAT_PTR_ADDR]);\n+    let llboxptr = GEPi(bcx, llpair, &[0, abi::FAT_PTR_ADDR]);\n     let llbox = Load(bcx, llboxptr);\n     let llself = PointerCast(bcx, llbox, Type::i8p(ccx));\n \n@@ -510,9 +510,9 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let llvtable = Load(bcx,\n                         PointerCast(bcx,\n                                     GEPi(bcx, llpair,\n-                                         &[0u, abi::FAT_PTR_EXTRA]),\n+                                         &[0, abi::FAT_PTR_EXTRA]),\n                                     Type::vtable(ccx).ptr_to().ptr_to()));\n-    let mptr = Load(bcx, GEPi(bcx, llvtable, &[0u, vtable_index + VTABLE_OFFSET]));\n+    let mptr = Load(bcx, GEPi(bcx, llvtable, &[0, vtable_index + VTABLE_OFFSET]));\n     let mptr = PointerCast(bcx, mptr, llcallee_ty.ptr_to());\n \n     return Callee {\n@@ -877,13 +877,13 @@ pub fn trans_trait_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let llbox_ty = type_of(bcx.ccx(), datum_ty);\n \n     // Store the pointer into the first half of pair.\n-    let llboxdest = GEPi(bcx, lldest, &[0u, abi::FAT_PTR_ADDR]);\n+    let llboxdest = GEPi(bcx, lldest, &[0, abi::FAT_PTR_ADDR]);\n     let llboxdest = PointerCast(bcx, llboxdest, llbox_ty.ptr_to());\n     bcx = datum.store_to(bcx, llboxdest);\n \n     // Store the vtable into the second half of pair.\n     let vtable = get_vtable(bcx, datum_ty, trait_ref);\n-    let llvtabledest = GEPi(bcx, lldest, &[0u, abi::FAT_PTR_EXTRA]);\n+    let llvtabledest = GEPi(bcx, lldest, &[0, abi::FAT_PTR_EXTRA]);\n     let llvtabledest = PointerCast(bcx, llvtabledest, val_ty(vtable).ptr_to());\n     Store(bcx, vtable, llvtabledest);\n "}, {"sha": "844795b667b54d8c09f13449a72e11cbc2fee281", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=00a933f9ece4ef22f8651320e5f4fcfcbd37e0bf", "patch": "@@ -73,7 +73,7 @@ pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let unit_size = llsize_of_alloc(ccx, llty);\n             if unit_size != 0 {\n                 let len = get_len(bcx, vptr);\n-                let not_empty = ICmp(bcx, llvm::IntNE, len, C_uint(ccx, 0u));\n+                let not_empty = ICmp(bcx, llvm::IntNE, len, C_uint(ccx, 0us));\n                 with_cond(bcx, not_empty, |bcx| {\n                     let llalign = C_uint(ccx, machine::llalign_of_min(ccx, llty));\n                     let size = Mul(bcx, C_uint(ccx, unit_size), len, DebugLoc::None);\n@@ -213,8 +213,8 @@ pub fn trans_lit_str<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let llbytes = C_uint(bcx.ccx(), bytes);\n             let llcstr = C_cstr(bcx.ccx(), str_lit, false);\n             let llcstr = consts::ptrcast(llcstr, Type::i8p(bcx.ccx()));\n-            Store(bcx, llcstr, GEPi(bcx, lldest, &[0u, abi::FAT_PTR_ADDR]));\n-            Store(bcx, llbytes, GEPi(bcx, lldest, &[0u, abi::FAT_PTR_EXTRA]));\n+            Store(bcx, llcstr, GEPi(bcx, lldest, &[0, abi::FAT_PTR_ADDR]));\n+            Store(bcx, llbytes, GEPi(bcx, lldest, &[0, abi::FAT_PTR_EXTRA]));\n             bcx\n         }\n     }\n@@ -375,8 +375,8 @@ pub fn get_fixed_base_and_len(bcx: Block,\n fn get_slice_base_and_len(bcx: Block,\n                           llval: ValueRef)\n                           -> (ValueRef, ValueRef) {\n-    let base = Load(bcx, GEPi(bcx, llval, &[0u, abi::FAT_PTR_ADDR]));\n-    let len = Load(bcx, GEPi(bcx, llval, &[0u, abi::FAT_PTR_EXTRA]));\n+    let base = Load(bcx, GEPi(bcx, llval, &[0, abi::FAT_PTR_ADDR]));\n+    let len = Load(bcx, GEPi(bcx, llval, &[0, abi::FAT_PTR_EXTRA]));\n     (base, len)\n }\n \n@@ -400,7 +400,7 @@ pub fn get_base_and_len(bcx: Block,\n         ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty.sty {\n             ty::ty_vec(_, None) | ty::ty_str => get_slice_base_and_len(bcx, llval),\n             ty::ty_vec(_, Some(n)) => {\n-                let base = GEPi(bcx, Load(bcx, llval), &[0u, 0u]);\n+                let base = GEPi(bcx, Load(bcx, llval), &[0, 0]);\n                 (base, C_uint(ccx, n))\n             }\n             _ => ccx.sess().bug(\"unexpected type in get_base_and_len\"),\n@@ -430,7 +430,7 @@ pub fn iter_vec_loop<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let loop_counter = {\n         // i = 0\n         let i = alloca(loop_bcx, bcx.ccx().int_type(), \"__i\");\n-        Store(loop_bcx, C_uint(bcx.ccx(), 0u), i);\n+        Store(loop_bcx, C_uint(bcx.ccx(), 0us), i);\n \n         Br(loop_bcx, cond_bcx.llbb, DebugLoc::None);\n         i\n@@ -458,7 +458,7 @@ pub fn iter_vec_loop<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n     { // i += 1\n         let i = Load(inc_bcx, loop_counter);\n-        let plusone = Add(inc_bcx, i, C_uint(bcx.ccx(), 1u), DebugLoc::None);\n+        let plusone = Add(inc_bcx, i, C_uint(bcx.ccx(), 1us), DebugLoc::None);\n         Store(inc_bcx, plusone, loop_counter);\n \n         Br(inc_bcx, cond_bcx.llbb, DebugLoc::None);"}]}