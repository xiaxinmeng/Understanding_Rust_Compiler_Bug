{"sha": "584000a792b1016677fe4e0e78706d14a8034eb2", "node_id": "C_kwDOAAsO6NoAKDU4NDAwMGE3OTJiMTAxNjY3N2ZlNGUwZTc4NzA2ZDE0YTgwMzRlYjI", "commit": {"author": {"name": "Lukas Lueg", "email": "lukas.lueg@gmail.com", "date": "2022-08-30T20:27:21Z"}, "committer": {"name": "Lukas Lueg", "email": "lukas.lueg@gmail.com", "date": "2022-09-02T22:16:28Z"}, "message": "Use `approx_ty_size` for `large_enum_variant`", "tree": {"sha": "2762c3ebb906c6f5761cf903545908a0e97bc164", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2762c3ebb906c6f5761cf903545908a0e97bc164"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/584000a792b1016677fe4e0e78706d14a8034eb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/584000a792b1016677fe4e0e78706d14a8034eb2", "html_url": "https://github.com/rust-lang/rust/commit/584000a792b1016677fe4e0e78706d14a8034eb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/584000a792b1016677fe4e0e78706d14a8034eb2/comments", "author": {"login": "lukaslueg", "id": 3148704, "node_id": "MDQ6VXNlcjMxNDg3MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3148704?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lukaslueg", "html_url": "https://github.com/lukaslueg", "followers_url": "https://api.github.com/users/lukaslueg/followers", "following_url": "https://api.github.com/users/lukaslueg/following{/other_user}", "gists_url": "https://api.github.com/users/lukaslueg/gists{/gist_id}", "starred_url": "https://api.github.com/users/lukaslueg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lukaslueg/subscriptions", "organizations_url": "https://api.github.com/users/lukaslueg/orgs", "repos_url": "https://api.github.com/users/lukaslueg/repos", "events_url": "https://api.github.com/users/lukaslueg/events{/privacy}", "received_events_url": "https://api.github.com/users/lukaslueg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lukaslueg", "id": 3148704, "node_id": "MDQ6VXNlcjMxNDg3MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3148704?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lukaslueg", "html_url": "https://github.com/lukaslueg", "followers_url": "https://api.github.com/users/lukaslueg/followers", "following_url": "https://api.github.com/users/lukaslueg/following{/other_user}", "gists_url": "https://api.github.com/users/lukaslueg/gists{/gist_id}", "starred_url": "https://api.github.com/users/lukaslueg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lukaslueg/subscriptions", "organizations_url": "https://api.github.com/users/lukaslueg/orgs", "repos_url": "https://api.github.com/users/lukaslueg/repos", "events_url": "https://api.github.com/users/lukaslueg/events{/privacy}", "received_events_url": "https://api.github.com/users/lukaslueg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30e453215380302b2cc1d4a7a41410e24482e50d", "url": "https://api.github.com/repos/rust-lang/rust/commits/30e453215380302b2cc1d4a7a41410e24482e50d", "html_url": "https://github.com/rust-lang/rust/commit/30e453215380302b2cc1d4a7a41410e24482e50d"}], "stats": {"total": 406, "additions": 267, "deletions": 139}, "files": [{"sha": "eb13d0869c037d522b4b3d34b0a66886c7f324db", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 58, "deletions": 38, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/584000a792b1016677fe4e0e78706d14a8034eb2/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584000a792b1016677fe4e0e78706d14a8034eb2/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=584000a792b1016677fe4e0e78706d14a8034eb2", "patch": "@@ -1,13 +1,12 @@\n //! lint when there is a large size difference between variants on an enum\n \n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{diagnostics::span_lint_and_then, ty::is_copy};\n+use clippy_utils::{diagnostics::span_lint_and_then, ty::approx_ty_size, ty::is_copy};\n use rustc_errors::Applicability;\n use rustc_hir::{Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::layout::LayoutOf;\n-use rustc_middle::ty::{Adt, Ty};\n+use rustc_middle::ty::{Adt, AdtDef, GenericArg, List, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n \n@@ -17,7 +16,7 @@ declare_clippy_lint! {\n     /// `enum`s.\n     ///\n     /// ### Why is this bad?\n-    /// Enum size is bounded by the largest variant. Having a\n+    /// Enum size is bounded by the largest variant. Having one\n     /// large variant can penalize the memory layout of that enum.\n     ///\n     /// ### Known problems\n@@ -33,8 +32,9 @@ declare_clippy_lint! {\n     /// use case it may be possible to store the large data in an auxiliary\n     /// structure (e.g. Arena or ECS).\n     ///\n-    /// The lint will ignore generic types if the layout depends on the\n-    /// generics, even if the size difference will be large anyway.\n+    /// The lint will ignore the impact of generic types to the type layout by\n+    /// assuming every type parameter is zero-sized. Depending on your use case,\n+    /// this may lead to a false positive.\n     ///\n     /// ### Example\n     /// ```rust\n@@ -83,6 +83,38 @@ struct VariantInfo {\n     fields_size: Vec<FieldInfo>,\n }\n \n+fn variants_size<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    adt: AdtDef<'tcx>,\n+    subst: &'tcx List<GenericArg<'tcx>>,\n+) -> Vec<VariantInfo> {\n+    let mut variants_size = adt\n+        .variants()\n+        .iter()\n+        .enumerate()\n+        .map(|(i, variant)| {\n+            let mut fields_size = variant\n+                .fields\n+                .iter()\n+                .enumerate()\n+                .map(|(i, f)| FieldInfo {\n+                    ind: i,\n+                    size: approx_ty_size(cx, f.ty(cx.tcx, subst)),\n+                })\n+                .collect::<Vec<_>>();\n+            fields_size.sort_by(|a, b| (a.size.cmp(&b.size)));\n+\n+            VariantInfo {\n+                ind: i,\n+                size: fields_size.iter().map(|info| info.size).sum(),\n+                fields_size,\n+            }\n+        })\n+        .collect::<Vec<_>>();\n+    variants_size.sort_by(|a, b| (b.size.cmp(&a.size)));\n+    variants_size\n+}\n+\n impl_lint_pass!(LargeEnumVariant => [LARGE_ENUM_VARIANT]);\n \n impl<'tcx> LateLintPass<'tcx> for LargeEnumVariant {\n@@ -92,57 +124,45 @@ impl<'tcx> LateLintPass<'tcx> for LargeEnumVariant {\n         }\n         if let ItemKind::Enum(ref def, _) = item.kind {\n             let ty = cx.tcx.type_of(item.def_id);\n-            let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n+            let (adt, subst) = match ty.kind() {\n+                Adt(adt, subst) => (adt, subst),\n+                _ => panic!(\"already checked whether this is an enum\"),\n+            };\n             if adt.variants().len() <= 1 {\n                 return;\n             }\n-            let mut variants_size: Vec<VariantInfo> = Vec::new();\n-            for (i, variant) in adt.variants().iter().enumerate() {\n-                let mut fields_size = Vec::new();\n-                for (i, f) in variant.fields.iter().enumerate() {\n-                    let ty = cx.tcx.type_of(f.did);\n-                    // don't lint variants which have a field of generic type.\n-                    match cx.layout_of(ty) {\n-                        Ok(l) => {\n-                            let fsize = l.size.bytes();\n-                            fields_size.push(FieldInfo { ind: i, size: fsize });\n-                        },\n-                        Err(_) => {\n-                            return;\n-                        },\n-                    }\n-                }\n-                let size: u64 = fields_size.iter().map(|info| info.size).sum();\n-\n-                variants_size.push(VariantInfo {\n-                    ind: i,\n-                    size,\n-                    fields_size,\n-                });\n-            }\n-\n-            variants_size.sort_by(|a, b| (b.size.cmp(&a.size)));\n+            let variants_size = variants_size(cx, *adt, subst);\n \n             let mut difference = variants_size[0].size - variants_size[1].size;\n             if difference > self.maximum_size_difference_allowed {\n                 let help_text = \"consider boxing the large fields to reduce the total size of the enum\";\n                 span_lint_and_then(\n                     cx,\n                     LARGE_ENUM_VARIANT,\n-                    def.variants[variants_size[0].ind].span,\n+                    item.span,\n                     \"large size difference between variants\",\n                     |diag| {\n+                        diag.span_label(\n+                            item.span,\n+                            format!(\"the entire enum is at least {} bytes\", approx_ty_size(cx, ty)),\n+                        );\n                         diag.span_label(\n                             def.variants[variants_size[0].ind].span,\n-                            &format!(\"this variant is {} bytes\", variants_size[0].size),\n+                            format!(\"the largest variant contains at least {} bytes\", variants_size[0].size),\n                         );\n-                        diag.span_note(\n+                        diag.span_label(\n                             def.variants[variants_size[1].ind].span,\n-                            &format!(\"and the second-largest variant is {} bytes:\", variants_size[1].size),\n+                            &if variants_size[1].fields_size.is_empty() {\n+                                \"the second-largest variant carries no data at all\".to_owned()\n+                            } else {\n+                                format!(\n+                                    \"the second-largest variant contains at least {} bytes\",\n+                                    variants_size[1].size\n+                                )\n+                            },\n                         );\n \n                         let fields = def.variants[variants_size[0].ind].data.fields();\n-                        variants_size[0].fields_size.sort_by(|a, b| (a.size.cmp(&b.size)));\n                         let mut applicability = Applicability::MaybeIncorrect;\n                         if is_copy(cx, ty) || maybe_copy(cx, ty) {\n                             diag.span_note("}, {"sha": "1f95430790d292b8fc2a574417597921bcac0acf", "filename": "src/docs/large_enum_variant.txt", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/584000a792b1016677fe4e0e78706d14a8034eb2/src%2Fdocs%2Flarge_enum_variant.txt", "raw_url": "https://github.com/rust-lang/rust/raw/584000a792b1016677fe4e0e78706d14a8034eb2/src%2Fdocs%2Flarge_enum_variant.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flarge_enum_variant.txt?ref=584000a792b1016677fe4e0e78706d14a8034eb2", "patch": "@@ -3,7 +3,7 @@ Checks for large size differences between variants on\n `enum`s.\n \n ### Why is this bad?\n-Enum size is bounded by the largest variant. Having a\n+Enum size is bounded by the largest variant. Having one\n large variant can penalize the memory layout of that enum.\n \n ### Known problems\n@@ -19,8 +19,9 @@ still be `Clone`, but that is worse ergonomically. Depending on the\n use case it may be possible to store the large data in an auxiliary\n structure (e.g. Arena or ECS).\n \n-The lint will ignore generic types if the layout depends on the\n-generics, even if the size difference will be large anyway.\n+The lint will ignore the impact of generic types to the type layout by\n+assuming every type parameter is zero-sized. Depending on your use case,\n+this may lead to a false positive.\n \n ### Example\n ```"}, {"sha": "717009e4c4ccadce5a5c5c93aa1607435c906edd", "filename": "tests/ui/large_enum_variant.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/584000a792b1016677fe4e0e78706d14a8034eb2/tests%2Fui%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584000a792b1016677fe4e0e78706d14a8034eb2/tests%2Fui%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_enum_variant.rs?ref=584000a792b1016677fe4e0e78706d14a8034eb2", "patch": "@@ -130,6 +130,30 @@ impl<T: Copy> Clone for SomeGenericPossiblyCopyEnum<T> {\n \n impl<T: Copy> Copy for SomeGenericPossiblyCopyEnum<T> {}\n \n+enum LargeEnumWithGenerics<T> {\n+    Small,\n+    Large((T, [u8; 512])),\n+}\n+\n+struct Foo<T> {\n+    foo: T,\n+}\n+\n+enum WithGenerics {\n+    Large([Foo<u64>; 64]),\n+    Small(u8),\n+}\n+\n+enum PossiblyLargeEnumWithConst<const U: usize> {\n+    SmallBuffer([u8; 4]),\n+    MightyBuffer([u16; U]),\n+}\n+\n+enum LargeEnumOfConst {\n+    Ok,\n+    Error(PossiblyLargeEnumWithConst<256>),\n+}\n+\n fn main() {\n     large_enum_variant!();\n }"}, {"sha": "e1ed2460e08a7ebd86f448ed1211b38bb0f94e33", "filename": "tests/ui/large_enum_variant.stderr", "status": "modified", "additions": 169, "deletions": 87, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/584000a792b1016677fe4e0e78706d14a8034eb2/tests%2Fui%2Flarge_enum_variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/584000a792b1016677fe4e0e78706d14a8034eb2/tests%2Fui%2Flarge_enum_variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_enum_variant.stderr?ref=584000a792b1016677fe4e0e78706d14a8034eb2", "patch": "@@ -1,143 +1,177 @@\n error: large size difference between variants\n-  --> $DIR/large_enum_variant.rs:12:5\n+  --> $DIR/large_enum_variant.rs:10:1\n    |\n-LL |     B([i32; 8000]),\n-   |     ^^^^^^^^^^^^^^ this variant is 32000 bytes\n+LL | / enum LargeEnum {\n+LL | |     A(i32),\n+   | |     ------ the second-largest variant contains at least 4 bytes\n+LL | |     B([i32; 8000]),\n+   | |     -------------- the largest variant contains at least 32000 bytes\n+LL | | }\n+   | |_^ the entire enum is at least 32004 bytes\n    |\n    = note: `-D clippy::large-enum-variant` implied by `-D warnings`\n-note: and the second-largest variant is 4 bytes:\n-  --> $DIR/large_enum_variant.rs:11:5\n-   |\n-LL |     A(i32),\n-   |     ^^^^^^\n help: consider boxing the large fields to reduce the total size of the enum\n    |\n LL |     B(Box<[i32; 8000]>),\n    |       ~~~~~~~~~~~~~~~~\n \n error: large size difference between variants\n-  --> $DIR/large_enum_variant.rs:36:5\n-   |\n-LL |     ContainingLargeEnum(LargeEnum),\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this variant is 32004 bytes\n+  --> $DIR/large_enum_variant.rs:34:1\n    |\n-note: and the second-largest variant is 8 bytes:\n-  --> $DIR/large_enum_variant.rs:35:5\n+LL | / enum LargeEnum2 {\n+LL | |     VariantOk(i32, u32),\n+   | |     ------------------- the second-largest variant contains at least 8 bytes\n+LL | |     ContainingLargeEnum(LargeEnum),\n+   | |     ------------------------------ the largest variant contains at least 32004 bytes\n+LL | | }\n+   | |_^ the entire enum is at least 32008 bytes\n    |\n-LL |     VariantOk(i32, u32),\n-   |     ^^^^^^^^^^^^^^^^^^^\n help: consider boxing the large fields to reduce the total size of the enum\n    |\n LL |     ContainingLargeEnum(Box<LargeEnum>),\n    |                         ~~~~~~~~~~~~~~\n \n error: large size difference between variants\n-  --> $DIR/large_enum_variant.rs:40:5\n-   |\n-LL |     ContainingMoreThanOneField(i32, [i32; 8000], [i32; 9500]),\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this variant is 70004 bytes\n+  --> $DIR/large_enum_variant.rs:39:1\n    |\n-note: and the second-largest variant is 8 bytes:\n-  --> $DIR/large_enum_variant.rs:42:5\n+LL | / enum LargeEnum3 {\n+LL | |     ContainingMoreThanOneField(i32, [i32; 8000], [i32; 9500]),\n+   | |     --------------------------------------------------------- the largest variant contains at least 70004 bytes\n+LL | |     VoidVariant,\n+LL | |     StructLikeLittle { x: i32, y: i32 },\n+   | |     ----------------------------------- the second-largest variant contains at least 8 bytes\n+LL | | }\n+   | |_^ the entire enum is at least 70008 bytes\n    |\n-LL |     StructLikeLittle { x: i32, y: i32 },\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: consider boxing the large fields to reduce the total size of the enum\n    |\n LL |     ContainingMoreThanOneField(i32, Box<[i32; 8000]>, Box<[i32; 9500]>),\n    |                                     ~~~~~~~~~~~~~~~~  ~~~~~~~~~~~~~~~~\n \n error: large size difference between variants\n-  --> $DIR/large_enum_variant.rs:47:5\n+  --> $DIR/large_enum_variant.rs:45:1\n    |\n-LL |     StructLikeLarge { x: [i32; 8000], y: i32 },\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this variant is 32004 bytes\n+LL | / enum LargeEnum4 {\n+LL | |     VariantOk(i32, u32),\n+   | |     ------------------- the second-largest variant contains at least 8 bytes\n+LL | |     StructLikeLarge { x: [i32; 8000], y: i32 },\n+   | |     ------------------------------------------ the largest variant contains at least 32004 bytes\n+LL | | }\n+   | |_^ the entire enum is at least 32008 bytes\n    |\n-note: and the second-largest variant is 8 bytes:\n-  --> $DIR/large_enum_variant.rs:46:5\n-   |\n-LL |     VariantOk(i32, u32),\n-   |     ^^^^^^^^^^^^^^^^^^^\n help: consider boxing the large fields to reduce the total size of the enum\n    |\n LL |     StructLikeLarge { x: Box<[i32; 8000]>, y: i32 },\n    |                          ~~~~~~~~~~~~~~~~\n \n error: large size difference between variants\n-  --> $DIR/large_enum_variant.rs:52:5\n-   |\n-LL |     StructLikeLarge2 { x: [i32; 8000] },\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this variant is 32000 bytes\n+  --> $DIR/large_enum_variant.rs:50:1\n    |\n-note: and the second-largest variant is 8 bytes:\n-  --> $DIR/large_enum_variant.rs:51:5\n+LL | / enum LargeEnum5 {\n+LL | |     VariantOk(i32, u32),\n+   | |     ------------------- the second-largest variant contains at least 8 bytes\n+LL | |     StructLikeLarge2 { x: [i32; 8000] },\n+   | |     ----------------------------------- the largest variant contains at least 32000 bytes\n+LL | | }\n+   | |_^ the entire enum is at least 32004 bytes\n    |\n-LL |     VariantOk(i32, u32),\n-   |     ^^^^^^^^^^^^^^^^^^^\n help: consider boxing the large fields to reduce the total size of the enum\n    |\n LL |     StructLikeLarge2 { x: Box<[i32; 8000]> },\n    |                           ~~~~~~~~~~~~~~~~\n \n error: large size difference between variants\n-  --> $DIR/large_enum_variant.rs:68:5\n-   |\n-LL |     B([u8; 1255]),\n-   |     ^^^^^^^^^^^^^ this variant is 1255 bytes\n+  --> $DIR/large_enum_variant.rs:66:1\n    |\n-note: and the second-largest variant is 200 bytes:\n-  --> $DIR/large_enum_variant.rs:69:5\n+LL | / enum LargeEnum7 {\n+LL | |     A,\n+LL | |     B([u8; 1255]),\n+   | |     ------------- the largest variant contains at least 1255 bytes\n+LL | |     C([u8; 200]),\n+   | |     ------------ the second-largest variant contains at least 200 bytes\n+LL | | }\n+   | |_^ the entire enum is at least 1256 bytes\n    |\n-LL |     C([u8; 200]),\n-   |     ^^^^^^^^^^^^\n help: consider boxing the large fields to reduce the total size of the enum\n    |\n LL |     B(Box<[u8; 1255]>),\n    |       ~~~~~~~~~~~~~~~\n \n error: large size difference between variants\n-  --> $DIR/large_enum_variant.rs:74:5\n+  --> $DIR/large_enum_variant.rs:72:1\n    |\n-LL |     ContainingMoreThanOneField([i32; 8000], [i32; 2], [i32; 9500], [i32; 30]),\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this variant is 70128 bytes\n+LL | / enum LargeEnum8 {\n+LL | |     VariantOk(i32, u32),\n+   | |     ------------------- the second-largest variant contains at least 8 bytes\n+LL | |     ContainingMoreThanOneField([i32; 8000], [i32; 2], [i32; 9500], [i32; 30]),\n+   | |     ------------------------------------------------------------------------- the largest variant contains at least 70128 bytes\n+LL | | }\n+   | |_^ the entire enum is at least 70132 bytes\n    |\n-note: and the second-largest variant is 8 bytes:\n-  --> $DIR/large_enum_variant.rs:73:5\n-   |\n-LL |     VariantOk(i32, u32),\n-   |     ^^^^^^^^^^^^^^^^^^^\n help: consider boxing the large fields to reduce the total size of the enum\n    |\n LL |     ContainingMoreThanOneField(Box<[i32; 8000]>, [i32; 2], Box<[i32; 9500]>, [i32; 30]),\n    |                                ~~~~~~~~~~~~~~~~            ~~~~~~~~~~~~~~~~\n \n error: large size difference between variants\n-  --> $DIR/large_enum_variant.rs:79:5\n+  --> $DIR/large_enum_variant.rs:77:1\n+   |\n+LL | / enum LargeEnum9 {\n+LL | |     A(Struct<()>),\n+   | |     ------------- the second-largest variant contains at least 4 bytes\n+LL | |     B(Struct2),\n+   | |     ---------- the largest variant contains at least 32000 bytes\n+LL | | }\n+   | |_^ the entire enum is at least 32004 bytes\n+   |\n+help: consider boxing the large fields to reduce the total size of the enum\n    |\n-LL |     B(Struct2),\n-   |     ^^^^^^^^^^ this variant is 32000 bytes\n+LL |     B(Box<Struct2>),\n+   |       ~~~~~~~~~~~~\n+\n+error: large size difference between variants\n+  --> $DIR/large_enum_variant.rs:82:1\n    |\n-note: and the second-largest variant is 4 bytes:\n-  --> $DIR/large_enum_variant.rs:78:5\n+LL | / enum LargeEnumOk2<T> {\n+LL | |     A(T),\n+   | |     ---- the second-largest variant contains at least 0 bytes\n+LL | |     B(Struct2),\n+   | |     ---------- the largest variant contains at least 32000 bytes\n+LL | | }\n+   | |_^ the entire enum is at least 32000 bytes\n    |\n-LL |     A(Struct<()>),\n-   |     ^^^^^^^^^^^^^\n help: consider boxing the large fields to reduce the total size of the enum\n    |\n LL |     B(Box<Struct2>),\n    |       ~~~~~~~~~~~~\n \n error: large size difference between variants\n-  --> $DIR/large_enum_variant.rs:104:5\n+  --> $DIR/large_enum_variant.rs:87:1\n    |\n-LL |     B([u128; 4000]),\n-   |     ^^^^^^^^^^^^^^^ this variant is 64000 bytes\n+LL | / enum LargeEnumOk3<T> {\n+LL | |     A(Struct<T>),\n+   | |     ------------ the second-largest variant contains at least 4 bytes\n+LL | |     B(Struct2),\n+   | |     ---------- the largest variant contains at least 32000 bytes\n+LL | | }\n+   | |_^ the entire enum is at least 32000 bytes\n+   |\n+help: consider boxing the large fields to reduce the total size of the enum\n    |\n-note: and the second-largest variant is 1 bytes:\n-  --> $DIR/large_enum_variant.rs:103:5\n+LL |     B(Box<Struct2>),\n+   |       ~~~~~~~~~~~~\n+\n+error: large size difference between variants\n+  --> $DIR/large_enum_variant.rs:102:1\n+   |\n+LL | / enum CopyableLargeEnum {\n+LL | |     A(bool),\n+   | |     ------- the second-largest variant contains at least 1 bytes\n+LL | |     B([u128; 4000]),\n+   | |     --------------- the largest variant contains at least 64000 bytes\n+LL | | }\n+   | |_^ the entire enum is at least 64008 bytes\n    |\n-LL |     A(bool),\n-   |     ^^^^^^^\n note: boxing a variant would require the type no longer be `Copy`\n   --> $DIR/large_enum_variant.rs:102:6\n    |\n@@ -150,16 +184,16 @@ LL |     B([u128; 4000]),\n    |     ^^^^^^^^^^^^^^^\n \n error: large size difference between variants\n-  --> $DIR/large_enum_variant.rs:109:5\n+  --> $DIR/large_enum_variant.rs:107:1\n    |\n-LL |     B([u128; 4000]),\n-   |     ^^^^^^^^^^^^^^^ this variant is 64000 bytes\n-   |\n-note: and the second-largest variant is 1 bytes:\n-  --> $DIR/large_enum_variant.rs:108:5\n+LL | / enum ManuallyCopyLargeEnum {\n+LL | |     A(bool),\n+   | |     ------- the second-largest variant contains at least 1 bytes\n+LL | |     B([u128; 4000]),\n+   | |     --------------- the largest variant contains at least 64000 bytes\n+LL | | }\n+   | |_^ the entire enum is at least 64008 bytes\n    |\n-LL |     A(bool),\n-   |     ^^^^^^^\n note: boxing a variant would require the type no longer be `Copy`\n   --> $DIR/large_enum_variant.rs:107:6\n    |\n@@ -172,16 +206,16 @@ LL |     B([u128; 4000]),\n    |     ^^^^^^^^^^^^^^^\n \n error: large size difference between variants\n-  --> $DIR/large_enum_variant.rs:122:5\n+  --> $DIR/large_enum_variant.rs:120:1\n    |\n-LL |     B([u64; 4000]),\n-   |     ^^^^^^^^^^^^^^ this variant is 32000 bytes\n-   |\n-note: and the second-largest variant is 1 bytes:\n-  --> $DIR/large_enum_variant.rs:121:5\n+LL | / enum SomeGenericPossiblyCopyEnum<T> {\n+LL | |     A(bool, std::marker::PhantomData<T>),\n+   | |     ------------------------------------ the second-largest variant contains at least 1 bytes\n+LL | |     B([u64; 4000]),\n+   | |     -------------- the largest variant contains at least 32000 bytes\n+LL | | }\n+   | |_^ the entire enum is at least 32008 bytes\n    |\n-LL |     A(bool, std::marker::PhantomData<T>),\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: boxing a variant would require the type no longer be `Copy`\n   --> $DIR/large_enum_variant.rs:120:6\n    |\n@@ -193,5 +227,53 @@ help: consider boxing the large fields to reduce the total size of the enum\n LL |     B([u64; 4000]),\n    |     ^^^^^^^^^^^^^^\n \n-error: aborting due to 11 previous errors\n+error: large size difference between variants\n+  --> $DIR/large_enum_variant.rs:133:1\n+   |\n+LL | / enum LargeEnumWithGenerics<T> {\n+LL | |     Small,\n+   | |     ----- the second-largest variant carries no data at all\n+LL | |     Large((T, [u8; 512])),\n+   | |     --------------------- the largest variant contains at least 512 bytes\n+LL | | }\n+   | |_^ the entire enum is at least 512 bytes\n+   |\n+help: consider boxing the large fields to reduce the total size of the enum\n+   |\n+LL |     Large(Box<(T, [u8; 512])>),\n+   |           ~~~~~~~~~~~~~~~~~~~\n+\n+error: large size difference between variants\n+  --> $DIR/large_enum_variant.rs:142:1\n+   |\n+LL | / enum WithGenerics {\n+LL | |     Large([Foo<u64>; 64]),\n+   | |     --------------------- the largest variant contains at least 512 bytes\n+LL | |     Small(u8),\n+   | |     --------- the second-largest variant contains at least 1 bytes\n+LL | | }\n+   | |_^ the entire enum is at least 520 bytes\n+   |\n+help: consider boxing the large fields to reduce the total size of the enum\n+   |\n+LL |     Large(Box<[Foo<u64>; 64]>),\n+   |           ~~~~~~~~~~~~~~~~~~~\n+\n+error: large size difference between variants\n+  --> $DIR/large_enum_variant.rs:152:1\n+   |\n+LL | / enum LargeEnumOfConst {\n+LL | |     Ok,\n+   | |     -- the second-largest variant carries no data at all\n+LL | |     Error(PossiblyLargeEnumWithConst<256>),\n+   | |     -------------------------------------- the largest variant contains at least 514 bytes\n+LL | | }\n+   | |_^ the entire enum is at least 514 bytes\n+   |\n+help: consider boxing the large fields to reduce the total size of the enum\n+   |\n+LL |     Error(Box<PossiblyLargeEnumWithConst<256>>),\n+   |           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+error: aborting due to 16 previous errors\n "}, {"sha": "f7df3b85655013f4b02e712354355cf7abbae0d5", "filename": "tests/ui/result_large_err.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/584000a792b1016677fe4e0e78706d14a8034eb2/tests%2Fui%2Fresult_large_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584000a792b1016677fe4e0e78706d14a8034eb2/tests%2Fui%2Fresult_large_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresult_large_err.rs?ref=584000a792b1016677fe4e0e78706d14a8034eb2", "patch": "@@ -1,4 +1,5 @@\n #![warn(clippy::result_large_err)]\n+#![allow(clippy::large_enum_variant)]\n \n pub fn small_err() -> Result<(), u128> {\n     Ok(())"}, {"sha": "ef19f2854ab12e731663126183c1d8f0795e48bb", "filename": "tests/ui/result_large_err.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/584000a792b1016677fe4e0e78706d14a8034eb2/tests%2Fui%2Fresult_large_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/584000a792b1016677fe4e0e78706d14a8034eb2/tests%2Fui%2Fresult_large_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresult_large_err.stderr?ref=584000a792b1016677fe4e0e78706d14a8034eb2", "patch": "@@ -1,5 +1,5 @@\n error: the `Err`-variant returned from this function is very large\n-  --> $DIR/result_large_err.rs:7:23\n+  --> $DIR/result_large_err.rs:8:23\n    |\n LL | pub fn large_err() -> Result<(), [u8; 512]> {\n    |                       ^^^^^^^^^^^^^^^^^^^^^ the `Err`-variant is at least 512 bytes\n@@ -8,79 +8,79 @@ LL | pub fn large_err() -> Result<(), [u8; 512]> {\n    = help: try reducing the size of `[u8; 512]`, for example by boxing large elements or replacing it with `Box<[u8; 512]>`\n \n error: the `Err`-variant returned from this function is very large\n-  --> $DIR/result_large_err.rs:18:21\n+  --> $DIR/result_large_err.rs:19:21\n    |\n LL |     pub fn ret() -> Result<(), Self> {\n    |                     ^^^^^^^^^^^^^^^^ the `Err`-variant is at least 240 bytes\n    |\n    = help: try reducing the size of `FullyDefinedLargeError`, for example by boxing large elements or replacing it with `Box<FullyDefinedLargeError>`\n \n error: the `Err`-variant returned from this function is very large\n-  --> $DIR/result_large_err.rs:23:26\n+  --> $DIR/result_large_err.rs:24:26\n    |\n LL | pub fn struct_error() -> Result<(), FullyDefinedLargeError> {\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the `Err`-variant is at least 240 bytes\n    |\n    = help: try reducing the size of `FullyDefinedLargeError`, for example by boxing large elements or replacing it with `Box<FullyDefinedLargeError>`\n \n error: the `Err`-variant returned from this function is very large\n-  --> $DIR/result_large_err.rs:28:45\n+  --> $DIR/result_large_err.rs:29:45\n    |\n LL | pub fn large_err_via_type_alias<T>(x: T) -> Fdlr<T> {\n    |                                             ^^^^^^^ the `Err`-variant is at least 240 bytes\n    |\n    = help: try reducing the size of `FullyDefinedLargeError`, for example by boxing large elements or replacing it with `Box<FullyDefinedLargeError>`\n \n error: the `Err`-variant returned from this function is very large\n-  --> $DIR/result_large_err.rs:36:34\n+  --> $DIR/result_large_err.rs:37:34\n    |\n LL | pub fn param_large_error<R>() -> Result<(), (u128, R, FullyDefinedLargeError)> {\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the `Err`-variant is at least 256 bytes\n    |\n    = help: try reducing the size of `(u128, R, FullyDefinedLargeError)`, for example by boxing large elements or replacing it with `Box<(u128, R, FullyDefinedLargeError)>`\n \n error: the `Err`-variant returned from this function is very large\n-  --> $DIR/result_large_err.rs:47:34\n+  --> $DIR/result_large_err.rs:48:34\n    |\n LL |     pub fn large_enum_error() -> Result<(), Self> {\n    |                                  ^^^^^^^^^^^^^^^^ the `Err`-variant is at least 513 bytes\n    |\n    = help: try reducing the size of `LargeErrorVariants<()>`, for example by boxing large elements or replacing it with `Box<LargeErrorVariants<()>>`\n \n error: the `Err`-variant returned from this function is very large\n-  --> $DIR/result_large_err.rs:53:25\n+  --> $DIR/result_large_err.rs:54:25\n    |\n LL |     fn large_error() -> Result<(), [u8; 512]> {\n    |                         ^^^^^^^^^^^^^^^^^^^^^ the `Err`-variant is at least 512 bytes\n    |\n    = help: try reducing the size of `[u8; 512]`, for example by boxing large elements or replacing it with `Box<[u8; 512]>`\n \n error: the `Err`-variant returned from this function is very large\n-  --> $DIR/result_large_err.rs:72:29\n+  --> $DIR/result_large_err.rs:73:29\n    |\n LL | pub fn large_union_err() -> Result<(), FullyDefinedUnionError> {\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the `Err`-variant is at least 512 bytes\n    |\n    = help: try reducing the size of `FullyDefinedUnionError`, for example by boxing large elements or replacing it with `Box<FullyDefinedUnionError>`\n \n error: the `Err`-variant returned from this function is very large\n-  --> $DIR/result_large_err.rs:81:40\n+  --> $DIR/result_large_err.rs:82:40\n    |\n LL | pub fn param_large_union<T: Copy>() -> Result<(), UnionError<T>> {\n    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^ the `Err`-variant is at least 512 bytes\n    |\n    = help: try reducing the size of `UnionError<T>`, for example by boxing large elements or replacing it with `Box<UnionError<T>>`\n \n error: the `Err`-variant returned from this function is very large\n-  --> $DIR/result_large_err.rs:90:34\n+  --> $DIR/result_large_err.rs:91:34\n    |\n LL | pub fn array_error_subst<U>() -> Result<(), ArrayError<i32, U>> {\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the `Err`-variant is at least 128 bytes\n    |\n    = help: try reducing the size of `ArrayError<i32, U>`, for example by boxing large elements or replacing it with `Box<ArrayError<i32, U>>`\n \n error: the `Err`-variant returned from this function is very large\n-  --> $DIR/result_large_err.rs:94:31\n+  --> $DIR/result_large_err.rs:95:31\n    |\n LL | pub fn array_error<T, U>() -> Result<(), ArrayError<(i32, T), U>> {\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the `Err`-variant is at least 128 bytes"}]}