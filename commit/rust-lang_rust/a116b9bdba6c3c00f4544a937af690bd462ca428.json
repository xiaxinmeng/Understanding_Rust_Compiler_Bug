{"sha": "a116b9bdba6c3c00f4544a937af690bd462ca428", "node_id": "C_kwDOAAsO6NoAKGExMTZiOWJkYmE2YzNjMDBmNDU0NGE5MzdhZjY5MGJkNDYyY2E0Mjg", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-11-14T12:42:47Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-11-25T09:09:34Z"}, "message": "Lint unnecessary safety comments on items", "tree": {"sha": "c13a49ca41a8660b105cba0e8dd6e697422eab6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c13a49ca41a8660b105cba0e8dd6e697422eab6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a116b9bdba6c3c00f4544a937af690bd462ca428", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a116b9bdba6c3c00f4544a937af690bd462ca428", "html_url": "https://github.com/rust-lang/rust/commit/a116b9bdba6c3c00f4544a937af690bd462ca428", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a116b9bdba6c3c00f4544a937af690bd462ca428/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a9657139d1beca1d01486ba360fa17c43b9f58f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a9657139d1beca1d01486ba360fa17c43b9f58f", "html_url": "https://github.com/rust-lang/rust/commit/1a9657139d1beca1d01486ba360fa17c43b9f58f"}], "stats": {"total": 259, "additions": 200, "deletions": 59}, "files": [{"sha": "23912bb3ed6b16aea9a4ce27ad1cd5a1a2f50661", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a116b9bdba6c3c00f4544a937af690bd462ca428/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/a116b9bdba6c3c00f4544a937af690bd462ca428/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=a116b9bdba6c3c00f4544a937af690bd462ca428", "patch": "@@ -4451,6 +4451,7 @@ Released 2018-09-13\n [`unnecessary_mut_passed`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_mut_passed\n [`unnecessary_operation`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_operation\n [`unnecessary_owned_empty_strings`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_owned_empty_strings\n+[`unnecessary_safety_comment`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_safety_comment\n [`unnecessary_safety_doc`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_safety_doc\n [`unnecessary_self_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_self_imports\n [`unnecessary_sort_by`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_sort_by"}, {"sha": "e4d76f07d6b482b13fa7d5fbaf9cb8b6ce9923fd", "filename": "clippy_lints/src/declared_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a116b9bdba6c3c00f4544a937af690bd462ca428/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a116b9bdba6c3c00f4544a937af690bd462ca428/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeclared_lints.rs?ref=a116b9bdba6c3c00f4544a937af690bd462ca428", "patch": "@@ -584,6 +584,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::types::TYPE_COMPLEXITY_INFO,\n     crate::types::VEC_BOX_INFO,\n     crate::undocumented_unsafe_blocks::UNDOCUMENTED_UNSAFE_BLOCKS_INFO,\n+    crate::undocumented_unsafe_blocks::UNNECESSARY_SAFETY_COMMENT_INFO,\n     crate::unicode::INVISIBLE_CHARACTERS_INFO,\n     crate::unicode::NON_ASCII_LITERAL_INFO,\n     crate::unicode::UNICODE_NOT_NFC_INFO,"}, {"sha": "57ee2735aa0339ea5c00b00f615d602b4ad67744", "filename": "clippy_lints/src/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 183, "deletions": 57, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/a116b9bdba6c3c00f4544a937af690bd462ca428/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a116b9bdba6c3c00f4544a937af690bd462ca428/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs?ref=a116b9bdba6c3c00f4544a937af690bd462ca428", "patch": "@@ -59,8 +59,36 @@ declare_clippy_lint! {\n     restriction,\n     \"creating an unsafe block without explaining why it is safe\"\n }\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `// SAFETY: ` comments on safe code.\n+    ///\n+    /// ### Why is this bad?\n+    /// Safe code has no safety requirements, so there is no need to\n+    /// describe safety invariants.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// use std::ptr::NonNull;\n+    /// let a = &mut 42;\n+    ///\n+    /// // SAFETY: references are guaranteed to be non-null.\n+    /// let ptr = NonNull::new(a).unwrap();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::ptr::NonNull;\n+    /// let a = &mut 42;\n+    ///\n+    /// let ptr = NonNull::new(a).unwrap();\n+    /// ```\n+    #[clippy::version = \"1.66.0\"]\n+    pub UNNECESSARY_SAFETY_COMMENT,\n+    restriction,\n+    \"creating an unsafe block without explaining why it is safe\"\n+}\n \n-declare_lint_pass!(UndocumentedUnsafeBlocks => [UNDOCUMENTED_UNSAFE_BLOCKS]);\n+declare_lint_pass!(UndocumentedUnsafeBlocks => [UNDOCUMENTED_UNSAFE_BLOCKS, UNNECESSARY_SAFETY_COMMENT]);\n \n impl LateLintPass<'_> for UndocumentedUnsafeBlocks {\n     fn check_block(&mut self, cx: &LateContext<'_>, block: &'_ Block<'_>) {\n@@ -90,28 +118,95 @@ impl LateLintPass<'_> for UndocumentedUnsafeBlocks {\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        if let hir::ItemKind::Impl(imple) = item.kind\n-            && imple.unsafety == hir::Unsafety::Unsafe\n-            && !in_external_macro(cx.tcx.sess, item.span)\n-            && !is_lint_allowed(cx, UNDOCUMENTED_UNSAFE_BLOCKS, item.hir_id())\n-            && !is_unsafe_from_proc_macro(cx, item.span)\n-            && !item_has_safety_comment(cx, item)\n-        {\n+        if in_external_macro(cx.tcx.sess, item.span) {\n+            return;\n+        }\n+\n+        let mk_spans = |pos: BytePos| {\n             let source_map = cx.tcx.sess.source_map();\n+            let span = Span::new(pos, pos, SyntaxContext::root(), None);\n+            let help_span = source_map.span_extend_to_next_char(span, '\\n', true);\n             let span = if source_map.is_multiline(item.span) {\n                 source_map.span_until_char(item.span, '\\n')\n             } else {\n                 item.span\n             };\n+            (span, help_span)\n+        };\n \n-            span_lint_and_help(\n-                cx,\n-                UNDOCUMENTED_UNSAFE_BLOCKS,\n-                span,\n-                \"unsafe impl missing a safety comment\",\n-                None,\n-                \"consider adding a safety comment on the preceding line\",\n-            );\n+        let item_has_safety_comment = item_has_safety_comment(cx, item);\n+        match (&item.kind, item_has_safety_comment) {\n+            (hir::ItemKind::Impl(impl_), HasSafetyComment::No) if impl_.unsafety == hir::Unsafety::Unsafe => {\n+                if !is_lint_allowed(cx, UNDOCUMENTED_UNSAFE_BLOCKS, item.hir_id())\n+                    && !is_unsafe_from_proc_macro(cx, item.span)\n+                {\n+                    let source_map = cx.tcx.sess.source_map();\n+                    let span = if source_map.is_multiline(item.span) {\n+                        source_map.span_until_char(item.span, '\\n')\n+                    } else {\n+                        item.span\n+                    };\n+\n+                    span_lint_and_help(\n+                        cx,\n+                        UNDOCUMENTED_UNSAFE_BLOCKS,\n+                        span,\n+                        \"unsafe impl missing a safety comment\",\n+                        None,\n+                        \"consider adding a safety comment on the preceding line\",\n+                    );\n+                }\n+            },\n+            (hir::ItemKind::Impl(impl_), HasSafetyComment::Yes(pos)) if impl_.unsafety == hir::Unsafety::Normal => {\n+                if !is_lint_allowed(cx, UNNECESSARY_SAFETY_COMMENT, item.hir_id()) {\n+                    let (span, help_span) = mk_spans(pos);\n+\n+                    span_lint_and_help(\n+                        cx,\n+                        UNNECESSARY_SAFETY_COMMENT,\n+                        span,\n+                        \"impl has unnecessary safety comment\",\n+                        Some(help_span),\n+                        \"consider removing the safety comment\",\n+                    );\n+                }\n+            },\n+            (hir::ItemKind::Impl(_), _) => {},\n+            (&hir::ItemKind::Const(.., body) | &hir::ItemKind::Static(.., body), HasSafetyComment::Yes(pos)) => {\n+                if !is_lint_allowed(cx, UNNECESSARY_SAFETY_COMMENT, body.hir_id) {\n+                    let body = cx.tcx.hir().body(body);\n+                    if !matches!(\n+                        body.value.kind, hir::ExprKind::Block(block, _)\n+                        if block.rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided)\n+                    ) {\n+                        let (span, help_span) = mk_spans(pos);\n+\n+                        span_lint_and_help(\n+                            cx,\n+                            UNNECESSARY_SAFETY_COMMENT,\n+                            span,\n+                            &format!(\"{} has unnecessary safety comment\", item.kind.descr()),\n+                            Some(help_span),\n+                            \"consider removing the safety comment\",\n+                        );\n+                    }\n+                }\n+            },\n+            (_, HasSafetyComment::Yes(pos)) => {\n+                if !is_lint_allowed(cx, UNNECESSARY_SAFETY_COMMENT, item.hir_id()) {\n+                    let (span, help_span) = mk_spans(pos);\n+\n+                    span_lint_and_help(\n+                        cx,\n+                        UNNECESSARY_SAFETY_COMMENT,\n+                        span,\n+                        &format!(\"{} has unnecessary safety comment\", item.kind.descr()),\n+                        Some(help_span),\n+                        \"consider removing the safety comment\",\n+                    );\n+                }\n+            },\n+            _ => (),\n         }\n     }\n }\n@@ -170,28 +265,38 @@ fn block_has_safety_comment(cx: &LateContext<'_>, span: Span) -> bool {\n     // won't work. This is to avoid dealing with where such a comment should be place relative to\n     // attributes and doc comments.\n \n-    span_from_macro_expansion_has_safety_comment(cx, span) || span_in_body_has_safety_comment(cx, span)\n+    matches!(\n+        span_from_macro_expansion_has_safety_comment(cx, span),\n+        HasSafetyComment::Yes(_)\n+    ) || span_in_body_has_safety_comment(cx, span)\n+}\n+\n+enum HasSafetyComment {\n+    Yes(BytePos),\n+    No,\n+    Maybe,\n }\n \n /// Checks if the lines immediately preceding the item contain a safety comment.\n #[allow(clippy::collapsible_match)]\n-fn item_has_safety_comment(cx: &LateContext<'_>, item: &hir::Item<'_>) -> bool {\n-    if span_from_macro_expansion_has_safety_comment(cx, item.span) {\n-        return true;\n+fn item_has_safety_comment(cx: &LateContext<'_>, item: &hir::Item<'_>) -> HasSafetyComment {\n+    match span_from_macro_expansion_has_safety_comment(cx, item.span) {\n+        HasSafetyComment::Maybe => (),\n+        has_safety_comment => return has_safety_comment,\n     }\n \n     if item.span.ctxt() == SyntaxContext::root() {\n         if let Some(parent_node) = get_parent_node(cx.tcx, item.hir_id()) {\n             let comment_start = match parent_node {\n                 Node::Crate(parent_mod) => {\n-                    comment_start_before_impl_in_mod(cx, parent_mod, parent_mod.spans.inner_span, item)\n+                    comment_start_before_item_in_mod(cx, parent_mod, parent_mod.spans.inner_span, item)\n                 },\n                 Node::Item(parent_item) => {\n                     if let ItemKind::Mod(parent_mod) = &parent_item.kind {\n-                        comment_start_before_impl_in_mod(cx, parent_mod, parent_item.span, item)\n+                        comment_start_before_item_in_mod(cx, parent_mod, parent_item.span, item)\n                     } else {\n                         // Doesn't support impls in this position. Pretend a comment was found.\n-                        return true;\n+                        return HasSafetyComment::Maybe;\n                     }\n                 },\n                 Node::Stmt(stmt) => {\n@@ -200,17 +305,17 @@ fn item_has_safety_comment(cx: &LateContext<'_>, item: &hir::Item<'_>) -> bool {\n                             Node::Block(block) => walk_span_to_context(block.span, SyntaxContext::root()).map(Span::lo),\n                             _ => {\n                                 // Doesn't support impls in this position. Pretend a comment was found.\n-                                return true;\n+                                return HasSafetyComment::Maybe;\n                             },\n                         }\n                     } else {\n                         // Problem getting the parent node. Pretend a comment was found.\n-                        return true;\n+                        return HasSafetyComment::Maybe;\n                     }\n                 },\n                 _ => {\n                     // Doesn't support impls in this position. Pretend a comment was found.\n-                    return true;\n+                    return HasSafetyComment::Maybe;\n                 },\n             };\n \n@@ -222,33 +327,40 @@ fn item_has_safety_comment(cx: &LateContext<'_>, item: &hir::Item<'_>) -> bool {\n                 && let Some(src) = unsafe_line.sf.src.as_deref()\n             {\n                 unsafe_line.sf.lines(|lines| {\n-                    comment_start_line.line < unsafe_line.line && text_has_safety_comment(\n-                        src,\n-                        &lines[comment_start_line.line + 1..=unsafe_line.line],\n-                        unsafe_line.sf.start_pos.to_usize(),\n-                    )\n+                    if comment_start_line.line >= unsafe_line.line {\n+                        HasSafetyComment::No\n+                    } else {\n+                        match text_has_safety_comment(\n+                            src,\n+                            &lines[comment_start_line.line + 1..=unsafe_line.line],\n+                            unsafe_line.sf.start_pos.to_usize(),\n+                        ) {\n+                            Some(b) => HasSafetyComment::Yes(b),\n+                            None => HasSafetyComment::No,\n+                        }\n+                    }\n                 })\n             } else {\n                 // Problem getting source text. Pretend a comment was found.\n-                true\n+                HasSafetyComment::Maybe\n             }\n         } else {\n             // No parent node. Pretend a comment was found.\n-            true\n+            HasSafetyComment::Maybe\n         }\n     } else {\n-        false\n+        HasSafetyComment::No\n     }\n }\n \n-fn comment_start_before_impl_in_mod(\n+fn comment_start_before_item_in_mod(\n     cx: &LateContext<'_>,\n     parent_mod: &hir::Mod<'_>,\n     parent_mod_span: Span,\n-    imple: &hir::Item<'_>,\n+    item: &hir::Item<'_>,\n ) -> Option<BytePos> {\n     parent_mod.item_ids.iter().enumerate().find_map(|(idx, item_id)| {\n-        if *item_id == imple.item_id() {\n+        if *item_id == item.item_id() {\n             if idx == 0 {\n                 // mod A { /* comment */ unsafe impl T {} ... }\n                 // ^------------------------------------------^ returns the start of this span\n@@ -270,11 +382,11 @@ fn comment_start_before_impl_in_mod(\n     })\n }\n \n-fn span_from_macro_expansion_has_safety_comment(cx: &LateContext<'_>, span: Span) -> bool {\n+fn span_from_macro_expansion_has_safety_comment(cx: &LateContext<'_>, span: Span) -> HasSafetyComment {\n     let source_map = cx.sess().source_map();\n     let ctxt = span.ctxt();\n     if ctxt == SyntaxContext::root() {\n-        false\n+        HasSafetyComment::Maybe\n     } else {\n         // From a macro expansion. Get the text from the start of the macro declaration to start of the\n         // unsafe block.\n@@ -286,15 +398,22 @@ fn span_from_macro_expansion_has_safety_comment(cx: &LateContext<'_>, span: Span\n             && let Some(src) = unsafe_line.sf.src.as_deref()\n         {\n             unsafe_line.sf.lines(|lines| {\n-                macro_line.line < unsafe_line.line && text_has_safety_comment(\n-                    src,\n-                    &lines[macro_line.line + 1..=unsafe_line.line],\n-                    unsafe_line.sf.start_pos.to_usize(),\n-                )\n+                if macro_line.line < unsafe_line.line {\n+                    match text_has_safety_comment(\n+                        src,\n+                        &lines[macro_line.line + 1..=unsafe_line.line],\n+                        unsafe_line.sf.start_pos.to_usize(),\n+                    ) {\n+                        Some(b) => HasSafetyComment::Yes(b),\n+                        None => HasSafetyComment::No,\n+                    }\n+                } else {\n+                    HasSafetyComment::No\n+                }\n             })\n         } else {\n             // Problem getting source text. Pretend a comment was found.\n-            true\n+            HasSafetyComment::Maybe\n         }\n     }\n }\n@@ -333,7 +452,7 @@ fn span_in_body_has_safety_comment(cx: &LateContext<'_>, span: Span) -> bool {\n                     src,\n                     &lines[body_line.line + 1..=unsafe_line.line],\n                     unsafe_line.sf.start_pos.to_usize(),\n-                )\n+                ).is_some()\n             })\n         } else {\n             // Problem getting source text. Pretend a comment was found.\n@@ -345,30 +464,34 @@ fn span_in_body_has_safety_comment(cx: &LateContext<'_>, span: Span) -> bool {\n }\n \n /// Checks if the given text has a safety comment for the immediately proceeding line.\n-fn text_has_safety_comment(src: &str, line_starts: &[BytePos], offset: usize) -> bool {\n+fn text_has_safety_comment(src: &str, line_starts: &[BytePos], offset: usize) -> Option<BytePos> {\n     let mut lines = line_starts\n         .array_windows::<2>()\n         .rev()\n         .map_while(|[start, end]| {\n             let start = start.to_usize() - offset;\n             let end = end.to_usize() - offset;\n-            src.get(start..end).map(|text| (start, text.trim_start()))\n+            let text = src.get(start..end)?;\n+            let trimmed = text.trim_start();\n+            Some((start + (text.len() - trimmed.len()), trimmed))\n         })\n         .filter(|(_, text)| !text.is_empty());\n \n     let Some((line_start, line)) = lines.next() else {\n-        return false;\n+        return None;\n     };\n     // Check for a sequence of line comments.\n     if line.starts_with(\"//\") {\n-        let mut line = line;\n+        let (mut line, mut line_start) = (line, line_start);\n         loop {\n             if line.to_ascii_uppercase().contains(\"SAFETY:\") {\n-                return true;\n+                return Some(BytePos(\n+                    u32::try_from(line_start).unwrap() + u32::try_from(offset).unwrap(),\n+                ));\n             }\n             match lines.next() {\n-                Some((_, x)) if x.starts_with(\"//\") => line = x,\n-                _ => return false,\n+                Some((s, x)) if x.starts_with(\"//\") => (line, line_start) = (x, s),\n+                _ => return None,\n             }\n         }\n     }\n@@ -377,16 +500,19 @@ fn text_has_safety_comment(src: &str, line_starts: &[BytePos], offset: usize) ->\n     let (mut line_start, mut line) = (line_start, line);\n     loop {\n         if line.starts_with(\"/*\") {\n-            let src = src[line_start..line_starts.last().unwrap().to_usize() - offset].trim_start();\n+            let src = &src[line_start..line_starts.last().unwrap().to_usize() - offset];\n             let mut tokens = tokenize(src);\n-            return src[..tokens.next().unwrap().len as usize]\n+            return (src[..tokens.next().unwrap().len as usize]\n                 .to_ascii_uppercase()\n                 .contains(\"SAFETY:\")\n-                && tokens.all(|t| t.kind == TokenKind::Whitespace);\n+                && tokens.all(|t| t.kind == TokenKind::Whitespace))\n+            .then_some(BytePos(\n+                u32::try_from(line_start).unwrap() + u32::try_from(offset).unwrap(),\n+            ));\n         }\n         match lines.next() {\n             Some(x) => (line_start, line) = x,\n-            None => return false,\n+            None => return None,\n         }\n     }\n }"}, {"sha": "c05eb447b2ebd34e50ef3db1197116eab83e7241", "filename": "tests/ui/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a116b9bdba6c3c00f4544a937af690bd462ca428/tests%2Fui%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a116b9bdba6c3c00f4544a937af690bd462ca428/tests%2Fui%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fundocumented_unsafe_blocks.rs?ref=a116b9bdba6c3c00f4544a937af690bd462ca428", "patch": "@@ -1,6 +1,6 @@\n // aux-build:proc_macro_unsafe.rs\n \n-#![warn(clippy::undocumented_unsafe_blocks)]\n+#![warn(clippy::undocumented_unsafe_blocks, clippy::unnecessary_safety_comment)]\n #![allow(clippy::let_unit_value, clippy::missing_safety_doc)]\n \n extern crate proc_macro_unsafe;"}, {"sha": "4c6f6cd18c51849da75762c46f335ede207ba6c0", "filename": "tests/ui/undocumented_unsafe_blocks.stderr", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a116b9bdba6c3c00f4544a937af690bd462ca428/tests%2Fui%2Fundocumented_unsafe_blocks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a116b9bdba6c3c00f4544a937af690bd462ca428/tests%2Fui%2Fundocumented_unsafe_blocks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fundocumented_unsafe_blocks.stderr?ref=a116b9bdba6c3c00f4544a937af690bd462ca428", "patch": "@@ -239,6 +239,19 @@ LL |     unsafe impl TrailingComment for () {} // SAFETY:\n    |\n    = help: consider adding a safety comment on the preceding line\n \n+error: constant item has unnecessary safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:471:5\n+   |\n+LL |     const BIG_NUMBER: i32 = 1000000;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider removing the safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:470:5\n+   |\n+LL |     // SAFETY:\n+   |     ^^^^^^^^^^\n+   = note: `-D clippy::unnecessary-safety-comment` implied by `-D warnings`\n+\n error: unsafe impl missing a safety comment\n   --> $DIR/undocumented_unsafe_blocks.rs:472:5\n    |\n@@ -287,5 +300,5 @@ LL |             let bar = unsafe {};\n    |\n    = help: consider adding a safety comment on the preceding line\n \n-error: aborting due to 34 previous errors\n+error: aborting due to 35 previous errors\n "}]}