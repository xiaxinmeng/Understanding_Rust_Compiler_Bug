{"sha": "066eb08f5d4304394d16af634c02d75c31adf580", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NmViMDhmNWQ0MzA0Mzk0ZDE2YWY2MzRjMDJkNzVjMzFhZGY1ODA=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-06T20:36:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-06T20:36:55Z"}, "message": "Rollup merge of #71950 - RalfJung:try-validation-cleanup, r=oli-obk\n\nMiri validation error handling cleanup\n\nSlightly expand @jumbatm's pattern macro and use it throughout validation. This ensures we never incorrectly swallow `InvalidProgram` errors or ICE when they occur.\n\nFixes https://github.com/rust-lang/rust/issues/71353\nr? @oli-obk", "tree": {"sha": "6e7854eeb4cb6ed5b1c07f8589186bbfa167446f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e7854eeb4cb6ed5b1c07f8589186bbfa167446f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/066eb08f5d4304394d16af634c02d75c31adf580", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJesx/nCRBK7hj4Ov3rIwAAdHIIACA/72cZRChRGrAjIz+V6nno\nXSSSZZxrjaevAbqoufQCwzCMYEJdAsIIgM62YK0R4rAzTnO2FzoXJDTv3glxUuh6\nEgMgMyPkimf0OSPJ0VmoWgtoztbi8VygQEq3NcwhR/ESx4qYLu5MJOxOsmp1T+kD\n30hHPbLwuDOvVg5MHh+sE7C3gb3CRTpWJnl1GnwgX2Ub8efFdIP39a9Iuizz5F8+\nYmNmY+dV/qCGfVuXVrNrL3p9f68coqQaC8W7G42uPKCzsj4onpPlgKXzJsurRPJ9\nbj0N9TdLn5C/bTgk1rBQMwyJAd5TaGLGY75L3WaTtdBbNpE5GIKoLeklG5UlUxc=\n=U8u8\n-----END PGP SIGNATURE-----\n", "payload": "tree 6e7854eeb4cb6ed5b1c07f8589186bbfa167446f\nparent d33180e1d77f92c0cc8d3302fa5bb75cc090417f\nparent 0e2a712743513f9b8e1c7cc4abdd287432534206\nauthor Dylan DPC <dylan.dpc@gmail.com> 1588797415 +0200\ncommitter GitHub <noreply@github.com> 1588797415 +0200\n\nRollup merge of #71950 - RalfJung:try-validation-cleanup, r=oli-obk\n\nMiri validation error handling cleanup\n\nSlightly expand @jumbatm's pattern macro and use it throughout validation. This ensures we never incorrectly swallow `InvalidProgram` errors or ICE when they occur.\n\nFixes https://github.com/rust-lang/rust/issues/71353\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/066eb08f5d4304394d16af634c02d75c31adf580", "html_url": "https://github.com/rust-lang/rust/commit/066eb08f5d4304394d16af634c02d75c31adf580", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/066eb08f5d4304394d16af634c02d75c31adf580/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d33180e1d77f92c0cc8d3302fa5bb75cc090417f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d33180e1d77f92c0cc8d3302fa5bb75cc090417f", "html_url": "https://github.com/rust-lang/rust/commit/d33180e1d77f92c0cc8d3302fa5bb75cc090417f"}, {"sha": "0e2a712743513f9b8e1c7cc4abdd287432534206", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e2a712743513f9b8e1c7cc4abdd287432534206", "html_url": "https://github.com/rust-lang/rust/commit/0e2a712743513f9b8e1c7cc4abdd287432534206"}], "stats": {"total": 379, "additions": 205, "deletions": 174}, "files": [{"sha": "ffe71eb3a0924c8008fd65fd657542d0ed9e77cd", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/066eb08f5d4304394d16af634c02d75c31adf580/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066eb08f5d4304394d16af634c02d75c31adf580/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=066eb08f5d4304394d16af634c02d75c31adf580", "patch": "@@ -3,8 +3,7 @@ use super::{AllocId, Pointer, RawConst, ScalarMaybeUndef};\n use crate::mir::interpret::ConstValue;\n use crate::ty::layout::LayoutError;\n use crate::ty::query::TyCtxtAt;\n-use crate::ty::tls;\n-use crate::ty::{self, layout, Ty};\n+use crate::ty::{self, layout, tls, FnSig, Ty};\n \n use rustc_data_structures::sync::Lock;\n use rustc_errors::{struct_span_err, DiagnosticBuilder, ErrorReported};\n@@ -329,7 +328,7 @@ impl fmt::Display for CheckInAllocMsg {\n }\n \n /// Error information for when the program caused Undefined Behavior.\n-pub enum UndefinedBehaviorInfo {\n+pub enum UndefinedBehaviorInfo<'tcx> {\n     /// Free-form case. Only for errors that are never caught!\n     Ub(String),\n     /// Unreachable code was executed.\n@@ -347,6 +346,8 @@ pub enum UndefinedBehaviorInfo {\n     PointerArithOverflow,\n     /// Invalid metadata in a wide pointer (using `str` to avoid allocations).\n     InvalidMeta(&'static str),\n+    /// Invalid drop function in vtable.\n+    InvalidDropFn(FnSig<'tcx>),\n     /// Reading a C string that does not end within its allocation.\n     UnterminatedCString(Pointer),\n     /// Dereferencing a dangling pointer after it got freed.\n@@ -380,6 +381,8 @@ pub enum UndefinedBehaviorInfo {\n     InvalidDiscriminant(ScalarMaybeUndef),\n     /// Using a pointer-not-to-a-function as function pointer.\n     InvalidFunctionPointer(Pointer),\n+    /// Using a string that is not valid UTF-8,\n+    InvalidStr(std::str::Utf8Error),\n     /// Using uninitialized data where it is not allowed.\n     InvalidUndefBytes(Option<Pointer>),\n     /// Working with a local that is not currently live.\n@@ -391,7 +394,7 @@ pub enum UndefinedBehaviorInfo {\n     },\n }\n \n-impl fmt::Display for UndefinedBehaviorInfo {\n+impl fmt::Display for UndefinedBehaviorInfo<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use UndefinedBehaviorInfo::*;\n         match self {\n@@ -404,6 +407,11 @@ impl fmt::Display for UndefinedBehaviorInfo {\n             RemainderByZero => write!(f, \"calculating the remainder with a divisor of zero\"),\n             PointerArithOverflow => write!(f, \"overflowing in-bounds pointer arithmetic\"),\n             InvalidMeta(msg) => write!(f, \"invalid metadata in wide pointer: {}\", msg),\n+            InvalidDropFn(sig) => write!(\n+                f,\n+                \"invalid drop function signature: got {}, expected exactly one argument which must be a pointer type\",\n+                sig\n+            ),\n             UnterminatedCString(p) => write!(\n                 f,\n                 \"reading a null-terminated string starting at {} with no null found before end of allocation\",\n@@ -446,6 +454,7 @@ impl fmt::Display for UndefinedBehaviorInfo {\n             InvalidFunctionPointer(p) => {\n                 write!(f, \"using {} as function pointer but it does not point to a function\", p)\n             }\n+            InvalidStr(err) => write!(f, \"this string is not valid UTF-8: {}\", err),\n             InvalidUndefBytes(Some(p)) => write!(\n                 f,\n                 \"reading uninitialized memory at {}, but this operation requires initialized memory\",\n@@ -549,7 +558,7 @@ impl dyn MachineStopType {\n \n pub enum InterpError<'tcx> {\n     /// The program caused undefined behavior.\n-    UndefinedBehavior(UndefinedBehaviorInfo),\n+    UndefinedBehavior(UndefinedBehaviorInfo<'tcx>),\n     /// The program did something the interpreter does not support (some of these *might* be UB\n     /// but the interpreter is not sure).\n     Unsupported(UnsupportedOpInfo),"}, {"sha": "db836d88dd05eaa0b45850dcaab7f7f266becb49", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/066eb08f5d4304394d16af634c02d75c31adf580/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066eb08f5d4304394d16af634c02d75c31adf580/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=066eb08f5d4304394d16af634c02d75c31adf580", "patch": "@@ -327,8 +327,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn read_str(&self, mplace: MPlaceTy<'tcx, M::PointerTag>) -> InterpResult<'tcx, &str> {\n         let len = mplace.len(self)?;\n         let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len))?;\n-        let str = ::std::str::from_utf8(bytes)\n-            .map_err(|err| err_ub_format!(\"this string is not valid UTF-8: {}\", err))?;\n+        let str = ::std::str::from_utf8(bytes).map_err(|err| err_ub!(InvalidStr(err)))?;\n         Ok(str)\n     }\n "}, {"sha": "b9f9d37df7645d19400ac4c3a5ebb783a859e04c", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/066eb08f5d4304394d16af634c02d75c31adf580/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066eb08f5d4304394d16af634c02d75c31adf580/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=066eb08f5d4304394d16af634c02d75c31adf580", "patch": "@@ -147,14 +147,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // The drop function takes `*mut T` where `T` is the type being dropped, so get that.\n         let args = fn_sig.inputs();\n         if args.len() != 1 {\n-            throw_ub_format!(\"drop fn should have 1 argument, but signature is {:?}\", fn_sig);\n+            throw_ub!(InvalidDropFn(fn_sig));\n         }\n-        let ty = args[0]\n-            .builtin_deref(true)\n-            .ok_or_else(|| {\n-                err_ub_format!(\"drop fn argument type {} is not a pointer type\", args[0])\n-            })?\n-            .ty;\n+        let ty = args[0].builtin_deref(true).ok_or_else(|| err_ub!(InvalidDropFn(fn_sig)))?.ty;\n         Ok((drop_instance, ty))\n     }\n "}, {"sha": "9f2e79bbee31ea71537372f21356aa9b6ff5a997", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 138, "deletions": 150, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/066eb08f5d4304394d16af634c02d75c31adf580/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066eb08f5d4304394d16af634c02d75c31adf580/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=066eb08f5d4304394d16af634c02d75c31adf580", "patch": "@@ -25,43 +25,39 @@ use super::{\n };\n \n macro_rules! throw_validation_failure {\n-    ($what:expr, $where:expr $(, $expected:expr )?) => {{\n-        let mut msg = format!(\"encountered {}\", $what);\n+    ($where:expr, { $( $what_fmt:expr ),+ } $( expected { $( $expected_fmt:expr ),+ } )?) => {{\n+        let mut msg = String::new();\n+        msg.push_str(\"encountered \");\n+        write!(&mut msg, $($what_fmt),+).unwrap();\n         let where_ = &$where;\n         if !where_.is_empty() {\n             msg.push_str(\" at \");\n             write_path(&mut msg, where_);\n         }\n-        $( write!(&mut msg, \", but expected {}\", $expected).unwrap(); )?\n+        $(\n+            msg.push_str(\", but expected \");\n+            write!(&mut msg, $($expected_fmt),+).unwrap();\n+        )?\n         throw_ub!(ValidationFailure(msg))\n     }};\n }\n \n-/// Returns a validation failure for any Err value of $e.\n-// FIXME: Replace all usages of try_validation! with try_validation_pat!.\n-macro_rules! try_validation {\n-    ($e:expr, $what:expr, $where:expr $(, $expected:expr )?) => {{\n-        try_validation_pat!($e, $where, {\n-            _ => { \"{}\", $what } $( expected { \"{}\", $expected } )?,\n-        })\n-    }};\n-}\n-/// Like try_validation, but will throw a validation error if any of the patterns in $p are\n-/// matched. Other errors are passed back to the caller, unchanged. This lets you use the patterns\n-/// as a kind of validation blacklist:\n+/// If $e throws an error matching the pattern, throw a validation failure.\n+/// Other errors are passed back to the caller, unchanged -- and if they reach the root of\n+/// the visitor, we make sure only validation errors and `InvalidProgram` errors are left.\n+/// This lets you use the patterns as a kind of validation whitelist, asserting which errors\n+/// can possibly happen:\n ///\n /// ```\n-/// let v = try_validation_pat!(some_fn(), some_path, {\n+/// let v = try_validation!(some_fn(), some_path, {\n ///     Foo | Bar | Baz => { \"some failure\" },\n /// });\n-/// // Failures that match $p are thrown up as validation errors, but other errors are passed back\n-/// // unchanged.\n /// ```\n ///\n /// An additional expected parameter can also be added to the failure message:\n ///\n /// ```\n-/// let v = try_validation_pat!(some_fn(), some_path, {\n+/// let v = try_validation!(some_fn(), some_path, {\n ///     Foo | Bar | Baz => { \"some failure\" } expected { \"something that wasn't a failure\" },\n /// });\n /// ```\n@@ -70,24 +66,25 @@ macro_rules! try_validation {\n /// the format string in directly:\n ///\n /// ```\n-/// let v = try_validation_pat!(some_fn(), some_path, {\n+/// let v = try_validation!(some_fn(), some_path, {\n ///     Foo | Bar | Baz => { \"{:?}\", some_failure } expected { \"{}\", expected_value },\n /// });\n /// ```\n ///\n-macro_rules! try_validation_pat {\n-    ($e:expr, $where:expr, { $( $p:pat )|+ =>\n-        { $( $what_fmt:expr ),+ } $( expected { $( $expected_fmt:expr ),+ } )? $( , )?}) => {{\n+macro_rules! try_validation {\n+    ($e:expr, $where:expr,\n+     $( $( $p:pat )|+ => { $( $what_fmt:expr ),+ } $( expected { $( $expected_fmt:expr ),+ } )? ),+ $(,)?\n+    ) => {{\n         match $e {\n             Ok(x) => x,\n             // We catch the error and turn it into a validation failure. We are okay with\n             // allocation here as this can only slow down builds that fail anyway.\n-            $( Err(InterpErrorInfo { kind: $p, .. }) )|+ =>\n+            $( $( Err(InterpErrorInfo { kind: $p, .. }) )|+ =>\n                 throw_validation_failure!(\n-                    format_args!($( $what_fmt ),+),\n-                    $where\n-                    $(, format_args!($( $expected_fmt ),+))?\n+                    $where,\n+                    { $( $what_fmt ),+ } $( expected { $( $expected_fmt ),+ } )?\n                 ),\n+            )+\n             #[allow(unreachable_patterns)]\n             Err(e) => Err::<!, _>(e)?,\n         }\n@@ -303,32 +300,45 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         match tail.kind {\n             ty::Dynamic(..) => {\n                 let vtable = meta.unwrap_meta();\n+                // Direct call to `check_ptr_access_align` checks alignment even on CTFE machines.\n                 try_validation!(\n-                    self.ecx.memory.check_ptr_access(\n+                    self.ecx.memory.check_ptr_access_align(\n                         vtable,\n                         3 * self.ecx.tcx.data_layout.pointer_size, // drop, size, align\n-                        self.ecx.tcx.data_layout.pointer_align.abi,\n+                        Some(self.ecx.tcx.data_layout.pointer_align.abi),\n+                        CheckInAllocMsg::InboundsTest,\n                     ),\n-                    \"dangling or unaligned vtable pointer in wide pointer or too small vtable\",\n-                    self.path\n+                    self.path,\n+                    err_ub!(DanglingIntPointer(..)) |\n+                    err_ub!(PointerUseAfterFree(..)) |\n+                    err_unsup!(ReadBytesAsPointer) =>\n+                        { \"dangling vtable pointer in wide pointer\" },\n+                    err_ub!(AlignmentCheckFailed { .. }) =>\n+                        { \"unaligned vtable pointer in wide pointer\" },\n+                    err_ub!(PointerOutOfBounds { .. }) =>\n+                        { \"too small vtable\" },\n                 );\n                 try_validation!(\n                     self.ecx.read_drop_type_from_vtable(vtable),\n-                    \"invalid drop fn in vtable\",\n-                    self.path\n+                    self.path,\n+                    err_ub!(InvalidDropFn(..)) |\n+                    err_ub!(DanglingIntPointer(..)) |\n+                    err_ub!(InvalidFunctionPointer(..)) |\n+                    err_unsup!(ReadBytesAsPointer) =>\n+                        { \"invalid drop function pointer in vtable\" },\n                 );\n                 try_validation!(\n                     self.ecx.read_size_and_align_from_vtable(vtable),\n-                    \"invalid size or align in vtable\",\n-                    self.path\n+                    self.path,\n+                    err_unsup!(ReadPointerAsBytes) => { \"invalid size or align in vtable\" },\n                 );\n                 // FIXME: More checks for the vtable.\n             }\n             ty::Slice(..) | ty::Str => {\n                 let _len = try_validation!(\n                     meta.unwrap_meta().to_machine_usize(self.ecx),\n-                    \"non-integer slice length in wide pointer\",\n-                    self.path\n+                    self.path,\n+                    err_unsup!(ReadPointerAsBytes) => { \"non-integer slice length in wide pointer\" },\n                 );\n                 // We do not check that `len * elem_size <= isize::MAX`:\n                 // that is only required for references, and there it falls out of the\n@@ -354,78 +364,52 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         // Check metadata early, for better diagnostics\n         let place = try_validation!(\n             self.ecx.ref_to_mplace(value),\n-            format_args!(\"uninitialized {}\", kind),\n-            self.path\n+            self.path,\n+            err_ub!(InvalidUndefBytes(..)) => { \"uninitialized {}\", kind },\n         );\n         if place.layout.is_unsized() {\n             self.check_wide_ptr_meta(place.meta, place.layout)?;\n         }\n         // Make sure this is dereferenceable and all.\n-        let size_and_align = match self.ecx.size_and_align_of(place.meta, place.layout) {\n-            Ok(res) => res,\n-            Err(err) => match err.kind {\n-                err_ub!(InvalidMeta(msg)) => throw_validation_failure!(\n-                    format_args!(\"invalid {} metadata: {}\", kind, msg),\n-                    self.path\n-                ),\n-                _ => bug!(\"unexpected error during ptr size_and_align_of: {}\", err),\n-            },\n-        };\n+        let size_and_align = try_validation!(\n+            self.ecx.size_and_align_of(place.meta, place.layout),\n+            self.path,\n+            err_ub!(InvalidMeta(msg)) => { \"invalid {} metadata: {}\", kind, msg },\n+        );\n         let (size, align) = size_and_align\n             // for the purpose of validity, consider foreign types to have\n             // alignment and size determined by the layout (size will be 0,\n             // alignment should take attributes into account).\n             .unwrap_or_else(|| (place.layout.size, place.layout.align.abi));\n-        let ptr: Option<_> = match self.ecx.memory.check_ptr_access_align(\n-            place.ptr,\n-            size,\n-            Some(align),\n-            CheckInAllocMsg::InboundsTest,\n-        ) {\n-            Ok(ptr) => ptr,\n-            Err(err) => {\n-                info!(\n-                    \"{:?} did not pass access check for size {:?}, align {:?}\",\n-                    place.ptr, size, align\n-                );\n-                match err.kind {\n-                    err_ub!(DanglingIntPointer(0, _)) => {\n-                        throw_validation_failure!(format_args!(\"a NULL {}\", kind), self.path)\n-                    }\n-                    err_ub!(DanglingIntPointer(i, _)) => throw_validation_failure!(\n-                        format_args!(\"a {} to unallocated address {}\", kind, i),\n-                        self.path\n-                    ),\n-                    err_ub!(AlignmentCheckFailed { required, has }) => throw_validation_failure!(\n-                        format_args!(\n-                            \"an unaligned {} (required {} byte alignment but found {})\",\n-                            kind,\n-                            required.bytes(),\n-                            has.bytes()\n-                        ),\n-                        self.path\n-                    ),\n-                    err_unsup!(ReadBytesAsPointer) => throw_validation_failure!(\n-                        format_args!(\"a dangling {} (created from integer)\", kind),\n-                        self.path\n-                    ),\n-                    err_ub!(PointerOutOfBounds { .. }) => throw_validation_failure!(\n-                        format_args!(\n-                            \"a dangling {} (going beyond the bounds of its allocation)\",\n-                            kind\n-                        ),\n-                        self.path\n-                    ),\n-                    // This cannot happen during const-eval (because interning already detects\n-                    // dangling pointers), but it can happen in Miri.\n-                    err_ub!(PointerUseAfterFree(_)) => throw_validation_failure!(\n-                        format_args!(\"a dangling {} (use-after-free)\", kind),\n-                        self.path\n-                    ),\n-                    _ => bug!(\"Unexpected error during ptr inbounds test: {}\", err),\n-                }\n-            }\n-        };\n+        // Direct call to `check_ptr_access_align` checks alignment even on CTFE machines.\n+        let ptr: Option<_> = try_validation!(\n+            self.ecx.memory.check_ptr_access_align(\n+                place.ptr,\n+                size,\n+                Some(align),\n+                CheckInAllocMsg::InboundsTest,\n+            ),\n+            self.path,\n+            err_ub!(AlignmentCheckFailed { required, has }) =>\n+                {\n+                    \"an unaligned {} (required {} byte alignment but found {})\",\n+                    kind,\n+                    required.bytes(),\n+                    has.bytes()\n+                },\n+            err_ub!(DanglingIntPointer(0, _)) =>\n+                { \"a NULL {}\", kind },\n+            err_ub!(DanglingIntPointer(i, _)) =>\n+                { \"a dangling {} (address {} is unallocated)\", kind, i },\n+            err_ub!(PointerOutOfBounds { .. }) =>\n+                { \"a dangling {} (going beyond the bounds of its allocation)\", kind },\n+            err_unsup!(ReadBytesAsPointer) =>\n+                { \"a dangling {} (created from integer)\", kind },\n+            // This cannot happen during const-eval (because interning already detects\n+            // dangling pointers), but it can happen in Miri.\n+            err_ub!(PointerUseAfterFree(..)) =>\n+                { \"a dangling {} (use-after-free)\", kind },\n+        );\n         // Recursive checking\n         if let Some(ref mut ref_tracking) = self.ref_tracking_for_consts {\n             if let Some(ptr) = ptr {\n@@ -440,9 +424,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     // We also need to do it here instead of going on to avoid running\n                     // into the `before_access_global` check during validation.\n                     if !self.may_ref_to_static && self.ecx.tcx.is_static(did) {\n-                        throw_validation_failure!(\n-                            format_args!(\"a {} pointing to a static variable\", kind),\n-                            self.path\n+                        throw_validation_failure!(self.path,\n+                            { \"a {} pointing to a static variable\", kind }\n                         );\n                     }\n                     // `extern static` cannot be validated as they have no body.\n@@ -489,12 +472,20 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         match ty.kind {\n             ty::Bool => {\n                 let value = self.ecx.read_scalar(value)?;\n-                try_validation!(value.to_bool(), value, self.path, \"a boolean\");\n+                try_validation!(\n+                    value.to_bool(),\n+                    self.path,\n+                    err_ub!(InvalidBool(..)) => { \"{}\", value } expected { \"a boolean\" },\n+                );\n                 Ok(true)\n             }\n             ty::Char => {\n                 let value = self.ecx.read_scalar(value)?;\n-                try_validation!(value.to_char(), value, self.path, \"a valid unicode codepoint\");\n+                try_validation!(\n+                    value.to_char(),\n+                    self.path,\n+                    err_ub!(InvalidChar(..)) => { \"{}\", value } expected { \"a valid unicode codepoint\" },\n+                );\n                 Ok(true)\n             }\n             ty::Float(_) | ty::Int(_) | ty::Uint(_) => {\n@@ -505,10 +496,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n                     let is_bits = value.not_undef().map_or(false, |v| v.is_bits());\n                     if !is_bits {\n-                        throw_validation_failure!(\n-                            value,\n-                            self.path,\n-                            \"initialized plain (non-pointer) bytes\"\n+                        throw_validation_failure!(self.path,\n+                            { \"{}\", value } expected { \"initialized plain (non-pointer) bytes\" }\n                         )\n                     }\n                 } else {\n@@ -521,9 +510,11 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // We are conservative with undef for integers, but try to\n                 // actually enforce the strict rules for raw pointers (mostly because\n                 // that lets us re-use `ref_to_mplace`).\n-                let place = try_validation_pat!(self.ecx.ref_to_mplace(self.ecx.read_immediate(value)?), self.path, {\n+                let place = try_validation!(\n+                    self.ecx.ref_to_mplace(self.ecx.read_immediate(value)?),\n+                    self.path,\n                     err_ub!(InvalidUndefBytes(..)) => { \"uninitialized raw pointer\" },\n-                });\n+                );\n                 if place.layout.is_unsized() {\n                     self.check_wide_ptr_meta(place.meta, place.layout)?;\n                 }\n@@ -541,14 +532,16 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 let value = self.ecx.read_scalar(value)?;\n                 let _fn = try_validation!(\n                     value.not_undef().and_then(|ptr| self.ecx.memory.get_fn(ptr)),\n-                    value,\n                     self.path,\n-                    \"a function pointer\"\n+                    err_ub!(DanglingIntPointer(..)) |\n+                    err_ub!(InvalidFunctionPointer(..)) |\n+                    err_unsup!(ReadBytesAsPointer) =>\n+                        { \"{}\", value } expected { \"a function pointer\" },\n                 );\n                 // FIXME: Check if the signature matches\n                 Ok(true)\n             }\n-            ty::Never => throw_validation_failure!(\"a value of the never type `!`\", self.path),\n+            ty::Never => throw_validation_failure!(self.path, { \"a value of the never type `!`\" }),\n             ty::Foreign(..) | ty::FnDef(..) => {\n                 // Nothing to check.\n                 Ok(true)\n@@ -598,35 +591,33 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         // At least one value is excluded. Get the bits.\n         let value = try_validation!(\n             value.not_undef(),\n-            value,\n             self.path,\n-            format_args!(\"something {}\", wrapping_range_format(valid_range, max_hi),)\n+            err_ub!(InvalidUndefBytes(..)) => { \"{}\", value }\n+                expected { \"something {}\", wrapping_range_format(valid_range, max_hi) },\n         );\n         let bits = match value.to_bits_or_ptr(op.layout.size, self.ecx) {\n             Err(ptr) => {\n                 if lo == 1 && hi == max_hi {\n                     // Only NULL is the niche.  So make sure the ptr is NOT NULL.\n                     if self.ecx.memory.ptr_may_be_null(ptr) {\n-                        throw_validation_failure!(\n-                            \"a potentially NULL pointer\",\n-                            self.path,\n-                            format_args!(\n+                        throw_validation_failure!(self.path,\n+                            { \"a potentially NULL pointer\" }\n+                            expected {\n                                 \"something that cannot possibly fail to be {}\",\n                                 wrapping_range_format(valid_range, max_hi)\n-                            )\n+                            }\n                         )\n                     }\n                     return Ok(());\n                 } else {\n                     // Conservatively, we reject, because the pointer *could* have a bad\n                     // value.\n-                    throw_validation_failure!(\n-                        \"a pointer\",\n-                        self.path,\n-                        format_args!(\n+                    throw_validation_failure!(self.path,\n+                        { \"a pointer\" }\n+                        expected {\n                             \"something that cannot possibly fail to be {}\",\n                             wrapping_range_format(valid_range, max_hi)\n-                        )\n+                        }\n                     )\n                 }\n             }\n@@ -636,10 +627,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         if wrapping_range_contains(&valid_range, bits) {\n             Ok(())\n         } else {\n-            throw_validation_failure!(\n-                bits,\n-                self.path,\n-                format_args!(\"something {}\", wrapping_range_format(valid_range, max_hi))\n+            throw_validation_failure!(self.path,\n+                { \"{}\", bits }\n+                expected { \"something {}\", wrapping_range_format(valid_range, max_hi) }\n             )\n         }\n     }\n@@ -703,19 +693,14 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         assert!(op.layout.ty.builtin_deref(true).is_none());\n \n         // Recursively walk the type. Translate some possible errors to something nicer.\n-        match self.walk_value(op) {\n-            Ok(()) => {}\n-            Err(err) => match err.kind {\n-                err_ub!(InvalidDiscriminant(val)) => {\n-                    throw_validation_failure!(val, self.path, \"a valid enum discriminant\")\n-                }\n-                err_unsup!(ReadPointerAsBytes) => {\n-                    throw_validation_failure!(\"a pointer\", self.path, \"plain (non-pointer) bytes\")\n-                }\n-                // Propagate upwards (that will also check for unexpected errors).\n-                _ => return Err(err),\n-            },\n-        }\n+        try_validation!(\n+            self.walk_value(op),\n+            self.path,\n+            err_ub!(InvalidDiscriminant(val)) =>\n+                { \"{}\", val } expected { \"a valid enum discriminant\" },\n+            err_unsup!(ReadPointerAsBytes) =>\n+                { \"a pointer\" } expected { \"plain (non-pointer) bytes\" },\n+        );\n \n         // *After* all of this, check the ABI.  We need to check the ABI to handle\n         // types like `NonNull` where the `Scalar` info is more restrictive than what\n@@ -729,9 +714,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         // MyNewtype and then the scalar in there).\n         match op.layout.abi {\n             Abi::Uninhabited => {\n-                throw_validation_failure!(\n-                    format_args!(\"a value of uninhabited type {:?}\", op.layout.ty),\n-                    self.path\n+                throw_validation_failure!(self.path,\n+                    { \"a value of uninhabited type {:?}\", op.layout.ty }\n                 );\n             }\n             Abi::Scalar(ref scalar_layout) => {\n@@ -761,8 +745,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 let mplace = op.assert_mem_place(self.ecx); // strings are never immediate\n                 try_validation!(\n                     self.ecx.read_str(mplace),\n-                    \"uninitialized or non-UTF-8 data in str\",\n-                    self.path\n+                    self.path,\n+                    err_ub!(InvalidStr(..)) => { \"uninitialized or non-UTF-8 data in str\" },\n                 );\n             }\n             ty::Array(tys, ..) | ty::Slice(tys)\n@@ -815,7 +799,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     Ok(()) => {}\n                     // Some error happened, try to provide a more detailed description.\n                     Err(err) => {\n-                        // For some errors we might be able to provide extra information\n+                        // For some errors we might be able to provide extra information.\n+                        // (This custom logic does not fit the `try_validation!` macro.)\n                         match err.kind {\n                             err_ub!(InvalidUndefBytes(Some(ptr))) => {\n                                 // Some byte was uninitialized, determine which\n@@ -825,7 +810,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                                     .unwrap();\n                                 self.path.push(PathElem::ArrayElem(i));\n \n-                                throw_validation_failure!(\"uninitialized bytes\", self.path)\n+                                throw_validation_failure!(self.path, { \"uninitialized bytes\" })\n                             }\n                             // Propagate upwards (that will also check for unexpected errors).\n                             _ => return Err(err),\n@@ -876,7 +861,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // validate and each caller will know best what to do with them.\n             Err(err) if matches!(err.kind, InterpError::InvalidProgram(_)) => Err(err),\n             // Avoid other errors as those do not show *where* in the value the issue lies.\n-            Err(err) => bug!(\"Unexpected error during validation: {}\", err),\n+            Err(err) => {\n+                err.print_backtrace();\n+                bug!(\"Unexpected error during validation: {}\", err);\n+            }\n         }\n     }\n "}, {"sha": "29ac32fcf2204765e7fe0f2a5ee9f914887f3b05", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/066eb08f5d4304394d16af634c02d75c31adf580/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066eb08f5d4304394d16af634c02d75c31adf580/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs?ref=066eb08f5d4304394d16af634c02d75c31adf580", "patch": "@@ -104,6 +104,14 @@ const TRAIT_OBJ_SHORT_VTABLE_2: &dyn Trait = unsafe { mem::transmute((&92u8, &3u\n // bad trait object\n const TRAIT_OBJ_INT_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, 4usize)) };\n //~^ ERROR it is undefined behavior to use this value\n+const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n+//~^ ERROR it is undefined behavior to use this value\n+const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n+//~^ ERROR it is undefined behavior to use this value\n+const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n+//~^ ERROR it is undefined behavior to use this value\n+const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: &dyn Trait = unsafe { mem::transmute((&92u8, &[&42u8; 8])) };\n+//~^ ERROR it is undefined behavior to use this value\n \n // bad data *inside* the trait object\n const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };"}, {"sha": "94ca60596d61bd6ccebf689626a5e42745cc39e6", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.stderr", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/066eb08f5d4304394d16af634c02d75c31adf580/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/066eb08f5d4304394d16af634c02d75c31adf580/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr?ref=066eb08f5d4304394d16af634c02d75c31adf580", "patch": "@@ -138,62 +138,94 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:99:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: &dyn Trait = unsafe { mem::transmute((&92u8, &3u8)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:102:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: &dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:105:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, 4usize)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling vtable pointer in wide pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:107:1\n+   |\n+LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered unaligned vtable pointer in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:109:1\n    |\n+LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop function pointer in vtable\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:111:1\n+   |\n+LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop function pointer in vtable\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:113:1\n+   |\n+LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: &dyn Trait = unsafe { mem::transmute((&92u8, &[&42u8; 8])) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop function pointer in vtable\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:117:1\n+   |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0x03 at .<deref>.<dyn-downcast>, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:113:1\n+  --> $DIR/ub-wide-ptr.rs:121:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling vtable pointer in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:115:1\n+  --> $DIR/ub-wide-ptr.rs:123:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:121:5\n+  --> $DIR/ub-wide-ptr.rs:129:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ inbounds test failed: 0x0 is not a valid pointer\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:125:5\n+  --> $DIR/ub-wide-ptr.rs:133:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: pointer must be in-bounds at offset N, but is outside bounds of allocN which has size N\n \n-error: aborting due to 24 previous errors\n+error: aborting due to 28 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}]}