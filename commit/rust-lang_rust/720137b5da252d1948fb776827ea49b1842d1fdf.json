{"sha": "720137b5da252d1948fb776827ea49b1842d1fdf", "node_id": "C_kwDOAAsO6NoAKDcyMDEzN2I1ZGEyNTJkMTk0OGZiNzc2ODI3ZWE0OWIxODQyZDFmZGY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-13T18:16:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-13T18:16:44Z"}, "message": "Rollup merge of #106701 - ibraheemdev:sync-sender-spin, r=Amanieu\n\nFix `mpsc::SyncSender` spinning behavior\n\nResolves https://github.com/rust-lang/rust/issues/106668.", "tree": {"sha": "8f6e7430f6f66472c198d15c102959445b79325c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f6e7430f6f66472c198d15c102959445b79325c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/720137b5da252d1948fb776827ea49b1842d1fdf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjwaAMCRBK7hj4Ov3rIwAAhcMIAHMsGjX7z2zJ5ZFQpa1wNpVE\nZFCkbEjkF81W6CjneE4kmUX2oNn+2wp76yIdBkiD5T5mFIdoGvPTAlPUynMVI4ja\nJiBs0WAxITLJfvPrlozbo616RlOLfgM7QoM2Gt/31whnscH2iZxo7K9LXhNBd+Vs\nh4/18uq2cKvfRybvtLAOqUJfETDCbVLhaUirbMStLXHZHurOo50TzBl2iopZH4Mo\nkQ6zDDLBpqUIJMMSN3Cc99beFkoaWBM7zsZJYnXeCDvfQZsNJReZayGg6Ri2O+MQ\nS8mv6ckIl1Sp2GWec4NG7pX7+aZh9/y35Ni0EXoXwF+CmbZIZEoHRMhHJoNZpvs=\n=VIcR\n-----END PGP SIGNATURE-----\n", "payload": "tree 8f6e7430f6f66472c198d15c102959445b79325c\nparent e4d01047547ba7fa3939e70e69df39e7bef78c5a\nparent 8917e9936282f855a08808ed8874c4117210da6e\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1673633804 +0100\ncommitter GitHub <noreply@github.com> 1673633804 +0100\n\nRollup merge of #106701 - ibraheemdev:sync-sender-spin, r=Amanieu\n\nFix `mpsc::SyncSender` spinning behavior\n\nResolves https://github.com/rust-lang/rust/issues/106668.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/720137b5da252d1948fb776827ea49b1842d1fdf", "html_url": "https://github.com/rust-lang/rust/commit/720137b5da252d1948fb776827ea49b1842d1fdf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/720137b5da252d1948fb776827ea49b1842d1fdf/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4d01047547ba7fa3939e70e69df39e7bef78c5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4d01047547ba7fa3939e70e69df39e7bef78c5a", "html_url": "https://github.com/rust-lang/rust/commit/e4d01047547ba7fa3939e70e69df39e7bef78c5a"}, {"sha": "8917e9936282f855a08808ed8874c4117210da6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8917e9936282f855a08808ed8874c4117210da6e", "html_url": "https://github.com/rust-lang/rust/commit/8917e9936282f855a08808ed8874c4117210da6e"}], "stats": {"total": 82, "additions": 49, "deletions": 33}, "files": [{"sha": "c1e3e48b04468c8c501d45392b3c06b35fa34ac8", "filename": "library/std/src/sync/mpmc/array.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/720137b5da252d1948fb776827ea49b1842d1fdf/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720137b5da252d1948fb776827ea49b1842d1fdf/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs?ref=720137b5da252d1948fb776827ea49b1842d1fdf", "patch": "@@ -168,7 +168,7 @@ impl<T> Channel<T> {\n                         return true;\n                     }\n                     Err(_) => {\n-                        backoff.spin();\n+                        backoff.spin_light();\n                         tail = self.tail.load(Ordering::Relaxed);\n                     }\n                 }\n@@ -182,11 +182,11 @@ impl<T> Channel<T> {\n                     return false;\n                 }\n \n-                backoff.spin();\n+                backoff.spin_light();\n                 tail = self.tail.load(Ordering::Relaxed);\n             } else {\n                 // Snooze because we need to wait for the stamp to get updated.\n-                backoff.snooze();\n+                backoff.spin_heavy();\n                 tail = self.tail.load(Ordering::Relaxed);\n             }\n         }\n@@ -251,7 +251,7 @@ impl<T> Channel<T> {\n                         return true;\n                     }\n                     Err(_) => {\n-                        backoff.spin();\n+                        backoff.spin_light();\n                         head = self.head.load(Ordering::Relaxed);\n                     }\n                 }\n@@ -273,11 +273,11 @@ impl<T> Channel<T> {\n                     }\n                 }\n \n-                backoff.spin();\n+                backoff.spin_light();\n                 head = self.head.load(Ordering::Relaxed);\n             } else {\n                 // Snooze because we need to wait for the stamp to get updated.\n-                backoff.snooze();\n+                backoff.spin_heavy();\n                 head = self.head.load(Ordering::Relaxed);\n             }\n         }\n@@ -330,7 +330,7 @@ impl<T> Channel<T> {\n                 if backoff.is_completed() {\n                     break;\n                 } else {\n-                    backoff.spin();\n+                    backoff.spin_light();\n                 }\n             }\n "}, {"sha": "ec6c0726ac790304403e374be47c6246c50f66dc", "filename": "library/std/src/sync/mpmc/list.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/720137b5da252d1948fb776827ea49b1842d1fdf/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720137b5da252d1948fb776827ea49b1842d1fdf/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs?ref=720137b5da252d1948fb776827ea49b1842d1fdf", "patch": "@@ -46,7 +46,7 @@ impl<T> Slot<T> {\n     fn wait_write(&self) {\n         let backoff = Backoff::new();\n         while self.state.load(Ordering::Acquire) & WRITE == 0 {\n-            backoff.snooze();\n+            backoff.spin_heavy();\n         }\n     }\n }\n@@ -82,7 +82,7 @@ impl<T> Block<T> {\n             if !next.is_null() {\n                 return next;\n             }\n-            backoff.snooze();\n+            backoff.spin_heavy();\n         }\n     }\n \n@@ -191,7 +191,7 @@ impl<T> Channel<T> {\n \n             // If we reached the end of the block, wait until the next one is installed.\n             if offset == BLOCK_CAP {\n-                backoff.snooze();\n+                backoff.spin_heavy();\n                 tail = self.tail.index.load(Ordering::Acquire);\n                 block = self.tail.block.load(Ordering::Acquire);\n                 continue;\n@@ -247,7 +247,7 @@ impl<T> Channel<T> {\n                     return true;\n                 },\n                 Err(_) => {\n-                    backoff.spin();\n+                    backoff.spin_light();\n                     tail = self.tail.index.load(Ordering::Acquire);\n                     block = self.tail.block.load(Ordering::Acquire);\n                 }\n@@ -286,7 +286,7 @@ impl<T> Channel<T> {\n \n             // If we reached the end of the block, wait until the next one is installed.\n             if offset == BLOCK_CAP {\n-                backoff.snooze();\n+                backoff.spin_heavy();\n                 head = self.head.index.load(Ordering::Acquire);\n                 block = self.head.block.load(Ordering::Acquire);\n                 continue;\n@@ -320,7 +320,7 @@ impl<T> Channel<T> {\n             // The block can be null here only if the first message is being sent into the channel.\n             // In that case, just wait until it gets initialized.\n             if block.is_null() {\n-                backoff.snooze();\n+                backoff.spin_heavy();\n                 head = self.head.index.load(Ordering::Acquire);\n                 block = self.head.block.load(Ordering::Acquire);\n                 continue;\n@@ -351,7 +351,7 @@ impl<T> Channel<T> {\n                     return true;\n                 },\n                 Err(_) => {\n-                    backoff.spin();\n+                    backoff.spin_light();\n                     head = self.head.index.load(Ordering::Acquire);\n                     block = self.head.block.load(Ordering::Acquire);\n                 }\n@@ -542,7 +542,7 @@ impl<T> Channel<T> {\n             // New updates to tail will be rejected by MARK_BIT and aborted unless it's\n             // at boundary. We need to wait for the updates take affect otherwise there\n             // can be memory leaks.\n-            backoff.snooze();\n+            backoff.spin_heavy();\n             tail = self.tail.index.load(Ordering::Acquire);\n         }\n "}, {"sha": "7a602cecd3b896455a8882b66a9517b3885670ca", "filename": "library/std/src/sync/mpmc/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/720137b5da252d1948fb776827ea49b1842d1fdf/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720137b5da252d1948fb776827ea49b1842d1fdf/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs?ref=720137b5da252d1948fb776827ea49b1842d1fdf", "patch": "@@ -43,7 +43,7 @@ mod zero;\n use crate::fmt;\n use crate::panic::{RefUnwindSafe, UnwindSafe};\n use crate::time::{Duration, Instant};\n-use error::*;\n+pub use error::*;\n \n /// Creates a channel of unbounded capacity.\n ///"}, {"sha": "cfe42750d5239a6a46ab629027581df795c12129", "filename": "library/std/src/sync/mpmc/utils.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/720137b5da252d1948fb776827ea49b1842d1fdf/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720137b5da252d1948fb776827ea49b1842d1fdf/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs?ref=720137b5da252d1948fb776827ea49b1842d1fdf", "patch": "@@ -91,9 +91,8 @@ impl<T> DerefMut for CachePadded<T> {\n }\n \n const SPIN_LIMIT: u32 = 6;\n-const YIELD_LIMIT: u32 = 10;\n \n-/// Performs exponential backoff in spin loops.\n+/// Performs quadratic backoff in spin loops.\n pub struct Backoff {\n     step: Cell<u32>,\n }\n@@ -104,25 +103,27 @@ impl Backoff {\n         Backoff { step: Cell::new(0) }\n     }\n \n-    /// Backs off in a lock-free loop.\n+    /// Backs off using lightweight spinning.\n     ///\n-    /// This method should be used when we need to retry an operation because another thread made\n-    /// progress.\n+    /// This method should be used for:\n+    ///     - Retrying an operation because another thread made progress. i.e. on CAS failure.\n+    ///     - Waiting for an operation to complete by spinning optimistically for a few iterations\n+    ///     before falling back to parking the thread (see `Backoff::is_completed`).\n     #[inline]\n-    pub fn spin(&self) {\n+    pub fn spin_light(&self) {\n         let step = self.step.get().min(SPIN_LIMIT);\n         for _ in 0..step.pow(2) {\n             crate::hint::spin_loop();\n         }\n \n-        if self.step.get() <= SPIN_LIMIT {\n-            self.step.set(self.step.get() + 1);\n-        }\n+        self.step.set(self.step.get() + 1);\n     }\n \n-    /// Backs off in a blocking loop.\n+    /// Backs off using heavyweight spinning.\n+    ///\n+    /// This method should be used in blocking loops where parking the thread is not an option.\n     #[inline]\n-    pub fn snooze(&self) {\n+    pub fn spin_heavy(&self) {\n         if self.step.get() <= SPIN_LIMIT {\n             for _ in 0..self.step.get().pow(2) {\n                 crate::hint::spin_loop()\n@@ -131,14 +132,12 @@ impl Backoff {\n             crate::thread::yield_now();\n         }\n \n-        if self.step.get() <= YIELD_LIMIT {\n-            self.step.set(self.step.get() + 1);\n-        }\n+        self.step.set(self.step.get() + 1);\n     }\n \n-    /// Returns `true` if quadratic backoff has completed and blocking the thread is advised.\n+    /// Returns `true` if quadratic backoff has completed and parking the thread is advised.\n     #[inline]\n     pub fn is_completed(&self) -> bool {\n-        self.step.get() > YIELD_LIMIT\n+        self.step.get() > SPIN_LIMIT\n     }\n }"}, {"sha": "33f768dcbe90296d9a98cbc191ad65adc4ce01aa", "filename": "library/std/src/sync/mpmc/zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/720137b5da252d1948fb776827ea49b1842d1fdf/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720137b5da252d1948fb776827ea49b1842d1fdf/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fzero.rs?ref=720137b5da252d1948fb776827ea49b1842d1fdf", "patch": "@@ -57,7 +57,7 @@ impl<T> Packet<T> {\n     fn wait_ready(&self) {\n         let backoff = Backoff::new();\n         while !self.ready.load(Ordering::Acquire) {\n-            backoff.snooze();\n+            backoff.spin_heavy();\n         }\n     }\n }"}, {"sha": "6e3c28f10bb1ba9e31298fa90d34b54029ae32bd", "filename": "library/std/src/sync/mpsc/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/720137b5da252d1948fb776827ea49b1842d1fdf/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720137b5da252d1948fb776827ea49b1842d1fdf/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs?ref=720137b5da252d1948fb776827ea49b1842d1fdf", "patch": "@@ -738,6 +738,15 @@ impl<T> SyncSender<T> {\n     pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> {\n         self.inner.try_send(t)\n     }\n+\n+    // Attempts to send for a value on this receiver, returning an error if the\n+    // corresponding channel has hung up, or if it waits more than `timeout`.\n+    //\n+    // This method is currently private and only used for tests.\n+    #[allow(unused)]\n+    fn send_timeout(&self, t: T, timeout: Duration) -> Result<(), mpmc::SendTimeoutError<T>> {\n+        self.inner.send_timeout(t, timeout)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "9d2f92ffc9b1415ec6e93a93189f10f64ed35042", "filename": "library/std/src/sync/mpsc/sync_tests.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/720137b5da252d1948fb776827ea49b1842d1fdf/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720137b5da252d1948fb776827ea49b1842d1fdf/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs?ref=720137b5da252d1948fb776827ea49b1842d1fdf", "patch": "@@ -1,5 +1,6 @@\n use super::*;\n use crate::env;\n+use crate::sync::mpmc::SendTimeoutError;\n use crate::thread;\n use crate::time::Duration;\n \n@@ -41,6 +42,13 @@ fn recv_timeout() {\n     assert_eq!(rx.recv_timeout(Duration::from_millis(1)), Ok(1));\n }\n \n+#[test]\n+fn send_timeout() {\n+    let (tx, _rx) = sync_channel::<i32>(1);\n+    assert_eq!(tx.send_timeout(1, Duration::from_millis(1)), Ok(()));\n+    assert_eq!(tx.send_timeout(1, Duration::from_millis(1)), Err(SendTimeoutError::Timeout(1)));\n+}\n+\n #[test]\n fn smoke_threads() {\n     let (tx, rx) = sync_channel::<i32>(0);"}]}