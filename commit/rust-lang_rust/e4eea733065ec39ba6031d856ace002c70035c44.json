{"sha": "e4eea733065ec39ba6031d856ace002c70035c44", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ZWVhNzMzMDY1ZWMzOWJhNjAzMWQ4NTZhY2UwMDJjNzAwMzVjNDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-04T12:38:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-04T12:38:13Z"}, "message": "Auto merge of #39434 - nikomatsakis:incr-comp-skip-typeck-2, r=eddyb\n\nMiscellaneous refactors around how lints and typeck interact\n\nThis is preparation for making incr. comp. skip typeck. The main gist of is trying to rationalize the outputs from typeck that are not part of tables:\n\n- one bit of output is the `used_trait_imports` set, which becomes something we track for dependencies\n- the other big of output are various lints; we used to store these into a table on sess, but this work stores them into the`TypeckTables`, and then makes the lint pass consult that\n    - I think it probably makes sense to handle errors similarly, eventually, but that's not necessary now\n\nr? @eddyb\n\nFixes #39495", "tree": {"sha": "6c1dfd29c11959877823886f831513acc65b637c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c1dfd29c11959877823886f831513acc65b637c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4eea733065ec39ba6031d856ace002c70035c44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4eea733065ec39ba6031d856ace002c70035c44", "html_url": "https://github.com/rust-lang/rust/commit/e4eea733065ec39ba6031d856ace002c70035c44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4eea733065ec39ba6031d856ace002c70035c44/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8568fdc499453397351230f71c9df85e95a340bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/8568fdc499453397351230f71c9df85e95a340bc", "html_url": "https://github.com/rust-lang/rust/commit/8568fdc499453397351230f71c9df85e95a340bc"}, {"sha": "2fc15868a2cd5a24cfe059457e40cbcad6da2d44", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fc15868a2cd5a24cfe059457e40cbcad6da2d44", "html_url": "https://github.com/rust-lang/rust/commit/2fc15868a2cd5a24cfe059457e40cbcad6da2d44"}], "stats": {"total": 421, "additions": 290, "deletions": 131}, "files": [{"sha": "06cf32ad0f6b5306ed22d5e11c65d63035393e9a", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -363,6 +363,7 @@ dependencies = [\n name = \"rustc_errors\"\n version = \"0.0.0\"\n dependencies = [\n+ \"serialize 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n "}, {"sha": "006de1c06e2d9f9d36fdeb4f15799b83868f8a06", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -113,6 +113,7 @@ pub enum DepNode<D: Clone + Debug> {\n     AssociatedItemDefIds(D),\n     InherentImpls(D),\n     TypeckTables(D),\n+    UsedTraitImports(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -162,6 +163,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             AssociatedItemDefIds,\n             InherentImpls,\n             TypeckTables,\n+            UsedTraitImports,\n             TraitImpls,\n             ReprHints,\n         }\n@@ -230,6 +232,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             AssociatedItemDefIds(ref d) => op(d).map(AssociatedItemDefIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),\n             TypeckTables(ref d) => op(d).map(TypeckTables),\n+            UsedTraitImports(ref d) => op(d).map(UsedTraitImports),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),"}, {"sha": "2ffc3951cc94db96466248f17345fd0fba378366", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -61,15 +61,10 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n         self.map.get(k)\n     }\n \n-    pub fn get_mut(&mut self, k: &M::Key) -> Option<&mut M::Value> {\n-        self.read(k);\n-        self.write(k);\n-        self.map.get_mut(k)\n-    }\n-\n-    pub fn insert(&mut self, k: M::Key, v: M::Value) -> Option<M::Value> {\n+    pub fn insert(&mut self, k: M::Key, v: M::Value) {\n         self.write(&k);\n-        self.map.insert(k, v)\n+        let old_value = self.map.insert(k, v);\n+        assert!(old_value.is_none());\n     }\n \n     pub fn contains_key(&self, k: &M::Key) -> bool {\n@@ -83,6 +78,10 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n \n     /// Append `elem` to the vector stored for `k`, creating a new vector if needed.\n     /// This is considered a write to `k`.\n+    ///\n+    /// NOTE: Caution is required when using this method. You should\n+    /// be sure that nobody is **reading from the vector** while you\n+    /// are writing to it. Eventually, it'd be nice to remove this.\n     pub fn push<E: Clone>(&mut self, k: M::Key, elem: E)\n         where M: DepTrackingMapConfig<Value=Vec<E>>\n     {"}, {"sha": "362117d860a5c15f3aece6d8d2c1a9f497a4f634", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -33,6 +33,7 @@ use lint::{Level, LevelSource, Lint, LintId, LintPass, LintSource};\n use lint::{EarlyLintPassObject, LateLintPassObject};\n use lint::{Default, CommandLine, Node, Allow, Warn, Deny, Forbid};\n use lint::builtin;\n+use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use util::nodemap::FxHashMap;\n \n use std::cmp;\n@@ -82,7 +83,7 @@ pub struct LintStore {\n \n /// When you call `add_lint` on the session, you wind up storing one\n /// of these, which records a \"potential lint\" at a particular point.\n-#[derive(PartialEq)]\n+#[derive(PartialEq, RustcEncodable, RustcDecodable)]\n pub struct EarlyLint {\n     /// what lint is this? (e.g., `dead_code`)\n     pub id: LintId,\n@@ -558,7 +559,7 @@ pub trait LintContext<'tcx>: Sized {\n         self.lookup_and_emit(lint, Some(span), msg);\n     }\n \n-    fn early_lint(&self, early_lint: EarlyLint) {\n+    fn early_lint(&self, early_lint: &EarlyLint) {\n         let span = early_lint.diagnostic.span.primary_span().expect(\"early lint w/o primary span\");\n         let mut err = self.struct_span_lint(early_lint.id.lint,\n                                             span,\n@@ -773,11 +774,10 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n \n     // Output any lints that were previously added to the session.\n     fn visit_id(&mut self, id: ast::NodeId) {\n-        if let Some(lints) = self.sess().lints.borrow_mut().remove(&id) {\n-            debug!(\"LateContext::visit_id: id={:?} lints={:?}\", id, lints);\n-            for early_lint in lints {\n-                self.early_lint(early_lint);\n-            }\n+        let lints = self.sess().lints.borrow_mut().take(id);\n+        for early_lint in lints.iter().chain(self.tables.lints.get(id)) {\n+            debug!(\"LateContext::visit_id: id={:?} early_lint={:?}\", id, early_lint);\n+            self.early_lint(early_lint);\n         }\n     }\n \n@@ -1232,7 +1232,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // If we missed any lints added to the session, then there's a bug somewhere\n     // in the iteration code.\n-    for (id, v) in tcx.sess.lints.borrow().iter() {\n+    if let Some((id, v)) = tcx.sess.lints.borrow().get_any() {\n         for early_lint in v {\n             span_bug!(early_lint.diagnostic.span.clone(),\n                       \"unprocessed lint {:?} at {}\",\n@@ -1250,10 +1250,9 @@ pub fn check_ast_crate(sess: &Session, krate: &ast::Crate) {\n     // Visit the whole crate.\n     cx.with_lint_attrs(&krate.attrs, |cx| {\n         // Lints may be assigned to the whole crate.\n-        if let Some(lints) = cx.sess.lints.borrow_mut().remove(&ast::CRATE_NODE_ID) {\n-            for early_lint in lints {\n-                cx.early_lint(early_lint);\n-            }\n+        let lints = cx.sess.lints.borrow_mut().take(ast::CRATE_NODE_ID);\n+        for early_lint in lints {\n+            cx.early_lint(&early_lint);\n         }\n \n         // since the root module isn't visited as an item (because it isn't an\n@@ -1270,9 +1269,28 @@ pub fn check_ast_crate(sess: &Session, krate: &ast::Crate) {\n \n     // If we missed any lints added to the session, then there's a bug somewhere\n     // in the iteration code.\n-    for (_, v) in sess.lints.borrow().iter() {\n+    for (_, v) in sess.lints.borrow().get_any() {\n         for early_lint in v {\n             span_bug!(early_lint.diagnostic.span.clone(), \"unprocessed lint {:?}\", early_lint);\n         }\n     }\n }\n+\n+impl Encodable for LintId {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_str(&self.lint.name.to_lowercase())\n+    }\n+}\n+\n+impl Decodable for LintId {\n+    #[inline]\n+    fn decode<D: Decoder>(d: &mut D) -> Result<LintId, D::Error> {\n+        let s = d.read_str()?;\n+        ty::tls::with(|tcx| {\n+            match tcx.sess.lint_store.borrow().find_lint(&s, tcx.sess, None) {\n+                Ok(id) => Ok(id),\n+                Err(_) => panic!(\"invalid lint-id `{}`\", s),\n+            }\n+        })\n+    }\n+}"}, {"sha": "d12065ca86e144c5d0e682e33b596ed4122d5275", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -31,18 +31,20 @@\n pub use self::Level::*;\n pub use self::LintSource::*;\n \n+use hir;\n+use hir::intravisit::FnKind;\n use std::hash;\n use std::ascii::AsciiExt;\n use syntax_pos::Span;\n-use hir::intravisit::FnKind;\n use syntax::visit as ast_visit;\n use syntax::ast;\n-use hir;\n \n pub use lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n                         raw_emit_lint, check_crate, check_ast_crate, gather_attrs,\n                         raw_struct_lint, FutureIncompatibleInfo, EarlyLint, IntoEarlyLint};\n \n+pub use lint::table::LintTable;\n+\n /// Specification of a single lint.\n #[derive(Copy, Clone, Debug)]\n pub struct Lint {\n@@ -346,3 +348,4 @@ pub type LevelSource = (Level, LintSource);\n \n pub mod builtin;\n mod context;\n+mod table;"}, {"sha": "f2dab25229ae4e0ec3ed063c38dbd8b70d328637", "filename": "src/librustc/lint/table.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc%2Flint%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc%2Flint%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Ftable.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::ast;\n+use syntax_pos::MultiSpan;\n+use util::nodemap::NodeMap;\n+\n+use super::{Lint, LintId, EarlyLint, IntoEarlyLint};\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct LintTable {\n+    map: NodeMap<Vec<EarlyLint>>\n+}\n+\n+impl LintTable {\n+    pub fn new() -> Self {\n+        LintTable { map: NodeMap() }\n+    }\n+\n+    pub fn add_lint<S: Into<MultiSpan>>(&mut self,\n+                                        lint: &'static Lint,\n+                                        id: ast::NodeId,\n+                                        sp: S,\n+                                        msg: String)\n+    {\n+        self.add_lint_diagnostic(lint, id, (sp, &msg[..]))\n+    }\n+\n+    pub fn add_lint_diagnostic<M>(&mut self,\n+                                  lint: &'static Lint,\n+                                  id: ast::NodeId,\n+                                  msg: M)\n+        where M: IntoEarlyLint,\n+    {\n+        let lint_id = LintId::of(lint);\n+        let early_lint = msg.into_early_lint(lint_id);\n+        let arr = self.map.entry(id).or_insert(vec![]);\n+        if !arr.contains(&early_lint) {\n+            arr.push(early_lint);\n+        }\n+    }\n+\n+    pub fn get(&self, id: ast::NodeId) -> &[EarlyLint] {\n+        self.map.get(&id).map(|v| &v[..]).unwrap_or(&[])\n+    }\n+\n+    pub fn take(&mut self, id: ast::NodeId) -> Vec<EarlyLint> {\n+        self.map.remove(&id).unwrap_or(vec![])\n+    }\n+\n+    pub fn transfer(&mut self, into: &mut LintTable) {\n+        into.map.extend(self.map.drain());\n+    }\n+\n+    /// Returns the first (id, lint) pair that is non-empty. Used to\n+    /// implement a sanity check in lints that all node-ids are\n+    /// visited.\n+    pub fn get_any(&self) -> Option<(&ast::NodeId, &Vec<EarlyLint>)> {\n+        self.map.iter()\n+                .filter(|&(_, v)| !v.is_empty())\n+                .next()\n+    }\n+}\n+"}, {"sha": "f10ea3544f2cae7566189ae262e5ab43bce6ca63", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -20,7 +20,7 @@ use middle::dependency_format;\n use session::search_paths::PathKind;\n use session::config::DebugInfoLevel;\n use ty::tls;\n-use util::nodemap::{NodeMap, FxHashMap, FxHashSet};\n+use util::nodemap::{FxHashMap, FxHashSet};\n use util::common::duration_to_secs_str;\n use mir::transform as mir_pass;\n \n@@ -78,7 +78,7 @@ pub struct Session {\n     pub local_crate_source_file: Option<PathBuf>,\n     pub working_dir: PathBuf,\n     pub lint_store: RefCell<lint::LintStore>,\n-    pub lints: RefCell<NodeMap<Vec<lint::EarlyLint>>>,\n+    pub lints: RefCell<lint::LintTable>,\n     /// Set of (LintId, span, message) tuples tracking lint (sub)diagnostics\n     /// that have been set once, but should not be set again, in order to avoid\n     /// redundantly verbose output (Issue #24690).\n@@ -270,13 +270,14 @@ impl Session {\n     pub fn unimpl(&self, msg: &str) -> ! {\n         self.diagnostic().unimpl(msg)\n     }\n+\n     pub fn add_lint<S: Into<MultiSpan>>(&self,\n                                         lint: &'static lint::Lint,\n                                         id: ast::NodeId,\n                                         sp: S,\n                                         msg: String)\n     {\n-        self.add_lint_diagnostic(lint, id, (sp, &msg[..]))\n+        self.lints.borrow_mut().add_lint(lint, id, sp, msg);\n     }\n \n     pub fn add_lint_diagnostic<M>(&self,\n@@ -285,17 +286,9 @@ impl Session {\n                                   msg: M)\n         where M: lint::IntoEarlyLint,\n     {\n-        let lint_id = lint::LintId::of(lint);\n-        let mut lints = self.lints.borrow_mut();\n-        let early_lint = msg.into_early_lint(lint_id);\n-        if let Some(arr) = lints.get_mut(&id) {\n-            if !arr.contains(&early_lint) {\n-                arr.push(early_lint);\n-            }\n-            return;\n-        }\n-        lints.insert(id, vec![early_lint]);\n+        self.lints.borrow_mut().add_lint_diagnostic(lint, id, msg);\n     }\n+\n     pub fn reserve_node_ids(&self, count: usize) -> ast::NodeId {\n         let id = self.next_node_id.get();\n \n@@ -617,7 +610,7 @@ pub fn build_session_(sopts: config::Options,\n         local_crate_source_file: local_crate_source_file,\n         working_dir: env::current_dir().unwrap(),\n         lint_store: RefCell::new(lint::LintStore::new()),\n-        lints: RefCell::new(NodeMap()),\n+        lints: RefCell::new(lint::LintTable::new()),\n         one_time_diagnostics: RefCell::new(FxHashSet()),\n         plugin_llvm_passes: RefCell::new(Vec::new()),\n         mir_passes: RefCell::new(mir_pass::Passes::new()),"}, {"sha": "7dcbe04caf82bcc9d93db94f9ec17a3469a879f5", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -12,6 +12,7 @@\n \n use dep_graph::{DepGraph, DepTrackingMap};\n use session::Session;\n+use lint;\n use middle;\n use hir::TraitMap;\n use hir::def::Def;\n@@ -237,6 +238,9 @@ pub struct TypeckTables<'tcx> {\n     /// Maps a cast expression to its kind. This is keyed on the\n     /// *from* expression of the cast, not the cast itself.\n     pub cast_kinds: NodeMap<ty::cast::CastKind>,\n+\n+    /// Lints for the body of this fn generated by typeck.\n+    pub lints: lint::LintTable,\n }\n \n impl<'tcx> TypeckTables<'tcx> {\n@@ -253,6 +257,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             liberated_fn_sigs: NodeMap(),\n             fru_field_types: NodeMap(),\n             cast_kinds: NodeMap(),\n+            lints: lint::LintTable::new(),\n         }\n     }\n \n@@ -494,7 +499,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     /// Set of trait imports actually used in the method resolution.\n     /// This is used for warning unused imports.\n-    pub used_trait_imports: RefCell<NodeSet>,\n+    pub used_trait_imports: RefCell<DepTrackingMap<maps::UsedTraitImports<'tcx>>>,\n \n     /// The set of external nominal types whose implementations have been read.\n     /// This is used for lazy resolution of methods.\n@@ -783,7 +788,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             inherent_impls: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             used_unsafe: RefCell::new(NodeSet()),\n             used_mut_nodes: RefCell::new(NodeSet()),\n-            used_trait_imports: RefCell::new(NodeSet()),\n+            used_trait_imports: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             populated_external_types: RefCell::new(DefIdSet()),\n             populated_external_primitive_impls: RefCell::new(DefIdSet()),\n             stability: RefCell::new(stability),"}, {"sha": "d7341d148b720636a865cadd0f0399f8f7d189cd", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -12,6 +12,7 @@ use dep_graph::{DepNode, DepTrackingMapConfig};\n use hir::def_id::DefId;\n use mir;\n use ty::{self, Ty};\n+use util::nodemap::DefIdSet;\n \n use std::cell::RefCell;\n use std::marker::PhantomData;\n@@ -49,3 +50,4 @@ dep_map_ty! { Mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>> }\n dep_map_ty! { ClosureKinds: ItemSignature(DefId) -> ty::ClosureKind }\n dep_map_ty! { ClosureTypes: ItemSignature(DefId) -> ty::ClosureTy<'tcx> }\n dep_map_ty! { TypeckTables: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx> }\n+dep_map_ty! { UsedTraitImports: UsedTraitImports(DefId) -> DefIdSet }"}, {"sha": "78ff52b4b2371491c5cbf566293a52c588957e01", "filename": "src/librustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2FCargo.toml?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -9,4 +9,5 @@ path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n+serialize = { path = \"../libserialize\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "1b77ead92deb6a4084d6539c7658fa8678af9cbd", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -17,7 +17,7 @@ use syntax_pos::{MultiSpan, Span};\n use snippet::Style;\n \n #[must_use]\n-#[derive(Clone, Debug, PartialEq)]\n+#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub struct Diagnostic {\n     pub level: Level,\n     pub message: Vec<(String, Style)>,\n@@ -27,7 +27,7 @@ pub struct Diagnostic {\n }\n \n /// For example a note attached to an error.\n-#[derive(Clone, Debug, PartialEq)]\n+#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub struct SubDiagnostic {\n     pub level: Level,\n     pub message: Vec<(String, Style)>,"}, {"sha": "d7bd5ed23c2b0af883ce9687447d15d233f63755", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -26,6 +26,7 @@\n \n extern crate term;\n extern crate libc;\n+extern crate serialize as rustc_serialize;\n extern crate syntax_pos;\n \n pub use emitter::ColorConfig;\n@@ -49,7 +50,7 @@ mod lock;\n use syntax_pos::{BytePos, Loc, FileLinesResult, FileName, MultiSpan, Span, NO_EXPANSION};\n use syntax_pos::MacroBacktrace;\n \n-#[derive(Clone, Debug, PartialEq)]\n+#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum RenderSpan {\n     /// A FullSpan renders with both with an initial line for the\n     /// message, prefixed by file:linenum, followed by a summary of\n@@ -63,7 +64,7 @@ pub enum RenderSpan {\n     Suggestion(CodeSuggestion),\n }\n \n-#[derive(Clone, Debug, PartialEq)]\n+#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub struct CodeSuggestion {\n     pub msp: MultiSpan,\n     pub substitutes: Vec<String>,\n@@ -477,7 +478,7 @@ impl Handler {\n }\n \n \n-#[derive(Copy, PartialEq, Clone, Debug)]\n+#[derive(Copy, PartialEq, Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum Level {\n     Bug,\n     Fatal,"}, {"sha": "5debbf4d37c20286fab1be9ed9b763888c84327f", "filename": "src/librustc_errors/snippet.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_errors%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_errors%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -204,7 +204,7 @@ pub struct StyledString {\n     pub style: Style,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Style {\n     HeaderMsg,\n     FileNameStyle,"}, {"sha": "b7f90682c7c74a5382a4824f2d48213125dada4c", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n \n             let mir = tcx.alloc_mir(mir);\n             let def_id = tcx.hir.local_def_id(src.item_id());\n-            assert!(tcx.mir_map.borrow_mut().insert(def_id, mir).is_none());\n+            tcx.mir_map.borrow_mut().insert(def_id, mir);\n         });\n \n         let body = self.tcx.hir.body(body_id);"}, {"sha": "441d427fe499e366303512c107e6733b31e9f414", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -311,23 +311,25 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         let t_cast = self.cast_ty;\n         let t_expr = self.expr_ty;\n         if t_cast.is_numeric() && t_expr.is_numeric() {\n-            fcx.tcx.sess.add_lint(lint::builtin::TRIVIAL_NUMERIC_CASTS,\n-                                  self.expr.id,\n-                                  self.span,\n-                                  format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n-                                           replaced by coercion, this might require type \\\n-                                           ascription or a temporary variable\",\n-                                          fcx.ty_to_string(t_expr),\n-                                          fcx.ty_to_string(t_cast)));\n+            fcx.tables.borrow_mut().lints.add_lint(\n+                lint::builtin::TRIVIAL_NUMERIC_CASTS,\n+                self.expr.id,\n+                self.span,\n+                format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n+                         replaced by coercion, this might require type \\\n+                         ascription or a temporary variable\",\n+                        fcx.ty_to_string(t_expr),\n+                        fcx.ty_to_string(t_cast)));\n         } else {\n-            fcx.tcx.sess.add_lint(lint::builtin::TRIVIAL_CASTS,\n-                                  self.expr.id,\n-                                  self.span,\n-                                  format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n-                                           replaced by coercion, this might require type \\\n-                                           ascription or a temporary variable\",\n-                                          fcx.ty_to_string(t_expr),\n-                                          fcx.ty_to_string(t_cast)));\n+            fcx.tables.borrow_mut().lints.add_lint(\n+                lint::builtin::TRIVIAL_CASTS,\n+                self.expr.id,\n+                self.span,\n+                format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n+                         replaced by coercion, this might require type \\\n+                         ascription or a temporary variable\",\n+                        fcx.ty_to_string(t_expr),\n+                        fcx.ty_to_string(t_cast)));\n         }\n \n     }"}, {"sha": "eae8989bd342eec23106eb22252eb96f0cf0030f", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -137,7 +137,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                        self_ty, call_expr.id)?;\n \n         if let Some(import_id) = pick.import_id {\n-            self.tcx.used_trait_imports.borrow_mut().insert(import_id);\n+            let import_def_id = self.tcx.hir.local_def_id(import_id);\n+            debug!(\"used_trait_import: {:?}\", import_def_id);\n+            self.used_trait_imports.borrow_mut().insert(import_def_id);\n         }\n \n         self.tcx.check_stability(pick.item.def_id, call_expr.id, span);\n@@ -336,7 +338,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                        self_ty, expr_id)?;\n \n         if let Some(import_id) = pick.import_id {\n-            self.tcx.used_trait_imports.borrow_mut().insert(import_id);\n+            let import_def_id = self.tcx.hir.local_def_id(import_id);\n+            debug!(\"used_trait_import: {:?}\", import_def_id);\n+            self.used_trait_imports.borrow_mut().insert(import_def_id);\n         }\n \n         let def = pick.item.def();"}, {"sha": "201a223c15f157ccf6fbd1fe5d803605c948f17d", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -55,7 +55,6 @@ struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     inherent_candidates: Vec<Candidate<'tcx>>,\n     extension_candidates: Vec<Candidate<'tcx>>,\n     impl_dups: FxHashSet<DefId>,\n-    import_id: Option<ast::NodeId>,\n \n     /// Collects near misses when the candidate functions are missing a `self` keyword and is only\n     /// used for error reporting\n@@ -351,7 +350,6 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             inherent_candidates: Vec::new(),\n             extension_candidates: Vec::new(),\n             impl_dups: FxHashSet(),\n-            import_id: None,\n             steps: Rc::new(steps),\n             opt_simplified_steps: opt_simplified_steps,\n             static_candidates: Vec::new(),\n@@ -530,7 +528,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 xform_self_ty: xform_self_ty,\n                 item: item,\n                 kind: InherentImplCandidate(impl_substs, obligations),\n-                import_id: self.import_id,\n+                import_id: None,\n             });\n         }\n     }\n@@ -559,7 +557,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 xform_self_ty: xform_self_ty,\n                 item: item,\n                 kind: ObjectCandidate,\n-                import_id: this.import_id,\n+                import_id: None,\n             });\n         });\n     }\n@@ -609,7 +607,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 xform_self_ty: xform_self_ty,\n                 item: item,\n                 kind: WhereClauseCandidate(poly_trait_ref),\n-                import_id: this.import_id,\n+                import_id: None,\n             });\n         });\n     }\n@@ -644,9 +642,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             for trait_candidate in applicable_traits {\n                 let trait_did = trait_candidate.def_id;\n                 if duplicates.insert(trait_did) {\n-                    self.import_id = trait_candidate.import_id;\n-                    let result = self.assemble_extension_candidates_for_trait(trait_did);\n-                    self.import_id = None;\n+                    let import_id = trait_candidate.import_id;\n+                    let result = self.assemble_extension_candidates_for_trait(import_id, trait_did);\n                     result?;\n                 }\n             }\n@@ -658,7 +655,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         let mut duplicates = FxHashSet();\n         for trait_info in suggest::all_traits(self.ccx) {\n             if duplicates.insert(trait_info.def_id) {\n-                self.assemble_extension_candidates_for_trait(trait_info.def_id)?;\n+                self.assemble_extension_candidates_for_trait(None, trait_info.def_id)?;\n             }\n         }\n         Ok(())\n@@ -682,6 +679,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn assemble_extension_candidates_for_trait(&mut self,\n+                                               import_id: Option<ast::NodeId>,\n                                                trait_def_id: DefId)\n                                                -> Result<(), MethodError<'tcx>> {\n         debug!(\"assemble_extension_candidates_for_trait(trait_def_id={:?})\",\n@@ -695,19 +693,21 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 continue;\n             }\n \n-            self.assemble_extension_candidates_for_trait_impls(trait_def_id, item.clone());\n+            self.assemble_extension_candidates_for_trait_impls(import_id, trait_def_id,\n+                                                               item.clone());\n \n-            self.assemble_closure_candidates(trait_def_id, item.clone())?;\n+            self.assemble_closure_candidates(import_id, trait_def_id, item.clone())?;\n \n-            self.assemble_projection_candidates(trait_def_id, item.clone());\n+            self.assemble_projection_candidates(import_id, trait_def_id, item.clone());\n \n-            self.assemble_where_clause_candidates(trait_def_id, item.clone());\n+            self.assemble_where_clause_candidates(import_id, trait_def_id, item.clone());\n         }\n \n         Ok(())\n     }\n \n     fn assemble_extension_candidates_for_trait_impls(&mut self,\n+                                                     import_id: Option<ast::NodeId>,\n                                                      trait_def_id: DefId,\n                                                      item: ty::AssociatedItem) {\n         let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n@@ -751,7 +751,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 xform_self_ty: xform_self_ty,\n                 item: item.clone(),\n                 kind: ExtensionImplCandidate(impl_def_id, impl_substs, obligations),\n-                import_id: self.import_id,\n+                import_id: import_id,\n             });\n         });\n     }\n@@ -777,6 +777,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn assemble_closure_candidates(&mut self,\n+                                   import_id: Option<ast::NodeId>,\n                                    trait_def_id: DefId,\n                                    item: ty::AssociatedItem)\n                                    -> Result<(), MethodError<'tcx>> {\n@@ -840,14 +841,15 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 xform_self_ty: xform_self_ty,\n                 item: item.clone(),\n                 kind: TraitCandidate,\n-                import_id: self.import_id,\n+                import_id: import_id,\n             });\n         }\n \n         Ok(())\n     }\n \n     fn assemble_projection_candidates(&mut self,\n+                                      import_id: Option<ast::NodeId>,\n                                       trait_def_id: DefId,\n                                       item: ty::AssociatedItem) {\n         debug!(\"assemble_projection_candidates(\\\n@@ -895,14 +897,15 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                         xform_self_ty: xform_self_ty,\n                         item: item.clone(),\n                         kind: TraitCandidate,\n-                        import_id: self.import_id,\n+                        import_id: import_id,\n                     });\n                 }\n             }\n         }\n     }\n \n     fn assemble_where_clause_candidates(&mut self,\n+                                        import_id: Option<ast::NodeId>,\n                                         trait_def_id: DefId,\n                                         item: ty::AssociatedItem) {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={:?})\",\n@@ -923,7 +926,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 xform_self_ty: xform_self_ty,\n                 item: item.clone(),\n                 kind: WhereClauseCandidate(poly_bound),\n-                import_id: self.import_id,\n+                import_id: import_id,\n             });\n         }\n     }"}, {"sha": "1d9913cd96dc310383f1a348745eba0f3945687c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -102,7 +102,7 @@ use CrateCtxt;\n use TypeAndSubsts;\n use lint;\n use util::common::{ErrorReported, indenter};\n-use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap};\n+use util::nodemap::{DefIdMap, DefIdSet, FxHashMap, FxHashSet, NodeMap};\n \n use std::cell::{Cell, RefCell};\n use std::cmp;\n@@ -179,6 +179,11 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // Obligations which will have to be checked at the end of\n     // type-checking, after all functions have been inferred.\n     deferred_obligations: RefCell<Vec<traits::DeferredObligation<'tcx>>>,\n+\n+    // a set of trait import def-ids that we use during method\n+    // resolution; during writeback, this is written into\n+    // `tcx.used_trait_imports` for this item def-id\n+    used_trait_imports: RefCell<FxHashSet<DefId>>,\n }\n \n impl<'a, 'gcx, 'tcx> Deref for Inherited<'a, 'gcx, 'tcx> {\n@@ -513,6 +518,7 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n             deferred_cast_checks: RefCell::new(Vec::new()),\n             anon_types: RefCell::new(DefIdMap()),\n             deferred_obligations: RefCell::new(Vec::new()),\n+            used_trait_imports: RefCell::new(DefIdSet()),\n         }\n     }\n \n@@ -1521,9 +1527,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if self.diverges.get() == Diverges::Always {\n             self.diverges.set(Diverges::WarnedAlways);\n \n-            self.tcx.sess.add_lint(lint::builtin::UNREACHABLE_CODE,\n-                                   id, span,\n-                                   format!(\"unreachable {}\", kind));\n+            self.tables.borrow_mut().lints.add_lint(\n+                lint::builtin::UNREACHABLE_CODE,\n+                id, span,\n+                format!(\"unreachable {}\", kind));\n         }\n     }\n "}, {"sha": "9df0542f51fa109240d4ba1141e50f0c148faeb1", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -19,9 +19,10 @@ use rustc::ty::{self, Ty, TyCtxt, MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::fold::{TypeFolder,TypeFoldable};\n use rustc::infer::{InferCtxt, FixupError};\n-use rustc::util::nodemap::DefIdMap;\n+use rustc::util::nodemap::{DefIdMap, DefIdSet};\n \n use std::cell::Cell;\n+use std::mem;\n \n use syntax::ast;\n use syntax_pos::Span;\n@@ -52,9 +53,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_deferred_obligations(item_id);\n         wbcx.visit_type_nodes();\n         wbcx.visit_cast_types();\n+        wbcx.visit_lints();\n \n         let tables = self.tcx.alloc_tables(wbcx.tables);\n         self.tcx.tables.borrow_mut().insert(item_def_id, tables);\n+\n+        let used_trait_imports = mem::replace(&mut *self.used_trait_imports.borrow_mut(),\n+                                              DefIdSet());\n+        debug!(\"used_trait_imports({:?}) = {:?}\", item_def_id, used_trait_imports);\n+        self.tcx.used_trait_imports.borrow_mut().insert(item_def_id, used_trait_imports);\n     }\n }\n \n@@ -301,6 +308,14 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             self.fcx.tables.borrow().cast_kinds.iter().map(|(&key, &value)| (key, value)));\n     }\n \n+    fn visit_lints(&mut self) {\n+        if self.fcx.writeback_errors.get() {\n+            return\n+        }\n+\n+        self.fcx.tables.borrow_mut().lints.transfer(&mut self.tables.lints);\n+    }\n+\n     fn visit_anon_types(&self) {\n         if self.fcx.writeback_errors.get() {\n             return"}, {"sha": "6dff6d57e4facc1d576c06f0dcf89dcf6131f029", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -17,17 +17,21 @@ use syntax_pos::{Span, DUMMY_SP};\n \n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::util::nodemap::DefIdSet;\n \n-struct UnusedTraitImportVisitor<'a, 'tcx: 'a> {\n+struct CheckVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    used_trait_imports: DefIdSet,\n }\n \n-impl<'a, 'tcx> UnusedTraitImportVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> CheckVisitor<'a, 'tcx> {\n     fn check_import(&self, id: ast::NodeId, span: Span) {\n         if !self.tcx.maybe_unused_trait_imports.contains(&id) {\n             return;\n         }\n-        if self.tcx.used_trait_imports.borrow().contains(&id) {\n+\n+        let import_def_id = self.tcx.hir.local_def_id(id);\n+        if self.used_trait_imports.contains(&import_def_id) {\n             return;\n         }\n \n@@ -40,7 +44,7 @@ impl<'a, 'tcx> UnusedTraitImportVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for UnusedTraitImportVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CheckVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if item.vis == hir::Public || item.span == DUMMY_SP {\n             return;\n@@ -59,6 +63,21 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for UnusedTraitImportVisitor<'a, 'tcx> {\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _task = tcx.dep_graph.in_task(DepNode::UnusedTraitCheck);\n-    let mut visitor = UnusedTraitImportVisitor { tcx: tcx };\n+\n+    let mut used_trait_imports = DefIdSet();\n+    for &body_id in tcx.hir.krate().bodies.keys() {\n+        let item_id = tcx.hir.body_owner(body_id);\n+        let item_def_id = tcx.hir.local_def_id(item_id);\n+\n+        // this will have been written by the main typeck pass\n+        if let Some(imports) = tcx.used_trait_imports.borrow().get(&item_def_id) {\n+            debug!(\"GatherVisitor: item_def_id={:?} with imports {:#?}\", item_def_id, imports);\n+            used_trait_imports.extend(imports);\n+        } else {\n+            debug!(\"GatherVisitor: item_def_id={:?} with no imports\", item_def_id);\n+        }\n+    }\n+\n+    let mut visitor = CheckVisitor { tcx, used_trait_imports };\n     tcx.hir.krate().visit_all_item_likes(&mut visitor);\n }"}, {"sha": "b6a863fd2ed0d533626972afbf1c6a219659a63d", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -15,8 +15,9 @@\n // done by the orphan and overlap modules. Then we build up various\n // mappings. That mapping code resides here.\n \n+use dep_graph::DepTrackingMap;\n use hir::def_id::DefId;\n-use rustc::ty::{self, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, maps, TyCtxt, TypeFoldable};\n use rustc::ty::{Ty, TyBool, TyChar, TyError};\n use rustc::ty::{TyParam, TyRawPtr};\n use rustc::ty::{TyRef, TyAdt, TyDynamic, TyNever, TyTuple};\n@@ -29,17 +30,19 @@ use rustc::dep_graph::DepNode;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::{Item, ItemImpl};\n use rustc::hir;\n+use std::cell::RefMut;\n \n mod builtin;\n mod orphan;\n mod overlap;\n mod unsafety;\n \n-struct CoherenceChecker<'a, 'tcx: 'a> {\n+struct CoherenceCollect<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    inherent_impls: RefMut<'a, DepTrackingMap<maps::InherentImpls<'tcx>>>,\n }\n \n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceChecker<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceCollect<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n         if let ItemImpl(..) = item.node {\n             self.check_implementation(item)\n@@ -53,7 +56,17 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceChecker<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n+impl<'a, 'tcx> CoherenceCollect<'a, 'tcx> {\n+    fn check(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+        let inherent_impls = tcx.inherent_impls.borrow_mut();\n+        let mut this = &mut CoherenceCollect { tcx, inherent_impls };\n+\n+        // Check implementations and traits. This populates the tables\n+        // containing the inherent methods and extension methods. It also\n+        // builds up the trait inheritance table.\n+        tcx.visit_all_item_likes_in_krate(DepNode::CoherenceCheckImpl, this);\n+    }\n+\n     // Returns the def ID of the base type, if there is one.\n     fn get_base_type_def_id(&self, span: Span, ty: Ty<'tcx>) -> Option<DefId> {\n         match ty.sty {\n@@ -75,14 +88,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         }\n     }\n \n-    fn check(&mut self) {\n-        // Check implementations and traits. This populates the tables\n-        // containing the inherent methods and extension methods. It also\n-        // builds up the trait inheritance table.\n-        self.tcx.visit_all_item_likes_in_krate(DepNode::CoherenceCheckImpl, self);\n-    }\n-\n-    fn check_implementation(&self, item: &Item) {\n+    fn check_implementation(&mut self, item: &Item) {\n         let tcx = self.tcx;\n         let impl_did = tcx.hir.local_def_id(item.id);\n         let self_type = tcx.item_type(impl_did);\n@@ -119,8 +125,19 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         }\n     }\n \n-    fn add_inherent_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n-        self.tcx.inherent_impls.borrow_mut().push(base_def_id, impl_def_id);\n+    fn add_inherent_impl(&mut self, base_def_id: DefId, impl_def_id: DefId) {\n+        // Subtle: it'd be better to collect these into a local map\n+        // and then write the vector only once all items are known,\n+        // but that leads to degenerate dep-graphs. The problem is\n+        // that the write of that big vector winds up having reads\n+        // from *all* impls in the krate, since we've lost the\n+        // precision basically.  This would be ok in the firewall\n+        // model so once we've made progess towards that we can modify\n+        // the strategy here. In the meantime, using `push` is ok\n+        // because we are doing this as a pre-pass before anyone\n+        // actually reads from `inherent_impls` -- and we know this is\n+        // true beacuse we hold the refcell lock.\n+        self.inherent_impls.push(base_def_id, impl_def_id);\n     }\n \n     fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'tcx>, impl_def_id: DefId) {\n@@ -160,8 +177,9 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: Def\n }\n \n pub fn check_coherence(ccx: &CrateCtxt) {\n+    CoherenceCollect::check(ccx.tcx);\n+\n     let _task = ccx.tcx.dep_graph.in_task(DepNode::Coherence);\n-    CoherenceChecker { tcx: ccx.tcx }.check();\n     unsafety::check(ccx.tcx);\n     orphan::check(ccx.tcx);\n     overlap::check(ccx.tcx);"}, {"sha": "266975994ec3ae01d9061cd2291d71e76b431ff8", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -634,7 +634,7 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     ccx.tcx.item_types.borrow_mut().insert(ty_f.did, tt);\n \n     let def_id = ccx.tcx.hir.local_def_id(field.id);\n-    ccx.tcx.item_types.borrow_mut().insert(def_id, tt);\n+    assert_eq!(def_id, ty_f.did);\n     ccx.tcx.generics.borrow_mut().insert(def_id, struct_generics);\n     ccx.tcx.predicates.borrow_mut().insert(def_id, struct_predicates.clone());\n }\n@@ -848,9 +848,10 @@ fn convert_trait_item(ccx: &CrateCtxt, trait_item: &hir::TraitItem) {\n             let const_def_id = ccx.tcx.hir.local_def_id(trait_item.id);\n             generics_of_def_id(ccx, const_def_id);\n             let ty = ccx.icx(&trait_predicates).to_ty(&ty);\n-            tcx.item_types.borrow_mut().insert(const_def_id, ty);\n-            convert_associated_const(ccx, TraitContainer(trait_def_id),\n-                                     trait_item.id, ty);\n+            convert_associated_const(ccx,\n+                                     TraitContainer(trait_def_id),\n+                                     trait_item.id,\n+                                     ty);\n         }\n \n         hir::TraitItemKind::Type(_, ref opt_ty) => {\n@@ -884,9 +885,10 @@ fn convert_impl_item(ccx: &CrateCtxt, impl_item: &hir::ImplItem) {\n             let const_def_id = ccx.tcx.hir.local_def_id(impl_item.id);\n             generics_of_def_id(ccx, const_def_id);\n             let ty = ccx.icx(&impl_predicates).to_ty(&ty);\n-            tcx.item_types.borrow_mut().insert(const_def_id, ty);\n-            convert_associated_const(ccx, ImplContainer(impl_def_id),\n-                                     impl_item.id, ty);\n+            convert_associated_const(ccx,\n+                                     ImplContainer(impl_def_id),\n+                                     impl_item.id,\n+                                     ty);\n         }\n \n         hir::ImplItemKind::Type(ref ty) => {\n@@ -1283,9 +1285,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n                                                            items);\n     trait_predicates.predicates.extend(assoc_predicates);\n \n-    let prev_predicates = tcx.predicates.borrow_mut().insert(def_id, trait_predicates);\n-    assert!(prev_predicates.is_none());\n-\n+    tcx.predicates.borrow_mut().insert(def_id, trait_predicates);\n     return;\n \n     fn predicates_for_associated_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -1592,9 +1592,7 @@ fn predicates_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     };\n \n     let predicates = ty_generic_predicates(ccx, generics, None, vec![], false);\n-    let prev_predicates = ccx.tcx.predicates.borrow_mut().insert(def_id,\n-                                                                 predicates.clone());\n-    assert!(prev_predicates.is_none());\n+    ccx.tcx.predicates.borrow_mut().insert(def_id, predicates.clone());\n \n     predicates\n }\n@@ -1617,8 +1615,7 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     };\n \n     let predicates = ty_generic_predicates(ccx, generics, None, vec![], false);\n-    let prev_predicates = ccx.tcx.predicates.borrow_mut().insert(def_id, predicates);\n-    assert!(prev_predicates.is_none());\n+    ccx.tcx.predicates.borrow_mut().insert(def_id, predicates);\n }\n \n // Is it marked with ?Sized"}, {"sha": "f19a59a5d38aeb56e33733149ee59ce6c1347447", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -77,6 +77,7 @@ This API is completely unstable and subject to change.\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(conservative_impl_trait)]\n+#![feature(field_init_shorthand)]\n #![feature(loop_break_value)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "3ccec97d606ea3afa60a968ad831825c6a8edca6", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -137,11 +137,9 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                           item_variances);\n             }\n \n-            let newly_added = tcx.item_variance_map\n-                .borrow_mut()\n-                .insert(item_def_id, Rc::new(item_variances))\n-                .is_none();\n-            assert!(newly_added);\n+            tcx.item_variance_map\n+               .borrow_mut()\n+               .insert(item_def_id, Rc::new(item_variances));\n         }\n     }\n "}, {"sha": "253d7a25b632f2fea0afd6a2e24b071b99b6cac8", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -178,12 +178,10 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         // parameters\".\n         if self.num_inferred() == inferreds_on_entry {\n             let item_def_id = self.tcx.hir.local_def_id(item_id);\n-            let newly_added = self.tcx\n+            self.tcx\n                 .item_variance_map\n                 .borrow_mut()\n-                .insert(item_def_id, self.empty_variances.clone())\n-                .is_none();\n-            assert!(newly_added);\n+                .insert(item_def_id, self.empty_variances.clone());\n         }\n     }\n "}, {"sha": "3808923e7728f9813d4cb33a5e1d6dd0341dc602", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4eea733065ec39ba6031d856ace002c70035c44/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=e4eea733065ec39ba6031d856ace002c70035c44", "patch": "@@ -66,7 +66,7 @@ pub struct Span {\n ///   the error, and would be rendered with `^^^`.\n /// - they can have a *label*. In this case, the label is written next\n ///   to the mark in the snippet when we render.\n-#[derive(Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Clone, Debug, Hash, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub struct MultiSpan {\n     primary_spans: Vec<Span>,\n     span_labels: Vec<(Span, String)>,"}]}