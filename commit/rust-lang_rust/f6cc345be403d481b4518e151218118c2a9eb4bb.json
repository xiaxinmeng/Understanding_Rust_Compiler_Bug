{"sha": "f6cc345be403d481b4518e151218118c2a9eb4bb", "node_id": "C_kwDOAAsO6NoAKGY2Y2MzNDViZTQwM2Q0ODFiNDUxOGUxNTEyMTgxMThjMmE5ZWI0YmI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-30T09:47:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-30T09:47:19Z"}, "message": "Auto merge of #106264 - Swatinem:higher-lifetime-regression, r=petrochenkov\n\nAdd regression test for #105501\n\nThe test was minified from the published crate `msf-ice:0.2.1` which failed in a crater run.\n\nA faulty compiler was triggering a `higher-ranked lifetime error`:\n> could not prove `[async block@...]: Send`\n\nThe testcase has some complexity, as it has a simplified subset of `futures::StreamExt` in it, but the error is only being triggered by a few layers of nesting. For example removing the noop `then` call would have been enough to make the error go away.", "tree": {"sha": "c8549543c631ef097418fb1fea15564f4a34b194", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8549543c631ef097418fb1fea15564f4a34b194"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6cc345be403d481b4518e151218118c2a9eb4bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6cc345be403d481b4518e151218118c2a9eb4bb", "html_url": "https://github.com/rust-lang/rust/commit/f6cc345be403d481b4518e151218118c2a9eb4bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6cc345be403d481b4518e151218118c2a9eb4bb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5e5fcb0b758fcf7f149cc9206155dcfa18ec909", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5e5fcb0b758fcf7f149cc9206155dcfa18ec909", "html_url": "https://github.com/rust-lang/rust/commit/e5e5fcb0b758fcf7f149cc9206155dcfa18ec909"}, {"sha": "42e7df998ce16487a54492f24deae272121e9e2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/42e7df998ce16487a54492f24deae272121e9e2e", "html_url": "https://github.com/rust-lang/rust/commit/42e7df998ce16487a54492f24deae272121e9e2e"}], "stats": {"total": 165, "additions": 165, "deletions": 0}, "files": [{"sha": "f30d2a9d81a6affd7e0d637ed4e82c15252be1d2", "filename": "src/test/ui/async-await/issue-105501.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/f6cc345be403d481b4518e151218118c2a9eb4bb/src%2Ftest%2Fui%2Fasync-await%2Fissue-105501.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6cc345be403d481b4518e151218118c2a9eb4bb/src%2Ftest%2Fui%2Fasync-await%2Fissue-105501.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-105501.rs?ref=f6cc345be403d481b4518e151218118c2a9eb4bb", "patch": "@@ -0,0 +1,165 @@\n+// check-pass\n+// edition:2018\n+\n+// This is a regression test for https://github.com/rust-lang/rust/issues/105501.\n+// It was minified from the published `msf-ice:0.2.1` crate which failed in a crater run.\n+// A faulty compiler was triggering a `higher-ranked lifetime error`:\n+//\n+// > could not prove `[async block@...]: Send`\n+\n+use mini_futures::Stream;\n+\n+fn is_send(_: impl Send) {}\n+\n+pub fn main() {\n+    let fut = async {\n+        let mut stream = mini_futures::iter([()])\n+            .then(|_| async {})\n+            .map(|_| async { None })\n+            .buffered()\n+            .filter_map(std::future::ready);\n+\n+        stream.next().await\n+    };\n+\n+    is_send(async move {\n+        let _: Option<()> = fut.await;\n+    });\n+}\n+\n+// this is a simplified subset of `futures::StreamExt` and related types\n+mod mini_futures {\n+    use std::future::Future;\n+    use std::pin::Pin;\n+    use std::task::{Context, Poll};\n+\n+    pub fn iter<I>(_: I) -> Iter<I::IntoIter>\n+    where\n+        I: IntoIterator,\n+    {\n+        todo!()\n+    }\n+\n+    pub trait Stream {\n+        type Item;\n+\n+        fn then<Fut, F>(self, _: F) -> Then<Self, Fut, F>\n+        where\n+            F: FnMut(Self::Item) -> Fut,\n+            Fut: Future,\n+            Self: Sized,\n+        {\n+            todo!()\n+        }\n+\n+        fn map<T, F>(self, _: F) -> Map<Self, F>\n+        where\n+            F: FnMut(Self::Item) -> T,\n+            Self: Sized,\n+        {\n+            todo!()\n+        }\n+\n+        fn buffered(self) -> Buffered<Self>\n+        where\n+            Self::Item: Future,\n+            Self: Sized,\n+        {\n+            todo!()\n+        }\n+\n+        fn filter_map<Fut, T, F>(self, _: F) -> FilterMap<Self, Fut, F>\n+        where\n+            F: FnMut(Self::Item) -> Fut,\n+            Fut: Future<Output = Option<T>>,\n+            Self: Sized,\n+        {\n+            todo!()\n+        }\n+\n+        fn next(&mut self) -> Next<'_, Self> {\n+            todo!()\n+        }\n+    }\n+\n+    pub struct Iter<I> {\n+        __: I,\n+    }\n+    impl<I> Stream for Iter<I>\n+    where\n+        I: Iterator,\n+    {\n+        type Item = I::Item;\n+    }\n+\n+    pub struct Then<St, Fut, F> {\n+        __: (St, Fut, F),\n+    }\n+    impl<St, Fut, F> Stream for Then<St, Fut, F>\n+    where\n+        St: Stream,\n+        F: FnMut(St::Item) -> Fut,\n+        Fut: Future,\n+    {\n+        type Item = Fut::Output;\n+    }\n+\n+    pub struct Map<St, F> {\n+        __: (St, F),\n+    }\n+    impl<St, F> Stream for Map<St, F>\n+    where\n+        St: Stream,\n+        F: FnMut1<St::Item>,\n+    {\n+        type Item = F::Output;\n+    }\n+\n+    pub trait FnMut1<A> {\n+        type Output;\n+    }\n+    impl<T, A, R> FnMut1<A> for T\n+    where\n+        T: FnMut(A) -> R,\n+    {\n+        type Output = R;\n+    }\n+\n+    pub struct Buffered<St>\n+    where\n+        St: Stream,\n+        St::Item: Future,\n+    {\n+        __: (St, St::Item),\n+    }\n+    impl<St> Stream for Buffered<St>\n+    where\n+        St: Stream,\n+        St::Item: Future,\n+    {\n+        type Item = <St::Item as Future>::Output;\n+    }\n+\n+    pub struct FilterMap<St, Fut, F> {\n+        __: (St, Fut, F),\n+    }\n+    impl<St, Fut, F, T> Stream for FilterMap<St, Fut, F>\n+    where\n+        St: Stream,\n+        F: FnMut1<St::Item, Output = Fut>,\n+        Fut: Future<Output = Option<T>>,\n+    {\n+        type Item = T;\n+    }\n+\n+    pub struct Next<'a, St: ?Sized> {\n+        __: &'a mut St,\n+    }\n+    impl<St: ?Sized + Stream> Future for Next<'_, St> {\n+        type Output = Option<St::Item>;\n+\n+        fn poll(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Self::Output> {\n+            todo!()\n+        }\n+    }\n+}"}]}