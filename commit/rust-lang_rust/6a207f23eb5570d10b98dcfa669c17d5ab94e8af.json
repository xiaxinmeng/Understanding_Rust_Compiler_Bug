{"sha": "6a207f23eb5570d10b98dcfa669c17d5ab94e8af", "node_id": "C_kwDOAAsO6NoAKDZhMjA3ZjIzZWI1NTcwZDEwYjk4ZGNmYTY2OWMxN2Q1YWI5NGU4YWY", "commit": {"author": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2021-10-26T22:24:23Z"}, "committer": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2021-11-15T02:14:54Z"}, "message": "Try all stable candidates first before trying unstable ones", "tree": {"sha": "350b99df3c32e0cc5c187cc268d1892c975b9fb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/350b99df3c32e0cc5c187cc268d1892c975b9fb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a207f23eb5570d10b98dcfa669c17d5ab94e8af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a207f23eb5570d10b98dcfa669c17d5ab94e8af", "html_url": "https://github.com/rust-lang/rust/commit/6a207f23eb5570d10b98dcfa669c17d5ab94e8af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a207f23eb5570d10b98dcfa669c17d5ab94e8af/comments", "author": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9740050726d8184b614b3150c7efbb63ea2288d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9740050726d8184b614b3150c7efbb63ea2288d9", "html_url": "https://github.com/rust-lang/rust/commit/9740050726d8184b614b3150c7efbb63ea2288d9"}], "stats": {"total": 124, "additions": 105, "deletions": 19}, "files": [{"sha": "015e7acb60ae0ad99d5d1c9639e2b9f8bb082513", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a207f23eb5570d10b98dcfa669c17d5ab94e8af/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a207f23eb5570d10b98dcfa669c17d5ab94e8af/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=6a207f23eb5570d10b98dcfa669c17d5ab94e8af", "patch": "@@ -751,6 +751,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(panic_abort_tests, true);\n     tracked!(panic_in_drop, PanicStrategy::Abort);\n     tracked!(partially_uninit_const_threshold, Some(123));\n+    tracked!(pick_stable_methods_before_any_unstable, false);\n     tracked!(plt, Some(true));\n     tracked!(polonius, true);\n     tracked!(precise_enum_drop_elaboration, false);"}, {"sha": "95ff5011180e4363cb9d6a6099125d069a2b79f2", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a207f23eb5570d10b98dcfa669c17d5ab94e8af/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a207f23eb5570d10b98dcfa669c17d5ab94e8af/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=6a207f23eb5570d10b98dcfa669c17d5ab94e8af", "patch": "@@ -1233,6 +1233,8 @@ options! {\n         and set the maximum total size of a const allocation for which this is allowed (default: never)\"),\n     perf_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"print some performance-related statistics (default: no)\"),\n+    pick_stable_methods_before_any_unstable: bool = (true, parse_bool, [TRACKED],\n+        \"try to pick stable methods first before picking any unstable methods (default: yes)\"),\n     plt: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"whether to use the PLT when calling into shared libraries;\n         only has effect for PIC code on systems with ELF binaries"}, {"sha": "95fe6c9b93c406890407e038cc71cba393a080fa", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 102, "deletions": 19, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/6a207f23eb5570d10b98dcfa669c17d5ab94e8af/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a207f23eb5570d10b98dcfa669c17d5ab94e8af/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=6a207f23eb5570d10b98dcfa669c17d5ab94e8af", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'tcx> Deref for ProbeContext<'a, 'tcx> {\n     }\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n struct Candidate<'tcx> {\n     // Candidates are (I'm not quite sure, but they are mostly) basically\n     // some metadata on top of a `ty::AssocItem` (without substs).\n@@ -132,7 +132,7 @@ struct Candidate<'tcx> {\n     import_ids: SmallVec<[LocalDefId; 1]>,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n enum CandidateKind<'tcx> {\n     InherentImplCandidate(\n         SubstsRef<'tcx>,\n@@ -1102,13 +1102,37 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     }\n \n     fn pick_core(&mut self) -> Option<PickResult<'tcx>> {\n-        let steps = self.steps.clone();\n+        let mut unstable_candidates = Vec::new();\n+        let pick = self.pick_all_method(Some(&mut unstable_candidates));\n+\n+        // In this case unstable picking is done by `pick_method`.\n+        if !self.tcx.sess.opts.debugging_opts.pick_stable_methods_before_any_unstable {\n+            return pick;\n+        }\n \n-        // find the first step that works\n+        match pick {\n+            // Emit a lint if there are unstable candidates alongside the stable ones.\n+            //\n+            // We suppress warning if we're picking the method only because it is a\n+            // suggestion.\n+            Some(Ok(ref p)) if !self.is_suggestion.0 && !unstable_candidates.is_empty() => {\n+                self.emit_unstable_name_collision_hint(p, &unstable_candidates);\n+                pick\n+            }\n+            Some(_) => pick,\n+            None => self.pick_all_method(None),\n+        }\n+    }\n+\n+    fn pick_all_method(\n+        &mut self,\n+        mut unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n+    ) -> Option<PickResult<'tcx>> {\n+        let steps = self.steps.clone();\n         steps\n             .iter()\n             .filter(|step| {\n-                debug!(\"pick_core: step={:?}\", step);\n+                debug!(\"pick_all_method: step={:?}\", step);\n                 // skip types that are from a type error or that would require dereferencing\n                 // a raw pointer\n                 !step.self_ty.references_error() && !step.from_unsafe_deref\n@@ -1124,11 +1148,30 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     .unwrap_or_else(|_| {\n                         span_bug!(self.span, \"{:?} was applicable but now isn't?\", step.self_ty)\n                     });\n-                self.pick_by_value_method(step, self_ty).or_else(|| {\n-                    self.pick_autorefd_method(step, self_ty, hir::Mutability::Not)\n-                        .or_else(|| self.pick_autorefd_method(step, self_ty, hir::Mutability::Mut))\n-                        .or_else(|| self.pick_const_ptr_method(step, self_ty))\n-                })\n+                self.pick_by_value_method(step, self_ty, unstable_candidates.as_deref_mut())\n+                    .or_else(|| {\n+                        self.pick_autorefd_method(\n+                            step,\n+                            self_ty,\n+                            hir::Mutability::Not,\n+                            unstable_candidates.as_deref_mut(),\n+                        )\n+                        .or_else(|| {\n+                            self.pick_autorefd_method(\n+                                step,\n+                                self_ty,\n+                                hir::Mutability::Mut,\n+                                unstable_candidates.as_deref_mut(),\n+                            )\n+                        })\n+                        .or_else(|| {\n+                            self.pick_const_ptr_method(\n+                                step,\n+                                self_ty,\n+                                unstable_candidates.as_deref_mut(),\n+                            )\n+                        })\n+                    })\n             })\n             .next()\n     }\n@@ -1143,12 +1186,13 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         &mut self,\n         step: &CandidateStep<'tcx>,\n         self_ty: Ty<'tcx>,\n+        unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n     ) -> Option<PickResult<'tcx>> {\n         if step.unsize {\n             return None;\n         }\n \n-        self.pick_method(self_ty).map(|r| {\n+        self.pick_method(self_ty, unstable_candidates).map(|r| {\n             r.map(|mut pick| {\n                 pick.autoderefs = step.autoderefs;\n \n@@ -1171,14 +1215,15 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         step: &CandidateStep<'tcx>,\n         self_ty: Ty<'tcx>,\n         mutbl: hir::Mutability,\n+        unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n     ) -> Option<PickResult<'tcx>> {\n         let tcx = self.tcx;\n \n         // In general, during probing we erase regions.\n         let region = tcx.lifetimes.re_erased;\n \n         let autoref_ty = tcx.mk_ref(region, ty::TypeAndMut { ty: self_ty, mutbl });\n-        self.pick_method(autoref_ty).map(|r| {\n+        self.pick_method(autoref_ty, unstable_candidates).map(|r| {\n             r.map(|mut pick| {\n                 pick.autoderefs = step.autoderefs;\n                 pick.autoref_or_ptr_adjustment = Some(AutorefOrPtrAdjustment::Autoref {\n@@ -1197,6 +1242,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         &mut self,\n         step: &CandidateStep<'tcx>,\n         self_ty: Ty<'tcx>,\n+        unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n     ) -> Option<PickResult<'tcx>> {\n         // Don't convert an unsized reference to ptr\n         if step.unsize {\n@@ -1210,7 +1256,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n         let const_self_ty = ty::TypeAndMut { ty, mutbl: hir::Mutability::Not };\n         let const_ptr_ty = self.tcx.mk_ptr(const_self_ty);\n-        self.pick_method(const_ptr_ty).map(|r| {\n+        self.pick_method(const_ptr_ty, unstable_candidates).map(|r| {\n             r.map(|mut pick| {\n                 pick.autoderefs = step.autoderefs;\n                 pick.autoref_or_ptr_adjustment = Some(AutorefOrPtrAdjustment::ToConstPtr);\n@@ -1219,8 +1265,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         })\n     }\n \n-    fn pick_method(&mut self, self_ty: Ty<'tcx>) -> Option<PickResult<'tcx>> {\n-        debug!(\"pick_method(self_ty={})\", self.ty_to_string(self_ty));\n+    fn pick_method_with_unstable(&mut self, self_ty: Ty<'tcx>) -> Option<PickResult<'tcx>> {\n+        debug!(\"pick_method_with_unstable(self_ty={})\", self.ty_to_string(self_ty));\n \n         let mut possibly_unsatisfied_predicates = Vec::new();\n         let mut unstable_candidates = Vec::new();\n@@ -1252,7 +1298,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         debug!(\"searching unstable candidates\");\n         let res = self.consider_candidates(\n             self_ty,\n-            unstable_candidates.into_iter().map(|(c, _)| c),\n+            unstable_candidates.iter().map(|(c, _)| c),\n             &mut possibly_unsatisfied_predicates,\n             None,\n         );\n@@ -1262,6 +1308,42 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         res\n     }\n \n+    fn pick_method(\n+        &mut self,\n+        self_ty: Ty<'tcx>,\n+        mut unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n+    ) -> Option<PickResult<'tcx>> {\n+        if !self.tcx.sess.opts.debugging_opts.pick_stable_methods_before_any_unstable {\n+            return self.pick_method_with_unstable(self_ty);\n+        }\n+\n+        debug!(\"pick_method(self_ty={})\", self.ty_to_string(self_ty));\n+\n+        let mut possibly_unsatisfied_predicates = Vec::new();\n+\n+        for (kind, candidates) in\n+            &[(\"inherent\", &self.inherent_candidates), (\"extension\", &self.extension_candidates)]\n+        {\n+            debug!(\"searching {} candidates\", kind);\n+            let res = self.consider_candidates(\n+                self_ty,\n+                candidates.iter(),\n+                &mut possibly_unsatisfied_predicates,\n+                unstable_candidates.as_deref_mut(),\n+            );\n+            if let Some(pick) = res {\n+                return Some(pick);\n+            }\n+        }\n+\n+        // `pick_method` may be called twice for the same self_ty if no stable methods\n+        // match. Only extend once.\n+        if unstable_candidates.is_some() {\n+            self.unsatisfied_predicates.extend(possibly_unsatisfied_predicates);\n+        }\n+        None\n+    }\n+\n     fn consider_candidates<'b, ProbesIter>(\n         &self,\n         self_ty: Ty<'tcx>,\n@@ -1270,10 +1352,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             ty::Predicate<'tcx>,\n             Option<ty::Predicate<'tcx>>,\n         )>,\n-        unstable_candidates: Option<&mut Vec<(&'b Candidate<'tcx>, Symbol)>>,\n+        unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n     ) -> Option<PickResult<'tcx>>\n     where\n         ProbesIter: Iterator<Item = &'b Candidate<'tcx>> + Clone,\n+        'tcx: 'b,\n     {\n         let mut applicable_candidates: Vec<_> = probes\n             .clone()\n@@ -1298,7 +1381,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 if let stability::EvalResult::Deny { feature, .. } =\n                     self.tcx.eval_stability(p.item.def_id, None, self.span, None)\n                 {\n-                    uc.push((p, feature));\n+                    uc.push((p.clone(), feature));\n                     return false;\n                 }\n                 true\n@@ -1322,7 +1405,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     fn emit_unstable_name_collision_hint(\n         &self,\n         stable_pick: &Pick<'_>,\n-        unstable_candidates: &[(&Candidate<'tcx>, Symbol)],\n+        unstable_candidates: &[(Candidate<'tcx>, Symbol)],\n     ) {\n         self.tcx.struct_span_lint_hir(\n             lint::builtin::UNSTABLE_NAME_COLLISIONS,"}]}