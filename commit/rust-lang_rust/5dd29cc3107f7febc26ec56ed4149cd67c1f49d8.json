{"sha": "5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkZDI5Y2MzMTA3ZjdmZWJjMjZlYzU2ZWQ0MTQ5Y2Q2N2MxZjQ5ZDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-18T20:44:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-18T20:44:33Z"}, "message": "Auto merge of #30389 - nikomatsakis:rfc1214-error, r=arielb1\n\nMake RFC 1214 warnings into errors, and rip out the \"warn or err\"\nassociated machinery. Future such attempts should go through lints\nanyhow.\n\nThere is a fair amount of fallout in the compile-fail tests, as WF\nchecking now occurs earlier in the process.\n\nr? @arielb1", "tree": {"sha": "0805b87696a6b3e3450518dfc6b8d5f94a308178", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0805b87696a6b3e3450518dfc6b8d5f94a308178"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "html_url": "https://github.com/rust-lang/rust/commit/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "html_url": "https://github.com/rust-lang/rust/commit/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3"}, {"sha": "dbf994bbaff214e6441a8e97df180db7b29e7189", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbf994bbaff214e6441a8e97df180db7b29e7189", "html_url": "https://github.com/rust-lang/rust/commit/dbf994bbaff214e6441a8e97df180db7b29e7189"}], "stats": {"total": 1478, "additions": 291, "deletions": 1187}, "files": [{"sha": "7bb66d6317abdc52b515d928827db543a4920480", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 25, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -577,11 +577,6 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         // where the error was detected. But that span is not readily\n         // accessible.\n \n-        let is_warning = match origin {\n-            infer::RFC1214Subregion(_) => true,\n-            _ => false,\n-        };\n-\n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) =>\n                 format!(\"the parameter type `{}`\", p),\n@@ -592,8 +587,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         match sub {\n             ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n                 // Does the required lifetime have a nice name we can print?\n-                span_err_or_warn!(\n-                    is_warning, self.tcx.sess, origin.span(), E0309,\n+                span_err!(\n+                    self.tcx.sess, origin.span(), E0309,\n                     \"{} may not live long enough\", labeled_user_string);\n                 self.tcx.sess.fileline_help(\n                     origin.span(),\n@@ -605,8 +600,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n             ty::ReStatic => {\n                 // Does the required lifetime have a nice name we can print?\n-                span_err_or_warn!(\n-                    is_warning, self.tcx.sess, origin.span(), E0310,\n+                span_err!(\n+                    self.tcx.sess, origin.span(), E0310,\n                     \"{} may not live long enough\", labeled_user_string);\n                 self.tcx.sess.fileline_help(\n                     origin.span(),\n@@ -617,8 +612,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n             _ => {\n                 // If not, be less specific.\n-                span_err_or_warn!(\n-                    is_warning, self.tcx.sess, origin.span(), E0311,\n+                span_err!(\n+                    self.tcx.sess, origin.span(), E0311,\n                     \"{} may not live long enough\",\n                     labeled_user_string);\n                 self.tcx.sess.fileline_help(\n@@ -633,10 +628,6 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         }\n \n-        if is_warning {\n-            self.tcx.sess.note_rfc_1214(origin.span());\n-        }\n-\n         self.note_region_origin(&origin);\n     }\n \n@@ -645,13 +636,6 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                sub: Region,\n                                sup: Region) {\n         match origin {\n-            infer::RFC1214Subregion(ref suborigin) => {\n-                // Ideally, this would be a warning, but it doesn't\n-                // seem to come up in practice, since the changes from\n-                // RFC1214 mostly trigger errors in type definitions\n-                // that don't wind up coming down this path.\n-                self.report_concrete_failure((**suborigin).clone(), sub, sup);\n-            }\n             infer::Subtype(trace) => {\n                 let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n                 self.report_and_explain_type_error(trace, &terr);\n@@ -1598,9 +1582,6 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn note_region_origin(&self, origin: &SubregionOrigin<'tcx>) {\n         match *origin {\n-            infer::RFC1214Subregion(ref suborigin) => {\n-                self.note_region_origin(suborigin);\n-            }\n             infer::Subtype(ref trace) => {\n                 let desc = match trace.origin {\n                     TypeOrigin::Misc(_) => {"}, {"sha": "d0ffed56635f7e3e183bd4de6a6359dc6bef0ca4", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -37,7 +37,6 @@ use middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{RefCell, Ref};\n use std::fmt;\n-use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::{Span, DUMMY_SP};\n@@ -198,11 +197,6 @@ pub struct TypeTrace<'tcx> {\n /// See `error_reporting.rs` for more details\n #[derive(Clone, Debug)]\n pub enum SubregionOrigin<'tcx> {\n-    // Marker to indicate a constraint that only arises due to new\n-    // provisions from RFC 1214. This will result in a warning, not an\n-    // error.\n-    RFC1214Subregion(Rc<SubregionOrigin<'tcx>>),\n-\n     // Arose from a subtyping relation\n     Subtype(TypeTrace<'tcx>),\n \n@@ -1568,7 +1562,6 @@ impl TypeOrigin {\n impl<'tcx> SubregionOrigin<'tcx> {\n     pub fn span(&self) -> Span {\n         match *self {\n-            RFC1214Subregion(ref a) => a.span(),\n             Subtype(ref a) => a.span(),\n             InfStackClosure(a) => a,\n             InvokeClosure(a) => a,"}, {"sha": "9cf8043be3ba1bf6c34bd7bf6dc89e7658bad50b", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 30, "deletions": 44, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -36,7 +36,6 @@ use syntax::attr::{AttributeMethods, AttrMetaMethods};\n \n #[derive(Debug, PartialEq, Eq, Hash)]\n pub struct TraitErrorKey<'tcx> {\n-    is_warning: bool,\n     span: Span,\n     predicate: ty::Predicate<'tcx>\n }\n@@ -47,7 +46,6 @@ impl<'tcx> TraitErrorKey<'tcx> {\n         let predicate =\n             infcx.resolve_type_vars_if_possible(&e.obligation.predicate);\n         TraitErrorKey {\n-            is_warning: is_warning(&e.obligation),\n             span: e.obligation.cause.span,\n             predicate: infcx.tcx.erase_regions(&predicate)\n         }\n@@ -83,10 +81,6 @@ fn report_fulfillment_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     }\n }\n \n-fn is_warning<T>(obligation: &Obligation<T>) -> bool {\n-    obligation.cause.code.is_rfc1214()\n-}\n-\n pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                          obligation: &PredicateObligation<'tcx>,\n                                          error: &MismatchedProjectionTypes<'tcx>)\n@@ -100,8 +94,8 @@ pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     // then $X will be unified with TyError, but the error still needs to be\n     // reported.\n     if !infcx.tcx.sess.has_errors() || !predicate.references_error() {\n-        span_err_or_warn!(\n-            is_warning(obligation), infcx.tcx.sess, obligation.cause.span, E0271,\n+        span_err!(\n+            infcx.tcx.sess, obligation.cause.span, E0271,\n             \"type mismatch resolving `{}`: {}\",\n             predicate,\n             error.err);\n@@ -208,12 +202,11 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                         obligation: &PredicateObligation<'tcx>,\n                                         error: &SelectionError<'tcx>)\n {\n-    let is_warning = is_warning(obligation);\n     match *error {\n         SelectionError::Unimplemented => {\n             if let ObligationCauseCode::CompareImplMethodObligation = obligation.cause.code {\n-                span_err_or_warn!(\n-                    is_warning, infcx.tcx.sess, obligation.cause.span, E0276,\n+                span_err!(\n+                    infcx.tcx.sess, obligation.cause.span, E0276,\n                     \"the requirement `{}` appears on the impl \\\n                      method but not on the corresponding trait method\",\n                     obligation.predicate);\n@@ -225,8 +218,8 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n                         if !infcx.tcx.sess.has_errors() || !trait_predicate.references_error() {\n                             let trait_ref = trait_predicate.to_poly_trait_ref();\n-                            span_err_or_warn!(\n-                                is_warning, infcx.tcx.sess, obligation.cause.span, E0277,\n+                            span_err!(\n+                                infcx.tcx.sess, obligation.cause.span, E0277,\n                                 \"the trait `{}` is not implemented for the type `{}`\",\n                                 trait_ref, trait_ref.self_ty());\n \n@@ -245,8 +238,8 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         let predicate = infcx.resolve_type_vars_if_possible(predicate);\n                         let err = infcx.equality_predicate(obligation.cause.span,\n                                                            &predicate).err().unwrap();\n-                        span_err_or_warn!(\n-                            is_warning, infcx.tcx.sess, obligation.cause.span, E0278,\n+                        span_err!(\n+                            infcx.tcx.sess, obligation.cause.span, E0278,\n                             \"the requirement `{}` is not satisfied (`{}`)\",\n                             predicate,\n                             err);\n@@ -257,8 +250,8 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         let predicate = infcx.resolve_type_vars_if_possible(predicate);\n                         let err = infcx.region_outlives_predicate(obligation.cause.span,\n                                                                   &predicate).err().unwrap();\n-                        span_err_or_warn!(\n-                            is_warning, infcx.tcx.sess, obligation.cause.span, E0279,\n+                        span_err!(\n+                            infcx.tcx.sess, obligation.cause.span, E0279,\n                             \"the requirement `{}` is not satisfied (`{}`)\",\n                             predicate,\n                             err);\n@@ -268,8 +261,8 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                     ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n                         let predicate =\n                             infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-                        span_err_or_warn!(\n-                            is_warning, infcx.tcx.sess, obligation.cause.span, E0280,\n+                        span_err!(\n+                            infcx.tcx.sess, obligation.cause.span, E0280,\n                             \"the requirement `{}` is not satisfied\",\n                             predicate);\n                         note_obligation_cause(infcx, obligation);\n@@ -281,8 +274,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         report_object_safety_error(infcx.tcx,\n                                                    obligation.cause.span,\n                                                    trait_def_id,\n-                                                   violations,\n-                                                   is_warning);\n+                                                   violations);\n                         note_obligation_cause(infcx, obligation);\n                     }\n \n@@ -304,8 +296,8 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             let expected_trait_ref = infcx.resolve_type_vars_if_possible(&*expected_trait_ref);\n             let actual_trait_ref = infcx.resolve_type_vars_if_possible(&*actual_trait_ref);\n             if !actual_trait_ref.self_ty().references_error() {\n-                span_err_or_warn!(\n-                    is_warning, infcx.tcx.sess, obligation.cause.span, E0281,\n+                span_err!(\n+                    infcx.tcx.sess, obligation.cause.span, E0281,\n                     \"type mismatch: the type `{}` implements the trait `{}`, \\\n                      but the trait `{}` is required ({})\",\n                     expected_trait_ref.self_ty(),\n@@ -318,8 +310,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n         TraitNotObjectSafe(did) => {\n             let violations = object_safety_violations(infcx.tcx, did);\n-            report_object_safety_error(infcx.tcx, obligation.cause.span, did,\n-                                       violations, is_warning);\n+            report_object_safety_error(infcx.tcx, obligation.cause.span, did, violations);\n             note_obligation_cause(infcx, obligation);\n         }\n     }\n@@ -328,11 +319,10 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n pub fn report_object_safety_error<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                         span: Span,\n                                         trait_def_id: DefId,\n-                                        violations: Vec<ObjectSafetyViolation>,\n-                                        is_warning: bool)\n+                                        violations: Vec<ObjectSafetyViolation>)\n {\n-    span_err_or_warn!(\n-        is_warning, tcx.sess, span, E0038,\n+    span_err!(\n+        tcx.sess, span, E0038,\n         \"the trait `{}` cannot be made into an object\",\n         tcx.item_path_str(trait_def_id));\n \n@@ -402,7 +392,17 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             let self_ty = trait_ref.self_ty();\n             let all_types = &trait_ref.substs().types;\n             if all_types.references_error() {\n-            } else if all_types.needs_infer() {\n+            } else {\n+                // Typically, this ambiguity should only happen if\n+                // there are unresolved type inference variables\n+                // (otherwise it would suggest a coherence\n+                // failure). But given #21974 that is not necessarily\n+                // the case -- we can have multiple where clauses that\n+                // are only distinguished by a region, which results\n+                // in an ambiguity even when all types are fully\n+                // known, since we don't dispatch based on region\n+                // relationships.\n+\n                 // This is kind of a hack: it frequently happens that some earlier\n                 // error prevents types from being fully inferred, and then we get\n                 // a bunch of uninteresting errors saying something like \"<generic\n@@ -430,16 +430,6 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         note_obligation_cause(infcx, obligation);\n                     }\n                 }\n-            } else if !infcx.tcx.sess.has_errors() {\n-                // Ambiguity. Coherence should have reported an error.\n-                infcx.tcx.sess.span_bug(\n-                    obligation.cause.span,\n-                    &format!(\n-                        \"coherence failed to report ambiguity: \\\n-                         cannot locate the impl of the trait `{}` for \\\n-                         the type `{}`\",\n-                        trait_ref,\n-                        self_ty));\n             }\n         }\n \n@@ -491,10 +481,6 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n     let tcx = infcx.tcx;\n     match *cause_code {\n         ObligationCauseCode::MiscObligation => { }\n-        ObligationCauseCode::RFC1214(ref subcode) => {\n-            tcx.sess.note_rfc_1214(cause_span);\n-            note_obligation_cause_code(infcx, predicate, cause_span, subcode);\n-        }\n         ObligationCauseCode::SliceOrArrayElem => {\n             tcx.sess.fileline_note(\n                 cause_span,"}, {"sha": "b93961f1aa9d2400e5edb84884db26afc53a32e4", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -21,16 +21,14 @@ use super::CodeSelectionError;\n use super::is_object_safe;\n use super::FulfillmentError;\n use super::ObligationCause;\n-use super::ObligationCauseCode;\n use super::PredicateObligation;\n use super::project;\n-use super::RFC1214Warning;\n use super::select::SelectionContext;\n use super::Unimplemented;\n use super::util::predicate_for_builtin_bound;\n \n pub struct FulfilledPredicates<'tcx> {\n-    set: FnvHashSet<(RFC1214Warning, ty::Predicate<'tcx>)>\n+    set: FnvHashSet<ty::Predicate<'tcx>>\n }\n \n /// The fulfillment context is used to drive trait resolution.  It\n@@ -194,9 +192,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n         assert!(!obligation.has_escaping_regions());\n \n-        let w = RFC1214Warning(obligation.cause.code.is_rfc1214());\n-\n-        if self.is_duplicate_or_add(infcx.tcx, w, &obligation.predicate) {\n+        if self.is_duplicate_or_add(infcx.tcx, &obligation.predicate) {\n             debug!(\"register_predicate({:?}) -- already seen, skip\", obligation);\n             return;\n         }\n@@ -261,7 +257,6 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n     fn is_duplicate_or_add(&mut self,\n                            tcx: &ty::ctxt<'tcx>,\n-                           w: RFC1214Warning,\n                            predicate: &ty::Predicate<'tcx>)\n                            -> bool {\n         // This is a kind of dirty hack to allow us to avoid \"rederiving\"\n@@ -276,12 +271,10 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         // evaluating the 'nested obligations'.  This cache lets us\n         // skip those.\n \n-        let will_warn_due_to_rfc1214 = w.0;\n-        let errors_will_be_reported = self.errors_will_be_reported && !will_warn_due_to_rfc1214;\n-        if errors_will_be_reported && predicate.is_global() {\n-            tcx.fulfilled_predicates.borrow_mut().is_duplicate_or_add(w, predicate)\n+        if self.errors_will_be_reported && predicate.is_global() {\n+            tcx.fulfilled_predicates.borrow_mut().is_duplicate_or_add(predicate)\n         } else {\n-            self.duplicate_set.is_duplicate_or_add(w, predicate)\n+            self.duplicate_set.is_duplicate_or_add(predicate)\n         }\n     }\n \n@@ -496,12 +489,8 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n         }\n \n         ty::Predicate::WellFormed(ty) => {\n-            let rfc1214 = match obligation.cause.code {\n-                ObligationCauseCode::RFC1214(_) => true,\n-                _ => false,\n-            };\n             match ty::wf::obligations(selcx.infcx(), obligation.cause.body_id,\n-                                      ty, obligation.cause.span, rfc1214) {\n+                                      ty, obligation.cause.span) {\n                 Some(obligations) => {\n                     new_obligations.extend(obligations);\n                     true\n@@ -539,13 +528,11 @@ impl<'tcx> FulfilledPredicates<'tcx> {\n         }\n     }\n \n-    pub fn is_duplicate(&self, w: RFC1214Warning, p: &ty::Predicate<'tcx>) -> bool {\n-        let key = (w, p.clone());\n-        self.set.contains(&key)\n+    pub fn is_duplicate(&self, key: &ty::Predicate<'tcx>) -> bool {\n+        self.set.contains(key)\n     }\n \n-    fn is_duplicate_or_add(&mut self, w: RFC1214Warning, p: &ty::Predicate<'tcx>) -> bool {\n-        let key = (w, p.clone());\n-        !self.set.insert(key)\n+    fn is_duplicate_or_add(&mut self, key: &ty::Predicate<'tcx>) -> bool {\n+        !self.set.insert(key.clone())\n     }\n }"}, {"sha": "255680465ca7fa4860c25bb2f2cebeb56b28fecb", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -106,9 +106,6 @@ pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from span.\n     MiscObligation,\n \n-    /// Obligation that triggers warning until RFC 1214 is fully in place.\n-    RFC1214(Rc<ObligationCauseCode<'tcx>>),\n-\n     /// This is the trait reference from the given projection\n     SliceOrArrayElem,\n \n@@ -554,24 +551,6 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n }\n \n-/// This marker is used in some caches to record whether the\n-/// predicate, if it is found to be false, will yield a warning (due\n-/// to RFC1214) or an error. We separate these two cases in the cache\n-/// so that if we see the same predicate twice, first resulting in a\n-/// warning, and next resulting in an error, we still report the\n-/// error, rather than considering it a duplicate.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct RFC1214Warning(bool);\n-\n-impl<'tcx> ObligationCauseCode<'tcx> {\n-    pub fn is_rfc1214(&self) -> bool {\n-        match *self {\n-            ObligationCauseCode::RFC1214(..) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n impl<'tcx, N> Vtable<'tcx, N> {\n     pub fn nested_obligations(self) -> Vec<N> {\n         match self {"}, {"sha": "b0215675fca815bbf3cc670a8c82028790a90ce3", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -26,7 +26,6 @@ use super::{ObligationCauseCode, BuiltinDerivedObligation, ImplDerivedObligation\n use super::{SelectionError, Unimplemented, OutputTypeParameterMismatch};\n use super::{ObjectCastObligation, Obligation};\n use super::TraitNotObjectSafe;\n-use super::RFC1214Warning;\n use super::Selection;\n use super::SelectionResult;\n use super::{VtableBuiltin, VtableImpl, VtableParam, VtableClosure,\n@@ -463,8 +462,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // have been proven elsewhere. This cache only contains\n         // predicates that are global in scope and hence unaffected by\n         // the current environment.\n-        let w = RFC1214Warning(false);\n-        if self.tcx().fulfilled_predicates.borrow().is_duplicate(w, &obligation.predicate) {\n+        if self.tcx().fulfilled_predicates.borrow().is_duplicate(&obligation.predicate) {\n             return EvaluatedToOk;\n         }\n \n@@ -485,8 +483,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::Predicate::WellFormed(ty) => {\n                 match ty::wf::obligations(self.infcx, obligation.cause.body_id,\n-                                          ty, obligation.cause.span,\n-                                          obligation.cause.code.is_rfc1214()) {\n+                                          ty, obligation.cause.span) {\n                     Some(obligations) =>\n                         self.evaluate_predicates_recursively(previous_stack, obligations.iter()),\n                     None =>\n@@ -2906,22 +2903,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // chain. Ideally, we should have a way to configure this either\n         // by using -Z verbose or just a CLI argument.\n         if obligation.recursion_depth >= 0 {\n-            let derived_code = match obligation.cause.code {\n-                ObligationCauseCode::RFC1214(ref base_code) => {\n-                    let derived_cause = DerivedObligationCause {\n-                        parent_trait_ref: obligation.predicate.to_poly_trait_ref(),\n-                        parent_code: base_code.clone(),\n-                    };\n-                    ObligationCauseCode::RFC1214(Rc::new(variant(derived_cause)))\n-                }\n-                _ => {\n-                    let derived_cause = DerivedObligationCause {\n-                        parent_trait_ref: obligation.predicate.to_poly_trait_ref(),\n-                        parent_code: Rc::new(obligation.cause.code.clone())\n-                    };\n-                    variant(derived_cause)\n-                }\n+            let derived_cause = DerivedObligationCause {\n+                parent_trait_ref: obligation.predicate.to_poly_trait_ref(),\n+                parent_code: Rc::new(obligation.cause.code.clone())\n             };\n+            let derived_code = variant(derived_cause);\n             ObligationCause::new(obligation.cause.span, obligation.cause.body_id, derived_code)\n         } else {\n             obligation.cause.clone()"}, {"sha": "7752367febb19c6fdbaca3212af2faf1c556df55", "filename": "src/librustc/middle/ty/outlives.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc%2Fmiddle%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc%2Fmiddle%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Foutlives.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -53,12 +53,6 @@ pub enum Component<'tcx> {\n     // them. This gives us room to improve the regionck reasoning in\n     // the future without breaking backwards compat.\n     EscapingProjection(Vec<Component<'tcx>>),\n-\n-    // This is a temporary marker indicating \"outlives components\"\n-    // that are due to the new rules introduced by RFC 1214.  For the\n-    // time being, violations of these requirements generally induce\n-    // warnings, not errors.\n-    RFC1214(Vec<Component<'tcx>>),\n }\n \n /// Returns all the things that must outlive `'a` for the condition\n@@ -124,20 +118,6 @@ fn compute_components<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n             }\n         }\n \n-        // Bare functions and traits are both binders. In the RFC,\n-        // this means we would add the bound regions to the \"bound\n-        // regions list\".  In our representation, no such list is\n-        // maintained explicitly, because bound regions themselves can\n-        // be readily identified. However, because the outlives\n-        // relation did not used to be applied to fn/trait-object\n-        // arguments, we wrap the resulting components in an RFC1214\n-        // wrapper so we can issue warnings.\n-        ty::TyBareFn(..) | ty::TyTrait(..) => {\n-            // OutlivesFunction, OutlivesObject, OutlivesFragment\n-            let subcomponents = capture_components(infcx, ty);\n-            out.push(Component::RFC1214(subcomponents));\n-        }\n-\n         // OutlivesTypeParameterEnv -- the actual checking that `X:'a`\n         // is implied by the environment is done in regionck.\n         ty::TyParam(p) => {\n@@ -202,7 +182,15 @@ fn compute_components<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n         ty::TyRawPtr(..) |      // ...\n         ty::TyRef(..) |         // OutlivesReference\n         ty::TyTuple(..) |       // ...\n+        ty::TyBareFn(..) |      // OutlivesFunction (*)\n+        ty::TyTrait(..) |       // OutlivesObject, OutlivesFragment (*)\n         ty::TyError => {\n+            // (*) Bare functions and traits are both binders. In the\n+            // RFC, this means we would add the bound regions to the\n+            // \"bound regions list\".  In our representation, no such\n+            // list is maintained explicitly, because bound regions\n+            // themselves can be readily identified.\n+\n             push_region_constraints(out, ty.regions());\n             for subty in ty.walk_shallow() {\n                 compute_components(infcx, subty, out);"}, {"sha": "d015711fa64db6851fee32fda897be091f746b47", "filename": "src/librustc/middle/ty/wf.rs", "status": "modified", "additions": 26, "deletions": 63, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc%2Fmiddle%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc%2Fmiddle%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fwf.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -15,8 +15,6 @@ use middle::subst::Substs;\n use middle::traits;\n use middle::ty::{self, RegionEscape, ToPredicate, Ty};\n use std::iter::once;\n-use std::mem;\n-use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n use util::common::ErrorReported;\n@@ -30,15 +28,13 @@ use util::common::ErrorReported;\n pub fn obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             body_id: ast::NodeId,\n                             ty: Ty<'tcx>,\n-                            span: Span,\n-                            rfc1214: bool)\n+                            span: Span)\n                             -> Option<Vec<traits::PredicateObligation<'tcx>>>\n {\n     let mut wf = WfPredicates { infcx: infcx,\n                                 body_id: body_id,\n                                 span: span,\n-                                out: vec![],\n-                                rfc1214: rfc1214 };\n+                                out: vec![] };\n     if wf.compute(ty) {\n         debug!(\"wf::obligations({:?}, body_id={:?}) = {:?}\", ty, body_id, wf.out);\n         let result = wf.normalize();\n@@ -56,25 +52,21 @@ pub fn obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n pub fn trait_obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                   body_id: ast::NodeId,\n                                   trait_ref: &ty::TraitRef<'tcx>,\n-                                  span: Span,\n-                                  rfc1214: bool)\n+                                  span: Span)\n                                   -> Vec<traits::PredicateObligation<'tcx>>\n {\n-    let mut wf = WfPredicates { infcx: infcx, body_id: body_id, span: span,\n-                                out: vec![], rfc1214: rfc1214 };\n+    let mut wf = WfPredicates { infcx: infcx, body_id: body_id, span: span, out: vec![] };\n     wf.compute_trait_ref(trait_ref);\n     wf.normalize()\n }\n \n pub fn predicate_obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                       body_id: ast::NodeId,\n                                       predicate: &ty::Predicate<'tcx>,\n-                                      span: Span,\n-                                      rfc1214: bool)\n+                                      span: Span)\n                                       -> Vec<traits::PredicateObligation<'tcx>>\n {\n-    let mut wf = WfPredicates { infcx: infcx, body_id: body_id, span: span,\n-                                out: vec![], rfc1214: rfc1214 };\n+    let mut wf = WfPredicates { infcx: infcx, body_id: body_id, span: span, out: vec![] };\n \n     // (*) ok to skip binders, because wf code is prepared for it\n     match *predicate {\n@@ -150,7 +142,7 @@ pub fn implied_bounds<'a,'tcx>(\n         // than the ultimate set. (Note: normally there won't be\n         // unresolved inference variables here anyway, but there might be\n         // during typeck under some circumstances.)\n-        let obligations = obligations(infcx, body_id, ty, span, false).unwrap_or(vec![]);\n+        let obligations = obligations(infcx, body_id, ty, span).unwrap_or(vec![]);\n \n         // From the full set of obligations, just filter down to the\n         // region relationships.\n@@ -223,8 +215,6 @@ fn implied_bounds_from_components<'tcx>(sub_region: ty::Region,\n                     vec!(),\n                 Component::UnresolvedInferenceVariable(..) =>\n                     vec!(),\n-                Component::RFC1214(components) =>\n-                    implied_bounds_from_components(sub_region, components),\n             }\n         })\n         .collect()\n@@ -235,24 +225,11 @@ struct WfPredicates<'a,'tcx:'a> {\n     body_id: ast::NodeId,\n     span: Span,\n     out: Vec<traits::PredicateObligation<'tcx>>,\n-    rfc1214: bool\n }\n \n impl<'a,'tcx> WfPredicates<'a,'tcx> {\n-    fn rfc1214<R,F:FnOnce(&mut WfPredicates<'a,'tcx>) -> R>(&mut self, f: F) -> R {\n-        let b = mem::replace(&mut self.rfc1214, true);\n-        let r = f(self);\n-        self.rfc1214 = b;\n-        r\n-    }\n-\n     fn cause(&mut self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n-        if !self.rfc1214 {\n-            traits::ObligationCause::new(self.span, self.body_id, code)\n-        } else {\n-            let code = traits::ObligationCauseCode::RFC1214(Rc::new(code));\n-            traits::ObligationCause::new(self.span, self.body_id, code)\n-        }\n+        traits::ObligationCause::new(self.span, self.body_id, code)\n     }\n \n     fn normalize(&mut self) -> Vec<traits::PredicateObligation<'tcx>> {\n@@ -268,14 +245,6 @@ impl<'a,'tcx> WfPredicates<'a,'tcx> {\n                 .collect()\n     }\n \n-    fn compute_rfc1214(&mut self, ty: Ty<'tcx>) {\n-        let b = mem::replace(&mut self.rfc1214, true);\n-        for subty in ty.walk().skip(1) {\n-            self.compute(subty);\n-        }\n-        self.rfc1214 = b;\n-    }\n-\n     /// Pushes the obligations required for `trait_ref` to be WF into\n     /// `self.out`.\n     fn compute_trait_ref(&mut self, trait_ref: &ty::TraitRef<'tcx>) {\n@@ -329,21 +298,19 @@ impl<'a,'tcx> WfPredicates<'a,'tcx> {\n \n                 ty::TySlice(subty) |\n                 ty::TyArray(subty, _) => {\n-                    self.rfc1214(|this| {\n-                        if !subty.has_escaping_regions() {\n-                            let cause = this.cause(traits::SliceOrArrayElem);\n-                            match traits::trait_ref_for_builtin_bound(this.infcx.tcx,\n-                                                                      ty::BoundSized,\n-                                                                      subty) {\n-                                Ok(trait_ref) => {\n-                                    this.out.push(\n-                                        traits::Obligation::new(cause,\n-                                                                trait_ref.to_predicate()));\n-                                }\n-                                Err(ErrorReported) => { }\n+                    if !subty.has_escaping_regions() {\n+                        let cause = self.cause(traits::SliceOrArrayElem);\n+                        match traits::trait_ref_for_builtin_bound(self.infcx.tcx,\n+                                                                  ty::BoundSized,\n+                                                                  subty) {\n+                            Ok(trait_ref) => {\n+                                self.out.push(\n+                                    traits::Obligation::new(cause,\n+                                                            trait_ref.to_predicate()));\n                             }\n+                            Err(ErrorReported) => { }\n                         }\n-                    })\n+                    }\n                 }\n \n                 ty::TyBox(_) |\n@@ -380,15 +347,16 @@ impl<'a,'tcx> WfPredicates<'a,'tcx> {\n                 ty::TyClosure(..) => {\n                     // the types in a closure are always the types of\n                     // local variables (or possibly references to local\n-                    // variables), which are separately checked w/r/t\n-                    // WFedness.\n+                    // variables), we'll walk those.\n+                    //\n+                    // (Though, local variables are probably not\n+                    // needed, as they are separately checked w/r/t\n+                    // WFedness.)\n                 }\n \n                 ty::TyBareFn(..) => {\n-                    // process the bound types; because the old implicator\n-                    // did not do this, go into RFC1214 mode.\n-                    subtys.skip_current_subtree();\n-                    self.compute_rfc1214(ty);\n+                    // let the loop iterator into the argument/return\n+                    // types appearing in the fn signature\n                 }\n \n                 ty::TyTrait(ref data) => {\n@@ -407,11 +375,6 @@ impl<'a,'tcx> WfPredicates<'a,'tcx> {\n                         traits::Obligation::new(\n                             cause,\n                             ty::Predicate::ObjectSafe(data.principal_def_id())));\n-\n-                    // process the bound types; because the old implicator\n-                    // did not do this, go into RFC1214 mode.\n-                    subtys.skip_current_subtree();\n-                    self.compute_rfc1214(ty);\n                 }\n \n                 // Inference variables are the complicated case, since we don't"}, {"sha": "a8587e83736812314e8d66673e78cf38130da892", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -102,13 +102,6 @@ impl Session {\n             None => self.diagnostic().span_err(sp, msg)\n         }\n     }\n-    pub fn note_rfc_1214(&self, span: Span) {\n-        self.span_note(\n-            span,\n-            &format!(\"this warning results from recent bug fixes and clarifications; \\\n-                      it will become a HARD ERROR in the next release. \\\n-                      See RFC 1214 for details.\"));\n-    }\n     pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n         match split_msg_into_multilines(msg) {\n             Some(msg) => self.diagnostic().span_err_with_code(sp, &msg[..], code),"}, {"sha": "98ae3071b87d22c3927dca80f286c65a2bd55802", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -1136,7 +1136,7 @@ fn make_object_type<'tcx>(this: &AstConv<'tcx>,\n         traits::astconv_object_safety_violations(tcx, principal.def_id());\n     if !object_safety_violations.is_empty() {\n         traits::report_object_safety_error(\n-            tcx, span, principal.def_id(), object_safety_violations, false);\n+            tcx, span, principal.def_id(), object_safety_violations);\n         return tcx.types.err;\n     }\n "}, {"sha": "f61d0992d1fb2e8653212b94f1631a435801e7a2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -138,7 +138,6 @@ pub mod coercion;\n pub mod demand;\n pub mod method;\n mod upvar;\n-mod wf;\n mod wfcheck;\n mod cast;\n mod closure;\n@@ -382,21 +381,6 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_wf_old(ccx: &CrateCtxt) {\n-    // If types are not well-formed, it leads to all manner of errors\n-    // downstream, so stop reporting errors at this point.\n-    ccx.tcx.sess.abort_if_new_errors(|| {\n-        // FIXME(#25759). The new code below is much more reliable but (for now)\n-        // only generates warnings. So as to ensure that we continue\n-        // getting errors where we used to get errors, we run the old wf\n-        // code first and abort if it encounters any errors. If no abort\n-        // comes, we run the new code and issue warnings.\n-        let krate = ccx.tcx.map.krate();\n-        let mut visit = wf::CheckTypeWellFormedVisitor::new(ccx);\n-        krate.visit_all_items(&mut visit);\n-    });\n-}\n-\n pub fn check_wf_new(ccx: &CrateCtxt) {\n     ccx.tcx.sess.abort_if_new_errors(|| {\n         let krate = ccx.tcx.map.krate();"}, {"sha": "759d561a961b7dab66aa761a5bd9abea38b0fa86", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -99,7 +99,6 @@ use middle::ty::adjustment;\n use middle::ty::wf::ImpliedBound;\n \n use std::mem;\n-use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n use rustc_front::intravisit::{self, Visitor};\n@@ -426,8 +425,6 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                       code: &traits::ObligationCauseCode<'tcx>)\n                       -> SubregionOrigin<'tcx> {\n         match *code {\n-            traits::ObligationCauseCode::RFC1214(ref code) =>\n-                infer::RFC1214Subregion(Rc::new(self.code_to_origin(span, sup_type, code))),\n             traits::ObligationCauseCode::ReferenceOutlivesReferent(ref_type) =>\n                 infer::ReferenceOutlivesReferent(ref_type, span),\n             _ =>\n@@ -1606,10 +1603,6 @@ fn components_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                     origin.span(),\n                     &format!(\"unresolved inference variable in outlives: {:?}\", v));\n             }\n-            ty::outlives::Component::RFC1214(subcomponents) => {\n-                let suborigin = infer::RFC1214Subregion(Rc::new(origin));\n-                components_must_outlive(rcx, suborigin, subcomponents, region);\n-            }\n         }\n     }\n }"}, {"sha": "ee2845c824e3b59493a19a8946ef6ba98a90e38c", "filename": "src/librustc_typeck/check/wf.rs", "status": "removed", "additions": 0, "deletions": 673, "changes": 673, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -1,673 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use astconv::AstConv;\n-use check::{FnCtxt, Inherited, blank_fn_ctxt, regionck, wfcheck};\n-use constrained_type_params::{identify_constrained_type_params, Parameter};\n-use CrateCtxt;\n-use middle::region;\n-use middle::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n-use middle::traits;\n-use middle::ty::{self, Ty};\n-use middle::ty::fold::{TypeFolder, TypeFoldable, super_fold_ty};\n-\n-use std::cell::RefCell;\n-use std::collections::HashSet;\n-use syntax::ast;\n-use syntax::codemap::{DUMMY_SP, Span};\n-use syntax::parse::token::special_idents;\n-\n-use rustc_front::intravisit::{self, Visitor, FnKind};\n-use rustc_front::hir;\n-\n-pub struct CheckTypeWellFormedVisitor<'ccx, 'tcx:'ccx> {\n-    ccx: &'ccx CrateCtxt<'ccx, 'tcx>,\n-    cache: HashSet<Ty<'tcx>>\n-}\n-\n-impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n-    pub fn new(ccx: &'ccx CrateCtxt<'ccx, 'tcx>) -> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n-        CheckTypeWellFormedVisitor { ccx: ccx, cache: HashSet::new() }\n-    }\n-\n-    fn tcx(&self) -> &ty::ctxt<'tcx> {\n-        self.ccx.tcx\n-    }\n-\n-    /// Checks that the field types (in a struct def'n) or argument types (in an enum def'n) are\n-    /// well-formed, meaning that they do not require any constraints not declared in the struct\n-    /// definition itself. For example, this definition would be illegal:\n-    ///\n-    ///     struct Ref<'a, T> { x: &'a T }\n-    ///\n-    /// because the type did not declare that `T:'a`.\n-    ///\n-    /// We do this check as a pre-pass before checking fn bodies because if these constraints are\n-    /// not included it frequently leads to confusing errors in fn bodies. So it's better to check\n-    /// the types first.\n-    fn check_item_well_formed(&mut self, item: &hir::Item) {\n-        let ccx = self.ccx;\n-        debug!(\"check_item_well_formed(it.id={}, it.name={})\",\n-               item.id,\n-               ccx.tcx.item_path_str(ccx.tcx.map.local_def_id(item.id)));\n-\n-        match item.node {\n-            /// Right now we check that every default trait implementation\n-            /// has an implementation of itself. Basically, a case like:\n-            ///\n-            /// `impl Trait for T {}`\n-            ///\n-            /// has a requirement of `T: Trait` which was required for default\n-            /// method implementations. Although this could be improved now that\n-            /// there's a better infrastructure in place for this, it's being left\n-            /// for a follow-up work.\n-            ///\n-            /// Since there's such a requirement, we need to check *just* positive\n-            /// implementations, otherwise things like:\n-            ///\n-            /// impl !Send for T {}\n-            ///\n-            /// won't be allowed unless there's an *explicit* implementation of `Send`\n-            /// for `T`\n-            hir::ItemImpl(_, hir::ImplPolarity::Positive, _, _, _, _) => {\n-                self.check_impl(item);\n-            }\n-            hir::ItemImpl(_, hir::ImplPolarity::Negative, _, Some(_), _, _) => {\n-                let item_def_id = ccx.tcx.map.local_def_id(item.id);\n-                let trait_ref = ccx.tcx.impl_trait_ref(item_def_id).unwrap();\n-                ccx.tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id);\n-                match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n-                    Some(ty::BoundSend) | Some(ty::BoundSync) => {}\n-                    Some(_) | None => {\n-                        if !ccx.tcx.trait_has_default_impl(trait_ref.def_id) {\n-                            wfcheck::error_192(ccx, item.span);\n-                        }\n-                    }\n-                }\n-            }\n-            hir::ItemFn(..) => {\n-                self.check_item_type(item);\n-            }\n-            hir::ItemStatic(..) => {\n-                self.check_item_type(item);\n-            }\n-            hir::ItemConst(..) => {\n-                self.check_item_type(item);\n-            }\n-            hir::ItemStruct(ref struct_def, ref ast_generics) => {\n-                self.check_type_defn(item, |fcx| {\n-                    vec![struct_variant(fcx, struct_def)]\n-                });\n-\n-                self.check_variances_for_type_defn(item, ast_generics);\n-            }\n-            hir::ItemEnum(ref enum_def, ref ast_generics) => {\n-                self.check_type_defn(item, |fcx| {\n-                    enum_variants(fcx, enum_def)\n-                });\n-\n-                self.check_variances_for_type_defn(item, ast_generics);\n-            }\n-            hir::ItemTrait(_, _, _, ref items) => {\n-                let trait_predicates =\n-                    ccx.tcx.lookup_predicates(ccx.tcx.map.local_def_id(item.id));\n-                reject_non_type_param_bounds(ccx.tcx, item.span, &trait_predicates);\n-                if ccx.tcx.trait_has_default_impl(ccx.tcx.map.local_def_id(item.id)) {\n-                    if !items.is_empty() {\n-                        wfcheck::error_380(ccx, item.span);\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    fn with_fcx<F>(&mut self, item: &hir::Item, mut f: F) where\n-        F: for<'fcx> FnMut(&mut CheckTypeWellFormedVisitor<'ccx, 'tcx>, &FnCtxt<'fcx, 'tcx>),\n-    {\n-        let ccx = self.ccx;\n-        let item_def_id = ccx.tcx.map.local_def_id(item.id);\n-        let type_scheme = ccx.tcx.lookup_item_type(item_def_id);\n-        let type_predicates = ccx.tcx.lookup_predicates(item_def_id);\n-        reject_non_type_param_bounds(ccx.tcx, item.span, &type_predicates);\n-        let free_id_outlive = ccx.tcx.region_maps.item_extent(item.id);\n-        let param_env = ccx.tcx.construct_parameter_environment(item.span,\n-                                                                &type_scheme.generics,\n-                                                                &type_predicates,\n-                                                                free_id_outlive);\n-        let tables = RefCell::new(ty::Tables::empty());\n-        let inh = Inherited::new(ccx.tcx, &tables, param_env);\n-        let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(type_scheme.ty), item.id);\n-        f(self, &fcx);\n-        fcx.select_all_obligations_or_error();\n-        regionck::regionck_item(&fcx, item.id, item.span, &[]);\n-    }\n-\n-    /// In a type definition, we check that to ensure that the types of the fields are well-formed.\n-    fn check_type_defn<F>(&mut self, item: &hir::Item, mut lookup_fields: F) where\n-        F: for<'fcx> FnMut(&FnCtxt<'fcx, 'tcx>) -> Vec<AdtVariant<'tcx>>,\n-    {\n-        self.with_fcx(item, |this, fcx| {\n-            let variants = lookup_fields(fcx);\n-            let mut bounds_checker = BoundsChecker::new(fcx,\n-                                                        item.id,\n-                                                        Some(&mut this.cache));\n-            debug!(\"check_type_defn at bounds_checker.scope: {:?}\", bounds_checker.scope);\n-\n-            for variant in &variants {\n-                for field in &variant.fields {\n-                    // Regions are checked below.\n-                    bounds_checker.check_traits_in_ty(field.ty, field.span);\n-                }\n-\n-                // For DST, all intermediate types must be sized.\n-                if let Some((_, fields)) = variant.fields.split_last() {\n-                    for field in fields {\n-                        fcx.register_builtin_bound(\n-                            field.ty,\n-                            ty::BoundSized,\n-                            traits::ObligationCause::new(field.span,\n-                                                         fcx.body_id,\n-                                                         traits::FieldSized));\n-                    }\n-                }\n-            }\n-\n-            for field in variants.iter().flat_map(|v| v.fields.iter()) {\n-                fcx.register_old_wf_obligation(field.ty, field.span, traits::MiscObligation);\n-            }\n-        });\n-    }\n-\n-    fn check_item_type(&mut self,\n-                       item: &hir::Item)\n-    {\n-        self.with_fcx(item, |this, fcx| {\n-            let mut bounds_checker = BoundsChecker::new(fcx,\n-                                                        item.id,\n-                                                        Some(&mut this.cache));\n-            debug!(\"check_item_type at bounds_checker.scope: {:?}\", bounds_checker.scope);\n-\n-            let item_def_id = fcx.tcx().map.local_def_id(item.id);\n-            let type_scheme = fcx.tcx().lookup_item_type(item_def_id);\n-            let item_ty = fcx.instantiate_type_scheme(item.span,\n-                                                      &fcx.inh\n-                                                          .infcx\n-                                                          .parameter_environment\n-                                                          .free_substs,\n-                                                      &type_scheme.ty);\n-\n-            bounds_checker.check_traits_in_ty(item_ty, item.span);\n-        });\n-    }\n-\n-    fn check_impl(&mut self,\n-                  item: &hir::Item)\n-    {\n-        self.with_fcx(item, |this, fcx| {\n-            let mut bounds_checker = BoundsChecker::new(fcx,\n-                                                        item.id,\n-                                                        Some(&mut this.cache));\n-            debug!(\"check_impl at bounds_checker.scope: {:?}\", bounds_checker.scope);\n-\n-            // Find the impl self type as seen from the \"inside\" --\n-            // that is, with all type parameters converted from bound\n-            // to free.\n-            let self_ty = fcx.tcx().node_id_to_type(item.id);\n-            let self_ty = fcx.instantiate_type_scheme(item.span,\n-                                                      &fcx.inh\n-                                                          .infcx\n-                                                          .parameter_environment\n-                                                          .free_substs,\n-                                                      &self_ty);\n-\n-            bounds_checker.check_traits_in_ty(self_ty, item.span);\n-\n-            // Similarly, obtain an \"inside\" reference to the trait\n-            // that the impl implements.\n-            let trait_ref = match fcx.tcx().impl_trait_ref(fcx.tcx().map.local_def_id(item.id)) {\n-                None => { return; }\n-                Some(t) => { t }\n-            };\n-\n-            let trait_ref = fcx.instantiate_type_scheme(item.span,\n-                                                        &fcx.inh\n-                                                            .infcx\n-                                                            .parameter_environment\n-                                                            .free_substs,\n-                                                        &trait_ref);\n-\n-            // We are stricter on the trait-ref in an impl than the\n-            // self-type.  In particular, we enforce region\n-            // relationships. The reason for this is that (at least\n-            // presently) \"applying\" an impl does not require that the\n-            // application site check the well-formedness constraints on the\n-            // trait reference. Instead, this is done at the impl site.\n-            // Arguably this is wrong and we should treat the trait-reference\n-            // the same way as we treat the self-type.\n-            bounds_checker.check_trait_ref(&trait_ref, item.span);\n-\n-            let cause =\n-                traits::ObligationCause::new(\n-                    item.span,\n-                    fcx.body_id,\n-                    traits::ItemObligation(trait_ref.def_id));\n-\n-            // Find the supertrait bounds. This will add `int:Bar`.\n-            let poly_trait_ref = ty::Binder(trait_ref);\n-            let predicates = fcx.tcx().lookup_super_predicates(poly_trait_ref.def_id());\n-            let predicates = predicates.instantiate_supertrait(fcx.tcx(), &poly_trait_ref);\n-            let predicates = {\n-                let selcx = &mut traits::SelectionContext::new(fcx.infcx());\n-                traits::normalize(selcx, cause.clone(), &predicates)\n-            };\n-            for predicate in predicates.value.predicates {\n-                fcx.register_predicate(traits::Obligation::new(cause.clone(), predicate));\n-            }\n-            for obligation in predicates.obligations {\n-                fcx.register_predicate(obligation);\n-            }\n-        });\n-    }\n-\n-    fn check_variances_for_type_defn(&self,\n-                                     item: &hir::Item,\n-                                     ast_generics: &hir::Generics)\n-    {\n-        let item_def_id = self.tcx().map.local_def_id(item.id);\n-        let ty_predicates = self.tcx().lookup_predicates(item_def_id);\n-        let variances = self.tcx().item_variances(item_def_id);\n-\n-        let mut constrained_parameters: HashSet<_> =\n-            variances.types\n-                     .iter_enumerated()\n-                     .filter(|&(_, _, &variance)| variance != ty::Bivariant)\n-                     .map(|(space, index, _)| self.param_ty(ast_generics, space, index))\n-                     .map(|p| Parameter::Type(p))\n-                     .collect();\n-\n-        identify_constrained_type_params(self.tcx(),\n-                                         ty_predicates.predicates.as_slice(),\n-                                         None,\n-                                         &mut constrained_parameters);\n-\n-        for (space, index, _) in variances.types.iter_enumerated() {\n-            let param_ty = self.param_ty(ast_generics, space, index);\n-            if constrained_parameters.contains(&Parameter::Type(param_ty)) {\n-                continue;\n-            }\n-            let span = self.ty_param_span(ast_generics, item, space, index);\n-            self.report_bivariance(span, param_ty.name);\n-        }\n-\n-        for (space, index, &variance) in variances.regions.iter_enumerated() {\n-            if variance != ty::Bivariant {\n-                continue;\n-            }\n-\n-            assert_eq!(space, TypeSpace);\n-            let span = ast_generics.lifetimes[index].lifetime.span;\n-            let name = ast_generics.lifetimes[index].lifetime.name;\n-            self.report_bivariance(span, name);\n-        }\n-    }\n-\n-    fn param_ty(&self,\n-                ast_generics: &hir::Generics,\n-                space: ParamSpace,\n-                index: usize)\n-                -> ty::ParamTy\n-    {\n-        let name = match space {\n-            TypeSpace => ast_generics.ty_params[index].name,\n-            SelfSpace => special_idents::type_self.name,\n-            FnSpace => self.tcx().sess.bug(\"Fn space occupied?\"),\n-        };\n-\n-        ty::ParamTy { space: space, idx: index as u32, name: name }\n-    }\n-\n-    fn ty_param_span(&self,\n-                     ast_generics: &hir::Generics,\n-                     item: &hir::Item,\n-                     space: ParamSpace,\n-                     index: usize)\n-                     -> Span\n-    {\n-        match space {\n-            TypeSpace => ast_generics.ty_params[index].span,\n-            SelfSpace => item.span,\n-            FnSpace => self.tcx().sess.span_bug(item.span, \"Fn space occupied?\"),\n-        }\n-    }\n-\n-    fn report_bivariance(&self,\n-                         span: Span,\n-                         param_name: ast::Name)\n-    {\n-        wfcheck::error_392(self.tcx(), span, param_name);\n-\n-        let suggested_marker_id = self.tcx().lang_items.phantom_data();\n-        match suggested_marker_id {\n-            Some(def_id) => {\n-                self.tcx().sess.fileline_help(\n-                    span,\n-                    &format!(\"consider removing `{}` or using a marker such as `{}`\",\n-                             param_name,\n-                             self.tcx().item_path_str(def_id)));\n-            }\n-            None => {\n-                // no lang items, no help!\n-            }\n-        }\n-    }\n-}\n-\n-// Reject any predicates that do not involve a type parameter.\n-fn reject_non_type_param_bounds<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                      span: Span,\n-                                      predicates: &ty::GenericPredicates<'tcx>) {\n-    for predicate in &predicates.predicates {\n-        match predicate {\n-            &ty::Predicate::Trait(ty::Binder(ref tr)) => {\n-                let found_param = tr.input_types().iter()\n-                                    .flat_map(|ty| ty.walk())\n-                                    .any(is_ty_param);\n-                if !found_param { report_bound_error(tcx, span, tr.self_ty() )}\n-            }\n-            &ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(ty, _))) => {\n-                let found_param = ty.walk().any(|t| is_ty_param(t));\n-                if !found_param { report_bound_error(tcx, span, ty) }\n-            }\n-            _ => {}\n-        };\n-    }\n-\n-    fn report_bound_error<'t>(tcx: &ty::ctxt<'t>,\n-                          span: Span,\n-                          bounded_ty: ty::Ty<'t>) {\n-        span_err!(tcx.sess, span, E0193,\n-            \"cannot bound type `{}`, where clause \\\n-                bounds may only be attached to types involving \\\n-                type parameters\",\n-                bounded_ty)\n-    }\n-\n-    fn is_ty_param(ty: ty::Ty) -> bool {\n-        match &ty.sty {\n-            &ty::TyParam(_) => true,\n-            _ => false\n-        }\n-    }\n-}\n-\n-fn reject_shadowing_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                          span: Span,\n-                                          generics: &ty::Generics<'tcx>) {\n-    let impl_params = generics.types.get_slice(subst::TypeSpace).iter()\n-        .map(|tp| tp.name).collect::<HashSet<_>>();\n-\n-    for method_param in generics.types.get_slice(subst::FnSpace) {\n-        if impl_params.contains(&method_param.name) {\n-            wfcheck::error_194(tcx, span, method_param.name);\n-        }\n-    }\n-}\n-\n-impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n-    fn visit_item(&mut self, i: &hir::Item) {\n-        self.check_item_well_formed(i);\n-        intravisit::walk_item(self, i);\n-    }\n-\n-    fn visit_fn(&mut self,\n-                fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, span: Span, id: ast::NodeId) {\n-        match fk {\n-            FnKind::Closure | FnKind::ItemFn(..) => {}\n-            FnKind::Method(..) => {\n-                match self.tcx().impl_or_trait_item(self.tcx().map.local_def_id(id)) {\n-                    ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n-                        reject_shadowing_type_parameters(self.tcx(), span, &ty_method.generics)\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-        intravisit::walk_fn(self, fk, fd, b, span)\n-    }\n-\n-    fn visit_trait_item(&mut self, trait_item: &'v hir::TraitItem) {\n-        if let hir::MethodTraitItem(_, None) = trait_item.node {\n-            match self.tcx().impl_or_trait_item(self.tcx().map.local_def_id(trait_item.id)) {\n-                ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n-                    reject_non_type_param_bounds(\n-                        self.tcx(),\n-                        trait_item.span,\n-                        &ty_method.predicates);\n-                    reject_shadowing_type_parameters(\n-                        self.tcx(),\n-                        trait_item.span,\n-                        &ty_method.generics);\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        intravisit::walk_trait_item(self, trait_item)\n-    }\n-}\n-\n-pub struct BoundsChecker<'cx,'tcx:'cx> {\n-    fcx: &'cx FnCtxt<'cx,'tcx>,\n-    span: Span,\n-\n-    scope: region::CodeExtent,\n-\n-    binding_count: usize,\n-    cache: Option<&'cx mut HashSet<Ty<'tcx>>>,\n-}\n-\n-impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n-    pub fn new(fcx: &'cx FnCtxt<'cx,'tcx>,\n-               scope: ast::NodeId,\n-               cache: Option<&'cx mut HashSet<Ty<'tcx>>>)\n-               -> BoundsChecker<'cx,'tcx> {\n-        let scope = fcx.tcx().region_maps.item_extent(scope);\n-        BoundsChecker { fcx: fcx, span: DUMMY_SP, scope: scope,\n-                        cache: cache, binding_count: 0 }\n-    }\n-\n-    /// Given a trait ref like `A : Trait<B>`, where `Trait` is defined as (say):\n-    ///\n-    ///     trait Trait<B:OtherTrait> : Copy { ... }\n-    ///\n-    /// This routine will check that `B : OtherTrait` and `A : Trait<B>`. It will also recursively\n-    /// check that the types `A` and `B` are well-formed.\n-    ///\n-    /// Note that it does not (currently, at least) check that `A : Copy` (that check is delegated\n-    /// to the point where impl `A : Trait<B>` is implemented).\n-    pub fn check_trait_ref(&mut self, trait_ref: &ty::TraitRef<'tcx>, span: Span) {\n-        let trait_predicates = self.fcx.tcx().lookup_predicates(trait_ref.def_id);\n-\n-        let bounds = self.fcx.instantiate_bounds(span,\n-                                                 trait_ref.substs,\n-                                                 &trait_predicates);\n-\n-        self.fcx.add_obligations_for_parameters(\n-            traits::ObligationCause::new(\n-                span,\n-                self.fcx.body_id,\n-                traits::ItemObligation(trait_ref.def_id)),\n-            &bounds);\n-\n-        for &ty in &trait_ref.substs.types {\n-            self.check_traits_in_ty(ty, span);\n-        }\n-    }\n-\n-    fn check_traits_in_ty(&mut self, ty: Ty<'tcx>, span: Span) {\n-        self.span = span;\n-        // When checking types outside of a type def'n, we ignore\n-        // region obligations. See discussion below in fold_ty().\n-        self.binding_count += 1;\n-        ty.fold_with(self);\n-        self.binding_count -= 1;\n-    }\n-}\n-\n-impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n-    fn tcx(&self) -> &ty::ctxt<'tcx> {\n-        self.fcx.tcx()\n-    }\n-\n-    fn fold_binder<T>(&mut self, binder: &ty::Binder<T>) -> ty::Binder<T>\n-        where T : TypeFoldable<'tcx>\n-    {\n-        self.binding_count += 1;\n-        let value = self.fcx.tcx().liberate_late_bound_regions(\n-            self.scope,\n-            binder);\n-        debug!(\"BoundsChecker::fold_binder: late-bound regions replaced: {:?} at scope: {:?}\",\n-               value, self.scope);\n-        let value = value.fold_with(self);\n-        self.binding_count -= 1;\n-        ty::Binder(value)\n-    }\n-\n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        debug!(\"BoundsChecker t={:?}\",\n-               t);\n-\n-        match self.cache {\n-            Some(ref mut cache) => {\n-                if !cache.insert(t) {\n-                    // Already checked this type! Don't check again.\n-                    debug!(\"cached\");\n-                    return t;\n-                }\n-            }\n-            None => { }\n-        }\n-\n-        match t.sty{\n-            ty::TyStruct(def, substs) |\n-            ty::TyEnum(def, substs) => {\n-                let type_predicates = def.predicates(self.fcx.tcx());\n-                let bounds = self.fcx.instantiate_bounds(self.span, substs,\n-                                                         &type_predicates);\n-\n-                if self.binding_count == 0 {\n-                    self.fcx.add_obligations_for_parameters(\n-                        traits::ObligationCause::new(self.span,\n-                                                     self.fcx.body_id,\n-                                                     traits::ItemObligation(def.did)),\n-                        &bounds);\n-                } else {\n-                    // There are two circumstances in which we ignore\n-                    // region obligations.\n-                    //\n-                    // The first is when we are inside of a closure\n-                    // type. This is because in that case the region\n-                    // obligations for the parameter types are things\n-                    // that the closure body gets to assume and the\n-                    // caller must prove at the time of call. In other\n-                    // words, if there is a type like `<'a, 'b> | &'a\n-                    // &'b int |`, it is well-formed, and caller will\n-                    // have to show that `'b : 'a` at the time of\n-                    // call.\n-                    //\n-                    // The second is when we are checking for\n-                    // well-formedness outside of a type def'n or fn\n-                    // body. This is for a similar reason: in general,\n-                    // we only do WF checking for regions in the\n-                    // result of expressions and type definitions, so\n-                    // to as allow for implicit where clauses.\n-                    //\n-                    // (I believe we should do the same for traits, but\n-                    // that will require an RFC. -nmatsakis)\n-                    let bounds = filter_to_trait_obligations(bounds);\n-                    self.fcx.add_obligations_for_parameters(\n-                        traits::ObligationCause::new(self.span,\n-                                                     self.fcx.body_id,\n-                                                     traits::ItemObligation(def.did)),\n-                        &bounds);\n-                }\n-\n-                self.fold_substs(substs);\n-            }\n-            _ => {\n-                super_fold_ty(self, t);\n-            }\n-        }\n-\n-        t // we're not folding to produce a new type, so just return `t` here\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// ADT\n-\n-struct AdtVariant<'tcx> {\n-    fields: Vec<AdtField<'tcx>>,\n-}\n-\n-struct AdtField<'tcx> {\n-    ty: Ty<'tcx>,\n-    span: Span,\n-}\n-\n-fn struct_variant<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                            struct_def: &hir::VariantData)\n-                            -> AdtVariant<'tcx> {\n-    let fields =\n-        struct_def.fields().iter()\n-        .map(|field| {\n-            let field_ty = fcx.tcx().node_id_to_type(field.node.id);\n-            let field_ty = fcx.instantiate_type_scheme(field.span,\n-                                                       &fcx.inh\n-                                                           .infcx\n-                                                           .parameter_environment\n-                                                           .free_substs,\n-                                                       &field_ty);\n-            AdtField { ty: field_ty, span: field.span }\n-        })\n-        .collect();\n-    AdtVariant { fields: fields }\n-}\n-\n-fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                           enum_def: &hir::EnumDef)\n-                           -> Vec<AdtVariant<'tcx>> {\n-    enum_def.variants.iter()\n-        .map(|variant| struct_variant(fcx, &variant.node.data))\n-        .collect()\n-}\n-\n-fn filter_to_trait_obligations<'tcx>(bounds: ty::InstantiatedPredicates<'tcx>)\n-                                     -> ty::InstantiatedPredicates<'tcx>\n-{\n-    let mut result = ty::InstantiatedPredicates::empty();\n-    for (space, _, predicate) in bounds.predicates.iter_enumerated() {\n-        match *predicate {\n-            ty::Predicate::Trait(..) |\n-            ty::Predicate::Projection(..) => {\n-                result.predicates.push(space, predicate.clone())\n-            }\n-            ty::Predicate::WellFormed(..) |\n-            ty::Predicate::ObjectSafe(..) |\n-            ty::Predicate::Equate(..) |\n-            ty::Predicate::TypeOutlives(..) |\n-            ty::Predicate::RegionOutlives(..) => {\n-            }\n-        }\n-    }\n-    result\n-}"}, {"sha": "5d0e713012f2a618d63ca1efd8933d0d588649b9", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -21,7 +21,6 @@ use middle::ty::fold::{TypeFolder};\n \n use std::cell::RefCell;\n use std::collections::HashSet;\n-use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::{Span};\n use syntax::parse::token::{special_idents};\n@@ -38,8 +37,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                -> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         CheckTypeWellFormedVisitor {\n             ccx: ccx,\n-            code: traits::ObligationCauseCode::RFC1214(\n-                Rc::new(traits::ObligationCauseCode::MiscObligation))\n+            code: traits::ObligationCauseCode::MiscObligation\n         }\n     }\n \n@@ -311,8 +309,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                         ty::wf::trait_obligations(fcx.infcx(),\n                                                   fcx.body_id,\n                                                   &trait_ref,\n-                                                  ast_trait_ref.path.span,\n-                                                  true);\n+                                                  ast_trait_ref.path.span);\n                     for obligation in obligations {\n                         fcx.register_predicate(obligation);\n                     }\n@@ -343,8 +340,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                       .flat_map(|p| ty::wf::predicate_obligations(fcx.infcx(),\n                                                                   fcx.body_id,\n                                                                   p,\n-                                                                  span,\n-                                                                  true));\n+                                                                  span));\n \n         for obligation in obligations {\n             fcx.register_predicate(obligation);"}, {"sha": "7d1f71967a2d5a524a8d5bb2b3953726b3bc2087", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -190,7 +190,7 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                     None => { }\n                 }\n             }\n-            hir::ItemImpl(_, _, _, Some(_), ref self_ty, _) => {\n+            hir::ItemImpl(_, _, _, Some(_), _, _) => {\n                 let impl_def_id = self.tcx.map.local_def_id(item.id);\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n@@ -200,16 +200,10 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                         // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n \n                         if !traits::is_object_safe(self.tcx, data.principal_def_id()) {\n-                            // FIXME(#27579). This just means the\n-                            // self-ty is illegal; WF will report this\n-                            // error. But it will do so as a warning\n-                            // for a release or two.  For backwards\n-                            // compat reasons, then, we continue to\n-                            // report it here so that things which\n-                            // were errors remain errors.\n-                            span_err!(self.tcx.sess, self_ty.span, E0372,\n-                                      \"the trait `{}` cannot be made into an object\",\n-                                      self.tcx.item_path_str(data.principal_def_id()));\n+                            // This is an error, but it will be\n+                            // reported by wfcheck.  Ignore it\n+                            // here. This is tested by\n+                            // `coherence-impl-trait-for-trait-object-safe.rs`.\n                         } else {\n                             let mut supertrait_def_ids =\n                                 traits::supertrait_def_ids(self.tcx, data.principal_def_id());"}, {"sha": "e64fb6437a96425c7b4fa1f82f73e9089769c12a", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -3114,14 +3114,6 @@ impl Baz for Bar { } // Note: This is OK\n ```\n \"##,\n \n-E0372: r##\"\n-Trying to implement a trait for a trait object (as in `impl Trait1 for\n-Trait2 { ... }`) does not work if the trait is not object-safe. Please see the\n-[RFC 255] for more details on object safety rules.\n-\n-[RFC 255]: https://github.com/rust-lang/rfcs/pull/255\n-\"##,\n-\n E0379: r##\"\n Trait methods cannot be declared `const` by design. For more information, see\n [RFC 911].\n@@ -3486,6 +3478,7 @@ register_diagnostics! {\n //  E0319, // trait impls for defaulted traits allowed just for structs/enums\n     E0320, // recursive overflow during dropck\n     E0328, // cannot implement Unsize explicitly\n+//  E0372, // coherence not object safe\n     E0374, // the trait `CoerceUnsized` may only be implemented for a coercion\n            // between structures with one field being coerced, none found\n     E0375, // the trait `CoerceUnsized` may only be implemented for a coercion"}, {"sha": "c0ede6370f1b12e56d80c2f5b13dea2bc83a7b82", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -346,8 +346,8 @@ pub fn check_crate(tcx: &ty::ctxt, trait_map: ty::TraitMap) {\n           coherence::check_coherence(&ccx));\n     });\n \n-    time(time_passes, \"wf checking (old)\", ||\n-        check::check_wf_old(&ccx));\n+    time(time_passes, \"wf checking\", ||\n+        check::check_wf_new(&ccx));\n \n     time(time_passes, \"item-types checking\", ||\n         check::check_item_types(&ccx));\n@@ -358,11 +358,6 @@ pub fn check_crate(tcx: &ty::ctxt, trait_map: ty::TraitMap) {\n     time(time_passes, \"drop-impl checking\", ||\n         check::check_drop_impls(&ccx));\n \n-    // Do this last so that if there are errors in the old code, they\n-    // get reported, and we don't get extra warnings.\n-    time(time_passes, \"wf checking (new)\", ||\n-        check::check_wf_new(&ccx));\n-\n     check_for_entry_fn(&ccx);\n     tcx.sess.abort_if_errors();\n }"}, {"sha": "175e8730cbcd3f8ccbed893ace5b4d98dd8d1641", "filename": "src/test/auxiliary/associated-types-cc-lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fauxiliary%2Fassociated-types-cc-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fauxiliary%2Fassociated-types-cc-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fassociated-types-cc-lib.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -13,7 +13,7 @@\n \n #![crate_type=\"lib\"]\n \n-pub trait Bar {\n+pub trait Bar: Sized {\n     type T;\n \n     fn get(x: Option<Self>) -> <Self as Bar>::T;"}, {"sha": "b8fd59bf7037df002c7fd0131cfa3d51261933cd", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -11,7 +11,7 @@\n #![crate_name=\"static_methods_crate\"]\n #![crate_type = \"lib\"]\n \n-pub trait read {\n+pub trait read: Sized {\n     fn readMaybe(s: String) -> Option<Self>;\n }\n "}, {"sha": "0b1d6a5b71ad20e0abb8a6bc1809ab559747fcb0", "filename": "src/test/compile-fail/associated-types-no-suitable-supertrait.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -25,10 +25,7 @@ trait Get {\n \n trait Other {\n     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-    // (note that we no longer catch the error here, since the\n-    //  error below aborts compilation.\n-    //  See also associated-types-no-suitable-supertrait-2.rs\n-    //  which checks that this error would be caught eventually.)\n+    //~^ ERROR the trait `Get` is not implemented for the type `Self`\n }\n \n impl<T:Get> Other for T {"}, {"sha": "3065ecfaa302d3379a35ad350ac16d3301b80c6a", "filename": "src/test/compile-fail/builtin-superkinds-self-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -13,7 +13,7 @@\n \n use std::sync::mpsc::{channel, Sender};\n \n-trait Foo : Sync+'static {\n+trait Foo : Sized+Sync+'static {\n     fn foo(self, mut chan: Sender<Self>) { }\n }\n "}, {"sha": "8bb9556fcc075204f010c66cab853259cb3c1b11", "filename": "src/test/compile-fail/coherence-impl-trait-for-trait-object-safe.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fcoherence-impl-trait-for-trait-object-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fcoherence-impl-trait-for-trait-object-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impl-trait-for-trait-object-safe.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -13,9 +13,7 @@\n \n // If the trait is not object-safe, we give a more tailored message\n // because we're such schnuckels:\n-trait NotObjectSafe { fn eq(&self, other: &Self); }\n-impl NotObjectSafe for NotObjectSafe {  //~ ERROR E0372\n-    fn eq(&self, other: &Self) { panic!(); }\n-}\n+trait NotObjectSafe { fn eq(&self, other: Self); }\n+impl NotObjectSafe for NotObjectSafe { } //~ ERROR E0038\n \n fn main() { }"}, {"sha": "7d4c618de665c622712d252d60417fade9974ef5", "filename": "src/test/compile-fail/cross-fn-cache-hole.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fcross-fn-cache-hole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fcross-fn-cache-hole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcross-fn-cache-hole.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -21,14 +21,15 @@ trait Foo<X,Y>: Bar<X> {\n \n trait Bar<X> { }\n \n-fn vacuous<A>()\n+// We don't always check where clauses for sanity, but in this case\n+// wfcheck does report an error here:\n+fn vacuous<A>() //~ ERROR the trait `Bar<u32>` is not implemented for the type `i32`\n     where i32: Foo<u32, A>\n {\n-    // vacuous could never be called, because it requires that i32:\n-    // Bar<u32>. But the code doesn't check that this could never be\n-    // satisfied.\n+    // ... the original intention was to check that we don't use that\n+    // vacuous where clause (which could never be satisfied) to accept\n+    // the following line and then mess up calls elsewhere.\n     require::<i32, u32>();\n-    //~^ ERROR the trait `Bar<u32>` is not implemented for the type `i32`\n }\n \n fn require<A,B>()"}, {"sha": "1635a8f69a6cd2b481f91adf5c99402dfc6923d8", "filename": "src/test/compile-fail/issue-13853-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-13853-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-13853-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13853-2.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -10,7 +10,7 @@\n \n trait FromStructReader<'a> { }\n trait ResponseHook {\n-     fn get<'a, T: FromStructReader<'a>>(&'a self);\n+     fn get(&self);\n }\n fn foo(res : Box<ResponseHook>) { res.get } //~ ERROR attempted to take value of method\n fn main() {}"}, {"sha": "7643310298da3d84c4e001caefc8d7e52422da53", "filename": "src/test/compile-fail/issue-13853.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -13,11 +13,14 @@ trait Node {\n }\n \n trait Graph<N: Node> {\n-    fn nodes<'a, I: Iterator<Item=&'a N>>(&'a self) -> I;\n+    fn nodes<'a, I: Iterator<Item=&'a N>>(&'a self) -> I\n+        where N: 'a;\n }\n \n impl<N: Node> Graph<N> for Vec<N> {\n-    fn nodes<'a, I: Iterator<Item=&'a N>>(&self) -> I {\n+    fn nodes<'a, I: Iterator<Item=&'a N>>(&self) -> I\n+        where N: 'a\n+    {\n         self.iter() //~ ERROR mismatched types\n     }\n }"}, {"sha": "c6c1a0fd17781ab1209e1a4923073f294e043ba9", "filename": "src/test/compile-fail/issue-14853.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -12,7 +12,7 @@ use std::fmt::Debug;\n \n trait Str {}\n \n-trait Something {\n+trait Something: Sized {\n     fn yay<T: Debug>(_: Option<Self>, thing: &[T]);\n }\n "}, {"sha": "7a6d012a3b6054197879a581b577807953ef9e24", "filename": "src/test/compile-fail/issue-18959.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-18959.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-18959.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18959.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -19,14 +19,12 @@ impl Foo for Thing {\n \n #[inline(never)]\n fn foo(b: &Bar) {\n+    //~^ ERROR E0038\n     b.foo(&0)\n-    //~^ ERROR the trait `Foo` is not implemented for the type `Bar`\n-    //~| ERROR E0038\n-    //~| WARNING E0038\n }\n \n fn main() {\n     let mut thing = Thing;\n-    let test: &Bar = &mut thing; //~ ERROR E0038\n+    let test: &Bar = &mut thing;\n     foo(test);\n }"}, {"sha": "322952ffef1e68aeca87fef0b0118e94adea117e", "filename": "src/test/compile-fail/issue-19380.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-19380.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-19380.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19380.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -19,10 +19,10 @@ impl Qiz for Foo {\n \n struct Bar {\n   foos: &'static [&'static (Qiz + 'static)]\n+//~^ ERROR E0038\n }\n \n const FOO : Foo = Foo;\n const BAR : Bar = Bar { foos: &[&FOO]};\n-//~^ ERROR E0038\n \n fn main() { }"}, {"sha": "aaf27ba527b18fb936fa49db9a246dd4bc4f380e", "filename": "src/test/compile-fail/issue-20005.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-20005.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-20005.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20005.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -15,13 +15,10 @@ trait From<Src> {\n }\n \n trait To {\n-    fn to<Dst>(\n-        self //~ error: the trait `core::marker::Sized` is not implemented\n+    fn to<Dst>(  //~ ERROR the trait `core::marker::Sized` is not implemented\n+        self\n     ) -> <Dst as From<Self>>::Result where Dst: From<Self> {\n-        From::from( //~ error: the trait `core::marker::Sized` is not implemented\n-            //~^ ERROR E0277\n-            self\n-        )\n+        From::from(self)\n     }\n }\n "}, {"sha": "3f96a9c342283d0678db124b5d7bfe0e4ca200bc", "filename": "src/test/compile-fail/issue-20831-debruijn.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-20831-debruijn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-20831-debruijn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20831-debruijn.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -38,6 +38,8 @@ impl<'a> Publisher<'a> for MyStruct<'a> {\n     fn subscribe(&mut self, t : Box<Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n         // Not obvious, but there is an implicit lifetime here -------^\n         //~^^ ERROR cannot infer\n+        //~|  ERROR cannot infer\n+        //~|  ERROR cannot infer\n         //\n         // The fact that `Publisher` is using an implicit lifetime is\n         // what was causing the debruijn accounting to be off, so"}, {"sha": "6ddfa4c8e3e57c5473b070716e04217b652f7e6f", "filename": "src/test/compile-fail/issue-21974.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-21974.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-21974.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21974.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -17,11 +17,11 @@ trait Foo {\n     fn foo(self);\n }\n \n-fn foo<'a,'b,T>(x: &'a T, y: &'b T)\n+fn foo<'a,'b,T>(x: &'a T, y: &'b T) //~ ERROR type annotations required\n     where &'a T : Foo,\n           &'b T : Foo\n {\n-    x.foo(); //~ ERROR type annotations required\n+    x.foo();\n     y.foo();\n }\n "}, {"sha": "1a9bb4c29f3e0183ad2f0a6a0cf45e5dd44f0214", "filename": "src/test/compile-fail/issue-23041.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-23041.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-23041.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23041.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -13,5 +13,5 @@ fn main()\n {\n     fn bar(x:i32) ->i32 { 3*x };\n     let b:Box<Any> = Box::new(bar as fn(_)->_);\n-    b.downcast_ref::<fn(_)->_>(); //~ ERROR E0101\n+    b.downcast_ref::<fn(_)->_>(); //~ ERROR E0282\n }"}, {"sha": "4acb1f70d343c459825c7a6422755d9623b3aac4", "filename": "src/test/compile-fail/issue-23305.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-23305.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-23305.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23305.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -13,6 +13,6 @@ pub trait ToNbt<T> {\n }\n \n impl ToNbt<Self> {} //~ ERROR use of `Self` outside of an impl or trait\n-//~^ WARNING the trait `ToNbt` cannot be made into an object\n+//~^ ERROR the trait `ToNbt` cannot be made into an object\n \n fn main() {}"}, {"sha": "130647966f2d126760c07c634889ee17209b80cb", "filename": "src/test/compile-fail/issue-3907-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-3907-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fissue-3907-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3907-2.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -18,6 +18,6 @@ struct S {\n }\n \n fn bar(_x: Foo) {}\n-//~^ ERROR E0277\n+//~^ ERROR E0038\n \n fn main() {}"}, {"sha": "341736f7ab5ee8c938539b8f48dc2282ac46861b", "filename": "src/test/compile-fail/object-safety-generics.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -22,16 +22,13 @@ trait Quux {\n }\n \n fn make_bar<T:Bar>(t: &T) -> &Bar {\n-    t\n         //~^ ERROR E0038\n         //~| NOTE method `bar` has generic type parameters\n+    t\n }\n \n fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n     t as &Bar\n-        //~^ ERROR E0038\n-        //~| NOTE method `bar` has generic type parameters\n-        //~| ERROR E0038\n }\n \n fn make_quux<T:Quux>(t: &T) -> &Quux {"}, {"sha": "edd31c1f79649fe98c89f8bc6b5e80f61c0a69eb", "filename": "src/test/compile-fail/object-safety-mentions-Self.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fobject-safety-mentions-Self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fobject-safety-mentions-Self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-mentions-Self.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -25,29 +25,15 @@ trait Quux {\n }\n \n fn make_bar<T:Bar>(t: &T) -> &Bar {\n-    t\n-        //~^ ERROR E0038\n-        //~| NOTE method `bar` references the `Self` type in its arguments or return type\n-}\n-\n-fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n-    t as &Bar\n         //~^ ERROR E0038\n         //~| NOTE method `bar` references the `Self` type in its arguments or return type\n-        //~| ERROR E0038\n+    loop { }\n }\n \n fn make_baz<T:Baz>(t: &T) -> &Baz {\n-    t\n         //~^ ERROR E0038\n         //~| NOTE method `bar` references the `Self` type in its arguments or return type\n-}\n-\n-fn make_baz_explicit<T:Baz>(t: &T) -> &Baz {\n-    t as &Baz\n-        //~^ ERROR E0038\n-        //~| NOTE method `bar` references the `Self` type in its arguments or return type\n-        //~| ERROR E0038\n+    t\n }\n \n fn make_quux<T:Quux>(t: &T) -> &Quux {"}, {"sha": "dd1d5af3f4a128a6db005b6fab2d17d2724b0bda", "filename": "src/test/compile-fail/object-safety-no-static.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fobject-safety-no-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fobject-safety-no-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-no-static.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -16,16 +16,8 @@ trait Foo {\n }\n \n fn foo_implicit<T:Foo+'static>(b: Box<T>) -> Box<Foo+'static> {\n-    b\n-        //~^ ERROR E0038\n-        //~| NOTE method `foo` has no receiver\n-}\n-\n-fn foo_explicit<T:Foo+'static>(b: Box<T>) -> Box<Foo+'static> {\n-    b as Box<Foo>\n-        //~^ ERROR E0038\n-        //~| NOTE method `foo` has no receiver\n-        //~| ERROR E0038\n+    //~^ ERROR E0038\n+    loop { }\n }\n \n fn main() {"}, {"sha": "3e1942d5a01884467d5ae54fed17430553dd0351", "filename": "src/test/compile-fail/object-safety-sized-2.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized-2.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -18,16 +18,8 @@ trait Bar\n }\n \n fn make_bar<T:Bar>(t: &T) -> &Bar {\n-    t\n         //~^ ERROR E0038\n-        //~| NOTE the trait cannot require that `Self : Sized`\n-}\n-\n-fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n-    t as &Bar\n-        //~^ ERROR E0038\n-        //~| NOTE the trait cannot require that `Self : Sized`\n-        //~| ERROR E0038\n+    loop { }\n }\n \n fn main() {"}, {"sha": "501d61d20fed124453edb3b2bad2050c71f7d273", "filename": "src/test/compile-fail/object-safety-sized.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-sized.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -16,16 +16,9 @@ trait Bar : Sized {\n }\n \n fn make_bar<T:Bar>(t: &T) -> &Bar {\n-    t\n-        //~^ ERROR E0038\n-        //~| NOTE the trait cannot require that `Self : Sized`\n-}\n-\n-fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n-    t as &Bar\n         //~^ ERROR E0038\n         //~| NOTE the trait cannot require that `Self : Sized`\n-        //~| ERROR E0038\n+    t\n }\n \n fn main() {"}, {"sha": "152c65cb69bf24b7f3a5aa1076ddd411fad4b03a", "filename": "src/test/compile-fail/regions-close-object-into-object-5.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-5.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -26,10 +26,10 @@ fn f<'a, T, U>(v: Box<A<T>+'static>) -> Box<X+'static> {\n     // oh dear!\n     box B(&*v) as Box<X>\n         //~^ ERROR the parameter type `T` may not live long enough\n-        //~| WARNING the parameter type `T` may not live long enough\n-        //~| WARNING the parameter type `T` may not live long enough\n         //~| ERROR the parameter type `T` may not live long enough\n-        //~| WARNING the parameter type `T` may not live long enough\n+        //~| ERROR the parameter type `T` may not live long enough\n+        //~| ERROR the parameter type `T` may not live long enough\n+        //~| ERROR the parameter type `T` may not live long enough\n         //~| ERROR the parameter type `T` may not live long enough\n         //~| ERROR the parameter type `T` may not live long enough\n }"}, {"sha": "bd31d1a5a90dc02189a9aced713dbb59730f8199", "filename": "src/test/compile-fail/regions-free-region-ordering-callee-4.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee-4.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that callees correctly infer an ordering between free regions\n+// that appear in their parameter list.  See also\n+// regions-free-region-ordering-caller.rs\n+\n+fn ordering4<'a, 'b, F>(a: &'a usize, b: &'b usize, x: F) where F: FnOnce(&'a &'b usize) {\n+    //~^ ERROR reference has a longer lifetime than the data it references\n+    // Do not infer ordering from closure argument types.\n+    let z: Option<&'a &'b usize> = None;\n+}\n+\n+fn main() {}"}, {"sha": "1893395e2b0079e480edad4b4a6c0963e1b3b707", "filename": "src/test/compile-fail/regions-free-region-ordering-callee.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -30,11 +30,7 @@ fn ordering3<'a, 'b>(x: &'a usize, y: &'b usize) -> &'a &'b usize {\n     panic!();\n }\n \n-fn ordering4<'a, 'b, F>(a: &'a usize, b: &'b usize, x: F) where F: FnOnce(&'a &'b usize) {\n-    // Do not infer ordering from closure argument types.\n-    let z: Option<&'a &'b usize> = None;\n-    //~^ ERROR reference has a longer lifetime than the data it references\n-}\n+// see regions-free-region-ordering-callee-4.rs\n \n fn ordering5<'a, 'b>(a: &'a usize, b: &'b usize, x: Option<&'a &'b usize>) {\n     let z: Option<&'a &'b usize> = None;"}, {"sha": "fd186d16559162b214001b548fc5b11301c10c82", "filename": "src/test/compile-fail/regions-implied-bounds-projection-gap-hr-1.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fregions-implied-bounds-projection-gap-hr-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fregions-implied-bounds-projection-gap-hr-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-implied-bounds-projection-gap-hr-1.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -24,16 +24,13 @@ trait Trait2<'a, 'b> {\n     type Foo;\n }\n \n-fn wf<T>() { }\n-\n-// As a side-effect of the conservative process above, this argument\n-// is not automatically considered well-formed, since for it to be WF,\n-// we would need to know that `'y: 'x`, but we do not infer that.\n-fn callee<'x, 'y, T>(\n-    t: &'x for<'z> Trait1< <T as Trait2<'y, 'z>>::Foo >)\n-{\n-    wf::<&'x &'y i32>();\n+// As a side-effect of the conservative process above, the type of\n+// this argument `t` is not automatically considered well-formed,\n+// since for it to be WF, we would need to know that `'y: 'x`, but we\n+// do not infer that.\n+fn callee<'x, 'y, T>(t: &'x for<'z> Trait1< <T as Trait2<'y, 'z>>::Foo >)\n     //~^ ERROR reference has a longer lifetime than the data it references\n+{\n }\n \n fn main() { }"}, {"sha": "40b715cf3b14d7ac4dfa59c338ed8aaebef32900", "filename": "src/test/compile-fail/regions-wf-trait-object.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fregions-wf-trait-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fregions-wf-trait-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-wf-trait-object.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -14,8 +14,7 @@\n trait TheTrait<'t>: 't { }\n \n struct Foo<'a,'b> {\n-    x: Box<TheTrait<'a>+'b>\n-        //~^ ERROR reference has a longer lifetime\n+    x: Box<TheTrait<'a>+'b> //~ ERROR E0478\n }\n \n fn main() { }"}, {"sha": "50fd3fc961c1d808fa9e98147b594cb07bdcb5bf", "filename": "src/test/compile-fail/rfc1214-warn-and-error.rs", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Fcompile-fail%2Frfc1214-warn-and-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Fcompile-fail%2Frfc1214-warn-and-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc1214-warn-and-error.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -1,37 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that an RFC1214 warning from an earlier function (`foo`) does\n-// not suppress an error for the same problem (`WantEq<NotEq>`,\n-// `NotEq: !Eq`) in a later function (`bar)`. Earlier versions of the\n-// warning mechanism had an issue due to caching.\n-\n-#![allow(dead_code)]\n-#![allow(unused_variables)]\n-\n-struct WantEq<T:Eq> { t: T }\n-\n-struct NotEq;\n-\n-trait Trait<T> { }\n-\n-fn foo() {\n-    let x: Box<Trait<WantEq<NotEq>>> = loop { };\n-    //~^ WARN E0277\n-}\n-\n-fn bar() {\n-    wf::<WantEq<NotEq>>();\n-    //~^ ERROR E0277\n-}\n-\n-fn wf<T>() { }\n-\n-fn main() { }"}, {"sha": "01910939a80ebd6af13a30eb67a4e1a4646e0438", "filename": "src/test/compile-fail/trait-bounds-impl-comparison-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-2.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -14,7 +14,7 @@ trait Iterator<A> {\n     fn next(&mut self) -> Option<A>;\n }\n \n-trait IteratorUtil<A>\n+trait IteratorUtil<A>: Sized\n {\n     fn zip<B, U: Iterator<U>>(self, other: U) -> ZipIterator<Self, U>;\n }"}, {"sha": "2d4df77f960452a126928ce40ee05fb108324012", "filename": "src/test/compile-fail/trait-test-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -22,5 +22,4 @@ fn main() {\n     //~^ ERROR E0038\n     //~| ERROR E0038\n     //~| ERROR E0277\n-    //~| WARNING E0038\n }"}, {"sha": "ad58ae92b46e2139eadfde8c3881550d16f61ff3", "filename": "src/test/compile-fail/typeck-default-trait-impl-trait-where-clause-2.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-trait-where-clause-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-trait-where-clause-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-trait-where-clause-2.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+// Test that when a `..` impl applies, we also check that any\n+// supertrait conditions are met.\n+\n+#![feature(optin_builtin_traits)]\n+\n+trait NotImplemented { }\n+\n+trait MyTrait: Sized\n+    where Option<Self> : NotImplemented\n+{}\n+\n+impl NotImplemented for i32 {}\n+\n+impl MyTrait for .. {}\n+\n+fn bar<T:NotImplemented>() { }\n+\n+fn test() {\n+    bar::<Option<i32>>();\n+    //~^ ERROR the trait `NotImplemented` is not implemented for the type `core::option::Option<i32>`\n+}\n+\n+fn main() {\n+}"}, {"sha": "ff8fbd49574917f78aac78c181fc5032a2aea6e0", "filename": "src/test/compile-fail/typeck-default-trait-impl-trait-where-clause.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-trait-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-trait-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-trait-where-clause.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -17,7 +17,7 @@\n \n trait NotImplemented { }\n \n-trait MyTrait\n+trait MyTrait: Sized\n     where Option<Self> : NotImplemented\n {}\n \n@@ -26,20 +26,11 @@ impl NotImplemented for i32 {}\n impl MyTrait for .. {}\n \n fn foo<T:MyTrait>() {\n-    bar::<Option<T>>()\n     //~^ ERROR the trait `NotImplemented` is not implemented for the type `core::option::Option<T>`\n-    //\n     // This should probably typecheck. This is #20671.\n }\n \n fn bar<T:NotImplemented>() { }\n \n-fn test() {\n-    bar::<Option<i32>>();\n-    //~^ ERROR the trait `NotImplemented` is not implemented for the type `core::option::Option<i32>`\n-}\n-\n fn main() {\n-    foo::<u32>();\n-    //~^ ERROR the trait `NotImplemented` is not implemented for the type `core::option::Option<u32>`\n }"}, {"sha": "fe61dee23bc2a03d04f63613132160f78766edc3", "filename": "src/test/compile-fail/variance-invariant-self-trait-match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-self-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-self-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-self-trait-match.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -15,13 +15,13 @@ trait Get {\n }\n \n fn get_min_from_max<'min, 'max, G>()\n-    where 'max : 'min, &'max G : Get\n+    where 'max : 'min, &'max G : Get, G : 'max\n {\n     impls_get::<&'min G>(); //~ ERROR mismatched types\n }\n \n fn get_max_from_min<'min, 'max, G>()\n-    where 'max : 'min, &'min G : Get\n+    where 'max : 'min, &'min G : Get, G : 'min\n {\n     impls_get::<&'max G>(); //~ ERROR mismatched types\n }"}, {"sha": "946341a1a75bb7d0dae60c4ce7ed6c47a04f5ae5", "filename": "src/test/compile-fail/wf-array-elem-sized.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-array-elem-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-array-elem-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-array-elem-sized.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -14,8 +14,8 @@\n #![allow(dead_code)]\n \n struct Foo {\n-    foo: [[u8]], //~ WARN E0277\n+    foo: [[u8]], //~ ERROR E0277\n }\n \n #[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }"}, {"sha": "e3e79fdd940af47cc88842fb0efb45a6b355fe09", "filename": "src/test/compile-fail/wf-enum-bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-enum-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-enum-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-enum-bound.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -16,11 +16,11 @@\n \n trait ExtraCopy<T:Copy> { }\n \n-enum SomeEnum<T,U> //~ WARN E0277\n+enum SomeEnum<T,U> //~ ERROR E0277\n     where T: ExtraCopy<U>\n {\n     SomeVariant(T,U)\n }\n \n #[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }"}, {"sha": "3ed9e5d9f1eb58123a5551b9bb75a29cbad3dfa7", "filename": "src/test/compile-fail/wf-fn-where-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-fn-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-fn-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-fn-where-clause.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -16,9 +16,9 @@\n \n trait ExtraCopy<T:Copy> { }\n \n-fn foo<T,U>() where T: ExtraCopy<U> //~ WARN E0277\n+fn foo<T,U>() where T: ExtraCopy<U> //~ ERROR E0277\n {\n }\n \n #[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }"}, {"sha": "a319b676eeb880cf660434e616a5e7212ad60638", "filename": "src/test/compile-fail/wf-impl-associated-type-region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-impl-associated-type-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-impl-associated-type-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-impl-associated-type-region.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -17,8 +17,8 @@ pub trait Foo<'a> {\n }\n \n impl<'a, T> Foo<'a> for T {\n-    type Bar = &'a T; //~ WARN E0309\n+    type Bar = &'a T; //~ ERROR E0309\n }\n \n #[rustc_error]\n-fn main() { } //~ ERROR compilation\n+fn main() { }"}, {"sha": "ba31de98e7f95186f7bb54d11fa222ce70f1d945", "filename": "src/test/compile-fail/wf-impl-associated-type-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-impl-associated-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-impl-associated-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-impl-associated-type-trait.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -25,9 +25,9 @@ pub trait Foo {\n \n impl<T> Foo for T {\n     type Bar = MySet<T>;\n-    //~^ WARN the trait `MyHash` is not implemented for the type `T`\n+    //~^ ERROR the trait `MyHash` is not implemented for the type `T`\n }\n \n #[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }\n "}, {"sha": "8e3bca09758139ac179680b3ca2ddfa771ef01eb", "filename": "src/test/compile-fail/wf-in-fn-type-static.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-type-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-type-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-type-static.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -20,13 +20,13 @@ struct MustBeCopy<T:Copy> {\n \n struct Foo<T> {\n     // needs T: 'static\n-    x: fn() -> &'static T //~ WARN E0310\n+    x: fn() -> &'static T //~ ERROR E0310\n }\n \n struct Bar<T> {\n     // needs T: Copy\n-    x: fn(&'static T) //~ WARN E0310\n+    x: fn(&'static T) //~ ERROR E0310\n }\n \n #[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }"}, {"sha": "c2f66a2a460c5690c72905c93b65771aabb73173", "filename": "src/test/compile-fail/wf-in-fn-where-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-in-fn-where-clause.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -16,10 +16,10 @@\n trait MustBeCopy<T:Copy> {\n }\n \n-fn bar<T,U>() //~ WARN E0277\n+fn bar<T,U>() //~ ERROR E0277\n     where T: MustBeCopy<U>\n {\n }\n \n #[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }"}, {"sha": "11535fb9f9e45685a710d2ac452f4ca4481cf19a", "filename": "src/test/compile-fail/wf-in-obj-type-static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-in-obj-type-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-in-obj-type-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-in-obj-type-static.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -21,8 +21,8 @@ struct MustBeCopy<T:Copy> {\n \n struct Foo<T> {\n     // needs T: 'static\n-    x: Object<&'static T> //~ WARN E0310\n+    x: Object<&'static T> //~ ERROR E0310\n }\n \n #[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }"}, {"sha": "78e12c47e24debc7b8f631ece604c86003d5783d", "filename": "src/test/compile-fail/wf-inherent-impl-method-where-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-inherent-impl-method-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-inherent-impl-method-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-inherent-impl-method-where-clause.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -19,9 +19,9 @@ trait ExtraCopy<T:Copy> { }\n struct Foo<T,U>(T,U);\n \n impl<T,U> Foo<T,U> {\n-    fn foo(self) where T: ExtraCopy<U> //~ WARN E0277\n+    fn foo(self) where T: ExtraCopy<U> //~ ERROR E0277\n     {}\n }\n \n #[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }"}, {"sha": "7edbb11e245200270033c8db2d6446d0867cfce0", "filename": "src/test/compile-fail/wf-inherent-impl-where-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-inherent-impl-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-inherent-impl-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-inherent-impl-where-clause.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -18,9 +18,9 @@ trait ExtraCopy<T:Copy> { }\n \n struct Foo<T,U>(T,U);\n \n-impl<T,U> Foo<T,U> where T: ExtraCopy<U> //~ WARN E0277\n+impl<T,U> Foo<T,U> where T: ExtraCopy<U> //~ ERROR E0277\n {\n }\n \n #[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }"}, {"sha": "c11b2e4c544e1fd524f25affa77fe82a637c2fed", "filename": "src/test/compile-fail/wf-outlives-ty-in-fn-or-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-outlives-ty-in-fn-or-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-outlives-ty-in-fn-or-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-outlives-ty-in-fn-or-trait.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -19,14 +19,14 @@ trait Trait<T> { }\n \n struct Foo<'a,T> {\n     f: &'a fn(T),\n-    //~^ WARN E0309\n+    //~^ ERROR E0309\n }\n \n struct Bar<'a,T> {\n     f: &'a Trait<T>,\n-    //~^ WARN E0309\n+    //~^ ERROR E0309\n }\n \n #[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }\n "}, {"sha": "e263b251aa379eb58bf5f12a21ebd7a1d47bf20b", "filename": "src/test/compile-fail/wf-struct-bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-struct-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-struct-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-struct-bound.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -16,11 +16,11 @@\n \n trait ExtraCopy<T:Copy> { }\n \n-struct SomeStruct<T,U> //~ WARN E0277\n+struct SomeStruct<T,U> //~ ERROR E0277\n     where T: ExtraCopy<U>\n {\n     data: (T,U)\n }\n \n #[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }"}, {"sha": "8420edd66a1809dcaa92f1fe5448fe09b43d518b", "filename": "src/test/compile-fail/wf-trait-associated-type-bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-associated-type-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-associated-type-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-associated-type-bound.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -16,9 +16,9 @@\n \n trait ExtraCopy<T:Copy> { }\n \n-trait SomeTrait<T> { //~ WARN E0277\n+trait SomeTrait<T> { //~ ERROR E0277\n     type Type1: ExtraCopy<T>;\n }\n \n #[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }"}, {"sha": "95d9ffdf9d35958782c0ab8ad105aa2dfc6f5021", "filename": "src/test/compile-fail/wf-trait-associated-type-region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-associated-type-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-associated-type-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-associated-type-region.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -17,8 +17,8 @@\n trait SomeTrait<'a> {\n     type Type1;\n     type Type2 = &'a Self::Type1;\n-    //~^ WARN E0309\n+    //~^ ERROR E0309\n }\n \n #[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }"}, {"sha": "902cbe2676b06a5995ccd67137a695831c1ec096", "filename": "src/test/compile-fail/wf-trait-associated-type-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-associated-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-associated-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-associated-type-trait.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -19,8 +19,8 @@ struct IsCopy<T:Copy> { x: T }\n trait SomeTrait {\n     type Type1;\n     type Type2 = IsCopy<Self::Type1>;\n-    //~^ WARN E0277\n+    //~^ ERROR E0277\n }\n \n #[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }"}, {"sha": "ca15a6ab648630d17c15f2502463fa1c7ec80ae8", "filename": "src/test/compile-fail/wf-trait-bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-bound.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -16,10 +16,10 @@\n \n trait ExtraCopy<T:Copy> { }\n \n-trait SomeTrait<T,U> //~ WARN E0277\n+trait SomeTrait<T,U> //~ ERROR E0277\n     where T: ExtraCopy<U>\n {\n }\n \n #[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }"}, {"sha": "453aa2428ce5d1ee94dcf0f5236e524a15ea4970", "filename": "src/test/compile-fail/wf-trait-default-fn-arg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-default-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-default-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-default-fn-arg.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -19,11 +19,11 @@ struct Bar<T:Eq+?Sized> { value: Box<T> }\n \n trait Foo {\n     fn bar(&self, x: &Bar<Self>) {\n-        //~^ WARN E0277\n+        //~^ ERROR E0277\n         //\n         // Here, Eq ought to be implemented.\n     }\n }\n \n #[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }"}, {"sha": "d94708d3e06a557305a48f7e7abe8722ef71c8cf", "filename": "src/test/compile-fail/wf-trait-default-fn-ret.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-default-fn-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-default-fn-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-default-fn-ret.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -19,12 +19,11 @@ struct Bar<T:Eq+?Sized> { value: Box<T> }\n \n trait Foo {\n     fn bar(&self) -> Bar<Self> {\n-        //~^ WARN E0277\n+        //~^ ERROR E0277\n         //\n         // Here, Eq ought to be implemented.\n         loop { }\n     }\n }\n \n-#[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }"}, {"sha": "29c85250583c7900c8d90875bc9711b83cc7d674", "filename": "src/test/compile-fail/wf-trait-default-fn-where-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-default-fn-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-default-fn-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-default-fn-where-clause.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -19,11 +19,11 @@ trait Bar<T:Eq+?Sized> { }\n \n trait Foo {\n     fn bar<A>(&self) where A: Bar<Self> {\n-        //~^ WARN E0277\n+        //~^ ERROR E0277\n         //\n         // Here, Eq ought to be implemented.\n     }\n }\n \n #[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }"}, {"sha": "d88e36faeec600578eda6a43a06d068284929b5d", "filename": "src/test/compile-fail/wf-trait-fn-arg.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-fn-arg.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -18,10 +18,9 @@ struct Bar<T:Eq+?Sized> { value: Box<T> }\n \n trait Foo {\n     fn bar(&self, x: &Bar<Self>);\n-        //~^ WARN E0277\n+        //~^ ERROR E0277\n         //\n         // Here, Eq ought to be implemented.\n }\n \n-#[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }"}, {"sha": "c368ff9a4a82dbf3bb99a3c6f49d5a952eae37dc", "filename": "src/test/compile-fail/wf-trait-fn-ret.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-fn-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-fn-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-fn-ret.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -18,10 +18,9 @@ struct Bar<T:Eq+?Sized> { value: Box<T> }\n \n trait Foo {\n     fn bar(&self) -> &Bar<Self>;\n-        //~^ WARN E0277\n+        //~^ ERROR E0277\n         //\n         // Here, Eq ought to be implemented.\n }\n \n-#[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }"}, {"sha": "f59dca93bb90a72e292fdea49289cad5fc8b2671", "filename": "src/test/compile-fail/wf-trait-fn-where-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-fn-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-fn-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-fn-where-clause.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -18,10 +18,10 @@ struct Bar<T:Eq+?Sized> { value: Box<T> }\n \n trait Foo {\n     fn bar(&self) where Bar<Self>: Copy;\n-        //~^ WARN E0277\n+        //~^ ERROR E0277\n         //\n         // Here, Eq ought to be implemented.\n }\n \n #[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }"}, {"sha": "ea8b2fdf3a14766ad28dbb0d09a8fdf3ac49864f", "filename": "src/test/compile-fail/wf-trait-superbound.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-superbound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Fcompile-fail%2Fwf-trait-superbound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-trait-superbound.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -16,8 +16,7 @@\n \n trait ExtraCopy<T:Copy> { }\n \n-trait SomeTrait<T>: ExtraCopy<T> { //~ WARN E0277\n+trait SomeTrait<T>: ExtraCopy<T> { //~ ERROR E0277\n }\n \n-#[rustc_error]\n-fn main() { } //~ ERROR compilation successful\n+fn main() { }"}, {"sha": "b6d84f9d5a24022dd865f999d15fd0899b38ae03", "filename": "src/test/run-pass/cycle-generic-bound.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Fcycle-generic-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Fcycle-generic-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-generic-bound.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -15,4 +15,6 @@\n trait Chromosome<X: Chromosome<i32>> {\n }\n \n+impl Chromosome<i32> for i32 { }\n+\n fn main() { }"}, {"sha": "4ae5c599b43ddeb5e71b4bfc0c819c8a9010db04", "filename": "src/test/run-pass/cycle-trait-type-trait.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Fcycle-trait-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Fcycle-trait-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-trait-type-trait.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -22,4 +22,12 @@ trait Get<A> {\n \n struct Struct<C:Chromosome> { c: C }\n \n+impl Chromosome for i32 { }\n+\n+impl Get<Struct<i32>> for i32 {\n+    fn get(&self) -> Struct<i32> {\n+        Struct { c: *self }\n+    }\n+}\n+\n fn main() { }"}, {"sha": "820872ad3fc501b84f6006d43abe9f9e470dd992", "filename": "src/test/run-pass/issue-25810.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Fissue-25810.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Fissue-25810.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-25810.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -14,7 +14,9 @@ fn main() {\n     println!(\"{:?}\",y);\n }\n \n-trait Foo {\n+trait Foo\n+    where for<'a> &'a Self: Bar\n+{\n     fn foo<'a>(&'a self) -> <&'a Self as Bar>::Output;\n }\n "}, {"sha": "e0d2f13ad6899daabf21850561463fc224940094", "filename": "src/test/run-pass/issue-6898.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Fissue-6898.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Fissue-6898.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6898.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -22,7 +22,7 @@ pub fn size_of_val<T>(val: &T) -> usize {\n     val.size_of_val()\n }\n \n-pub trait TypeInfo {\n+pub trait TypeInfo: Sized {\n     fn size_of(_lame_type_hint: Option<Self>) -> usize;\n     fn size_of_val(&self) -> usize;\n }"}, {"sha": "b6815d929678a6bd0c7cd1b73fde3cf26429df1b", "filename": "src/test/run-pass/regions-issue-22246.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Fregions-issue-22246.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Fregions-issue-22246.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-issue-22246.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -17,7 +17,7 @@\n \n use std::ops::Deref;\n \n-pub trait ToOwned {\n+pub trait ToOwned: Sized {\n     type Owned: Borrow<Self>;\n     fn to_owned(&self) -> Self::Owned;\n }"}, {"sha": "c339be25f8bb3fb35f2114765709b26ca4db23ed", "filename": "src/test/run-pass/regions-no-variance-from-fn-generics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Fregions-no-variance-from-fn-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Fregions-no-variance-from-fn-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-no-variance-from-fn-generics.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -22,7 +22,7 @@ trait UseLife01 {\n }\n \n trait UseLife02 {\n-    fn refs<'a, T, H: HasType<&'a T>>(&'a self) -> H;\n+    fn refs<'a, T: 'a, H: HasType<&'a T>>(&'a self) -> H;\n }\n \n \n@@ -33,7 +33,7 @@ pub trait HasType<T>\n \n \n trait UseLife03<T> {\n-    fn refs<'a, H: HasType<&'a T>>(&'a self) -> H;\n+    fn refs<'a, H: HasType<&'a T>>(&'a self) -> H where T: 'a;\n }\n \n \n@@ -45,7 +45,7 @@ pub fn top_refs_1<'a, H: HasLife<'a>>(_s: &'a ()) -> H {\n     unimplemented!()\n }\n \n-pub fn top_refs_2<'a, T, H: HasType<&'a T>>(_s: &'a ()) -> H {\n+pub fn top_refs_2<'a, T: 'a, H: HasType<&'a T>>(_s: &'a ()) -> H {\n     unimplemented!()\n }\n "}, {"sha": "70515a088e2de597ba2589d16806f43c702671c2", "filename": "src/test/run-pass/trait-inheritance-num0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -16,7 +16,7 @@\n \n use std::cmp::PartialOrd;\n \n-pub trait NumCast {\n+pub trait NumCast: Sized {\n     fn from(i: i32) -> Option<Self>;\n }\n "}, {"sha": "e21abdae730bcc433c80488a44779fcbd5127bb5", "filename": "src/test/run-pass/trait-inheritance-num1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -10,7 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-pub trait NumCast {\n+pub trait NumCast: Sized {\n     fn from(i: i32) -> Option<Self>;\n }\n "}, {"sha": "fb56ae82b303ee7fdc3ef20702e93ec89230d8cc", "filename": "src/test/run-pass/trait-inheritance-num3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub trait NumCast {\n+pub trait NumCast: Sized {\n     fn from(i: i32) -> Option<Self>;\n }\n "}, {"sha": "bd442629243ee03e8e02a70052f6e719454dfc25", "filename": "src/test/run-pass/trait-inheritance-num5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -10,7 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-pub trait NumCast {\n+pub trait NumCast: Sized {\n     fn from(i: i32) -> Option<Self>;\n }\n "}, {"sha": "e353be16b45e515e011b7862609277e895a90692", "filename": "src/test/run-pass/trait-inheritance-self-in-supertype.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Ftrait-inheritance-self-in-supertype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Ftrait-inheritance-self-in-supertype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-self-in-supertype.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -17,7 +17,7 @@ pub trait FuzzyEq<Eps> {\n     fn fuzzy_eq_eps(&self, other: &Self, epsilon: &Eps) -> bool;\n }\n \n-trait Float: FuzzyEq<Self> {\n+trait Float: Sized+FuzzyEq<Self> {\n     fn two_pi() -> Self;\n }\n "}, {"sha": "a025be5d651bc1f414b27504cc74c734c8722734", "filename": "src/test/run-pass/trait-inheritance-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Ftrait-inheritance-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Ftrait-inheritance-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-self.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -12,7 +12,7 @@ trait Foo<T> {\n     fn f(&self, x: &T);\n }\n \n-trait Bar : Foo<Self> {\n+trait Bar : Sized + Foo<Self> {\n     fn g(&self);\n }\n "}, {"sha": "73bb4bacf64e1b5b0ba18e6874b83db5c6b53c5b", "filename": "src/test/run-pass/trait-inheritance-subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Ftrait-inheritance-subst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Ftrait-inheritance-subst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-subst.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -13,7 +13,7 @@ pub trait Add<RHS,Result> {\n     fn add(&self, rhs: &RHS) -> Result;\n }\n \n-trait MyNum : Add<Self,Self> { }\n+trait MyNum : Sized + Add<Self,Self> { }\n \n struct MyInt { val: isize }\n "}, {"sha": "7d3ebc19e8f833663a12b99db5f71726080e943d", "filename": "src/test/run-pass/trait-inheritance-subst2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Ftrait-inheritance-subst2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Ftrait-inheritance-subst2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-subst2.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -17,7 +17,7 @@ trait Add<RHS,Result>: Panda<RHS> {\n     fn add(&self, rhs: &RHS) -> Result;\n }\n \n-trait MyNum : Add<Self,Self> { }\n+trait MyNum : Sized + Add<Self,Self> { }\n \n struct MyInt { val: isize }\n "}, {"sha": "5b9fa5230d1e0289f1df1aeb24b8562a3811d444", "filename": "src/test/run-pass/unsized2.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Funsized2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd29cc3107f7febc26ec56ed4149cd67c1f49d8/src%2Ftest%2Frun-pass%2Funsized2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized2.rs?ref=5dd29cc3107f7febc26ec56ed4149cd67c1f49d8", "patch": "@@ -67,26 +67,26 @@ fn f7<X: ?Sized+T3>(x: &X) {\n \n trait T4<X> {\n     fn dummy(&self) { }\n-    fn m1(x: &T4<X>, y: X);\n-    fn m2(x: &T5<X>, y: X);\n+    fn m1(&self, x: &T4<X>, y: X);\n+    fn m2(&self, x: &T5<X>, y: X);\n }\n trait T5<X: ?Sized> {\n     fn dummy(&self) { }\n     // not an error (for now)\n-    fn m1(x: &T4<X>);\n-    fn m2(x: &T5<X>);\n+    fn m1(&self, x: &T4<X>);\n+    fn m2(&self, x: &T5<X>);\n }\n \n trait T6<X: T> {\n     fn dummy(&self) { }\n-    fn m1(x: &T4<X>);\n-    fn m2(x: &T5<X>);\n+    fn m1(&self, x: &T4<X>);\n+    fn m2(&self, x: &T5<X>);\n }\n trait T7<X: ?Sized+T> {\n     fn dummy(&self) { }\n     // not an error (for now)\n-    fn m1(x: &T4<X>);\n-    fn m2(x: &T5<X>);\n+    fn m1(&self, x: &T4<X>);\n+    fn m2(&self, x: &T5<X>);\n }\n \n // The last field in a struct or variant may be unsized"}]}