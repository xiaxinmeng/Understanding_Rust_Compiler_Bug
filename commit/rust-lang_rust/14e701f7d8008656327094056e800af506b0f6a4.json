{"sha": "14e701f7d8008656327094056e800af506b0f6a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0ZTcwMWY3ZDgwMDg2NTYzMjcwOTQwNTZlODAwYWY1MDZiMGY2YTQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-17T12:23:21Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-17T14:02:57Z"}, "message": "abstract mapping over all the stacks in some memory range", "tree": {"sha": "05844d2316ae3744bbfcbffe689ea73cc981dab1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05844d2316ae3744bbfcbffe689ea73cc981dab1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14e701f7d8008656327094056e800af506b0f6a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14e701f7d8008656327094056e800af506b0f6a4", "html_url": "https://github.com/rust-lang/rust/commit/14e701f7d8008656327094056e800af506b0f6a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14e701f7d8008656327094056e800af506b0f6a4/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b7fef1b53dab72a6a61951e166851ffc7d4bc82", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b7fef1b53dab72a6a61951e166851ffc7d4bc82", "html_url": "https://github.com/rust-lang/rust/commit/7b7fef1b53dab72a6a61951e166851ffc7d4bc82"}], "stats": {"total": 83, "additions": 27, "deletions": 56}, "files": [{"sha": "7c0a72cde3c0a068cde2e25284ae907c1fbd33bd", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 27, "deletions": 56, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/14e701f7d8008656327094056e800af506b0f6a4/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e701f7d8008656327094056e800af506b0f6a4/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=14e701f7d8008656327094056e800af506b0f6a4", "patch": "@@ -492,7 +492,7 @@ impl<'tcx> Stack {\n }\n // # Stacked Borrows Core End\n \n-/// Higher-level per-location operations: deref, access, dealloc, reborrow.\n+/// Map per-stack operations to higher-level per-location-range operations.\n impl<'tcx> Stacks {\n     /// Creates new stack with initial tag.\n     pub(crate) fn new(\n@@ -510,61 +510,17 @@ impl<'tcx> Stacks {\n         }\n     }\n \n-    /// `ptr` got used, reflect that in the stack.\n-    fn access(\n-        &self,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-        access: AccessKind,\n-    ) -> EvalResult<'tcx> {\n-        trace!(\"{} access of tag {}: {:?}, size {}\", access, ptr.tag, ptr, size.bytes());\n-        // Even reads can have a side-effect, by invalidating other references.\n-        // This is fundamentally necessary since `&mut` asserts that there\n-        // are no accesses through other references, not even reads.\n-        let global = self.global.borrow();\n-        let mut stacks = self.stacks.borrow_mut();\n-        for stack in stacks.iter_mut(ptr.offset, size) {\n-            stack.access(access, ptr.tag, &*global)?;\n-        }\n-        Ok(())\n-    }\n-\n-    /// `ptr` is used to deallocate.\n-    fn dealloc(\n+    /// Call `f` on every stack in the range.\n+    fn for_each(\n         &self,\n         ptr: Pointer<Tag>,\n         size: Size,\n+        f: impl Fn(&mut Stack, Tag, &GlobalState) -> EvalResult<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"deallocation with tag {}: {:?}, size {}\", ptr.tag, ptr, size.bytes());\n-        // Even reads can have a side-effect, by invalidating other references.\n-        // This is fundamentally necessary since `&mut` asserts that there\n-        // are no accesses through other references, not even reads.\n         let global = self.global.borrow();\n         let mut stacks = self.stacks.borrow_mut();\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            stack.dealloc(ptr.tag, &*global)?;\n-        }\n-        Ok(())\n-    }\n-\n-    /// Reborrow the given pointer to the new tag for the given kind of reference.\n-    /// This works on `&self` because we might encounter references to constant memory.\n-    fn reborrow(\n-        &self,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-        barrier: Option<CallId>,\n-        new_perm: Permission,\n-        new_tag: Tag,\n-    ) -> EvalResult<'tcx> {\n-        trace!(\n-            \"reborrow tag {} as {:?} {}: {:?}, size {}\",\n-            ptr.tag, new_perm, new_tag, ptr, size.bytes(),\n-        );\n-        let global = self.global.borrow();\n-        let mut stacks = self.stacks.borrow_mut();\n-        for stack in stacks.iter_mut(ptr.offset, size) {\n-            stack.reborrow(ptr.tag, barrier, new_perm, new_tag, &*global)?;\n+            f(stack, ptr.tag, &*global)?;\n         }\n         Ok(())\n     }\n@@ -605,7 +561,11 @@ impl AllocationExtra<Tag> for Stacks {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        alloc.extra.access(ptr, size, AccessKind::Read)\n+        trace!(\"read access with tag {}: {:?}, size {}\", ptr.tag, ptr, size.bytes());\n+        alloc.extra.for_each(ptr, size, |stack, tag, global| {\n+            stack.access(AccessKind::Read, tag, global)?;\n+            Ok(())\n+        })\n     }\n \n     #[inline(always)]\n@@ -614,7 +574,11 @@ impl AllocationExtra<Tag> for Stacks {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        alloc.extra.access(ptr, size, AccessKind::Write)\n+        trace!(\"write access with tag {}: {:?}, size {}\", ptr.tag, ptr, size.bytes());\n+        alloc.extra.for_each(ptr, size, |stack, tag, global| {\n+            stack.access(AccessKind::Write, tag, global)?;\n+            Ok(())\n+        })\n     }\n \n     #[inline(always)]\n@@ -623,7 +587,10 @@ impl AllocationExtra<Tag> for Stacks {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        alloc.extra.dealloc(ptr, size)\n+        trace!(\"deallocation with tag {}: {:?}, size {}\", ptr.tag, ptr, size.bytes());\n+        alloc.extra.for_each(ptr, size, |stack, tag, global| {\n+            stack.dealloc(tag, global)\n+        })\n     }\n }\n \n@@ -642,8 +609,8 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         let this = self.eval_context_mut();\n         let barrier = if fn_barrier { Some(this.frame().extra) } else { None };\n         let ptr = place.ptr.to_ptr()?;\n-        trace!(\"reborrow: creating new reference for {:?} (pointee {}): {}, {:?}\",\n-            ptr, place.layout.ty, kind, new_tag);\n+        trace!(\"reborrow: {:?} reference {} derived from {} (pointee {}): {:?}, size {}\",\n+            kind, new_tag, ptr.tag, place.layout.ty, ptr, size.bytes());\n \n         // Get the allocation. It might not be mutable, so we cannot use `get_mut`.\n         let alloc = this.memory().get(ptr.alloc_id)?;\n@@ -659,12 +626,16 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 return this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n                     // We are only ever `SharedReadOnly` inside the frozen bits.\n                     let perm = if frozen { Permission::SharedReadOnly } else { Permission::SharedReadWrite };\n-                    alloc.extra.reborrow(cur_ptr, size, barrier, perm, new_tag)\n+                    alloc.extra.for_each(cur_ptr, size, |stack, tag, global| {\n+                        stack.reborrow(tag, barrier, perm, new_tag, global)\n+                    })\n                 });\n             }\n         };\n         debug_assert_ne!(perm, Permission::SharedReadOnly, \"SharedReadOnly must be used frozen-sensitive\");\n-        return alloc.extra.reborrow(ptr, size, barrier, perm, new_tag);\n+        alloc.extra.for_each(ptr, size, |stack, tag, global| {\n+            stack.reborrow(tag, barrier, perm, new_tag, global)\n+        })\n     }\n \n     /// Retags an indidual pointer, returning the retagged version."}]}