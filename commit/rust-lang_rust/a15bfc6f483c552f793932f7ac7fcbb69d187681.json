{"sha": "a15bfc6f483c552f793932f7ac7fcbb69d187681", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExNWJmYzZmNDgzYzU1MmY3OTM5MzJmN2FjN2ZjYmI2OWQxODc2ODE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-12-21T15:10:21Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: merge PrintCx::parameterized and def_path printing.", "tree": {"sha": "6547c71ccaf526b15a413b46ef3708a88d850b14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6547c71ccaf526b15a413b46ef3708a88d850b14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a15bfc6f483c552f793932f7ac7fcbb69d187681", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a15bfc6f483c552f793932f7ac7fcbb69d187681", "html_url": "https://github.com/rust-lang/rust/commit/a15bfc6f483c552f793932f7ac7fcbb69d187681", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a15bfc6f483c552f793932f7ac7fcbb69d187681/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0fbca953fbdcef5e561a97e5936db0dd13c41d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0fbca953fbdcef5e561a97e5936db0dd13c41d2", "html_url": "https://github.com/rust-lang/rust/commit/b0fbca953fbdcef5e561a97e5936db0dd13c41d2"}], "stats": {"total": 806, "additions": 473, "deletions": 333}, "files": [{"sha": "c99ab215b35801e9d517a4120748436fcc7c10fd", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a15bfc6f483c552f793932f7ac7fcbb69d187681/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15bfc6f483c552f793932f7ac7fcbb69d187681/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=a15bfc6f483c552f793932f7ac7fcbb69d187681", "patch": "@@ -450,8 +450,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             if !(did1.is_local() || did2.is_local()) && did1.krate != did2.krate {\n                 let exp_path = self.tcx.def_path_str(did1);\n                 let found_path = self.tcx.def_path_str(did2);\n-                let exp_abs_path = self.tcx.absolute_def_path_str(did1);\n-                let found_abs_path = self.tcx.absolute_def_path_str(did2);\n+                // HACK(eddyb) switch form `with_forced_absolute_paths`\n+                // to a custom implementation of `ty::print::Printer`.\n+                let (exp_abs_path, found_abs_path) = ty::print::with_forced_absolute_paths(|| {\n+                    (self.tcx.def_path_str(did1), self.tcx.def_path_str(did2))\n+                });\n                 // We compare strings because DefPath can be different\n                 // for imported and non-imported crates\n                 if exp_path == found_path || exp_abs_path == found_abs_path {"}, {"sha": "45762460f2dbc1d35b17db007f8bad9be2495130", "filename": "src/librustc/ty/print.rs", "status": "modified", "additions": 234, "deletions": 95, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/a15bfc6f483c552f793932f7ac7fcbb69d187681/src%2Flibrustc%2Fty%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15bfc6f483c552f793932f7ac7fcbb69d187681/src%2Flibrustc%2Fty%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint.rs?ref=a15bfc6f483c552f793932f7ac7fcbb69d187681", "patch": "@@ -2,7 +2,7 @@ use crate::hir::def::Namespace;\n use crate::hir::map::DefPathData;\n use crate::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use crate::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable};\n-use crate::ty::subst::{Subst, SubstsRef};\n+use crate::ty::subst::{Kind, Subst, SubstsRef, UnpackedKind};\n use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n use syntax::ast;\n use syntax::symbol::{keywords, Symbol};\n@@ -12,6 +12,7 @@ use syntax::symbol::InternedString;\n \n use std::cell::Cell;\n use std::fmt::{self, Write as _};\n+use std::iter;\n use std::ops::Deref;\n \n thread_local! {\n@@ -151,8 +152,9 @@ pub trait Printer: Sized {\n         def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n         ns: Namespace,\n+        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n     ) -> Self::Path {\n-        self.default_print_def_path(def_id, substs, ns)\n+        self.default_print_def_path(def_id, substs, ns, projections)\n     }\n     #[must_use]\n     fn print_impl_path(\n@@ -167,13 +169,28 @@ pub trait Printer: Sized {\n     #[must_use]\n     fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path;\n     #[must_use]\n+    fn path_qualified(\n+        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Self::Path;\n+    #[must_use]\n     fn path_impl(self: &mut PrintCx<'_, '_, '_, Self>, text: &str) -> Self::Path;\n     #[must_use]\n     fn path_append(\n         self: &mut PrintCx<'_, '_, '_, Self>,\n         path: Self::Path,\n         text: &str,\n     ) -> Self::Path;\n+    #[must_use]\n+    fn path_generic_args(\n+        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+        path: Self::Path,\n+        params: &[ty::GenericParamDef],\n+        substs: SubstsRef<'tcx>,\n+        ns: Namespace,\n+        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n+    ) -> Self::Path;\n }\n \n #[must_use]\n@@ -193,6 +210,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             DefPathData::EnumVariant(..) |\n             DefPathData::Field(..) |\n             DefPathData::AnonConst |\n+            DefPathData::ConstParam(..) |\n             DefPathData::ClosureExpr |\n             DefPathData::StructCtor => Namespace::ValueNS,\n \n@@ -212,37 +230,29 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         ns: Namespace,\n     ) -> String {\n         debug!(\"def_path_str: def_id={:?}, substs={:?}, ns={:?}\", def_id, substs, ns);\n-        if FORCE_ABSOLUTE.with(|force| force.get()) {\n-            PrintCx::new(self, AbsolutePathPrinter).print_def_path(def_id, substs, ns)\n-        } else {\n-            let mut s = String::new();\n-            let _ = PrintCx::new(self, FmtPrinter { fmt: &mut s })\n-                .print_def_path(def_id, substs, ns);\n-            s\n-        }\n+        let mut s = String::new();\n+        let _ = PrintCx::new(self, FmtPrinter { fmt: &mut s })\n+            .print_def_path(def_id, substs, ns, iter::empty());\n+        s\n     }\n \n     /// Returns a string identifying this `DefId`. This string is\n     /// suitable for user output. It is relative to the current crate\n     /// root, unless with_forced_absolute_paths was used.\n     pub fn def_path_str(self, def_id: DefId) -> String {\n         let ns = self.guess_def_namespace(def_id);\n-        self.def_path_str_with_substs_and_ns(def_id, None, ns)\n+        debug!(\"def_path_str: def_id={:?}, ns={:?}\", def_id, ns);\n+        let mut s = String::new();\n+        let _ = PrintCx::new(self, FmtPrinter { fmt: &mut s })\n+            .print_def_path(def_id, None, ns, iter::empty());\n+        s\n     }\n \n     /// Returns a string identifying this local node-id.\n     // FIXME(eddyb) remove in favor of calling `def_path_str` directly.\n     pub fn node_path_str(self, id: ast::NodeId) -> String {\n         self.def_path_str(self.hir().local_def_id(id))\n     }\n-\n-    /// Returns a string identifying this `DefId`. This string is\n-    /// suitable for user output. It always begins with a crate identifier.\n-    pub fn absolute_def_path_str(self, def_id: DefId) -> String {\n-        debug!(\"absolute_def_path_str: def_id={:?}\", def_id);\n-        let ns = self.guess_def_namespace(def_id);\n-        PrintCx::new(self, AbsolutePathPrinter).print_def_path(def_id, None, ns)\n-    }\n }\n \n impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n@@ -251,10 +261,12 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n         def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n         ns: Namespace,\n+        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n     ) -> P::Path {\n         debug!(\"default_print_def_path: def_id={:?}, substs={:?}, ns={:?}\", def_id, substs, ns);\n         let key = self.tcx.def_key(def_id);\n         debug!(\"default_print_def_path: key={:?}\", key);\n+\n         match key.disambiguated_data.data {\n             DefPathData::CrateRoot => {\n                 assert!(key.parent.is_none());\n@@ -265,36 +277,46 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n                 self.print_impl_path(def_id, substs, ns)\n             }\n \n-            // Unclear if there is any value in distinguishing these.\n-            // Probably eventually (and maybe we would even want\n-            // finer-grained distinctions, e.g., between enum/struct).\n-            data @ DefPathData::Misc |\n-            data @ DefPathData::TypeNs(..) |\n-            data @ DefPathData::Trait(..) |\n-            data @ DefPathData::TraitAlias(..) |\n-            data @ DefPathData::AssocTypeInTrait(..) |\n-            data @ DefPathData::AssocTypeInImpl(..) |\n-            data @ DefPathData::AssocExistentialInImpl(..) |\n-            data @ DefPathData::ValueNs(..) |\n-            data @ DefPathData::Module(..) |\n-            data @ DefPathData::TypeParam(..) |\n-            data @ DefPathData::LifetimeParam(..) |\n-            data @ DefPathData::ConstParam(..) |\n-            data @ DefPathData::EnumVariant(..) |\n-            data @ DefPathData::Field(..) |\n-            data @ DefPathData::AnonConst |\n-            data @ DefPathData::MacroDef(..) |\n-            data @ DefPathData::ClosureExpr |\n-            data @ DefPathData::ImplTrait |\n-            data @ DefPathData::GlobalMetaData(..) => {\n-                let parent_did = self.tcx.parent(def_id).unwrap();\n-                let path = self.print_def_path(parent_did, None, ns);\n-                self.path_append(path, &data.as_interned_str().as_symbol().as_str())\n-            },\n-\n-            DefPathData::StructCtor => { // present `X` instead of `X::{{constructor}}`\n-                let parent_def_id = self.tcx.parent(def_id).unwrap();\n-                self.print_def_path(parent_def_id, substs, ns)\n+            _ => {\n+                let generics = substs.map(|_| self.tcx.generics_of(def_id));\n+                let generics_parent = generics.as_ref().and_then(|g| g.parent);\n+                let parent_def_id = DefId { index: key.parent.unwrap(), ..def_id };\n+                let path = if let Some(generics_parent_def_id) = generics_parent {\n+                    assert_eq!(parent_def_id, generics_parent_def_id);\n+\n+                    // FIXME(eddyb) try to move this into the parent's printing\n+                    // logic, instead of doing it when printing the child.\n+                    let parent_generics = self.tcx.generics_of(parent_def_id);\n+                    let parent_has_own_self =\n+                        parent_generics.has_self && parent_generics.parent_count == 0;\n+                    if let (Some(substs), true) = (substs, parent_has_own_self) {\n+                        let trait_ref = ty::TraitRef::new(parent_def_id, substs);\n+                        self.path_qualified(trait_ref.self_ty(), Some(trait_ref))\n+                    } else {\n+                        self.print_def_path(parent_def_id, substs, ns, iter::empty())\n+                    }\n+                } else {\n+                    self.print_def_path(parent_def_id, None, ns, iter::empty())\n+                };\n+                let path = match key.disambiguated_data.data {\n+                    // Skip `::{{constructor}}` on tuple/unit structs.\n+                    DefPathData::StructCtor => path,\n+\n+                    _ => {\n+                        self.path_append(\n+                            path,\n+                            &key.disambiguated_data.data.as_interned_str().as_str(),\n+                        )\n+                    }\n+                };\n+\n+                if let (Some(generics), Some(substs)) = (generics, substs) {\n+                    let has_own_self = generics.has_self && generics.parent_count == 0;\n+                    let params = &generics.params[has_own_self as usize..];\n+                    self.path_generic_args(path, params, substs, ns, projections)\n+                } else {\n+                    path\n+                }\n             }\n         }\n     }\n@@ -335,7 +357,7 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n             // If the impl is not co-located with either self-type or\n             // trait-type, then fallback to a format that identifies\n             // the module more clearly.\n-            let path = self.print_def_path(parent_def_id, None, ns);\n+            let path = self.print_def_path(parent_def_id, None, ns, iter::empty());\n             if let Some(trait_ref) = impl_trait_ref {\n                 return self.path_append(path, &format!(\"<impl {} for {}>\", trait_ref, self_ty));\n             } else {\n@@ -348,22 +370,18 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n \n         if let Some(trait_ref) = impl_trait_ref {\n             // Trait impls.\n-            return self.path_impl(&format!(\"<{} as {}>\", self_ty, trait_ref));\n+            return self.path_qualified(self_ty, Some(trait_ref));\n         }\n \n         // Inherent impls. Try to print `Foo::bar` for an inherent\n         // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n         // anything other than a simple path.\n         match self_ty.sty {\n             ty::Adt(adt_def, substs) => {\n-                // FIXME(eddyb) this should recurse to build the path piecewise.\n-                // self.print_def_path(adt_def.did, Some(substs), ns)\n-                let mut s = String::new();\n-                crate::util::ppaux::parameterized(&mut s, adt_def.did, substs, ns).unwrap();\n-                self.path_impl(&s)\n+                self.print_def_path(adt_def.did, Some(substs), ns, iter::empty())\n             }\n \n-            ty::Foreign(did) => self.print_def_path(did, None, ns),\n+            ty::Foreign(did) => self.print_def_path(did, None, ns, iter::empty()),\n \n             ty::Bool |\n             ty::Char |\n@@ -375,7 +393,7 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n             }\n \n             _ => {\n-                self.path_impl(&format!(\"<{}>\", self_ty))\n+                self.path_qualified(self_ty, None)\n             }\n         }\n     }\n@@ -429,44 +447,15 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n     }\n }\n \n-// FIXME(eddyb) remove, alongside `FORCE_ABSOLUTE` and `absolute_def_path_str`.\n-struct AbsolutePathPrinter;\n-\n-impl Printer for AbsolutePathPrinter {\n-    type Path = String;\n-\n-    fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {\n-        self.tcx.original_crate_name(cnum).to_string()\n-    }\n-    fn path_impl(self: &mut PrintCx<'_, '_, '_, Self>, text: &str) -> Self::Path {\n-        text.to_string()\n-    }\n-    fn path_append(\n-        self: &mut PrintCx<'_, '_, '_, Self>,\n-        mut path: Self::Path,\n-        text: &str,\n-    ) -> Self::Path {\n-        if !path.is_empty() {\n-            path.push_str(\"::\");\n-        }\n-        path.push_str(text);\n-        path\n-    }\n-}\n-\n pub struct FmtPrinter<F: fmt::Write> {\n     pub fmt: F,\n }\n \n-impl<F: fmt::Write> FmtPrinter<F> {\n+impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n     /// If possible, this returns a global path resolving to `def_id` that is visible\n     /// from at least one local module and returns true. If the crate defining `def_id` is\n     /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n-    fn try_print_visible_def_path(\n-        self: &mut PrintCx<'_, '_, '_, Self>,\n-        def_id: DefId,\n-        ns: Namespace,\n-    ) -> Option<<Self as Printer>::Path> {\n+    fn try_print_visible_def_path(&mut self, def_id: DefId) -> Option<P::Path> {\n         debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n \n         // If `def_id` is a direct or injected extern crate, return the\n@@ -497,7 +486,7 @@ impl<F: fmt::Write> FmtPrinter<F> {\n                 }) => {\n                     debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n                     let path = if !span.is_dummy() {\n-                        self.print_def_path(def_id, None, ns)\n+                        self.print_def_path(def_id, None, Namespace::TypeNS, iter::empty())\n                     } else {\n                         self.path_crate(cnum)\n                     };\n@@ -530,7 +519,7 @@ impl<F: fmt::Write> FmtPrinter<F> {\n         }\n \n         let visible_parent = visible_parent_map.get(&def_id).cloned()?;\n-        let path = self.try_print_visible_def_path(visible_parent, ns)?;\n+        let path = self.try_print_visible_def_path(visible_parent)?;\n         let actual_parent = self.tcx.parent(def_id);\n \n         let data = cur_def_key.disambiguated_data.data;\n@@ -593,6 +582,114 @@ impl<F: fmt::Write> FmtPrinter<F> {\n         debug!(\"try_print_visible_def_path: symbol={:?}\", symbol);\n         Some(self.path_append(path, &symbol))\n     }\n+\n+    pub fn pretty_path_qualified(\n+        &mut self,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> P::Path {\n+        write!(self.printer, \"<\")?;\n+        self_ty.print_display(self)?;\n+        if let Some(trait_ref) = trait_ref {\n+            write!(self.printer, \" as \")?;\n+            let _ = self.print_def_path(\n+                trait_ref.def_id,\n+                Some(trait_ref.substs),\n+                Namespace::TypeNS,\n+                iter::empty(),\n+            )?;\n+        }\n+        write!(self.printer, \">\")?;\n+        Ok(PrettyPath { empty: false })\n+    }\n+\n+    pub fn pretty_path_generic_args(\n+        &mut self,\n+        path: P::Path,\n+        params: &[ty::GenericParamDef],\n+        substs: SubstsRef<'tcx>,\n+        ns: Namespace,\n+        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n+    ) -> P::Path {\n+        let path = path?;\n+\n+        let mut empty = true;\n+        let mut start_or_continue = |cx: &mut Self, start: &str, cont: &str| {\n+            if empty {\n+                empty = false;\n+                write!(cx.printer, \"{}\", start)\n+            } else {\n+                write!(cx.printer, \"{}\", cont)\n+            }\n+        };\n+\n+        let start = if ns == Namespace::ValueNS { \"::<\" } else { \"<\" };\n+\n+        // Don't print any regions if they're all erased.\n+        let print_regions = params.iter().any(|param| {\n+            match substs[param.index as usize].unpack() {\n+                UnpackedKind::Lifetime(r) => *r != ty::ReErased,\n+                _ => false,\n+            }\n+        });\n+\n+        // Don't print args that are the defaults of their respective parameters.\n+        let num_supplied_defaults = if self.is_verbose {\n+            0\n+        } else {\n+            params.iter().rev().take_while(|param| {\n+                match param.kind {\n+                    ty::GenericParamDefKind::Lifetime => false,\n+                    ty::GenericParamDefKind::Type { has_default, .. } => {\n+                        has_default && substs[param.index as usize] == Kind::from(\n+                            self.tcx.type_of(param.def_id).subst(self.tcx, substs)\n+                        )\n+                    }\n+                    ty::GenericParamDefKind::Const => false, // FIXME(const_generics:defaults)\n+                }\n+            }).count()\n+        };\n+\n+        for param in &params[..params.len() - num_supplied_defaults] {\n+            match substs[param.index as usize].unpack() {\n+                UnpackedKind::Lifetime(region) => {\n+                    if !print_regions {\n+                        continue;\n+                    }\n+                    start_or_continue(self, start, \", \")?;\n+                    if !region.display_outputs_anything(self) {\n+                        // This happens when the value of the region\n+                        // parameter is not easily serialized. This may be\n+                        // because the user omitted it in the first place,\n+                        // or because it refers to some block in the code,\n+                        // etc. I'm not sure how best to serialize this.\n+                        write!(self.printer, \"'_\")?;\n+                    } else {\n+                        region.print_display(self)?;\n+                    }\n+                }\n+                UnpackedKind::Type(ty) => {\n+                    start_or_continue(self, start, \", \")?;\n+                    ty.print_display(self)?;\n+                }\n+                UnpackedKind::Const(ct) => {\n+                    start_or_continue(self, start, \", \")?;\n+                    ct.print_display(self)?;\n+                }\n+            }\n+        }\n+\n+        for projection in projections {\n+            start_or_continue(self, start, \", \")?;\n+            write!(self.printer, \"{}=\",\n+                   self.tcx.associated_item(projection.item_def_id).ident)?;\n+            projection.ty.print_display(self)?;\n+        }\n+\n+        start_or_continue(self, \"\", \">\")?;\n+\n+        Ok(path)\n+    }\n }\n \n impl<F: fmt::Write> fmt::Write for FmtPrinter<F> {\n@@ -609,9 +706,27 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n         ns: Namespace,\n+        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n     ) -> Self::Path {\n-        self.try_print_visible_def_path(def_id, ns)\n-            .unwrap_or_else(|| self.default_print_def_path(def_id, substs, ns))\n+        // FIXME(eddyb) avoid querying `tcx.generics_of`\n+        // both here and in `default_print_def_path`.\n+        let generics = substs.map(|_| self.tcx.generics_of(def_id));\n+        if // HACK(eddyb) remove the `FORCE_ABSOLUTE` hack by bypassing `FmtPrinter`\n+            !FORCE_ABSOLUTE.with(|force| force.get()) &&\n+            generics.as_ref().and_then(|g| g.parent).is_none() {\n+            if let Some(path) = self.try_print_visible_def_path(def_id) {\n+                let path = if let (Some(generics), Some(substs)) = (generics, substs) {\n+                    let has_own_self = generics.has_self && generics.parent_count == 0;\n+                    let params = &generics.params[has_own_self as usize..];\n+                    self.path_generic_args(path, params, substs, ns, projections)\n+                } else {\n+                    path\n+                };\n+                return path;\n+            }\n+        }\n+\n+        self.default_print_def_path(def_id, substs, ns, projections)\n     }\n     fn print_impl_path(\n         self: &mut PrintCx<'_, '_, 'tcx, Self>,\n@@ -621,7 +736,9 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n     ) -> Self::Path {\n         // Always use types for non-local impls, where types are always\n         // available, and filename/line-number is mostly uninteresting.\n-        let use_types = !impl_def_id.is_local() || {\n+        let use_types = // HACK(eddyb) remove the `FORCE_ABSOLUTE` hack by bypassing `FmtPrinter`\n+            FORCE_ABSOLUTE.with(|force| force.get()) ||\n+            !impl_def_id.is_local() || {\n             // Otherwise, use filename/line-number if forced.\n             let force_no_types = FORCE_IMPL_FILENAME_LINE.with(|f| f.get());\n             !force_no_types\n@@ -632,7 +749,7 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n             // pretty printing some span information. This should\n             // only occur very early in the compiler pipeline.\n             let parent_def_id = self.tcx.parent(impl_def_id).unwrap();\n-            let path = self.print_def_path(parent_def_id, None, ns);\n+            let path = self.print_def_path(parent_def_id, None, ns, iter::empty());\n             let span = self.tcx.def_span(impl_def_id);\n             return self.path_append(path, &format!(\"<impl at {:?}>\", span));\n         }\n@@ -641,6 +758,11 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n     }\n \n     fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {\n+        // HACK(eddyb) remove the `FORCE_ABSOLUTE` hack by bypassing `FmtPrinter`\n+        if FORCE_ABSOLUTE.with(|force| force.get()) {\n+            write!(self.printer, \"{}\", self.tcx.original_crate_name(cnum))?;\n+            return Ok(PrettyPath { empty: false });\n+        }\n         if cnum == LOCAL_CRATE {\n             if self.tcx.sess.rust_2018() {\n                 // We add the `crate::` keyword on Rust 2018, only when desired.\n@@ -655,6 +777,13 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n             Ok(PrettyPath { empty: false })\n         }\n     }\n+    fn path_qualified(\n+        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Self::Path {\n+        self.pretty_path_qualified(self_ty, trait_ref)\n+    }\n     fn path_impl(self: &mut PrintCx<'_, '_, '_, Self>, text: &str) -> Self::Path {\n         write!(self.printer, \"{}\", text)?;\n         Ok(PrettyPath { empty: false })\n@@ -678,6 +807,16 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         write!(self.printer, \"{}\", text)?;\n         Ok(PrettyPath { empty: false })\n     }\n+    fn path_generic_args(\n+        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+        path: Self::Path,\n+        params: &[ty::GenericParamDef],\n+        substs: SubstsRef<'tcx>,\n+        ns: Namespace,\n+        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n+    ) -> Self::Path {\n+        self.pretty_path_generic_args(path, params, substs, ns, projections)\n+    }\n }\n \n impl<F: fmt::Write> PrettyPrinter for FmtPrinter<F> {}"}, {"sha": "2c38c437cf6e7ede8f741698e873e8b586e16c92", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 97, "deletions": 160, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/a15bfc6f483c552f793932f7ac7fcbb69d187681/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15bfc6f483c552f793932f7ac7fcbb69d187681/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=a15bfc6f483c552f793932f7ac7fcbb69d187681", "patch": "@@ -1,16 +1,15 @@\n use crate::hir::def::Namespace;\n use crate::hir::def_id::DefId;\n-use crate::hir::map::definitions::DefPathData;\n use crate::middle::region;\n-use crate::ty::subst::{self, Kind, Subst, SubstsRef, UnpackedKind};\n+use crate::ty::subst::{Kind, Subst, SubstsRef, UnpackedKind};\n use crate::ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n use crate::ty::{Bool, Char, Adt};\n use crate::ty::{Error, Str, Array, Slice, Float, FnDef, FnPtr};\n use crate::ty::{Param, Bound, RawPtr, Ref, Never, Tuple};\n use crate::ty::{Closure, Generator, GeneratorWitness, Foreign, Projection, Opaque};\n use crate::ty::{Placeholder, UnnormalizedProjection, Dynamic, Int, Uint, Infer};\n use crate::ty::{self, ParamConst, Ty, TypeFoldable};\n-use crate::ty::print::{FmtPrinter, PrettyPrinter, PrintCx, Print};\n+use crate::ty::print::{FmtPrinter, PrettyPrinter, PrintCx, Print, Printer};\n use crate::mir::interpret::ConstValue;\n \n use std::cell::Cell;\n@@ -284,130 +283,6 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n         Ok(())\n     }\n \n-    fn parameterized(\n-        &mut self,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>,\n-        ns: Namespace,\n-        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n-    ) -> fmt::Result {\n-        let key = self.tcx.def_key(def_id);\n-        let generics = self.tcx.generics_of(def_id);\n-\n-        if let Some(parent_def_id) = generics.parent {\n-            assert_eq!(parent_def_id, DefId { index: key.parent.unwrap(), ..def_id });\n-\n-            let parent_generics = self.tcx.generics_of(parent_def_id);\n-            let parent_has_own_self =\n-                parent_generics.has_self && parent_generics.parent_count == 0;\n-            if parent_has_own_self {\n-                print!(self, write(\"<\"), print_display(substs.type_at(0)), write(\" as \"))?;\n-                self.parameterized(parent_def_id, substs, Namespace::TypeNS, iter::empty())?;\n-                print!(self, write(\">\"))?;\n-            } else {\n-                self.parameterized(parent_def_id, substs, ns, iter::empty())?;\n-            }\n-\n-            // Skip `::{{constructor}}` on tuple/unit structs.\n-            match key.disambiguated_data.data {\n-                DefPathData::StructCtor => {}\n-\n-                _ => {\n-                    print!(self, write(\"::{}\", key.disambiguated_data.data.as_interned_str()))?;\n-                }\n-            }\n-        } else {\n-            // FIXME(eddyb) recurse through printing a path via `self`, instead\n-            // instead of using the `tcx` method that produces a `String`.\n-            print!(self, write(\"{}\",\n-                self.tcx.def_path_str_with_substs_and_ns(def_id, Some(substs), ns)))?;\n-\n-            // For impls, the above call already prints relevant generics args.\n-            if let DefPathData::Impl = key.disambiguated_data.data {\n-                return Ok(());\n-            }\n-        }\n-\n-        let mut empty = true;\n-        let mut start_or_continue = |cx: &mut Self, start: &str, cont: &str| {\n-            if empty {\n-                empty = false;\n-                print!(cx, write(\"{}\", start))\n-            } else {\n-                print!(cx, write(\"{}\", cont))\n-            }\n-        };\n-\n-        let start = if ns == Namespace::ValueNS { \"::<\" } else { \"<\" };\n-\n-        let has_own_self = generics.has_self && generics.parent_count == 0;\n-        let params = &generics.params[has_own_self as usize..];\n-\n-        // Don't print any regions if they're all erased.\n-        let print_regions = params.iter().any(|param| {\n-            match substs[param.index as usize].unpack() {\n-                UnpackedKind::Lifetime(r) => *r != ty::ReErased,\n-                _ => false,\n-            }\n-        });\n-\n-        // Don't print args that are the defaults of their respective parameters.\n-        let num_supplied_defaults = if self.is_verbose {\n-            0\n-        } else {\n-            params.iter().rev().take_while(|param| {\n-                match param.kind {\n-                    ty::GenericParamDefKind::Lifetime => false,\n-                    ty::GenericParamDefKind::Type { has_default, .. } => {\n-                        has_default && substs[param.index as usize] == Kind::from(\n-                            self.tcx.type_of(param.def_id).subst(self.tcx, substs)\n-                        )\n-                    }\n-                    ty::GenericParamDefKind::Const => false, // FIXME(const_generics:defaults)\n-                }\n-            }).count()\n-        };\n-\n-        for param in &params[..params.len() - num_supplied_defaults] {\n-            match substs[param.index as usize].unpack() {\n-                UnpackedKind::Lifetime(region) => {\n-                    if !print_regions {\n-                        continue;\n-                    }\n-                    start_or_continue(self, start, \", \")?;\n-                    if !region.display_outputs_anything(self) {\n-                        // This happens when the value of the region\n-                        // parameter is not easily serialized. This may be\n-                        // because the user omitted it in the first place,\n-                        // or because it refers to some block in the code,\n-                        // etc. I'm not sure how best to serialize this.\n-                        print!(self, write(\"'_\"))?;\n-                    } else {\n-                        region.print_display(self)?;\n-                    }\n-                }\n-                UnpackedKind::Type(ty) => {\n-                    start_or_continue(self, start, \", \")?;\n-                    ty.print_display(self)?;\n-                }\n-                UnpackedKind::Const(ct) => {\n-                    start_or_continue(self, start, \", \")?;\n-                    ct.print_display(self)?;\n-                }\n-            }\n-        }\n-\n-        for projection in projections {\n-            start_or_continue(self, start, \", \")?;\n-            print!(self,\n-                    write(\"{}=\",\n-                            self.tcx.associated_item(projection.item_def_id).ident),\n-                    print_display(projection.ty))?;\n-        }\n-\n-        start_or_continue(self, \"\", \">\")\n-    }\n-\n     fn in_binder<T>(&mut self, value: &ty::Binder<T>) -> fmt::Result\n         where T: Print<'tcx, P, Output = fmt::Result> + TypeFoldable<'tcx>\n     {\n@@ -490,7 +365,8 @@ pub fn parameterized<F: fmt::Write>(\n ) -> fmt::Result {\n     PrintCx::with(FmtPrinter { fmt: f }, |mut cx| {\n         let substs = cx.tcx.lift(&substs).expect(\"could not lift for printing\");\n-        cx.parameterized(did, substs, ns, iter::empty())\n+        let _ = cx.print_def_path(did, Some(substs), ns, iter::empty())?;\n+        Ok(())\n     })\n }\n \n@@ -508,7 +384,12 @@ define_print! {\n                     if let Tuple(ref args) = principal.substs.type_at(0).sty {\n                         let mut projections = self.projection_bounds();\n                         if let (Some(proj), None) = (projections.next(), projections.next()) {\n-                            print!(cx, write(\"{}\", cx.tcx.def_path_str(principal.def_id)))?;\n+                            let _ = cx.print_def_path(\n+                                principal.def_id,\n+                                None,\n+                                Namespace::TypeNS,\n+                                iter::empty(),\n+                            )?;\n                             cx.fn_sig(args, false, proj.ty)?;\n                             resugared_principal = true;\n                         }\n@@ -519,9 +400,9 @@ define_print! {\n                     // Use a type that can't appear in defaults of type parameters.\n                     let dummy_self = cx.tcx.mk_infer(ty::FreshTy(0));\n                     let principal = principal.with_self_ty(cx.tcx, dummy_self);\n-                    cx.parameterized(\n+                    let _ = cx.print_def_path(\n                         principal.def_id,\n-                        principal.substs,\n+                        Some(principal.substs),\n                         Namespace::TypeNS,\n                         self.projection_bounds(),\n                     )?;\n@@ -530,8 +411,10 @@ define_print! {\n             }\n \n             // Builtin bounds.\n+            // FIXME(eddyb) avoid printing twice (needed to ensure\n+            // that the auto traits are sorted *and* printed via cx).\n             let mut auto_traits: Vec<_> = self.auto_traits().map(|did| {\n-                cx.tcx.def_path_str(did)\n+                (cx.tcx.def_path_str(did), did)\n             }).collect();\n \n             // The auto traits come ordered by `DefPathHash`. While\n@@ -543,13 +426,18 @@ define_print! {\n             // output, sort the auto-traits alphabetically.\n             auto_traits.sort();\n \n-            for auto_trait in auto_traits {\n+            for (_, def_id) in auto_traits {\n                 if !first {\n                     print!(cx, write(\" + \"))?;\n                 }\n                 first = false;\n \n-                print!(cx, write(\"{}\", auto_trait))?;\n+                let _ = cx.print_def_path(\n+                    def_id,\n+                    None,\n+                    Namespace::TypeNS,\n+                    iter::empty(),\n+                )?;\n             }\n \n             Ok(())\n@@ -575,15 +463,27 @@ impl fmt::Debug for ty::GenericParamDef {\n impl fmt::Debug for ty::TraitDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         PrintCx::with(FmtPrinter { fmt: f }, |mut cx| {\n-            print!(cx, write(\"{}\", cx.tcx.def_path_str(self.def_id)))\n+            let _ = cx.print_def_path(\n+                self.def_id,\n+                None,\n+                Namespace::TypeNS,\n+                iter::empty(),\n+            )?;\n+            Ok(())\n         })\n     }\n }\n \n impl fmt::Debug for ty::AdtDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         PrintCx::with(FmtPrinter { fmt: f }, |mut cx| {\n-            print!(cx, write(\"{}\", cx.tcx.def_path_str(self.did)))\n+            let _ = cx.print_def_path(\n+                self.did,\n+                None,\n+                Namespace::TypeNS,\n+                iter::empty(),\n+            )?;\n+            Ok(())\n         })\n     }\n }\n@@ -645,10 +545,10 @@ define_print! {\n         display {\n             let dummy_self = cx.tcx.mk_infer(ty::FreshTy(0));\n \n-            let trait_ref = *ty::Binder::bind(*self)\n+            ty::Binder::bind(*self)\n                 .with_self_ty(cx.tcx, dummy_self)\n-                .skip_binder();\n-            cx.parameterized(trait_ref.def_id, trait_ref.substs, Namespace::TypeNS, iter::empty())\n+                .skip_binder()\n+                .print_display(cx)\n         }\n         debug {\n             self.print_display(cx)\n@@ -874,7 +774,8 @@ define_print! {\n //\n // NB: this must be kept in sync with the printing logic above.\n impl ty::RegionKind {\n-    fn display_outputs_anything<P>(&self, cx: &mut PrintCx<'_, '_, '_, P>) -> bool {\n+    // HACK(eddyb) `pub(crate)` only for `ty::print`.\n+    pub(crate) fn display_outputs_anything<P>(&self, cx: &mut PrintCx<'_, '_, '_, P>) -> bool {\n         if cx.is_verbose {\n             return true;\n         }\n@@ -1097,16 +998,17 @@ define_print_multi! {\n define_print! {\n     ('tcx) ty::TraitRef<'tcx>, (self, cx) {\n         display {\n-            cx.parameterized(self.def_id, self.substs, Namespace::TypeNS, iter::empty())\n+            let _ = cx.print_def_path(\n+                self.def_id,\n+                Some(self.substs),\n+                Namespace::TypeNS,\n+                iter::empty(),\n+            )?;\n+            Ok(())\n         }\n         debug {\n-            print!(cx,\n-                write(\"<\"),\n-                print(self.self_ty()),\n-                write(\" as \"),\n-                print_display(self),\n-                write(\">\")\n-            )\n+            let _ = cx.path_qualified(self.self_ty(), Some(*self))?;\n+            Ok(())\n         }\n     }\n }\n@@ -1152,7 +1054,12 @@ define_print! {\n                 FnDef(def_id, substs) => {\n                     let sig = cx.tcx.fn_sig(def_id).subst(cx.tcx, substs);\n                     print!(cx, print(sig), write(\" {{\"))?;\n-                    cx.parameterized(def_id, substs, Namespace::ValueNS, iter::empty())?;\n+                    let _ = cx.print_def_path(\n+                        def_id,\n+                        Some(substs),\n+                        Namespace::ValueNS,\n+                        iter::empty(),\n+                    )?;\n                     print!(cx, write(\"}}\"))\n                 }\n                 FnPtr(ref bare_fn) => {\n@@ -1175,7 +1082,13 @@ define_print! {\n                     }\n                 }\n                 Adt(def, substs) => {\n-                    cx.parameterized(def.did, substs, Namespace::TypeNS, iter::empty())\n+                    let _ = cx.print_def_path(\n+                        def.did,\n+                        Some(substs),\n+                        Namespace::TypeNS,\n+                        iter::empty(),\n+                    )?;\n+                    Ok(())\n                 }\n                 Dynamic(data, r) => {\n                     let print_r = r.display_outputs_anything(cx);\n@@ -1190,12 +1103,13 @@ define_print! {\n                     Ok(())\n                 }\n                 Foreign(def_id) => {\n-                    cx.parameterized(\n+                    let _ = cx.print_def_path(\n                         def_id,\n-                        subst::InternalSubsts::empty(),\n+                        None,\n                         Namespace::TypeNS,\n                         iter::empty(),\n-                    )\n+                    )?;\n+                    Ok(())\n                 }\n                 Projection(ref data) => data.print(cx),\n                 UnnormalizedProjection(ref data) => {\n@@ -1215,7 +1129,7 @@ define_print! {\n                     if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n                         print!(cx, write(\"{}\", name))?;\n                         let mut substs = substs.iter();\n-                        // FIXME(eddyb) print this with `parameterized`.\n+                        // FIXME(eddyb) print this with `print_def_path`.\n                         if let Some(first) = substs.next() {\n                             print!(cx, write(\"::<\"))?;\n                             print!(cx, write(\"{}\", first))?;\n@@ -1477,7 +1391,13 @@ define_print! {\n define_print! {\n     ('tcx) ty::ProjectionTy<'tcx>, (self, cx) {\n         display {\n-            cx.parameterized(self.item_def_id, self.substs, Namespace::TypeNS, iter::empty())\n+            let _ = cx.print_def_path(\n+                self.item_def_id,\n+                Some(self.substs),\n+                Namespace::TypeNS,\n+                iter::empty(),\n+            )?;\n+            Ok(())\n         }\n     }\n }\n@@ -1505,16 +1425,33 @@ define_print! {\n                 ty::Predicate::Projection(ref predicate) => predicate.print(cx),\n                 ty::Predicate::WellFormed(ty) => print!(cx, print(ty), write(\" well-formed\")),\n                 ty::Predicate::ObjectSafe(trait_def_id) => {\n-                    print!(cx, write(\"the trait `{}` is object-safe\",\n-                        cx.tcx.def_path_str(trait_def_id)))\n+                    print!(cx, write(\"the trait `\"))?;\n+                    let _ = cx.print_def_path(\n+                        trait_def_id,\n+                        None,\n+                        Namespace::TypeNS,\n+                        iter::empty(),\n+                    )?;\n+                    print!(cx, write(\"` is object-safe\"))\n                 }\n                 ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) => {\n-                    print!(cx, write(\"the closure `{}` implements the trait `{}`\",\n-                           cx.tcx.def_path_str(closure_def_id), kind))\n+                    print!(cx, write(\"the closure `\"))?;\n+                    let _ = cx.print_def_path(\n+                        closure_def_id,\n+                        None,\n+                        Namespace::ValueNS,\n+                        iter::empty(),\n+                    )?;\n+                    print!(cx, write(\"` implements the trait `{}`\", kind))\n                 }\n                 ty::Predicate::ConstEvaluatable(def_id, substs) => {\n                     print!(cx, write(\"the constant `\"))?;\n-                    cx.parameterized(def_id, substs, Namespace::ValueNS, iter::empty())?;\n+                    let _ = cx.print_def_path(\n+                        def_id,\n+                        Some(substs),\n+                        Namespace::ValueNS,\n+                        iter::empty(),\n+                    )?;\n                     print!(cx, write(\"` can be evaluated\"))\n                 }\n             }"}, {"sha": "4c7b00ae0780d6845cc8687e44f80b78beb9639c", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 110, "deletions": 72, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/a15bfc6f483c552f793932f7ac7fcbb69d187681/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15bfc6f483c552f793932f7ac7fcbb69d187681/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=a15bfc6f483c552f793932f7ac7fcbb69d187681", "patch": "@@ -93,7 +93,7 @@ use rustc::hir::Node;\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::ich::NodeIdHashingMode;\n-use rustc::ty::print::{PrintCx, Printer};\n+use rustc::ty::print::{PrettyPath, PrettyPrinter, PrintCx, Printer};\n use rustc::ty::query::Providers;\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -106,8 +106,9 @@ use syntax_pos::symbol::Symbol;\n \n use log::debug;\n \n-use std::fmt::Write;\n-use std::mem::discriminant;\n+use std::fmt::{self, Write};\n+use std::iter;\n+use std::mem::{self, discriminant};\n \n pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n@@ -225,9 +226,9 @@ fn get_symbol_hash<'a, 'tcx>(\n \n fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::SymbolName {\n     ty::print::with_forced_absolute_paths(|| {\n-        PrintCx::new(tcx, SymbolPathPrinter)\n-            .print_def_path(def_id, None, Namespace::ValueNS)\n-            .into_interned()\n+        let mut cx = PrintCx::new(tcx, SymbolPath::new(tcx));\n+        let _ = cx.print_def_path(def_id, None, Namespace::ValueNS, iter::empty());\n+        cx.printer.into_interned()\n     })\n }\n \n@@ -323,7 +324,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n     let mut buf = SymbolPath::from_interned(tcx.def_symbol_name(def_id), tcx);\n \n     if instance.is_vtable_shim() {\n-        buf.push(\"{{vtable-shim}}\");\n+        let _ = buf.write_str(\"{{vtable-shim}}\");\n     }\n \n     buf.finish(hash)\n@@ -347,6 +348,12 @@ struct SymbolPath {\n     result: String,\n     temp_buf: String,\n     strict_naming: bool,\n+\n+    // When `true`, `finalize_pending_component` is a noop.\n+    // This is needed when recursing into `path_qualified`,\n+    // or `path_generic_args`, as any nested paths are\n+    // logically within one component.\n+    keep_within_component: bool,\n }\n \n impl SymbolPath {\n@@ -355,6 +362,7 @@ impl SymbolPath {\n             result: String::with_capacity(64),\n             temp_buf: String::with_capacity(16),\n             strict_naming: tcx.has_strict_asm_symbol_naming(),\n+            keep_within_component: false,\n         };\n         result.result.push_str(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n         result\n@@ -365,109 +373,139 @@ impl SymbolPath {\n             result: String::with_capacity(64),\n             temp_buf: String::with_capacity(16),\n             strict_naming: tcx.has_strict_asm_symbol_naming(),\n+            keep_within_component: false,\n         };\n         result.result.push_str(&symbol.as_str());\n         result\n     }\n \n-    fn into_interned(self) -> ty::SymbolName {\n+    fn into_interned(mut self) -> ty::SymbolName {\n+        self.finalize_pending_component();\n         ty::SymbolName {\n             name: Symbol::intern(&self.result).as_interned_str(),\n         }\n     }\n \n-    fn push(&mut self, text: &str) {\n-        self.temp_buf.clear();\n-        let need_underscore = sanitize(&mut self.temp_buf, text, self.strict_naming);\n-        let _ = write!(\n-            self.result,\n-            \"{}\",\n-            self.temp_buf.len() + (need_underscore as usize)\n-        );\n-        if need_underscore {\n-            self.result.push('_');\n+    fn finalize_pending_component(&mut self) {\n+        if !self.keep_within_component && !self.temp_buf.is_empty() {\n+            let _ = write!(self.result, \"{}{}\", self.temp_buf.len(), self.temp_buf);\n+            self.temp_buf.clear();\n         }\n-        self.result.push_str(&self.temp_buf);\n     }\n \n     fn finish(mut self, hash: u64) -> String {\n+        self.finalize_pending_component();\n         // E = end name-sequence\n         let _ = write!(self.result, \"17h{:016x}E\", hash);\n         self.result\n     }\n }\n \n-struct SymbolPathPrinter;\n+// HACK(eddyb) this relies on using the `fmt` interface to get\n+// `PrettyPrinter` aka pretty printing of e.g. types in paths,\n+// symbol names should have their own printing machinery.\n \n-impl Printer for SymbolPathPrinter {\n-    type Path = SymbolPath;\n+impl Printer for SymbolPath {\n+    type Path = Result<PrettyPath, fmt::Error>;\n \n     fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {\n-        let mut path = SymbolPath::new(self.tcx);\n-        path.push(&self.tcx.original_crate_name(cnum).as_str());\n-        path\n+        self.printer.write_str(&self.tcx.original_crate_name(cnum).as_str())?;\n+        Ok(PrettyPath { empty: false })\n+    }\n+    fn path_qualified(\n+        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Self::Path {\n+        let kept_within_component = mem::replace(&mut self.printer.keep_within_component, true);\n+        let r = self.pretty_path_qualified(self_ty, trait_ref);\n+        self.printer.keep_within_component = kept_within_component;\n+        r\n     }\n     fn path_impl(self: &mut PrintCx<'_, '_, '_, Self>, text: &str) -> Self::Path {\n-        let mut path = SymbolPath::new(self.tcx);\n-        path.push(text);\n-        path\n+        self.printer.write_str(text)?;\n+        Ok(PrettyPath { empty: false })\n     }\n     fn path_append(\n         self: &mut PrintCx<'_, '_, '_, Self>,\n-        mut path: Self::Path,\n+        _: Self::Path,\n         text: &str,\n     ) -> Self::Path {\n-        path.push(text);\n-        path\n+        self.printer.finalize_pending_component();\n+        self.printer.write_str(text)?;\n+        Ok(PrettyPath { empty: false })\n+    }\n+    fn path_generic_args(\n+        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+        path: Self::Path,\n+        params: &[ty::GenericParamDef],\n+        substs: SubstsRef<'tcx>,\n+        ns: Namespace,\n+        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n+    ) -> Self::Path {\n+        let kept_within_component = mem::replace(&mut self.printer.keep_within_component, true);\n+        let r = self.pretty_path_generic_args(path, params, substs, ns, projections);\n+        self.printer.keep_within_component = kept_within_component;\n+        r\n     }\n }\n \n-// Name sanitation. LLVM will happily accept identifiers with weird names, but\n-// gas doesn't!\n-// gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n-// NVPTX assembly has more strict naming rules than gas, so additionally, dots\n-// are replaced with '$' there.\n-//\n-// returns true if an underscore must be added at the start\n-fn sanitize(result: &mut String, s: &str, strict_naming: bool) -> bool {\n-    for c in s.chars() {\n-        match c {\n-            // Escape these with $ sequences\n-            '@' => result.push_str(\"$SP$\"),\n-            '*' => result.push_str(\"$BP$\"),\n-            '&' => result.push_str(\"$RF$\"),\n-            '<' => result.push_str(\"$LT$\"),\n-            '>' => result.push_str(\"$GT$\"),\n-            '(' => result.push_str(\"$LP$\"),\n-            ')' => result.push_str(\"$RP$\"),\n-            ',' => result.push_str(\"$C$\"),\n-\n-            '-' | ':' | '.' if strict_naming => {\n-                // NVPTX doesn't support these characters in symbol names.\n-                result.push('$')\n+impl PrettyPrinter for SymbolPath {}\n+\n+impl fmt::Write for SymbolPath {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        // Name sanitation. LLVM will happily accept identifiers with weird names, but\n+        // gas doesn't!\n+        // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n+        // NVPTX assembly has more strict naming rules than gas, so additionally, dots\n+        // are replaced with '$' there.\n+\n+        for c in s.chars() {\n+            if self.temp_buf.is_empty() {\n+                match c {\n+                    'a'..='z' | 'A'..='Z' | '_' => {}\n+                    _ => {\n+                        // Underscore-qualify anything that didn't start as an ident.\n+                        self.temp_buf.push('_');\n+                    }\n+                }\n             }\n+            match c {\n+                // Escape these with $ sequences\n+                '@' => self.temp_buf.push_str(\"$SP$\"),\n+                '*' => self.temp_buf.push_str(\"$BP$\"),\n+                '&' => self.temp_buf.push_str(\"$RF$\"),\n+                '<' => self.temp_buf.push_str(\"$LT$\"),\n+                '>' => self.temp_buf.push_str(\"$GT$\"),\n+                '(' => self.temp_buf.push_str(\"$LP$\"),\n+                ')' => self.temp_buf.push_str(\"$RP$\"),\n+                ',' => self.temp_buf.push_str(\"$C$\"),\n+\n+                '-' | ':' | '.' if self.strict_naming => {\n+                    // NVPTX doesn't support these characters in symbol names.\n+                    self.temp_buf.push('$')\n+                }\n \n-            // '.' doesn't occur in types and functions, so reuse it\n-            // for ':' and '-'\n-            '-' | ':' => result.push('.'),\n-\n-            // These are legal symbols\n-            'a'..='z' | 'A'..='Z' | '0'..='9' | '_' | '.' | '$' => result.push(c),\n-\n-            _ => {\n-                result.push('$');\n-                for c in c.escape_unicode().skip(1) {\n-                    match c {\n-                        '{' => {}\n-                        '}' => result.push('$'),\n-                        c => result.push(c),\n+                // '.' doesn't occur in types and functions, so reuse it\n+                // for ':' and '-'\n+                '-' | ':' => self.temp_buf.push('.'),\n+\n+                // These are legal symbols\n+                'a'..='z' | 'A'..='Z' | '0'..='9' | '_' | '.' | '$' => self.temp_buf.push(c),\n+\n+                _ => {\n+                    self.temp_buf.push('$');\n+                    for c in c.escape_unicode().skip(1) {\n+                        match c {\n+                            '{' => {}\n+                            '}' => self.temp_buf.push('$'),\n+                            c => self.temp_buf.push(c),\n+                        }\n                     }\n                 }\n             }\n         }\n-    }\n \n-    // Underscore-qualify anything that didn't start as an ident.\n-    !result.is_empty() && result.as_bytes()[0] != '_' as u8\n-        && !(result.as_bytes()[0] as char).is_xid_start()\n+        Ok(())\n+    }\n }"}, {"sha": "f629447fc64faecdfb6e0dbb7d276cff42a37f4c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a15bfc6f483c552f793932f7ac7fcbb69d187681/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15bfc6f483c552f793932f7ac7fcbb69d187681/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a15bfc6f483c552f793932f7ac7fcbb69d187681", "patch": "@@ -39,7 +39,7 @@ use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::default::Default;\n use std::{mem, slice, vec};\n-use std::iter::{FromIterator, once};\n+use std::iter::{self, FromIterator, once};\n use std::rc::Rc;\n use std::str::FromStr;\n use std::cell::RefCell;\n@@ -4235,6 +4235,18 @@ where F: Fn(DefId) -> Def {\n         fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {\n             vec![self.tcx.original_crate_name(cnum).to_string()]\n         }\n+        fn path_qualified(\n+            self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+            self_ty: Ty<'tcx>,\n+            trait_ref: Option<ty::TraitRef<'tcx>>,\n+        ) -> Self::Path {\n+            // This shouldn't ever be needed, but just in case:\n+            if let Some(trait_ref) = trait_ref {\n+                vec![format!(\"{:?}\", trait_ref)]\n+            } else {\n+                vec![format!(\"<{}>\", self_ty)]\n+            }\n+        }\n         fn path_impl(self: &mut PrintCx<'_, '_, '_, Self>, text: &str) -> Self::Path {\n             vec![text.to_string()]\n         }\n@@ -4246,10 +4258,20 @@ where F: Fn(DefId) -> Def {\n             path.push(text.to_string());\n             path\n         }\n+        fn path_generic_args(\n+            self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+            path: Self::Path,\n+            _params: &[ty::GenericParamDef],\n+            _substs: SubstsRef<'tcx>,\n+            _ns: Namespace,\n+            _projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n+        ) -> Self::Path {\n+            path\n+        }\n     }\n \n     let names = PrintCx::new(tcx, AbsolutePathPrinter)\n-        .print_def_path(def_id, None, Namespace::TypeNS);\n+        .print_def_path(def_id, None, Namespace::TypeNS, iter::empty());\n \n     hir::Path {\n         span: DUMMY_SP,"}, {"sha": "2ac44d0109f3a7649457cc614dfceb6f6fee0ee1", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a15bfc6f483c552f793932f7ac7fcbb69d187681/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15bfc6f483c552f793932f7ac7fcbb69d187681/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=a15bfc6f483c552f793932f7ac7fcbb69d187681", "patch": "@@ -8,6 +8,7 @@\n #![feature(arbitrary_self_types)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(set_stdio)]\n #![feature(test)]"}, {"sha": "c712137e828f94e1d4e2ee8d6ce13b6cd716c944", "filename": "src/test/ui/symbol-names/impl1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a15bfc6f483c552f793932f7ac7fcbb69d187681/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15bfc6f483c552f793932f7ac7fcbb69d187681/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs?ref=a15bfc6f483c552f793932f7ac7fcbb69d187681", "patch": "@@ -5,7 +5,7 @@ mod foo {\n     pub struct Foo { x: u32 }\n \n     impl Foo {\n-        #[rustc_symbol_name] //~ ERROR _ZN15impl1..foo..Foo3bar\n+        #[rustc_symbol_name] //~ ERROR _ZN5impl13foo3Foo3bar\n         #[rustc_def_path] //~ ERROR def-path(foo::Foo::bar)\n         fn bar() { }\n     }"}, {"sha": "eda8646b5b4de1f035fbf03a7bbe5766bbf51acc", "filename": "src/test/ui/symbol-names/impl1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a15bfc6f483c552f793932f7ac7fcbb69d187681/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a15bfc6f483c552f793932f7ac7fcbb69d187681/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.stderr?ref=a15bfc6f483c552f793932f7ac7fcbb69d187681", "patch": "@@ -1,4 +1,4 @@\n-error: symbol-name(_ZN15impl1..foo..Foo3bar17hc487d6ec13fe9124E)\n+error: symbol-name(_ZN5impl13foo3Foo3bar17hc487d6ec13fe9124E)\n   --> $DIR/impl1.rs:8:9\n    |\n LL |         #[rustc_symbol_name]"}]}