{"sha": "d735f6bf33a8654e387d248f46e0ad6d98280a05", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3MzVmNmJmMzNhODY1NGUzODdkMjQ4ZjQ2ZTBhZDZkOTgyODBhMDU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-27T11:40:05Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-06-05T11:41:04Z"}, "message": "trans: implement CheckedBinaryOp in mir::constant.", "tree": {"sha": "ba721ae728b9f7021864771006783bdd984e0b53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba721ae728b9f7021864771006783bdd984e0b53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d735f6bf33a8654e387d248f46e0ad6d98280a05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d735f6bf33a8654e387d248f46e0ad6d98280a05", "html_url": "https://github.com/rust-lang/rust/commit/d735f6bf33a8654e387d248f46e0ad6d98280a05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d735f6bf33a8654e387d248f46e0ad6d98280a05/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8c5053a02f5468e58f856d06586d1a06560d224", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8c5053a02f5468e58f856d06586d1a06560d224", "html_url": "https://github.com/rust-lang/rust/commit/b8c5053a02f5468e58f856d06586d1a06560d224"}], "stats": {"total": 182, "additions": 112, "deletions": 70}, "files": [{"sha": "a516a84f0c60f24c026c8fcfb83aba80dcf73f77", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 112, "deletions": 70, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/d735f6bf33a8654e387d248f46e0ad6d98280a05/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d735f6bf33a8654e387d248f46e0ad6d98280a05/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=d735f6bf33a8654e387d248f46e0ad6d98280a05", "patch": "@@ -12,12 +12,13 @@ use llvm::{self, ValueRef};\n use rustc::middle::const_val::ConstVal;\n use rustc_const_eval::ErrKind;\n use rustc_const_math::ConstInt::*;\n+use rustc_const_math::ConstMathErr;\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc::traits;\n-use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::Substs;\n use {abi, adt, base, Disr};\n@@ -713,73 +714,28 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 let ty = lhs.ty;\n                 let binop_ty = self.mir.binop_ty(tcx, op, lhs.ty, rhs.ty);\n                 let (lhs, rhs) = (lhs.llval, rhs.llval);\n-                assert!(!ty.is_simd());\n-                let is_float = ty.is_fp();\n-                let signed = ty.is_signed();\n-\n-                if let (Some(lhs), Some(rhs)) = (to_const_int(lhs, ty, tcx),\n-                                                 to_const_int(rhs, ty, tcx)) {\n-                    let result = match op {\n-                        mir::BinOp::Add => lhs + rhs,\n-                        mir::BinOp::Sub => lhs - rhs,\n-                        mir::BinOp::Mul => lhs * rhs,\n-                        mir::BinOp::Div => lhs / rhs,\n-                        mir::BinOp::Rem => lhs % rhs,\n-                        mir::BinOp::Shl => lhs << rhs,\n-                        mir::BinOp::Shr => lhs >> rhs,\n-                        _ => Ok(lhs)\n-                    };\n-                    consts::const_err(self.ccx, span,\n-                                      result.map_err(ErrKind::Math),\n-                                      TrueConst::Yes)?;\n-                }\n-\n-                let llval = unsafe {\n-                    match op {\n-                        mir::BinOp::Add if is_float => llvm::LLVMConstFAdd(lhs, rhs),\n-                        mir::BinOp::Add             => llvm::LLVMConstAdd(lhs, rhs),\n-\n-                        mir::BinOp::Sub if is_float => llvm::LLVMConstFSub(lhs, rhs),\n-                        mir::BinOp::Sub             => llvm::LLVMConstSub(lhs, rhs),\n-\n-                        mir::BinOp::Mul if is_float => llvm::LLVMConstFMul(lhs, rhs),\n-                        mir::BinOp::Mul             => llvm::LLVMConstMul(lhs, rhs),\n-\n-                        mir::BinOp::Div if is_float => llvm::LLVMConstFDiv(lhs, rhs),\n-                        mir::BinOp::Div if signed   => llvm::LLVMConstSDiv(lhs, rhs),\n-                        mir::BinOp::Div             => llvm::LLVMConstUDiv(lhs, rhs),\n+                Const::new(const_scalar_binop(op, lhs, rhs, ty), binop_ty)\n+            }\n \n-                        mir::BinOp::Rem if is_float => llvm::LLVMConstFRem(lhs, rhs),\n-                        mir::BinOp::Rem if signed   => llvm::LLVMConstSRem(lhs, rhs),\n-                        mir::BinOp::Rem             => llvm::LLVMConstURem(lhs, rhs),\n+            mir::Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n+                let lhs = self.const_operand(lhs, span)?;\n+                let rhs = self.const_operand(rhs, span)?;\n+                let ty = lhs.ty;\n+                let val_ty = self.mir.binop_ty(tcx, op, lhs.ty, rhs.ty);\n+                let binop_ty = tcx.mk_tup(vec![val_ty, tcx.types.bool]);\n+                let (lhs, rhs) = (lhs.llval, rhs.llval);\n+                assert!(!ty.is_fp());\n \n-                        mir::BinOp::BitXor => llvm::LLVMConstXor(lhs, rhs),\n-                        mir::BinOp::BitAnd => llvm::LLVMConstAnd(lhs, rhs),\n-                        mir::BinOp::BitOr  => llvm::LLVMConstOr(lhs, rhs),\n-                        mir::BinOp::Shl    => {\n-                            let rhs = base::cast_shift_const_rhs(op.to_hir_binop(), lhs, rhs);\n-                            llvm::LLVMConstShl(lhs, rhs)\n-                        }\n-                        mir::BinOp::Shr    => {\n-                            let rhs = base::cast_shift_const_rhs(op.to_hir_binop(), lhs, rhs);\n-                            if signed { llvm::LLVMConstAShr(lhs, rhs) }\n-                            else      { llvm::LLVMConstLShr(lhs, rhs) }\n-                        }\n-                        mir::BinOp::Eq | mir::BinOp::Ne |\n-                        mir::BinOp::Lt | mir::BinOp::Le |\n-                        mir::BinOp::Gt | mir::BinOp::Ge => {\n-                            if is_float {\n-                                let cmp = base::bin_op_to_fcmp_predicate(op.to_hir_binop());\n-                                llvm::ConstFCmp(cmp, lhs, rhs)\n-                            } else {\n-                                let cmp = base::bin_op_to_icmp_predicate(op.to_hir_binop(),\n-                                                                         signed);\n-                                llvm::ConstICmp(cmp, lhs, rhs)\n-                            }\n-                        }\n+                match const_scalar_checked_binop(tcx, op, lhs, rhs, ty) {\n+                    Some((llval, of)) => {\n+                        let llof = C_bool(self.ccx, of);\n+                        Const::new(C_struct(self.ccx, &[llval, llof], false), binop_ty)\n                     }\n-                };\n-                Const::new(llval, binop_ty)\n+                    None => {\n+                        span_bug!(span, \"{:?} got non-integer operands: {:?} and {:?}\",\n+                                  rvalue, Value(lhs), Value(rhs));\n+                    }\n+                }\n             }\n \n             mir::Rvalue::UnaryOp(op, ref operand) => {\n@@ -792,11 +748,6 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         }\n                     }\n                     mir::UnOp::Neg => {\n-                        if let Some(cval) = to_const_int(lloperand, operand.ty, tcx) {\n-                            consts::const_err(self.ccx, span,\n-                                              (-cval).map_err(ErrKind::Math),\n-                                              TrueConst::Yes)?;\n-                        }\n                         let is_float = operand.ty.is_fp();\n                         unsafe {\n                             if is_float {\n@@ -815,6 +766,97 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n         Ok(val)\n     }\n+\n+}\n+\n+pub fn const_scalar_binop(op: mir::BinOp,\n+                          lhs: ValueRef,\n+                          rhs: ValueRef,\n+                          input_ty: Ty) -> ValueRef {\n+    assert!(!input_ty.is_simd());\n+    let is_float = input_ty.is_fp();\n+    let signed = input_ty.is_signed();\n+\n+    unsafe {\n+        match op {\n+            mir::BinOp::Add if is_float => llvm::LLVMConstFAdd(lhs, rhs),\n+            mir::BinOp::Add             => llvm::LLVMConstAdd(lhs, rhs),\n+\n+            mir::BinOp::Sub if is_float => llvm::LLVMConstFSub(lhs, rhs),\n+            mir::BinOp::Sub             => llvm::LLVMConstSub(lhs, rhs),\n+\n+            mir::BinOp::Mul if is_float => llvm::LLVMConstFMul(lhs, rhs),\n+            mir::BinOp::Mul             => llvm::LLVMConstMul(lhs, rhs),\n+\n+            mir::BinOp::Div if is_float => llvm::LLVMConstFDiv(lhs, rhs),\n+            mir::BinOp::Div if signed   => llvm::LLVMConstSDiv(lhs, rhs),\n+            mir::BinOp::Div             => llvm::LLVMConstUDiv(lhs, rhs),\n+\n+            mir::BinOp::Rem if is_float => llvm::LLVMConstFRem(lhs, rhs),\n+            mir::BinOp::Rem if signed   => llvm::LLVMConstSRem(lhs, rhs),\n+            mir::BinOp::Rem             => llvm::LLVMConstURem(lhs, rhs),\n+\n+            mir::BinOp::BitXor => llvm::LLVMConstXor(lhs, rhs),\n+            mir::BinOp::BitAnd => llvm::LLVMConstAnd(lhs, rhs),\n+            mir::BinOp::BitOr  => llvm::LLVMConstOr(lhs, rhs),\n+            mir::BinOp::Shl    => {\n+                let rhs = base::cast_shift_const_rhs(op.to_hir_binop(), lhs, rhs);\n+                llvm::LLVMConstShl(lhs, rhs)\n+            }\n+            mir::BinOp::Shr    => {\n+                let rhs = base::cast_shift_const_rhs(op.to_hir_binop(), lhs, rhs);\n+                if signed { llvm::LLVMConstAShr(lhs, rhs) }\n+                else      { llvm::LLVMConstLShr(lhs, rhs) }\n+            }\n+            mir::BinOp::Eq | mir::BinOp::Ne |\n+            mir::BinOp::Lt | mir::BinOp::Le |\n+            mir::BinOp::Gt | mir::BinOp::Ge => {\n+                if is_float {\n+                    let cmp = base::bin_op_to_fcmp_predicate(op.to_hir_binop());\n+                    llvm::ConstFCmp(cmp, lhs, rhs)\n+                } else {\n+                    let cmp = base::bin_op_to_icmp_predicate(op.to_hir_binop(),\n+                                                                signed);\n+                    llvm::ConstICmp(cmp, lhs, rhs)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub fn const_scalar_checked_binop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                            op: mir::BinOp,\n+                                            lllhs: ValueRef,\n+                                            llrhs: ValueRef,\n+                                            input_ty: Ty<'tcx>)\n+                                            -> Option<(ValueRef, bool)> {\n+    if let (Some(lhs), Some(rhs)) = (to_const_int(lllhs, input_ty, tcx),\n+                                     to_const_int(llrhs, input_ty, tcx)) {\n+        let result = match op {\n+            mir::BinOp::Add => lhs + rhs,\n+            mir::BinOp::Sub => lhs - rhs,\n+            mir::BinOp::Mul => lhs * rhs,\n+            mir::BinOp::Shl => lhs << rhs,\n+            mir::BinOp::Shr => lhs >> rhs,\n+            _ => {\n+                bug!(\"Operator `{:?}` is not a checkable operator\", op)\n+            }\n+        };\n+\n+        let of = match result {\n+            Ok(_) => false,\n+            Err(ConstMathErr::Overflow(_)) |\n+            Err(ConstMathErr::ShiftNegative) => true,\n+            Err(err) => {\n+                bug!(\"Operator `{:?}` on `{:?}` and `{:?}` errored: {}\",\n+                     op, lhs, rhs, err.description());\n+            }\n+        };\n+\n+        Some((const_scalar_binop(op, lllhs, llrhs, input_ty), of))\n+    } else {\n+        None\n+    }\n }\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {"}]}