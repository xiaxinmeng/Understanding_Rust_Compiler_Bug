{"sha": "5345636f37a2934ea4c183baa2069fa50c6793cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNDU2MzZmMzdhMjkzNGVhNGMxODNiYWEyMDY5ZmE1MGM2NzkzY2M=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-17T08:30:32Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-17T08:54:09Z"}, "message": "use new isize_max method in FS accesses; also check full buffers for validity", "tree": {"sha": "519be1ca1783549d54ef338d54755c98bb6797d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/519be1ca1783549d54ef338d54755c98bb6797d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5345636f37a2934ea4c183baa2069fa50c6793cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5345636f37a2934ea4c183baa2069fa50c6793cc", "html_url": "https://github.com/rust-lang/rust/commit/5345636f37a2934ea4c183baa2069fa50c6793cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5345636f37a2934ea4c183baa2069fa50c6793cc/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f1aec34e1de3cddfa5c7f734ff1690b5cce2b0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f1aec34e1de3cddfa5c7f734ff1690b5cce2b0c", "html_url": "https://github.com/rust-lang/rust/commit/9f1aec34e1de3cddfa5c7f734ff1690b5cce2b0c"}], "stats": {"total": 42, "additions": 23, "deletions": 19}, "files": [{"sha": "9291f3a6e3b20d6c1204962b7b41cff49129c7ab", "filename": "src/shims/fs.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5345636f37a2934ea4c183baa2069fa50c6793cc/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5345636f37a2934ea4c183baa2069fa50c6793cc/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=5345636f37a2934ea4c183baa2069fa50c6793cc", "patch": "@@ -3,7 +3,7 @@ use std::convert::TryFrom;\n use std::fs::{remove_file, File, OpenOptions};\n use std::io::{Read, Write};\n \n-use rustc::ty::layout::Size;\n+use rustc::ty::layout::{Size, Align};\n \n use crate::stacked_borrows::Tag;\n use crate::*;\n@@ -166,18 +166,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"read\")?;\n \n-        let ptr_size = this.pointer_size().bits();\n-\n-        // We cap the number of read bytes to the largest value that we are able to fit in both the\n-        // host's and target's `isize`.\n+        let fd = this.read_scalar(fd_op)?.to_i32()?;\n+        let buf = this.read_scalar(buf_op)?.not_undef()?;\n         let count = this\n             .read_scalar(count_op)?\n-            .to_machine_usize(&*this.tcx)?\n-            .min((1 << (ptr_size - 1)) - 1) // max value of target `isize`\n-            .min(isize::max_value() as u64);\n+            .to_machine_usize(&*this.tcx)?;\n \n-        let fd = this.read_scalar(fd_op)?.to_i32()?;\n-        let buf = this.read_scalar(buf_op)?.not_undef()?;\n+        // Check that the *entire* buffer is actually valid memory.\n+        this.memory.check_ptr_access(buf, Size::from_bytes(count), Align::from_bytes(1).unwrap())?;\n+\n+        // We cap the number of read bytes to the largest value that we are able to fit in both the\n+        // host's and target's `isize`. This saves us from having to handle overflows later.\n+        let count = count\n+            .min(this.isize_max() as u64)\n+            .min(isize::max_value() as u64);\n \n         if let Some(handle) = this.machine.file_handler.handles.get_mut(&fd) {\n             // This can never fail because `count` was capped to be smaller than\n@@ -219,18 +221,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"write\")?;\n \n-        let ptr_size = this.pointer_size().bits();\n-\n-        // We cap the number of read bytes to the largest value that we are able to fit in both the\n-        // host's and target's `isize`.\n+        let fd = this.read_scalar(fd_op)?.to_i32()?;\n+        let buf = this.read_scalar(buf_op)?.not_undef()?;\n         let count = this\n             .read_scalar(count_op)?\n-            .to_machine_usize(&*this.tcx)?\n-            .min((1 << (ptr_size - 1)) - 1) // max value of target `isize`\n-            .min(isize::max_value() as u64);\n+            .to_machine_usize(&*this.tcx)?;\n \n-        let fd = this.read_scalar(fd_op)?.to_i32()?;\n-        let buf = this.read_scalar(buf_op)?.not_undef()?;\n+        // Check that the *entire* buffer is actually valid memory.\n+        this.memory.check_ptr_access(buf, Size::from_bytes(count), Align::from_bytes(1).unwrap())?;\n+\n+        // We cap the number of written bytes to the largest value that we are able to fit in both the\n+        // host's and target's `isize`. This saves us from having to handle overflows later.\n+        let count = count\n+            .min(this.isize_max() as u64)\n+            .min(isize::max_value() as u64);\n \n         if let Some(handle) = this.machine.file_handler.handles.get_mut(&fd) {\n             let bytes = this.memory.read_bytes(buf, Size::from_bytes(count))?;"}]}