{"sha": "9409c208a9a70eb6194c7502979843f42d6fed1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0MDljMjA4YTlhNzBlYjYxOTRjNzUwMjk3OTg0M2Y0MmQ2ZmVkMWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-13T06:51:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-13T06:51:28Z"}, "message": "Auto merge of #66405 - nnethercote:tweak-ObligForest-NodeStates, r=nikomatsakis\n\nRemove `NodeState::{Waiting,Done}`\n\nAn optimization, and then some clean-ups.\n\nr? @nikomatsakis", "tree": {"sha": "b4fd527b8e8073cd6a6f74f17b9d98e0cce39e1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4fd527b8e8073cd6a6f74f17b9d98e0cce39e1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9409c208a9a70eb6194c7502979843f42d6fed1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9409c208a9a70eb6194c7502979843f42d6fed1a", "html_url": "https://github.com/rust-lang/rust/commit/9409c208a9a70eb6194c7502979843f42d6fed1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9409c208a9a70eb6194c7502979843f42d6fed1a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf7e019b42cd523d91cb350ab49acbda1b11e571", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf7e019b42cd523d91cb350ab49acbda1b11e571", "html_url": "https://github.com/rust-lang/rust/commit/cf7e019b42cd523d91cb350ab49acbda1b11e571"}, {"sha": "cb212938d424a94695e35bb92e20613a2af72a0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb212938d424a94695e35bb92e20613a2af72a0f", "html_url": "https://github.com/rust-lang/rust/commit/cb212938d424a94695e35bb92e20613a2af72a0f"}], "stats": {"total": 282, "additions": 153, "deletions": 129}, "files": [{"sha": "b1931ca459f619715193a77cc52945d8f21fc54e", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 153, "deletions": 129, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/9409c208a9a70eb6194c7502979843f42d6fed1a/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9409c208a9a70eb6194c7502979843f42d6fed1a/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=9409c208a9a70eb6194c7502979843f42d6fed1a", "patch": "@@ -128,21 +128,19 @@ type ObligationTreeIdGenerator =\n     ::std::iter::Map<::std::ops::RangeFrom<usize>, fn(usize) -> ObligationTreeId>;\n \n pub struct ObligationForest<O: ForestObligation> {\n-    /// The list of obligations. In between calls to\n-    /// `process_obligations`, this list only contains nodes in the\n-    /// `Pending` or `Success` state (with a non-zero number of\n-    /// incomplete children). During processing, some of those nodes\n-    /// may be changed to the error state, or we may find that they\n-    /// are completed (That is, `num_incomplete_children` drops to 0).\n-    /// At the end of processing, those nodes will be removed by a\n-    /// call to `compress`.\n+    /// The list of obligations. In between calls to `process_obligations`,\n+    /// this list only contains nodes in the `Pending` or `Success` state.\n     ///\n     /// `usize` indices are used here and throughout this module, rather than\n-    /// `rustc_index::newtype_index!` indices, because this code is hot enough that the\n-    /// `u32`-to-`usize` conversions that would be required are significant,\n-    /// and space considerations are not important.\n+    /// `rustc_index::newtype_index!` indices, because this code is hot enough\n+    /// that the `u32`-to-`usize` conversions that would be required are\n+    /// significant, and space considerations are not important.\n     nodes: Vec<Node<O>>,\n \n+    /// The process generation is 1 on the first call to `process_obligations`,\n+    /// 2 on the second call, etc.\n+    gen: u32,\n+\n     /// A cache of predicates that have been successfully completed.\n     done_cache: FxHashSet<O::Predicate>,\n \n@@ -211,31 +209,61 @@ impl<O> Node<O> {\n /// represents the current state of processing for the obligation (of\n /// type `O`) associated with this node.\n ///\n-/// Outside of ObligationForest methods, nodes should be either Pending\n-/// or Waiting.\n+/// The non-`Error` state transitions are as follows.\n+/// ```\n+/// (Pre-creation)\n+///  |\n+///  |     register_obligation_at() (called by process_obligations() and\n+///  v                               from outside the crate)\n+/// Pending\n+///  |\n+///  |     process_obligations()\n+///  v\n+/// Success(not_waiting())\n+///  |  |\n+///  |  |  mark_still_waiting_nodes()\n+///  |  v\n+///  | Success(still_waiting())\n+///  |  |\n+///  |  |  compress()\n+///  v  v\n+/// (Removed)\n+/// ```\n+/// The `Error` state can be introduced in several places, via `error_at()`.\n+///\n+/// Outside of `ObligationForest` methods, nodes should be either `Pending` or\n+/// `Success`.\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n enum NodeState {\n-    /// Obligations for which selection had not yet returned a\n-    /// non-ambiguous result.\n+    /// This obligation has not yet been selected successfully. Cannot have\n+    /// subobligations.\n     Pending,\n \n-    /// This obligation was selected successfully, but may or\n-    /// may not have subobligations.\n-    Success,\n-\n-    /// This obligation was selected successfully, but it has\n-    /// a pending subobligation.\n-    Waiting,\n+    /// This obligation was selected successfully, but it may be waiting on one\n+    /// or more pending subobligations, as indicated by the `WaitingState`.\n+    Success(WaitingState),\n \n-    /// This obligation, along with its subobligations, are complete,\n-    /// and will be removed in the next collection.\n-    Done,\n-\n-    /// This obligation was resolved to an error. Error nodes are\n-    /// removed from the vector by the compression step.\n+    /// This obligation was resolved to an error. It will be removed by the\n+    /// next compression step.\n     Error,\n }\n \n+/// Indicates when a `Success` node was last (if ever) waiting on one or more\n+/// `Pending` nodes. The notion of \"when\" comes from `ObligationForest::gen`.\n+/// - 0: \"Not waiting\". This is a special value, set by `process_obligation`,\n+///   and usable because generation counting starts at 1.\n+/// - 1..ObligationForest::gen: \"Was waiting\" in a previous generation, but\n+///   waiting no longer. In other words, finished.\n+/// - ObligationForest::gen: \"Still waiting\" in this generation.\n+///\n+/// Things to note about this encoding:\n+/// - Every time `ObligationForest::gen` is incremented, all the \"still\n+///   waiting\" nodes automatically become \"was waiting\".\n+/// - `ObligationForest::is_still_waiting` is very cheap.\n+///\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd)]\n+struct WaitingState(u32);\n+\n #[derive(Debug)]\n pub struct Outcome<O, E> {\n     /// Obligations that were completely evaluated, including all\n@@ -272,6 +300,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n     pub fn new() -> ObligationForest<O> {\n         ObligationForest {\n             nodes: vec![],\n+            gen: 0,\n             done_cache: Default::default(),\n             active_cache: Default::default(),\n             node_rewrites: RefCell::new(vec![]),\n@@ -300,10 +329,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         match self.active_cache.entry(obligation.as_predicate().clone()) {\n             Entry::Occupied(o) => {\n-                let index = *o.get();\n-                debug!(\"register_obligation_at({:?}, {:?}) - duplicate of {:?}!\",\n-                       obligation, parent, index);\n-                let node = &mut self.nodes[index];\n+                let node = &mut self.nodes[*o.get()];\n                 if let Some(parent_index) = parent {\n                     // If the node is already in `active_cache`, it has already\n                     // had its chance to be marked with a parent. So if it's\n@@ -320,9 +346,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 }\n             }\n             Entry::Vacant(v) => {\n-                debug!(\"register_obligation_at({:?}, {:?}) - ok, new index is {}\",\n-                       obligation, parent, self.nodes.len());\n-\n                 let obligation_tree_id = match parent {\n                     Some(parent_index) => self.nodes[parent_index].obligation_tree_id,\n                     None => self.obligation_tree_id_generator.next().unwrap(),\n@@ -382,6 +405,18 @@ impl<O: ForestObligation> ObligationForest<O> {\n             .insert(node.obligation.as_predicate().clone());\n     }\n \n+    fn not_waiting() -> WaitingState {\n+        WaitingState(0)\n+    }\n+\n+    fn still_waiting(&self) -> WaitingState {\n+        WaitingState(self.gen)\n+    }\n+\n+    fn is_still_waiting(&self, waiting: WaitingState) -> bool {\n+        waiting.0 == self.gen\n+    }\n+\n     /// Performs a pass through the obligation list. This must\n     /// be called in a loop until `outcome.stalled` is false.\n     ///\n@@ -390,7 +425,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                                   -> Outcome<O, P::Error>\n         where P: ObligationProcessor<Obligation=O>\n     {\n-        debug!(\"process_obligations(len={})\", self.nodes.len());\n+        self.gen += 1;\n \n         let mut errors = vec![];\n         let mut stalled = true;\n@@ -407,8 +442,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n         while index < self.nodes.len() {\n             let node = &mut self.nodes[index];\n \n-            debug!(\"process_obligations: node {} == {:?}\", index, node);\n-\n             // `processor.process_obligation` can modify the predicate within\n             // `node.obligation`, and that predicate is the key used for\n             // `self.active_cache`. This means that `self.active_cache` can get\n@@ -418,18 +451,15 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 index += 1;\n                 continue;\n             }\n-            let result = processor.process_obligation(&mut node.obligation);\n \n-            debug!(\"process_obligations: node {} got result {:?}\", index, result);\n-\n-            match result {\n+            match processor.process_obligation(&mut node.obligation) {\n                 ProcessResult::Unchanged => {\n                     // No change in state.\n                 }\n                 ProcessResult::Changed(children) => {\n                     // We are not (yet) stalled.\n                     stalled = false;\n-                    node.state.set(NodeState::Success);\n+                    node.state.set(NodeState::Success(Self::not_waiting()));\n \n                     for child in children {\n                         let st = self.register_obligation_at(\n@@ -464,69 +494,17 @@ impl<O: ForestObligation> ObligationForest<O> {\n             };\n         }\n \n-        self.mark_as_waiting();\n+        self.mark_still_waiting_nodes();\n         self.process_cycles(processor);\n         let completed = self.compress(do_completed);\n \n-        debug!(\"process_obligations: complete\");\n-\n         Outcome {\n             completed,\n             errors,\n             stalled,\n         }\n     }\n \n-    /// Mark all `NodeState::Success` nodes as `NodeState::Done` and\n-    /// report all cycles between them. This should be called\n-    /// after `mark_as_waiting` marks all nodes with pending\n-    /// subobligations as NodeState::Waiting.\n-    fn process_cycles<P>(&self, processor: &mut P)\n-        where P: ObligationProcessor<Obligation=O>\n-    {\n-        let mut stack = vec![];\n-\n-        debug!(\"process_cycles()\");\n-\n-        for (index, node) in self.nodes.iter().enumerate() {\n-            // For some benchmarks this state test is extremely\n-            // hot. It's a win to handle the no-op cases immediately to avoid\n-            // the cost of the function call.\n-            if node.state.get() == NodeState::Success {\n-                self.find_cycles_from_node(&mut stack, processor, index);\n-            }\n-        }\n-\n-        debug!(\"process_cycles: complete\");\n-\n-        debug_assert!(stack.is_empty());\n-    }\n-\n-    fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>, processor: &mut P, index: usize)\n-        where P: ObligationProcessor<Obligation=O>\n-    {\n-        let node = &self.nodes[index];\n-        if node.state.get() == NodeState::Success {\n-            match stack.iter().rposition(|&n| n == index) {\n-                None => {\n-                    stack.push(index);\n-                    for &index in node.dependents.iter() {\n-                        self.find_cycles_from_node(stack, processor, index);\n-                    }\n-                    stack.pop();\n-                    node.state.set(NodeState::Done);\n-                }\n-                Some(rpos) => {\n-                    // Cycle detected.\n-                    processor.process_backedge(\n-                        stack[rpos..].iter().map(GetObligation(&self.nodes)),\n-                        PhantomData\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n     /// Returns a vector of obligations for `p` and all of its\n     /// ancestors, putting them into the error state in the process.\n     fn error_at(&self, mut index: usize) -> Vec<O> {\n@@ -560,64 +538,105 @@ impl<O: ForestObligation> ObligationForest<O> {\n         trace\n     }\n \n+    /// Mark all `Success` nodes that depend on a pending node as still\n+    /// waiting. Upon completion, any `Success` nodes that aren't still waiting\n+    /// can be removed by `compress`.\n+    fn mark_still_waiting_nodes(&self) {\n+        for node in &self.nodes {\n+            if node.state.get() == NodeState::Pending {\n+                // This call site is hot.\n+                self.inlined_mark_dependents_as_still_waiting(node);\n+            }\n+        }\n+    }\n+\n     // This always-inlined function is for the hot call site.\n     #[inline(always)]\n-    fn inlined_mark_neighbors_as_waiting_from(&self, node: &Node<O>) {\n+    fn inlined_mark_dependents_as_still_waiting(&self, node: &Node<O>) {\n         for &index in node.dependents.iter() {\n             let node = &self.nodes[index];\n-            match node.state.get() {\n-                NodeState::Waiting | NodeState::Error => {}\n-                NodeState::Success => {\n-                    node.state.set(NodeState::Waiting);\n-                    // This call site is cold.\n-                    self.uninlined_mark_neighbors_as_waiting_from(node);\n-                }\n-                NodeState::Pending | NodeState::Done => {\n+            if let NodeState::Success(waiting) = node.state.get() {\n+                if !self.is_still_waiting(waiting) {\n+                    node.state.set(NodeState::Success(self.still_waiting()));\n                     // This call site is cold.\n-                    self.uninlined_mark_neighbors_as_waiting_from(node);\n+                    self.uninlined_mark_dependents_as_still_waiting(node);\n                 }\n             }\n         }\n     }\n \n     // This never-inlined function is for the cold call site.\n     #[inline(never)]\n-    fn uninlined_mark_neighbors_as_waiting_from(&self, node: &Node<O>) {\n-        self.inlined_mark_neighbors_as_waiting_from(node)\n+    fn uninlined_mark_dependents_as_still_waiting(&self, node: &Node<O>) {\n+        self.inlined_mark_dependents_as_still_waiting(node)\n     }\n \n-    /// Marks all nodes that depend on a pending node as `NodeState::Waiting`.\n-    fn mark_as_waiting(&self) {\n-        for node in &self.nodes {\n-            if node.state.get() == NodeState::Waiting {\n-                node.state.set(NodeState::Success);\n+    /// Report cycles between all `Success` nodes that aren't still waiting.\n+    /// This must be called after `mark_still_waiting_nodes`.\n+    fn process_cycles<P>(&self, processor: &mut P)\n+        where P: ObligationProcessor<Obligation=O>\n+    {\n+        let mut stack = vec![];\n+\n+        for (index, node) in self.nodes.iter().enumerate() {\n+            // For some benchmarks this state test is extremely hot. It's a win\n+            // to handle the no-op cases immediately to avoid the cost of the\n+            // function call.\n+            if let NodeState::Success(waiting) = node.state.get() {\n+                if !self.is_still_waiting(waiting) {\n+                    self.find_cycles_from_node(&mut stack, processor, index, index);\n+                }\n             }\n         }\n \n-        for node in &self.nodes {\n-            if node.state.get() == NodeState::Pending {\n-                // This call site is hot.\n-                self.inlined_mark_neighbors_as_waiting_from(node);\n+        debug_assert!(stack.is_empty());\n+    }\n+\n+    fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>, processor: &mut P, min_index: usize,\n+                                index: usize)\n+        where P: ObligationProcessor<Obligation=O>\n+    {\n+        let node = &self.nodes[index];\n+        if let NodeState::Success(waiting) = node.state.get() {\n+            if !self.is_still_waiting(waiting) {\n+                match stack.iter().rposition(|&n| n == index) {\n+                    None => {\n+                        stack.push(index);\n+                        for &dep_index in node.dependents.iter() {\n+                            // The index check avoids re-considering a node.\n+                            if dep_index >= min_index {\n+                                self.find_cycles_from_node(stack, processor, min_index, dep_index);\n+                            }\n+                        }\n+                        stack.pop();\n+                    }\n+                    Some(rpos) => {\n+                        // Cycle detected.\n+                        processor.process_backedge(\n+                            stack[rpos..].iter().map(GetObligation(&self.nodes)),\n+                            PhantomData\n+                        );\n+                    }\n+                }\n             }\n         }\n     }\n \n     /// Compresses the vector, removing all popped nodes. This adjusts the\n-    /// indices and hence invalidates any outstanding indices.\n-    ///\n-    /// Beforehand, all nodes must be marked as `Done` and no cycles\n-    /// on these nodes may be present. This is done by e.g., `process_cycles`.\n+    /// indices and hence invalidates any outstanding indices. `process_cycles`\n+    /// must be run beforehand to remove any cycles on not-still-waiting\n+    /// `Success` nodes.\n     #[inline(never)]\n     fn compress(&mut self, do_completed: DoCompleted) -> Option<Vec<O>> {\n         let orig_nodes_len = self.nodes.len();\n         let mut node_rewrites: Vec<_> = self.node_rewrites.replace(vec![]);\n         debug_assert!(node_rewrites.is_empty());\n         node_rewrites.extend(0..orig_nodes_len);\n         let mut dead_nodes = 0;\n-        let mut removed_done_obligations: Vec<O> = vec![];\n+        let mut removed_success_obligations: Vec<O> = vec![];\n \n-        // Now move all Done/Error nodes to the end, preserving the order of\n-        // the Pending/Waiting nodes.\n+        // Move removable nodes to the end, preserving the order of the\n+        // remaining nodes.\n         //\n         // LOOP INVARIANT:\n         //     self.nodes[0..index - dead_nodes] are the first remaining nodes\n@@ -626,13 +645,19 @@ impl<O: ForestObligation> ObligationForest<O> {\n         for index in 0..orig_nodes_len {\n             let node = &self.nodes[index];\n             match node.state.get() {\n-                NodeState::Pending | NodeState::Waiting => {\n+                NodeState::Pending => {\n+                    if dead_nodes > 0 {\n+                        self.nodes.swap(index, index - dead_nodes);\n+                        node_rewrites[index] -= dead_nodes;\n+                    }\n+                }\n+                NodeState::Success(waiting) if self.is_still_waiting(waiting) => {\n                     if dead_nodes > 0 {\n                         self.nodes.swap(index, index - dead_nodes);\n                         node_rewrites[index] -= dead_nodes;\n                     }\n                 }\n-                NodeState::Done => {\n+                NodeState::Success(_) => {\n                     // This lookup can fail because the contents of\n                     // `self.active_cache` are not guaranteed to match those of\n                     // `self.nodes`. See the comment in `process_obligation`\n@@ -646,7 +671,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     }\n                     if do_completed == DoCompleted::Yes {\n                         // Extract the success stories.\n-                        removed_done_obligations.push(node.obligation.clone());\n+                        removed_success_obligations.push(node.obligation.clone());\n                     }\n                     node_rewrites[index] = orig_nodes_len;\n                     dead_nodes += 1;\n@@ -660,7 +685,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     node_rewrites[index] = orig_nodes_len;\n                     dead_nodes += 1;\n                 }\n-                NodeState::Success => unreachable!()\n             }\n         }\n \n@@ -674,7 +698,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         self.node_rewrites.replace(node_rewrites);\n \n         if do_completed == DoCompleted::Yes {\n-            Some(removed_done_obligations)\n+            Some(removed_success_obligations)\n         } else {\n             None\n         }"}]}