{"sha": "45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1YzhjNTY3OGEzMDY1YzVkMWY3NWIyNDEzYmQ4MDBhNzkyY2YzZDk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-26T00:41:06Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-26T11:41:28Z"}, "message": "rustc: rename TyCtxt's `map` field to `hir`.", "tree": {"sha": "4a5407ec9fd25d87232d027012ea6fd1c8698c69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a5407ec9fd25d87232d027012ea6fd1c8698c69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "html_url": "https://github.com/rust-lang/rust/commit/45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f0463a4a4f323c4deffc861349e38c6b5091782", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f0463a4a4f323c4deffc861349e38c6b5091782", "html_url": "https://github.com/rust-lang/rust/commit/2f0463a4a4f323c4deffc861349e38c6b5091782"}], "stats": {"total": 1522, "additions": 761, "deletions": 761}, "files": [{"sha": "595059332895de875da28ed8b7c86ed9482e7d7a", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -46,18 +46,18 @@ pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Find the function this expression is from.\n     let mut node_id = body.id;\n     loop {\n-        let node = tcx.map.get(node_id);\n+        let node = tcx.hir.get(node_id);\n         if hir::map::blocks::FnLikeNode::from_node(node).is_some() {\n             break;\n         }\n-        let parent = tcx.map.get_parent_node(node_id);\n+        let parent = tcx.hir.get_parent_node(node_id);\n         assert!(node_id != parent);\n         node_id = parent;\n     }\n \n     let mut cfg_builder = CFGBuilder {\n         tcx: tcx,\n-        tables: tcx.item_tables(tcx.map.local_def_id(node_id)),\n+        tables: tcx.item_tables(tcx.hir.local_def_id(node_id)),\n         graph: graph,\n         fn_exit: fn_exit,\n         loop_scopes: Vec::new()"}, {"sha": "df6db366df5b36bd6426bd9acbb65c2f5a52aeaf", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -29,10 +29,10 @@ pub enum DepNode<D: Clone + Debug> {\n     // Represents the `Krate` as a whole (the `hir::Krate` value) (as\n     // distinct from the krate module). This is basically a hash of\n     // the entire krate, so if you read from `Krate` (e.g., by calling\n-    // `tcx.map.krate()`), we will have to assume that any change\n+    // `tcx.hir.krate()`), we will have to assume that any change\n     // means that you need to be recompiled. This is because the\n     // `Krate` value gives you access to all other items. To avoid\n-    // this fate, do not call `tcx.map.krate()`; instead, prefer\n+    // this fate, do not call `tcx.hir.krate()`; instead, prefer\n     // wrappers like `tcx.visit_all_items_in_krate()`.  If there is no\n     // suitable wrapper, you can use `tcx.dep_graph.ignore()` to gain\n     // access to the krate, but you must remember to add suitable"}, {"sha": "9660758220368c47270733b367da00600076f653", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -117,7 +117,7 @@ impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n     ///\n     /// ```\n     /// fn type_of_item(..., item: &hir::Item) -> Ty<'tcx> {\n-    ///     let item_def_id = ccx.tcx.map.local_def_id(it.id);\n+    ///     let item_def_id = ccx.tcx.hir.local_def_id(it.id);\n     ///     ccx.tcx.item_types.memoized(item_def_id, || {\n     ///         ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id)); // (*)\n     ///         compute_type_of_item(ccx, item)"}, {"sha": "f0a81fd1cfd334f061686970ed6a8a69d9b58201", "filename": "src/librustc/dep_graph/visit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -36,7 +36,7 @@ pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n         where F: FnMut(DefId) -> DepNode<DefId>, V: ItemLikeVisitor<'tcx>\n     {\n         fn visit_item(&mut self, i: &'tcx hir::Item) {\n-            let item_def_id = self.tcx.map.local_def_id(i.id);\n+            let item_def_id = self.tcx.hir.local_def_id(i.id);\n             let task_id = (self.dep_node_fn)(item_def_id);\n             let _task = self.tcx.dep_graph.in_task(task_id.clone());\n             debug!(\"Started task {:?}\", task_id);\n@@ -46,7 +46,7 @@ pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n         }\n \n         fn visit_trait_item(&mut self, i: &'tcx hir::TraitItem) {\n-            let trait_item_def_id = self.tcx.map.local_def_id(i.id);\n+            let trait_item_def_id = self.tcx.hir.local_def_id(i.id);\n             let task_id = (self.dep_node_fn)(trait_item_def_id);\n             let _task = self.tcx.dep_graph.in_task(task_id.clone());\n             debug!(\"Started task {:?}\", task_id);\n@@ -56,7 +56,7 @@ pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n         }\n \n         fn visit_impl_item(&mut self, i: &'tcx hir::ImplItem) {\n-            let impl_item_def_id = self.tcx.map.local_def_id(i.id);\n+            let impl_item_def_id = self.tcx.hir.local_def_id(i.id);\n             let task_id = (self.dep_node_fn)(impl_item_def_id);\n             let _task = self.tcx.dep_graph.in_task(task_id.clone());\n             debug!(\"Started task {:?}\", task_id);\n@@ -66,7 +66,7 @@ pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n         }\n     }\n \n-    let krate = tcx.dep_graph.with_ignore(|| tcx.map.krate());\n+    let krate = tcx.dep_graph.with_ignore(|| tcx.hir.krate());\n     let mut tracking_visitor = TrackingVisitor {\n         tcx: tcx,\n         dep_node_fn: &mut dep_node_fn,"}, {"sha": "0d79017066b01da6946a97a70559737aa8596de7", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -44,7 +44,7 @@ use super::intravisit::Visitor;\n ///    - How: Implement `intravisit::Visitor` and override the\n ///      `visit_nested_map()` methods to return\n ///      `NestedVisitorMap::All`. Walk your crate with\n-///      `intravisit::walk_crate()` invoked on `tcx.map.krate()`.\n+///      `intravisit::walk_crate()` invoked on `tcx.hir.krate()`.\n ///    - Pro: Visitor methods for any kind of HIR node, not just item-like things.\n ///    - Pro: Preserves nesting information\n ///    - Con: Does not integrate well into dependency tracking."}, {"sha": "0b43f32e3dc291f321cb6a8b03ad844c6d3b4b3d", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -144,14 +144,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     format!(\"{}unknown scope: {:?}{}.  Please report a bug.\",\n                             prefix, scope, suffix)\n                 };\n-                let span = match scope.span(&self.region_maps, &self.map) {\n+                let span = match scope.span(&self.region_maps, &self.hir) {\n                     Some(s) => s,\n                     None => {\n                         err.note(&unknown_scope());\n                         return;\n                     }\n                 };\n-                let tag = match self.map.find(scope.node_id(&self.region_maps)) {\n+                let tag = match self.hir.find(scope.node_id(&self.region_maps)) {\n                     Some(ast_map::NodeBlock(_)) => \"block\",\n                     Some(ast_map::NodeExpr(expr)) => match expr.node {\n                         hir::ExprCall(..) => \"call\",\n@@ -206,7 +206,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n                 let node = fr.scope.node_id(&self.region_maps);\n                 let unknown;\n-                let tag = match self.map.find(node) {\n+                let tag = match self.hir.find(node) {\n                     Some(ast_map::NodeBlock(_)) |\n                     Some(ast_map::NodeExpr(_)) => \"body\",\n                     Some(ast_map::NodeItem(it)) => item_scope_tag(&it),\n@@ -218,7 +218,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     Some(_) => {\n                         unknown = format!(\"unexpected node ({}) for scope {:?}.  \\\n                                            Please report a bug.\",\n-                                          self.map.node_to_string(node), fr.scope);\n+                                          self.hir.node_to_string(node), fr.scope);\n                         &unknown\n                     }\n                     None => {\n@@ -227,7 +227,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         &unknown\n                     }\n                 };\n-                let (msg, opt_span) = explain_span(self, tag, self.map.span(node));\n+                let (msg, opt_span) = explain_span(self, tag, self.hir.span(node));\n                 (format!(\"{} {}\", prefix, msg), opt_span)\n             }\n \n@@ -467,8 +467,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 },\n                 _ => return None\n             };\n-            let parent = tcx.map.get_parent(scope_id);\n-            let parent_node = tcx.map.find(parent);\n+            let parent = tcx.hir.get_parent(scope_id);\n+            let parent_node = tcx.hir.find(parent);\n             match parent_node {\n                 Some(node) => match node {\n                     ast_map::NodeItem(item) => match item.node {\n@@ -1068,8 +1068,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     fn give_suggestion(&self, err: &mut DiagnosticBuilder, same_regions: &[SameRegions]) {\n         let scope_id = same_regions[0].scope_id;\n-        let parent = self.tcx.map.get_parent(scope_id);\n-        let parent_node = self.tcx.map.find(parent);\n+        let parent = self.tcx.hir.get_parent(scope_id);\n+        let parent_node = self.tcx.hir.find(parent);\n         let taken = lifetimes_in_scope(self.tcx, scope_id);\n         let life_giver = LifeGiver::with_taken(&taken[..]);\n         let node_inner = match parent_node {\n@@ -1083,8 +1083,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n                 ast_map::NodeImplItem(item) => {\n-                    let id = self.tcx.map.get_parent(item.id);\n-                    if let Some(ast_map::NodeItem(parent_scope)) = self.tcx.map.find(id) {\n+                    let id = self.tcx.hir.get_parent(item.id);\n+                    if let Some(ast_map::NodeItem(parent_scope)) = self.tcx.hir.find(id) {\n                         if let hir::ItemImpl(_, _, _, None, _, _) = parent_scope.node {\n                             // this impl scope implements a trait, do not recomend\n                             // using explicit lifetimes (#37363)\n@@ -1654,7 +1654,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 generics: &hir::Generics,\n                                 span: Span,\n                                 body: hir::BodyId) {\n-        let s = hir::print::to_string(&self.tcx.map, |s| {\n+        let s = hir::print::to_string(&self.tcx.hir, |s| {\n             use syntax::abi::Abi;\n             use syntax::print::pprust::PrintState;\n \n@@ -1891,8 +1891,8 @@ fn lifetimes_in_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                       scope_id: ast::NodeId)\n                                       -> Vec<hir::LifetimeDef> {\n     let mut taken = Vec::new();\n-    let parent = tcx.map.get_parent(scope_id);\n-    let method_id_opt = match tcx.map.find(parent) {\n+    let parent = tcx.hir.get_parent(scope_id);\n+    let method_id_opt = match tcx.hir.find(parent) {\n         Some(node) => match node {\n             ast_map::NodeItem(item) => match item.node {\n                 hir::ItemFn(.., ref gen, _) => {\n@@ -1915,8 +1915,8 @@ fn lifetimes_in_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         None => None\n     };\n     if let Some(method_id) = method_id_opt {\n-        let parent = tcx.map.get_parent(method_id);\n-        if let Some(node) = tcx.map.find(parent) {\n+        let parent = tcx.hir.get_parent(method_id);\n+        if let Some(node) = tcx.hir.find(parent) {\n             match node {\n                 ast_map::NodeItem(item) => match item.node {\n                     hir::ItemImpl(_, _, ref gen, ..) => {"}, {"sha": "45a58333f781f1c5b340ae58e2e59df6d2d3436b", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -453,8 +453,8 @@ impl<'a, 'tcx> InferEnv<'a, 'tcx> for hir::BodyId {\n                 -> (Option<&'a ty::TypeckTables<'tcx>>,\n                     Option<ty::TypeckTables<'tcx>>,\n                     Option<ty::ParameterEnvironment<'tcx>>) {\n-        let item_id = tcx.map.body_owner(self);\n-        (Some(tcx.item_tables(tcx.map.local_def_id(item_id))),\n+        let item_id = tcx.hir.body_owner(self);\n+        (Some(tcx.item_tables(tcx.hir.local_def_id(item_id))),\n          None,\n          Some(ty::ParameterEnvironment::for_item(tcx, item_id)))\n     }\n@@ -1269,7 +1269,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 self.tcx.types.err,\n             None => {\n                 bug!(\"no type for node {}: {} in fcx\",\n-                     id, self.tcx.map.node_to_string(id));\n+                     id, self.tcx.hir.node_to_string(id));\n             }\n         }\n     }\n@@ -1639,7 +1639,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         -> Option<ty::ClosureKind>\n     {\n         if let InferTables::InProgress(tables) = self.tables {\n-            if let Some(id) = self.tcx.map.as_local_node_id(def_id) {\n+            if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n                 return tables.borrow().closure_kinds.get(&id).cloned();\n             }\n         }\n@@ -1657,7 +1657,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         -> ty::ClosureTy<'tcx>\n     {\n         if let InferTables::InProgress(tables) = self.tables {\n-            if let Some(id) = self.tcx.map.as_local_node_id(def_id) {\n+            if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n                 if let Some(ty) = tables.borrow().closure_tys.get(&id) {\n                     return ty.subst(self.tcx, substs.substs);\n                 }"}, {"sha": "3506a9c067ca6ddcce00fb6b3c870ddae5507651", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -768,7 +768,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     /// items in the context of the outer item, so enable\n     /// deep-walking.\n     fn nested_visit_map<'this>(&'this mut self) -> hir_visit::NestedVisitorMap<'this, 'tcx> {\n-        hir_visit::NestedVisitorMap::All(&self.tcx.map)\n+        hir_visit::NestedVisitorMap::All(&self.tcx.hir)\n     }\n \n     // Output any lints that were previously added to the session.\n@@ -784,7 +784,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         let old_tables = self.tables;\n         self.tables = self.tcx.body_tables(body);\n-        let body = self.tcx.map.body(body);\n+        let body = self.tcx.hir.body(body);\n         self.visit_body(body);\n         self.tables = old_tables;\n     }\n@@ -834,7 +834,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         // in order for `check_fn` to be able to use them.\n         let old_tables = self.tables;\n         self.tables = self.tcx.body_tables(body_id);\n-        let body = self.tcx.map.body(body_id);\n+        let body = self.tcx.hir.body(body_id);\n         run_lints!(self, check_fn, late_passes, fk, decl, body, span, id);\n         hir_visit::walk_fn(self, fk, decl, body_id, span, id);\n         run_lints!(self, check_fn_post, late_passes, fk, decl, body, span, id);\n@@ -1206,7 +1206,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              access_levels: &AccessLevels) {\n     let _task = tcx.dep_graph.in_task(DepNode::LateLintCheck);\n \n-    let krate = tcx.map.krate();\n+    let krate = tcx.hir.krate();\n \n     // We want to own the lint store, so move it out of the session.\n     let lint_store = mem::replace(&mut *tcx.sess.lint_store.borrow_mut(), LintStore::new());\n@@ -1236,7 +1236,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         for early_lint in v {\n             span_bug!(early_lint.diagnostic.span.clone(),\n                       \"unprocessed lint {:?} at {}\",\n-                      early_lint, tcx.map.node_to_string(*id));\n+                      early_lint, tcx.hir.node_to_string(*id));\n         }\n     }\n "}, {"sha": "7d62103e386c41bba88c14f993652d4a04a79370", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -109,7 +109,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O> {\n     fn nested(&self, state: &mut pprust::State, nested: pprust::Nested) -> io::Result<()> {\n-        pprust::PpAnn::nested(&self.tcx.map, state, nested)\n+        pprust::PpAnn::nested(&self.tcx.hir, state, nested)\n     }\n     fn pre(&self,\n            ps: &mut pprust::State,"}, {"sha": "fe1dadca05134484945d750e43c6fe14976f6c14", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -35,7 +35,7 @@ use syntax_pos;\n // may need to be marked as live.\n fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             node_id: ast::NodeId) -> bool {\n-    match tcx.map.find(node_id) {\n+    match tcx.hir.find(node_id) {\n         Some(ast_map::NodeItem(..)) |\n         Some(ast_map::NodeImplItem(..)) |\n         Some(ast_map::NodeForeignItem(..)) |\n@@ -59,7 +59,7 @@ struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn check_def_id(&mut self, def_id: DefId) {\n-        if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+        if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n             if should_explore(self.tcx, node_id) {\n                 self.worklist.push(node_id);\n             }\n@@ -68,7 +68,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn insert_def_id(&mut self, def_id: DefId) {\n-        if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+        if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n             debug_assert!(!should_explore(self.tcx, node_id));\n             self.live_symbols.insert(node_id);\n         }\n@@ -143,7 +143,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             }\n             scanned.insert(id);\n \n-            if let Some(ref node) = self.tcx.map.find(id) {\n+            if let Some(ref node) = self.tcx.hir.find(id) {\n                 self.live_symbols.insert(id);\n                 self.visit_node(node);\n             }\n@@ -203,7 +203,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         let old_tables = self.tables;\n         self.tables = self.tcx.body_tables(body);\n-        let body = self.tcx.map.body(body);\n+        let body = self.tcx.hir.body(body);\n         self.visit_body(body);\n         self.tables = old_tables;\n     }\n@@ -434,7 +434,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n-        let field_type = self.tcx.item_type(self.tcx.map.local_def_id(field.id));\n+        let field_type = self.tcx.item_type(self.tcx.hir.local_def_id(field.id));\n         let is_marker_field = match field_type.ty_to_def_id() {\n             Some(def_id) => self.tcx.lang_items.items().iter().any(|item| *item == Some(def_id)),\n             _ => false\n@@ -478,10 +478,10 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // method of a private type is used, but the type itself is never\n         // called directly.\n         if let Some(impl_list) =\n-                self.tcx.inherent_impls.borrow().get(&self.tcx.map.local_def_id(id)) {\n+                self.tcx.inherent_impls.borrow().get(&self.tcx.hir.local_def_id(id)) {\n             for &impl_did in impl_list.iter() {\n                 for &item_did in &self.tcx.associated_item_def_ids(impl_did)[..] {\n-                    if let Some(item_node_id) = self.tcx.map.as_local_node_id(item_did) {\n+                    if let Some(item_node_id) = self.tcx.hir.as_local_node_id(item_did) {\n                         if self.live_symbols.contains(&item_node_id) {\n                             return true;\n                         }\n@@ -514,7 +514,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     /// an error. We could do this also by checking the parents, but\n     /// this is how the code is setup and it seems harmless enough.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.tcx.map)\n+        NestedVisitorMap::All(&self.tcx.hir)\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -596,7 +596,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              access_levels: &privacy::AccessLevels) {\n     let _task = tcx.dep_graph.in_task(DepNode::DeadCheck);\n-    let krate = tcx.map.krate();\n+    let krate = tcx.hir.krate();\n     let live_symbols = find_live(tcx, access_levels, krate);\n     let mut visitor = DeadVisitor { tcx: tcx, live_symbols: live_symbols };\n     intravisit::walk_crate(&mut visitor, krate);"}, {"sha": "ab33c3843aae5d6c0a9a1db6fe8b3726dfc19888", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         let old_tables = self.tables;\n         self.tables = self.tcx.body_tables(body);\n-        let body = self.tcx.map.body(body);\n+        let body = self.tcx.hir.body(body);\n         self.visit_body(body);\n         self.tables = old_tables;\n     }\n@@ -203,7 +203,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n                 if let Def::Static(def_id, mutbl) = path.def {\n                     if mutbl {\n                         self.require_unsafe(expr.span, \"use of mutable static\");\n-                    } else if match self.tcx.map.get_if_local(def_id) {\n+                    } else if match self.tcx.hir.get_if_local(def_id) {\n                         Some(hir::map::NodeForeignItem(..)) => true,\n                         Some(..) => false,\n                         None => self.tcx.sess.cstore.is_foreign_item(def_id),\n@@ -249,5 +249,5 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         unsafe_context: UnsafeContext::new(SafeContext),\n     };\n \n-    tcx.map.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n+    tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n }"}, {"sha": "738bd0009abae636b395a0c9f6f6ec3b61c035fe", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -1020,7 +1020,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         self.tcx().with_freevars(closure_expr.id, |freevars| {\n             for freevar in freevars {\n                 let def_id = freevar.def.def_id();\n-                let id_var = self.tcx().map.as_local_node_id(def_id).unwrap();\n+                let id_var = self.tcx().hir.as_local_node_id(def_id).unwrap();\n                 let upvar_id = ty::UpvarId { var_id: id_var,\n                                              closure_expr_id: closure_expr.id };\n                 let upvar_capture = self.mc.infcx.upvar_capture(upvar_id).unwrap();\n@@ -1052,7 +1052,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         -> mc::McResult<mc::cmt<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n-        let var_id = self.tcx().map.as_local_node_id(upvar_def.def_id()).unwrap();\n+        let var_id = self.tcx().hir.as_local_node_id(upvar_def.def_id()).unwrap();\n         let var_ty = self.mc.infcx.node_ty(var_id)?;\n         self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }"}, {"sha": "05be35df959915f79434d403ad137ecd4fb84c14", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -110,7 +110,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ItemVisitor<'a, 'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n-        let body = self.tcx.map.body(body_id);\n+        let body = self.tcx.hir.body(body_id);\n         self.tcx.infer_ctxt(body_id, Reveal::All).enter(|infcx| {\n             let mut visitor = ExprVisitor {\n                 infcx: &infcx"}, {"sha": "7fa3365694c269967868deb358faa7be9bd75250", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -183,7 +183,7 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt) -> String {\n \n impl<'a, 'tcx> Visitor<'tcx> for IrMaps<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n@@ -197,7 +197,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IrMaps<'a, 'tcx> {\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _task = tcx.dep_graph.in_task(DepNode::Liveness);\n-    tcx.map.krate().visit_all_item_likes(&mut IrMaps::new(tcx).as_deep_visitor());\n+    tcx.hir.krate().visit_all_item_likes(&mut IrMaps::new(tcx).as_deep_visitor());\n     tcx.sess.abort_if_errors();\n }\n \n@@ -364,7 +364,7 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n \n     debug!(\"creating fn_maps: {:?}\", &fn_maps as *const IrMaps);\n \n-    let body = ir.tcx.map.body(body_id);\n+    let body = ir.tcx.hir.body(body_id);\n \n     for arg in &body.arguments {\n         arg.pat.each_binding(|_bm, arg_id, _x, path1| {\n@@ -440,7 +440,7 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n         ir.tcx.with_freevars(expr.id, |freevars| {\n             for fv in freevars {\n                 if let Def::Local(def_id) = fv.def {\n-                    let rv = ir.tcx.map.as_local_node_id(def_id).unwrap();\n+                    let rv = ir.tcx.hir.as_local_node_id(def_id).unwrap();\n                     let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n                     call_caps.push(CaptureInfo {ln: fv_ln,\n                                                 var_nid: rv});\n@@ -807,7 +807,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n \n-        debug!(\"compute: using id for body, {}\", self.ir.tcx.map.node_to_pretty_string(body.id));\n+        debug!(\"compute: using id for body, {}\", self.ir.tcx.hir.node_to_pretty_string(body.id));\n \n         let exit_ln = self.s.exit_ln;\n         let entry_ln: LiveNode = self.with_loop_nodes(body.id, exit_ln, exit_ln, |this| {\n@@ -900,7 +900,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn propagate_through_expr(&mut self, expr: &Expr, succ: LiveNode)\n                               -> LiveNode {\n-        debug!(\"propagate_through_expr: {}\", self.ir.tcx.map.node_to_pretty_string(expr.id));\n+        debug!(\"propagate_through_expr: {}\", self.ir.tcx.hir.node_to_pretty_string(expr.id));\n \n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n@@ -919,7 +919,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprClosure(.., blk_id, _) => {\n               debug!(\"{} is an ExprClosure\",\n-                     self.ir.tcx.map.node_to_pretty_string(expr.id));\n+                     self.ir.tcx.hir.node_to_pretty_string(expr.id));\n \n               /*\n               The next-node for a break is the successor of the entire\n@@ -1241,7 +1241,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                    -> LiveNode {\n         match path.def {\n           Def::Local(def_id) => {\n-            let nid = self.ir.tcx.map.as_local_node_id(def_id).unwrap();\n+            let nid = self.ir.tcx.hir.as_local_node_id(def_id).unwrap();\n             let ln = self.live_node(id, path.span);\n             if acc != 0 {\n                 self.init_from_succ(ln, succ);\n@@ -1295,7 +1295,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n         }\n         debug!(\"propagate_through_loop: using id for loop body {} {}\",\n-               expr.id, self.ir.tcx.map.node_to_pretty_string(body.id));\n+               expr.id, self.ir.tcx.hir.node_to_pretty_string(body.id));\n \n         let cond_ln = match kind {\n             LoopLoop => ln,\n@@ -1440,7 +1440,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                  entry_ln: LiveNode,\n                  body: &hir::Body)\n     {\n-        let fn_ty = self.ir.tcx.item_type(self.ir.tcx.map.local_def_id(id));\n+        let fn_ty = self.ir.tcx.item_type(self.ir.tcx.hir.local_def_id(id));\n         let fn_ret = match fn_ty.sty {\n             ty::TyClosure(closure_def_id, substs) =>\n                 self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n@@ -1477,7 +1477,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     // if there is no later assignment. If this local is actually\n                     // mutable, then check for a reassignment to flag the mutability\n                     // as being used.\n-                    let nid = self.ir.tcx.map.as_local_node_id(def_id).unwrap();\n+                    let nid = self.ir.tcx.hir.as_local_node_id(def_id).unwrap();\n                     let ln = self.live_node(expr.id, expr.span);\n                     let var = self.variable(nid, expr.span);\n                     self.warn_about_dead_assign(expr.span, expr.id, ln, var);"}, {"sha": "d4438f5ecfa1adcefb720dd476cf8a2aef80be01", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -268,7 +268,7 @@ impl MutabilityCategory {\n     }\n \n     fn from_local(tcx: TyCtxt, id: ast::NodeId) -> MutabilityCategory {\n-        let ret = match tcx.map.get(id) {\n+        let ret = match tcx.hir.get(id) {\n             ast_map::NodeLocal(p) => match p.node {\n                 PatKind::Binding(bind_mode, ..) => {\n                     if bind_mode == hir::BindByValue(hir::MutMutable) {\n@@ -279,7 +279,7 @@ impl MutabilityCategory {\n                 }\n                 _ => span_bug!(p.span, \"expected identifier pattern\")\n             },\n-            _ => span_bug!(tcx.map.span(id), \"expected identifier pattern\")\n+            _ => span_bug!(tcx.hir.span(id), \"expected identifier pattern\")\n         };\n         debug!(\"MutabilityCategory::{}(tcx, id={:?}) => {:?}\",\n                \"from_local\", id, ret);\n@@ -539,7 +539,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           }\n \n           Def::Upvar(def_id, _, fn_node_id) => {\n-              let var_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n+              let var_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n               let ty = self.node_ty(fn_node_id)?;\n               match ty.sty {\n                   ty::TyClosure(closure_id, _) => {\n@@ -576,7 +576,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           }\n \n           Def::Local(def_id) => {\n-            let vid = self.tcx().map.as_local_node_id(def_id).unwrap();\n+            let vid = self.tcx().hir.as_local_node_id(def_id).unwrap();\n             Ok(Rc::new(cmt_ {\n                 id: id,\n                 span: span,\n@@ -698,7 +698,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // Look up the node ID of the closure body so we can construct\n         // a free region within it\n         let fn_body_id = {\n-            let fn_expr = match self.tcx().map.find(upvar_id.closure_expr_id) {\n+            let fn_expr = match self.tcx().hir.find(upvar_id.closure_expr_id) {\n                 Some(ast_map::NodeExpr(e)) => e,\n                 _ => bug!()\n             };\n@@ -1313,7 +1313,7 @@ impl<'tcx> cmt_<'tcx> {\n                 \"non-lvalue\".to_string()\n             }\n             Categorization::Local(vid) => {\n-                if tcx.map.is_argument(vid) {\n+                if tcx.hir.is_argument(vid) {\n                     \"argument\".to_string()\n                 } else {\n                     \"local variable\".to_string()"}, {"sha": "9b00fc3f220eccdd598d53f15791b95ddf7da76d", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -63,8 +63,8 @@ fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         generics_require_inlining(&sig.generics) {\n         return true\n     }\n-    if let Some(impl_node_id) = tcx.map.as_local_node_id(impl_src) {\n-        match tcx.map.find(impl_node_id) {\n+    if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_src) {\n+        match tcx.hir.find(impl_node_id) {\n             Some(ast_map::NodeItem(item)) =>\n                 item_might_be_inlined(&item),\n             Some(..) | None =>\n@@ -97,7 +97,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         let old_tables = self.tables;\n         self.tables = self.tcx.body_tables(body);\n-        let body = self.tcx.map.body(body);\n+        let body = self.tcx.hir.body(body);\n         self.visit_body(body);\n         self.tables = old_tables;\n     }\n@@ -117,7 +117,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n \n         if let Some(def) = def {\n             let def_id = def.def_id();\n-            if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+            if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n                 if self.def_id_represents_local_inlined_item(def_id) {\n                     self.worklist.push(node_id);\n                 } else {\n@@ -147,12 +147,12 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n     fn def_id_represents_local_inlined_item(&self, def_id: DefId) -> bool {\n-        let node_id = match self.tcx.map.as_local_node_id(def_id) {\n+        let node_id = match self.tcx.hir.as_local_node_id(def_id) {\n             Some(node_id) => node_id,\n             None => { return false; }\n         };\n \n-        match self.tcx.map.find(node_id) {\n+        match self.tcx.hir.find(node_id) {\n             Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n                     hir::ItemFn(..) => item_might_be_inlined(&item),\n@@ -176,13 +176,13 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             true\n                         } else {\n                             let impl_did = self.tcx\n-                                               .map\n+                                               .hir\n                                                .get_parent_did(node_id);\n                             // Check the impl. If the generics on the self\n                             // type of the impl require inlining, this method\n                             // does too.\n-                            let impl_node_id = self.tcx.map.as_local_node_id(impl_did).unwrap();\n-                            match self.tcx.map.expect_item(impl_node_id).node {\n+                            let impl_node_id = self.tcx.hir.as_local_node_id(impl_did).unwrap();\n+                            match self.tcx.hir.expect_item(impl_node_id).node {\n                                 hir::ItemImpl(_, _, ref generics, ..) => {\n                                     generics_require_inlining(generics)\n                                 }\n@@ -210,7 +210,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 continue\n             }\n \n-            if let Some(ref item) = self.tcx.map.find(search_item) {\n+            if let Some(ref item) = self.tcx.hir.find(search_item) {\n                 self.propagate_node(item, search_item);\n             }\n         }\n@@ -287,7 +287,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         self.visit_nested_body(body);\n                     }\n                     hir::ImplItemKind::Method(ref sig, body) => {\n-                        let did = self.tcx.map.get_parent_did(search_item);\n+                        let did = self.tcx.hir.get_parent_did(search_item);\n                         if method_might_be_inlined(self.tcx, sig, impl_item, did) {\n                             self.visit_nested_body(body)\n                         }\n@@ -303,7 +303,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             ast_map::NodeTy(_) => {}\n             _ => {\n                 bug!(\"found unexpected thingy in worklist: {}\",\n-                     self.tcx.map.node_to_string(search_item))\n+                     self.tcx.hir.node_to_string(search_item))\n             }\n         }\n     }\n@@ -343,7 +343,7 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n \n                 for default_method in self.tcx.provided_trait_methods(trait_def_id) {\n                     let node_id = self.tcx\n-                                      .map\n+                                      .hir\n                                       .as_local_node_id(default_method.def_id)\n                                       .unwrap();\n                     self.worklist.push(node_id);\n@@ -386,7 +386,7 @@ pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n     for item in tcx.lang_items.items().iter() {\n         if let Some(did) = *item {\n-            if let Some(node_id) = tcx.map.as_local_node_id(did) {\n+            if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n                 reachable_context.worklist.push(node_id);\n             }\n         }\n@@ -397,7 +397,7 @@ pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             access_levels: access_levels,\n             worklist: &mut reachable_context.worklist,\n         };\n-        tcx.map.krate().visit_all_item_likes(&mut collect_private_impl_items);\n+        tcx.hir.krate().visit_all_item_likes(&mut collect_private_impl_items);\n     }\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch."}, {"sha": "487e13b47fec2755effb15a351d6cd056cd592ad", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -178,7 +178,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                     }\n                 }\n \n-                let def_id = self.tcx.map.local_def_id(id);\n+                let def_id = self.tcx.hir.local_def_id(id);\n                 self.index.stab_map.insert(def_id, Some(stab));\n \n                 let orig_parent_stab = replace(&mut self.parent_stab, Some(stab));\n@@ -188,7 +188,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 debug!(\"annotate: not found, parent = {:?}\", self.parent_stab);\n                 if let Some(stab) = self.parent_stab {\n                     if stab.level.is_unstable() {\n-                        let def_id = self.tcx.map.local_def_id(id);\n+                        let def_id = self.tcx.hir.local_def_id(id);\n                         self.index.stab_map.insert(def_id, Some(stab));\n                     }\n                 }\n@@ -211,15 +211,15 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 }\n \n                 // `Deprecation` is just two pointers, no need to intern it\n-                let def_id = self.tcx.map.local_def_id(id);\n+                let def_id = self.tcx.hir.local_def_id(id);\n                 let depr_entry = Some(DeprecationEntry::local(depr, def_id));\n                 self.index.depr_map.insert(def_id, depr_entry.clone());\n \n                 let orig_parent_depr = replace(&mut self.parent_depr, depr_entry);\n                 visit_children(self);\n                 self.parent_depr = orig_parent_depr;\n             } else if let parent_depr @ Some(_) = self.parent_depr.clone() {\n-                let def_id = self.tcx.map.local_def_id(id);\n+                let def_id = self.tcx.hir.local_def_id(id);\n                 self.index.depr_map.insert(def_id, parent_depr);\n                 visit_children(self);\n             } else {\n@@ -234,7 +234,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.tcx.map)\n+        NestedVisitorMap::All(&self.tcx.hir)\n     }\n \n     fn visit_item(&mut self, i: &'tcx Item) {\n@@ -313,7 +313,7 @@ struct MissingStabilityAnnotations<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx: 'a> MissingStabilityAnnotations<'a, 'tcx> {\n     fn check_missing_stability(&self, id: NodeId, span: Span) {\n-        let def_id = self.tcx.map.local_def_id(id);\n+        let def_id = self.tcx.hir.local_def_id(id);\n         let is_error = !self.tcx.sess.opts.test &&\n                         !self.tcx.stability.borrow().stab_map.contains_key(&def_id) &&\n                         self.access_levels.is_reachable(id);\n@@ -325,7 +325,7 @@ impl<'a, 'tcx: 'a> MissingStabilityAnnotations<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n     }\n \n     fn visit_item(&mut self, i: &'tcx Item) {\n@@ -348,7 +348,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n-        let impl_def_id = self.tcx.map.local_def_id(self.tcx.map.get_parent(ii.id));\n+        let impl_def_id = self.tcx.hir.local_def_id(self.tcx.hir.get_parent(ii.id));\n         if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n             self.check_missing_stability(ii.id, ii.span);\n         }\n@@ -384,7 +384,7 @@ impl<'a, 'tcx> Index<'tcx> {\n         self.active_features = active_lib_features.iter().map(|&(ref s, _)| s.clone()).collect();\n \n         let _task = tcx.dep_graph.in_task(DepNode::StabilityIndex);\n-        let krate = tcx.map.krate();\n+        let krate = tcx.hir.krate();\n         let mut annotator = Annotator {\n             tcx: tcx,\n             index: self,\n@@ -484,7 +484,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             let skip = if id == ast::DUMMY_NODE_ID {\n                 true\n             } else {\n-                let parent_def_id = self.map.local_def_id(self.map.get_parent(id));\n+                let parent_def_id = self.hir.local_def_id(self.hir.get_parent(id));\n                 self.lookup_deprecation_entry(parent_def_id).map_or(false, |parent_depr| {\n                     parent_depr.same_origin(&depr_entry)\n                 })\n@@ -555,7 +555,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -578,7 +578,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             hir::ItemImpl(.., Some(ref t), _, ref impl_item_refs) => {\n                 if let Def::Trait(trait_did) = t.path.def {\n                     for impl_item_ref in impl_item_refs {\n-                        let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n+                        let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n                         let trait_item_def_id = self.tcx.associated_items(trait_did)\n                             .find(|item| item.name == impl_item.name).map(|item| item.def_id);\n                         if let Some(def_id) = trait_item_def_id {\n@@ -658,7 +658,7 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     if tcx.stability.borrow().staged_api[&LOCAL_CRATE] && tcx.sess.features.borrow().staged_api {\n         let _task = tcx.dep_graph.in_task(DepNode::StabilityIndex);\n-        let krate = tcx.map.krate();\n+        let krate = tcx.hir.krate();\n         let mut missing = MissingStabilityAnnotations {\n             tcx: tcx,\n             access_levels: access_levels,"}, {"sha": "6e9091cf31728cef9f5f7d1a31ebcebdbfd9b37c", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -1163,14 +1163,14 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     }\n \n                     AggregateKind::Closure(def_id, _) => ty::tls::with(|tcx| {\n-                        if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n-                            let name = format!(\"[closure@{:?}]\", tcx.map.span(node_id));\n+                        if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n+                            let name = format!(\"[closure@{:?}]\", tcx.hir.span(node_id));\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n                             tcx.with_freevars(node_id, |freevars| {\n                                 for (freevar, lv) in freevars.iter().zip(lvs) {\n                                     let def_id = freevar.def.def_id();\n-                                    let var_id = tcx.map.as_local_node_id(def_id).unwrap();\n+                                    let var_id = tcx.hir.as_local_node_id(def_id).unwrap();\n                                     let var_name = tcx.local_var_name_str(var_id);\n                                     struct_fmt.field(&var_name, lv);\n                                 }"}, {"sha": "652fef76f288a486b6ab6df8ef82bd4c15c1f16a", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -40,13 +40,13 @@ impl<'a, 'tcx> MirSource {\n         use hir::*;\n \n         // Handle constants in enum discriminants, types, and repeat expressions.\n-        let def_id = tcx.map.local_def_id(id);\n+        let def_id = tcx.hir.local_def_id(id);\n         let def_key = tcx.def_key(def_id);\n         if def_key.disambiguated_data.data == DefPathData::Initializer {\n             return MirSource::Const(id);\n         }\n \n-        match tcx.map.get(id) {\n+        match tcx.hir.get(id) {\n             map::NodeItem(&Item { node: ItemConst(..), .. }) |\n             map::NodeTraitItem(&TraitItem { node: TraitItemKind::Const(..), .. }) |\n             map::NodeImplItem(&ImplItem { node: ImplItemKind::Const(..), .. }) => {\n@@ -124,7 +124,7 @@ impl<'tcx, T: MirPass<'tcx>> MirMapPass<'tcx> for T {\n             let mir = &mut tcx.mir_map.borrow()[&def_id].borrow_mut();\n             tcx.dep_graph.write(DepNode::Mir(def_id));\n \n-            let id = tcx.map.as_local_node_id(def_id).unwrap();\n+            let id = tcx.hir.as_local_node_id(def_id).unwrap();\n             let src = MirSource::from_node(tcx, id);\n \n             for hook in &mut *hooks {"}, {"sha": "1658efb03235a2405f6c6a153c5a10c1a249c65d", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -441,7 +441,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                              E0276,\n                              \"impl has stricter requirements than trait\");\n \n-        if let Some(trait_item_span) = self.tcx.map.span_if_local(trait_item_def_id) {\n+        if let Some(trait_item_span) = self.tcx.hir.span_if_local(trait_item_def_id) {\n             err.span_label(trait_item_span,\n                            &format!(\"definition of `{}` from trait\", item_name));\n         }\n@@ -594,7 +594,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n                         ty::Predicate::ClosureKind(closure_def_id, kind) => {\n                             let found_kind = self.closure_kind(closure_def_id).unwrap();\n-                            let closure_span = self.tcx.map.span_if_local(closure_def_id).unwrap();\n+                            let closure_span = self.tcx.hir.span_if_local(closure_def_id).unwrap();\n                             let mut err = struct_span_err!(\n                                 self.tcx.sess, closure_span, E0525,\n                                 \"expected a closure that implements the `{}` trait, \\\n@@ -653,7 +653,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                                    -> DiagnosticBuilder<'tcx>\n     {\n         assert!(type_def_id.is_local());\n-        let span = self.map.span_if_local(type_def_id).unwrap();\n+        let span = self.hir.span_if_local(type_def_id).unwrap();\n         let mut err = struct_span_err!(self.sess, span, E0072,\n                                        \"recursive type `{}` has infinite size\",\n                                        self.item_path_str(type_def_id));"}, {"sha": "7f26fdfba569354bbd6b78900161e59f7add487c", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -265,7 +265,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             Some(ty) => ty,\n             None => {\n                 bug!(\"node_id_to_type: no type for node `{}`\",\n-                     tls::with(|tcx| tcx.map.node_to_string(id)))\n+                     tls::with(|tcx| tcx.hir.node_to_string(id)))\n             }\n         }\n     }\n@@ -428,7 +428,7 @@ pub struct GlobalCtxt<'tcx> {\n     /// additional acyclicity requirements).\n     pub super_predicates: RefCell<DepTrackingMap<maps::Predicates<'tcx>>>,\n \n-    pub map: ast_map::Map<'tcx>,\n+    pub hir: ast_map::Map<'tcx>,\n \n     /// Maps from the def-id of a function/method or const/static\n     /// to its MIR. Mutation is done at an item granularity to\n@@ -628,7 +628,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"retrace_path(path={:?}, krate={:?})\", path_data, self.crate_name(krate));\n \n         if krate == LOCAL_CRATE {\n-            self.map\n+            self.hir\n                 .definitions()\n                 .def_path_table()\n                 .retrace_path(path_data)\n@@ -730,7 +730,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                   arena: &'tcx DroplessArena,\n                                   resolutions: ty::Resolutions,\n                                   named_region_map: resolve_lifetime::NamedRegionMap,\n-                                  map: ast_map::Map<'tcx>,\n+                                  hir: ast_map::Map<'tcx>,\n                                   region_maps: RegionMaps,\n                                   lang_items: middle::lang_items::LanguageItems,\n                                   stability: stability::Index<'tcx>,\n@@ -741,7 +741,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let data_layout = TargetDataLayout::parse(s);\n         let interners = CtxtInterners::new(arena);\n         let common_types = CommonTypes::new(&interners);\n-        let dep_graph = map.dep_graph.clone();\n+        let dep_graph = hir.dep_graph.clone();\n         let fulfilled_predicates = traits::GlobalFulfilledPredicates::new(dep_graph.clone());\n         tls::enter_global(GlobalCtxt {\n             specializes_cache: RefCell::new(traits::SpecializesCache::new()),\n@@ -765,7 +765,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             super_predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             fulfilled_predicates: RefCell::new(fulfilled_predicates),\n-            map: map,\n+            hir: hir,\n             mir_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             freevars: RefCell::new(resolutions.freevars),\n             maybe_unused_trait_imports: resolutions.maybe_unused_trait_imports,"}, {"sha": "91087a3dcecd084dcb7b6b2d99acc3b5c4ba3bd2", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -283,7 +283,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                           expected.ty,\n                                           found.ty));\n \n-                match self.map.span_if_local(expected.def_id) {\n+                match self.hir.span_if_local(expected.def_id) {\n                     Some(span) => {\n                         db.span_note(span, \"a default was defined here...\");\n                     }\n@@ -297,7 +297,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     expected.origin_span,\n                     \"...that was applied to an unconstrained type variable here\");\n \n-                match self.map.span_if_local(found.def_id) {\n+                match self.hir.span_if_local(found.def_id) {\n                     Some(span) => {\n                         db.span_note(span, \"a second default was defined here...\");\n                     }"}, {"sha": "6801e82fe74769d2831625871eb6a1faa9ebd6b4", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'gcx, 'tcx> DefIdForest {\n     /// crate.\n     #[inline]\n     pub fn full(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest {\n-        let crate_id = tcx.map.local_def_id(CRATE_NODE_ID);\n+        let crate_id = tcx.hir.local_def_id(CRATE_NODE_ID);\n         DefIdForest::from_id(crate_id)\n     }\n "}, {"sha": "d488cd1c42711469419c45561ffd06cad105d602", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Returns a string identifying this local node-id.\n     pub fn node_path_str(self, id: ast::NodeId) -> String {\n-        self.item_path_str(self.map.local_def_id(id))\n+        self.item_path_str(self.hir.local_def_id(id))\n     }\n \n     /// Returns a string identifying this def-id. This string is\n@@ -286,8 +286,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // only occur very early in the compiler pipeline.\n         let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n         self.push_item_path(buffer, parent_def_id);\n-        let node_id = self.map.as_local_node_id(impl_def_id).unwrap();\n-        let item = self.map.expect_item(node_id);\n+        let node_id = self.hir.as_local_node_id(impl_def_id).unwrap();\n+        let item = self.hir.expect_item(node_id);\n         let span_str = self.sess.codemap().span_to_string(item.span);\n         buffer.push(&format!(\"<impl at {}>\", span_str));\n     }"}, {"sha": "7a8788f053dd07d9193f77e63f348764ba151af8", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -261,7 +261,7 @@ impl Visibility {\n                 def => Visibility::Restricted(def.def_id()),\n             },\n             hir::Inherited => {\n-                Visibility::Restricted(tcx.map.local_def_id(tcx.map.get_module_parent(id)))\n+                Visibility::Restricted(tcx.hir.local_def_id(tcx.hir.get_module_parent(id)))\n             }\n         }\n     }\n@@ -1198,22 +1198,22 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n     /// Construct a parameter environment given an item, impl item, or trait item\n     pub fn for_item(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: NodeId)\n                     -> ParameterEnvironment<'tcx> {\n-        match tcx.map.find(id) {\n+        match tcx.hir.find(id) {\n             Some(ast_map::NodeImplItem(ref impl_item)) => {\n                 match impl_item.node {\n                     hir::ImplItemKind::Type(_) | hir::ImplItemKind::Const(..) => {\n                         // associated types don't have their own entry (for some reason),\n                         // so for now just grab environment for the impl\n-                        let impl_id = tcx.map.get_parent(id);\n-                        let impl_def_id = tcx.map.local_def_id(impl_id);\n+                        let impl_id = tcx.hir.get_parent(id);\n+                        let impl_def_id = tcx.hir.local_def_id(impl_id);\n                         tcx.construct_parameter_environment(impl_item.span,\n                                                             impl_def_id,\n                                                             tcx.region_maps.item_extent(id))\n                     }\n                     hir::ImplItemKind::Method(_, ref body) => {\n                         tcx.construct_parameter_environment(\n                             impl_item.span,\n-                            tcx.map.local_def_id(id),\n+                            tcx.hir.local_def_id(id),\n                             tcx.region_maps.call_site_extent(id, body.node_id))\n                     }\n                 }\n@@ -1223,8 +1223,8 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                     hir::TraitItemKind::Type(..) | hir::TraitItemKind::Const(..) => {\n                         // associated types don't have their own entry (for some reason),\n                         // so for now just grab environment for the trait\n-                        let trait_id = tcx.map.get_parent(id);\n-                        let trait_def_id = tcx.map.local_def_id(trait_id);\n+                        let trait_id = tcx.hir.get_parent(id);\n+                        let trait_def_id = tcx.hir.local_def_id(trait_id);\n                         tcx.construct_parameter_environment(trait_item.span,\n                                                             trait_def_id,\n                                                             tcx.region_maps.item_extent(id))\n@@ -1242,7 +1242,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         };\n                         tcx.construct_parameter_environment(\n                             trait_item.span,\n-                            tcx.map.local_def_id(id),\n+                            tcx.hir.local_def_id(id),\n                             extent)\n                     }\n                 }\n@@ -1251,7 +1251,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                 match item.node {\n                     hir::ItemFn(.., body_id) => {\n                         // We assume this is a function.\n-                        let fn_def_id = tcx.map.local_def_id(id);\n+                        let fn_def_id = tcx.hir.local_def_id(id);\n \n                         tcx.construct_parameter_environment(\n                             item.span,\n@@ -1265,13 +1265,13 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                     hir::ItemImpl(..) |\n                     hir::ItemConst(..) |\n                     hir::ItemStatic(..) => {\n-                        let def_id = tcx.map.local_def_id(id);\n+                        let def_id = tcx.hir.local_def_id(id);\n                         tcx.construct_parameter_environment(item.span,\n                                                             def_id,\n                                                             tcx.region_maps.item_extent(id))\n                     }\n                     hir::ItemTrait(..) => {\n-                        let def_id = tcx.map.local_def_id(id);\n+                        let def_id = tcx.hir.local_def_id(id);\n                         tcx.construct_parameter_environment(item.span,\n                                                             def_id,\n                                                             tcx.region_maps.item_extent(id))\n@@ -1287,7 +1287,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n             Some(ast_map::NodeExpr(expr)) => {\n                 // This is a convenience to allow closures to work.\n                 if let hir::ExprClosure(.., body, _) = expr.node {\n-                    let def_id = tcx.map.local_def_id(id);\n+                    let def_id = tcx.hir.local_def_id(id);\n                     let base_def_id = tcx.closure_base_def_id(def_id);\n                     tcx.construct_parameter_environment(\n                         expr.span,\n@@ -1298,15 +1298,15 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                 }\n             }\n             Some(ast_map::NodeForeignItem(item)) => {\n-                let def_id = tcx.map.local_def_id(id);\n+                let def_id = tcx.hir.local_def_id(id);\n                 tcx.construct_parameter_environment(item.span,\n                                                     def_id,\n                                                     ROOT_CODE_EXTENT)\n             }\n             _ => {\n                 bug!(\"ParameterEnvironment::from_item(): \\\n                       `{}` is not an item\",\n-                     tcx.map.node_to_string(id))\n+                     tcx.hir.node_to_string(id))\n             }\n         }\n     }\n@@ -1918,7 +1918,7 @@ impl BorrowKind {\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn body_tables(self, body: hir::BodyId) -> &'gcx TypeckTables<'gcx> {\n-        self.item_tables(self.map.body_owner_def_id(body))\n+        self.item_tables(self.hir.body_owner_def_id(body))\n     }\n \n     pub fn item_tables(self, def_id: DefId) -> &'gcx TypeckTables<'gcx> {\n@@ -1944,7 +1944,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn expr_span(self, id: NodeId) -> Span {\n-        match self.map.find(id) {\n+        match self.hir.find(id) {\n             Some(ast_map::NodeExpr(e)) => {\n                 e.span\n             }\n@@ -1958,7 +1958,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn local_var_name_str(self, id: NodeId) -> InternedString {\n-        match self.map.find(id) {\n+        match self.hir.find(id) {\n             Some(ast_map::NodeLocal(pat)) => {\n                 match pat.node {\n                     hir::PatKind::Binding(_, _, ref path1, _) => path1.node.as_str(),\n@@ -2031,8 +2031,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn trait_impl_polarity(self, id: DefId) -> hir::ImplPolarity {\n-        if let Some(id) = self.map.as_local_node_id(id) {\n-            match self.map.expect_item(id).node {\n+        if let Some(id) = self.hir.as_local_node_id(id) {\n+            match self.hir.expect_item(id).node {\n                 hir::ItemImpl(_, polarity, ..) => polarity,\n                 ref item => bug!(\"trait_impl_polarity: {:?} not an impl\", item)\n             }\n@@ -2077,10 +2077,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             // those tasks that just need to scan the names of items\n             // and so forth.\n \n-            let id = self.map.as_local_node_id(def_id).unwrap();\n-            let parent_id = self.map.get_parent(id);\n-            let parent_def_id = self.map.local_def_id(parent_id);\n-            let parent_item = self.map.expect_item(parent_id);\n+            let id = self.hir.as_local_node_id(def_id).unwrap();\n+            let parent_id = self.hir.get_parent(id);\n+            let parent_def_id = self.hir.local_def_id(parent_id);\n+            let parent_item = self.hir.expect_item(parent_id);\n             match parent_item.node {\n                 hir::ItemImpl(.., ref impl_trait_ref, _, ref impl_item_refs) => {\n                     for impl_item_ref in impl_item_refs {\n@@ -2115,7 +2115,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                            parent_def_id: DefId,\n                                            trait_item_ref: &hir::TraitItemRef)\n                                            -> AssociatedItem {\n-        let def_id = self.map.local_def_id(trait_item_ref.id.node_id);\n+        let def_id = self.hir.local_def_id(trait_item_ref.id.node_id);\n         let (kind, has_self) = match trait_item_ref.kind {\n             hir::AssociatedItemKind::Const => (ty::AssociatedKind::Const, false),\n             hir::AssociatedItemKind::Method { has_self } => {\n@@ -2140,7 +2140,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                           from_trait_impl: bool,\n                                           impl_item_ref: &hir::ImplItemRef)\n                                           -> AssociatedItem {\n-        let def_id = self.map.local_def_id(impl_item_ref.id.node_id);\n+        let def_id = self.hir.local_def_id(impl_item_ref.id.node_id);\n         let (kind, has_self) = match impl_item_ref.kind {\n             hir::AssociatedItemKind::Const => (ty::AssociatedKind::Const, false),\n             hir::AssociatedItemKind::Method { has_self } => {\n@@ -2170,19 +2170,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 return Rc::new(self.sess.cstore.associated_item_def_ids(def_id));\n             }\n \n-            let id = self.map.as_local_node_id(def_id).unwrap();\n-            let item = self.map.expect_item(id);\n+            let id = self.hir.as_local_node_id(def_id).unwrap();\n+            let item = self.hir.expect_item(id);\n             let vec: Vec<_> = match item.node {\n                 hir::ItemTrait(.., ref trait_item_refs) => {\n                     trait_item_refs.iter()\n                                    .map(|trait_item_ref| trait_item_ref.id)\n-                                   .map(|id| self.map.local_def_id(id.node_id))\n+                                   .map(|id| self.hir.local_def_id(id.node_id))\n                                    .collect()\n                 }\n                 hir::ItemImpl(.., ref impl_item_refs) => {\n                     impl_item_refs.iter()\n                                   .map(|impl_item_ref| impl_item_ref.id)\n-                                  .map(|id| self.map.local_def_id(id.node_id))\n+                                  .map(|id| self.hir.local_def_id(id.node_id))\n                                   .collect()\n                 }\n                 _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\")\n@@ -2227,7 +2227,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn def_key(self, id: DefId) -> ast_map::DefKey {\n         if id.is_local() {\n-            self.map.def_key(id)\n+            self.hir.def_key(id)\n         } else {\n             self.sess.cstore.def_key(id)\n         }\n@@ -2240,27 +2240,27 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     //  be a non-local `DefPath`.\n     pub fn def_path(self, id: DefId) -> ast_map::DefPath {\n         if id.is_local() {\n-            self.map.def_path(id)\n+            self.hir.def_path(id)\n         } else {\n             self.sess.cstore.def_path(id)\n         }\n     }\n \n     pub fn def_span(self, def_id: DefId) -> Span {\n-        if let Some(id) = self.map.as_local_node_id(def_id) {\n-            self.map.span(id)\n+        if let Some(id) = self.hir.as_local_node_id(def_id) {\n+            self.hir.span(id)\n         } else {\n             self.sess.cstore.def_span(&self.sess, def_id)\n         }\n     }\n \n     pub fn vis_is_accessible_from(self, vis: Visibility, block: NodeId) -> bool {\n-        vis.is_accessible_from(self.map.local_def_id(self.map.get_module_parent(block)), self)\n+        vis.is_accessible_from(self.hir.local_def_id(self.hir.get_module_parent(block)), self)\n     }\n \n     pub fn item_name(self, id: DefId) -> ast::Name {\n-        if let Some(id) = self.map.as_local_node_id(id) {\n-            self.map.name(id)\n+        if let Some(id) = self.hir.as_local_node_id(id) {\n+            self.hir.name(id)\n         } else if id.index == CRATE_DEF_INDEX {\n             self.sess.cstore.original_crate_name(id.krate)\n         } else {\n@@ -2372,8 +2372,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Get the attributes of a definition.\n     pub fn get_attrs(self, did: DefId) -> Cow<'gcx, [ast::Attribute]> {\n-        if let Some(id) = self.map.as_local_node_id(did) {\n-            Cow::Borrowed(self.map.attrs(id))\n+        if let Some(id) = self.hir.as_local_node_id(did) {\n+            Cow::Borrowed(self.hir.attrs(id))\n         } else {\n             Cow::Owned(self.sess.cstore.item_attrs(did))\n         }\n@@ -2656,8 +2656,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// with the name of the crate containing the impl.\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {\n         if impl_did.is_local() {\n-            let node_id = self.map.as_local_node_id(impl_did).unwrap();\n-            Ok(self.map.span(node_id))\n+            let node_id = self.hir.as_local_node_id(impl_did).unwrap();\n+            Ok(self.hir.span(node_id))\n         } else {\n             Err(self.sess.cstore.crate_name(impl_did.krate))\n         }"}, {"sha": "e90e1a94be951facdb3225e0ac0c93c7452813d2", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -285,7 +285,7 @@ fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n             ty::BrEnv => {\n                 let name = Symbol::intern(\"'r\");\n                 let _ = write!(f, \"{}\", name);\n-                ty::BrNamed(tcx.map.local_def_id(CRATE_NODE_ID),\n+                ty::BrNamed(tcx.hir.local_def_id(CRATE_NODE_ID),\n                             name,\n                             ty::Issue32330::WontChange)\n             }\n@@ -833,13 +833,13 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 let upvar_tys = substs.upvar_tys(did, tcx);\n                 write!(f, \"[closure\")?;\n \n-                if let Some(node_id) = tcx.map.as_local_node_id(did) {\n-                    write!(f, \"@{:?}\", tcx.map.span(node_id))?;\n+                if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n+                    write!(f, \"@{:?}\", tcx.hir.span(node_id))?;\n                     let mut sep = \" \";\n                     tcx.with_freevars(node_id, |freevars| {\n                         for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n                             let def_id = freevar.def.def_id();\n-                            let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n+                            let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n                             write!(f,\n                                         \"{}{}:{}\",\n                                         sep,"}, {"sha": "e3dec97472a481af97aa6b6e87b4ffe1495e16d2", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -460,7 +460,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             // 3. Where does old loan expire.\n \n             let previous_end_span =\n-                self.tcx().map.span(old_loan.kill_scope.node_id(&self.tcx().region_maps))\n+                self.tcx().hir.span(old_loan.kill_scope.node_id(&self.tcx().region_maps))\n                               .end_point();\n \n             let mut err = match (new_loan.kind, old_loan.kind) {\n@@ -704,7 +704,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                        borrow_kind: ty::BorrowKind)\n                                        -> UseError<'tcx> {\n         debug!(\"analyze_restrictions_on_use(expr_id={}, use_path={:?})\",\n-               self.tcx().map.node_to_string(expr_id),\n+               self.tcx().hir.node_to_string(expr_id),\n                use_path);\n \n         let mut ret = UseOk;"}, {"sha": "285f3ab9047c85c5379abf9171f886cbfb7aab56", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -132,7 +132,7 @@ pub fn build_unfragmented_map(this: &mut borrowck::BorrowckCtxt,\n     }\n \n     let mut fraginfo_map = this.tcx.fragment_infos.borrow_mut();\n-    let fn_did = this.tcx.map.local_def_id(id);\n+    let fn_did = this.tcx.hir.local_def_id(id);\n     let prev = fraginfo_map.insert(fn_did, fragment_infos);\n     assert!(prev.is_none());\n }\n@@ -202,7 +202,7 @@ pub fn instrument_move_fragments<'a, 'tcx>(this: &MoveData<'tcx>,\n                                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            sp: Span,\n                                            id: ast::NodeId) {\n-    let span_err = tcx.map.attrs(id).iter()\n+    let span_err = tcx.hir.attrs(id).iter()\n                           .any(|a| a.check_name(\"rustc_move_fragments\"));\n     let print = tcx.sess.opts.debugging_opts.print_move_fragments;\n \n@@ -496,7 +496,7 @@ fn add_fragment_siblings_for_extension<'a, 'tcx>(this: &MoveData<'tcx>,\n         },\n \n         ref ty => {\n-            let span = origin_id.map_or(DUMMY_SP, |id| tcx.map.span(id));\n+            let span = origin_id.map_or(DUMMY_SP, |id| tcx.hir.span(id));\n             span_bug!(span,\n                       \"type {:?} ({:?}) is not fragmentable\",\n                       parent_ty, ty);"}, {"sha": "7f7f73d9a9678e45ab6e39c44087428b5836c78c", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -53,7 +53,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n \n-    let body = glcx.bccx.tcx.map.body(body);\n+    let body = glcx.bccx.tcx.hir.body(body);\n     euv::ExprUseVisitor::new(&mut glcx, &infcx).consume_body(body);\n \n     glcx.report_potential_errors();\n@@ -553,6 +553,6 @@ pub fn gather_loans_in_static_initializer(bccx: &mut BorrowckCtxt, body: hir::Bo\n         body_id: body\n     };\n \n-    let body = sicx.bccx.tcx.map.body(body);\n+    let body = sicx.bccx.tcx.hir.body(body);\n     sicx.visit_body(body);\n }"}, {"sha": "372eb1d5d64f018bad60a3a82fa940cebf125690", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -57,7 +57,7 @@ pub fn borrowck_mir(bcx: &mut BorrowckCtxt,\n                     id: ast::NodeId,\n                     attributes: &[ast::Attribute]) {\n     let tcx = bcx.tcx;\n-    let def_id = tcx.map.local_def_id(id);\n+    let def_id = tcx.hir.local_def_id(id);\n     debug!(\"borrowck_mir({}) UNIMPLEMENTED\", tcx.item_path_str(def_id));\n \n     let mir = &tcx.item_mir(def_id);"}, {"sha": "3464f1fa89a27c0e121459aee810c38fa273722b", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -64,7 +64,7 @@ pub type LoanDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, LoanDataFlowOperator\n \n impl<'a, 'tcx> Visitor<'tcx> for BorrowckCtxt<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n@@ -167,7 +167,7 @@ fn borrowck_fn<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                          attributes: &[ast::Attribute]) {\n     debug!(\"borrowck_fn(id={})\", id);\n \n-    let body = this.tcx.map.body(body_id);\n+    let body = this.tcx.hir.body(body_id);\n \n     if attributes.iter().any(|item| item.check_name(\"rustc_mir_borrowck\")) {\n         this.with_temp_region_map(id, |this| {\n@@ -201,9 +201,9 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n {\n     // Check the body of fn items.\n     let tcx = this.tcx;\n-    let body = tcx.map.body(body_id);\n+    let body = tcx.hir.body(body_id);\n     let id_range = {\n-        let mut visitor = intravisit::IdRangeComputingVisitor::new(&tcx.map);\n+        let mut visitor = intravisit::IdRangeComputingVisitor::new(&tcx.hir);\n         visitor.visit_body(body);\n         visitor.result()\n     };\n@@ -398,7 +398,7 @@ pub enum LoanPathElem<'tcx> {\n \n pub fn closure_to_block(closure_id: ast::NodeId,\n                         tcx: TyCtxt) -> ast::NodeId {\n-    match tcx.map.get(closure_id) {\n+    match tcx.hir.get(closure_id) {\n         hir_map::NodeExpr(expr) => match expr.node {\n             hir::ExprClosure(.., body_id, _) => {\n                 body_id.node_id\n@@ -685,10 +685,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n             move_data::MoveExpr |\n             move_data::MovePat =>\n-                (self.tcx.map.span(the_move.id), \"\"),\n+                (self.tcx.hir.span(the_move.id), \"\"),\n \n             move_data::Captured =>\n-                (match self.tcx.map.expect_expr(the_move.id).node {\n+                (match self.tcx.hir.expect_expr(the_move.id).node {\n                     hir::ExprClosure(.., fn_decl_span) => fn_decl_span,\n                     ref r => bug!(\"Captured({}) maps to non-closure: {:?}\",\n                                   the_move.id, r),\n@@ -882,10 +882,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     // happen for nested closures, so we know the enclosing\n                     // closure incorrectly accepts an `Fn` while it needs to\n                     // be `FnMut`.\n-                    span_help!(&mut err, self.tcx.map.span(id),\n+                    span_help!(&mut err, self.tcx.hir.span(id),\n                            \"consider changing this to accept closures that implement `FnMut`\");\n                 } else {\n-                    span_help!(&mut err, self.tcx.map.span(id),\n+                    span_help!(&mut err, self.tcx.hir.span(id),\n                            \"consider changing this closure to take self by mutable reference\");\n                 }\n                 err\n@@ -948,7 +948,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     fn region_end_span(&self, region: &'tcx ty::Region) -> Option<Span> {\n         match *region {\n             ty::ReScope(scope) => {\n-                match scope.span(&self.tcx.region_maps, &self.tcx.map) {\n+                match scope.span(&self.tcx.region_maps, &self.tcx.hir) {\n                     Some(s) => {\n                         Some(s.end_point())\n                     }\n@@ -1097,18 +1097,18 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     _ => bug!()\n                 };\n                 if kind == ty::ClosureKind::Fn {\n-                    db.span_help(self.tcx.map.span(upvar_id.closure_expr_id),\n+                    db.span_help(self.tcx.hir.span(upvar_id.closure_expr_id),\n                                  \"consider changing this closure to take \\\n                                  self by mutable reference\");\n                 }\n             }\n             _ => {\n                 if let Categorization::Deref(ref inner_cmt, ..) = err.cmt.cat {\n                     if let Categorization::Local(local_id) = inner_cmt.cat {\n-                        let parent = self.tcx.map.get_parent_node(local_id);\n+                        let parent = self.tcx.hir.get_parent_node(local_id);\n \n-                        if let Some(fn_like) = FnLikeNode::from_node(self.tcx.map.get(parent)) {\n-                            if let Some(i) = self.tcx.map.body(fn_like.body()).arguments.iter()\n+                        if let Some(fn_like) = FnLikeNode::from_node(self.tcx.hir.get(parent)) {\n+                            if let Some(i) = self.tcx.hir.body(fn_like.body()).arguments.iter()\n                                                      .position(|arg| arg.pat.id == local_id) {\n                                 let arg_ty = &fn_like.decl().inputs[i];\n                                 if let hir::TyRptr(\n@@ -1141,7 +1141,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         }\n                     }\n                 } else if let Categorization::Local(local_id) = err.cmt.cat {\n-                    let span = self.tcx.map.span(local_id);\n+                    let span = self.tcx.hir.span(local_id);\n                     if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n                         if snippet.starts_with(\"ref mut \") || snippet.starts_with(\"&mut \") {\n                             db.span_label(*error_span, &format!(\"cannot reborrow mutably\"));\n@@ -1253,7 +1253,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n fn statement_scope_span(tcx: TyCtxt, region: &ty::Region) -> Option<Span> {\n     match *region {\n         ty::ReScope(scope) => {\n-            match tcx.map.find(scope.node_id(&tcx.region_maps)) {\n+            match tcx.hir.find(scope.node_id(&tcx.region_maps)) {\n                 Some(hir_map::NodeStmt(stmt)) => Some(stmt.span),\n                 _ => None\n             }\n@@ -1302,11 +1302,11 @@ impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.kind {\n             LpVar(id) => {\n-                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.map.node_to_string(id)))\n+                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir.node_to_string(id)))\n             }\n \n             LpUpvar(ty::UpvarId{ var_id, closure_expr_id }) => {\n-                let s = ty::tls::with(|tcx| tcx.map.node_to_string(var_id));\n+                let s = ty::tls::with(|tcx| tcx.hir.node_to_string(var_id));\n                 write!(f, \"$({} captured by id={})\", s, closure_expr_id)\n             }\n \n@@ -1334,11 +1334,11 @@ impl<'tcx> fmt::Display for LoanPath<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.kind {\n             LpVar(id) => {\n-                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.map.node_to_user_string(id)))\n+                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir.node_to_user_string(id)))\n             }\n \n             LpUpvar(ty::UpvarId{ var_id, closure_expr_id: _ }) => {\n-                let s = ty::tls::with(|tcx| tcx.map.node_to_user_string(var_id));\n+                let s = ty::tls::with(|tcx| tcx.hir.node_to_user_string(var_id));\n                 write!(f, \"$({} captured by closure)\", s)\n             }\n "}, {"sha": "0b1f2465a4d5921daee9beced54ea09dde65bd53", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -42,7 +42,7 @@ struct OuterVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n \n impl<'a, 'tcx> Visitor<'tcx> for OuterVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n@@ -53,7 +53,7 @@ impl<'a, 'tcx> Visitor<'tcx> for OuterVisitor<'a, 'tcx> {\n             tcx: self.tcx,\n             tables: self.tcx.body_tables(b),\n             param_env: &ty::ParameterEnvironment::for_item(self.tcx, id)\n-        }.visit_body(self.tcx.map.body(b));\n+        }.visit_body(self.tcx.hir.body(b));\n     }\n }\n \n@@ -152,7 +152,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             }\n         }\n \n-        let module = self.tcx.map.local_def_id(self.tcx.map.get_module_parent(scrut.id));\n+        let module = self.tcx.hir.local_def_id(self.tcx.hir.get_module_parent(scrut.id));\n         MatchCheckCtxt::create_and_enter(self.tcx, module, |ref mut cx| {\n             let mut have_errors = false;\n \n@@ -195,7 +195,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             \"local binding\"\n         };\n \n-        let module = self.tcx.map.local_def_id(self.tcx.map.get_module_parent(pat.id));\n+        let module = self.tcx.hir.local_def_id(self.tcx.hir.get_module_parent(pat.id));\n         MatchCheckCtxt::create_and_enter(self.tcx, module, |ref mut cx| {\n             let mut patcx = PatternContext::new(self.tcx, self.tables);\n             let pattern = patcx.lower_pattern(pat);"}, {"sha": "e8055602087e542336d6b26cc82b45cd18ce5eca", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -53,15 +53,15 @@ macro_rules! math {\n fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   variant_def: DefId)\n                                   -> Option<(&'tcx Expr, Option<&'a ty::TypeckTables<'tcx>>)> {\n-    if let Some(variant_node_id) = tcx.map.as_local_node_id(variant_def) {\n-        let enum_node_id = tcx.map.get_parent(variant_node_id);\n-        if let Some(ast_map::NodeItem(it)) = tcx.map.find(enum_node_id) {\n+    if let Some(variant_node_id) = tcx.hir.as_local_node_id(variant_def) {\n+        let enum_node_id = tcx.hir.get_parent(variant_node_id);\n+        if let Some(ast_map::NodeItem(it)) = tcx.hir.find(enum_node_id) {\n             if let hir::ItemEnum(ref edef, _) = it.node {\n                 for variant in &edef.variants {\n                     if variant.node.data.id() == variant_node_id {\n                         return variant.node.disr_expr.map(|e| {\n-                            let def_id = tcx.map.body_owner_def_id(e);\n-                            (&tcx.map.body(e).value,\n+                            let def_id = tcx.hir.body_owner_def_id(e);\n+                            (&tcx.hir.body(e).value,\n                              tcx.tables.borrow().get(&def_id).cloned())\n                         });\n                     }\n@@ -83,16 +83,16 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         -> Option<(&'tcx Expr,\n                                                    Option<&'a ty::TypeckTables<'tcx>>,\n                                                    Option<ty::Ty<'tcx>>)> {\n-    if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n-        match tcx.map.find(node_id) {\n+    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n+        match tcx.hir.find(node_id) {\n             None => None,\n             Some(ast_map::NodeItem(&hir::Item {\n                 node: hir::ItemConst(ref ty, body), ..\n             })) |\n             Some(ast_map::NodeImplItem(&hir::ImplItem {\n                 node: hir::ImplItemKind::Const(ref ty, body), ..\n             })) => {\n-                Some((&tcx.map.body(body).value,\n+                Some((&tcx.hir.body(body).value,\n                       tcx.tables.borrow().get(&def_id).cloned(),\n                       tcx.ast_ty_to_prim_ty(ty)))\n             }\n@@ -102,10 +102,10 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         // If we have a trait item and the substitutions for it,\n                         // `resolve_trait_associated_const` will select an impl\n                         // or the default.\n-                        let trait_id = tcx.map.get_parent(node_id);\n-                        let trait_id = tcx.map.local_def_id(trait_id);\n+                        let trait_id = tcx.hir.get_parent(node_id);\n+                        let trait_id = tcx.hir.local_def_id(trait_id);\n                         let default_value = default.map(|body| {\n-                            (&tcx.map.body(body).value,\n+                            (&tcx.hir.body(body).value,\n                              tcx.tables.borrow().get(&def_id).cloned(),\n                              tcx.ast_ty_to_prim_ty(ty))\n                         });\n@@ -156,10 +156,10 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                                    -> Option<(&'tcx hir::Body, Option<&'a ty::TypeckTables<'tcx>>)>\n {\n-    if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n-        FnLikeNode::from_node(tcx.map.get(node_id)).and_then(|fn_like| {\n+    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n+        FnLikeNode::from_node(tcx.hir.get(node_id)).and_then(|fn_like| {\n             if fn_like.constness() == hir::Constness::Const {\n-                Some((tcx.map.body(fn_like.body()),\n+                Some((tcx.hir.body(fn_like.body()),\n                       tcx.tables.borrow().get(&def_id).cloned()))\n             } else {\n                 None\n@@ -232,7 +232,7 @@ pub struct ConstContext<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, body: hir::BodyId) -> Self {\n-        let def_id = tcx.map.body_owner_def_id(body);\n+        let def_id = tcx.hir.body_owner_def_id(body);\n         ConstContext {\n             tcx: tcx,\n             tables: tcx.tables.borrow().get(&def_id).cloned(),\n@@ -808,7 +808,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n                 _ => bug!()\n             }\n           } else {\n-            let n = &tcx.map.body(count).value;\n+            let n = &tcx.hir.body(count).value;\n             match ConstContext::new(tcx, count).eval(n, len_hint)? {\n                 Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n                 Integral(_) => signal!(e, RepeatCountNotNatural),\n@@ -1203,7 +1203,7 @@ pub fn eval_length<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              -> Result<usize, ErrorReported>\n {\n     let hint = UncheckedExprHint(tcx.types.usize);\n-    let count_expr = &tcx.map.body(count).value;\n+    let count_expr = &tcx.hir.body(count).value;\n     match ConstContext::new(tcx, count).eval(count_expr, hint) {\n         Ok(Integral(Usize(count))) => {\n             let val = count.as_u64(tcx.sess.target.uint_type);\n@@ -1227,7 +1227,7 @@ pub fn eval_length<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             if let hir::ExprPath(hir::QPath::Resolved(None, ref path)) = count_expr.node {\n                 if let Def::Local(..) = path.def {\n                     diag.note(&format!(\"`{}` is a variable\",\n-                                       tcx.map.node_to_pretty_string(count_expr.id)));\n+                                       tcx.hir.node_to_pretty_string(count_expr.id)));\n                 }\n             }\n "}, {"sha": "a3b80ebddcf00d15472f7e6d7a7627fb462f9455", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -360,7 +360,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::Binding(bm, def_id, ref ident, ref sub) => {\n-                let id = self.tcx.map.as_local_node_id(def_id).unwrap();\n+                let id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                 let var_ty = self.tables.node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(r, _) => Some(r),"}, {"sha": "1991fbb58edf13d1889a60aece621626fac234db", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -181,7 +181,7 @@ pub fn compile_input(sess: &Session,\n                                                                    outdir,\n                                                                    output,\n                                                                    opt_crate,\n-                                                                   tcx.map.krate(),\n+                                                                   tcx.hir.krate(),\n                                                                    &analysis,\n                                                                    tcx,\n                                                                    &crate_name);"}, {"sha": "1885f76f1e4cdd3734054a5df312032b2ae5d060", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -502,7 +502,7 @@ impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n     }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'tcx>> {\n-        Some(&self.tcx.map)\n+        Some(&self.tcx.hir)\n     }\n \n     fn pp_ann<'a>(&'a self) -> &'a pprust_hir::PpAnn {\n@@ -521,7 +521,7 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n         if let pprust_hir::Nested::Body(id) = nested {\n             self.tables.set(self.tcx.body_tables(id));\n         }\n-        pprust_hir::PpAnn::nested(&self.tcx.map, state, nested)?;\n+        pprust_hir::PpAnn::nested(&self.tcx.hir, state, nested)?;\n         self.tables.set(old_tables);\n         Ok(())\n     }\n@@ -739,13 +739,13 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n     let cfg = match code {\n         blocks::Code::Expr(expr) => cfg::CFG::new(tcx, expr),\n         blocks::Code::FnLike(fn_like) => {\n-            let body = tcx.map.body(fn_like.body());\n+            let body = tcx.hir.body(fn_like.body());\n             cfg::CFG::new(tcx, &body.value)\n         },\n     };\n     let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n     let lcfg = LabelledCFG {\n-        ast_map: &tcx.map,\n+        ast_map: &tcx.hir,\n         cfg: &cfg,\n         name: format!(\"node_{}\", code.id()),\n         labelled_edges: labelled_edges,\n@@ -1005,7 +1005,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n         match ppm {\n             PpmMir | PpmMirCFG => {\n                 if let Some(nodeid) = nodeid {\n-                    let def_id = tcx.map.local_def_id(nodeid);\n+                    let def_id = tcx.hir.local_def_id(nodeid);\n                     match ppm {\n                         PpmMir => write_mir_pretty(tcx, iter::once(def_id), &mut out),\n                         PpmMirCFG => write_mir_graphviz(tcx, iter::once(def_id), &mut out),\n@@ -1030,11 +1030,11 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                 let nodeid =\n                     nodeid.expect(\"`pretty flowgraph=..` needs NodeId (int) or unique path \\\n                                    suffix (b::c::d)\");\n-                let node = tcx.map.find(nodeid).unwrap_or_else(|| {\n+                let node = tcx.hir.find(nodeid).unwrap_or_else(|| {\n                     tcx.sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\", nodeid))\n                 });\n \n-                match blocks::Code::from_node(&tcx.map, nodeid) {\n+                match blocks::Code::from_node(&tcx.hir, nodeid) {\n                     Some(code) => {\n                         let variants = gather_flowgraph_variants(tcx.sess);\n \n@@ -1047,7 +1047,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                got {:?}\",\n                                               node);\n \n-                        tcx.sess.span_fatal(tcx.map.span(nodeid), &message)\n+                        tcx.sess.span_fatal(tcx.hir.span(nodeid), &message)\n                     }\n                 }\n             }"}, {"sha": "0ac95d12eeef3635b2515cd69e76dc6ceefafb2d", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -197,7 +197,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n     #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now\n     pub fn lookup_item(&self, names: &[String]) -> ast::NodeId {\n-        return match search_mod(self, &self.infcx.tcx.map.krate().module, 0, names) {\n+        return match search_mod(self, &self.infcx.tcx.hir.krate().module, 0, names) {\n             Some(id) => id,\n             None => {\n                 panic!(\"no item found: `{}`\", names.join(\"::\"));\n@@ -211,7 +211,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n                       -> Option<ast::NodeId> {\n             assert!(idx < names.len());\n             for item in &m.item_ids {\n-                let item = this.infcx.tcx.map.expect_item(item.id);\n+                let item = this.infcx.tcx.hir.expect_item(item.id);\n                 if item.name.to_string() == names[idx] {\n                     return search(this, item, idx + 1, names);\n                 }"}, {"sha": "287ee7dd13e4e5729328aa74d6c6ade039035b91", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -79,8 +79,8 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         let mut visitor = IfThisChanged { tcx: tcx,\n                                           if_this_changed: vec![],\n                                           then_this_would_need: vec![] };\n-        visitor.process_attrs(ast::CRATE_NODE_ID, &tcx.map.krate().attrs);\n-        tcx.map.krate().visit_all_item_likes(&mut visitor);\n+        visitor.process_attrs(ast::CRATE_NODE_ID, &tcx.hir.krate().attrs);\n+        tcx.hir.krate().visit_all_item_likes(&mut visitor);\n         (visitor.if_this_changed, visitor.then_this_would_need)\n     };\n \n@@ -120,7 +120,7 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n     }\n \n     fn process_attrs(&mut self, node_id: ast::NodeId, attrs: &[ast::Attribute]) {\n-        let def_id = self.tcx.map.local_def_id(node_id);\n+        let def_id = self.tcx.hir.local_def_id(node_id);\n         for attr in attrs {\n             if attr.check_name(ATTR_IF_THIS_CHANGED) {\n                 let dep_node_interned = self.argument(attr);"}, {"sha": "b9e6426dc01d804894568299cc771c5007600a7e", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -102,7 +102,7 @@ impl<'a> ::std::ops::Index<&'a DepNode<DefId>> for IncrementalHashesMap {\n pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                                     -> IncrementalHashesMap {\n     let _ignore = tcx.dep_graph.in_ignore();\n-    let krate = tcx.map.krate();\n+    let krate = tcx.hir.krate();\n     let hash_spans = tcx.sess.opts.debuginfo != NoDebugInfo;\n     let mut visitor = HashItemsVisitor {\n         tcx: tcx,\n@@ -141,7 +141,7 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n     fn calculate_node_id<W>(&mut self, id: ast::NodeId, walk_op: W)\n         where W: for<'v> FnMut(&mut StrictVersionHashVisitor<'v, 'a, 'tcx>)\n     {\n-        let def_id = self.tcx.map.local_def_id(id);\n+        let def_id = self.tcx.hir.local_def_id(id);\n         self.calculate_def_id(def_id, walk_op)\n     }\n \n@@ -178,7 +178,7 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n     }\n \n     fn compute_crate_hash(&mut self) {\n-        let krate = self.tcx.map.krate();\n+        let krate = self.tcx.hir.krate();\n \n         let mut crate_state = IchHasher::new();\n "}, {"sha": "69237f406760df9ebe1ebd4c97b83e5fb276f60b", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -561,7 +561,7 @@ macro_rules! hash_span {\n impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> visit::NestedVisitorMap<'this, 'tcx> {\n         if self.hash_bodies {\n-            visit::NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+            visit::NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n         } else {\n             visit::NestedVisitorMap::None\n         }"}, {"sha": "6e66dac6470f03df93ecd83f54b492be4d72742c", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -72,7 +72,7 @@ pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                    .collect();\n     let query = tcx.dep_graph.query();\n     debug!(\"query-nodes: {:?}\", query.nodes());\n-    let krate = tcx.map.krate();\n+    let krate = tcx.hir.krate();\n     krate.visit_all_item_likes(&mut DirtyCleanVisitor {\n         tcx: tcx,\n         query: &query,\n@@ -171,7 +171,7 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let def_id = self.tcx.map.local_def_id(item.id);\n+        let def_id = self.tcx.hir.local_def_id(item.id);\n         for attr in self.tcx.get_attrs(def_id).iter() {\n             if attr.check_name(ATTR_DIRTY) {\n                 if check_config(self.tcx, attr) {\n@@ -200,7 +200,7 @@ pub fn check_dirty_clean_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     tcx.dep_graph.with_ignore(||{\n-        let krate = tcx.map.krate();\n+        let krate = tcx.hir.krate();\n         krate.visit_all_item_likes(&mut DirtyCleanMetadataVisitor {\n             tcx: tcx,\n             prev_metadata_hashes: prev_metadata_hashes,\n@@ -217,7 +217,7 @@ pub struct DirtyCleanMetadataVisitor<'a, 'tcx:'a, 'm> {\n \n impl<'a, 'tcx, 'm> ItemLikeVisitor<'tcx> for DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let def_id = self.tcx.map.local_def_id(item.id);\n+        let def_id = self.tcx.hir.local_def_id(item.id);\n \n         for attr in self.tcx.get_attrs(def_id).iter() {\n             if attr.check_name(ATTR_DIRTY_METADATA) {"}, {"sha": "d4ab31da8a31ec59064401796222bc825ce08e5e", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -28,7 +28,7 @@ pub enum MethodLateContext {\n }\n \n pub fn method_context(cx: &LateContext, id: ast::NodeId, span: Span) -> MethodLateContext {\n-    let def_id = cx.tcx.map.local_def_id(id);\n+    let def_id = cx.tcx.hir.local_def_id(id);\n     match cx.tcx.associated_items.borrow().get(&def_id) {\n         None => span_bug!(span, \"missing method descriptor?!\"),\n         Some(item) => {"}, {"sha": "2892d61b8bd6fdf38204ffad45921ac1b4299376", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -117,7 +117,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n             hir::ItemEnum(..) |\n             hir::ItemStruct(..) |\n             hir::ItemUnion(..) => {\n-                let def_id = cx.tcx.map.local_def_id(it.id);\n+                let def_id = cx.tcx.hir.local_def_id(it.id);\n                 self.check_heap_type(cx, it.span, cx.tcx.item_type(def_id))\n             }\n             _ => ()\n@@ -128,7 +128,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n             hir::ItemStruct(ref struct_def, _) |\n             hir::ItemUnion(ref struct_def, _) => {\n                 for struct_field in struct_def.fields() {\n-                    let def_id = cx.tcx.map.local_def_id(struct_field.id);\n+                    let def_id = cx.tcx.hir.local_def_id(struct_field.id);\n                     self.check_heap_type(cx, struct_field.span,\n                                          cx.tcx.item_type(def_id));\n                 }\n@@ -390,8 +390,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 // If the trait is private, add the impl items to private_traits so they don't get\n                 // reported for missing docs.\n                 let real_trait = trait_ref.path.def.def_id();\n-                if let Some(node_id) = cx.tcx.map.as_local_node_id(real_trait) {\n-                    match cx.tcx.map.find(node_id) {\n+                if let Some(node_id) = cx.tcx.hir.as_local_node_id(real_trait) {\n+                    match cx.tcx.hir.find(node_id) {\n                         Some(hir_map::NodeItem(item)) => {\n                             if item.vis == hir::Visibility::Inherited {\n                                 for impl_item_ref in impl_item_refs {\n@@ -504,21 +504,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                let def = cx.tcx.lookup_adt_def(cx.tcx.map.local_def_id(item.id));\n+                let def = cx.tcx.lookup_adt_def(cx.tcx.hir.local_def_id(item.id));\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemUnion(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                let def = cx.tcx.lookup_adt_def(cx.tcx.map.local_def_id(item.id));\n+                let def = cx.tcx.lookup_adt_def(cx.tcx.hir.local_def_id(item.id));\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemEnum(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                let def = cx.tcx.lookup_adt_def(cx.tcx.map.local_def_id(item.id));\n+                let def = cx.tcx.lookup_adt_def(cx.tcx.hir.local_def_id(item.id));\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             _ => return,\n@@ -586,7 +586,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n             let mut impls = NodeSet();\n             debug_def.for_each_impl(cx.tcx, |d| {\n                 if let Some(ty_def) = cx.tcx.item_type(d).ty_to_def_id() {\n-                    if let Some(node_id) = cx.tcx.map.as_local_node_id(ty_def) {\n+                    if let Some(node_id) = cx.tcx.hir.as_local_node_id(ty_def) {\n                         impls.insert(node_id);\n                     }\n                 }\n@@ -680,7 +680,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n         let method = match fn_kind {\n             FnKind::ItemFn(..) => None,\n             FnKind::Method(..) => {\n-                Some(cx.tcx.associated_item(cx.tcx.map.local_def_id(id)))\n+                Some(cx.tcx.associated_item(cx.tcx.hir.local_def_id(id)))\n             }\n             // closures can't recur, so they don't matter.\n             FnKind::Closure(_) => return,\n@@ -745,7 +745,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                 false\n             };\n             if self_recursive {\n-                self_call_spans.push(cx.tcx.map.span(node_id));\n+                self_call_spans.push(cx.tcx.hir.span(node_id));\n                 // this is a self call, so we shouldn't explore past\n                 // this node in the CFG.\n                 continue;\n@@ -788,14 +788,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n         // represents a call to the function `fn_id`/method `method`.\n \n         fn expr_refers_to_this_fn(cx: &LateContext, fn_id: ast::NodeId, id: ast::NodeId) -> bool {\n-            match cx.tcx.map.get(id) {\n+            match cx.tcx.hir.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n                     let def = if let hir::ExprPath(ref qpath) = callee.node {\n                         cx.tables.qpath_def(qpath, callee.id)\n                     } else {\n                         return false;\n                     };\n-                    def.def_id() == cx.tcx.map.local_def_id(fn_id)\n+                    def.def_id() == cx.tcx.hir.local_def_id(fn_id)\n                 }\n                 _ => false,\n             }\n@@ -830,7 +830,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             }\n \n             // Check for calls to methods via explicit paths (e.g. `T::method()`).\n-            match cx.tcx.map.get(id) {\n+            match cx.tcx.hir.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n                     let def = if let hir::ExprPath(ref qpath) = callee.node {\n                         cx.tables.qpath_def(qpath, callee.id)\n@@ -871,15 +871,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                 ty::TraitContainer(trait_def_id) => {\n                     let trait_ref = ty::TraitRef::from_method(tcx, trait_def_id, callee_substs);\n                     let trait_ref = ty::Binder(trait_ref);\n-                    let span = tcx.map.span(expr_id);\n+                    let span = tcx.hir.span(expr_id);\n                     let obligation =\n                         traits::Obligation::new(traits::ObligationCause::misc(span, expr_id),\n                                                 trait_ref.to_poly_trait_predicate());\n \n                     // unwrap() is ok here b/c `method` is the method\n                     // defined in this crate whose body we are\n                     // checking, so it's always local\n-                    let node_id = tcx.map.as_local_node_id(method.def_id).unwrap();\n+                    let node_id = tcx.hir.as_local_node_id(method.def_id).unwrap();\n \n                     let param_env = ty::ParameterEnvironment::for_item(tcx, node_id);\n                     tcx.infer_ctxt(param_env, Reveal::NotSpecializable).enter(|infcx| {\n@@ -1151,7 +1151,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n         if let hir::ItemUnion(ref vdata, _) = item.node {\n             let param_env = &ty::ParameterEnvironment::for_item(ctx.tcx, item.id);\n             for field in vdata.fields() {\n-                let field_ty = ctx.tcx.item_type(ctx.tcx.map.local_def_id(field.id));\n+                let field_ty = ctx.tcx.item_type(ctx.tcx.hir.local_def_id(field.id));\n                 if ctx.tcx.type_needs_drop_given_env(field_ty, param_env) {\n                     ctx.span_lint(UNIONS_WITH_DROP_FIELDS,\n                                   field.span,"}, {"sha": "532e602226450aed85fdefe7b8613bfbfe551213", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -631,7 +631,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     }\n \n     fn check_foreign_fn(&mut self, id: ast::NodeId, decl: &hir::FnDecl) {\n-        let def_id = self.cx.tcx.map.local_def_id(id);\n+        let def_id = self.cx.tcx.hir.local_def_id(id);\n         let sig = self.cx.tcx.item_type(def_id).fn_sig();\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n \n@@ -648,7 +648,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     }\n \n     fn check_foreign_static(&mut self, id: ast::NodeId, span: Span) {\n-        let def_id = self.cx.tcx.map.local_def_id(id);\n+        let def_id = self.cx.tcx.hir.local_def_id(id);\n         let ty = self.cx.tcx.item_type(def_id);\n         self.check_type_for_ffi_and_report_errors(span, ty);\n     }\n@@ -696,7 +696,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n         if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n             if gens.ty_params.is_empty() {\n                 // sizes only make sense for non-generic types\n-                let t = cx.tcx.item_type(cx.tcx.map.local_def_id(it.id));\n+                let t = cx.tcx.item_type(cx.tcx.hir.local_def_id(it.id));\n                 let layout = cx.tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n                     let ty = cx.tcx.erase_regions(&t);\n                     ty.layout(&infcx).unwrap_or_else(|e| {"}, {"sha": "a85b47c8ada7a2c6c533567ed8ec160cfa9436af", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -64,7 +64,7 @@ impl UnusedMut {\n         for (_, v) in &mutables {\n             if !v.iter().any(|e| used_mutables.contains(e)) {\n                 cx.span_lint(UNUSED_MUT,\n-                             cx.tcx.map.span(v[0]),\n+                             cx.tcx.hir.span(v[0]),\n                              \"variable does not need to be mutable\");\n             }\n         }"}, {"sha": "459132eb9c61394f637b9cd210ec03281c9fbdbf", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -28,7 +28,7 @@ pub struct Ast<'tcx> {\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     pub fn encode_body(&mut self, body_id: hir::BodyId) -> Lazy<Ast<'tcx>> {\n-        let body = self.tcx.map.body(body_id);\n+        let body = self.tcx.hir.body(body_id);\n         let lazy_body = self.lazy(body);\n \n         let tables = self.tcx.body_tables(body_id);\n@@ -67,7 +67,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for NestedBodyEncodingVisitor<'a, 'b, 'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let body = self.ecx.tcx.map.body(body);\n+        let body = self.ecx.tcx.hir.body(body);\n         body.encode(self.ecx).unwrap();\n         self.count += 1;\n "}, {"sha": "d100cb53a8b016649659dac39227198151119139", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -428,7 +428,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                                def_id: DefId)\n                                -> Option<&'tcx hir::Body>\n     {\n-        if let Some(cached) = tcx.map.get_inlined_body(def_id) {\n+        if let Some(cached) = tcx.hir.get_inlined_body(def_id) {\n             return Some(cached);\n         }\n "}, {"sha": "101531b52afb804b54b9a6432f3a9f2ea2ee7526", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -776,7 +776,7 @@ impl<'a, 'tcx> CrateMetadata {\n             tcx.tables.borrow_mut().insert(def_id, tcx.alloc_tables(tables));\n \n             let body = ast.body.decode((self, tcx));\n-            tcx.map.intern_inlined_body(def_id, body)\n+            tcx.hir.intern_inlined_body(def_id, body)\n         })\n     }\n "}, {"sha": "2f71776ecf758db446399699903730e55b3ae2f4", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -267,8 +267,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             struct_ctor: None,\n         };\n \n-        let enum_id = tcx.map.as_local_node_id(enum_did).unwrap();\n-        let enum_vis = &tcx.map.expect_item(enum_id).vis;\n+        let enum_id = tcx.hir.as_local_node_id(enum_did).unwrap();\n+        let enum_vis = &tcx.hir.expect_item(enum_id).vis;\n \n         Entry {\n             kind: EntryKind::Variant(self.lazy(&data)),\n@@ -299,7 +299,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                                                                  &hir::Visibility)>)\n                            -> Entry<'tcx> {\n         let tcx = self.tcx;\n-        let def_id = tcx.map.local_def_id(id);\n+        let def_id = tcx.hir.local_def_id(id);\n \n         let data = ModData {\n             reexports: match self.reexports.get(&id) {\n@@ -314,7 +314,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             span: self.lazy(&md.inner),\n             attributes: self.encode_attributes(attrs),\n             children: self.lazy_seq(md.item_ids.iter().map(|item_id| {\n-                tcx.map.local_def_id(item_id.id).index\n+                tcx.hir.local_def_id(item_id.id).index\n             })),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n@@ -361,8 +361,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let field = &variant.fields[field_index];\n \n         let def_id = field.did;\n-        let variant_id = tcx.map.as_local_node_id(variant.did).unwrap();\n-        let variant_data = tcx.map.expect_variant_data(variant_id);\n+        let variant_id = tcx.hir.as_local_node_id(variant.did).unwrap();\n+        let variant_data = tcx.hir.expect_variant_data(variant_id);\n \n         Entry {\n             kind: EntryKind::Field,\n@@ -394,8 +394,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             struct_ctor: Some(def_id.index),\n         };\n \n-        let struct_id = tcx.map.as_local_node_id(adt_def_id).unwrap();\n-        let struct_vis = &tcx.map.expect_item(struct_id).vis;\n+        let struct_id = tcx.hir.as_local_node_id(adt_def_id).unwrap();\n+        let struct_vis = &tcx.hir.expect_item(struct_id).vis;\n \n         Entry {\n             kind: EntryKind::Struct(self.lazy(&data)),\n@@ -430,8 +430,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_info_for_trait_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n         let tcx = self.tcx;\n \n-        let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n-        let ast_item = tcx.map.expect_trait_item(node_id);\n+        let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+        let ast_item = tcx.hir.expect_trait_item(node_id);\n         let trait_item = tcx.associated_item(def_id);\n \n         let container = match trait_item.defaultness {\n@@ -508,8 +508,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        let node_id = self.tcx.map.as_local_node_id(def_id).unwrap();\n-        let ast_item = self.tcx.map.expect_impl_item(node_id);\n+        let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n+        let ast_item = self.tcx.hir.expect_impl_item(node_id);\n         let impl_item = self.tcx.associated_item(def_id);\n \n         let container = match impl_item.defaultness {\n@@ -576,7 +576,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_fn_arg_names_for_body(&mut self, body_id: hir::BodyId)\n                                     -> LazySeq<ast::Name> {\n         let _ignore = self.tcx.dep_graph.in_ignore();\n-        let body = self.tcx.map.body(body_id);\n+        let body = self.tcx.hir.body(body_id);\n         self.lazy_seq(body.arguments.iter().map(|arg| {\n             match arg.pat.node {\n                 PatKind::Binding(_, _, name, _) => name.node,\n@@ -646,7 +646,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 // for methods, write all the stuff get_trait_method\n                 // needs to know\n                 let struct_ctor = if !struct_def.is_struct() {\n-                    Some(tcx.map.local_def_id(struct_def.id()).index)\n+                    Some(tcx.hir.local_def_id(struct_def.id()).index)\n                 } else {\n                     None\n                 };\n@@ -725,7 +725,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 hir::ItemForeignMod(ref fm) => {\n                     self.lazy_seq(fm.items\n                         .iter()\n-                        .map(|foreign_item| tcx.map.local_def_id(foreign_item.id).index))\n+                        .map(|foreign_item| tcx.hir.local_def_id(foreign_item.id).index))\n                 }\n                 hir::ItemEnum(..) => {\n                     let def = self.tcx.lookup_adt_def(def_id);\n@@ -855,7 +855,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     /// so it's easier to do that here then to wait until we would encounter\n     /// normally in the visitor walk.\n     fn encode_addl_info_for_item(&mut self, item: &hir::Item) {\n-        let def_id = self.tcx.map.local_def_id(item.id);\n+        let def_id = self.tcx.hir.local_def_id(item.id);\n         match item.node {\n             hir::ItemStatic(..) |\n             hir::ItemConst(..) |\n@@ -883,7 +883,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n \n                 // If the struct has a constructor, encode it.\n                 if !struct_def.is_struct() {\n-                    let ctor_def_id = self.tcx.map.local_def_id(struct_def.id());\n+                    let ctor_def_id = self.tcx.hir.local_def_id(struct_def.id());\n                     self.record(ctor_def_id,\n                                 EncodeContext::encode_struct_ctor,\n                                 (def_id, ctor_def_id));\n@@ -957,15 +957,15 @@ struct EncodeVisitor<'a, 'b: 'a, 'tcx: 'b> {\n \n impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.index.tcx.map)\n+        NestedVisitorMap::OnlyBodies(&self.index.tcx.hir)\n     }\n     fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n         intravisit::walk_expr(self, ex);\n         self.index.encode_info_for_expr(ex);\n     }\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         intravisit::walk_item(self, item);\n-        let def_id = self.index.tcx.map.local_def_id(item.id);\n+        let def_id = self.index.tcx.hir.local_def_id(item.id);\n         match item.node {\n             hir::ItemExternCrate(_) |\n             hir::ItemUse(..) => (), // ignore these\n@@ -975,7 +975,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n         intravisit::walk_foreign_item(self, ni);\n-        let def_id = self.index.tcx.map.local_def_id(ni.id);\n+        let def_id = self.index.tcx.hir.local_def_id(ni.id);\n         self.index.record(def_id,\n                           EncodeContext::encode_info_for_foreign_item,\n                           (def_id, ni));\n@@ -985,23 +985,23 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n         self.index.encode_info_for_ty(ty);\n     }\n     fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef) {\n-        let def_id = self.index.tcx.map.local_def_id(macro_def.id);\n+        let def_id = self.index.tcx.hir.local_def_id(macro_def.id);\n         self.index.record(def_id, EncodeContext::encode_info_for_macro_def, macro_def);\n     }\n }\n \n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n         if let hir::TyImplTrait(_) = ty.node {\n-            let def_id = self.tcx.map.local_def_id(ty.id);\n+            let def_id = self.tcx.hir.local_def_id(ty.id);\n             self.record(def_id, EncodeContext::encode_info_for_anon_ty, def_id);\n         }\n     }\n \n     fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n             hir::ExprClosure(..) => {\n-                let def_id = self.tcx.map.local_def_id(expr.id);\n+                let def_id = self.tcx.hir.local_def_id(expr.id);\n                 self.record(def_id, EncodeContext::encode_info_for_closure, def_id);\n             }\n             _ => {}\n@@ -1061,7 +1061,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_info_for_items(&mut self) -> Index {\n-        let krate = self.tcx.map.krate();\n+        let krate = self.tcx.hir.krate();\n         let mut index = IndexBuilder::new(self);\n         index.record(DefId::local(CRATE_DEF_INDEX),\n                      EncodeContext::encode_info_for_mod,\n@@ -1145,7 +1145,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_def_path_table(&mut self) -> Lazy<DefPathTable> {\n-        let definitions = self.tcx.map.definitions();\n+        let definitions = self.tcx.hir.definitions();\n         self.lazy(definitions.def_path_table())\n     }\n }\n@@ -1158,7 +1158,7 @@ struct ImplVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let hir::ItemImpl(..) = item.node {\n-            let impl_id = self.tcx.map.local_def_id(item.id);\n+            let impl_id = self.tcx.hir.local_def_id(item.id);\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n                 self.impls\n                     .entry(trait_ref.def_id)\n@@ -1182,7 +1182,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             tcx: self.tcx,\n             impls: FxHashMap(),\n         };\n-        self.tcx.map.krate().visit_all_item_likes(&mut visitor);\n+        self.tcx.hir.krate().visit_all_item_likes(&mut visitor);\n \n         let all_impls: Vec<_> = visitor.impls\n             .into_iter()\n@@ -1206,7 +1206,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_exported_symbols(&mut self) -> LazySeq<DefIndex> {\n         let exported_symbols = self.exported_symbols;\n         let tcx = self.tcx;\n-        self.lazy_seq(exported_symbols.iter().map(|&id| tcx.map.local_def_id(id).index))\n+        self.lazy_seq(exported_symbols.iter().map(|&id| tcx.hir.local_def_id(id).index))\n     }\n \n     fn encode_dylib_dependency_formats(&mut self) -> LazySeq<Option<LinkagePreference>> {\n@@ -1283,10 +1283,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             plugin_registrar_fn: tcx.sess\n                 .plugin_registrar_fn\n                 .get()\n-                .map(|id| tcx.map.local_def_id(id).index),\n+                .map(|id| tcx.hir.local_def_id(id).index),\n             macro_derive_registrar: if is_proc_macro {\n                 let id = tcx.sess.derive_registrar_fn.get().unwrap();\n-                Some(tcx.map.local_def_id(id).index)\n+                Some(tcx.hir.local_def_id(id).index)\n             } else {\n                 None\n             },"}, {"sha": "2359c747d888d4f71dbe4a7da46772297d6b6d56", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -90,7 +90,7 @@ impl<'a, 'b, 'tcx> DerefMut for IndexBuilder<'a, 'b, 'tcx> {\n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     pub fn new(ecx: &'a mut EncodeContext<'b, 'tcx>) -> Self {\n         IndexBuilder {\n-            items: Index::new(ecx.tcx.map.num_local_def_ids()),\n+            items: Index::new(ecx.tcx.hir.num_local_def_ids()),\n             ecx: ecx,\n         }\n     }\n@@ -186,7 +186,7 @@ macro_rules! read_hir {\n     ($t:ty) => {\n         impl<'tcx> DepGraphRead for &'tcx $t {\n             fn read(&self, tcx: TyCtxt) {\n-                tcx.map.read(self.id);\n+                tcx.hir.read(self.id);\n             }\n         }\n     }\n@@ -220,6 +220,6 @@ pub struct FromId<T>(pub ast::NodeId, pub T);\n \n impl<T> DepGraphRead for FromId<T> {\n     fn read(&self, tcx: TyCtxt) {\n-        tcx.map.read(self.0);\n+        tcx.hir.read(self.0);\n     }\n }"}, {"sha": "73d3875ba2384866ffbd9e14d034d739b9bffe53", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -58,7 +58,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         let_extent_stack.push(remainder_scope);\n \n                         // Declare the bindings, which may create a visibility scope.\n-                        let remainder_span = remainder_scope.span(&tcx.region_maps, &tcx.map);\n+                        let remainder_span = remainder_scope.span(&tcx.region_maps, &tcx.hir);\n                         let remainder_span = remainder_span.unwrap_or(span);\n                         let scope = this.declare_bindings(None, remainder_span, &pattern);\n "}, {"sha": "ecdc58ba55d6cbfef15d5d1eb20477b45ad5739c", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -133,7 +133,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let arguments: Vec<_> = arguments.collect();\n \n     let tcx = hir.tcx();\n-    let span = tcx.map.span(fn_id);\n+    let span = tcx.hir.span(fn_id);\n     let mut builder = Builder::new(hir, span, arguments.len(), return_ty);\n \n     let call_site_extent =\n@@ -168,7 +168,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     // Gather the upvars of a closure, if any.\n     let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n         freevars.iter().map(|fv| {\n-            let var_id = tcx.map.as_local_node_id(fv.def.def_id()).unwrap();\n+            let var_id = tcx.hir.as_local_node_id(fv.def.def_id()).unwrap();\n             let by_ref = hir.tables().upvar_capture(ty::UpvarId {\n                 var_id: var_id,\n                 closure_expr_id: fn_id\n@@ -180,7 +180,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 debug_name: keywords::Invalid.name(),\n                 by_ref: by_ref\n             };\n-            if let Some(hir::map::NodeLocal(pat)) = tcx.map.find(var_id) {\n+            if let Some(hir::map::NodeLocal(pat)) = tcx.hir.find(var_id) {\n                 if let hir::PatKind::Binding(_, _, ref ident, _) = pat.node {\n                     decl.debug_name = ident.node;\n                 }\n@@ -198,9 +198,9 @@ pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        body_id: hir::BodyId)\n                                        -> Mir<'tcx> {\n     let tcx = hir.tcx();\n-    let ast_expr = &tcx.map.body(body_id).value;\n+    let ast_expr = &tcx.hir.body(body_id).value;\n     let ty = hir.tables().expr_ty_adjusted(ast_expr);\n-    let span = tcx.map.span(tcx.map.body_owner(body_id));\n+    let span = tcx.hir.span(tcx.hir.body_owner(body_id));\n     let mut builder = Builder::new(hir, span, 0, ty);\n \n     let extent = tcx.region_maps.temporary_scope(ast_expr.id)"}, {"sha": "c702a142fab342fc1520b5643565d544be117d75", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -499,7 +499,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     scope.needs_cleanup = true;\n                 }\n                 let tcx = self.hir.tcx();\n-                let extent_span = extent.span(&tcx.region_maps, &tcx.map).unwrap();\n+                let extent_span = extent.span(&tcx.region_maps, &tcx.hir).unwrap();\n                 // Attribute scope exit drops to scope's closing brace\n                 let scope_end = Span { lo: extent_span.hi, .. extent_span};\n                 scope.drops.push(DropData {"}, {"sha": "91600b947c6106b96fce3887c8a99cee6f96371b", "filename": "src/librustc_mir/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -26,7 +26,7 @@ pub fn write_mir_graphviz<'a, 'b, 'tcx, W, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n     where W: Write, I: Iterator<Item=DefId>\n {\n     for def_id in iter {\n-        let nodeid = tcx.map.as_local_node_id(def_id).unwrap();\n+        let nodeid = tcx.hir.as_local_node_id(def_id).unwrap();\n         let mir = &tcx.item_mir(def_id);\n \n         writeln!(w, \"digraph Mir_{} {{\", nodeid)?;"}, {"sha": "c4c6ec6b8f40067ee7dab254d01a888311c80742", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -574,7 +574,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         // Now comes the rote stuff:\n         hir::ExprRepeat(ref v, count) => {\n             let tcx = cx.tcx.global_tcx();\n-            let c = &cx.tcx.map.body(count).value;\n+            let c = &cx.tcx.hir.body(count).value;\n             let count = match ConstContext::new(tcx, count).eval(c, EvalHint::ExprTypeChecked) {\n                 Ok(ConstVal::Integral(ConstInt::Usize(u))) => u,\n                 Ok(other) => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n@@ -765,19 +765,19 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n     match def {\n         Def::Local(def_id) => {\n-            let node_id = cx.tcx.map.as_local_node_id(def_id).unwrap();\n+            let node_id = cx.tcx.hir.as_local_node_id(def_id).unwrap();\n             ExprKind::VarRef { id: node_id }\n         }\n \n         Def::Upvar(def_id, index, closure_expr_id) => {\n-            let id_var = cx.tcx.map.as_local_node_id(def_id).unwrap();\n+            let id_var = cx.tcx.hir.as_local_node_id(def_id).unwrap();\n             debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\",\n                    id_var,\n                    index,\n                    closure_expr_id);\n             let var_ty = cx.tables().node_id_to_type(id_var);\n \n-            let body_id = match cx.tcx.map.find(closure_expr_id) {\n+            let body_id = match cx.tcx.hir.find(closure_expr_id) {\n                 Some(map::NodeExpr(expr)) => {\n                     match expr.node {\n                         hir::ExprClosure(.., body, _) => body.node_id,\n@@ -803,7 +803,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             });\n             let region = cx.tcx.mk_region(region);\n \n-            let self_expr = match cx.tcx.closure_kind(cx.tcx.map.local_def_id(closure_expr_id)) {\n+            let self_expr = match cx.tcx.closure_kind(cx.tcx.hir.local_def_id(closure_expr_id)) {\n                 ty::ClosureKind::Fn => {\n                     let ref_closure_ty = cx.tcx.mk_ref(region,\n                                                        ty::TypeAndMut {\n@@ -1013,7 +1013,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    freevar: &hir::Freevar,\n                                    freevar_ty: Ty<'tcx>)\n                                    -> ExprRef<'tcx> {\n-    let id_var = cx.tcx.map.as_local_node_id(freevar.def.def_id()).unwrap();\n+    let id_var = cx.tcx.hir.as_local_node_id(freevar.def.def_id()).unwrap();\n     let upvar_id = ty::UpvarId {\n         var_id: id_var,\n         closure_expr_id: closure_expr.id,"}, {"sha": "5b3297cb694e855f5f3e305dbb05c621a2018319", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -45,13 +45,13 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             MirSource::Const(_) |\n             MirSource::Static(..) => hir::Constness::Const,\n             MirSource::Fn(id) => {\n-                let fn_like = FnLikeNode::from_node(infcx.tcx.map.get(id));\n+                let fn_like = FnLikeNode::from_node(infcx.tcx.hir.get(id));\n                 fn_like.map_or(hir::Constness::NotConst, |f| f.constness())\n             }\n             MirSource::Promoted(..) => bug!(),\n         };\n \n-        let attrs = infcx.tcx.map.attrs(src.item_id());\n+        let attrs = infcx.tcx.hir.attrs(src.item_id());\n \n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on"}, {"sha": "c71255dcc7c61fec7d5c15fd4a05f8652ea53723", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -84,22 +84,22 @@ fn build<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                          -> (Mir<'tcx>, MirSource) {\n     let tcx = infcx.tcx.global_tcx();\n \n-    let item_id = tcx.map.body_owner(body_id);\n+    let item_id = tcx.hir.body_owner(body_id);\n     let src = MirSource::from_node(tcx, item_id);\n     let cx = Cx::new(infcx, src);\n     if let MirSource::Fn(id) = src {\n         // fetch the fully liberated fn signature (that is, all bound\n         // types/lifetimes replaced)\n         let fn_sig = cx.tables().liberated_fn_sigs[&id].clone();\n \n-        let ty = tcx.item_type(tcx.map.local_def_id(id));\n+        let ty = tcx.item_type(tcx.hir.local_def_id(id));\n         let (abi, implicit_argument) = if let ty::TyClosure(..) = ty.sty {\n             (Abi::Rust, Some((closure_self_ty(tcx, id, body_id), None)))\n         } else {\n             (ty.fn_abi(), None)\n         };\n \n-        let body = tcx.map.body(body_id);\n+        let body = tcx.hir.body(body_id);\n         let explicit_arguments =\n             body.arguments\n                 .iter()\n@@ -138,11 +138,11 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n             pretty::dump_mir(tcx, \"mir_map\", &0, src, &mir);\n \n             let mir = tcx.alloc_mir(mir);\n-            let def_id = tcx.map.local_def_id(src.item_id());\n+            let def_id = tcx.hir.local_def_id(src.item_id());\n             assert!(tcx.mir_map.borrow_mut().insert(def_id, mir).is_none());\n         });\n \n-        let body = self.tcx.map.body(body_id);\n+        let body = self.tcx.hir.body(body_id);\n         self.visit_body(body);\n     }\n }\n@@ -162,7 +162,7 @@ fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     });\n     let region = tcx.mk_region(region);\n \n-    match tcx.closure_kind(tcx.map.local_def_id(closure_expr_id)) {\n+    match tcx.closure_kind(tcx.hir.local_def_id(closure_expr_id)) {\n         ty::ClosureKind::Fn =>\n             tcx.mk_ref(region,\n                        ty::TypeAndMut { ty: closure_ty,"}, {"sha": "bfe3e143e7c50697c5c04fdbccc08935c8f9f048", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -48,7 +48,7 @@ pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         Some(ref filters) => filters,\n     };\n     let node_id = src.item_id();\n-    let node_path = tcx.item_path_str(tcx.map.local_def_id(node_id));\n+    let node_path = tcx.item_path_str(tcx.hir.local_def_id(node_id));\n     let is_matched =\n         filters.split(\"&\")\n                .any(|filter| {\n@@ -102,7 +102,7 @@ pub fn write_mir_pretty<'a, 'b, 'tcx, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n             writeln!(w, \"\")?;\n         }\n \n-        let id = tcx.map.as_local_node_id(def_id).unwrap();\n+        let id = tcx.hir.as_local_node_id(def_id).unwrap();\n         let src = MirSource::from_node(tcx, id);\n         write_mir_fn(tcx, src, mir, w)?;\n "}, {"sha": "2194c20c2f442fe3e62dff7771f6c5623c4fb3b7", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -57,7 +57,7 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                 return\n             }\n             MirSource::Fn(function_node_id) => {\n-                if qualify_consts::is_const_fn(tcx, tcx.map.local_def_id(function_node_id)) {\n+                if qualify_consts::is_const_fn(tcx, tcx.hir.local_def_id(function_node_id)) {\n                     // Don't run on const functions, as, again, trans might not be able to evaluate\n                     // the optimized IR.\n                     return"}, {"sha": "3a93bef36c5f77c958f21ac9918ac6e15774cbbd", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -21,7 +21,7 @@ impl<'tcx> MirPass<'tcx> for Deaggregator {\n     fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     source: MirSource, mir: &mut Mir<'tcx>) {\n         let node_id = source.item_id();\n-        let node_path = tcx.item_path_str(tcx.map.local_def_id(node_id));\n+        let node_path = tcx.item_path_str(tcx.hir.local_def_id(node_id));\n         debug!(\"running on: {:?}\", node_path);\n         // we only run when mir_opt_level > 2\n         if tcx.sess.opts.debugging_opts.mir_opt_level <= 2 {"}, {"sha": "af9f7fb5781386b6454d7e6efc32ef17de3365ce", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -115,8 +115,8 @@ impl fmt::Display for Mode {\n }\n \n pub fn is_const_fn(tcx: TyCtxt, def_id: DefId) -> bool {\n-    if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n-        if let Some(fn_like) = FnLikeNode::from_node(tcx.map.get(node_id)) {\n+    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n+        if let Some(fn_like) = FnLikeNode::from_node(tcx.hir.get(node_id)) {\n             fn_like.constness() == hir::Constness::Const\n         } else {\n             false\n@@ -267,15 +267,15 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                 self.tcx\n                     .lookup_trait_def(drop_trait_id)\n                     .for_each_relevant_impl(self.tcx, self.mir.return_ty, |impl_did| {\n-                        self.tcx.map\n+                        self.tcx.hir\n                             .as_local_node_id(impl_did)\n-                            .and_then(|impl_node_id| self.tcx.map.find(impl_node_id))\n+                            .and_then(|impl_node_id| self.tcx.hir.find(impl_node_id))\n                             .map(|node| {\n                                 if let hir_map::NodeItem(item) = node {\n                                     if let hir::ItemImpl(.., ref impl_item_refs) = item.node {\n                                         span = impl_item_refs.first()\n                                                              .map(|iiref| {\n-                                                                 self.tcx.map.impl_item(iiref.id)\n+                                                                 self.tcx.hir.impl_item(iiref.id)\n                                                                              .span\n                                                              });\n                                     }\n@@ -953,7 +953,7 @@ fn qualify_const_item_cached<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let param_env = if def_id.is_local() {\n-        let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n+        let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n         ty::ParameterEnvironment::for_item(tcx, node_id)\n     } else {\n         // These should only be monomorphic constants.\n@@ -978,7 +978,7 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants {\n     fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     src: MirSource, mir: &mut Mir<'tcx>) {\n         let id = src.item_id();\n-        let def_id = tcx.map.local_def_id(id);\n+        let def_id = tcx.hir.local_def_id(id);\n         let mode = match src {\n             MirSource::Fn(_) => {\n                 if is_const_fn(tcx, def_id) {"}, {"sha": "b6241c618df2f01507a9f06e923bd846bdd0f0de", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -98,8 +98,8 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     fn handle_const_fn_call(&mut self, def_id: DefId, ret_ty: Ty<'gcx>) {\n         self.add_type(ret_ty);\n \n-        self.promotable &= if let Some(fn_id) = self.tcx.map.as_local_node_id(def_id) {\n-            FnLikeNode::from_node(self.tcx.map.get(fn_id)).map_or(false, |fn_like| {\n+        self.promotable &= if let Some(fn_id) = self.tcx.hir.as_local_node_id(def_id) {\n+            FnLikeNode::from_node(self.tcx.hir.get(fn_id)).map_or(false, |fn_like| {\n                 fn_like.constness() == hir::Constness::Const\n             })\n         } else {\n@@ -122,7 +122,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n             }\n         }\n \n-        let item_id = self.tcx.map.body_owner(body_id);\n+        let item_id = self.tcx.hir.body_owner(body_id);\n \n         let outer_in_fn = self.in_fn;\n         self.in_fn = match MirSource::from_node(self.tcx, item_id) {\n@@ -131,9 +131,9 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         };\n \n         let outer_tables = self.tables;\n-        self.tables = self.tcx.item_tables(self.tcx.map.local_def_id(item_id));\n+        self.tables = self.tcx.item_tables(self.tcx.hir.local_def_id(item_id));\n \n-        let body = self.tcx.map.body(body_id);\n+        let body = self.tcx.hir.body(body_id);\n         if !self.in_fn {\n             self.check_const_eval(&body.value);\n         }\n@@ -329,8 +329,8 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                 Def::Fn(..) | Def::Method(..) => {}\n                 Def::AssociatedConst(_) => v.add_type(node_ty),\n                 Def::Const(did) => {\n-                    v.promotable &= if let Some(node_id) = v.tcx.map.as_local_node_id(did) {\n-                        match v.tcx.map.expect_item(node_id).node {\n+                    v.promotable &= if let Some(node_id) = v.tcx.hir.as_local_node_id(did) {\n+                        match v.tcx.hir.expect_item(node_id).node {\n                             hir::ItemConst(_, body) => {\n                                 v.visit_nested_body(body);\n                                 v.tcx.rvalue_promotable_to_static.borrow()[&body.node_id]"}, {"sha": "9de5ff541a52c98d6bfb799493644aacfca67028", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -37,7 +37,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RvalueContext<'a, 'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n-        let body = self.tcx.map.body(body_id);\n+        let body = self.tcx.hir.body(body_id);\n         self.tcx.infer_ctxt(body_id, Reveal::NotSpecializable).enter(|infcx| {\n             let mut delegate = RvalueContextDelegate {\n                 tcx: infcx.tcx,"}, {"sha": "7357d6f38b651a0d3a5d25a71ba873452db3bcba", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -75,7 +75,7 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n             ty::TyProjection(ref proj) => proj.trait_ref.def_id,\n             _ => return Some(AccessLevel::Public)\n         };\n-        if let Some(node_id) = self.tcx.map.as_local_node_id(ty_def_id) {\n+        if let Some(node_id) = self.tcx.hir.as_local_node_id(ty_def_id) {\n             self.get(node_id)\n         } else {\n             Some(AccessLevel::Public)\n@@ -84,7 +84,7 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n \n     fn impl_trait_level(&self, impl_def_id: DefId) -> Option<AccessLevel> {\n         if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_def_id) {\n-            if let Some(node_id) = self.tcx.map.as_local_node_id(trait_ref.def_id) {\n+            if let Some(node_id) = self.tcx.hir.as_local_node_id(trait_ref.def_id) {\n                 return self.get(node_id);\n             }\n         }\n@@ -111,7 +111,7 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     fn reach<'b>(&'b mut self, item_id: ast::NodeId)\n                  -> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n-            item_def_id: self.tcx.map.local_def_id(item_id),\n+            item_def_id: self.tcx.hir.local_def_id(item_id),\n             ev: self,\n         }\n     }\n@@ -121,18 +121,18 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.tcx.map)\n+        NestedVisitorMap::All(&self.tcx.hir)\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let inherited_item_level = match item.node {\n             // Impls inherit level from their types and traits\n             hir::ItemImpl(..) => {\n-                let def_id = self.tcx.map.local_def_id(item.id);\n+                let def_id = self.tcx.hir.local_def_id(item.id);\n                 cmp::min(self.item_ty_level(def_id), self.impl_trait_level(def_id))\n             }\n             hir::ItemDefaultImpl(..) => {\n-                let def_id = self.tcx.map.local_def_id(item.id);\n+                let def_id = self.tcx.hir.local_def_id(item.id);\n                 self.impl_trait_level(def_id)\n             }\n             // Foreign mods inherit level from parents\n@@ -306,7 +306,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n         if self.prev_level.is_some() {\n             if let Some(exports) = self.export_map.get(&id) {\n                 for export in exports {\n-                    if let Some(node_id) = self.tcx.map.as_local_node_id(export.def.def_id()) {\n+                    if let Some(node_id) = self.tcx.hir.as_local_node_id(export.def.def_id()) {\n                         self.update(node_id, Some(AccessLevel::Exported));\n                     }\n                 }\n@@ -366,7 +366,7 @@ impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b\n         };\n \n         if let Some(def_id) = ty_def_id {\n-            if let Some(node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n+            if let Some(node_id) = self.ev.tcx.hir.as_local_node_id(def_id) {\n                 self.ev.update(node_id, Some(AccessLevel::Reachable));\n             }\n         }\n@@ -375,8 +375,8 @@ impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b\n     }\n \n     fn visit_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n-        if let Some(node_id) = self.ev.tcx.map.as_local_node_id(trait_ref.def_id) {\n-            let item = self.ev.tcx.map.expect_item(node_id);\n+        if let Some(node_id) = self.ev.tcx.hir.as_local_node_id(trait_ref.def_id) {\n+            let item = self.ev.tcx.hir.expect_item(node_id);\n             self.ev.update(item.id, Some(AccessLevel::Reachable));\n         }\n \n@@ -397,9 +397,9 @@ struct PrivacyVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     fn item_is_accessible(&self, did: DefId) -> bool {\n-        match self.tcx.map.as_local_node_id(did) {\n+        match self.tcx.hir.as_local_node_id(did) {\n             Some(node_id) =>\n-                ty::Visibility::from_hir(&self.tcx.map.expect_item(node_id).vis, node_id, self.tcx),\n+                ty::Visibility::from_hir(&self.tcx.hir.expect_item(node_id).vis, node_id, self.tcx),\n             None => self.tcx.sess.cstore.visibility(did),\n         }.is_accessible_from(self.curitem, self.tcx)\n     }\n@@ -433,19 +433,19 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.tcx.map)\n+        NestedVisitorMap::All(&self.tcx.hir)\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         let old_tables = self.tables;\n         self.tables = self.tcx.body_tables(body);\n-        let body = self.tcx.map.body(body);\n+        let body = self.tcx.hir.body(body);\n         self.visit_body(body);\n         self.tables = old_tables;\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let orig_curitem = replace(&mut self.curitem, self.tcx.map.local_def_id(item.id));\n+        let orig_curitem = replace(&mut self.curitem, self.tcx.hir.local_def_id(item.id));\n         intravisit::walk_item(self, item);\n         self.curitem = orig_curitem;\n     }\n@@ -492,8 +492,8 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n                         error.span_label(expr.span,\n                                          &format!(\"cannot construct with a private field\"));\n \n-                        if let Some(node_id) = self.tcx.map.as_local_node_id(adt_def.did) {\n-                            let node = self.tcx.map.find(node_id);\n+                        if let Some(node_id) = self.tcx.hir.as_local_node_id(adt_def.did) {\n+                            let node = self.tcx.hir.find(node_id);\n                             if let Some(hir::map::NodeStructCtor(vdata)) = node {\n                                 for i in private_indexes {\n                                     error.span_label(vdata.fields()[i].span,\n@@ -590,10 +590,10 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n         // A path can only be private if:\n         // it's in this crate...\n-        if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n+        if let Some(node_id) = self.tcx.hir.as_local_node_id(did) {\n             // .. and it corresponds to a private type in the AST (this returns\n             // None for type parameters)\n-            match self.tcx.map.find(node_id) {\n+            match self.tcx.hir.find(node_id) {\n                 Some(hir::map::NodeItem(ref item)) => item.vis != hir::Public,\n                 Some(_) | None => false,\n             }\n@@ -653,7 +653,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.tcx.map)\n+        NestedVisitorMap::All(&self.tcx.hir)\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -709,7 +709,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                               |tr| {\n                         let did = tr.path.def.def_id();\n \n-                        if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n+                        if let Some(node_id) = self.tcx.hir.as_local_node_id(did) {\n                             self.trait_is_public(node_id)\n                         } else {\n                             true // external traits must be public\n@@ -728,7 +728,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     trait_ref.is_some() ||\n                     impl_item_refs.iter()\n                                  .any(|impl_item_ref| {\n-                                     let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n+                                     let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n                                      match impl_item.node {\n                                          hir::ImplItemKind::Const(..) |\n                                          hir::ImplItemKind::Method(..) => {\n@@ -752,7 +752,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                 // should only walk into public items so that we\n                                 // don't erroneously report errors for private\n                                 // types in private items.\n-                                let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n+                                let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n                                 match impl_item.node {\n                                     hir::ImplItemKind::Const(..) |\n                                     hir::ImplItemKind::Method(..)\n@@ -785,7 +785,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n                             // Those in 3. are warned with this call.\n                             for impl_item_ref in impl_item_refs {\n-                                let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n+                                let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n                                 if let hir::ImplItemKind::Type(ref ty) = impl_item.node {\n                                     self.visit_ty(ty);\n                                 }\n@@ -798,7 +798,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     let mut found_pub_static = false;\n                     for impl_item_ref in impl_item_refs {\n                         if self.item_is_public(&impl_item_ref.id.node_id, &impl_item_ref.vis) {\n-                            let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n+                            let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n                             match impl_item_ref.kind {\n                                 hir::AssociatedItemKind::Const => {\n                                     found_pub_static = true;\n@@ -962,8 +962,8 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n \n         if let Some(def_id) = ty_def_id {\n             // Non-local means public (private items can't leave their crate, modulo bugs)\n-            if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n-                let item = self.tcx.map.expect_item(node_id);\n+            if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                let item = self.tcx.hir.expect_item(node_id);\n                 let vis = ty::Visibility::from_hir(&item.vis, node_id, self.tcx);\n \n                 if !vis.is_at_least(self.min_visibility, self.tcx) {\n@@ -997,8 +997,8 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n \n     fn visit_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n         // Non-local means public (private items can't leave their crate, modulo bugs)\n-        if let Some(node_id) = self.tcx.map.as_local_node_id(trait_ref.def_id) {\n-            let item = self.tcx.map.expect_item(node_id);\n+        if let Some(node_id) = self.tcx.hir.as_local_node_id(trait_ref.def_id) {\n+            let item = self.tcx.hir.expect_item(node_id);\n             let vis = ty::Visibility::from_hir(&item.vis, node_id, self.tcx);\n \n             if !vis.is_at_least(self.min_visibility, self.tcx) {\n@@ -1045,7 +1045,7 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n                     has_old_errors = true;\n                     break;\n                 }\n-                let parent = self.tcx.map.get_parent_node(id);\n+                let parent = self.tcx.hir.get_parent_node(id);\n                 if parent == id {\n                     break;\n                 }\n@@ -1059,8 +1059,8 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n \n         SearchInterfaceForPrivateItemsVisitor {\n             tcx: self.tcx,\n-            item_def_id: self.tcx.map.local_def_id(item_id),\n-            span: self.tcx.map.span(item_id),\n+            item_def_id: self.tcx.hir.local_def_id(item_id),\n+            span: self.tcx.hir.span(item_id),\n             min_visibility: ty::Visibility::Public,\n             required_visibility: required_visibility,\n             has_old_errors: has_old_errors,\n@@ -1070,7 +1070,7 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -1148,7 +1148,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 self.check(item.id, ty_vis).generics().predicates();\n \n                 for impl_item_ref in impl_item_refs {\n-                    let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n+                    let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n                     let impl_item_vis =\n                         ty::Visibility::from_hir(&impl_item.vis, item.id, tcx);\n                     self.check(impl_item.id, min(impl_item_vis, ty_vis))\n@@ -1166,7 +1166,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                               .item_type().impl_trait_ref().min_visibility;\n                 self.check(item.id, vis).generics().predicates();\n                 for impl_item_ref in impl_item_refs {\n-                    let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n+                    let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n                     self.check(impl_item.id, vis).generics().predicates().item_type();\n \n                     // Recurse for e.g. `impl Trait` (see `visit_ty`).\n@@ -1205,7 +1205,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              -> AccessLevels {\n     let _task = tcx.dep_graph.in_task(DepNode::Privacy);\n \n-    let krate = tcx.map.krate();\n+    let krate = tcx.hir.krate();\n \n     // Use the parent map to check the privacy of everything\n     let mut visitor = PrivacyVisitor {"}, {"sha": "74521fe465bcd45360924e94547972cb80725239", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -112,7 +112,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         where F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, D>)\n     {\n         let old_tables = self.save_ctxt.tables;\n-        let item_def_id = self.tcx.map.local_def_id(item_id);\n+        let item_def_id = self.tcx.hir.local_def_id(item_id);\n         self.save_ctxt.tables = self.tcx.item_tables(item_def_id);\n         f(self);\n         self.save_ctxt.tables = old_tables;\n@@ -399,7 +399,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             // with the right name.\n             if !self.span.filter_generated(Some(method_data.span), span) {\n                 let container =\n-                    self.tcx.associated_item(self.tcx.map.local_def_id(id)).container;\n+                    self.tcx.associated_item(self.tcx.hir.local_def_id(id)).container;\n                 let mut trait_id;\n                 let mut decl_id = None;\n                 match container {\n@@ -418,7 +418,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                                 }\n                             }\n                             None => {\n-                                if let Some(NodeItem(item)) = self.tcx.map.get_if_local(id) {\n+                                if let Some(NodeItem(item)) = self.tcx.hir.get_if_local(id) {\n                                     if let hir::ItemImpl(_, _, _, _, ref ty, _) = item.node {\n                                         trait_id = self.lookup_def_id(ty.id);\n                                     }\n@@ -693,7 +693,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                             type_value: enum_data.qualname.clone(),\n                             value: val,\n                             scope: enum_data.scope,\n-                            parent: Some(make_def_id(item.id, &self.tcx.map)),\n+                            parent: Some(make_def_id(item.id, &self.tcx.hir)),\n                             docs: docs_for_attrs(&variant.node.attrs),\n                             sig: sig,\n                         }.lower(self.tcx));\n@@ -719,7 +719,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                             type_value: enum_data.qualname.clone(),\n                             value: val,\n                             scope: enum_data.scope,\n-                            parent: Some(make_def_id(item.id, &self.tcx.map)),\n+                            parent: Some(make_def_id(item.id, &self.tcx.hir)),\n                             docs: docs_for_attrs(&variant.node.attrs),\n                             sig: sig,\n                         }.lower(self.tcx));\n@@ -775,7 +775,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         }\n         self.process_generic_params(type_parameters, item.span, \"\", item.id);\n         for impl_item in impl_items {\n-            let map = &self.tcx.map;\n+            let map = &self.tcx.hir;\n             self.process_impl_item(impl_item, make_def_id(item.id, map));\n         }\n     }\n@@ -848,7 +848,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         // walk generics and methods\n         self.process_generic_params(generics, item.span, &qualname, item.id);\n         for method in methods {\n-            let map = &self.tcx.map;\n+            let map = &self.tcx.hir;\n             self.process_trait_item(method, make_def_id(item.id, map))\n         }\n     }\n@@ -1383,7 +1383,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                 visit::walk_expr(self, ex);\n             }\n             ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n-                let hir_expr = self.save_ctxt.tcx.map.expect_expr(ex.id);\n+                let hir_expr = self.save_ctxt.tcx.hir.expect_expr(ex.id);\n                 let adt = match self.save_ctxt.tables.expr_ty_opt(&hir_expr) {\n                     Some(ty) => ty.ty_adt_def().unwrap(),\n                     None => {\n@@ -1408,7 +1408,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n             ast::ExprKind::TupField(ref sub_ex, idx) => {\n                 self.visit_expr(&sub_ex);\n \n-                let hir_node = match self.save_ctxt.tcx.map.find(sub_ex.id) {\n+                let hir_node = match self.save_ctxt.tcx.hir.find(sub_ex.id) {\n                     Some(Node::NodeExpr(expr)) => expr,\n                     _ => {\n                         debug!(\"Missing or weird node for sub-expression {} in {:?}\",\n@@ -1510,7 +1510,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n         for &(id, ref p, immut, ref_kind) in &collector.collected_paths {\n             match self.save_ctxt.get_path_def(id) {\n                 Def::Local(def_id) => {\n-                    let id = self.tcx.map.as_local_node_id(def_id).unwrap();\n+                    let id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                     let mut value = if immut == ast::Mutability::Immutable {\n                         self.span.snippet(p.span).to_string()\n                     } else {"}, {"sha": "fccb56e88b3de801a55eb08a7e77f6f175b072e2", "filename": "src/librustc_save_analysis/external_data.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fexternal_data.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -105,13 +105,13 @@ impl Lower for data::EnumData {\n \n     fn lower(self, tcx: TyCtxt) -> EnumData {\n         EnumData {\n-            id: make_def_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.hir),\n             name: self.name,\n             value: self.value,\n             qualname: self.qualname,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.map),\n-            variants: self.variants.into_iter().map(|id| make_def_id(id, &tcx.map)).collect(),\n+            scope: make_def_id(self.scope, &tcx.hir),\n+            variants: self.variants.into_iter().map(|id| make_def_id(id, &tcx.hir)).collect(),\n             visibility: self.visibility,\n             docs: self.docs,\n             sig: self.sig.lower(tcx),\n@@ -135,12 +135,12 @@ impl Lower for data::ExternCrateData {\n \n     fn lower(self, tcx: TyCtxt) -> ExternCrateData {\n         ExternCrateData {\n-            id: make_def_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.hir),\n             name: self.name,\n             crate_num: self.crate_num,\n             location: self.location,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.hir),\n         }\n     }\n }\n@@ -159,7 +159,7 @@ impl Lower for data::FunctionCallData {\n     fn lower(self, tcx: TyCtxt) -> FunctionCallData {\n         FunctionCallData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.hir),\n             ref_id: self.ref_id,\n         }\n     }\n@@ -186,12 +186,12 @@ impl Lower for data::FunctionData {\n \n     fn lower(self, tcx: TyCtxt) -> FunctionData {\n         FunctionData {\n-            id: make_def_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.hir),\n             name: self.name,\n             qualname: self.qualname,\n             declaration: self.declaration,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.hir),\n             value: self.value,\n             visibility: self.visibility,\n             parent: self.parent,\n@@ -215,7 +215,7 @@ impl Lower for data::FunctionRefData {\n     fn lower(self, tcx: TyCtxt) -> FunctionRefData {\n         FunctionRefData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.hir),\n             ref_id: self.ref_id,\n         }\n     }\n@@ -234,9 +234,9 @@ impl Lower for data::ImplData {\n \n     fn lower(self, tcx: TyCtxt) -> ImplData {\n         ImplData {\n-            id: make_def_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.hir),\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.hir),\n             trait_ref: self.trait_ref,\n             self_ref: self.self_ref,\n         }\n@@ -257,7 +257,7 @@ impl Lower for data::InheritanceData {\n         InheritanceData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             base_id: self.base_id,\n-            deriv_id: make_def_id(self.deriv_id, &tcx.map)\n+            deriv_id: make_def_id(self.deriv_id, &tcx.hir)\n         }\n     }\n }\n@@ -305,7 +305,7 @@ impl Lower for data::MacroUseData {\n             name: self.name,\n             qualname: self.qualname,\n             callee_span: SpanData::from_span(self.callee_span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.hir),\n         }\n     }\n }\n@@ -325,7 +325,7 @@ impl Lower for data::MethodCallData {\n     fn lower(self, tcx: TyCtxt) -> MethodCallData {\n         MethodCallData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.hir),\n             ref_id: self.ref_id,\n             decl_id: self.decl_id,\n         }\n@@ -355,8 +355,8 @@ impl Lower for data::MethodData {\n         MethodData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n-            scope: make_def_id(self.scope, &tcx.map),\n-            id: make_def_id(self.id, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.hir),\n+            id: make_def_id(self.id, &tcx.hir),\n             qualname: self.qualname,\n             value: self.value,\n             decl_id: self.decl_id,\n@@ -388,13 +388,13 @@ impl Lower for data::ModData {\n \n     fn lower(self, tcx: TyCtxt) -> ModData {\n         ModData {\n-            id: make_def_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.hir),\n             name: self.name,\n             qualname: self.qualname,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.hir),\n             filename: self.filename,\n-            items: self.items.into_iter().map(|id| make_def_id(id, &tcx.map)).collect(),\n+            items: self.items.into_iter().map(|id| make_def_id(id, &tcx.hir)).collect(),\n             visibility: self.visibility,\n             docs: self.docs,\n             sig: self.sig.lower(tcx),\n@@ -417,7 +417,7 @@ impl Lower for data::ModRefData {\n     fn lower(self, tcx: TyCtxt) -> ModRefData {\n         ModRefData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.hir),\n             ref_id: self.ref_id,\n             qualname: self.qualname,\n         }\n@@ -446,12 +446,12 @@ impl Lower for data::StructData {\n         StructData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n-            id: make_def_id(self.id, &tcx.map),\n-            ctor_id: make_def_id(self.ctor_id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.hir),\n+            ctor_id: make_def_id(self.ctor_id, &tcx.hir),\n             qualname: self.qualname,\n-            scope: make_def_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.hir),\n             value: self.value,\n-            fields: self.fields.into_iter().map(|id| make_def_id(id, &tcx.map)).collect(),\n+            fields: self.fields.into_iter().map(|id| make_def_id(id, &tcx.hir)).collect(),\n             visibility: self.visibility,\n             docs: self.docs,\n             sig: self.sig.lower(tcx),\n@@ -480,11 +480,11 @@ impl Lower for data::StructVariantData {\n         StructVariantData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n-            id: make_def_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.hir),\n             qualname: self.qualname,\n             type_value: self.type_value,\n             value: self.value,\n-            scope: make_def_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.hir),\n             parent: self.parent,\n             docs: self.docs,\n             sig: self.sig.lower(tcx),\n@@ -513,11 +513,11 @@ impl Lower for data::TraitData {\n         TraitData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n-            id: make_def_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.hir),\n             qualname: self.qualname,\n-            scope: make_def_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.hir),\n             value: self.value,\n-            items: self.items.into_iter().map(|id| make_def_id(id, &tcx.map)).collect(),\n+            items: self.items.into_iter().map(|id| make_def_id(id, &tcx.hir)).collect(),\n             visibility: self.visibility,\n             docs: self.docs,\n             sig: self.sig.lower(tcx),\n@@ -545,12 +545,12 @@ impl Lower for data::TupleVariantData {\n     fn lower(self, tcx: TyCtxt) -> TupleVariantData {\n         TupleVariantData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            id: make_def_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.hir),\n             name: self.name,\n             qualname: self.qualname,\n             type_value: self.type_value,\n             value: self.value,\n-            scope: make_def_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.hir),\n             parent: self.parent,\n             docs: self.docs,\n             sig: self.sig.lower(tcx),\n@@ -577,7 +577,7 @@ impl Lower for data::TypeDefData {\n \n     fn lower(self, tcx: TyCtxt) -> TypeDefData {\n         TypeDefData {\n-            id: make_def_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.hir),\n             name: self.name,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             qualname: self.qualname,\n@@ -605,7 +605,7 @@ impl Lower for data::TypeRefData {\n     fn lower(self, tcx: TyCtxt) -> TypeRefData {\n         TypeRefData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.hir),\n             ref_id: self.ref_id,\n             qualname: self.qualname,\n         }\n@@ -627,11 +627,11 @@ impl Lower for data::UseData {\n \n     fn lower(self, tcx: TyCtxt) -> UseData {\n         UseData {\n-            id: make_def_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.hir),\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n             mod_id: self.mod_id,\n-            scope: make_def_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.hir),\n             visibility: self.visibility,\n         }\n     }\n@@ -651,10 +651,10 @@ impl Lower for data::UseGlobData {\n \n     fn lower(self, tcx: TyCtxt) -> UseGlobData {\n         UseGlobData {\n-            id: make_def_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.hir),\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             names: self.names,\n-            scope: make_def_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.hir),\n             visibility: self.visibility,\n         }\n     }\n@@ -682,12 +682,12 @@ impl Lower for data::VariableData {\n \n     fn lower(self, tcx: TyCtxt) -> VariableData {\n         VariableData {\n-            id: make_def_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.hir),\n             kind: self.kind,\n             name: self.name,\n             qualname: self.qualname,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.hir),\n             value: self.value,\n             type_value: self.type_value,\n             parent: self.parent,\n@@ -715,7 +715,7 @@ impl Lower for data::VariableRefData {\n         VariableRefData {\n             name: self.name,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: make_def_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.hir),\n             ref_id: self.ref_id,\n         }\n     }"}, {"sha": "8d0cdd1678c730a39c19175cc9dc3f943aef4fc9", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -285,7 +285,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             let qualname = format!(\"::{}::{}\", self.tcx.node_path_str(scope), ident);\n             let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n             filter!(self.span_utils, sub_span, field.span, None);\n-            let def_id = self.tcx.map.local_def_id(field.id);\n+            let def_id = self.tcx.hir.local_def_id(field.id);\n             let typ = self.tcx.item_type(def_id).to_string();\n \n             let span = field.span;\n@@ -307,7 +307,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 qualname: qualname,\n                 span: sub_span.unwrap(),\n                 scope: scope,\n-                parent: Some(make_def_id(scope, &self.tcx.map)),\n+                parent: Some(make_def_id(scope, &self.tcx.hir)),\n                 value: \"\".to_owned(),\n                 type_value: typ,\n                 visibility: From::from(&field.vis),\n@@ -326,13 +326,13 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n         let (qualname, parent_scope, decl_id, vis, docs) =\n-          match self.tcx.impl_of_method(self.tcx.map.local_def_id(id)) {\n-            Some(impl_id) => match self.tcx.map.get_if_local(impl_id) {\n+          match self.tcx.impl_of_method(self.tcx.hir.local_def_id(id)) {\n+            Some(impl_id) => match self.tcx.hir.get_if_local(impl_id) {\n                 Some(Node::NodeItem(item)) => {\n                     match item.node {\n                         hir::ItemImpl(.., ref ty, _) => {\n                             let mut result = String::from(\"<\");\n-                            result.push_str(&self.tcx.map.node_to_pretty_string(ty.id));\n+                            result.push_str(&self.tcx.hir.node_to_pretty_string(ty.id));\n \n                             let trait_id = self.tcx.trait_id_of_impl(impl_id);\n                             let mut decl_id = None;\n@@ -365,9 +365,9 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                               r);\n                 }\n             },\n-            None => match self.tcx.trait_of_item(self.tcx.map.local_def_id(id)) {\n+            None => match self.tcx.trait_of_item(self.tcx.hir.local_def_id(id)) {\n                 Some(def_id) => {\n-                    match self.tcx.map.get_if_local(def_id) {\n+                    match self.tcx.hir.get_if_local(def_id) {\n                         Some(Node::NodeItem(item)) => {\n                             (format!(\"::{}\", self.tcx.item_path_str(def_id)),\n                              Some(def_id), None,\n@@ -442,14 +442,14 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n-        let hir_node = self.tcx.map.expect_expr(expr.id);\n+        let hir_node = self.tcx.hir.expect_expr(expr.id);\n         let ty = self.tables.expr_ty_adjusted_opt(&hir_node);\n         if ty.is_none() || ty.unwrap().sty == ty::TyError {\n             return None;\n         }\n         match expr.node {\n             ast::ExprKind::Field(ref sub_ex, ident) => {\n-                let hir_node = match self.tcx.map.find(sub_ex.id) {\n+                let hir_node = match self.tcx.hir.find(sub_ex.id) {\n                     Some(Node::NodeExpr(expr)) => expr,\n                     _ => {\n                         debug!(\"Missing or weird node for sub-expression {} in {:?}\",\n@@ -523,7 +523,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_path_def(&self, id: NodeId) -> Def {\n-        match self.tcx.map.get(id) {\n+        match self.tcx.hir.get(id) {\n             Node::NodeTraitRef(tr) => tr.path.def,\n \n             Node::NodeItem(&hir::Item { node: hir::ItemUse(ref path, _), .. }) |\n@@ -733,7 +733,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     #[inline]\n     pub fn enclosing_scope(&self, id: NodeId) -> NodeId {\n-        self.tcx.map.get_enclosing_scope(id).unwrap_or(CRATE_NODE_ID)\n+        self.tcx.hir.get_enclosing_scope(id).unwrap_or(CRATE_NODE_ID)\n     }\n }\n "}, {"sha": "7a41f8341099b5cf79703b0999ecf68e0e209540", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -50,7 +50,7 @@ pub fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let ams = AssertModuleSource { tcx: tcx, modules: modules };\n-    for attr in &tcx.map.krate().attrs {\n+    for attr in &tcx.hir.krate().attrs {\n         ams.check_attr(attr);\n     }\n }"}, {"sha": "81be2d02f125b0797bbaa7ff009fe69a21703b49", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -48,7 +48,7 @@ impl ExportedSymbols {\n             .exported_symbols()\n             .iter()\n             .map(|&node_id| {\n-                scx.tcx().map.local_def_id(node_id)\n+                scx.tcx().hir.local_def_id(node_id)\n             })\n             .map(|def_id| {\n                 let name = symbol_for_def_id(scx, def_id, symbol_map);\n@@ -64,7 +64,7 @@ impl ExportedSymbols {\n \n         if let Some(id) = scx.sess().derive_registrar_fn.get() {\n             let svh = &scx.link_meta().crate_hash;\n-            let def_id = scx.tcx().map.local_def_id(id);\n+            let def_id = scx.tcx().hir.local_def_id(id);\n             let idx = def_id.index;\n             let registrar = scx.sess().generate_derive_registrar_symbol(svh, idx);\n             local_crate.push((registrar, SymbolExportLevel::C));\n@@ -181,7 +181,7 @@ fn symbol_for_def_id<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                -> String {\n     // Just try to look things up in the symbol map. If nothing's there, we\n     // recompute.\n-    if let Some(node_id) = scx.tcx().map.as_local_node_id(def_id) {\n+    if let Some(node_id) = scx.tcx().hir.as_local_node_id(def_id) {\n         if let Some(sym) = symbol_map.get(TransItem::Static(node_id)) {\n             return sym.to_owned();\n         }"}, {"sha": "20338e4f6afb03293fcee550cf150f516bd55982", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -175,7 +175,7 @@ impl<'a, 'tcx> Instance<'tcx> {\n         debug!(\"symbol_name(def_id={:?}, substs={:?})\",\n                def_id, substs);\n \n-        let node_id = scx.tcx().map.as_local_node_id(def_id);\n+        let node_id = scx.tcx().hir.as_local_node_id(def_id);\n \n         if let Some(id) = node_id {\n             if scx.sess().plugin_registrar_fn.get() == Some(id) {\n@@ -193,7 +193,7 @@ impl<'a, 'tcx> Instance<'tcx> {\n         // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n         let attrs = scx.tcx().get_attrs(def_id);\n         let is_foreign = if let Some(id) = node_id {\n-            match scx.tcx().map.get(id) {\n+            match scx.tcx().hir.get(id) {\n                 hir_map::NodeForeignItem(_) => true,\n                 _ => false\n             }"}, {"sha": "32fe3effcc9f8af57c2713eae5a25d2138373514", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -710,7 +710,7 @@ pub fn set_link_section(ccx: &CrateContext,\n pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n     let (main_def_id, span) = match *ccx.sess().entry_fn.borrow() {\n         Some((id, span)) => {\n-            (ccx.tcx().map.local_def_id(id), span)\n+            (ccx.tcx().hir.local_def_id(id), span)\n         }\n         None => return,\n     };\n@@ -1075,9 +1075,9 @@ pub fn find_exported_symbols(tcx: TyCtxt, reachable: NodeSet) -> NodeSet {\n         //\n         // As a result, if this id is an FFI item (foreign item) then we only\n         // let it through if it's included statically.\n-        match tcx.map.get(id) {\n+        match tcx.hir.get(id) {\n             hir_map::NodeForeignItem(..) => {\n-                let def_id = tcx.map.local_def_id(id);\n+                let def_id = tcx.hir.local_def_id(id);\n                 tcx.sess.cstore.is_statically_included_foreign_item(def_id)\n             }\n \n@@ -1088,7 +1088,7 @@ pub fn find_exported_symbols(tcx: TyCtxt, reachable: NodeSet) -> NodeSet {\n                 node: hir::ItemFn(..), .. }) |\n             hir_map::NodeImplItem(&hir::ImplItem {\n                 node: hir::ImplItemKind::Method(..), .. }) => {\n-                let def_id = tcx.map.local_def_id(id);\n+                let def_id = tcx.hir.local_def_id(id);\n                 let generics = tcx.item_generics(def_id);\n                 let attributes = tcx.get_attrs(def_id);\n                 (generics.parent_types == 0 && generics.types.is_empty()) &&\n@@ -1112,7 +1112,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // entire contents of the krate. So if you push any subtasks of\n     // `TransCrate`, you need to be careful to register \"reads\" of the\n     // particular items that will be processed.\n-    let krate = tcx.map.krate();\n+    let krate = tcx.hir.krate();\n \n     let ty::CrateAnalysis { export_map, reachable, name, .. } = analysis;\n     let exported_symbols = find_exported_symbols(tcx, reachable);"}, {"sha": "d30766dc5392a3015a2785c5d2043889bf7973c1", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -309,7 +309,7 @@ fn collect_roots<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             output: &mut roots,\n         };\n \n-        scx.tcx().map.krate().visit_all_item_likes(&mut visitor);\n+        scx.tcx().hir.krate().visit_all_item_likes(&mut visitor);\n     }\n \n     roots\n@@ -336,7 +336,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n             recursion_depth_reset = None;\n         }\n         TransItem::Static(node_id) => {\n-            let def_id = scx.tcx().map.local_def_id(node_id);\n+            let def_id = scx.tcx().hir.local_def_id(node_id);\n \n             // Sanity check whether this ended up being collected accidentally\n             debug_assert!(should_trans_locally(scx.tcx(), def_id));\n@@ -406,8 +406,8 @@ fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if recursion_depth > tcx.sess.recursion_limit.get() {\n         let error = format!(\"reached the recursion limit while instantiating `{}`\",\n                             instance);\n-        if let Some(node_id) = tcx.map.as_local_node_id(instance.def) {\n-            tcx.sess.span_fatal(tcx.map.span(node_id), &error);\n+        if let Some(node_id) = tcx.hir.as_local_node_id(instance.def) {\n+            tcx.sess.span_fatal(tcx.hir.span(node_id), &error);\n         } else {\n             tcx.sess.fatal(&error);\n         }\n@@ -438,8 +438,8 @@ fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let instance_name = instance.to_string();\n         let msg = format!(\"reached the type-length limit while instantiating `{:.64}...`\",\n                           instance_name);\n-        let mut diag = if let Some(node_id) = tcx.map.as_local_node_id(instance.def) {\n-            tcx.sess.struct_span_fatal(tcx.map.span(node_id), &msg)\n+        let mut diag = if let Some(node_id) = tcx.hir.as_local_node_id(instance.def) {\n+            tcx.sess.struct_span_fatal(tcx.hir.span(node_id), &msg)\n         } else {\n             tcx.sess.struct_fatal(&msg)\n         };\n@@ -619,7 +619,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     // Some constructors also have type TyFnDef but they are\n                     // always instantiated inline and don't result in a\n                     // translation item. Same for FFI functions.\n-                    if let Some(hir_map::NodeForeignItem(_)) = tcx.map.get_if_local(def_id) {\n+                    if let Some(hir_map::NodeForeignItem(_)) = tcx.hir.get_if_local(def_id) {\n                         return false;\n                     }\n \n@@ -1152,7 +1152,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemUnion(_, ref generics) => {\n                 if !generics.is_parameterized() {\n                     if self.mode == TransItemCollectionMode::Eager {\n-                        let def_id = self.scx.tcx().map.local_def_id(item.id);\n+                        let def_id = self.scx.tcx().hir.local_def_id(item.id);\n                         debug!(\"RootCollector: ADT drop-glue for {}\",\n                                def_id_to_string(self.scx.tcx(), def_id));\n \n@@ -1165,7 +1165,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemStatic(..) => {\n                 debug!(\"RootCollector: ItemStatic({})\",\n                        def_id_to_string(self.scx.tcx(),\n-                                        self.scx.tcx().map.local_def_id(item.id)));\n+                                        self.scx.tcx().hir.local_def_id(item.id)));\n                 self.output.push(TransItem::Static(item.id));\n             }\n             hir::ItemConst(..) => {\n@@ -1174,7 +1174,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n             }\n             hir::ItemFn(.., ref generics, _) => {\n                 if !generics.is_type_parameterized() {\n-                    let def_id = self.scx.tcx().map.local_def_id(item.id);\n+                    let def_id = self.scx.tcx().hir.local_def_id(item.id);\n \n                     debug!(\"RootCollector: ItemFn({})\",\n                            def_id_to_string(self.scx.tcx(), def_id));\n@@ -1197,7 +1197,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                 ref generics,\n                 ..\n             }, _) => {\n-                let hir_map = &self.scx.tcx().map;\n+                let hir_map = &self.scx.tcx().hir;\n                 let parent_node_id = hir_map.get_parent_node(ii.id);\n                 let is_impl_generic = match hir_map.expect_item(parent_node_id) {\n                     &hir::Item {\n@@ -1212,7 +1212,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                 };\n \n                 if !generics.is_type_parameterized() && !is_impl_generic {\n-                    let def_id = self.scx.tcx().map.local_def_id(ii.id);\n+                    let def_id = self.scx.tcx().hir.local_def_id(ii.id);\n \n                     debug!(\"RootCollector: MethodImplItem({})\",\n                            def_id_to_string(self.scx.tcx(), def_id));\n@@ -1240,7 +1240,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                 return\n             }\n \n-            let impl_def_id = tcx.map.local_def_id(item.id);\n+            let impl_def_id = tcx.hir.local_def_id(item.id);\n \n             debug!(\"create_trans_items_for_default_impls(item={})\",\n                    def_id_to_string(tcx, impl_def_id));"}, {"sha": "b68de7b46c82e9b7a0ded83ce76ec76989107115", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -85,10 +85,10 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n     }\n \n     let ty = ccx.tcx().item_type(def_id);\n-    let g = if let Some(id) = ccx.tcx().map.as_local_node_id(def_id) {\n+    let g = if let Some(id) = ccx.tcx().hir.as_local_node_id(def_id) {\n \n         let llty = type_of::type_of(ccx, ty);\n-        let (g, attrs) = match ccx.tcx().map.get(id) {\n+        let (g, attrs) = match ccx.tcx().hir.get(id) {\n             hir_map::NodeItem(&hir::Item {\n                 ref attrs, span, node: hir::ItemStatic(..), ..\n             }) => {\n@@ -219,7 +219,7 @@ pub fn trans_static(ccx: &CrateContext,\n                     attrs: &[ast::Attribute])\n                     -> Result<ValueRef, ConstEvalErr> {\n     unsafe {\n-        let def_id = ccx.tcx().map.local_def_id(id);\n+        let def_id = ccx.tcx().hir.local_def_id(id);\n         let g = get_static(ccx, def_id);\n \n         let v = ::mir::trans_static_initializer(ccx, def_id)?;"}, {"sha": "4567ec8b452df58a258cd932092af89b9699c52a", "filename": "src/librustc_trans/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -79,7 +79,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n \n pub fn needs_gdb_debug_scripts_section(ccx: &CrateContext) -> bool {\n     let omit_gdb_pretty_printer_section =\n-        attr::contains_name(&ccx.tcx().map.krate_attrs(),\n+        attr::contains_name(&ccx.tcx().hir.krate_attrs(),\n                             \"omit_gdb_pretty_printer_section\");\n \n     !omit_gdb_pretty_printer_section &&"}, {"sha": "0de3c13dc21a9864943d4bd352230ae889cbc5d7", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -1738,7 +1738,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n \n     let tcx = cx.tcx();\n \n-    let node_def_id = tcx.map.local_def_id(node_id);\n+    let node_def_id = tcx.hir.local_def_id(node_id);\n     let (var_scope, span) = get_namespace_and_span_for_item(cx, node_def_id);\n \n     let (file_metadata, line_number) = if span != syntax_pos::DUMMY_SP {"}, {"sha": "f05d48566daaea4396044d34f130140db2ec3148", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -251,7 +251,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let scope_line = span_start(cx, span).line;\n \n-    let local_id = cx.tcx().map.as_local_node_id(instance.def);\n+    let local_id = cx.tcx().hir.as_local_node_id(instance.def);\n     let is_local_to_unit = local_id.map_or(false, |id| is_node_local_to_unit(cx, id));\n \n     let function_name = CString::new(name).unwrap();"}, {"sha": "bf7a02eb0f196c7fdc6306f6a8a2c35fd3014afd", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -76,7 +76,7 @@ fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n     // compiler-rt, then we want to implicitly compile everything with hidden\n     // visibility as we're going to link this object all over the place but\n     // don't want the symbols to get exported.\n-    if attr::contains_name(ccx.tcx().map.krate_attrs(), \"compiler_builtins\") {\n+    if attr::contains_name(ccx.tcx().hir.krate_attrs(), \"compiler_builtins\") {\n         unsafe {\n             llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n         }"}, {"sha": "706f131ed627fc1df6a491b18ca7e9d462dac6fa", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -186,7 +186,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n             symbol_name.hash(&mut state);\n             let exported = match item {\n                TransItem::Fn(ref instance) => {\n-                    let node_id = scx.tcx().map.as_local_node_id(instance.def);\n+                    let node_id = scx.tcx().hir.as_local_node_id(instance.def);\n                     node_id.map(|node_id| exported_symbols.contains(&node_id))\n                            .unwrap_or(false)\n                }\n@@ -241,7 +241,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n         fn local_node_id(tcx: TyCtxt, trans_item: TransItem) -> Option<NodeId> {\n             match trans_item {\n                 TransItem::Fn(instance) => {\n-                    tcx.map.as_local_node_id(instance.def)\n+                    tcx.hir.as_local_node_id(instance.def)\n                 }\n                 TransItem::Static(node_id) => Some(node_id),\n                 TransItem::DropGlue(_) => None,\n@@ -482,7 +482,7 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n             Some(instance.def)\n         }\n         TransItem::DropGlue(dg) => characteristic_def_id_of_type(dg.ty()),\n-        TransItem::Static(node_id) => Some(tcx.map.local_def_id(node_id)),\n+        TransItem::Static(node_id) => Some(tcx.hir.local_def_id(node_id)),\n     }\n }\n "}, {"sha": "880c65937e3087f826a8bd079c4d57a0e7ef1a22", "filename": "src/librustc_trans/symbol_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fsymbol_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fsymbol_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_map.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -97,12 +97,12 @@ impl<'tcx> SymbolMap<'tcx> {\n                               trans_item: TransItem<'tcx>) -> Option<Span> {\n             match trans_item {\n                 TransItem::Fn(Instance { def, .. }) => {\n-                    tcx.map.as_local_node_id(def)\n+                    tcx.hir.as_local_node_id(def)\n                 }\n                 TransItem::Static(node_id) => Some(node_id),\n                 TransItem::DropGlue(_) => None,\n             }.map(|node_id| {\n-                tcx.map.span(node_id)\n+                tcx.hir.span(node_id)\n             })\n         }\n "}, {"sha": "02e1290b5778331d0e5734100811561d78196448", "filename": "src/librustc_trans/symbol_names_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_names_test.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -36,7 +36,7 @@ pub fn report_symbol_names(scx: &SharedCrateContext) {\n     let _ignore = tcx.dep_graph.in_ignore();\n     let mut visitor = SymbolNamesTest { scx: scx };\n     // FIXME(#37712) could use ItemLikeVisitor if trait items were item-like\n-    tcx.map.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n+    tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n }\n \n struct SymbolNamesTest<'a, 'tcx:'a> {\n@@ -47,7 +47,7 @@ impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n     fn process_attrs(&mut self,\n                      node_id: ast::NodeId) {\n         let tcx = self.scx.tcx();\n-        let def_id = tcx.map.local_def_id(node_id);\n+        let def_id = tcx.hir.local_def_id(node_id);\n         for attr in tcx.get_attrs(def_id).iter() {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names"}, {"sha": "43ea1e56a5a4d19e2112a0d98ccc7bde27bc3eb7", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -77,9 +77,9 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n         match *self {\n             TransItem::Static(node_id) => {\n-                let def_id = ccx.tcx().map.local_def_id(node_id);\n+                let def_id = ccx.tcx().hir.local_def_id(node_id);\n                 let _task = ccx.tcx().dep_graph.in_task(DepNode::TransCrateItem(def_id)); // (*)\n-                let item = ccx.tcx().map.expect_item(node_id);\n+                let item = ccx.tcx().hir.expect_item(node_id);\n                 if let hir::ItemStatic(_, m, _) = item.node {\n                     match consts::trans_static(&ccx, m, item.id, &item.attrs) {\n                         Ok(_) => { /* Cool, everything's alright. */ },\n@@ -145,12 +145,12 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                         node_id: ast::NodeId,\n                         linkage: llvm::Linkage,\n                         symbol_name: &str) {\n-        let def_id = ccx.tcx().map.local_def_id(node_id);\n+        let def_id = ccx.tcx().hir.local_def_id(node_id);\n         let ty = ccx.tcx().item_type(def_id);\n         let llty = type_of::type_of(ccx, ty);\n \n         let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n-            ccx.sess().span_fatal(ccx.tcx().map.span(node_id),\n+            ccx.sess().span_fatal(ccx.tcx().hir.span(node_id),\n                 &format!(\"symbol `{}` is already defined\", symbol_name))\n         });\n \n@@ -222,7 +222,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         match *self {\n             TransItem::Fn(instance) => instance.symbol_name(scx),\n             TransItem::Static(node_id) => {\n-                let def_id = scx.tcx().map.local_def_id(node_id);\n+                let def_id = scx.tcx().hir.local_def_id(node_id);\n                 Instance::mono(scx, def_id).symbol_name(scx)\n             }\n             TransItem::DropGlue(dg) => {\n@@ -274,7 +274,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n     pub fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n         let def_id = match *self {\n             TransItem::Fn(ref instance) => instance.def,\n-            TransItem::Static(node_id) => tcx.map.local_def_id(node_id),\n+            TransItem::Static(node_id) => tcx.hir.local_def_id(node_id),\n             TransItem::DropGlue(..) => return None,\n         };\n \n@@ -283,7 +283,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             if let Some(linkage) = base::llvm_linkage_by_name(&name.as_str()) {\n                 Some(linkage)\n             } else {\n-                let span = tcx.map.span_if_local(def_id);\n+                let span = tcx.hir.span_if_local(def_id);\n                 if let Some(span) = span {\n                     tcx.sess.span_fatal(span, \"invalid linkage specified\")\n                 } else {\n@@ -296,7 +296,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n     }\n \n     pub fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n-        let hir_map = &tcx.map;\n+        let hir_map = &tcx.hir;\n \n         return match *self {\n             TransItem::DropGlue(dg) => {"}, {"sha": "1af8b59cdfa7d7ab6dc3db7b722d395fe89320d9", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -186,7 +186,7 @@ pub fn ast_region_to_region<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                  .get(&id)\n                                  .cloned()\n                                  .unwrap_or(ty::Issue32330::WontChange);\n-            ty::ReLateBound(debruijn, ty::BrNamed(tcx.map.local_def_id(id),\n+            ty::ReLateBound(debruijn, ty::BrNamed(tcx.hir.local_def_id(id),\n                                                   lifetime.name,\n                                                   issue_32330))\n         }\n@@ -208,7 +208,7 @@ pub fn ast_region_to_region<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                  .unwrap_or(ty::Issue32330::WontChange);\n             ty::ReFree(ty::FreeRegion {\n                     scope: scope.to_code_extent(&tcx.region_maps),\n-                    bound_region: ty::BrNamed(tcx.map.local_def_id(id),\n+                    bound_region: ty::BrNamed(tcx.hir.local_def_id(id),\n                                               lifetime.name,\n                                               issue_32330)\n             })\n@@ -245,8 +245,8 @@ fn report_elision_failure(\n         } = info;\n \n         let help_name = if let Some(body) = parent {\n-            let arg = &tcx.map.body(body).arguments[index];\n-            format!(\"`{}`\", tcx.map.node_to_pretty_string(arg.pat.id))\n+            let arg = &tcx.hir.body(body).arguments[index];\n+            format!(\"`{}`\", tcx.hir.node_to_pretty_string(arg.pat.id))\n         } else {\n             format!(\"argument {}\", index + 1)\n         };\n@@ -684,7 +684,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             _ => {\n                 span_fatal!(self.tcx().sess, path.span, E0245, \"`{}` is not a trait\",\n-                            self.tcx().map.node_to_pretty_string(trait_ref.ref_id));\n+                            self.tcx().hir.node_to_pretty_string(trait_ref.ref_id));\n             }\n         }\n     }\n@@ -1152,7 +1152,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 let bound_span = self.tcx().associated_items(bound.def_id()).find(|item| {\n                     item.kind == ty::AssociatedKind::Type && item.name == assoc_name\n                 })\n-                .and_then(|item| self.tcx().map.span_if_local(item.def_id));\n+                .and_then(|item| self.tcx().hir.span_if_local(item.def_id));\n \n                 if let Some(span) = bound_span {\n                     err.span_label(span, &format!(\"ambiguous `{}` from `{}`\",\n@@ -1223,7 +1223,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 }\n             }\n             (&ty::TyParam(_), Def::SelfTy(Some(trait_did), None)) => {\n-                let trait_node_id = tcx.map.as_local_node_id(trait_did).unwrap();\n+                let trait_node_id = tcx.hir.as_local_node_id(trait_did).unwrap();\n                 match self.find_bound_for_assoc_item(trait_node_id,\n                                                      keywords::SelfType.name(),\n                                                      assoc_name,\n@@ -1233,7 +1233,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 }\n             }\n             (&ty::TyParam(_), Def::TyParam(param_did)) => {\n-                let param_node_id = tcx.map.as_local_node_id(param_did).unwrap();\n+                let param_node_id = tcx.hir.as_local_node_id(param_did).unwrap();\n                 let param_name = tcx.type_parameter_def(param_node_id).name;\n                 match self.find_bound_for_assoc_item(param_node_id,\n                                                      param_name,\n@@ -1379,7 +1379,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 assert_eq!(opt_self_ty, None);\n                 tcx.prohibit_type_params(&path.segments);\n \n-                let node_id = tcx.map.as_local_node_id(did).unwrap();\n+                let node_id = tcx.hir.as_local_node_id(did).unwrap();\n                 let param = tcx.ty_param_defs.borrow().get(&node_id)\n                                .map(ty::ParamTy::for_def);\n                 if let Some(p) = param {\n@@ -1544,10 +1544,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 use collect::{compute_bounds, SizedByDefault};\n \n                 // Create the anonymized type.\n-                let def_id = tcx.map.local_def_id(ast_ty.id);\n+                let def_id = tcx.hir.local_def_id(ast_ty.id);\n                 if let Some(anon_scope) = rscope.anon_type_scope() {\n                     let substs = anon_scope.fresh_substs(self, ast_ty.span);\n-                    let ty = tcx.mk_anon(tcx.map.local_def_id(ast_ty.id), substs);\n+                    let ty = tcx.mk_anon(tcx.hir.local_def_id(ast_ty.id), substs);\n \n                     // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n                     let bounds = compute_bounds(self, ty, bounds,"}, {"sha": "932e7ae1dd4266ffa480e092fbae9cf3e44033e7", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // if there are multiple arms, make sure they all agree on\n                 // what the type of the binding `x` ought to be\n-                let var_id = tcx.map.as_local_node_id(def_id).unwrap();\n+                let var_id = tcx.hir.as_local_node_id(def_id).unwrap();\n                 if var_id != pat.id {\n                     let vt = self.local_ty(pat.span, var_id);\n                     self.demand_eqtype(pat.span, vt, typ);\n@@ -561,7 +561,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             span_err!(tcx.sess, pat.span, E0533,\n                       \"expected unit struct/variant or constant, found {} `{}`\",\n                       def.kind_name(),\n-                      hir::print::to_string(&tcx.map, |s| s.print_qpath(qpath, false)));\n+                      hir::print::to_string(&tcx.hir, |s| s.print_qpath(qpath, false)));\n         };\n \n         // Resolve the path and check the definition for errors.\n@@ -603,7 +603,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let report_unexpected_def = |def: Def| {\n             let msg = format!(\"expected tuple struct/variant, found {} `{}`\",\n                               def.kind_name(),\n-                              hir::print::to_string(&tcx.map, |s| s.print_qpath(qpath, false)));\n+                              hir::print::to_string(&tcx.hir, |s| s.print_qpath(qpath, false)));\n             struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg)\n                 .span_label(pat.span, &format!(\"not a tuple variant or struct\")).emit();\n             on_error();"}, {"sha": "3a980c8e7642bae14c380ddad7e1f0f1bf1bb540", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -194,15 +194,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let (fn_sig, def_span) = match callee_ty.sty {\n             ty::TyFnDef(def_id, .., &ty::BareFnTy {ref sig, ..}) => {\n-                (sig, self.tcx.map.span_if_local(def_id))\n+                (sig, self.tcx.hir.span_if_local(def_id))\n             }\n             ty::TyFnPtr(&ty::BareFnTy {ref sig, ..}) => (sig, None),\n             ref t => {\n                 let mut unit_variant = None;\n                 if let &ty::TyAdt(adt_def, ..) = t {\n                     if adt_def.is_enum() {\n                         if let hir::ExprCall(ref expr, _) = call_expr.node {\n-                            unit_variant = Some(self.tcx.map.node_to_pretty_string(expr.id))\n+                            unit_variant = Some(self.tcx.hir.node_to_pretty_string(expr.id))\n                         }\n                     }\n                 }\n@@ -225,7 +225,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         Def::Err\n                     };\n                     if def != Def::Err {\n-                        if let Some(span) = self.tcx.map.span_if_local(def.def_id()) {\n+                        if let Some(span) = self.tcx.hir.span_if_local(def.def_id()) {\n                             err.span_note(span, \"defined here\");\n                         }\n                     }"}, {"sha": "2e6592b55017961034aff71eb3398c012209e428", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Some(ty) => self.deduce_expectations_from_expected_type(ty),\n             None => (None, None),\n         };\n-        let body = self.tcx.map.body(body_id);\n+        let body = self.tcx.hir.body(body_id);\n         self.check_closure(expr, expected_kind, decl, body, expected_sig)\n     }\n \n@@ -54,7 +54,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                opt_kind,\n                expected_sig);\n \n-        let expr_def_id = self.tcx.map.local_def_id(expr.id);\n+        let expr_def_id = self.tcx.hir.local_def_id(expr.id);\n         let mut fn_ty = AstConv::ty_of_closure(self,\n                                                hir::Unsafety::Normal,\n                                                decl,"}, {"sha": "d110c16cf331396e133e95315cc154a8722564a8", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -170,7 +170,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     // Create a parameter environment that represents the implementation's\n     // method.\n-    let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n+    let impl_m_node_id = tcx.hir.as_local_node_id(impl_m.def_id).unwrap();\n     let impl_param_env = ty::ParameterEnvironment::for_item(tcx, impl_m_node_id);\n \n     // Create mapping from impl to skolemized.\n@@ -437,8 +437,8 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                                                      trait_sig: ty::FnSig<'tcx>)\n                                                      -> (Span, Option<Span>) {\n     let tcx = infcx.tcx;\n-    let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n-    let (impl_m_output, impl_m_iter) = match tcx.map.expect_impl_item(impl_m_node_id).node {\n+    let impl_m_node_id = tcx.hir.as_local_node_id(impl_m.def_id).unwrap();\n+    let (impl_m_output, impl_m_iter) = match tcx.hir.expect_impl_item(impl_m_node_id).node {\n         ImplItemKind::Method(ref impl_m_sig, _) => {\n             (&impl_m_sig.decl.output, impl_m_sig.decl.inputs.iter())\n         }\n@@ -447,8 +447,8 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n \n     match *terr {\n         TypeError::Mutability => {\n-            if let Some(trait_m_node_id) = tcx.map.as_local_node_id(trait_m.def_id) {\n-                let trait_m_iter = match tcx.map.expect_trait_item(trait_m_node_id).node {\n+            if let Some(trait_m_node_id) = tcx.hir.as_local_node_id(trait_m.def_id) {\n+                let trait_m_iter = match tcx.hir.expect_trait_item(trait_m_node_id).node {\n                     TraitItemKind::Method(ref trait_m_sig, _) => {\n                         trait_m_sig.decl.inputs.iter()\n                     }\n@@ -466,15 +466,15 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                 }).map(|(ref impl_arg, ref trait_arg)| {\n                     (impl_arg.span, Some(trait_arg.span))\n                 })\n-                .unwrap_or_else(|| (cause.span, tcx.map.span_if_local(trait_m.def_id)))\n+                .unwrap_or_else(|| (cause.span, tcx.hir.span_if_local(trait_m.def_id)))\n             } else {\n-                (cause.span, tcx.map.span_if_local(trait_m.def_id))\n+                (cause.span, tcx.hir.span_if_local(trait_m.def_id))\n             }\n         }\n         TypeError::Sorts(ExpectedFound { .. }) => {\n-            if let Some(trait_m_node_id) = tcx.map.as_local_node_id(trait_m.def_id) {\n+            if let Some(trait_m_node_id) = tcx.hir.as_local_node_id(trait_m.def_id) {\n                 let (trait_m_output, trait_m_iter) =\n-                    match tcx.map.expect_trait_item(trait_m_node_id).node {\n+                    match tcx.hir.expect_trait_item(trait_m_node_id).node {\n                         TraitItemKind::Method(ref trait_m_sig, _) => {\n                             (&trait_m_sig.decl.output, trait_m_sig.decl.inputs.iter())\n                         }\n@@ -499,14 +499,14 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                                      .is_err() {\n                                          (impl_m_output.span(), Some(trait_m_output.span()))\n                                      } else {\n-                                         (cause.span, tcx.map.span_if_local(trait_m.def_id))\n+                                         (cause.span, tcx.hir.span_if_local(trait_m.def_id))\n                                      }\n                          })\n             } else {\n-                (cause.span, tcx.map.span_if_local(trait_m.def_id))\n+                (cause.span, tcx.hir.span_if_local(trait_m.def_id))\n             }\n         }\n-        _ => (cause.span, tcx.map.span_if_local(trait_m.def_id)),\n+        _ => (cause.span, tcx.hir.span_if_local(trait_m.def_id)),\n     }\n }\n \n@@ -554,7 +554,7 @@ fn compare_self_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                            trait_m.name,\n                                            self_descr);\n             err.span_label(impl_m_span, &format!(\"`{}` used in impl\", self_descr));\n-            if let Some(span) = tcx.map.span_if_local(trait_m.def_id) {\n+            if let Some(span) = tcx.hir.span_if_local(trait_m.def_id) {\n                 err.span_label(span, &format!(\"trait declared without `{}`\", self_descr));\n             }\n             err.emit();\n@@ -572,7 +572,7 @@ fn compare_self_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                            self_descr);\n             err.span_label(impl_m_span,\n                            &format!(\"expected `{}` in impl\", self_descr));\n-            if let Some(span) = tcx.map.span_if_local(trait_m.def_id) {\n+            if let Some(span) = tcx.hir.span_if_local(trait_m.def_id) {\n                 err.span_label(span, &format!(\"`{}` used in trait\", self_descr));\n             }\n             err.emit();\n@@ -595,8 +595,8 @@ fn compare_number_of_generics<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let num_impl_m_type_params = impl_m_generics.types.len();\n     let num_trait_m_type_params = trait_m_generics.types.len();\n     if num_impl_m_type_params != num_trait_m_type_params {\n-        let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n-        let span = match tcx.map.expect_impl_item(impl_m_node_id).node {\n+        let impl_m_node_id = tcx.hir.as_local_node_id(impl_m.def_id).unwrap();\n+        let span = match tcx.hir.expect_impl_item(impl_m_node_id).node {\n             ImplItemKind::Method(ref impl_m_sig, _) => {\n                 if impl_m_sig.generics.is_parameterized() {\n                     impl_m_sig.generics.span\n@@ -671,9 +671,9 @@ fn compare_number_of_method_arguments<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let trait_number_args = trait_m_fty.sig.inputs().skip_binder().len();\n     let impl_number_args = impl_m_fty.sig.inputs().skip_binder().len();\n     if trait_number_args != impl_number_args {\n-        let trait_m_node_id = tcx.map.as_local_node_id(trait_m.def_id);\n+        let trait_m_node_id = tcx.hir.as_local_node_id(trait_m.def_id);\n         let trait_span = if let Some(trait_id) = trait_m_node_id {\n-            match tcx.map.expect_trait_item(trait_id).node {\n+            match tcx.hir.expect_trait_item(trait_id).node {\n                 TraitItemKind::Method(ref trait_m_sig, _) => {\n                     if let Some(arg) = trait_m_sig.decl.inputs.get(if trait_number_args > 0 {\n                         trait_number_args - 1\n@@ -690,8 +690,8 @@ fn compare_number_of_method_arguments<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         } else {\n             trait_item_span\n         };\n-        let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n-        let impl_span = match tcx.map.expect_impl_item(impl_m_node_id).node {\n+        let impl_m_node_id = tcx.hir.as_local_node_id(impl_m.def_id).unwrap();\n+        let impl_span = match tcx.hir.expect_impl_item(impl_m_node_id).node {\n             ImplItemKind::Method(ref impl_m_sig, _) => {\n                 if let Some(arg) = impl_m_sig.decl.inputs.get(if impl_number_args > 0 {\n                     impl_number_args - 1\n@@ -759,7 +759,7 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         // Create a parameter environment that represents the implementation's\n         // method.\n-        let impl_c_node_id = tcx.map.as_local_node_id(impl_c.def_id).unwrap();\n+        let impl_c_node_id = tcx.hir.as_local_node_id(impl_c.def_id).unwrap();\n         let impl_param_env = ty::ParameterEnvironment::for_item(tcx, impl_c_node_id);\n \n         // Create mapping from impl to skolemized.\n@@ -810,7 +810,7 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                    trait_ty);\n \n             // Locate the Span containing just the type of the offending impl\n-            match tcx.map.expect_impl_item(impl_c_node_id).node {\n+            match tcx.hir.expect_impl_item(impl_c_node_id).node {\n                 ImplItemKind::Const(ref ty, _) => cause.span = ty.span,\n                 _ => bug!(\"{:?} is not a impl const\", impl_c),\n             }\n@@ -823,8 +823,8 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             trait_c.name);\n \n             // Add a label to the Span containing just the type of the item\n-            let trait_c_node_id = tcx.map.as_local_node_id(trait_c.def_id).unwrap();\n-            let trait_c_span = match tcx.map.expect_trait_item(trait_c_node_id).node {\n+            let trait_c_node_id = tcx.hir.as_local_node_id(trait_c.def_id).unwrap();\n+            let trait_c_span = match tcx.hir.expect_trait_item(trait_c_node_id).node {\n                 TraitItemKind::Const(ref ty, _) => ty.span,\n                 _ => bug!(\"{:?} is not a trait const\", trait_c),\n             };"}, {"sha": "91b772a748c72c28a6dc4ab11ff6a5da08769946", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -75,8 +75,8 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     -> Result<(), ()>\n {\n     let tcx = ccx.tcx;\n-    let drop_impl_node_id = tcx.map.as_local_node_id(drop_impl_did).unwrap();\n-    let self_type_node_id = tcx.map.as_local_node_id(self_type_did).unwrap();\n+    let drop_impl_node_id = tcx.hir.as_local_node_id(drop_impl_did).unwrap();\n+    let self_type_node_id = tcx.hir.as_local_node_id(self_type_did).unwrap();\n \n     // check that the impl type can be made to match the trait type.\n \n@@ -100,7 +100,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n                 assert!(obligations.is_empty());\n             }\n             Err(_) => {\n-                let item_span = tcx.map.span(self_type_node_id);\n+                let item_span = tcx.hir.span(self_type_node_id);\n                 struct_span_err!(tcx.sess, drop_impl_span, E0366,\n                                  \"Implementations of Drop cannot be specialized\")\n                     .span_note(item_span,\n@@ -171,7 +171,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n \n     let tcx = ccx.tcx;\n \n-    let self_type_node_id = tcx.map.as_local_node_id(self_type_did).unwrap();\n+    let self_type_node_id = tcx.hir.as_local_node_id(self_type_did).unwrap();\n \n     let drop_impl_span = tcx.def_span(drop_impl_did);\n \n@@ -203,7 +203,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n         // repeated `contains` calls.\n \n         if !assumptions_in_impl_context.contains(&predicate) {\n-            let item_span = tcx.map.span(self_type_node_id);\n+            let item_span = tcx.hir.span(self_type_node_id);\n             struct_span_err!(tcx.sess, drop_impl_span, E0367,\n                              \"The requirement `{}` is added only by the Drop impl.\", predicate)\n                 .span_note(item_span,"}, {"sha": "7ead7ada893d7bccdb2e284a13d19c300ee21c83", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -34,7 +34,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    inputs: Vec<Ty<'tcx>>,\n                                    output: Ty<'tcx>) {\n     let tcx = ccx.tcx;\n-    let def_id = tcx.map.local_def_id(it.id);\n+    let def_id = tcx.hir.local_def_id(it.id);\n \n     let substs = Substs::for_item(tcx, def_id,\n                                   |_, _| tcx.mk_region(ty::ReErased),\n@@ -324,7 +324,7 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n     };\n \n     let tcx = ccx.tcx;\n-    let def_id = tcx.map.local_def_id(it.id);\n+    let def_id = tcx.hir.local_def_id(it.id);\n     let i_n_tps = tcx.item_generics(def_id).types.len();\n     let name = it.name.as_str();\n "}, {"sha": "e2d7d31a8a890b0ca3586caa7809cef9821326e0", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -803,7 +803,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         for step in steps.iter() {\n             let closure_id = match step.self_ty.sty {\n                 ty::TyClosure(def_id, _) => {\n-                    if let Some(id) = self.tcx.map.as_local_node_id(def_id) {\n+                    if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n                         id\n                     } else {\n                         continue;"}, {"sha": "f6345e6e262db618192ee00d2719f77c48e5f42a", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -99,8 +99,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     item_name\n                                 )\n                             }).unwrap();\n-                        let note_span = self.tcx.map.span_if_local(item.def_id).or_else(|| {\n-                            self.tcx.map.span_if_local(impl_did)\n+                        let note_span = self.tcx.hir.span_if_local(item.def_id).or_else(|| {\n+                            self.tcx.hir.span_if_local(impl_did)\n                         });\n \n                         let impl_ty = self.impl_self_ty(span, impl_did).ty;\n@@ -285,7 +285,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let msg = if let Some(callee) = rcvr_expr {\n                     format!(\"{}; use overloaded call notation instead (e.g., `{}()`)\",\n                             msg,\n-                            self.tcx.map.node_to_pretty_string(callee.id))\n+                            self.tcx.hir.node_to_pretty_string(callee.id))\n                 } else {\n                     msg\n                 };\n@@ -488,8 +488,8 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n             fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n             }\n         }\n-        ccx.tcx.map.krate().visit_all_item_likes(&mut Visitor {\n-            map: &ccx.tcx.map,\n+        ccx.tcx.hir.krate().visit_all_item_likes(&mut Visitor {\n+            map: &ccx.tcx.hir,\n             traits: &mut traits,\n         });\n "}, {"sha": "7b87ec5dd5d2fb6907e7bbea77bd9924024ebdd9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -538,7 +538,7 @@ struct CheckItemBodiesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n \n impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.ccx.tcx.map)\n+        NestedVisitorMap::OnlyBodies(&self.ccx.tcx.hir)\n     }\n \n     fn visit_item(&mut self, i: &'tcx hir::Item) {\n@@ -634,7 +634,7 @@ pub fn check_item_bodies(ccx: &CrateCtxt) -> CompileResult {\n         // bodies have been fully inferred.\n         for (&item_id, obligations) in ccx.deferred_obligations.borrow().iter() {\n             // Use the same DepNode as for the body of the original function/item.\n-            let def_id = ccx.tcx.map.local_def_id(item_id);\n+            let def_id = ccx.tcx.hir.local_def_id(item_id);\n             let _task = ccx.tcx.dep_graph.in_task(DepNode::TypeckTables(def_id));\n \n             let param_env = ParameterEnvironment::for_item(ccx.tcx, item_id);\n@@ -677,9 +677,9 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            body_id: hir::BodyId,\n                            fn_id: ast::NodeId,\n                            span: Span) {\n-    let body = ccx.tcx.map.body(body_id);\n+    let body = ccx.tcx.hir.body(body_id);\n \n-    let raw_fty = ccx.tcx.item_type(ccx.tcx.map.local_def_id(fn_id));\n+    let raw_fty = ccx.tcx.item_type(ccx.tcx.hir.local_def_id(fn_id));\n     let fn_ty = match raw_fty.sty {\n         ty::TyFnDef(.., f) => f,\n         _ => span_bug!(body.value.span, \"check_bare_fn: function type expected\")\n@@ -835,7 +835,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n }\n \n fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n-    let def_id = ccx.tcx.map.local_def_id(id);\n+    let def_id = ccx.tcx.hir.local_def_id(id);\n     check_representable(ccx.tcx, span, def_id);\n \n     if ccx.tcx.lookup_simd(def_id) {\n@@ -844,13 +844,13 @@ fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n }\n \n fn check_union(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n-    check_representable(ccx.tcx, span, ccx.tcx.map.local_def_id(id));\n+    check_representable(ccx.tcx, span, ccx.tcx.hir.local_def_id(id));\n }\n \n pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n     debug!(\"check_item_type(it.id={}, it.name={})\",\n            it.id,\n-           ccx.tcx.item_path_str(ccx.tcx.map.local_def_id(it.id)));\n+           ccx.tcx.item_path_str(ccx.tcx.hir.local_def_id(it.id)));\n     let _indenter = indenter();\n     match it.node {\n       // Consts can play a role in type-checking, so they are included here.\n@@ -865,7 +865,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n       hir::ItemFn(..) => {} // entirely within check_item_body\n       hir::ItemImpl(.., ref impl_item_refs) => {\n           debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n-          let impl_def_id = ccx.tcx.map.local_def_id(it.id);\n+          let impl_def_id = ccx.tcx.hir.local_def_id(it.id);\n           if let Some(impl_trait_ref) = ccx.tcx.impl_trait_ref(impl_def_id) {\n               check_impl_items_against_trait(ccx,\n                                              it.span,\n@@ -877,7 +877,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n           }\n       }\n       hir::ItemTrait(..) => {\n-        let def_id = ccx.tcx.map.local_def_id(it.id);\n+        let def_id = ccx.tcx.hir.local_def_id(it.id);\n         check_on_unimplemented(ccx, def_id, it);\n       }\n       hir::ItemStruct(..) => {\n@@ -887,7 +887,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n         check_union(ccx, it.id, it.span);\n       }\n       hir::ItemTy(_, ref generics) => {\n-        let def_id = ccx.tcx.map.local_def_id(it.id);\n+        let def_id = ccx.tcx.hir.local_def_id(it.id);\n         let pty_ty = ccx.tcx.item_type(def_id);\n         check_bounds_are_used(ccx, generics, pty_ty);\n       }\n@@ -904,7 +904,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n             }\n         } else {\n             for item in &m.items {\n-                let generics = ccx.tcx.item_generics(ccx.tcx.map.local_def_id(item.id));\n+                let generics = ccx.tcx.item_generics(ccx.tcx.hir.local_def_id(item.id));\n                 if !generics.types.is_empty() {\n                     let mut err = struct_span_err!(ccx.tcx.sess, item.span, E0044,\n                         \"foreign items may not have type parameters\");\n@@ -1038,12 +1038,12 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let trait_def = tcx.lookup_trait_def(impl_trait_ref.def_id);\n     let mut overridden_associated_type = None;\n \n-    let impl_items = || impl_item_refs.iter().map(|iiref| ccx.tcx.map.impl_item(iiref.id));\n+    let impl_items = || impl_item_refs.iter().map(|iiref| ccx.tcx.hir.impl_item(iiref.id));\n \n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n     for impl_item in impl_items() {\n-        let ty_impl_item = tcx.associated_item(tcx.map.local_def_id(impl_item.id));\n+        let ty_impl_item = tcx.associated_item(tcx.hir.local_def_id(impl_item.id));\n         let ty_trait_item = tcx.associated_items(impl_trait_ref.def_id)\n             .find(|ac| ac.name == ty_impl_item.name);\n \n@@ -1067,14 +1067,14 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                          err.span_label(impl_item.span, &format!(\"does not match trait\"));\n                          // We can only get the spans from local trait definition\n                          // Same for E0324 and E0325\n-                         if let Some(trait_span) = tcx.map.span_if_local(ty_trait_item.def_id) {\n+                         if let Some(trait_span) = tcx.hir.span_if_local(ty_trait_item.def_id) {\n                             err.span_label(trait_span, &format!(\"item in trait\"));\n                          }\n                          err.emit()\n                     }\n                 }\n                 hir::ImplItemKind::Method(_, body_id) => {\n-                    let trait_span = tcx.map.span_if_local(ty_trait_item.def_id);\n+                    let trait_span = tcx.hir.span_if_local(ty_trait_item.def_id);\n                     if ty_trait_item.kind == ty::AssociatedKind::Method {\n                         let err_count = tcx.sess.err_count();\n                         compare_impl_method(ccx,\n@@ -1103,7 +1103,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   ty_impl_item.name,\n                                   impl_trait_ref);\n                          err.span_label(impl_item.span, &format!(\"does not match trait\"));\n-                         if let Some(trait_span) = tcx.map.span_if_local(ty_trait_item.def_id) {\n+                         if let Some(trait_span) = tcx.hir.span_if_local(ty_trait_item.def_id) {\n                             err.span_label(trait_span, &format!(\"item in trait\"));\n                          }\n                          err.emit()\n@@ -1121,7 +1121,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   ty_impl_item.name,\n                                   impl_trait_ref);\n                          err.span_label(impl_item.span, &format!(\"does not match trait\"));\n-                         if let Some(trait_span) = tcx.map.span_if_local(ty_trait_item.def_id) {\n+                         if let Some(trait_span) = tcx.hir.span_if_local(ty_trait_item.def_id) {\n                             err.span_label(trait_span, &format!(\"item in trait\"));\n                          }\n                          err.emit()\n@@ -1176,7 +1176,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     .map(|trait_item| trait_item.name.to_string())\n                     .collect::<Vec<_>>().join(\"`, `\")));\n         for trait_item in missing_items {\n-            if let Some(span) = tcx.map.span_if_local(trait_item.def_id) {\n+            if let Some(span) = tcx.hir.span_if_local(trait_item.def_id) {\n                 err.span_label(span, &format!(\"`{}` from trait\", trait_item.name));\n             } else {\n                 err.note(&format!(\"`{}` from trait: `{}`\",\n@@ -1204,7 +1204,7 @@ fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n                                    body: hir::BodyId,\n                                    expected_type: Ty<'tcx>,\n                                    id: ast::NodeId) {\n-    let body = ccx.tcx.map.body(body);\n+    let body = ccx.tcx.hir.body(body);\n     ccx.inherited(id).enter(|inh| {\n         let fcx = FnCtxt::new(&inh, None, body.value.id);\n         fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n@@ -1231,7 +1231,7 @@ fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n fn check_const<'a, 'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                          body: hir::BodyId,\n                          id: ast::NodeId) {\n-    let decl_ty = ccx.tcx.item_type(ccx.tcx.map.local_def_id(id));\n+    let decl_ty = ccx.tcx.item_type(ccx.tcx.hir.local_def_id(id));\n     check_const_with_type(ccx, body, decl_ty, id);\n }\n \n@@ -1294,7 +1294,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                     sp: Span,\n                                     vs: &'tcx [hir::Variant],\n                                     id: ast::NodeId) {\n-    let def_id = ccx.tcx.map.local_def_id(id);\n+    let def_id = ccx.tcx.hir.local_def_id(id);\n     let hint = *ccx.tcx.lookup_repr_hints(def_id).get(0).unwrap_or(&attr::ReprAny);\n \n     if hint != attr::ReprAny && vs.is_empty() {\n@@ -1319,7 +1319,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         }\n     }\n \n-    let def_id = ccx.tcx.map.local_def_id(id);\n+    let def_id = ccx.tcx.hir.local_def_id(id);\n \n     let variants = &ccx.tcx.lookup_adt_def(def_id).variants;\n     let mut disr_vals: Vec<ty::Disr> = Vec::new();\n@@ -1328,14 +1328,14 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n \n         // Check for duplicate discriminant values\n         if let Some(i) = disr_vals.iter().position(|&x| x == current_disr_val) {\n-            let variant_i_node_id = ccx.tcx.map.as_local_node_id(variants[i].did).unwrap();\n-            let variant_i = ccx.tcx.map.expect_variant(variant_i_node_id);\n+            let variant_i_node_id = ccx.tcx.hir.as_local_node_id(variants[i].did).unwrap();\n+            let variant_i = ccx.tcx.hir.expect_variant(variant_i_node_id);\n             let i_span = match variant_i.node.disr_expr {\n-                Some(expr) => ccx.tcx.map.span(expr.node_id),\n-                None => ccx.tcx.map.span(variant_i_node_id)\n+                Some(expr) => ccx.tcx.hir.span(expr.node_id),\n+                None => ccx.tcx.hir.span(variant_i_node_id)\n             };\n             let span = match v.node.disr_expr {\n-                Some(expr) => ccx.tcx.map.span(expr.node_id),\n+                Some(expr) => ccx.tcx.hir.span(expr.node_id),\n                 None => v.span\n             };\n             struct_span_err!(ccx.tcx.sess, span, E0081,\n@@ -1610,7 +1610,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Some(&t) => t,\n             None => {\n                 span_bug!(span, \"no type for local variable {}\",\n-                          self.tcx.map.node_to_string(nid));\n+                          self.tcx.hir.node_to_string(nid));\n             }\n         }\n     }\n@@ -1841,7 +1841,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             None if self.err_count_since_creation() != 0 => self.tcx.types.err,\n             None => {\n                 bug!(\"no type for node {}: {} in fcx {}\",\n-                     id, self.tcx.map.node_to_string(id),\n+                     id, self.tcx.hir.node_to_string(id),\n                      self.tag());\n             }\n         }\n@@ -2159,7 +2159,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     TypeVariableOrigin::MiscVariable(syntax_pos::DUMMY_SP)),\n                                 origin_span: syntax_pos::DUMMY_SP,\n                                 // what do I put here?\n-                                def_id: self.tcx.map.local_def_id(ast::CRATE_NODE_ID)\n+                                def_id: self.tcx.hir.local_def_id(ast::CRATE_NODE_ID)\n                             });\n \n                     // This is to ensure that we elimnate any non-determinism from the error\n@@ -2435,7 +2435,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     );\n                     self.check_argument_types(sp, &fty.sig.0.inputs()[1..], &expected_arg_tys[..],\n                                               args_no_rcvr, fty.sig.0.variadic, tuple_arguments,\n-                                              self.tcx.map.span_if_local(def_id));\n+                                              self.tcx.hir.span_if_local(def_id));\n                     fty.sig.0.output()\n                 }\n                 _ => {\n@@ -3021,7 +3021,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 ty::TyRawPtr(..) => {\n                     err.note(&format!(\"`{0}` is a native pointer; perhaps you need to deref with \\\n                                       `(*{0}).{1}`\",\n-                                      self.tcx.map.node_to_pretty_string(base.id),\n+                                      self.tcx.hir.node_to_pretty_string(base.id),\n                                       field.node));\n                 }\n                 _ => {}\n@@ -3436,12 +3436,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.diverges.set(self.diverges.get() | old_diverges);\n         self.has_errors.set(self.has_errors.get() | old_has_errors);\n \n-        debug!(\"type of {} is...\", self.tcx.map.node_to_string(expr.id));\n+        debug!(\"type of {} is...\", self.tcx.hir.node_to_string(expr.id));\n         debug!(\"... {:?}, expected is {:?}\", ty, expected);\n \n         // Add adjustments to !-expressions\n         if ty.is_never() {\n-            if let Some(hir::map::NodeExpr(node_expr)) = self.tcx.map.find(expr.id) {\n+            if let Some(hir::map::NodeExpr(node_expr)) = self.tcx.hir.find(expr.id) {\n                 let adj_ty = self.next_diverging_ty_var(\n                     TypeVariableOrigin::AdjustmentType(node_expr.span));\n                 self.write_adjustment(expr.id, adjustment::Adjustment {\n@@ -4370,7 +4370,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         match def {\n             Def::Local(def_id) | Def::Upvar(def_id, ..) => {\n-                let nid = self.tcx.map.as_local_node_id(def_id).unwrap();\n+                let nid = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                 let ty = self.local_ty(span, nid);\n                 let ty = self.normalize_associated_types_in(span, &ty);\n                 self.write_ty(node_id, ty);"}, {"sha": "9a5d402ef0adfb3a6c8ab28c6f6be35be1be7650", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -148,7 +148,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n-            rcx.visit_fn_body(fn_id, body, self.tcx.map.span(fn_id));\n+            rcx.visit_fn_body(fn_id, body, self.tcx.hir.span(fn_id));\n         }\n \n         rcx.free_region_map.relate_free_regions_from_predicates(\n@@ -482,7 +482,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn visit_fn(&mut self, _fk: intravisit::FnKind<'gcx>, _: &'gcx hir::FnDecl,\n                 b: hir::BodyId, span: Span, id: ast::NodeId) {\n-        let body = self.tcx.map.body(b);\n+        let body = self.tcx.hir.body(b);\n         self.visit_fn_body(id, body, span)\n     }\n "}, {"sha": "d511d57c3780dbc36647fead7a44747cd9b79238", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -85,7 +85,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for SeedBorrowKind<'a, 'gcx, 'tcx> {\n     fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n         match expr.node {\n             hir::ExprClosure(cc, _, body_id, _) => {\n-                let body = self.fcx.tcx.map.body(body_id);\n+                let body = self.fcx.tcx.hir.body(body_id);\n                 self.visit_body(body);\n                 self.check_closure(expr, cc);\n             }\n@@ -114,7 +114,7 @@ impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n         self.fcx.tcx.with_freevars(expr.id, |freevars| {\n             for freevar in freevars {\n                 let def_id = freevar.def.def_id();\n-                let var_node_id = self.fcx.tcx.map.as_local_node_id(def_id).unwrap();\n+                let var_node_id = self.fcx.tcx.hir.as_local_node_id(def_id).unwrap();\n                 let upvar_id = ty::UpvarId { var_id: var_node_id,\n                                              closure_expr_id: expr.id };\n                 debug!(\"seed upvar_id {:?}\", upvar_id);\n@@ -208,7 +208,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n \n         // If we are also inferred the closure kind here, update the\n         // main table and process any deferred resolutions.\n-        let closure_def_id = self.fcx.tcx.map.local_def_id(id);\n+        let closure_def_id = self.fcx.tcx.hir.local_def_id(id);\n         if let Some(&kind) = self.temp_closure_kinds.get(&id) {\n             self.fcx.tables.borrow_mut().closure_kinds.insert(id, kind);\n             debug!(\"closure_kind({:?}) = {:?}\", closure_def_id, kind);\n@@ -232,7 +232,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         tcx.with_freevars(closure_id, |freevars| {\n             freevars.iter().map(|freevar| {\n                 let def_id = freevar.def.def_id();\n-                let var_id = tcx.map.as_local_node_id(def_id).unwrap();\n+                let var_id = tcx.hir.as_local_node_id(def_id).unwrap();\n                 let freevar_ty = self.fcx.node_ty(var_id);\n                 let upvar_id = ty::UpvarId {\n                     var_id: var_id,\n@@ -500,7 +500,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     {\n         intravisit::walk_fn(self, fn_kind, decl, body, span, id);\n \n-        let body = self.fcx.tcx.map.body(body);\n+        let body = self.fcx.tcx.hir.body(body);\n         self.visit_body(body);\n         self.analyze_closure(id, span, body);\n     }"}, {"sha": "cef6a75e58dc9bdddfe8f1961a9450e2a7c7eff7", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -90,7 +90,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         let ccx = self.ccx;\n         debug!(\"check_item_well_formed(it.id={}, it.name={})\",\n                item.id,\n-               ccx.tcx.item_path_str(ccx.tcx.map.local_def_id(item.id)));\n+               ccx.tcx.item_path_str(ccx.tcx.hir.local_def_id(item.id)));\n \n         match item.node {\n             /// Right now we check that every default trait implementation\n@@ -117,7 +117,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             hir::ItemImpl(_, hir::ImplPolarity::Negative, _, Some(_), ..) => {\n                 // FIXME(#27579) what amount of WF checking do we need for neg impls?\n \n-                let trait_ref = ccx.tcx.impl_trait_ref(ccx.tcx.map.local_def_id(item.id)).unwrap();\n+                let trait_ref = ccx.tcx.impl_trait_ref(ccx.tcx.hir.local_def_id(item.id)).unwrap();\n                 if !ccx.tcx.trait_has_default_impl(trait_ref.def_id) {\n                     error_192(ccx, item.span);\n                 }\n@@ -168,7 +168,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             let free_substs = &fcx.parameter_environment.free_substs;\n             let free_id_outlive = fcx.parameter_environment.free_id_outlive;\n \n-            let item = fcx.tcx.associated_item(fcx.tcx.map.local_def_id(item_id));\n+            let item = fcx.tcx.associated_item(fcx.tcx.hir.local_def_id(item_id));\n \n             let (mut implied_bounds, self_ty) = match item.container {\n                 ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n@@ -251,7 +251,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             }\n \n             let free_substs = &fcx.parameter_environment.free_substs;\n-            let def_id = fcx.tcx.map.local_def_id(item.id);\n+            let def_id = fcx.tcx.hir.local_def_id(item.id);\n             let predicates = fcx.instantiate_bounds(item.span, def_id, free_substs);\n             this.check_where_clauses(fcx, item.span, &predicates);\n \n@@ -321,7 +321,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n     }\n \n     fn check_trait(&mut self, item: &hir::Item) {\n-        let trait_def_id = self.tcx().map.local_def_id(item.id);\n+        let trait_def_id = self.tcx().hir.local_def_id(item.id);\n \n         if self.tcx().trait_has_default_impl(trait_def_id) {\n             self.check_auto_trait(trait_def_id, item.span);\n@@ -341,7 +341,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n     {\n         self.for_item(item).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n-            let def_id = fcx.tcx.map.local_def_id(item.id);\n+            let def_id = fcx.tcx.hir.local_def_id(item.id);\n             let ty = fcx.tcx.item_type(def_id);\n             let item_ty = fcx.instantiate_type_scheme(item.span, free_substs, &ty);\n             let bare_fn_ty = match item_ty.sty {\n@@ -367,7 +367,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         debug!(\"check_item_type: {:?}\", item);\n \n         self.for_item(item).with_fcx(|fcx, this| {\n-            let ty = fcx.tcx.item_type(fcx.tcx.map.local_def_id(item.id));\n+            let ty = fcx.tcx.item_type(fcx.tcx.hir.local_def_id(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span,\n                                                       &fcx.parameter_environment\n                                                           .free_substs,\n@@ -388,7 +388,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n         self.for_item(item).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n-            let item_def_id = fcx.tcx.map.local_def_id(item.id);\n+            let item_def_id = fcx.tcx.hir.local_def_id(item.id);\n \n             match *ast_trait_ref {\n                 Some(ref ast_trait_ref) => {\n@@ -514,7 +514,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                                      item: &hir::Item,\n                                      ast_generics: &hir::Generics)\n     {\n-        let item_def_id = self.tcx().map.local_def_id(item.id);\n+        let item_def_id = self.tcx().hir.local_def_id(item.id);\n         let ty = self.tcx().item_type(item_def_id);\n         if self.tcx().has_error_field(ty) {\n             return;\n@@ -644,7 +644,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let fields =\n             struct_def.fields().iter()\n             .map(|field| {\n-                let field_ty = self.tcx.item_type(self.tcx.map.local_def_id(field.id));\n+                let field_ty = self.tcx.item_type(self.tcx.hir.local_def_id(field.id));\n                 let field_ty = self.instantiate_type_scheme(field.span,\n                                                             &self.parameter_environment\n                                                                  .free_substs,"}, {"sha": "b95126af56aa7c43c7b674129e4bd7fda956f8e1", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -36,8 +36,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn resolve_type_vars_in_body(&self, body: &'gcx hir::Body) {\n         assert_eq!(self.writeback_errors.get(), false);\n \n-        let item_id = self.tcx.map.body_owner(body.id());\n-        let item_def_id = self.tcx.map.local_def_id(item_id);\n+        let item_id = self.tcx.hir.body_owner(body.id());\n+        let item_def_id = self.tcx.hir.local_def_id(item_id);\n \n         let mut wbcx = WritebackCx::new(self);\n         for arg in &body.arguments {\n@@ -209,7 +209,7 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n                                     MethodCall::expr(e.id));\n \n         if let hir::ExprClosure(_, _, body, _) = e.node {\n-            let body = self.fcx.tcx.map.body(body);\n+            let body = self.fcx.tcx.hir.body(body);\n             for arg in &body.arguments {\n                 self.visit_node_id(ResolvingExpr(e.span), arg.id);\n             }\n@@ -281,12 +281,12 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n         for (&id, closure_ty) in self.fcx.tables.borrow().closure_tys.iter() {\n             let closure_ty = self.resolve(closure_ty, ResolvingClosure(id));\n-            let def_id = self.tcx().map.local_def_id(id);\n+            let def_id = self.tcx().hir.local_def_id(id);\n             self.tcx().closure_tys.borrow_mut().insert(def_id, closure_ty);\n         }\n \n         for (&id, &closure_kind) in self.fcx.tables.borrow().closure_kinds.iter() {\n-            let def_id = self.tcx().map.local_def_id(id);\n+            let def_id = self.tcx().hir.local_def_id(id);\n             self.tcx().closure_kinds.borrow_mut().insert(def_id, closure_kind);\n         }\n     }\n@@ -517,7 +517,7 @@ impl<'a, 'gcx, 'tcx> ResolveReason {\n             ResolvingFnSig(id) |\n             ResolvingFieldTypes(id) |\n             ResolvingTyNode(id) => {\n-                tcx.map.span(id)\n+                tcx.hir.span(id)\n             }\n             ResolvingAnonTy(did) => {\n                 tcx.def_span(did)"}, {"sha": "bdda538db160ec3765299ac174188f643693905d", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -60,5 +60,5 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for UnusedTraitImportVisitor<'a, 'tcx> {\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _task = tcx.dep_graph.in_task(DepNode::UnusedTraitCheck);\n     let mut visitor = UnusedTraitImportVisitor { tcx: tcx };\n-    tcx.map.krate().visit_all_item_likes(&mut visitor);\n+    tcx.hir.krate().visit_all_item_likes(&mut visitor);\n }"}, {"sha": "086484c643ad1c238c5b5fa26acf3cd6504651e2", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -69,8 +69,8 @@ fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n         _ => {\n             // Destructors only work on nominal types.\n-            if let Some(impl_node_id) = tcx.map.as_local_node_id(impl_did) {\n-                match tcx.map.find(impl_node_id) {\n+            if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_did) {\n+                match tcx.hir.find(impl_node_id) {\n                     Some(hir_map::NodeItem(item)) => {\n                         let span = match item.node {\n                             ItemImpl(.., ref ty, _) => ty.span,\n@@ -101,7 +101,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                           impl_did: DefId) {\n     debug!(\"visit_implementation_of_copy: impl_did={:?}\", impl_did);\n \n-    let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n+    let impl_node_id = if let Some(n) = tcx.hir.as_local_node_id(impl_did) {\n         n\n     } else {\n         debug!(\"visit_implementation_of_copy(): impl not in this \\\n@@ -113,7 +113,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"visit_implementation_of_copy: self_type={:?} (bound)\",\n            self_type);\n \n-    let span = tcx.map.span(impl_node_id);\n+    let span = tcx.hir.span(impl_node_id);\n     let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n     let self_type = self_type.subst(tcx, &param_env.free_substs);\n     assert!(!self_type.has_escaping_regions());\n@@ -124,7 +124,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match param_env.can_type_implement_copy(tcx, self_type, span) {\n         Ok(()) => {}\n         Err(CopyImplementationError::InfrigingField(field)) => {\n-            let item = tcx.map.expect_item(impl_node_id);\n+            let item = tcx.hir.expect_item(impl_node_id);\n             let span = if let ItemImpl(.., Some(ref tr), _, _) = item.node {\n                 tr.path.span\n             } else {\n@@ -141,7 +141,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 .emit()\n         }\n         Err(CopyImplementationError::NotAnAdt) => {\n-            let item = tcx.map.expect_item(impl_node_id);\n+            let item = tcx.hir.expect_item(impl_node_id);\n             let span = if let ItemImpl(.., ref ty, _) = item.node {\n                 ty.span\n             } else {\n@@ -180,7 +180,7 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     };\n \n-    let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n+    let impl_node_id = if let Some(n) = tcx.hir.as_local_node_id(impl_did) {\n         n\n     } else {\n         debug!(\"visit_implementation_of_coerce_unsized(): impl not \\\n@@ -195,7 +195,7 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            source,\n            target);\n \n-    let span = tcx.map.span(impl_node_id);\n+    let span = tcx.hir.span(impl_node_id);\n     let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n     let source = source.subst(tcx, &param_env.free_substs);\n     let target = target.subst(tcx, &param_env.free_substs);\n@@ -281,11 +281,11 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                being coerced, none found\");\n                     return;\n                 } else if diff_fields.len() > 1 {\n-                    let item = tcx.map.expect_item(impl_node_id);\n+                    let item = tcx.hir.expect_item(impl_node_id);\n                     let span = if let ItemImpl(.., Some(ref t), _, _) = item.node {\n                         t.path.span\n                     } else {\n-                        tcx.map.span(impl_node_id)\n+                        tcx.hir.span(impl_node_id)\n                     };\n \n                     let mut err = struct_span_err!(tcx.sess,"}, {"sha": "5af9ea29fafa76e49cffc8c400515c254585b8d0", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n     fn check_implementation(&self, item: &Item) {\n         let tcx = self.tcx;\n-        let impl_did = tcx.map.local_def_id(item.id);\n+        let impl_did = tcx.hir.local_def_id(item.id);\n         let self_type = tcx.item_type(impl_did);\n \n         // If there are no traits, then this implementation must have a"}, {"sha": "c3417ab08d7fad3642f99f65e63c8016a7253f97", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -76,13 +76,13 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n     /// to prevent inundating the user with a bunch of similar error\n     /// reports.\n     fn visit_item(&mut self, item: &hir::Item) {\n-        let def_id = self.tcx.map.local_def_id(item.id);\n+        let def_id = self.tcx.hir.local_def_id(item.id);\n         match item.node {\n             hir::ItemImpl(.., None, ref ty, _) => {\n                 // For inherent impls, self type must be a nominal type\n                 // defined in this crate.\n                 debug!(\"coherence2::orphan check: inherent impl {}\",\n-                       self.tcx.map.node_to_string(item.id));\n+                       self.tcx.hir.node_to_string(item.id));\n                 let self_ty = self.tcx.item_type(def_id);\n                 match self_ty.sty {\n                     ty::TyAdt(def, _) => {\n@@ -249,7 +249,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n             hir::ItemImpl(.., Some(_), _, _) => {\n                 // \"Trait\" impl\n                 debug!(\"coherence2::orphan check: trait impl {}\",\n-                       self.tcx.map.node_to_string(item.id));\n+                       self.tcx.hir.node_to_string(item.id));\n                 let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n                 match traits::orphan_check(self.tcx, def_id) {\n@@ -374,7 +374,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n             hir::ItemDefaultImpl(_, ref item_trait_ref) => {\n                 // \"Trait\" impl\n                 debug!(\"coherence2::orphan check: default trait impl {}\",\n-                       self.tcx.map.node_to_string(item.id));\n+                       self.tcx.hir.node_to_string(item.id));\n                 let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n                 if trait_ref.def_id.krate != LOCAL_CRATE {\n                     struct_span_err!(self.tcx.sess,\n@@ -384,7 +384,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                                       the crate they're defined in; define a new trait instead\")\n                         .span_label(item_trait_ref.path.span,\n                                     &format!(\"`{}` trait not defined in this crate\",\n-                            self.tcx.map.node_to_pretty_string(item_trait_ref.ref_id)))\n+                            self.tcx.hir.node_to_pretty_string(item_trait_ref.ref_id)))\n                         .emit();\n                     return;\n                 }"}, {"sha": "56c17dc2f6efda144dbb9e2be510ab19648c57db", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -66,7 +66,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n             for &item2 in &impl_items2[..] {\n                 if (name, namespace) == name_and_namespace(item2) {\n                     let msg = format!(\"duplicate definitions with name `{}`\", name);\n-                    let node_id = self.tcx.map.as_local_node_id(item1).unwrap();\n+                    let node_id = self.tcx.hir.as_local_node_id(item1).unwrap();\n                     self.tcx.sess.add_lint(lint::builtin::OVERLAPPING_INHERENT_IMPLS,\n                                            node_id,\n                                            self.tcx.span_of_impl(item1).unwrap(),\n@@ -104,15 +104,15 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OverlapChecker<'cx, 'tcx> {\n             hir::ItemStruct(..) |\n             hir::ItemTrait(..) |\n             hir::ItemUnion(..) => {\n-                let type_def_id = self.tcx.map.local_def_id(item.id);\n+                let type_def_id = self.tcx.hir.local_def_id(item.id);\n                 self.check_for_overlapping_inherent_impls(type_def_id);\n             }\n \n             hir::ItemDefaultImpl(..) => {\n                 // look for another default impl; note that due to the\n                 // general orphan/coherence rules, it must always be\n                 // in this crate.\n-                let impl_def_id = self.tcx.map.local_def_id(item.id);\n+                let impl_def_id = self.tcx.hir.local_def_id(item.id);\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n \n                 let prev_default_impl = self.default_impls.insert(trait_ref.def_id, item.id);\n@@ -124,14 +124,14 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OverlapChecker<'cx, 'tcx> {\n                                                     `{}`:\",\n                                                    trait_ref);\n                     err.span_note(self.tcx\n-                                      .span_of_impl(self.tcx.map.local_def_id(prev_id))\n+                                      .span_of_impl(self.tcx.hir.local_def_id(prev_id))\n                                       .unwrap(),\n                                   \"redundant implementation is here:\");\n                     err.emit();\n                 }\n             }\n             hir::ItemImpl(.., Some(_), _, _) => {\n-                let impl_def_id = self.tcx.map.local_def_id(item.id);\n+                let impl_def_id = self.tcx.hir.local_def_id(item.id);\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n "}, {"sha": "8c98e2952ebe9ce155696b2779fe49535486c3bb", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -17,7 +17,7 @@ use rustc::hir::{self, Unsafety};\n \n pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut unsafety = UnsafetyChecker { tcx: tcx };\n-    tcx.map.krate().visit_all_item_likes(&mut unsafety);\n+    tcx.hir.krate().visit_all_item_likes(&mut unsafety);\n }\n \n struct UnsafetyChecker<'cx, 'tcx: 'cx> {\n@@ -30,7 +30,7 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n                                 impl_generics: Option<&hir::Generics>,\n                                 unsafety: hir::Unsafety,\n                                 polarity: hir::ImplPolarity) {\n-        match self.tcx.impl_trait_ref(self.tcx.map.local_def_id(item.id)) {\n+        match self.tcx.impl_trait_ref(self.tcx.hir.local_def_id(item.id)) {\n             None => {\n                 // Inherent impl.\n                 match unsafety {"}, {"sha": "841b4516a18f31720f3dd603b10c1d50f241e338", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -169,17 +169,17 @@ impl<'a, 'tcx> CollectItemTypesVisitor<'a, 'tcx> {\n     fn with_collect_item_sig<OP>(&self, id: ast::NodeId, op: OP)\n         where OP: FnOnce()\n     {\n-        let def_id = self.ccx.tcx.map.local_def_id(id);\n+        let def_id = self.ccx.tcx.hir.local_def_id(id);\n         self.ccx.tcx.dep_graph.with_task(DepNode::CollectItemSig(def_id), || {\n-            self.ccx.tcx.map.read(id);\n+            self.ccx.tcx.hir.read(id);\n             op();\n         });\n     }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.ccx.tcx.map)\n+        NestedVisitorMap::OnlyBodies(&self.ccx.tcx.hir)\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -189,7 +189,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if let hir::ExprClosure(..) = expr.node {\n-            let def_id = self.ccx.tcx.map.local_def_id(expr.id);\n+            let def_id = self.ccx.tcx.hir.local_def_id(expr.id);\n             generics_of_def_id(self.ccx, def_id);\n             type_of_def_id(self.ccx, def_id);\n         }\n@@ -198,7 +198,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         if let hir::TyImplTrait(..) = ty.node {\n-            let def_id = self.ccx.tcx.map.local_def_id(ty.id);\n+            let def_id = self.ccx.tcx.hir.local_def_id(ty.id);\n             generics_of_def_id(self.ccx, def_id);\n         }\n         intravisit::walk_ty(self, ty);\n@@ -341,8 +341,8 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n     {\n         let tcx = self.tcx;\n \n-        if let Some(trait_id) = tcx.map.as_local_node_id(def_id) {\n-            let item = match tcx.map.get(trait_id) {\n+        if let Some(trait_id) = tcx.hir.as_local_node_id(def_id) {\n+            let item = match tcx.hir.get(trait_id) {\n                 hir_map::NodeItem(item) => item,\n                 _ => bug!(\"get_trait_def({:?}): not an item\", trait_id)\n             };\n@@ -611,7 +611,7 @@ fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         match path.def {\n             Def::SelfTy(Some(def_id), None) |\n             Def::TyParam(def_id) => {\n-                def_id == tcx.map.local_def_id(param_id)\n+                def_id == tcx.hir.local_def_id(param_id)\n             }\n             _ => false\n         }\n@@ -629,7 +629,7 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let tt = ccx.icx(struct_predicates).to_ty(&ExplicitRscope, &field.ty);\n     ccx.tcx.item_types.borrow_mut().insert(ty_f.did, tt);\n \n-    let def_id = ccx.tcx.map.local_def_id(field.id);\n+    let def_id = ccx.tcx.hir.local_def_id(field.id);\n     ccx.tcx.item_types.borrow_mut().insert(def_id, tt);\n     ccx.tcx.generics.borrow_mut().insert(def_id, struct_generics);\n     ccx.tcx.predicates.borrow_mut().insert(def_id, struct_predicates.clone());\n@@ -642,7 +642,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             untransformed_rcvr_ty: Ty<'tcx>,\n                             body: Option<hir::BodyId>,\n                             rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,) {\n-    let def_id = ccx.tcx.map.local_def_id(id);\n+    let def_id = ccx.tcx.hir.local_def_id(id);\n     let ty_generics = generics_of_def_id(ccx, def_id);\n \n     let ty_generic_predicates =\n@@ -662,7 +662,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     sig, self_value_ty, body, anon_scope);\n \n     let substs = mk_item_substs(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n-                                ccx.tcx.map.span(id), def_id);\n+                                ccx.tcx.hir.span(id), def_id);\n     let fty = ccx.tcx.mk_fn_def(def_id, substs, fty);\n     ccx.tcx.item_types.borrow_mut().insert(def_id, fty);\n     ccx.tcx.predicates.borrow_mut().insert(def_id, ty_generic_predicates);\n@@ -677,7 +677,7 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         parent: Some(container.id()),\n         predicates: vec![]\n     };\n-    let def_id = ccx.tcx.map.local_def_id(id);\n+    let def_id = ccx.tcx.hir.local_def_id(id);\n     ccx.tcx.predicates.borrow_mut().insert(def_id, predicates);\n     ccx.tcx.item_types.borrow_mut().insert(def_id, ty);\n }\n@@ -691,7 +691,7 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         parent: Some(container.id()),\n         predicates: vec![]\n     };\n-    let def_id = ccx.tcx.map.local_def_id(id);\n+    let def_id = ccx.tcx.hir.local_def_id(id);\n     ccx.tcx.predicates.borrow_mut().insert(def_id, predicates);\n \n     if let Some(ty) = ty {\n@@ -741,7 +741,7 @@ fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n     let tcx = ccx.tcx;\n     debug!(\"convert: item {} with id {}\", it.name, it.id);\n-    let def_id = ccx.tcx.map.local_def_id(it.id);\n+    let def_id = ccx.tcx.hir.local_def_id(it.id);\n     match it.node {\n         // These don't define types.\n         hir::ItemExternCrate(_) | hir::ItemUse(..) | hir::ItemMod(_) => {\n@@ -756,7 +756,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             let generics = generics_of_def_id(ccx, def_id);\n             let predicates = predicates_of_item(ccx, it);\n             convert_enum_variant_types(ccx,\n-                                       tcx.lookup_adt_def(ccx.tcx.map.local_def_id(it.id)),\n+                                       tcx.lookup_adt_def(ccx.tcx.hir.local_def_id(it.id)),\n                                        ty,\n                                        generics,\n                                        predicates,\n@@ -771,7 +771,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             tcx.record_trait_has_default_impl(trait_ref.def_id);\n \n-            tcx.impl_trait_refs.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n+            tcx.impl_trait_refs.borrow_mut().insert(ccx.tcx.hir.local_def_id(it.id),\n                                                     Some(trait_ref));\n         }\n         hir::ItemImpl(..,\n@@ -851,12 +851,12 @@ fn convert_trait_item(ccx: &CrateCtxt, trait_item: &hir::TraitItem) {\n \n     // we can lookup details about the trait because items are visited\n     // before trait-items\n-    let trait_def_id = tcx.map.get_parent_did(trait_item.id);\n+    let trait_def_id = tcx.hir.get_parent_did(trait_item.id);\n     let trait_predicates = tcx.item_predicates(trait_def_id);\n \n     match trait_item.node {\n         hir::TraitItemKind::Const(ref ty, _) => {\n-            let const_def_id = ccx.tcx.map.local_def_id(trait_item.id);\n+            let const_def_id = ccx.tcx.hir.local_def_id(trait_item.id);\n             generics_of_def_id(ccx, const_def_id);\n             let ty = ccx.icx(&trait_predicates)\n                         .to_ty(&ExplicitRscope, &ty);\n@@ -866,7 +866,7 @@ fn convert_trait_item(ccx: &CrateCtxt, trait_item: &hir::TraitItem) {\n         }\n \n         hir::TraitItemKind::Type(_, ref opt_ty) => {\n-            let type_def_id = ccx.tcx.map.local_def_id(trait_item.id);\n+            let type_def_id = ccx.tcx.hir.local_def_id(trait_item.id);\n             generics_of_def_id(ccx, type_def_id);\n \n             let typ = opt_ty.as_ref().map({\n@@ -893,14 +893,14 @@ fn convert_impl_item(ccx: &CrateCtxt, impl_item: &hir::ImplItem) {\n \n     // we can lookup details about the impl because items are visited\n     // before impl-items\n-    let impl_def_id = tcx.map.get_parent_did(impl_item.id);\n+    let impl_def_id = tcx.hir.get_parent_did(impl_item.id);\n     let impl_predicates = tcx.item_predicates(impl_def_id);\n     let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n     let impl_self_ty = tcx.item_type(impl_def_id);\n \n     match impl_item.node {\n         hir::ImplItemKind::Const(ref ty, _) => {\n-            let const_def_id = ccx.tcx.map.local_def_id(impl_item.id);\n+            let const_def_id = ccx.tcx.hir.local_def_id(impl_item.id);\n             generics_of_def_id(ccx, const_def_id);\n             let ty = ccx.icx(&impl_predicates)\n                         .to_ty(&ExplicitRscope, &ty);\n@@ -910,7 +910,7 @@ fn convert_impl_item(ccx: &CrateCtxt, impl_item: &hir::ImplItem) {\n         }\n \n         hir::ImplItemKind::Type(ref ty) => {\n-            let type_def_id = ccx.tcx.map.local_def_id(impl_item.id);\n+            let type_def_id = ccx.tcx.hir.local_def_id(impl_item.id);\n             generics_of_def_id(ccx, type_def_id);\n \n             if impl_trait_ref.is_none() {\n@@ -937,13 +937,13 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   ty: Ty<'tcx>,\n                                   predicates: ty::GenericPredicates<'tcx>) {\n     let tcx = ccx.tcx;\n-    let def_id = tcx.map.local_def_id(ctor_id);\n+    let def_id = tcx.hir.local_def_id(ctor_id);\n     generics_of_def_id(ccx, def_id);\n     let ctor_ty = match variant.ctor_kind {\n         CtorKind::Fictive | CtorKind::Const => ty,\n         CtorKind::Fn => {\n             let inputs = variant.fields.iter().map(|field| tcx.item_type(field.did));\n-            let substs = mk_item_substs(&ccx.icx(&predicates), ccx.tcx.map.span(ctor_id), def_id);\n+            let substs = mk_item_substs(&ccx.icx(&predicates), ccx.tcx.hir.span(ctor_id), def_id);\n             tcx.mk_fn_def(def_id, substs, tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: abi::Abi::Rust,\n@@ -952,7 +952,7 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     };\n     tcx.item_types.borrow_mut().insert(def_id, ctor_ty);\n-    tcx.predicates.borrow_mut().insert(tcx.map.local_def_id(ctor_id), predicates);\n+    tcx.predicates.borrow_mut().insert(tcx.hir.local_def_id(ctor_id), predicates);\n }\n \n fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -986,9 +986,9 @@ fn convert_struct_variant<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     def: &hir::VariantData)\n                                     -> ty::VariantDef {\n     let mut seen_fields: FxHashMap<ast::Name, Span> = FxHashMap();\n-    let node_id = ccx.tcx.map.as_local_node_id(did).unwrap();\n+    let node_id = ccx.tcx.hir.as_local_node_id(did).unwrap();\n     let fields = def.fields().iter().map(|f| {\n-        let fid = ccx.tcx.map.local_def_id(f.id);\n+        let fid = ccx.tcx.hir.local_def_id(f.id);\n         let dup_span = seen_fields.get(&f.name).cloned();\n         if let Some(prev_span) = dup_span {\n             struct_span_err!(ccx.tcx.sess, f.span, E0124,\n@@ -1021,9 +1021,9 @@ fn convert_struct_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 def: &hir::VariantData)\n                                 -> &'tcx ty::AdtDef\n {\n-    let did = ccx.tcx.map.local_def_id(it.id);\n+    let did = ccx.tcx.hir.local_def_id(it.id);\n     // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n-    let ctor_id = if !def.is_struct() { Some(ccx.tcx.map.local_def_id(def.id())) } else { None };\n+    let ctor_id = if !def.is_struct() { Some(ccx.tcx.hir.local_def_id(def.id())) } else { None };\n     let variants = vec![convert_struct_variant(ccx, ctor_id.unwrap_or(did), it.name,\n                                                ConstInt::Infer(0), def)];\n     let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Struct, variants);\n@@ -1041,7 +1041,7 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 def: &hir::VariantData)\n                                 -> &'tcx ty::AdtDef\n {\n-    let did = ccx.tcx.map.local_def_id(it.id);\n+    let did = ccx.tcx.hir.local_def_id(it.id);\n     let variants = vec![convert_struct_variant(ccx, did, it.name, ConstInt::Infer(0), def)];\n \n     let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Union, variants);\n@@ -1051,8 +1051,8 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, body: hir::BodyId)\n                           -> Option<ty::Disr> {\n-        let e = &ccx.tcx.map.body(body).value;\n-        debug!(\"disr expr, checking {}\", ccx.tcx.map.node_to_pretty_string(e.id));\n+        let e = &ccx.tcx.hir.body(body).value;\n+        debug!(\"disr expr, checking {}\", ccx.tcx.hir.node_to_pretty_string(e.id));\n \n         let ty_hint = repr_ty.to_ty(ccx.tcx);\n         let print_err = |cv: ConstVal| {\n@@ -1106,7 +1106,7 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                               -> &'tcx ty::AdtDef\n {\n     let tcx = ccx.tcx;\n-    let did = tcx.map.local_def_id(it.id);\n+    let did = tcx.hir.local_def_id(it.id);\n     let repr_hints = tcx.lookup_repr_hints(did);\n     let repr_type = tcx.enum_repr_type(repr_hints.get(0));\n     let initial = repr_type.initial_discriminant(tcx);\n@@ -1128,7 +1128,7 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }.unwrap_or(wrapped_disr);\n         prev_disr = Some(disr);\n \n-        let did = tcx.map.local_def_id(v.node.data.id());\n+        let did = tcx.hir.local_def_id(v.node.data.id());\n         convert_struct_variant(ccx, did, v.node.name, disr, &v.node.data)\n     }).collect();\n \n@@ -1152,7 +1152,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n \n     debug!(\"ensure_super_predicates_step(trait_def_id={:?})\", trait_def_id);\n \n-    let trait_node_id = if let Some(n) = tcx.map.as_local_node_id(trait_def_id) {\n+    let trait_node_id = if let Some(n) = tcx.hir.as_local_node_id(trait_def_id) {\n         n\n     } else {\n         // If this trait comes from an external crate, then all of the\n@@ -1165,7 +1165,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n \n     let superpredicates = tcx.super_predicates.borrow().get(&trait_def_id).cloned();\n     let superpredicates = superpredicates.unwrap_or_else(|| {\n-        let item = match ccx.tcx.map.get(trait_node_id) {\n+        let item = match ccx.tcx.hir.get(trait_node_id) {\n             hir_map::NodeItem(item) => item,\n             _ => bug!(\"trait_node_id {} is not an item\", trait_node_id)\n         };\n@@ -1213,7 +1213,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n             predicates: superbounds\n         };\n         debug!(\"superpredicates for trait {:?} = {:?}\",\n-               tcx.map.local_def_id(item.id),\n+               tcx.hir.local_def_id(item.id),\n                superpredicates);\n \n         tcx.super_predicates.borrow_mut().insert(trait_def_id, superpredicates.clone());\n@@ -1233,7 +1233,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n }\n \n fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item) -> &'tcx ty::TraitDef {\n-    let def_id = ccx.tcx.map.local_def_id(it.id);\n+    let def_id = ccx.tcx.hir.local_def_id(it.id);\n     let tcx = ccx.tcx;\n \n     tcx.trait_defs.memoize(def_id, || {\n@@ -1262,7 +1262,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item) -> &'t\n fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item) {\n     let tcx = ccx.tcx;\n \n-    let def_id = ccx.tcx.map.local_def_id(it.id);\n+    let def_id = ccx.tcx.hir.local_def_id(it.id);\n \n     generics_of_def_id(ccx, def_id);\n     trait_def_of_item(ccx, it);\n@@ -1319,7 +1319,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n                                                  -> Vec<ty::Predicate<'tcx>>\n     {\n         trait_item_refs.iter().flat_map(|trait_item_ref| {\n-            let trait_item = ccx.tcx.map.trait_item(trait_item_ref.id);\n+            let trait_item = ccx.tcx.hir.trait_item(trait_item_ref.id);\n             let bounds = match trait_item.node {\n                 hir::TraitItemKind::Type(ref bounds, _) => bounds,\n                 _ => {\n@@ -1346,7 +1346,7 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 def_id: DefId)\n                                 -> &'tcx ty::Generics<'tcx> {\n     let tcx = ccx.tcx;\n-    let node_id = if let Some(id) = tcx.map.as_local_node_id(def_id) {\n+    let node_id = if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n         id\n     } else {\n         return tcx.item_generics(def_id);\n@@ -1355,29 +1355,29 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         use rustc::hir::map::*;\n         use rustc::hir::*;\n \n-        let node = tcx.map.get(node_id);\n+        let node = tcx.hir.get(node_id);\n         let parent_def_id = match node {\n             NodeImplItem(_) |\n             NodeTraitItem(_) |\n             NodeVariant(_) |\n             NodeStructCtor(_) => {\n-                let parent_id = tcx.map.get_parent(node_id);\n-                Some(tcx.map.local_def_id(parent_id))\n+                let parent_id = tcx.hir.get_parent(node_id);\n+                Some(tcx.hir.local_def_id(parent_id))\n             }\n             NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n                 Some(tcx.closure_base_def_id(def_id))\n             }\n             NodeTy(&hir::Ty { node: hir::TyImplTrait(..), .. }) => {\n                 let mut parent_id = node_id;\n                 loop {\n-                    match tcx.map.get(parent_id) {\n+                    match tcx.hir.get(parent_id) {\n                         NodeItem(_) | NodeImplItem(_) | NodeTraitItem(_) => break,\n                         _ => {\n-                            parent_id = tcx.map.get_parent_node(parent_id);\n+                            parent_id = tcx.hir.get_parent_node(parent_id);\n                         }\n                     }\n                 }\n-                Some(tcx.map.local_def_id(parent_id))\n+                Some(tcx.hir.local_def_id(parent_id))\n             }\n             _ => None\n         };\n@@ -1421,13 +1421,13 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         // the node id for the Self type parameter.\n                         let param_id = item.id;\n \n-                        let parent = ccx.tcx.map.get_parent(param_id);\n+                        let parent = ccx.tcx.hir.get_parent(param_id);\n \n                         let def = ty::TypeParameterDef {\n                             index: 0,\n                             name: keywords::SelfType.name(),\n-                            def_id: tcx.map.local_def_id(param_id),\n-                            default_def_id: tcx.map.local_def_id(parent),\n+                            def_id: tcx.hir.local_def_id(param_id),\n+                            default_def_id: tcx.hir.local_def_id(parent),\n                             default: None,\n                             object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n                             pure_wrt_drop: false,\n@@ -1470,7 +1470,7 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             ty::RegionParameterDef {\n                 name: l.lifetime.name,\n                 index: own_start + i as u32,\n-                def_id: tcx.map.local_def_id(l.lifetime.id),\n+                def_id: tcx.hir.local_def_id(l.lifetime.id),\n                 bounds: l.bounds.iter().map(|l| {\n                     ast_region_to_region(tcx, l)\n                 }).collect(),\n@@ -1512,7 +1512,7 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         d => format!(\"{:?}\", d),\n                     }\n                 }).collect::<Vec<String>>().join(\",\");\n-            tcx.sess.span_err(tcx.map.span(node_id), &object_lifetime_default_reprs);\n+            tcx.sess.span_err(tcx.hir.span(node_id), &object_lifetime_default_reprs);\n         }\n \n         tcx.alloc_generics(ty::Generics {\n@@ -1529,7 +1529,7 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             def_id: DefId)\n                             -> Ty<'tcx> {\n-    let node_id = if let Some(id) = ccx.tcx.map.as_local_node_id(def_id) {\n+    let node_id = if let Some(id) = ccx.tcx.hir.as_local_node_id(def_id) {\n         id\n     } else {\n         return ccx.tcx.item_type(def_id);\n@@ -1541,7 +1541,7 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         // Alway bring in generics, as computing the type needs them.\n         generics_of_def_id(ccx, def_id);\n \n-        let ty = match ccx.tcx.map.get(node_id) {\n+        let ty = match ccx.tcx.hir.get(node_id) {\n             NodeItem(item) => {\n                 match item.node {\n                     ItemStatic(ref t, ..) | ItemConst(ref t, _) => {\n@@ -1586,12 +1586,12 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 }\n             }\n             NodeForeignItem(foreign_item) => {\n-                let abi = ccx.tcx.map.get_foreign_abi(node_id);\n+                let abi = ccx.tcx.hir.get_foreign_abi(node_id);\n \n                 match foreign_item.node {\n                     ForeignItemFn(ref fn_decl, _, ref generics) => {\n                         compute_type_of_foreign_fn_decl(\n-                            ccx, ccx.tcx.map.local_def_id(foreign_item.id),\n+                            ccx, ccx.tcx.hir.local_def_id(foreign_item.id),\n                             fn_decl, generics, abi)\n                     }\n                     ForeignItemStatic(ref t, _) => {\n@@ -1621,7 +1621,7 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n fn predicates_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 it: &hir::Item)\n                                 -> ty::GenericPredicates<'tcx> {\n-    let def_id = ccx.tcx.map.local_def_id(it.id);\n+    let def_id = ccx.tcx.hir.local_def_id(it.id);\n \n     let no_generics = hir::Generics::empty();\n     let generics = match it.node {\n@@ -1648,7 +1648,7 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // map, and I regard each time that I use it as a personal and\n     // moral failing, but at the moment it seems like the only\n     // convenient way to extract the ABI. - ndm\n-    let def_id = ccx.tcx.map.local_def_id(it.id);\n+    let def_id = ccx.tcx.hir.local_def_id(it.id);\n     type_of_def_id(ccx, def_id);\n     generics_of_def_id(ccx, def_id);\n \n@@ -1868,7 +1868,7 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         compute_object_lifetime_default(ccx, param.id,\n                                         &param.bounds, &ast_generics.where_clause);\n \n-    let parent = tcx.map.get_parent(param.id);\n+    let parent = tcx.hir.get_parent(param.id);\n \n     if !allow_defaults && default.is_some() {\n         if !tcx.sess.features.borrow().default_type_parameter_fallback {\n@@ -1884,8 +1884,8 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let def = ty::TypeParameterDef {\n         index: index,\n         name: param.name,\n-        def_id: ccx.tcx.map.local_def_id(param.id),\n-        default_def_id: ccx.tcx.map.local_def_id(parent),\n+        def_id: ccx.tcx.hir.local_def_id(param.id),\n+        default_def_id: ccx.tcx.hir.local_def_id(parent),\n         default: default,\n         object_lifetime_default: object_lifetime_default,\n         pure_wrt_drop: param.pure_wrt_drop,\n@@ -2083,7 +2083,7 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n                 ccx.tcx.sess.struct_span_err(ast_ty.span,\n                               &format!(\"use of SIMD type `{}` in FFI is highly experimental and \\\n                                         may result in invalid code\",\n-                                       ccx.tcx.map.node_to_pretty_string(ast_ty.id)))\n+                                       ccx.tcx.hir.node_to_pretty_string(ast_ty.id)))\n                     .help(\"add #![feature(simd_ffi)] to the crate attributes to enable\")\n                     .emit();\n             }\n@@ -2096,8 +2096,8 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n         }\n     }\n \n-    let id = ccx.tcx.map.as_local_node_id(def_id).unwrap();\n-    let substs = mk_item_substs(&ccx.icx(ast_generics), ccx.tcx.map.span(id), def_id);\n+    let id = ccx.tcx.hir.as_local_node_id(def_id).unwrap();\n+    let substs = mk_item_substs(&ccx.icx(ast_generics), ccx.tcx.hir.span(id), def_id);\n     ccx.tcx.mk_fn_def(def_id, substs, ccx.tcx.mk_bare_fn(ty::BareFnTy {\n         abi: abi,\n         unsafety: hir::Unsafety::Unsafe,"}, {"sha": "3a19b3579d5598b61bf275fc13f2db9b0eafa0f8", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -76,7 +76,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for ImplWfCheck<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n             hir::ItemImpl(.., ref generics, _, _, ref impl_item_refs) => {\n-                let impl_def_id = self.ccx.tcx.map.local_def_id(item.id);\n+                let impl_def_id = self.ccx.tcx.hir.local_def_id(item.id);\n                 enforce_impl_params_are_constrained(self.ccx,\n                                                     generics,\n                                                     impl_def_id,\n@@ -117,7 +117,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     // Disallow unconstrained lifetimes, but only if they appear in assoc types.\n     let lifetimes_in_associated_types: FxHashSet<_> = impl_item_refs.iter()\n-        .map(|item_ref|  ccx.tcx.map.local_def_id(item_ref.id.node_id))\n+        .map(|item_ref|  ccx.tcx.hir.local_def_id(item_ref.id.node_id))\n         .filter(|&def_id| {\n             let item = ccx.tcx.associated_item(def_id);\n             item.kind == ty::AssociatedKind::Type && item.defaultness.has_value()\n@@ -181,7 +181,7 @@ fn enforce_impl_items_are_distinct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let mut seen_type_items = FxHashMap();\n     let mut seen_value_items = FxHashMap();\n     for impl_item_ref in impl_item_refs {\n-        let impl_item = tcx.map.impl_item(impl_item_ref.id);\n+        let impl_item = tcx.hir.impl_item(impl_item_ref.id);\n         let seen_items = match impl_item.node {\n             hir::ImplItemKind::Type(_) => &mut seen_type_items,\n             _                    => &mut seen_value_items,"}, {"sha": "0e7daa03404c5bf18b4bdd113a6cf08961043821", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -196,11 +196,11 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                     main_id: ast::NodeId,\n                     main_span: Span) {\n     let tcx = ccx.tcx;\n-    let main_def_id = tcx.map.local_def_id(main_id);\n+    let main_def_id = tcx.hir.local_def_id(main_id);\n     let main_t = tcx.item_type(main_def_id);\n     match main_t.sty {\n         ty::TyFnDef(..) => {\n-            match tcx.map.find(main_id) {\n+            match tcx.hir.find(main_id) {\n                 Some(hir_map::NodeItem(it)) => {\n                     match it.node {\n                         hir::ItemFn(.., ref generics, _) => {\n@@ -244,11 +244,11 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                      start_id: ast::NodeId,\n                      start_span: Span) {\n     let tcx = ccx.tcx;\n-    let start_def_id = ccx.tcx.map.local_def_id(start_id);\n+    let start_def_id = ccx.tcx.hir.local_def_id(start_id);\n     let start_t = tcx.item_type(start_def_id);\n     match start_t.sty {\n         ty::TyFnDef(..) => {\n-            match tcx.map.find(start_id) {\n+            match tcx.hir.find(start_id) {\n                 Some(hir_map::NodeItem(it)) => {\n                     match it.node {\n                         hir::ItemFn(..,ref ps,_)"}, {"sha": "55033330a449055a4d0cf9903cb4bd64be45bb2a", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -74,9 +74,9 @@ pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let tcx = self.terms_cx.tcx;\n-        let did = tcx.map.local_def_id(item.id);\n+        let did = tcx.hir.local_def_id(item.id);\n \n-        debug!(\"visit_item item={}\", tcx.map.node_to_string(item.id));\n+        debug!(\"visit_item item={}\", tcx.hir.node_to_string(item.id));\n \n         match item.node {\n             hir::ItemEnum(..) |\n@@ -145,14 +145,14 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             Some(&index) => index,\n             None => {\n                 bug!(\"no inferred index entry for {}\",\n-                     self.tcx().map.node_to_string(param_id));\n+                     self.tcx().hir.node_to_string(param_id));\n             }\n         }\n     }\n \n     fn find_binding_for_lifetime(&self, param_id: ast::NodeId) -> ast::NodeId {\n         let tcx = self.terms_cx.tcx;\n-        assert!(is_lifetime(&tcx.map, param_id));\n+        assert!(is_lifetime(&tcx.hir, param_id));\n         match tcx.named_region_map.defs.get(&param_id) {\n             Some(&rl::DefEarlyBoundRegion(_, lifetime_decl_id)) => lifetime_decl_id,\n             Some(_) => bug!(\"should not encounter non early-bound cases\"),\n@@ -177,17 +177,17 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             let tcx = this.terms_cx.tcx;\n             let decl_id = this.find_binding_for_lifetime(param_id);\n             // Currently only called on lifetimes; double-checking that.\n-            assert!(is_lifetime(&tcx.map, param_id));\n-            let parent_id = tcx.map.get_parent(decl_id);\n-            let parent = tcx.map\n+            assert!(is_lifetime(&tcx.hir, param_id));\n+            let parent_id = tcx.hir.get_parent(decl_id);\n+            let parent = tcx.hir\n                 .find(parent_id)\n-                .unwrap_or_else(|| bug!(\"tcx.map missing entry for id: {}\", parent_id));\n+                .unwrap_or_else(|| bug!(\"tcx.hir missing entry for id: {}\", parent_id));\n \n             let is_inferred;\n             macro_rules! cannot_happen { () => { {\n                 bug!(\"invalid parent: {} for {}\",\n-                     tcx.map.node_to_string(parent_id),\n-                     tcx.map.node_to_string(param_id));\n+                     tcx.hir.node_to_string(parent_id),\n+                     tcx.hir.node_to_string(param_id));\n             } } }\n \n             match parent {\n@@ -224,7 +224,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                          -> VarianceTermPtr<'a> {\n         assert_eq!(param_def_id.krate, item_def_id.krate);\n \n-        if let Some(param_node_id) = self.tcx().map.as_local_node_id(param_def_id) {\n+        if let Some(param_node_id) = self.tcx().hir.as_local_node_id(param_def_id) {\n             // Parameter on an item defined within current crate:\n             // variance not yet inferred, so return a symbolic\n             // variance.\n@@ -400,7 +400,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                     i -= generics.regions.len();\n                 }\n                 let def_id = generics.types[i].def_id;\n-                let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n+                let node_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n                 match self.terms_cx.inferred_map.get(&node_id) {\n                     Some(&index) => {\n                         self.add_constraint(index, variance);\n@@ -487,7 +487,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 assert_eq!(generics.parent, None);\n                 let i = data.index as usize - generics.has_self as usize;\n                 let def_id = generics.regions[i].def_id;\n-                let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n+                let node_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n                 if self.is_to_be_inferred(node_id) {\n                     let index = self.inferred_index(node_id);\n                     self.add_constraint(index, variance);"}, {"sha": "bdf1d0590bcc7bf48a72db776abfa4ad7003fccb", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -125,13 +125,13 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n \n             debug!(\"item_id={} item_variances={:?}\", item_id, item_variances);\n \n-            let item_def_id = tcx.map.local_def_id(item_id);\n+            let item_def_id = tcx.hir.local_def_id(item_id);\n \n             // For unit testing: check for a special \"rustc_variance\"\n             // attribute and report an error with various results if found.\n             if tcx.has_attr(item_def_id, \"rustc_variance\") {\n                 span_err!(tcx.sess,\n-                          tcx.map.span(item_id),\n+                          tcx.hir.span(item_id),\n                           E0208,\n                           \"{:?}\",\n                           item_variances);"}, {"sha": "0e09d34cc9bd3774c0c0ee13936cc266ce66c483", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -132,7 +132,7 @@ fn lang_items(tcx: TyCtxt) -> Vec<(ast::NodeId, Vec<ty::Variance>)> {\n     all.into_iter() // iterating over (Option<DefId>, Variance)\n        .filter(|&(ref d,_)| d.is_some())\n        .map(|(d, v)| (d.unwrap(), v)) // (DefId, Variance)\n-       .filter_map(|(d, v)| tcx.map.as_local_node_id(d).map(|n| (n, v))) // (NodeId, Variance)\n+       .filter_map(|(d, v)| tcx.hir.as_local_node_id(d).map(|n| (n, v))) // (NodeId, Variance)\n        .collect()\n }\n \n@@ -177,7 +177,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         // \"invalid item id\" from \"item id with no\n         // parameters\".\n         if self.num_inferred() == inferreds_on_entry {\n-            let item_def_id = self.tcx.map.local_def_id(item_id);\n+            let item_def_id = self.tcx.hir.local_def_id(item_id);\n             let newly_added = self.tcx\n                 .item_variance_map\n                 .borrow_mut()\n@@ -207,7 +207,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n                 param_id={}, \\\n                 inf_index={:?}, \\\n                 initial_variance={:?})\",\n-               self.tcx.item_path_str(self.tcx.map.local_def_id(item_id)),\n+               self.tcx.item_path_str(self.tcx.hir.local_def_id(item_id)),\n                item_id,\n                index,\n                param_id,\n@@ -230,7 +230,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         debug!(\"add_inferreds for item {}\",\n-               self.tcx.map.node_to_string(item.id));\n+               self.tcx.hir.node_to_string(item.id));\n \n         match item.node {\n             hir::ItemEnum(_, ref generics) |"}, {"sha": "eedca0ffb63270ae1d380de3a361c80f71159aed", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -223,17 +223,17 @@ impl Clean<ExternalCrate> for CrateNum {\n             None\n         };\n         let primitives = if root.is_local() {\n-            cx.tcx.map.krate().module.item_ids.iter().filter_map(|&id| {\n-                let item = cx.tcx.map.expect_item(id.id);\n+            cx.tcx.hir.krate().module.item_ids.iter().filter_map(|&id| {\n+                let item = cx.tcx.hir.expect_item(id.id);\n                 match item.node {\n                     hir::ItemMod(_) => {\n-                        as_primitive(Def::Mod(cx.tcx.map.local_def_id(id.id)))\n+                        as_primitive(Def::Mod(cx.tcx.hir.local_def_id(id.id)))\n                     }\n                     hir::ItemUse(ref path, hir::UseKind::Single)\n                     if item.vis == hir::Visibility::Public => {\n                         as_primitive(path.def).map(|(_, prim, attrs)| {\n                             // Pretend the primitive is local.\n-                            (cx.tcx.map.local_def_id(id.id), prim, attrs)\n+                            (cx.tcx.hir.local_def_id(id.id), prim, attrs)\n                         })\n                     }\n                     _ => None\n@@ -454,7 +454,7 @@ impl Clean<Item> for doctree::Module {\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.tcx.map.local_def_id(self.id),\n+            def_id: cx.tcx.hir.local_def_id(self.id),\n             inner: ModuleItem(Module {\n                is_crate: self.is_crate,\n                items: items\n@@ -576,7 +576,7 @@ impl Clean<TyParam> for hir::TyParam {\n     fn clean(&self, cx: &DocContext) -> TyParam {\n         TyParam {\n             name: self.name.clean(cx),\n-            did: cx.tcx.map.local_def_id(self.id),\n+            did: cx.tcx.hir.local_def_id(self.id),\n             bounds: self.bounds.clean(cx),\n             default: self.default.clean(cx),\n         }\n@@ -1067,7 +1067,7 @@ impl Clean<Item> for doctree::Function {\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.tcx.map.local_def_id(self.id),\n+            def_id: cx.tcx.hir.local_def_id(self.id),\n             inner: FunctionItem(Function {\n                 decl: (&self.decl, self.body).clean(cx),\n                 generics: self.generics.clean(cx),\n@@ -1122,7 +1122,7 @@ impl<'a> Clean<Arguments> for (&'a [P<hir::Ty>], &'a [Spanned<ast::Name>]) {\n \n impl<'a> Clean<Arguments> for (&'a [P<hir::Ty>], hir::BodyId) {\n     fn clean(&self, cx: &DocContext) -> Arguments {\n-        let body = cx.tcx.map.body(self.1);\n+        let body = cx.tcx.hir.body(self.1);\n \n         Arguments {\n             values: self.0.iter().enumerate().map(|(i, ty)| {\n@@ -1151,7 +1151,7 @@ impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl, A)\n impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n     fn clean(&self, cx: &DocContext) -> FnDecl {\n         let (did, sig) = *self;\n-        let mut names = if cx.tcx.map.as_local_node_id(did).is_some() {\n+        let mut names = if cx.tcx.hir.as_local_node_id(did).is_some() {\n             vec![].into_iter()\n         } else {\n             cx.tcx.sess.cstore.fn_arg_names(did).into_iter()\n@@ -1231,7 +1231,7 @@ impl Clean<Item> for doctree::Trait {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.map.local_def_id(self.id),\n+            def_id: cx.tcx.hir.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -1286,10 +1286,10 @@ impl Clean<Item> for hir::TraitItem {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            def_id: cx.tcx.map.local_def_id(self.id),\n+            def_id: cx.tcx.hir.local_def_id(self.id),\n             visibility: None,\n-            stability: get_stability(cx, cx.tcx.map.local_def_id(self.id)),\n-            deprecation: get_deprecation(cx, cx.tcx.map.local_def_id(self.id)),\n+            stability: get_stability(cx, cx.tcx.hir.local_def_id(self.id)),\n+            deprecation: get_deprecation(cx, cx.tcx.hir.local_def_id(self.id)),\n             inner: inner\n         }\n     }\n@@ -1318,10 +1318,10 @@ impl Clean<Item> for hir::ImplItem {\n             name: Some(self.name.clean(cx)),\n             source: self.span.clean(cx),\n             attrs: self.attrs.clean(cx),\n-            def_id: cx.tcx.map.local_def_id(self.id),\n+            def_id: cx.tcx.hir.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, cx.tcx.map.local_def_id(self.id)),\n-            deprecation: get_deprecation(cx, cx.tcx.map.local_def_id(self.id)),\n+            stability: get_stability(cx, cx.tcx.hir.local_def_id(self.id)),\n+            deprecation: get_deprecation(cx, cx.tcx.hir.local_def_id(self.id)),\n             inner: inner\n         }\n     }\n@@ -1703,9 +1703,9 @@ impl Clean<Type> for hir::Ty {\n                 let mut alias = None;\n                 if let Def::TyAlias(def_id) = path.def {\n                     // Substitute private type aliases\n-                    if let Some(node_id) = cx.tcx.map.as_local_node_id(def_id) {\n+                    if let Some(node_id) = cx.tcx.hir.as_local_node_id(def_id) {\n                         if !cx.access_levels.borrow().is_exported(def_id) {\n-                            alias = Some(&cx.tcx.map.expect_item(node_id).node);\n+                            alias = Some(&cx.tcx.hir.expect_item(node_id).node);\n                         }\n                     }\n                 };\n@@ -1715,7 +1715,7 @@ impl Clean<Type> for hir::Ty {\n                     let mut ty_substs = FxHashMap();\n                     let mut lt_substs = FxHashMap();\n                     for (i, ty_param) in generics.ty_params.iter().enumerate() {\n-                        let ty_param_def = Def::TyParam(cx.tcx.map.local_def_id(ty_param.id));\n+                        let ty_param_def = Def::TyParam(cx.tcx.hir.local_def_id(ty_param.id));\n                         if let Some(ty) = provided_params.types().get(i).cloned()\n                                                                         .cloned() {\n                             ty_substs.insert(ty_param_def, ty.unwrap().clean(cx));\n@@ -1823,7 +1823,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     type_params: Vec::new(),\n                     where_predicates: Vec::new()\n                 },\n-                decl: (cx.tcx.map.local_def_id(ast::CRATE_NODE_ID), &fty.sig).clean(cx),\n+                decl: (cx.tcx.hir.local_def_id(ast::CRATE_NODE_ID), &fty.sig).clean(cx),\n                 abi: fty.abi,\n             }),\n             ty::TyAdt(def, substs) => {\n@@ -1919,9 +1919,9 @@ impl Clean<Item> for hir::StructField {\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, cx.tcx.map.local_def_id(self.id)),\n-            deprecation: get_deprecation(cx, cx.tcx.map.local_def_id(self.id)),\n-            def_id: cx.tcx.map.local_def_id(self.id),\n+            stability: get_stability(cx, cx.tcx.hir.local_def_id(self.id)),\n+            deprecation: get_deprecation(cx, cx.tcx.hir.local_def_id(self.id)),\n+            def_id: cx.tcx.hir.local_def_id(self.id),\n             inner: StructFieldItem(self.ty.clean(cx)),\n         }\n     }\n@@ -1982,7 +1982,7 @@ impl Clean<Item> for doctree::Struct {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.map.local_def_id(self.id),\n+            def_id: cx.tcx.hir.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2002,7 +2002,7 @@ impl Clean<Item> for doctree::Union {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.map.local_def_id(self.id),\n+            def_id: cx.tcx.hir.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2049,7 +2049,7 @@ impl Clean<Item> for doctree::Enum {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.map.local_def_id(self.id),\n+            def_id: cx.tcx.hir.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2076,7 +2076,7 @@ impl Clean<Item> for doctree::Variant {\n             visibility: None,\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.tcx.map.local_def_id(self.def.id()),\n+            def_id: cx.tcx.hir.local_def_id(self.def.id()),\n             inner: VariantItem(Variant {\n                 kind: self.def.clean(cx),\n             }),\n@@ -2306,7 +2306,7 @@ impl Clean<Item> for doctree::Typedef {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.map.local_def_id(self.id.clone()),\n+            def_id: cx.tcx.hir.local_def_id(self.id.clone()),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2358,7 +2358,7 @@ impl Clean<Item> for doctree::Static {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.map.local_def_id(self.id),\n+            def_id: cx.tcx.hir.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2383,7 +2383,7 @@ impl Clean<Item> for doctree::Constant {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.map.local_def_id(self.id),\n+            def_id: cx.tcx.hir.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2459,7 +2459,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.map.local_def_id(self.id),\n+            def_id: cx.tcx.hir.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2542,7 +2542,7 @@ impl Clean<Item> for doctree::DefaultImpl {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.map.local_def_id(self.id),\n+            def_id: cx.tcx.hir.local_def_id(self.id),\n             visibility: Some(Public),\n             stability: None,\n             deprecation: None,\n@@ -2598,7 +2598,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.map.local_def_id(ast::CRATE_NODE_ID),\n+            def_id: cx.tcx.hir.local_def_id(ast::CRATE_NODE_ID),\n             visibility: self.vis.clean(cx),\n             stability: None,\n             deprecation: None,\n@@ -2657,10 +2657,10 @@ impl Clean<Item> for hir::ForeignItem {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            def_id: cx.tcx.map.local_def_id(self.id),\n+            def_id: cx.tcx.hir.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, cx.tcx.map.local_def_id(self.id)),\n-            deprecation: get_deprecation(cx, cx.tcx.map.local_def_id(self.id)),\n+            stability: get_stability(cx, cx.tcx.hir.local_def_id(self.id)),\n+            deprecation: get_deprecation(cx, cx.tcx.hir.local_def_id(self.id)),\n             inner: inner,\n         }\n     }\n@@ -2721,7 +2721,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n }\n \n fn print_const_expr(cx: &DocContext, body: hir::BodyId) -> String {\n-    cx.tcx.map.node_to_pretty_string(body.node_id)\n+    cx.tcx.hir.node_to_pretty_string(body.node_id)\n }\n \n /// Given a type Path, resolve it to a Type using the TyCtxt"}, {"sha": "5393e395bbe43aad2e90af3c1e66729493742754", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -189,7 +189,7 @@ pub fn run_core(search_paths: SearchPaths,\n         // to the map from defid -> nodeid\n         let access_levels = AccessLevels {\n             map: access_levels.map.into_iter()\n-                                  .map(|(k, v)| (tcx.map.local_def_id(k), v))\n+                                  .map(|(k, v)| (tcx.hir.local_def_id(k), v))\n                                   .collect()\n         };\n \n@@ -204,11 +204,11 @@ pub fn run_core(search_paths: SearchPaths,\n             export_map: export_map,\n             hir_ty_to_ty: hir_ty_to_ty,\n         };\n-        debug!(\"crate: {:?}\", tcx.map.krate());\n+        debug!(\"crate: {:?}\", tcx.hir.krate());\n \n         let krate = {\n             let mut v = RustdocVisitor::new(&ctxt);\n-            v.visit(tcx.map.krate());\n+            v.visit(tcx.hir.krate());\n             v.clean(&ctxt)\n         };\n "}, {"sha": "394eb4779898c1021b754a4612ca69e08658c501", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -65,12 +65,12 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     fn stability(&self, id: ast::NodeId) -> Option<attr::Stability> {\n-        self.cx.tcx.map.opt_local_def_id(id)\n+        self.cx.tcx.hir.opt_local_def_id(id)\n             .and_then(|def_id| self.cx.tcx.lookup_stability(def_id)).cloned()\n     }\n \n     fn deprecation(&self, id: ast::NodeId) -> Option<attr::Deprecation> {\n-        self.cx.tcx.map.opt_local_def_id(id)\n+        self.cx.tcx.hir.opt_local_def_id(id)\n             .and_then(|def_id| self.cx.tcx.lookup_deprecation(def_id))\n     }\n \n@@ -193,7 +193,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let orig_inside_public_path = self.inside_public_path;\n         self.inside_public_path &= vis == hir::Public;\n         for i in &m.item_ids {\n-            let item = self.cx.tcx.map.expect_item(i.id);\n+            let item = self.cx.tcx.hir.expect_item(i.id);\n             self.visit_item(item, None, &mut om);\n         }\n         self.inside_public_path = orig_inside_public_path;\n@@ -246,9 +246,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                           please_inline: bool) -> bool {\n \n         fn inherits_doc_hidden(cx: &core::DocContext, mut node: ast::NodeId) -> bool {\n-            while let Some(id) = cx.tcx.map.get_enclosing_scope(node) {\n+            while let Some(id) = cx.tcx.hir.get_enclosing_scope(node) {\n                 node = id;\n-                if cx.tcx.map.attrs(node).lists(\"doc\").has_word(\"hidden\") {\n+                if cx.tcx.hir.attrs(node).lists(\"doc\").has_word(\"hidden\") {\n                     return true;\n                 }\n                 if node == ast::CRATE_NODE_ID {\n@@ -264,7 +264,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         }\n         let def_did = def.def_id();\n \n-        let use_attrs = tcx.map.attrs(id);\n+        let use_attrs = tcx.hir.attrs(id);\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n         let is_no_inline = use_attrs.lists(\"doc\").has_word(\"no_inline\") ||\n                            use_attrs.lists(\"doc\").has_word(\"hidden\");\n@@ -292,7 +292,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false\n         }\n \n-        let def_node_id = match tcx.map.as_local_node_id(def_did) {\n+        let def_node_id = match tcx.hir.as_local_node_id(def_did) {\n             Some(n) => n, None => return false\n         };\n \n@@ -306,14 +306,14 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n         if !self.view_item_stack.insert(def_node_id) { return false }\n \n-        let ret = match tcx.map.get(def_node_id) {\n+        let ret = match tcx.hir.get(def_node_id) {\n             hir_map::NodeItem(it) => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 if glob {\n                     match it.node {\n                         hir::ItemMod(ref m) => {\n                             for i in &m.item_ids {\n-                                let i = self.cx.tcx.map.expect_item(i.id);\n+                                let i = self.cx.tcx.hir.expect_item(i.id);\n                                 self.visit_item(i, None, om);\n                             }\n                         }\n@@ -460,7 +460,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             },\n             hir::ItemTrait(unsafety, ref gen, ref b, ref item_ids) => {\n                 let items = item_ids.iter()\n-                                    .map(|ti| self.cx.tcx.map.trait_item(ti.id).clone())\n+                                    .map(|ti| self.cx.tcx.hir.trait_item(ti.id).clone())\n                                     .collect();\n                 let t = Trait {\n                     unsafety: unsafety,\n@@ -483,7 +483,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 // regardless of where they're located.\n                 if !self.inlining {\n                     let items = item_ids.iter()\n-                                        .map(|ii| self.cx.tcx.map.impl_item(ii.id).clone())\n+                                        .map(|ii| self.cx.tcx.hir.impl_item(ii.id).clone())\n                                         .collect();\n                     let i = Impl {\n                         unsafety: unsafety,\n@@ -524,7 +524,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let matchers = def.body.chunks(4).map(|arm| arm[0].get_span()).collect();\n \n         Macro {\n-            def_id: self.cx.tcx.map.local_def_id(def.id),\n+            def_id: self.cx.tcx.hir.local_def_id(def.id),\n             attrs: def.attrs.clone(),\n             name: def.name,\n             whence: def.span,"}, {"sha": "778c49d144c020da249b21ad45d479ed4a754b58", "filename": "src/test/run-pass-fulldeps/issue-37290/auxiliary/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Ftest%2Frun-pass-fulldeps%2Fissue-37290%2Fauxiliary%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c8c5678a3065c5d1f75b2413bd800a792cf3d9/src%2Ftest%2Frun-pass-fulldeps%2Fissue-37290%2Fauxiliary%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-37290%2Fauxiliary%2Flint.rs?ref=45c8c5678a3065c5d1f75b2413bd800a792cf3d9", "patch": "@@ -53,8 +53,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if let Some(other) = self.map.insert(extent, node) {\n             cx.span_lint(REGION_HIERARCHY, span, &format!(\n                 \"different fns {:?}, {:?} with the same root extent {:?}\",\n-                cx.tcx.map.local_def_id(other),\n-                cx.tcx.map.local_def_id(node),\n+                cx.tcx.hir.local_def_id(other),\n+                cx.tcx.hir.local_def_id(node),\n                 extent));\n         }\n     }"}]}