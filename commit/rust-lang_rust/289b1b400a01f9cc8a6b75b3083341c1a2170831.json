{"sha": "289b1b400a01f9cc8a6b75b3083341c1a2170831", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4OWIxYjQwMGEwMWY5Y2M4YTZiNzViMzA4MzM0MWMxYTIxNzA4MzE=", "commit": {"author": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2015-11-14T10:18:32Z"}, "committer": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2015-11-14T10:18:32Z"}, "message": "Reindent code", "tree": {"sha": "16e39b433d3d6e197c3b55de3f459988ab1c2e0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16e39b433d3d6e197c3b55de3f459988ab1c2e0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/289b1b400a01f9cc8a6b75b3083341c1a2170831", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/289b1b400a01f9cc8a6b75b3083341c1a2170831", "html_url": "https://github.com/rust-lang/rust/commit/289b1b400a01f9cc8a6b75b3083341c1a2170831", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/289b1b400a01f9cc8a6b75b3083341c1a2170831/comments", "author": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdadba578655ed35f99395b66cd36d8f6d6fdaf3", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdadba578655ed35f99395b66cd36d8f6d6fdaf3", "html_url": "https://github.com/rust-lang/rust/commit/fdadba578655ed35f99395b66cd36d8f6d6fdaf3"}], "stats": {"total": 44, "additions": 22, "deletions": 22}, "files": [{"sha": "c5cbb95aeebff5870d5cea75240374040646e320", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/289b1b400a01f9cc8a6b75b3083341c1a2170831/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289b1b400a01f9cc8a6b75b3083341c1a2170831/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=289b1b400a01f9cc8a6b75b3083341c1a2170831", "patch": "@@ -169,17 +169,17 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n     let mut best_fail_msg = \"internal error: ran no matchers\".to_string();\n \n     for (i, lhs) in lhses.iter().enumerate() { // try each arm's matchers\n-            let lhs_tt = match *lhs {\n-                TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n-                _ => panic!(cx.span_fatal(sp, \"malformed macro lhs\"))\n-            };\n+        let lhs_tt = match *lhs {\n+            TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n+            _ => panic!(cx.span_fatal(sp, \"malformed macro lhs\"))\n+        };\n \n-            match TokenTree::parse(cx, lhs_tt, arg) {\n-              Success(named_matches) => {\n+        match TokenTree::parse(cx, lhs_tt, arg) {\n+            Success(named_matches) => {\n                 let rhs = match rhses[i] {\n-                            // ignore delimiters\n-                            TokenTree::Delimited(_, ref delimed) => delimed.tts.clone(),\n-                            _ => panic!(cx.span_fatal(sp, \"macro rhs must be delimited\")),\n+                    // ignore delimiters\n+                    TokenTree::Delimited(_, ref delimed) => delimed.tts.clone(),\n+                    _ => panic!(cx.span_fatal(sp, \"macro rhs must be delimited\")),\n                 };\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n                 let trncbr = new_tt_reader(&cx.parse_sess().span_diagnostic,\n@@ -199,15 +199,15 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                     site_span: sp,\n                     macro_ident: name\n                 })\n-              }\n-              Failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n+            }\n+            Failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n                 best_fail_spot = sp;\n                 best_fail_msg = (*msg).clone();\n-              },\n-              Error(err_sp, ref msg) => {\n+            },\n+            Error(err_sp, ref msg) => {\n                 panic!(cx.span_fatal(err_sp.substitute_dummy(sp), &msg[..]))\n-              }\n             }\n+        }\n     }\n \n     panic!(cx.span_fatal(best_fail_spot.substitute_dummy(sp), &best_fail_msg[..]));\n@@ -310,14 +310,14 @@ fn check_lhs_nt_follows(cx: &mut ExtCtxt, lhs: &TokenTree, sp: Span) {\n     // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n     match lhs {\n-            &TokenTree::Delimited(_, ref tts) => {\n-                check_matcher(cx, tts.tts.iter(), &Eof);\n-            },\n-            tt @ &TokenTree::Sequence(..) => {\n-                check_matcher(cx, Some(tt).into_iter(), &Eof);\n-            },\n-            _ => cx.span_err(sp, \"Invalid macro matcher; matchers must be contained \\\n-               in balanced delimiters or a repetition indicator\")\n+        &TokenTree::Delimited(_, ref tts) => {\n+            check_matcher(cx, tts.tts.iter(), &Eof);\n+        },\n+        tt @ &TokenTree::Sequence(..) => {\n+            check_matcher(cx, Some(tt).into_iter(), &Eof);\n+        },\n+        _ => cx.span_err(sp, \"Invalid macro matcher; matchers must be contained \\\n+                              in balanced delimiters or a repetition indicator\")\n     };\n     // we don't abort on errors on rejection, the driver will do that for us\n     // after parsing/expansion. we can report every error in every macro this way."}]}