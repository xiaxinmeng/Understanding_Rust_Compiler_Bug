{"sha": "7f50e7ca8564489b888f23839687b1e076844a49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmNTBlN2NhODU2NDQ4OWI4ODhmMjM4Mzk2ODdiMWUwNzY4NDRhNDk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-09T15:56:20Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-20T19:04:52Z"}, "message": "extract the writeback code for anon types into InferCtxt\n\nNo functional change.", "tree": {"sha": "adf9ed0441866c8717a8ee8843a4bfe3a699bbd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adf9ed0441866c8717a8ee8843a4bfe3a699bbd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f50e7ca8564489b888f23839687b1e076844a49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f50e7ca8564489b888f23839687b1e076844a49", "html_url": "https://github.com/rust-lang/rust/commit/7f50e7ca8564489b888f23839687b1e076844a49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f50e7ca8564489b888f23839687b1e076844a49/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e64ba83beac81f38c5b473f9dbee924a03a3ea7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e64ba83beac81f38c5b473f9dbee924a03a3ea7", "html_url": "https://github.com/rust-lang/rust/commit/8e64ba83beac81f38c5b473f9dbee924a03a3ea7"}], "stats": {"total": 357, "additions": 225, "deletions": 132}, "files": [{"sha": "f163076218a853e6e17636d8d33f454d92724416", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 102, "deletions": 1, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/7f50e7ca8564489b888f23839687b1e076844a49/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f50e7ca8564489b888f23839687b1e076844a49/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=7f50e7ca8564489b888f23839687b1e076844a49", "patch": "@@ -11,12 +11,13 @@\n use hir::def_id::DefId;\n use infer::{self, InferCtxt, InferOk, TypeVariableOrigin};\n use infer::outlives::free_region_map::FreeRegionRelations;\n+use rustc_data_structures::fx::FxHashMap;\n use syntax::ast;\n use traits::{self, PredicateObligation};\n use ty::{self, Ty};\n use ty::fold::{BottomUpFolder, TypeFoldable};\n use ty::outlives::Component;\n-use ty::subst::Substs;\n+use ty::subst::{Kind, Substs};\n use util::nodemap::DefIdMap;\n \n pub type AnonTypeMap<'tcx> = DefIdMap<AnonTypeDecl<'tcx>>;\n@@ -375,6 +376,106 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n     }\n+\n+    /// Given the fully resolved, instantiated type for an anonymous\n+    /// type, i.e., the value of an inference variable like C1 or C2\n+    /// (*), computes the \"definition type\" for an abstract type\n+    /// definition -- that is, the inferred value of `Foo1<'x>` or\n+    /// `Foo2<'x>` that we would conceptually use in its definition:\n+    ///\n+    ///     abstract type Foo1<'x>: Bar<'x> = AAA; <-- this type AAA\n+    ///     abstract type Foo2<'x>: Bar<'x> = BBB; <-- or this type BBB\n+    ///     fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n+    ///\n+    /// Note that these values are defined in terms of a distinct set of\n+    /// generic parameters (`'x` instead of `'a`) from C1 or C2. The main\n+    /// purpose of this function is to do that translation.\n+    ///\n+    /// (*) C1 and C2 were introduced in the comments on\n+    /// `constrain_anon_types`. Read that comment for more context.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `def_id`, the `impl Trait` type\n+    /// - `anon_defn`, the anonymous definition created in `instantiate_anon_types`\n+    /// - `instantiated_ty`, the inferred type C1 -- fully resolved, lifted version of\n+    ///   `anon_defn.concrete_ty`\n+    pub fn infer_anon_definition_from_instantiation(\n+        &self,\n+        def_id: DefId,\n+        anon_defn: &AnonTypeDecl<'tcx>,\n+        instantiated_ty: Ty<'gcx>,\n+    ) -> Ty<'gcx> {\n+        debug!(\n+            \"infer_anon_definition_from_instantiation(instantiated_ty={:?})\",\n+            instantiated_ty\n+        );\n+\n+        let gcx = self.tcx.global_tcx();\n+\n+        // Use substs to build up a reverse map from regions to their\n+        // identity mappings. This is necessary because of `impl\n+        // Trait` lifetimes are computed by replacing existing\n+        // lifetimes with 'static and remapping only those used in the\n+        // `impl Trait` return type, resulting in the parameters\n+        // shifting.\n+        let id_substs = Substs::identity_for_item(gcx, def_id);\n+        let map: FxHashMap<Kind<'tcx>, Kind<'gcx>> = anon_defn\n+            .substs\n+            .iter()\n+            .enumerate()\n+            .map(|(index, subst)| (*subst, id_substs[index]))\n+            .collect();\n+\n+        // Convert the type from the function into a type valid outside\n+        // the function, by replacing invalid regions with 'static,\n+        // after producing an error for each of them.\n+        let definition_ty = gcx.fold_regions(&instantiated_ty, &mut false, |r, _| {\n+            match *r {\n+                // 'static and early-bound regions are valid.\n+                ty::ReStatic | ty::ReEmpty => r,\n+\n+                // All other regions, we map them appropriately to their adjusted\n+                // indices, erroring if we find any lifetimes that were not mapped\n+                // into the new set.\n+                _ => if let Some(r1) = map.get(&Kind::from(r)).and_then(|k| k.as_region()) {\n+                    r1\n+                } else {\n+                    // No mapping was found. This means that\n+                    // it is either a disallowed lifetime,\n+                    // which will be caught by regionck, or it\n+                    // is a region in a non-upvar closure\n+                    // generic, which is explicitly\n+                    // allowed. If that surprises you, read\n+                    // on.\n+                    //\n+                    // The case of closure is a somewhat\n+                    // subtle (read: hacky) consideration. The\n+                    // problem is that our closure types\n+                    // currently include all the lifetime\n+                    // parameters declared on the enclosing\n+                    // function, even if they are unused by\n+                    // the closure itself. We can't readily\n+                    // filter them out, so here we replace\n+                    // those values with `'empty`. This can't\n+                    // really make a difference to the rest of\n+                    // the compiler; those regions are ignored\n+                    // for the outlives relation, and hence\n+                    // don't affect trait selection or auto\n+                    // traits, and they are erased during\n+                    // trans.\n+                    gcx.types.re_empty\n+                },\n+            }\n+        });\n+\n+        debug!(\n+            \"infer_anon_definition_from_instantiation: definition_ty={:?}\",\n+            definition_ty\n+        );\n+\n+        definition_ty\n+    }\n }\n \n struct Instantiator<'a, 'gcx: 'tcx, 'tcx: 'a> {"}, {"sha": "29dc983ab560b9c09066f3c2bcf570013fba72d9", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 123, "deletions": 131, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/7f50e7ca8564489b888f23839687b1e076844a49/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f50e7ca8564489b888f23839687b1e076844a49/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=7f50e7ca8564489b888f23839687b1e076844a49", "patch": "@@ -15,12 +15,11 @@\n use check::FnCtxt;\n use rustc::hir;\n use rustc::hir::def_id::{DefId, DefIndex};\n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::infer::{InferCtxt};\n+use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc::infer::InferCtxt;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::fold::{TypeFolder, TypeFoldable};\n-use rustc::ty::subst::{Kind, Substs};\n-use rustc::util::nodemap::{DefIdSet, FxHashMap};\n+use rustc::ty::fold::{TypeFoldable, TypeFolder};\n+use rustc::util::nodemap::DefIdSet;\n use syntax::ast;\n use syntax_pos::Span;\n use std::mem;\n@@ -30,8 +29,7 @@ use std::rc::Rc;\n // Entry point\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn resolve_type_vars_in_body(&self, body: &'gcx hir::Body)\n-                                     -> &'gcx ty::TypeckTables<'gcx> {\n+    pub fn resolve_type_vars_in_body(&self, body: &'gcx hir::Body) -> &'gcx ty::TypeckTables<'gcx> {\n         let item_id = self.tcx.hir.body_owner(body.id());\n         let item_def_id = self.tcx.hir.local_def_id(item_id);\n \n@@ -48,14 +46,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_cast_types();\n         wbcx.visit_free_region_map();\n \n-        let used_trait_imports = mem::replace(&mut self.tables.borrow_mut().used_trait_imports,\n-                                              Rc::new(DefIdSet()));\n-        debug!(\"used_trait_imports({:?}) = {:?}\", item_def_id, used_trait_imports);\n+        let used_trait_imports = mem::replace(\n+            &mut self.tables.borrow_mut().used_trait_imports,\n+            Rc::new(DefIdSet()),\n+        );\n+        debug!(\n+            \"used_trait_imports({:?}) = {:?}\",\n+            item_def_id,\n+            used_trait_imports\n+        );\n         wbcx.tables.used_trait_imports = used_trait_imports;\n \n         wbcx.tables.tainted_by_errors = self.is_tainted_by_errors();\n \n-        debug!(\"writeback: tables for {:?} are {:#?}\", item_def_id, wbcx.tables);\n+        debug!(\n+            \"writeback: tables for {:?} are {:#?}\",\n+            item_def_id,\n+            wbcx.tables\n+        );\n \n         self.tcx.alloc_tables(wbcx.tables)\n     }\n@@ -69,7 +77,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n // there, it applies a few ad-hoc checks that were not convenient to\n // do elsewhere.\n \n-struct WritebackCx<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n+struct WritebackCx<'cx, 'gcx: 'cx + 'tcx, 'tcx: 'cx> {\n     fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>,\n \n     tables: ty::TypeckTables<'gcx>,\n@@ -78,9 +86,10 @@ struct WritebackCx<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n-    fn new(fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>, body: &'gcx hir::Body)\n-        -> WritebackCx<'cx, 'gcx, 'tcx>\n-    {\n+    fn new(\n+        fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>,\n+        body: &'gcx hir::Body,\n+    ) -> WritebackCx<'cx, 'gcx, 'tcx> {\n         let owner = fcx.tcx.hir.definitions().node_to_hir_id(body.id().node_id);\n \n         WritebackCx {\n@@ -95,7 +104,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn write_ty_to_tables(&mut self, hir_id: hir::HirId, ty: Ty<'gcx>) {\n-        debug!(\"write_ty_to_tables({:?}, {:?})\", hir_id,  ty);\n+        debug!(\"write_ty_to_tables({:?}, {:?})\", hir_id, ty);\n         assert!(!ty.needs_infer());\n         self.tables.node_types_mut().insert(hir_id, ty);\n     }\n@@ -106,8 +115,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     // operating on scalars, we clear the overload.\n     fn fix_scalar_builtin_expr(&mut self, e: &hir::Expr) {\n         match e.node {\n-            hir::ExprUnary(hir::UnNeg, ref inner) |\n-            hir::ExprUnary(hir::UnNot, ref inner)  => {\n+            hir::ExprUnary(hir::UnNeg, ref inner) | hir::ExprUnary(hir::UnNot, ref inner) => {\n                 let inner_ty = self.fcx.node_ty(inner.hir_id);\n                 let inner_ty = self.fcx.resolve_type_vars_if_possible(&inner_ty);\n \n@@ -117,8 +125,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                     tables.node_substs_mut().remove(e.hir_id);\n                 }\n             }\n-            hir::ExprBinary(ref op, ref lhs, ref rhs) |\n-            hir::ExprAssignOp(ref op, ref lhs, ref rhs) => {\n+            hir::ExprBinary(ref op, ref lhs, ref rhs)\n+            | hir::ExprAssignOp(ref op, ref lhs, ref rhs) => {\n                 let lhs_ty = self.fcx.node_ty(lhs.hir_id);\n                 let lhs_ty = self.fcx.resolve_type_vars_if_possible(&lhs_ty);\n \n@@ -137,15 +145,18 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                                 adjustments.get_mut(lhs.hir_id).map(|a| a.pop());\n                                 adjustments.get_mut(rhs.hir_id).map(|a| a.pop());\n                             }\n-                        },\n+                        }\n                         hir::ExprAssignOp(..) => {\n-                            tables.adjustments_mut().get_mut(lhs.hir_id).map(|a| a.pop());\n-                        },\n-                        _ => {},\n+                            tables\n+                                .adjustments_mut()\n+                                .get_mut(lhs.hir_id)\n+                                .map(|a| a.pop());\n+                        }\n+                        _ => {}\n                     }\n                 }\n             }\n-            _ => {},\n+            _ => {}\n         }\n     }\n }\n@@ -189,11 +200,11 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n         match p.node {\n             hir::PatKind::Binding(..) => {\n                 let bm = *self.fcx\n-                              .tables\n-                              .borrow()\n-                              .pat_binding_modes()\n-                              .get(p.hir_id)\n-                              .expect(\"missing binding mode\");\n+                    .tables\n+                    .borrow()\n+                    .pat_binding_modes()\n+                    .get(p.hir_id)\n+                    .expect(\"missing binding mode\");\n                 self.tables.pat_binding_modes_mut().insert(p.hir_id, bm);\n             }\n             _ => {}\n@@ -228,14 +239,20 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 ty::UpvarCapture::ByRef(ref upvar_borrow) => {\n                     let r = upvar_borrow.region;\n                     let r = self.resolve(&r, &upvar_id.var_id);\n-                    ty::UpvarCapture::ByRef(\n-                        ty::UpvarBorrow { kind: upvar_borrow.kind, region: r })\n+                    ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n+                        kind: upvar_borrow.kind,\n+                        region: r,\n+                    })\n                 }\n             };\n-            debug!(\"Upvar capture for {:?} resolved to {:?}\",\n-                   upvar_id,\n-                   new_upvar_capture);\n-            self.tables.upvar_capture_map.insert(*upvar_id, new_upvar_capture);\n+            debug!(\n+                \"Upvar capture for {:?} resolved to {:?}\",\n+                upvar_id,\n+                new_upvar_capture\n+            );\n+            self.tables\n+                .upvar_capture_map\n+                .insert(*upvar_id, new_upvar_capture);\n         }\n     }\n \n@@ -249,7 +266,9 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 owner: common_local_id_root.index,\n                 local_id: id,\n             };\n-            self.tables.closure_kind_origins_mut().insert(hir_id, origin);\n+            self.tables\n+                .closure_kind_origins_mut()\n+                .insert(hir_id, origin);\n         }\n     }\n \n@@ -270,7 +289,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_free_region_map(&mut self) {\n-        let free_region_map = self.tcx().lift_to_global(&self.fcx.tables.borrow().free_region_map);\n+        let free_region_map = self.tcx()\n+            .lift_to_global(&self.fcx.tables.borrow().free_region_map);\n         let free_region_map = free_region_map.expect(\"all regions in free-region-map are global\");\n         self.tables.free_region_map = free_region_map;\n     }\n@@ -279,77 +299,25 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         let gcx = self.tcx().global_tcx();\n         for (&def_id, anon_defn) in self.fcx.anon_types.borrow().iter() {\n             let node_id = gcx.hir.as_local_node_id(def_id).unwrap();\n-            let inside_ty = self.resolve(&anon_defn.concrete_ty, &node_id);\n-\n-            // Use substs to build up a reverse map from regions\n-            // to their identity mappings.\n-            // This is necessary because of `impl Trait` lifetimes\n-            // are computed by replacing existing lifetimes with 'static\n-            // and remapping only those used in the `impl Trait` return type,\n-            // resulting in the parameters shifting.\n-            let id_substs = Substs::identity_for_item(gcx, def_id);\n-            let map: FxHashMap<Kind<'tcx>, Kind<'gcx>> =\n-                anon_defn.substs\n-                         .iter()\n-                         .enumerate()\n-                         .map(|(index, subst)| (*subst, id_substs[index]))\n-                         .collect();\n-\n-            // Convert the type from the function into a type valid outside\n-            // the function, by replacing invalid regions with 'static,\n-            // after producing an error for each of them.\n-            let outside_ty = gcx.fold_regions(&inside_ty, &mut false, |r, _| {\n-                match *r {\n-                    // 'static and early-bound regions are valid.\n-                    ty::ReStatic |\n-                    ty::ReEmpty => r,\n-\n-                    // All other regions, we map them appropriately to their adjusted\n-                    // indices, erroring if we find any lifetimes that were not mapped\n-                    // into the new set.\n-                    _ => if let Some(r1) =\n-                            map.get(&Kind::from(r)).and_then(|k| k.as_region()) { r1 } else\n-                        {\n-                            // No mapping was found. This means that\n-                            // it is either a disallowed lifetime,\n-                            // which will be caught by regionck, or it\n-                            // is a region in a non-upvar closure\n-                            // generic, which is explicitly\n-                            // allowed. If that surprises you, read\n-                            // on.\n-                            //\n-                            // The case of closure is a somewhat\n-                            // subtle (read: hacky) consideration. The\n-                            // problem is that our closure types\n-                            // currently include all the lifetime\n-                            // parameters declared on the enclosing\n-                            // function, even if they are unused by\n-                            // the closure itself. We can't readily\n-                            // filter them out, so here we replace\n-                            // those values with `'empty`. This can't\n-                            // really make a difference to the rest of\n-                            // the compiler; those regions are ignored\n-                            // for the outlives relation, and hence\n-                            // don't affect trait selection or auto\n-                            // traits, and they are erased during\n-                            // trans.\n-                            gcx.types.re_empty\n-                        },\n-                }\n-            });\n-\n+            let instantiated_ty = self.resolve(&anon_defn.concrete_ty, &node_id);\n+            let definition_ty = self.fcx.infer_anon_definition_from_instantiation(\n+                def_id,\n+                anon_defn,\n+                instantiated_ty,\n+            );\n             let hir_id = self.tcx().hir.node_to_hir_id(node_id);\n-            self.tables.node_types_mut().insert(hir_id, outside_ty);\n+            self.tables.node_types_mut().insert(hir_id, definition_ty);\n         }\n     }\n \n     fn visit_node_id(&mut self, span: Span, hir_id: hir::HirId) {\n         // Export associated path extensions and method resultions.\n         if let Some(def) = self.fcx\n-                               .tables\n-                               .borrow_mut()\n-                               .type_dependent_defs_mut()\n-                               .remove(hir_id) {\n+            .tables\n+            .borrow_mut()\n+            .type_dependent_defs_mut()\n+            .remove(hir_id)\n+        {\n             self.tables.type_dependent_defs_mut().insert(hir_id, def);\n         }\n \n@@ -373,38 +341,50 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n     fn visit_adjustments(&mut self, span: Span, hir_id: hir::HirId) {\n         let adjustment = self.fcx\n-                             .tables\n-                             .borrow_mut()\n-                             .adjustments_mut()\n-                             .remove(hir_id);\n+            .tables\n+            .borrow_mut()\n+            .adjustments_mut()\n+            .remove(hir_id);\n         match adjustment {\n             None => {\n                 debug!(\"No adjustments for node {:?}\", hir_id);\n             }\n \n             Some(adjustment) => {\n                 let resolved_adjustment = self.resolve(&adjustment, &span);\n-                debug!(\"Adjustments for node {:?}: {:?}\", hir_id, resolved_adjustment);\n-                self.tables.adjustments_mut().insert(hir_id, resolved_adjustment);\n+                debug!(\n+                    \"Adjustments for node {:?}: {:?}\",\n+                    hir_id,\n+                    resolved_adjustment\n+                );\n+                self.tables\n+                    .adjustments_mut()\n+                    .insert(hir_id, resolved_adjustment);\n             }\n         }\n     }\n \n     fn visit_pat_adjustments(&mut self, span: Span, hir_id: hir::HirId) {\n         let adjustment = self.fcx\n-                             .tables\n-                             .borrow_mut()\n-                             .pat_adjustments_mut()\n-                             .remove(hir_id);\n+            .tables\n+            .borrow_mut()\n+            .pat_adjustments_mut()\n+            .remove(hir_id);\n         match adjustment {\n             None => {\n                 debug!(\"No pat_adjustments for node {:?}\", hir_id);\n             }\n \n             Some(adjustment) => {\n                 let resolved_adjustment = self.resolve(&adjustment, &span);\n-                debug!(\"pat_adjustments for node {:?}: {:?}\", hir_id, resolved_adjustment);\n-                self.tables.pat_adjustments_mut().insert(hir_id, resolved_adjustment);\n+                debug!(\n+                    \"pat_adjustments for node {:?}: {:?}\",\n+                    hir_id,\n+                    resolved_adjustment\n+                );\n+                self.tables\n+                    .pat_adjustments_mut()\n+                    .insert(hir_id, resolved_adjustment);\n             }\n         }\n     }\n@@ -420,7 +400,9 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 local_id,\n             };\n             let fn_sig = self.resolve(fn_sig, &hir_id);\n-            self.tables.liberated_fn_sigs_mut().insert(hir_id, fn_sig.clone());\n+            self.tables\n+                .liberated_fn_sigs_mut()\n+                .insert(hir_id, fn_sig.clone());\n         }\n     }\n \n@@ -440,15 +422,18 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn resolve<T>(&self, x: &T, span: &Locatable) -> T::Lifted\n-        where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n+    where\n+        T: TypeFoldable<'tcx> + ty::Lift<'gcx>,\n     {\n         let x = x.fold_with(&mut Resolver::new(self.fcx, span, self.body));\n         if let Some(lifted) = self.tcx().lift_to_global(&x) {\n             lifted\n         } else {\n-            span_bug!(span.to_span(&self.fcx.tcx),\n-                      \"writeback: `{:?}` missing from the global type context\",\n-                      x);\n+            span_bug!(\n+                span.to_span(&self.fcx.tcx),\n+                \"writeback: `{:?}` missing from the global type context\",\n+                x\n+            );\n         }\n     }\n }\n@@ -458,11 +443,15 @@ trait Locatable {\n }\n \n impl Locatable for Span {\n-    fn to_span(&self, _: &TyCtxt) -> Span { *self }\n+    fn to_span(&self, _: &TyCtxt) -> Span {\n+        *self\n+    }\n }\n \n impl Locatable for ast::NodeId {\n-    fn to_span(&self, tcx: &TyCtxt) -> Span { tcx.hir.span(*self) }\n+    fn to_span(&self, tcx: &TyCtxt) -> Span {\n+        tcx.hir.span(*self)\n+    }\n }\n \n impl Locatable for DefIndex {\n@@ -483,17 +472,19 @@ impl Locatable for hir::HirId {\n // The Resolver. This is the type folding engine that detects\n // unresolved types and so forth.\n \n-struct Resolver<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n+struct Resolver<'cx, 'gcx: 'cx + 'tcx, 'tcx: 'cx> {\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n     span: &'cx Locatable,\n     body: &'gcx hir::Body,\n }\n \n impl<'cx, 'gcx, 'tcx> Resolver<'cx, 'gcx, 'tcx> {\n-    fn new(fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>, span: &'cx Locatable, body: &'gcx hir::Body)\n-        -> Resolver<'cx, 'gcx, 'tcx>\n-    {\n+    fn new(\n+        fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>,\n+        span: &'cx Locatable,\n+        body: &'gcx hir::Body,\n+    ) -> Resolver<'cx, 'gcx, 'tcx> {\n         Resolver {\n             tcx: fcx.tcx,\n             infcx: fcx,\n@@ -504,7 +495,8 @@ impl<'cx, 'gcx, 'tcx> Resolver<'cx, 'gcx, 'tcx> {\n \n     fn report_error(&self, t: Ty<'tcx>) {\n         if !self.tcx.sess.has_errors() {\n-            self.infcx.need_type_info(Some(self.body.id()), self.span.to_span(&self.tcx), t);\n+            self.infcx\n+                .need_type_info(Some(self.body.id()), self.span.to_span(&self.tcx), t);\n         }\n     }\n }\n@@ -518,8 +510,10 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Resolver<'cx, 'gcx, 'tcx> {\n         match self.infcx.fully_resolve(&t) {\n             Ok(t) => t,\n             Err(_) => {\n-                debug!(\"Resolver::fold_ty: input type `{:?}` not fully resolvable\",\n-                       t);\n+                debug!(\n+                    \"Resolver::fold_ty: input type `{:?}` not fully resolvable\",\n+                    t\n+                );\n                 self.report_error(t);\n                 self.tcx().types.err\n             }\n@@ -531,9 +525,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Resolver<'cx, 'gcx, 'tcx> {\n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match self.infcx.fully_resolve(&r) {\n             Ok(r) => r,\n-            Err(_) => {\n-                self.tcx.types.re_static\n-            }\n+            Err(_) => self.tcx.types.re_static,\n         }\n     }\n }"}]}