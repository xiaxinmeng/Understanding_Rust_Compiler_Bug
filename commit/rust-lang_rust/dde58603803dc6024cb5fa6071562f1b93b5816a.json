{"sha": "dde58603803dc6024cb5fa6071562f1b93b5816a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkZTU4NjAzODAzZGM2MDI0Y2I1ZmE2MDcxNTYyZjFiOTNiNTgxNmE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-12-15T02:04:45Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-12-15T02:04:45Z"}, "message": "Remove some duplicated unused parts of std now that they're present in core.", "tree": {"sha": "078eeb8efdc18e0796d667409ceb33be30abff43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/078eeb8efdc18e0796d667409ceb33be30abff43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dde58603803dc6024cb5fa6071562f1b93b5816a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dde58603803dc6024cb5fa6071562f1b93b5816a", "html_url": "https://github.com/rust-lang/rust/commit/dde58603803dc6024cb5fa6071562f1b93b5816a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dde58603803dc6024cb5fa6071562f1b93b5816a/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7540b165cfe800ff5bfd2be22cc08510d4d03eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7540b165cfe800ff5bfd2be22cc08510d4d03eb", "html_url": "https://github.com/rust-lang/rust/commit/f7540b165cfe800ff5bfd2be22cc08510d4d03eb"}], "stats": {"total": 3939, "additions": 3, "deletions": 3936}, "files": [{"sha": "0fc869d1b41a93b0b8077bcc30ce0a12a375cf93", "filename": "src/libstd/bool.rs", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=f7540b165cfe800ff5bfd2be22cc08510d4d03eb", "patch": "@@ -1,134 +0,0 @@\n-// -*- rust -*-\n-\n-/*\n-Module: bool\n-\n-Classic Boolean logic reified as ADT\n-*/\n-\n-export t;\n-export not, and, or, xor, implies;\n-export eq, ne, is_true, is_false;\n-export from_str, to_str, all_values, to_bit;\n-\n-/*\n-Type: t\n-\n-The type of boolean logic values\n-*/\n-type t = bool;\n-\n-/* Function: not\n-\n-Negation/Inverse\n-*/\n-pure fn not(v: t) -> t { !v }\n-\n-/* Function: and\n-\n-Conjunction\n-*/\n-pure fn and(a: t, b: t) -> t { a && b }\n-\n-/* Function: or\n-\n-Disjunction\n-*/\n-pure fn or(a: t, b: t) -> t { a || b }\n-\n-/*\n-Function: xor\n-\n-Exclusive or, i.e. `or(and(a, not(b)), and(not(a), b))`\n-*/\n-pure fn xor(a: t, b: t) -> t { (a && !b) || (!a && b) }\n-\n-/*\n-Function: implies\n-\n-Implication in the logic, i.e. from `a` follows `b`\n-*/\n-pure fn implies(a: t, b: t) -> t { !a || b }\n-\n-/*\n-Predicate: eq\n-\n-Returns:\n-\n-true if truth values `a` and `b` are indistinguishable in the logic\n-*/\n-pure fn eq(a: t, b: t) -> bool { a == b }\n-\n-/*\n-Predicate: ne\n-\n-Returns:\n-\n-true if truth values `a` and `b` are distinguishable in the logic\n-*/\n-pure fn ne(a: t, b: t) -> bool { a != b }\n-\n-/*\n-Predicate: is_true\n-\n-Returns:\n-\n-true if `v` represents truth in the logic\n-*/\n-pure fn is_true(v: t) -> bool { v }\n-\n-/*\n-Predicate: is_false\n-\n-Returns:\n-\n-true if `v` represents falsehood in the logic\n-*/\n-pure fn is_false(v: t) -> bool { !v }\n-\n-/*\n-Function: from_str\n-\n-Parse logic value from `s`\n-*/\n-pure fn from_str(s: str) -> t {\n-    alt s {\n-      \"true\" { true }\n-      \"false\" { false }\n-    }\n-}\n-\n-/*\n-Function: to_str\n-\n-Convert `v` into a string\n-*/\n-pure fn to_str(v: t) -> str { if v { \"true\" } else { \"false\" } }\n-\n-/*\n-Function: all_values\n-\n-Iterates over all truth values by passing them to `blk`\n-in an unspecified order\n-*/\n-fn all_values(blk: block(v: t)) {\n-    blk(true);\n-    blk(false);\n-}\n-\n-/*\n-Function: to_bit\n-\n-Returns:\n-\n-An u8 whose first bit is set if `if_true(v)` holds\n-*/\n-fn to_bit(v: t) -> u8 { if v { 1u8 } else { 0u8 } }\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "6682fe17284ac429a2000635d04d02b418d8327f", "filename": "src/libstd/box.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbox.rs?ref=f7540b165cfe800ff5bfd2be22cc08510d4d03eb", "patch": "@@ -1,20 +0,0 @@\n-/*\n-Module: box\n-*/\n-\n-\n-export ptr_eq;\n-\n-/*\n-Function: ptr_eq\n-\n-Determine if two shared boxes point to the same object\n-*/\n-fn ptr_eq<T>(a: @T, b: @T) -> bool {\n-    // FIXME: ptr::addr_of\n-    unsafe {\n-        let a_ptr: uint = unsafe::reinterpret_cast(a);\n-        let b_ptr: uint = unsafe::reinterpret_cast(b);\n-        ret a_ptr == b_ptr;\n-    }\n-}"}, {"sha": "5ff7681ae8ab484dc377d2f71541d5dcc24d283a", "filename": "src/libstd/char.rs", "status": "removed", "additions": 0, "deletions": 150, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=f7540b165cfe800ff5bfd2be22cc08510d4d03eb", "patch": "@@ -1,150 +0,0 @@\n-/*\n-Module: char\n-\n-Utilities for manipulating the char type\n-*/\n-\n-/*\n-Function: is_whitespace\n-\n-Indicates whether a character is whitespace.\n-\n-Whitespace characters include space (U+0020), tab (U+0009), line feed\n-(U+000A), carriage return (U+000D), and a number of less common\n-ASCII and unicode characters.\n-*/\n-pure fn is_whitespace(c: char) -> bool {\n-    const ch_space: char = '\\u0020';\n-    const ch_ogham_space_mark: char = '\\u1680';\n-    const ch_mongolian_vowel_sep: char = '\\u180e';\n-    const ch_en_quad: char = '\\u2000';\n-    const ch_em_quad: char = '\\u2001';\n-    const ch_en_space: char = '\\u2002';\n-    const ch_em_space: char = '\\u2003';\n-    const ch_three_per_em_space: char = '\\u2004';\n-    const ch_four_per_em_space: char = '\\u2005';\n-    const ch_six_per_em_space: char = '\\u2006';\n-    const ch_figure_space: char = '\\u2007';\n-    const ch_punctuation_space: char = '\\u2008';\n-    const ch_thin_space: char = '\\u2009';\n-    const ch_hair_space: char = '\\u200a';\n-    const ch_narrow_no_break_space: char = '\\u202f';\n-    const ch_medium_mathematical_space: char = '\\u205f';\n-    const ch_ideographic_space: char = '\\u3000';\n-    const ch_line_separator: char = '\\u2028';\n-    const ch_paragraph_separator: char = '\\u2029';\n-    const ch_character_tabulation: char = '\\u0009';\n-    const ch_line_feed: char = '\\u000a';\n-    const ch_line_tabulation: char = '\\u000b';\n-    const ch_form_feed: char = '\\u000c';\n-    const ch_carriage_return: char = '\\u000d';\n-    const ch_next_line: char = '\\u0085';\n-    const ch_no_break_space: char = '\\u00a0';\n-\n-    if c == ch_space {\n-        true\n-    } else if c == ch_ogham_space_mark {\n-        true\n-    } else if c == ch_mongolian_vowel_sep {\n-        true\n-    } else if c == ch_en_quad {\n-        true\n-    } else if c == ch_em_quad {\n-        true\n-    } else if c == ch_en_space {\n-        true\n-    } else if c == ch_em_space {\n-        true\n-    } else if c == ch_three_per_em_space {\n-        true\n-    } else if c == ch_four_per_em_space {\n-        true\n-    } else if c == ch_six_per_em_space {\n-        true\n-    } else if c == ch_figure_space {\n-        true\n-    } else if c == ch_punctuation_space {\n-        true\n-    } else if c == ch_thin_space {\n-        true\n-    } else if c == ch_hair_space {\n-        true\n-    } else if c == ch_narrow_no_break_space {\n-        true\n-    } else if c == ch_medium_mathematical_space {\n-        true\n-    } else if c == ch_ideographic_space {\n-        true\n-    } else if c == ch_line_tabulation {\n-        true\n-    } else if c == ch_paragraph_separator {\n-        true\n-    } else if c == ch_character_tabulation {\n-        true\n-    } else if c == ch_line_feed {\n-        true\n-    } else if c == ch_line_tabulation {\n-        true\n-    } else if c == ch_form_feed {\n-        true\n-    } else if c == ch_carriage_return {\n-        true\n-    } else if c == ch_next_line {\n-        true\n-    } else if c == ch_no_break_space { true } else { false }\n-}\n-\n-/*\n- Function: to_digit\n-\n- Convert a char to the corresponding digit.\n-\n- Parameters:\n-   c - a char, either '0' to '9', 'a' to 'z' or 'A' to 'Z'\n-\n- Returns:\n-   If `c` is between '0' and '9', the corresponding value between 0 and 9.\n- If `c` is 'a' or 'A', 10. If `c` is 'b' or 'B', 11, etc.\n-\n- Safety note:\n-   This function fails if `c` is not a valid char\n-*/\n-pure fn to_digit(c: char) -> u8 unsafe {\n-    alt maybe_digit(c) {\n-      option::some(x) { x }\n-      option::none. { fail; }\n-    }\n-}\n-\n-/*\n- Function: to_digit\n-\n- Convert a char to the corresponding digit. Returns none when the\n- character is not a valid hexadecimal digit.\n-*/\n-fn maybe_digit(c: char) -> option::t<u8> {\n-    alt c {\n-      '0' to '9' { option::some(c as u8 - ('0' as u8)) }\n-      'a' to 'z' { option::some(c as u8 + 10u8 - ('a' as u8)) }\n-      'A' to 'Z' { option::some(c as u8 + 10u8 - ('A' as u8)) }\n-      _ { option::none }\n-    }\n-}\n-\n-/*\n- Function: cmp\n-\n- Compare two chars.\n-\n- Parameters:\n-  a - a char\n-  b - a char\n-\n- Returns:\n-  -1 if a<b, 0 if a==b, +1 if a>b\n-*/\n-fn cmp(a: char, b: char) -> int {\n-    ret  if b > a { -1 }\n-    else if b < a { 1 }\n-    else { 0 }\n-}\n\\ No newline at end of file"}, {"sha": "89d47b20746a0c9d6f2a58a5595e5f273f73d893", "filename": "src/libstd/either.rs", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=f7540b165cfe800ff5bfd2be22cc08510d4d03eb", "patch": "@@ -1,89 +0,0 @@\n-/*\n-Module: either\n-\n-A type that represents one of two alternatives\n-*/\n-\n-\n-/*\n-Tag: t\n-\n-The either type\n-*/\n-tag t<T, U> {\n-    /* Variant: left */\n-    left(T);\n-    /* Variant: right */\n-    right(U);\n-}\n-\n-/* Section: Operations */\n-\n-/*\n-Function: either\n-\n-Applies a function based on the given either value\n-\n-If `value` is left(T) then `f_left` is applied to its contents, if\n-`value` is right(U) then `f_right` is applied to its contents, and\n-the result is returned.\n-*/\n-fn either<T, U,\n-          V>(f_left: block(T) -> V, f_right: block(U) -> V, value: t<T, U>) ->\n-   V {\n-    alt value { left(l) { f_left(l) } right(r) { f_right(r) } }\n-}\n-\n-/*\n-Function: lefts\n-\n-Extracts from a vector of either all the left values.\n-*/\n-fn lefts<copy T, U>(eithers: [t<T, U>]) -> [T] {\n-    let result: [T] = [];\n-    for elt: t<T, U> in eithers {\n-        alt elt { left(l) { result += [l]; } _ {/* fallthrough */ } }\n-    }\n-    ret result;\n-}\n-\n-/*\n-Function: rights\n-\n-Extracts from a vector of either all the right values\n-*/\n-fn rights<T, copy U>(eithers: [t<T, U>]) -> [U] {\n-    let result: [U] = [];\n-    for elt: t<T, U> in eithers {\n-        alt elt { right(r) { result += [r]; } _ {/* fallthrough */ } }\n-    }\n-    ret result;\n-}\n-\n-/*\n-Function: partition\n-\n-Extracts from a vector of either all the left values and right values\n-\n-Returns a structure containing a vector of left values and a vector of\n-right values.\n-*/\n-fn partition<copy T, copy U>(eithers: [t<T, U>])\n-    -> {lefts: [T], rights: [U]} {\n-    let lefts: [T] = [];\n-    let rights: [U] = [];\n-    for elt: t<T, U> in eithers {\n-        alt elt { left(l) { lefts += [l]; } right(r) { rights += [r]; } }\n-    }\n-    ret {lefts: lefts, rights: rights};\n-}\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "015dceb1dc1c0caf3c30229c40228447ddf60837", "filename": "src/libstd/float.rs", "status": "removed", "additions": 0, "deletions": 343, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffloat.rs?ref=f7540b165cfe800ff5bfd2be22cc08510d4d03eb", "patch": "@@ -1,343 +0,0 @@\n-/*\n-Module: float\n-*/\n-\n-/**\n- * Section: String Conversions\n- */\n-\n-/*\n-Function: to_str_common\n-\n-Converts a float to a string\n-\n-Parameters:\n-\n-num - The float value\n-digits - The number of significant digits\n-exact - Whether to enforce the exact number of significant digits\n-*/\n-fn to_str_common(num: float, digits: uint, exact: bool) -> str {\n-    let (num, accum) = num < 0.0 ? (-num, \"-\") : (num, \"\");\n-    let trunc = num as uint;\n-    let frac = num - (trunc as float);\n-    accum += uint::str(trunc);\n-    if frac == 0.0 || digits == 0u { ret accum; }\n-    accum += \".\";\n-    let i = digits;\n-    let epsilon = 1. / pow_uint_to_uint_as_float(10u, i);\n-    while i > 0u && (frac >= epsilon || exact) {\n-        frac *= 10.0;\n-        epsilon *= 10.0;\n-        let digit = frac as uint;\n-        accum += uint::str(digit);\n-        frac -= digit as float;\n-        i -= 1u;\n-    }\n-    ret accum;\n-\n-}\n-\n-/*\n-Function: to_str\n-\n-Converts a float to a string with exactly the number of provided significant\n-digits\n-\n-Parameters:\n-\n-num - The float value\n-digits - The number of significant digits\n-*/\n-fn to_str_exact(num: float, digits: uint) -> str {\n-    to_str_common(num, digits, true)\n-}\n-\n-/*\n-Function: to_str\n-\n-Converts a float to a string with a maximum number of significant digits\n-\n-Parameters:\n-\n-num - The float value\n-digits - The number of significant digits\n-*/\n-fn to_str(num: float, digits: uint) -> str {\n-    to_str_common(num, digits, false)\n-}\n-\n-/*\n-Function: from_str\n-\n-Convert a string to a float\n-\n-This function accepts strings such as\n-* \"3.14\"\n-* \"+3.14\", equivalent to \"3.14\"\n-* \"-3.14\"\n-* \"2.5E10\", or equivalently, \"2.5e10\"\n-* \"2.5E-10\"\n-* \"\", or, equivalently, \".\" (understood as 0)\n-* \"5.\"\n-* \".5\", or, equivalently,  \"0.5\"\n-\n-Leading and trailing whitespace are ignored.\n-\n-Parameters:\n-\n-num - A string, possibly empty.\n-\n-Returns:\n-\n-<NaN> If the string did not represent a valid number.\n-Otherwise, the floating-point number represented [num].\n-*/\n-fn from_str(num: str) -> float {\n-   let num = str::trim(num);\n-\n-   let pos = 0u;                  //Current byte position in the string.\n-                                  //Used to walk the string in O(n).\n-   let len = str::byte_len(num);  //Length of the string, in bytes.\n-\n-   if len == 0u { ret 0.; }\n-   let total = 0f;                //Accumulated result\n-   let c     = 'z';               //Latest char.\n-\n-   //The string must start with one of the following characters.\n-   alt str::char_at(num, 0u) {\n-      '-' | '+' | '0' to '9' | '.' {}\n-      _ { ret NaN; }\n-   }\n-\n-   //Determine if first char is '-'/'+'. Set [pos] and [neg] accordingly.\n-   let neg = false;               //Sign of the result\n-   alt str::char_at(num, 0u) {\n-      '-' {\n-          neg = true;\n-          pos = 1u;\n-      }\n-      '+' {\n-          pos = 1u;\n-      }\n-      _ {}\n-   }\n-\n-   //Examine the following chars until '.', 'e', 'E'\n-   while(pos < len) {\n-       let char_range = str::char_range_at(num, pos);\n-       c   = char_range.ch;\n-       pos = char_range.next;\n-       alt c {\n-         '0' to '9' {\n-           total = total * 10f;\n-           total += ((c as int) - ('0' as int)) as float;\n-         }\n-         '.' | 'e' | 'E' {\n-           break;\n-         }\n-         _ {\n-           ret NaN;\n-         }\n-       }\n-   }\n-\n-   if c == '.' {//Examine decimal part\n-      let decimal = 1.f;\n-      while(pos < len) {\n-         let char_range = str::char_range_at(num, pos);\n-         c = char_range.ch;\n-         pos = char_range.next;\n-         alt c {\n-            '0' | '1' | '2' | '3' | '4' | '5' | '6'| '7' | '8' | '9'  {\n-                 decimal /= 10.f;\n-                 total += (((c as int) - ('0' as int)) as float)*decimal;\n-             }\n-             'e' | 'E' {\n-                 break;\n-             }\n-             _ {\n-                 ret NaN;\n-             }\n-         }\n-      }\n-   }\n-\n-   if (c == 'e') | (c == 'E') {//Examine exponent\n-      let exponent = 0u;\n-      let neg_exponent = false;\n-      if(pos < len) {\n-          let char_range = str::char_range_at(num, pos);\n-          c   = char_range.ch;\n-          alt c  {\n-             '+' {\n-                pos = char_range.next;\n-             }\n-             '-' {\n-                pos = char_range.next;\n-                neg_exponent = true;\n-             }\n-             _ {}\n-          }\n-          while(pos < len) {\n-             let char_range = str::char_range_at(num, pos);\n-             c = char_range.ch;\n-             alt c {\n-                 '0' | '1' | '2' | '3' | '4' | '5' | '6'| '7' | '8' | '9' {\n-                     exponent *= 10u;\n-                     exponent += ((c as uint) - ('0' as uint));\n-                 }\n-                 _ {\n-                     break;\n-                 }\n-             }\n-             pos = char_range.next;\n-          }\n-          let multiplier = pow_uint_to_uint_as_float(10u, exponent);\n-              //Note: not [int::pow], otherwise, we'll quickly\n-              //end up with a nice overflow\n-          if neg_exponent {\n-             total = total / multiplier;\n-          } else {\n-             total = total * multiplier;\n-          }\n-      } else {\n-         ret NaN;\n-      }\n-   }\n-\n-   if(pos < len) {\n-     ret NaN;\n-   } else {\n-     if(neg) {\n-        total *= -1f;\n-     }\n-     ret total;\n-   }\n-}\n-\n-/**\n- * Section: Arithmetics\n- */\n-\n-/*\n-Function: pow_uint_to_uint_as_float\n-\n-Compute the exponentiation of an integer by another integer as a float.\n-\n-Parameters:\n-x - The base.\n-pow - The exponent.\n-\n-Returns:\n-<NaN> of both `x` and `pow` are `0u`, otherwise `x^pow`.\n-*/\n-fn pow_uint_to_uint_as_float(x: uint, pow: uint) -> float {\n-   if x == 0u {\n-      if pow == 0u {\n-        ret NaN;\n-      }\n-       ret 0.;\n-   }\n-   let my_pow     = pow;\n-   let total      = 1f;\n-   let multiplier = x as float;\n-   while (my_pow > 0u) {\n-     if my_pow % 2u == 1u {\n-       total = total * multiplier;\n-     }\n-     my_pow     /= 2u;\n-     multiplier *= multiplier;\n-   }\n-   ret total;\n-}\n-\n-\n-/* Const: NaN */\n-const NaN: float = 0./0.;\n-\n-/* Const: infinity */\n-const infinity: float = 1./0.;\n-\n-/* Const: neg_infinity */\n-const neg_infinity: float = -1./0.;\n-\n-/* Predicate: isNaN */\n-pure fn isNaN(f: float) -> bool { f != f }\n-\n-/* Function: add */\n-pure fn add(x: float, y: float) -> float { ret x + y; }\n-\n-/* Function: sub */\n-pure fn sub(x: float, y: float) -> float { ret x - y; }\n-\n-/* Function: mul */\n-pure fn mul(x: float, y: float) -> float { ret x * y; }\n-\n-/* Function: div */\n-pure fn div(x: float, y: float) -> float { ret x / y; }\n-\n-/* Function: rem */\n-pure fn rem(x: float, y: float) -> float { ret x % y; }\n-\n-/* Predicate: lt */\n-pure fn lt(x: float, y: float) -> bool { ret x < y; }\n-\n-/* Predicate: le */\n-pure fn le(x: float, y: float) -> bool { ret x <= y; }\n-\n-/* Predicate: eq */\n-pure fn eq(x: float, y: float) -> bool { ret x == y; }\n-\n-/* Predicate: ne */\n-pure fn ne(x: float, y: float) -> bool { ret x != y; }\n-\n-/* Predicate: ge */\n-pure fn ge(x: float, y: float) -> bool { ret x >= y; }\n-\n-/* Predicate: gt */\n-pure fn gt(x: float, y: float) -> bool { ret x > y; }\n-\n-/*\n-Predicate: positive\n-\n-Returns true if `x` is a positive number, including +0.0 and +Infinity.\n- */\n-pure fn positive(x: float) -> bool { ret x > 0. || (1./x) == infinity; }\n-\n-/*\n-Predicate: negative\n-\n-Returns true if `x` is a negative number, including -0.0 and -Infinity.\n- */\n-pure fn negative(x: float) -> bool { ret x < 0. || (1./x) == neg_infinity; }\n-\n-/*\n-Predicate: nonpositive\n-\n-Returns true if `x` is a negative number, including -0.0 and -Infinity.\n-(This is the same as `float::negative`.)\n-*/\n-pure fn nonpositive(x: float) -> bool {\n-  ret x < 0. || (1./x) == neg_infinity;\n-}\n-\n-/*\n-Predicate: nonnegative\n-\n-Returns true if `x` is a positive number, including +0.0 and +Infinity.\n-(This is the same as `float::positive`.)\n-*/\n-pure fn nonnegative(x: float) -> bool {\n-  ret x > 0. || (1./x) == infinity;\n-}\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "2ab299800adf52589ff11e1d65c277ff4e75f369", "filename": "src/libstd/int.rs", "status": "removed", "additions": 0, "deletions": 189, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fint.rs?ref=f7540b165cfe800ff5bfd2be22cc08510d4d03eb", "patch": "@@ -1,189 +0,0 @@\n-/*\n-Module: int\n-*/\n-\n-/*\n-Const: max_value\n-\n-The maximum value of an integer\n-*/\n-// FIXME: Find another way to access the machine word size in a const expr\n-#[cfg(target_arch=\"x86\")]\n-const max_value: int = (-1 << 31)-1;\n-\n-#[cfg(target_arch=\"x86_64\")]\n-const max_value: int = (-1 << 63)-1;\n-\n-/*\n-Const: min_value\n-\n-The minumum value of an integer\n-*/\n-#[cfg(target_arch=\"x86\")]\n-const min_value: int = -1 << 31;\n-\n-#[cfg(target_arch=\"x86_64\")]\n-const min_value: int = -1 << 63;\n-\n-/* Function: add */\n-pure fn add(x: int, y: int) -> int { ret x + y; }\n-\n-/* Function: sub */\n-pure fn sub(x: int, y: int) -> int { ret x - y; }\n-\n-/* Function: mul */\n-pure fn mul(x: int, y: int) -> int { ret x * y; }\n-\n-/* Function: div */\n-pure fn div(x: int, y: int) -> int { ret x / y; }\n-\n-/* Function: rem */\n-pure fn rem(x: int, y: int) -> int { ret x % y; }\n-\n-/* Predicate: lt */\n-pure fn lt(x: int, y: int) -> bool { ret x < y; }\n-\n-/* Predicate: le */\n-pure fn le(x: int, y: int) -> bool { ret x <= y; }\n-\n-/* Predicate: eq */\n-pure fn eq(x: int, y: int) -> bool { ret x == y; }\n-\n-/* Predicate: ne */\n-pure fn ne(x: int, y: int) -> bool { ret x != y; }\n-\n-/* Predicate: ge */\n-pure fn ge(x: int, y: int) -> bool { ret x >= y; }\n-\n-/* Predicate: gt */\n-pure fn gt(x: int, y: int) -> bool { ret x > y; }\n-\n-/* Predicate: positive */\n-pure fn positive(x: int) -> bool { ret x > 0; }\n-\n-/* Predicate: negative */\n-pure fn negative(x: int) -> bool { ret x < 0; }\n-\n-/* Predicate: nonpositive */\n-pure fn nonpositive(x: int) -> bool { ret x <= 0; }\n-\n-/* Predicate: nonnegative */\n-pure fn nonnegative(x: int) -> bool { ret x >= 0; }\n-\n-\n-// FIXME: Make sure this works with negative integers.\n-/*\n-Function: hash\n-\n-Produce a uint suitable for use in a hash table\n-*/\n-fn hash(x: int) -> uint { ret x as uint; }\n-\n-/*\n-Function: range\n-\n-Iterate over the range [`lo`..`hi`)\n-*/\n-fn range(lo: int, hi: int, it: block(int)) {\n-    let i = lo;\n-    while i < hi { it(i); i += 1; }\n-}\n-\n-/*\n-Function: parse_buf\n-\n-Parse a buffer of bytes\n-\n-Parameters:\n-\n-buf - A byte buffer\n-radix - The base of the number\n-\n-Failure:\n-\n-buf must not be empty\n-*/\n-fn parse_buf(buf: [u8], radix: uint) -> int {\n-    if vec::len::<u8>(buf) == 0u {\n-        log_err \"parse_buf(): buf is empty\";\n-        fail;\n-    }\n-    let i = vec::len::<u8>(buf) - 1u;\n-    let start = 0u;\n-    let power = 1;\n-\n-    if buf[0] == ('-' as u8) {\n-        power = -1;\n-        start = 1u;\n-    }\n-    let n = 0;\n-    while true {\n-        let digit = char::to_digit(buf[i] as char);\n-        if (digit as uint) >= radix {\n-            fail;\n-        }\n-        n += (digit as int) * power;\n-        power *= radix as int;\n-        if i <= start { ret n; }\n-        i -= 1u;\n-    }\n-    fail;\n-}\n-\n-/*\n-Function: from_str\n-\n-Parse a string to an int\n-\n-Failure:\n-\n-s must not be empty\n-*/\n-fn from_str(s: str) -> int { parse_buf(str::bytes(s), 10u) }\n-\n-/*\n-Function: to_str\n-\n-Convert to a string in a given base\n-*/\n-fn to_str(n: int, radix: uint) -> str {\n-    assert (0u < radix && radix <= 16u);\n-    ret if n < 0 {\n-            \"-\" + uint::to_str(-n as uint, radix)\n-        } else { uint::to_str(n as uint, radix) };\n-}\n-\n-/*\n-Function: str\n-\n-Convert to a string\n-*/\n-fn str(i: int) -> str { ret to_str(i, 10u); }\n-\n-/*\n-Function: pow\n-\n-Returns `base` raised to the power of `exponent`\n-*/\n-fn pow(base: int, exponent: uint) -> int {\n-    if exponent == 0u { ret 1; } //Not mathemtically true if [base == 0]\n-    if base     == 0  { ret 0; }\n-    let my_pow  = exponent;\n-    let acc     = 1;\n-    let multiplier = base;\n-    while(my_pow > 0u) {\n-      if my_pow % 2u == 1u {\n-         acc *= multiplier;\n-      }\n-      my_pow     /= 2u;\n-      multiplier *= multiplier;\n-    }\n-    ret acc;\n-}\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "9ab74496d0b0f16e23b5044740f03aedc511f9d5", "filename": "src/libstd/option.rs", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=f7540b165cfe800ff5bfd2be22cc08510d4d03eb", "patch": "@@ -1,93 +0,0 @@\n-/*\n-Module: option\n-\n-Represents the presence or absence of a value.\n-\n-Every option<T> value can either be some(T) or none. Where in other languages\n-you might use a nullable type, in Rust you would use an option type.\n-*/\n-\n-/*\n-Tag: t\n-\n-The option type\n-*/\n-tag t<T> {\n-    /* Variant: none */\n-    none;\n-    /* Variant: some */\n-    some(T);\n-}\n-\n-/* Section: Operations */\n-\n-/*\n-Function: get\n-\n-Gets the value out of an option\n-\n-Failure:\n-\n-Fails if the value equals `none`.\n-*/\n-fn get<copy T>(opt: t<T>) -> T {\n-    alt opt { some(x) { ret x; } none. { fail \"option none\"; } }\n-}\n-\n-/*\n-*/\n-fn map<T, U>(f: block(T) -> U, opt: t<T>) -> t<U> {\n-    alt opt { some(x) { some(f(x)) } none. { none } }\n-}\n-\n-/*\n-Function: is_none\n-\n-Returns true if the option equals none\n-*/\n-pure fn is_none<T>(opt: t<T>) -> bool {\n-    alt opt { none. { true } some(_) { false } }\n-}\n-\n-/*\n-Function: is_some\n-\n-Returns true if the option contains some value\n-*/\n-pure fn is_some<T>(opt: t<T>) -> bool { !is_none(opt) }\n-\n-/*\n-Function: from_maybe\n-\n-Returns the contained value or a default\n-*/\n-fn from_maybe<T>(def: T, opt: t<T>) -> T {\n-    alt opt { some(x) { x } none. { def } }\n-}\n-\n-/*\n-Function: maybe\n-\n-Applies a function to the contained value or returns a default\n-*/\n-fn maybe<T, U>(def: U, opt: t<T>, f: block(T) -> U) -> U {\n-    alt opt { none. { def } some(t) { f(t) } }\n-}\n-\n-// FIXME: Can be defined in terms of the above when/if we have const bind.\n-/*\n-Function: may\n-\n-Performs an operation on the contained value or does nothing\n-*/\n-fn may<T>(opt: t<T>, f: block(T)) {\n-    alt opt { none. {/* nothing */ } some(t) { f(t); } }\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "0372b17cdf1d27dbda952c10b75e2b3e6ec43de1", "filename": "src/libstd/ptr.rs", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=f7540b165cfe800ff5bfd2be22cc08510d4d03eb", "patch": "@@ -1,52 +0,0 @@\n-/*\n-Module: ptr\n-\n-Unsafe pointer utility functions\n-*/\n-#[abi = \"rust-intrinsic\"]\n-native mod rusti {\n-    fn addr_of<T>(val: T) -> *T;\n-    fn ptr_offset<T>(ptr: *T, count: uint) -> *T;\n-}\n-\n-/*\n-Function: addr_of\n-\n-Get an unsafe pointer to a value\n-*/\n-fn addr_of<T>(val: T) -> *T { ret rusti::addr_of(val); }\n-\n-/*\n-Function: mut_addr_of\n-\n-Get an unsafe mutable pointer to a value\n-*/\n-fn mut_addr_of<T>(val: T) -> *mutable T unsafe {\n-    ret unsafe::reinterpret_cast(rusti::addr_of(val));\n-}\n-\n-/*\n-Function: offset\n-\n-Calculate the offset from a pointer\n-*/\n-fn offset<T>(ptr: *T, count: uint) -> *T {\n-    ret rusti::ptr_offset(ptr, count);\n-}\n-\n-/*\n-Function: mut_offset\n-\n-Calculate the offset from a mutable pointer\n-*/\n-fn mut_offset<T>(ptr: *mutable T, count: uint) -> *mutable T {\n-    ret rusti::ptr_offset(ptr as *T, count) as *mutable T;\n-}\n-\n-\n-/*\n-Function: null\n-\n-Create an unsafe null pointer\n-*/\n-fn null<T>() -> *T unsafe { ret unsafe::reinterpret_cast(0u); }"}, {"sha": "550f53470bbe8d0e9db5cc7924859abbf808a739", "filename": "src/libstd/result.rs", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=f7540b165cfe800ff5bfd2be22cc08510d4d03eb", "patch": "@@ -1,112 +0,0 @@\n-/*\n-Module: result\n-\n-A type representing either success or failure\n-*/\n-\n-/* Section: Types */\n-\n-/*\n-Tag: t\n-\n-The result type\n-*/\n-tag t<T, U> {\n-    /*\n-    Variant: ok\n-\n-    Contains the result value\n-    */\n-    ok(T);\n-    /*\n-    Variant: err\n-\n-    Contains the error value\n-    */\n-    err(U);\n-}\n-\n-/* Section: Operations */\n-\n-/*\n-Function: get\n-\n-Get the value out of a successful result\n-\n-Failure:\n-\n-If the result is an error\n-*/\n-fn get<T, U>(res: t<T, U>) -> T {\n-    alt res {\n-      ok(t) { t }\n-      err(_) {\n-        // FIXME: Serialize the error value\n-        // and include it in the fail message\n-        fail \"get called on error result\";\n-      }\n-    }\n-}\n-\n-/*\n-Function: get_err\n-\n-Get the value out of an error result\n-\n-Failure:\n-\n-If the result is not an error\n-*/\n-fn get_err<T, U>(res: t<T, U>) -> U {\n-    alt res {\n-      err(u) { u }\n-      ok(_) {\n-        fail \"get_error called on ok result\";\n-      }\n-    }\n-}\n-\n-/*\n-Function: success\n-\n-Returns true if the result is <ok>\n-*/\n-fn success<T, U>(res: t<T, U>) -> bool {\n-    alt res {\n-      ok(_) { true }\n-      err(_) { false }\n-    }\n-}\n-\n-/*\n-Function: failure\n-\n-Returns true if the result is <error>\n-*/\n-fn failure<T, U>(res: t<T, U>) -> bool {\n-    !success(res)\n-}\n-\n-/*\n-Function: chain\n-\n-Call a function based on a previous result\n-\n-If `res` is <ok> then the value is extracted and passed to `op` whereupon\n-`op`s result is returned. if `res` is <err> then it is immediately returned.\n-This function can be used to compose the results of two functions.\n-\n-Example:\n-\n-> let res = chain(read_file(file), { |buf|\n->   ok(parse_buf(buf))\n-> })\n-\n-*/\n-fn chain<T, copy U, copy V>(res: t<T, V>, op: block(T) -> t<U, V>)\n-    -> t<U, V> {\n-    alt res {\n-      ok(t) { op(t) }\n-      err(e) { err(e) }\n-    }\n-}"}, {"sha": "5fc310deca580447b862316ecd39dc22cc382006", "filename": "src/libstd/std.rc", "status": "modified", "additions": 3, "deletions": 27, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dde58603803dc6024cb5fa6071562f1b93b5816a/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/dde58603803dc6024cb5fa6071562f1b93b5816a/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=dde58603803dc6024cb5fa6071562f1b93b5816a", "patch": "@@ -7,35 +7,17 @@\n #[license = \"BSD\"];\n #[crate_type = \"lib\"];\n \n-export box, char, float, int, str, ptr;\n-export uint, u8, u32, u64, vec, bool;\n-export comm, fs, io, net, run, sys, task, uv;\n-export c_vec, ctypes, either, option, result, four, tri, util;\n+export comm, fs, io, net, run, uv;\n+export c_vec, ctypes, four, tri, util;\n export bitv, deque, fun_treemap, list, map, smallintmap, sort, treemap, ufind;\n export rope;\n export math;\n-export ebml, dbg, getopts, json, rand, sha1, term, time, unsafe;\n+export ebml, dbg, getopts, json, rand, sha1, term, time;\n export extfmt, test, tempfile;\n // FIXME: generic_os and os_fs shouldn't be exported\n export generic_os, os, os_fs;\n \n \n-// Built-in types support modules\n-\n-mod box;\n-mod char;\n-mod float;\n-mod int;\n-mod str;\n-mod ptr;\n-mod uint;\n-mod u8;\n-mod u32;\n-mod u64;\n-mod bool;\n-mod vec;\n-\n-\n // General io and system-services modules\n \n mod comm;\n@@ -44,8 +26,6 @@ mod io;\n mod net;\n #[path =  \"run_program.rs\"]\n mod run;\n-mod sys;\n-mod task;\n mod uv;\n \n \n@@ -56,9 +36,6 @@ mod ctypes;\n mod cmath; /* unexported */\n mod math_f32;\n mod math_f64;\n-mod either;\n-mod option;\n-mod result;\n mod four;\n mod tri;\n mod util;\n@@ -90,7 +67,6 @@ mod sha1;\n mod tempfile;\n mod term;\n mod time;\n-mod unsafe;\n \n #[cfg(unicode)]\n mod unicode;"}, {"sha": "fe2e7d9c567a29726cf6d39e5f8373fec9156522", "filename": "src/libstd/str.rs", "status": "removed", "additions": 0, "deletions": 960, "changes": 960, "blob_url": "https://github.com/rust-lang/rust/blob/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=f7540b165cfe800ff5bfd2be22cc08510d4d03eb", "patch": "@@ -1,960 +0,0 @@\n-/*\n-Module: str\n-\n-String manipulation.\n-*/\n-\n-export eq, lteq, hash, is_empty, is_not_empty, is_whitespace, byte_len,\n-       byte_len_range, index,\n-       rindex, find, starts_with, ends_with, substr, slice, split, concat,\n-       connect, to_upper, replace, char_slice, trim_left, trim_right, trim,\n-       unshift_char, shift_char, pop_char, push_char, is_utf8, from_chars,\n-       to_chars, char_len, char_len_range, char_at, bytes, is_ascii,\n-       shift_byte, pop_byte,\n-       unsafe_from_byte, unsafe_from_bytes, from_char, char_range_at,\n-       str_from_cstr, sbuf, as_buf, push_byte, utf8_char_width, safe_slice,\n-       contains, iter_chars, loop_chars, loop_chars_sub,\n-       escape;\n-\n-#[abi = \"cdecl\"]\n-native mod rustrt {\n-    fn rust_str_push(&s: str, ch: u8);\n-}\n-\n-/*\n-Function: eq\n-\n-Bytewise string equality\n-*/\n-fn eq(&&a: str, &&b: str) -> bool { a == b }\n-\n-/*\n-Function: lteq\n-\n-Bytewise less than or equal\n-*/\n-fn lteq(&&a: str, &&b: str) -> bool { a <= b }\n-\n-/*\n-Function: hash\n-\n-String hash function\n-*/\n-fn hash(&&s: str) -> uint {\n-    // djb hash.\n-    // FIXME: replace with murmur.\n-\n-    let u: uint = 5381u;\n-    for c: u8 in s { u *= 33u; u += c as uint; }\n-    ret u;\n-}\n-\n-// UTF-8 tags and ranges\n-const tag_cont_u8: u8 = 128u8;\n-const tag_cont: uint = 128u;\n-const max_one_b: uint = 128u;\n-const tag_two_b: uint = 192u;\n-const max_two_b: uint = 2048u;\n-const tag_three_b: uint = 224u;\n-const max_three_b: uint = 65536u;\n-const tag_four_b: uint = 240u;\n-const max_four_b: uint = 2097152u;\n-const tag_five_b: uint = 248u;\n-const max_five_b: uint = 67108864u;\n-const tag_six_b: uint = 252u;\n-\n-/*\n-Function: is_utf8\n-\n-Determines if a vector of bytes contains valid UTF-8\n-*/\n-fn is_utf8(v: [u8]) -> bool {\n-    let i = 0u;\n-    let total = vec::len::<u8>(v);\n-    while i < total {\n-        let chsize = utf8_char_width(v[i]);\n-        if chsize == 0u { ret false; }\n-        if i + chsize > total { ret false; }\n-        i += 1u;\n-        while chsize > 1u {\n-            if v[i] & 192u8 != tag_cont_u8 { ret false; }\n-            i += 1u;\n-            chsize -= 1u;\n-        }\n-    }\n-    ret true;\n-}\n-\n-/*\n-Function: is_ascii\n-\n-Determines if a string contains only ASCII characters\n-*/\n-fn is_ascii(s: str) -> bool {\n-    let i: uint = byte_len(s);\n-    while i > 0u { i -= 1u; if s[i] & 128u8 != 0u8 { ret false; } }\n-    ret true;\n-}\n-\n-/*\n-Predicate: is_empty\n-\n-Returns true if the string has length 0\n-*/\n-pure fn is_empty(s: str) -> bool { for c: u8 in s { ret false; } ret true; }\n-\n-/*\n-Predicate: is_not_empty\n-\n-Returns true if the string has length greater than 0\n-*/\n-pure fn is_not_empty(s: str) -> bool { !is_empty(s) }\n-\n-/*\n-Function: is_whitespace\n-\n-Returns true if the string contains only whitespace\n-*/\n-fn is_whitespace(s: str) -> bool {\n-    let i = 0u;\n-    let len = char_len(s);\n-    while i < len {\n-        // FIXME: This is not how char_at works\n-        if !char::is_whitespace(char_at(s, i)) { ret false; }\n-        i += 1u;\n-    }\n-    ret true;\n-}\n-\n-/*\n-Function: byte_len\n-\n-Returns the length in bytes of a string\n-*/\n-fn byte_len(s: str) -> uint unsafe {\n-    let v: [u8] = unsafe::reinterpret_cast(s);\n-    let vlen = vec::len(v);\n-    unsafe::leak(v);\n-    // There should always be a null terminator\n-    assert (vlen > 0u);\n-    ret vlen - 1u;\n-}\n-\n-/*\n-Function: byte_len_range\n-\n-As byte_len but for a substring\n-\n-Parameters:\n-s - A string\n-byte_offset - The byte offset at which to start in the string\n-char_len    - The number of chars (not bytes!) in the range\n-\n-Returns:\n-The number of bytes in the substring starting at `byte_offset` and\n-containing `char_len` chars.\n-\n-Safety note:\n-\n-This function fails if `byte_offset` or `char_len` do not represent\n-valid positions in `s`\n-*/\n-fn byte_len_range(s: str, byte_offset: uint, char_len: uint) -> uint {\n-    let i = byte_offset;\n-    let chars = 0u;\n-    while chars < char_len {\n-        let chsize = utf8_char_width(s[i]);\n-        assert (chsize > 0u);\n-        i += chsize;\n-        chars += 1u;\n-    }\n-    ret i - byte_offset;\n-}\n-\n-/*\n-Function: bytes\n-\n-Converts a string to a vector of bytes. The result vector is not\n-null-terminated.\n-*/\n-fn bytes(s: str) -> [u8] unsafe {\n-    let v = unsafe::reinterpret_cast(s);\n-    let vcopy = vec::slice(v, 0u, vec::len(v) - 1u);\n-    unsafe::leak(v);\n-    ret vcopy;\n-}\n-\n-/*\n-Function: unsafe_from_bytes\n-\n-Converts a vector of bytes to a string. Does not verify that the\n-vector contains valid UTF-8.\n-*/\n-fn unsafe_from_bytes(v: [const u8]) -> str unsafe {\n-    let vcopy: [u8] = v + [0u8];\n-    let scopy: str = unsafe::reinterpret_cast(vcopy);\n-    unsafe::leak(vcopy);\n-    ret scopy;\n-}\n-\n-/*\n-Function: unsafe_from_byte\n-\n-Converts a byte to a string. Does not verify that the byte is\n-valid UTF-8.\n-*/\n-fn unsafe_from_byte(u: u8) -> str { unsafe_from_bytes([u]) }\n-\n-fn push_utf8_bytes(&s: str, ch: char) {\n-    let code = ch as uint;\n-    let bytes =\n-        if code < max_one_b {\n-            [code as u8]\n-        } else if code < max_two_b {\n-            [code >> 6u & 31u | tag_two_b as u8, code & 63u | tag_cont as u8]\n-        } else if code < max_three_b {\n-            [code >> 12u & 15u | tag_three_b as u8,\n-             code >> 6u & 63u | tag_cont as u8, code & 63u | tag_cont as u8]\n-        } else if code < max_four_b {\n-            [code >> 18u & 7u | tag_four_b as u8,\n-             code >> 12u & 63u | tag_cont as u8,\n-             code >> 6u & 63u | tag_cont as u8, code & 63u | tag_cont as u8]\n-        } else if code < max_five_b {\n-            [code >> 24u & 3u | tag_five_b as u8,\n-             code >> 18u & 63u | tag_cont as u8,\n-             code >> 12u & 63u | tag_cont as u8,\n-             code >> 6u & 63u | tag_cont as u8, code & 63u | tag_cont as u8]\n-        } else {\n-            [code >> 30u & 1u | tag_six_b as u8,\n-             code >> 24u & 63u | tag_cont as u8,\n-             code >> 18u & 63u | tag_cont as u8,\n-             code >> 12u & 63u | tag_cont as u8,\n-             code >> 6u & 63u | tag_cont as u8, code & 63u | tag_cont as u8]\n-        };\n-    push_bytes(s, bytes);\n-}\n-\n-/*\n-Function: from_char\n-\n-Convert a char to a string\n-*/\n-fn from_char(ch: char) -> str {\n-    let buf = \"\";\n-    push_utf8_bytes(buf, ch);\n-    ret buf;\n-}\n-\n-/*\n-Function: from_chars\n-\n-Convert a vector of chars to a string\n-*/\n-fn from_chars(chs: [char]) -> str {\n-    let buf = \"\";\n-    for ch: char in chs { push_utf8_bytes(buf, ch); }\n-    ret buf;\n-}\n-\n-/*\n-Function: utf8_char_width\n-\n-FIXME: What does this function do?\n-*/\n-fn utf8_char_width(b: u8) -> uint {\n-    let byte: uint = b as uint;\n-    if byte < 128u { ret 1u; }\n-    if byte < 192u {\n-        ret 0u; // Not a valid start byte\n-\n-    }\n-    if byte < 224u { ret 2u; }\n-    if byte < 240u { ret 3u; }\n-    if byte < 248u { ret 4u; }\n-    if byte < 252u { ret 5u; }\n-    ret 6u;\n-}\n-\n-/*\n-Function: char_range_at\n-\n-Pluck a character out of a string and return the index of the next character.\n-This function can be used to iterate over the unicode characters of a string.\n-\n-Example:\n-\n-> let s = \"Clam chowder, hot sauce, pork rinds\";\n-> let i = 0;\n-> while i < len(s) {\n->   let {ch, next} = char_range_at(s, i);\n->   log ch;\n->   i = next;\n-> }\n-\n-Parameters:\n-\n-s - The string\n-i - The byte offset of the char to extract\n-\n-Returns:\n-\n-A record {ch: char, next: uint} containing the char value and the byte\n-index of the next unicode character.\n-\n-Failure:\n-\n-If `i` is greater than or equal to the length of the string.\n-If `i` is not the index of the beginning of a valid UTF-8 character.\n-*/\n-fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n-    let b0 = s[i];\n-    let w = utf8_char_width(b0);\n-    assert (w != 0u);\n-    if w == 1u { ret {ch: b0 as char, next: i + 1u}; }\n-    let val = 0u;\n-    let end = i + w;\n-    let i = i + 1u;\n-    while i < end {\n-        let byte = s[i];\n-        assert (byte & 192u8 == tag_cont_u8);\n-        val <<= 6u;\n-        val += byte & 63u8 as uint;\n-        i += 1u;\n-    }\n-    // Clunky way to get the right bits from the first byte. Uses two shifts,\n-    // the first to clip off the marker bits at the left of the byte, and then\n-    // a second (as uint) to get it to the right position.\n-    val += (b0 << (w + 1u as u8) as uint) << ((w - 1u) * 6u - w - 1u);\n-    ret {ch: val as char, next: i};\n-}\n-\n-/*\n-Function: char_at\n-\n-Pluck a character out of a string\n-*/\n-fn char_at(s: str, i: uint) -> char { ret char_range_at(s, i).ch; }\n-\n-/*\n-Function: iter_chars\n-\n-Iterate over the characters in a string\n-*/\n-\n-fn iter_chars(s: str, it: block(char)) {\n-    let pos = 0u, len = byte_len(s);\n-    while (pos < len) {\n-        let {ch, next} = char_range_at(s, pos);\n-        pos = next;\n-        it(ch);\n-    }\n-}\n-\n-/*\n-Function: loop_chars\n-\n-Loop through a string, char by char\n-\n-Parameters:\n-s  - A string to traverse. It may be empty.\n-it - A block to execute with each consecutive character of `s`.\n-Return `true` to continue, `false` to stop.\n-\n-Returns:\n-\n-`true` If execution proceeded correctly, `false` if it was interrupted,\n-that is if `it` returned `false` at any point.\n- */\n-fn loop_chars(s: str, it: block(char) -> bool) -> bool{\n-    ret loop_chars_sub(s, 0u, byte_len(s), it);\n-}\n-\n-/*\n-Function: loop_chars_sub\n-\n-Loop through a substring, char by char\n-\n-Parameters:\n-s           - A string to traverse. It may be empty.\n-byte_offset - The byte offset at which to start in the string.\n-byte_len    - The number of bytes to traverse in the string\n-it          - A block to execute with each consecutive character of `s`.\n-Return `true` to continue, `false` to stop.\n-\n-Returns:\n-\n-`true` If execution proceeded correctly, `false` if it was interrupted,\n-that is if `it` returned `false` at any point.\n-\n-Safety note:\n-- This function does not check whether the substring is valid.\n-- This function fails if `byte_offset` or `byte_len` do not\n- represent valid positions inside `s`\n- */\n-fn loop_chars_sub(s: str, byte_offset: uint, byte_len: uint,\n-              it: block(char) -> bool) -> bool {\n-   let i = byte_offset;\n-   let result = true;\n-   while i < byte_len {\n-      let {ch, next} = char_range_at(s, i);\n-      if !it(ch) {result = false; break;}\n-      i = next;\n-   }\n-   ret result;\n-}\n-\n-\n-/*\n-Function: char_len\n-\n-Count the number of unicode characters in a string\n-*/\n-fn char_len(s: str) -> uint {\n-    ret char_len_range(s, 0u, byte_len(s));\n-}\n-\n-/*\n-Function: char_len_range\n-\n-As char_len but for a slice of a string\n-\n-Parameters:\n- s           - A valid string\n- byte_start  - The position inside `s` where to start counting in bytes.\n- byte_len    - The number of bytes of `s` to take into account.\n-\n-Returns:\n- The number of Unicode characters in `s` in\n-segment [byte_start, byte_start+len( .\n-\n-Safety note:\n-- This function does not check whether the substring is valid.\n-- This function fails if `byte_offset` or `byte_len` do not\n- represent valid positions inside `s`\n-*/\n-fn char_len_range(s: str, byte_start: uint, byte_len: uint) -> uint {\n-    let i     = byte_start;\n-    let len   = 0u;\n-    while i < byte_len {\n-        let chsize = utf8_char_width(s[i]);\n-        assert (chsize > 0u);\n-        len += 1u;\n-        i += chsize;\n-    }\n-    assert (i == byte_len);\n-    ret len;\n-}\n-\n-/*\n-Function: to_chars\n-\n-Convert a string to a vector of characters\n-*/\n-fn to_chars(s: str) -> [char] {\n-    let buf: [char] = [];\n-    let i = 0u;\n-    let len = byte_len(s);\n-    while i < len {\n-        let cur = char_range_at(s, i);\n-        buf += [cur.ch];\n-        i = cur.next;\n-    }\n-    ret buf;\n-}\n-\n-/*\n-Function: push_char\n-\n-Append a character to a string\n-*/\n-fn push_char(&s: str, ch: char) { s += from_char(ch); }\n-\n-/*\n-Function: pop_char\n-\n-Remove the final character from a string and return it.\n-\n-Failure:\n-\n-If the string does not contain any characters.\n-*/\n-fn pop_char(&s: str) -> char {\n-    let end = byte_len(s);\n-    while end > 0u && s[end - 1u] & 192u8 == tag_cont_u8 { end -= 1u; }\n-    assert (end > 0u);\n-    let ch = char_at(s, end - 1u);\n-    s = substr(s, 0u, end - 1u);\n-    ret ch;\n-}\n-\n-/*\n-Function: shift_char\n-\n-Remove the first character from a string and return it.\n-\n-Failure:\n-\n-If the string does not contain any characters.\n-*/\n-fn shift_char(&s: str) -> char {\n-    let r = char_range_at(s, 0u);\n-    s = substr(s, r.next, byte_len(s) - r.next);\n-    ret r.ch;\n-}\n-\n-/*\n-Function: unshift_char\n-\n-Prepend a char to a string\n-*/\n-fn unshift_char(&s: str, ch: char) { s = from_char(ch) + s; }\n-\n-/*\n-Function: index\n-\n-Returns the index of the first matching byte. Returns -1 if\n-no match is found.\n-*/\n-fn index(s: str, c: u8) -> int {\n-    let i: int = 0;\n-    for k: u8 in s { if k == c { ret i; } i += 1; }\n-    ret -1;\n-}\n-\n-/*\n-Function: rindex\n-\n-Returns the index of the last matching byte. Returns -1\n-if no match is found.\n-*/\n-fn rindex(s: str, c: u8) -> int {\n-    let n: int = byte_len(s) as int;\n-    while n >= 0 { if s[n] == c { ret n; } n -= 1; }\n-    ret n;\n-}\n-\n-/*\n-Function: find\n-\n-Finds the index of the first matching substring.\n-Returns -1 if `haystack` does not contain `needle`.\n-\n-Parameters:\n-\n-haystack - The string to look in\n-needle - The string to look for\n-\n-Returns:\n-\n-The index of the first occurrence of `needle`, or -1 if not found.\n-*/\n-fn find(haystack: str, needle: str) -> int {\n-    let haystack_len: int = byte_len(haystack) as int;\n-    let needle_len: int = byte_len(needle) as int;\n-    if needle_len == 0 { ret 0; }\n-    fn match_at(haystack: str, needle: str, i: int) -> bool {\n-        let j: int = i;\n-        for c: u8 in needle { if haystack[j] != c { ret false; } j += 1; }\n-        ret true;\n-    }\n-    let i: int = 0;\n-    while i <= haystack_len - needle_len {\n-        if match_at(haystack, needle, i) { ret i; }\n-        i += 1;\n-    }\n-    ret -1;\n-}\n-\n-/*\n-Function: contains\n-\n-Returns true if one string contains another\n-\n-Parameters:\n-\n-haystack - The string to look in\n-needle - The string to look for\n-*/\n-fn contains(haystack: str, needle: str) -> bool {\n-    0 <= find(haystack, needle)\n-}\n-\n-/*\n-Function: starts_with\n-\n-Returns true if one string starts with another\n-\n-Parameters:\n-\n-haystack - The string to look in\n-needle - The string to look for\n-*/\n-fn starts_with(haystack: str, needle: str) -> bool {\n-    let haystack_len: uint = byte_len(haystack);\n-    let needle_len: uint = byte_len(needle);\n-    if needle_len == 0u { ret true; }\n-    if needle_len > haystack_len { ret false; }\n-    ret eq(substr(haystack, 0u, needle_len), needle);\n-}\n-\n-/*\n-Function: ends_with\n-\n-Returns true if one string ends with another\n-\n-haystack - The string to look in\n-needle - The string to look for\n-*/\n-fn ends_with(haystack: str, needle: str) -> bool {\n-    let haystack_len: uint = byte_len(haystack);\n-    let needle_len: uint = byte_len(needle);\n-    ret if needle_len == 0u {\n-            true\n-        } else if needle_len > haystack_len {\n-            false\n-        } else {\n-            eq(substr(haystack, haystack_len - needle_len, needle_len),\n-               needle)\n-        };\n-}\n-\n-/*\n-Function: substr\n-\n-Take a substring of another. Returns a string containing `len` bytes\n-starting at byte offset `begin`.\n-\n-This function is not unicode-safe.\n-\n-Failure:\n-\n-If `begin` + `len` is is greater than the byte length of the string\n-*/\n-fn substr(s: str, begin: uint, len: uint) -> str {\n-    ret slice(s, begin, begin + len);\n-}\n-\n-/*\n-Function: slice\n-\n-Takes a bytewise slice from a string. Returns the substring from\n-[`begin`..`end`).\n-\n-This function is not unicode-safe.\n-\n-Failure:\n-\n-- If begin is greater than end.\n-- If end is greater than the length of the string.\n-*/\n-fn slice(s: str, begin: uint, end: uint) -> str unsafe {\n-    // FIXME: Typestate precondition\n-    assert (begin <= end);\n-    assert (end <= byte_len(s));\n-\n-    let v: [u8] = unsafe::reinterpret_cast(s);\n-    let v2 = vec::slice(v, begin, end);\n-    unsafe::leak(v);\n-    v2 += [0u8];\n-    let s2: str = unsafe::reinterpret_cast(v2);\n-    unsafe::leak(v2);\n-    ret s2;\n-}\n-\n-/*\n-Function: safe_slice\n-*/\n-fn safe_slice(s: str, begin: uint, end: uint) : uint::le(begin, end) -> str {\n-    // would need some magic to make this a precondition\n-    assert (end <= byte_len(s));\n-    ret slice(s, begin, end);\n-}\n-\n-/*\n-Function: shift_byte\n-\n-Removes the first byte from a string and returns it.\n-\n-This function is not unicode-safe.\n-*/\n-fn shift_byte(&s: str) -> u8 {\n-    let len = byte_len(s);\n-    assert (len > 0u);\n-    let b = s[0];\n-    s = substr(s, 1u, len - 1u);\n-    ret b;\n-}\n-\n-/*\n-Function: pop_byte\n-\n-Removes the last byte from a string and returns it.\n-\n-This function is not unicode-safe.\n-*/\n-fn pop_byte(&s: str) -> u8 {\n-    let len = byte_len(s);\n-    assert (len > 0u);\n-    let b = s[len - 1u];\n-    s = substr(s, 0u, len - 1u);\n-    ret b;\n-}\n-\n-/*\n-Function: push_byte\n-\n-Appends a byte to a string.\n-\n-This function is not unicode-safe.\n-*/\n-fn push_byte(&s: str, b: u8) { rustrt::rust_str_push(s, b); }\n-\n-/*\n-Function: push_bytes\n-\n-Appends a vector of bytes to a string.\n-\n-This function is not unicode-safe.\n-*/\n-fn push_bytes(&s: str, bytes: [u8]) {\n-    for byte in bytes { rustrt::rust_str_push(s, byte); }\n-}\n-\n-/*\n-Function: split\n-\n-Split a string at each occurrence of a given separator\n-\n-Returns:\n-\n-A vector containing all the strings between each occurrence of the separator\n-*/\n-fn split(s: str, sep: u8) -> [str] {\n-    let v: [str] = [];\n-    let accum: str = \"\";\n-    let ends_with_sep: bool = false;\n-    for c: u8 in s {\n-        if c == sep {\n-            v += [accum];\n-            accum = \"\";\n-            ends_with_sep = true;\n-        } else { accum += unsafe_from_byte(c); ends_with_sep = false; }\n-    }\n-    if byte_len(accum) != 0u || ends_with_sep { v += [accum]; }\n-    ret v;\n-}\n-\n-/*\n-Function: concat\n-\n-Concatenate a vector of strings\n-*/\n-fn concat(v: [str]) -> str {\n-    let s: str = \"\";\n-    for ss: str in v { s += ss; }\n-    ret s;\n-}\n-\n-/*\n-Function: connect\n-\n-Concatenate a vector of strings, placing a given separator between each\n-*/\n-fn connect(v: [str], sep: str) -> str {\n-    let s: str = \"\";\n-    let first: bool = true;\n-    for ss: str in v {\n-        if first { first = false; } else { s += sep; }\n-        s += ss;\n-    }\n-    ret s;\n-}\n-\n-// FIXME: This only handles ASCII\n-/*\n-Function: to_upper\n-\n-Convert a string to uppercase\n-*/\n-fn to_upper(s: str) -> str {\n-    let outstr = \"\";\n-    let ascii_a = 'a' as u8;\n-    let ascii_z = 'z' as u8;\n-    let diff = 32u8;\n-    for byte: u8 in s {\n-        let next;\n-        if ascii_a <= byte && byte <= ascii_z {\n-            next = byte - diff;\n-        } else { next = byte; }\n-        push_byte(outstr, next);\n-    }\n-    ret outstr;\n-}\n-\n-// FIXME: This is super-inefficient\n-/*\n-Function: replace\n-\n-Replace all occurrences of one string with another\n-\n-Parameters:\n-\n-s - The string containing substrings to replace\n-from - The string to replace\n-to - The replacement string\n-\n-Returns:\n-\n-The original string with all occurrences of `from` replaced with `to`\n-*/\n-fn replace(s: str, from: str, to: str) : is_not_empty(from) -> str {\n-    // FIXME (694): Shouldn't have to check this\n-    check (is_not_empty(from));\n-    if byte_len(s) == 0u {\n-        ret \"\";\n-    } else if starts_with(s, from) {\n-        ret to + replace(slice(s, byte_len(from), byte_len(s)), from, to);\n-    } else {\n-        ret unsafe_from_byte(s[0]) +\n-                replace(slice(s, 1u, byte_len(s)), from, to);\n-    }\n-}\n-\n-// FIXME: Also not efficient\n-/*\n-Function: char_slice\n-\n-Unicode-safe slice. Returns a slice of the given string containing\n-the characters in the range [`begin`..`end`). `begin` and `end` are\n-character indexes, not byte indexes.\n-\n-Failure:\n-\n-- If begin is greater than end\n-- If end is greater than the character length of the string\n-*/\n-fn char_slice(s: str, begin: uint, end: uint) -> str {\n-    from_chars(vec::slice(to_chars(s), begin, end))\n-}\n-\n-/*\n-Function: trim_left\n-\n-Returns a string with leading whitespace removed.\n-*/\n-fn trim_left(s: str) -> str {\n-    fn count_whities(s: [char]) -> uint {\n-        let i = 0u;\n-        while i < vec::len(s) {\n-            if !char::is_whitespace(s[i]) { break; }\n-            i += 1u;\n-        }\n-        ret i;\n-    }\n-    let chars = to_chars(s);\n-    let whities = count_whities(chars);\n-    ret from_chars(vec::slice(chars, whities, vec::len(chars)));\n-}\n-\n-/*\n-Function: trim_right\n-\n-Returns a string with trailing whitespace removed.\n-*/\n-fn trim_right(s: str) -> str {\n-    fn count_whities(s: [char]) -> uint {\n-        let i = vec::len(s);\n-        while 0u < i {\n-            if !char::is_whitespace(s[i - 1u]) { break; }\n-            i -= 1u;\n-        }\n-        ret i;\n-    }\n-    let chars = to_chars(s);\n-    let whities = count_whities(chars);\n-    ret from_chars(vec::slice(chars, 0u, whities));\n-}\n-\n-/*\n-Function: trim\n-\n-Returns a string with leading and trailing whitespace removed\n-*/\n-fn trim(s: str) -> str { trim_left(trim_right(s)) }\n-\n-/*\n-Type: sbuf\n-\n-An unsafe buffer of bytes. Corresponds to a C char pointer.\n-*/\n-type sbuf = *u8;\n-\n-// NB: This is intentionally unexported because it's easy to misuse (there's\n-// no guarantee that the string is rooted). Instead, use as_buf below.\n-unsafe fn buf(s: str) -> sbuf {\n-    let saddr = ptr::addr_of(s);\n-    let vaddr: *[u8] = unsafe::reinterpret_cast(saddr);\n-    let buf = vec::to_ptr(*vaddr);\n-    ret buf;\n-}\n-\n-/*\n-Function: as_buf\n-\n-Work with the byte buffer of a string. Allows for unsafe manipulation\n-of strings, which is useful for native interop.\n-\n-Example:\n-\n-> let s = str::as_buf(\"PATH\", { |path_buf| libc::getenv(path_buf) });\n-\n-*/\n-fn as_buf<T>(s: str, f: block(sbuf) -> T) -> T unsafe {\n-    let buf = buf(s); f(buf)\n-}\n-\n-/*\n-Function: str_from_cstr\n-\n-Create a Rust string from a null-terminated C string\n-*/\n-unsafe fn str_from_cstr(cstr: sbuf) -> str {\n-    let res = \"\";\n-    let start = cstr;\n-    let curr = start;\n-    let i = 0u;\n-    while *curr != 0u8 {\n-        push_byte(res, *curr);\n-        i += 1u;\n-        curr = ptr::offset(start, i);\n-    }\n-    ret res;\n-}\n-\n-/*\n-Function: escape_char\n-\n-Escapes a single character.\n-*/\n-fn escape_char(c: char) -> str {\n-    alt c {\n-      '\"' { \"\\\\\\\"\" }\n-      '\\\\' { \"\\\\\\\\\" }\n-      '\\n' { \"\\\\n\" }\n-      '\\t' { \"\\\\t\" }\n-      '\\r' { \"\\\\r\" }\n-      '\\x00' to '\\x1f' { #fmt[\"\\\\x%02x\", c as uint] }\n-      v { from_char(c) }\n-    }\n-}\n-\n-/*\n-Function: escape\n-\n-Escapes special characters inside the string, making it safe for transfer.\n-*/\n-fn escape(s: str) -> str {\n-    let r = \"\";\n-    loop_chars(s, { |c| r += escape_char(c); true });\n-    r\n-}"}, {"sha": "3b4a3b8c64378eeae0c037f9c453d26018ffd0bf", "filename": "src/libstd/sys.rs", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=f7540b165cfe800ff5bfd2be22cc08510d4d03eb", "patch": "@@ -1,96 +0,0 @@\n-/*\n-Module: sys\n-\n-Misc low level stuff\n-*/\n-tag type_desc = {\n-    first_param: **ctypes::c_int,\n-    size: ctypes::size_t,\n-    align: ctypes::size_t\n-    // Remaining fields not listed\n-};\n-\n-#[abi = \"cdecl\"]\n-native mod rustrt {\n-    // Explicitly re-export native stuff we want to be made\n-    // available outside this crate. Otherwise it's\n-    // visible-in-crate, but not re-exported.\n-    fn last_os_error() -> str;\n-    fn refcount<T>(t: @T) -> uint;\n-    fn do_gc();\n-    fn unsupervise();\n-}\n-\n-#[abi = \"rust-intrinsic\"]\n-native mod rusti {\n-    fn get_type_desc<T>() -> *type_desc;\n-}\n-\n-/*\n-Function: get_type_desc\n-\n-Returns a pointer to a type descriptor. Useful for calling certain\n-function in the Rust runtime or otherwise performing dark magick.\n-*/\n-fn get_type_desc<T>() -> *type_desc {\n-    ret rusti::get_type_desc::<T>();\n-}\n-\n-/*\n-Function: last_os_error\n-\n-Get a string representing the platform-dependent last error\n-*/\n-fn last_os_error() -> str {\n-    ret rustrt::last_os_error();\n-}\n-\n-/*\n-Function: size_of\n-\n-Returns the size of a type\n-*/\n-fn size_of<T>() -> uint unsafe {\n-    ret (*get_type_desc::<T>()).size;\n-}\n-\n-/*\n-Function: align_of\n-\n-Returns the alignment of a type\n-*/\n-fn align_of<T>() -> uint unsafe {\n-    ret (*get_type_desc::<T>()).align;\n-}\n-\n-/*\n-Function: refcount\n-\n-Returns the refcount of a shared box\n-*/\n-fn refcount<T>(t: @T) -> uint {\n-    ret rustrt::refcount::<T>(t);\n-}\n-\n-/*\n-Function: do_gc\n-\n-Force a garbage collection\n-*/\n-fn do_gc() -> () {\n-    ret rustrt::do_gc();\n-}\n-\n-// FIXME: There's a wrapper for this in the task module and this really\n-// just belongs there\n-fn unsupervise() -> () {\n-    ret rustrt::unsupervise();\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "31f01cf838425eb06f51a9085dcda124b840888a", "filename": "src/libstd/task.rs", "status": "removed", "additions": 0, "deletions": 357, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=f7540b165cfe800ff5bfd2be22cc08510d4d03eb", "patch": "@@ -1,357 +0,0 @@\n-/*\n-Module: task\n-\n-Task management.\n-\n-An executing Rust program consists of a tree of tasks, each with their own\n-stack, and sole ownership of their allocated heap data. Tasks communicate\n-with each other using ports and channels.\n-\n-When a task fails, that failure will propagate to its parent (the task\n-that spawned it) and the parent will fail as well. The reverse is not\n-true: when a parent task fails its children will continue executing. When\n-the root (main) task fails, all tasks fail, and then so does the entire\n-process.\n-\n-A task may remove itself from this failure propagation mechanism by\n-calling the <unsupervise> function, after which failure will only\n-result in the termination of that task.\n-\n-Tasks may execute in parallel and are scheduled automatically by the runtime.\n-\n-Example:\n-\n-> spawn(\"Hello, World\", fn (&&msg: str) {\n->   log msg;\n-> });\n-\n-*/\n-import cast = unsafe::reinterpret_cast;\n-import comm;\n-import option::{some, none};\n-import option = option::t;\n-import ptr;\n-\n-export task;\n-export joinable_task;\n-export sleep;\n-export yield;\n-export task_notification;\n-export join;\n-export unsupervise;\n-export pin;\n-export unpin;\n-export set_min_stack;\n-export task_result;\n-export tr_success;\n-export tr_failure;\n-export get_task;\n-export spawn;\n-export spawn_notify;\n-export spawn_joinable;\n-\n-#[abi = \"rust-intrinsic\"]\n-native mod rusti {\n-    // these must run on the Rust stack so that they can swap stacks etc:\n-    fn task_sleep(task: *rust_task, time_in_us: uint, &killed: bool);\n-}\n-\n-#[link_name = \"rustrt\"]\n-#[abi = \"cdecl\"]\n-native mod rustrt {\n-    // these can run on the C stack:\n-    fn pin_task();\n-    fn unpin_task();\n-    fn get_task_id() -> task_id;\n-    fn rust_get_task() -> *rust_task;\n-\n-    fn set_min_stack(stack_size: uint);\n-\n-    fn new_task() -> task_id;\n-    fn drop_task(task_id: *rust_task);\n-    fn get_task_pointer(id: task_id) -> *rust_task;\n-\n-    fn migrate_alloc(alloc: *u8, target: task_id);\n-\n-    fn start_task(id: task, closure: *u8);\n-\n-}\n-\n-/* Section: Types */\n-\n-type rust_task =\n-    {id: task,\n-     mutable notify_enabled: int,\n-     mutable notify_chan: comm::chan<task_notification>,\n-     mutable stack_ptr: *u8};\n-\n-resource rust_task_ptr(task: *rust_task) { rustrt::drop_task(task); }\n-\n-type task_id = int;\n-\n-/*\n-Type: task\n-\n-A handle to a task\n-*/\n-type task = task_id;\n-\n-/*\n-Type: joinable_task\n-\n-A task that sends notification upon termination\n-*/\n-type joinable_task = (task, comm::port<task_notification>);\n-\n-/*\n-Tag: task_result\n-\n-Indicates the manner in which a task exited\n-*/\n-tag task_result {\n-    /* Variant: tr_success */\n-    tr_success;\n-    /* Variant: tr_failure */\n-    tr_failure;\n-}\n-\n-/*\n-Tag: task_notification\n-\n-Message sent upon task exit to indicate normal or abnormal termination\n-*/\n-tag task_notification {\n-    /* Variant: exit */\n-    exit(task, task_result);\n-}\n-\n-/* Section: Operations */\n-\n-/*\n-Type: get_task\n-\n-Retreives a handle to the currently executing task\n-*/\n-fn get_task() -> task { rustrt::get_task_id() }\n-\n-/*\n-Function: sleep\n-\n-Hints the scheduler to yield this task for a specified ammount of time.\n-\n-Parameters:\n-\n-time_in_us - maximum number of microseconds to yield control for\n-*/\n-fn sleep(time_in_us: uint) {\n-    let task = rustrt::rust_get_task();\n-    let killed = false;\n-    // FIXME: uncomment this when extfmt is moved to core\n-    // in a snapshot.\n-    // log #fmt(\"yielding for %u us\", time_in_us);\n-    rusti::task_sleep(task, time_in_us, killed);\n-    if killed {\n-        fail \"killed\";\n-    }\n-}\n-\n-/*\n-Function: yield\n-\n-Yield control to the task scheduler\n-\n-The scheduler may schedule another task to execute.\n-*/\n-fn yield() { sleep(1u) }\n-\n-/*\n-Function: join\n-\n-Wait for a child task to exit\n-\n-The child task must have been spawned with <spawn_joinable>, which\n-produces a notification port that the child uses to communicate its\n-exit status.\n-\n-Returns:\n-\n-A task_result indicating whether the task terminated normally or failed\n-*/\n-fn join(task_port: joinable_task) -> task_result {\n-    let (id, port) = task_port;\n-    alt comm::recv::<task_notification>(port) {\n-      exit(_id, res) {\n-        if _id == id {\n-            ret res\n-        } else {\n-            // FIXME: uncomment this when extfmt is moved to core\n-            // in a snapshot.\n-            // fail #fmt[\"join received id %d, expected %d\", _id, id]\n-            fail;\n-        }\n-      }\n-    }\n-}\n-\n-/*\n-Function: unsupervise\n-\n-Detaches this task from its parent in the task tree\n-\n-An unsupervised task will not propagate its failure up the task tree\n-*/\n-fn unsupervise() { ret sys::unsupervise(); }\n-\n-/*\n-Function: pin\n-\n-Pins the current task and future child tasks to a single scheduler thread\n-*/\n-fn pin() { rustrt::pin_task(); }\n-\n-/*\n-Function: unpin\n-\n-Unpin the current task and future child tasks\n-*/\n-fn unpin() { rustrt::unpin_task(); }\n-\n-/*\n-Function: set_min_stack\n-\n-Set the minimum stack size (in bytes) for tasks spawned in the future.\n-\n-This function has global effect and should probably not be used.\n-*/\n-fn set_min_stack(stack_size: uint) { rustrt::set_min_stack(stack_size); }\n-\n-/*\n-Function: spawn\n-\n-Creates and executes a new child task\n-\n-Sets up a new task with its own call stack and schedules it to be executed.\n-Upon execution the new task will call function `f` with the provided\n-argument `data`.\n-\n-Function `f` is a bare function, meaning it may not close over any data, as do\n-shared functions (fn@) and lambda blocks. `data` must be a uniquely owned\n-type; it is moved into the new task and thus can no longer be accessed\n-locally.\n-\n-Parameters:\n-\n-data - A unique-type value to pass to the new task\n-f - A function to execute in the new task\n-\n-Returns:\n-\n-A handle to the new task\n-*/\n-fn spawn<send T>(-data: T, f: fn(T)) -> task {\n-    spawn_inner(data, f, none)\n-}\n-\n-/*\n-Function: spawn_notify\n-\n-Create and execute a new child task, requesting notification upon its\n-termination\n-\n-Immediately before termination, either on success or failure, the spawned\n-task will send a <task_notification> message on the provided channel.\n-*/\n-fn spawn_notify<send T>(-data: T, f: fn(T),\n-                         notify: comm::chan<task_notification>) -> task {\n-    spawn_inner(data, f, some(notify))\n-}\n-\n-/*\n-Function: spawn_joinable\n-\n-Create and execute a task which can later be joined with the <join> function\n-\n-This is a convenience wrapper around spawn_notify which, when paired\n-with <join> can be easily used to spawn a task then wait for it to\n-complete.\n-*/\n-fn spawn_joinable<send T>(-data: T, f: fn(T)) -> joinable_task {\n-    let p = comm::port::<task_notification>();\n-    let id = spawn_notify(data, f, comm::chan::<task_notification>(p));\n-    ret (id, p);\n-}\n-\n-// FIXME: To transition from the unsafe spawn that spawns a shared closure to\n-// the safe spawn that spawns a bare function we're going to write\n-// barefunc-spawn on top of unsafe-spawn.  Sadly, bind does not work reliably\n-// enough to suite our needs (#1034, probably others yet to be discovered), so\n-// we're going to copy the bootstrap data into a unique pointer, cast it to an\n-// unsafe pointer then wrap up the bare function and the unsafe pointer in a\n-// shared closure to spawn.\n-//\n-// After the transition this should all be rewritten.\n-\n-fn spawn_inner<send T>(-data: T, f: fn(T),\n-                          notify: option<comm::chan<task_notification>>)\n-    -> task unsafe {\n-\n-    fn wrapper<send T>(data: *u8, f: fn(T)) unsafe {\n-        let data: ~T = unsafe::reinterpret_cast(data);\n-        f(*data);\n-    }\n-\n-    let data = ~data;\n-    let dataptr: *u8 = unsafe::reinterpret_cast(data);\n-    unsafe::leak(data);\n-    let wrapped = bind wrapper(dataptr, f);\n-    ret unsafe_spawn_inner(wrapped, notify);\n-}\n-\n-// FIXME: This is the old spawn function that spawns a shared closure.\n-// It is a hack and needs to be rewritten.\n-fn unsafe_spawn_inner(-thunk: fn@(),\n-                      notify: option<comm::chan<task_notification>>) ->\n-   task unsafe {\n-    let id = rustrt::new_task();\n-\n-    let raw_thunk: {code: uint, env: uint} = cast(thunk);\n-\n-    // set up the task pointer\n-    let task_ptr <- rust_task_ptr(rustrt::get_task_pointer(id));\n-\n-    assert (ptr::null() != (**task_ptr).stack_ptr);\n-\n-    // copy the thunk from our stack to the new stack\n-    let sp: uint = cast((**task_ptr).stack_ptr);\n-    let ptrsize = sys::size_of::<*u8>();\n-    let thunkfn: *mutable uint = cast(sp - ptrsize * 2u);\n-    let thunkenv: *mutable uint = cast(sp - ptrsize);\n-    *thunkfn = cast(raw_thunk.code);;\n-    *thunkenv = cast(raw_thunk.env);;\n-    // align the stack to 16 bytes\n-    (**task_ptr).stack_ptr = cast(sp - ptrsize * 4u);\n-\n-    // set up notifications if they are enabled.\n-    alt notify {\n-      some(c) {\n-        (**task_ptr).notify_enabled = 1;\n-        (**task_ptr).notify_chan = c;\n-      }\n-      none { }\n-    }\n-\n-    // give the thunk environment's allocation to the new task\n-    rustrt::migrate_alloc(cast(raw_thunk.env), id);\n-    rustrt::start_task(id, cast(thunkfn));\n-    // don't cleanup the thunk in this task\n-    unsafe::leak(thunk);\n-    ret id;\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "f33b8414a4d2eee46ac188d5fb90414fefc3f4d3", "filename": "src/libstd/u32.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fu32.rs?ref=f7540b165cfe800ff5bfd2be22cc08510d4d03eb", "patch": "@@ -1,27 +0,0 @@\n-/*\n-Module: u32\n-*/\n-\n-/*\n-Const: min_value\n-\n-Return the minimal value for a u32\n-*/\n-const min_value: u32 = 0u32;\n-\n-/*\n-Const: max_value\n-\n-Return the maximal value for a u32\n-*/\n-const max_value: u32 = 0xffff_ffffu32;\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "0e1a330c6631176565a0f9d144ef565d69e68583", "filename": "src/libstd/u64.rs", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fu64.rs?ref=f7540b165cfe800ff5bfd2be22cc08510d4d03eb", "patch": "@@ -1,88 +0,0 @@\n-/*\n-Module: u64\n-*/\n-\n-/*\n-Const: min_value\n-\n-Return the minimal value for a u64\n-*/\n-const min_value: u64 = 0u64;\n-\n-/*\n-Const: max_value\n-\n-Return the maximal value for a u64\n-*/\n-const max_value: u64 = 18446744073709551615u64;\n-\n-/*\n-Function: to_str\n-\n-Convert to a string in a given base\n-*/\n-fn to_str(n: u64, radix: uint) -> str {\n-    assert (0u < radix && radix <= 16u);\n-\n-    let r64 = radix as u64;\n-\n-    fn digit(n: u64) -> str {\n-        ret alt n {\n-              0u64 { \"0\" }\n-              1u64 { \"1\" }\n-              2u64 { \"2\" }\n-              3u64 { \"3\" }\n-              4u64 { \"4\" }\n-              5u64 { \"5\" }\n-              6u64 { \"6\" }\n-              7u64 { \"7\" }\n-              8u64 { \"8\" }\n-              9u64 { \"9\" }\n-              10u64 { \"a\" }\n-              11u64 { \"b\" }\n-              12u64 { \"c\" }\n-              13u64 { \"d\" }\n-              14u64 { \"e\" }\n-              15u64 { \"f\" }\n-              _ { fail }\n-            };\n-    }\n-\n-    if n == 0u64 { ret \"0\"; }\n-\n-    let s = \"\";\n-\n-    let n = n;\n-    while n > 0u64 { s = digit(n % r64) + s; n /= r64; }\n-    ret s;\n-}\n-\n-/*\n-Function: str\n-\n-Convert to a string\n-*/\n-fn str(n: u64) -> str { ret to_str(n, 10u); }\n-\n-/*\n-Function: parse_buf\n-\n-Parse a string as an unsigned integer.\n-*/\n-fn from_str(buf: str, radix: u64) -> u64 {\n-    if str::byte_len(buf) == 0u {\n-        log_err \"parse_buf(): buf is empty\";\n-        fail;\n-    }\n-    let i = str::byte_len(buf) - 1u;\n-    let power = 1u64, n = 0u64;\n-    while true {\n-        let digit = char::to_digit(buf[i] as char) as u64;\n-        if digit >= radix { fail; }\n-        n += digit * power;\n-        power *= radix;\n-        if i == 0u { ret n; }\n-        i -= 1u;\n-    }\n-    fail;\n-}"}, {"sha": "eadfcadda4a12cd15f547cd91bae50cc944d7b2c", "filename": "src/libstd/u8.rs", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fu8.rs?ref=f7540b165cfe800ff5bfd2be22cc08510d4d03eb", "patch": "@@ -1,68 +0,0 @@\n-/*\n-Module: u8\n-*/\n-\n-/*\n-Const: max_value\n-\n-The maximum value of a u8.\n-*/\n-const max_value: u8 = 255u8;\n-\n-/*\n-Const: min_value\n-\n-The minumum value of a u8.\n-*/\n-const min_value: u8 = 0u8;\n-\n-/* Function: add */\n-pure fn add(x: u8, y: u8) -> u8 { ret x + y; }\n-\n-/* Function: sub */\n-pure fn sub(x: u8, y: u8) -> u8 { ret x - y; }\n-\n-/* Function: mul */\n-pure fn mul(x: u8, y: u8) -> u8 { ret x * y; }\n-\n-/* Function: div */\n-pure fn div(x: u8, y: u8) -> u8 { ret x / y; }\n-\n-/* Function: rem */\n-pure fn rem(x: u8, y: u8) -> u8 { ret x % y; }\n-\n-/* Predicate: lt */\n-pure fn lt(x: u8, y: u8) -> bool { ret x < y; }\n-\n-/* Predicate: le */\n-pure fn le(x: u8, y: u8) -> bool { ret x <= y; }\n-\n-/* Predicate: eq */\n-pure fn eq(x: u8, y: u8) -> bool { ret x == y; }\n-\n-/* Predicate: ne */\n-pure fn ne(x: u8, y: u8) -> bool { ret x != y; }\n-\n-/* Predicate: ge */\n-pure fn ge(x: u8, y: u8) -> bool { ret x >= y; }\n-\n-/* Predicate: gt */\n-pure fn gt(x: u8, y: u8) -> bool { ret x > y; }\n-\n-/*\n-Function: range\n-\n-Iterate over the range [`lo`..`hi`)\n-*/\n-fn range(lo: u8, hi: u8, it: block(u8)) {\n-    let i = lo;\n-    while i < hi { it(i); i += 1u8; }\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "ae1ba628aa644596af9c903e3cf8ca460be9f8d8", "filename": "src/libstd/uint.rs", "status": "removed", "additions": 0, "deletions": 254, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuint.rs?ref=f7540b165cfe800ff5bfd2be22cc08510d4d03eb", "patch": "@@ -1,254 +0,0 @@\n-/*\n-Module: uint\n-*/\n-\n-/*\n-Const: min_value\n-\n-Return the minimal value for an uint.\n-\n-This is always 0\n-*/\n-const min_value: uint = 0u;\n-\n-/*\n-Const: max_value\n-\n-Return the maximal value for an uint.\n-\n-This is 2^wordsize - 1\n-*/\n-const max_value: uint = 0u - 1u;\n-\n-/* Function: add */\n-pure fn add(x: uint, y: uint) -> uint { ret x + y; }\n-\n-/* Function: sub */\n-pure fn sub(x: uint, y: uint) -> uint { ret x - y; }\n-\n-/* Function: mul */\n-pure fn mul(x: uint, y: uint) -> uint { ret x * y; }\n-\n-/* Function: div */\n-pure fn div(x: uint, y: uint) -> uint { ret x / y; }\n-\n-/* Function: div_ceil\n-\n-   Divide two numbers, return the result, rounded up.\n-\n-   Parameters:\n-   x - an integer\n-   y - an integer distinct from 0u\n-\n-   Return:\n-    The smallest integer `q` such that `x/y <= q`.\n-*/\n-pure fn div_ceil(x: uint, y: uint) -> uint {\n-    let div = div(x, y);\n-    if x % y == 0u { ret div;}\n-    else { ret div + 1u; }\n-}\n-\n-/* Function: div_ceil\n-\n-   Divide two numbers, return the result, rounded to the closest integer.\n-\n-   Parameters:\n-   x - an integer\n-   y - an integer distinct from 0u\n-\n-   Return:\n-    The integer `q` closest to `x/y`.\n-*/\n-pure fn div_round(x: uint, y: uint) -> uint {\n-    let div = div(x, y);\n-    if x % y * 2u  < y { ret div;}\n-    else { ret div + 1u; }\n-}\n-\n-/* Function: div_ceil\n-\n-   Divide two numbers, return the result, rounded down.\n-\n-   Parameters:\n-   x - an integer\n-   y - an integer distinct from 0u\n-\n-   Note: This is the same function as `div`.\n-\n-   Return:\n-    The smallest integer `q` such that `x/y <= q`. This\n-   is either `x/y` or `x/y + 1`.\n-*/\n-pure fn div_floor(x: uint, y: uint) -> uint { ret x / y; }\n-\n-/* Function: rem */\n-pure fn rem(x: uint, y: uint) -> uint { ret x % y; }\n-\n-/* Predicate: lt */\n-pure fn lt(x: uint, y: uint) -> bool { ret x < y; }\n-\n-/* Predicate: le */\n-pure fn le(x: uint, y: uint) -> bool { ret x <= y; }\n-\n-/* Predicate: eq */\n-pure fn eq(x: uint, y: uint) -> bool { ret x == y; }\n-\n-/* Predicate: ne */\n-pure fn ne(x: uint, y: uint) -> bool { ret x != y; }\n-\n-/* Predicate: ge */\n-pure fn ge(x: uint, y: uint) -> bool { ret x >= y; }\n-\n-/* Predicate: gt */\n-pure fn gt(x: uint, y: uint) -> bool { ret x > y; }\n-\n-/*\n-Function: range\n-\n-Iterate over the range [`lo`..`hi`)\n-*/\n-fn range(lo: uint, hi: uint, it: block(uint)) {\n-    let i = lo;\n-    while i < hi { it(i); i += 1u; }\n-}\n-\n-/*\n-Function: loop\n-\n-Iterate over the range [`lo`..`hi`), or stop when requested\n-\n-Parameters:\n-lo - The integer at which to start the loop (included)\n-hi - The integer at which to stop the loop (excluded)\n-it - A block to execute with each consecutive integer of the range.\n-Return `true` to continue, `false` to stop.\n-\n-Returns:\n-\n-`true` If execution proceeded correctly, `false` if it was interrupted,\n-that is if `it` returned `false` at any point.\n-*/\n-fn loop(lo: uint, hi: uint, it: block(uint) -> bool) -> bool {\n-    let i = lo;\n-    while i < hi {\n-        if (!it(i)) { ret false; }\n-        i += 1u;\n-    }\n-    ret true;\n-}\n-\n-/*\n-Function: next_power_of_two\n-\n-Returns the smallest power of 2 greater than or equal to `n`\n-*/\n-fn next_power_of_two(n: uint) -> uint {\n-    let halfbits: uint = sys::size_of::<uint>() * 4u;\n-    let tmp: uint = n - 1u;\n-    let shift: uint = 1u;\n-    while shift <= halfbits { tmp |= tmp >> shift; shift <<= 1u; }\n-    ret tmp + 1u;\n-}\n-\n-/*\n-Function: parse_buf\n-\n-Parse a buffer of bytes\n-\n-Parameters:\n-\n-buf - A byte buffer\n-radix - The base of the number\n-\n-Failure:\n-\n-buf must not be empty\n-*/\n-fn parse_buf(buf: [u8], radix: uint) -> uint {\n-    if vec::len::<u8>(buf) == 0u {\n-        log_err \"parse_buf(): buf is empty\";\n-        fail;\n-    }\n-    let i = vec::len::<u8>(buf) - 1u;\n-    let power = 1u;\n-    let n = 0u;\n-    while true {\n-        let digit = char::to_digit(buf[i] as char);\n-        if (digit as uint) >= radix {\n-            fail;\n-        }\n-        n += (digit as uint) * power;\n-        power *= radix;\n-        if i == 0u { ret n; }\n-        i -= 1u;\n-    }\n-    fail;\n-}\n-\n-/*\n-Function: from_str\n-\n-Parse a string to an int\n-\n-Failure:\n-\n-s must not be empty\n-*/\n-fn from_str(s: str) -> uint { parse_buf(str::bytes(s), 10u) }\n-\n-/*\n-Function: to_str\n-\n-Convert to a string in a given base\n-*/\n-fn to_str(num: uint, radix: uint) -> str {\n-    let n = num;\n-    assert (0u < radix && radix <= 16u);\n-    fn digit(n: uint) -> char {\n-        ret alt n {\n-              0u { '0' }\n-              1u { '1' }\n-              2u { '2' }\n-              3u { '3' }\n-              4u { '4' }\n-              5u { '5' }\n-              6u { '6' }\n-              7u { '7' }\n-              8u { '8' }\n-              9u { '9' }\n-              10u { 'a' }\n-              11u { 'b' }\n-              12u { 'c' }\n-              13u { 'd' }\n-              14u { 'e' }\n-              15u { 'f' }\n-              _ { fail }\n-            };\n-    }\n-    if n == 0u { ret \"0\"; }\n-    let s: str = \"\";\n-    while n != 0u {\n-        s += str::unsafe_from_byte(digit(n % radix) as u8);\n-        n /= radix;\n-    }\n-    let s1: str = \"\";\n-    let len: uint = str::byte_len(s);\n-    while len != 0u { len -= 1u; s1 += str::unsafe_from_byte(s[len]); }\n-    ret s1;\n-}\n-\n-/*\n-Function: str\n-\n-Convert to a string\n-*/\n-fn str(i: uint) -> str { ret to_str(i, 10u); }\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "22cce4956498260f83a5fd5771d0266c071c3c0c", "filename": "src/libstd/unsafe.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funsafe.rs?ref=f7540b165cfe800ff5bfd2be22cc08510d4d03eb", "patch": "@@ -1,41 +0,0 @@\n-/*\n-Module: unsafe\n-\n-Unsafe operations\n-*/\n-\n-#[abi = \"rust-intrinsic\"]\n-native mod rusti {\n-    fn cast<T, U>(src: T) -> U;\n-}\n-\n-#[abi = \"cdecl\"]\n-native mod rustrt {\n-    fn leak<T>(-thing: T);\n-}\n-\n-/*\n-Function: reinterpret_cast\n-\n-Casts the value at `src` to U. The two types must have the same length.\n-*/\n-unsafe fn reinterpret_cast<T, U>(src: T) -> U {\n-    let t1 = sys::get_type_desc::<T>();\n-    let t2 = sys::get_type_desc::<U>();\n-    if (*t1).size != (*t2).size {\n-        fail \"attempt to cast values of differing sizes\";\n-    }\n-    ret rusti::cast(src);\n-}\n-\n-/*\n-Function: leak\n-\n-Move `thing` into the void.\n-\n-The leak function will take ownership of the provided value but neglect\n-to run any required cleanup or memory-management operations on it. This\n-can be used for various acts of magick, particularly when using\n-reinterpret_cast on managed pointer types.\n-*/\n-unsafe fn leak<T>(-thing: T) { rustrt::leak(thing); }"}, {"sha": "1e211d0ffcb6a6d990787f2bb98cbc65462485b2", "filename": "src/libstd/vec.rs", "status": "removed", "additions": 0, "deletions": 836, "changes": 836, "blob_url": "https://github.com/rust-lang/rust/blob/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7540b165cfe800ff5bfd2be22cc08510d4d03eb/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=f7540b165cfe800ff5bfd2be22cc08510d4d03eb", "patch": "@@ -1,836 +0,0 @@\n-/*\n-Module: vec\n-*/\n-\n-import core::option;\n-import option::{some, none};\n-import uint::next_power_of_two;\n-import ptr::addr_of;\n-\n-#[abi = \"rust-intrinsic\"]\n-native mod rusti {\n-    fn vec_len<T>(&&v: [const T]) -> uint;\n-}\n-\n-#[abi = \"cdecl\"]\n-native mod rustrt {\n-    fn vec_reserve_shared<T>(t: *sys::type_desc,\n-                             &v: [const T],\n-                             n: uint);\n-    fn vec_from_buf_shared<T>(t: *sys::type_desc,\n-                              ptr: *T,\n-                              count: uint) -> [T];\n-}\n-\n-/*\n-Type: init_op\n-\n-A function used to initialize the elements of a vector.\n-*/\n-type init_op<T> = block(uint) -> T;\n-\n-\n-/*\n-Predicate: is_empty\n-\n-Returns true if a vector contains no elements.\n-*/\n-pure fn is_empty<T>(v: [const T]) -> bool {\n-    // FIXME: This would be easier if we could just call len\n-    for t: T in v { ret false; }\n-    ret true;\n-}\n-\n-/*\n-Predicate: is_not_empty\n-\n-Returns true if a vector contains some elements.\n-*/\n-pure fn is_not_empty<T>(v: [const T]) -> bool { ret !is_empty(v); }\n-\n-/*\n-Predicate: same_length\n-\n-Returns true if two vectors have the same length\n-*/\n-pure fn same_length<T, U>(xs: [T], ys: [U]) -> bool {\n-    vec::len(xs) == vec::len(ys)\n-}\n-\n-/*\n-Function: reserve\n-\n-Reserves capacity for `n` elements in the given vector.\n-\n-If the capacity for `v` is already equal to or greater than the requested\n-capacity, then no action is taken.\n-\n-Parameters:\n-\n-v - A vector\n-n - The number of elements to reserve space for\n-*/\n-fn reserve<T>(&v: [const T], n: uint) {\n-    rustrt::vec_reserve_shared(sys::get_type_desc::<T>(), v, n);\n-}\n-\n-/*\n-Function: len\n-\n-Returns the length of a vector\n-*/\n-pure fn len<T>(v: [const T]) -> uint { unchecked { rusti::vec_len(v) } }\n-\n-/*\n-Function: init_fn\n-\n-Creates and initializes an immutable vector.\n-\n-Creates an immutable vector of size `n_elts` and initializes the elements\n-to the value returned by the function `op`.\n-*/\n-fn init_fn<T>(op: init_op<T>, n_elts: uint) -> [T] {\n-    let v = [];\n-    reserve(v, n_elts);\n-    let i: uint = 0u;\n-    while i < n_elts { v += [op(i)]; i += 1u; }\n-    ret v;\n-}\n-\n-// TODO: Remove me once we have slots.\n-/*\n-Function: init_fn_mut\n-\n-Creates and initializes a mutable vector.\n-\n-Creates a mutable vector of size `n_elts` and initializes the elements to\n-the value returned by the function `op`.\n-*/\n-fn init_fn_mut<T>(op: init_op<T>, n_elts: uint) -> [mutable T] {\n-    let v = [mutable];\n-    reserve(v, n_elts);\n-    let i: uint = 0u;\n-    while i < n_elts { v += [mutable op(i)]; i += 1u; }\n-    ret v;\n-}\n-\n-/*\n-Function: init_elt\n-\n-Creates and initializes an immutable vector.\n-\n-Creates an immutable vector of size `n_elts` and initializes the elements\n-to the value `t`.\n-*/\n-fn init_elt<copy T>(t: T, n_elts: uint) -> [T] {\n-    let v = [];\n-    reserve(v, n_elts);\n-    let i: uint = 0u;\n-    while i < n_elts { v += [t]; i += 1u; }\n-    ret v;\n-}\n-\n-// TODO: Remove me once we have slots.\n-/*\n-Function: init_elt_mut\n-\n-Creates and initializes a mutable vector.\n-\n-Creates a mutable vector of size `n_elts` and initializes the elements\n-to the value `t`.\n-*/\n-fn init_elt_mut<copy T>(t: T, n_elts: uint) -> [mutable T] {\n-    let v = [mutable];\n-    reserve(v, n_elts);\n-    let i: uint = 0u;\n-    while i < n_elts { v += [mutable t]; i += 1u; }\n-    ret v;\n-}\n-\n-// FIXME: Possible typestate postcondition:\n-// len(result) == len(v) (needs issue #586)\n-/*\n-Function: to_mut\n-\n-Produces a mutable vector from an immutable vector.\n-*/\n-fn to_mut<copy T>(v: [T]) -> [mutable T] {\n-    let vres = [mutable];\n-    for t: T in v { vres += [mutable t]; }\n-    ret vres;\n-}\n-\n-// Same comment as from_mut\n-/*\n-Function: from_mut\n-\n-Produces an immutable vector from a mutable vector.\n-*/\n-fn from_mut<copy T>(v: [mutable T]) -> [T] {\n-    let vres = [];\n-    for t: T in v { vres += [t]; }\n-    ret vres;\n-}\n-\n-// Accessors\n-\n-/*\n-Function: head\n-\n-Returns the first element of a vector\n-\n-Predicates:\n-<is_not_empty> (v)\n-*/\n-fn head<copy T>(v: [const T]) : is_not_empty(v) -> T { ret v[0]; }\n-\n-/*\n-Function: tail\n-\n-Returns all but the first element of a vector\n-\n-Predicates:\n-<is_not_empty> (v)\n-*/\n-fn tail<copy T>(v: [const T]) : is_not_empty(v) -> [T] {\n-    ret slice(v, 1u, len(v));\n-}\n-\n-// FIXME: This name is sort of confusing next to init_fn, etc\n-// but this is the name haskell uses for this function,\n-// along with head/tail/last.\n-/*\n-Function: init\n-\n-Returns all but the last elemnt of a vector\n-\n-Preconditions:\n-`v` is not empty\n-*/\n-fn init<copy T>(v: [const T]) -> [T] {\n-    assert len(v) != 0u;\n-    slice(v, 0u, len(v) - 1u)\n-}\n-\n-/*\n-Function: last\n-\n-Returns the last element of a vector\n-\n-Returns:\n-\n-An option containing the last element of `v` if `v` is not empty, or\n-none if `v` is empty.\n-*/\n-fn last<copy T>(v: [const T]) -> option::t<T> {\n-    if len(v) == 0u { ret none; }\n-    ret some(v[len(v) - 1u]);\n-}\n-\n-/*\n-Function: last_total\n-\n-Returns the last element of a non-empty vector `v`\n-\n-Predicates:\n-<is_not_empty> (v)\n-*/\n-fn last_total<copy T>(v: [const T]) : is_not_empty(v) -> T {\n-    ret v[len(v) - 1u];\n-}\n-\n-/*\n-Function: slice\n-\n-Returns a copy of the elements from [`start`..`end`) from `v`.\n-*/\n-fn slice<copy T>(v: [const T], start: uint, end: uint) -> [T] {\n-    assert (start <= end);\n-    assert (end <= len(v));\n-    let result = [];\n-    reserve(result, end - start);\n-    let i = start;\n-    while i < end { result += [v[i]]; i += 1u; }\n-    ret result;\n-}\n-\n-// TODO: Remove me once we have slots.\n-/*\n-Function: slice_mut\n-\n-Returns a copy of the elements from [`start`..`end`) from `v`.\n-*/\n-fn slice_mut<copy T>(v: [const T], start: uint, end: uint) -> [mutable T] {\n-    assert (start <= end);\n-    assert (end <= len(v));\n-    let result = [mutable];\n-    reserve(result, end - start);\n-    let i = start;\n-    while i < end { result += [mutable v[i]]; i += 1u; }\n-    ret result;\n-}\n-\n-\n-// Mutators\n-\n-/*\n-Function: shift\n-\n-Removes the first element from a vector and return it\n-*/\n-fn shift<copy T>(&v: [const T]) -> T {\n-    let ln = len::<T>(v);\n-    assert (ln > 0u);\n-    let e = v[0];\n-    v = slice::<T>(v, 1u, ln);\n-    ret e;\n-}\n-\n-// TODO: Write this, unsafely, in a way that's not O(n).\n-/*\n-Function: pop\n-\n-Remove the last element from a vector and return it\n-*/\n-fn pop<copy T>(&v: [const T]) -> T {\n-    let ln = len(v);\n-    assert (ln > 0u);\n-    ln -= 1u;\n-    let e = v[ln];\n-    v = slice(v, 0u, ln);\n-    ret e;\n-}\n-\n-// TODO: More.\n-\n-\n-// Appending\n-\n-/*\n-Function: grow\n-\n-Expands a vector in place, initializing the new elements to a given value\n-\n-Parameters:\n-\n-v - The vector to grow\n-n - The number of elements to add\n-initval - The value for the new elements\n-*/\n-fn grow<copy T>(&v: [T], n: uint, initval: T) {\n-    reserve(v, next_power_of_two(len(v) + n));\n-    let i: uint = 0u;\n-    while i < n { v += [initval]; i += 1u; }\n-}\n-\n-// TODO: Remove me once we have slots.\n-// FIXME: Can't grow take a [const T]\n-/*\n-Function: grow_mut\n-\n-Expands a vector in place, initializing the new elements to a given value\n-\n-Parameters:\n-\n-v - The vector to grow\n-n - The number of elements to add\n-initval - The value for the new elements\n-*/\n-fn grow_mut<copy T>(&v: [mutable T], n: uint, initval: T) {\n-    reserve(v, next_power_of_two(len(v) + n));\n-    let i: uint = 0u;\n-    while i < n { v += [mutable initval]; i += 1u; }\n-}\n-\n-/*\n-Function: grow_fn\n-\n-Expands a vector in place, initializing the new elements to the result of a\n-function\n-\n-Function `init_fn` is called `n` times with the values [0..`n`)\n-\n-Parameters:\n-\n-v - The vector to grow\n-n - The number of elements to add\n-init_fn - A function to call to retreive each appended element's value\n-*/\n-fn grow_fn<T>(&v: [T], n: uint, op: init_op<T>) {\n-    reserve(v, next_power_of_two(len(v) + n));\n-    let i: uint = 0u;\n-    while i < n { v += [op(i)]; i += 1u; }\n-}\n-\n-/*\n-Function: grow_set\n-\n-Sets the value of a vector element at a given index, growing the vector as\n-needed\n-\n-Sets the element at position `index` to `val`. If `index` is past the end\n-of the vector, expands the vector by replicating `initval` to fill the\n-intervening space.\n-*/\n-fn grow_set<copy T>(&v: [mutable T], index: uint, initval: T, val: T) {\n-    if index >= len(v) { grow_mut(v, index - len(v) + 1u, initval); }\n-    v[index] = val;\n-}\n-\n-\n-// Functional utilities\n-\n-/*\n-Function: map\n-\n-Apply a function to each element of a vector and return the results\n-*/\n-fn map<T, U>(f: block(T) -> U, v: [T]) -> [U] {\n-    let result = [];\n-    reserve(result, len(v));\n-    for elem: T in v { result += [f(elem)]; }\n-    ret result;\n-}\n-\n-/*\n-Function: map_mut\n-\n-Apply a function to each element of a mutable vector and return the results\n-*/\n-fn map_mut<copy T, U>(f: block(T) -> U, v: [const T]) -> [U] {\n-    let result = [];\n-    reserve(result, len(v));\n-    for elem: T in v {\n-        // copy satisfies alias checker\n-        result += [f(copy elem)];\n-    }\n-    ret result;\n-}\n-\n-/*\n-Function: map2\n-\n-Apply a function to each pair of elements and return the results\n-*/\n-fn map2<copy T, copy U, V>(f: block(T, U) -> V, v0: [T], v1: [U]) -> [V] {\n-    let v0_len = len(v0);\n-    if v0_len != len(v1) { fail; }\n-    let u: [V] = [];\n-    let i = 0u;\n-    while i < v0_len { u += [f(copy v0[i], copy v1[i])]; i += 1u; }\n-    ret u;\n-}\n-\n-/*\n-Function: filter_map\n-\n-Apply a function to each element of a vector and return the results\n-\n-If function `f` returns `none` then that element is excluded from\n-the resulting vector.\n-*/\n-fn filter_map<copy T, copy U>(f: block(T) -> option::t<U>, v: [const T])\n-    -> [U] {\n-    let result = [];\n-    for elem: T in v {\n-        alt f(copy elem) {\n-          none. {/* no-op */ }\n-          some(result_elem) { result += [result_elem]; }\n-        }\n-    }\n-    ret result;\n-}\n-\n-/*\n-Function: filter\n-\n-Construct a new vector from the elements of a vector for which some predicate\n-holds.\n-\n-Apply function `f` to each element of `v` and return a vector containing\n-only those elements for which `f` returned true.\n-*/\n-fn filter<copy T>(f: block(T) -> bool, v: [T]) -> [T] {\n-    let result = [];\n-    for elem: T in v {\n-        if f(elem) { result += [elem]; }\n-    }\n-    ret result;\n-}\n-\n-/*\n-Function: concat\n-\n-Concatenate a vector of vectors. Flattens a vector of vectors of T into\n-a single vector of T.\n-*/\n-fn concat<copy T>(v: [const [const T]]) -> [T] {\n-    let new: [T] = [];\n-    for inner: [T] in v { new += inner; }\n-    ret new;\n-}\n-\n-/*\n-Function: foldl\n-\n-Reduce a vector from left to right\n-*/\n-fn foldl<copy T, U>(p: block(T, U) -> T, z: T, v: [const U]) -> T {\n-    let accum = z;\n-    iter(v) { |elt|\n-        accum = p(accum, elt);\n-    }\n-    ret accum;\n-}\n-\n-/*\n-Function: foldr\n-\n-Reduce a vector from right to left\n-*/\n-fn foldr<T, copy U>(p: block(T, U) -> U, z: U, v: [const T]) -> U {\n-    let accum = z;\n-    riter(v) { |elt|\n-        accum = p(elt, accum);\n-    }\n-    ret accum;\n-}\n-\n-/*\n-Function: any\n-\n-Return true if a predicate matches any elements\n-\n-If the vector contains no elements then false is returned.\n-*/\n-fn any<T>(f: block(T) -> bool, v: [T]) -> bool {\n-    for elem: T in v { if f(elem) { ret true; } }\n-    ret false;\n-}\n-\n-/*\n-Function: all\n-\n-Return true if a predicate matches all elements\n-\n-If the vector contains no elements then true is returned.\n-*/\n-fn all<T>(f: block(T) -> bool, v: [T]) -> bool {\n-    for elem: T in v { if !f(elem) { ret false; } }\n-    ret true;\n-}\n-\n-/*\n-Function: member\n-\n-Return true if a vector contains an element with the given value\n-*/\n-fn member<T>(x: T, v: [T]) -> bool {\n-    for elt: T in v { if x == elt { ret true; } }\n-    ret false;\n-}\n-\n-/*\n-Function: count\n-\n-Returns the number of elements that are equal to a given value\n-*/\n-fn count<T>(x: T, v: [const T]) -> uint {\n-    let cnt = 0u;\n-    for elt: T in v { if x == elt { cnt += 1u; } }\n-    ret cnt;\n-}\n-\n-/*\n-Function: find\n-\n-Search for an element that matches a given predicate\n-\n-Apply function `f` to each element of `v`, starting from the first.\n-When function `f` returns true then an option containing the element\n-is returned. If `f` matches no elements then none is returned.\n-*/\n-fn find<copy T>(f: block(T) -> bool, v: [T]) -> option::t<T> {\n-    for elt: T in v { if f(elt) { ret some(elt); } }\n-    ret none;\n-}\n-\n-/*\n-Function: position\n-\n-Find the first index containing a matching value\n-\n-Returns:\n-\n-option::some(uint) - The first index containing a matching value\n-option::none - No elements matched\n-*/\n-fn position<T>(x: T, v: [T]) -> option::t<uint> {\n-    let i: uint = 0u;\n-    while i < len(v) { if x == v[i] { ret some::<uint>(i); } i += 1u; }\n-    ret none;\n-}\n-\n-/*\n-Function: position_pred\n-\n-Find the first index for which the value matches some predicate\n-*/\n-fn position_pred<T>(f: block(T) -> bool, v: [T]) -> option::t<uint> {\n-    let i: uint = 0u;\n-    while i < len(v) { if f(v[i]) { ret some::<uint>(i); } i += 1u; }\n-    ret none;\n-}\n-\n-// FIXME: if issue #586 gets implemented, could have a postcondition\n-// saying the two result lists have the same length -- or, could\n-// return a nominal record with a constraint saying that, instead of\n-// returning a tuple (contingent on issue #869)\n-/*\n-Function: unzip\n-\n-Convert a vector of pairs into a pair of vectors\n-\n-Returns a tuple containing two vectors where the i-th element of the first\n-vector contains the first element of the i-th tuple of the input vector,\n-and the i-th element of the second vector contains the second element\n-of the i-th tuple of the input vector.\n-*/\n-fn unzip<copy T, copy U>(v: [(T, U)]) -> ([T], [U]) {\n-    let as = [], bs = [];\n-    for (a, b) in v { as += [a]; bs += [b]; }\n-    ret (as, bs);\n-}\n-\n-/*\n-Function: zip\n-\n-Convert two vectors to a vector of pairs\n-\n-Returns a vector of tuples, where the i-th tuple contains contains the\n-i-th elements from each of the input vectors.\n-\n-Preconditions:\n-\n-<same_length> (v, u)\n-*/\n-fn zip<copy T, copy U>(v: [T], u: [U]) : same_length(v, u) -> [(T, U)] {\n-    let zipped = [];\n-    let sz = len(v), i = 0u;\n-    assert (sz == len(u));\n-    while i < sz { zipped += [(v[i], u[i])]; i += 1u; }\n-    ret zipped;\n-}\n-\n-/*\n-Function: swap\n-\n-Swaps two elements in a vector\n-\n-Parameters:\n-v - The input vector\n-a - The index of the first element\n-b - The index of the second element\n-*/\n-fn swap<T>(v: [mutable T], a: uint, b: uint) {\n-    v[a] <-> v[b];\n-}\n-\n-/*\n-Function: reverse\n-\n-Reverse the order of elements in a vector, in place\n-*/\n-fn reverse<T>(v: [mutable T]) {\n-    let i: uint = 0u;\n-    let ln = len::<T>(v);\n-    while i < ln / 2u { v[i] <-> v[ln - i - 1u]; i += 1u; }\n-}\n-\n-\n-/*\n-Function: reversed\n-\n-Returns a vector with the order of elements reversed\n-*/\n-fn reversed<copy T>(v: [const T]) -> [T] {\n-    let rs: [T] = [];\n-    let i = len::<T>(v);\n-    if i == 0u { ret rs; } else { i -= 1u; }\n-    while i != 0u { rs += [v[i]]; i -= 1u; }\n-    rs += [v[0]];\n-    ret rs;\n-}\n-\n-// FIXME: Seems like this should take char params. Maybe belongs in char\n-/*\n-Function: enum_chars\n-\n-Returns a vector containing a range of chars\n-*/\n-fn enum_chars(start: u8, end: u8) : u8::le(start, end) -> [char] {\n-    let i = start;\n-    let r = [];\n-    while i <= end { r += [i as char]; i += 1u as u8; }\n-    ret r;\n-}\n-\n-// FIXME: Probably belongs in uint. Compare to uint::range\n-/*\n-Function: enum_uints\n-\n-Returns a vector containing a range of uints\n-*/\n-fn enum_uints(start: uint, end: uint) : uint::le(start, end) -> [uint] {\n-    let i = start;\n-    let r = [];\n-    while i <= end { r += [i]; i += 1u; }\n-    ret r;\n-}\n-\n-/*\n-Function: iter\n-\n-Iterates over a vector\n-\n-Iterates over vector `v` and, for each element, calls function `f` with the\n-element's value.\n-\n-*/\n-fn iter<T>(v: [const T], f: block(T)) {\n-    iter2(v) { |_i, v| f(v) }\n-}\n-\n-/*\n-Function: iter2\n-\n-Iterates over a vector's elements and indexes\n-\n-Iterates over vector `v` and, for each element, calls function `f` with the\n-element's value and index.\n-*/\n-fn iter2<T>(v: [const T], f: block(uint, T)) {\n-    let i = 0u, l = len(v);\n-    while i < l { f(i, v[i]); i += 1u; }\n-}\n-\n-/*\n-Function: riter\n-\n-Iterates over a vector in reverse\n-\n-Iterates over vector `v` and, for each element, calls function `f` with the\n-element's value.\n-\n-*/\n-fn riter<T>(v: [const T], f: block(T)) {\n-    riter2(v) { |_i, v| f(v) }\n-}\n-\n-/*\n-Function: riter2\n-\n-Iterates over a vector's elements and indexes in reverse\n-\n-Iterates over vector `v` and, for each element, calls function `f` with the\n-element's value and index.\n-*/\n-fn riter2<T>(v: [const T], f: block(uint, T)) {\n-    let i = len(v);\n-    while 0u < i {\n-        i -= 1u;\n-        f(i, v[i]);\n-    };\n-}\n-\n-/*\n-Function: permute\n-\n-Iterate over all permutations of vector `v`.  Permutations are produced in\n-lexicographic order with respect to the order of elements in `v` (so if `v`\n-is sorted then the permutations are lexicographically sorted).\n-\n-The total number of permutations produced is `len(v)!`.  If `v` contains\n-repeated elements, then some permutations are repeated.\n-*/\n-fn permute<copy T>(v: [const T], put: block([T])) {\n-  let ln = len(v);\n-  if ln == 0u {\n-    put([]);\n-  } else {\n-    let i = 0u;\n-    while i < ln {\n-      let elt = v[i];\n-      let rest = slice(v, 0u, i) + slice(v, i+1u, ln);\n-      permute(rest) {|permutation| put([elt] + permutation)}\n-      i += 1u;\n-    }\n-  }\n-}\n-\n-/*\n-Function: to_ptr\n-\n-FIXME: We don't need this wrapper\n-*/\n-unsafe fn to_ptr<T>(v: [T]) -> *T { ret unsafe::to_ptr(v); }\n-\n-/*\n-Module: unsafe\n-*/\n-mod unsafe {\n-    type vec_repr = {mutable fill: uint, mutable alloc: uint, data: u8};\n-\n-    /*\n-    Function: from_buf\n-\n-    Constructs a vector from an unsafe pointer to a buffer\n-\n-    Parameters:\n-\n-    ptr - An unsafe pointer to a buffer of `T`\n-    elts - The number of elements in the buffer\n-    */\n-    unsafe fn from_buf<T>(ptr: *T, elts: uint) -> [T] {\n-        ret rustrt::vec_from_buf_shared(sys::get_type_desc::<T>(),\n-                                        ptr, elts);\n-    }\n-\n-    /*\n-    Function: set_len\n-\n-    Sets the length of a vector\n-\n-    This well explicitly set the size of the vector, without actually\n-    modifing its buffers, so it is up to the caller to ensure that\n-    the vector is actually the specified size.\n-    */\n-    unsafe fn set_len<T>(&v: [const T], new_len: uint) {\n-        let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n-        (**repr).fill = new_len * sys::size_of::<T>();\n-    }\n-\n-    /*\n-    Function: to_ptr\n-\n-    Returns an unsafe pointer to the vector's buffer\n-\n-    The caller must ensure that the vector outlives the pointer this\n-    function returns, or else it will end up pointing to garbage.\n-\n-    Modifying the vector may cause its buffer to be reallocated, which\n-    would also make any pointers to it invalid.\n-    */\n-    unsafe fn to_ptr<T>(v: [const T]) -> *T {\n-        let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n-        ret ::unsafe::reinterpret_cast(addr_of((**repr).data));\n-    }\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}]}