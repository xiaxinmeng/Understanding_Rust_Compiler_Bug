{"sha": "8f091efa4f201c16110efbb668476236bf0b4f5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMDkxZWZhNGYyMDFjMTYxMTBlZmJiNjY4NDc2MjM2YmYwYjRmNWM=", "commit": {"author": {"name": "Carol Nichols", "email": "carol.nichols@gmail.com", "date": "2015-02-14T23:18:41Z"}, "committer": {"name": "Carol Nichols", "email": "carol.nichols@gmail.com", "date": "2015-03-06T01:37:49Z"}, "message": "Add tests to stable f32 and f64 methods that didn't have any", "tree": {"sha": "78df048d149414a2bbebdfd993f522d09c3e2dda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78df048d149414a2bbebdfd993f522d09c3e2dda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f091efa4f201c16110efbb668476236bf0b4f5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f091efa4f201c16110efbb668476236bf0b4f5c", "html_url": "https://github.com/rust-lang/rust/commit/8f091efa4f201c16110efbb668476236bf0b4f5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f091efa4f201c16110efbb668476236bf0b4f5c/comments", "author": {"login": "carols10cents", "id": 193874, "node_id": "MDQ6VXNlcjE5Mzg3NA==", "avatar_url": "https://avatars.githubusercontent.com/u/193874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/carols10cents", "html_url": "https://github.com/carols10cents", "followers_url": "https://api.github.com/users/carols10cents/followers", "following_url": "https://api.github.com/users/carols10cents/following{/other_user}", "gists_url": "https://api.github.com/users/carols10cents/gists{/gist_id}", "starred_url": "https://api.github.com/users/carols10cents/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/carols10cents/subscriptions", "organizations_url": "https://api.github.com/users/carols10cents/orgs", "repos_url": "https://api.github.com/users/carols10cents/repos", "events_url": "https://api.github.com/users/carols10cents/events{/privacy}", "received_events_url": "https://api.github.com/users/carols10cents/received_events", "type": "User", "site_admin": false}, "committer": {"login": "carols10cents", "id": 193874, "node_id": "MDQ6VXNlcjE5Mzg3NA==", "avatar_url": "https://avatars.githubusercontent.com/u/193874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/carols10cents", "html_url": "https://github.com/carols10cents", "followers_url": "https://api.github.com/users/carols10cents/followers", "following_url": "https://api.github.com/users/carols10cents/following{/other_user}", "gists_url": "https://api.github.com/users/carols10cents/gists{/gist_id}", "starred_url": "https://api.github.com/users/carols10cents/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/carols10cents/subscriptions", "organizations_url": "https://api.github.com/users/carols10cents/orgs", "repos_url": "https://api.github.com/users/carols10cents/repos", "events_url": "https://api.github.com/users/carols10cents/events{/privacy}", "received_events_url": "https://api.github.com/users/carols10cents/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33d8a4efea27616e21848a3b69c0195e76201d7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/33d8a4efea27616e21848a3b69c0195e76201d7b", "html_url": "https://github.com/rust-lang/rust/commit/33d8a4efea27616e21848a3b69c0195e76201d7b"}], "stats": {"total": 580, "additions": 580, "deletions": 0}, "files": [{"sha": "ae59271997f6f3aa0909e95b40b19a54d1267471", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 290, "deletions": 0, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/8f091efa4f201c16110efbb668476236bf0b4f5c/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f091efa4f201c16110efbb668476236bf0b4f5c/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=8f091efa4f201c16110efbb668476236bf0b4f5c", "patch": "@@ -485,6 +485,120 @@ mod tests {\n         assert_eq!(2.0f32.max(NAN), 2.0);\n     }\n \n+    #[test]\n+    fn test_nan() {\n+        let nan: f32 = Float::nan();\n+        assert!(nan.is_nan());\n+        assert!(!nan.is_infinite());\n+        assert!(!nan.is_finite());\n+        assert!(!nan.is_normal());\n+        assert!(!nan.is_positive());\n+        assert!(!nan.is_negative());\n+        assert_eq!(Fp::Nan, nan.classify());\n+    }\n+\n+    #[test]\n+    fn test_infinity() {\n+        let inf: f32 = Float::infinity();\n+        assert!(inf.is_infinite());\n+        assert!(!inf.is_finite());\n+        assert!(inf.is_positive());\n+        assert!(!inf.is_negative());\n+        assert!(!inf.is_nan());\n+        assert!(!inf.is_normal());\n+        assert_eq!(Fp::Infinite, inf.classify());\n+    }\n+\n+    #[test]\n+    fn test_neg_infinity() {\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert!(neg_inf.is_infinite());\n+        assert!(!neg_inf.is_finite());\n+        assert!(!neg_inf.is_positive());\n+        assert!(neg_inf.is_negative());\n+        assert!(!neg_inf.is_nan());\n+        assert!(!neg_inf.is_normal());\n+        assert_eq!(Fp::Infinite, neg_inf.classify());\n+    }\n+\n+    #[test]\n+    fn test_zero() {\n+        let zero: f32 = Float::zero();\n+        assert_eq!(0.0, zero);\n+        assert!(!zero.is_infinite());\n+        assert!(zero.is_finite());\n+        assert!(zero.is_positive());\n+        assert!(!zero.is_negative());\n+        assert!(!zero.is_nan());\n+        assert!(!zero.is_normal());\n+        assert_eq!(Fp::Zero, zero.classify());\n+    }\n+\n+    #[test]\n+    fn test_neg_zero() {\n+        let neg_zero: f32 = Float::neg_zero();\n+        assert_eq!(0.0, neg_zero);\n+        assert!(!neg_zero.is_infinite());\n+        assert!(neg_zero.is_finite());\n+        assert!(!neg_zero.is_positive());\n+        assert!(neg_zero.is_negative());\n+        assert!(!neg_zero.is_nan());\n+        assert!(!neg_zero.is_normal());\n+        assert_eq!(Fp::Zero, neg_zero.classify());\n+    }\n+\n+    #[test]\n+    fn test_one() {\n+        let one: f32 = Float::one();\n+        assert_eq!(1.0, one);\n+        assert!(!one.is_infinite());\n+        assert!(one.is_finite());\n+        assert!(one.is_positive());\n+        assert!(!one.is_negative());\n+        assert!(!one.is_nan());\n+        assert!(one.is_normal());\n+        assert_eq!(Fp::Normal, one.classify());\n+    }\n+\n+    #[test]\n+    fn test_is_nan() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert!(nan.is_nan());\n+        assert!(!0.0f32.is_nan());\n+        assert!(!5.3f32.is_nan());\n+        assert!(!(-10.732f32).is_nan());\n+        assert!(!inf.is_nan());\n+        assert!(!neg_inf.is_nan());\n+    }\n+\n+    #[test]\n+    fn test_is_infinite() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert!(!nan.is_infinite());\n+        assert!(inf.is_infinite());\n+        assert!(neg_inf.is_infinite());\n+        assert!(!0.0f32.is_infinite());\n+        assert!(!42.8f32.is_infinite());\n+        assert!(!(-109.2f32).is_infinite());\n+    }\n+\n+    #[test]\n+    fn test_is_finite() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert!(!nan.is_finite());\n+        assert!(!inf.is_finite());\n+        assert!(!neg_inf.is_finite());\n+        assert!(0.0f32.is_finite());\n+        assert!(42.8f32.is_finite());\n+        assert!((-109.2f32).is_finite());\n+    }\n+\n     #[test]\n     fn test_is_normal() {\n         let nan: f32 = Float::nan();\n@@ -649,6 +763,66 @@ mod tests {\n         assert!(!NAN.is_negative());\n     }\n \n+    #[test]\n+    fn test_mul_add() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert_approx_eq!(12.3f32.mul_add(4.5, 6.7), 62.05);\n+        assert_approx_eq!((-12.3f32).mul_add(-4.5, -6.7), 48.65);\n+        assert_approx_eq!(0.0f32.mul_add(8.9, 1.2), 1.2);\n+        assert_approx_eq!(3.4f32.mul_add(-0.0, 5.6), 5.6);\n+        assert!(nan.mul_add(7.8, 9.0).is_nan());\n+        assert_eq!(inf.mul_add(7.8, 9.0), inf);\n+        assert_eq!(neg_inf.mul_add(7.8, 9.0), neg_inf);\n+        assert_eq!(8.9f32.mul_add(inf, 3.2), inf);\n+        assert_eq!((-3.2f32).mul_add(2.4, neg_inf), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_recip() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert_eq!(1.0f32.recip(), 1.0);\n+        assert_eq!(2.0f32.recip(), 0.5);\n+        assert_eq!((-0.4f32).recip(), -2.5);\n+        assert_eq!(0.0f32.recip(), inf);\n+        assert!(nan.recip().is_nan());\n+        assert_eq!(inf.recip(), 0.0);\n+        assert_eq!(neg_inf.recip(), 0.0);\n+    }\n+\n+    #[test]\n+    fn test_powi() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert_eq!(1.0f32.powi(1), 1.0);\n+        assert_approx_eq!((-3.1f32).powi(2), 9.61);\n+        assert_approx_eq!(5.9f32.powi(-2), 0.028727);\n+        assert_eq!(8.3f32.powi(0), 1.0);\n+        assert!(nan.powi(2).is_nan());\n+        assert_eq!(inf.powi(3), inf);\n+        assert_eq!(neg_inf.powi(2), inf);\n+    }\n+\n+    #[test]\n+    fn test_powf() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert_eq!(1.0f32.powf(1.0), 1.0);\n+        assert_approx_eq!(3.4f32.powf(4.5), 246.408218);\n+        assert_approx_eq!(2.7f32.powf(-3.2), 0.041652);\n+        assert_approx_eq!((-3.1f32).powf(2.0), 9.61);\n+        assert_approx_eq!(5.9f32.powf(-2.0), 0.028727);\n+        assert_eq!(8.3f32.powf(0.0), 1.0);\n+        assert!(nan.powf(2.0).is_nan());\n+        assert_eq!(inf.powf(2.0), inf);\n+        assert_eq!(neg_inf.powf(3.0), neg_inf);\n+    }\n+\n     #[test]\n     fn test_sqrt_domain() {\n         assert!(NAN.sqrt().is_nan());\n@@ -660,6 +834,21 @@ mod tests {\n         assert_eq!(INFINITY.sqrt(), INFINITY);\n     }\n \n+    #[test]\n+    fn test_rsqrt() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert!(nan.rsqrt().is_nan());\n+        assert_eq!(inf.rsqrt(), 0.0);\n+        assert!(neg_inf.rsqrt().is_nan());\n+        assert!((-1.0f32).rsqrt().is_nan());\n+        assert_eq!((-0.0f32).rsqrt(), neg_inf);\n+        assert_eq!(0.0f32.rsqrt(), inf);\n+        assert_eq!(1.0f32.rsqrt(), 1.0);\n+        assert_eq!(4.0f32.rsqrt(), 0.5);\n+    }\n+\n     #[test]\n     fn test_exp() {\n         assert_eq!(1.0, 0.0f32.exp());\n@@ -687,14 +876,111 @@ mod tests {\n         assert!(nan.exp2().is_nan());\n     }\n \n+    #[test]\n+    fn test_ln() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert_approx_eq!(1.0f32.exp().ln(), 1.0);\n+        assert!(nan.ln().is_nan());\n+        assert_eq!(inf.ln(), inf);\n+        assert!(neg_inf.ln().is_nan());\n+        assert!((-2.3f32).ln().is_nan());\n+        assert_eq!((-0.0f32).ln(), neg_inf);\n+        assert_eq!(0.0f32.ln(), neg_inf);\n+        assert_approx_eq!(4.0f32.ln(), 1.386294);\n+    }\n+\n+    #[test]\n+    fn test_log() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert_eq!(10.0f32.log(10.0), 1.0);\n+        assert_approx_eq!(2.3f32.log(3.5), 0.664858);\n+        assert_eq!(1.0f32.exp().log(1.0.exp()), 1.0);\n+        assert!(1.0f32.log(1.0).is_nan());\n+        assert!(1.0f32.log(-13.9).is_nan());\n+        assert!(nan.log(2.3).is_nan());\n+        assert_eq!(inf.log(10.0), inf);\n+        assert!(neg_inf.log(8.8).is_nan());\n+        assert!((-2.3f32).log(0.1).is_nan());\n+        assert_eq!((-0.0f32).log(2.0), neg_inf);\n+        assert_eq!(0.0f32.log(7.0), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_log2() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert_approx_eq!(10.0f32.log2(), 3.321928);\n+        assert_approx_eq!(2.3f32.log2(), 1.201634);\n+        assert_approx_eq!(1.0f32.exp().log2(), 1.442695);\n+        assert!(nan.log2().is_nan());\n+        assert_eq!(inf.log2(), inf);\n+        assert!(neg_inf.log2().is_nan());\n+        assert!((-2.3f32).log2().is_nan());\n+        assert_eq!((-0.0f32).log2(), neg_inf);\n+        assert_eq!(0.0f32.log2(), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_log10() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert_eq!(10.0f32.log10(), 1.0);\n+        assert_approx_eq!(2.3f32.log10(), 0.361728);\n+        assert_approx_eq!(1.0f32.exp().log10(), 0.434294);\n+        assert_eq!(1.0f32.log10(), 0.0);\n+        assert!(nan.log10().is_nan());\n+        assert_eq!(inf.log10(), inf);\n+        assert!(neg_inf.log10().is_nan());\n+        assert!((-2.3f32).log10().is_nan());\n+        assert_eq!((-0.0f32).log10(), neg_inf);\n+        assert_eq!(0.0f32.log10(), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_to_degrees() {\n+        let pi: f32 = consts::PI;\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert_eq!(0.0f32.to_degrees(), 0.0);\n+        assert_approx_eq!((-5.8f32).to_degrees(), -332.315521);\n+        assert_eq!(pi.to_degrees(), 180.0);\n+        assert!(nan.to_degrees().is_nan());\n+        assert_eq!(inf.to_degrees(), inf);\n+        assert_eq!(neg_inf.to_degrees(), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_to_radians() {\n+        let pi: f32 = consts::PI;\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert_eq!(0.0f32.to_radians(), 0.0);\n+        assert_approx_eq!(154.6f32.to_radians(), 2.698279);\n+        assert_approx_eq!((-332.31f32).to_radians(), -5.799903);\n+        assert_eq!(180.0f32.to_radians(), pi);\n+        assert!(nan.to_radians().is_nan());\n+        assert_eq!(inf.to_radians(), inf);\n+        assert_eq!(neg_inf.to_radians(), neg_inf);\n+    }\n+\n     #[test]\n     fn test_ldexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n         let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n         let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n+        let f3: f32 = FromStrRadix::from_str_radix(\"1.Cp-12\", 16).unwrap();\n         assert_eq!(Float::ldexp(1f32, -123), f1);\n         assert_eq!(Float::ldexp(1f32, -111), f2);\n+        assert_eq!(Float::ldexp(1.75f32, -12), f3);\n \n         assert_eq!(Float::ldexp(0f32, -123), 0f32);\n         assert_eq!(Float::ldexp(-0f32, -123), -0f32);\n@@ -713,12 +999,16 @@ mod tests {\n         // are supported in floating-point literals\n         let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n         let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n+        let f3: f32 = FromStrRadix::from_str_radix(\"1.Cp-123\", 16).unwrap();\n         let (x1, exp1) = f1.frexp();\n         let (x2, exp2) = f2.frexp();\n+        let (x3, exp3) = f3.frexp();\n         assert_eq!((x1, exp1), (0.5f32, -122));\n         assert_eq!((x2, exp2), (0.5f32, -110));\n+        assert_eq!((x3, exp3), (0.875f32, -122));\n         assert_eq!(Float::ldexp(x1, exp1), f1);\n         assert_eq!(Float::ldexp(x2, exp2), f2);\n+        assert_eq!(Float::ldexp(x3, exp3), f3);\n \n         assert_eq!(0f32.frexp(), (0f32, 0));\n         assert_eq!((-0f32).frexp(), (-0f32, 0));"}, {"sha": "162f6824c8f6290686954c3b2f98990da9ded017", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 290, "deletions": 0, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/8f091efa4f201c16110efbb668476236bf0b4f5c/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f091efa4f201c16110efbb668476236bf0b4f5c/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=8f091efa4f201c16110efbb668476236bf0b4f5c", "patch": "@@ -494,6 +494,120 @@ mod tests {\n         assert_eq!(2.0f64.max(NAN), 2.0);\n     }\n \n+    #[test]\n+    fn test_nan() {\n+        let nan: f64 = Float::nan();\n+        assert!(nan.is_nan());\n+        assert!(!nan.is_infinite());\n+        assert!(!nan.is_finite());\n+        assert!(!nan.is_normal());\n+        assert!(!nan.is_positive());\n+        assert!(!nan.is_negative());\n+        assert_eq!(Fp::Nan, nan.classify());\n+    }\n+\n+    #[test]\n+    fn test_infinity() {\n+        let inf: f64 = Float::infinity();\n+        assert!(inf.is_infinite());\n+        assert!(!inf.is_finite());\n+        assert!(inf.is_positive());\n+        assert!(!inf.is_negative());\n+        assert!(!inf.is_nan());\n+        assert!(!inf.is_normal());\n+        assert_eq!(Fp::Infinite, inf.classify());\n+    }\n+\n+    #[test]\n+    fn test_neg_infinity() {\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert!(neg_inf.is_infinite());\n+        assert!(!neg_inf.is_finite());\n+        assert!(!neg_inf.is_positive());\n+        assert!(neg_inf.is_negative());\n+        assert!(!neg_inf.is_nan());\n+        assert!(!neg_inf.is_normal());\n+        assert_eq!(Fp::Infinite, neg_inf.classify());\n+    }\n+\n+    #[test]\n+    fn test_zero() {\n+        let zero: f64 = Float::zero();\n+        assert_eq!(0.0, zero);\n+        assert!(!zero.is_infinite());\n+        assert!(zero.is_finite());\n+        assert!(zero.is_positive());\n+        assert!(!zero.is_negative());\n+        assert!(!zero.is_nan());\n+        assert!(!zero.is_normal());\n+        assert_eq!(Fp::Zero, zero.classify());\n+    }\n+\n+    #[test]\n+    fn test_neg_zero() {\n+        let neg_zero: f64 = Float::neg_zero();\n+        assert_eq!(0.0, neg_zero);\n+        assert!(!neg_zero.is_infinite());\n+        assert!(neg_zero.is_finite());\n+        assert!(!neg_zero.is_positive());\n+        assert!(neg_zero.is_negative());\n+        assert!(!neg_zero.is_nan());\n+        assert!(!neg_zero.is_normal());\n+        assert_eq!(Fp::Zero, neg_zero.classify());\n+    }\n+\n+    #[test]\n+    fn test_one() {\n+        let one: f64 = Float::one();\n+        assert_eq!(1.0, one);\n+        assert!(!one.is_infinite());\n+        assert!(one.is_finite());\n+        assert!(one.is_positive());\n+        assert!(!one.is_negative());\n+        assert!(!one.is_nan());\n+        assert!(one.is_normal());\n+        assert_eq!(Fp::Normal, one.classify());\n+    }\n+\n+    #[test]\n+    fn test_is_nan() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert!(nan.is_nan());\n+        assert!(!0.0f64.is_nan());\n+        assert!(!5.3f64.is_nan());\n+        assert!(!(-10.732f64).is_nan());\n+        assert!(!inf.is_nan());\n+        assert!(!neg_inf.is_nan());\n+    }\n+\n+    #[test]\n+    fn test_is_infinite() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert!(!nan.is_infinite());\n+        assert!(inf.is_infinite());\n+        assert!(neg_inf.is_infinite());\n+        assert!(!0.0f64.is_infinite());\n+        assert!(!42.8f64.is_infinite());\n+        assert!(!(-109.2f64).is_infinite());\n+    }\n+\n+    #[test]\n+    fn test_is_finite() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert!(!nan.is_finite());\n+        assert!(!inf.is_finite());\n+        assert!(!neg_inf.is_finite());\n+        assert!(0.0f64.is_finite());\n+        assert!(42.8f64.is_finite());\n+        assert!((-109.2f64).is_finite());\n+    }\n+\n     #[test]\n     fn test_is_normal() {\n         let nan: f64 = Float::nan();\n@@ -657,6 +771,66 @@ mod tests {\n         assert!(!NAN.is_negative());\n     }\n \n+    #[test]\n+    fn test_mul_add() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert_approx_eq!(12.3f64.mul_add(4.5, 6.7), 62.05);\n+        assert_approx_eq!((-12.3f64).mul_add(-4.5, -6.7), 48.65);\n+        assert_approx_eq!(0.0f64.mul_add(8.9, 1.2), 1.2);\n+        assert_approx_eq!(3.4f64.mul_add(-0.0, 5.6), 5.6);\n+        assert!(nan.mul_add(7.8, 9.0).is_nan());\n+        assert_eq!(inf.mul_add(7.8, 9.0), inf);\n+        assert_eq!(neg_inf.mul_add(7.8, 9.0), neg_inf);\n+        assert_eq!(8.9f64.mul_add(inf, 3.2), inf);\n+        assert_eq!((-3.2f64).mul_add(2.4, neg_inf), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_recip() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert_eq!(1.0f64.recip(), 1.0);\n+        assert_eq!(2.0f64.recip(), 0.5);\n+        assert_eq!((-0.4f64).recip(), -2.5);\n+        assert_eq!(0.0f64.recip(), inf);\n+        assert!(nan.recip().is_nan());\n+        assert_eq!(inf.recip(), 0.0);\n+        assert_eq!(neg_inf.recip(), 0.0);\n+    }\n+\n+    #[test]\n+    fn test_powi() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert_eq!(1.0f64.powi(1), 1.0);\n+        assert_approx_eq!((-3.1f64).powi(2), 9.61);\n+        assert_approx_eq!(5.9f64.powi(-2), 0.028727);\n+        assert_eq!(8.3f64.powi(0), 1.0);\n+        assert!(nan.powi(2).is_nan());\n+        assert_eq!(inf.powi(3), inf);\n+        assert_eq!(neg_inf.powi(2), inf);\n+    }\n+\n+    #[test]\n+    fn test_powf() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert_eq!(1.0f64.powf(1.0), 1.0);\n+        assert_approx_eq!(3.4f64.powf(4.5), 246.408183);\n+        assert_approx_eq!(2.7f64.powf(-3.2), 0.041652);\n+        assert_approx_eq!((-3.1f64).powf(2.0), 9.61);\n+        assert_approx_eq!(5.9f64.powf(-2.0), 0.028727);\n+        assert_eq!(8.3f64.powf(0.0), 1.0);\n+        assert!(nan.powf(2.0).is_nan());\n+        assert_eq!(inf.powf(2.0), inf);\n+        assert_eq!(neg_inf.powf(3.0), neg_inf);\n+    }\n+\n     #[test]\n     fn test_sqrt_domain() {\n         assert!(NAN.sqrt().is_nan());\n@@ -668,6 +842,21 @@ mod tests {\n         assert_eq!(INFINITY.sqrt(), INFINITY);\n     }\n \n+    #[test]\n+    fn test_rsqrt() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert!(nan.rsqrt().is_nan());\n+        assert_eq!(inf.rsqrt(), 0.0);\n+        assert!(neg_inf.rsqrt().is_nan());\n+        assert!((-1.0f64).rsqrt().is_nan());\n+        assert_eq!((-0.0f64).rsqrt(), neg_inf);\n+        assert_eq!(0.0f64.rsqrt(), inf);\n+        assert_eq!(1.0f64.rsqrt(), 1.0);\n+        assert_eq!(4.0f64.rsqrt(), 0.5);\n+    }\n+\n     #[test]\n     fn test_exp() {\n         assert_eq!(1.0, 0.0f64.exp());\n@@ -695,14 +884,111 @@ mod tests {\n         assert!(nan.exp2().is_nan());\n     }\n \n+    #[test]\n+    fn test_ln() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert_approx_eq!(1.0f64.exp().ln(), 1.0);\n+        assert!(nan.ln().is_nan());\n+        assert_eq!(inf.ln(), inf);\n+        assert!(neg_inf.ln().is_nan());\n+        assert!((-2.3f64).ln().is_nan());\n+        assert_eq!((-0.0f64).ln(), neg_inf);\n+        assert_eq!(0.0f64.ln(), neg_inf);\n+        assert_approx_eq!(4.0f64.ln(), 1.386294);\n+    }\n+\n+    #[test]\n+    fn test_log() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert_eq!(10.0f64.log(10.0), 1.0);\n+        assert_approx_eq!(2.3f64.log(3.5), 0.664858);\n+        assert_eq!(1.0f64.exp().log(1.0.exp()), 1.0);\n+        assert!(1.0f64.log(1.0).is_nan());\n+        assert!(1.0f64.log(-13.9).is_nan());\n+        assert!(nan.log(2.3).is_nan());\n+        assert_eq!(inf.log(10.0), inf);\n+        assert!(neg_inf.log(8.8).is_nan());\n+        assert!((-2.3f64).log(0.1).is_nan());\n+        assert_eq!((-0.0f64).log(2.0), neg_inf);\n+        assert_eq!(0.0f64.log(7.0), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_log2() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert_approx_eq!(10.0f64.log2(), 3.321928);\n+        assert_approx_eq!(2.3f64.log2(), 1.201634);\n+        assert_approx_eq!(1.0f64.exp().log2(), 1.442695);\n+        assert!(nan.log2().is_nan());\n+        assert_eq!(inf.log2(), inf);\n+        assert!(neg_inf.log2().is_nan());\n+        assert!((-2.3f64).log2().is_nan());\n+        assert_eq!((-0.0f64).log2(), neg_inf);\n+        assert_eq!(0.0f64.log2(), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_log10() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert_eq!(10.0f64.log10(), 1.0);\n+        assert_approx_eq!(2.3f64.log10(), 0.361728);\n+        assert_approx_eq!(1.0f64.exp().log10(), 0.434294);\n+        assert_eq!(1.0f64.log10(), 0.0);\n+        assert!(nan.log10().is_nan());\n+        assert_eq!(inf.log10(), inf);\n+        assert!(neg_inf.log10().is_nan());\n+        assert!((-2.3f64).log10().is_nan());\n+        assert_eq!((-0.0f64).log10(), neg_inf);\n+        assert_eq!(0.0f64.log10(), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_to_degrees() {\n+        let pi: f64 = consts::PI;\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert_eq!(0.0f64.to_degrees(), 0.0);\n+        assert_approx_eq!((-5.8f64).to_degrees(), -332.315521);\n+        assert_eq!(pi.to_degrees(), 180.0);\n+        assert!(nan.to_degrees().is_nan());\n+        assert_eq!(inf.to_degrees(), inf);\n+        assert_eq!(neg_inf.to_degrees(), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_to_radians() {\n+        let pi: f64 = consts::PI;\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert_eq!(0.0f64.to_radians(), 0.0);\n+        assert_approx_eq!(154.6f64.to_radians(), 2.698279);\n+        assert_approx_eq!((-332.31f64).to_radians(), -5.799903);\n+        assert_eq!(180.0f64.to_radians(), pi);\n+        assert!(nan.to_radians().is_nan());\n+        assert_eq!(inf.to_radians(), inf);\n+        assert_eq!(neg_inf.to_radians(), neg_inf);\n+    }\n+\n     #[test]\n     fn test_ldexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n         let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n         let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n+        let f3: f64 = FromStrRadix::from_str_radix(\"1.Cp-12\", 16).unwrap();\n         assert_eq!(Float::ldexp(1f64, -123), f1);\n         assert_eq!(Float::ldexp(1f64, -111), f2);\n+        assert_eq!(Float::ldexp(1.75f64, -12), f3);\n \n         assert_eq!(Float::ldexp(0f64, -123), 0f64);\n         assert_eq!(Float::ldexp(-0f64, -123), -0f64);\n@@ -721,12 +1007,16 @@ mod tests {\n         // are supported in floating-point literals\n         let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n         let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n+        let f3: f64 = FromStrRadix::from_str_radix(\"1.Cp-123\", 16).unwrap();\n         let (x1, exp1) = f1.frexp();\n         let (x2, exp2) = f2.frexp();\n+        let (x3, exp3) = f3.frexp();\n         assert_eq!((x1, exp1), (0.5f64, -122));\n         assert_eq!((x2, exp2), (0.5f64, -110));\n+        assert_eq!((x3, exp3), (0.875f64, -122));\n         assert_eq!(Float::ldexp(x1, exp1), f1);\n         assert_eq!(Float::ldexp(x2, exp2), f2);\n+        assert_eq!(Float::ldexp(x3, exp3), f3);\n \n         assert_eq!(0f64.frexp(), (0f64, 0));\n         assert_eq!((-0f64).frexp(), (-0f64, 0));"}]}