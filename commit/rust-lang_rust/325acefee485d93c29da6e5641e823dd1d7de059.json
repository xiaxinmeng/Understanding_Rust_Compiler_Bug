{"sha": "325acefee485d93c29da6e5641e823dd1d7de059", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNWFjZWZlZTQ4NWQ5M2MyOWRhNmU1NjQxZTgyM2RkMWQ3ZGUwNTk=", "commit": {"author": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2020-09-08T21:36:36Z"}, "committer": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2020-09-08T21:36:36Z"}, "message": "Use intra-doc links in `core::ptr`\n\nThe only link that I did not change is a link to a function on the\n`pointer` primitive because intra-doc links for the `pointer` primitive\ndon't work yet (see #63351).", "tree": {"sha": "7315cbd35d7c0dfd47b126d1cf921d132ceda517", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7315cbd35d7c0dfd47b126d1cf921d132ceda517"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/325acefee485d93c29da6e5641e823dd1d7de059", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/325acefee485d93c29da6e5641e823dd1d7de059", "html_url": "https://github.com/rust-lang/rust/commit/325acefee485d93c29da6e5641e823dd1d7de059", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/325acefee485d93c29da6e5641e823dd1d7de059/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5099914a16a215794ad243df0cc7a05d91d168e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/5099914a16a215794ad243df0cc7a05d91d168e0", "html_url": "https://github.com/rust-lang/rust/commit/5099914a16a215794ad243df0cc7a05d91d168e0"}], "stats": {"total": 77, "additions": 21, "deletions": 56}, "files": [{"sha": "219835bfae0f9318af57c6b733bf51712681b176", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 21, "deletions": 56, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/325acefee485d93c29da6e5641e823dd1d7de059/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/325acefee485d93c29da6e5641e823dd1d7de059/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=325acefee485d93c29da6e5641e823dd1d7de059", "patch": "@@ -54,16 +54,9 @@\n //! [aliasing]: ../../nomicon/aliasing.html\n //! [book]: ../../book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer\n //! [ub]: ../../reference/behavior-considered-undefined.html\n-//! [null]: ./fn.null.html\n //! [zst]: ../../nomicon/exotic-sizes.html#zero-sized-types-zsts\n-//! [atomic operations]: ../../std/sync/atomic/index.html\n-//! [`copy`]: ../../std/ptr/fn.copy.html\n+//! [atomic operations]: crate::sync::atomic\n //! [`offset`]: ../../std/primitive.pointer.html#method.offset\n-//! [`read_unaligned`]: ./fn.read_unaligned.html\n-//! [`write_unaligned`]: ./fn.write_unaligned.html\n-//! [`read_volatile`]: ./fn.read_volatile.html\n-//! [`write_volatile`]: ./fn.write_volatile.html\n-//! [`NonNull::dangling`]: ./struct.NonNull.html#method.dangling\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -118,9 +111,9 @@ mod mut_ptr;\n /// done automatically by the compiler. This means the fields of packed structs\n /// are not dropped in-place.\n ///\n-/// [`ptr::read`]: ../ptr/fn.read.html\n-/// [`ptr::read_unaligned`]: ../ptr/fn.read_unaligned.html\n-/// [pinned]: ../pin/index.html\n+/// [`ptr::read`]: self::read\n+/// [`ptr::read_unaligned`]: self::read_unaligned\n+/// [pinned]: crate::pin\n ///\n /// # Safety\n ///\n@@ -141,9 +134,7 @@ mod mut_ptr;\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`write`]: ../ptr/fn.write.html\n+/// [valid]: #safety\n ///\n /// # Examples\n ///\n@@ -243,9 +234,9 @@ pub(crate) struct FatPtr<T> {\n /// The `len` argument is the number of **elements**, not the number of bytes.\n ///\n /// This function is safe, but actually using the return value is unsafe.\n-/// See the documentation of [`from_raw_parts`] for slice safety requirements.\n+/// See the documentation of [`slice::from_raw_parts`] for slice safety requirements.\n ///\n-/// [`from_raw_parts`]: ../../std/slice/fn.from_raw_parts.html\n+/// [`slice::from_raw_parts`]: crate::slice::from_raw_parts\n ///\n /// # Examples\n ///\n@@ -274,10 +265,9 @@ pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n /// See the documentation of [`slice_from_raw_parts`] for more details.\n ///\n /// This function is safe, but actually using the return value is unsafe.\n-/// See the documentation of [`from_raw_parts_mut`] for slice safety requirements.\n+/// See the documentation of [`slice::from_raw_parts_mut`] for slice safety requirements.\n ///\n-/// [`slice_from_raw_parts`]: fn.slice_from_raw_parts.html\n-/// [`from_raw_parts_mut`]: ../../std/slice/fn.from_raw_parts_mut.html\n+/// [`slice::from_raw_parts_mut`]: crate::slice::from_raw_parts_mut\n ///\n /// # Examples\n ///\n@@ -316,8 +306,6 @@ pub const fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n ///   overlapping region of memory from `x` will be used. This is demonstrated\n ///   in the second example below.\n ///\n-/// [`mem::swap`]: ../mem/fn.swap.html\n-///\n /// # Safety\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n@@ -328,7 +316,7 @@ pub const fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n ///\n /// Note that even if `T` has size `0`, the pointers must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n+/// [valid]: #safety\n ///\n /// # Examples\n ///\n@@ -406,7 +394,7 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n /// Note that even if the effectively copied size (`count * size_of::<T>()`) is `0`,\n /// the pointers must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n+/// [valid]: #safety\n ///\n /// # Examples\n ///\n@@ -533,8 +521,6 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n /// operates on raw pointers instead of references. When references are\n /// available, [`mem::replace`] should be preferred.\n ///\n-/// [`mem::replace`]: ../mem/fn.replace.html\n-///\n /// # Safety\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n@@ -547,7 +533,7 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n+/// [valid]: #safety\n ///\n /// # Examples\n ///\n@@ -682,11 +668,7 @@ pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n /// assert_eq!(s, \"bar\");\n /// ```\n ///\n-/// [`mem::swap`]: ../mem/fn.swap.html\n-/// [valid]: ../ptr/index.html#safety\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`read_unaligned`]: ./fn.read_unaligned.html\n-/// [`write`]: ./fn.write.html\n+/// [valid]: #safety\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn read<T>(src: *const T) -> T {\n@@ -723,11 +705,8 @@ pub unsafe fn read<T>(src: *const T) -> T {\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL.\n ///\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`read`]: ./fn.read.html\n-/// [`write_unaligned`]: ./fn.write_unaligned.html\n-/// [read-ownership]: ./fn.read.html#ownership-of-the-returned-value\n-/// [valid]: ../ptr/index.html#safety\n+/// [read-ownership]: read#ownership-of-the-returned-value\n+/// [valid]: #safety\n ///\n /// ## On `packed` structs\n ///\n@@ -819,8 +798,6 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n /// This is appropriate for initializing uninitialized memory, or overwriting\n /// memory that has previously been [`read`] from.\n ///\n-/// [`read`]: ./fn.read.html\n-///\n /// # Safety\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n@@ -832,8 +809,7 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n-/// [`write_unaligned`]: ./fn.write_unaligned.html\n+/// [valid]: #safety\n ///\n /// # Examples\n ///\n@@ -888,8 +864,6 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n /// assert_eq!(foo, \"bar\");\n /// assert_eq!(bar, \"foo\");\n /// ```\n-///\n-/// [`mem::swap`]: ../mem/fn.swap.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn write<T>(dst: *mut T, src: T) {\n@@ -916,9 +890,6 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n /// This is appropriate for initializing uninitialized memory, or overwriting\n /// memory that has previously been read with [`read_unaligned`].\n ///\n-/// [`write`]: ./fn.write.html\n-/// [`read_unaligned`]: ./fn.read_unaligned.html\n-///\n /// # Safety\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n@@ -927,7 +898,7 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL.\n ///\n-/// [valid]: ../ptr/index.html#safety\n+/// [valid]: #safety\n ///\n /// ## On `packed` structs\n ///\n@@ -1007,8 +978,6 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// to not be elided or reordered by the compiler across other volatile\n /// operations.\n ///\n-/// [`write_volatile`]: ./fn.write_volatile.html\n-///\n /// # Notes\n ///\n /// Rust does not currently have a rigorously and formally defined memory model,\n@@ -1041,10 +1010,8 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`read`]: ./fn.read.html\n-/// [read-ownership]: ./fn.read.html#ownership-of-the-returned-value\n+/// [valid]: #safety\n+/// [read-ownership]: read#ownership-of-the-returned-value\n ///\n /// Just like in C, whether an operation is volatile has no bearing whatsoever\n /// on questions involving concurrent access from multiple threads. Volatile\n@@ -1089,8 +1056,6 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n /// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n /// location pointed to by `dst`.\n ///\n-/// [`read_volatile`]: ./fn.read_volatile.html\n-///\n /// # Notes\n ///\n /// Rust does not currently have a rigorously and formally defined memory model,\n@@ -1115,12 +1080,12 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n+/// [valid]: #safety\n ///\n /// Just like in C, whether an operation is volatile has no bearing whatsoever\n /// on questions involving concurrent access from multiple threads. Volatile\n /// accesses behave exactly like non-atomic accesses in that regard. In particular,\n-/// a race between a `write_volatile` and any other operation (reading or writing)\n+/// a race between a [`write_volatile`] and any other operation (reading or writing)\n /// on the same location is undefined behavior.\n ///\n /// # Examples"}]}