{"sha": "67e40e431aa966a76b6a247b19505e22b620a0c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3ZTQwZTQzMWFhOTY2YTc2YjZhMjQ3YjE5NTA1ZTIyYjYyMGEwYzc=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2019-01-25T21:18:13Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2019-01-27T16:59:21Z"}, "message": "Initial implementation of generics for method calls", "tree": {"sha": "057224378bf9dde5aca4c15194d1399cffef1d38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/057224378bf9dde5aca4c15194d1399cffef1d38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67e40e431aa966a76b6a247b19505e22b620a0c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67e40e431aa966a76b6a247b19505e22b620a0c7", "html_url": "https://github.com/rust-lang/rust/commit/67e40e431aa966a76b6a247b19505e22b620a0c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67e40e431aa966a76b6a247b19505e22b620a0c7/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bd47c0285433b5eb258196a81b95141d2a70505", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bd47c0285433b5eb258196a81b95141d2a70505", "html_url": "https://github.com/rust-lang/rust/commit/3bd47c0285433b5eb258196a81b95141d2a70505"}], "stats": {"total": 85, "additions": 72, "deletions": 13}, "files": [{"sha": "defb9fd0af21d5c0a86c42de22235cd7cde1b49c", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67e40e431aa966a76b6a247b19505e22b620a0c7/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e40e431aa966a76b6a247b19505e22b620a0c7/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=67e40e431aa966a76b6a247b19505e22b620a0c7", "patch": "@@ -424,6 +424,10 @@ impl Function {\n         self.id.module(db)\n     }\n \n+    pub fn name(&self, db: &impl HirDatabase) -> Name {\n+        self.signature(db).name.clone()\n+    }\n+\n     pub fn body_syntax_mapping(&self, db: &impl HirDatabase) -> Arc<BodySyntaxMapping> {\n         db.body_syntax_mapping(*self)\n     }"}, {"sha": "9b08b9c97b0d6223a51930ff3537d7416f7bddd2", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 68, "deletions": 13, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/67e40e431aa966a76b6a247b19505e22b620a0c7/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e40e431aa966a76b6a247b19505e22b620a0c7/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=67e40e431aa966a76b6a247b19505e22b620a0c7", "patch": "@@ -185,7 +185,7 @@ pub enum Ty {\n \n     /// Structures, enumerations and unions.\n     Adt {\n-        /// The DefId of the struct/enum.\n+        /// The definition of the struct/enum.\n         def_id: AdtDef,\n         /// The name, for displaying.\n         name: Name,\n@@ -219,7 +219,14 @@ pub enum Ty {\n     /// fn foo() -> i32 { 1 }\n     /// let bar = foo; // bar: fn() -> i32 {foo}\n     /// ```\n-    FnDef(Function, Substs),\n+    FnDef {\n+        // Function definition\n+        def: Function,\n+        /// For display\n+        name: Name,\n+        /// Substitutions for the generic parameters of the type\n+        substs: Substs\n+    },\n \n     /// A pointer to a function.  Written as `fn() -> i32`.\n     ///\n@@ -497,7 +504,7 @@ impl Ty {\n                 }\n                 sig_mut.output.walk_mut(f);\n             }\n-            Ty::FnDef(_, substs) | Ty::Adt { substs, .. } => {\n+            Ty::FnDef { substs, .. } | Ty::Adt { substs, .. } => {\n                 // Without an Arc::make_mut_slice, we can't avoid the clone here:\n                 let mut v: Vec<_> = substs.0.iter().cloned().collect();\n                 for t in &mut v {\n@@ -536,7 +543,11 @@ impl Ty {\n                 name,\n                 substs,\n             },\n-            Ty::FnDef(func, _) => Ty::FnDef(func, substs),\n+            Ty::FnDef { def, name, .. } => Ty::FnDef {\n+                def,\n+                name,\n+                substs,\n+            },\n             _ => self,\n         }\n     }\n@@ -592,14 +603,26 @@ impl fmt::Display for Ty {\n                         .to_fmt(f)\n                 }\n             }\n-            Ty::FnDef(_func, _substs) => write!(f, \"FNDEF-IMPLEMENT-ME\"),\n             Ty::FnPtr(sig) => {\n                 join(sig.input.iter())\n                     .surround_with(\"fn(\", \")\")\n                     .separator(\", \")\n                     .to_fmt(f)?;\n                 write!(f, \" -> {}\", sig.output)\n             }\n+            Ty::FnDef { name, substs, .. } => {\n+                // don't have access to the param types here :-(\n+                // we could store them in the def, but not sure if it\n+                // is worth it\n+                write!(f, \"fn {}\", name)?;\n+                if substs.0.len() > 0 {\n+                    join(substs.0.iter())\n+                        .surround_with(\"<\", \">\")\n+                        .separator(\", \")\n+                        .to_fmt(f)?;\n+                }\n+                Ok(())\n+            }\n             Ty::Adt { name, substs, .. } => {\n                 write!(f, \"{}\", name)?;\n                 if substs.0.len() > 0 {\n@@ -624,7 +647,12 @@ impl fmt::Display for Ty {\n fn type_for_fn(db: &impl HirDatabase, f: Function) -> Ty {\n     let generics = f.generic_params(db);\n     let substs = make_substs(&generics);\n-    Ty::FnDef(f.into(), substs)\n+    let name = f.name(db);\n+    Ty::FnDef {\n+        def: f.into(),\n+        name,\n+        substs\n+    }\n }\n \n fn get_func_sig(db: &impl HirDatabase, f: Function) -> FnSig {\n@@ -1355,16 +1383,18 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 Ty::Unknown\n             }\n             Expr::Call { callee, args } => {\n+                // TODO: we should use turbofish hints like this:\n+                // f::<u32>(x)\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n                 // FIXME: so manu unnecessary clones\n                 let (param_tys, ret_ty) = match &callee_ty {\n                     Ty::FnPtr(sig) => (sig.input.clone(), sig.output.clone()),\n-                    Ty::FnDef(func, substs) => {\n-                        let fn_sig = func.signature(self.db);\n+                    Ty::FnDef { def, substs, .. } => {\n+                        let fn_sig = def.signature(self.db);\n                         // TODO: get input and return types from the fn_sig.\n                         // it contains typerefs which we can make into proper tys\n \n-                        let sig = get_func_sig(self.db, *func);\n+                        let sig = get_func_sig(self.db, *def);\n                         (\n                             sig.input\n                                 .iter()\n@@ -1405,16 +1435,41 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let (expected_receiver_ty, param_tys, ret_ty) = match &method_ty {\n                     Ty::FnPtr(sig) => {\n                         if sig.input.len() > 0 {\n-                            (&sig.input[0], &sig.input[1..], sig.output.clone())\n+                            (sig.input[0].clone(), sig.input[1..].iter().cloned().collect(), sig.output.clone())\n+                        } else {\n+                            (Ty::Unknown, Vec::new(), sig.output.clone())\n+                        }\n+                    }\n+                    Ty::FnDef { def, substs, .. } => {\n+                        // TODO: fix deduplication with Expr::Call block above\n+                        // TODO: fix the ridiculous number of clones\n+                        let fn_sig = def.signature(self.db);\n+                        // TODO: get input and return types from the fn_sig.\n+                        // it contains typerefs which we can make into proper tys\n+\n+                        // check that len > 0\n+                        let sig = get_func_sig(self.db, *def);\n+                        if sig.input.len() > 0 {\n+                            (\n+                                sig.input[0].clone().subst(&substs),\n+                                sig.input[1..]\n+                                    .iter()\n+                                    .map(|ty| ty.clone().subst(&substs))\n+                                    .collect(),\n+                                sig.output.clone().subst(&substs),\n+                            )\n                         } else {\n-                            (&Ty::Unknown, &[][..], sig.output.clone())\n+                            (Ty::Unknown, Vec::new(), sig.output.clone())\n                         }\n                     }\n-                    _ => (&Ty::Unknown, &[][..], Ty::Unknown),\n+                    _ => (Ty::Unknown, Vec::new(), Ty::Unknown),\n                 };\n                 // TODO we would have to apply the autoderef/autoref steps here\n                 // to get the correct receiver type to unify...\n-                self.unify(expected_receiver_ty, &receiver_ty);\n+                // \n+                // TODO: zip param_tys.chain(iter::repeat(Ty::Unknown)) above then its not so bad\n+                // that we clone\n+                self.unify(&expected_receiver_ty, &receiver_ty);\n                 for (i, arg) in args.iter().enumerate() {\n                     self.infer_expr(\n                         *arg,"}]}