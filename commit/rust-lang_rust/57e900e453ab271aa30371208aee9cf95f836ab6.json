{"sha": "57e900e453ab271aa30371208aee9cf95f836ab6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ZTkwMGU0NTNhYjI3MWFhMzAzNzEyMDhhZWU5Y2Y5NWY4MzZhYjY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-06T17:00:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-06T17:00:47Z"}, "message": "Rollup merge of #64189 - phansch:add_macros_support, r=estebank\n\nannotate-snippet emitter: Deal with multispans from macros, too\n\nThis moves the two methods from the `EmitterWriter` impl to trait\ndefault methods in the `Emitter` trait so that they can be re-used by\nthe `AnnotateSnippetEmitterWriter`.\n\nr? @estebank\n\nCloses #61810", "tree": {"sha": "b74a2f20db8a3f9a95a6a743a52fe51e6b8f2526", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b74a2f20db8a3f9a95a6a743a52fe51e6b8f2526"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57e900e453ab271aa30371208aee9cf95f836ab6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdcpC/CRBK7hj4Ov3rIwAAdHIIAKRjLEvn9LBzSYJX7tXWCEhq\nVRb3exAHdD74/h9zg7RSPIHh5Kn7/c5/b5q+QLtpQvT8uHjxP9FL1IpqQwMdaW9G\nWbj3EmDj/lK9KZT87xBZBqEspjv6+sf4rRlAP8o95D6i1mxMuwPYPHK3xgRpxNBA\nIZ4+HQRW/zrOP47sF8IoxP75CVl1EdoFJH7xMeFP5rfoS0yKVy/DRyYsPqj3tNFM\nwYcAalCZMMXLA1TjKGNe+sb9dkvCUGr9K7VGKj+YHNw0MC1qItqSa076agUSTN28\nBRqO27pkLXJh0QyUZsU+O+THf1rVrHjT02EcqSfAZRYqiJP8LSiPVA/rX9nesPM=\n=5Oa4\n-----END PGP SIGNATURE-----\n", "payload": "tree b74a2f20db8a3f9a95a6a743a52fe51e6b8f2526\nparent 8bbd71b99a3993c83267a25c62f990139e277f3b\nparent 159d249705659ecb2ef41623105cab1c9f95b802\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1567789247 +0200\ncommitter GitHub <noreply@github.com> 1567789247 +0200\n\nRollup merge of #64189 - phansch:add_macros_support, r=estebank\n\nannotate-snippet emitter: Deal with multispans from macros, too\n\nThis moves the two methods from the `EmitterWriter` impl to trait\ndefault methods in the `Emitter` trait so that they can be re-used by\nthe `AnnotateSnippetEmitterWriter`.\n\nr? @estebank\n\nCloses #61810\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57e900e453ab271aa30371208aee9cf95f836ab6", "html_url": "https://github.com/rust-lang/rust/commit/57e900e453ab271aa30371208aee9cf95f836ab6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57e900e453ab271aa30371208aee9cf95f836ab6/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bbd71b99a3993c83267a25c62f990139e277f3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bbd71b99a3993c83267a25c62f990139e277f3b", "html_url": "https://github.com/rust-lang/rust/commit/8bbd71b99a3993c83267a25c62f990139e277f3b"}, {"sha": "159d249705659ecb2ef41623105cab1c9f95b802", "url": "https://api.github.com/repos/rust-lang/rust/commits/159d249705659ecb2ef41623105cab1c9f95b802", "html_url": "https://github.com/rust-lang/rust/commit/159d249705659ecb2ef41623105cab1c9f95b802"}], "stats": {"total": 263, "additions": 137, "deletions": 126}, "files": [{"sha": "60ee7507223e93d670519dff79d215fe50d1dc2f", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/57e900e453ab271aa30371208aee9cf95f836ab6/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e900e453ab271aa30371208aee9cf95f836ab6/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=57e900e453ab271aa30371208aee9cf95f836ab6", "patch": "@@ -30,10 +30,14 @@ pub struct AnnotateSnippetEmitterWriter {\n impl Emitter for AnnotateSnippetEmitterWriter {\n     /// The entry point for the diagnostics generation\n     fn emit_diagnostic(&mut self, db: &DiagnosticBuilder<'_>) {\n-        let children = db.children.clone();\n-        let (primary_span, suggestions) = self.primary_span_formatted(&db);\n-\n-        // FIXME(#59346): Add `fix_multispans_in_std_macros` function from emitter.rs\n+        let mut children = db.children.clone();\n+        let (mut primary_span, suggestions) = self.primary_span_formatted(&db);\n+\n+        self.fix_multispans_in_std_macros(&self.source_map,\n+                                          &mut primary_span,\n+                                          &mut children,\n+                                          &db.level,\n+                                          db.handler.flags.external_macro_backtrace);\n \n         self.emit_messages_default(&db.level,\n                                    db.message(),"}, {"sha": "0ce69eecc6b1ead2068c18a7c9e6805a45282649", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 129, "deletions": 122, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/57e900e453ab271aa30371208aee9cf95f836ab6/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e900e453ab271aa30371208aee9cf95f836ab6/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=57e900e453ab271aa30371208aee9cf95f836ab6", "patch": "@@ -247,14 +247,142 @@ pub trait Emitter {\n             (primary_span, &db.suggestions)\n         }\n     }\n+\n+    // This does a small \"fix\" for multispans by looking to see if it can find any that\n+    // point directly at <*macros>. Since these are often difficult to read, this\n+    // will change the span to point at the use site.\n+    fn fix_multispans_in_std_macros(&self,\n+                                    source_map: &Option<Lrc<SourceMapperDyn>>,\n+                                    span: &mut MultiSpan,\n+                                    children: &mut Vec<SubDiagnostic>,\n+                                    level: &Level,\n+                                    backtrace: bool) {\n+        let mut spans_updated = self.fix_multispan_in_std_macros(source_map, span, backtrace);\n+        for child in children.iter_mut() {\n+            spans_updated |= self.fix_multispan_in_std_macros(\n+                                 source_map,\n+                                 &mut child.span,\n+                                 backtrace\n+                             );\n+        }\n+        let msg = if level == &Error {\n+            \"this error originates in a macro outside of the current crate \\\n+             (in Nightly builds, run with -Z external-macro-backtrace \\\n+              for more info)\".to_string()\n+        } else {\n+            \"this warning originates in a macro outside of the current crate \\\n+             (in Nightly builds, run with -Z external-macro-backtrace \\\n+              for more info)\".to_string()\n+        };\n+\n+        if spans_updated {\n+            children.push(SubDiagnostic {\n+                level: Level::Note,\n+                message: vec![\n+                    (msg,\n+                     Style::NoStyle),\n+                ],\n+                span: MultiSpan::new(),\n+                render_span: None,\n+            });\n+        }\n+    }\n+\n+    // This \"fixes\" MultiSpans that contain Spans that are pointing to locations inside of\n+    // <*macros>. Since these locations are often difficult to read, we move these Spans from\n+    // <*macros> to their corresponding use site.\n+    fn fix_multispan_in_std_macros(&self,\n+                                   source_map: &Option<Lrc<SourceMapperDyn>>,\n+                                   span: &mut MultiSpan,\n+                                   always_backtrace: bool) -> bool {\n+        let mut spans_updated = false;\n+\n+        if let Some(ref sm) = source_map {\n+            let mut before_after: Vec<(Span, Span)> = vec![];\n+            let mut new_labels: Vec<(Span, String)> = vec![];\n+\n+            // First, find all the spans in <*macros> and point instead at their use site\n+            for sp in span.primary_spans() {\n+                if sp.is_dummy() {\n+                    continue;\n+                }\n+                let call_sp = sm.call_span_if_macro(*sp);\n+                if call_sp != *sp && !always_backtrace {\n+                    before_after.push((*sp, call_sp));\n+                }\n+                let backtrace_len = sp.macro_backtrace().len();\n+                for (i, trace) in sp.macro_backtrace().iter().rev().enumerate() {\n+                    // Only show macro locations that are local\n+                    // and display them like a span_note\n+                    if trace.def_site_span.is_dummy() {\n+                        continue;\n+                    }\n+                    if always_backtrace {\n+                        new_labels.push((trace.def_site_span,\n+                                            format!(\"in this expansion of `{}`{}\",\n+                                                    trace.macro_decl_name,\n+                                                    if backtrace_len > 2 {\n+                                                        // if backtrace_len == 1 it'll be pointed\n+                                                        // at by \"in this macro invocation\"\n+                                                        format!(\" (#{})\", i + 1)\n+                                                    } else {\n+                                                        String::new()\n+                                                    })));\n+                    }\n+                    // Check to make sure we're not in any <*macros>\n+                    if !sm.span_to_filename(trace.def_site_span).is_macros() &&\n+                        !trace.macro_decl_name.starts_with(\"desugaring of \") &&\n+                        !trace.macro_decl_name.starts_with(\"#[\") ||\n+                        always_backtrace {\n+                        new_labels.push((trace.call_site,\n+                                            format!(\"in this macro invocation{}\",\n+                                                    if backtrace_len > 2 && always_backtrace {\n+                                                        // only specify order when the macro\n+                                                        // backtrace is multiple levels deep\n+                                                        format!(\" (#{})\", i + 1)\n+                                                    } else {\n+                                                        String::new()\n+                                                    })));\n+                        if !always_backtrace {\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            for (label_span, label_text) in new_labels {\n+                span.push_span_label(label_span, label_text);\n+            }\n+            for sp_label in span.span_labels() {\n+                if sp_label.span.is_dummy() {\n+                    continue;\n+                }\n+                if sm.span_to_filename(sp_label.span.clone()).is_macros() &&\n+                    !always_backtrace\n+                {\n+                    let v = sp_label.span.macro_backtrace();\n+                    if let Some(use_site) = v.last() {\n+                        before_after.push((sp_label.span.clone(), use_site.call_site.clone()));\n+                    }\n+                }\n+            }\n+            // After we have them, make sure we replace these 'bad' def sites with their use sites\n+            for (before, after) in before_after {\n+                span.replace(before, after);\n+                spans_updated = true;\n+            }\n+        }\n+\n+        spans_updated\n+    }\n }\n \n impl Emitter for EmitterWriter {\n     fn emit_diagnostic(&mut self, db: &DiagnosticBuilder<'_>) {\n         let mut children = db.children.clone();\n         let (mut primary_span, suggestions) = self.primary_span_formatted(&db);\n \n-        self.fix_multispans_in_std_macros(&mut primary_span,\n+        self.fix_multispans_in_std_macros(&self.sm,\n+                                          &mut primary_span,\n                                           &mut children,\n                                           &db.level,\n                                           db.handler.flags.external_macro_backtrace);\n@@ -919,127 +1047,6 @@ impl EmitterWriter {\n         max\n     }\n \n-    // This \"fixes\" MultiSpans that contain Spans that are pointing to locations inside of\n-    // <*macros>. Since these locations are often difficult to read, we move these Spans from\n-    // <*macros> to their corresponding use site.\n-    fn fix_multispan_in_std_macros(&mut self,\n-                                   span: &mut MultiSpan,\n-                                   always_backtrace: bool) -> bool {\n-        let mut spans_updated = false;\n-\n-        if let Some(ref sm) = self.sm {\n-            let mut before_after: Vec<(Span, Span)> = vec![];\n-            let mut new_labels: Vec<(Span, String)> = vec![];\n-\n-            // First, find all the spans in <*macros> and point instead at their use site\n-            for sp in span.primary_spans() {\n-                if sp.is_dummy() {\n-                    continue;\n-                }\n-                let call_sp = sm.call_span_if_macro(*sp);\n-                if call_sp != *sp && !always_backtrace {\n-                    before_after.push((*sp, call_sp));\n-                }\n-                let backtrace_len = sp.macro_backtrace().len();\n-                for (i, trace) in sp.macro_backtrace().iter().rev().enumerate() {\n-                    // Only show macro locations that are local\n-                    // and display them like a span_note\n-                    if trace.def_site_span.is_dummy() {\n-                        continue;\n-                    }\n-                    if always_backtrace {\n-                        new_labels.push((trace.def_site_span,\n-                                            format!(\"in this expansion of `{}`{}\",\n-                                                    trace.macro_decl_name,\n-                                                    if backtrace_len > 2 {\n-                                                        // if backtrace_len == 1 it'll be pointed\n-                                                        // at by \"in this macro invocation\"\n-                                                        format!(\" (#{})\", i + 1)\n-                                                    } else {\n-                                                        String::new()\n-                                                    })));\n-                    }\n-                    // Check to make sure we're not in any <*macros>\n-                    if !sm.span_to_filename(trace.def_site_span).is_macros() &&\n-                        !trace.macro_decl_name.starts_with(\"desugaring of \") &&\n-                        !trace.macro_decl_name.starts_with(\"#[\") ||\n-                        always_backtrace {\n-                        new_labels.push((trace.call_site,\n-                                            format!(\"in this macro invocation{}\",\n-                                                    if backtrace_len > 2 && always_backtrace {\n-                                                        // only specify order when the macro\n-                                                        // backtrace is multiple levels deep\n-                                                        format!(\" (#{})\", i + 1)\n-                                                    } else {\n-                                                        String::new()\n-                                                    })));\n-                        if !always_backtrace {\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-            for (label_span, label_text) in new_labels {\n-                span.push_span_label(label_span, label_text);\n-            }\n-            for sp_label in span.span_labels() {\n-                if sp_label.span.is_dummy() {\n-                    continue;\n-                }\n-                if sm.span_to_filename(sp_label.span.clone()).is_macros() &&\n-                    !always_backtrace\n-                {\n-                    let v = sp_label.span.macro_backtrace();\n-                    if let Some(use_site) = v.last() {\n-                        before_after.push((sp_label.span.clone(), use_site.call_site.clone()));\n-                    }\n-                }\n-            }\n-            // After we have them, make sure we replace these 'bad' def sites with their use sites\n-            for (before, after) in before_after {\n-                span.replace(before, after);\n-                spans_updated = true;\n-            }\n-        }\n-\n-        spans_updated\n-    }\n-\n-    // This does a small \"fix\" for multispans by looking to see if it can find any that\n-    // point directly at <*macros>. Since these are often difficult to read, this\n-    // will change the span to point at the use site.\n-    fn fix_multispans_in_std_macros(&mut self,\n-                                    span: &mut MultiSpan,\n-                                    children: &mut Vec<SubDiagnostic>,\n-                                    level: &Level,\n-                                    backtrace: bool) {\n-        let mut spans_updated = self.fix_multispan_in_std_macros(span, backtrace);\n-        for child in children.iter_mut() {\n-            spans_updated |= self.fix_multispan_in_std_macros(&mut child.span, backtrace);\n-        }\n-        let msg = if level == &Error {\n-            \"this error originates in a macro outside of the current crate \\\n-             (in Nightly builds, run with -Z external-macro-backtrace \\\n-              for more info)\".to_string()\n-        } else {\n-            \"this warning originates in a macro outside of the current crate \\\n-             (in Nightly builds, run with -Z external-macro-backtrace \\\n-              for more info)\".to_string()\n-        };\n-\n-        if spans_updated {\n-            children.push(SubDiagnostic {\n-                level: Level::Note,\n-                message: vec![\n-                    (msg,\n-                     Style::NoStyle),\n-                ],\n-                span: MultiSpan::new(),\n-                render_span: None,\n-            });\n-        }\n-    }\n-\n     /// Adds a left margin to every line but the first, given a padding length and the label being\n     /// displayed, keeping the provided highlighting.\n     fn msg_to_buffer(&self,"}]}