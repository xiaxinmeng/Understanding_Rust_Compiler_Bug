{"sha": "aecccbc579c0092e609f47fabc4d5fb6dbe110d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlY2NjYmM1NzljMDA5MmU2MDlmNDdmYWJjNGQ1ZmI2ZGJlMTEwZDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-12T08:52:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-12T08:52:10Z"}, "message": "Auto merge of #7047 - camsteffen:lang-ctor, r=flip1995\n\nIntroduce `is_lang_ctor`\n\nchangelog: none\n\nReplaces `is_some_ctor` and `is_ok_ctor`. Removes many path usages.", "tree": {"sha": "459e7868151e77e2629b4f41b4d017fe23081cd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/459e7868151e77e2629b4f41b4d017fe23081cd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aecccbc579c0092e609f47fabc4d5fb6dbe110d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aecccbc579c0092e609f47fabc4d5fb6dbe110d0", "html_url": "https://github.com/rust-lang/rust/commit/aecccbc579c0092e609f47fabc4d5fb6dbe110d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0ceb28ba16c9f7c138a4311cabcf44bacc923ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0ceb28ba16c9f7c138a4311cabcf44bacc923ce", "html_url": "https://github.com/rust-lang/rust/commit/f0ceb28ba16c9f7c138a4311cabcf44bacc923ce"}, {"sha": "7468542328caf3f0114ac4733fe2b76e2ed79954", "url": "https://api.github.com/repos/rust-lang/rust/commits/7468542328caf3f0114ac4733fe2b76e2ed79954", "html_url": "https://github.com/rust-lang/rust/commit/7468542328caf3f0114ac4733fe2b76e2ed79954"}], "stats": {"total": 278, "additions": 121, "deletions": 157}, "files": [{"sha": "ab22578abd674efec12970050170789ec492d5d9", "filename": "clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=aecccbc579c0092e609f47fabc4d5fb6dbe110d0", "patch": "@@ -1,11 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::visitors::LocalUsedVisitor;\n-use clippy_utils::{path_to_local, SpanlessEq};\n+use clippy_utils::{is_lang_ctor, path_to_local, SpanlessEq};\n use if_chain::if_chain;\n-use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n-use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, QPath, StmtKind, UnOp};\n+use rustc_hir::LangItem::OptionNone;\n+use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, StmtKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{DefIdTree, TyCtxt, TypeckResults};\n+use rustc_middle::ty::TypeckResults;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{MultiSpan, Span};\n \n@@ -52,7 +52,7 @@ declare_lint_pass!(CollapsibleMatch => [COLLAPSIBLE_MATCH]);\n impl<'tcx> LateLintPass<'tcx> for CollapsibleMatch {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n         if let ExprKind::Match(_expr, arms, _source) = expr.kind {\n-            if let Some(wild_arm) = arms.iter().rfind(|arm| arm_is_wild_like(arm, cx.tcx)) {\n+            if let Some(wild_arm) = arms.iter().rfind(|arm| arm_is_wild_like(cx, arm)) {\n                 for arm in arms {\n                     check_arm(arm, wild_arm, cx);\n                 }\n@@ -75,7 +75,7 @@ fn check_arm<'tcx>(arm: &Arm<'tcx>, wild_outer_arm: &Arm<'tcx>, cx: &LateContext\n         // match <local> { .. }\n         if let Some(binding_id) = path_to_local(strip_ref_operators(expr_in, cx.typeck_results()));\n         // one of the branches must be \"wild-like\"\n-        if let Some(wild_inner_arm_idx) = arms_inner.iter().rposition(|arm_inner| arm_is_wild_like(arm_inner, cx.tcx));\n+        if let Some(wild_inner_arm_idx) = arms_inner.iter().rposition(|arm_inner| arm_is_wild_like(cx, arm_inner));\n         let (wild_inner_arm, non_wild_inner_arm) =\n             (&arms_inner[wild_inner_arm_idx], &arms_inner[1 - wild_inner_arm_idx]);\n         if !pat_contains_or(non_wild_inner_arm.pat);\n@@ -126,13 +126,13 @@ fn strip_singleton_blocks<'hir>(mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir>\n /// A \"wild-like\" pattern is wild (\"_\") or `None`.\n /// For this lint to apply, both the outer and inner match expressions\n /// must have \"wild-like\" branches that can be combined.\n-fn arm_is_wild_like(arm: &Arm<'_>, tcx: TyCtxt<'_>) -> bool {\n+fn arm_is_wild_like(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n     if arm.guard.is_some() {\n         return false;\n     }\n     match arm.pat.kind {\n         PatKind::Binding(..) | PatKind::Wild => true,\n-        PatKind::Path(QPath::Resolved(None, path)) if is_none_ctor(path.res, tcx) => true,\n+        PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n         _ => false,\n     }\n }\n@@ -164,17 +164,6 @@ fn pat_contains_or(pat: &Pat<'_>) -> bool {\n     result\n }\n \n-fn is_none_ctor(res: Res, tcx: TyCtxt<'_>) -> bool {\n-    if let Some(none_id) = tcx.lang_items().option_none_variant() {\n-        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Const), id) = res {\n-            if let Some(variant_id) = tcx.parent(id) {\n-                return variant_id == none_id;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n /// Removes `AddrOf` operators (`&`) or deref operators (`*`), but only if a reference type is\n /// dereferenced. An overloaded deref such as `Vec` to slice would not be removed.\n fn strip_ref_operators<'hir>(mut expr: &'hir Expr<'hir>, typeck_results: &TypeckResults<'_>) -> &'hir Expr<'hir> {"}, {"sha": "f73b3a1fe67c2d52973038ebc2b078afc6c8af2a", "filename": "clippy_lints/src/if_then_some_else_none.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs?ref=aecccbc579c0092e609f47fabc4d5fb6dbe110d0", "patch": "@@ -1,7 +1,8 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::source::snippet_with_macro_callsite;\n-use clippy_utils::{match_qpath, meets_msrv, parent_node_is_if_expr};\n+use clippy_utils::{is_lang_ctor, meets_msrv, parent_node_is_if_expr};\n use if_chain::if_chain;\n+use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -77,12 +78,12 @@ impl LateLintPass<'_> for IfThenSomeElseNone {\n             if let Some(then_expr) = then_block.expr;\n             if let ExprKind::Call(then_call, [then_arg]) = then_expr.kind;\n             if let ExprKind::Path(ref then_call_qpath) = then_call.kind;\n-            if match_qpath(then_call_qpath, &clippy_utils::paths::OPTION_SOME);\n+            if is_lang_ctor(cx, then_call_qpath, OptionSome);\n             if let ExprKind::Block(els_block, _) = els.kind;\n             if els_block.stmts.is_empty();\n             if let Some(els_expr) = els_block.expr;\n-            if let ExprKind::Path(ref els_call_qpath) = els_expr.kind;\n-            if match_qpath(els_call_qpath, &clippy_utils::paths::OPTION_NONE);\n+            if let ExprKind::Path(ref qpath) = els_expr.kind;\n+            if is_lang_ctor(cx, qpath, OptionNone);\n             then {\n                 let cond_snip = snippet_with_macro_callsite(cx, cond.span, \"[condition]\");\n                 let cond_snip = if matches!(cond.kind, ExprKind::Unary(_, _) | ExprKind::Binary(_, _, _)) {"}, {"sha": "64ff7574f86b7669d4efbf498e09527aa100abe4", "filename": "clippy_lints/src/loops/manual_flatten.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=aecccbc579c0092e609f47fabc4d5fb6dbe110d0", "patch": "@@ -1,10 +1,11 @@\n use super::utils::make_iterator_snippet;\n use super::MANUAL_FLATTEN;\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::{is_ok_ctor, is_some_ctor, path_to_local_id};\n+use clippy_utils::{is_lang_ctor, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, MatchSource, Pat, PatKind, QPath, StmtKind};\n+use rustc_hir::LangItem::{OptionSome, ResultOk};\n+use rustc_hir::{Expr, ExprKind, MatchSource, Pat, PatKind, StmtKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n use rustc_span::source_map::Span;\n@@ -42,9 +43,9 @@ pub(super) fn check<'tcx>(\n             if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n             if path_to_local_id(match_expr, pat_hir_id);\n             // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n-            if let PatKind::TupleStruct(QPath::Resolved(None, path), _, _) = match_arms[0].pat.kind;\n-            let some_ctor = is_some_ctor(cx, path.res);\n-            let ok_ctor = is_ok_ctor(cx, path.res);\n+            if let PatKind::TupleStruct(ref qpath, _, _) = match_arms[0].pat.kind;\n+            let some_ctor = is_lang_ctor(cx, qpath, OptionSome);\n+            let ok_ctor = is_lang_ctor(cx, qpath, ResultOk);\n             if some_ctor || ok_ctor;\n             then {\n                 let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };"}, {"sha": "29be07399774ffbdd6f9066901cb6fd92f3da86e", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=aecccbc579c0092e609f47fabc4d5fb6dbe110d0", "patch": "@@ -2,9 +2,10 @@ use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{can_partially_move_ty, is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n-use clippy_utils::{in_constant, is_allowed, is_else_clause, match_def_path, match_var, paths, peel_hir_expr_refs};\n+use clippy_utils::{in_constant, is_allowed, is_else_clause, is_lang_ctor, match_var, peel_hir_expr_refs};\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n+use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{\n     def::Res,\n     intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n@@ -269,20 +270,9 @@ fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxCon\n         match pat.kind {\n             PatKind::Wild => Some(OptionPat::Wild),\n             PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n-            PatKind::Path(QPath::Resolved(None, path))\n-                if path\n-                    .res\n-                    .opt_def_id()\n-                    .map_or(false, |id| match_def_path(cx, id, &paths::OPTION_NONE)) =>\n-            {\n-                Some(OptionPat::None)\n-            },\n-            PatKind::TupleStruct(QPath::Resolved(None, path), [pattern], _)\n-                if path\n-                    .res\n-                    .opt_def_id()\n-                    .map_or(false, |id| match_def_path(cx, id, &paths::OPTION_SOME))\n-                    && pat.span.ctxt() == ctxt =>\n+            PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone) => Some(OptionPat::None),\n+            PatKind::TupleStruct(ref qpath, [pattern], _)\n+                if is_lang_ctor(cx, qpath, OptionSome) && pat.span.ctxt() == ctxt =>\n             {\n                 Some(OptionPat::Some { pattern, ref_count })\n             },\n@@ -298,17 +288,11 @@ fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, ctxt: SyntaxConte\n     match expr.kind {\n         ExprKind::Call(\n             Expr {\n-                kind: ExprKind::Path(QPath::Resolved(None, path)),\n+                kind: ExprKind::Path(ref qpath),\n                 ..\n             },\n             [arg],\n-        ) if ctxt == expr.span.ctxt() => {\n-            if match_def_path(cx, path.res.opt_def_id()?, &paths::OPTION_SOME) {\n-                Some(arg)\n-            } else {\n-                None\n-            }\n-        },\n+        ) if ctxt == expr.span.ctxt() && is_lang_ctor(cx, qpath, OptionSome) => Some(arg),\n         ExprKind::Block(\n             Block {\n                 stmts: [],\n@@ -324,10 +308,7 @@ fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, ctxt: SyntaxConte\n // Checks for the `None` value.\n fn is_none_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n     match expr.kind {\n-        ExprKind::Path(QPath::Resolved(None, path)) => path\n-            .res\n-            .opt_def_id()\n-            .map_or(false, |id| match_def_path(cx, id, &paths::OPTION_NONE)),\n+        ExprKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n         ExprKind::Block(\n             Block {\n                 stmts: [],"}, {"sha": "847c8c648b00acb21dfd4f4d9b6b8e61ebc2968a", "filename": "clippy_lints/src/manual_ok_or.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fmanual_ok_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fmanual_ok_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_ok_or.rs?ref=aecccbc579c0092e609f47fabc4d5fb6dbe110d0", "patch": "@@ -1,9 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{match_qpath, path_to_local_id, paths};\n+use clippy_utils::{is_lang_ctor, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n+use rustc_hir::LangItem::{ResultErr, ResultOk};\n use rustc_hir::{Expr, ExprKind, PatKind};\n use rustc_lint::LintContext;\n use rustc_lint::{LateContext, LateLintPass};\n@@ -54,7 +55,7 @@ impl LateLintPass<'_> for ManualOkOr {\n             let or_expr = &args[1];\n             if is_ok_wrapping(cx, &args[2]);\n             if let ExprKind::Call(Expr { kind: ExprKind::Path(err_path), .. }, &[ref err_arg]) = or_expr.kind;\n-            if match_qpath(err_path, &paths::RESULT_ERR);\n+            if is_lang_ctor(cx, err_path, ResultErr);\n             if let Some(method_receiver_snippet) = snippet_opt(cx, method_receiver.span);\n             if let Some(err_arg_snippet) = snippet_opt(cx, err_arg.span);\n             if let Some(indent) = indent_of(cx, scrutinee.span);\n@@ -81,7 +82,7 @@ impl LateLintPass<'_> for ManualOkOr {\n \n fn is_ok_wrapping(cx: &LateContext<'_>, map_expr: &Expr<'_>) -> bool {\n     if let ExprKind::Path(ref qpath) = map_expr.kind {\n-        if match_qpath(qpath, &paths::RESULT_OK) {\n+        if is_lang_ctor(cx, qpath, ResultOk) {\n             return true;\n         }\n     }\n@@ -90,7 +91,7 @@ fn is_ok_wrapping(cx: &LateContext<'_>, map_expr: &Expr<'_>) -> bool {\n         let body = cx.tcx.hir().body(body_id);\n         if let PatKind::Binding(_, param_id, ..) = body.params[0].pat.kind;\n         if let ExprKind::Call(Expr { kind: ExprKind::Path(ok_path), .. }, &[ref ok_arg]) = body.value.kind;\n-        if match_qpath(ok_path, &paths::RESULT_OK);\n+        if is_lang_ctor(cx, ok_path, ResultOk);\n         then { path_to_local_id(ok_arg, param_id) } else { false }\n     }\n }"}, {"sha": "65baa2552ccc6b7758b9ce9c7570beb914539368", "filename": "clippy_lints/src/manual_unwrap_or.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs?ref=aecccbc579c0092e609f47fabc4d5fb6dbe110d0", "patch": "@@ -3,10 +3,11 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::usage::contains_return_break_continue_macro;\n-use clippy_utils::{in_constant, match_qpath, path_to_local_id, paths, sugg};\n+use clippy_utils::{in_constant, is_lang_ctor, path_to_local_id, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Arm, Expr, ExprKind, Pat, PatKind};\n+use rustc_hir::LangItem::{OptionNone, OptionSome, ResultErr, ResultOk};\n+use rustc_hir::{Arm, Expr, ExprKind, PatKind};\n use rustc_lint::LintContext;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n@@ -68,23 +69,21 @@ impl Case {\n }\n \n fn lint_manual_unwrap_or<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-    fn applicable_or_arm<'a>(arms: &'a [Arm<'a>]) -> Option<&'a Arm<'a>> {\n+    fn applicable_or_arm<'a>(cx: &LateContext<'_>, arms: &'a [Arm<'a>]) -> Option<&'a Arm<'a>> {\n         if_chain! {\n             if arms.len() == 2;\n             if arms.iter().all(|arm| arm.guard.is_none());\n-            if let Some((idx, or_arm)) = arms.iter().enumerate().find(|(_, arm)|\n+            if let Some((idx, or_arm)) = arms.iter().enumerate().find(|(_, arm)| {\n                 match arm.pat.kind {\n-                    PatKind::Path(ref some_qpath) =>\n-                        match_qpath(some_qpath, &paths::OPTION_NONE),\n-                    PatKind::TupleStruct(ref err_qpath, &[Pat { kind: PatKind::Wild, .. }], _) =>\n-                        match_qpath(err_qpath, &paths::RESULT_ERR),\n+                    PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+                    PatKind::TupleStruct(ref qpath, &[pat], _) =>\n+                        matches!(pat.kind, PatKind::Wild) && is_lang_ctor(cx, qpath, ResultErr),\n                     _ => false,\n                 }\n-            );\n+            });\n             let unwrap_arm = &arms[1 - idx];\n-            if let PatKind::TupleStruct(ref unwrap_qpath, &[unwrap_pat], _) = unwrap_arm.pat.kind;\n-            if match_qpath(unwrap_qpath, &paths::OPTION_SOME)\n-                || match_qpath(unwrap_qpath, &paths::RESULT_OK);\n+            if let PatKind::TupleStruct(ref qpath, &[unwrap_pat], _) = unwrap_arm.pat.kind;\n+            if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk);\n             if let PatKind::Binding(_, binding_hir_id, ..) = unwrap_pat.kind;\n             if path_to_local_id(unwrap_arm.body, binding_hir_id);\n             if !contains_return_break_continue_macro(or_arm.body);\n@@ -106,7 +105,7 @@ fn lint_manual_unwrap_or<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         } else {\n             None\n         };\n-        if let Some(or_arm) = applicable_or_arm(match_arms);\n+        if let Some(or_arm) = applicable_or_arm(cx, match_arms);\n         if let Some(or_body_snippet) = snippet_opt(cx, or_arm.body.span);\n         if let Some(indent) = indent_of(cx, expr.span);\n         if constant_simple(cx, cx.typeck_results(), or_arm.body).is_some();"}, {"sha": "30091e0e2d79318bbacf2cecfd9f90be4458e27b", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=aecccbc579c0092e609f47fabc4d5fb6dbe110d0", "patch": "@@ -7,14 +7,15 @@ use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n use clippy_utils::visitors::LocalUsedVisitor;\n use clippy_utils::{\n-    get_parent_expr, in_macro, is_allowed, is_expn_of, is_refutable, is_wild, match_qpath, meets_msrv, path_to_local,\n+    get_parent_expr, in_macro, is_allowed, is_expn_of, is_lang_ctor, is_refutable, is_wild, meets_msrv, path_to_local,\n     path_to_local_id, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns, remove_blocks, strip_pat_refs,\n };\n use clippy_utils::{paths, search_same, SpanlessEq, SpanlessHash};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n+use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{\n     self as hir, Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Guard, HirId, Local, MatchSource,\n     Mutability, Node, Pat, PatKind, PathSegment, QPath, RangeEnd, TyKind,\n@@ -1189,10 +1190,10 @@ fn check_match_ref_pats(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], e\n \n fn check_match_as_ref(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n-        let arm_ref: Option<BindingAnnotation> = if is_none_arm(&arms[0]) {\n-            is_ref_some_arm(&arms[1])\n-        } else if is_none_arm(&arms[1]) {\n-            is_ref_some_arm(&arms[0])\n+        let arm_ref: Option<BindingAnnotation> = if is_none_arm(cx, &arms[0]) {\n+            is_ref_some_arm(cx, &arms[1])\n+        } else if is_none_arm(cx, &arms[1]) {\n+            is_ref_some_arm(cx, &arms[0])\n         } else {\n             None\n         };\n@@ -1575,20 +1576,20 @@ fn is_unit_expr(expr: &Expr<'_>) -> bool {\n }\n \n // Checks if arm has the form `None => None`\n-fn is_none_arm(arm: &Arm<'_>) -> bool {\n-    matches!(arm.pat.kind, PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE))\n+fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n+    matches!(arm.pat.kind, PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))\n }\n \n // Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n-fn is_ref_some_arm(arm: &Arm<'_>) -> Option<BindingAnnotation> {\n+fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<BindingAnnotation> {\n     if_chain! {\n-        if let PatKind::TupleStruct(ref path, pats, _) = arm.pat.kind;\n-        if pats.len() == 1 && match_qpath(path, &paths::OPTION_SOME);\n+        if let PatKind::TupleStruct(ref qpath, pats, _) = arm.pat.kind;\n+        if is_lang_ctor(cx, qpath, OptionSome);\n         if let PatKind::Binding(rb, .., ident, _) = pats[0].kind;\n         if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n         if let ExprKind::Call(e, args) = remove_blocks(arm.body).kind;\n         if let ExprKind::Path(ref some_path) = e.kind;\n-        if match_qpath(some_path, &paths::OPTION_SOME) && args.len() == 1;\n+        if is_lang_ctor(cx, some_path, OptionSome) && args.len() == 1;\n         if let ExprKind::Path(QPath::Resolved(_, path2)) = args[0].kind;\n         if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n         then {\n@@ -1700,10 +1701,11 @@ mod redundant_pattern_match {\n     use super::REDUNDANT_PATTERN_MATCHING;\n     use clippy_utils::diagnostics::span_lint_and_then;\n     use clippy_utils::source::snippet;\n-    use clippy_utils::{is_trait_method, match_qpath, paths};\n+    use clippy_utils::{is_lang_ctor, is_trait_method, match_qpath, paths};\n     use if_chain::if_chain;\n     use rustc_ast::ast::LitKind;\n     use rustc_errors::Applicability;\n+    use rustc_hir::LangItem::{OptionNone, OptionSome, PollPending, PollReady, ResultErr, ResultOk};\n     use rustc_hir::{Arm, Expr, ExprKind, MatchSource, PatKind, QPath};\n     use rustc_lint::LateContext;\n     use rustc_span::sym;\n@@ -1735,13 +1737,13 @@ mod redundant_pattern_match {\n         let good_method = match kind {\n             PatKind::TupleStruct(ref path, patterns, _) if patterns.len() == 1 => {\n                 if let PatKind::Wild = patterns[0].kind {\n-                    if match_qpath(path, &paths::RESULT_OK) {\n+                    if is_lang_ctor(cx, path, ResultOk) {\n                         \"is_ok()\"\n-                    } else if match_qpath(path, &paths::RESULT_ERR) {\n+                    } else if is_lang_ctor(cx, path, ResultErr) {\n                         \"is_err()\"\n-                    } else if match_qpath(path, &paths::OPTION_SOME) {\n+                    } else if is_lang_ctor(cx, path, OptionSome) {\n                         \"is_some()\"\n-                    } else if match_qpath(path, &paths::POLL_READY) {\n+                    } else if is_lang_ctor(cx, path, PollReady) {\n                         \"is_ready()\"\n                     } else if match_qpath(path, &paths::IPADDR_V4) {\n                         \"is_ipv4()\"\n@@ -1755,9 +1757,9 @@ mod redundant_pattern_match {\n                 }\n             },\n             PatKind::Path(ref path) => {\n-                if match_qpath(path, &paths::OPTION_NONE) {\n+                if is_lang_ctor(cx, path, OptionNone) {\n                     \"is_none()\"\n-                } else if match_qpath(path, &paths::POLL_PENDING) {\n+                } else if is_lang_ctor(cx, path, PollPending) {\n                     \"is_pending()\"\n                 } else {\n                     return;"}, {"sha": "1f521ec609095db064015a90bdf68af16b610174", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=aecccbc579c0092e609f47fabc4d5fb6dbe110d0", "patch": "@@ -1,10 +1,11 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::is_diagnostic_assoc_item;\n use clippy_utils::source::{snippet, snippet_with_applicability};\n-use clippy_utils::{in_macro, match_def_path, match_qpath, meets_msrv, paths};\n+use clippy_utils::{in_macro, match_def_path, meets_msrv, paths};\n+use clippy_utils::{is_diagnostic_assoc_item, is_lang_ctor};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::def_id::DefId;\n+use rustc_hir::LangItem::OptionNone;\n use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, QPath};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -102,7 +103,7 @@ impl_lint_pass!(MemReplace =>\n fn check_replace_option_with_none(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n     if let ExprKind::Path(ref replacement_qpath) = src.kind {\n         // Check that second argument is `Option::None`\n-        if match_qpath(replacement_qpath, &paths::OPTION_NONE) {\n+        if is_lang_ctor(cx, replacement_qpath, OptionNone) {\n             // Since this is a late pass (already type-checked),\n             // and we already know that the second argument is an\n             // `Option`, we do not need to check the first"}, {"sha": "36a1c13d5be1e1918cab85e6cea28e34920a102c", "filename": "clippy_lints/src/methods/option_map_or_none.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=aecccbc579c0092e609f47fabc4d5fb6dbe110d0", "patch": "@@ -1,9 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_lang_ctor;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{match_qpath, paths};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n+use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_lint::LateContext;\n use rustc_span::symbol::sym;\n \n@@ -32,7 +33,7 @@ pub(super) fn check<'tcx>(\n \n     let (lint_name, msg, instead, hint) = {\n         let default_arg_is_none = if let hir::ExprKind::Path(ref qpath) = def_arg.kind {\n-            match_qpath(qpath, &paths::OPTION_NONE)\n+            is_lang_ctor(cx, qpath, OptionNone)\n         } else {\n             return;\n         };\n@@ -43,7 +44,7 @@ pub(super) fn check<'tcx>(\n         }\n \n         let f_arg_is_some = if let hir::ExprKind::Path(ref qpath) = map_arg.kind {\n-            match_qpath(qpath, &paths::OPTION_SOME)\n+            is_lang_ctor(cx, qpath, OptionSome)\n         } else {\n             false\n         };"}, {"sha": "66255b77331eb79d1bc9d3b14c0fa73f9f4408ff", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=aecccbc579c0092e609f47fabc4d5fb6dbe110d0", "patch": "@@ -1,8 +1,9 @@\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::usage::mutated_variables;\n-use clippy_utils::{is_trait_method, match_qpath, path_to_local_id, paths};\n+use clippy_utils::{is_lang_ctor, is_trait_method, path_to_local_id};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n use rustc_span::sym;\n@@ -54,7 +55,7 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n     match &expr.kind {\n         hir::ExprKind::Call(func, args) => {\n             if let hir::ExprKind::Path(ref path) = func.kind {\n-                if match_qpath(path, &paths::OPTION_SOME) {\n+                if is_lang_ctor(cx, path, OptionSome) {\n                     if path_to_local_id(&args[0], arg_id) {\n                         return (false, false);\n                     }\n@@ -85,7 +86,7 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n             let else_check = check_expression(cx, arg_id, else_arm);\n             (if_check.0 | else_check.0, if_check.1 | else_check.1)\n         },\n-        hir::ExprKind::Path(path) if match_qpath(path, &paths::OPTION_NONE) => (false, true),\n+        hir::ExprKind::Path(path) if is_lang_ctor(cx, path, OptionNone) => (false, true),\n         _ => (true, true),\n     }\n }"}, {"sha": "cfe7ae6630e0472257e9284dcf0b3139aad5c980", "filename": "clippy_lints/src/needless_question_mark.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_question_mark.rs?ref=aecccbc579c0092e609f47fabc4d5fb6dbe110d0", "patch": "@@ -1,9 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_lang_ctor;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{differing_macro_contexts, is_ok_ctor, is_some_ctor, meets_msrv};\n+use clippy_utils::{differing_macro_contexts, meets_msrv};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n+use rustc_hir::LangItem::{OptionSome, ResultOk};\n use rustc_hir::{Body, Expr, ExprKind, LangItem, MatchSource, QPath};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_semver::RustcVersion;\n@@ -159,8 +161,8 @@ fn is_some_or_ok_call<'a>(\n     if_chain! {\n         // Check outer expression matches CALL_IDENT(ARGUMENT) format\n         if let ExprKind::Call(path, args) = &expr.kind;\n-        if let ExprKind::Path(QPath::Resolved(None, path)) = &path.kind;\n-        if is_some_ctor(cx, path.res) || is_ok_ctor(cx, path.res);\n+        if let ExprKind::Path(ref qpath) = &path.kind;\n+        if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk);\n \n         // Extract inner expression from ARGUMENT\n         if let ExprKind::Match(inner_expr_with_q, _, MatchSource::TryDesugar) = &args[0].kind;"}, {"sha": "e527adbb8929def838d0e8dc9ef6ffbfe6b3ad52", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=aecccbc579c0092e609f47fabc4d5fb6dbe110d0", "patch": "@@ -1,11 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::paths;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::usage::contains_return_break_continue_macro;\n-use clippy_utils::{eager_or_lazy, get_enclosing_block, in_macro, match_qpath};\n+use clippy_utils::{eager_or_lazy, get_enclosing_block, in_macro, is_lang_ctor};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n+use rustc_hir::LangItem::OptionSome;\n use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, PatKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -164,7 +164,7 @@ fn detect_option_if_let_else<'tcx>(\n         if arms.len() == 2;\n         if !is_result_ok(cx, cond_expr); // Don't lint on Result::ok because a different lint does it already\n         if let PatKind::TupleStruct(struct_qpath, &[inner_pat], _) = &arms[0].pat.kind;\n-        if match_qpath(struct_qpath, &paths::OPTION_SOME);\n+        if is_lang_ctor(cx, struct_qpath, OptionSome);\n         if let PatKind::Binding(bind_annotation, _, id, _) = &inner_pat.kind;\n         if !contains_return_break_continue_macro(arms[0].body);\n         if !contains_return_break_continue_macro(arms[1].body);"}, {"sha": "ea9ff37e13fdc49993d905ca6e3477df20b54619", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=aecccbc579c0092e609f47fabc4d5fb6dbe110d0", "patch": "@@ -1,12 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_lang_ctor;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{eq_expr_value, match_def_path, match_qpath, paths};\n+use clippy_utils::{eq_expr_value, match_qpath};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::{def, BindingAnnotation, Block, Expr, ExprKind, MatchSource, PatKind, StmtKind};\n+use rustc_hir::LangItem::OptionNone;\n+use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, MatchSource, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -156,15 +157,7 @@ impl QuestionMark {\n                 false\n             },\n             ExprKind::Ret(Some(expr)) => Self::expression_returns_none(cx, expr),\n-            ExprKind::Path(ref qp) => {\n-                if let Res::Def(DefKind::Ctor(def::CtorOf::Variant, def::CtorKind::Const), def_id) =\n-                    cx.qpath_res(qp, expression.hir_id)\n-                {\n-                    return match_def_path(cx, def_id, &paths::OPTION_NONE);\n-                }\n-\n-                false\n-            },\n+            ExprKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n             _ => false,\n         }\n     }"}, {"sha": "0b8c03c6865c9430bad5836ff20db99ab00ac042", "filename": "clippy_lints/src/try_err.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftry_err.rs?ref=aecccbc579c0092e609f47fabc4d5fb6dbe110d0", "patch": "@@ -1,9 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet, snippet_with_macro_callsite};\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{differing_macro_contexts, in_macro, match_def_path, match_qpath, paths};\n+use clippy_utils::{differing_macro_contexts, in_macro, is_lang_ctor, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n+use rustc_hir::LangItem::ResultErr;\n use rustc_hir::{Expr, ExprKind, LangItem, MatchSource, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n@@ -68,7 +69,7 @@ impl<'tcx> LateLintPass<'tcx> for TryErr {\n             if let ExprKind::Call(err_fun, err_args) = try_arg.kind;\n             if let Some(err_arg) = err_args.get(0);\n             if let ExprKind::Path(ref err_fun_path) = err_fun.kind;\n-            if match_qpath(err_fun_path, &paths::RESULT_ERR);\n+            if is_lang_ctor(cx, err_fun_path, ResultErr);\n             if let Some(return_ty) = find_return_type(cx, &expr.kind);\n             then {\n                 let prefix;"}, {"sha": "d2c0f60d296777f05345211829b7a26b4988ee08", "filename": "clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=aecccbc579c0092e609f47fabc4d5fb6dbe110d0", "patch": "@@ -1,9 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n-use clippy_utils::{contains_return, in_macro, match_qpath, paths, return_ty, visitors::find_all_ret_expressions};\n+use clippy_utils::{contains_return, in_macro, is_lang_ctor, return_ty, visitors::find_all_ret_expressions};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n+use rustc_hir::LangItem::{OptionSome, ResultOk};\n use rustc_hir::{Body, ExprKind, FnDecl, HirId, Impl, ItemKind, Node};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n@@ -85,11 +86,11 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n         }\n \n         // Get the wrapper and inner types, if can't, abort.\n-        let (return_type_label, path, inner_type) = if let ty::Adt(adt_def, subst) = return_ty(cx, hir_id).kind() {\n+        let (return_type_label, lang_item, inner_type) = if let ty::Adt(adt_def, subst) = return_ty(cx, hir_id).kind() {\n             if cx.tcx.is_diagnostic_item(sym::option_type, adt_def.did) {\n-                (\"Option\", &paths::OPTION_SOME, subst.type_at(0))\n+                (\"Option\", OptionSome, subst.type_at(0))\n             } else if cx.tcx.is_diagnostic_item(sym::result_type, adt_def.did) {\n-                (\"Result\", &paths::RESULT_OK, subst.type_at(0))\n+                (\"Result\", ResultOk, subst.type_at(0))\n             } else {\n                 return;\n             }\n@@ -107,7 +108,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n                 // Get the Path of the function call.\n                 if let ExprKind::Path(ref qpath) = func.kind;\n                 // Check if OPTION_SOME or RESULT_OK, depending on return type.\n-                if match_qpath(qpath, path);\n+                if is_lang_ctor(cx, qpath, lang_item);\n                 if args.len() == 1;\n                 // Make sure the function argument does not contain a return expression.\n                 if !contains_return(&args[0]);"}, {"sha": "5e8e530f480fb439871a99399e7ef4123657311d", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=aecccbc579c0092e609f47fabc4d5fb6dbe110d0", "patch": "@@ -41,7 +41,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n         };\n \n         match expr.kind {\n-            hir::ExprKind::Match(res, _, _) if is_try(expr).is_some() => {\n+            hir::ExprKind::Match(res, _, _) if is_try(cx, expr).is_some() => {\n                 if let hir::ExprKind::Call(func, args) = res.kind {\n                     if matches!(\n                         func.kind,"}, {"sha": "e99ffbe269b602af77d63c877dc5f196636c33a7", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 22, "deletions": 32, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aecccbc579c0092e609f47fabc4d5fb6dbe110d0/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=aecccbc579c0092e609f47fabc4d5fb6dbe110d0", "patch": "@@ -57,9 +57,10 @@ use if_chain::if_chain;\n use rustc_ast::ast::{self, Attribute, BorrowKind, LitKind};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_hir::LangItem::{ResultErr, ResultOk};\n use rustc_hir::{\n     def, Arm, BindingAnnotation, Block, Body, Constness, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl, ImplItem,\n     ImplItemKind, Item, ItemKind, LangItem, MatchSource, Node, Param, Pat, PatKind, Path, PathSegment, QPath,\n@@ -222,6 +223,19 @@ pub fn in_constant(cx: &LateContext<'_>, id: HirId) -> bool {\n     }\n }\n \n+/// Checks if a `QPath` resolves to a constructor of a `LangItem`.\n+/// For example, use this to check whether a function call or a pattern is `Some(..)`.\n+pub fn is_lang_ctor(cx: &LateContext<'_>, qpath: &QPath<'_>, lang_item: LangItem) -> bool {\n+    if let QPath::Resolved(_, path) = qpath {\n+        if let Res::Def(DefKind::Ctor(..), ctor_id) = path.res {\n+            if let Ok(item_id) = cx.tcx.lang_items().require(lang_item) {\n+                return cx.tcx.parent(ctor_id) == Some(item_id);\n+            }\n+        }\n+    }\n+    false\n+}\n+\n /// Returns `true` if this `span` was expanded by any macro.\n #[must_use]\n pub fn in_macro(span: Span) -> bool {\n@@ -1011,11 +1025,11 @@ pub fn iter_input_pats<'tcx>(decl: &FnDecl<'_>, body: &'tcx Body<'_>) -> impl It\n \n /// Checks if a given expression is a match expression expanded from the `?`\n /// operator or the `try` macro.\n-pub fn is_try<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-    fn is_ok(arm: &Arm<'_>) -> bool {\n+pub fn is_try<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n+    fn is_ok(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n         if_chain! {\n             if let PatKind::TupleStruct(ref path, ref pat, None) = arm.pat.kind;\n-            if match_qpath(path, &paths::RESULT_OK[1..]);\n+            if is_lang_ctor(cx, path, ResultOk);\n             if let PatKind::Binding(_, hir_id, _, None) = pat[0].kind;\n             if path_to_local_id(arm.body, hir_id);\n             then {\n@@ -1025,9 +1039,9 @@ pub fn is_try<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n         false\n     }\n \n-    fn is_err(arm: &Arm<'_>) -> bool {\n+    fn is_err(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n         if let PatKind::TupleStruct(ref path, _, _) = arm.pat.kind {\n-            match_qpath(path, &paths::RESULT_ERR[1..])\n+            is_lang_ctor(cx, path, ResultErr)\n         } else {\n             false\n         }\n@@ -1043,8 +1057,8 @@ pub fn is_try<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n             if arms.len() == 2;\n             if arms[0].guard.is_none();\n             if arms[1].guard.is_none();\n-            if (is_ok(&arms[0]) && is_err(&arms[1])) ||\n-                (is_ok(&arms[1]) && is_err(&arms[0]));\n+            if (is_ok(cx, &arms[0]) && is_err(cx, &arms[1])) ||\n+                (is_ok(cx, &arms[1]) && is_err(cx, &arms[0]));\n             then {\n                 return Some(expr);\n             }\n@@ -1450,27 +1464,3 @@ pub fn is_hir_ty_cfg_dependant(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n         }\n     }\n }\n-\n-/// Check if the resolution of a given path is an `Ok` variant of `Result`.\n-pub fn is_ok_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n-    if let Some(ok_id) = cx.tcx.lang_items().result_ok_variant() {\n-        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n-            if let Some(variant_id) = cx.tcx.parent(id) {\n-                return variant_id == ok_id;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n-/// Check if the resolution of a given path is a `Some` variant of `Option`.\n-pub fn is_some_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n-    if let Some(some_id) = cx.tcx.lang_items().option_some_variant() {\n-        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n-            if let Some(variant_id) = cx.tcx.parent(id) {\n-                return variant_id == some_id;\n-            }\n-        }\n-    }\n-    false\n-}"}]}