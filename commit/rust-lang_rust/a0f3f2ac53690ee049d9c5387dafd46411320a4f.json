{"sha": "a0f3f2ac53690ee049d9c5387dafd46411320a4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwZjNmMmFjNTM2OTBlZTA0OWQ5YzUzODdkYWZkNDY0MTEzMjBhNGY=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-06-05T19:34:03Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-07-28T14:12:32Z"}, "message": "Extend `trans::datum::Lvalue` so that it carrys an optional dropflag hint.\n\nInstrumented calls sites that construct Lvalues to ease tracking down\ncases that we might need to change whether or not they carry a hint.\n\nNote that this commit does not do anything to actually *construct*\nthe `lldropflag_hints` map, nor does it change anything about codegen\nitself. Those parts are in follow-on commits.", "tree": {"sha": "a1268400187700f41ef0b917dd08fd8ca33ec724", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1268400187700f41ef0b917dd08fd8ca33ec724"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0f3f2ac53690ee049d9c5387dafd46411320a4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0f3f2ac53690ee049d9c5387dafd46411320a4f", "html_url": "https://github.com/rust-lang/rust/commit/a0f3f2ac53690ee049d9c5387dafd46411320a4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0f3f2ac53690ee049d9c5387dafd46411320a4f/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20aa27b7bca3504f6a7672cc88e17a9c286cec4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/20aa27b7bca3504f6a7672cc88e17a9c286cec4b", "html_url": "https://github.com/rust-lang/rust/commit/20aa27b7bca3504f6a7672cc88e17a9c286cec4b"}], "stats": {"total": 244, "additions": 213, "deletions": 31}, "files": [{"sha": "08be1fd2e4c57cca36831286105283b0c3dd7f7d", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a0f3f2ac53690ee049d9c5387dafd46411320a4f/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0f3f2ac53690ee049d9c5387dafd46411320a4f/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=a0f3f2ac53690ee049d9c5387dafd46411320a4f", "patch": "@@ -437,7 +437,7 @@ impl MatchInput {\n     fn from_val(val: ValueRef) -> MatchInput {\n         MatchInput {\n             val: val,\n-            lval: Lvalue,\n+            lval: Lvalue::new(\"MatchInput::from_val\"),\n         }\n     }\n \n@@ -941,30 +941,41 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                cs: Option<cleanup::ScopeId>)\n                                -> Block<'blk, 'tcx> {\n     for (&ident, &binding_info) in bindings_map {\n-        let llval = match binding_info.trmode {\n+        let (llval, aliases_other_state) = match binding_info.trmode {\n             // By value mut binding for a copy type: load from the ptr\n             // into the matched value and copy to our alloca\n             TrByCopy(llbinding) |\n             TrByMoveIntoCopy(llbinding) => {\n                 let llval = Load(bcx, binding_info.llmatch);\n-                let datum = Datum::new(llval, binding_info.ty, Lvalue);\n+                let lval = match binding_info.trmode {\n+                    TrByCopy(..) =>\n+                        Lvalue::new(\"_match::insert_lllocals\"),\n+                    TrByMoveIntoCopy(..) =>\n+                        Lvalue::match_input(\"_match::insert_lllocals\", bcx, binding_info.id),\n+                    _ => unreachable!(),\n+                };\n+                let datum = Datum::new(llval, binding_info.ty, lval);\n                 call_lifetime_start(bcx, llbinding);\n                 bcx = datum.store_to(bcx, llbinding);\n                 if let Some(cs) = cs {\n                     bcx.fcx.schedule_lifetime_end(cs, llbinding);\n                 }\n \n-                llbinding\n+                (llbinding, false)\n             },\n \n             // By value move bindings: load from the ptr into the matched value\n-            TrByMoveRef => Load(bcx, binding_info.llmatch),\n+            TrByMoveRef => (Load(bcx, binding_info.llmatch), true),\n \n             // By ref binding: use the ptr into the matched value\n-            TrByRef => binding_info.llmatch\n+            TrByRef => (binding_info.llmatch, true),\n         };\n \n-        let datum = Datum::new(llval, binding_info.ty, Lvalue);\n+        let lval = Lvalue::local(\"_match::insert_lllocals\",\n+                                 bcx,\n+                                 binding_info.id,\n+                                 aliases_other_state);\n+        let datum = Datum::new(llval, binding_info.ty, lval);\n         if let Some(cs) = cs {\n             bcx.fcx.schedule_lifetime_end(cs, binding_info.llmatch);\n             bcx.fcx.schedule_drop_and_fill_mem(cs, llval, binding_info.ty);\n@@ -1619,6 +1630,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let scope = cleanup::var_scope(tcx, p_id);\n             bcx = mk_binding_alloca(\n                 bcx, p_id, path1.node.name, scope, (),\n+                \"_match::store_local::create_dummy_locals\",\n                 |(), bcx, llval, ty| { drop_done_fill_mem(bcx, llval, ty); bcx });\n         });\n         bcx\n@@ -1641,6 +1653,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     let var_scope = cleanup::var_scope(tcx, local.id);\n                     return mk_binding_alloca(\n                         bcx, pat.id, ident.name, var_scope, (),\n+                        \"_match::store_local\",\n                         |(), bcx, v, _| expr::trans_into(bcx, &**init_expr,\n                                                          expr::SaveIn(v)));\n                 }\n@@ -1668,6 +1681,7 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n                                        name: ast::Name,\n                                        cleanup_scope: cleanup::ScopeId,\n                                        arg: A,\n+                                       caller_name: &'static str,\n                                        populate: F)\n                                        -> Block<'blk, 'tcx> where\n     F: FnOnce(A, Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>,\n@@ -1685,7 +1699,8 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n \n     // Now that memory is initialized and has cleanup scheduled,\n     // create the datum and insert into the local variable map.\n-    let datum = Datum::new(llval, var_ty, Lvalue);\n+    let lval = Lvalue::binding(caller_name, bcx, p_id, name);\n+    let datum = Datum::new(llval, var_ty, lval);\n     bcx.fcx.lllocals.borrow_mut().insert(p_id, datum);\n     bcx\n }\n@@ -1730,6 +1745,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // map.\n                 bcx = mk_binding_alloca(\n                     bcx, pat.id, path1.node.name, cleanup_scope, (),\n+                    \"_match::bind_irrefutable_pat\",\n                     |(), bcx, llval, ty| {\n                         match pat_binding_mode {\n                             ast::BindByValue(_) => {"}, {"sha": "d2753f5b78fb40a0fce87ef5ec9cc356054cbe10", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0f3f2ac53690ee049d9c5387dafd46411320a4f/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0f3f2ac53690ee049d9c5387dafd46411320a4f/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=a0f3f2ac53690ee049d9c5387dafd46411320a4f", "patch": "@@ -1083,7 +1083,7 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             ));\n             bcx = fold_variants(bcx, r, val, |variant_cx, st, value| {\n                 let ptr = struct_field_ptr(variant_cx, st, value, (st.fields.len() - 1), false);\n-                datum::Datum::new(ptr, ptr_ty, datum::Lvalue)\n+                datum::Datum::new(ptr, ptr_ty, datum::Lvalue::new(\"adt::trans_drop_flag_ptr\"))\n                     .store_to(variant_cx, scratch.val)\n             });\n             let expr_datum = scratch.to_expr_datum();"}, {"sha": "ec7ff4fa748e0dbac8f1e767fac064959a8c2a02", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0f3f2ac53690ee049d9c5387dafd46411320a4f/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0f3f2ac53690ee049d9c5387dafd46411320a4f/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=a0f3f2ac53690ee049d9c5387dafd46411320a4f", "patch": "@@ -56,7 +56,7 @@ use trans::cleanup;\n use trans::closure;\n use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_integral};\n use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n-use trans::common::{CrateContext, FunctionContext};\n+use trans::common::{CrateContext, DropFlagHintsMap, FunctionContext};\n use trans::common::{Result, NodeIdAndSpan};\n use trans::common::{node_id_type, return_type_is_void};\n use trans::common::{type_is_immediate, type_is_zero_size, val_ty};\n@@ -1235,6 +1235,7 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n           caller_expects_out_pointer: uses_outptr,\n           lllocals: RefCell::new(NodeMap()),\n           llupvars: RefCell::new(NodeMap()),\n+          lldropflag_hints: RefCell::new(DropFlagHintsMap::new()),\n           id: id,\n           param_substs: param_substs,\n           span: sp,"}, {"sha": "fe996020267ed5d0388234fec4b8f5ab78d2efe2", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a0f3f2ac53690ee049d9c5387dafd46411320a4f/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0f3f2ac53690ee049d9c5387dafd46411320a4f/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=a0f3f2ac53690ee049d9c5387dafd46411320a4f", "patch": "@@ -124,6 +124,7 @@ use trans::base;\n use trans::build;\n use trans::common;\n use trans::common::{Block, FunctionContext, NodeIdAndSpan};\n+use trans::datum::{Datum, Lvalue};\n use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::glue;\n use middle::region;\n@@ -212,6 +213,12 @@ pub enum ScopeId {\n     CustomScope(CustomScopeIndex)\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub struct DropHint<K>(pub ast::NodeId, pub K);\n+\n+pub type DropHintDatum<'tcx> = DropHint<Datum<'tcx, Lvalue>>;\n+pub type DropHintValue = DropHint<ValueRef>;\n+\n impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     /// Invoked when we start to trans the code contained within a new cleanup scope.\n     fn push_ast_cleanup_scope(&self, debug_loc: NodeIdAndSpan) {"}, {"sha": "82c835e8c34ec8dcf757d6c4f041066d32b3b6b4", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a0f3f2ac53690ee049d9c5387dafd46411320a4f/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0f3f2ac53690ee049d9c5387dafd46411320a4f/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=a0f3f2ac53690ee049d9c5387dafd46411320a4f", "patch": "@@ -299,6 +299,27 @@ pub fn validate_substs(substs: &Substs) {\n type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n pub type LvalueDatum<'tcx> = datum::Datum<'tcx, datum::Lvalue>;\n \n+#[derive(Clone, Debug)]\n+struct HintEntry<'tcx> {\n+    // The datum for the dropflag-hint itself; note that many\n+    // source-level Lvalues will be associated with the same\n+    // dropflag-hint datum.\n+    datum: cleanup::DropHintDatum<'tcx>,\n+}\n+\n+pub struct DropFlagHintsMap<'tcx> {\n+    // Maps NodeId for expressions that read/write unfragmented state\n+    // to that state's drop-flag \"hint.\"  (A stack-local hint\n+    // indicates either that (1.) it is certain that no-drop is\n+    // needed, or (2.)  inline drop-flag must be consulted.)\n+    node_map: NodeMap<HintEntry<'tcx>>,\n+}\n+\n+impl<'tcx> DropFlagHintsMap<'tcx> {\n+    pub fn new() -> DropFlagHintsMap<'tcx> { DropFlagHintsMap { node_map: NodeMap() } }\n+    pub fn has_hint(&self, id: ast::NodeId) -> bool { self.node_map.contains_key(&id) }\n+}\n+\n // Function context.  Every LLVM function we create will have one of\n // these.\n pub struct FunctionContext<'a, 'tcx: 'a> {\n@@ -349,6 +370,10 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // Same as above, but for closure upvars\n     pub llupvars: RefCell<NodeMap<ValueRef>>,\n \n+    // Carries info about drop-flags for local bindings (longer term,\n+    // paths) for the code being compiled.\n+    pub lldropflag_hints: RefCell<DropFlagHintsMap<'tcx>>,\n+\n     // The NodeId of the function, or -1 if it doesn't correspond to\n     // a user-defined function.\n     pub id: ast::NodeId,"}, {"sha": "f14b6f368f4b140298a1da949674b9cf64894a1a", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 137, "deletions": 10, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/a0f3f2ac53690ee049d9c5387dafd46411320a4f/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0f3f2ac53690ee049d9c5387dafd46411320a4f/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=a0f3f2ac53690ee049d9c5387dafd46411320a4f", "patch": "@@ -138,17 +138,141 @@ pub enum Expr {\n     /// `val` is a pointer into memory for which a cleanup is scheduled\n     /// (and thus has type *T). If you move out of an Lvalue, you must\n     /// zero out the memory (FIXME #5016).\n-    LvalueExpr,\n+    LvalueExpr(Lvalue),\n }\n \n-#[derive(Clone, Copy, Debug)]\n-pub struct Lvalue;\n+#[derive(Copy, Clone, Debug)]\n+pub enum DropFlagInfo {\n+    DontZeroJustUse(ast::NodeId),\n+    ZeroAndMaintain(ast::NodeId),\n+    None,\n+}\n+\n+impl DropFlagInfo {\n+    pub fn must_zero(&self) -> bool {\n+        match *self {\n+            DropFlagInfo::DontZeroJustUse(..) => false,\n+            DropFlagInfo::ZeroAndMaintain(..) => true,\n+            DropFlagInfo::None => true,\n+        }\n+    }\n+\n+    pub fn hint_to_maintain(&self) -> Option<ast::NodeId> {\n+        match *self {\n+            DropFlagInfo::DontZeroJustUse(id) => Some(id),\n+            DropFlagInfo::ZeroAndMaintain(id) => Some(id),\n+            DropFlagInfo::None => None,\n+        }\n+    }\n+}\n+\n+// FIXME: having Lvalue be `Copy` is a bit of a footgun, since clients\n+// may not realize that subparts of an Lvalue can have a subset of\n+// drop-flags associated with them, while this as written will just\n+// memcpy the drop_flag_info. But, it is an easier way to get `_match`\n+// off the ground to just let this be `Copy` for now.\n+#[derive(Copy, Clone, Debug)]\n+pub struct Lvalue {\n+    pub source: &'static str,\n+    pub drop_flag_info: DropFlagInfo\n+}\n \n #[derive(Debug)]\n pub struct Rvalue {\n     pub mode: RvalueMode\n }\n \n+impl Lvalue {\n+    pub fn new(source: &'static str) -> Lvalue {\n+        Lvalue { source: source, drop_flag_info: DropFlagInfo::None }\n+    }\n+\n+    pub fn upvar<'blk, 'tcx>(source: &'static str,\n+                             bcx: Block<'blk, 'tcx>,\n+                             id: ast::NodeId) -> Lvalue {\n+        let info = if Lvalue::has_dropflag_hint(bcx, id) {\n+            DropFlagInfo::ZeroAndMaintain(id)\n+        } else {\n+            DropFlagInfo::None\n+        };\n+        let info = if bcx.tcx().sess.nonzeroing_move_hints() { info } else { DropFlagInfo::None };\n+        debug!(\"upvar Lvalue at {}, id: {} info: {:?}\", source, id, info);\n+        Lvalue { source: source, drop_flag_info: info }\n+    }\n+\n+    pub fn match_input<'blk, 'tcx>(source: &'static str,\n+                                   bcx: Block<'blk, 'tcx>,\n+                                   id: ast::NodeId) -> Lvalue\n+    {\n+        let info = if Lvalue::has_dropflag_hint(bcx, id) {\n+            // match_input is used to move from the input into a\n+            // separate stack slot; it must zero (at least until we\n+            // improve things to track drop flags for the fragmented\n+            // parent match input expression).\n+            DropFlagInfo::ZeroAndMaintain(id)\n+        } else {\n+            DropFlagInfo::None\n+        };\n+        let info = if bcx.tcx().sess.nonzeroing_move_hints() { info } else { DropFlagInfo::None };\n+        debug!(\"match_input Lvalue at {}, id: {} info: {:?}\", source, id, info);\n+        Lvalue { source: source, drop_flag_info: info }\n+    }\n+\n+    pub fn local<'blk, 'tcx>(source: &'static str,\n+                             bcx: Block<'blk, 'tcx>,\n+                             id: ast::NodeId,\n+                             aliases_other_state: bool)\n+                             -> Lvalue\n+    {\n+        let info = if Lvalue::has_dropflag_hint(bcx, id) {\n+            if aliases_other_state {\n+                DropFlagInfo::ZeroAndMaintain(id)\n+            } else {\n+                DropFlagInfo::DontZeroJustUse(id)\n+            }\n+        } else {\n+            DropFlagInfo::None\n+        };\n+        let info = if bcx.tcx().sess.nonzeroing_move_hints() { info } else { DropFlagInfo::None };\n+        debug!(\"local Lvalue at {}, id: {} info: {:?}\", source, id, info);\n+        Lvalue { source: source, drop_flag_info: info }\n+    }\n+\n+    pub fn store_arg<'blk, 'tcx>(source: &'static str,\n+                                 bcx: Block<'blk, 'tcx>,\n+                                 id: ast::NodeId) -> Lvalue\n+    {\n+        let info = if Lvalue::has_dropflag_hint(bcx, id) {\n+            DropFlagInfo::ZeroAndMaintain(id)\n+        } else {\n+            DropFlagInfo::None\n+        };\n+        let info = if bcx.tcx().sess.nonzeroing_move_hints() { info } else { DropFlagInfo::None };\n+        debug!(\"store_arg Lvalue at {}, id: {} info: {:?}\", source, id, info);\n+        Lvalue { source: source, drop_flag_info: info }\n+    }\n+\n+    pub fn binding<'blk, 'tcx>(source: &'static str,\n+                               bcx: Block<'blk, 'tcx>,\n+                               id: ast::NodeId,\n+                               name: ast::Name) -> Lvalue {\n+        let info = if Lvalue::has_dropflag_hint(bcx, id) {\n+            DropFlagInfo::DontZeroJustUse(id)\n+        } else {\n+            DropFlagInfo::None\n+        };\n+        let info = if bcx.tcx().sess.nonzeroing_move_hints() { info } else { DropFlagInfo::None };\n+        debug!(\"binding Lvalue at {}, id: {} name: {} info: {:?}\",\n+               source, id, name, info);\n+        Lvalue { source: source, drop_flag_info: info }\n+    }\n+\n+    fn has_dropflag_hint<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                     id: ast::NodeId) -> bool {\n+        bcx.fcx.lldropflag_hints.borrow().has_hint(id)\n+    }\n+}\n+\n impl Rvalue {\n     pub fn new(m: RvalueMode) -> Rvalue {\n         Rvalue { mode: m }\n@@ -201,7 +325,7 @@ pub fn lvalue_scratch_datum<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n     bcx.fcx.schedule_lifetime_end(scope, scratch);\n     bcx.fcx.schedule_drop_mem(scope, scratch, ty);\n \n-    DatumBlock::new(bcx, Datum::new(scratch, ty, Lvalue))\n+    DatumBlock::new(bcx, Datum::new(scratch, ty, Lvalue::new(\"datum::lvalue_scratch_datum\")))\n }\n \n /// Allocates temporary space on the stack using alloca() and returns a by-ref Datum pointing to\n@@ -308,7 +432,7 @@ impl KindOps for Lvalue {\n     }\n \n     fn to_expr_kind(self) -> Expr {\n-        LvalueExpr\n+        LvalueExpr(self)\n     }\n }\n \n@@ -319,14 +443,14 @@ impl KindOps for Expr {\n                               ty: Ty<'tcx>)\n                               -> Block<'blk, 'tcx> {\n         match *self {\n-            LvalueExpr => Lvalue.post_store(bcx, val, ty),\n+            LvalueExpr(ref l) => l.post_store(bcx, val, ty),\n             RvalueExpr(ref r) => r.post_store(bcx, val, ty),\n         }\n     }\n \n     fn is_by_ref(&self) -> bool {\n         match *self {\n-            LvalueExpr => Lvalue.is_by_ref(),\n+            LvalueExpr(ref l) => l.is_by_ref(),\n             RvalueExpr(ref r) => r.is_by_ref()\n         }\n     }\n@@ -360,7 +484,10 @@ impl<'tcx> Datum<'tcx, Rvalue> {\n         match self.kind.mode {\n             ByRef => {\n                 add_rvalue_clean(ByRef, fcx, scope, self.val, self.ty);\n-                DatumBlock::new(bcx, Datum::new(self.val, self.ty, Lvalue))\n+                DatumBlock::new(bcx, Datum::new(\n+                    self.val,\n+                    self.ty,\n+                    Lvalue::new(\"datum::to_lvalue_datum_in_scope\")))\n             }\n \n             ByValue => {\n@@ -417,7 +544,7 @@ impl<'tcx> Datum<'tcx, Expr> {\n     {\n         let Datum { val, ty, kind } = self;\n         match kind {\n-            LvalueExpr => if_lvalue(Datum::new(val, ty, Lvalue)),\n+            LvalueExpr(l) => if_lvalue(Datum::new(val, ty, l)),\n             RvalueExpr(r) => if_rvalue(Datum::new(val, ty, r)),\n         }\n     }\n@@ -528,7 +655,7 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n         };\n         Datum {\n             val: val,\n-            kind: Lvalue,\n+            kind: Lvalue::new(\"Datum::get_element\"),\n             ty: ty,\n         }\n     }"}, {"sha": "1582a43d94de59d9c69fa65fdc0087e86e81c60f", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a0f3f2ac53690ee049d9c5387dafd46411320a4f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0f3f2ac53690ee049d9c5387dafd46411320a4f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=a0f3f2ac53690ee049d9c5387dafd46411320a4f", "patch": "@@ -227,7 +227,7 @@ pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let const_ty = expr_ty_adjusted(bcx, expr);\n             let llty = type_of::type_of(bcx.ccx(), const_ty);\n             let global = PointerCast(bcx, global, llty.ptr_to());\n-            let datum = Datum::new(global, const_ty, Lvalue);\n+            let datum = Datum::new(global, const_ty, Lvalue::new(\"expr::trans\"));\n             return DatumBlock::new(bcx, datum.to_expr_datum());\n         }\n \n@@ -733,7 +733,7 @@ fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n             // Always generate an lvalue datum, because this pointer doesn't own\n             // the data and cleanup is scheduled elsewhere.\n-            DatumBlock::new(bcx, Datum::new(scratch.val, scratch.ty, LvalueExpr))\n+            DatumBlock::new(bcx, Datum::new(scratch.val, scratch.ty, LvalueExpr(d.kind)))\n         }\n     })\n \n@@ -810,10 +810,11 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                Some(SaveIn(scratch.val)),\n                                                false));\n             let datum = scratch.to_expr_datum();\n+            let lval = Lvalue::new(\"expr::trans_index overload\");\n             if type_is_sized(bcx.tcx(), elt_ty) {\n-                Datum::new(datum.to_llscalarish(bcx), elt_ty, LvalueExpr)\n+                Datum::new(datum.to_llscalarish(bcx), elt_ty, LvalueExpr(lval))\n             } else {\n-                Datum::new(datum.val, elt_ty, LvalueExpr)\n+                Datum::new(datum.val, elt_ty, LvalueExpr(lval))\n             }\n         }\n         None => {\n@@ -867,7 +868,8 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             });\n             let elt = InBoundsGEP(bcx, base, &[ix_val]);\n             let elt = PointerCast(bcx, elt, type_of::type_of(ccx, unit_ty).ptr_to());\n-            Datum::new(elt, unit_ty, LvalueExpr)\n+            let lval = Lvalue::new(\"expr::trans_index fallback\");\n+            Datum::new(elt, unit_ty, LvalueExpr(lval))\n         }\n     };\n \n@@ -912,7 +914,8 @@ fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // Case 2.\n                 base::get_extern_const(bcx.ccx(), did, const_ty)\n             };\n-            DatumBlock::new(bcx, Datum::new(val, const_ty, LvalueExpr))\n+            let lval = Lvalue::new(\"expr::trans_def\");\n+            DatumBlock::new(bcx, Datum::new(val, const_ty, LvalueExpr(lval)))\n         }\n         def::DefConst(_) => {\n             bcx.sess().span_bug(ref_expr.span,\n@@ -1302,8 +1305,9 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         def::DefUpvar(nid, _) => {\n             // Can't move upvars, so this is never a ZeroMemLastUse.\n             let local_ty = node_id_type(bcx, nid);\n+            let lval = Lvalue::upvar(\"expr::trans_local_var\", bcx, nid);\n             match bcx.fcx.llupvars.borrow().get(&nid) {\n-                Some(&val) => Datum::new(val, local_ty, Lvalue),\n+                Some(&val) => Datum::new(val, local_ty, lval),\n                 None => {\n                     bcx.sess().bug(&format!(\n                         \"trans_local_var: no llval for upvar {} found\",\n@@ -2267,21 +2271,23 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             if type_is_sized(bcx.tcx(), content_ty) {\n                 let ptr = load_ty(bcx, datum.val, datum.ty);\n-                DatumBlock::new(bcx, Datum::new(ptr, content_ty, LvalueExpr))\n+                DatumBlock::new(bcx, Datum::new(ptr, content_ty, LvalueExpr(datum.kind)))\n             } else {\n                 // A fat pointer and a DST lvalue have the same representation\n                 // just different types. Since there is no temporary for `*e`\n                 // here (because it is unsized), we cannot emulate the sized\n                 // object code path for running drop glue and free. Instead,\n                 // we schedule cleanup for `e`, turning it into an lvalue.\n \n-                let datum = Datum::new(datum.val, content_ty, LvalueExpr);\n+                let lval = Lvalue::new(\"expr::deref_once ty_uniq\");\n+                let datum = Datum::new(datum.val, content_ty, LvalueExpr(lval));\n                 DatumBlock::new(bcx, datum)\n             }\n         }\n \n         ty::TyRawPtr(ty::TypeAndMut { ty: content_ty, .. }) |\n         ty::TyRef(_, ty::TypeAndMut { ty: content_ty, .. }) => {\n+            let lval = Lvalue::new(\"expr::deref_once ptr\");\n             if type_is_sized(bcx.tcx(), content_ty) {\n                 let ptr = datum.to_llscalarish(bcx);\n \n@@ -2290,11 +2296,11 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // rvalue for non-owning pointers like &T or *T, in which\n                 // case cleanup *is* scheduled elsewhere, by the true\n                 // owner (or, in the case of *T, by the user).\n-                DatumBlock::new(bcx, Datum::new(ptr, content_ty, LvalueExpr))\n+                DatumBlock::new(bcx, Datum::new(ptr, content_ty, LvalueExpr(lval)))\n             } else {\n                 // A fat pointer and a DST lvalue have the same representation\n                 // just different types.\n-                DatumBlock::new(bcx, Datum::new(datum.val, content_ty, LvalueExpr))\n+                DatumBlock::new(bcx, Datum::new(datum.val, content_ty, LvalueExpr(lval)))\n             }\n         }\n "}]}