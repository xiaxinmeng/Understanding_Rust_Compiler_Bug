{"sha": "77be4ecc1795787eab4b51b9def35096546122ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3YmU0ZWNjMTc5NTc4N2VhYjRiNTFiOWRlZjM1MDk2NTQ2MTIyZWM=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-02-24T15:14:03Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-02-24T20:04:22Z"}, "message": "Make list of statements flat\n\nIn MIR we previously tried to match `let x in { exprs; let y in { exprs; }}` with our data\nstructures which is rather unwieldy, espeicially because it requires some sort of recursion or\nstack to process, while, a flat list of statements is enough \u2013 lets only relinquish their lifetime\nat the end of the block (i.e. end of the list).\n\nAlso fixes #31853.", "tree": {"sha": "298378970f1eefc214a700d333212d25a9409c26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/298378970f1eefc214a700d333212d25a9409c26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77be4ecc1795787eab4b51b9def35096546122ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77be4ecc1795787eab4b51b9def35096546122ec", "html_url": "https://github.com/rust-lang/rust/commit/77be4ecc1795787eab4b51b9def35096546122ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77be4ecc1795787eab4b51b9def35096546122ec/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbd817115525b8f11ffe0a301e17341684771369", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbd817115525b8f11ffe0a301e17341684771369", "html_url": "https://github.com/rust-lang/rust/commit/fbd817115525b8f11ffe0a301e17341684771369"}], "stats": {"total": 183, "additions": 73, "deletions": 110}, "files": [{"sha": "a4d222d24cac1619c6f1f6efebb88d1b07a8010c", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77be4ecc1795787eab4b51b9def35096546122ec/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77be4ecc1795787eab4b51b9def35096546122ec/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=77be4ecc1795787eab4b51b9def35096546122ec", "patch": "@@ -198,8 +198,8 @@ pub fn visit_all_items_in_krate<'tcx,V,F>(tcx: &ty::ctxt<'tcx>,\n         fn visit_item(&mut self, i: &'tcx hir::Item) {\n             let item_def_id = self.tcx.map.local_def_id(i.id);\n             let task_id = (self.dep_node_fn)(item_def_id);\n-            debug!(\"About to start task {:?}\", task_id);\n             let _task = self.tcx.dep_graph.in_task(task_id);\n+            debug!(\"Started task {:?}\", task_id);\n             self.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n             self.visitor.visit_item(i)\n         }"}, {"sha": "7d8a35165d286e5b47c136b58238d40cfbbe6436", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 62, "deletions": 6, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/77be4ecc1795787eab4b51b9def35096546122ec/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77be4ecc1795787eab4b51b9def35096546122ec/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=77be4ecc1795787eab4b51b9def35096546122ec", "patch": "@@ -21,14 +21,70 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                      -> BlockAnd<()> {\n         let Block { extent, span, stmts, expr } = self.hir.mirror(ast_block);\n         self.in_scope(extent, block, move |this| {\n-            unpack!(block = this.stmts(block, stmts));\n-            match expr {\n-                Some(expr) => this.into(destination, block, expr),\n-                None => {\n-                    this.cfg.push_assign_unit(block, span, destination);\n-                    block.unit()\n+            // This convoluted structure is to avoid using recursion as we walk down a list\n+            // of statements. Basically, the structure we get back is something like:\n+            //\n+            //    let x = <init> in {\n+            //       expr1;\n+            //       let y = <init> in {\n+            //           expr2;\n+            //           expr3;\n+            //           ...\n+            //       }\n+            //    }\n+            //\n+            // The let bindings are valid till the end of block so all we have to do is to pop all\n+            // the let-scopes at the end.\n+            //\n+            // First we build all the statements in the block.\n+            let mut let_extent_stack = Vec::with_capacity(8);\n+            for stmt in stmts {\n+                let Stmt { span: _, kind } = this.hir.mirror(stmt);\n+                match kind {\n+                    StmtKind::Expr { scope, expr } => {\n+                        unpack!(block = this.in_scope(scope, block, |this| {\n+                            let expr = this.hir.mirror(expr);\n+                            let temp = this.temp(expr.ty.clone());\n+                            unpack!(block = this.into(&temp, block, expr));\n+                            unpack!(block = this.build_drop(block, temp));\n+                            block.unit()\n+                        }));\n+                    }\n+                    StmtKind::Let { remainder_scope, init_scope, pattern, initializer } => {\n+                        this.push_scope(remainder_scope);\n+                        let_extent_stack.push(remainder_scope);\n+                        unpack!(block = this.in_scope(init_scope, block, move |this| {\n+                            // FIXME #30046                              ^~~~\n+                            match initializer {\n+                                Some(initializer) => {\n+                                    this.expr_into_pattern(block,\n+                                                           remainder_scope,\n+                                                           pattern,\n+                                                           initializer)\n+                                }\n+                                None => {\n+                                    this.declare_bindings(remainder_scope, &pattern);\n+                                    block.unit()\n+                                }\n+                            }\n+                        }));\n+                    }\n                 }\n             }\n+            // Then, the block may have an optional trailing expression which is a \u201creturn\u201d value\n+            // of the block.\n+            if let Some(expr) = expr {\n+                unpack!(block = this.into(destination, block, expr));\n+            } else {\n+                // FIXME(#31472)\n+                this.cfg.push_assign_unit(block, span, destination);\n+            }\n+            // Finally, we pop all the let scopes before exiting out from the scope of block\n+            // itself.\n+            for extent in let_extent_stack.into_iter().rev() {\n+                unpack!(block = this.pop_scope(extent, block));\n+            }\n+            block.unit()\n         })\n     }\n }"}, {"sha": "5d9f827984e0e116e45a1039d2fd653412f6c3a6", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/77be4ecc1795787eab4b51b9def35096546122ec/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77be4ecc1795787eab4b51b9def35096546122ec/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=77be4ecc1795787eab4b51b9def35096546122ec", "patch": "@@ -185,4 +185,3 @@ mod into;\n mod matches;\n mod misc;\n mod scope;\n-mod stmt;"}, {"sha": "a738663bf8cc50a8e9f0678eb79b42b54a28877b", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/77be4ecc1795787eab4b51b9def35096546122ec/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77be4ecc1795787eab4b51b9def35096546122ec/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=77be4ecc1795787eab4b51b9def35096546122ec", "patch": "@@ -249,6 +249,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                       extent: CodeExtent,\n                       mut block: BasicBlock,\n                       target: BasicBlock) {\n+        debug!(\"exit_scope(extent={:?}, block={:?}, target={:?})\", extent, block, target);\n         let scope_count = 1 + self.scopes.iter().rev().position(|scope| scope.extent == extent)\n                                                       .unwrap_or_else(||{\n             self.hir.span_bug(span, &format!(\"extent {:?} does not enclose\", extent))"}, {"sha": "6c0f1c7081be8f44c47a7cd3da41483bb11df4d6", "filename": "src/librustc_mir/build/stmt.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/fbd817115525b8f11ffe0a301e17341684771369/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd817115525b8f11ffe0a301e17341684771369/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs?ref=fbd817115525b8f11ffe0a301e17341684771369", "patch": "@@ -1,83 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use build::{BlockAnd, BlockAndExtension, Builder};\n-use hair::*;\n-use rustc::mir::repr::*;\n-\n-impl<'a,'tcx> Builder<'a,'tcx> {\n-    pub fn stmts(&mut self, mut block: BasicBlock, stmts: Vec<StmtRef<'tcx>>) -> BlockAnd<()> {\n-        // This convoluted structure is to avoid using recursion as we walk down a list\n-        // of statements. Basically, the structure we get back is something like:\n-        //\n-        //    let x = <init> in {\n-        //       let y = <init> in {\n-        //           expr1;\n-        //           expr2;\n-        //       }\n-        //    }\n-        //\n-        // To process this, we keep a stack of (Option<CodeExtent>,\n-        // vec::IntoIter<Stmt>) pairs.  At each point we pull off the\n-        // top most pair and extract one statement from the\n-        // iterator. Once it's complete, we pop the scope from the\n-        // first half the pair.\n-        let this = self;\n-        let mut stmt_lists = vec![(None, stmts.into_iter())];\n-        while !stmt_lists.is_empty() {\n-            let stmt = {\n-                let &mut (_, ref mut stmts) = stmt_lists.last_mut().unwrap();\n-                stmts.next()\n-            };\n-\n-            let stmt = match stmt {\n-                Some(stmt) => stmt,\n-                None => {\n-                    let (extent, _) = stmt_lists.pop().unwrap();\n-                    if let Some(extent) = extent {\n-                        unpack!(block = this.pop_scope(extent, block));\n-                    }\n-                    continue\n-                }\n-            };\n-\n-            let Stmt { span: _, kind } = this.hir.mirror(stmt);\n-            match kind {\n-                StmtKind::Let { remainder_scope, init_scope, pattern, initializer, stmts } => {\n-                    this.push_scope(remainder_scope);\n-                    stmt_lists.push((Some(remainder_scope), stmts.into_iter()));\n-                    unpack!(block = this.in_scope(init_scope, block, move |this| {\n-                        // FIXME #30046                              ^~~~\n-                        match initializer {\n-                            Some(initializer) => {\n-                                this.expr_into_pattern(block, remainder_scope, pattern, initializer)\n-                            }\n-                            None => {\n-                                this.declare_bindings(remainder_scope, &pattern);\n-                                block.unit()\n-                            }\n-                        }\n-                    }));\n-                }\n-\n-                StmtKind::Expr { scope, expr } => {\n-                    unpack!(block = this.in_scope(scope, block, |this| {\n-                        let expr = this.hir.mirror(expr);\n-                        let temp = this.temp(expr.ty.clone());\n-                        unpack!(block = this.into(&temp, block, expr));\n-                        unpack!(block = this.build_drop(block, temp));\n-                        block.unit()\n-                    }));\n-                }\n-            }\n-        }\n-        block.unit()\n-    }\n-}"}, {"sha": "66cb1f56b916bb24449fa6723fe353922cbbafb9", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/77be4ecc1795787eab4b51b9def35096546122ec/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77be4ecc1795787eab4b51b9def35096546122ec/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=77be4ecc1795787eab4b51b9def35096546122ec", "patch": "@@ -26,7 +26,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n             extent: cx.tcx.region_maps.node_extent(self.id),\n             span: self.span,\n             stmts: stmts,\n-            expr: self.expr.to_ref(),\n+            expr: self.expr.to_ref()\n         }\n     }\n }\n@@ -41,13 +41,13 @@ fn mirror_stmts<'a,'tcx:'a,STMTS>(cx: &mut Cx<'a,'tcx>,\n     while let Some((index, stmt)) = stmts.next() {\n         match stmt.node {\n             hir::StmtExpr(ref expr, id) | hir::StmtSemi(ref expr, id) =>\n-                result.push(\n-                    StmtRef::Mirror(\n-                        Box::new(Stmt { span: stmt.span,\n-                                        kind: StmtKind::Expr {\n-                                            scope: cx.tcx.region_maps.node_extent(id),\n-                                            expr: expr.to_ref() } }))),\n-\n+                result.push(StmtRef::Mirror(Box::new(Stmt {\n+                    span: stmt.span,\n+                    kind: StmtKind::Expr {\n+                        scope: cx.tcx.region_maps.node_extent(id),\n+                        expr: expr.to_ref()\n+                    }\n+                }))),\n             hir::StmtDecl(ref decl, id) => {\n                 match decl.node {\n                     hir::DeclItem(..) => { /* ignore for purposes of the MIR */ }\n@@ -59,10 +59,6 @@ fn mirror_stmts<'a,'tcx:'a,STMTS>(cx: &mut Cx<'a,'tcx>,\n                         let remainder_extent =\n                             cx.tcx.region_maps.lookup_code_extent(remainder_extent);\n \n-                        // pull in all following statements, since\n-                        // they are within the scope of this let:\n-                        let following_stmts = mirror_stmts(cx, block_id, stmts);\n-\n                         let pattern = cx.irrefutable_pat(&local.pat);\n                         result.push(StmtRef::Mirror(Box::new(Stmt {\n                             span: stmt.span,\n@@ -71,11 +67,8 @@ fn mirror_stmts<'a,'tcx:'a,STMTS>(cx: &mut Cx<'a,'tcx>,\n                                 init_scope: cx.tcx.region_maps.node_extent(id),\n                                 pattern: pattern,\n                                 initializer: local.init.to_ref(),\n-                                stmts: following_stmts,\n                             },\n                         })));\n-\n-                        return result;\n                     }\n                 }\n             }"}, {"sha": "707dd972003ff465859c9ac24d4961162918e3d5", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/77be4ecc1795787eab4b51b9def35096546122ec/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77be4ecc1795787eab4b51b9def35096546122ec/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=77be4ecc1795787eab4b51b9def35096546122ec", "patch": "@@ -78,10 +78,7 @@ pub enum StmtKind<'tcx> {\n         pattern: Pattern<'tcx>,\n \n         /// let pat = <INIT> ...\n-        initializer: Option<ExprRef<'tcx>>,\n-\n-        /// let pat = init; <STMTS>\n-        stmts: Vec<StmtRef<'tcx>>,\n+        initializer: Option<ExprRef<'tcx>>\n     },\n }\n "}]}