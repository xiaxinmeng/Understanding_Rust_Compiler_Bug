{"sha": "70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwZWQzYTQ4ZGZhMzAxYzViYjU2ZGUzZTBhN2MyNTIxNDUzOWI4M2M=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-27T20:20:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-01T19:08:15Z"}, "message": "std: Add a new `env` module\n\nThis is an implementation of [RFC 578][rfc] which adds a new `std::env` module\nto replace most of the functionality in the current `std::os` module. More\ndetails can be found in the RFC itself, but as a summary the following methods\nhave all been deprecated:\n\n[rfc]: https://github.com/rust-lang/rfcs/pull/578\n\n* `os::args_as_bytes`   => `env::args`\n* `os::args`            => `env::args`\n* `os::consts`          => `env::consts`\n* `os::dll_filename`    => no replacement, use `env::consts` directly\n* `os::page_size`       => `env::page_size`\n* `os::make_absolute`   => use `env::current_dir` + `join` instead\n* `os::getcwd`          => `env::current_dir`\n* `os::change_dir`      => `env::set_current_dir`\n* `os::homedir`         => `env::home_dir`\n* `os::tmpdir`          => `env::temp_dir`\n* `os::join_paths`      => `env::join_paths`\n* `os::split_paths`     => `env::split_paths`\n* `os::self_exe_name`   => `env::current_exe`\n* `os::self_exe_path`   => use `env::current_exe` + `pop`\n* `os::set_exit_status` => `env::set_exit_status`\n* `os::get_exit_status` => `env::get_exit_status`\n* `os::env`             => `env::vars`\n* `os::env_as_bytes`    => `env::vars`\n* `os::getenv`          => `env::var` or `env::var_string`\n* `os::getenv_as_bytes` => `env::var`\n* `os::setenv`          => `env::set_var`\n* `os::unsetenv`        => `env::remove_var`\n\nMany function signatures have also been tweaked for various purposes, but the\nmain changes were:\n\n* `Vec`-returning APIs now all return iterators instead\n* All APIs are now centered around `OsString` instead of `Vec<u8>` or `String`.\n  There is currently on convenience API, `env::var_string`, which can be used to\n  get the value of an environment variable as a unicode `String`.\n\nAll old APIs are `#[deprecated]` in-place and will remain for some time to allow\nfor migrations. The semantics of the APIs have been tweaked slightly with regard\nto dealing with invalid unicode (panic instead of replacement).\n\nThe new `std::env` module is all contained within the `env` feature, so crates\nmust add the following to access the new APIs:\n\n    #![feature(env)]\n\n[breaking-change]", "tree": {"sha": "c05dbc24078626ff2a2aa6de769343756528df30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c05dbc24078626ff2a2aa6de769343756528df30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "html_url": "https://github.com/rust-lang/rust/commit/70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1398d2736f132dd4af828b3d9134691f924b7e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1398d2736f132dd4af828b3d9134691f924b7e1", "html_url": "https://github.com/rust-lang/rust/commit/f1398d2736f132dd4af828b3d9134691f924b7e1"}], "stats": {"total": 2957, "additions": 2175, "deletions": 782}, "files": [{"sha": "7c0ee7be8a4449c8e430e5cb47c12cdd2f98199a", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -22,6 +22,7 @@\n #![feature(std_misc)]\n #![feature(test)]\n #![feature(unicode)]\n+#![feature(env)]\n \n #![deny(warnings)]\n \n@@ -31,7 +32,7 @@ extern crate getopts;\n #[macro_use]\n extern crate log;\n \n-use std::os;\n+use std::env;\n use std::old_io;\n use std::old_io::fs;\n use std::thunk::Thunk;\n@@ -48,7 +49,7 @@ pub mod common;\n pub mod errors;\n \n pub fn main() {\n-    let args = os::args();\n+    let args = env::args().map(|s| s.into_string().unwrap()).collect();;\n     let config = parse_config(args);\n \n     if config.valgrind_path.is_none() && config.force_valgrind {\n@@ -224,15 +225,15 @@ pub fn run_tests(config: &Config) {\n         //arm-linux-androideabi debug-info test uses remote debugger\n         //so, we test 1 task at once.\n         // also trying to isolate problems with adb_run_wrapper.sh ilooping\n-        os::setenv(\"RUST_TEST_TASKS\",\"1\");\n+        env::set_var(\"RUST_TEST_TASKS\",\"1\");\n     }\n \n     match config.mode {\n         DebugInfoLldb => {\n             // Some older versions of LLDB seem to have problems with multiple\n             // instances running in parallel, so only run one test task at a\n             // time.\n-            os::setenv(\"RUST_TEST_TASKS\", \"1\");\n+            env::set_var(\"RUST_TEST_TASKS\", \"1\");\n         }\n         _ => { /* proceed */ }\n     }\n@@ -245,7 +246,7 @@ pub fn run_tests(config: &Config) {\n     old_io::test::raise_fd_limit();\n     // Prevent issue #21352 UAC blocking .exe containing 'patch' etc. on Windows\n     // If #11207 is resolved (adding manifest to .exe) this becomes unnecessary\n-    os::setenv(\"__COMPAT_LAYER\", \"RunAsInvoker\");\n+    env::set_var(\"__COMPAT_LAYER\", \"RunAsInvoker\");\n     let res = test::run_tests_console(&opts, tests.into_iter().collect());\n     match res {\n         Ok(true) => {}"}, {"sha": "5b0ea3b4854edec05c4f7a875cde23e67603ab6e", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -31,7 +31,7 @@ use std::old_io::process::ProcessExit;\n use std::old_io::process;\n use std::old_io::timer;\n use std::old_io;\n-use std::os;\n+use std::env;\n use std::iter::repeat;\n use std::str;\n use std::string::String;\n@@ -1298,9 +1298,9 @@ fn make_lib_name(config: &Config, auxfile: &Path, testfile: &Path) -> Path {\n \n fn make_exe_name(config: &Config, testfile: &Path) -> Path {\n     let mut f = output_base_name(config, testfile);\n-    if !os::consts::EXE_SUFFIX.is_empty() {\n+    if !env::consts::EXE_SUFFIX.is_empty() {\n         let mut fname = f.filename().unwrap().to_vec();\n-        fname.extend(os::consts::EXE_SUFFIX.bytes());\n+        fname.extend(env::consts::EXE_SUFFIX.bytes());\n         f.set_filename(fname);\n     }\n     f"}, {"sha": "defda27acc9ec663adc816983504002be17c7f55", "filename": "src/etc/make-win-dist.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Fetc%2Fmake-win-dist.py", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Fetc%2Fmake-win-dist.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmake-win-dist.py?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -87,6 +87,7 @@ def make_win_dist(rust_root, gcc_root, target_triple):\n                     \"libsetupapi.a\",\n                     \"libshell32.a\",\n                     \"libuser32.a\",\n+                    \"libuserenv.a\",\n                     \"libuuid.a\",\n                     \"libwinhttp.a\",\n                     \"libwinmm.a\","}, {"sha": "34216518c21d2073bb61909101eae42b6c089c69", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -173,15 +173,15 @@\n #![feature(int_uint)]\n #![feature(core)]\n #![feature(io)]\n-#![feature(os)]\n #![feature(std_misc)]\n+#![feature(env)]\n \n use std::cell::RefCell;\n use std::fmt;\n use std::old_io::LineBufferedWriter;\n use std::old_io;\n use std::mem;\n-use std::os;\n+use std::env;\n use std::ptr;\n use std::rt;\n use std::slice;\n@@ -397,9 +397,9 @@ fn enabled(level: u32,\n /// This is not threadsafe at all, so initialization is performed through a\n /// `Once` primitive (and this function is called from that primitive).\n fn init() {\n-    let (mut directives, filter) = match os::getenv(\"RUST_LOG\") {\n-        Some(spec) => directive::parse_logging_spec(&spec[]),\n-        None => (Vec::new(), None),\n+    let (mut directives, filter) = match env::var_string(\"RUST_LOG\") {\n+        Ok(spec) => directive::parse_logging_spec(&spec[]),\n+        Err(..) => (Vec::new(), None),\n     };\n \n     // Sort the provided directives by length of their name, this allows a"}, {"sha": "2f31a2c083f7fbdd790b360f8ab25a9d8761849b", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -32,7 +32,7 @@\n #![feature(int_uint)]\n #![feature(io)]\n #![feature(libc)]\n-#![feature(os)]\n+#![feature(env)]\n #![feature(path)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "45dd4b4dbacbdb6419a9f3655d7f963bdd89d7c8", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -13,9 +13,9 @@\n pub use self::FileMatch::*;\n \n use std::collections::HashSet;\n+use std::env;\n use std::old_io::fs::PathExtensions;\n use std::old_io::fs;\n-use std::os;\n \n use util::fs as myfs;\n use session::search_paths::{SearchPaths, PathKind};\n@@ -194,7 +194,7 @@ pub fn get_or_default_sysroot() -> Path {\n             })\n     }\n \n-    match canonicalize(os::self_exe_name()) {\n+    match canonicalize(env::current_exe().ok()) {\n         Some(mut p) => { p.pop(); p.pop(); p }\n         None => panic!(\"can't determine value for sysroot\")\n     }\n@@ -207,7 +207,7 @@ static PATH_ENTRY_SEPARATOR: &'static str = \":\";\n \n /// Returns RUST_PATH as a string, without default paths added\n pub fn get_rust_path() -> Option<String> {\n-    os::getenv(\"RUST_PATH\").map(|x| x.to_string())\n+    env::var_string(\"RUST_PATH\").ok()\n }\n \n /// Returns the value of RUST_PATH, as a list\n@@ -224,7 +224,7 @@ pub fn rust_path() -> Vec<Path> {\n         }\n         None => Vec::new()\n     };\n-    let mut cwd = os::getcwd().unwrap();\n+    let mut cwd = env::current_dir().unwrap();\n     // now add in default entries\n     let cwd_dot_rust = cwd.join(\".rust\");\n     if !env_rust_path.contains(&cwd_dot_rust) {\n@@ -243,7 +243,7 @@ pub fn rust_path() -> Vec<Path> {\n         }\n         cwd.pop();\n     }\n-    let h = os::homedir();\n+    let h = env::home_dir();\n     for h in h.iter() {\n         let p = h.join(\".rust\");\n         if !env_rust_path.contains(&p) && p.exists() {"}, {"sha": "87ea5436dab6b545662d33faec5b9a0fed89ed7a", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -27,7 +27,7 @@ use util::ppaux::Repr;\n \n use std::collections::hash_map::Entry::Vacant;\n use std::old_io::{self, File};\n-use std::os;\n+use std::env;\n use std::sync::atomic::{AtomicBool, Ordering, ATOMIC_BOOL_INIT};\n use syntax::ast;\n \n@@ -59,13 +59,13 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n     }\n \n     let requested_node : Option<ast::NodeId> =\n-        os::getenv(\"RUST_REGION_GRAPH_NODE\").and_then(|s| s.parse().ok());\n+        env::var_string(\"RUST_REGION_GRAPH_NODE\").ok().and_then(|s| s.parse().ok());\n \n     if requested_node.is_some() && requested_node != Some(subject_node) {\n         return;\n     }\n \n-    let requested_output = os::getenv(\"RUST_REGION_GRAPH\");\n+    let requested_output = env::var_string(\"RUST_REGION_GRAPH\").ok();\n     debug!(\"requested_output: {:?} requested_node: {:?}\",\n            requested_output, requested_node);\n "}, {"sha": "c04bf755b1f6b76a0b4343371e5b28fff58494ac", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -15,7 +15,7 @@ use metadata::creader::{CrateOrString, CrateReader};\n use plugin::registry::Registry;\n \n use std::mem;\n-use std::os;\n+use std::env;\n use std::dynamic_lib::DynamicLibrary;\n use std::collections::HashSet;\n use syntax::ast;\n@@ -233,7 +233,7 @@ impl<'a> PluginLoader<'a> {\n                         path: Path,\n                         symbol: String) -> PluginRegistrarFun {\n         // Make sure the path contains a / or the linker will search for it.\n-        let path = os::make_absolute(&path).unwrap();\n+        let path = env::current_dir().unwrap().join(&path);\n \n         let lib = match DynamicLibrary::open(Some(&path)) {\n             Ok(lib) => lib,"}, {"sha": "a983f995d3f64a79783dd7b4086c80942bf6026a", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -27,7 +27,7 @@ use syntax::{ast, codemap};\n \n use rustc_back::target::Target;\n \n-use std::os;\n+use std::env;\n use std::cell::{Cell, RefCell};\n \n pub mod config;\n@@ -347,7 +347,7 @@ pub fn build_session_(sopts: config::Options,\n         if path.is_absolute() {\n             path.clone()\n         } else {\n-            os::getcwd().unwrap().join(&path)\n+            env::current_dir().unwrap().join(&path)\n         }\n     );\n \n@@ -370,7 +370,7 @@ pub fn build_session_(sopts: config::Options,\n         plugin_registrar_fn: Cell::new(None),\n         default_sysroot: default_sysroot,\n         local_crate_source_file: local_crate_source_file,\n-        working_dir: os::getcwd().unwrap(),\n+        working_dir: env::current_dir().unwrap(),\n         lint_store: RefCell::new(lint::LintStore::new()),\n         lints: RefCell::new(NodeMap()),\n         crate_types: RefCell::new(Vec::new()),"}, {"sha": "f5483e666cfd4663f93a21117964cc6baf4aeff6", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -14,7 +14,7 @@ use std::old_io::fs::PathExtensions;\n use std::old_io::process::{Command, ProcessOutput};\n use std::old_io::{fs, TempDir};\n use std::old_io;\n-use std::os;\n+use std::env;\n use std::str;\n use syntax::diagnostic::Handler as ErrorHandler;\n \n@@ -224,7 +224,7 @@ impl<'a> ArchiveBuilder<'a> {\n     pub fn build(self) -> Archive<'a> {\n         // Get an absolute path to the destination, so `ar` will work even\n         // though we run it from `self.work_dir`.\n-        let abs_dst = os::getcwd().unwrap().join(&self.archive.dst);\n+        let abs_dst = env::current_dir().unwrap().join(&self.archive.dst);\n         assert!(!abs_dst.is_relative());\n         let mut args = vec![&abs_dst];\n         let mut total_len = abs_dst.as_vec().len();\n@@ -283,7 +283,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // First, extract the contents of the archive to a temporary directory.\n         // We don't unpack directly into `self.work_dir` due to the possibility\n         // of filename collisions.\n-        let archive = os::make_absolute(archive).unwrap();\n+        let archive = env::current_dir().unwrap().join(archive);\n         run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n                \"x\", Some(loc.path()), &[&archive]);\n "}, {"sha": "acf49d1ca46e3b6d7a3c55cc44a607d48aea0681", "filename": "src/librustc_back/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -10,13 +10,13 @@\n \n use std::old_io;\n use std::old_io::fs;\n-use std::os;\n+use std::env;\n \n /// Returns an absolute path in the filesystem that `path` points to. The\n /// returned path does not contain any symlinks in its hierarchy.\n pub fn realpath(original: &Path) -> old_io::IoResult<Path> {\n     static MAX_LINKS_FOLLOWED: uint = 256;\n-    let original = os::make_absolute(original).unwrap();\n+    let original = try!(env::current_dir()).join(original);\n \n     // Right now lstat on windows doesn't work quite well\n     if cfg!(windows) {"}, {"sha": "54b3e8f208125e8253ddc528957bd0d774a84684", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -40,6 +40,7 @@\n #![feature(path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n+#![feature(env)]\n \n extern crate syntax;\n extern crate serialize;"}, {"sha": "b6a34b4beba717e0ca79e4fa0f8345044c462820", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -10,7 +10,7 @@\n \n \n use std::collections::HashSet;\n-use std::os;\n+use std::env;\n use std::old_io::IoError;\n use syntax::ast;\n \n@@ -105,18 +105,17 @@ fn get_rpath_relative_to_output<F, G>(config: &mut RPathConfig<F, G>, lib: &Path\n     F: FnOnce() -> Path,\n     G: FnMut(&Path) -> Result<Path, IoError>,\n {\n-    use std::os;\n-\n     // Mac doesn't appear to support $ORIGIN\n     let prefix = if config.is_like_osx {\n         \"@loader_path\"\n     } else {\n         \"$ORIGIN\"\n     };\n \n-    let mut lib = (config.realpath)(&os::make_absolute(lib).unwrap()).unwrap();\n+    let cwd = env::current_dir().unwrap();\n+    let mut lib = (config.realpath)(&cwd.join(lib)).unwrap();\n     lib.pop();\n-    let mut output = (config.realpath)(&os::make_absolute(&config.out_filename).unwrap()).unwrap();\n+    let mut output = (config.realpath)(&cwd.join(&config.out_filename)).unwrap();\n     output.pop();\n     let relative = lib.path_relative_from(&output);\n     let relative = relative.expect(\"could not create rpath relative to output\");\n@@ -131,7 +130,7 @@ fn get_install_prefix_rpath<F, G>(config: RPathConfig<F, G>) -> String where\n     G: FnMut(&Path) -> Result<Path, IoError>,\n {\n     let path = (config.get_install_prefix_lib_path)();\n-    let path = os::make_absolute(&path).unwrap();\n+    let path = env::current_dir().unwrap().join(&path);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     path.as_str().expect(\"non-utf8 component in rpath\").to_string()\n }"}, {"sha": "eb7c23f95e2e1998cfc6c5e8350fa51f43e2ee3d", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -301,7 +301,8 @@ impl Target {\n     /// The error string could come from any of the APIs called, including filesystem access and\n     /// JSON decoding.\n     pub fn search(target: &str) -> Result<Target, String> {\n-        use std::os;\n+        use std::env;\n+        use std::ffi::OsString;\n         use std::old_io::File;\n         use std::path::Path;\n         use serialize::json;\n@@ -379,12 +380,12 @@ impl Target {\n             Path::new(target)\n         };\n \n-        let target_path = os::getenv(\"RUST_TARGET_PATH\").unwrap_or(String::new());\n+        let target_path = env::var(\"RUST_TARGET_PATH\")\n+                              .unwrap_or(OsString::from_str(\"\"));\n \n-        let paths = os::split_paths(&target_path[]);\n         // FIXME 16351: add a sane default search path?\n \n-        for dir in paths.iter() {\n+        for dir in env::split_paths(&target_path) {\n             let p =  dir.join(path.clone());\n             if p.is_file() {\n                 return load_file(&p);"}, {"sha": "4aa4193d51134c263eb9d96d9e7b1845646c064f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -30,9 +30,10 @@ use rustc_privacy;\n \n use serialize::json;\n \n-use std::old_io;\n+use std::env;\n+use std::ffi::OsString;\n use std::old_io::fs;\n-use std::os;\n+use std::old_io;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::attr;\n@@ -460,12 +461,12 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             // dependent dlls. Note that this uses cfg!(windows) as opposed to\n             // targ_cfg because syntax extensions are always loaded for the host\n             // compiler, not for the target.\n-            let mut _old_path = String::new();\n+            let mut _old_path = OsString::from_str(\"\");\n             if cfg!(windows) {\n-                _old_path = os::getenv(\"PATH\").unwrap_or(_old_path);\n+                _old_path = env::var(\"PATH\").unwrap_or(_old_path);\n                 let mut new_path = sess.host_filesearch(PathKind::All).get_dylib_search_paths();\n-                new_path.extend(os::split_paths(&_old_path[]).into_iter());\n-                os::setenv(\"PATH\", os::join_paths(&new_path[]).unwrap());\n+                new_path.extend(env::split_paths(&_old_path));\n+                env::set_var(\"PATH\", &env::join_paths(new_path.iter()).unwrap());\n             }\n             let cfg = syntax::ext::expand::ExpansionConfig {\n                 crate_name: crate_name.to_string(),\n@@ -478,7 +479,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                                               syntax_exts,\n                                               krate);\n             if cfg!(windows) {\n-                os::setenv(\"PATH\", _old_path);\n+                env::set_var(\"PATH\", &_old_path);\n             }\n             ret\n         }\n@@ -734,18 +735,18 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n pub fn phase_6_link_output(sess: &Session,\n                            trans: &trans::CrateTranslation,\n                            outputs: &OutputFilenames) {\n-    let old_path = os::getenv(\"PATH\").unwrap_or_else(||String::new());\n+    let old_path = env::var(\"PATH\").unwrap_or(OsString::from_str(\"\"));\n     let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths();\n-    new_path.extend(os::split_paths(&old_path[]).into_iter());\n-    os::setenv(\"PATH\", os::join_paths(&new_path[]).unwrap());\n+    new_path.extend(env::split_paths(&old_path));\n+    env::set_var(\"PATH\", &env::join_paths(new_path.iter()).unwrap());\n \n     time(sess.time_passes(), \"linking\", (), |_|\n          link::link_binary(sess,\n                            trans,\n                            outputs,\n                            &trans.link.crate_name[]));\n \n-    os::setenv(\"PATH\", old_path);\n+    env::set_var(\"PATH\", &old_path);\n }\n \n fn escape_dep_filename(filename: &str) -> String {"}, {"sha": "6230f0b14a23b8672c59fa0d560b1dd7d6d62e33", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -26,6 +26,7 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(env)]\n #![feature(int_uint)]\n #![feature(io)]\n #![feature(libc)]\n@@ -74,7 +75,7 @@ use rustc::util::common::time;\n use std::cmp::Ordering::Equal;\n use std::old_io;\n use std::iter::repeat;\n-use std::os;\n+use std::env;\n use std::sync::mpsc::channel;\n use std::thread;\n \n@@ -252,7 +253,7 @@ pub fn get_unstable_features_setting() -> UnstableFeatures {\n     // subverting the unstable features lints\n     let bootstrap_secret_key = option_env!(\"CFG_BOOTSTRAP_KEY\");\n     // The matching key to the above, only known by the build system\n-    let bootstrap_provided_key = os::getenv(\"RUSTC_BOOTSTRAP_KEY\");\n+    let bootstrap_provided_key = env::var_string(\"RUSTC_BOOTSTRAP_KEY\").ok();\n     match (disable_unstable_features, bootstrap_secret_key, bootstrap_provided_key) {\n         (_, Some(ref s), Some(ref p)) if s == p => UnstableFeatures::Cheat,\n         (true, _, _) => UnstableFeatures::Disallow,\n@@ -618,7 +619,7 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n \n     // FIXME: Hacks on hacks. If the env is trying to override the stack size\n     // then *don't* set it explicitly.\n-    if os::getenv(\"RUST_MIN_STACK\").is_none() {\n+    if env::var(\"RUST_MIN_STACK\").is_none() {\n         cfg = cfg.stack_size(STACK_SIZE);\n     }\n \n@@ -682,8 +683,8 @@ pub fn diagnostics_registry() -> diagnostics::registry::Registry {\n }\n \n pub fn main() {\n-    let args = std::os::args();\n-    let result = run(args);\n-    std::os::set_exit_status(result);\n+    let args = env::args().map(|s| s.into_string().unwrap());\n+    let result = run(args.collect());\n+    std::env::set_exit_status(result as i32);\n }\n "}, {"sha": "11ffade6da6c6ef9aac596d92ee200ac09ca7bca", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -32,8 +32,8 @@\n #![feature(hash)]\n #![feature(int_uint)]\n #![feature(io)]\n+#![feature(env)]\n #![feature(libc)]\n-#![feature(os)]\n #![feature(path)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "f429ab7599fef676aec2ec3880bb621bce276f96", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -34,7 +34,7 @@ use middle::ty::{self, Ty};\n \n use std::cell::Cell;\n use std::old_io::{self, File, fs};\n-use std::os;\n+use std::env;\n \n use syntax::ast_util::{self, PostExpansionMethod};\n use syntax::ast::{self, NodeId, DefId};\n@@ -1551,9 +1551,9 @@ pub fn process_crate(sess: &Session,\n     info!(\"Dumping crate {}\", cratename);\n \n     // find a path to dump our data to\n-    let mut root_path = match os::getenv(\"DXR_RUST_TEMP_FOLDER\") {\n-        Some(val) => Path::new(val),\n-        None => match odir {\n+    let mut root_path = match env::var_string(\"DXR_RUST_TEMP_FOLDER\") {\n+        Ok(val) => Path::new(val),\n+        Err(..) => match odir {\n             Some(val) => val.join(\"dxr\"),\n             None => Path::new(\"dxr-temp\"),\n         },"}, {"sha": "c9b50bdd3c1d201025bbf4fe842cd7440e6e1ed0", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -21,6 +21,7 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(env)]\n #![feature(hash)]\n #![feature(int_uint)]\n #![feature(io)]\n@@ -50,6 +51,7 @@ extern crate \"serialize\" as rustc_serialize; // used by deriving\n \n use std::cell::RefCell;\n use std::collections::HashMap;\n+use std::env;\n use std::old_io::File;\n use std::old_io;\n use std::rc::Rc;\n@@ -121,9 +123,10 @@ struct Output {\n pub fn main() {\n     static STACK_SIZE: uint = 32000000; // 32MB\n     let res = std::thread::Builder::new().stack_size(STACK_SIZE).scoped(move || {\n-        main_args(std::os::args().as_slice())\n+        let s = env::args().map(|s| s.into_string().unwrap());\n+        main_args(&s.collect::<Vec<_>>())\n     }).join();\n-    std::os::set_exit_status(res.ok().unwrap());\n+    env::set_exit_status(res.ok().unwrap() as i32);\n }\n \n pub fn opts() -> Vec<getopts::OptGroup> {"}, {"sha": "29abea009e547f2580a9b2a9e76d804ac06c9e33", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -13,7 +13,7 @@ use std::sync::mpsc::channel;\n use std::dynamic_lib::DynamicLibrary;\n use std::old_io::{Command, TempDir};\n use std::old_io;\n-use std::os;\n+use std::env;\n use std::str;\n use std::thread::Thread;\n use std::thunk::Thunk;\n@@ -49,7 +49,7 @@ pub fn run(input: &str,\n     let input = config::Input::File(input_path.clone());\n \n     let sessopts = config::Options {\n-        maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n+        maybe_sysroot: Some(env::current_exe().unwrap().dir_path().dir_path()),\n         search_paths: libs.clone(),\n         crate_types: vec!(config::CrateTypeDylib),\n         externs: externs.clone(),\n@@ -119,7 +119,7 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     let input = config::Input::Str(test.to_string());\n \n     let sessopts = config::Options {\n-        maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n+        maybe_sysroot: Some(env::current_exe().unwrap().dir_path().dir_path()),\n         search_paths: libs,\n         crate_types: vec!(config::CrateTypeExecutable),\n         output_types: vec!(config::OutputTypeExe),"}, {"sha": "46567aedbec4ebebd5bd09f1da3e2b0564dab740", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -19,7 +19,7 @@ use prelude::v1::*;\n \n use ffi::CString;\n use mem;\n-use os;\n+use env;\n use str;\n \n #[allow(missing_copy_implementations)]\n@@ -68,8 +68,8 @@ impl DynamicLibrary {\n         let mut search_path = DynamicLibrary::search_path();\n         search_path.insert(0, path.clone());\n         let newval = DynamicLibrary::create_path(search_path.as_slice());\n-        os::setenv(DynamicLibrary::envvar(),\n-                   str::from_utf8(newval.as_slice()).unwrap());\n+        env::set_var(DynamicLibrary::envvar(),\n+                     str::from_utf8(newval.as_slice()).unwrap());\n     }\n \n     /// From a slice of paths, create a new vector which is suitable to be an\n@@ -102,18 +102,10 @@ impl DynamicLibrary {\n     /// Returns the current search path for dynamic libraries being used by this\n     /// process\n     pub fn search_path() -> Vec<Path> {\n-        let mut ret = Vec::new();\n-        match os::getenv_as_bytes(DynamicLibrary::envvar()) {\n-            Some(env) => {\n-                for portion in\n-                        env.as_slice()\n-                           .split(|a| *a == DynamicLibrary::separator()) {\n-                    ret.push(Path::new(portion));\n-                }\n-            }\n-            None => {}\n+        match env::var(DynamicLibrary::envvar()) {\n+            Some(var) => env::split_paths(&var).collect(),\n+            None => Vec::new(),\n         }\n-        return ret;\n     }\n \n     /// Access the value at the symbol of the dynamic library"}, {"sha": "5070f8c547ab0663501b84ce25d29b291c84c561", "filename": "src/libstd/env.rs", "status": "added", "additions": 833, "deletions": 0, "changes": 833, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -0,0 +1,833 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Inspection and manipulation of the process's environment.\n+//!\n+//! This module contains methods to inspect various aspects such as\n+//! environment varibles, process arguments, the current directory, and various\n+//! other important directories.\n+\n+#![unstable(feature = \"env\", reason = \"recently added via RFC 578\")]\n+\n+use prelude::v1::*;\n+\n+use error::Error;\n+use ffi::{OsString, AsOsStr};\n+use fmt;\n+use old_io::IoResult;\n+use sync::atomic::{AtomicIsize, ATOMIC_ISIZE_INIT, Ordering};\n+use sync::{StaticMutex, MUTEX_INIT};\n+use sys::os as os_imp;\n+\n+/// Returns the current working directory as a `Path`.\n+///\n+/// # Errors\n+///\n+/// Returns an `Err` if the current working directory value is invalid.\n+/// Possible cases:\n+///\n+/// * Current directory does not exist.\n+/// * There are insufficient permissions to access the current directory.\n+/// * The internal buffer is not large enough to hold the path.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// // We assume that we are in a valid directory.\n+/// let p = env::current_dir().unwrap();\n+/// println!(\"The current directory is {}\", p.display());\n+/// ```\n+pub fn current_dir() -> IoResult<Path> {\n+    os_imp::getcwd()\n+}\n+\n+/// Changes the current working directory to the specified path, returning\n+/// whether the change was completed successfully or not.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+/// use std::path::Path;\n+///\n+/// let root = Path::new(\"/\");\n+/// assert!(env::set_current_dir(&root).is_ok());\n+/// println!(\"Successfully changed working directory to {}!\", root.display());\n+/// ```\n+pub fn set_current_dir(p: &Path) -> IoResult<()> {\n+    os_imp::chdir(p)\n+}\n+\n+static ENV_LOCK: StaticMutex = MUTEX_INIT;\n+\n+/// An iterator over a snapshot of the environment variables of this process.\n+///\n+/// This iterator is created through `std::env::vars()` and yields `(OsString,\n+/// OsString)` pairs.\n+pub struct Vars { inner: os_imp::Env }\n+\n+/// Returns an iterator of (variable, value) pairs, for all the environment\n+/// variables of the current process.\n+///\n+/// The returned iterator contains a snapshot of the process's environment\n+/// variables at the time of this invocation, modifications to environment\n+/// variables afterwards will not be reflected in the returned iterator.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// // We will iterate through the references to the element returned by\n+/// // env::vars();\n+/// for (key, value) in env::vars() {\n+///     println!(\"{:?}: {:?}\", key, value);\n+/// }\n+/// ```\n+pub fn vars() -> Vars {\n+    let _g = ENV_LOCK.lock();\n+    Vars { inner: os_imp::env() }\n+}\n+\n+impl Iterator for Vars {\n+    type Item = (OsString, OsString);\n+    fn next(&mut self) -> Option<(OsString, OsString)> { self.inner.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+}\n+\n+/// Fetches the environment variable `key` from the current process, returning\n+/// None if the variable isn't set.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// let key = \"HOME\";\n+/// match env::var(key) {\n+///     Some(val) => println!(\"{}: {:?}\", key, val),\n+///     None => println!(\"{} is not defined in the environment.\", key)\n+/// }\n+/// ```\n+pub fn var<K: ?Sized>(key: &K) -> Option<OsString> where K: AsOsStr {\n+    let _g = ENV_LOCK.lock();\n+    os_imp::getenv(key.as_os_str())\n+}\n+\n+/// Fetches the environment variable `key` from the current process.\n+///\n+/// The returned result is `Ok(s)` if the environment variable is present and is\n+/// valid unicode. If the environment variable is not present, or it is not\n+/// valid unicode, then `Err` will be returned.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// let key = \"HOME\";\n+/// match env::var_string(key) {\n+///     Ok(val) => println!(\"{}: {:?}\", key, val),\n+///     Err(e) => println!(\"couldn't interpret {}: {}\", key, e),\n+/// }\n+/// ```\n+pub fn var_string<K: ?Sized>(key: &K) -> Result<String, VarError> where K: AsOsStr {\n+    match var(key) {\n+        Some(s) => s.into_string().map_err(VarError::NotUnicode),\n+        None => Err(VarError::NotPresent)\n+    }\n+}\n+\n+/// Possible errors from the `env::var` method.\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum VarError {\n+    /// The specified environment variable was not present in the current\n+    /// process's environment.\n+    NotPresent,\n+\n+    /// The specified environment variable was found, but it did not contain\n+    /// valid unicode data. The found data is returned as a payload of this\n+    /// variant.\n+    NotUnicode(OsString),\n+}\n+\n+impl fmt::Display for VarError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            VarError::NotPresent => write!(f, \"environment variable not found\"),\n+            VarError::NotUnicode(ref s) => {\n+                write!(f, \"environment variable was not valid unicode: {:?}\", s)\n+            }\n+        }\n+    }\n+}\n+\n+impl Error for VarError {\n+    fn description(&self) -> &str {\n+        match *self {\n+            VarError::NotPresent => \"environment variable not found\",\n+            VarError::NotUnicode(..) => \"environment variable was not valid unicode\",\n+        }\n+    }\n+}\n+\n+/// Sets the environment variable `k` to the value `v` for the currently running\n+/// process.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// let key = \"KEY\";\n+/// env::set_var(key, \"VALUE\");\n+/// assert_eq!(env::var_string(key), Ok(\"VALUE\".to_string()));\n+/// ```\n+pub fn set_var<K: ?Sized, V: ?Sized>(k: &K, v: &V)\n+    where K: AsOsStr, V: AsOsStr\n+{\n+    let _g = ENV_LOCK.lock();\n+    os_imp::setenv(k.as_os_str(), v.as_os_str())\n+}\n+\n+/// Remove a variable from the environment entirely.\n+pub fn remove_var<K: ?Sized>(k: &K) where K: AsOsStr {\n+    let _g = ENV_LOCK.lock();\n+    os_imp::unsetenv(k.as_os_str())\n+}\n+\n+/// An iterator over `Path` instances for parsing an environment variable\n+/// according to platform-specific conventions.\n+///\n+/// This structure is returned from `std::env::split_paths`.\n+pub struct SplitPaths<'a> { inner: os_imp::SplitPaths<'a> }\n+\n+/// Parses input according to platform conventions for the `PATH`\n+/// environment variable.\n+///\n+/// Returns an iterator over the paths contained in `unparsed`.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// let key = \"PATH\";\n+/// match env::var(key) {\n+///     Some(paths) => {\n+///         for path in env::split_paths(&paths) {\n+///             println!(\"'{}'\", path.display());\n+///         }\n+///     }\n+///     None => println!(\"{} is not defined in the environment.\", key)\n+/// }\n+/// ```\n+pub fn split_paths<T: AsOsStr + ?Sized>(unparsed: &T) -> SplitPaths {\n+    SplitPaths { inner: os_imp::split_paths(unparsed.as_os_str()) }\n+}\n+\n+impl<'a> Iterator for SplitPaths<'a> {\n+    type Item = Path;\n+    fn next(&mut self) -> Option<Path> { self.inner.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+}\n+\n+/// Error type returned from `std::env::join_paths` when paths fail to be\n+/// joined.\n+#[derive(Debug)]\n+pub struct JoinPathsError {\n+    inner: os_imp::JoinPathsError\n+}\n+\n+/// Joins a collection of `Path`s appropriately for the `PATH`\n+/// environment variable.\n+///\n+/// Returns an `OsString` on success.\n+///\n+/// Returns an `Err` (containing an error message) if one of the input\n+/// `Path`s contains an invalid character for constructing the `PATH`\n+/// variable (a double quote on Windows or a colon on Unix).\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// if let Some(path) = env::var(\"PATH\") {\n+///     let mut paths = env::split_paths(&path).collect::<Vec<_>>();\n+///     paths.push(Path::new(\"/home/xyz/bin\"));\n+///     let new_path = env::join_paths(paths.iter()).unwrap();\n+///     env::set_var(\"PATH\", &new_path);\n+/// }\n+/// ```\n+pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n+    where I: Iterator<Item=T>, T: AsOsStr\n+{\n+    os_imp::join_paths(paths).map_err(|e| {\n+        JoinPathsError { inner: e }\n+    })\n+}\n+\n+impl fmt::Display for JoinPathsError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.inner.fmt(f)\n+    }\n+}\n+\n+impl Error for JoinPathsError {\n+    fn description(&self) -> &str { self.inner.description() }\n+}\n+\n+/// Optionally returns the path to the current user's home directory if known.\n+///\n+/// # Unix\n+///\n+/// Returns the value of the 'HOME' environment variable if it is set\n+/// and not equal to the empty string.\n+///\n+/// # Windows\n+///\n+/// Returns the value of the 'HOME' environment variable if it is\n+/// set and not equal to the empty string. Otherwise, returns the value of the\n+/// 'USERPROFILE' environment variable if it is set and not equal to the empty\n+/// string.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// match env::home_dir() {\n+///     Some(ref p) => println!(\"{}\", p.display()),\n+///     None => println!(\"Impossible to get your home dir!\")\n+/// }\n+/// ```\n+pub fn home_dir() -> Option<Path> {\n+    os_imp::home_dir()\n+}\n+\n+/// Returns the path to a temporary directory.\n+///\n+/// On Unix, returns the value of the 'TMPDIR' environment variable if it is\n+/// set, otherwise for non-Android it returns '/tmp'. If Android, since there\n+/// is no global temporary folder (it is usually allocated per-app), we return\n+/// '/data/local/tmp'.\n+///\n+/// On Windows, returns the value of, in order, the 'TMP', 'TEMP',\n+/// 'USERPROFILE' environment variable  if any are set and not the empty\n+/// string. Otherwise, tmpdir returns the path to the Windows directory.\n+pub fn temp_dir() -> Path {\n+    os_imp::temp_dir()\n+}\n+\n+/// Optionally returns the filesystem path to the current executable which is\n+/// running but with the executable name.\n+///\n+/// The path returned is not necessarily a \"real path\" to the executable as\n+/// there may be intermediate symlinks.\n+///\n+/// # Errors\n+///\n+/// Acquring the path to the current executable is a platform-specific operation\n+/// that can fail for a good number of reasons. Some errors can include, but not\n+/// be limited to filesystem operations failing or general syscall failures.\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// match env::current_exe() {\n+///     Ok(exe_path) => println!(\"Path of this executable is: {}\",\n+///                               exe_path.display()),\n+///     Err(e) => println!(\"failed to get current exe path: {}\", e),\n+/// };\n+/// ```\n+pub fn current_exe() -> IoResult<Path> {\n+    os_imp::current_exe()\n+}\n+\n+static EXIT_STATUS: AtomicIsize = ATOMIC_ISIZE_INIT;\n+\n+/// Sets the process exit code\n+///\n+/// Sets the exit code returned by the process if all supervised tasks\n+/// terminate successfully (without panicking). If the current root task panics\n+/// and is supervised by the scheduler then any user-specified exit status is\n+/// ignored and the process exits with the default panic status.\n+///\n+/// Note that this is not synchronized against modifications of other threads.\n+pub fn set_exit_status(code: i32) {\n+    EXIT_STATUS.store(code as isize, Ordering::SeqCst)\n+}\n+\n+/// Fetches the process's current exit code. This defaults to 0 and can change\n+/// by calling `set_exit_status`.\n+pub fn get_exit_status() -> i32 {\n+    EXIT_STATUS.load(Ordering::SeqCst) as i32\n+}\n+\n+/// An iterator over the arguments of a process, yielding an `OsString` value\n+/// for each argument.\n+///\n+/// This structure is created through the `std::env::args` method.\n+pub struct Args { inner: os_imp::Args }\n+\n+/// Returns the arguments which this program was started with (normally passed\n+/// via the command line).\n+///\n+/// The first element is traditionally the path to the executable, but it can be\n+/// set to arbitrary text, and it may not even exist, so this property should\n+/// not be relied upon for security purposes.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::env;\n+///\n+/// // Prints each argument on a separate line\n+/// for argument in env::args() {\n+///     println!(\"{:?}\", argument);\n+/// }\n+/// ```\n+pub fn args() -> Args {\n+    Args { inner: os_imp::args() }\n+}\n+\n+impl Iterator for Args {\n+    type Item = OsString;\n+    fn next(&mut self) -> Option<OsString> { self.inner.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+}\n+\n+/// Returns the page size of the current architecture in bytes.\n+pub fn page_size() -> usize {\n+    os_imp::page_size()\n+}\n+\n+/// Constants associated with the current target\n+#[cfg(target_os = \"linux\")]\n+pub mod consts {\n+    pub use super::arch_consts::ARCH;\n+\n+    pub const FAMILY: &'static str = \"unix\";\n+\n+    /// A string describing the specific operating system in use: in this\n+    /// case, `linux`.\n+    pub const OS: &'static str = \"linux\";\n+\n+    /// Specifies the filename prefix used for shared libraries on this\n+    /// platform: in this case, `lib`.\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+\n+    /// Specifies the filename suffix used for shared libraries on this\n+    /// platform: in this case, `.so`.\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+\n+    /// Specifies the file extension used for shared libraries on this\n+    /// platform that goes after the dot: in this case, `so`.\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+\n+    /// Specifies the filename suffix used for executable binaries on this\n+    /// platform: in this case, the empty string.\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+\n+    /// Specifies the file extension, if any, used for executable binaries\n+    /// on this platform: in this case, the empty string.\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+/// Constants associated with the current target\n+#[cfg(target_os = \"macos\")]\n+pub mod consts {\n+    pub use super::arch_consts::ARCH;\n+\n+    pub const FAMILY: &'static str = \"unix\";\n+\n+    /// A string describing the specific operating system in use: in this\n+    /// case, `macos`.\n+    pub const OS: &'static str = \"macos\";\n+\n+    /// Specifies the filename prefix used for shared libraries on this\n+    /// platform: in this case, `lib`.\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+\n+    /// Specifies the filename suffix used for shared libraries on this\n+    /// platform: in this case, `.dylib`.\n+    pub const DLL_SUFFIX: &'static str = \".dylib\";\n+\n+    /// Specifies the file extension used for shared libraries on this\n+    /// platform that goes after the dot: in this case, `dylib`.\n+    pub const DLL_EXTENSION: &'static str = \"dylib\";\n+\n+    /// Specifies the filename suffix used for executable binaries on this\n+    /// platform: in this case, the empty string.\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+\n+    /// Specifies the file extension, if any, used for executable binaries\n+    /// on this platform: in this case, the empty string.\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+/// Constants associated with the current target\n+#[cfg(target_os = \"ios\")]\n+pub mod consts {\n+    pub use super::arch_consts::ARCH;\n+\n+    pub const FAMILY: &'static str = \"unix\";\n+\n+    /// A string describing the specific operating system in use: in this\n+    /// case, `ios`.\n+    pub const OS: &'static str = \"ios\";\n+\n+    /// Specifies the filename suffix used for executable binaries on this\n+    /// platform: in this case, the empty string.\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+\n+    /// Specifies the file extension, if any, used for executable binaries\n+    /// on this platform: in this case, the empty string.\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+/// Constants associated with the current target\n+#[cfg(target_os = \"freebsd\")]\n+pub mod consts {\n+    pub use super::arch_consts::ARCH;\n+\n+    pub const FAMILY: &'static str = \"unix\";\n+\n+    /// A string describing the specific operating system in use: in this\n+    /// case, `freebsd`.\n+    pub const OS: &'static str = \"freebsd\";\n+\n+    /// Specifies the filename prefix used for shared libraries on this\n+    /// platform: in this case, `lib`.\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+\n+    /// Specifies the filename suffix used for shared libraries on this\n+    /// platform: in this case, `.so`.\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+\n+    /// Specifies the file extension used for shared libraries on this\n+    /// platform that goes after the dot: in this case, `so`.\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+\n+    /// Specifies the filename suffix used for executable binaries on this\n+    /// platform: in this case, the empty string.\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+\n+    /// Specifies the file extension, if any, used for executable binaries\n+    /// on this platform: in this case, the empty string.\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+/// Constants associated with the current target\n+#[cfg(target_os = \"dragonfly\")]\n+pub mod consts {\n+    pub use super::arch_consts::ARCH;\n+\n+    pub const FAMILY: &'static str = \"unix\";\n+\n+    /// A string describing the specific operating system in use: in this\n+    /// case, `dragonfly`.\n+    pub const OS: &'static str = \"dragonfly\";\n+\n+    /// Specifies the filename prefix used for shared libraries on this\n+    /// platform: in this case, `lib`.\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+\n+    /// Specifies the filename suffix used for shared libraries on this\n+    /// platform: in this case, `.so`.\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+\n+    /// Specifies the file extension used for shared libraries on this\n+    /// platform that goes after the dot: in this case, `so`.\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+\n+    /// Specifies the filename suffix used for executable binaries on this\n+    /// platform: in this case, the empty string.\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+\n+    /// Specifies the file extension, if any, used for executable binaries\n+    /// on this platform: in this case, the empty string.\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+/// Constants associated with the current target\n+#[cfg(target_os = \"android\")]\n+pub mod consts {\n+    pub use super::arch_consts::ARCH;\n+\n+    pub const FAMILY: &'static str = \"unix\";\n+\n+    /// A string describing the specific operating system in use: in this\n+    /// case, `android`.\n+    pub const OS: &'static str = \"android\";\n+\n+    /// Specifies the filename prefix used for shared libraries on this\n+    /// platform: in this case, `lib`.\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+\n+    /// Specifies the filename suffix used for shared libraries on this\n+    /// platform: in this case, `.so`.\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+\n+    /// Specifies the file extension used for shared libraries on this\n+    /// platform that goes after the dot: in this case, `so`.\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+\n+    /// Specifies the filename suffix used for executable binaries on this\n+    /// platform: in this case, the empty string.\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+\n+    /// Specifies the file extension, if any, used for executable binaries\n+    /// on this platform: in this case, the empty string.\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+/// Constants associated with the current target\n+#[cfg(target_os = \"windows\")]\n+pub mod consts {\n+    pub use super::arch_consts::ARCH;\n+\n+    pub const FAMILY: &'static str = \"windows\";\n+\n+    /// A string describing the specific operating system in use: in this\n+    /// case, `windows`.\n+    pub const OS: &'static str = \"windows\";\n+\n+    /// Specifies the filename prefix used for shared libraries on this\n+    /// platform: in this case, the empty string.\n+    pub const DLL_PREFIX: &'static str = \"\";\n+\n+    /// Specifies the filename suffix used for shared libraries on this\n+    /// platform: in this case, `.dll`.\n+    pub const DLL_SUFFIX: &'static str = \".dll\";\n+\n+    /// Specifies the file extension used for shared libraries on this\n+    /// platform that goes after the dot: in this case, `dll`.\n+    pub const DLL_EXTENSION: &'static str = \"dll\";\n+\n+    /// Specifies the filename suffix used for executable binaries on this\n+    /// platform: in this case, `.exe`.\n+    pub const EXE_SUFFIX: &'static str = \".exe\";\n+\n+    /// Specifies the file extension, if any, used for executable binaries\n+    /// on this platform: in this case, `exe`.\n+    pub const EXE_EXTENSION: &'static str = \"exe\";\n+}\n+\n+#[cfg(target_arch = \"x86\")]\n+mod arch_consts {\n+    pub const ARCH: &'static str = \"x86\";\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+mod arch_consts {\n+    pub const ARCH: &'static str = \"x86_64\";\n+}\n+\n+#[cfg(target_arch = \"arm\")]\n+mod arch_consts {\n+    pub const ARCH: &'static str = \"arm\";\n+}\n+\n+#[cfg(target_arch = \"aarch64\")]\n+mod arch_consts {\n+    pub const ARCH: &'static str = \"aarch64\";\n+}\n+\n+#[cfg(target_arch = \"mips\")]\n+mod arch_consts {\n+    pub const ARCH: &'static str = \"mips\";\n+}\n+\n+#[cfg(target_arch = \"mipsel\")]\n+mod arch_consts {\n+    pub const ARCH: &'static str = \"mipsel\";\n+}\n+\n+#[cfg(target_arch = \"powerpc\")]\n+mod arch_consts {\n+    pub const ARCH: &'static str = \"powerpc\";\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+    use super::*;\n+    use iter::repeat;\n+    use rand::{self, Rng};\n+    use ffi::{OsString, OsStr};\n+\n+    fn make_rand_name() -> OsString {\n+        let mut rng = rand::thread_rng();\n+        let n = format!(\"TEST{}\", rng.gen_ascii_chars().take(10)\n+                                     .collect::<String>());\n+        let n = OsString::from_string(n);\n+        assert!(var(&n).is_none());\n+        n\n+    }\n+\n+    fn eq(a: Option<OsString>, b: Option<&str>) {\n+        assert_eq!(a.as_ref().map(|s| &**s), b.map(OsStr::from_str).map(|s| &*s));\n+    }\n+\n+    #[test]\n+    fn test_set_var() {\n+        let n = make_rand_name();\n+        set_var(&n, \"VALUE\");\n+        eq(var(&n), Some(\"VALUE\"));\n+    }\n+\n+    #[test]\n+    fn test_remove_var() {\n+        let n = make_rand_name();\n+        set_var(&n, \"VALUE\");\n+        remove_var(&n);\n+        eq(var(&n), None);\n+    }\n+\n+    #[test]\n+    fn test_set_var_overwrite() {\n+        let n = make_rand_name();\n+        set_var(&n, \"1\");\n+        set_var(&n, \"2\");\n+        eq(var(&n), Some(\"2\"));\n+        set_var(&n, \"\");\n+        eq(var(&n), Some(\"\"));\n+    }\n+\n+    #[test]\n+    fn test_var_big() {\n+        let mut s = \"\".to_string();\n+        let mut i = 0;\n+        while i < 100 {\n+            s.push_str(\"aaaaaaaaaa\");\n+            i += 1;\n+        }\n+        let n = make_rand_name();\n+        set_var(&n, s.as_slice());\n+        eq(var(&n), Some(s.as_slice()));\n+    }\n+\n+    #[test]\n+    fn test_self_exe_path() {\n+        let path = current_exe();\n+        assert!(path.is_ok());\n+        let path = path.unwrap();\n+\n+        // Hard to test this function\n+        assert!(path.is_absolute());\n+    }\n+\n+    #[test]\n+    fn test_env_set_get_huge() {\n+        let n = make_rand_name();\n+        let s = repeat(\"x\").take(10000).collect::<String>();\n+        set_var(&n, &s);\n+        eq(var(&n), Some(s.as_slice()));\n+        remove_var(&n);\n+        eq(var(&n), None);\n+    }\n+\n+    #[test]\n+    fn test_env_set_var() {\n+        let n = make_rand_name();\n+\n+        let mut e = vars();\n+        set_var(&n, \"VALUE\");\n+        assert!(!e.any(|(k, v)| {\n+            &*k == &*n && &*v == \"VALUE\"\n+        }));\n+\n+        assert!(vars().any(|(k, v)| {\n+            &*k == &*n && &*v == \"VALUE\"\n+        }));\n+    }\n+\n+    #[test]\n+    fn test() {\n+        assert!((!Path::new(\"test-path\").is_absolute()));\n+\n+        current_dir().unwrap();\n+    }\n+\n+    #[test]\n+    #[cfg(windows)]\n+    fn split_paths_windows() {\n+        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n+            split_paths(unparsed).collect::<Vec<_>>() ==\n+                parsed.iter().map(|s| Path::new(*s)).collect::<Vec<_>>()\n+        }\n+\n+        assert!(check_parse(\"\", &mut [\"\"]));\n+        assert!(check_parse(r#\"\"\"\"#, &mut [\"\"]));\n+        assert!(check_parse(\";;\", &mut [\"\", \"\", \"\"]));\n+        assert!(check_parse(r\"c:\\\", &mut [r\"c:\\\"]));\n+        assert!(check_parse(r\"c:\\;\", &mut [r\"c:\\\", \"\"]));\n+        assert!(check_parse(r\"c:\\;c:\\Program Files\\\",\n+                            &mut [r\"c:\\\", r\"c:\\Program Files\\\"]));\n+        assert!(check_parse(r#\"c:\\;c:\\\"foo\"\\\"#, &mut [r\"c:\\\", r\"c:\\foo\\\"]));\n+        assert!(check_parse(r#\"c:\\;c:\\\"foo;bar\"\\;c:\\baz\"#,\n+                            &mut [r\"c:\\\", r\"c:\\foo;bar\\\", r\"c:\\baz\"]));\n+    }\n+\n+    #[test]\n+    #[cfg(unix)]\n+    fn split_paths_unix() {\n+        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n+            split_paths(unparsed).collect::<Vec<_>>() ==\n+                parsed.iter().map(|s| Path::new(*s)).collect::<Vec<_>>()\n+        }\n+\n+        assert!(check_parse(\"\", &mut [\"\"]));\n+        assert!(check_parse(\"::\", &mut [\"\", \"\", \"\"]));\n+        assert!(check_parse(\"/\", &mut [\"/\"]));\n+        assert!(check_parse(\"/:\", &mut [\"/\", \"\"]));\n+        assert!(check_parse(\"/:/usr/local\", &mut [\"/\", \"/usr/local\"]));\n+    }\n+\n+    #[test]\n+    #[cfg(unix)]\n+    fn join_paths_unix() {\n+        fn test_eq(input: &[&str], output: &str) -> bool {\n+            &*join_paths(input.iter().map(|s| *s)).unwrap() ==\n+                OsStr::from_str(output)\n+        }\n+\n+        assert!(test_eq(&[], \"\"));\n+        assert!(test_eq(&[\"/bin\", \"/usr/bin\", \"/usr/local/bin\"],\n+                         \"/bin:/usr/bin:/usr/local/bin\"));\n+        assert!(test_eq(&[\"\", \"/bin\", \"\", \"\", \"/usr/bin\", \"\"],\n+                         \":/bin:::/usr/bin:\"));\n+        assert!(join_paths([\"/te:st\"].iter().map(|s| *s)).is_err());\n+    }\n+\n+    #[test]\n+    #[cfg(windows)]\n+    fn join_paths_windows() {\n+        fn test_eq(input: &[&str], output: &str) -> bool {\n+            &*join_paths(input.iter().map(|s| *s)).unwrap() ==\n+                OsStr::from_str(output)\n+        }\n+\n+        assert!(test_eq(&[], \"\"));\n+        assert!(test_eq(&[r\"c:\\windows\", r\"c:\\\"],\n+                        r\"c:\\windows;c:\\\"));\n+        assert!(test_eq(&[\"\", r\"c:\\windows\", \"\", \"\", r\"c:\\\", \"\"],\n+                        r\";c:\\windows;;;c:\\;\"));\n+        assert!(test_eq(&[r\"c:\\te;st\", r\"c:\\\"],\n+                        r#\"\"c:\\te;st\";c:\\\"#));\n+        assert!(join_paths([r#\"c:\\te\"st\"#].iter().map(|s| *s)).is_err());\n+    }\n+    }"}, {"sha": "76f925a23f17412e3cd4bac2a6a707ccadc9caa3", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -20,7 +20,12 @@ pub use self::c_str::c_str_to_bytes_with_nul;\n \n pub use self::os_str::OsString;\n pub use self::os_str::OsStr;\n-pub use self::os_str::AsOsStr;\n \n mod c_str;\n mod os_str;\n+\n+/// Freely convertible to an `&OsStr` slice.\n+pub trait AsOsStr {\n+    /// Convert to an `&OsStr` slice.\n+    fn as_os_str(&self) -> &OsStr;\n+}"}, {"sha": "57489e86230069a168155e43460f4eb3c63cbc07", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 82, "deletions": 4, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -41,9 +41,11 @@ use string::{String, CowString};\n use ops;\n use cmp;\n use hash::{Hash, Hasher, Writer};\n+use path::{Path, GenericPath};\n \n use sys::os_str::{Buf, Slice};\n use sys_common::{AsInner, IntoInner, FromInner};\n+use super::AsOsStr;\n \n /// Owned, mutable OS strings.\n #[derive(Clone)]\n@@ -69,6 +71,11 @@ impl OsString {\n         OsString { inner: Buf::from_str(s) }\n     }\n \n+    /// Constructs a new empty `OsString`.\n+    pub fn new() -> OsString {\n+        OsString { inner: Buf::from_string(String::new()) }\n+    }\n+\n     /// Convert the `OsString` into a `String` if it contains valid Unicode data.\n     ///\n     /// On failure, ownership of the original `OsString` is returned.\n@@ -117,6 +124,62 @@ impl Debug for OsString {\n     }\n }\n \n+impl PartialEq for OsString {\n+    fn eq(&self, other: &OsString) -> bool {\n+        &**self == &**other\n+    }\n+}\n+\n+impl PartialEq<str> for OsString {\n+    fn eq(&self, other: &str) -> bool {\n+        &**self == other\n+    }\n+}\n+\n+impl PartialEq<OsString> for str {\n+    fn eq(&self, other: &OsString) -> bool {\n+        &**other == self\n+    }\n+}\n+\n+impl Eq for OsString {}\n+\n+impl PartialOrd for OsString {\n+    #[inline]\n+    fn partial_cmp(&self, other: &OsString) -> Option<cmp::Ordering> {\n+        (&**self).partial_cmp(&**other)\n+    }\n+    #[inline]\n+    fn lt(&self, other: &OsString) -> bool { &**self < &**other }\n+    #[inline]\n+    fn le(&self, other: &OsString) -> bool { &**self <= &**other }\n+    #[inline]\n+    fn gt(&self, other: &OsString) -> bool { &**self > &**other }\n+    #[inline]\n+    fn ge(&self, other: &OsString) -> bool { &**self >= &**other }\n+}\n+\n+impl PartialOrd<str> for OsString {\n+    #[inline]\n+    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {\n+        (&**self).partial_cmp(other)\n+    }\n+}\n+\n+impl Ord for OsString {\n+    #[inline]\n+    fn cmp(&self, other: &OsString) -> cmp::Ordering {\n+        (&**self).cmp(&**other)\n+    }\n+}\n+\n+impl<'a, S: Hasher + Writer> Hash<S> for OsString {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        (&**self).hash(state)\n+    }\n+}\n+\n impl OsStr {\n     /// Coerce directly from a `&str` slice to a `&OsStr` slice.\n     pub fn from_str(s: &str) -> &OsStr {\n@@ -222,10 +285,10 @@ impl ToOwned<OsString> for OsStr {\n     fn to_owned(&self) -> OsString { self.to_os_string() }\n }\n \n-/// Freely convertible to an `&OsStr` slice.\n-pub trait AsOsStr {\n-    /// Convert to an `&OsStr` slice.\n-    fn as_os_str(&self) -> &OsStr;\n+impl<'a, T: AsOsStr + ?Sized> AsOsStr for &'a T {\n+    fn as_os_str(&self) -> &OsStr {\n+        (*self).as_os_str()\n+    }\n }\n \n impl AsOsStr for OsStr {\n@@ -252,6 +315,21 @@ impl AsOsStr for String {\n     }\n }\n \n+#[cfg(unix)]\n+impl AsOsStr for Path {\n+    fn as_os_str(&self) -> &OsStr {\n+        unsafe { mem::transmute(self.as_vec()) }\n+    }\n+}\n+\n+#[cfg(windows)]\n+impl AsOsStr for Path {\n+    fn as_os_str(&self) -> &OsStr {\n+        // currently .as_str() is actually infallible on windows\n+        OsStr::from_str(self.as_str().unwrap())\n+    }\n+}\n+\n impl FromInner<Buf> for OsString {\n     fn from_inner(buf: Buf) -> OsString {\n         OsString { inner: buf }"}, {"sha": "487efb4332682092311867abf18f5aab76a6c470", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -250,6 +250,7 @@ pub mod ffi;\n pub mod fmt;\n pub mod old_io;\n pub mod os;\n+pub mod env;\n pub mod path;\n pub mod rand;\n pub mod time;"}, {"sha": "81903d0a97e99b0b1cfe88c638c2e9864989d036", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -231,6 +231,7 @@ impl Command {\n         self\n     }\n     // Get a mutable borrow of the environment variable map for this `Command`.\n+    #[allow(deprecated)]\n     fn get_env_map<'a>(&'a mut self) -> &'a mut EnvMap {\n         match self.env {\n             Some(ref mut map) => map,"}, {"sha": "83a42549424d698dabee5242ff2075df1c04ceb0", "filename": "src/libstd/old_io/tempfile.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fold_io%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fold_io%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftempfile.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -10,13 +10,13 @@\n \n //! Temporary files and directories\n \n+use env;\n+use iter::{IteratorExt};\n use old_io::{fs, IoError, IoErrorKind, IoResult};\n use old_io;\n-use iter::IteratorExt;\n use ops::Drop;\n-use option::Option;\n use option::Option::{None, Some};\n-use os;\n+use option::Option;\n use path::{Path, GenericPath};\n use rand::{Rng, thread_rng};\n use result::Result::{Ok, Err};\n@@ -97,8 +97,8 @@ impl TempDir {\n     /// If no directory can be created, `Err` is returned.\n     pub fn new_in(tmpdir: &Path, prefix: &str) -> IoResult<TempDir> {\n         if !tmpdir.is_absolute() {\n-            let abs_tmpdir = try!(os::make_absolute(tmpdir));\n-            return TempDir::new_in(&abs_tmpdir, prefix);\n+            let cur_dir = try!(env::current_dir());\n+            return TempDir::new_in(&cur_dir.join(tmpdir), prefix);\n         }\n \n         let mut rng = thread_rng();\n@@ -132,7 +132,7 @@ impl TempDir {\n     ///\n     /// If no directory can be created, `Err` is returned.\n     pub fn new(prefix: &str) -> IoResult<TempDir> {\n-        TempDir::new_in(&os::tmpdir(), prefix)\n+        TempDir::new_in(&env::temp_dir(), prefix)\n     }\n \n     /// Unwrap the wrapped `std::path::Path` from the `TempDir` wrapper."}, {"sha": "3f4e070e30d95b66bb199d517e7ff1a3624a604f", "filename": "src/libstd/old_io/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fold_io%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fold_io%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftest.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -12,8 +12,8 @@\n \n use prelude::v1::*;\n \n+use env;\n use libc;\n-use os;\n use std::old_io::net::ip::*;\n use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n \n@@ -41,7 +41,7 @@ fn next_test_unix_socket() -> String {\n pub fn next_test_unix() -> Path {\n     let string = next_test_unix_socket();\n     if cfg!(unix) {\n-        os::tmpdir().join(string)\n+        env::temp_dir().join(string)\n     } else {\n         Path::new(format!(\"{}{}\", r\"\\\\.\\pipe\\\", string))\n     }\n@@ -87,7 +87,7 @@ fn base_port() -> u16 {\n     ];\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let path = os::getcwd().unwrap();\n+    let path = env::current_dir().unwrap();\n     let path_s = path.as_str().unwrap();\n \n     let mut final_base = base;"}, {"sha": "27e843d2383bf429392ca2236268d7d789215f1a", "filename": "src/libstd/os.rs", "status": "modified", "additions": 106, "deletions": 141, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -34,29 +34,32 @@ use self::MemoryMapKind::*;\n use self::MapOption::*;\n use self::MapError::*;\n \n+use boxed::Box;\n use clone::Clone;\n+use env;\n use error::{FromError, Error};\n+use ffi::{OsString, OsStr};\n use fmt;\n-use old_io::{IoResult, IoError};\n use iter::{Iterator, IteratorExt};\n-use marker::{Copy, Send};\n use libc::{c_void, c_int, c_char};\n use libc;\n-use boxed::Box;\n+use marker::{Copy, Send};\n+use old_io::{IoResult, IoError};\n use ops::{Drop, FnOnce};\n-use option::Option;\n use option::Option::{Some, None};\n+use option::Option;\n use path::{Path, GenericPath, BytesContainer};\n-use sys;\n-use sys::os as os_imp;\n use ptr::PtrExt;\n use ptr;\n-use result::Result;\n use result::Result::{Err, Ok};\n+use result::Result;\n use slice::{AsSlice, SliceExt};\n use str::{Str, StrExt};\n+use str;\n use string::{String, ToString};\n use sync::atomic::{AtomicIsize, ATOMIC_ISIZE_INIT, Ordering};\n+use sys::os as os_imp;\n+use sys;\n use vec::Vec;\n \n #[cfg(unix)] use ffi::{self, CString};\n@@ -97,23 +100,10 @@ pub const TMPBUF_SZ : uint = 1000u;\n /// let current_working_directory = os::getcwd().unwrap();\n /// println!(\"The current directory is {:?}\", current_working_directory.display());\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to std::env::current_dir\")]\n+#[unstable(feature = \"os\")]\n pub fn getcwd() -> IoResult<Path> {\n-    sys::os::getcwd()\n-}\n-\n-/*\n-Accessing environment variables is not generally threadsafe.\n-Serialize access through a global lock.\n-*/\n-fn with_env_lock<T, F>(f: F) -> T where\n-    F: FnOnce() -> T,\n-{\n-    use sync::{StaticMutex, MUTEX_INIT};\n-\n-    static LOCK: StaticMutex = MUTEX_INIT;\n-\n-    let _guard = LOCK.lock();\n-    f()\n+    env::current_dir()\n }\n \n /// Returns a vector of (variable, value) pairs, for all the environment\n@@ -132,37 +122,22 @@ fn with_env_lock<T, F>(f: F) -> T where\n ///     println!(\"'{}': '{}'\", key, value );\n /// }\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"use env::vars instead\")]\n+#[unstable(feature = \"os\")]\n pub fn env() -> Vec<(String,String)> {\n-    env_as_bytes().into_iter().map(|(k,v)| {\n-        let k = String::from_utf8_lossy(k.as_slice()).into_owned();\n-        let v = String::from_utf8_lossy(v.as_slice()).into_owned();\n-        (k,v)\n+    env::vars().map(|(k, v)| {\n+        (k.to_string_lossy().into_owned(), v.to_string_lossy().into_owned())\n     }).collect()\n }\n \n /// Returns a vector of (variable, value) byte-vector pairs for all the\n /// environment variables of the current process.\n-pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n-    unsafe {\n-        fn env_convert(input: Vec<Vec<u8>>) -> Vec<(Vec<u8>, Vec<u8>)> {\n-            let mut pairs = Vec::new();\n-            for p in input.iter() {\n-                let mut it = p.splitn(1, |b| *b == b'=');\n-                let key = it.next().unwrap().to_vec();\n-                let default: &[u8] = &[];\n-                let val = it.next().unwrap_or(default).to_vec();\n-                pairs.push((key, val));\n-            }\n-            pairs\n-        }\n-        with_env_lock(|| {\n-            let unparsed_environ = sys::os::get_env_pairs();\n-            env_convert(unparsed_environ)\n-        })\n-    }\n+#[deprecated(since = \"1.0.0\", reason = \"use env::vars instead\")]\n+#[unstable(feature = \"os\")]\n+pub fn env_as_bytes() -> Vec<(Vec<u8>, Vec<u8>)> {\n+    env::vars().map(|(k, v)| (byteify(k), byteify(v))).collect()\n }\n \n-#[cfg(unix)]\n /// Fetches the environment variable `n` from the current process, returning\n /// None if the variable isn't set.\n ///\n@@ -184,52 +159,32 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n ///     None => println!(\"{} is not defined in the environment.\", key)\n /// }\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"use env::var or env::var_string instead\")]\n+#[unstable(feature = \"os\")]\n pub fn getenv(n: &str) -> Option<String> {\n-    getenv_as_bytes(n).map(|v| String::from_utf8_lossy(v.as_slice()).into_owned())\n+    env::var_string(n).ok()\n }\n \n-#[cfg(unix)]\n /// Fetches the environment variable `n` byte vector from the current process,\n /// returning None if the variable isn't set.\n ///\n /// # Panics\n ///\n /// Panics if `n` has any interior NULs.\n+#[deprecated(since = \"1.0.0\", reason = \"use env::var instead\")]\n+#[unstable(feature = \"os\")]\n pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n-    unsafe {\n-        with_env_lock(|| {\n-            let s = CString::from_slice(n.as_bytes());\n-            let s = libc::getenv(s.as_ptr()) as *const _;\n-            if s.is_null() {\n-                None\n-            } else {\n-                Some(ffi::c_str_to_bytes(&s).to_vec())\n-            }\n-        })\n-    }\n+    env::var(n).map(byteify)\n }\n \n-#[cfg(windows)]\n-/// Fetches the environment variable `n` from the current process, returning\n-/// None if the variable isn't set.\n-pub fn getenv(n: &str) -> Option<String> {\n-    unsafe {\n-        with_env_lock(|| {\n-            use sys::os::fill_utf16_buf_and_decode;\n-            let mut n: Vec<u16> = n.utf16_units().collect();\n-            n.push(0);\n-            fill_utf16_buf_and_decode(|buf, sz| {\n-                libc::GetEnvironmentVariableW(n.as_ptr(), buf, sz)\n-            })\n-        })\n-    }\n+#[cfg(unix)]\n+fn byteify(s: OsString) -> Vec<u8> {\n+    use os::unix::*;\n+    s.into_vec()\n }\n-\n #[cfg(windows)]\n-/// Fetches the environment variable `n` byte vector from the current process,\n-/// returning None if the variable isn't set.\n-pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n-    getenv(n).map(|s| s.into_bytes())\n+fn byteify(s: OsString) -> Vec<u8> {\n+    s.to_string_lossy().as_bytes().to_vec()\n }\n \n /// Sets the environment variable `n` to the value `v` for the currently running\n@@ -247,68 +202,30 @@ pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n ///     None => println!(\"{} is not defined in the environment.\", key)\n /// }\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::set_var\")]\n+#[unstable(feature = \"os\")]\n pub fn setenv<T: BytesContainer>(n: &str, v: T) {\n     #[cfg(unix)]\n     fn _setenv(n: &str, v: &[u8]) {\n-        unsafe {\n-            with_env_lock(|| {\n-                let k = CString::from_slice(n.as_bytes());\n-                let v = CString::from_slice(v);\n-                if libc::funcs::posix01::unistd::setenv(k.as_ptr(),\n-                                                        v.as_ptr(), 1) != 0 {\n-                    panic!(IoError::last_error());\n-                }\n-            })\n-        }\n+        use os::unix::*;\n+        let v: OsString = OsStringExt::from_vec(v.to_vec());\n+        env::set_var(n, &v)\n     }\n \n     #[cfg(windows)]\n     fn _setenv(n: &str, v: &[u8]) {\n-        let mut n: Vec<u16> = n.utf16_units().collect();\n-        n.push(0);\n-        let mut v: Vec<u16> = ::str::from_utf8(v).unwrap().utf16_units().collect();\n-        v.push(0);\n-\n-        unsafe {\n-            with_env_lock(|| {\n-                if libc::SetEnvironmentVariableW(n.as_ptr(), v.as_ptr()) == 0 {\n-                    panic!(IoError::last_error());\n-                }\n-            })\n-        }\n+        let v = str::from_utf8(v).unwrap();\n+        env::set_var(n, v)\n     }\n \n     _setenv(n, v.container_as_bytes())\n }\n \n /// Remove a variable from the environment entirely.\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::remove_var\")]\n+#[unstable(feature = \"os\")]\n pub fn unsetenv(n: &str) {\n-    #[cfg(unix)]\n-    fn _unsetenv(n: &str) {\n-        unsafe {\n-            with_env_lock(|| {\n-                let nbuf = CString::from_slice(n.as_bytes());\n-                if libc::funcs::posix01::unistd::unsetenv(nbuf.as_ptr()) != 0 {\n-                    panic!(IoError::last_error());\n-                }\n-            })\n-        }\n-    }\n-\n-    #[cfg(windows)]\n-    fn _unsetenv(n: &str) {\n-        let mut n: Vec<u16> = n.utf16_units().collect();\n-        n.push(0);\n-        unsafe {\n-            with_env_lock(|| {\n-                if libc::SetEnvironmentVariableW(n.as_ptr(), ptr::null()) == 0 {\n-                    panic!(IoError::last_error());\n-                }\n-            })\n-        }\n-    }\n-\n-    _unsetenv(n)\n+    env::remove_var(n)\n }\n \n /// Parses input according to platform conventions for the `PATH`\n@@ -328,8 +245,12 @@ pub fn unsetenv(n: &str) {\n ///     None => println!(\"{} is not defined in the environment.\", key)\n /// }\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::split_paths\")]\n+#[unstable(feature = \"os\")]\n pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n-    sys::os::split_paths(unparsed.container_as_bytes())\n+    let b = unparsed.container_as_bytes();\n+    let s = str::from_utf8(b).unwrap();\n+    env::split_paths(s).collect()\n }\n \n /// Joins a collection of `Path`s appropriately for the `PATH`\n@@ -353,8 +274,14 @@ pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n /// paths.push(Path::new(\"/home/xyz/bin\"));\n /// os::setenv(key, os::join_paths(paths.as_slice()).unwrap());\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::join_paths\")]\n+#[unstable(feature = \"os\")]\n pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n-    sys::os::join_paths(paths)\n+    env::join_paths(paths.iter().map(|s| {\n+        str::from_utf8(s.container_as_bytes()).unwrap()\n+    })).map(|s| {\n+        s.to_string_lossy().into_owned().into_bytes()\n+    }).map_err(|_| \"failed to join paths\")\n }\n \n /// A low-level OS in-memory pipe.\n@@ -388,6 +315,8 @@ pub unsafe fn pipe() -> IoResult<Pipe> {\n /// Returns the proper dll filename for the given basename of a file\n /// as a String.\n #[cfg(not(target_os=\"ios\"))]\n+#[deprecated(since = \"1.0.0\", reason = \"this function will be removed, use the constants directly\")]\n+#[unstable(feature = \"os\")]\n pub fn dll_filename(base: &str) -> String {\n     format!(\"{}{}{}\", consts::DLL_PREFIX, base, consts::DLL_SUFFIX)\n }\n@@ -405,8 +334,10 @@ pub fn dll_filename(base: &str) -> String {\n ///     None => println!(\"Unable to get the path of this executable!\")\n /// };\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::current_exe\")]\n+#[unstable(feature = \"os\")]\n pub fn self_exe_name() -> Option<Path> {\n-    sys::os::load_self().and_then(Path::new_opt)\n+    env::current_exe().ok()\n }\n \n /// Optionally returns the filesystem path to the current executable which is\n@@ -424,8 +355,10 @@ pub fn self_exe_name() -> Option<Path> {\n ///     None => println!(\"Impossible to fetch the path of this executable.\")\n /// };\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"use env::current_exe + dir_path/pop\")]\n+#[unstable(feature = \"os\")]\n pub fn self_exe_path() -> Option<Path> {\n-    self_exe_name().map(|mut p| { p.pop(); p })\n+    env::current_exe().ok().map(|mut p| { p.pop(); p })\n }\n \n /// Optionally returns the path to the current user's home directory if known.\n@@ -452,6 +385,9 @@ pub fn self_exe_path() -> Option<Path> {\n ///     None => println!(\"Impossible to get your home dir!\")\n /// }\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::home_dir\")]\n+#[allow(deprecated)]\n+#[unstable(feature = \"os\")]\n pub fn homedir() -> Option<Path> {\n     #[inline]\n     #[cfg(unix)]\n@@ -487,6 +423,9 @@ pub fn homedir() -> Option<Path> {\n /// On Windows, returns the value of, in order, the 'TMP', 'TEMP',\n /// 'USERPROFILE' environment variable  if any are set and not the empty\n /// string. Otherwise, tmpdir returns the path to the Windows directory.\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::temp_dir\")]\n+#[allow(deprecated)]\n+#[unstable(feature = \"os\")]\n pub fn tmpdir() -> Path {\n     return lookup();\n \n@@ -542,11 +481,13 @@ pub fn tmpdir() -> Path {\n // NB: this is here rather than in path because it is a form of environment\n // querying; what it does depends on the process working directory, not just\n // the input paths.\n+#[deprecated(since = \"1.0.0\", reason = \"use env::current_dir + .join directly\")]\n+#[unstable(feature = \"os\")]\n pub fn make_absolute(p: &Path) -> IoResult<Path> {\n     if p.is_absolute() {\n         Ok(p.clone())\n     } else {\n-        getcwd().map(|mut cwd| {\n+        env::current_dir().map(|mut cwd| {\n             cwd.push(p);\n             cwd\n         })\n@@ -565,6 +506,8 @@ pub fn make_absolute(p: &Path) -> IoResult<Path> {\n /// assert!(os::change_dir(&root).is_ok());\n /// println!(\"Successfully changed working directory to {}!\", root.display());\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::set_current_dir\")]\n+#[unstable(feature = \"os\")]\n pub fn change_dir(p: &Path) -> IoResult<()> {\n     return sys::os::chdir(p);\n }\n@@ -592,8 +535,6 @@ pub fn last_os_error() -> String {\n     error_string(errno() as uint)\n }\n \n-static EXIT_STATUS: AtomicIsize = ATOMIC_ISIZE_INIT;\n-\n /// Sets the process exit code\n ///\n /// Sets the exit code returned by the process if all supervised tasks\n@@ -602,14 +543,18 @@ static EXIT_STATUS: AtomicIsize = ATOMIC_ISIZE_INIT;\n /// ignored and the process exits with the default panic status.\n ///\n /// Note that this is not synchronized against modifications of other threads.\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::set_exit_status\")]\n+#[unstable(feature = \"os\")]\n pub fn set_exit_status(code: int) {\n-    EXIT_STATUS.store(code, Ordering::SeqCst)\n+    env::set_exit_status(code as i32)\n }\n \n /// Fetches the process's current exit code. This defaults to 0 and can change\n /// by calling `set_exit_status`.\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::get_exit_status\")]\n+#[unstable(feature = \"os\")]\n pub fn get_exit_status() -> int {\n-    EXIT_STATUS.load(Ordering::SeqCst)\n+    env::get_exit_status() as isize\n }\n \n #[cfg(target_os = \"macos\")]\n@@ -726,7 +671,7 @@ fn real_args() -> Vec<String> {\n         // Push it onto the list.\n         let ptr = ptr as *const u16;\n         let buf = slice::from_raw_buf(&ptr, len);\n-        let opt_s = String::from_utf16(sys::os::truncate_utf16_at_nul(buf));\n+        let opt_s = String::from_utf16(sys::truncate_utf16_at_nul(buf));\n         opt_s.ok().expect(\"CommandLineToArgvW returned invalid UTF-16\")\n     }).collect();\n \n@@ -777,24 +722,30 @@ extern \"system\" {\n ///     println!(\"{}\", argument);\n /// }\n /// ```\n+#[deprecated(since = \"1.0.0\", reason = \"use env::args instead\")]\n+#[unstable(feature = \"os\")]\n pub fn args() -> Vec<String> {\n     real_args()\n }\n \n /// Returns the arguments which this program was started with (normally passed\n /// via the command line) as byte vectors.\n+#[deprecated(since = \"1.0.0\", reason = \"use env::args_raw instead\")]\n+#[unstable(feature = \"os\")]\n pub fn args_as_bytes() -> Vec<Vec<u8>> {\n     real_args_as_bytes()\n }\n \n #[cfg(target_os = \"macos\")]\n extern {\n     // These functions are in crt_externs.h.\n-    pub fn _NSGetArgc() -> *mut c_int;\n-    pub fn _NSGetArgv() -> *mut *mut *mut c_char;\n+    fn _NSGetArgc() -> *mut c_int;\n+    fn _NSGetArgv() -> *mut *mut *mut c_char;\n }\n \n /// Returns the page size of the current architecture in bytes.\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::page_size\")]\n+#[unstable(feature = \"os\")]\n pub fn page_size() -> uint {\n     sys::os::page_size()\n }\n@@ -970,7 +921,7 @@ impl MemoryMap {\n         let mut fd = -1;\n         let mut offset = 0;\n         let mut custom_flags = false;\n-        let len = round_up(min_len, page_size());\n+        let len = round_up(min_len, env::page_size());\n \n         for &o in options.iter() {\n             match o {\n@@ -1020,7 +971,7 @@ impl MemoryMap {\n     /// Granularity that the offset or address must be for `MapOffset` and\n     /// `MapAddr` respectively.\n     pub fn granularity() -> uint {\n-        page_size()\n+        env::page_size()\n     }\n }\n \n@@ -1049,7 +1000,7 @@ impl MemoryMap {\n         let mut executable = false;\n         let mut handle: HANDLE = libc::INVALID_HANDLE_VALUE;\n         let mut offset: uint = 0;\n-        let len = round_up(min_len, page_size());\n+        let len = round_up(min_len, env::page_size());\n \n         for &o in options.iter() {\n             match o {\n@@ -1184,6 +1135,8 @@ impl MemoryMap {\n }\n \n #[cfg(target_os = \"linux\")]\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n+#[unstable(feature = \"os\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n \n@@ -1215,6 +1168,8 @@ pub mod consts {\n }\n \n #[cfg(target_os = \"macos\")]\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n+#[unstable(feature = \"os\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n \n@@ -1246,6 +1201,8 @@ pub mod consts {\n }\n \n #[cfg(target_os = \"ios\")]\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n+#[unstable(feature = \"os\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n \n@@ -1265,6 +1222,8 @@ pub mod consts {\n }\n \n #[cfg(target_os = \"freebsd\")]\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n+#[unstable(feature = \"os\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n \n@@ -1296,6 +1255,8 @@ pub mod consts {\n }\n \n #[cfg(target_os = \"dragonfly\")]\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n+#[unstable(feature = \"os\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n \n@@ -1327,6 +1288,8 @@ pub mod consts {\n }\n \n #[cfg(target_os = \"android\")]\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n+#[unstable(feature = \"os\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n \n@@ -1358,6 +1321,8 @@ pub mod consts {\n }\n \n #[cfg(target_os = \"windows\")]\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n+#[unstable(feature = \"os\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;\n "}, {"sha": "905cc06c4f007f11d5640e31d1d8f3756a88fc8e", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -14,7 +14,7 @@\n \n use prelude::v1::*;\n \n-use os;\n+use env;\n use sync::atomic::{self, Ordering};\n \n pub use sys::backtrace::write;\n@@ -29,7 +29,7 @@ pub fn log_enabled() -> bool {\n         _ => {}\n     }\n \n-    let val = match os::getenv(\"RUST_BACKTRACE\") {\n+    let val = match env::var(\"RUST_BACKTRACE\") {\n         Some(..) => 2,\n         None => 1,\n     };"}, {"sha": "00088d6d99a0a6af49b02b8910da11c29832cd00", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -65,7 +65,7 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n     use prelude::v1::*;\n \n     use mem;\n-    use os;\n+    use env;\n     use rt;\n     use sys_common::thread_info::{self, NewThread};\n     use sys_common;\n@@ -131,7 +131,7 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n     if failed {\n         rt::DEFAULT_ERROR_CODE\n     } else {\n-        os::get_exit_status()\n+        env::get_exit_status() as isize\n     }\n }\n "}, {"sha": "86d21cf72782ed51a3b71db9225c346d1dc52e71", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -13,6 +13,7 @@\n use prelude::v1::*;\n \n use cmp;\n+use env;\n use fmt;\n use intrinsics;\n use libc::{self, uintptr_t};\n@@ -51,7 +52,7 @@ pub fn min_stack() -> uint {\n         0 => {}\n         n => return n - 1,\n     }\n-    let amt = os::getenv(\"RUST_MIN_STACK\").and_then(|s| s.parse().ok());\n+    let amt = env::var_string(\"RUST_MIN_STACK\").ok().and_then(|s| s.parse().ok());\n     let amt = amt.unwrap_or(2 * 1024 * 1024);\n     // 0 is our sentinel value, so ensure that we'll never see 0 after\n     // initialization has run\n@@ -62,15 +63,15 @@ pub fn min_stack() -> uint {\n /// Get's the number of scheduler threads requested by the environment\n /// either `RUST_THREADS` or `num_cpus`.\n pub fn default_sched_threads() -> uint {\n-    match os::getenv(\"RUST_THREADS\") {\n-        Some(nstr) => {\n+    match env::var_string(\"RUST_THREADS\") {\n+        Ok(nstr) => {\n             let opt_n: Option<uint> = nstr.parse().ok();\n             match opt_n {\n                 Some(n) if n > 0 => n,\n                 _ => panic!(\"`RUST_THREADS` is `{}`, should be a positive integer\", nstr)\n             }\n         }\n-        None => {\n+        Err(..) => {\n             if limit_thread_creation_due_to_osx_and_valgrind() {\n                 1\n             } else {"}, {"sha": "0ca228267003db79e76a9e5b96a06dd1eed35b41", "filename": "src/libstd/sys/common/mutex.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -24,13 +24,6 @@ unsafe impl Sync for Mutex {}\n pub const MUTEX_INIT: Mutex = Mutex(imp::MUTEX_INIT);\n \n impl Mutex {\n-    /// Creates a newly initialized mutex.\n-    ///\n-    /// Behavior is undefined if the mutex is moved after the first method is\n-    /// called on the mutex.\n-    #[inline]\n-    pub unsafe fn new() -> Mutex { Mutex(imp::Mutex::new()) }\n-\n     /// Lock the mutex blocking the current thread until it is available.\n     ///\n     /// Behavior is undefined if the mutex has been moved between this and any"}, {"sha": "fe374e1fd78a3dd55ac97c08234d60054832fe90", "filename": "src/libstd/sys/common/rwlock.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -21,13 +21,6 @@ pub struct RWLock(imp::RWLock);\n pub const RWLOCK_INIT: RWLock = RWLock(imp::RWLOCK_INIT);\n \n impl RWLock {\n-    /// Creates a new instance of an RWLock.\n-    ///\n-    /// Usage of an RWLock is undefined if it is moved after its first use (any\n-    /// function calls below).\n-    #[inline]\n-    pub unsafe fn new() -> RWLock { RWLock(imp::RWLock::new()) }\n-\n     /// Acquire shared access to the underlying lock, blocking the current\n     /// thread to do so.\n     ///"}, {"sha": "51186feeaf4bcb39df729aa8838717329b0d95c9", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -240,7 +240,7 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n \n #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n-    use os;\n+    use env;\n     use ptr;\n \n     ////////////////////////////////////////////////////////////////////////\n@@ -319,7 +319,7 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n         if !STATE.is_null() { return STATE }\n         let selfname = if cfg!(target_os = \"freebsd\") ||\n                           cfg!(target_os = \"dragonfly\") {\n-            os::self_exe_name()\n+            env::current_exe().ok()\n         } else {\n             None\n         };"}, {"sha": "7a17e8b6f1e1512823f9dbea41c3574f05055236", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -66,6 +66,53 @@ pub const MSG_DONTWAIT: libc::c_int = 0x40;\n \n pub const WNOHANG: libc::c_int = 1;\n \n+#[cfg(target_os = \"linux\")]\n+pub const _SC_GETPW_R_SIZE_MAX: libc::c_int = 70;\n+#[cfg(any(target_os = \"macos\",\n+          target_os = \"freebsd\"))]\n+pub const _SC_GETPW_R_SIZE_MAX: libc::c_int = 71;\n+#[cfg(target_os = \"android\")]\n+pub const _SC_GETPW_R_SIZE_MAX: libc::c_int = 0x0048;\n+\n+#[repr(C)]\n+#[cfg(target_os = \"linux\")]\n+pub struct passwd {\n+    pub pw_name: *mut libc::c_char,\n+    pub pw_passwd: *mut libc::c_char,\n+    pub pw_uid: libc::uid_t,\n+    pub pw_gid: libc::gid_t,\n+    pub pw_gecos: *mut libc::c_char,\n+    pub pw_dir: *mut libc::c_char,\n+    pub pw_shell: *mut libc::c_char,\n+}\n+\n+#[repr(C)]\n+#[cfg(any(target_os = \"macos\",\n+          target_os = \"freebsd\"))]\n+pub struct passwd {\n+    pub pw_name: *mut libc::c_char,\n+    pub pw_passwd: *mut libc::c_char,\n+    pub pw_uid: libc::uid_t,\n+    pub pw_gid: libc::gid_t,\n+    pub pw_change: libc::time_t,\n+    pub pw_class: *mut libc::c_char,\n+    pub pw_gecos: *mut libc::c_char,\n+    pub pw_dir: *mut libc::c_char,\n+    pub pw_shell: *mut libc::c_char,\n+    pub pw_expire: libc::time_t,\n+}\n+\n+#[repr(C)]\n+#[cfg(target_os = \"android\")]\n+pub struct passwd {\n+    pub pw_name: *mut libc::c_char,\n+    pub pw_passwd: *mut libc::c_char,\n+    pub pw_uid: libc::uid_t,\n+    pub pw_gid: libc::gid_t,\n+    pub pw_dir: *mut libc::c_char,\n+    pub pw_shell: *mut libc::c_char,\n+}\n+\n extern {\n     pub fn gettimeofday(timeval: *mut libc::timeval,\n                         tzp: *mut libc::c_void) -> libc::c_int;\n@@ -92,6 +139,12 @@ extern {\n     pub fn sigaddset(set: *mut sigset_t, signum: libc::c_int) -> libc::c_int;\n     pub fn sigdelset(set: *mut sigset_t, signum: libc::c_int) -> libc::c_int;\n     pub fn sigemptyset(set: *mut sigset_t) -> libc::c_int;\n+\n+    pub fn getpwuid_r(uid: libc::uid_t,\n+                      pwd: *mut passwd,\n+                      buf: *mut libc::c_char,\n+                      buflen: libc::size_t,\n+                      result: *mut *mut passwd) -> libc::c_int;\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]"}, {"sha": "b03b9046966a02dc3dccc99307c8a9900cbb6750", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -141,7 +141,7 @@ pub fn retry<T, F> (mut f: F) -> T where\n     let one: T = Int::one();\n     loop {\n         let n = f();\n-        if n == -one && os::errno() == libc::EINTR as int { }\n+        if n == -one && os::errno() == libc::EINTR as i32 { }\n         else { return n }\n     }\n }\n@@ -155,7 +155,7 @@ pub fn ms_to_timeval(ms: u64) -> libc::timeval {\n \n pub fn wouldblock() -> bool {\n     let err = os::errno();\n-    err == libc::EWOULDBLOCK as int || err == libc::EAGAIN as int\n+    err == libc::EWOULDBLOCK as i32 || err == libc::EAGAIN as i32\n }\n \n pub fn set_nonblocking(fd: sock_t, nb: bool) -> IoResult<()> {"}, {"sha": "68818b07b7fefe7c0869c56ea8a9a8bb7009fc55", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 319, "deletions": 121, "changes": 440, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -11,93 +11,64 @@\n //! Implementation of `std::os` functionality for unix systems\n \n use prelude::v1::*;\n+use os::unix::*;\n \n-use error::{FromError, Error};\n-use ffi::{self, CString};\n+use error::Error as StdError;\n+use ffi::{self, CString, OsString, OsStr, AsOsStr};\n use fmt;\n-use old_io::{IoError, IoResult};\n+use iter;\n use libc::{self, c_int, c_char, c_void};\n-use os::TMPBUF_SZ;\n-use os;\n-use path::{BytesContainer};\n+use mem;\n+use old_io::{IoResult, IoError, fs};\n use ptr;\n+use slice;\n use str;\n+use sys::c;\n use sys::fs::FileDesc;\n+use vec;\n \n-const BUF_BYTES : uint = 2048u;\n+const BUF_BYTES: usize = 2048;\n+const TMPBUF_SZ: usize = 128;\n \n /// Returns the platform-specific value of errno\n-pub fn errno() -> int {\n+pub fn errno() -> i32 {\n     #[cfg(any(target_os = \"macos\",\n               target_os = \"ios\",\n               target_os = \"freebsd\"))]\n-    fn errno_location() -> *const c_int {\n-        extern {\n-            fn __error() -> *const c_int;\n-        }\n-        unsafe {\n-            __error()\n-        }\n+    unsafe fn errno_location() -> *const c_int {\n+        extern { fn __error() -> *const c_int; }\n+        __error()\n     }\n \n     #[cfg(target_os = \"dragonfly\")]\n-    fn errno_location() -> *const c_int {\n-        extern {\n-            fn __dfly_error() -> *const c_int;\n-        }\n-        unsafe {\n-            __dfly_error()\n-        }\n+    unsafe fn errno_location() -> *const c_int {\n+        extern { fn __dfly_error() -> *const c_int; }\n+        __dfly_error()\n     }\n \n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    fn errno_location() -> *const c_int {\n-        extern {\n-            fn __errno_location() -> *const c_int;\n-        }\n-        unsafe {\n-            __errno_location()\n-        }\n+    unsafe fn errno_location() -> *const c_int {\n+        extern { fn __errno_location() -> *const c_int; }\n+        __errno_location()\n     }\n \n     unsafe {\n-        (*errno_location()) as int\n+        (*errno_location()) as i32\n     }\n }\n \n /// Get a detailed string description for the given error number\n pub fn error_string(errno: i32) -> String {\n-    #[cfg(any(target_os = \"macos\",\n-              target_os = \"ios\",\n-              target_os = \"android\",\n-              target_os = \"freebsd\",\n-              target_os = \"dragonfly\"))]\n-    fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t)\n-                  -> c_int {\n-        extern {\n-            fn strerror_r(errnum: c_int, buf: *mut c_char,\n-                          buflen: libc::size_t) -> c_int;\n-        }\n-        unsafe {\n-            strerror_r(errnum, buf, buflen)\n-        }\n-    }\n-\n-    // GNU libc provides a non-compliant version of strerror_r by default\n-    // and requires macros to instead use the POSIX compliant variant.\n-    // So we just use __xpg_strerror_r which is always POSIX compliant\n     #[cfg(target_os = \"linux\")]\n-    fn strerror_r(errnum: c_int, buf: *mut c_char,\n-                  buflen: libc::size_t) -> c_int {\n-        extern {\n-            fn __xpg_strerror_r(errnum: c_int,\n-                                buf: *mut c_char,\n-                                buflen: libc::size_t)\n-                                -> c_int;\n-        }\n-        unsafe {\n-            __xpg_strerror_r(errnum, buf, buflen)\n-        }\n+    extern {\n+        #[link_name = \"__xpg_strerror_r\"]\n+        fn strerror_r(errnum: c_int, buf: *mut c_char,\n+                      buflen: libc::size_t) -> c_int;\n+    }\n+    #[cfg(not(target_os = \"linux\"))]\n+    extern {\n+        fn strerror_r(errnum: c_int, buf: *mut c_char,\n+                      buflen: libc::size_t) -> c_int;\n     }\n \n     let mut buf = [0 as c_char; TMPBUF_SZ];\n@@ -113,15 +84,6 @@ pub fn error_string(errno: i32) -> String {\n     }\n }\n \n-pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n-    let mut fds = [0; 2];\n-    if libc::pipe(fds.as_mut_ptr()) == 0 {\n-        Ok((FileDesc::new(fds[0], true), FileDesc::new(fds[1], true)))\n-    } else {\n-        Err(super::last_error())\n-    }\n-}\n-\n pub fn getcwd() -> IoResult<Path> {\n     let mut buf = [0 as c_char; BUF_BYTES];\n     unsafe {\n@@ -133,43 +95,69 @@ pub fn getcwd() -> IoResult<Path> {\n     }\n }\n \n-pub unsafe fn get_env_pairs() -> Vec<Vec<u8>> {\n-    extern {\n-        fn rust_env_pairs() -> *const *const c_char;\n-    }\n-    let mut environ = rust_env_pairs();\n-    if environ as uint == 0 {\n-        panic!(\"os::env() failure getting env string from OS: {}\",\n-               os::last_os_error());\n+pub fn chdir(p: &Path) -> IoResult<()> {\n+    let p = CString::from_slice(p.as_vec());\n+    unsafe {\n+        match libc::chdir(p.as_ptr()) == (0 as c_int) {\n+            true => Ok(()),\n+            false => Err(IoError::last_error()),\n+        }\n     }\n-    let mut result = Vec::new();\n-    while *environ != ptr::null() {\n-        let env_pair = ffi::c_str_to_bytes(&*environ).to_vec();\n-        result.push(env_pair);\n-        environ = environ.offset(1);\n+}\n+\n+pub struct SplitPaths<'a> {\n+    iter: iter::Map<&'a [u8], Path,\n+                    slice::Split<'a, u8, fn(&u8) -> bool>,\n+                    fn(&'a [u8]) -> Path>,\n+}\n+\n+pub fn split_paths<'a>(unparsed: &'a OsStr) -> SplitPaths<'a> {\n+    fn is_colon(b: &u8) -> bool { *b == b':' }\n+    let unparsed = unparsed.as_byte_slice();\n+    SplitPaths {\n+        iter: unparsed.split(is_colon as fn(&u8) -> bool)\n+                      .map(Path::new as fn(&'a [u8]) ->  Path)\n     }\n-    result\n }\n \n-pub fn split_paths(unparsed: &[u8]) -> Vec<Path> {\n-    unparsed.split(|b| *b == b':').map(Path::new).collect()\n+impl<'a> Iterator for SplitPaths<'a> {\n+    type Item = Path;\n+    fn next(&mut self) -> Option<Path> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n-pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n+#[derive(Debug)]\n+pub struct JoinPathsError;\n+\n+pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n+    where I: Iterator<Item=T>, T: AsOsStr\n+{\n     let mut joined = Vec::new();\n     let sep = b':';\n \n-    for (i, path) in paths.iter().map(|p| p.container_as_bytes()).enumerate() {\n+    for (i, path) in paths.enumerate() {\n+        let path = path.as_os_str().as_byte_slice();\n         if i > 0 { joined.push(sep) }\n-        if path.contains(&sep) { return Err(\"path segment contains separator `:`\") }\n+        if path.contains(&sep) {\n+            return Err(JoinPathsError)\n+        }\n         joined.push_all(path);\n     }\n+    Ok(OsStringExt::from_vec(joined))\n+}\n \n-    Ok(joined)\n+impl fmt::Display for JoinPathsError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"path segment contains separator `:`\".fmt(f)\n+    }\n+}\n+\n+impl StdError for JoinPathsError {\n+    fn description(&self) -> &str { \"failed to join paths\" }\n }\n \n #[cfg(target_os = \"freebsd\")]\n-pub fn load_self() -> Option<Vec<u8>> {\n+pub fn current_exe() -> IoResult<Path> {\n     unsafe {\n         use libc::funcs::bsd44::*;\n         use libc::consts::os::extra::*;\n@@ -181,66 +169,276 @@ pub fn load_self() -> Option<Vec<u8>> {\n         let err = sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n                          ptr::null_mut(), &mut sz, ptr::null_mut(),\n                          0u as libc::size_t);\n-        if err != 0 { return None; }\n-        if sz == 0 { return None; }\n+        if err != 0 { return Err(IoError::last_error()); }\n+        if sz == 0 { return Err(IoError::last_error()); }\n         let mut v: Vec<u8> = Vec::with_capacity(sz as uint);\n         let err = sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n                          v.as_mut_ptr() as *mut libc::c_void, &mut sz,\n                          ptr::null_mut(), 0u as libc::size_t);\n-        if err != 0 { return None; }\n-        if sz == 0 { return None; }\n+        if err != 0 { return Err(IoError::last_error()); }\n+        if sz == 0 { return Err(IoError::last_error()); }\n         v.set_len(sz as uint - 1); // chop off trailing NUL\n-        Some(v)\n+        Ok(Path::new(v))\n     }\n }\n \n #[cfg(target_os = \"dragonfly\")]\n-pub fn load_self() -> Option<Vec<u8>> {\n-    use old_io;\n-\n-    match old_io::fs::readlink(&Path::new(\"/proc/curproc/file\")) {\n-        Ok(path) => Some(path.into_vec()),\n-        Err(..) => None\n-    }\n+pub fn current_exe() -> IoResult<Path> {\n+    fs::readlink(&Path::new(\"/proc/curproc/file\"))\n }\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-pub fn load_self() -> Option<Vec<u8>> {\n-    use old_io;\n-\n-    match old_io::fs::readlink(&Path::new(\"/proc/self/exe\")) {\n-        Ok(path) => Some(path.into_vec()),\n-        Err(..) => None\n-    }\n+pub fn current_exe() -> IoResult<Path> {\n+    fs::readlink(&Path::new(\"/proc/self/exe\"))\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-pub fn load_self() -> Option<Vec<u8>> {\n+pub fn current_exe() -> IoResult<Path> {\n     unsafe {\n         use libc::funcs::extra::_NSGetExecutablePath;\n         let mut sz: u32 = 0;\n         _NSGetExecutablePath(ptr::null_mut(), &mut sz);\n-        if sz == 0 { return None; }\n+        if sz == 0 { return Err(IoError::last_error()); }\n         let mut v: Vec<u8> = Vec::with_capacity(sz as uint);\n         let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n-        if err != 0 { return None; }\n+        if err != 0 { return Err(IoError::last_error()); }\n         v.set_len(sz as uint - 1); // chop off trailing NUL\n-        Some(v)\n+        Ok(Path::new(v))\n     }\n }\n \n-pub fn chdir(p: &Path) -> IoResult<()> {\n-    let p = CString::from_slice(p.as_vec());\n+pub struct Args {\n+    iter: vec::IntoIter<OsString>,\n+    _dont_send_or_sync_me: *mut (),\n+}\n+\n+impl Iterator for Args {\n+    type Item = OsString;\n+    fn next(&mut self) -> Option<OsString> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+/// Returns the command line arguments\n+///\n+/// Returns a list of the command line arguments.\n+#[cfg(target_os = \"macos\")]\n+pub fn args() -> Args {\n+    extern {\n+        // These functions are in crt_externs.h.\n+        fn _NSGetArgc() -> *mut c_int;\n+        fn _NSGetArgv() -> *mut *mut *mut c_char;\n+    }\n+\n+    let vec = unsafe {\n+        let (argc, argv) = (*_NSGetArgc() as isize,\n+                            *_NSGetArgv() as *const *const c_char);\n+        range(0, argc as isize).map(|i| {\n+            let bytes = ffi::c_str_to_bytes(&*argv.offset(i)).to_vec();\n+            OsStringExt::from_vec(bytes)\n+        }).collect::<Vec<_>>()\n+    };\n+    Args {\n+        iter: vec.into_iter(),\n+        _dont_send_or_sync_me: 0 as *mut (),\n+    }\n+}\n+\n+// As _NSGetArgc and _NSGetArgv aren't mentioned in iOS docs\n+// and use underscores in their names - they're most probably\n+// are considered private and therefore should be avoided\n+// Here is another way to get arguments using Objective C\n+// runtime\n+//\n+// In general it looks like:\n+// res = Vec::new()\n+// let args = [[NSProcessInfo processInfo] arguments]\n+// for i in range(0, [args count])\n+//      res.push([args objectAtIndex:i])\n+// res\n+#[cfg(target_os = \"ios\")]\n+pub fn args() -> Args {\n+    use iter::range;\n+    use mem;\n+\n+    #[link(name = \"objc\")]\n+    extern {\n+        fn sel_registerName(name: *const libc::c_uchar) -> Sel;\n+        fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;\n+        fn objc_getClass(class_name: *const libc::c_uchar) -> NsId;\n+    }\n+\n+    #[link(name = \"Foundation\", kind = \"framework\")]\n+    extern {}\n+\n+    type Sel = *const libc::c_void;\n+    type NsId = *const libc::c_void;\n+\n+    let mut res = Vec::new();\n+\n     unsafe {\n-        match libc::chdir(p.as_ptr()) == (0 as c_int) {\n-            true => Ok(()),\n-            false => Err(IoError::last_error()),\n+        let processInfoSel = sel_registerName(\"processInfo\\0\".as_ptr());\n+        let argumentsSel = sel_registerName(\"arguments\\0\".as_ptr());\n+        let utf8Sel = sel_registerName(\"UTF8String\\0\".as_ptr());\n+        let countSel = sel_registerName(\"count\\0\".as_ptr());\n+        let objectAtSel = sel_registerName(\"objectAtIndex:\\0\".as_ptr());\n+\n+        let klass = objc_getClass(\"NSProcessInfo\\0\".as_ptr());\n+        let info = objc_msgSend(klass, processInfoSel);\n+        let args = objc_msgSend(info, argumentsSel);\n+\n+        let cnt: int = mem::transmute(objc_msgSend(args, countSel));\n+        for i in range(0, cnt) {\n+            let tmp = objc_msgSend(args, objectAtSel, i);\n+            let utf_c_str: *const libc::c_char =\n+                mem::transmute(objc_msgSend(tmp, utf8Sel));\n+            let bytes = ffi::c_str_to_bytes(&utf_c_str).to_vec();\n+            res.push(OsString::from_vec(bytes))\n+        }\n+    }\n+\n+    Args { iter: res.into_iter(), _dont_send_or_sync_me: 0 as *mut _ }\n+}\n+\n+#[cfg(any(target_os = \"linux\",\n+          target_os = \"android\",\n+          target_os = \"freebsd\",\n+          target_os = \"dragonfly\"))]\n+pub fn args() -> Args {\n+    use rt;\n+    let bytes = rt::args::clone().unwrap_or(Vec::new());\n+    let v: Vec<OsString> = bytes.into_iter().map(|v| {\n+        OsStringExt::from_vec(v)\n+    }).collect();\n+    Args { iter: v.into_iter(), _dont_send_or_sync_me: 0 as *mut _ }\n+}\n+\n+pub struct Env {\n+    iter: vec::IntoIter<(OsString, OsString)>,\n+    _dont_send_or_sync_me: *mut (),\n+}\n+\n+impl Iterator for Env {\n+    type Item = (OsString, OsString);\n+    fn next(&mut self) -> Option<(OsString, OsString)> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+pub unsafe fn environ() -> *mut *const *const c_char {\n+    extern { fn _NSGetEnviron() -> *mut *const *const c_char; }\n+    _NSGetEnviron()\n+}\n+\n+#[cfg(not(target_os = \"macos\"))]\n+pub unsafe fn environ() -> *mut *const *const c_char {\n+    extern { static mut environ: *const *const c_char; }\n+    &mut environ\n+}\n+\n+/// Returns a vector of (variable, value) byte-vector pairs for all the\n+/// environment variables of the current process.\n+pub fn env() -> Env {\n+    return unsafe {\n+        let mut environ = *environ();\n+        if environ as usize == 0 {\n+            panic!(\"os::env() failure getting env string from OS: {}\",\n+                   IoError::last_error());\n+        }\n+        let mut result = Vec::new();\n+        while *environ != ptr::null() {\n+            result.push(parse(ffi::c_str_to_bytes(&*environ)));\n+            environ = environ.offset(1);\n+        }\n+        Env { iter: result.into_iter(), _dont_send_or_sync_me: 0 as *mut _ }\n+    };\n+\n+    fn parse(input: &[u8]) -> (OsString, OsString) {\n+        let mut it = input.splitn(1, |b| *b == b'=');\n+        let key = it.next().unwrap().to_vec();\n+        let default: &[u8] = &[];\n+        let val = it.next().unwrap_or(default).to_vec();\n+        (OsStringExt::from_vec(key), OsStringExt::from_vec(val))\n+    }\n+}\n+\n+pub fn getenv(k: &OsStr) -> Option<OsString> {\n+    unsafe {\n+        let s = CString::from_slice(k.as_byte_slice());\n+        let s = libc::getenv(s.as_ptr()) as *const _;\n+        if s.is_null() {\n+            None\n+        } else {\n+            Some(OsStringExt::from_vec(ffi::c_str_to_bytes(&s).to_vec()))\n+        }\n+    }\n+}\n+\n+pub fn setenv(k: &OsStr, v: &OsStr) {\n+    unsafe {\n+        let k = CString::from_slice(k.as_byte_slice());\n+        let v = CString::from_slice(v.as_byte_slice());\n+        if libc::funcs::posix01::unistd::setenv(k.as_ptr(), v.as_ptr(), 1) != 0 {\n+            panic!(\"failed setenv: {}\", IoError::last_error());\n+        }\n+    }\n+}\n+\n+pub fn unsetenv(n: &OsStr) {\n+    unsafe {\n+        let nbuf = CString::from_slice(n.as_byte_slice());\n+        if libc::funcs::posix01::unistd::unsetenv(nbuf.as_ptr()) != 0 {\n+            panic!(\"failed unsetenv: {}\", IoError::last_error());\n         }\n     }\n }\n \n-pub fn page_size() -> uint {\n+pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n+    let mut fds = [0; 2];\n+    if libc::pipe(fds.as_mut_ptr()) == 0 {\n+        Ok((FileDesc::new(fds[0], true), FileDesc::new(fds[1], true)))\n+    } else {\n+        Err(IoError::last_error())\n+    }\n+}\n+\n+pub fn page_size() -> usize {\n     unsafe {\n-        libc::sysconf(libc::_SC_PAGESIZE) as uint\n+        libc::sysconf(libc::_SC_PAGESIZE) as usize\n     }\n }\n+\n+pub fn temp_dir() -> Path {\n+    getenv(\"TMPDIR\".as_os_str()).map(|p| Path::new(p.into_vec())).unwrap_or_else(|| {\n+        if cfg!(target_os = \"android\") {\n+            Path::new(\"/data/local/tmp\")\n+        } else {\n+            Path::new(\"/tmp\")\n+        }\n+    })\n+}\n+\n+pub fn home_dir() -> Option<Path> {\n+    getenv(\"HOME\".as_os_str()).or_else(|| unsafe {\n+        let mut amt = match libc::sysconf(c::_SC_GETPW_R_SIZE_MAX) {\n+            n if n < 0 => 512 as usize,\n+            n => n as usize,\n+        };\n+        let me = libc::getuid();\n+        loop {\n+            let mut buf = Vec::with_capacity(amt);\n+            let mut passwd: c::passwd = mem::zeroed();\n+            let mut result = 0 as *mut _;\n+            match c::getpwuid_r(me, &mut passwd, buf.as_mut_ptr(),\n+                                buf.capacity() as libc::size_t,\n+                                &mut result) {\n+                0 if !result.is_null() => {}\n+                _ => return None\n+            }\n+            let ptr = passwd.pw_dir as *const _;\n+            let bytes = ffi::c_str_to_bytes(&ptr).to_vec();\n+            return Some(OsStringExt::from_vec(bytes))\n+        }\n+    }).map(|os| {\n+        Path::new(os.into_vec())\n+    })\n+}"}, {"sha": "ae648d13959f952311bc59f0754d363807e81f08", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -72,18 +72,6 @@ impl Process {\n             }\n         }\n \n-        #[cfg(target_os = \"macos\")]\n-        unsafe fn set_environ(envp: *const c_void) {\n-            extern { fn _NSGetEnviron() -> *mut *const c_void; }\n-\n-            *_NSGetEnviron() = envp;\n-        }\n-        #[cfg(not(target_os = \"macos\"))]\n-        unsafe fn set_environ(envp: *const c_void) {\n-            extern { static mut environ: *const c_void; }\n-            environ = envp;\n-        }\n-\n         unsafe fn set_cloexec(fd: c_int) {\n             let ret = c::ioctl(fd, c::FIOCLEX);\n             assert_eq!(ret, 0);\n@@ -269,7 +257,7 @@ impl Process {\n                     fail(&mut output);\n                 }\n                 if !envp.is_null() {\n-                    set_environ(envp);\n+                    *sys::os::environ() = envp as *const _;\n                 }\n                 let _ = execvp(*argv, argv as *mut _);\n                 fail(&mut output);"}, {"sha": "66712b9e3a1e6e6edfbd0bd50a0b3821b46fb555", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -7,29 +7,31 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-/// As always, windows has something very different than unix, we mainly want\n-/// to avoid having to depend too much on libunwind for windows.\n-///\n-/// If you google around, you'll find a fair bit of references to built-in\n-/// functions to get backtraces on windows. It turns out that most of these are\n-/// in an external library called dbghelp. I was unable to find this library\n-/// via `-ldbghelp`, but it is apparently normal to do the `dlopen` equivalent\n-/// of it.\n-///\n-/// You'll also find that there's a function called CaptureStackBackTrace\n-/// mentioned frequently (which is also easy to use), but sadly I didn't have a\n-/// copy of that function in my mingw install (maybe it was broken?). Instead,\n-/// this takes the route of using StackWalk64 in order to walk the stack.\n+\n+//! As always, windows has something very different than unix, we mainly want\n+//! to avoid having to depend too much on libunwind for windows.\n+//!\n+//! If you google around, you'll find a fair bit of references to built-in\n+//! functions to get backtraces on windows. It turns out that most of these are\n+//! in an external library called dbghelp. I was unable to find this library\n+//! via `-ldbghelp`, but it is apparently normal to do the `dlopen` equivalent\n+//! of it.\n+//!\n+//! You'll also find that there's a function called CaptureStackBackTrace\n+//! mentioned frequently (which is also easy to use), but sadly I didn't have a\n+//! copy of that function in my mingw install (maybe it was broken?). Instead,\n+//! this takes the route of using StackWalk64 in order to walk the stack.\n+\n+#![allow(dead_code)]\n \n use dynamic_lib::DynamicLibrary;\n use ffi;\n-use core::ops::Index;\n use intrinsics;\n use old_io::{IoResult, Writer};\n use libc;\n use mem;\n use ops::Drop;\n-use option::Option::{Some, None};\n+use option::Option::{Some};\n use path::Path;\n use ptr;\n use result::Result::{Ok, Err};\n@@ -296,7 +298,7 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n     // According to windows documentation, all dbghelp functions are\n     // single-threaded.\n     static LOCK: StaticMutex = MUTEX_INIT;\n-    let _g = unsafe { LOCK.lock() };\n+    let _g = LOCK.lock();\n \n     // Open up dbghelp.dll, we don't link to it explicitly because it can't\n     // always be found. Additionally, it's nice having fewer dependencies."}, {"sha": "0355565cf00f29d9b52c912b0f144eeba68b3b25", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 150, "deletions": 40, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -10,17 +10,21 @@\n \n //! C definitions used by libnative that don't belong in liblibc\n \n-#![allow(overflowing_literals)]\n-#![allow(dead_code)]\n-#![allow(non_camel_case_types)]\n+#![allow(bad_style, dead_code, overflowing_literals)]\n \n use libc;\n-use prelude::v1::*;\n \n-pub const WSADESCRIPTION_LEN: uint = 256;\n-pub const WSASYS_STATUS_LEN: uint = 128;\n+pub use self::GET_FILEEX_INFO_LEVELS::*;\n+pub use self::FILE_INFO_BY_HANDLE_CLASS::*;\n+pub use libc::consts::os::extra::{\n+    FILE_ATTRIBUTE_READONLY,\n+    FILE_ATTRIBUTE_DIRECTORY,\n+};\n+\n+pub const WSADESCRIPTION_LEN: usize = 256;\n+pub const WSASYS_STATUS_LEN: usize = 128;\n pub const FIONBIO: libc::c_long = 0x8004667e;\n-pub const FD_SETSIZE: uint = 64;\n+pub const FD_SETSIZE: usize = 64;\n pub const MSG_DONTWAIT: libc::c_int = 0;\n pub const ERROR_ILLEGAL_CHARACTER: libc::c_int = 582;\n pub const ENABLE_ECHO_INPUT: libc::DWORD = 0x4;\n@@ -32,12 +36,15 @@ pub const ENABLE_QUICK_EDIT_MODE: libc::DWORD = 0x40;\n pub const WSA_INVALID_EVENT: WSAEVENT = 0 as WSAEVENT;\n \n pub const FD_ACCEPT: libc::c_long = 0x08;\n-pub const FD_MAX_EVENTS: uint = 10;\n+pub const FD_MAX_EVENTS: usize = 10;\n pub const WSA_INFINITE: libc::DWORD = libc::INFINITE;\n pub const WSA_WAIT_TIMEOUT: libc::DWORD = libc::consts::os::extra::WAIT_TIMEOUT;\n pub const WSA_WAIT_EVENT_0: libc::DWORD = libc::consts::os::extra::WAIT_OBJECT_0;\n pub const WSA_WAIT_FAILED: libc::DWORD = libc::consts::os::extra::WAIT_FAILED;\n \n+pub const ERROR_NO_MORE_FILES: libc::DWORD = 18;\n+pub const TOKEN_READ: libc::DWORD = 0x20008;\n+\n #[repr(C)]\n #[cfg(target_arch = \"x86\")]\n pub struct WSADATA {\n@@ -80,7 +87,7 @@ pub struct fd_set {\n }\n \n pub fn fd_set(set: &mut fd_set, s: libc::SOCKET) {\n-    set.fd_array[set.fd_count as uint] = s;\n+    set.fd_array[set.fd_count as usize] = s;\n     set.fd_count += 1;\n }\n \n@@ -110,6 +117,69 @@ pub struct CONSOLE_SCREEN_BUFFER_INFO {\n }\n pub type PCONSOLE_SCREEN_BUFFER_INFO = *mut CONSOLE_SCREEN_BUFFER_INFO;\n \n+#[repr(C)]\n+pub struct WIN32_FILE_ATTRIBUTE_DATA {\n+    pub dwFileAttributes: libc::DWORD,\n+    pub ftCreationTime: libc::FILETIME,\n+    pub ftLastAccessTime: libc::FILETIME,\n+    pub ftLastWriteTime: libc::FILETIME,\n+    pub nFileSizeHigh: libc::DWORD,\n+    pub nFileSizeLow: libc::DWORD,\n+}\n+\n+#[repr(C)]\n+pub struct BY_HANDLE_FILE_INFORMATION {\n+    pub dwFileAttributes: libc::DWORD,\n+    pub ftCreationTime: libc::FILETIME,\n+    pub ftLastAccessTime: libc::FILETIME,\n+    pub ftLastWriteTime: libc::FILETIME,\n+    pub dwVolumeSerialNumber: libc::DWORD,\n+    pub nFileSizeHigh: libc::DWORD,\n+    pub nFileSizeLow: libc::DWORD,\n+    pub nNumberOfLinks: libc::DWORD,\n+    pub nFileIndexHigh: libc::DWORD,\n+    pub nFileIndexLow: libc::DWORD,\n+}\n+\n+pub type LPBY_HANDLE_FILE_INFORMATION = *mut BY_HANDLE_FILE_INFORMATION;\n+\n+#[repr(C)]\n+pub enum GET_FILEEX_INFO_LEVELS {\n+    GetFileExInfoStandard,\n+    GetFileExMaxInfoLevel\n+}\n+\n+#[repr(C)]\n+pub enum FILE_INFO_BY_HANDLE_CLASS {\n+    FileBasicInfo                   = 0,\n+    FileStandardInfo                = 1,\n+    FileNameInfo                    = 2,\n+    FileRenameInfo                  = 3,\n+    FileDispositionInfo             = 4,\n+    FileAllocationInfo              = 5,\n+    FileEndOfFileInfo               = 6,\n+    FileStreamInfo                  = 7,\n+    FileCompressionInfo             = 8,\n+    FileAttributeTagInfo            = 9,\n+    FileIdBothDirectoryInfo         = 10, // 0xA\n+    FileIdBothDirectoryRestartInfo  = 11, // 0xB\n+    FileIoPriorityHintInfo          = 12, // 0xC\n+    FileRemoteProtocolInfo          = 13, // 0xD\n+    FileFullDirectoryInfo           = 14, // 0xE\n+    FileFullDirectoryRestartInfo    = 15, // 0xF\n+    FileStorageInfo                 = 16, // 0x10\n+    FileAlignmentInfo               = 17, // 0x11\n+    FileIdInfo                      = 18, // 0x12\n+    FileIdExtdDirectoryInfo         = 19, // 0x13\n+    FileIdExtdDirectoryRestartInfo  = 20, // 0x14\n+    MaximumFileInfoByHandlesClass\n+}\n+\n+#[repr(C)]\n+pub struct FILE_END_OF_FILE_INFO {\n+    pub EndOfFile: libc::LARGE_INTEGER,\n+}\n+\n #[link(name = \"ws2_32\")]\n extern \"system\" {\n     pub fn WSAStartup(wVersionRequested: libc::WORD,\n@@ -156,31 +226,29 @@ extern \"system\" {\n }\n \n pub mod compat {\n-    use intrinsics::{atomic_store_relaxed, transmute};\n-    use libc::types::os::arch::extra::{LPCWSTR, HMODULE, LPCSTR, LPVOID};\n     use prelude::v1::*;\n+\n     use ffi::CString;\n+    use libc::types::os::arch::extra::{LPCWSTR, HMODULE, LPCSTR, LPVOID};\n+    use sync::atomic::{AtomicUsize, Ordering};\n \n     extern \"system\" {\n         fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n         fn GetProcAddress(hModule: HMODULE, lpProcName: LPCSTR) -> LPVOID;\n     }\n \n-    // store_func() is idempotent, so using relaxed ordering for the atomics\n-    // should be enough.  This way, calling a function in this compatibility\n-    // layer (after it's loaded) shouldn't be any slower than a regular DLL\n-    // call.\n-    unsafe fn store_func(ptr: *mut uint, module: &str, symbol: &str, fallback: uint) {\n+    fn store_func(ptr: &AtomicUsize, module: &str, symbol: &str,\n+                  fallback: usize) -> usize {\n         let mut module: Vec<u16> = module.utf16_units().collect();\n         module.push(0);\n         let symbol = CString::from_slice(symbol.as_bytes());\n-        let handle = GetModuleHandleW(module.as_ptr());\n-        let func: uint = transmute(GetProcAddress(handle, symbol.as_ptr()));\n-        atomic_store_relaxed(ptr, if func == 0 {\n-            fallback\n-        } else {\n-            func\n-        })\n+        let func = unsafe {\n+            let handle = GetModuleHandleW(module.as_ptr());\n+            GetProcAddress(handle, symbol.as_ptr()) as usize\n+        };\n+        let value = if func == 0 {fallback} else {func};\n+        ptr.store(value, Ordering::SeqCst);\n+        value\n     }\n \n     /// Macro for creating a compatibility fallback for a Windows function\n@@ -192,29 +260,36 @@ pub mod compat {\n     /// })\n     /// ```\n     ///\n-    /// Note that arguments unused by the fallback implementation should not be called `_` as\n-    /// they are used to be passed to the real function if available.\n+    /// Note that arguments unused by the fallback implementation should not be\n+    /// called `_` as they are used to be passed to the real function if\n+    /// available.\n     macro_rules! compat_fn {\n         ($module:ident::$symbol:ident($($argname:ident: $argtype:ty),*)\n                                       -> $rettype:ty { $fallback:expr }) => (\n             #[inline(always)]\n             pub unsafe fn $symbol($($argname: $argtype),*) -> $rettype {\n-                static mut ptr: extern \"system\" fn($($argname: $argtype),*) -> $rettype = thunk;\n-\n-                extern \"system\" fn thunk($($argname: $argtype),*) -> $rettype {\n-                    unsafe {\n-                        ::sys::c::compat::store_func(&mut ptr as *mut _ as *mut uint,\n-                                                    stringify!($module),\n-                                                    stringify!($symbol),\n-                                                    fallback as uint);\n-                        ::intrinsics::atomic_load_relaxed(&ptr)($($argname),*)\n-                    }\n+                use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+                use mem;\n+\n+                static PTR: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+                fn load() -> usize {\n+                    ::sys::c::compat::store_func(&PTR,\n+                                                 stringify!($module),\n+                                                 stringify!($symbol),\n+                                                 fallback as usize)\n                 }\n \n                 extern \"system\" fn fallback($($argname: $argtype),*)\n                                             -> $rettype { $fallback }\n \n-                ::intrinsics::atomic_load_relaxed(&ptr)($($argname),*)\n+                let addr = match PTR.load(Ordering::SeqCst) {\n+                    0 => load(),\n+                    n => n,\n+                };\n+                let f: extern \"system\" fn($($argtype),*) -> $rettype =\n+                    mem::transmute(addr);\n+                f($($argname),*)\n             }\n         )\n     }\n@@ -229,10 +304,7 @@ pub mod compat {\n         use libc::c_uint;\n         use libc::types::os::arch::extra::{DWORD, LPCWSTR, BOOLEAN, HANDLE};\n         use libc::consts::os::extra::ERROR_CALL_NOT_IMPLEMENTED;\n-\n-        extern \"system\" {\n-            fn SetLastError(dwErrCode: DWORD);\n-        }\n+        use sys::c::SetLastError;\n \n         compat_fn! {\n             kernel32::CreateSymbolicLinkW(_lpSymlinkFileName: LPCWSTR,\n@@ -282,4 +354,42 @@ extern \"system\" {\n         hConsoleOutput: libc::HANDLE,\n         lpConsoleScreenBufferInfo: PCONSOLE_SCREEN_BUFFER_INFO,\n     ) -> libc::BOOL;\n+\n+    pub fn GetFileAttributesExW(lpFileName: libc::LPCWSTR,\n+                                fInfoLevelId: GET_FILEEX_INFO_LEVELS,\n+                                lpFileInformation: libc::LPVOID) -> libc::BOOL;\n+    pub fn RemoveDirectoryW(lpPathName: libc::LPCWSTR) -> libc::BOOL;\n+    pub fn SetFileAttributesW(lpFileName: libc::LPCWSTR,\n+                              dwFileAttributes: libc::DWORD) -> libc::BOOL;\n+    pub fn GetFileAttributesW(lpFileName: libc::LPCWSTR) -> libc::DWORD;\n+    pub fn GetFileInformationByHandle(hFile: libc::HANDLE,\n+                            lpFileInformation: LPBY_HANDLE_FILE_INFORMATION)\n+                            -> libc::BOOL;\n+\n+    pub fn SetLastError(dwErrCode: libc::DWORD);\n+    pub fn GetCommandLineW() -> *mut libc::LPCWSTR;\n+    pub fn LocalFree(ptr: *mut libc::c_void);\n+    pub fn CommandLineToArgvW(lpCmdLine: *mut libc::LPCWSTR,\n+                              pNumArgs: *mut libc::c_int) -> *mut *mut u16;\n+    pub fn SetFileTime(hFile: libc::HANDLE,\n+                       lpCreationTime: *const libc::FILETIME,\n+                       lpLastAccessTime: *const libc::FILETIME,\n+                       lpLastWriteTime: *const libc::FILETIME) -> libc::BOOL;\n+    pub fn SetFileInformationByHandle(hFile: libc::HANDLE,\n+                    FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,\n+                    lpFileInformation: libc::LPVOID,\n+                    dwBufferSize: libc::DWORD) -> libc::BOOL;\n+    pub fn GetTempPathW(nBufferLength: libc::DWORD,\n+                        lpBuffer: libc::LPCWSTR) -> libc::DWORD;\n+    pub fn OpenProcessToken(ProcessHandle: libc::HANDLE,\n+                            DesiredAccess: libc::DWORD,\n+                            TokenHandle: *mut libc::HANDLE) -> libc::BOOL;\n+    pub fn GetCurrentProcess() -> libc::HANDLE;\n+}\n+\n+#[link(name = \"userenv\")]\n+extern \"system\" {\n+    pub fn GetUserProfileDirectoryW(hToken: libc::HANDLE,\n+                                    lpProfileDir: libc::LPCWSTR,\n+                                    lpcchSize: *mut libc::DWORD) -> libc::BOOL;\n }"}, {"sha": "304d7e015327960747c3fc6dbb0e413d4b5845fd", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -10,20 +10,15 @@\n \n //! Blocking Windows-based file I/O\n \n-use alloc::arc::Arc;\n use libc::{self, c_int};\n \n use mem;\n-use sys::os::fill_utf16_buf_and_decode;\n-use path;\n use ptr;\n-use str;\n use old_io;\n \n use prelude::v1::*;\n use sys;\n-use sys::os;\n-use sys_common::{keep_going, eof, mkerr_libc};\n+use sys_common::{mkerr_libc};\n \n use old_io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n use old_io::{IoResult, IoError, FileStat, SeekStyle};\n@@ -262,7 +257,7 @@ pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n             let mut more_files = 1 as libc::BOOL;\n             while more_files != 0 {\n                 {\n-                    let filename = os::truncate_utf16_at_nul(&wfd.cFileName);\n+                    let filename = super::truncate_utf16_at_nul(&wfd.cFileName);\n                     match String::from_utf16(filename) {\n                         Ok(filename) => paths.push(Path::new(filename)),\n                         Err(..) => {\n@@ -368,19 +363,12 @@ pub fn readlink(p: &Path) -> IoResult<Path> {\n     }\n     // Specify (sz - 1) because the documentation states that it's the size\n     // without the null pointer\n-    let ret = fill_utf16_buf_and_decode(|buf, sz| unsafe {\n+    let ret = super::fill_utf16_buf(|buf, sz| unsafe {\n         GetFinalPathNameByHandleW(handle,\n                                   buf as *const u16,\n                                   sz - 1,\n                                   libc::VOLUME_NAME_DOS)\n-    });\n-    let ret = match ret {\n-        Some(ref s) if s.starts_with(r\"\\\\?\\\") => { // \"\n-            Ok(Path::new(&s[4..]))\n-        }\n-        Some(s) => Ok(Path::new(s)),\n-        None => Err(super::last_error()),\n-    };\n+    }, super::os2path);\n     assert!(unsafe { libc::CloseHandle(handle) } != 0);\n     return ret;\n }"}, {"sha": "6737eeef12532604554536076e75b641197bdd69", "filename": "src/libstd/sys/windows/handle.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use libc::{self, HANDLE};\n+\n+pub struct Handle(HANDLE);\n+\n+unsafe impl Send for Handle {}\n+unsafe impl Sync for Handle {}\n+\n+impl Handle {\n+    pub fn new(handle: HANDLE) -> Handle {\n+        Handle(handle)\n+    }\n+}\n+\n+impl Drop for Handle {\n+    fn drop(&mut self) {\n+        unsafe { let _ = libc::CloseHandle(self.0); }\n+    }\n+}\n+"}, {"sha": "8dd467eba9e2a885e5ffff07ee34ec4d28d08e26", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 92, "deletions": 19, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -11,18 +11,14 @@\n #![allow(missing_docs)]\n #![allow(non_camel_case_types)]\n #![allow(non_snake_case)]\n-#![allow(unused_imports)]\n-#![allow(dead_code)]\n-#![allow(unused_unsafe)]\n-#![allow(unused_mut)]\n-\n-extern crate libc;\n \n use prelude::v1::*;\n \n-use num;\n+use ffi::OsStr;\n+use libc;\n use mem;\n use old_io::{self, IoResult, IoError};\n+use os::windows::OsStrExt;\n use sync::{Once, ONCE_INIT};\n \n macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n@@ -38,22 +34,23 @@ macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n \n pub mod backtrace;\n pub mod c;\n-pub mod ext;\n pub mod condvar;\n+pub mod ext;\n pub mod fs;\n+pub mod handle;\n pub mod helper_signal;\n pub mod mutex;\n pub mod os;\n pub mod os_str;\n pub mod pipe;\n pub mod process;\n pub mod rwlock;\n-pub mod sync;\n pub mod stack_overflow;\n+pub mod sync;\n pub mod tcp;\n-pub mod time;\n pub mod thread;\n pub mod thread_local;\n+pub mod time;\n pub mod timer;\n pub mod tty;\n pub mod udp;\n@@ -158,7 +155,7 @@ pub fn ms_to_timeval(ms: u64) -> libc::timeval {\n \n pub fn wouldblock() -> bool {\n     let err = os::errno();\n-    err == libc::WSAEWOULDBLOCK as uint\n+    err == libc::WSAEWOULDBLOCK as i32\n }\n \n pub fn set_nonblocking(fd: sock_t, nb: bool) -> IoResult<()> {\n@@ -191,17 +188,93 @@ pub fn unimpl() -> IoError {\n     }\n }\n \n-pub fn to_utf16(s: Option<&str>) -> IoResult<Vec<u16>> {\n+fn to_utf16(s: Option<&str>) -> IoResult<Vec<u16>> {\n     match s {\n-        Some(s) => Ok({\n-            let mut s = s.utf16_units().collect::<Vec<u16>>();\n-            s.push(0);\n-            s\n-        }),\n+        Some(s) => Ok(to_utf16_os(OsStr::from_str(s))),\n         None => Err(IoError {\n             kind: old_io::InvalidInput,\n             desc: \"valid unicode input required\",\n-            detail: None\n-        })\n+            detail: None,\n+        }),\n+    }\n+}\n+\n+fn to_utf16_os(s: &OsStr) -> Vec<u16> {\n+    let mut v: Vec<_> = s.encode_wide().collect();\n+    v.push(0);\n+    v\n+}\n+\n+// Many Windows APIs follow a pattern of where we hand the a buffer and then\n+// they will report back to us how large the buffer should be or how many bytes\n+// currently reside in the buffer. This function is an abstraction over these\n+// functions by making them easier to call.\n+//\n+// The first callback, `f1`, is yielded a (pointer, len) pair which can be\n+// passed to a syscall. The `ptr` is valid for `len` items (u16 in this case).\n+// The closure is expected to return what the syscall returns which will be\n+// interpreted by this function to determine if the syscall needs to be invoked\n+// again (with more buffer space).\n+//\n+// Once the syscall has completed (errors bail out early) the second closure is\n+// yielded the data which has been read from the syscall. The return value\n+// from this closure is then the return value of the function.\n+fn fill_utf16_buf<F1, F2, T>(mut f1: F1, f2: F2) -> IoResult<T>\n+    where F1: FnMut(*mut u16, libc::DWORD) -> libc::DWORD,\n+          F2: FnOnce(&[u16]) -> T\n+{\n+    // Start off with a stack buf but then spill over to the heap if we end up\n+    // needing more space.\n+    let mut stack_buf = [0u16; 512];\n+    let mut heap_buf = Vec::new();\n+    unsafe {\n+        let mut n = stack_buf.len();\n+        loop {\n+            let buf = if n <= stack_buf.len() {\n+                &mut stack_buf[]\n+            } else {\n+                let extra = n - heap_buf.len();\n+                heap_buf.reserve(extra);\n+                heap_buf.set_len(n);\n+                &mut heap_buf[]\n+            };\n+\n+            // This function is typically called on windows API functions which\n+            // will return the correct length of the string, but these functions\n+            // also return the `0` on error. In some cases, however, the\n+            // returned \"correct length\" may actually be 0!\n+            //\n+            // To handle this case we call `SetLastError` to reset it to 0 and\n+            // then check it again if we get the \"0 error value\". If the \"last\n+            // error\" is still 0 then we interpret it as a 0 length buffer and\n+            // not an actual error.\n+            c::SetLastError(0);\n+            let k = match f1(buf.as_mut_ptr(), n as libc::DWORD) {\n+                0 if libc::GetLastError() == 0 => 0,\n+                0 => return Err(IoError::last_error()),\n+                n => n,\n+            } as usize;\n+            if k == n && libc::GetLastError() ==\n+                            libc::ERROR_INSUFFICIENT_BUFFER as libc::DWORD {\n+                n *= 2;\n+            } else if k >= n {\n+                n = k;\n+            } else {\n+                return Ok(f2(&buf[..k]))\n+            }\n+        }\n+    }\n+}\n+\n+fn os2path(s: &[u16]) -> Path {\n+    // FIXME: this should not be a panicking conversion (aka path reform)\n+    Path::new(String::from_utf16(s).unwrap())\n+}\n+\n+pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n+    match v.iter().position(|c| *c == 0) {\n+        // don't include the 0\n+        Some(i) => &v[..i],\n+        None => v\n     }\n }"}, {"sha": "75495efc7cbb60f9d2a7f12ffa78980f2540ab39", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -37,8 +37,6 @@ pub unsafe fn raw(m: &Mutex) -> ffi::PSRWLOCK {\n // no guarantees of fairness.\n \n impl Mutex {\n-    #[inline]\n-    pub unsafe fn new() -> Mutex { MUTEX_INIT }\n     #[inline]\n     pub unsafe fn lock(&self) {\n         ffi::AcquireSRWLockExclusive(self.inner.get())"}, {"sha": "c71e2d057c35117af1cea05e2506f25fdf2f075a", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 246, "deletions": 207, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -10,48 +10,32 @@\n \n //! Implementation of `std::os` functionality for Windows\n \n-// FIXME: move various extern bindings from here into liblibc or\n-// something similar\n+#![allow(bad_style)]\n \n use prelude::v1::*;\n+use os::windows::*;\n \n+use error::Error as StdError;\n+use ffi::{OsString, OsStr, AsOsStr};\n use fmt;\n-use old_io::{IoResult, IoError};\n-use iter::repeat;\n-use libc::{c_int, c_void};\n-use libc;\n-use os;\n-use path::BytesContainer;\n+use iter::Range;\n+use libc::types::os::arch::extra::LPWCH;\n+use libc::{self, c_int, c_void};\n+use mem;\n+use old_io::{IoError, IoResult};\n use ptr;\n use slice;\n+use sys::c;\n use sys::fs::FileDesc;\n+use sys::handle::Handle as RawHandle;\n \n-use os::TMPBUF_SZ;\n-use libc::types::os::arch::extra::DWORD;\n+use libc::funcs::extra::kernel32::{\n+    GetEnvironmentStringsW,\n+    FreeEnvironmentStringsW\n+};\n \n-const BUF_BYTES : uint = 2048u;\n-\n-/// Return a slice of `v` ending at (and not including) the first NUL\n-/// (0).\n-pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n-    match v.iter().position(|c| *c == 0) {\n-        // don't include the 0\n-        Some(i) => &v[..i],\n-        None => v\n-    }\n-}\n-\n-pub fn errno() -> uint {\n-    use libc::types::os::arch::extra::DWORD;\n-\n-    #[link_name = \"kernel32\"]\n-    extern \"system\" {\n-        fn GetLastError() -> DWORD;\n-    }\n-\n-    unsafe {\n-        GetLastError() as uint\n-    }\n+pub fn errno() -> i32 {\n+    unsafe { libc::GetLastError() as i32 }\n }\n \n /// Get a detailed string description for the given error number\n@@ -80,7 +64,7 @@ pub fn error_string(errnum: i32) -> String {\n     // MAKELANGID(LANG_SYSTEM_DEFAULT, SUBLANG_SYS_DEFAULT)\n     let langId = 0x0800 as DWORD;\n \n-    let mut buf = [0 as WCHAR; TMPBUF_SZ];\n+    let mut buf = [0 as WCHAR; 2048];\n \n     unsafe {\n         let res = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |\n@@ -94,200 +78,170 @@ pub fn error_string(errnum: i32) -> String {\n         if res == 0 {\n             // Sometimes FormatMessageW can fail e.g. system doesn't like langId,\n             let fm_err = errno();\n-            return format!(\"OS Error {} (FormatMessageW() returned error {})\", errnum, fm_err);\n+            return format!(\"OS Error {} (FormatMessageW() returned error {})\",\n+                           errnum, fm_err);\n         }\n \n-        let msg = String::from_utf16(truncate_utf16_at_nul(&buf));\n+        let b = buf.iter().position(|&b| b == 0).unwrap_or(buf.len());\n+        let msg = String::from_utf16(&buf[..b]);\n         match msg {\n-            Ok(msg) => format!(\"OS Error {}: {}\", errnum, msg),\n+            Ok(msg) => msg,\n             Err(..) => format!(\"OS Error {} (FormatMessageW() returned \\\n                                 invalid UTF-16)\", errnum),\n         }\n     }\n }\n \n-pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n-    // Windows pipes work subtly differently than unix pipes, and their\n-    // inheritance has to be handled in a different way that I do not\n-    // fully understand. Here we explicitly make the pipe non-inheritable,\n-    // which means to pass it to a subprocess they need to be duplicated\n-    // first, as in std::run.\n-    let mut fds = [0; 2];\n-    match libc::pipe(fds.as_mut_ptr(), 1024 as ::libc::c_uint,\n-                     (libc::O_BINARY | libc::O_NOINHERIT) as c_int) {\n-        0 => {\n-            assert!(fds[0] != -1 && fds[0] != 0);\n-            assert!(fds[1] != -1 && fds[1] != 0);\n-            Ok((FileDesc::new(fds[0], true), FileDesc::new(fds[1], true)))\n-        }\n-        _ => Err(IoError::last_error()),\n-    }\n+pub struct Env {\n+    base: LPWCH,\n+    cur: LPWCH,\n }\n \n-pub fn fill_utf16_buf_and_decode<F>(mut f: F) -> Option<String> where\n-    F: FnMut(*mut u16, DWORD) -> DWORD,\n-{\n-    unsafe {\n-        let mut n = TMPBUF_SZ as DWORD;\n-        let mut res = None;\n-        let mut done = false;\n-        while !done {\n-            let mut buf: Vec<u16> = repeat(0u16).take(n as uint).collect();\n-            let k = f(buf.as_mut_ptr(), n);\n-            if k == (0 as DWORD) {\n-                done = true;\n-            } else if k == n &&\n-                      libc::GetLastError() ==\n-                      libc::ERROR_INSUFFICIENT_BUFFER as DWORD {\n-                n *= 2 as DWORD;\n-            } else if k >= n {\n-                n = k;\n-            } else {\n-                done = true;\n-            }\n-            if k != 0 && done {\n-                let sub = &buf[.. (k as uint)];\n-                // We want to explicitly catch the case when the\n-                // closure returned invalid UTF-16, rather than\n-                // set `res` to None and continue.\n-                let s = String::from_utf16(sub).ok()\n-                    .expect(\"fill_utf16_buf_and_decode: closure created invalid UTF-16\");\n-                res = Some(s)\n+impl Iterator for Env {\n+    type Item = (OsString, OsString);\n+\n+    fn next(&mut self) -> Option<(OsString, OsString)> {\n+        unsafe {\n+            if *self.cur == 0 { return None }\n+            let p = &*self.cur;\n+            let mut len = 0;\n+            while *(p as *const _).offset(len) != 0 {\n+                len += 1;\n             }\n+            let p = p as *const u16;\n+            let s = slice::from_raw_buf(&p, len as usize);\n+            self.cur = self.cur.offset(len + 1);\n+\n+            let (k, v) = match s.iter().position(|&b| b == '=' as u16) {\n+                Some(n) => (&s[..n], &s[n+1..]),\n+                None => (s, &[][]),\n+            };\n+            Some((OsStringExt::from_wide(k), OsStringExt::from_wide(v)))\n         }\n-        return res;\n     }\n }\n \n-pub fn getcwd() -> IoResult<Path> {\n-    use libc::DWORD;\n-    use libc::GetCurrentDirectoryW;\n-    use old_io::OtherIoError;\n+impl Drop for Env {\n+    fn drop(&mut self) {\n+        unsafe { FreeEnvironmentStringsW(self.base); }\n+    }\n+}\n \n-    let mut buf = [0 as u16; BUF_BYTES];\n+pub fn env() -> Env {\n     unsafe {\n-        if libc::GetCurrentDirectoryW(buf.len() as DWORD, buf.as_mut_ptr()) == 0 as DWORD {\n-            return Err(IoError::last_error());\n+        let ch = GetEnvironmentStringsW();\n+        if ch as usize == 0 {\n+            panic!(\"failure getting env string from OS: {}\",\n+                   IoError::last_error());\n         }\n+        Env { base: ch, cur: ch }\n     }\n+}\n \n-    match String::from_utf16(truncate_utf16_at_nul(&buf)) {\n-        Ok(ref cwd) => Ok(Path::new(cwd)),\n-        Err(..) => Err(IoError {\n-            kind: OtherIoError,\n-            desc: \"GetCurrentDirectoryW returned invalid UTF-16\",\n-            detail: None,\n-        }),\n-    }\n+pub struct SplitPaths<'a> {\n+    data: EncodeWide<'a>,\n+    must_yield: bool,\n }\n \n-pub unsafe fn get_env_pairs() -> Vec<Vec<u8>> {\n-    use libc::funcs::extra::kernel32::{\n-        GetEnvironmentStringsW,\n-        FreeEnvironmentStringsW\n-    };\n-    let ch = GetEnvironmentStringsW();\n-    if ch as uint == 0 {\n-        panic!(\"os::env() failure getting env string from OS: {}\",\n-               os::last_os_error());\n+pub fn split_paths(unparsed: &OsStr) -> SplitPaths {\n+    SplitPaths {\n+        data: unparsed.encode_wide(),\n+        must_yield: true,\n     }\n-    // Here, we lossily decode the string as UTF16.\n-    //\n-    // The docs suggest that the result should be in Unicode, but\n-    // Windows doesn't guarantee it's actually UTF16 -- it doesn't\n-    // validate the environment string passed to CreateProcess nor\n-    // SetEnvironmentVariable.  Yet, it's unlikely that returning a\n-    // raw u16 buffer would be of practical use since the result would\n-    // be inherently platform-dependent and introduce additional\n-    // complexity to this code.\n-    //\n-    // Using the non-Unicode version of GetEnvironmentStrings is even\n-    // worse since the result is in an OEM code page.  Characters that\n-    // can't be encoded in the code page would be turned into question\n-    // marks.\n-    let mut result = Vec::new();\n-    let mut i = 0;\n-    while *ch.offset(i) != 0 {\n-        let p = &*ch.offset(i);\n-        let mut len = 0;\n-        while *(p as *const _).offset(len) != 0 {\n-            len += 1;\n-        }\n-        let p = p as *const u16;\n-        let s = slice::from_raw_buf(&p, len as uint);\n-        result.push(String::from_utf16_lossy(s).into_bytes());\n-        i += len as int + 1;\n-    }\n-    FreeEnvironmentStringsW(ch);\n-    result\n }\n \n-pub fn split_paths(unparsed: &[u8]) -> Vec<Path> {\n-    // On Windows, the PATH environment variable is semicolon separated.  Double\n-    // quotes are used as a way of introducing literal semicolons (since\n-    // c:\\some;dir is a valid Windows path). Double quotes are not themselves\n-    // permitted in path names, so there is no way to escape a double quote.\n-    // Quoted regions can appear in arbitrary locations, so\n-    //\n-    //   c:\\foo;c:\\som\"e;di\"r;c:\\bar\n-    //\n-    // Should parse as [c:\\foo, c:\\some;dir, c:\\bar].\n-    //\n-    // (The above is based on testing; there is no clear reference available\n-    // for the grammar.)\n-\n-    let mut parsed = Vec::new();\n-    let mut in_progress = Vec::new();\n-    let mut in_quote = false;\n-\n-    for b in unparsed.iter() {\n-        match *b {\n-            b';' if !in_quote => {\n-                parsed.push(Path::new(in_progress.as_slice()));\n-                in_progress.truncate(0)\n-            }\n-            b'\"' => {\n+impl<'a> Iterator for SplitPaths<'a> {\n+    type Item = Path;\n+    fn next(&mut self) -> Option<Path> {\n+        // On Windows, the PATH environment variable is semicolon separated.\n+        // Double quotes are used as a way of introducing literal semicolons\n+        // (since c:\\some;dir is a valid Windows path). Double quotes are not\n+        // themselves permitted in path names, so there is no way to escape a\n+        // double quote.  Quoted regions can appear in arbitrary locations, so\n+        //\n+        //   c:\\foo;c:\\som\"e;di\"r;c:\\bar\n+        //\n+        // Should parse as [c:\\foo, c:\\some;dir, c:\\bar].\n+        //\n+        // (The above is based on testing; there is no clear reference available\n+        // for the grammar.)\n+\n+\n+        let must_yield = self.must_yield;\n+        self.must_yield = false;\n+\n+        let mut in_progress = Vec::new();\n+        let mut in_quote = false;\n+        for b in self.data.by_ref() {\n+            if b == '\"' as u16 {\n                 in_quote = !in_quote;\n+            } else if b == ';' as u16 && !in_quote {\n+                self.must_yield = true;\n+                break\n+            } else {\n+                in_progress.push(b)\n             }\n-            _  => {\n-                in_progress.push(*b);\n-            }\n+        }\n+\n+        if !must_yield && in_progress.is_empty() {\n+            None\n+        } else {\n+            Some(super::os2path(&in_progress[]))\n         }\n     }\n-    parsed.push(Path::new(in_progress));\n-    parsed\n }\n \n-pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n+#[derive(Show)]\n+pub struct JoinPathsError;\n+\n+pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n+    where I: Iterator<Item=T>, T: AsOsStr\n+{\n     let mut joined = Vec::new();\n-    let sep = b';';\n+    let sep = b';' as u16;\n \n-    for (i, path) in paths.iter().map(|p| p.container_as_bytes()).enumerate() {\n+    for (i, path) in paths.enumerate() {\n+        let path = path.as_os_str();\n         if i > 0 { joined.push(sep) }\n-        if path.contains(&b'\"') {\n-            return Err(\"path segment contains `\\\"`\");\n-        } else if path.contains(&sep) {\n-            joined.push(b'\"');\n-            joined.push_all(path);\n-            joined.push(b'\"');\n+        let v = path.encode_wide().collect::<Vec<u16>>();\n+        if v.contains(&(b'\"' as u16)) {\n+            return Err(JoinPathsError)\n+        } else if v.contains(&sep) {\n+            joined.push(b'\"' as u16);\n+            joined.push_all(&v[]);\n+            joined.push(b'\"' as u16);\n         } else {\n-            joined.push_all(path);\n+            joined.push_all(&v[]);\n         }\n     }\n \n-    Ok(joined)\n+    Ok(OsStringExt::from_wide(&joined[]))\n }\n \n-pub fn load_self() -> Option<Vec<u8>> {\n-    unsafe {\n-        fill_utf16_buf_and_decode(|buf, sz| {\n-            libc::GetModuleFileNameW(ptr::null_mut(), buf, sz)\n-        }).map(|s| s.to_string().into_bytes())\n+impl fmt::Display for JoinPathsError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"path segment contains `\\\"`\".fmt(f)\n     }\n }\n \n+impl StdError for JoinPathsError {\n+    fn description(&self) -> &str { \"failed to join paths\" }\n+}\n+\n+pub fn current_exe() -> IoResult<Path> {\n+    super::fill_utf16_buf(|buf, sz| unsafe {\n+        libc::GetModuleFileNameW(ptr::null_mut(), buf, sz)\n+    }, super::os2path)\n+}\n+\n+pub fn getcwd() -> IoResult<Path> {\n+    super::fill_utf16_buf(|buf, sz| unsafe {\n+        libc::GetCurrentDirectoryW(sz, buf)\n+    }, super::os2path)\n+}\n+\n pub fn chdir(p: &Path) -> IoResult<()> {\n-    let mut p = p.as_str().unwrap().utf16_units().collect::<Vec<u16>>();\n+    let mut p = p.as_os_str().encode_wide().collect::<Vec<_>>();\n     p.push(0);\n \n     unsafe {\n@@ -298,39 +252,124 @@ pub fn chdir(p: &Path) -> IoResult<()> {\n     }\n }\n \n-pub fn page_size() -> uint {\n-    use mem;\n+pub fn getenv(k: &OsStr) -> Option<OsString> {\n+    let k = super::to_utf16_os(k);\n+    super::fill_utf16_buf(|buf, sz| unsafe {\n+        libc::GetEnvironmentVariableW(k.as_ptr(), buf, sz)\n+    }, |buf| {\n+        OsStringExt::from_wide(buf)\n+    }).ok()\n+}\n+\n+pub fn setenv(k: &OsStr, v: &OsStr) {\n+    let k = super::to_utf16_os(k);\n+    let v = super::to_utf16_os(v);\n+\n     unsafe {\n-        let mut info = mem::zeroed();\n-        libc::GetSystemInfo(&mut info);\n+        if libc::SetEnvironmentVariableW(k.as_ptr(), v.as_ptr()) == 0 {\n+            panic!(\"failed to set env: {}\", IoError::last_error());\n+        }\n+    }\n+}\n \n-        return info.dwPageSize as uint;\n+pub fn unsetenv(n: &OsStr) {\n+    let v = super::to_utf16_os(n);\n+    unsafe {\n+        if libc::SetEnvironmentVariableW(v.as_ptr(), ptr::null()) == 0 {\n+            panic!(\"failed to unset env: {}\", IoError::last_error());\n+        }\n     }\n }\n \n-#[cfg(test)]\n-mod tests {\n-    use super::truncate_utf16_at_nul;\n+pub struct Args {\n+    range: Range<isize>,\n+    cur: *mut *mut u16,\n+}\n \n-    #[test]\n-    fn test_truncate_utf16_at_nul() {\n-        let v = [];\n-        let b: &[u16] = &[];\n-        assert_eq!(truncate_utf16_at_nul(&v), b);\n+impl Iterator for Args {\n+    type Item = OsString;\n+    fn next(&mut self) -> Option<OsString> {\n+        self.range.next().map(|i| unsafe {\n+            let ptr = *self.cur.offset(i);\n+            let mut len = 0;\n+            while *ptr.offset(len) != 0 { len += 1; }\n+\n+            // Push it onto the list.\n+            let ptr = ptr as *const u16;\n+            let buf = slice::from_raw_buf(&ptr, len as usize);\n+            OsStringExt::from_wide(buf)\n+        })\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n+}\n \n-        let v = [0, 2, 3];\n-        assert_eq!(truncate_utf16_at_nul(&v), b);\n+impl Drop for Args {\n+    fn drop(&mut self) {\n+        unsafe { c::LocalFree(self.cur as *mut c_void); }\n+    }\n+}\n \n-        let v = [1, 0, 3];\n-        let b: &[u16] = &[1];\n-        assert_eq!(truncate_utf16_at_nul(&v), b);\n+pub fn args() -> Args {\n+    unsafe {\n+        let mut nArgs: c_int = 0;\n+        let lpCmdLine = c::GetCommandLineW();\n+        let szArgList = c::CommandLineToArgvW(lpCmdLine, &mut nArgs);\n \n-        let v = [1, 2, 0];\n-        let b: &[u16] = &[1, 2];\n-        assert_eq!(truncate_utf16_at_nul(&v), b);\n+        Args { cur: szArgList, range: range(0, nArgs as isize) }\n+    }\n+}\n \n-        let v = [1, 2, 3];\n-        let b: &[u16] = &[1, 2, 3];\n-        assert_eq!(truncate_utf16_at_nul(&v), b);\n+pub fn page_size() -> usize {\n+    unsafe {\n+        let mut info = mem::zeroed();\n+        libc::GetSystemInfo(&mut info);\n+        return info.dwPageSize as usize;\n+    }\n+}\n+\n+pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n+    // Windows pipes work subtly differently than unix pipes, and their\n+    // inheritance has to be handled in a different way that I do not\n+    // fully understand. Here we explicitly make the pipe non-inheritable,\n+    // which means to pass it to a subprocess they need to be duplicated\n+    // first, as in std::run.\n+    let mut fds = [0; 2];\n+    match libc::pipe(fds.as_mut_ptr(), 1024 as ::libc::c_uint,\n+    (libc::O_BINARY | libc::O_NOINHERIT) as c_int) {\n+        0 => {\n+            assert!(fds[0] != -1 && fds[0] != 0);\n+            assert!(fds[1] != -1 && fds[1] != 0);\n+            Ok((FileDesc::new(fds[0], true), FileDesc::new(fds[1], true)))\n+        }\n+        _ => Err(IoError::last_error()),\n     }\n }\n+\n+pub fn temp_dir() -> Path {\n+    super::fill_utf16_buf(|buf, sz| unsafe {\n+        c::GetTempPathW(sz, buf)\n+    }, super::os2path).unwrap()\n+}\n+\n+pub fn home_dir() -> Option<Path> {\n+    getenv(\"HOME\".as_os_str()).or_else(|| {\n+        getenv(\"USERPROFILE\".as_os_str())\n+    }).map(|os| {\n+        // FIXME: OsString => Path\n+        Path::new(os.to_str().unwrap())\n+    }).or_else(|| unsafe {\n+        let me = c::GetCurrentProcess();\n+        let mut token = ptr::null_mut();\n+        if c::OpenProcessToken(me, c::TOKEN_READ, &mut token) == 0 {\n+            return None\n+        }\n+        let _handle = RawHandle::new(token);\n+        super::fill_utf16_buf(|buf, mut sz| {\n+            match c::GetUserProfileDirectoryW(token, buf, &mut sz) {\n+                0 if libc::GetLastError() != 0 => 0,\n+                0 => sz,\n+                n => n as libc::DWORD,\n+            }\n+        }, super::os2path).ok()\n+    })\n+}"}, {"sha": "1f228b7d32e35042131cefcbce51e8fab742409a", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -352,7 +352,7 @@ impl UnixStream {\n \n     fn cancel_io(&self) -> IoResult<()> {\n         match unsafe { c::CancelIoEx(self.handle(), ptr::null_mut()) } {\n-            0 if os::errno() == libc::ERROR_NOT_FOUND as uint => {\n+            0 if os::errno() == libc::ERROR_NOT_FOUND as i32 => {\n                 Ok(())\n             }\n             0 => Err(super::last_error()),\n@@ -374,7 +374,7 @@ impl UnixStream {\n         // acquire the lock.\n         //\n         // See comments in close_read() about why this lock is necessary.\n-        let guard = unsafe { self.inner.lock.lock() };\n+        let guard = self.inner.lock.lock();\n         if self.read_closed() {\n             return Err(eof())\n         }\n@@ -392,7 +392,7 @@ impl UnixStream {\n \n         // If our errno doesn't say that the I/O is pending, then we hit some\n         // legitimate error and return immediately.\n-        if os::errno() != libc::ERROR_IO_PENDING as uint {\n+        if os::errno() != libc::ERROR_IO_PENDING as i32 {\n             return Err(super::last_error())\n         }\n \n@@ -417,7 +417,7 @@ impl UnixStream {\n             // If we succeeded, or we failed for some reason other than\n             // CancelIoEx, return immediately\n             if ret != 0 { return Ok(bytes_read as uint) }\n-            if os::errno() != libc::ERROR_OPERATION_ABORTED as uint {\n+            if os::errno() != libc::ERROR_OPERATION_ABORTED as i32 {\n                 return Err(super::last_error())\n             }\n \n@@ -450,7 +450,7 @@ impl UnixStream {\n             // going after we woke up.\n             //\n             // See comments in close_read() about why this lock is necessary.\n-            let guard = unsafe { self.inner.lock.lock() };\n+            let guard = self.inner.lock.lock();\n             if self.write_closed() {\n                 return Err(epipe())\n             }\n@@ -465,7 +465,7 @@ impl UnixStream {\n             drop(guard);\n \n             if ret == 0 {\n-                if err != libc::ERROR_IO_PENDING as uint {\n+                if err != libc::ERROR_IO_PENDING as i32 {\n                     return Err(decode_error_detailed(err as i32))\n                 }\n                 // Process a timeout if one is pending\n@@ -481,7 +481,7 @@ impl UnixStream {\n                 // aborted, then check to see if the write half was actually\n                 // closed or whether we woke up from the read half closing.\n                 if ret == 0 {\n-                    if os::errno() != libc::ERROR_OPERATION_ABORTED as uint {\n+                    if os::errno() != libc::ERROR_OPERATION_ABORTED as i32 {\n                         return Err(super::last_error())\n                     }\n                     if !wait_succeeded.is_ok() {\n@@ -525,14 +525,14 @@ impl UnixStream {\n         // close_read() between steps 1 and 2. By atomically executing steps 1\n         // and 2 with a lock with respect to close_read(), we're guaranteed that\n         // no thread will erroneously sit in a read forever.\n-        let _guard = unsafe { self.inner.lock.lock() };\n+        let _guard = self.inner.lock.lock();\n         self.inner.read_closed.store(true, Ordering::SeqCst);\n         self.cancel_io()\n     }\n \n     pub fn close_write(&mut self) -> IoResult<()> {\n         // see comments in close_read() for why this lock is necessary\n-        let _guard = unsafe { self.inner.lock.lock() };\n+        let _guard = self.inner.lock.lock();\n         self.inner.write_closed.store(true, Ordering::SeqCst);\n         self.cancel_io()\n     }"}, {"sha": "043fdb38805dc8d20b422c48491adde83a41e677", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -10,28 +10,27 @@\n \n use prelude::v1::*;\n \n+use collections::hash_map::Hasher;\n use collections;\n+use env;\n use ffi::CString;\n use hash::Hash;\n-use collections::hash_map::Hasher;\n+use libc::{pid_t, c_void};\n+use libc;\n+use mem;\n use old_io::fs::PathExtensions;\n-use old_io::process::{ProcessExit, ExitStatus, ExitSignal};\n+use old_io::process::{ProcessExit, ExitStatus};\n use old_io::{IoResult, IoError};\n use old_io;\n-use libc::{pid_t, c_void, c_int};\n-use libc;\n-use mem;\n use os;\n use path::BytesContainer;\n use ptr;\n use str;\n-use sys::fs::FileDesc;\n use sync::{StaticMutex, MUTEX_INIT};\n+use sys::fs::FileDesc;\n \n-use sys::fs;\n-use sys::{self, retry, c, wouldblock, set_nonblocking, ms_to_timeval, timer};\n-use sys_common::helper_thread::Helper;\n-use sys_common::{AsInner, mkerr_libc, timeout};\n+use sys::timer;\n+use sys_common::{AsInner, timeout};\n \n pub use sys_common::ProcessConfig;\n \n@@ -106,6 +105,7 @@ impl Process {\n         return ret;\n     }\n \n+    #[allow(deprecated)]\n     pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,\n                               out_fd: Option<P>, err_fd: Option<P>)\n                               -> IoResult<Process>\n@@ -128,7 +128,7 @@ impl Process {\n         use libc::funcs::extra::msvcrt::get_osfhandle;\n \n         use mem;\n-        use iter::{Iterator, IteratorExt};\n+        use iter::IteratorExt;\n         use str::StrExt;\n \n         if cfg.gid().is_some() || cfg.uid().is_some() {\n@@ -149,7 +149,7 @@ impl Process {\n                 // program exists.\n                 for path in os::split_paths(v.container_as_bytes()).into_iter() {\n                     let path = path.join(cfg.program().as_bytes())\n-                                   .with_extension(os::consts::EXE_EXTENSION);\n+                                   .with_extension(env::consts::EXE_EXTENSION);\n                     if path.exists() {\n                         return Some(CString::from_slice(path.as_vec()))\n                     }"}, {"sha": "76fe352ed7717cf6ca623bb693a1fcf48663d5c1", "filename": "src/libstd/sys/windows/rwlock.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -18,9 +18,6 @@ pub const RWLOCK_INIT: RWLock = RWLock {\n };\n \n impl RWLock {\n-    #[inline]\n-    pub unsafe fn new() -> RWLock { RWLOCK_INIT }\n-\n     #[inline]\n     pub unsafe fn read(&self) {\n         ffi::AcquireSRWLockShared(self.inner.get())"}, {"sha": "b0410701ee1012817ece41b7fb16eda28c47cd08", "filename": "src/libstd/sys/windows/stack_overflow.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -14,7 +14,7 @@ use ptr;\n use mem;\n use libc;\n use libc::types::os::arch::extra::{LPVOID, DWORD, LONG, BOOL};\n-use sys_common::{stack, thread_info};\n+use sys_common::stack;\n \n pub struct Handler {\n     _data: *mut libc::c_void\n@@ -30,14 +30,6 @@ impl Drop for Handler {\n     fn drop(&mut self) {}\n }\n \n-// get_task_info is called from an exception / signal handler.\n-// It returns the guard page of the current task or 0 if that\n-// guard page doesn't exist. None is returned if there's currently\n-// no local task.\n-unsafe fn get_task_guard_page() -> uint {\n-    thread_info::stack_guard()\n-}\n-\n // This is initialized in init() and only read from after\n static mut PAGE_SIZE: uint = 0;\n "}, {"sha": "7614104c98bf37bd8759f6832b6fcaa39d70b4a9", "filename": "src/libstd/sys/windows/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fsync.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use libc::{BOOL, DWORD, c_void, LPVOID, c_ulong};\n+use libc::{BOOL, DWORD, LPVOID, c_ulong};\n use libc::types::os::arch::extra::BOOLEAN;\n \n pub type PCONDITION_VARIABLE = *mut CONDITION_VARIABLE;"}, {"sha": "4804ca510cb0ba0e9be1b8fffdbd75285e78a703", "filename": "src/libstd/sys/windows/tcp.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -14,12 +14,11 @@ use libc;\n use mem;\n use ptr;\n use prelude::v1::*;\n-use super::{last_error, last_net_error, retry, sock_t};\n+use super::{last_error, last_net_error, sock_t};\n use sync::Arc;\n use sync::atomic::{AtomicBool, Ordering};\n-use sys::fs::FileDesc;\n use sys::{self, c, set_nonblocking, wouldblock, timer};\n-use sys_common::{self, timeout, eof, net};\n+use sys_common::{timeout, eof, net};\n \n pub use sys_common::net::TcpStream;\n \n@@ -202,10 +201,6 @@ impl TcpAcceptor {\n         Err(eof())\n     }\n \n-    pub fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n-        net::sockname(self.socket(), libc::getsockname)\n-    }\n-\n     pub fn set_timeout(&mut self, timeout: Option<u64>) {\n         self.deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n     }"}, {"sha": "a38dc9b2d340770d643d9539e349abe706044292", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n-\n use boxed::Box;\n use cmp;\n use mem;"}, {"sha": "cc731738afe3e12b6d64a48a3f4587c6a6f580d2", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -233,6 +233,7 @@ unsafe extern \"system\" fn on_tls_callback(h: LPVOID,\n     }\n }\n \n+#[allow(dead_code)] // actually called above\n unsafe fn run_dtors() {\n     let mut any_run = true;\n     for _ in 0..5 {"}, {"sha": "d156dd801f974905fa2d2adc64d461bbdd1f7525", "filename": "src/libstd/sys/windows/timer.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -28,8 +28,6 @@ use ptr;\n \n use old_io::IoResult;\n use sync::mpsc::{channel, Sender, Receiver, TryRecvError};\n-use sys::c;\n-use sys::fs::FileDesc;\n use sys_common::helper_thread::Helper;\n \n helper_init! { static HELPER: Helper<Req> }"}, {"sha": "f02c8e49f4188d1b26c783ffcd20ace768c8e8f7", "filename": "src/libstd/sys/windows/tty.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -38,7 +38,7 @@ use str::from_utf8;\n use super::c::{ENABLE_ECHO_INPUT, ENABLE_EXTENDED_FLAGS};\n use super::c::{ENABLE_INSERT_MODE, ENABLE_LINE_INPUT};\n use super::c::{ENABLE_PROCESSED_INPUT, ENABLE_QUICK_EDIT_MODE};\n-use super::c::{ERROR_ILLEGAL_CHARACTER, CONSOLE_SCREEN_BUFFER_INFO};\n+use super::c::{CONSOLE_SCREEN_BUFFER_INFO};\n use super::c::{ReadConsoleW, WriteConsoleW, GetConsoleMode, SetConsoleMode};\n use super::c::{GetConsoleScreenBufferInfo};\n \n@@ -155,9 +155,6 @@ impl TTY {\n                      (info.srWindow.Bottom + 1 - info.srWindow.Top) as int)),\n         }\n     }\n-\n-    // Let us magically declare this as a TTY\n-    pub fn isatty(&self) -> bool { true }\n }\n \n impl Drop for TTY {"}, {"sha": "9aa454ae8d5c9c567395e92d4a39c9997be1bb09", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -21,7 +21,7 @@ use ext::base;\n use ext::build::AstBuilder;\n use parse::token;\n \n-use std::os;\n+use std::env;\n \n pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                               -> Box<base::MacResult+'cx> {\n@@ -30,8 +30,8 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenT\n         Some(v) => v\n     };\n \n-    let e = match os::getenv(&var[]) {\n-      None => {\n+    let e = match env::var_string(&var[]) {\n+      Err(..) => {\n           cx.expr_path(cx.path_all(sp,\n                                    true,\n                                    vec!(cx.ident_of(\"std\"),\n@@ -48,7 +48,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenT\n                                                    ast::MutImmutable)),\n                                    Vec::new()))\n       }\n-      Some(s) => {\n+      Ok(s) => {\n           cx.expr_call_global(sp,\n                               vec!(cx.ident_of(\"std\"),\n                                    cx.ident_of(\"option\"),\n@@ -101,12 +101,12 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         }\n     }\n \n-    let e = match os::getenv(var.get()) {\n-        None => {\n+    let e = match env::var_string(var.get()) {\n+        Err(..) => {\n             cx.span_err(sp, msg.get());\n             cx.expr_usize(sp, 0)\n         }\n-        Some(s) => cx.expr_str(sp, token::intern_and_get_ident(&s[]))\n+        Ok(s) => cx.expr_str(sp, token::intern_and_get_ident(&s[]))\n     };\n     MacExpr::new(e)\n }"}, {"sha": "54b37483f8cfdc5f456d1496fd53818fbe4a6d09", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -28,11 +28,11 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(env)]\n #![feature(hash)]\n #![feature(int_uint)]\n #![feature(io)]\n #![feature(libc)]\n-#![feature(os)]\n #![feature(path)]\n #![feature(quote, unsafe_destructor)]\n #![feature(rustc_private)]"}, {"sha": "219c9baf4c8925a6a742917f42da6064febe825c", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -55,13 +55,14 @@\n #![feature(core)]\n #![feature(int_uint)]\n #![feature(io)]\n-#![feature(os)]\n #![feature(path)]\n #![feature(rustc_private)]\n #![feature(slicing_syntax)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]\n+#![feature(env)]\n+#![cfg_attr(windows, feature(libc))]\n \n #[macro_use] extern crate log;\n "}, {"sha": "17c1e8cdb8c6d119b9a06a2f28836638993f35e6", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -12,7 +12,7 @@\n \n use std::collections::HashMap;\n use std::old_io::IoResult;\n-use std::os;\n+use std::env;\n \n use attr;\n use color;\n@@ -172,17 +172,17 @@ impl<T: Writer+Send> TerminfoTerminal<T> {\n     /// Returns `None` whenever the terminal cannot be created for some\n     /// reason.\n     pub fn new(out: T) -> Option<Box<Terminal<T>+Send+'static>> {\n-        let term = match os::getenv(\"TERM\") {\n-            Some(t) => t,\n-            None => {\n+        let term = match env::var_string(\"TERM\") {\n+            Ok(t) => t,\n+            Err(..) => {\n                 debug!(\"TERM environment variable not defined\");\n                 return None;\n             }\n         };\n \n         let entry = open(&term[]);\n         if entry.is_err() {\n-            if os::getenv(\"MSYSCON\").map_or(false, |s| {\n+            if env::var_string(\"MSYSCON\").ok().map_or(false, |s| {\n                     \"mintty.exe\" == s\n                 }) {\n                 // msys terminal"}, {"sha": "74c986cd9e262358ec5029d1e443e02da767b31d", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -14,30 +14,29 @@\n \n use std::old_io::File;\n use std::old_io::fs::PathExtensions;\n-use std::os::getenv;\n-use std::os;\n+use std::env;\n \n /// Return path to database entry for `term`\n pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n     if term.len() == 0 {\n         return None;\n     }\n \n-    let homedir = os::homedir();\n+    let homedir = env::home_dir();\n \n     let mut dirs_to_search = Vec::new();\n     let first_char = term.char_at(0);\n \n     // Find search directory\n-    match getenv(\"TERMINFO\") {\n-        Some(dir) => dirs_to_search.push(Path::new(dir)),\n-        None => {\n+    match env::var_string(\"TERMINFO\") {\n+        Ok(dir) => dirs_to_search.push(Path::new(dir)),\n+        Err(..) => {\n             if homedir.is_some() {\n                 // ncurses compatibility;\n                 dirs_to_search.push(homedir.unwrap().join(\".terminfo\"))\n             }\n-            match getenv(\"TERMINFO_DIRS\") {\n-                Some(dirs) => for i in dirs.split(':') {\n+            match env::var_string(\"TERMINFO_DIRS\") {\n+                Ok(dirs) => for i in dirs.split(':') {\n                     if i == \"\" {\n                         dirs_to_search.push(Path::new(\"/usr/share/terminfo\"));\n                     } else {\n@@ -48,7 +47,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n                 // According to  /etc/terminfo/README, after looking at\n                 // ~/.terminfo, ncurses will search /etc/terminfo, then\n                 // /lib/terminfo, and eventually /usr/share/terminfo.\n-                None => {\n+                Err(..) => {\n                     dirs_to_search.push(Path::new(\"/etc/terminfo\"));\n                     dirs_to_search.push(Path::new(\"/lib/terminfo\"));\n                     dirs_to_search.push(Path::new(\"/usr/share/terminfo\"));"}, {"sha": "2295f122822db33f16f9995dc2e87350975a2d86", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -38,10 +38,10 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(env)]\n #![feature(hash)]\n #![feature(int_uint)]\n #![feature(io)]\n-#![feature(os)]\n #![feature(path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n@@ -75,7 +75,7 @@ use std::old_io::{File, ChanReader, ChanWriter};\n use std::old_io;\n use std::iter::repeat;\n use std::num::{Float, Int};\n-use std::os;\n+use std::env;\n use std::sync::mpsc::{channel, Sender};\n use std::thread::{self, Thread};\n use std::thunk::{Thunk, Invoke};\n@@ -388,7 +388,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n \n     let mut nocapture = matches.opt_present(\"nocapture\");\n     if !nocapture {\n-        nocapture = os::getenv(\"RUST_TEST_NOCAPTURE\").is_some();\n+        nocapture = env::var(\"RUST_TEST_NOCAPTURE\").is_some();\n     }\n \n     let color = match matches.opt_str(\"color\").as_ref().map(|s| s.as_slice()) {\n@@ -817,15 +817,15 @@ fn run_tests<F>(opts: &TestOpts,\n \n fn get_concurrency() -> uint {\n     use std::rt;\n-    match os::getenv(\"RUST_TEST_TASKS\") {\n-        Some(s) => {\n+    match env::var_string(\"RUST_TEST_TASKS\") {\n+        Ok(s) => {\n             let opt_n: Option<uint> = s.parse().ok();\n             match opt_n {\n                 Some(n) if n > 0 => n,\n                 _ => panic!(\"RUST_TEST_TASKS is `{}`, should be a positive integer.\", s)\n             }\n         }\n-        None => {\n+        Err(..) => {\n             rt::default_sched_threads()\n         }\n     }"}, {"sha": "ac32b5848015d80c45096d676d183d4f274cd0bc", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -48,12 +48,12 @@ use std::simd::f64x2;\n use std::sync::Arc;\n use std::thread::Thread;\n \n-const ITER: int = 50;\n+const ITER: usize = 50;\n const LIMIT: f64 = 2.0;\n-const WORKERS: uint = 16;\n+const WORKERS: usize = 16;\n \n #[inline(always)]\n-fn mandelbrot<W: old_io::Writer>(w: uint, mut out: W) -> old_io::IoResult<()> {\n+fn mandelbrot<W: old_io::Writer>(w: usize, mut out: W) -> old_io::IoResult<()> {\n     assert!(WORKERS % 2 == 0);\n \n     // Ensure w and h are multiples of 8.\n@@ -198,7 +198,6 @@ fn write_line(init_i: f64, vec_init_r: &[f64], res: &mut Vec<u8>) {\n \n fn main() {\n     let args = os::args();\n-    let args = args.as_slice();\n     let res = if args.len() < 2 {\n         println!(\"Test mode: do not dump the image because it's not utf8, \\\n                   which interferes with the test runner.\");"}, {"sha": "960d9ef0f2fb4d4b97a47e3ed2783fd8daa31987", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -12,7 +12,6 @@\n #![deny(unused_assignments)]\n #![allow(dead_code, non_camel_case_types)]\n #![feature(core)]\n-#![feature(os)]\n \n fn f1(x: isize) {\n     //~^ ERROR unused variable: `x`\n@@ -98,7 +97,7 @@ fn f5c() {\n     for (_, x) in [1is, 2, 3].iter().enumerate() {\n     //~^ ERROR unused variable: `x`\n         continue;\n-        std::os::set_exit_status(*x); //~ WARNING unreachable statement\n+        drop(*x as i32); //~ WARNING unreachable statement\n     }\n }\n "}, {"sha": "5623e98c928859940dd727b079ac56928fe33028", "filename": "src/test/run-pass/env-home-dir.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Ftest%2Frun-pass%2Fenv-home-dir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Ftest%2Frun-pass%2Fenv-home-dir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenv-home-dir.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::env::*;\n+\n+#[cfg(unix)]\n+fn main() {\n+    let oldhome = var(\"HOME\");\n+\n+    set_var(\"HOME\", \"/home/MountainView\");\n+    assert!(home_dir() == Some(Path::new(\"/home/MountainView\")));\n+\n+    remove_var(\"HOME\");\n+    assert!(home_dir().is_some());\n+}\n+\n+#[cfg(windows)]\n+fn main() {\n+    let oldhome = var(\"HOME\");\n+    let olduserprofile = var(\"USERPROFILE\");\n+\n+    remove_var(\"HOME\");\n+    remove_var(\"USERPROFILE\");\n+\n+    assert!(home_dir().is_some());\n+\n+    set_var(\"HOME\", \"/home/MountainView\");\n+    assert!(home_dir() == Some(Path::new(\"/home/MountainView\")));\n+\n+    remove_var(\"HOME\");\n+\n+    set_var(\"USERPROFILE\", \"/home/MountainView\");\n+    assert!(home_dir() == Some(Path::new(\"/home/MountainView\")));\n+\n+    set_var(\"HOME\", \"/home/MountainView\");\n+    set_var(\"USERPROFILE\", \"/home/PaloAlto\");\n+    assert!(home_dir() == Some(Path::new(\"/home/MountainView\")));\n+}"}, {"sha": "892041b964889457c1d9f84798bfd97182c5aa9e", "filename": "src/test/run-pass/env-vars.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Ftest%2Frun-pass%2Fenv-vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ed3a48dfa301c5bb56de3e0a7c25214539b83c/src%2Ftest%2Frun-pass%2Fenv-vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenv-vars.rs?ref=70ed3a48dfa301c5bb56de3e0a7c25214539b83c", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::env::*;\n+\n+fn main() {\n+    for (k, v) in vars() {\n+        let v2 = var(&k);\n+        // MingW seems to set some funky environment variables like\n+        // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n+        // from vars() but not visible from var().\n+        assert!(v2.is_none() || v2.as_ref().map(|s| &**s) == Some(&*v),\n+                \"bad vars->var transition: {:?} {:?} {:?}\", k, v, v2);\n+    }\n+}"}]}