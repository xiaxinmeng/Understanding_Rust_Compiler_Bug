{"sha": "dd2b32be56945824e1e900d9748274633d6db6c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkMmIzMmJlNTY5NDU4MjRlMWU5MDBkOTc0ODI3NDYzM2Q2ZGI2YzE=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2012-12-10T01:02:33Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-17T03:27:05Z"}, "message": "add priority queue implementation (binary heap)", "tree": {"sha": "f18ded190a6ddb67b4824cb3098b78b889576c7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f18ded190a6ddb67b4824cb3098b78b889576c7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd2b32be56945824e1e900d9748274633d6db6c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd2b32be56945824e1e900d9748274633d6db6c1", "html_url": "https://github.com/rust-lang/rust/commit/dd2b32be56945824e1e900d9748274633d6db6c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd2b32be56945824e1e900d9748274633d6db6c1/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6036add5ebf18f412adf8a9d36db738906acc274", "url": "https://api.github.com/repos/rust-lang/rust/commits/6036add5ebf18f412adf8a9d36db738906acc274", "html_url": "https://github.com/rust-lang/rust/commit/6036add5ebf18f412adf8a9d36db738906acc274"}], "stats": {"total": 254, "additions": 254, "deletions": 0}, "files": [{"sha": "c744ba1ca5cea8433de1e0eeccc97342754c9b87", "filename": "src/libstd/priority_queue.rs", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/dd2b32be56945824e1e900d9748274633d6db6c1/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd2b32be56945824e1e900d9748274633d6db6c1/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=dd2b32be56945824e1e900d9748274633d6db6c1", "patch": "@@ -0,0 +1,253 @@\n+\n+/// A priority queue implemented with a binary heap\n+use core::cmp::Ord;\n+\n+pub struct PriorityQueue <T: Copy Ord>{\n+    priv data: ~[T],\n+}\n+\n+impl <T: Copy Ord> PriorityQueue<T> {\n+    /// Returns the greatest item in the queue - fails if empty\n+    pure fn top(&self) -> T { self.data[0] }\n+\n+    /// Returns the greatest item in the queue - None if empty\n+    pure fn maybe_top(&self) -> Option<T> {\n+        if self.is_empty() { None } else { Some(self.top()) }\n+    }\n+\n+    /// Returns the length of the queue\n+    pure fn len(&self) -> uint { self.data.len() }\n+\n+    /// Returns true if a queue contains no elements\n+    pure fn is_empty(&self) -> bool { self.data.is_empty() }\n+\n+    /// Returns true if a queue contains some elements\n+    pure fn is_not_empty(&self) -> bool { self.data.is_not_empty() }\n+\n+    /// Returns the number of elements the queue can hold without reallocating\n+    pure fn capacity(&self) -> uint { vec::capacity(&self.data) }\n+\n+    fn reserve(&mut self, n: uint) { vec::reserve(&mut self.data, n) }\n+\n+    fn reserve_at_least(&mut self, n: uint) {\n+        vec::reserve_at_least(&mut self.data, n)\n+    }\n+\n+    /// Drop all items from the queue\n+    fn clear(&mut self) { self.data.truncate(0) }\n+\n+    /// Pop the greatest item from the queue - fails if empty\n+    fn pop(&mut self) -> T {\n+        let last = self.data.pop();\n+        if self.is_not_empty() {\n+            let ret = self.data[0];\n+            self.data[0] = last;\n+            self.siftup(0);\n+            ret\n+        } else { last }\n+    }\n+\n+    /// Pop the greatest item from the queue - None if empty\n+    fn maybe_pop(&mut self) -> Option<T> {\n+        if self.is_empty() { None } else { Some(self.pop()) }\n+    }\n+\n+    /// Push an item onto the queue\n+    fn push(&mut self, item: T) {\n+        self.data.push(item);\n+        self.siftdown(0, self.len() - 1);\n+    }\n+\n+    /// Optimized version of a push followed by a pop\n+    fn push_pop(&mut self, item: T) -> T {\n+        let mut item = item;\n+        if self.is_not_empty() && self.data[0] > item {\n+            item <-> self.data[0];\n+            self.siftup(0);\n+        }\n+        item\n+    }\n+\n+    /// Optimized version of a pop followed by a push - fails if empty\n+    fn replace(&mut self, item: T) -> T {\n+        let ret = self.data[0];\n+        self.data[0] = item;\n+        self.siftup(0);\n+        ret\n+    }\n+\n+    priv fn siftdown(&mut self, startpos: uint, pos: uint) {\n+        let mut pos = pos;\n+        let newitem = self.data[pos];\n+\n+        while pos > startpos {\n+            let parentpos = (pos - 1) >> 1;\n+            let parent = self.data[parentpos];\n+            if newitem > parent {\n+                self.data[pos] = parent;\n+                pos = parentpos;\n+                loop\n+            }\n+            break\n+        }\n+        self.data[pos] = newitem;\n+    }\n+\n+    priv fn siftup_range(&mut self, pos: uint, endpos: uint) {\n+        let mut pos = pos;\n+        let startpos = pos;\n+        let newitem = self.data[pos];\n+\n+        let mut childpos = 2 * pos + 1;\n+        while childpos < endpos {\n+            let rightpos = childpos + 1;\n+            if rightpos < endpos &&\n+                   !(self.data[childpos] > self.data[rightpos]) {\n+                childpos = rightpos;\n+            }\n+            self.data[pos] = self.data[childpos];\n+            pos = childpos;\n+            childpos = 2 * pos + 1;\n+        }\n+        self.data[pos] = newitem;\n+        self.siftdown(startpos, pos);\n+    }\n+\n+    priv fn siftup(&mut self, pos: uint) {\n+        self.siftup_range(pos, self.len());\n+    }\n+}\n+\n+/// Consume the PriorityQueue and return the underlying vector\n+pub pure fn to_vec<T: Copy Ord>(q: PriorityQueue<T>) -> ~[T] {\n+    let PriorityQueue{data: v} = q;\n+    v\n+}\n+\n+/// Consume the PriorityQueue and return a vector in sorted (ascending) order\n+pub pure fn to_sorted_vec<T: Copy Ord>(q: PriorityQueue<T>) -> ~[T] {\n+    let mut q = q;\n+    let mut end = q.len() - 1;\n+    while end > 0 {\n+        q.data[end] <-> q.data[0];\n+        end -= 1;\n+        unsafe { q.siftup_range(0, end) } // purity-checking workaround\n+    }\n+    to_vec(q)\n+}\n+\n+pub pure fn from_vec<T: Copy Ord>(xs: ~[T]) -> PriorityQueue<T> {\n+    let mut q = PriorityQueue{data: xs,};\n+    let mut n = q.len() / 2;\n+    while n > 0 {\n+        n -= 1;\n+        unsafe { q.siftup(n) }; // purity-checking workaround\n+    }\n+    q\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use sort::merge_sort;\n+    use core::cmp::le;\n+\n+    #[test]\n+    fn test_top_and_pop() {\n+        let data = ~[2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n+        let mut sorted = merge_sort(data, le);\n+        let mut heap = from_vec(data);\n+        while heap.is_not_empty() {\n+            assert heap.top() == sorted.last();\n+            assert heap.pop() == sorted.pop();\n+        }\n+    }\n+\n+    #[test]\n+    fn test_push() {\n+        let mut heap = from_vec(~[2, 4, 9]);\n+        assert heap.len() == 3;\n+        assert heap.top() == 9;\n+        heap.push(11);\n+        assert heap.len() == 4;\n+        assert heap.top() == 11;\n+        heap.push(5);\n+        assert heap.len() == 5;\n+        assert heap.top() == 11;\n+        heap.push(27);\n+        assert heap.len() == 6;\n+        assert heap.top() == 27;\n+        heap.push(3);\n+        assert heap.len() == 7;\n+        assert heap.top() == 27;\n+        heap.push(103);\n+        assert heap.len() == 8;\n+        assert heap.top() == 103;\n+    }\n+\n+    #[test]\n+    fn test_push_pop() {\n+        let mut heap = from_vec(~[5, 5, 2, 1, 3]);\n+        assert heap.len() == 5;\n+        assert heap.push_pop(6) == 6;\n+        assert heap.len() == 5;\n+        assert heap.push_pop(0) == 5;\n+        assert heap.len() == 5;\n+        assert heap.push_pop(4) == 5;\n+        assert heap.len() == 5;\n+        assert heap.push_pop(1) == 4;\n+        assert heap.len() == 5;\n+    }\n+\n+    #[test]\n+    fn test_replace() {\n+        let mut heap = from_vec(~[5, 5, 2, 1, 3]);\n+        assert heap.len() == 5;\n+        assert heap.replace(6) == 5;\n+        assert heap.len() == 5;\n+        assert heap.replace(0) == 6;\n+        assert heap.len() == 5;\n+        assert heap.replace(4) == 5;\n+        assert heap.len() == 5;\n+        assert heap.replace(1) == 4;\n+        assert heap.len() == 5;\n+    }\n+\n+    #[test]\n+    fn test_to_sorted_vec() {\n+        let data = ~[2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n+        assert to_sorted_vec(from_vec(data)) == merge_sort(data, le);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_empty_pop() { let mut heap = from_vec::<int>(~[]); heap.pop(); }\n+\n+    #[test]\n+    fn test_empty_maybe_pop() {\n+        let mut heap = from_vec::<int>(~[]);\n+        assert heap.maybe_pop().is_none();\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_empty_top() { from_vec::<int>(~[]).top(); }\n+\n+    #[test]\n+    fn test_empty_maybe_top() {\n+        assert from_vec::<int>(~[]).maybe_top().is_none();\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_empty_replace() {\n+        let mut heap = from_vec::<int>(~[]);\n+        heap.replace(5);\n+    }\n+\n+    #[test]\n+    fn test_to_vec() {\n+        let data = ~[1, 3, 5, 7, 9, 2, 4, 6, 8, 0];\n+        let heap = from_vec(copy data);\n+        assert merge_sort(to_vec(heap), le) == merge_sort(data, le);\n+    }\n+}"}, {"sha": "f5363ca23c503511baf33987fb648cd375bf9a21", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd2b32be56945824e1e900d9748274633d6db6c1/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/dd2b32be56945824e1e900d9748274633d6db6c1/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=dd2b32be56945824e1e900d9748274633d6db6c1", "patch": "@@ -73,6 +73,7 @@ pub mod deque;\n pub mod fun_treemap;\n pub mod list;\n pub mod map;\n+pub mod priority_queue;\n pub mod rope;\n pub mod smallintmap;\n pub mod sort;"}]}