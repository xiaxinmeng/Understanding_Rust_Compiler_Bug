{"sha": "82001412f2a454158d8e29d7d1a4d1122e734e57", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyMDAxNDEyZjJhNDU0MTU4ZDhlMjlkN2QxYTRkMTEyMmU3MzRlNTc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-06T21:34:41Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-06T21:38:05Z"}, "message": "tutorial: Add a section on the memory model", "tree": {"sha": "31bdf499cf25f6d198a5f887a63e2b29d776ea7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31bdf499cf25f6d198a5f887a63e2b29d776ea7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82001412f2a454158d8e29d7d1a4d1122e734e57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82001412f2a454158d8e29d7d1a4d1122e734e57", "html_url": "https://github.com/rust-lang/rust/commit/82001412f2a454158d8e29d7d1a4d1122e734e57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82001412f2a454158d8e29d7d1a4d1122e734e57/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e1a6cf3d902065327625ff05ebbd7836bdb001b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e1a6cf3d902065327625ff05ebbd7836bdb001b", "html_url": "https://github.com/rust-lang/rust/commit/0e1a6cf3d902065327625ff05ebbd7836bdb001b"}], "stats": {"total": 76, "additions": 76, "deletions": 0}, "files": [{"sha": "7872a695827f9765566e5abfb4481a9eeca44c12", "filename": "doc/tutorial.md", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/82001412f2a454158d8e29d7d1a4d1122e734e57/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/82001412f2a454158d8e29d7d1a4d1122e734e57/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=82001412f2a454158d8e29d7d1a4d1122e734e57", "patch": "@@ -879,6 +879,82 @@ while (x > 10) { x -= 10; }\n assert x == 10;\n ~~~~\n \n+# The Rust Memory Model\n+\n+At this junction let's take a detour to explain the concepts involved\n+in Rust's memory model. Rust has a very particular approach to\n+memory management that plays a significant role in shaping the \"feel\"\n+of the language. Understanding the memory landscape will illuminate\n+several of Rust's unique features as we encounter them.\n+\n+Rust has three competing goals that inform its view of memory:\n+\n+* Memory safety - memory that is managed by and is accessible to\n+  the Rust language must be guaranteed to be valid. Under normal\n+  circumstances it is impossible for Rust to trigger a segmentation\n+  fault or leak memory\n+* Performance - high-performance low-level code tends to employ\n+  a number of allocation strategies. low-performance high-level\n+  code often uses a single, GC-based, heap allocation strategy\n+* Concurrency - Rust maintain memory safety guarantees even\n+  for code running in parallel\n+\n+## How performance considerations influence the memory model\n+\n+Many languages that ofter the kinds of memory safety guarentees that\n+Rust does have a single allocation strategy: objects live on the heap,\n+live for as long as they are needed, and are periodically garbage\n+collected. This is very straightforword both conceptually and in\n+implementation, but has very significant costs. Such languages tend to\n+aggressively pursue ways to ameliorate allocation costs (think the\n+Java virtual machine). Rust supports this strategy with _shared\n+boxes_, memory allocated on the heap that may be referred to (shared)\n+by multiple variables.\n+\n+In comparison, languages like C++ offer a very precise control over\n+where objects are allocated. In particular, it is common to put\n+them directly on the stack, avoiding expensive heap allocation. In\n+Rust this is possible as well, and the compiler will use a clever\n+lifetime analysis to ensure that no variable can refer to stack\n+objects after they are destroyed.\n+\n+## How concurrency considerations influence the memory model\n+\n+Memory safety in a concurrent environment tends to mean avoiding race\n+conditions between two threads of execution accessing the same\n+memory. Even high-level languages frequently avoid solving this\n+problem, requiring programmers to correctly employ locking to unsure\n+their program is free of races.\n+\n+Rust solves this problem by starting from the position that memory\n+simply cannot be shared between tasks. Experience in other languages\n+has proven that isolating each tasks' heap from each other is\n+a reliable strategy and one that is easy for programmers to reason\n+about. Having isolated heaps additionally means that garbage collection\n+must only be done per-heap. Rust never 'stops the world' to garbage\n+collect memory.\n+\n+If Rust tasks have completely isolated heaps then that seems to imply\n+that any data transferred between them must be copied. While this\n+is a fine and useful way to implement communication between tasks,\n+it is also very inefficient for large data structures.\n+\n+Because of this Rust also introduces a global \"exchange heap\". Objects\n+allocated here have _ownership semantics_, meaning that there is only\n+a single variable that refers to them. For this reason they are\n+refered to as _unique boxes_. All tasks may allocate objects on this\n+heap, then _move_ those allocations to other tasks, avoiding expensive\n+copies.\n+\n+## What to be aware of\n+\n+Rust has three \"realms\" in which objects can be allocated: the stack,\n+the local heap, and the exchange heap. These realms have corresponding\n+pointer types: the borrowed pointer (`&T`), the shared pointer (`@T`),\n+and the unique pointer (`~T`). These three sigils will appear\n+repeatedly as we explore the language. Learning the appropriate role\n+of each is key to using Rust effectively.\n+\n # Functions\n \n Like all other static declarations, such as `type`, functions can be"}]}