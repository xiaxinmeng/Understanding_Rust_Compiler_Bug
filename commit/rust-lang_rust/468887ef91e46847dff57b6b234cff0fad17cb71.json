{"sha": "468887ef91e46847dff57b6b234cff0fad17cb71", "node_id": "C_kwDOAAsO6NoAKDQ2ODg4N2VmOTFlNDY4NDdkZmY1N2I2YjIzNGNmZjBmYWQxN2NiNzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-19T15:31:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-19T15:31:25Z"}, "message": "Auto merge of #100209 - cjgillot:source-file-index, r=estebank\n\nLazily decode SourceFile from metadata\n\nCurrently, source files from foreign crates are decoded up-front from metadata.\nSpans from those crates were matched with the corresponding source using binary search among those files.\n\nThis PR changes the strategy by matching spans to files during encoding. This allows to decode source files on-demand, instead of up-front. The on-disk format for spans becomes: `<tag> <position from start of file> <length> <file index> <crate (if foreign file)>`.", "tree": {"sha": "49e813da63717690a927445103916508ef9c1342", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49e813da63717690a927445103916508ef9c1342"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/468887ef91e46847dff57b6b234cff0fad17cb71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/468887ef91e46847dff57b6b234cff0fad17cb71", "html_url": "https://github.com/rust-lang/rust/commit/468887ef91e46847dff57b6b234cff0fad17cb71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/468887ef91e46847dff57b6b234cff0fad17cb71/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c943bad02626dddc5e5135b23c77429b6e4a063", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c943bad02626dddc5e5135b23c77429b6e4a063", "html_url": "https://github.com/rust-lang/rust/commit/6c943bad02626dddc5e5135b23c77429b6e4a063"}, {"sha": "0d41f9145ce4f884a53fddefe0624060eb22609b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d41f9145ce4f884a53fddefe0624060eb22609b", "html_url": "https://github.com/rust-lang/rust/commit/0d41f9145ce4f884a53fddefe0624060eb22609b"}], "stats": {"total": 428, "additions": 204, "deletions": 224}, "files": [{"sha": "889001d0a843f8a7ea9954aafa3868fcb9758ef3", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 102, "deletions": 126, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/468887ef91e46847dff57b6b234cff0fad17cb71/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/468887ef91e46847dff57b6b234cff0fad17cb71/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=468887ef91e46847dff57b6b234cff0fad17cb71", "patch": "@@ -99,7 +99,7 @@ pub(crate) struct CrateMetadata {\n     /// Proc macro descriptions for this crate, if it's a proc macro crate.\n     raw_proc_macros: Option<&'static [ProcMacro]>,\n     /// Source maps for code from the crate.\n-    source_map_import_info: OnceCell<Vec<ImportedSourceFile>>,\n+    source_map_import_info: Lock<Vec<Option<ImportedSourceFile>>>,\n     /// For every definition in this crate, maps its `DefPathHash` to its `DefIndex`.\n     def_path_hash_map: DefPathHashMapRef<'static>,\n     /// Likewise for ExpnHash.\n@@ -143,7 +143,8 @@ pub(crate) struct CrateMetadata {\n }\n \n /// Holds information about a rustc_span::SourceFile imported from another crate.\n-/// See `imported_source_files()` for more information.\n+/// See `imported_source_file()` for more information.\n+#[derive(Clone)]\n struct ImportedSourceFile {\n     /// This SourceFile's byte-offset within the source_map of its original crate\n     original_start_pos: rustc_span::BytePos,\n@@ -160,9 +161,6 @@ pub(super) struct DecodeContext<'a, 'tcx> {\n     sess: Option<&'tcx Session>,\n     tcx: Option<TyCtxt<'tcx>>,\n \n-    // Cache the last used source_file for translating spans as an optimization.\n-    last_source_file_index: usize,\n-\n     lazy_state: LazyState,\n \n     // Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n@@ -191,7 +189,6 @@ pub(super) trait Metadata<'a, 'tcx>: Copy {\n             blob: self.blob(),\n             sess: self.sess().or(tcx.map(|tcx| tcx.sess)),\n             tcx,\n-            last_source_file_index: 0,\n             lazy_state: LazyState::NoNode,\n             alloc_decoding_session: self\n                 .cdata()\n@@ -527,6 +524,9 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n             bug!(\"Cannot decode Span without Session.\")\n         };\n \n+        // Index of the file in the corresponding crate's list of encoded files.\n+        let metadata_index = u32::decode(decoder);\n+\n         // There are two possibilities here:\n         // 1. This is a 'local span', which is located inside a `SourceFile`\n         // that came from this crate. In this case, we use the source map data\n@@ -553,10 +553,10 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n         // to be based on the *foreign* crate (e.g. crate C), not the crate\n         // we are writing metadata for (e.g. crate B). This allows us to\n         // treat the 'local' and 'foreign' cases almost identically during deserialization:\n-        // we can call `imported_source_files` for the proper crate, and binary search\n+        // we can call `imported_source_file` for the proper crate, and binary search\n         // through the returned slice using our span.\n-        let imported_source_files = if tag == TAG_VALID_SPAN_LOCAL {\n-            decoder.cdata().imported_source_files(sess)\n+        let source_file = if tag == TAG_VALID_SPAN_LOCAL {\n+            decoder.cdata().imported_source_file(metadata_index, sess)\n         } else {\n             // When we encode a proc-macro crate, all `Span`s should be encoded\n             // with `TAG_VALID_SPAN_LOCAL`\n@@ -577,60 +577,30 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n                 cnum\n             );\n \n-            // Decoding 'foreign' spans should be rare enough that it's\n-            // not worth it to maintain a per-CrateNum cache for `last_source_file_index`.\n-            // We just set it to 0, to ensure that we don't try to access something out\n-            // of bounds for our initial 'guess'\n-            decoder.last_source_file_index = 0;\n-\n             let foreign_data = decoder.cdata().cstore.get_crate_data(cnum);\n-            foreign_data.imported_source_files(sess)\n+            foreign_data.imported_source_file(metadata_index, sess)\n         };\n \n-        let source_file = {\n-            // Optimize for the case that most spans within a translated item\n-            // originate from the same source_file.\n-            let last_source_file = &imported_source_files[decoder.last_source_file_index];\n-\n-            if lo >= last_source_file.original_start_pos && lo <= last_source_file.original_end_pos\n-            {\n-                last_source_file\n-            } else {\n-                let index = imported_source_files\n-                    .binary_search_by_key(&lo, |source_file| source_file.original_start_pos)\n-                    .unwrap_or_else(|index| index - 1);\n-\n-                // Don't try to cache the index for foreign spans,\n-                // as this would require a map from CrateNums to indices\n-                if tag == TAG_VALID_SPAN_LOCAL {\n-                    decoder.last_source_file_index = index;\n-                }\n-                &imported_source_files[index]\n-            }\n-        };\n-\n-        // Make sure our binary search above is correct.\n+        // Make sure our span is well-formed.\n         debug_assert!(\n-            lo >= source_file.original_start_pos && lo <= source_file.original_end_pos,\n-            \"Bad binary search: lo={:?} source_file.original_start_pos={:?} source_file.original_end_pos={:?}\",\n+            lo + source_file.original_start_pos <= source_file.original_end_pos,\n+            \"Malformed encoded span: lo={:?} source_file.original_start_pos={:?} source_file.original_end_pos={:?}\",\n             lo,\n             source_file.original_start_pos,\n             source_file.original_end_pos\n         );\n \n-        // Make sure we correctly filtered out invalid spans during encoding\n+        // Make sure we correctly filtered out invalid spans during encoding.\n         debug_assert!(\n-            hi >= source_file.original_start_pos && hi <= source_file.original_end_pos,\n-            \"Bad binary search: hi={:?} source_file.original_start_pos={:?} source_file.original_end_pos={:?}\",\n+            hi + source_file.original_start_pos <= source_file.original_end_pos,\n+            \"Malformed encoded span: hi={:?} source_file.original_start_pos={:?} source_file.original_end_pos={:?}\",\n             hi,\n             source_file.original_start_pos,\n             source_file.original_end_pos\n         );\n \n-        let lo =\n-            (lo + source_file.translated_source_file.start_pos) - source_file.original_start_pos;\n-        let hi =\n-            (hi + source_file.translated_source_file.start_pos) - source_file.original_start_pos;\n+        let lo = lo + source_file.translated_source_file.start_pos;\n+        let hi = hi + source_file.translated_source_file.start_pos;\n \n         // Do not try to decode parent for foreign spans.\n         Span::new(lo, hi, ctxt, None)\n@@ -1482,7 +1452,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     ///\n     /// Proc macro crates don't currently export spans, so this function does not have\n     /// to work for them.\n-    fn imported_source_files(self, sess: &Session) -> &'a [ImportedSourceFile] {\n+    fn imported_source_file(self, source_file_index: u32, sess: &Session) -> ImportedSourceFile {\n         fn filter<'a>(sess: &Session, path: Option<&'a Path>) -> Option<&'a Path> {\n             path.filter(|_| {\n                 // Only spend time on further checks if we have what to translate *to*.\n@@ -1570,90 +1540,96 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             }\n         };\n \n-        self.cdata.source_map_import_info.get_or_init(|| {\n-            let external_source_map = self.root.source_map.decode(self);\n-\n-            external_source_map\n-                .map(|source_file_to_import| {\n-                    // We can't reuse an existing SourceFile, so allocate a new one\n-                    // containing the information we need.\n-                    let rustc_span::SourceFile {\n-                        mut name,\n-                        src_hash,\n-                        start_pos,\n-                        end_pos,\n-                        lines,\n-                        multibyte_chars,\n-                        non_narrow_chars,\n-                        normalized_pos,\n-                        name_hash,\n-                        ..\n-                    } = source_file_to_import;\n-\n-                    // If this file is under $sysroot/lib/rustlib/src/ but has not been remapped\n-                    // during rust bootstrapping by `remap-debuginfo = true`, and the user\n-                    // wish to simulate that behaviour by -Z simulate-remapped-rust-src-base,\n-                    // then we change `name` to a similar state as if the rust was bootstrapped\n-                    // with `remap-debuginfo = true`.\n-                    // This is useful for testing so that tests about the effects of\n-                    // `try_to_translate_virtual_to_real` don't have to worry about how the\n-                    // compiler is bootstrapped.\n-                    if let Some(virtual_dir) =\n-                        &sess.opts.unstable_opts.simulate_remapped_rust_src_base\n-                    {\n-                        if let Some(real_dir) = &sess.opts.real_rust_source_base_dir {\n-                            if let rustc_span::FileName::Real(ref mut old_name) = name {\n-                                if let rustc_span::RealFileName::LocalPath(local) = old_name {\n-                                    if let Ok(rest) = local.strip_prefix(real_dir) {\n-                                        *old_name = rustc_span::RealFileName::Remapped {\n-                                            local_path: None,\n-                                            virtual_name: virtual_dir.join(rest),\n-                                        };\n-                                    }\n+        let mut import_info = self.cdata.source_map_import_info.lock();\n+        for _ in import_info.len()..=(source_file_index as usize) {\n+            import_info.push(None);\n+        }\n+        import_info[source_file_index as usize]\n+            .get_or_insert_with(|| {\n+                let source_file_to_import = self\n+                    .root\n+                    .source_map\n+                    .get(self, source_file_index)\n+                    .expect(\"missing source file\")\n+                    .decode(self);\n+\n+                // We can't reuse an existing SourceFile, so allocate a new one\n+                // containing the information we need.\n+                let rustc_span::SourceFile {\n+                    mut name,\n+                    src_hash,\n+                    start_pos,\n+                    end_pos,\n+                    lines,\n+                    multibyte_chars,\n+                    non_narrow_chars,\n+                    normalized_pos,\n+                    name_hash,\n+                    ..\n+                } = source_file_to_import;\n+\n+                // If this file is under $sysroot/lib/rustlib/src/ but has not been remapped\n+                // during rust bootstrapping by `remap-debuginfo = true`, and the user\n+                // wish to simulate that behaviour by -Z simulate-remapped-rust-src-base,\n+                // then we change `name` to a similar state as if the rust was bootstrapped\n+                // with `remap-debuginfo = true`.\n+                // This is useful for testing so that tests about the effects of\n+                // `try_to_translate_virtual_to_real` don't have to worry about how the\n+                // compiler is bootstrapped.\n+                if let Some(virtual_dir) = &sess.opts.unstable_opts.simulate_remapped_rust_src_base\n+                {\n+                    if let Some(real_dir) = &sess.opts.real_rust_source_base_dir {\n+                        if let rustc_span::FileName::Real(ref mut old_name) = name {\n+                            if let rustc_span::RealFileName::LocalPath(local) = old_name {\n+                                if let Ok(rest) = local.strip_prefix(real_dir) {\n+                                    *old_name = rustc_span::RealFileName::Remapped {\n+                                        local_path: None,\n+                                        virtual_name: virtual_dir.join(rest),\n+                                    };\n                                 }\n                             }\n                         }\n                     }\n+                }\n \n-                    // If this file's path has been remapped to `/rustc/$hash`,\n-                    // we might be able to reverse that (also see comments above,\n-                    // on `try_to_translate_virtual_to_real`).\n-                    try_to_translate_virtual_to_real(&mut name);\n-\n-                    let source_length = (end_pos - start_pos).to_usize();\n-\n-                    let local_version = sess.source_map().new_imported_source_file(\n-                        name,\n-                        src_hash,\n-                        name_hash,\n-                        source_length,\n-                        self.cnum,\n-                        lines,\n-                        multibyte_chars,\n-                        non_narrow_chars,\n-                        normalized_pos,\n-                        start_pos,\n-                        end_pos,\n-                    );\n-                    debug!(\n-                        \"CrateMetaData::imported_source_files alloc \\\n+                // If this file's path has been remapped to `/rustc/$hash`,\n+                // we might be able to reverse that (also see comments above,\n+                // on `try_to_translate_virtual_to_real`).\n+                try_to_translate_virtual_to_real(&mut name);\n+\n+                let source_length = (end_pos - start_pos).to_usize();\n+\n+                let local_version = sess.source_map().new_imported_source_file(\n+                    name,\n+                    src_hash,\n+                    name_hash,\n+                    source_length,\n+                    self.cnum,\n+                    lines,\n+                    multibyte_chars,\n+                    non_narrow_chars,\n+                    normalized_pos,\n+                    start_pos,\n+                    source_file_index,\n+                );\n+                debug!(\n+                    \"CrateMetaData::imported_source_files alloc \\\n                          source_file {:?} original (start_pos {:?} end_pos {:?}) \\\n                          translated (start_pos {:?} end_pos {:?})\",\n-                        local_version.name,\n-                        start_pos,\n-                        end_pos,\n-                        local_version.start_pos,\n-                        local_version.end_pos\n-                    );\n+                    local_version.name,\n+                    start_pos,\n+                    end_pos,\n+                    local_version.start_pos,\n+                    local_version.end_pos\n+                );\n \n-                    ImportedSourceFile {\n-                        original_start_pos: start_pos,\n-                        original_end_pos: end_pos,\n-                        translated_source_file: local_version,\n-                    }\n-                })\n-                .collect()\n-        })\n+                ImportedSourceFile {\n+                    original_start_pos: start_pos,\n+                    original_end_pos: end_pos,\n+                    translated_source_file: local_version,\n+                }\n+            })\n+            .clone()\n     }\n \n     fn get_generator_diagnostic_data(\n@@ -1716,7 +1692,7 @@ impl CrateMetadata {\n             trait_impls,\n             incoherent_impls: Default::default(),\n             raw_proc_macros,\n-            source_map_import_info: OnceCell::new(),\n+            source_map_import_info: Lock::new(Vec::new()),\n             def_path_hash_map,\n             expn_hash_map: Default::default(),\n             alloc_decoding_state,"}, {"sha": "ad2b6846a4bc04f3ec306662ddafdd39166ecf82", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/468887ef91e46847dff57b6b234cff0fad17cb71/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/468887ef91e46847dff57b6b234cff0fad17cb71/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=468887ef91e46847dff57b6b234cff0fad17cb71", "patch": "@@ -676,6 +676,9 @@ impl CrateStore for CStore {\n     }\n \n     fn import_source_files(&self, sess: &Session, cnum: CrateNum) {\n-        self.get_crate_data(cnum).imported_source_files(sess);\n+        let cdata = self.get_crate_data(cnum);\n+        for file_index in 0..cdata.root.source_map.size() {\n+            cdata.imported_source_file(file_index as u32, sess);\n+        }\n     }\n }"}, {"sha": "0d3a3efb0d331f4109ef7330fad9c9b4bc75a0ff", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 87, "deletions": 83, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/468887ef91e46847dff57b6b234cff0fad17cb71/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/468887ef91e46847dff57b6b234cff0fad17cb71/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=468887ef91e46847dff57b6b234cff0fad17cb71", "patch": "@@ -17,7 +17,6 @@ use rustc_hir::definitions::DefPathData;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::lang_items;\n use rustc_hir::{AnonConst, GenericParamKind};\n-use rustc_index::bit_set::GrowableBitSet;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_middle::middle::exported_symbols::{\n@@ -67,13 +66,10 @@ pub(super) struct EncodeContext<'a, 'tcx> {\n     // The indices (into the `SourceMap`'s `MonotonicVec`)\n     // of all of the `SourceFiles` that we need to serialize.\n     // When we serialize a `Span`, we insert the index of its\n-    // `SourceFile` into the `GrowableBitSet`.\n-    //\n-    // This needs to be a `GrowableBitSet` and not a\n-    // regular `BitSet` because we may actually import new `SourceFiles`\n-    // during metadata encoding, due to executing a query\n-    // with a result containing a foreign `Span`.\n-    required_source_files: Option<GrowableBitSet<usize>>,\n+    // `SourceFile` into the `FxIndexSet`.\n+    // The order inside the `FxIndexSet` is used as on-disk\n+    // order of `SourceFiles`, and encoded inside `Span`s.\n+    required_source_files: Option<FxIndexSet<usize>>,\n     is_proc_macro: bool,\n     hygiene_ctxt: &'a HygieneEncodeContext,\n     symbol_table: FxHashMap<Symbol, usize>,\n@@ -240,17 +236,15 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n             s.source_file_cache =\n                 (source_map.files()[source_file_index].clone(), source_file_index);\n         }\n+        let (ref source_file, source_file_index) = s.source_file_cache;\n+        debug_assert!(source_file.contains(span.lo));\n \n-        if !s.source_file_cache.0.contains(span.hi) {\n+        if !source_file.contains(span.hi) {\n             // Unfortunately, macro expansion still sometimes generates Spans\n             // that malformed in this way.\n             return TAG_PARTIAL_SPAN.encode(s);\n         }\n \n-        let source_files = s.required_source_files.as_mut().expect(\"Already encoded SourceMap!\");\n-        // Record the fact that we need to encode the data for this `SourceFile`\n-        source_files.insert(s.source_file_cache.1);\n-\n         // There are two possible cases here:\n         // 1. This span comes from a 'foreign' crate - e.g. some crate upstream of the\n         // crate we are writing metadata for. When the metadata for *this* crate gets\n@@ -267,7 +261,7 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n         // if we're a proc-macro crate.\n         // This allows us to avoid loading the dependencies of proc-macro crates: all of\n         // the information we need to decode `Span`s is stored in the proc-macro crate.\n-        let (tag, lo, hi) = if s.source_file_cache.0.is_imported() && !s.is_proc_macro {\n+        let (tag, metadata_index) = if source_file.is_imported() && !s.is_proc_macro {\n             // To simplify deserialization, we 'rebase' this span onto the crate it originally came from\n             // (the crate that 'owns' the file it references. These rebased 'lo' and 'hi' values\n             // are relative to the source map information for the 'foreign' crate whose CrateNum\n@@ -277,29 +271,41 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n             //\n             // All of this logic ensures that the final result of deserialization is a 'normal'\n             // Span that can be used without any additional trouble.\n-            let external_start_pos = {\n+            let metadata_index = {\n                 // Introduce a new scope so that we drop the 'lock()' temporary\n-                match &*s.source_file_cache.0.external_src.lock() {\n-                    ExternalSource::Foreign { original_start_pos, .. } => *original_start_pos,\n+                match &*source_file.external_src.lock() {\n+                    ExternalSource::Foreign { metadata_index, .. } => *metadata_index,\n                     src => panic!(\"Unexpected external source {:?}\", src),\n                 }\n             };\n-            let lo = (span.lo - s.source_file_cache.0.start_pos) + external_start_pos;\n-            let hi = (span.hi - s.source_file_cache.0.start_pos) + external_start_pos;\n \n-            (TAG_VALID_SPAN_FOREIGN, lo, hi)\n+            (TAG_VALID_SPAN_FOREIGN, metadata_index)\n         } else {\n-            (TAG_VALID_SPAN_LOCAL, span.lo, span.hi)\n+            // Record the fact that we need to encode the data for this `SourceFile`\n+            let source_files =\n+                s.required_source_files.as_mut().expect(\"Already encoded SourceMap!\");\n+            let (metadata_index, _) = source_files.insert_full(source_file_index);\n+            let metadata_index: u32 =\n+                metadata_index.try_into().expect(\"cannot export more than U32_MAX files\");\n+\n+            (TAG_VALID_SPAN_LOCAL, metadata_index)\n         };\n \n-        tag.encode(s);\n-        lo.encode(s);\n+        // Encode the start position relative to the file start, so we profit more from the\n+        // variable-length integer encoding.\n+        let lo = span.lo - source_file.start_pos;\n \n         // Encode length which is usually less than span.hi and profits more\n         // from the variable-length integer encoding that we use.\n-        let len = hi - lo;\n+        let len = span.hi - span.lo;\n+\n+        tag.encode(s);\n+        lo.encode(s);\n         len.encode(s);\n \n+        // Encode the index of the `SourceFile` for the span, in order to make decoding faster.\n+        metadata_index.encode(s);\n+\n         if tag == TAG_VALID_SPAN_FOREIGN {\n             // This needs to be two lines to avoid holding the `s.source_file_cache`\n             // while calling `cnum.encode(s)`\n@@ -469,7 +475,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.lazy(DefPathHashMapRef::BorrowedFromTcx(self.tcx.def_path_hash_to_def_index_map()))\n     }\n \n-    fn encode_source_map(&mut self) -> LazyArray<rustc_span::SourceFile> {\n+    fn encode_source_map(&mut self) -> LazyTable<u32, LazyValue<rustc_span::SourceFile>> {\n         let source_map = self.tcx.sess.source_map();\n         let all_source_files = source_map.files();\n \n@@ -480,66 +486,64 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let working_directory = &self.tcx.sess.opts.working_dir;\n \n-        let adapted = all_source_files\n-            .iter()\n-            .enumerate()\n-            .filter(|(idx, source_file)| {\n-                // Only serialize `SourceFile`s that were used\n-                // during the encoding of a `Span`\n-                required_source_files.contains(*idx) &&\n-                // Don't serialize imported `SourceFile`s, unless\n-                // we're in a proc-macro crate.\n-                (!source_file.is_imported() || self.is_proc_macro)\n-            })\n-            .map(|(_, source_file)| {\n-                // At export time we expand all source file paths to absolute paths because\n-                // downstream compilation sessions can have a different compiler working\n-                // directory, so relative paths from this or any other upstream crate\n-                // won't be valid anymore.\n-                //\n-                // At this point we also erase the actual on-disk path and only keep\n-                // the remapped version -- as is necessary for reproducible builds.\n-                match source_file.name {\n-                    FileName::Real(ref original_file_name) => {\n-                        let adapted_file_name =\n-                            source_map.path_mapping().to_embeddable_absolute_path(\n-                                original_file_name.clone(),\n-                                working_directory,\n-                            );\n-\n-                        if adapted_file_name != *original_file_name {\n-                            let mut adapted: SourceFile = (**source_file).clone();\n-                            adapted.name = FileName::Real(adapted_file_name);\n-                            adapted.name_hash = {\n-                                let mut hasher: StableHasher = StableHasher::new();\n-                                adapted.name.hash(&mut hasher);\n-                                hasher.finish::<u128>()\n-                            };\n-                            Lrc::new(adapted)\n-                        } else {\n-                            // Nothing to adapt\n-                            source_file.clone()\n-                        }\n+        let mut adapted = TableBuilder::default();\n+\n+        // Only serialize `SourceFile`s that were used during the encoding of a `Span`.\n+        //\n+        // The order in which we encode source files is important here: the on-disk format for\n+        // `Span` contains the index of the corresponding `SourceFile`.\n+        for (on_disk_index, &source_file_index) in required_source_files.iter().enumerate() {\n+            let source_file = &all_source_files[source_file_index];\n+            // Don't serialize imported `SourceFile`s, unless we're in a proc-macro crate.\n+            assert!(!source_file.is_imported() || self.is_proc_macro);\n+\n+            // At export time we expand all source file paths to absolute paths because\n+            // downstream compilation sessions can have a different compiler working\n+            // directory, so relative paths from this or any other upstream crate\n+            // won't be valid anymore.\n+            //\n+            // At this point we also erase the actual on-disk path and only keep\n+            // the remapped version -- as is necessary for reproducible builds.\n+            let mut source_file = match source_file.name {\n+                FileName::Real(ref original_file_name) => {\n+                    let adapted_file_name = source_map\n+                        .path_mapping()\n+                        .to_embeddable_absolute_path(original_file_name.clone(), working_directory);\n+\n+                    if adapted_file_name != *original_file_name {\n+                        let mut adapted: SourceFile = (**source_file).clone();\n+                        adapted.name = FileName::Real(adapted_file_name);\n+                        adapted.name_hash = {\n+                            let mut hasher: StableHasher = StableHasher::new();\n+                            adapted.name.hash(&mut hasher);\n+                            hasher.finish::<u128>()\n+                        };\n+                        Lrc::new(adapted)\n+                    } else {\n+                        // Nothing to adapt\n+                        source_file.clone()\n                     }\n-                    // expanded code, not from a file\n-                    _ => source_file.clone(),\n-                }\n-            })\n-            .map(|mut source_file| {\n-                // We're serializing this `SourceFile` into our crate metadata,\n-                // so mark it as coming from this crate.\n-                // This also ensures that we don't try to deserialize the\n-                // `CrateNum` for a proc-macro dependency - since proc macro\n-                // dependencies aren't loaded when we deserialize a proc-macro,\n-                // trying to remap the `CrateNum` would fail.\n-                if self.is_proc_macro {\n-                    Lrc::make_mut(&mut source_file).cnum = LOCAL_CRATE;\n                 }\n-                source_file\n-            })\n-            .collect::<Vec<_>>();\n+                // expanded code, not from a file\n+                _ => source_file.clone(),\n+            };\n+\n+            // We're serializing this `SourceFile` into our crate metadata,\n+            // so mark it as coming from this crate.\n+            // This also ensures that we don't try to deserialize the\n+            // `CrateNum` for a proc-macro dependency - since proc macro\n+            // dependencies aren't loaded when we deserialize a proc-macro,\n+            // trying to remap the `CrateNum` would fail.\n+            if self.is_proc_macro {\n+                Lrc::make_mut(&mut source_file).cnum = LOCAL_CRATE;\n+            }\n+\n+            let on_disk_index: u32 =\n+                on_disk_index.try_into().expect(\"cannot export more than U32_MAX files\");\n+            adapted.set(on_disk_index, self.lazy(source_file));\n+        }\n \n-        self.lazy_array(adapted.iter().map(|rc| &**rc))\n+        adapted.encode(&mut self.opaque)\n     }\n \n     fn encode_crate_root(&mut self) -> LazyValue<CrateRoot> {\n@@ -2261,7 +2265,7 @@ fn encode_metadata_impl(tcx: TyCtxt<'_>, path: &Path) {\n \n     let source_map_files = tcx.sess.source_map().files();\n     let source_file_cache = (source_map_files[0].clone(), 0);\n-    let required_source_files = Some(GrowableBitSet::with_capacity(source_map_files.len()));\n+    let required_source_files = Some(FxIndexSet::default());\n     drop(source_map_files);\n \n     let hygiene_ctxt = HygieneEncodeContext::default();"}, {"sha": "91d744879fd098b3e777fa329956b99e1657a1c9", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/468887ef91e46847dff57b6b234cff0fad17cb71/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/468887ef91e46847dff57b6b234cff0fad17cb71/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=468887ef91e46847dff57b6b234cff0fad17cb71", "patch": "@@ -249,7 +249,7 @@ pub(crate) struct CrateRoot {\n \n     def_path_hash_map: LazyValue<DefPathHashMapRef<'static>>,\n \n-    source_map: LazyArray<rustc_span::SourceFile>,\n+    source_map: LazyTable<u32, LazyValue<rustc_span::SourceFile>>,\n \n     compiler_builtins: bool,\n     needs_allocator: bool,"}, {"sha": "8d26cd6bee3340978a335750b71257972e45f0d2", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/468887ef91e46847dff57b6b234cff0fad17cb71/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/468887ef91e46847dff57b6b234cff0fad17cb71/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=468887ef91e46847dff57b6b234cff0fad17cb71", "patch": "@@ -1094,10 +1094,8 @@ pub enum ExternalSource {\n     Unneeded,\n     Foreign {\n         kind: ExternalSourceKind,\n-        /// This SourceFile's byte-offset within the source_map of its original crate.\n-        original_start_pos: BytePos,\n-        /// The end of this SourceFile within the source_map of its original crate.\n-        original_end_pos: BytePos,\n+        /// Index of the file inside metadata.\n+        metadata_index: u32,\n     },\n }\n "}, {"sha": "bc76ccc1d59a7d8723a52cb2bea49a30bddc4ebd", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/468887ef91e46847dff57b6b234cff0fad17cb71/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/468887ef91e46847dff57b6b234cff0fad17cb71/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=468887ef91e46847dff57b6b234cff0fad17cb71", "patch": "@@ -336,7 +336,7 @@ impl SourceMap {\n         mut file_local_non_narrow_chars: Vec<NonNarrowChar>,\n         mut file_local_normalized_pos: Vec<NormalizedPos>,\n         original_start_pos: BytePos,\n-        original_end_pos: BytePos,\n+        metadata_index: u32,\n     ) -> Lrc<SourceFile> {\n         let start_pos = self\n             .allocate_address_space(source_len)\n@@ -381,8 +381,7 @@ impl SourceMap {\n             src_hash,\n             external_src: Lock::new(ExternalSource::Foreign {\n                 kind: ExternalSourceKind::AbsentOk,\n-                original_start_pos,\n-                original_end_pos,\n+                metadata_index,\n             }),\n             start_pos,\n             end_pos,"}, {"sha": "3058ec45a6468d96a5557863d764f07cd5ad6e4e", "filename": "compiler/rustc_span/src/source_map/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/468887ef91e46847dff57b6b234cff0fad17cb71/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/468887ef91e46847dff57b6b234cff0fad17cb71/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs?ref=468887ef91e46847dff57b6b234cff0fad17cb71", "patch": "@@ -251,7 +251,7 @@ fn t10() {\n         non_narrow_chars,\n         normalized_pos,\n         start_pos,\n-        end_pos,\n+        0,\n     );\n \n     assert!("}, {"sha": "0b8222088b879509e60c7fae29ce3091728fd441", "filename": "src/test/ui/issues/issue-31173.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/468887ef91e46847dff57b6b234cff0fad17cb71/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/468887ef91e46847dff57b6b234cff0fad17cb71/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr?ref=468887ef91e46847dff57b6b234cff0fad17cb71", "patch": "@@ -18,16 +18,16 @@ error[E0599]: the method `collect` exists for struct `Cloned<TakeWhile<&mut std:\n LL |         .collect();\n    |          ^^^^^^^ method cannot be called on `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>>` due to unsatisfied trait bounds\n    |\n-  ::: $SRC_DIR/core/src/iter/adapters/cloned.rs:LL:COL\n-   |\n-LL | pub struct Cloned<I> {\n-   | -------------------- doesn't satisfy `_: Iterator`\n-   |\n   ::: $SRC_DIR/core/src/iter/adapters/take_while.rs:LL:COL\n    |\n LL | pub struct TakeWhile<I, P> {\n    | -------------------------- doesn't satisfy `<_ as Iterator>::Item = &_`\n    |\n+  ::: $SRC_DIR/core/src/iter/adapters/cloned.rs:LL:COL\n+   |\n+LL | pub struct Cloned<I> {\n+   | -------------------- doesn't satisfy `_: Iterator`\n+   |\n    = note: the following trait bounds were not satisfied:\n            `<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]> as Iterator>::Item = &_`\n            which is required by `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>>: Iterator`"}]}