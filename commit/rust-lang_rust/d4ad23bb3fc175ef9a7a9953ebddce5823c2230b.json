{"sha": "d4ad23bb3fc175ef9a7a9953ebddce5823c2230b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0YWQyM2JiM2ZjMTc1ZWY5YTdhOTk1M2ViZGRjZTU4MjNjMjIzMGI=", "commit": {"author": {"name": "Grzegorz", "email": "grzegorz.bartoszek@thaumatec.com", "date": "2019-06-09T11:24:34Z"}, "committer": {"name": "Grzegorz", "email": "grzegorz.bartoszek@thaumatec.com", "date": "2019-06-12T11:43:36Z"}, "message": "redundant_closure_for_method_calls fixes:\nlint does not trigger when there is a difference in mutability\nlint does not trigger when the method belongs to a trait which is not implemebted directly (Deref)", "tree": {"sha": "e03f0a84db88a477640062f321f17b7c6cae4708", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e03f0a84db88a477640062f321f17b7c6cae4708"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4ad23bb3fc175ef9a7a9953ebddce5823c2230b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4ad23bb3fc175ef9a7a9953ebddce5823c2230b", "html_url": "https://github.com/rust-lang/rust/commit/d4ad23bb3fc175ef9a7a9953ebddce5823c2230b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4ad23bb3fc175ef9a7a9953ebddce5823c2230b/comments", "author": null, "committer": null, "parents": [{"sha": "bd33a97cc46c2bc8ba5e3b228288720d3bc3b3f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd33a97cc46c2bc8ba5e3b228288720d3bc3b3f3", "html_url": "https://github.com/rust-lang/rust/commit/bd33a97cc46c2bc8ba5e3b228288720d3bc3b3f3"}], "stats": {"total": 53, "additions": 47, "deletions": 6}, "files": [{"sha": "e4fcd271bbcbc57f6704f2fd25730f17c2992dbb", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d4ad23bb3fc175ef9a7a9953ebddce5823c2230b/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ad23bb3fc175ef9a7a9953ebddce5823c2230b/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=d4ad23bb3fc175ef9a7a9953ebddce5823c2230b", "patch": "@@ -6,7 +6,9 @@ use rustc::ty::{self, Ty};\n use rustc::{declare_lint_pass, declare_tool_lint};\n use rustc_errors::Applicability;\n \n-use crate::utils::{is_adjusted, iter_input_pats, snippet_opt, span_lint_and_then, type_is_unsafe_function};\n+use crate::utils::{\n+    implements_trait, is_adjusted, iter_input_pats, snippet_opt, span_lint_and_then, type_is_unsafe_function,\n+};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for closures which just call another function where\n@@ -152,7 +154,9 @@ fn get_ufcs_type_name(\n     let actual_type_of_self = &cx.tables.node_type(self_arg.hir_id);\n \n     if let Some(trait_id) = cx.tcx.trait_of_item(method_def_id) {\n-        if match_borrow_depth(expected_type_of_self, &actual_type_of_self) {\n+        if match_borrow_depth(expected_type_of_self, &actual_type_of_self)\n+            && implements_trait(cx, actual_type_of_self, trait_id, &[])\n+        {\n             return Some(cx.tcx.def_path_str(trait_id));\n         }\n     }\n@@ -168,7 +172,7 @@ fn get_ufcs_type_name(\n \n fn match_borrow_depth(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n     match (&lhs.sty, &rhs.sty) {\n-        (ty::Ref(_, t1, _), ty::Ref(_, t2, _)) => match_borrow_depth(&t1, &t2),\n+        (ty::Ref(_, t1, mut1), ty::Ref(_, t2, mut2)) => mut1 == mut2 && match_borrow_depth(&t1, &t2),\n         (l, r) => match (l, r) {\n             (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _)) => false,\n             (_, _) => true,\n@@ -183,9 +187,8 @@ fn match_types(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n         | (ty::Int(_), ty::Int(_))\n         | (ty::Uint(_), ty::Uint(_))\n         | (ty::Str, ty::Str) => true,\n-        (ty::Ref(_, t1, _), ty::Ref(_, t2, _))\n-        | (ty::Array(t1, _), ty::Array(t2, _))\n-        | (ty::Slice(t1), ty::Slice(t2)) => match_types(t1, t2),\n+        (ty::Ref(_, t1, mut1), ty::Ref(_, t2, mut2)) => mut1 == mut2 && match_types(t1, t2),\n+        (ty::Array(t1, _), ty::Array(t2, _)) | (ty::Slice(t1), ty::Slice(t2)) => match_types(t1, t2),\n         (ty::Adt(def1, _), ty::Adt(def2, _)) => def1 == def2,\n         (_, _) => false,\n     }"}, {"sha": "5d62a6d9b01efe8926a4de38f7b683ab7cf27f28", "filename": "tests/ui/eta.fixed", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d4ad23bb3fc175ef9a7a9953ebddce5823c2230b/tests%2Fui%2Feta.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d4ad23bb3fc175ef9a7a9953ebddce5823c2230b/tests%2Fui%2Feta.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.fixed?ref=d4ad23bb3fc175ef9a7a9953ebddce5823c2230b", "patch": "@@ -184,3 +184,22 @@ fn make_lazy(f: impl Fn() -> fn(u8) -> u8) -> impl Fn(u8) -> u8 {\n     // called. This changes semantics, so the closure must stay.\n     Box::new(move |x| f()(x))\n }\n+\n+fn call<F: FnOnce(&mut String) -> String>(f: F) -> String {\n+    f(&mut \"Hello\".to_owned())\n+}\n+fn test_difference_in_mutability() {\n+    call(|s| s.clone());\n+}\n+\n+struct Bar;\n+impl std::ops::Deref for Bar {\n+    type Target = str;\n+    fn deref(&self) -> &str {\n+        \"hi\"\n+    }\n+}\n+\n+fn test_deref_with_trait_method() {\n+    let _ = [Bar].iter().map(|s| s.to_string()).collect::<Vec<_>>();\n+}"}, {"sha": "a9c4b209960c9838d7ff55aa12051eb56a73d5b3", "filename": "tests/ui/eta.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d4ad23bb3fc175ef9a7a9953ebddce5823c2230b/tests%2Fui%2Feta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ad23bb3fc175ef9a7a9953ebddce5823c2230b/tests%2Fui%2Feta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.rs?ref=d4ad23bb3fc175ef9a7a9953ebddce5823c2230b", "patch": "@@ -184,3 +184,22 @@ fn make_lazy(f: impl Fn() -> fn(u8) -> u8) -> impl Fn(u8) -> u8 {\n     // called. This changes semantics, so the closure must stay.\n     Box::new(move |x| f()(x))\n }\n+\n+fn call<F: FnOnce(&mut String) -> String>(f: F) -> String {\n+    f(&mut \"Hello\".to_owned())\n+}\n+fn test_difference_in_mutability() {\n+    call(|s| s.clone());\n+}\n+\n+struct Bar;\n+impl std::ops::Deref for Bar {\n+    type Target = str;\n+    fn deref(&self) -> &str {\n+        \"hi\"\n+    }\n+}\n+\n+fn test_deref_with_trait_method() {\n+    let _ = [Bar].iter().map(|s| s.to_string()).collect::<Vec<_>>();\n+}"}]}