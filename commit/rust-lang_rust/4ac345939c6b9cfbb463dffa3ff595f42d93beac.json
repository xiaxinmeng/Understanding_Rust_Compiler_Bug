{"sha": "4ac345939c6b9cfbb463dffa3ff595f42d93beac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhYzM0NTkzOWM2YjljZmJiNDYzZGZmYTNmZjU5NWY0MmQ5M2JlYWM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-12-15T02:57:52Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-12-17T21:45:38Z"}, "message": "rt: Cache an extra stack segment to avoid bad behavior at stack boundaries", "tree": {"sha": "9d8031c3d1c86c47d020c6d039ed06953b867268", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d8031c3d1c86c47d020c6d039ed06953b867268"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ac345939c6b9cfbb463dffa3ff595f42d93beac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ac345939c6b9cfbb463dffa3ff595f42d93beac", "html_url": "https://github.com/rust-lang/rust/commit/4ac345939c6b9cfbb463dffa3ff595f42d93beac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ac345939c6b9cfbb463dffa3ff595f42d93beac/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ed5117a9d1cdf0024b8c14d810a71d48c365350", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ed5117a9d1cdf0024b8c14d810a71d48c365350", "html_url": "https://github.com/rust-lang/rust/commit/0ed5117a9d1cdf0024b8c14d810a71d48c365350"}], "stats": {"total": 92, "additions": 80, "deletions": 12}, "files": [{"sha": "7434a4673cd8584040e2d88800fd98b4b934bc91", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 79, "deletions": 12, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/4ac345939c6b9cfbb463dffa3ff595f42d93beac/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4ac345939c6b9cfbb463dffa3ff595f42d93beac/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=4ac345939c6b9cfbb463dffa3ff595f42d93beac", "patch": "@@ -63,16 +63,71 @@ get_next_stk_size(rust_scheduler *sched, rust_task *task,\n     sz = std::max(sz, next);\n \n     LOG(task, mem, \"next stack size: %\" PRIdPTR, sz);\n+    I(sched, requested <= sz);\n     return sz;\n }\n \n // Task stack segments. Heap allocated and chained together.\n \n+static void\n+config_valgrind_stack(stk_seg *stk) {\n+    stk->valgrind_id =\n+        VALGRIND_STACK_REGISTER(&stk->data[0],\n+                                stk->end);\n+#ifndef NVALGRIND\n+    // Establish that the stack is accessible.  This must be done when reusing\n+    // old stack segments, since the act of popping the stack previously\n+    // caused valgrind to consider the whole thing inaccessible.\n+    size_t sz = stk->end - (uintptr_t)&stk->data[0];\n+    VALGRIND_MAKE_MEM_UNDEFINED(stk->data, sz);\n+\n+    // Establish some guard bytes so valgrind will tell\n+    // us if we run off the end of the stack\n+    VALGRIND_MAKE_MEM_NOACCESS(stk->data, STACK_NOACCESS_SIZE);\n+#endif\n+}\n+\n+static void\n+unconfig_valgrind_stack(stk_seg *stk) {\n+#ifndef NVALGRIND\n+    // Make the guard bytes accessible again, but undefined\n+    VALGRIND_MAKE_MEM_UNDEFINED(stk->data, STACK_NOACCESS_SIZE);\n+#endif\n+VALGRIND_STACK_DEREGISTER(stk->valgrind_id);\n+}\n+\n+static void\n+free_stk(rust_task *task, stk_seg *stk) {\n+    LOGPTR(task->sched, \"freeing stk segment\", (uintptr_t)stk);\n+    task->free(stk);\n+}\n+\n static stk_seg*\n new_stk(rust_scheduler *sched, rust_task *task, size_t requested_sz)\n {\n+    LOG(task, mem, \"creating new stack for task %\" PRIxPTR, task);\n+\n     // The minimum stack size, in bytes, of a Rust stack, excluding red zone\n     size_t min_sz = get_min_stk_size(sched->min_stack_size);\n+\n+    // Try to reuse an existing stack segment\n+    if (task->stk != NULL && task->stk->prev != NULL) {\n+        size_t prev_sz = (size_t)(task->stk->prev->end\n+                                  - (uintptr_t)&task->stk->prev->data[0]\n+                                  - RED_ZONE_SIZE);\n+        if (min_sz <= prev_sz) {\n+            LOG(task, mem, \"reusing existing stack\");\n+            task->stk = task->stk->prev;\n+            A(sched, task->stk->prev == NULL, \"Bogus stack ptr\");\n+            config_valgrind_stack(task->stk);\n+            return task->stk;\n+        } else {\n+            LOG(task, mem, \"existing stack is not big enough\");\n+            free_stk(task, task->stk->prev);\n+            task->stk->prev = NULL;\n+        }\n+    }\n+\n     // The size of the current stack segment, excluding red zone\n     size_t current_sz = 0;\n     if (task->stk != NULL) {\n@@ -88,16 +143,13 @@ new_stk(rust_scheduler *sched, rust_task *task, size_t requested_sz)\n     stk_seg *stk = (stk_seg *)task->malloc(sz, \"stack\");\n     LOGPTR(task->sched, \"new stk\", (uintptr_t)stk);\n     memset(stk, 0, sizeof(stk_seg));\n+    stk->prev = NULL;\n     stk->next = task->stk;\n     stk->end = (uintptr_t) &stk->data[rust_stk_sz + RED_ZONE_SIZE];\n     LOGPTR(task->sched, \"stk end\", stk->end);\n-    stk->valgrind_id =\n-        VALGRIND_STACK_REGISTER(&stk->data[0],\n-                                &stk->data[rust_stk_sz + RED_ZONE_SIZE]);\n-#ifndef NVALGRIND\n-    VALGRIND_MAKE_MEM_NOACCESS(stk->data, STACK_NOACCESS_SIZE);\n-#endif\n+\n     task->stk = stk;\n+    config_valgrind_stack(task->stk);\n     return stk;\n }\n \n@@ -108,12 +160,27 @@ del_stk(rust_task *task, stk_seg *stk)\n \n     task->stk = stk->next;\n \n-#ifndef NVALGRIND\n-    VALGRIND_MAKE_MEM_DEFINED(stk->data, STACK_NOACCESS_SIZE);\n-#endif\n-    VALGRIND_STACK_DEREGISTER(stk->valgrind_id);\n-    LOGPTR(task->sched, \"freeing stk segment\", (uintptr_t)stk);\n-    task->free(stk);\n+    bool delete_stack = false;\n+    if (task->stk != NULL) {\n+        // Don't actually delete this stack. Save it to reuse later,\n+        // preventing the pathological case where we repeatedly reallocate\n+        // the stack for the next frame.\n+        task->stk->prev = stk;\n+    } else {\n+        // This is the last stack, delete it.\n+        delete_stack = true;\n+    }\n+\n+    // Delete the previous previous stack\n+    if (stk->prev != NULL) {\n+        free_stk(task, stk->prev);\n+        stk->prev = NULL;\n+    }\n+\n+    unconfig_valgrind_stack(stk);\n+    if (delete_stack) {\n+        free_stk(task, stk);\n+    }\n }\n \n // Tasks"}, {"sha": "3339ad42bfdd268f6e61eaab84ce337af1bc8808", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ac345939c6b9cfbb463dffa3ff595f42d93beac/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/4ac345939c6b9cfbb463dffa3ff595f42d93beac/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=4ac345939c6b9cfbb463dffa3ff595f42d93beac", "patch": "@@ -24,6 +24,7 @@ struct chan_handle {\n struct rust_box;\n \n struct stk_seg {\n+    stk_seg *prev;\n     stk_seg *next;\n     uintptr_t end;\n     unsigned int valgrind_id;"}]}