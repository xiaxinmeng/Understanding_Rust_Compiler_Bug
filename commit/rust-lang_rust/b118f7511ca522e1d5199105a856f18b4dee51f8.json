{"sha": "b118f7511ca522e1d5199105a856f18b4dee51f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxMThmNzUxMWNhNTIyZTFkNTE5OTEwNWE4NTZmMThiNGRlZTUxZjg=", "commit": {"author": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2019-08-04T11:06:07Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2019-08-05T13:53:54Z"}, "message": "Optimize Parser::is_composite a little", "tree": {"sha": "a65c68c8ebf131d90d30e871395e61e1f1e96c4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a65c68c8ebf131d90d30e871395e61e1f1e96c4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b118f7511ca522e1d5199105a856f18b4dee51f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b118f7511ca522e1d5199105a856f18b4dee51f8", "html_url": "https://github.com/rust-lang/rust/commit/b118f7511ca522e1d5199105a856f18b4dee51f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b118f7511ca522e1d5199105a856f18b4dee51f8/comments", "author": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f5ac06b47b040936c6e0a1fbac9cdba13e26197", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f5ac06b47b040936c6e0a1fbac9cdba13e26197", "html_url": "https://github.com/rust-lang/rust/commit/6f5ac06b47b040936c6e0a1fbac9cdba13e26197"}], "stats": {"total": 54, "additions": 35, "deletions": 19}, "files": [{"sha": "393586561b10328ecc4125e6ebc79eeca861a5c0", "filename": "crates/ra_parser/src/parser.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b118f7511ca522e1d5199105a856f18b4dee51f8/crates%2Fra_parser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b118f7511ca522e1d5199105a856f18b4dee51f8/crates%2Fra_parser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fparser.rs?ref=b118f7511ca522e1d5199105a856f18b4dee51f8", "patch": "@@ -6,7 +6,7 @@ use crate::{\n     event::Event,\n     ParseError,\n     SyntaxKind::{self, EOF, ERROR, TOMBSTONE},\n-    TokenSet, TokenSource, T,\n+    Token, TokenSet, TokenSource, T,\n };\n \n /// `Parser` struct provides the low-level API for\n@@ -87,8 +87,9 @@ impl<'t> Parser<'t> {\n         let mut i = 0;\n \n         loop {\n-            let mut kind = self.token_source.lookahead_nth(i).kind;\n-            if let Some((composited, step)) = self.is_composite(kind, i) {\n+            let token = self.token_source.lookahead_nth(i);\n+            let mut kind = token.kind;\n+            if let Some((composited, step)) = self.is_composite(token, i) {\n                 kind = composited;\n                 i += step;\n             } else {\n@@ -250,32 +251,47 @@ impl<'t> Parser<'t> {\n     }\n \n     /// helper function for check if it is composite.\n-    fn is_composite(&self, kind: SyntaxKind, n: usize) -> Option<(SyntaxKind, usize)> {\n+    fn is_composite(&self, first: Token, n: usize) -> Option<(SyntaxKind, usize)> {\n         // We assume the dollars will not occuried between\n         // mult-byte tokens\n \n-        let first = self.token_source.lookahead_nth(n);\n+        let jn1 = first.is_jointed_to_next;\n+        if !jn1 && first.kind != T![-] {\n+            return None;\n+        }\n+\n         let second = self.token_source.lookahead_nth(n + 1);\n+        if first.kind == T![-] && second.kind == T![>] {\n+            return Some((T![->], 2));\n+        }\n+        if !jn1 {\n+            return None;\n+        }\n+\n+        match (first.kind, second.kind) {\n+            (T![:], T![:]) => return Some((T![::], 2)),\n+            (T![=], T![=]) => return Some((T![==], 2)),\n+            (T![=], T![>]) => return Some((T![=>], 2)),\n+            (T![!], T![=]) => return Some((T![!=], 2)),\n+            _ => {}\n+        }\n+\n+        if first.kind != T![.] || second.kind != T![.] {\n+            return None;\n+        }\n+\n         let third = self.token_source.lookahead_nth(n + 2);\n \n-        let jn1 = first.is_jointed_to_next;\n-        let la2 = second.kind;\n         let jn2 = second.is_jointed_to_next;\n         let la3 = third.kind;\n \n-        match kind {\n-            T![.] if jn1 && la2 == T![.] && jn2 && la3 == T![.] => Some((T![...], 3)),\n-            T![.] if jn1 && la2 == T![.] && la3 == T![=] => Some((T![..=], 3)),\n-            T![.] if jn1 && la2 == T![.] => Some((T![..], 2)),\n-\n-            T![:] if jn1 && la2 == T![:] => Some((T![::], 2)),\n-            T![=] if jn1 && la2 == T![=] => Some((T![==], 2)),\n-            T![=] if jn1 && la2 == T![>] => Some((T![=>], 2)),\n-\n-            T![!] if jn1 && la2 == T![=] => Some((T![!=], 2)),\n-            T![-] if la2 == T![>] => Some((T![->], 2)),\n-            _ => None,\n+        if jn2 && la3 == T![.] {\n+            return Some((T![...], 3));\n+        }\n+        if la3 == T![=] {\n+            return Some((T![..=], 3));\n         }\n+        return Some((T![..], 2));\n     }\n \n     fn eat_dollars(&mut self) {"}]}