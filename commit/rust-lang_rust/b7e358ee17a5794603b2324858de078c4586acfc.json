{"sha": "b7e358ee17a5794603b2324858de078c4586acfc", "node_id": "C_kwDOAAsO6NoAKGI3ZTM1OGVlMTdhNTc5NDYwM2IyMzI0ODU4ZGUwNzhjNDU4NmFjZmM", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-09-25T20:48:50Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-09-25T23:30:39Z"}, "message": "Trivialize tracking of unreachable subpatterns\n\nPhew it had been very had to make it work without a good way to identify\npatterns. Now it's dead easy.", "tree": {"sha": "1b6bf66a4de15818e3cf250d67309281d100cabd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b6bf66a4de15818e3cf250d67309281d100cabd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7e358ee17a5794603b2324858de078c4586acfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7e358ee17a5794603b2324858de078c4586acfc", "html_url": "https://github.com/rust-lang/rust/commit/b7e358ee17a5794603b2324858de078c4586acfc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7e358ee17a5794603b2324858de078c4586acfc/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6062bda4ccf3c87ddecda6b0a97b961b0f3fa04", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6062bda4ccf3c87ddecda6b0a97b961b0f3fa04", "html_url": "https://github.com/rust-lang/rust/commit/b6062bda4ccf3c87ddecda6b0a97b961b0f3fa04"}], "stats": {"total": 392, "additions": 95, "deletions": 297}, "files": [{"sha": "69a7d44ff3972894bcc7d0768e8844086db54fe9", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 60, "deletions": 19, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b7e358ee17a5794603b2324858de078c4586acfc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e358ee17a5794603b2324858de078c4586acfc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=b7e358ee17a5794603b2324858de078c4586acfc", "patch": "@@ -62,6 +62,7 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Integer, Size, VariantIdx};\n \n use smallvec::{smallvec, SmallVec};\n+use std::cell::Cell;\n use std::cmp::{self, max, min, Ordering};\n use std::fmt;\n use std::iter::{once, IntoIterator};\n@@ -1219,21 +1220,45 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n     }\n }\n \n-#[derive(Clone)]\n+/// Values and patterns can be represented as a constructor applied to some fields. This represents\n+/// a pattern in this form.\n+/// This also keeps track of whether the pattern has been foundreachable during analysis. For this\n+/// reason we should be careful not to clone patterns for which we care about that. Use\n+/// `clone_and_forget_reachability` is you're sure.\n pub(crate) struct DeconstructedPat<'p, 'tcx> {\n     ctor: Constructor<'tcx>,\n     fields: Fields<'p, 'tcx>,\n     ty: Ty<'tcx>,\n     span: Span,\n+    reachable: Cell<bool>,\n }\n \n impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n     pub(super) fn wildcard(ty: Ty<'tcx>) -> Self {\n-        Self::new(Wildcard, Fields::empty(), ty)\n+        Self::new(Wildcard, Fields::empty(), ty, DUMMY_SP)\n     }\n \n-    pub(super) fn new(ctor: Constructor<'tcx>, fields: Fields<'p, 'tcx>, ty: Ty<'tcx>) -> Self {\n-        DeconstructedPat { ctor, fields, ty, span: DUMMY_SP }\n+    pub(super) fn new(\n+        ctor: Constructor<'tcx>,\n+        fields: Fields<'p, 'tcx>,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> Self {\n+        DeconstructedPat { ctor, fields, ty, span, reachable: Cell::new(false) }\n+    }\n+\n+    /// Construct a pattern that matches everything that starts with this constructor.\n+    /// For example, if `ctor` is a `Constructor::Variant` for `Option::Some`, we get the pattern\n+    /// `Some(_)`.\n+    pub(super) fn wild_from_ctor(pcx: PatCtxt<'_, 'p, 'tcx>, ctor: Constructor<'tcx>) -> Self {\n+        let fields = Fields::wildcards(pcx.cx, pcx.ty, &ctor);\n+        DeconstructedPat::new(ctor, fields, pcx.ty, DUMMY_SP)\n+    }\n+\n+    /// Clone this value. This method emphasizes that cloning loses reachability information and\n+    /// should be done carefully.\n+    pub(super) fn clone_and_forget_reachability(&self) -> Self {\n+        DeconstructedPat::new(self.ctor.clone(), self.fields, self.ty, self.span)\n     }\n \n     pub(crate) fn from_pat(cx: &MatchCheckCtxt<'p, 'tcx>, pat: &Pat<'tcx>) -> Self {\n@@ -1332,12 +1357,9 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                             // So here, the constructor for a `\"foo\"` pattern is `&` (represented by\n                             // `Single`), and has one field. That field has constructor `Str(value)` and no\n                             // fields.\n-                            let subpattern = DeconstructedPat {\n-                                ctor: Str(value),\n-                                fields: Fields::empty(),\n-                                ty: t, // `t` is `str`, not `&str`\n-                                span: pat.span,\n-                            };\n+                            // Note: `t` is `str`, not `&str`.\n+                            let subpattern =\n+                                DeconstructedPat::new(Str(value), Fields::empty(), t, pat.span);\n                             ctor = Single;\n                             fields = Fields::singleton(cx, subpattern)\n                         }\n@@ -1386,7 +1408,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                 fields = Fields::from_iter(cx, pats.into_iter().map(mkpat));\n             }\n         }\n-        DeconstructedPat { ctor, fields, ty: pat.ty, span: pat.span }\n+        DeconstructedPat::new(ctor, fields, pat.ty, pat.span)\n     }\n \n     pub(crate) fn to_pat(&self, cx: &MatchCheckCtxt<'p, 'tcx>) -> Pat<'tcx> {\n@@ -1475,14 +1497,6 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n         Pat { ty: self.ty, span: DUMMY_SP, kind: Box::new(pat) }\n     }\n \n-    /// Construct a pattern that matches everything that starts with this constructor.\n-    // For example, if `ctor` is a `Constructor::Variant` for `Option::Some`, we get the pattern\n-    // `Some(_)`.\n-    pub(super) fn wild_from_ctor(pcx: PatCtxt<'_, 'p, 'tcx>, ctor: Constructor<'tcx>) -> Self {\n-        let fields = Fields::wildcards(pcx.cx, pcx.ty, &ctor);\n-        DeconstructedPat::new(ctor, fields, pcx.ty)\n-    }\n-\n     pub(super) fn is_or_pat(&self) -> bool {\n         matches!(self.ctor, Or)\n     }\n@@ -1543,6 +1557,33 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n             _ => self.fields.iter_patterns().collect(),\n         }\n     }\n+\n+    /// We keep track for each pattern if it was ever reachable during the analysis. This is used\n+    /// with `unreachable_spans` to report unreachable subpatterns arising from or patterns.\n+    pub(super) fn set_reachable(&self) {\n+        self.reachable.set(true)\n+    }\n+    pub(super) fn is_reachable(&self) -> bool {\n+        self.reachable.get()\n+    }\n+\n+    /// Report the spans of subpatterns that were not reachable, if any.\n+    pub(super) fn unreachable_spans(&self) -> Vec<Span> {\n+        let mut spans = Vec::new();\n+        self.collect_unreachable_spans(&mut spans);\n+        spans\n+    }\n+\n+    fn collect_unreachable_spans(&self, spans: &mut Vec<Span>) {\n+        // We don't look at subpatterns if we already reported the whole pattern as unreachable.\n+        if !self.is_reachable() {\n+            spans.push(self.span);\n+        } else {\n+            for p in self.iter_fields() {\n+                p.collect_unreachable_spans(spans);\n+            }\n+        }\n+    }\n }\n \n /// This is mostly copied from the `Pat` impl. This is best effort and not good enough for a"}, {"sha": "650a87b2d885976e8a9b04a0e9492e58c52e0069", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 35, "deletions": 278, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/b7e358ee17a5794603b2324858de078c4586acfc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e358ee17a5794603b2324858de078c4586acfc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=b7e358ee17a5794603b2324858de078c4586acfc", "patch": "@@ -287,18 +287,17 @@ use super::check_match::{joined_uncovered_patterns, pattern_not_covered_label};\n use super::deconstruct_pat::{Constructor, DeconstructedPat, Fields, SplitWildcard};\n \n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fx::FxHashMap;\n \n use rustc_arena::TypedArena;\n use rustc_hir::def_id::DefId;\n use rustc_hir::HirId;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint::builtin::NON_EXHAUSTIVE_OMITTED_PATTERNS;\n-use rustc_span::Span;\n+use rustc_span::{Span, DUMMY_SP};\n \n use smallvec::{smallvec, SmallVec};\n use std::fmt;\n-use std::iter::IntoIterator;\n+use std::iter::once;\n \n crate struct MatchCheckCtxt<'p, 'tcx> {\n     crate tcx: TyCtxt<'tcx>,\n@@ -512,256 +511,16 @@ impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n     }\n }\n \n-/// Given a pattern or a pattern-stack, this struct captures a set of its subpatterns. We use that\n-/// to track reachable sub-patterns arising from or-patterns. In the absence of or-patterns this\n-/// will always be either `Empty` (the whole pattern is unreachable) or `Full` (the whole pattern\n-/// is reachable). When there are or-patterns, some subpatterns may be reachable while others\n-/// aren't. In this case the whole pattern still counts as reachable, but we will lint the\n-/// unreachable subpatterns.\n-///\n-/// This supports a limited set of operations, so not all possible sets of subpatterns can be\n-/// represented. That's ok, we only want the ones that make sense for our usage.\n-///\n-/// What we're doing is illustrated by this:\n-/// ```\n-/// match (true, 0) {\n-///     (true, 0) => {}\n-///     (_, 1) => {}\n-///     (true | false, 0 | 1) => {}\n-/// }\n-/// ```\n-/// When we try the alternatives of the `true | false` or-pattern, the last `0` is reachable in the\n-/// `false` alternative but not the `true`. So overall it is reachable. By contrast, the last `1`\n-/// is not reachable in either alternative, so we want to signal this to the user.\n-/// Therefore we take the union of sets of reachable patterns coming from different alternatives in\n-/// order to figure out which subpatterns are overall reachable.\n-///\n-/// Invariant: we try to construct the smallest representation we can. In particular if\n-/// `self.is_empty()` we ensure that `self` is `Empty`, and same with `Full`. This is not important\n-/// for correctness currently.\n-#[derive(Debug, Clone)]\n-enum SubPatSet {\n-    /// The empty set. This means the pattern is unreachable.\n-    Empty,\n-    /// The set containing the full pattern.\n-    Full,\n-    /// If the pattern is a pattern with a constructor or a pattern-stack, we store a set for each\n-    /// of its subpatterns. Missing entries in the map are implicitly full, because that's the\n-    /// common case.\n-    Seq { subpats: FxHashMap<usize, SubPatSet> },\n-    /// If the pattern is an or-pattern, we store a set for each of its alternatives. Missing\n-    /// entries in the map are implicitly empty. Note: we always flatten nested or-patterns.\n-    Alt {\n-        subpats: FxHashMap<usize, SubPatSet>,\n-        /// Span of each alternative in the pattern\n-        spans: Vec<Span>,\n-    },\n-}\n-\n-impl SubPatSet {\n-    fn full() -> Self {\n-        SubPatSet::Full\n-    }\n-    fn empty() -> Self {\n-        SubPatSet::Empty\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        match self {\n-            SubPatSet::Empty => true,\n-            SubPatSet::Full => false,\n-            // If any subpattern in a sequence is unreachable, the whole pattern is unreachable.\n-            SubPatSet::Seq { subpats } => subpats.values().any(|set| set.is_empty()),\n-            // An or-pattern is reachable if any of its alternatives is.\n-            SubPatSet::Alt { subpats, .. } => subpats.values().all(|set| set.is_empty()),\n-        }\n-    }\n-\n-    fn is_full(&self) -> bool {\n-        match self {\n-            SubPatSet::Empty => false,\n-            SubPatSet::Full => true,\n-            // The whole pattern is reachable only when all its alternatives are.\n-            SubPatSet::Seq { subpats } => subpats.values().all(|sub_set| sub_set.is_full()),\n-            // The whole or-pattern is reachable only when all its alternatives are.\n-            SubPatSet::Alt { subpats, spans, .. } => {\n-                subpats.len() == spans.len() && subpats.values().all(|set| set.is_full())\n-            }\n-        }\n-    }\n-\n-    /// Union `self` with `other`, mutating `self`.\n-    fn union(&mut self, other: Self) {\n-        use SubPatSet::*;\n-        // Union with full stays full; union with empty changes nothing.\n-        if self.is_full() || other.is_empty() {\n-            return;\n-        } else if self.is_empty() {\n-            *self = other;\n-            return;\n-        } else if other.is_full() {\n-            *self = Full;\n-            return;\n-        }\n-\n-        match (&mut *self, other) {\n-            (Seq { subpats: s_set }, Seq { subpats: mut o_set }) => {\n-                s_set.retain(|i, s_sub_set| {\n-                    // Missing entries count as full.\n-                    let o_sub_set = o_set.remove(&i).unwrap_or(Full);\n-                    s_sub_set.union(o_sub_set);\n-                    // We drop full entries.\n-                    !s_sub_set.is_full()\n-                });\n-                // Everything left in `o_set` is missing from `s_set`, i.e. counts as full. Since\n-                // unioning with full returns full, we can drop those entries.\n-            }\n-            (Alt { subpats: s_set, .. }, Alt { subpats: mut o_set, .. }) => {\n-                s_set.retain(|i, s_sub_set| {\n-                    // Missing entries count as empty.\n-                    let o_sub_set = o_set.remove(&i).unwrap_or(Empty);\n-                    s_sub_set.union(o_sub_set);\n-                    // We drop empty entries.\n-                    !s_sub_set.is_empty()\n-                });\n-                // Everything left in `o_set` is missing from `s_set`, i.e. counts as empty. Since\n-                // unioning with empty changes nothing, we can take those entries as is.\n-                s_set.extend(o_set);\n-            }\n-            _ => bug!(),\n-        }\n-\n-        if self.is_full() {\n-            *self = Full;\n-        }\n-    }\n-\n-    /// Returns a list of the spans of the unreachable subpatterns. If `self` is empty (i.e. the\n-    /// whole pattern is unreachable) we return `None`.\n-    fn list_unreachable_spans(&self) -> Option<Vec<Span>> {\n-        /// Panics if `set.is_empty()`.\n-        fn fill_spans(set: &SubPatSet, spans: &mut Vec<Span>) {\n-            match set {\n-                SubPatSet::Empty => bug!(),\n-                SubPatSet::Full => {}\n-                SubPatSet::Seq { subpats } => {\n-                    for (_, sub_set) in subpats {\n-                        fill_spans(sub_set, spans);\n-                    }\n-                }\n-                SubPatSet::Alt { subpats, spans: alt_spans, .. } => {\n-                    for (i, span) in alt_spans.iter().enumerate() {\n-                        let sub_set = subpats.get(&i).unwrap_or(&SubPatSet::Empty);\n-                        if sub_set.is_empty() {\n-                            // Found an unreachable subpattern.\n-                            spans.push(*span);\n-                        } else {\n-                            fill_spans(sub_set, spans);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        if self.is_empty() {\n-            return None;\n-        }\n-        if self.is_full() {\n-            // No subpatterns are unreachable.\n-            return Some(Vec::new());\n-        }\n-        let mut spans = Vec::new();\n-        fill_spans(self, &mut spans);\n-        Some(spans)\n-    }\n-\n-    /// When `self` refers to a patstack that was obtained from specialization, after running\n-    /// `unspecialize` it will refer to the original patstack before specialization.\n-    fn unspecialize(self, arity: usize) -> Self {\n-        use SubPatSet::*;\n-        match self {\n-            Full => Full,\n-            Empty => Empty,\n-            Seq { subpats } => {\n-                // We gather the first `arity` subpatterns together and shift the remaining ones.\n-                let mut new_subpats = FxHashMap::default();\n-                let mut new_subpats_first_col = FxHashMap::default();\n-                for (i, sub_set) in subpats {\n-                    if i < arity {\n-                        // The first `arity` indices are now part of the pattern in the first\n-                        // column.\n-                        new_subpats_first_col.insert(i, sub_set);\n-                    } else {\n-                        // Indices after `arity` are simply shifted\n-                        new_subpats.insert(i - arity + 1, sub_set);\n-                    }\n-                }\n-                // If `new_subpats_first_col` has no entries it counts as full, so we can omit it.\n-                if !new_subpats_first_col.is_empty() {\n-                    new_subpats.insert(0, Seq { subpats: new_subpats_first_col });\n-                }\n-                Seq { subpats: new_subpats }\n-            }\n-            Alt { .. } => bug!(), // `self` is a patstack\n-        }\n-    }\n-\n-    /// When `self` refers to a patstack that was obtained from splitting an or-pattern, after\n-    /// running `unsplit_or_pat` it will refer to the original patstack before splitting.\n-    ///\n-    /// For example:\n-    /// ```\n-    /// match Some(true) {\n-    ///     Some(true) => {}\n-    ///     None | Some(true | false) => {}\n-    /// }\n-    /// ```\n-    /// Here `None` would return the full set and `Some(true | false)` would return the set\n-    /// containing `false`. After `unsplit_or_pat`, we want the set to contain `None` and `false`.\n-    /// This is what this function does.\n-    fn unsplit_or_pat(mut self, alt_id: usize, spans: Vec<Span>) -> Self {\n-        use SubPatSet::*;\n-        if self.is_empty() {\n-            return Empty;\n-        }\n-\n-        // Subpatterns coming from inside the or-pattern alternative itself, e.g. in `None | Some(0\n-        // | 1)`.\n-        let set_first_col = match &mut self {\n-            Full => Full,\n-            Seq { subpats } => subpats.remove(&0).unwrap_or(Full),\n-            Empty => unreachable!(),\n-            Alt { .. } => bug!(), // `self` is a patstack\n-        };\n-        let mut subpats_first_col = FxHashMap::default();\n-        subpats_first_col.insert(alt_id, set_first_col);\n-        let set_first_col = Alt { subpats: subpats_first_col, spans };\n-\n-        let mut subpats = match self {\n-            Full => FxHashMap::default(),\n-            Seq { subpats } => subpats,\n-            Empty => unreachable!(),\n-            Alt { .. } => bug!(), // `self` is a patstack\n-        };\n-        subpats.insert(0, set_first_col);\n-        Seq { subpats }\n-    }\n-}\n-\n /// This carries the results of computing usefulness, as described at the top of the file. When\n /// checking usefulness of a match branch, we use the `NoWitnesses` variant, which also keeps track\n /// of potential unreachable sub-patterns (in the presence of or-patterns). When checking\n /// exhaustiveness of a whole match, we use the `WithWitnesses` variant, which carries a list of\n /// witnesses of non-exhaustiveness when there are any.\n /// Which variant to use is dictated by `ArmType`.\n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n enum Usefulness<'p, 'tcx> {\n-    /// Carries a set of subpatterns that have been found to be reachable. If empty, this indicates\n-    /// the whole pattern is unreachable. If not, this indicates that the pattern is reachable but\n-    /// that some sub-patterns may be unreachable (due to or-patterns). In the absence of\n-    /// or-patterns this will always be either `Empty` (the whole pattern is unreachable) or `Full`\n-    /// (the whole pattern is reachable).\n-    NoWitnesses(SubPatSet),\n+    /// If we don't care about witnesses, simply remember if the pattern was useful.\n+    NoWitnesses { useful: bool },\n     /// Carries a list of witnesses of non-exhaustiveness. If empty, indicates that the whole\n     /// pattern is unreachable.\n     WithWitnesses(Vec<Witness<'p, 'tcx>>),\n@@ -770,21 +529,22 @@ enum Usefulness<'p, 'tcx> {\n impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n     fn new_useful(preference: ArmType) -> Self {\n         match preference {\n+            // A single (empty) witness of reachability.\n             FakeExtraWildcard => WithWitnesses(vec![Witness(vec![])]),\n-            RealArm => NoWitnesses(SubPatSet::full()),\n+            RealArm => NoWitnesses { useful: true },\n         }\n     }\n \n     fn new_not_useful(preference: ArmType) -> Self {\n         match preference {\n             FakeExtraWildcard => WithWitnesses(vec![]),\n-            RealArm => NoWitnesses(SubPatSet::empty()),\n+            RealArm => NoWitnesses { useful: false },\n         }\n     }\n \n     fn is_useful(&self) -> bool {\n         match self {\n-            Usefulness::NoWitnesses(set) => !set.is_empty(),\n+            Usefulness::NoWitnesses { useful } => *useful,\n             Usefulness::WithWitnesses(witnesses) => !witnesses.is_empty(),\n         }\n     }\n@@ -795,20 +555,13 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n             (WithWitnesses(_), WithWitnesses(o)) if o.is_empty() => {}\n             (WithWitnesses(s), WithWitnesses(o)) if s.is_empty() => *self = WithWitnesses(o),\n             (WithWitnesses(s), WithWitnesses(o)) => s.extend(o),\n-            (NoWitnesses(s), NoWitnesses(o)) => s.union(o),\n+            (NoWitnesses { useful: s_useful }, NoWitnesses { useful: o_useful }) => {\n+                *s_useful = *s_useful || o_useful\n+            }\n             _ => unreachable!(),\n         }\n     }\n \n-    /// After calculating the usefulness for a branch of an or-pattern, call this to make this\n-    /// usefulness mergeable with those from the other branches.\n-    fn unsplit_or_pat(self, alt_id: usize, spans: Vec<Span>) -> Self {\n-        match self {\n-            NoWitnesses(subpats) => NoWitnesses(subpats.unsplit_or_pat(alt_id, spans)),\n-            WithWitnesses(_) => bug!(),\n-        }\n-    }\n-\n     /// After calculating usefulness after a specialization, call this to reconstruct a usefulness\n     /// that makes sense for the matrix pre-specialization. This new usefulness can then be merged\n     /// with the results of specializing with the other constructors.\n@@ -819,7 +572,8 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n         ctor: &Constructor<'tcx>,\n     ) -> Self {\n         match self {\n-            WithWitnesses(witnesses) if witnesses.is_empty() => WithWitnesses(witnesses),\n+            NoWitnesses { .. } => self,\n+            WithWitnesses(ref witnesses) if witnesses.is_empty() => self,\n             WithWitnesses(witnesses) => {\n                 let new_witnesses = if let Constructor::Missing { .. } = ctor {\n                     // We got the special `Missing` constructor, so each of the missing constructors\n@@ -846,9 +600,14 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n                         .into_iter()\n                         .flat_map(|witness| {\n                             new_patterns.iter().map(move |pat| {\n-                                let mut witness = witness.clone();\n-                                witness.0.push(pat.clone());\n-                                witness\n+                                Witness(\n+                                    witness\n+                                        .0\n+                                        .iter()\n+                                        .chain(once(pat))\n+                                        .map(DeconstructedPat::clone_and_forget_reachability)\n+                                        .collect(),\n+                                )\n                             })\n                         })\n                         .collect()\n@@ -860,7 +619,6 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n                 };\n                 WithWitnesses(new_witnesses)\n             }\n-            NoWitnesses(subpats) => NoWitnesses(subpats.unspecialize(ctor.arity(pcx))),\n         }\n     }\n }\n@@ -904,7 +662,7 @@ enum ArmType {\n ///     `Witness(vec![Pair(Some(_), true)])`\n ///\n /// The final `Pair(Some(_), true)` is then the resulting witness.\n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n crate struct Witness<'p, 'tcx>(Vec<DeconstructedPat<'p, 'tcx>>);\n \n impl<'p, 'tcx> Witness<'p, 'tcx> {\n@@ -933,7 +691,7 @@ impl<'p, 'tcx> Witness<'p, 'tcx> {\n             let arity = ctor.arity(pcx);\n             let pats = self.0.drain((len - arity)..).rev();\n             let fields = Fields::from_iter(pcx.cx, pats);\n-            DeconstructedPat::new(ctor.clone(), fields, pcx.ty)\n+            DeconstructedPat::new(ctor.clone(), fields, pcx.ty, DUMMY_SP)\n         };\n \n         self.0.push(pat);\n@@ -1032,14 +790,11 @@ fn is_useful<'p, 'tcx>(\n     let mut ret = Usefulness::new_not_useful(witness_preference);\n     if v.head().is_or_pat() {\n         debug!(\"expanding or-pattern\");\n-        let spans: Vec<_> = v.head().iter_fields().map(|pat| pat.span()).collect();\n-        let vs: Vec<_> = v.expand_or_pat().collect();\n         // We try each or-pattern branch in turn.\n         let mut matrix = matrix.clone();\n-        for (i, v) in vs.into_iter().enumerate() {\n+        for v in v.expand_or_pat() {\n             let usefulness =\n                 is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n-            let usefulness = usefulness.unsplit_or_pat(i, spans.clone());\n             ret.extend(usefulness);\n             // If pattern has a guard don't add it to the matrix.\n             if !is_under_guard {\n@@ -1111,6 +866,10 @@ fn is_useful<'p, 'tcx>(\n         }\n     }\n \n+    if ret.is_useful() {\n+        v.head().set_reachable();\n+    }\n+\n     debug!(?ret);\n     ret\n }\n@@ -1161,16 +920,14 @@ crate fn compute_match_usefulness<'p, 'tcx>(\n         .copied()\n         .map(|arm| {\n             let v = PatStack::from_pattern(arm.pat);\n-            let usefulness = is_useful(cx, &matrix, &v, RealArm, arm.hir_id, arm.has_guard, true);\n+            is_useful(cx, &matrix, &v, RealArm, arm.hir_id, arm.has_guard, true);\n             if !arm.has_guard {\n                 matrix.push(v);\n             }\n-            let reachability = match usefulness {\n-                NoWitnesses(subpats) if subpats.is_empty() => Reachability::Unreachable,\n-                NoWitnesses(subpats) => {\n-                    Reachability::Reachable(subpats.list_unreachable_spans().unwrap())\n-                }\n-                WithWitnesses(..) => bug!(),\n+            let reachability = if arm.pat.is_reachable() {\n+                Reachability::Reachable(arm.pat.unreachable_spans())\n+            } else {\n+                Reachability::Unreachable\n             };\n             (arm, reachability)\n         })\n@@ -1181,7 +938,7 @@ crate fn compute_match_usefulness<'p, 'tcx>(\n     let usefulness = is_useful(cx, &matrix, &v, FakeExtraWildcard, scrut_hir_id, false, true);\n     let non_exhaustiveness_witnesses = match usefulness {\n         WithWitnesses(pats) => pats.into_iter().map(|w| w.single_pattern()).collect(),\n-        NoWitnesses(_) => bug!(),\n+        NoWitnesses { .. } => bug!(),\n     };\n     UsefulnessReport { arm_usefulness, non_exhaustiveness_witnesses }\n }"}]}