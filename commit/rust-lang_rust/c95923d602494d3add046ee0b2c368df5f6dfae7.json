{"sha": "c95923d602494d3add046ee0b2c368df5f6dfae7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5NTkyM2Q2MDI0OTRkM2FkZDA0NmVlMGIyYzM2OGRmNWY2ZGZhZTc=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-09-19T23:31:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-09-19T23:31:34Z"}, "message": "Merge pull request #458 from RalfJung/tls\n\nMove TLS data to machine data", "tree": {"sha": "4e0a421cb93763e90d7a05de0c3b37e03002c084", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e0a421cb93763e90d7a05de0c3b37e03002c084"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c95923d602494d3add046ee0b2c368df5f6dfae7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbotxWCRBK7hj4Ov3rIwAAdHIIAJ07uEhc5kRlnJUXIWV2qkxR\ndK+0trgmJwT7d9kB384dc0YI7CKzS7thhMjXpAYtycbbLpc6tIqDl22YzuEm/pZx\npaeIT6gj6iNrGHG6n7XOZyGxTysLokiulbYZHuCAbKsC7Wt1rLJrMITfXMyz9j4N\nvl+/RKfnl7jBCJIpEIwGYLMgKGfs3dSaQSYs95OV2GdH8NGxH33WlLkp6yUaIM1S\nVd+8fEC3Ia5WxWFVXX82UY/L2XwLSejOvZbt+DTtpw/Q7j9WvJ2VXF7FAhiqrm6R\nE0a+oxH6jtcKDi9cDxMCx5DyOOO7A4jUlvkRL0N3FXb1YkJJJQMAFjCZ/gKw0GM=\n=QnSI\n-----END PGP SIGNATURE-----\n", "payload": "tree 4e0a421cb93763e90d7a05de0c3b37e03002c084\nparent 384c2bec2ac2f43bdbd6ae300abb4214f8bf82ce\nparent ea4232cf22613aa06fb3d273dadf58f003df9388\nauthor Eduard-Mihai Burtescu <edy.burt@gmail.com> 1537399894 +0300\ncommitter GitHub <noreply@github.com> 1537399894 +0300\n\nMerge pull request #458 from RalfJung/tls\n\nMove TLS data to machine data"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c95923d602494d3add046ee0b2c368df5f6dfae7", "html_url": "https://github.com/rust-lang/rust/commit/c95923d602494d3add046ee0b2c368df5f6dfae7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c95923d602494d3add046ee0b2c368df5f6dfae7/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "384c2bec2ac2f43bdbd6ae300abb4214f8bf82ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/384c2bec2ac2f43bdbd6ae300abb4214f8bf82ce", "html_url": "https://github.com/rust-lang/rust/commit/384c2bec2ac2f43bdbd6ae300abb4214f8bf82ce"}, {"sha": "ea4232cf22613aa06fb3d273dadf58f003df9388", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea4232cf22613aa06fb3d273dadf58f003df9388", "html_url": "https://github.com/rust-lang/rust/commit/ea4232cf22613aa06fb3d273dadf58f003df9388"}], "stats": {"total": 210, "additions": 94, "deletions": 116}, "files": [{"sha": "3e795f1653318cf8145ab8604243b3733a53f5f7", "filename": "src/fn_call.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c95923d602494d3add046ee0b2c368df5f6dfae7/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c95923d602494d3add046ee0b2c368df5f6dfae7/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=c95923d602494d3add046ee0b2c368df5f6dfae7", "patch": "@@ -8,10 +8,6 @@ use std::mem;\n \n use super::*;\n \n-use tls::MemoryExt;\n-\n-use super::memory::MemoryKind;\n-\n pub trait EvalContextExt<'tcx, 'mir> {\n     /// Emulate calling a foreign item, fail if the item is not supported.\n     /// This function will handle `goto_block` if needed.\n@@ -129,7 +125,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                     self.write_null(dest)?;\n                 } else {\n                     let align = self.tcx.data_layout.pointer_align;\n-                    let ptr = self.memory.allocate(Size::from_bytes(size), align, MemoryKind::C.into())?;\n+                    let ptr = self.memory.allocate(Size::from_bytes(size), align, MiriMemoryKind::C.into())?;\n                     self.write_scalar(Scalar::Ptr(ptr), dest)?;\n                 }\n             }\n@@ -140,7 +136,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                     self.memory.deallocate(\n                         ptr.to_ptr()?,\n                         None,\n-                        MemoryKind::C.into(),\n+                        MiriMemoryKind::C.into(),\n                     )?;\n                 }\n             }\n@@ -156,7 +152,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                 }\n                 let ptr = self.memory.allocate(Size::from_bytes(size),\n                                                Align::from_bytes(align, align).unwrap(),\n-                                               MemoryKind::Rust.into())?;\n+                                               MiriMemoryKind::Rust.into())?;\n                 self.write_scalar(Scalar::Ptr(ptr), dest)?;\n             }\n             \"__rust_alloc_zeroed\" => {\n@@ -170,7 +166,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                 }\n                 let ptr = self.memory.allocate(Size::from_bytes(size),\n                                                Align::from_bytes(align, align).unwrap(),\n-                                               MemoryKind::Rust.into())?;\n+                                               MiriMemoryKind::Rust.into())?;\n                 self.memory.write_repeat(ptr.into(), 0, Size::from_bytes(size))?;\n                 self.write_scalar(Scalar::Ptr(ptr), dest)?;\n             }\n@@ -187,7 +183,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                 self.memory.deallocate(\n                     ptr,\n                     Some((Size::from_bytes(old_size), Align::from_bytes(align, align).unwrap())),\n-                    MemoryKind::Rust.into(),\n+                    MiriMemoryKind::Rust.into(),\n                 )?;\n             }\n             \"__rust_realloc\" => {\n@@ -207,7 +203,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                     Align::from_bytes(align, align).unwrap(),\n                     Size::from_bytes(new_size),\n                     Align::from_bytes(align, align).unwrap(),\n-                    MemoryKind::Rust.into(),\n+                    MiriMemoryKind::Rust.into(),\n                 )?;\n                 self.write_scalar(Scalar::Ptr(new_ptr), dest)?;\n             }\n@@ -365,7 +361,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                 }\n                 if let Some(old) = success {\n                     if let Some(var) = old {\n-                        self.memory.deallocate(var, None, MemoryKind::Env.into())?;\n+                        self.memory.deallocate(var, None, MiriMemoryKind::Env.into())?;\n                     }\n                     self.write_null(dest)?;\n                 } else {\n@@ -391,7 +387,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                     let value_copy = self.memory.allocate(\n                         Size::from_bytes((value.len() + 1) as u64),\n                         Align::from_bytes(1, 1).unwrap(),\n-                        MemoryKind::Env.into(),\n+                        MiriMemoryKind::Env.into(),\n                     )?;\n                     self.memory.write_bytes(value_copy.into(), &value)?;\n                     let trailing_zero_ptr = value_copy.offset(Size::from_bytes(value.len() as u64), &self)?.into();\n@@ -401,7 +397,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                         value_copy,\n                     )\n                     {\n-                        self.memory.deallocate(var, None, MemoryKind::Env.into())?;\n+                        self.memory.deallocate(var, None, MiriMemoryKind::Env.into())?;\n                     }\n                     self.write_null(dest)?;\n                 } else {\n@@ -504,7 +500,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                 let key_layout = self.layout_of(key_type)?;\n \n                 // Create key and write it into the memory where key_ptr wants it\n-                let key = self.memory.create_tls_key(dtor) as u128;\n+                let key = self.machine.tls.create_tls_key(dtor, *self.tcx) as u128;\n                 if key_layout.size.bits() < 128 && key >= (1u128 << key_layout.size.bits() as u128) {\n                     return err!(OutOfTls);\n                 }\n@@ -520,19 +516,19 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n             }\n             \"pthread_key_delete\" => {\n                 let key = self.read_scalar(args[0])?.to_bytes()?;\n-                self.memory.delete_tls_key(key)?;\n+                self.machine.tls.delete_tls_key(key)?;\n                 // Return success (0)\n                 self.write_null(dest)?;\n             }\n             \"pthread_getspecific\" => {\n                 let key = self.read_scalar(args[0])?.to_bytes()?;\n-                let ptr = self.memory.load_tls(key)?;\n+                let ptr = self.machine.tls.load_tls(key)?;\n                 self.write_scalar(ptr, dest)?;\n             }\n             \"pthread_setspecific\" => {\n                 let key = self.read_scalar(args[0])?.to_bytes()?;\n                 let new_ptr = self.read_scalar(args[1])?.not_undef()?;\n-                self.memory.store_tls(key, new_ptr)?;\n+                self.machine.tls.store_tls(key, new_ptr)?;\n \n                 // Return success (0)\n                 self.write_null(dest)?;\n@@ -607,7 +603,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                 // This just creates a key; Windows does not natively support TLS dtors.\n \n                 // Create key and return it\n-                let key = self.memory.create_tls_key(None) as u128;\n+                let key = self.machine.tls.create_tls_key(None, *self.tcx) as u128;\n \n                 // Figure out how large a TLS key actually is. This is c::DWORD.\n                 if dest.layout.size.bits() < 128 && key >= (1u128 << dest.layout.size.bits() as u128) {\n@@ -617,13 +613,13 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n             }\n             \"TlsGetValue\" => {\n                 let key = self.read_scalar(args[0])?.to_bytes()?;\n-                let ptr = self.memory.load_tls(key)?;\n+                let ptr = self.machine.tls.load_tls(key)?;\n                 self.write_scalar(ptr, dest)?;\n             }\n             \"TlsSetValue\" => {\n                 let key = self.read_scalar(args[0])?.to_bytes()?;\n                 let new_ptr = self.read_scalar(args[1])?.not_undef()?;\n-                self.memory.store_tls(key, new_ptr)?;\n+                self.machine.tls.store_tls(key, new_ptr)?;\n \n                 // Return success (1)\n                 self.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;"}, {"sha": "98d89510251c9e7d3e1a2bf6e7c428e8c68733c3", "filename": "src/lib.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c95923d602494d3add046ee0b2c368df5f6dfae7/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c95923d602494d3add046ee0b2c368df5f6dfae7/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c95923d602494d3add046ee0b2c368df5f6dfae7", "patch": "@@ -21,27 +21,24 @@ use rustc::mir;\n use syntax::ast::Mutability;\n use syntax::attr;\n \n-use std::marker::PhantomData;\n use std::collections::HashMap;\n \n pub use rustc::mir::interpret::*;\n pub use rustc_mir::interpret::*;\n+pub use rustc_mir::interpret;\n \n mod fn_call;\n mod operator;\n mod intrinsic;\n mod helpers;\n-mod memory;\n mod tls;\n mod locks;\n mod range_map;\n \n use fn_call::EvalContextExt as MissingFnsEvalContextExt;\n use operator::EvalContextExt as OperatorEvalContextExt;\n use intrinsic::EvalContextExt as IntrinsicEvalContextExt;\n-use tls::EvalContextExt as TlsEvalContextExt;\n-use memory::{MemoryKind as MiriMemoryKind, TlsKey, TlsEntry, MemoryData};\n-use locks::LockInfo;\n+use tls::{EvalContextExt as TlsEvalContextExt, TlsData};\n use range_map::RangeMap;\n use helpers::FalibleScalarExt;\n \n@@ -54,7 +51,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n         Default::default(),\n-        MemoryData::new()\n+        Default::default(),\n     );\n \n     let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n@@ -201,21 +198,41 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     }\n }\n \n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum MiriMemoryKind {\n+    /// `__rust_alloc` memory\n+    Rust,\n+    /// `malloc` memory\n+    C,\n+    /// Part of env var emulation\n+    Env,\n+    /// mutable statics\n+    MutStatic,\n+}\n+\n+impl Into<MemoryKind<MiriMemoryKind>> for MiriMemoryKind {\n+    fn into(self) -> MemoryKind<MiriMemoryKind> {\n+        MemoryKind::Machine(self)\n+    }\n+}\n+\n+\n #[derive(Clone, Default, PartialEq, Eq)]\n pub struct Evaluator<'tcx> {\n     /// Environment variables set by `setenv`\n     /// Miri does not expose env vars from the host to the emulated program\n     pub(crate) env_vars: HashMap<Vec<u8>, Pointer>,\n \n-    /// Use the lifetime\n-    _dummy : PhantomData<&'tcx ()>,\n+    /// TLS state\n+    pub(crate) tls: TlsData<'tcx>,\n }\n \n impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n-    type MemoryData = memory::MemoryData<'tcx>;\n-    type MemoryKinds = memory::MemoryKind;\n+    type MemoryData = ();\n+    type MemoryKinds = MiriMemoryKind;\n \n-    const MUT_STATIC_KIND: Option<memory::MemoryKind> = Some(memory::MemoryKind::MutStatic);\n+    const MUT_STATIC_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::MutStatic);\n     const DETECT_LOOPS: bool = false;\n \n     /// Returns Ok() when the function was handled, fail otherwise"}, {"sha": "4e0fcd4f511ffcfec52716a911840842cb01ca23", "filename": "src/memory.rs", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/384c2bec2ac2f43bdbd6ae300abb4214f8bf82ce/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384c2bec2ac2f43bdbd6ae300abb4214f8bf82ce/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=384c2bec2ac2f43bdbd6ae300abb4214f8bf82ce", "patch": "@@ -1,57 +0,0 @@\n-use std::collections::{HashMap, BTreeMap};\n-\n-use rustc::ty;\n-\n-use super::{AllocId, Scalar, LockInfo, RangeMap};\n-\n-pub type TlsKey = u128;\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub struct TlsEntry<'tcx> {\n-    pub(crate) data: Scalar, // Will eventually become a map from thread IDs to `Scalar`s, if we ever support more than one thread.\n-    pub(crate) dtor: Option<ty::Instance<'tcx>>,\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct MemoryData<'tcx> {\n-    /// The Key to use for the next thread-local allocation.\n-    pub(crate) next_thread_local: TlsKey,\n-\n-    /// pthreads-style thread-local storage.\n-    pub(crate) thread_local: BTreeMap<TlsKey, TlsEntry<'tcx>>,\n-\n-    /// Memory regions that are locked by some function\n-    ///\n-    /// Only mutable (static mut, heap, stack) allocations have an entry in this map.\n-    /// The entry is created when allocating the memory and deleted after deallocation.\n-    pub(crate) locks: HashMap<AllocId, RangeMap<LockInfo<'tcx>>>,\n-}\n-\n-impl<'tcx> MemoryData<'tcx> {\n-    pub(crate) fn new() -> Self {\n-        MemoryData {\n-            next_thread_local: 1, // start with 1 as we must not use 0 on Windows\n-            thread_local: BTreeMap::new(),\n-            locks: HashMap::new(),\n-        }\n-    }\n-}\n-\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub enum MemoryKind {\n-    /// `__rust_alloc` memory\n-    Rust,\n-    /// `malloc` memory\n-    C,\n-    /// Part of env var emulation\n-    Env,\n-    /// mutable statics\n-    MutStatic,\n-}\n-\n-impl Into<::rustc_mir::interpret::MemoryKind<MemoryKind>> for MemoryKind {\n-    fn into(self) -> ::rustc_mir::interpret::MemoryKind<MemoryKind> {\n-        ::rustc_mir::interpret::MemoryKind::Machine(self)\n-    }\n-}"}, {"sha": "a1ddaf64cc0f3ae60a80c1791d87305f03403475", "filename": "src/tls.rs", "status": "modified", "additions": 50, "deletions": 28, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c95923d602494d3add046ee0b2c368df5f6dfae7/src%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c95923d602494d3add046ee0b2c368df5f6dfae7/src%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftls.rs?ref=c95923d602494d3add046ee0b2c368df5f6dfae7", "patch": "@@ -1,40 +1,61 @@\n-use rustc::{ty, mir};\n+use std::collections::BTreeMap;\n \n-use super::{TlsKey, TlsEntry, EvalResult, EvalErrorKind, Scalar, Memory, Evaluator,\n+use rustc::{ty, ty::layout::HasDataLayout, mir};\n+\n+use super::{EvalResult, EvalErrorKind, Scalar, Evaluator,\n             Place, StackPopCleanup, EvalContext};\n \n-pub trait MemoryExt<'tcx> {\n-    fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey;\n-    fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx>;\n-    fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Scalar>;\n-    fn store_tls(&mut self, key: TlsKey, new_data: Scalar) -> EvalResult<'tcx>;\n-    fn fetch_tls_dtor(\n-        &mut self,\n-        key: Option<TlsKey>,\n-    ) -> Option<(ty::Instance<'tcx>, Scalar, TlsKey)>;\n+pub type TlsKey = u128;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct TlsEntry<'tcx> {\n+    pub(crate) data: Scalar, // Will eventually become a map from thread IDs to `Scalar`s, if we ever support more than one thread.\n+    pub(crate) dtor: Option<ty::Instance<'tcx>>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TlsData<'tcx> {\n+    /// The Key to use for the next thread-local allocation.\n+    pub(crate) next_key: TlsKey,\n+\n+    /// pthreads-style thread-local storage.\n+    pub(crate) keys: BTreeMap<TlsKey, TlsEntry<'tcx>>,\n+}\n+\n+impl<'tcx> Default for TlsData<'tcx> {\n+    fn default() -> Self {\n+        TlsData {\n+            next_key: 1, // start with 1 as we must not use 0 on Windows\n+            keys: Default::default(),\n+        }\n+    }\n }\n \n pub trait EvalContextExt<'tcx> {\n     fn run_tls_dtors(&mut self) -> EvalResult<'tcx>;\n }\n \n-impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evaluator<'tcx>> {\n-    fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n-        let new_key = self.data.next_thread_local;\n-        self.data.next_thread_local += 1;\n-        self.data.thread_local.insert(\n+impl<'tcx> TlsData<'tcx> {\n+    pub fn create_tls_key(\n+        &mut self,\n+        dtor: Option<ty::Instance<'tcx>>,\n+        cx: impl HasDataLayout,\n+    ) -> TlsKey {\n+        let new_key = self.next_key;\n+        self.next_key += 1;\n+        self.keys.insert(\n             new_key,\n             TlsEntry {\n-                data: Scalar::ptr_null(*self.tcx).into(),\n+                data: Scalar::ptr_null(cx).into(),\n                 dtor,\n             },\n         );\n         trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n         new_key\n     }\n \n-    fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx> {\n-        match self.data.thread_local.remove(&key) {\n+    pub fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx> {\n+        match self.keys.remove(&key) {\n             Some(_) => {\n                 trace!(\"TLS key {} removed\", key);\n                 Ok(())\n@@ -43,8 +64,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n         }\n     }\n \n-    fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Scalar> {\n-        match self.data.thread_local.get(&key) {\n+    pub fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Scalar> {\n+        match self.keys.get(&key) {\n             Some(&TlsEntry { data, .. }) => {\n                 trace!(\"TLS key {} loaded: {:?}\", key, data);\n                 Ok(data)\n@@ -53,8 +74,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n         }\n     }\n \n-    fn store_tls(&mut self, key: TlsKey, new_data: Scalar) -> EvalResult<'tcx> {\n-        match self.data.thread_local.get_mut(&key) {\n+    pub fn store_tls(&mut self, key: TlsKey, new_data: Scalar) -> EvalResult<'tcx> {\n+        match self.keys.get_mut(&key) {\n             Some(&mut TlsEntry { ref mut data, .. }) => {\n                 trace!(\"TLS key {} stored: {:?}\", key, new_data);\n                 *data = new_data;\n@@ -85,10 +106,11 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n     fn fetch_tls_dtor(\n         &mut self,\n         key: Option<TlsKey>,\n+        cx: impl HasDataLayout,\n     ) -> Option<(ty::Instance<'tcx>, Scalar, TlsKey)> {\n         use std::collections::Bound::*;\n \n-        let thread_local = &mut self.data.thread_local;\n+        let thread_local = &mut self.keys;\n         let start = match key {\n             Some(key) => Excluded(key),\n             None => Unbounded,\n@@ -99,7 +121,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n             if !data.is_null() {\n                 if let Some(dtor) = dtor {\n                     let ret = Some((dtor, *data, key));\n-                    *data = Scalar::ptr_null(*self.tcx);\n+                    *data = Scalar::ptr_null(cx);\n                     return ret;\n                 }\n             }\n@@ -110,7 +132,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n \n impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>> {\n     fn run_tls_dtors(&mut self) -> EvalResult<'tcx> {\n-        let mut dtor = self.memory.fetch_tls_dtor(None);\n+        let mut dtor = self.machine.tls.fetch_tls_dtor(None, *self.tcx);\n         // FIXME: replace loop by some structure that works with stepping\n         while let Some((instance, ptr, key)) = dtor {\n             trace!(\"Running TLS dtor {:?} on {:?}\", instance, ptr);\n@@ -134,9 +156,9 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             // step until out of stackframes\n             self.run()?;\n \n-            dtor = match self.memory.fetch_tls_dtor(Some(key)) {\n+            dtor = match self.machine.tls.fetch_tls_dtor(Some(key), *self.tcx) {\n                 dtor @ Some(_) => dtor,\n-                None => self.memory.fetch_tls_dtor(None),\n+                None => self.machine.tls.fetch_tls_dtor(None, *self.tcx),\n             };\n         }\n         // FIXME: On a windows target, call `unsafe extern \"system\" fn on_tls_callback`."}]}