{"sha": "9f36f988ad873f5d34cd9c08e4903c597ffc9532", "node_id": "C_kwDOAAsO6NoAKDlmMzZmOTg4YWQ4NzNmNWQzNGNkOWMwOGU0OTAzYzU5N2ZmYzk1MzI", "commit": {"author": {"name": "Arpad Borsos", "email": "swatinem@swatinem.de", "date": "2022-11-18T21:56:22Z"}, "committer": {"name": "Arpad Borsos", "email": "swatinem@swatinem.de", "date": "2022-11-24T09:04:27Z"}, "message": "Avoid `GenFuture` shim when compiling async constructs\n\nPreviously, async constructs would be lowered to \"normal\" generators,\nwith an additional `from_generator` / `GenFuture` shim in between to\nconvert from `Generator` to `Future`.\n\nThe compiler will now special-case these generators internally so that\nasync constructs will *directly* implement `Future` without the need\nto go through the `from_generator` / `GenFuture` shim.\n\nThe primary motivation for this change was hiding this implementation\ndetail in stack traces and debuginfo, but it can in theory also help\nthe optimizer as there is less abstractions to see through.", "tree": {"sha": "48825cd5da62cbc7f585c6c991a3b8e25d01dd20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48825cd5da62cbc7f585c6c991a3b8e25d01dd20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f36f988ad873f5d34cd9c08e4903c597ffc9532", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZNNjbpmzULCa7LeL/HvKd4JLMpgFAmN/M6UACgkQ/HvKd4JL\nMphusA//Trm2i1/0ZcsCIjhr6JxvOnqaVYcq5V2rje0m0APSIJlWLpO3fjw7gEku\npLvsORp6AU8JAP9gEQPzQQNmQVnpONBTDuiUMsRcRPQUOgZaeQl3DhLgna7aX/Fb\nfDFugsy4DJ2JVggp4S4Un1OkJ+4xHWdXBrJkBj0YRRUy+s8Ep89d8hhczGBRltB2\n+UYpCPl8Wha17YwXyf6a68d2S/KpFbI9jV5weSOSNmaCNHjjVUNjyta1XSc8hWi3\niV9Kuht1U2f75wOyaT27GXrsjdJHjZzQzOXaT/kGqJqV3BjHqo6E1pv2UBSNHRWM\nb/IoW9IVChYooUH7sB81mSBE2oJP9w4n1aSfUAPDBfrSlcNMD+gfMkH6vsXraslp\nv2t9Rbud8w43XAgM11q1dACU1h3hEegaPGwdqFBz2jVrxhb+f+YVDNBHbhb3dPyP\nJe5LUM/qHkvo3M4URtCqj4Q3jPrADkRIEpnsi2ab1nR3/dh9nN8dDmFOVz6cUq9w\nMTfqXgvC0nXd8i9c3iS17W7NyHeS+FQ1Iz0PU3kIVa2GujF5IbwEZAVXEy9i/B2P\nBMBtCKip8D2k7+gQFII2PiE9PYoEZTtrx561R1m0YgESNqmcA/4KdBLnY0qtaf0r\nJN2i+cbjo3joq2aBXQVXtdJvv9tt/bmc5J7UzMFyRgjkx59q+ZI=\n=ZoNV\n-----END PGP SIGNATURE-----", "payload": "tree 48825cd5da62cbc7f585c6c991a3b8e25d01dd20\nparent fd815a5091eb4d49cd317f8ad272f17b7a5f550d\nauthor Arpad Borsos <swatinem@swatinem.de> 1668808582 +0100\ncommitter Arpad Borsos <swatinem@swatinem.de> 1669280667 +0100\n\nAvoid `GenFuture` shim when compiling async constructs\n\nPreviously, async constructs would be lowered to \"normal\" generators,\nwith an additional `from_generator` / `GenFuture` shim in between to\nconvert from `Generator` to `Future`.\n\nThe compiler will now special-case these generators internally so that\nasync constructs will *directly* implement `Future` without the need\nto go through the `from_generator` / `GenFuture` shim.\n\nThe primary motivation for this change was hiding this implementation\ndetail in stack traces and debuginfo, but it can in theory also help\nthe optimizer as there is less abstractions to see through.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f36f988ad873f5d34cd9c08e4903c597ffc9532", "html_url": "https://github.com/rust-lang/rust/commit/9f36f988ad873f5d34cd9c08e4903c597ffc9532", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f36f988ad873f5d34cd9c08e4903c597ffc9532/comments", "author": {"login": "Swatinem", "id": 580492, "node_id": "MDQ6VXNlcjU4MDQ5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/580492?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Swatinem", "html_url": "https://github.com/Swatinem", "followers_url": "https://api.github.com/users/Swatinem/followers", "following_url": "https://api.github.com/users/Swatinem/following{/other_user}", "gists_url": "https://api.github.com/users/Swatinem/gists{/gist_id}", "starred_url": "https://api.github.com/users/Swatinem/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Swatinem/subscriptions", "organizations_url": "https://api.github.com/users/Swatinem/orgs", "repos_url": "https://api.github.com/users/Swatinem/repos", "events_url": "https://api.github.com/users/Swatinem/events{/privacy}", "received_events_url": "https://api.github.com/users/Swatinem/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Swatinem", "id": 580492, "node_id": "MDQ6VXNlcjU4MDQ5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/580492?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Swatinem", "html_url": "https://github.com/Swatinem", "followers_url": "https://api.github.com/users/Swatinem/followers", "following_url": "https://api.github.com/users/Swatinem/following{/other_user}", "gists_url": "https://api.github.com/users/Swatinem/gists{/gist_id}", "starred_url": "https://api.github.com/users/Swatinem/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Swatinem/subscriptions", "organizations_url": "https://api.github.com/users/Swatinem/orgs", "repos_url": "https://api.github.com/users/Swatinem/repos", "events_url": "https://api.github.com/users/Swatinem/events{/privacy}", "received_events_url": "https://api.github.com/users/Swatinem/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd815a5091eb4d49cd317f8ad272f17b7a5f550d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd815a5091eb4d49cd317f8ad272f17b7a5f550d", "html_url": "https://github.com/rust-lang/rust/commit/fd815a5091eb4d49cd317f8ad272f17b7a5f550d"}], "stats": {"total": 674, "additions": 461, "deletions": 213}, "files": [{"sha": "b222ef4a88924edd01d6c81c05a894ddd9524db6", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -149,7 +149,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     *capture_clause,\n                     *closure_node_id,\n                     None,\n-                    block.span,\n+                    e.span,\n                     hir::AsyncGeneratorKind::Block,\n                     |this| this.with_new_scopes(|this| this.lower_block_expr(block)),\n                 ),\n@@ -569,12 +569,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    /// Lower an `async` construct to a generator that is then wrapped so it implements `Future`.\n+    /// Lower an `async` construct to a generator that implements `Future`.\n     ///\n     /// This results in:\n     ///\n     /// ```text\n-    /// std::future::from_generator(static move? |_task_context| -> <ret_ty> {\n+    /// std::future::identity_future(static move? |_task_context| -> <ret_ty> {\n     ///     <body>\n     /// })\n     /// ```\n@@ -589,12 +589,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> hir::ExprKind<'hir> {\n         let output = ret_ty.unwrap_or_else(|| hir::FnRetTy::DefaultReturn(self.lower_span(span)));\n \n-        // Resume argument type. We let the compiler infer this to simplify the lowering. It is\n-        // fully constrained by `future::from_generator`.\n+        // Resume argument type: `ResumeTy`\n+        let unstable_span =\n+            self.mark_span_with_reason(DesugaringKind::Async, span, self.allow_gen_future.clone());\n+        let resume_ty = hir::QPath::LangItem(hir::LangItem::ResumeTy, unstable_span, None);\n         let input_ty = hir::Ty {\n             hir_id: self.next_id(),\n-            kind: hir::TyKind::Infer,\n-            span: self.lower_span(span),\n+            kind: hir::TyKind::Path(resume_ty),\n+            span: unstable_span,\n         };\n \n         // The closure/generator `FnDecl` takes a single (resume) argument of type `input_ty`.\n@@ -677,16 +679,24 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let generator = hir::Expr { hir_id, kind: generator_kind, span: self.lower_span(span) };\n \n-        // `future::from_generator`:\n-        let gen_future = self.expr_lang_item_path(\n+        // FIXME(swatinem):\n+        // For some reason, the async block needs to flow through *any*\n+        // call (like the identity function), as otherwise type and lifetime\n+        // inference have a hard time figuring things out.\n+        // Without this, we would get:\n+        // E0720 in src/test/ui/impl-trait/in-trait/default-body-with-rpit.rs\n+        // E0700 in src/test/ui/self/self_lifetime-async.rs\n+\n+        // `future::identity_future`:\n+        let identity_future = self.expr_lang_item_path(\n             unstable_span,\n-            hir::LangItem::FromGenerator,\n+            hir::LangItem::IdentityFuture,\n             AttrVec::new(),\n             None,\n         );\n \n-        // `future::from_generator(generator)`:\n-        hir::ExprKind::Call(self.arena.alloc(gen_future), arena_vec![self; generator])\n+        // `future::identity_future(generator)`:\n+        hir::ExprKind::Call(self.arena.alloc(identity_future), arena_vec![self; generator])\n     }\n \n     /// Desugar `<expr>.await` into:\n@@ -990,7 +1000,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n \n             // Transform `async |x: u8| -> X { ... }` into\n-            // `|x: u8| future_from_generator(|| -> X { ... })`.\n+            // `|x: u8| identity_future(|| -> X { ... })`.\n             let body_id = this.lower_fn_body(&outer_decl, |this| {\n                 let async_ret_ty = if let FnRetTy::Ty(ty) = &decl.output {\n                     let itctx = ImplTraitContext::Disallowed(ImplTraitPosition::AsyncBlock);"}, {"sha": "534675f1dc042c5bab0df36fdba6fc4b860d2a9c", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -21,7 +21,7 @@ use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::Region;\n use rustc_middle::ty::TypeVisitor;\n use rustc_middle::ty::{self, RegionVid, Ty};\n-use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_span::symbol::{kw, Ident};\n use rustc_span::Span;\n \n use crate::borrowck_errors;\n@@ -514,8 +514,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             span: *span,\n             ty_err: match output_ty.kind() {\n                 ty::Closure(_, _) => FnMutReturnTypeErr::ReturnClosure { span: *span },\n-                ty::Adt(def, _)\n-                    if self.infcx.tcx.is_diagnostic_item(sym::gen_future, def.did()) =>\n+                ty::Generator(def, ..)\n+                    if matches!(\n+                        self.infcx.tcx.generator_kind(def),\n+                        Some(hir::GeneratorKind::Async(_))\n+                    ) =>\n                 {\n                     FnMutReturnTypeErr::ReturnAsyncBlock { span: *span }\n                 }\n@@ -927,10 +930,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     // only when the block is a closure\n                     if let hir::ExprKind::Closure(hir::Closure {\n                         capture_clause: hir::CaptureBy::Ref,\n+                        body,\n                         ..\n                     }) = expr.kind\n                     {\n-                        closure_span = Some(expr.span.shrink_to_lo());\n+                        let body = map.body(*body);\n+                        if !matches!(body.generator_kind, Some(hir::GeneratorKind::Async(..))) {\n+                            closure_span = Some(expr.span.shrink_to_lo());\n+                        }\n                     }\n                 }\n             }"}, {"sha": "b268eac97d0b07a075bb100e816655d45028d008", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -2588,7 +2588,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n \n             // For closures, we have some **extra requirements** we\n-            //\n             // have to check. In particular, in their upvars and\n             // signatures, closures often reference various regions\n             // from the surrounding function -- we call those the"}, {"sha": "4564a6c4f2f4e3f37f47ceee09ba266cbe4a914a", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -449,8 +449,17 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n             | Rvalue::CopyForDeref(..)\n             | Rvalue::Repeat(..)\n             | Rvalue::Discriminant(..)\n-            | Rvalue::Len(_)\n-            | Rvalue::Aggregate(..) => {}\n+            | Rvalue::Len(_) => {}\n+\n+            Rvalue::Aggregate(ref kind, ..) => {\n+                if let AggregateKind::Generator(def_id, ..) = kind.as_ref() {\n+                    if let Some(generator_kind) = self.tcx.generator_kind(def_id.to_def_id()) {\n+                        if matches!(generator_kind, hir::GeneratorKind::Async(..)) {\n+                            self.check_op(ops::Generator(generator_kind));\n+                        }\n+                    }\n+                }\n+            }\n \n             Rvalue::Ref(_, kind @ BorrowKind::Mut { .. }, ref place)\n             | Rvalue::Ref(_, kind @ BorrowKind::Unique, ref place) => {\n@@ -889,14 +898,6 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                     return;\n                 }\n \n-                // `async` blocks get lowered to `std::future::from_generator(/* a closure */)`.\n-                let is_async_block = Some(callee) == tcx.lang_items().from_generator_fn();\n-                if is_async_block {\n-                    let kind = hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block);\n-                    self.check_op(ops::Generator(kind));\n-                    return;\n-                }\n-\n                 if !tcx.is_const_fn_raw(callee) {\n                     if !tcx.is_const_default_method(callee) {\n                         // To get to here we must have already found a const impl for the"}, {"sha": "038509031b180a3cd42417a23846ff36c00ea7c0", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -280,10 +280,14 @@ language_item_table! {\n \n     PointerSized,            sym::pointer_sized,       pointer_sized,              Target::Trait,          GenericRequirement::Exact(0);\n \n+    Poll,                    sym::Poll,                poll,                       Target::Enum,           GenericRequirement::None;\n     PollReady,               sym::Ready,               poll_ready_variant,         Target::Variant,        GenericRequirement::None;\n     PollPending,             sym::Pending,             poll_pending_variant,       Target::Variant,        GenericRequirement::None;\n \n-    FromGenerator,           sym::from_generator,      from_generator_fn,          Target::Fn,             GenericRequirement::None;\n+    // FIXME(swatinem): the following lang items are used for async lowering and\n+    // should become obsolete eventually.\n+    ResumeTy,                sym::ResumeTy,            resume_ty,                  Target::Struct,         GenericRequirement::None;\n+    IdentityFuture,          sym::identity_future,     identity_future_fn,         Target::Fn,             GenericRequirement::None;\n     GetContext,              sym::get_context,         get_context_fn,             Target::Fn,             GenericRequirement::None;\n \n     FuturePoll,              sym::poll,                future_poll_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;"}, {"sha": "2c24b9ef14e85833645887c2e9830152c1e51b62", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -56,10 +56,15 @@ pub(super) fn check_fn<'a, 'tcx>(\n \n     fn_maybe_err(tcx, span, fn_sig.abi);\n \n-    if body.generator_kind.is_some() && can_be_generator.is_some() {\n-        let yield_ty = fcx\n-            .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n-        fcx.require_type_is_sized(yield_ty, span, traits::SizedYieldType);\n+    if let Some(kind) = body.generator_kind && can_be_generator.is_some() {\n+        let yield_ty = if kind == hir::GeneratorKind::Gen {\n+            let yield_ty = fcx\n+                .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n+            fcx.require_type_is_sized(yield_ty, span, traits::SizedYieldType);\n+            yield_ty\n+        } else {\n+            tcx.mk_unit()\n+        };\n \n         // Resume type defaults to `()` if the generator has no argument.\n         let resume_ty = fn_sig.inputs().get(0).copied().unwrap_or_else(|| tcx.mk_unit());"}, {"sha": "5727a120390d49c72755ff8619456b2d2c2d06d5", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -1734,14 +1734,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let hir = self.tcx.hir();\n         let hir::Node::Expr(expr) = hir.get(hir_id) else { return false; };\n \n-        // Skip over mentioning async lang item\n-        if Some(def_id) == self.tcx.lang_items().from_generator_fn()\n-            && error.obligation.cause.span.desugaring_kind()\n-                == Some(rustc_span::DesugaringKind::Async)\n-        {\n-            return false;\n-        }\n-\n         let Some(unsubstituted_pred) =\n             self.tcx.predicates_of(def_id).instantiate_identity(self.tcx).predicates.into_iter().nth(idx)\n             else { return false; };"}, {"sha": "d6a01b425483129a1ff9a8d9c4139c246ed0cbd4", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -319,7 +319,20 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                         .map(|inner| MustUsePath::Array(Box::new(inner), len)),\n                 },\n                 ty::Closure(..) => Some(MustUsePath::Closure(span)),\n-                ty::Generator(..) => Some(MustUsePath::Generator(span)),\n+                ty::Generator(def_id, ..) => {\n+                    // async fn should be treated as \"implementor of `Future`\"\n+                    let must_use = if matches!(\n+                        cx.tcx.generator_kind(def_id),\n+                        Some(hir::GeneratorKind::Async(..))\n+                    ) {\n+                        let def_id = cx.tcx.lang_items().future_trait().unwrap();\n+                        is_def_must_use(cx, def_id, span)\n+                            .map(|inner| MustUsePath::Opaque(Box::new(inner)))\n+                    } else {\n+                        None\n+                    };\n+                    must_use.or(Some(MustUsePath::Generator(span)))\n+                }\n                 _ => None,\n             }\n         }"}, {"sha": "536d2872bf084af6660ffa4cc410aa0bab2831af", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -660,6 +660,9 @@ pub enum ImplSource<'tcx, N> {\n     /// ImplSource automatically generated for a generator.\n     Generator(ImplSourceGeneratorData<'tcx, N>),\n \n+    /// ImplSource automatically generated for a generator backing an async future.\n+    Future(ImplSourceFutureData<'tcx, N>),\n+\n     /// ImplSource for a trait alias.\n     TraitAlias(ImplSourceTraitAliasData<'tcx, N>),\n \n@@ -676,6 +679,7 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n             ImplSource::AutoImpl(d) => d.nested,\n             ImplSource::Closure(c) => c.nested,\n             ImplSource::Generator(c) => c.nested,\n+            ImplSource::Future(c) => c.nested,\n             ImplSource::Object(d) => d.nested,\n             ImplSource::FnPointer(d) => d.nested,\n             ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n@@ -694,6 +698,7 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n             ImplSource::AutoImpl(d) => &d.nested,\n             ImplSource::Closure(c) => &c.nested,\n             ImplSource::Generator(c) => &c.nested,\n+            ImplSource::Future(c) => &c.nested,\n             ImplSource::Object(d) => &d.nested,\n             ImplSource::FnPointer(d) => &d.nested,\n             ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n@@ -737,6 +742,11 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n                 substs: c.substs,\n                 nested: c.nested.into_iter().map(f).collect(),\n             }),\n+            ImplSource::Future(c) => ImplSource::Future(ImplSourceFutureData {\n+                generator_def_id: c.generator_def_id,\n+                substs: c.substs,\n+                nested: c.nested.into_iter().map(f).collect(),\n+            }),\n             ImplSource::FnPointer(p) => ImplSource::FnPointer(ImplSourceFnPointerData {\n                 fn_ty: p.fn_ty,\n                 nested: p.nested.into_iter().map(f).collect(),\n@@ -796,6 +806,16 @@ pub struct ImplSourceGeneratorData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n+#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n+#[derive(TypeFoldable, TypeVisitable)]\n+pub struct ImplSourceFutureData<'tcx, N> {\n+    pub generator_def_id: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+    /// Nested obligations. This can be non-empty if the generator\n+    /// signature contains associated types.\n+    pub nested: Vec<N>,\n+}\n+\n #[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n #[derive(TypeFoldable, TypeVisitable)]\n pub struct ImplSourceClosureData<'tcx, N> {"}, {"sha": "99bfa477f74e895112586e7787f31625531599d3", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -131,6 +131,10 @@ pub enum SelectionCandidate<'tcx> {\n     /// generated for a generator.\n     GeneratorCandidate,\n \n+    /// Implementation of a `Future` trait by one of the generator types\n+    /// generated for an async construct.\n+    FutureCandidate,\n+\n     /// Implementation of a `Fn`-family trait by one of the anonymous\n     /// types generated for a fn pointer type (e.g., `fn(int) -> int`)\n     FnPointerCandidate {"}, {"sha": "735cece83997a999723f8aafa0084fbe456ce5b7", "filename": "compiler/rustc_middle/src/traits/structural_impls.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -15,6 +15,8 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSource<'tcx, N> {\n \n             super::ImplSource::Generator(ref d) => write!(f, \"{:?}\", d),\n \n+            super::ImplSource::Future(ref d) => write!(f, \"{:?}\", d),\n+\n             super::ImplSource::FnPointer(ref d) => write!(f, \"({:?})\", d),\n \n             super::ImplSource::DiscriminantKind(ref d) => write!(f, \"{:?}\", d),\n@@ -58,6 +60,16 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceGeneratorData<'tcx, N\n     }\n }\n \n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceFutureData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"ImplSourceFutureData(generator_def_id={:?}, substs={:?}, nested={:?})\",\n+            self.generator_def_id, self.substs, self.nested\n+        )\n+    }\n+}\n+\n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceClosureData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!("}, {"sha": "c54edf10c2d8f79a5af9ed271c7e8f9a0b7db5ab", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -681,6 +681,17 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             ty::Str => p!(\"str\"),\n             ty::Generator(did, substs, movability) => {\n+                // FIXME(swatinem): async constructs used to be pretty printed\n+                // as `impl Future` previously due to the `from_generator` wrapping.\n+                // lets special case this here for now to avoid churn in diagnostics.\n+                let generator_kind = self.tcx().generator_kind(did);\n+                if matches!(generator_kind, Some(hir::GeneratorKind::Async(..))) {\n+                    let return_ty = substs.as_generator().return_ty();\n+                    p!(write(\"impl Future<Output = {}>\", return_ty));\n+\n+                    return Ok(self);\n+                }\n+\n                 p!(write(\"[\"));\n                 match movability {\n                     hir::Movability::Movable => {}"}, {"sha": "ffe4d43bc88e88970ddf6d36aa24ccda53f7f4f6", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 68, "deletions": 27, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -11,10 +11,10 @@\n //! generator in the MIR, since it is used to create the drop glue for the generator. We'd get\n //! infinite recursion otherwise.\n //!\n-//! This pass creates the implementation for the Generator::resume function and the drop shim\n-//! for the generator based on the MIR input. It converts the generator argument from Self to\n-//! &mut Self adding derefs in the MIR as needed. It computes the final layout of the generator\n-//! struct which looks like this:\n+//! This pass creates the implementation for either the `Generator::resume` or `Future::poll`\n+//! function and the drop shim for the generator based on the MIR input.\n+//! It converts the generator argument from Self to &mut Self adding derefs in the MIR as needed.\n+//! It computes the final layout of the generator struct which looks like this:\n //!     First upvars are stored\n //!     It is followed by the generator state field.\n //!     Then finally the MIR locals which are live across a suspension point are stored.\n@@ -32,14 +32,15 @@\n //!     2 - Generator has been poisoned\n //!\n //! It also rewrites `return x` and `yield y` as setting a new generator state and returning\n-//! GeneratorState::Complete(x) and GeneratorState::Yielded(y) respectively.\n+//! `GeneratorState::Complete(x)` and `GeneratorState::Yielded(y)`,\n+//! or `Poll::Ready(x)` and `Poll::Pending` respectively.\n //! MIR locals which are live across a suspension point are moved to the generator struct\n //! with references to them being updated with references to the generator struct.\n //!\n //! The pass creates two functions which have a switch on the generator state giving\n //! the action to take.\n //!\n-//! One of them is the implementation of Generator::resume.\n+//! One of them is the implementation of `Generator::resume` / `Future::poll`.\n //! For generators with state 0 (unresumed) it starts the execution of the generator.\n //! For generators with state 1 (returned) and state 2 (poisoned) it panics.\n //! Otherwise it continues the execution from the last suspension point.\n@@ -56,6 +57,7 @@ use crate::MirPass;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n+use rustc_hir::GeneratorKind;\n use rustc_index::bit_set::{BitMatrix, BitSet, GrowableBitSet};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::dump_mir;\n@@ -215,6 +217,7 @@ struct SuspensionPoint<'tcx> {\n \n struct TransformVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n+    is_async_kind: bool,\n     state_adt_ref: AdtDef<'tcx>,\n     state_substs: SubstsRef<'tcx>,\n \n@@ -239,28 +242,57 @@ struct TransformVisitor<'tcx> {\n }\n \n impl<'tcx> TransformVisitor<'tcx> {\n-    // Make a GeneratorState variant assignment. `core::ops::GeneratorState` only has single\n-    // element tuple variants, so we can just write to the downcasted first field and then set the\n+    // Make a `GeneratorState` or `Poll` variant assignment.\n+    //\n+    // `core::ops::GeneratorState` only has single element tuple variants,\n+    // so we can just write to the downcasted first field and then set the\n     // discriminant to the appropriate variant.\n     fn make_state(\n         &self,\n-        idx: VariantIdx,\n         val: Operand<'tcx>,\n         source_info: SourceInfo,\n-    ) -> impl Iterator<Item = Statement<'tcx>> {\n+        is_return: bool,\n+        statements: &mut Vec<Statement<'tcx>>,\n+    ) {\n+        let idx = VariantIdx::new(match (is_return, self.is_async_kind) {\n+            (true, false) => 1,  // GeneratorState::Complete\n+            (false, false) => 0, // GeneratorState::Yielded\n+            (true, true) => 0,   // Poll::Ready\n+            (false, true) => 1,  // Poll::Pending\n+        });\n+\n         let kind = AggregateKind::Adt(self.state_adt_ref.did(), idx, self.state_substs, None, None);\n+\n+        // `Poll::Pending`\n+        if self.is_async_kind && idx == VariantIdx::new(1) {\n+            assert_eq!(self.state_adt_ref.variant(idx).fields.len(), 0);\n+\n+            // FIXME(swatinem): assert that `val` is indeed unit?\n+            statements.extend(expand_aggregate(\n+                Place::return_place(),\n+                std::iter::empty(),\n+                kind,\n+                source_info,\n+                self.tcx,\n+            ));\n+            return;\n+        }\n+\n+        // else: `Poll::Ready(x)`, `GeneratorState::Yielded(x)` or `GeneratorState::Complete(x)`\n         assert_eq!(self.state_adt_ref.variant(idx).fields.len(), 1);\n+\n         let ty = self\n             .tcx\n             .bound_type_of(self.state_adt_ref.variant(idx).fields[0].did)\n             .subst(self.tcx, self.state_substs);\n-        expand_aggregate(\n+\n+        statements.extend(expand_aggregate(\n             Place::return_place(),\n             std::iter::once((val, ty)),\n             kind,\n             source_info,\n             self.tcx,\n-        )\n+        ));\n     }\n \n     // Create a Place referencing a generator struct field\n@@ -331,22 +363,19 @@ impl<'tcx> MutVisitor<'tcx> for TransformVisitor<'tcx> {\n         });\n \n         let ret_val = match data.terminator().kind {\n-            TerminatorKind::Return => Some((\n-                VariantIdx::new(1),\n-                None,\n-                Operand::Move(Place::from(self.new_ret_local)),\n-                None,\n-            )),\n+            TerminatorKind::Return => {\n+                Some((true, None, Operand::Move(Place::from(self.new_ret_local)), None))\n+            }\n             TerminatorKind::Yield { ref value, resume, resume_arg, drop } => {\n-                Some((VariantIdx::new(0), Some((resume, resume_arg)), value.clone(), drop))\n+                Some((false, Some((resume, resume_arg)), value.clone(), drop))\n             }\n             _ => None,\n         };\n \n-        if let Some((state_idx, resume, v, drop)) = ret_val {\n+        if let Some((is_return, resume, v, drop)) = ret_val {\n             let source_info = data.terminator().source_info;\n             // We must assign the value first in case it gets declared dead below\n-            data.statements.extend(self.make_state(state_idx, v, source_info));\n+            self.make_state(v, source_info, is_return, &mut data.statements);\n             let state = if let Some((resume, mut resume_arg)) = resume {\n                 // Yield\n                 let state = RESERVED_VARIANTS + self.suspension_points.len();\n@@ -1268,10 +1297,20 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n             }\n         };\n \n-        // Compute GeneratorState<yield_ty, return_ty>\n-        let state_did = tcx.require_lang_item(LangItem::GeneratorState, None);\n-        let state_adt_ref = tcx.adt_def(state_did);\n-        let state_substs = tcx.intern_substs(&[yield_ty.into(), body.return_ty().into()]);\n+        let is_async_kind = body.generator_kind().unwrap() != GeneratorKind::Gen;\n+        let (state_adt_ref, state_substs) = if is_async_kind {\n+            // Compute Poll<return_ty>\n+            let state_did = tcx.require_lang_item(LangItem::Poll, None);\n+            let state_adt_ref = tcx.adt_def(state_did);\n+            let state_substs = tcx.intern_substs(&[body.return_ty().into()]);\n+            (state_adt_ref, state_substs)\n+        } else {\n+            // Compute GeneratorState<yield_ty, return_ty>\n+            let state_did = tcx.require_lang_item(LangItem::GeneratorState, None);\n+            let state_adt_ref = tcx.adt_def(state_did);\n+            let state_substs = tcx.intern_substs(&[yield_ty.into(), body.return_ty().into()]);\n+            (state_adt_ref, state_substs)\n+        };\n         let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n \n         // We rename RETURN_PLACE which has type mir.return_ty to new_ret_local\n@@ -1327,9 +1366,11 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         // Run the transformation which converts Places from Local to generator struct\n         // accesses for locals in `remap`.\n         // It also rewrites `return x` and `yield y` as writing a new generator state and returning\n-        // GeneratorState::Complete(x) and GeneratorState::Yielded(y) respectively.\n+        // either GeneratorState::Complete(x) and GeneratorState::Yielded(y),\n+        // or Poll::Ready(x) and Poll::Pending respectively depending on `is_async_kind`.\n         let mut transform = TransformVisitor {\n             tcx,\n+            is_async_kind,\n             state_adt_ref,\n             state_substs,\n             remap,\n@@ -1367,7 +1408,7 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n \n         body.generator.as_mut().unwrap().generator_drop = Some(drop_shim);\n \n-        // Create the Generator::resume function\n+        // Create the Generator::resume / Future::poll function\n         create_generator_resume_function(tcx, transform, body, can_return);\n \n         // Run derefer to fix Derefs that are not in the first place"}, {"sha": "2cc3e410d206f4e4969847344d6a1630f16c8a9b", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -3912,7 +3912,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 visit::walk_expr(self, expr);\n                 self.diagnostic_metadata.current_type_ascription.pop();\n             }\n-            // `async |x| ...` gets desugared to `|x| future_from_generator(|| ...)`, so we need to\n+            // `async |x| ...` gets desugared to `|x| async {...}`, so we need to\n             // resolve the arguments within the proper scopes so that usages of them inside the\n             // closure are detected as upvars rather than normal closure arg usages.\n             ExprKind::Closure(box ast::Closure {"}, {"sha": "aba301dce10989ee8dd52c090066809f5db79f65", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -264,6 +264,7 @@ symbols! {\n         Relaxed,\n         Release,\n         Result,\n+        ResumeTy,\n         Return,\n         Right,\n         Rust,\n@@ -728,7 +729,6 @@ symbols! {\n         frem_fast,\n         from,\n         from_desugaring,\n-        from_generator,\n         from_iter,\n         from_method,\n         from_output,\n@@ -779,6 +779,7 @@ symbols! {\n         i64,\n         i8,\n         ident,\n+        identity_future,\n         if_let,\n         if_let_guard,\n         if_while_or_patterns,"}, {"sha": "30207033236c5314628a92ab01e09c5f04b715e4", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -1885,13 +1885,9 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         //\n         // - `BuiltinDerivedObligation` with a generator witness (B)\n         // - `BuiltinDerivedObligation` with a generator (B)\n-        // - `BuiltinDerivedObligation` with `std::future::GenFuture` (B)\n-        // - `BuiltinDerivedObligation` with `impl std::future::Future` (B)\n         // - `BuiltinDerivedObligation` with `impl std::future::Future` (B)\n         // - `BuiltinDerivedObligation` with a generator witness (A)\n         // - `BuiltinDerivedObligation` with a generator (A)\n-        // - `BuiltinDerivedObligation` with `std::future::GenFuture` (A)\n-        // - `BuiltinDerivedObligation` with `impl std::future::Future` (A)\n         // - `BuiltinDerivedObligation` with `impl std::future::Future` (A)\n         // - `BindingObligation` with `impl_send (Send requirement)\n         //\n@@ -2624,30 +2620,24 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     }\n                 };\n \n-                let from_generator = tcx.require_lang_item(LangItem::FromGenerator, None);\n+                let identity_future = tcx.require_lang_item(LangItem::IdentityFuture, None);\n \n                 // Don't print the tuple of capture types\n                 'print: {\n                     if !is_upvar_tys_infer_tuple {\n                         let msg = format!(\"required because it appears within the type `{}`\", ty);\n                         match ty.kind() {\n-                            ty::Adt(def, _) => {\n-                                // `gen_future` is used in all async functions; it doesn't add any additional info.\n-                                if self.tcx.is_diagnostic_item(sym::gen_future, def.did()) {\n-                                    break 'print;\n-                                }\n-                                match self.tcx.opt_item_ident(def.did()) {\n-                                    Some(ident) => err.span_note(ident.span, &msg),\n-                                    None => err.note(&msg),\n-                                }\n-                            }\n+                            ty::Adt(def, _) => match self.tcx.opt_item_ident(def.did()) {\n+                                Some(ident) => err.span_note(ident.span, &msg),\n+                                None => err.note(&msg),\n+                            },\n                             ty::Opaque(def_id, _) => {\n-                                // Avoid printing the future from `core::future::from_generator`, it's not helpful\n-                                if tcx.parent(*def_id) == from_generator {\n+                                // Avoid printing the future from `core::future::identity_future`, it's not helpful\n+                                if tcx.parent(*def_id) == identity_future {\n                                     break 'print;\n                                 }\n \n-                                // If the previous type is `from_generator`, this is the future generated by the body of an async function.\n+                                // If the previous type is `identity_future`, this is the future generated by the body of an async function.\n                                 // Avoid printing it twice (it was already printed in the `ty::Generator` arm below).\n                                 let is_future = tcx.ty_is_opaque_future(ty);\n                                 debug!(\n@@ -2657,8 +2647,11 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 );\n                                 if is_future\n                                     && obligated_types.last().map_or(false, |ty| match ty.kind() {\n-                                        ty::Opaque(last_def_id, _) => {\n-                                            tcx.parent(*last_def_id) == from_generator\n+                                        ty::Generator(last_def_id, ..) => {\n+                                            matches!(\n+                                                tcx.generator_kind(last_def_id),\n+                                                Some(GeneratorKind::Async(..))\n+                                            )\n                                         }\n                                         _ => false,\n                                     })"}, {"sha": "f17d702d421bd4e0e39da696c10aed09c00d8d8f", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -12,7 +12,8 @@ use super::SelectionContext;\n use super::SelectionError;\n use super::{\n     ImplSourceClosureData, ImplSourceDiscriminantKindData, ImplSourceFnPointerData,\n-    ImplSourceGeneratorData, ImplSourcePointeeData, ImplSourceUserDefinedData,\n+    ImplSourceFutureData, ImplSourceGeneratorData, ImplSourcePointeeData,\n+    ImplSourceUserDefinedData,\n };\n use super::{Normalized, NormalizedTy, ProjectionCacheEntry, ProjectionCacheKey};\n \n@@ -1544,6 +1545,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n         let eligible = match &impl_source {\n             super::ImplSource::Closure(_)\n             | super::ImplSource::Generator(_)\n+            | super::ImplSource::Future(_)\n             | super::ImplSource::FnPointer(_)\n             | super::ImplSource::TraitAlias(_) => true,\n             super::ImplSource::UserDefined(impl_data) => {\n@@ -1832,6 +1834,7 @@ fn confirm_select_candidate<'cx, 'tcx>(\n     match impl_source {\n         super::ImplSource::UserDefined(data) => confirm_impl_candidate(selcx, obligation, data),\n         super::ImplSource::Generator(data) => confirm_generator_candidate(selcx, obligation, data),\n+        super::ImplSource::Future(data) => confirm_future_candidate(selcx, obligation, data),\n         super::ImplSource::Closure(data) => confirm_closure_candidate(selcx, obligation, data),\n         super::ImplSource::FnPointer(data) => confirm_fn_pointer_candidate(selcx, obligation, data),\n         super::ImplSource::DiscriminantKind(data) => {\n@@ -1905,6 +1908,48 @@ fn confirm_generator_candidate<'cx, 'tcx>(\n         .with_addl_obligations(obligations)\n }\n \n+fn confirm_future_candidate<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    impl_source: ImplSourceFutureData<'tcx, PredicateObligation<'tcx>>,\n+) -> Progress<'tcx> {\n+    let gen_sig = impl_source.substs.as_generator().poly_sig();\n+    let Normalized { value: gen_sig, obligations } = normalize_with_depth(\n+        selcx,\n+        obligation.param_env,\n+        obligation.cause.clone(),\n+        obligation.recursion_depth + 1,\n+        gen_sig,\n+    );\n+\n+    debug!(?obligation, ?gen_sig, ?obligations, \"confirm_future_candidate\");\n+\n+    let tcx = selcx.tcx();\n+    let fut_def_id = tcx.require_lang_item(LangItem::Future, None);\n+\n+    let predicate = super::util::future_trait_ref_and_outputs(\n+        tcx,\n+        fut_def_id,\n+        obligation.predicate.self_ty(),\n+        gen_sig,\n+    )\n+    .map_bound(|(trait_ref, return_ty)| {\n+        debug_assert_eq!(tcx.associated_item(obligation.predicate.item_def_id).name, sym::Output);\n+\n+        ty::ProjectionPredicate {\n+            projection_ty: ty::ProjectionTy {\n+                substs: trait_ref.substs,\n+                item_def_id: obligation.predicate.item_def_id,\n+            },\n+            term: return_ty.into(),\n+        }\n+    });\n+\n+    confirm_param_env_candidate(selcx, obligation, predicate, false)\n+        .with_addl_obligations(impl_source.nested)\n+        .with_addl_obligations(obligations)\n+}\n+\n fn confirm_discriminant_kind_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,"}, {"sha": "617dbe240e94a19dde6c5a115acbcc6f783e8913", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -314,7 +314,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     self.assemble_builtin_bound_candidates(clone_conditions, &mut candidates);\n                 }\n \n-                self.assemble_generator_candidates(obligation, &mut candidates);\n+                if lang_items.gen_trait() == Some(def_id) {\n+                    self.assemble_generator_candidates(obligation, &mut candidates);\n+                } else if lang_items.future_trait() == Some(def_id) {\n+                    self.assemble_future_candidates(obligation, &mut candidates);\n+                }\n+\n                 self.assemble_closure_candidates(obligation, &mut candidates);\n                 self.assemble_fn_pointer_candidates(obligation, &mut candidates);\n                 self.assemble_candidates_from_impls(obligation, &mut candidates);\n@@ -402,10 +407,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) {\n-        if self.tcx().lang_items().gen_trait() != Some(obligation.predicate.def_id()) {\n-            return;\n-        }\n-\n         // Okay to skip binder because the substs on generator types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters.\n@@ -424,6 +425,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n+    fn assemble_future_candidates(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) {\n+        let self_ty = obligation.self_ty().skip_binder();\n+        if let ty::Generator(did, ..) = self_ty.kind() {\n+            if let Some(rustc_hir::GeneratorKind::Async(_generator_kind)) =\n+                self.tcx().generator_kind(did)\n+            {\n+                debug!(?self_ty, ?obligation, \"assemble_future_candidates\",);\n+\n+                candidates.vec.push(FutureCandidate);\n+            }\n+        }\n+    }\n+\n     /// Checks for the artificial impl that the compiler will create for an obligation like `X :\n     /// FnMut<..>` where `X` is a closure type.\n     ///"}, {"sha": "4a90d8baf9e4454063f7cfe9007180e7b4abe07f", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 55, "deletions": 5, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -23,10 +23,11 @@ use crate::traits::{\n     BuiltinDerivedObligation, ImplDerivedObligation, ImplDerivedObligationCause, ImplSource,\n     ImplSourceAutoImplData, ImplSourceBuiltinData, ImplSourceClosureData,\n     ImplSourceConstDestructData, ImplSourceDiscriminantKindData, ImplSourceFnPointerData,\n-    ImplSourceGeneratorData, ImplSourceObjectData, ImplSourcePointeeData, ImplSourceTraitAliasData,\n-    ImplSourceTraitUpcastingData, ImplSourceUserDefinedData, Normalized, ObjectCastObligation,\n-    Obligation, ObligationCause, OutputTypeParameterMismatch, PredicateObligation, Selection,\n-    SelectionError, TraitNotObjectSafe, TraitObligation, Unimplemented, VtblSegment,\n+    ImplSourceFutureData, ImplSourceGeneratorData, ImplSourceObjectData, ImplSourcePointeeData,\n+    ImplSourceTraitAliasData, ImplSourceTraitUpcastingData, ImplSourceUserDefinedData, Normalized,\n+    ObjectCastObligation, Obligation, ObligationCause, OutputTypeParameterMismatch,\n+    PredicateObligation, Selection, SelectionError, TraitNotObjectSafe, TraitObligation,\n+    Unimplemented, VtblSegment,\n };\n \n use super::BuiltinImplConditions;\n@@ -89,6 +90,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ImplSource::Generator(vtable_generator)\n             }\n \n+            FutureCandidate => {\n+                let vtable_future = self.confirm_future_candidate(obligation)?;\n+                ImplSource::Future(vtable_future)\n+            }\n+\n             FnPointerCandidate { .. } => {\n                 let data = self.confirm_fn_pointer_candidate(obligation)?;\n                 ImplSource::FnPointer(data)\n@@ -685,14 +691,58 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(?obligation, ?generator_def_id, ?substs, \"confirm_generator_candidate\");\n \n-        let trait_ref = self.generator_trait_ref_unnormalized(obligation, substs);\n+        let gen_sig = substs.as_generator().poly_sig();\n+\n+        // (1) Feels icky to skip the binder here, but OTOH we know\n+        // that the self-type is an generator type and hence is\n+        // in fact unparameterized (or at least does not reference any\n+        // regions bound in the obligation). Still probably some\n+        // refactoring could make this nicer.\n+\n+        let trait_ref = super::util::generator_trait_ref_and_outputs(\n+            self.tcx(),\n+            obligation.predicate.def_id(),\n+            obligation.predicate.skip_binder().self_ty(), // (1)\n+            gen_sig,\n+        )\n+        .map_bound(|(trait_ref, ..)| trait_ref);\n \n         let nested = self.confirm_poly_trait_refs(obligation, trait_ref)?;\n         debug!(?trait_ref, ?nested, \"generator candidate obligations\");\n \n         Ok(ImplSourceGeneratorData { generator_def_id, substs, nested })\n     }\n \n+    fn confirm_future_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+    ) -> Result<ImplSourceFutureData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+        // Okay to skip binder because the substs on generator types never\n+        // touch bound regions, they just capture the in-scope\n+        // type/region parameters.\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n+        let ty::Generator(generator_def_id, substs, _) = *self_ty.kind() else {\n+            bug!(\"closure candidate for non-closure {:?}\", obligation);\n+        };\n+\n+        debug!(?obligation, ?generator_def_id, ?substs, \"confirm_future_candidate\");\n+\n+        let gen_sig = substs.as_generator().poly_sig();\n+\n+        let trait_ref = super::util::future_trait_ref_and_outputs(\n+            self.tcx(),\n+            obligation.predicate.def_id(),\n+            obligation.predicate.no_bound_vars().expect(\"future has no bound vars\").self_ty(),\n+            gen_sig,\n+        )\n+        .map_bound(|(trait_ref, ..)| trait_ref);\n+\n+        let nested = self.confirm_poly_trait_refs(obligation, trait_ref)?;\n+        debug!(?trait_ref, ?nested, \"future candidate obligations\");\n+\n+        Ok(ImplSourceFutureData { generator_def_id, substs, nested })\n+    }\n+\n     #[instrument(skip(self), level = \"debug\")]\n     fn confirm_closure_candidate(\n         &mut self,"}, {"sha": "9fe13fe296a16fcee2ced1992bd17128f8ab106f", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -1139,9 +1139,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ProjectionCandidate(_, ty::BoundConstness::ConstIfConst) => {}\n                     // auto trait impl\n                     AutoImplCandidate => {}\n-                    // generator, this will raise error in other places\n+                    // generator / future, this will raise error in other places\n                     // or ignore error with const_async_blocks feature\n                     GeneratorCandidate => {}\n+                    FutureCandidate => {}\n                     // FnDef where the function is const\n                     FnPointerCandidate { is_const: true } => {}\n                     ConstDestructCandidate(_) => {}\n@@ -1620,6 +1621,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ImplCandidate(..)\n                 | ClosureCandidate\n                 | GeneratorCandidate\n+                | FutureCandidate\n                 | FnPointerCandidate { .. }\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n@@ -1638,6 +1640,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ImplCandidate(_)\n                 | ClosureCandidate\n                 | GeneratorCandidate\n+                | FutureCandidate\n                 | FnPointerCandidate { .. }\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n@@ -1668,6 +1671,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ImplCandidate(..)\n                 | ClosureCandidate\n                 | GeneratorCandidate\n+                | FutureCandidate\n                 | FnPointerCandidate { .. }\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n@@ -1680,6 +1684,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ImplCandidate(..)\n                 | ClosureCandidate\n                 | GeneratorCandidate\n+                | FutureCandidate\n                 | FnPointerCandidate { .. }\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n@@ -1761,6 +1766,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ImplCandidate(_)\n                 | ClosureCandidate\n                 | GeneratorCandidate\n+                | FutureCandidate\n                 | FnPointerCandidate { .. }\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n@@ -1770,6 +1776,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ImplCandidate(_)\n                 | ClosureCandidate\n                 | GeneratorCandidate\n+                | FutureCandidate\n                 | FnPointerCandidate { .. }\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n@@ -2279,28 +2286,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         .map_bound(|(trait_ref, _)| trait_ref)\n     }\n \n-    fn generator_trait_ref_unnormalized(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        substs: SubstsRef<'tcx>,\n-    ) -> ty::PolyTraitRef<'tcx> {\n-        let gen_sig = substs.as_generator().poly_sig();\n-\n-        // (1) Feels icky to skip the binder here, but OTOH we know\n-        // that the self-type is an generator type and hence is\n-        // in fact unparameterized (or at least does not reference any\n-        // regions bound in the obligation). Still probably some\n-        // refactoring could make this nicer.\n-\n-        super::util::generator_trait_ref_and_outputs(\n-            self.tcx(),\n-            obligation.predicate.def_id(),\n-            obligation.predicate.skip_binder().self_ty(), // (1)\n-            gen_sig,\n-        )\n-        .map_bound(|(trait_ref, ..)| trait_ref)\n-    }\n-\n     /// Returns the obligations that are implied by instantiating an\n     /// impl or trait. The obligations are substituted and fully\n     /// normalized. This is used when confirming an impl or default"}, {"sha": "20d8a7a742c3a1487e3616b163fbe9ebdaa88773", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -318,6 +318,17 @@ pub fn generator_trait_ref_and_outputs<'tcx>(\n     sig.map_bound(|sig| (trait_ref, sig.yield_ty, sig.return_ty))\n }\n \n+pub fn future_trait_ref_and_outputs<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    fn_trait_def_id: DefId,\n+    self_ty: Ty<'tcx>,\n+    sig: ty::PolyGenSig<'tcx>,\n+) -> ty::Binder<'tcx, (ty::TraitRef<'tcx>, Ty<'tcx>)> {\n+    debug_assert!(!self_ty.has_escaping_bound_vars());\n+    let trait_ref = tcx.mk_trait_ref(fn_trait_def_id, [self_ty]);\n+    sig.map_bound(|sig| (trait_ref, sig.return_ty))\n+}\n+\n pub fn impl_item_is_final(tcx: TyCtxt<'_>, assoc_item: &ty::AssocItem) -> bool {\n     assoc_item.defaultness(tcx).is_final()\n         && tcx.impl_defaultness(assoc_item.container_id(tcx)).is_final()"}, {"sha": "9931a7f32ef7711fbaa45a26640b77113ee27816", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -413,7 +413,11 @@ impl<'tcx> LowerInto<'tcx, Ty<'tcx>> for &chalk_ir::Ty<RustInterner<'tcx>> {\n             TyKind::Closure(closure, substitution) => {\n                 ty::Closure(closure.0, substitution.lower_into(interner))\n             }\n-            TyKind::Generator(..) => unimplemented!(),\n+            TyKind::Generator(generator, substitution) => ty::Generator(\n+                generator.0,\n+                substitution.lower_into(interner),\n+                ast::Movability::Static,\n+            ),\n             TyKind::GeneratorWitness(..) => unimplemented!(),\n             TyKind::Never => ty::Never,\n             TyKind::Tuple(_len, substitution) => {"}, {"sha": "7f16b2d35e800a680abe223441597f9168f80c2c", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -202,6 +202,12 @@ fn resolve_associated_item<'tcx>(\n             )),\n             substs: generator_data.substs,\n         }),\n+        traits::ImplSource::Future(future_data) => Some(Instance {\n+            def: ty::InstanceDef::Item(ty::WithOptConstParam::unknown(\n+                future_data.generator_def_id,\n+            )),\n+            substs: future_data.substs,\n+        }),\n         traits::ImplSource::Closure(closure_data) => {\n             let trait_closure_kind = tcx.fn_trait_kind_from_lang_item(trait_id).unwrap();\n             Instance::resolve_closure("}, {"sha": "f2b961d62e00c8149750785c3792cdf94924ce1d", "filename": "library/core/src/future/mod.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -9,12 +9,8 @@\n //! [`await`]: ../../std/keyword.await.html\n //! [async book]: https://rust-lang.github.io/async-book/\n \n-use crate::{\n-    ops::{Generator, GeneratorState},\n-    pin::Pin,\n-    ptr::NonNull,\n-    task::{Context, Poll},\n-};\n+use crate::ptr::NonNull;\n+use crate::task::Context;\n \n mod future;\n mod into_future;\n@@ -48,6 +44,7 @@ pub use poll_fn::{poll_fn, PollFn};\n ///    non-Send/Sync as well, and we don't want that.\n ///\n /// It also simplifies the HIR lowering of `.await`.\n+#[cfg_attr(not(bootstrap), lang = \"ResumeTy\")]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[derive(Debug, Copy, Clone)]\n@@ -64,15 +61,21 @@ unsafe impl Sync for ResumeTy {}\n /// This function returns a `GenFuture` underneath, but hides it in `impl Trait` to give\n /// better error messages (`impl Future` rather than `GenFuture<[closure.....]>`).\n // This is `const` to avoid extra errors after we recover from `const async fn`\n-#[lang = \"from_generator\"]\n+#[cfg_attr(bootstrap, lang = \"from_generator\")]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[rustc_const_unstable(feature = \"gen_future\", issue = \"50547\")]\n #[inline]\n pub const fn from_generator<T>(gen: T) -> impl Future<Output = T::Return>\n where\n-    T: Generator<ResumeTy, Yield = ()>,\n+    T: crate::ops::Generator<ResumeTy, Yield = ()>,\n {\n+    use crate::{\n+        ops::{Generator, GeneratorState},\n+        pin::Pin,\n+        task::Poll,\n+    };\n+\n     #[rustc_diagnostic_item = \"gen_future\"]\n     struct GenFuture<T: Generator<ResumeTy, Yield = ()>>(T);\n \n@@ -109,3 +112,11 @@ pub unsafe fn get_context<'a, 'b>(cx: ResumeTy) -> &'a mut Context<'b> {\n     // that fulfills all the requirements for a mutable reference.\n     unsafe { &mut *cx.0.as_ptr().cast() }\n }\n+\n+#[cfg_attr(not(bootstrap), lang = \"identity_future\")]\n+#[doc(hidden)]\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+#[inline]\n+pub const fn identity_future<O, Fut: Future<Output = O>>(f: Fut) -> Fut {\n+    f\n+}"}, {"sha": "f1dc4f7b575aaeb03deaaa41ace566fdbb0ec36e", "filename": "library/core/src/task/poll.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -9,6 +9,7 @@ use crate::task::Ready;\n /// scheduled to receive a wakeup instead.\n #[must_use = \"this `Poll` may be a `Pending` variant, which should be handled\"]\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+#[cfg_attr(not(bootstrap), lang = \"Poll\")]\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub enum Poll<T> {\n     /// Represents that a value is immediately ready."}, {"sha": "bc2686158140106026ca75b7895d0ce2e644c709", "filename": "src/test/codegen/async-fn-debug-awaitee-field.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fcodegen%2Fasync-fn-debug-awaitee-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fcodegen%2Fasync-fn-debug-awaitee-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fasync-fn-debug-awaitee-field.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -11,12 +11,14 @@ async fn async_fn_test() {\n     foo().await;\n }\n \n-// NONMSVC: [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_fn_env#0}\",\n+// NONMSVC: [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_fn_env#0}\", scope: [[GEN_SCOPE:![0-9]*]],\n // MSVC: [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"enum2$<async_fn_debug_awaitee_field::async_fn_test::async_fn_env$0>\",\n+// NONMSVC: [[GEN_SCOPE:!.*]] = !DINamespace(name: \"async_fn_test\",\n // CHECK: [[SUSPEND_STRUCT:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Suspend0\", scope: [[GEN]],\n // CHECK: !DIDerivedType(tag: DW_TAG_member, name: \"__awaitee\", scope: [[SUSPEND_STRUCT]], {{.*}}, baseType: [[AWAITEE_TYPE:![0-9]*]],\n-// NONMSVC: [[AWAITEE_TYPE]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"GenFuture<async_fn_debug_awaitee_field::foo::{async_fn_env#0}>\",\n-// MSVC: [[AWAITEE_TYPE]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"GenFuture<enum2$<async_fn_debug_awaitee_field::foo::async_fn_env$0> >\",\n+// NONMSVC: [[AWAITEE_TYPE]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_fn_env#0}\", scope: [[AWAITEE_SCOPE:![0-9]*]],\n+// MSVC: [[AWAITEE_TYPE]] = !DICompositeType(tag: DW_TAG_union_type, name: \"enum2$<async_fn_debug_awaitee_field::foo::async_fn_env$0>\",\n+// NONMSVC: [[AWAITEE_SCOPE]] = !DINamespace(name: \"foo\",\n \n fn main() {\n     let _fn = async_fn_test();"}, {"sha": "500dde1f2698ae7d5870f308b19bb8eb75fe9a60", "filename": "src/test/run-make/coverage-reports/expected_show_coverage.async2.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.async2.txt", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.async2.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.async2.txt?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -72,7 +72,7 @@\n    67|       |        }\n    68|      2|    }\n   ------------------\n-  | async2::executor::block_on::<core::future::from_generator::GenFuture<async2::async_func::{closure#0}>>:\n+  | async2::executor::block_on::<async2::async_func::{closure#0}>:\n   |   51|      1|    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n   |   52|      1|        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n   |   53|      1|        use std::hint::unreachable_unchecked;\n@@ -92,7 +92,7 @@\n   |   67|       |        }\n   |   68|      1|    }\n   ------------------\n-  | async2::executor::block_on::<core::future::from_generator::GenFuture<async2::async_func_just_println::{closure#0}>>:\n+  | async2::executor::block_on::<async2::async_func_just_println::{closure#0}>:\n   |   51|      1|    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n   |   52|      1|        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n   |   53|      1|        use std::hint::unreachable_unchecked;"}, {"sha": "b8ca64fae831948c51f4ae38810f29034e639205", "filename": "src/test/ui/async-await/async-block-control-flow-static-semantics.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -1,8 +1,7 @@\n error[E0267]: `break` inside of an `async` block\n   --> $DIR/async-block-control-flow-static-semantics.rs:32:9\n    |\n-LL |       async {\n-   |  ___________-\n+LL | /     async {\n LL | |         break 0u8;\n    | |         ^^^^^^^^^ cannot `break` inside of an `async` block\n LL | |     };\n@@ -11,8 +10,7 @@ LL | |     };\n error[E0267]: `break` inside of an `async` block\n   --> $DIR/async-block-control-flow-static-semantics.rs:39:13\n    |\n-LL |           async {\n-   |  _______________-\n+LL | /         async {\n LL | |             break 0u8;\n    | |             ^^^^^^^^^ cannot `break` inside of an `async` block\n LL | |         };"}, {"sha": "190c59e32ebbbc9dfe69c7e133daec6559eb48b8", "filename": "src/test/ui/async-await/async-borrowck-escaping-block-error.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-block-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-block-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-block-error.stderr?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -1,11 +1,11 @@\n error[E0373]: async block may outlive the current function, but it borrows `x`, which is owned by the current function\n-  --> $DIR/async-borrowck-escaping-block-error.rs:6:20\n+  --> $DIR/async-borrowck-escaping-block-error.rs:6:14\n    |\n LL |     Box::new(async { x } )\n-   |                    ^^-^^\n-   |                    | |\n-   |                    | `x` is borrowed here\n-   |                    may outlive borrowed value `x`\n+   |              ^^^^^^^^-^^\n+   |              |       |\n+   |              |       `x` is borrowed here\n+   |              may outlive borrowed value `x`\n    |\n note: async block is returned here\n   --> $DIR/async-borrowck-escaping-block-error.rs:6:5\n@@ -18,13 +18,13 @@ LL |     Box::new(async move { x } )\n    |                    ++++\n \n error[E0373]: async block may outlive the current function, but it borrows `x`, which is owned by the current function\n-  --> $DIR/async-borrowck-escaping-block-error.rs:11:11\n+  --> $DIR/async-borrowck-escaping-block-error.rs:11:5\n    |\n LL |     async { *x }\n-   |           ^^--^^\n-   |           | |\n-   |           | `x` is borrowed here\n-   |           may outlive borrowed value `x`\n+   |     ^^^^^^^^--^^\n+   |     |       |\n+   |     |       `x` is borrowed here\n+   |     may outlive borrowed value `x`\n    |\n note: async block is returned here\n   --> $DIR/async-borrowck-escaping-block-error.rs:11:5"}, {"sha": "774c97966b18eb9f2b97cf73a42a230442d8a824", "filename": "src/test/ui/async-await/generator-desc.stderr", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Fasync-await%2Fgenerator-desc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Fasync-await%2Fgenerator-desc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fgenerator-desc.stderr?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -1,20 +1,20 @@\n error[E0308]: mismatched types\n-  --> $DIR/generator-desc.rs:10:25\n+  --> $DIR/generator-desc.rs:10:19\n    |\n LL |     fun(async {}, async {});\n-   |               --        ^^\n-   |               |         |\n-   |               |         expected `async` block, found a different `async` block\n-   |               |         arguments to this function are incorrect\n-   |               the expected `async` block\n+   |         --------  ^^^^^^^^\n+   |         |         |\n+   |         |         expected `async` block, found a different `async` block\n+   |         |         arguments to this function are incorrect\n+   |         the expected `async` block\n    |\n-   = note: expected `async` block `[static generator@$DIR/generator-desc.rs:10:15: 10:17]`\n-              found `async` block `[static generator@$DIR/generator-desc.rs:10:25: 10:27]`\n+   = note: expected `async` block `impl Future<Output = ()>` (`async` block)\n+              found `async` block `impl Future<Output = ()>` (`async` block)\n note: function defined here\n   --> $SRC_DIR/core/src/future/mod.rs:LL:COL\n    |\n-LL | pub const fn from_generator<T>(gen: T) -> impl Future<Output = T::Return>\n-   |              ^^^^^^^^^^^^^^\n+LL | pub const fn identity_future<O, Fut: Future<Output = O>>(f: Fut) -> Fut {\n+   |              ^^^^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/generator-desc.rs:12:16\n@@ -53,16 +53,8 @@ LL |     fun((async || {})(), (async || {})());\n    |     |             the expected `async` closure body\n    |     arguments to this function are incorrect\n    |\n-  ::: $SRC_DIR/core/src/future/mod.rs:LL:COL\n-   |\n-LL | pub const fn from_generator<T>(gen: T) -> impl Future<Output = T::Return>\n-   |                                           -------------------------------\n-   |                                           |\n-   |                                           the expected opaque type\n-   |                                           the found opaque type\n-   |\n-   = note: expected opaque type `impl Future<Output = ()>` (`async` closure body)\n-              found opaque type `impl Future<Output = ()>` (`async` closure body)\n+   = note: expected `async` closure body `impl Future<Output = ()>` (`async` closure body)\n+              found `async` closure body `impl Future<Output = ()>` (`async` closure body)\n note: function defined here\n   --> $DIR/generator-desc.rs:8:4\n    |"}, {"sha": "f2802698fd5b646fdd3e993df175ae58705b5abe", "filename": "src/test/ui/async-await/issue-68112.drop_tracking.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.drop_tracking.stderr?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -59,10 +59,10 @@ LL | fn make_non_send_future2() -> impl Future<Output = Arc<RefCell<i32>>> {\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: required because it captures the following types: `ResumeTy`, `impl Future<Output = Arc<RefCell<i32>>>`, `()`, `Ready<i32>`\n note: required because it's used within this `async` block\n-  --> $DIR/issue-68112.rs:60:26\n+  --> $DIR/issue-68112.rs:60:20\n    |\n LL |       let send_fut = async {\n-   |  __________________________^\n+   |  ____________________^\n LL | |         let non_send_fut = make_non_send_future2();\n LL | |         let _ = non_send_fut.await;\n LL | |         ready(0).await;"}, {"sha": "38eb85b302fd588abbeb8e8f4b82f84338fa21bb", "filename": "src/test/ui/async-await/issue-68112.no_drop_tracking.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.no_drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.no_drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.no_drop_tracking.stderr?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -59,10 +59,10 @@ LL | fn make_non_send_future2() -> impl Future<Output = Arc<RefCell<i32>>> {\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: required because it captures the following types: `ResumeTy`, `impl Future<Output = Arc<RefCell<i32>>>`, `()`, `i32`, `Ready<i32>`\n note: required because it's used within this `async` block\n-  --> $DIR/issue-68112.rs:60:26\n+  --> $DIR/issue-68112.rs:60:20\n    |\n LL |       let send_fut = async {\n-   |  __________________________^\n+   |  ____________________^\n LL | |         let non_send_fut = make_non_send_future2();\n LL | |         let _ = non_send_fut.await;\n LL | |         ready(0).await;"}, {"sha": "721234aa4a782875a2e90e32d4c2f5bea168c7f0", "filename": "src/test/ui/async-await/issue-70935-complex-spans.drop_tracking.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.drop_tracking.stderr?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -20,10 +20,9 @@ LL | | }\n    | |_^\n    = note: required because it captures the following types: `ResumeTy`, `impl Future<Output = ()>`, `()`\n note: required because it's used within this `async` block\n-  --> $DIR/issue-70935-complex-spans.rs:16:16\n+  --> $DIR/issue-70935-complex-spans.rs:16:5\n    |\n-LL |       async move {\n-   |  ________________^\n+LL | /     async move {\n LL | |         baz(|| async{\n LL | |             foo(tx.clone());\n LL | |         }).await;"}, {"sha": "c1a4b467f104e35c01804d750ee2da16cb1b228b", "filename": "src/test/ui/async-await/issues/issue-78938-async-block.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78938-async-block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78938-async-block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78938-async-block.stderr?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -1,8 +1,8 @@\n error[E0373]: async block may outlive the current function, but it borrows `room_ref`, which is owned by the current function\n-  --> $DIR/issue-78938-async-block.rs:8:39\n+  --> $DIR/issue-78938-async-block.rs:8:33\n    |\n LL |       let gameloop_handle = spawn(async {\n-   |  _______________________________________^\n+   |  _________________________________^\n LL | |         game_loop(Arc::clone(&room_ref))\n    | |                               -------- `room_ref` is borrowed here\n LL | |     });"}, {"sha": "4c7b4fa41faea36ba109d7d9e4b1fde4cc1e0836", "filename": "src/test/ui/async-await/try-on-option-in-async.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.stderr?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -1,8 +1,7 @@\n error[E0277]: the `?` operator can only be used in an async block that returns `Result` or `Option` (or another type that implements `FromResidual`)\n   --> $DIR/try-on-option-in-async.rs:8:10\n    |\n-LL |       async {\n-   |  ___________-\n+LL | /     async {\n LL | |         let x: Option<u32> = None;\n LL | |         x?;\n    | |          ^ cannot use the `?` operator in an async block that returns `{integer}`"}, {"sha": "6f22d2c593a3b9da365d1a9a55dacb42901eacec", "filename": "src/test/ui/chalkify/bugs/async.stderr", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -1,39 +1,54 @@\n-error[E0277]: the trait bound `[static generator@$DIR/async.rs:7:29: 9:2]: Generator<ResumeTy>` is not satisfied\n+error[E0277]: `impl Future<Output = u32>` is not a future\n   --> $DIR/async.rs:7:29\n    |\n LL |   async fn foo(x: u32) -> u32 {\n-   |  _____________________________^\n+   |  _____________________________-\n LL | |     x\n LL | | }\n-   | |_^ the trait `Generator<ResumeTy>` is not implemented for `[static generator@$DIR/async.rs:7:29: 9:2]`\n+   | | ^\n+   | | |\n+   | |_`impl Future<Output = u32>` is not a future\n+   |   required by a bound introduced by this call\n    |\n-note: required by a bound in `std::future::from_generator`\n+   = help: the trait `Future` is not implemented for `impl Future<Output = u32>`\n+   = note: impl Future<Output = u32> must be a future or must implement `IntoFuture` to be awaited\n+note: required by a bound in `identity_future`\n   --> $SRC_DIR/core/src/future/mod.rs:LL:COL\n    |\n-LL |     T: Generator<ResumeTy, Yield = ()>,\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `std::future::from_generator`\n+LL | pub const fn identity_future<O, Fut: Future<Output = O>>(f: Fut) -> Fut {\n+   |                                      ^^^^^^^^^^^^^^^^^^ required by this bound in `identity_future`\n \n-error[E0280]: the requirement `<[static generator@$DIR/async.rs:7:29: 9:2] as Generator<ResumeTy>>::Yield == ()` is not satisfied\n+error[E0277]: the size for values of type `<impl Future<Output = u32> as Future>::Output` cannot be known at compilation time\n   --> $DIR/async.rs:7:29\n    |\n LL |   async fn foo(x: u32) -> u32 {\n    |  _____________________________^\n LL | |     x\n LL | | }\n-   | |_^\n+   | |_^ doesn't have a size known at compile-time\n    |\n-note: required by a bound in `std::future::from_generator`\n+   = help: the trait `Sized` is not implemented for `<impl Future<Output = u32> as Future>::Output`\n+note: required by a bound in `identity_future`\n   --> $SRC_DIR/core/src/future/mod.rs:LL:COL\n    |\n-LL |     T: Generator<ResumeTy, Yield = ()>,\n-   |                            ^^^^^^^^^^ required by this bound in `std::future::from_generator`\n+LL | pub const fn identity_future<O, Fut: Future<Output = O>>(f: Fut) -> Fut {\n+   |                              ^ required by this bound in `identity_future`\n+\n+error[E0277]: `impl Future<Output = u32>` is not a future\n+  --> $DIR/async.rs:7:25\n+   |\n+LL | async fn foo(x: u32) -> u32 {\n+   |                         ^^^ `impl Future<Output = u32>` is not a future\n+   |\n+   = help: the trait `Future` is not implemented for `impl Future<Output = u32>`\n+   = note: impl Future<Output = u32> must be a future or must implement `IntoFuture` to be awaited\n \n error[E0280]: the requirement `<impl Future<Output = u32> as Future>::Output == u32` is not satisfied\n   --> $DIR/async.rs:7:25\n    |\n LL | async fn foo(x: u32) -> u32 {\n    |                         ^^^\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "f02a93ed41b9a03e9b192d80e47c3221850abee3", "filename": "src/test/ui/lazy-type-alias-impl-trait/freeze_cycle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Ffreeze_cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Ffreeze_cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Ffreeze_cycle.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -1,6 +1,6 @@\n // check-pass\n \n-#![feature(gen_future, generator_trait, negative_impls)]\n+#![feature(generator_trait, negative_impls)]\n \n use std::ops::{Generator, GeneratorState};\n use std::task::{Poll, Context};"}, {"sha": "918d37e65594d8f4fb29cff8c574080030fb3914", "filename": "src/test/ui/suggestions/expected-boxed-future-isnt-pinned.stderr", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -78,20 +78,21 @@ LL | impl<P: Deref<Target: Unpin>> Pin<P> {\n error[E0308]: mismatched types\n   --> $DIR/expected-boxed-future-isnt-pinned.rs:28:5\n    |\n-LL |   fn zap() -> BoxFuture<'static, i32> {\n-   |               ----------------------- expected `Pin<Box<(dyn Future<Output = i32> + Send + 'static)>>` because of return type\n LL | /     async {\n LL | |         42\n LL | |     }\n-   | |_____^ expected struct `Pin`, found opaque type\n-   |\n-  ::: $SRC_DIR/core/src/future/mod.rs:LL:COL\n-   |\n-LL |   pub const fn from_generator<T>(gen: T) -> impl Future<Output = T::Return>\n-   |                                             ------------------------------- the found opaque type\n-   |\n-   = note:   expected struct `Pin<Box<(dyn Future<Output = i32> + Send + 'static)>>`\n-           found opaque type `impl Future<Output = {integer}>`\n+   | |     ^\n+   | |     |\n+   | |_____expected struct `Pin`, found `async` block\n+   |       arguments to this function are incorrect\n+   |\n+   = note:     expected struct `Pin<Box<dyn Future<Output = i32> + Send>>`\n+           found `async` block `impl Future<Output = {integer}>`\n+note: function defined here\n+  --> $SRC_DIR/core/src/future/mod.rs:LL:COL\n+   |\n+LL | pub const fn identity_future<O, Fut: Future<Output = O>>(f: Fut) -> Fut {\n+   |              ^^^^^^^^^^^^^^^\n help: you need to pin and box this expression\n    |\n LL ~     Box::pin(async {"}, {"sha": "ae5f9424b2323b015f34a85547c880b5b387bb49", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -427,9 +427,7 @@ fn lint_for_missing_headers(\n                 let body = cx.tcx.hir().body(body_id);\n                 let ret_ty = typeck.expr_ty(body.value);\n                 if implements_trait(cx, ret_ty, future, &[]);\n-                if let ty::Opaque(_, subs) = ret_ty.kind();\n-                if let Some(gen) = subs.types().next();\n-                if let ty::Generator(_, subs, _) = gen.kind();\n+                if let ty::Generator(_, subs, _) = ret_ty.kind();\n                 if is_type_diagnostic_item(cx, subs.as_generator().return_ty(), sym::Result);\n                 then {\n                     span_lint("}, {"sha": "6a98df4991259a34e7d99424ab988314c58440c8", "filename": "src/tools/clippy/clippy_lints/src/manual_async_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -177,7 +177,7 @@ fn desugared_async_block<'tcx>(cx: &LateContext<'tcx>, block: &'tcx Block<'tcx>)\n         if let Some(args) = cx\n             .tcx\n             .lang_items()\n-            .from_generator_fn()\n+            .identity_future_fn()\n             .and_then(|def_id| match_function_call_with_def_id(cx, block_expr, def_id));\n         if args.len() == 1;\n         if let Expr {"}, {"sha": "c6acf24c21ecf73cd57470a72d0f1a82a3c602a6", "filename": "src/tools/clippy/tests/ui/author/blocks.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Fblocks.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9f36f988ad873f5d34cd9c08e4903c597ffc9532/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Fblocks.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Fblocks.stdout?ref=9f36f988ad873f5d34cd9c08e4903c597ffc9532", "patch": "@@ -45,7 +45,7 @@ if let ExprKind::Closure(CaptureBy::Value, fn_decl, body_id, _, None) = expr.kin\n     && expr1 = &cx.tcx.hir().body(body_id).value\n     && let ExprKind::Call(func, args) = expr1.kind\n     && let ExprKind::Path(ref qpath) = func.kind\n-    && matches!(qpath, QPath::LangItem(LangItem::FromGenerator, _))\n+    && matches!(qpath, QPath::LangItem(LangItem::IdentityFuture, _))\n     && args.len() == 1\n     && let ExprKind::Closure(CaptureBy::Value, fn_decl1, body_id1, _, Some(Movability::Static)) = args[0].kind\n     && let FnRetTy::DefaultReturn(_) = fn_decl1.output"}]}