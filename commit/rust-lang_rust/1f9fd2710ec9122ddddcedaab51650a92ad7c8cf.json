{"sha": "1f9fd2710ec9122ddddcedaab51650a92ad7c8cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmOWZkMjcxMGVjOTEyMmRkZGRjZWRhYWI1MTY1MGE5MmFkN2M4Y2Y=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-06-29T19:00:15Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-06-29T19:00:15Z"}, "message": "Initial stab at lowering mutable and exterior into the type system.", "tree": {"sha": "5e8505579d43bb5ad4c95187f6207820a950b37c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e8505579d43bb5ad4c95187f6207820a950b37c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf", "html_url": "https://github.com/rust-lang/rust/commit/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffdcd67c2522aaa369149024074ec884471399d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffdcd67c2522aaa369149024074ec884471399d2", "html_url": "https://github.com/rust-lang/rust/commit/ffdcd67c2522aaa369149024074ec884471399d2"}], "stats": {"total": 1841, "additions": 937, "deletions": 904}, "files": [{"sha": "30fce0cd2d71da62432f5747c7727a16bc720889", "filename": "src/boot/driver/llvm/glue.ml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fdriver%2Fllvm%2Fglue.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fdriver%2Fllvm%2Fglue.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Fllvm%2Fglue.ml?ref=1f9fd2710ec9122ddddcedaab51650a92ad7c8cf", "patch": "@@ -16,8 +16,8 @@ let alt_pipeline sess sem_cx crate =\n     [|\n       Resolve.process_crate;\n       Type.process_crate;\n-      Effect.process_crate;\n       Typestate.process_crate;\n+      Effect.process_crate;\n       Loop.process_crate;\n       Alias.process_crate;\n       Dead.process_crate;"}, {"sha": "5655604d3f267129eb740018931f7127665879fc", "filename": "src/boot/driver/main.ml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fdriver%2Fmain.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fdriver%2Fmain.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Fmain.ml?ref=1f9fd2710ec9122ddddcedaab51650a92ad7c8cf", "patch": "@@ -316,8 +316,8 @@ let main_pipeline _ =\n          exit_if_failed ())\n       [| Resolve.process_crate;\n          Type.process_crate;\n-         Effect.process_crate;\n          Typestate.process_crate;\n+         Effect.process_crate;\n          Loop.process_crate;\n          Alias.process_crate;\n          Dead.process_crate;"}, {"sha": "8b1ce71fb34e4cd93b6e9e04540c038bae162757", "filename": "src/boot/fe/ast.ml", "status": "modified", "additions": 60, "deletions": 41, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Ffe%2Fast.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Ffe%2Fast.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fast.ml?ref=1f9fd2710ec9122ddddcedaab51650a92ad7c8cf", "patch": "@@ -9,11 +9,6 @@\n open Common;;\n open Fmt;;\n \n-(*\n- * Slot names are given by a dot-separated path within the current\n- * module namespace.\n- *)\n-\n type ident = string\n ;;\n \n@@ -70,11 +65,11 @@ and ty =\n   | TY_str\n \n   | TY_tup of ty_tup\n-  | TY_vec of slot\n+  | TY_vec of ty\n   | TY_rec of ty_rec\n \n   (*\n-   * Note that ty_idx is only valid inside a slot of a ty_iso group, not\n+   * Note that ty_idx is only valid inside a ty of a ty_iso group, not\n    * in a general type term.\n    *)\n   | TY_tag of ty_tag\n@@ -93,18 +88,25 @@ and ty =\n   | TY_named of name\n   | TY_type\n \n+  | TY_exterior of ty\n+  | TY_mutable of ty\n+\n   | TY_constrained of (ty * constrs)\n \n+(*\n+ * FIXME: this should be cleaned up to be a different\n+ * type definition. Only args can be by-ref, only locals\n+ * can be auto. The structure here is historical.\n+ *)\n+\n and mode =\n-    MODE_exterior\n   | MODE_interior\n   | MODE_alias\n \n and slot = { slot_mode: mode;\n-             slot_mutable: bool;\n              slot_ty: ty option; }\n \n-and ty_tup = slot array\n+and ty_tup = ty array\n \n (* In closed type terms a constraint may refer to components of the term by\n  * anchoring off the \"formal symbol\" '*', which represents \"the term this\n@@ -147,7 +149,7 @@ and constr =\n \n and constrs = constr array\n \n-and ty_rec = (ident * slot) array\n+and ty_rec = (ident * ty) array\n \n (* ty_tag is a sum type.\n  *\n@@ -185,20 +187,21 @@ and ty_obj = (effect * ((ident,ty_fn) Hashtbl.t))\n \n and check_calls = (lval * (atom array)) array\n \n-and rec_input = (ident * mode * bool * atom)\n+and rec_input = (ident * atom)\n \n-and tup_input = (mode * bool * atom)\n+and tup_input = atom\n \n and stmt' =\n \n   (* lval-assigning stmts. *)\n     STMT_spawn of (lval * domain * lval * (atom array))\n   | STMT_init_rec of (lval * (rec_input array) * lval option)\n   | STMT_init_tup of (lval * (tup_input array))\n-  | STMT_init_vec of (lval * slot * (atom array))\n+  | STMT_init_vec of (lval * atom array)\n   | STMT_init_str of (lval * string)\n   | STMT_init_port of lval\n   | STMT_init_chan of (lval * (lval option))\n+  | STMT_init_exterior of (lval * atom)\n   | STMT_copy of (lval * expr)\n   | STMT_copy_binop of (lval * binop * atom)\n   | STMT_call of (lval * lval * (atom array))\n@@ -516,24 +519,36 @@ and fmt_name (ff:Format.formatter) (n:name) : unit =\n         fmt ff \".\";\n         fmt_name_component ff nc\n \n-and fmt_mutable (ff:Format.formatter) (m:bool) : unit =\n-  if m\n-  then fmt ff \"mutable \";\n-\n and fmt_mode (ff:Format.formatter) (m:mode) : unit =\n   match m with\n-      MODE_exterior -> fmt ff \"@@\"\n     | MODE_alias -> fmt ff \"&\"\n     | MODE_interior -> ()\n \n and fmt_slot (ff:Format.formatter) (s:slot) : unit =\n   match s.slot_ty with\n       None -> fmt ff \"auto\"\n     | Some t ->\n-        fmt_mutable ff s.slot_mutable;\n         fmt_mode ff s.slot_mode;\n         fmt_ty ff t\n \n+and fmt_tys\n+    (ff:Format.formatter)\n+    (tys:ty array)\n+    : unit =\n+  fmt_bracketed_arr_sep \"(\" \")\" \",\" fmt_ty ff tys\n+\n+and fmt_ident_tys\n+    (ff:Format.formatter)\n+    (entries:(ident * ty) array)\n+    : unit =\n+  fmt_bracketed_arr_sep \"(\" \")\" \",\"\n+    (fun ff (ident, ty) ->\n+       fmt_ty ff ty;\n+       fmt ff \" \";\n+       fmt_ident ff ident)\n+    ff\n+    entries\n+\n and fmt_slots\n     (ff:Format.formatter)\n     (slots:slot array)\n@@ -594,7 +609,7 @@ and fmt_tag (ff:Format.formatter) (ttag:ty_tag) : unit =\n            then first := false\n            else fmt ff \",@ \");\n           fmt_name ff name;\n-          fmt_slots ff ttup None\n+          fmt_tys ff ttup\n       end\n       ttag;\n     fmt ff \"@])@]\"\n@@ -623,19 +638,15 @@ and fmt_ty (ff:Format.formatter) (t:ty) : unit =\n   | TY_char -> fmt ff \"char\"\n   | TY_str -> fmt ff \"str\"\n \n-  | TY_tup slots -> (fmt ff \"tup\"; fmt_slots ff slots None)\n-  | TY_vec s -> (fmt ff \"vec[\"; fmt_slot ff s; fmt ff \"]\")\n+  | TY_tup tys -> (fmt ff \"tup\"; fmt_tys ff tys)\n+  | TY_vec t -> (fmt ff \"vec[\"; fmt_ty ff t; fmt ff \"]\")\n   | TY_chan t -> (fmt ff \"chan[\"; fmt_ty ff t; fmt ff \"]\")\n   | TY_port t -> (fmt ff \"port[\"; fmt_ty ff t; fmt ff \"]\")\n \n-  | TY_rec slots ->\n-      let (idents, slots) =\n-        let (idents, slots) = List.split (Array.to_list slots) in\n-          (Array.of_list idents, Array.of_list slots)\n-      in\n-        fmt ff \"@[rec\";\n-        fmt_slots ff slots (Some idents);\n-        fmt ff \"@]\"\n+  | TY_rec entries ->\n+      fmt ff \"@[rec\";\n+      fmt_ident_tys ff entries;\n+      fmt ff \"@]\"\n \n   | TY_param (i, e) -> (fmt_effect ff e;\n                         if e <> PURE then fmt ff \" \";\n@@ -644,6 +655,14 @@ and fmt_ty (ff:Format.formatter) (t:ty) : unit =\n   | TY_named n -> fmt_name ff n\n   | TY_type -> fmt ff \"type\"\n \n+  | TY_exterior t ->\n+      fmt ff \"@@\";\n+      fmt_ty ff t\n+\n+  | TY_mutable t ->\n+      fmt ff \"mutable \";\n+      fmt_ty ff t\n+\n   | TY_fn tfn -> fmt_ty_fn ff None tfn\n   | TY_task -> fmt ff \"task\"\n   | TY_tag ttag -> fmt_tag ff ttag\n@@ -964,7 +983,7 @@ and fmt_stmt_body (ff:Format.formatter) (s:stmt) : unit =\n           fmt_lval ff lv;\n           fmt ff \" \";\n           fmt_binop ff binop;\n-          fmt ff \"=\";\n+          fmt ff \"= \";\n           fmt_atom ff at;\n           fmt ff \";\"\n \n@@ -999,11 +1018,9 @@ and fmt_stmt_body (ff:Format.formatter) (s:stmt) : unit =\n           do\n             if i != 0\n             then fmt ff \", \";\n-            let (ident, mode, mut, atom) = entries.(i) in\n+            let (ident, atom) = entries.(i) in\n               fmt_ident ff ident;\n               fmt ff \" = \";\n-              fmt_mutable ff mut;\n-              fmt_mode ff mode;\n               fmt_atom ff atom;\n           done;\n           begin\n@@ -1015,7 +1032,7 @@ and fmt_stmt_body (ff:Format.formatter) (s:stmt) : unit =\n           end;\n           fmt ff \");\"\n \n-      | STMT_init_vec (dst, _, atoms) ->\n+      | STMT_init_vec (dst, atoms) ->\n           fmt_lval ff dst;\n           fmt ff \" = vec(\";\n           for i = 0 to (Array.length atoms) - 1\n@@ -1033,10 +1050,7 @@ and fmt_stmt_body (ff:Format.formatter) (s:stmt) : unit =\n           do\n             if i != 0\n             then fmt ff \", \";\n-            let (mode, mut, atom) = entries.(i) in\n-              fmt_mutable ff mut;\n-              fmt_mode ff mode;\n-              fmt_atom ff atom;\n+            fmt_atom ff entries.(i);\n           done;\n           fmt ff \");\";\n \n@@ -1153,6 +1167,12 @@ and fmt_stmt_body (ff:Format.formatter) (s:stmt) : unit =\n           fmt_lval ff t;\n           fmt ff \";\"\n \n+      | STMT_init_exterior (lv, at) ->\n+          fmt_lval ff lv;\n+          fmt ff \" = @\";\n+          fmt_atom ff at;\n+          fmt ff \";\"\n+\n       | STMT_alt_tag _ -> fmt ff \"?stmt_alt_tag?\"\n       | STMT_alt_type _ -> fmt ff \"?stmt_alt_type?\"\n       | STMT_alt_port _ -> fmt ff \"?stmt_alt_port?\"\n@@ -1321,7 +1341,6 @@ let sprintf_lval_component = sprintf_fmt fmt_lval_component;;\n let sprintf_atom = sprintf_fmt fmt_atom;;\n let sprintf_slot = sprintf_fmt fmt_slot;;\n let sprintf_slot_key = sprintf_fmt fmt_slot_key;;\n-let sprintf_mutable = sprintf_fmt fmt_mutable;;\n let sprintf_ty = sprintf_fmt fmt_ty;;\n let sprintf_effect = sprintf_fmt fmt_effect;;\n let sprintf_tag = sprintf_fmt fmt_tag;;"}, {"sha": "5c0a7c6560805627da73a70e27e57ead2979eb5a", "filename": "src/boot/fe/item.ml", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Ffe%2Fitem.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Ffe%2Fitem.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fitem.ml?ref=1f9fd2710ec9122ddddcedaab51650a92ad7c8cf", "patch": "@@ -128,6 +128,13 @@ and parse_auto_slot_and_init\n and parse_stmts (ps:pstate) : Ast.stmt array =\n   let apos = lexpos ps in\n \n+  let ensure_mutable slot =\n+    match slot.Ast.slot_ty with\n+        None -> slot\n+      | Some (Ast.TY_mutable _) -> slot\n+      | Some t -> { slot with Ast.slot_ty = Some (Ast.TY_mutable t) }\n+  in\n+\n   let rec name_to_lval (apos:pos) (bpos:pos) (name:Ast.name)\n       : Ast.lval =\n     match name with\n@@ -236,7 +243,6 @@ and parse_stmts (ps:pstate) : Ast.stmt array =\n                                   Ast.NAME_base (Ast.BASE_ident ident) ->\n                                     let slot =\n                                       { Ast.slot_mode = Ast.MODE_interior;\n-                                        Ast.slot_mutable = false;\n                                         Ast.slot_ty = None }\n                                     in\n                                       Ast.PAT_slot\n@@ -456,7 +462,7 @@ and parse_stmts (ps:pstate) : Ast.stmt array =\n           bump ps;\n           let (stmts, slot, ident) =\n             ctxt \"stmt slot\" parse_slot_and_ident_and_init ps in\n-          let slot = Pexp.apply_mutability slot true in\n+          let slot = ensure_mutable slot in\n           let bpos = lexpos ps in\n           let decl = Ast.DECL_slot (Ast.KEY_ident ident,\n                                     (span ps apos bpos slot))\n@@ -467,7 +473,7 @@ and parse_stmts (ps:pstate) : Ast.stmt array =\n           bump ps;\n           let (stmts, slot, ident) =\n             ctxt \"stmt slot\" parse_auto_slot_and_init ps in\n-          let slot = Pexp.apply_mutability slot true in\n+          let slot = ensure_mutable slot in\n           let bpos = lexpos ps in\n           let decl = Ast.DECL_slot (Ast.KEY_ident ident,\n                                     (span ps apos bpos slot))\n@@ -979,7 +985,9 @@ and expand_tags\n                            (ps, \"unexpected name type while expanding tag\"))\n             in\n             let header =\n-              Array.map (fun slot -> (clone_span ps item slot)) tup\n+              Array.map (fun ty -> (clone_span ps item\n+                                      { Ast.slot_mode = Ast.MODE_alias;\n+                                        Ast.slot_ty = Some ty})) tup\n             in\n             let tag_item' = Ast.MOD_ITEM_tag (header, ttag, id) in\n             let cloned_params ="}, {"sha": "97cf898533bb5102752128aede3b8d2389e1cfae", "filename": "src/boot/fe/parser.ml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Ffe%2Fparser.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Ffe%2Fparser.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fparser.ml?ref=1f9fd2710ec9122ddddcedaab51650a92ad7c8cf", "patch": "@@ -181,13 +181,11 @@ let err (str:string) (ps:pstate) =\n \n let (slot_nil:Ast.slot) =\n   { Ast.slot_mode = Ast.MODE_interior;\n-    Ast.slot_mutable = false;\n     Ast.slot_ty = Some Ast.TY_nil }\n ;;\n \n let (slot_auto:Ast.slot) =\n   { Ast.slot_mode = Ast.MODE_interior;\n-    Ast.slot_mutable = true;\n     Ast.slot_ty = None }\n ;;\n "}, {"sha": "25352e5c752075af469ed8d0507503b58ed00c2b", "filename": "src/boot/fe/pexp.ml", "status": "modified", "additions": 47, "deletions": 68, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Ffe%2Fpexp.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Ffe%2Fpexp.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fpexp.ml?ref=1f9fd2710ec9122ddddcedaab51650a92ad7c8cf", "patch": "@@ -22,7 +22,7 @@ type pexp' =\n   | PEXP_bind of (pexp * pexp option array)\n   | PEXP_rec of ((Ast.ident * pexp) array * pexp option)\n   | PEXP_tup of (pexp array)\n-  | PEXP_vec of (Ast.slot * (pexp array))\n+  | PEXP_vec of (pexp array)\n   | PEXP_port\n   | PEXP_chan of (pexp option)\n   | PEXP_binop of (Ast.binop * pexp * pexp)\n@@ -261,19 +261,18 @@ and parse_atomic_ty (ps:pstate) : Ast.ty =\n \n     | VEC ->\n         bump ps;\n-        Ast.TY_vec (bracketed LBRACKET RBRACKET (parse_slot false) ps)\n+        Ast.TY_vec (bracketed LBRACKET RBRACKET parse_ty ps)\n \n     | IDENT _ -> Ast.TY_named (parse_name ps)\n \n-\n     | TAG ->\n         bump ps;\n         let htab = Hashtbl.create 4 in\n         let parse_tag_entry ps =\n           let ident = parse_ident ps in\n           let tup =\n             match peek ps with\n-                LPAREN -> paren_comma_list (parse_slot false) ps\n+                LPAREN -> paren_comma_list parse_ty ps\n               | _ -> raise (err \"tag variant missing argument list\" ps)\n           in\n             htab_put htab (Ast.NAME_base (Ast.BASE_ident ident)) tup\n@@ -287,9 +286,8 @@ and parse_atomic_ty (ps:pstate) : Ast.ty =\n     | REC ->\n         bump ps;\n         let parse_rec_entry ps =\n-          let mut = parse_mutability ps in\n-          let (slot, ident) = parse_slot_and_ident false ps in\n-            (ident, apply_mutability slot mut)\n+          let (ty, ident) = parse_ty_and_ident ps in\n+            (ident, ty)\n         in\n         let entries = paren_comma_list parse_rec_entry ps in\n         let labels = Array.map (fun (l, _) -> l) entries in\n@@ -300,8 +298,8 @@ and parse_atomic_ty (ps:pstate) : Ast.ty =\n \n     | TUP ->\n         bump ps;\n-        let slots = paren_comma_list (parse_slot false) ps in\n-          Ast.TY_tup slots\n+        let tys = paren_comma_list parse_ty ps in\n+          Ast.TY_tup tys\n \n     | MACH m ->\n         bump ps;\n@@ -333,6 +331,14 @@ and parse_atomic_ty (ps:pstate) : Ast.ty =\n               | _ -> raise (unexpected ps)\n           end\n \n+    | AT ->\n+        bump ps;\n+        Ast.TY_exterior (parse_ty ps)\n+\n+    | MUTABLE ->\n+        bump ps;\n+        Ast.TY_mutable (parse_ty ps)\n+\n     | LPAREN ->\n         begin\n           bump ps;\n@@ -356,21 +362,15 @@ and flag (ps:pstate) (tok:token) : bool =\n and parse_mutability (ps:pstate) : bool =\n   flag ps MUTABLE\n \n-and apply_mutability (slot:Ast.slot) (mut:bool) : Ast.slot =\n-  { slot with Ast.slot_mutable = mut }\n-\n and parse_slot (aliases_ok:bool) (ps:pstate) : Ast.slot =\n-  let mut = parse_mutability ps in\n   let mode =\n   match (peek ps, aliases_ok) with\n-      (AT, _) -> bump ps; Ast.MODE_exterior\n-    | (AND, true) -> bump ps; Ast.MODE_alias\n+      (AND, true) -> bump ps; Ast.MODE_alias\n     | (AND, false) -> raise (err \"alias slot in prohibited context\" ps)\n     | _ -> Ast.MODE_interior\n   in\n   let ty = parse_ty ps in\n     { Ast.slot_mode = mode;\n-      Ast.slot_mutable = mut;\n       Ast.slot_ty = Some ty }\n \n and parse_slot_and_ident\n@@ -381,6 +381,13 @@ and parse_slot_and_ident\n   let ident = ctxt \"slot and ident: ident\" parse_ident ps in\n     (slot, ident)\n \n+and parse_ty_and_ident\n+    (ps:pstate)\n+    : (Ast.ty * Ast.ident) =\n+  let ty = ctxt \"ty and ident: ty\" parse_ty ps in\n+  let ident = ctxt \"ty and ident: ident\" parse_ident ps in\n+    (ty, ident)\n+\n and parse_slot_and_optional_ignored_ident\n     (aliases_ok:bool)\n     (ps:pstate)\n@@ -494,16 +501,9 @@ and parse_bottom_pexp (ps:pstate) : pexp =\n     | VEC ->\n         bump ps;\n         begin\n-          let slot =\n-            match peek ps with\n-                LBRACKET -> bracketed LBRACKET RBRACKET (parse_slot false) ps\n-              | _ -> { Ast.slot_mode = Ast.MODE_interior;\n-                       Ast.slot_mutable = false;\n-                       Ast.slot_ty = None }\n-          in\n           let pexps = ctxt \"vec pexp: exprs\" parse_pexp_list ps in\n           let bpos = lexpos ps in\n-            span ps apos bpos (PEXP_vec (slot, pexps))\n+            span ps apos bpos (PEXP_vec pexps)\n         end\n \n \n@@ -1088,7 +1088,9 @@ and desugar_expr_atom\n       | PEXP_call _\n       | PEXP_bind _\n       | PEXP_spawn _\n-      | PEXP_custom _ ->\n+      | PEXP_custom _\n+      | PEXP_exterior _\n+      | PEXP_mutable _ ->\n           let (_, tmp, decl_stmt) = build_tmp ps slot_auto apos bpos in\n           let stmts = desugar_expr_init ps tmp pexp in\n             (Array.append [| decl_stmt |] stmts,\n@@ -1101,31 +1103,6 @@ and desugar_expr_atom\n           let (stmts, lval) = desugar_lval ps pexp in\n             (stmts, Ast.ATOM_lval lval)\n \n-      | PEXP_exterior _ ->\n-          raise (err \"exterior symbol in atom context\" ps)\n-\n-      | PEXP_mutable _ ->\n-          raise (err \"mutable keyword in atom context\" ps)\n-\n-\n-and desugar_expr_mode_mut_atom\n-    (ps:pstate)\n-    (pexp:pexp)\n-    : (Ast.stmt array * (Ast.mode * bool * Ast.atom)) =\n-  let desugar_inner mode mut e =\n-    let (stmts, atom) = desugar_expr_atom ps e in\n-      (stmts, (mode, mut, atom))\n-  in\n-    match pexp.node with\n-        PEXP_mutable {node=(PEXP_exterior e); id=_} ->\n-          desugar_inner Ast.MODE_exterior true e\n-      | PEXP_exterior e ->\n-          desugar_inner Ast.MODE_exterior false e\n-      | PEXP_mutable e ->\n-          desugar_inner Ast.MODE_interior true e\n-      | _ ->\n-          desugar_inner Ast.MODE_interior false pexp\n-\n and desugar_expr_atoms\n     (ps:pstate)\n     (pexps:pexp array)\n@@ -1138,12 +1115,6 @@ and desugar_opt_expr_atoms\n     : (Ast.stmt array * Ast.atom option array) =\n   arj1st (Array.map (desugar_opt_expr_atom ps) pexps)\n \n-and desugar_expr_mode_mut_atoms\n-    (ps:pstate)\n-    (pexps:pexp array)\n-    : (Ast.stmt array * (Ast.mode * bool * Ast.atom) array) =\n-  arj1st (Array.map (desugar_expr_mode_mut_atom ps) pexps)\n-\n and desugar_expr_init\n     (ps:pstate)\n     (dst_lval:Ast.lval)\n@@ -1253,10 +1224,10 @@ and desugar_expr_init\n                 Array.map\n                   begin\n                     fun (ident, pexp) ->\n-                      let (stmts, (mode, mut, atom)) =\n-                        desugar_expr_mode_mut_atom ps pexp\n+                      let (stmts, atom) =\n+                        desugar_expr_atom ps pexp\n                       in\n-                        (stmts, (ident, mode, mut, atom))\n+                        (stmts, (ident, atom))\n                   end\n                   args\n               end\n@@ -1278,19 +1249,19 @@ and desugar_expr_init\n             end\n \n       | PEXP_tup args ->\n-          let (arg_stmts, arg_mode_atoms) =\n-            desugar_expr_mode_mut_atoms ps args\n+          let (arg_stmts, arg_atoms) =\n+            desugar_expr_atoms ps args\n           in\n-          let stmt = ss (Ast.STMT_init_tup (dst_lval, arg_mode_atoms)) in\n+          let stmt = ss (Ast.STMT_init_tup (dst_lval, arg_atoms)) in\n             aa arg_stmts [| stmt |]\n \n       | PEXP_str s ->\n           let stmt = ss (Ast.STMT_init_str (dst_lval, s)) in\n             [| stmt |]\n \n-      | PEXP_vec (slot, args) ->\n+      | PEXP_vec args ->\n           let (arg_stmts, arg_atoms) = desugar_expr_atoms ps args in\n-          let stmt = ss (Ast.STMT_init_vec (dst_lval, slot, arg_atoms)) in\n+          let stmt = ss (Ast.STMT_init_vec (dst_lval, arg_atoms)) in\n             aa arg_stmts [| stmt |]\n \n       | PEXP_port ->\n@@ -1315,11 +1286,19 @@ and desugar_expr_init\n           in\n             aa port_stmts [| chan_stmt |]\n \n-      | PEXP_exterior _ ->\n-          raise (err \"exterior symbol in initialiser context\" ps)\n+      | PEXP_exterior arg ->\n+          let (arg_stmts, arg_mode_atom) =\n+            desugar_expr_atom ps arg\n+          in\n+          let stmt = ss (Ast.STMT_init_exterior (dst_lval, arg_mode_atom)) in\n+            aa arg_stmts [| stmt |]\n \n-      | PEXP_mutable _ ->\n-          raise (err \"mutable keyword in initialiser context\" ps)\n+      | PEXP_mutable arg ->\n+          (* Initializing a local from a \"mutable\" atom is the same as\n+           * initializing it from an immutable one; all locals are mutable\n+           * anyways. So this is just a fall-through.\n+           *)\n+          desugar_expr_init ps dst_lval arg\n \n       | PEXP_custom (n, a, b) ->\n           let (arg_stmts, args) = desugar_expr_atoms ps a in"}, {"sha": "b603e77919ed2d9e949ef06d6333f6edc064acad", "filename": "src/boot/me/alias.ml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fme%2Falias.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fme%2Falias.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Falias.ml?ref=1f9fd2710ec9122ddddcedaab51650a92ad7c8cf", "patch": "@@ -67,7 +67,7 @@ let alias_analysis_visitor\n           | Ast.STMT_recv (dst, _) -> alias dst\n           | Ast.STMT_init_port (dst) -> alias dst\n           | Ast.STMT_init_chan (dst, _) -> alias dst\n-          | Ast.STMT_init_vec (dst, _, _) -> alias dst\n+          | Ast.STMT_init_vec (dst, _) -> alias dst\n           | Ast.STMT_init_str (dst, _) -> alias dst\n           | Ast.STMT_for_each sfe ->\n               let (slot, _) = sfe.Ast.for_each_slot in"}, {"sha": "410ff402ca3875b2cb5a0afd1d5132f7bd4168c4", "filename": "src/boot/me/dwarf.ml", "status": "modified", "additions": 90, "deletions": 84, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fme%2Fdwarf.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fme%2Fdwarf.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fdwarf.ml?ref=1f9fd2710ec9122ddddcedaab51650a92ad7c8cf", "patch": "@@ -1307,56 +1307,65 @@ let (abbrev_alias_slot:abbrev) =\n   (DW_TAG_reference_type, DW_CHILDREN_no,\n    [|\n      (DW_AT_type, DW_FORM_ref_addr);\n-     (DW_AT_mutable, DW_FORM_flag);\n    |])\n ;;\n \n-let (abbrev_exterior_slot:abbrev) =\n-  (DW_TAG_reference_type, DW_CHILDREN_no,\n+(* FIXME: Perverse, but given dwarf's vocabulary it seems at least plausible\n+ * that a \"mutable const type\" is a correct way of saying \"mutable\". Or else we\n+ * make up our own. Revisit perhaps.\n+ *)\n+let (abbrev_mutable_type:abbrev) =\n+  (DW_TAG_const_type, DW_CHILDREN_no,\n    [|\n      (DW_AT_type, DW_FORM_ref_addr);\n      (DW_AT_mutable, DW_FORM_flag);\n+   |])\n+;;\n+\n+let (abbrev_exterior_type:abbrev) =\n+  (DW_TAG_pointer_type, DW_CHILDREN_no,\n+   [|\n+     (DW_AT_type, DW_FORM_ref_addr);\n      (DW_AT_data_location, DW_FORM_block1);\n    |])\n ;;\n \n let (abbrev_struct_type:abbrev) =\n-    (DW_TAG_structure_type, DW_CHILDREN_yes,\n-     [|\n-       (DW_AT_byte_size, DW_FORM_block4)\n-     |])\n+  (DW_TAG_structure_type, DW_CHILDREN_yes,\n+   [|\n+     (DW_AT_byte_size, DW_FORM_block4)\n+   |])\n ;;\n \n let (abbrev_struct_type_member:abbrev) =\n-    (DW_TAG_member, DW_CHILDREN_no,\n-     [|\n-       (DW_AT_name, DW_FORM_string);\n-       (DW_AT_type, DW_FORM_ref_addr);\n-       (DW_AT_mutable, DW_FORM_flag);\n-       (DW_AT_data_member_location, DW_FORM_block4);\n-       (DW_AT_byte_size, DW_FORM_block4)\n-     |])\n+  (DW_TAG_member, DW_CHILDREN_no,\n+   [|\n+     (DW_AT_name, DW_FORM_string);\n+     (DW_AT_type, DW_FORM_ref_addr);\n+     (DW_AT_data_member_location, DW_FORM_block4);\n+     (DW_AT_byte_size, DW_FORM_block4)\n+   |])\n ;;\n \n let (abbrev_variant_part:abbrev) =\n-    (DW_TAG_variant_part, DW_CHILDREN_yes,\n-     [|\n-       (DW_AT_discr, DW_FORM_ref_addr)\n-     |])\n+  (DW_TAG_variant_part, DW_CHILDREN_yes,\n+   [|\n+     (DW_AT_discr, DW_FORM_ref_addr)\n+   |])\n ;;\n \n \n let (abbrev_variant:abbrev) =\n-    (DW_TAG_variant, DW_CHILDREN_yes,\n-     [|\n-       (DW_AT_discr_value, DW_FORM_udata)\n-     |])\n+  (DW_TAG_variant, DW_CHILDREN_yes,\n+   [|\n+     (DW_AT_discr_value, DW_FORM_udata)\n+   |])\n ;;\n \n let (abbrev_subroutine_type:abbrev) =\n-    (DW_TAG_subroutine_type, DW_CHILDREN_yes,\n-     [|\n-       (DW_AT_type, DW_FORM_ref_addr); (* NB: output type. *)\n+  (DW_TAG_subroutine_type, DW_CHILDREN_yes,\n+   [|\n+     (DW_AT_type, DW_FORM_ref_addr); (* NB: output type. *)\n        (DW_AT_mutable, DW_FORM_flag);\n        (DW_AT_pure, DW_FORM_flag);\n        (DW_AT_rust_iterator, DW_FORM_flag);\n@@ -1541,42 +1550,15 @@ let dwarf_visitor\n       in\n \n         match slot.Ast.slot_mode with\n-            Ast.MODE_exterior ->\n-              let fix = new_fixup \"exterior DIE\" in\n-              let body_off =\n-                word_sz_int * Abi.exterior_rc_slot_field_body\n-              in\n-                emit_die (DEF (fix, SEQ [|\n-                                 uleb (get_abbrev_code abbrev_exterior_slot);\n-                                 (* DW_AT_type: DW_FORM_ref_addr *)\n-                                 (ref_type_die (slot_ty slot));\n-                                 (* DW_AT_mutable: DW_FORM_flag *)\n-                                 BYTE (if slot.Ast.slot_mutable\n-                                       then 1 else 0);\n-                                 (* DW_AT_data_location: DW_FORM_block1 *)\n-                                 (* This is a DWARF expression for moving\n-                                    from the address of an exterior\n-                                    allocation to the address of its\n-                                    body. *)\n-                                 dw_form_block1\n-                                   [| DW_OP_push_object_address;\n-                                      DW_OP_lit body_off;\n-                                      DW_OP_plus;\n-                                      DW_OP_deref |]\n-                               |]));\n-                ref_addr_for_fix fix\n-\n-          (* FIXME (issue #72): encode mutable-ness of interiors. *)\n-          | Ast.MODE_interior -> ref_type_die (slot_ty slot)\n+          | Ast.MODE_interior ->\n+              ref_type_die (slot_ty slot)\n \n           | Ast.MODE_alias ->\n               let fix = new_fixup \"alias DIE\" in\n                 emit_die (DEF (fix, SEQ [|\n                                  uleb (get_abbrev_code abbrev_alias_slot);\n                                  (* DW_AT_type: DW_FORM_ref_addr *)\n                                  (ref_type_die (slot_ty slot));\n-                                 (* DW_AT_mutable: DW_FORM_flag *)\n-                                 BYTE (if slot.Ast.slot_mutable then 1 else 0)\n                                |]));\n                 ref_addr_for_fix fix\n \n@@ -1708,15 +1690,13 @@ let dwarf_visitor\n           emit_die die;\n           Array.iteri\n             begin\n-              fun i (ident, slot) ->\n+              fun i (ident, ty) ->\n                 emit_die (SEQ [|\n                             uleb (get_abbrev_code abbrev_struct_type_member);\n                             (* DW_AT_name: DW_FORM_string *)\n                             ZSTRING ident;\n                             (* DW_AT_type: DW_FORM_ref_addr *)\n-                            (ref_slot_die slot);\n-                            (* DW_AT_mutable: DW_FORM_flag *)\n-                            BYTE (if slot.Ast.slot_mutable then 1 else 0);\n+                            (ref_type_die ty);\n                             (* DW_AT_data_member_location: DW_FORM_block4 *)\n                             size_block4\n                               (Il.get_element_offset word_bits rtys i)\n@@ -1904,10 +1884,6 @@ let dwarf_visitor\n         unspecified_ptr_with_ref rust_ty (ref_type_die ty)\n       in\n \n-      let unspecified_ptr_with_ref_slot rust_ty slot =\n-        unspecified_ptr_with_ref rust_ty (ref_slot_die slot)\n-      in\n-\n       let unspecified_ptr rust_ty =\n         unspecified_ptr_with_ref rust_ty (unspecified_anon_struct ())\n       in\n@@ -1974,9 +1950,7 @@ let dwarf_visitor\n                  (* DW_AT_name: DW_FORM_string *)\n                  ZSTRING \"tag\";\n                  (* DW_AT_type: DW_FORM_ref_addr *)\n-                 (ref_slot_die (interior_slot Ast.TY_uint));\n-                 (* DW_AT_mutable: DW_FORM_flag *)\n-                 BYTE 0;\n+                 (ref_type_die Ast.TY_uint);\n                  (* DW_AT_data_member_location: DW_FORM_block4 *)\n                  size_block4\n                    (Il.get_element_offset word_bits rtys 0)\n@@ -2038,6 +2012,41 @@ let dwarf_visitor\n         ref_addr_for_fix (Stack.top iso_stack).(i)\n       in\n \n+      let exterior_type t =\n+        let fix = new_fixup \"exterior DIE\" in\n+        let body_off =\n+          word_sz_int * Abi.exterior_rc_slot_field_body\n+        in\n+          emit_die (DEF (fix, SEQ [|\n+                           uleb (get_abbrev_code abbrev_exterior_type);\n+                           (* DW_AT_type: DW_FORM_ref_addr *)\n+                           (ref_type_die t);\n+                           (* DW_AT_data_location: DW_FORM_block1 *)\n+                           (* This is a DWARF expression for moving\n+                              from the address of an exterior\n+                              allocation to the address of its\n+                              body. *)\n+                           dw_form_block1\n+                             [| DW_OP_push_object_address;\n+                                DW_OP_lit body_off;\n+                                DW_OP_plus;\n+                                DW_OP_deref |]\n+                         |]));\n+          ref_addr_for_fix fix\n+      in\n+\n+      let mutable_type t =\n+        let fix = new_fixup \"mutable DIE\" in\n+          emit_die (DEF (fix, SEQ [|\n+                           uleb (get_abbrev_code abbrev_mutable_type);\n+                           (* DW_AT_type: DW_FORM_ref_addr *)\n+                           (ref_type_die t);\n+                           (* DW_AT_mutable: DW_FORM_flag *)\n+                           BYTE 1;\n+                         |]));\n+          ref_addr_for_fix fix\n+      in\n+\n         match ty with\n             Ast.TY_nil -> unspecified_struct DW_RUST_nil\n           | Ast.TY_bool -> base (\"bool\", DW_ATE_boolean, 1)\n@@ -2058,7 +2067,7 @@ let dwarf_visitor\n           | Ast.TY_tag ttag -> tag_type None ttag\n           | Ast.TY_iso tiso -> iso_type tiso\n           | Ast.TY_idx i -> idx_type i\n-          | Ast.TY_vec s -> unspecified_ptr_with_ref_slot DW_RUST_vec s\n+          | Ast.TY_vec t -> unspecified_ptr_with_ref_ty DW_RUST_vec t\n           | Ast.TY_chan t -> unspecified_ptr_with_ref_ty DW_RUST_chan t\n           | Ast.TY_port t -> unspecified_ptr_with_ref_ty DW_RUST_port t\n           | Ast.TY_task -> unspecified_ptr DW_RUST_task\n@@ -2067,6 +2076,8 @@ let dwarf_visitor\n           | Ast.TY_native i -> native_ptr_type i\n           | Ast.TY_param p -> rust_type_param p\n           | Ast.TY_obj ob -> obj_type ob\n+          | Ast.TY_mutable t -> mutable_type t\n+          | Ast.TY_exterior t -> exterior_type t\n           | _ ->\n               bug () \"unimplemented dwarf encoding for type %a\"\n                 Ast.sprintf_ty ty\n@@ -2893,7 +2904,7 @@ let rec extract_mod_items\n \n         | DW_TAG_pointer_type\n             when is_rust_type die DW_RUST_vec ->\n-            Ast.TY_vec (get_referenced_slot die)\n+            Ast.TY_vec (get_referenced_ty die)\n \n         | DW_TAG_pointer_type\n             when is_rust_type die DW_RUST_type_param ->\n@@ -2903,6 +2914,13 @@ let rec extract_mod_items\n             when is_rust_type die DW_RUST_native ->\n             Ast.TY_native (get_opaque_of (get_native_id die))\n \n+        | DW_TAG_pointer_type ->\n+            Ast.TY_exterior (get_referenced_ty die)\n+\n+        | DW_TAG_const_type\n+            when ((get_num die DW_AT_mutable) = 1) ->\n+            Ast.TY_mutable (get_referenced_ty die)\n+\n         | DW_TAG_string_type -> Ast.TY_str\n \n         | DW_TAG_base_type ->\n@@ -2953,13 +2971,13 @@ let rec extract_mod_items\n                 assert ((Array.length members) > 0);\n                 if is_num_idx (get_name members.(0))\n                 then\n-                  let slots = Array.map get_referenced_slot members in\n-                    Ast.TY_tup slots\n+                  let tys = Array.map get_referenced_ty members in\n+                    Ast.TY_tup tys\n                 else\n                   let entries =\n                     Array.map\n                       (fun member_die -> ((get_name member_die),\n-                                          (get_referenced_slot member_die)))\n+                                          (get_referenced_ty member_die)))\n                       members\n                   in\n                     Ast.TY_rec entries\n@@ -2989,23 +3007,11 @@ let rec extract_mod_items\n     match die.die_tag with\n         DW_TAG_reference_type ->\n           let ty = get_referenced_ty die in\n-          let mut = get_flag die DW_AT_mutable in\n-          let mode =\n-            (* Exterior slots have a 'data_location' attr. *)\n-            match atab_search die.die_attrs DW_AT_data_location with\n-                Some _ -> Ast.MODE_exterior\n-              | None -> Ast.MODE_alias\n-          in\n-            { Ast.slot_mode = mode;\n-              Ast.slot_mutable = mut;\n+            { Ast.slot_mode = Ast.MODE_alias;\n               Ast.slot_ty = Some ty }\n       | _ ->\n           let ty = get_ty die in\n-            (* FIXME (issue #28): encode mutability of interior slots\n-             * properly.\n-             *)\n             { Ast.slot_mode = Ast.MODE_interior;\n-              Ast.slot_mutable = false;\n               Ast.slot_ty = Some ty }\n \n   and get_referenced_ty die ="}, {"sha": "22edce7c7eb68d6723a73b7cfc8bb2e232c9da96", "filename": "src/boot/me/effect.ml", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fme%2Feffect.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fme%2Feffect.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Feffect.ml?ref=1f9fd2710ec9122ddddcedaab51650a92ad7c8cf", "patch": "@@ -33,23 +33,29 @@ let mutability_checking_visitor\n       | _ -> ()\n   in\n \n-  let check_write id dst =\n-    let dst_slot = lval_slot cx dst in\n-      if (dst_slot.Ast.slot_mutable or\n-            (Hashtbl.mem cx.ctxt_copy_stmt_is_init id))\n+  let check_write s dst =\n+    let dst_ty = lval_ty cx dst in\n+    let is_mutable =\n+      match dst_ty with\n+          Ast.TY_mutable _ -> true\n+        | _ -> false\n+    in\n+      if (is_mutable or (Hashtbl.mem cx.ctxt_copy_stmt_is_init s.id))\n       then ()\n-      else err (Some id) \"writing to non-mutable slot\"\n+      else err (Some s.id)\n+        \"writing to non-mutable slot of type %a in statement %a\"\n+        Ast.sprintf_ty dst_ty Ast.sprintf_stmt s\n   in\n     (* FIXME (issue #75): enforce the no-write-alias-to-immutable-slot\n      * rule.\n      *)\n   let visit_stmt_pre s =\n     begin\n       match s.node with\n-          Ast.STMT_copy (dst, _) -> check_write s.id dst\n-        | Ast.STMT_copy_binop (dst, _, _) -> check_write s.id dst\n-        | Ast.STMT_call (dst, _, _) -> check_write s.id dst\n-        | Ast.STMT_recv (dst, _) -> check_write s.id dst\n+          Ast.STMT_copy (dst, _) -> check_write s dst\n+        | Ast.STMT_copy_binop (dst, _, _) -> check_write s dst\n+        | Ast.STMT_call (dst, _, _) -> check_write s dst\n+        | Ast.STMT_recv (dst, _) -> check_write s dst\n         | _ -> ()\n     end;\n     inner.Walk.visit_stmt_pre s\n@@ -151,8 +157,7 @@ let function_effect_propagation_visitor\n             in\n               if lval_is_slot cx fn\n               then\n-                let t = lval_slot cx fn in\n-                  lower_to_callee_ty (slot_ty t)\n+                lower_to_callee_ty (lval_ty cx fn)\n               else\n                 begin\n                   let item = lval_item cx fn in"}, {"sha": "746f83bf6b647bef9d642e7c278770ed5ffb7d99", "filename": "src/boot/me/semant.ml", "status": "modified", "additions": 93, "deletions": 78, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=1f9fd2710ec9122ddddcedaab51650a92ad7c8cf", "patch": "@@ -582,15 +582,13 @@ let atoms_slots (cx:ctxt) (az:Ast.atom array) : node_id array =\n ;;\n \n let tup_inputs_slots (cx:ctxt) (az:Ast.tup_input array) : node_id array =\n-  Array.concat (List.map\n-                  (fun (_,_,a) -> atom_slots cx a)\n-                  (Array.to_list az))\n+  Array.concat (List.map (atom_slots cx) (Array.to_list az))\n ;;\n \n let rec_inputs_slots (cx:ctxt)\n     (inputs:Ast.rec_input array) : node_id array =\n   Array.concat (List.map\n-                  (fun (_, _, _, atom) -> atom_slots cx atom)\n+                  (fun (_, atom) -> atom_slots cx atom)\n                   (Array.to_list inputs))\n ;;\n \n@@ -606,14 +604,27 @@ let expr_slots (cx:ctxt) (e:Ast.expr) : node_id array =\n (* Type extraction. *)\n \n let interior_slot_full mut ty : Ast.slot =\n-  { Ast.slot_mode = Ast.MODE_interior;\n-    Ast.slot_mutable = mut;\n-    Ast.slot_ty = Some ty }\n+  let ty =\n+    if mut\n+    then Ast.TY_mutable ty\n+    else ty\n+  in\n+    { Ast.slot_mode = Ast.MODE_interior;\n+      Ast.slot_ty = Some ty }\n ;;\n \n let exterior_slot_full mut ty : Ast.slot =\n-  { Ast.slot_mode = Ast.MODE_exterior;\n-    Ast.slot_mutable = mut;\n+  let ty =\n+    match ty with\n+        Ast.TY_exterior _ -> ty\n+      | _ -> Ast.TY_exterior ty\n+  in\n+  let ty =\n+    if mut\n+    then Ast.TY_mutable ty\n+    else ty\n+  in\n+  { Ast.slot_mode = Ast.MODE_interior;\n     Ast.slot_ty = Some ty }\n ;;\n \n@@ -626,12 +637,13 @@ let exterior_slot ty : Ast.slot = exterior_slot_full false ty\n \n (* General folds of Ast.ty. *)\n \n-type ('ty, 'slot, 'slots, 'tag) ty_fold =\n+type ('ty, 'tys, 'slot, 'slots, 'tag) ty_fold =\n     {\n       (* Functions that correspond to interior nodes in Ast.ty. *)\n-      ty_fold_slot : (Ast.mode * bool * 'ty) -> 'slot;\n+      ty_fold_slot : (Ast.mode * 'ty) -> 'slot;\n       ty_fold_slots : ('slot array) -> 'slots;\n-      ty_fold_tags : (Ast.name, 'slots) Hashtbl.t -> 'tag;\n+      ty_fold_tys : ('ty array) -> 'tys;\n+      ty_fold_tags : (Ast.name, 'tys) Hashtbl.t -> 'tag;\n \n       (* Functions that correspond to the Ast.ty constructors. *)\n       ty_fold_any: unit -> 'ty;\n@@ -642,9 +654,9 @@ type ('ty, 'slot, 'slots, 'tag) ty_fold =\n       ty_fold_uint : unit -> 'ty;\n       ty_fold_char : unit -> 'ty;\n       ty_fold_str : unit -> 'ty;\n-      ty_fold_tup : 'slots -> 'ty;\n-      ty_fold_vec : 'slot -> 'ty;\n-      ty_fold_rec : (Ast.ident * 'slot) array -> 'ty;\n+      ty_fold_tup : 'tys -> 'ty;\n+      ty_fold_vec : 'ty -> 'ty;\n+      ty_fold_rec : (Ast.ident * 'ty) array -> 'ty;\n       ty_fold_tag : 'tag -> 'ty;\n       ty_fold_iso : (int * 'tag array) -> 'ty;\n       ty_fold_idx : int -> 'ty;\n@@ -659,21 +671,29 @@ type ('ty, 'slot, 'slots, 'tag) ty_fold =\n       ty_fold_param : (int * Ast.effect) -> 'ty;\n       ty_fold_named : Ast.name -> 'ty;\n       ty_fold_type : unit -> 'ty;\n+      ty_fold_exterior : 'ty -> 'ty;\n+      ty_fold_mutable : 'ty -> 'ty;\n       ty_fold_constrained : ('ty * Ast.constrs) -> 'ty }\n ;;\n \n-let rec fold_ty (f:('ty, 'slot, 'slots, 'tag) ty_fold) (ty:Ast.ty) : 'ty =\n+let rec fold_ty (f:('ty, 'tys, 'slot, 'slots, 'tag) ty_fold) (ty:Ast.ty) : 'ty =\n   let fold_slot (s:Ast.slot) : 'slot =\n     f.ty_fold_slot (s.Ast.slot_mode,\n-                    s.Ast.slot_mutable,\n                     fold_ty f (slot_ty s))\n   in\n+\n   let fold_slots (slots:Ast.slot array) : 'slots =\n     f.ty_fold_slots (Array.map fold_slot slots)\n   in\n+\n+  let fold_tys (tys:Ast.ty array) : 'tys =\n+    f.ty_fold_tys (Array.map (fold_ty f) tys)\n+  in\n+\n   let fold_tags (ttag:Ast.ty_tag) : 'tag =\n-    f.ty_fold_tags (htab_map ttag (fun k v -> (k, fold_slots v)))\n+    f.ty_fold_tags (htab_map ttag (fun k v -> (k, fold_tys v)))\n   in\n+\n   let fold_sig tsig =\n     (fold_slots tsig.Ast.sig_input_slots,\n      tsig.Ast.sig_input_constrs,\n@@ -692,13 +712,15 @@ let rec fold_ty (f:('ty, 'slot, 'slots, 'tag) ty_fold) (ty:Ast.ty) : 'ty =\n   | Ast.TY_char -> f.ty_fold_char ()\n   | Ast.TY_str -> f.ty_fold_str ()\n \n-  | Ast.TY_tup t -> f.ty_fold_tup (fold_slots t)\n-  | Ast.TY_vec s -> f.ty_fold_vec (fold_slot s)\n-  | Ast.TY_rec r -> f.ty_fold_rec (Array.map (fun (k,v) -> (k,fold_slot v)) r)\n+  | Ast.TY_tup t -> f.ty_fold_tup (fold_tys t)\n+  | Ast.TY_vec t -> f.ty_fold_vec (fold_ty f t)\n+  | Ast.TY_rec r ->\n+      f.ty_fold_rec (Array.map (fun (k,v) -> (k,fold_ty f v)) r)\n \n   | Ast.TY_tag tt -> f.ty_fold_tag (fold_tags tt)\n-  | Ast.TY_iso ti -> f.ty_fold_iso (ti.Ast.iso_index,\n-                                    (Array.map fold_tags ti.Ast.iso_group))\n+  | Ast.TY_iso ti ->\n+      f.ty_fold_iso (ti.Ast.iso_index,\n+                     (Array.map fold_tags ti.Ast.iso_group))\n   | Ast.TY_idx i -> f.ty_fold_idx i\n \n   | Ast.TY_fn (tsig,taux) -> f.ty_fold_fn (fold_sig tsig, taux)\n@@ -713,16 +735,20 @@ let rec fold_ty (f:('ty, 'slot, 'slots, 'tag) ty_fold) (ty:Ast.ty) : 'ty =\n   | Ast.TY_named n -> f.ty_fold_named n\n   | Ast.TY_type -> f.ty_fold_type ()\n \n+  | Ast.TY_exterior t -> f.ty_fold_exterior (fold_ty f t)\n+  | Ast.TY_mutable t -> f.ty_fold_mutable (fold_ty f t)\n+\n   | Ast.TY_constrained (t, constrs) ->\n       f.ty_fold_constrained (fold_ty f t, constrs)\n \n ;;\n \n-type 'a simple_ty_fold = ('a, 'a, 'a, 'a) ty_fold\n+type 'a simple_ty_fold = ('a, 'a, 'a, 'a, 'a) ty_fold\n ;;\n \n let ty_fold_default (default:'a) : 'a simple_ty_fold =\n-    { ty_fold_slot = (fun _ -> default);\n+    { ty_fold_tys = (fun _ -> default);\n+      ty_fold_slot = (fun _ -> default);\n       ty_fold_slots = (fun _ -> default);\n       ty_fold_tags = (fun _ -> default);\n       ty_fold_any = (fun _ -> default);\n@@ -748,19 +774,22 @@ let ty_fold_default (default:'a) : 'a simple_ty_fold =\n       ty_fold_param = (fun _ -> default);\n       ty_fold_named = (fun _ -> default);\n       ty_fold_type = (fun _ -> default);\n+      ty_fold_exterior = (fun _ -> default);\n+      ty_fold_mutable = (fun _ -> default);\n       ty_fold_constrained = (fun _ -> default) }\n ;;\n \n let ty_fold_rebuild (id:Ast.ty -> Ast.ty)\n-    : (Ast.ty, Ast.slot, Ast.slot array, Ast.ty_tag) ty_fold =\n+    : (Ast.ty, Ast.ty array, Ast.slot, Ast.slot array, Ast.ty_tag) ty_fold =\n   let rebuild_fn ((islots, constrs, oslot), aux) =\n     ({ Ast.sig_input_slots = islots;\n        Ast.sig_input_constrs = constrs;\n        Ast.sig_output_slot = oslot }, aux)\n   in\n-  { ty_fold_slot = (fun (mode, mut, t) ->\n+    {\n+    ty_fold_tys = (fun ts -> ts);\n+    ty_fold_slot = (fun (mode, t) ->\n                       { Ast.slot_mode = mode;\n-                        Ast.slot_mutable = mut;\n                         Ast.slot_ty = Some t });\n     ty_fold_slots = (fun slots -> slots);\n     ty_fold_tags = (fun htab -> htab);\n@@ -773,7 +802,7 @@ let ty_fold_rebuild (id:Ast.ty -> Ast.ty)\n     ty_fold_char = (fun _ -> id Ast.TY_char);\n     ty_fold_str = (fun _ -> id Ast.TY_str);\n     ty_fold_tup =  (fun slots -> id (Ast.TY_tup slots));\n-    ty_fold_vec = (fun slot -> id (Ast.TY_vec slot));\n+    ty_fold_vec = (fun t -> id (Ast.TY_vec t));\n     ty_fold_rec = (fun entries -> id (Ast.TY_rec entries));\n     ty_fold_tag = (fun tag -> id (Ast.TY_tag tag));\n     ty_fold_iso = (fun (i, tags) -> id (Ast.TY_iso { Ast.iso_index = i;\n@@ -791,6 +820,8 @@ let ty_fold_rebuild (id:Ast.ty -> Ast.ty)\n     ty_fold_param = (fun (i, mut) -> id (Ast.TY_param (i, mut)));\n     ty_fold_named = (fun n -> id (Ast.TY_named n));\n     ty_fold_type = (fun _ -> id (Ast.TY_type));\n+    ty_fold_exterior = (fun t -> id (Ast.TY_exterior t));\n+    ty_fold_mutable = (fun t -> id (Ast.TY_mutable t));\n     ty_fold_constrained = (fun (t, constrs) ->\n                              id (Ast.TY_constrained (t, constrs))) }\n ;;\n@@ -892,7 +923,7 @@ let associative_binary_op_ty_fold\n   in\n     { base with\n         ty_fold_slots = (fun slots -> reduce (Array.to_list slots));\n-        ty_fold_slot = (fun (_, _, a) -> a);\n+        ty_fold_slot = (fun (_, a) -> a);\n         ty_fold_tags = (fun tab -> reduce (htab_vals tab));\n         ty_fold_tup = (fun a -> a);\n         ty_fold_vec = (fun a -> a);\n@@ -957,13 +988,9 @@ let lower_effect_of x y =\n ;;\n \n let type_effect (t:Ast.ty) : Ast.effect =\n-  let fold_slot ((*mode*)_, mut, eff) =\n-    if mut\n-    then lower_effect_of Ast.STATE eff\n-    else eff\n-  in\n+  let fold_mutable _ = Ast.STATE in\n   let fold = associative_binary_op_ty_fold Ast.PURE lower_effect_of in\n-  let fold = { fold with ty_fold_slot = fold_slot } in\n+  let fold = { fold with ty_fold_mutable = fold_mutable } in\n     fold_ty fold t\n ;;\n \n@@ -1037,15 +1064,15 @@ let check_concrete params thing =\n ;;\n \n \n-let project_type_to_slot\n+let project_type\n     (base_ty:Ast.ty)\n     (comp:Ast.lval_component)\n-    : Ast.slot =\n+    : Ast.ty =\n   match (base_ty, comp) with\n       (Ast.TY_rec elts, Ast.COMP_named (Ast.COMP_ident id)) ->\n         begin\n           match atab_search elts id with\n-              Some slot -> slot\n+              Some ty -> ty\n             | None -> err None \"unknown record-member '%s'\" id\n         end\n \n@@ -1054,14 +1081,10 @@ let project_type_to_slot\n         then elts.(i)\n         else err None \"out-of-range tuple index %d\" i\n \n-    | (Ast.TY_vec slot, Ast.COMP_atom _) ->\n-        slot\n-\n-    | (Ast.TY_str, Ast.COMP_atom _) ->\n-        interior_slot (Ast.TY_mach TY_u8)\n-\n+    | (Ast.TY_vec ty, Ast.COMP_atom _) -> ty\n+    | (Ast.TY_str, Ast.COMP_atom _) -> (Ast.TY_mach TY_u8)\n     | (Ast.TY_obj (_, fns), Ast.COMP_named (Ast.COMP_ident id)) ->\n-        interior_slot (Ast.TY_fn (Hashtbl.find fns id))\n+        (Ast.TY_fn (Hashtbl.find fns id))\n \n     | (_,_) ->\n         bug ()\n@@ -1070,16 +1093,6 @@ let project_type_to_slot\n           Ast.sprintf_ty base_ty Ast.sprintf_lval_component comp\n ;;\n \n-\n-(* NB: this will fail if lval is not a slot. *)\n-let rec lval_slot (cx:ctxt) (lval:Ast.lval) : Ast.slot =\n-  match lval with\n-      Ast.LVAL_base nb -> lval_to_slot cx nb.id\n-    | Ast.LVAL_ext (base, comp) ->\n-        let base_ty = slot_ty (lval_slot cx base) in\n-          project_type_to_slot base_ty comp\n-;;\n-\n let exports_permit (view:Ast.mod_view) (ident:Ast.ident) : bool =\n   (Hashtbl.mem view.Ast.view_exports Ast.EXPORT_all_decls) ||\n     (Hashtbl.mem view.Ast.view_exports (Ast.EXPORT_ident ident))\n@@ -1150,6 +1163,10 @@ let lval_is_direct_mod (cx:ctxt) (lval:Ast.lval) : bool =\n         | _ -> false\n ;;\n \n+let lval_ty (cx:ctxt) (lval:Ast.lval) : Ast.ty =\n+  Hashtbl.find cx.ctxt_all_lval_types (lval_base_id lval)\n+;;\n+\n let lval_is_static (cx:ctxt) (lval:Ast.lval) : bool =\n   defn_is_static (resolve_lval cx lval)\n ;;\n@@ -1164,19 +1181,14 @@ let lval_is_obj_vtbl (cx:ctxt) (lval:Ast.lval) : bool =\n     match lval with\n         Ast.LVAL_ext (base, _) ->\n           begin\n-            match slot_ty (lval_slot cx base) with\n+            match lval_ty cx base with\n                 Ast.TY_obj _ -> true\n               | _ -> false\n           end\n       | _ -> false\n   else false\n ;;\n \n-let rec lval_ty (cx:ctxt) (lval:Ast.lval) : Ast.ty =\n-  let base_id = lval_base_id lval in\n-    Hashtbl.find cx.ctxt_all_lval_types base_id\n-;;\n-\n let rec atom_type (cx:ctxt) (at:Ast.atom) : Ast.ty =\n   match at with\n       Ast.ATOM_literal {node=(Ast.LIT_int _); id=_} -> Ast.TY_int\n@@ -1741,7 +1753,7 @@ let rec referent_type (abi:Abi.abi) (t:Ast.ty) : Il.referent_ty =\n   let ptr = sp Il.OpaqueTy in\n   let rc_ptr = sp (Il.StructTy [| word; Il.OpaqueTy |]) in\n   let codeptr = sp Il.CodeTy in\n-  let tup ttup = Il.StructTy (Array.map (slot_referent_type abi) ttup) in\n+  let tup ttup = Il.StructTy (Array.map (referent_type abi) ttup) in\n   let tag ttag =\n     let union =\n       Il.UnionTy\n@@ -1802,23 +1814,23 @@ let rec referent_type (abi:Abi.abi) (t:Ast.ty) : Il.referent_ty =\n \n       | Ast.TY_native _ -> ptr\n \n+      | Ast.TY_exterior t ->\n+          sp (Il.StructTy [| word; referent_type abi t |])\n+\n+      | Ast.TY_mutable t -> referent_type abi t\n+\n       | Ast.TY_param (i, _) -> Il.ParamTy i\n \n       | Ast.TY_named _ -> bug () \"named type in referent_type\"\n       | Ast.TY_constrained (t, _) -> referent_type abi t\n \n and slot_referent_type (abi:Abi.abi) (sl:Ast.slot) : Il.referent_ty =\n   let s t = Il.ScalarTy t in\n-  let v b = Il.ValTy b in\n   let p t = Il.AddrTy t in\n-  let sv b = s (v b) in\n   let sp t = s (p t) in\n \n-  let word = sv abi.Abi.abi_word_bits in\n-\n   let rty = referent_type abi (slot_ty sl) in\n     match sl.Ast.slot_mode with\n-        Ast.MODE_exterior _ -> sp (Il.StructTy [| word; rty |])\n       | Ast.MODE_interior _ -> rty\n       | Ast.MODE_alias _ -> sp rty\n ;;\n@@ -1940,14 +1952,17 @@ let word_slot (abi:Abi.abi) : Ast.slot =\n \n let alias_slot (ty:Ast.ty) : Ast.slot =\n   { Ast.slot_mode = Ast.MODE_alias;\n-    Ast.slot_mutable = false;\n     Ast.slot_ty = Some ty }\n ;;\n \n let mutable_alias_slot (ty:Ast.ty) : Ast.slot =\n-  { Ast.slot_mode = Ast.MODE_alias;\n-    Ast.slot_mutable = true;\n-    Ast.slot_ty = Some ty }\n+  let ty =\n+    match ty with\n+        Ast.TY_mutable _ -> ty\n+      | _ -> Ast.TY_mutable ty\n+  in\n+    { Ast.slot_mode = Ast.MODE_alias;\n+      Ast.slot_ty = Some ty }\n ;;\n \n let mk_ty_fn_or_iter\n@@ -2002,12 +2017,10 @@ let item_str (cx:ctxt) (id:node_id) : string =\n \n let ty_str (ty:Ast.ty) : string =\n   let base = associative_binary_op_ty_fold \"\" (fun a b -> a ^ b) in\n-  let fold_slot (mode,mut,ty) =\n-    (if mut then \"m\" else \"\")\n-    ^ (match mode with\n-           Ast.MODE_exterior -> \"e\"\n-         | Ast.MODE_alias -> \"a\"\n-         | Ast.MODE_interior -> \"\")\n+  let fold_slot (mode,ty) =\n+    (match mode with\n+         Ast.MODE_alias -> \"a\"\n+       | Ast.MODE_interior -> \"\")\n     ^ ty\n   in\n   let num n = (string_of_int n) ^ \"$\" in\n@@ -2080,6 +2093,8 @@ let ty_str (ty:Ast.ty) : string =\n          ty_fold_native = (fun _ -> \"N\");\n          ty_fold_param = (fun _ -> \"P\");\n          ty_fold_type = (fun _ -> \"Y\");\n+         ty_fold_mutable = (fun t -> \"m\" ^ t);\n+         ty_fold_exterior = (fun t -> \"e\" ^ t);\n \n          (* FIXME (issue #78): encode obj types. *)\n          (* FIXME (issue #78): encode opaque and param numbers. *)"}, {"sha": "5a15eadadca320b92a91b3c04f632571d9106831", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 510, "deletions": 540, "changes": 1050, "blob_url": "https://github.com/rust-lang/rust/blob/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=1f9fd2710ec9122ddddcedaab51650a92ad7c8cf", "patch": "@@ -55,13 +55,14 @@ let trans_visitor\n   let (abi:Abi.abi) = cx.ctxt_abi in\n   let (word_sz:int64) = word_sz abi in\n   let (word_slot:Ast.slot) = word_slot abi in\n+  let (word_ty:Ast.ty) = Ast.TY_mach abi.Abi.abi_word_ty in\n \n   let oper_str = Il.string_of_operand abi.Abi.abi_str_of_hardreg in\n   let cell_str = Il.string_of_cell abi.Abi.abi_str_of_hardreg in\n \n   let (word_bits:Il.bits) = abi.Abi.abi_word_bits in\n-  let (word_ty:Il.scalar_ty) = Il.ValTy word_bits in\n-  let (word_rty:Il.referent_ty) = Il.ScalarTy word_ty in\n+  let (word_sty:Il.scalar_ty) = Il.ValTy word_bits in\n+  let (word_rty:Il.referent_ty) = Il.ScalarTy word_sty in\n   let (word_ty_mach:ty_mach) =\n     match word_bits with\n         Il.Bits8 -> TY_u8\n@@ -88,7 +89,7 @@ let trans_visitor\n   let imm_true = imm_of_ty 1L TY_u8 in\n   let imm_false = imm_of_ty 0L TY_u8 in\n   let nil_ptr = Il.Mem ((Il.Abs (Asm.IMM 0L)), Il.NilTy) in\n-  let wordptr_ty = Il.AddrTy (Il.ScalarTy word_ty) in\n+  let wordptr_ty = Il.AddrTy (Il.ScalarTy word_sty) in\n \n   let crate_rel fix =\n     Asm.SUB (Asm.M_POS fix, Asm.M_POS cx.ctxt_crate_fixup)\n@@ -431,8 +432,8 @@ let trans_visitor\n   in\n \n \n-  let make_tydesc_slots n =\n-    Array.init n (fun _ -> interior_slot Ast.TY_type)\n+  let make_tydesc_tys n =\n+    Array.init n (fun _ -> Ast.TY_type)\n   in\n \n   let cell_vreg_num (vr:(int option) ref) : int =\n@@ -521,7 +522,7 @@ let trans_visitor\n         begin\n           let obj = get_obj_for_current_frame() in\n           let tydesc = get_element_ptr obj 1 in\n-          let ty_params_ty = Ast.TY_tup (make_tydesc_slots n_ty_params) in\n+          let ty_params_ty = Ast.TY_tup (make_tydesc_tys n_ty_params) in\n           let ty_params_rty = referent_type abi ty_params_ty in\n           let ty_params =\n             get_element_ptr (deref tydesc) Abi.tydesc_field_first_param\n@@ -595,28 +596,28 @@ let trans_visitor\n \n               | SIZE_rt_neg a ->\n                   let op_a = sub_sz a in\n-                  let tmp = next_vreg_cell word_ty in\n+                  let tmp = next_vreg_cell word_sty in\n                     emit (Il.unary Il.NEG tmp op_a);\n                     Il.Cell tmp\n \n               | SIZE_rt_add (a, b) ->\n                   let op_a = sub_sz a in\n                   let op_b = sub_sz b in\n-                  let tmp = next_vreg_cell word_ty in\n+                  let tmp = next_vreg_cell word_sty in\n                     add tmp op_a op_b;\n                     Il.Cell tmp\n \n               | SIZE_rt_mul (a, b) ->\n                   let op_a = sub_sz a in\n                   let op_b = sub_sz b in\n-                  let tmp = next_vreg_cell word_ty in\n+                  let tmp = next_vreg_cell word_sty in\n                     emit (Il.binary Il.UMUL tmp op_a op_b);\n                     Il.Cell tmp\n \n               | SIZE_rt_max (a, b) ->\n                   let op_a = sub_sz a in\n                   let op_b = sub_sz b in\n-                  let tmp = next_vreg_cell word_ty in\n+                  let tmp = next_vreg_cell word_sty in\n                     mov tmp op_a;\n                     emit (Il.cmp op_a op_b);\n                     let jmp = mark () in\n@@ -643,8 +644,8 @@ let trans_visitor\n                   let op_align = sub_sz align in\n                     annotate \"fetch offset\";\n                     let op_off = sub_sz off in\n-                    let mask = next_vreg_cell word_ty in\n-                    let off = next_vreg_cell word_ty in\n+                    let mask = next_vreg_cell word_sty in\n+                    let off = next_vreg_cell word_sty in\n                       mov mask op_align;\n                       sub_from mask one;\n                       mov off op_off;\n@@ -678,8 +679,8 @@ let trans_visitor\n       | None ->\n              let runtime_size = calculate_sz ty_params size in\n              let v = next_vreg () in\n-             let c = (Il.Reg (v, word_ty)) in\n-               mov c (Il.Cell (Il.Reg (reg, word_ty)));\n+             let c = (Il.Reg (v, word_sty)) in\n+               mov c (Il.Cell (Il.Reg (reg, word_sty)));\n                add_to c runtime_size;\n                based v\n \n@@ -690,17 +691,17 @@ let trans_visitor\n     based_sz (get_ty_params_of_current_frame()) abi.Abi.abi_sp_reg size\n   in\n \n-  let slot_sz_in_current_frame (slot:Ast.slot) : Il.operand =\n-    let rty = slot_referent_type abi slot in\n+  let ty_sz_in_current_frame (ty:Ast.ty) : Il.operand =\n+    let rty = referent_type abi ty in\n     let sz = Il.referent_ty_size word_bits rty in\n       calculate_sz_in_current_frame sz\n   in\n \n-  let slot_sz_with_ty_params\n+  let ty_sz_with_ty_params\n       (ty_params:Il.cell)\n-      (slot:Ast.slot)\n+      (ty:Ast.ty)\n       : Il.operand =\n-    let rty = slot_referent_type abi slot in\n+    let rty = referent_type abi ty in\n     let sz = Il.referent_ty_size word_bits rty in\n       calculate_sz ty_params sz\n   in\n@@ -722,8 +723,8 @@ let trans_visitor\n                       Il.Mem (Il.mem_off_imm mem fixed_off, elt_rty)\n                   | sz ->\n                       let sz = calculate_sz ty_params sz in\n-                      let v = next_vreg word_ty in\n-                      let vc = Il.Reg (v, word_ty) in\n+                      let v = next_vreg word_sty in\n+                      let vc = Il.Reg (v, word_sty) in\n                         lea vc mem;\n                         add_to vc sz;\n                         Il.Mem (based v, elt_rty)\n@@ -739,12 +740,6 @@ let trans_visitor\n     get_element_ptr_dyn (get_ty_params_of_current_frame()) mem_cell i\n   in\n \n-  let get_explicit_args_for_current_frame _ =\n-    get_element_ptr_dyn_in_current_frame (get_args_for_current_frame ())\n-      Abi.calltup_elt_args\n-  in\n-\n-\n   let deref_off_sz\n       (ty_params:Il.cell)\n       (ptr:Il.cell)\n@@ -890,15 +885,15 @@ let trans_visitor\n       (base_ty:Ast.ty)\n       (cell:Il.cell)\n       (comp:Ast.lval_component)\n-      : (Il.cell * Ast.slot) =\n+      : (Il.cell * Ast.ty) =\n \n-    let bounds_checked_access at slot =\n+    let bounds_checked_access at ty =\n       let atop = trans_atom at in\n-      let unit_sz = slot_sz_in_current_frame slot in\n-      let idx = next_vreg_cell word_ty in\n+      let unit_sz = ty_sz_in_current_frame ty in\n+      let idx = next_vreg_cell word_sty in\n         emit (Il.binary Il.UMUL idx atop unit_sz);\n         let elt_mem = trans_bounds_check (deref cell) (Il.Cell idx) in\n-          (Il.Mem (elt_mem, slot_referent_type abi slot), slot)\n+          (Il.Mem (elt_mem, referent_type abi ty), ty)\n     in\n \n     match (base_ty, comp) with\n@@ -911,18 +906,18 @@ let trans_visitor\n          Ast.COMP_named (Ast.COMP_idx i)) ->\n           (get_element_ptr_dyn_in_current_frame cell i, entries.(i))\n \n-      | (Ast.TY_vec slot,\n+      | (Ast.TY_vec ty,\n          Ast.COMP_atom at) ->\n-          bounds_checked_access at slot\n+          bounds_checked_access at ty\n \n       | (Ast.TY_str,\n          Ast.COMP_atom at) ->\n-          bounds_checked_access at (interior_slot (Ast.TY_mach TY_u8))\n+          bounds_checked_access at (Ast.TY_mach TY_u8)\n \n       | (Ast.TY_obj obj_ty,\n          Ast.COMP_named (Ast.COMP_ident id)) ->\n           let (cell, fn_ty) = get_vtbl_entry cell obj_ty id in\n-            (cell, (interior_slot (Ast.TY_fn fn_ty)))\n+            (cell, (Ast.TY_fn fn_ty))\n \n \n       | _ -> bug () \"unhandled form of lval_ext in trans_slot_lval_ext\"\n@@ -938,7 +933,7 @@ let trans_visitor\n     let (base:Il.cell) = next_vreg_cell Il.voidptr_t in\n     let (elt_reg:Il.reg) = next_vreg () in\n     let (elt:Il.cell) = Il.Reg (elt_reg, Il.voidptr_t) in\n-    let (diff:Il.cell) = next_vreg_cell word_ty in\n+    let (diff:Il.cell) = next_vreg_cell word_sty in\n       annotate \"bounds check\";\n       lea base (fst (need_mem_cell data));\n       add elt (Il.Cell base) mul_idx;\n@@ -950,23 +945,27 @@ let trans_visitor\n   and trans_lval_full\n       (initializing:bool)\n       (lv:Ast.lval)\n-      : (Il.cell * Ast.slot) =\n+      : (Il.cell * Ast.ty) =\n \n     let rec trans_slot_lval_full (initializing:bool) lv =\n-      let (cell, slot) =\n+      let (cell, ty) =\n         match lv with\n             Ast.LVAL_ext (base, comp) ->\n-              let (base_cell, base_slot) =\n+              let (base_cell, base_ty) =\n                 trans_slot_lval_full initializing base\n               in\n-              let base_cell' = deref_slot initializing base_cell base_slot in\n-                trans_slot_lval_ext (slot_ty base_slot) base_cell' comp\n+              let (base_cell, base_ty) =\n+                deref_ty initializing base_cell base_ty\n+              in\n+                trans_slot_lval_ext base_ty base_cell comp\n \n           | Ast.LVAL_base nb ->\n               let slot = lval_to_slot cx nb.id in\n               let referent = lval_to_referent cx nb.id in\n               let cell = cell_of_block_slot referent in\n-                (cell, slot)\n+              let ty = slot_ty slot in\n+              let cell = deref_slot initializing cell slot in\n+                deref_ty initializing cell ty\n       in\n         iflog\n           begin\n@@ -976,7 +975,7 @@ let trans_visitor\n                    Ast.sprintf_lval lv\n                    (cell_str cell))\n           end;\n-        (cell, slot)\n+        (cell, ty)\n \n     in\n       if lval_is_slot cx lv\n@@ -994,13 +993,13 @@ let trans_visitor\n   and trans_lval_maybe_init\n       (initializing:bool)\n       (lv:Ast.lval)\n-      : (Il.cell * Ast.slot) =\n+      : (Il.cell * Ast.ty) =\n     trans_lval_full initializing lv\n \n-  and trans_lval_init (lv:Ast.lval) : (Il.cell * Ast.slot) =\n+  and trans_lval_init (lv:Ast.lval) : (Il.cell * Ast.ty) =\n     trans_lval_maybe_init true lv\n \n-  and trans_lval (lv:Ast.lval) : (Il.cell * Ast.slot) =\n+  and trans_lval (lv:Ast.lval) : (Il.cell * Ast.ty) =\n     trans_lval_maybe_init false lv\n \n   and trans_callee\n@@ -1231,8 +1230,8 @@ let trans_visitor\n \n     match atom with\n         Ast.ATOM_lval lv ->\n-          let (cell, slot) = trans_lval lv in\n-            Il.Cell (deref_slot false cell slot)\n+          let (cell, ty) = trans_lval lv in\n+            Il.Cell (fst (deref_ty false cell ty))\n \n       | Ast.ATOM_literal lit -> trans_lit lit.node\n \n@@ -1302,7 +1301,7 @@ let trans_visitor\n \n   and check_interrupt_flag _ =\n     let dom = next_vreg_cell wordptr_ty in\n-    let flag = next_vreg_cell word_ty in\n+    let flag = next_vreg_cell word_sty in\n       mov dom (Il.Cell (tp_imm (word_n Abi.task_field_dom)));\n       mov flag (Il.Cell (deref_imm dom\n                            (word_n Abi.dom_field_interrupt_flag)));\n@@ -1393,7 +1392,7 @@ let trans_visitor\n       (bs:Ast.slot array)\n       (* FIXME (issue #5): mutability flag *)\n       : Il.referent_ty =\n-    let rc = Il.ScalarTy word_ty in\n+    let rc = Il.ScalarTy word_sty in\n     let targ = referent_type abi (mk_simple_ty_fn [||]) in\n     let bindings = Array.map (slot_referent_type abi) bs in\n       Il.StructTy [| rc; targ; Il.StructTy bindings |]\n@@ -1557,7 +1556,7 @@ let trans_visitor\n \n   and ty_params_covering (t:Ast.ty) : Ast.slot =\n     let n_ty_params = n_used_type_params t in\n-    let params = make_tydesc_slots n_ty_params in\n+    let params = make_tydesc_tys n_ty_params in\n       alias_slot (Ast.TY_tup params)\n \n   and get_drop_glue\n@@ -1570,7 +1569,7 @@ let trans_visitor\n       let cell = get_element_ptr args 1 in\n         note_drop_step ty \"in drop-glue, dropping\";\n         trace_word cx.ctxt_sess.Session.sess_trace_drop cell;\n-        drop_ty ty_params ty (deref cell) curr_iso;\n+        drop_ty ty_params (deref cell) ty curr_iso;\n         note_drop_step ty \"drop-glue complete\";\n     in\n     let ty_params_ptr = ty_params_covering ty in\n@@ -1621,7 +1620,7 @@ let trans_visitor\n     let inner _ (args:Il.cell) =\n       let ty_params = deref (get_element_ptr args 0) in\n       let cell = get_element_ptr args 1 in\n-        sever_ty ty_params ty (deref cell) curr_iso\n+        sever_ty ty_params (deref cell) ty curr_iso\n     in\n     let ty_params_ptr = ty_params_covering ty in\n     let fty = mk_simple_ty_fn [| ty_params_ptr; alias_slot ty |] in\n@@ -1636,7 +1635,7 @@ let trans_visitor\n     let inner _ (args:Il.cell) =\n       let ty_params = deref (get_element_ptr args 0) in\n       let cell = get_element_ptr args 1 in\n-        mark_ty ty_params ty (deref cell) curr_iso\n+        mark_ty ty_params (deref cell) ty curr_iso\n     in\n     let ty_params_ptr = ty_params_covering ty in\n     let fty = mk_simple_ty_fn [| ty_params_ptr; alias_slot ty |] in\n@@ -1653,7 +1652,7 @@ let trans_visitor\n       let ty_params = deref (get_element_ptr args 0) in\n       let src = deref (get_element_ptr args 1) in\n       let clone_task = get_element_ptr args 2 in\n-        clone_ty ty_params clone_task ty dst src curr_iso\n+        clone_ty ty_params clone_task dst src ty curr_iso\n     in\n     let ty_params_ptr = ty_params_covering ty in\n     let fty =\n@@ -1677,7 +1676,7 @@ let trans_visitor\n       let dst = deref out_ptr in\n       let ty_params = deref (get_element_ptr args 0) in\n       let src = deref (get_element_ptr args 1) in\n-        copy_ty ty_params ty dst src curr_iso\n+        copy_ty ty_params dst src ty curr_iso\n     in\n     let ty_params_ptr = ty_params_covering ty in\n     let fty =\n@@ -2096,8 +2095,8 @@ let trans_visitor\n         end\n \n   and trans_init_port (dst:Ast.lval) : unit =\n-    let (dstcell, dst_slot) = trans_lval_init dst in\n-    let unit_ty = match slot_ty dst_slot with\n+    let (dstcell, dst_ty) = trans_lval_init dst in\n+    let unit_ty = match dst_ty with\n         Ast.TY_port t -> t\n       | _ -> bug () \"init dst of port-init has non-port type\"\n     in\n@@ -2134,19 +2133,18 @@ let trans_visitor\n    *)\n \n   and trans_init_vec (dst:Ast.lval) (atoms:Ast.atom array) : unit =\n-    let (dst_cell, dst_slot) = trans_lval_init dst in\n-    let dst_ty = slot_ty dst_slot in\n+    let (dst_cell, dst_ty) = trans_lval_init dst in\n     let gc_ctrl =\n-      if (slot_mem_ctrl dst_slot) = MEM_gc\n-      then Il.Cell (get_tydesc None (slot_ty dst_slot))\n+      if (ty_mem_ctrl dst_ty) = MEM_gc\n+      then Il.Cell (get_tydesc None dst_ty)\n       else zero\n     in\n-    let unit_slot = match dst_ty with\n-        Ast.TY_vec s -> s\n+    let unit_ty = match dst_ty with\n+        Ast.TY_vec t -> t\n       | _ -> bug () \"init dst of vec-init has non-vec type\"\n     in\n-    let fill = next_vreg_cell word_ty in\n-    let unit_sz = slot_sz_in_current_frame unit_slot in\n+    let fill = next_vreg_cell word_sty in\n+    let unit_sz = ty_sz_in_current_frame unit_ty in\n       umul fill unit_sz (imm (Int64.of_int (Array.length atoms)));\n       trans_upcall \"upcall_new_vec\" dst_cell [| Il.Cell fill; gc_ctrl |];\n       let vec = deref dst_cell in\n@@ -2155,14 +2153,14 @@ let trans_visitor\n                  (get_element_ptr_dyn_in_current_frame\n                     vec Abi.vec_elt_data))\n         in\n-        let unit_rty = slot_referent_type abi unit_slot in\n+        let unit_rty = referent_type abi unit_ty in\n         let body_rty = Il.StructTy (Array.map (fun _ -> unit_rty) atoms) in\n         let body = Il.Mem (body_mem, body_rty) in\n           Array.iteri\n             begin\n               fun i atom ->\n                 let cell = get_element_ptr_dyn_in_current_frame body i in\n-                  trans_init_slot_from_atom CLONE_none cell unit_slot atom\n+                  trans_init_ty_from_atom cell unit_ty atom\n             end\n             atoms;\n             mov (get_element_ptr vec Abi.vec_elt_fill) (Il.Cell fill);\n@@ -2221,45 +2219,44 @@ let trans_visitor\n     exterior_ctrl_cell cell Abi.exterior_rc_slot_field_refcnt\n \n   and exterior_allocation_size\n-      (slot:Ast.slot)\n+      (ty:Ast.ty)\n       : Il.operand =\n     let header_sz =\n-      match slot_mem_ctrl slot with\n+      match ty_mem_ctrl ty with\n           MEM_gc\n         | MEM_rc_opaque\n         | MEM_rc_struct -> word_n Abi.exterior_rc_header_size\n         | MEM_interior -> bug () \"exterior_allocation_size of MEM_interior\"\n     in\n-    let t = slot_ty slot in\n     let refty_sz =\n-      Il.referent_ty_size abi.Abi.abi_word_bits (referent_type abi t)\n+      Il.referent_ty_size abi.Abi.abi_word_bits (referent_type abi ty)\n     in\n       match refty_sz with\n-          SIZE_fixed _ -> imm (Int64.add (ty_sz abi t) header_sz)\n+          SIZE_fixed _ -> imm (Int64.add (ty_sz abi ty) header_sz)\n         | _ ->\n             let ty_params = get_ty_params_of_current_frame() in\n             let refty_sz = calculate_sz ty_params refty_sz in\n-            let v = next_vreg word_ty in\n-            let vc = Il.Reg (v, word_ty) in\n+            let v = next_vreg word_sty in\n+            let vc = Il.Reg (v, word_sty) in\n               mov vc refty_sz;\n               add_to vc (imm header_sz);\n               Il.Cell vc;\n \n-  and iter_tag_slots\n+  and iter_tag_parts\n       (ty_params:Il.cell)\n       (dst_cell:Il.cell)\n       (src_cell:Il.cell)\n       (ttag:Ast.ty_tag)\n-      (f:Il.cell -> Il.cell -> Ast.slot -> (Ast.ty_iso option) -> unit)\n+      (f:Il.cell -> Il.cell -> Ast.ty -> (Ast.ty_iso option) -> unit)\n       (curr_iso:Ast.ty_iso option)\n       : unit =\n     let tag_keys = sorted_htab_keys ttag in\n     let src_tag = get_element_ptr src_cell 0 in\n     let dst_tag = get_element_ptr dst_cell 0 in\n     let src_union = get_element_ptr_dyn ty_params src_cell 1 in\n     let dst_union = get_element_ptr_dyn ty_params dst_cell 1 in\n-    let tmp = next_vreg_cell word_ty in\n-      f dst_tag src_tag word_slot curr_iso;\n+    let tmp = next_vreg_cell word_sty in\n+      f dst_tag src_tag word_ty curr_iso;\n       mov tmp (Il.Cell src_tag);\n       Array.iteri\n         begin\n@@ -2271,7 +2268,7 @@ let trans_visitor\n               trans_compare Il.JNE (Il.Cell tmp) (imm (Int64.of_int i))\n             in\n             let ttup = Hashtbl.find ttag key in\n-              iter_tup_slots\n+              iter_tup_parts\n                 (get_element_ptr_dyn ty_params)\n                 (get_variant_ptr dst_union i)\n                 (get_variant_ptr src_union i)\n@@ -2284,24 +2281,24 @@ let trans_visitor\n     tiso.Ast.iso_group.(tiso.Ast.iso_index)\n \n \n-  and seq_unit_slot (seq:Ast.ty) : Ast.slot =\n+  and seq_unit_ty (seq:Ast.ty) : Ast.ty =\n     match seq with\n-        Ast.TY_vec s -> s\n-      | Ast.TY_str -> (interior_slot (Ast.TY_mach TY_u8))\n-      | _ -> bug () \"seq_unit_slot of non-vec, non-str type\"\n+        Ast.TY_vec t -> t\n+      | Ast.TY_str -> Ast.TY_mach TY_u8\n+      | _ -> bug () \"seq_unit_ty of non-vec, non-str type\"\n \n \n-  and iter_seq_slots\n+  and iter_seq_parts\n       (ty_params:Il.cell)\n       (dst_cell:Il.cell)\n       (src_cell:Il.cell)\n-      (unit_slot:Ast.slot)\n-      (f:Il.cell -> Il.cell -> Ast.slot -> (Ast.ty_iso option) -> unit)\n+      (unit_ty:Ast.ty)\n+      (f:Il.cell -> Il.cell -> Ast.ty -> (Ast.ty_iso option) -> unit)\n       (curr_iso:Ast.ty_iso option)\n       : unit =\n-    let unit_sz = slot_sz_with_ty_params ty_params unit_slot in\n+    let unit_sz = ty_sz_with_ty_params ty_params unit_ty in\n       (* \n-       * Unlike most of the iter_ty_slots helpers; this one allocates a\n+       * Unlike most of the iter_ty_parts helpers; this one allocates a\n        * vreg and so has to be aware of when it's iterating over 2\n        * sequences of cells or just 1.\n        *)\n@@ -2323,9 +2320,9 @@ let trans_visitor\n             let back_jmp_target = mark () in\n             let fwd_jmps = trans_compare Il.JAE (Il.Cell ptr) (Il.Cell lim) in\n             let unit_cell =\n-              deref (ptr_cast ptr (slot_referent_type abi unit_slot))\n+              deref (ptr_cast ptr (referent_type abi unit_ty))\n             in\n-              f unit_cell unit_cell unit_slot curr_iso;\n+              f unit_cell unit_cell unit_ty curr_iso;\n               add_to ptr unit_sz;\n               check_interrupt_flag ();\n               emit (Il.jmp Il.JMP (Il.CodeLabel back_jmp_target));\n@@ -2337,12 +2334,12 @@ let trans_visitor\n         end\n \n \n-  and iter_ty_slots_full\n+  and iter_ty_parts_full\n       (ty_params:Il.cell)\n-      (ty:Ast.ty)\n       (dst_cell:Il.cell)\n       (src_cell:Il.cell)\n-      (f:Il.cell -> Il.cell -> Ast.slot -> (Ast.ty_iso option) -> unit)\n+      (ty:Ast.ty)\n+      (f:Il.cell -> Il.cell -> Ast.ty -> (Ast.ty_iso option) -> unit)\n       (curr_iso:Ast.ty_iso option)\n       : unit =\n     (* \n@@ -2352,84 +2349,74 @@ let trans_visitor\n      *)\n     match ty with\n         Ast.TY_rec entries ->\n-          iter_rec_slots\n+          iter_rec_parts\n             (get_element_ptr_dyn ty_params) dst_cell src_cell\n             entries f curr_iso\n \n-      | Ast.TY_tup slots ->\n-          iter_tup_slots\n+      | Ast.TY_tup tys ->\n+          iter_tup_parts\n             (get_element_ptr_dyn ty_params) dst_cell src_cell\n-            slots f curr_iso\n+            tys f curr_iso\n \n       | Ast.TY_tag tag ->\n-          iter_tag_slots ty_params dst_cell src_cell tag f curr_iso\n+          iter_tag_parts ty_params dst_cell src_cell tag f curr_iso\n \n       | Ast.TY_iso tiso ->\n           let ttag = get_iso_tag tiso in\n-            iter_tag_slots ty_params dst_cell src_cell ttag f (Some tiso)\n+            iter_tag_parts ty_params dst_cell src_cell ttag f (Some tiso)\n \n       | Ast.TY_fn _\n       | Ast.TY_obj _ -> bug () \"Attempting to iterate over fn/pred/obj slots\"\n \n       | Ast.TY_vec _\n       | Ast.TY_str ->\n-          let unit_slot = seq_unit_slot ty in\n-            iter_seq_slots ty_params dst_cell src_cell unit_slot f curr_iso\n+          let unit_ty = seq_unit_ty ty in\n+            iter_seq_parts ty_params dst_cell src_cell unit_ty f curr_iso\n \n       | _ -> ()\n \n   (* \n-   * This just calls iter_ty_slots_full with your cell as both src and\n-   * dst, with an adaptor function that discards the dst slots of the\n+   * This just calls iter_ty_parts_full with your cell as both src and\n+   * dst, with an adaptor function that discards the dst parts of the\n    * parallel traversal and and calls your provided function on the\n-   * passed-in src slots.\n+   * passed-in src parts.\n    *)\n-  and iter_ty_slots\n+  and iter_ty_parts\n       (ty_params:Il.cell)\n-      (ty:Ast.ty)\n       (cell:Il.cell)\n-      (f:Il.cell -> Ast.slot -> (Ast.ty_iso option) -> unit)\n+      (ty:Ast.ty)\n+      (f:Il.cell -> Ast.ty -> (Ast.ty_iso option) -> unit)\n       (curr_iso:Ast.ty_iso option)\n       : unit =\n-    iter_ty_slots_full ty_params ty cell cell\n-      (fun _ src_cell slot curr_iso -> f src_cell slot curr_iso)\n+    iter_ty_parts_full ty_params cell cell ty\n+      (fun _ src_cell ty curr_iso -> f src_cell ty curr_iso)\n       curr_iso\n \n   and drop_ty\n       (ty_params:Il.cell)\n-      (ty:Ast.ty)\n       (cell:Il.cell)\n+      (ty:Ast.ty)\n       (curr_iso:Ast.ty_iso option)\n       : unit =\n-    match ty with\n-        Ast.TY_param (i, _) ->\n-          iflog (fun _ -> annotate\n-                   (Printf.sprintf \"drop_ty: parametric drop %#d\" i));\n-          aliasing false cell\n-            begin\n-              fun cell ->\n-                trans_call_simple_dynamic_glue\n-                   i Abi.tydesc_field_drop_glue ty_params cell\n-            end\n \n-      | Ast.TY_fn _ ->\n-          begin\n+    let ty = maybe_iso curr_iso ty in\n+    let curr_iso = maybe_enter_iso ty curr_iso in\n+    let mctrl = ty_mem_ctrl ty in\n+\n+      match ty with\n+\n+          Ast.TY_fn _ ->\n             let binding = get_element_ptr cell Abi.binding_field_binding in\n             let null_jmp = null_check binding in\n               (* Drop non-null bindings. *)\n-              (* FIXME (issue #58): this is completely wrong,\n-               * need a second thunk that generates code to make\n-               * use of a runtime type descriptor extracted from\n-               * a binding tuple. For now this only works by\n-               * accident. \n+              (* FIXME (issue #58): this is completely wrong, Closures need to\n+               * carry tydescs like objs. For now this only works by accident,\n+               * and will leak closures with exterior substructure.\n                *)\n-              drop_slot ty_params binding\n-                (exterior_slot Ast.TY_int) curr_iso;\n+              drop_ty ty_params binding (Ast.TY_exterior Ast.TY_int) curr_iso;\n               patch null_jmp\n-          end\n \n-      | Ast.TY_obj _ ->\n-          begin\n+        | Ast.TY_obj _ ->\n             let binding = get_element_ptr cell Abi.binding_field_binding in\n             let null_jmp = null_check binding in\n             let obj = deref binding in\n@@ -2445,55 +2432,109 @@ let trans_visitor\n             in\n             let null_dtor_jmp = null_check dtor in\n               (* Call any dtor, if present. *)\n-              trans_call_dynamic_glue tydesc\n-                Abi.tydesc_field_obj_drop_glue None [| binding |];\n-              patch null_dtor_jmp;\n-              (* Drop the body. *)\n-              trans_call_dynamic_glue tydesc\n-                Abi.tydesc_field_drop_glue None [| ty_params; alias body |];\n-              (* FIXME: this will fail if the user has lied about the\n-               * state-ness of their obj. We need to store state-ness in the\n-               * captured tydesc, and use that.  *)\n-              trans_free binding (type_has_state ty);\n-              mov binding zero;\n-              patch rc_jmp;\n-              patch null_jmp\n-          end\n+            trans_call_dynamic_glue tydesc\n+              Abi.tydesc_field_obj_drop_glue None [| binding |];\n+            patch null_dtor_jmp;\n+            (* Drop the body. *)\n+            trans_call_dynamic_glue tydesc\n+              Abi.tydesc_field_drop_glue None [| ty_params; alias body |];\n+            (* FIXME: this will fail if the user has lied about the\n+             * state-ness of their obj. We need to store state-ness in the\n+             * captured tydesc, and use that.  *)\n+            trans_free binding (type_has_state ty);\n+            mov binding zero;\n+            patch rc_jmp;\n+            patch null_jmp\n+\n \n+      | Ast.TY_param (i, _) ->\n+          iflog (fun _ -> annotate\n+                   (Printf.sprintf \"drop_ty: parametric drop %#d\" i));\n+          aliasing false cell\n+            begin\n+              fun cell ->\n+                trans_call_simple_dynamic_glue\n+                  i Abi.tydesc_field_drop_glue ty_params cell\n+            end\n \n       | _ ->\n-          iter_ty_slots ty_params ty cell (drop_slot ty_params) curr_iso\n+          match mctrl with\n+              MEM_gc\n+            | MEM_rc_opaque\n+            | MEM_rc_struct ->\n+\n+                let _ = check_exterior_rty cell in\n+                let null_jmp = null_check cell in\n+                let rc = exterior_rc_cell cell in\n+                let j = drop_refcount_and_cmp rc in\n+\n+                  (* FIXME (issue #25): check to see that the exterior has\n+                   * further exterior members; if it doesn't we can elide the\n+                   * call to the glue function.  *)\n+\n+                  if mctrl = MEM_rc_opaque\n+                  then\n+                    free_ty false ty_params ty cell curr_iso\n+                  else\n+                    trans_call_simple_static_glue\n+                      (get_free_glue ty (mctrl = MEM_gc) curr_iso)\n+                      ty_params cell;\n+\n+                  (* Null the slot out to prevent double-free if the frame\n+                   * unwinds.\n+                   *)\n+                  mov cell zero;\n+                  patch j;\n+                  patch null_jmp\n+\n+            | MEM_interior when type_is_structured ty ->\n+                (iflog (fun _ ->\n+                          annotate (\"drop interior slot \" ^\n+                                      (Fmt.fmt_to_str Ast.fmt_ty ty))));\n+                let (mem, _) = need_mem_cell cell in\n+                let vr = next_vreg_cell Il.voidptr_t in\n+                  lea vr mem;\n+                  trans_call_simple_static_glue\n+                    (get_drop_glue ty curr_iso)\n+                    ty_params vr\n+\n+            | MEM_interior ->\n+                (* Interior allocation of all-interior value not caught above:\n+                 * nothing to do.\n+                 *)\n+                ()\n \n   and sever_ty\n       (ty_params:Il.cell)\n-      (ty:Ast.ty)\n       (cell:Il.cell)\n-      (curr_iso:Ast.ty_iso option)\n-      : unit =\n-    match ty with\n-      | Ast.TY_fn _\n-      | Ast.TY_obj _ -> ()\n-      | _ ->\n-          iter_ty_slots ty_params ty cell (sever_slot ty_params) curr_iso\n-\n-  and mark_ty\n-      (ty_params:Il.cell)\n       (ty:Ast.ty)\n-      (cell:Il.cell)\n       (curr_iso:Ast.ty_iso option)\n       : unit =\n-    match ty with\n-      | Ast.TY_fn _\n-      | Ast.TY_obj _ -> ()\n-      | _ ->\n-          iter_ty_slots ty_params ty cell (mark_slot ty_params) curr_iso\n+    let _ = note_gc_step ty \"severing\" in\n+      match ty_mem_ctrl ty with\n+          MEM_gc ->\n+\n+            let _ = check_exterior_rty cell in\n+            let null_jmp = null_check cell in\n+            let rc = exterior_rc_cell cell in\n+            let _ = note_gc_step ty \"severing GC slot\" in\n+              emit (Il.binary Il.SUB rc (Il.Cell rc) one);\n+              mov cell zero;\n+              patch null_jmp\n+\n+        | MEM_interior when type_is_structured ty ->\n+            iter_ty_parts ty_params cell ty\n+              (sever_ty ty_params) curr_iso\n+\n+        | _ -> ()\n+            (* No need to follow links / call glue; severing is shallow. *)\n \n   and clone_ty\n       (ty_params:Il.cell)\n       (clone_task:Il.cell)\n-      (ty:Ast.ty)\n       (dst:Il.cell)\n       (src:Il.cell)\n+      (ty:Ast.ty)\n       (curr_iso:Ast.ty_iso option)\n       : unit =\n     match ty with\n@@ -2508,15 +2549,21 @@ let trans_visitor\n           -> mov dst (Il.Cell src)\n       | Ast.TY_fn _\n       | Ast.TY_obj _ -> ()\n+      | Ast.TY_exterior ty ->\n+          let glue_fix = get_clone_glue ty curr_iso in\n+            trans_call_static_glue\n+              (code_fixup_to_ptr_operand glue_fix)\n+              (Some dst)\n+              [| alias ty_params; src; clone_task |]\n       | _ ->\n-          iter_ty_slots_full ty_params ty dst src\n-            (clone_slot ty_params clone_task) curr_iso\n+          iter_ty_parts_full ty_params dst src ty\n+            (clone_ty ty_params clone_task) curr_iso\n \n   and copy_ty\n       (ty_params:Il.cell)\n-      (ty:Ast.ty)\n       (dst:Il.cell)\n       (src:Il.cell)\n+      (ty:Ast.ty)\n       (curr_iso:Ast.ty_iso option)\n       : unit =\n     iflog (fun _ ->\n@@ -2565,18 +2612,18 @@ let trans_visitor\n                  * through to the binding's self-copy fptr. For now\n                  * this only works by accident.\n                  *)\n-                trans_copy_slot ty_params true\n-                  dst_binding (exterior_slot Ast.TY_int)\n-                  src_binding (exterior_slot Ast.TY_int)\n+                trans_copy_ty ty_params true\n+                  dst_binding (Ast.TY_exterior Ast.TY_int)\n+                  src_binding (Ast.TY_exterior Ast.TY_int)\n                   curr_iso;\n                 patch null_jmp\n           end\n \n       | _ ->\n-          iter_ty_slots_full ty_params ty dst src\n-            (fun dst src slot curr_iso ->\n-               trans_copy_slot ty_params true\n-                 dst slot src slot curr_iso)\n+          iter_ty_parts_full ty_params dst src ty\n+            (fun dst src ty curr_iso ->\n+               trans_copy_ty ty_params true\n+                 dst ty src ty curr_iso)\n             curr_iso\n \n   and free_ty\n@@ -2591,8 +2638,8 @@ let trans_visitor\n       | Ast.TY_chan _ -> trans_del_chan cell\n       | Ast.TY_task -> trans_kill_task cell\n       | Ast.TY_vec s ->\n-          iter_seq_slots ty_params cell cell s\n-            (fun _ src slot iso -> drop_slot ty_params src slot iso) curr_iso;\n+          iter_seq_parts ty_params cell cell s\n+            (fun _ src ty iso -> drop_ty ty_params src ty iso) curr_iso;\n           trans_free cell is_gc\n \n       | _ -> trans_free cell is_gc\n@@ -2603,7 +2650,7 @@ let trans_visitor\n       : Ast.ty =\n     match (curr_iso, t) with\n         (Some iso, Ast.TY_idx n) ->\n-          Ast.TY_iso { iso with Ast.iso_index = n }\n+          Ast.TY_exterior (Ast.TY_iso { iso with Ast.iso_index = n })\n       | (None, Ast.TY_idx _) ->\n           bug () \"TY_idx outside TY_iso\"\n       | _ -> t\n@@ -2616,74 +2663,46 @@ let trans_visitor\n         Ast.TY_iso tiso -> Some tiso\n       | _ -> curr_iso\n \n-  and sever_slot\n+  and mark_slot\n       (ty_params:Il.cell)\n       (cell:Il.cell)\n       (slot:Ast.slot)\n       (curr_iso:Ast.ty_iso option)\n       : unit =\n-    let _ = note_gc_step slot \"severing\" in\n-    let ty = slot_ty slot in\n-      match slot_mem_ctrl slot with\n-          MEM_gc ->\n-\n-            let _ = check_exterior_rty cell in\n-            let null_jmp = null_check cell in\n-            let rc = exterior_rc_cell cell in\n-            let _ = note_gc_step slot \"severing GC slot\" in\n-              emit (Il.binary Il.SUB rc (Il.Cell rc) one);\n-              mov cell zero;\n-              patch null_jmp\n-\n-        | MEM_interior when type_is_structured ty ->\n-            let (mem, _) = need_mem_cell cell in\n-            let tmp = next_vreg_cell Il.voidptr_t in\n-            let ty = maybe_iso curr_iso ty in\n-            let curr_iso = maybe_enter_iso ty curr_iso in\n-              lea tmp mem;\n-              trans_call_simple_static_glue\n-                (get_sever_glue ty curr_iso)\n-                ty_params tmp\n+    (* Marking goes straight through aliases. Reachable means reachable. *)\n+    mark_ty ty_params (deref_slot false cell slot) (slot_ty slot) curr_iso\n \n-        | MEM_interior ->\n-            (* Interior allocation of all-interior value: sever directly. *)\n-            let ty = maybe_iso curr_iso ty in\n-              sever_ty ty_params ty cell curr_iso\n-\n-        | _ -> ()\n-\n-  and mark_slot\n+  and mark_ty\n       (ty_params:Il.cell)\n       (cell:Il.cell)\n-      (slot:Ast.slot)\n+      (ty:Ast.ty)\n       (curr_iso:Ast.ty_iso option)\n       : unit =\n-    let ty = slot_ty slot in\n-      match slot_mem_ctrl slot with\n-          MEM_gc ->\n-            let tmp = next_vreg_cell Il.voidptr_t in\n+    match ty_mem_ctrl ty with\n+        MEM_gc ->\n+          let tmp = next_vreg_cell Il.voidptr_t in\n             trans_upcall \"upcall_mark\" tmp [| Il.Cell cell |];\n-              let marked_jump =\n-                trans_compare Il.JE (Il.Cell tmp) zero;\n-              in\n-                (* Iterate over exterior slots marking outgoing links. *)\n-              let (body_mem, _) =\n-                need_mem_cell\n-                  (get_element_ptr (deref cell)\n-                     Abi.exterior_gc_slot_field_body)\n-              in\n-              let ty = maybe_iso curr_iso ty in\n-              let curr_iso = maybe_enter_iso ty curr_iso in\n-                lea tmp body_mem;\n-                trans_call_simple_static_glue\n-                  (get_mark_glue ty curr_iso)\n-                  ty_params tmp;\n-                List.iter patch marked_jump;\n+            let marked_jump =\n+              trans_compare Il.JE (Il.Cell tmp) zero;\n+            in\n+              (* Iterate over exterior parts marking outgoing links. *)\n+            let (body_mem, _) =\n+              need_mem_cell\n+                (get_element_ptr (deref cell)\n+                   Abi.exterior_gc_slot_field_body)\n+            in\n+            let ty = maybe_iso curr_iso ty in\n+            let curr_iso = maybe_enter_iso ty curr_iso in\n+              lea tmp body_mem;\n+              trans_call_simple_static_glue\n+                (get_mark_glue ty curr_iso)\n+                ty_params tmp;\n+              List.iter patch marked_jump;\n \n         | MEM_interior when type_is_structured ty ->\n             (iflog (fun _ ->\n                       annotate (\"mark interior slot \" ^\n-                                  (Fmt.fmt_to_str Ast.fmt_slot slot))));\n+                                  (Fmt.fmt_to_str Ast.fmt_ty ty))));\n             let (mem, _) = need_mem_cell cell in\n             let tmp = next_vreg_cell Il.voidptr_t in\n             let ty = maybe_iso curr_iso ty in\n@@ -2704,30 +2723,6 @@ let trans_visitor\n           \"expected plausibly-exterior cell, got %s\"\n             (Il.string_of_referent_ty (Il.cell_referent_ty cell))\n \n-  and clone_slot\n-      (ty_params:Il.cell)\n-      (clone_task:Il.cell)\n-      (dst:Il.cell)\n-      (src:Il.cell)\n-      (dst_slot:Ast.slot)\n-      (curr_iso:Ast.ty_iso option)\n-      : unit =\n-    let ty = slot_ty dst_slot in\n-      match dst_slot.Ast.slot_mode with\n-          Ast.MODE_exterior _ ->\n-            let ty = maybe_iso curr_iso ty in\n-            let curr_iso = maybe_enter_iso ty curr_iso in\n-            let dst = deref_slot true dst dst_slot in\n-            let glue_fix = get_clone_glue (slot_ty dst_slot) curr_iso in\n-              trans_call_static_glue\n-                (code_fixup_to_ptr_operand glue_fix)\n-                (Some dst)\n-                [| alias ty_params; src; clone_task |]\n-\n-        | Ast.MODE_alias _ -> bug () \"cloning into alias slot\"\n-        | Ast.MODE_interior _ ->\n-            clone_ty ty_params clone_task ty dst src curr_iso\n-\n   and drop_slot_in_current_frame\n       (cell:Il.cell)\n       (slot:Ast.slot)\n@@ -2755,54 +2750,11 @@ let trans_visitor\n       (slot:Ast.slot)\n       (curr_iso:Ast.ty_iso option)\n       : unit =\n-    let ty = slot_ty slot in\n-    let ty = maybe_iso curr_iso ty in\n-    let curr_iso = maybe_enter_iso ty curr_iso in\n-    let slot = {slot with Ast.slot_ty = Some ty} in\n-    let mctrl = slot_mem_ctrl slot in\n-      match mctrl with\n-          MEM_rc_opaque\n-        | MEM_gc\n-        | MEM_rc_struct ->\n-            let _ = check_exterior_rty cell in\n-            let null_jmp = null_check cell in\n-            let rc = exterior_rc_cell cell in\n-            let j = drop_refcount_and_cmp rc in\n-\n-              (* FIXME (issue #25): check to see that the exterior has\n-               * further exterior members; if it doesn't we can elide the\n-               * call to the glue function.  *)\n-\n-              if mctrl = MEM_rc_opaque\n-              then\n-                free_ty false ty_params ty cell curr_iso\n-              else\n-                trans_call_simple_static_glue\n-                  (get_free_glue ty (mctrl = MEM_gc) curr_iso)\n-                  ty_params cell;\n-\n-              (* Null the slot out to prevent double-free if the frame\n-               * unwinds.\n-               *)\n-              mov cell zero;\n-              patch j;\n-              patch null_jmp\n-\n-        | MEM_interior when type_is_structured ty ->\n-            (iflog (fun _ ->\n-                      annotate (\"drop interior slot \" ^\n-                                  (Fmt.fmt_to_str Ast.fmt_slot slot))));\n-            let (mem, _) = need_mem_cell cell in\n-            let vr = next_vreg_cell Il.voidptr_t in\n-              lea vr mem;\n-              trans_call_simple_static_glue\n-                (get_drop_glue ty curr_iso)\n-                ty_params vr\n-\n-        | MEM_interior ->\n-            (* Interior allocation of all-interior value: free directly. *)\n-            let ty = maybe_iso curr_iso ty in\n-              drop_ty ty_params ty cell curr_iso\n+    match slot.Ast.slot_mode with\n+        Ast.MODE_alias\n+          (* Aliases are always free to drop. *)\n+      | Ast.MODE_interior ->\n+          drop_ty ty_params cell (slot_ty slot) curr_iso\n \n   and note_drop_step ty step =\n     if cx.ctxt_sess.Session.sess_trace_drop ||\n@@ -2815,62 +2767,80 @@ let trans_visitor\n           trace_str cx.ctxt_sess.Session.sess_trace_drop str\n         end\n \n-  and note_gc_step slot step =\n+  and note_gc_step ty step =\n     if cx.ctxt_sess.Session.sess_trace_gc ||\n       cx.ctxt_sess.Session.sess_log_trans\n     then\n       let mctrl_str =\n-        match slot_mem_ctrl slot with\n+        match ty_mem_ctrl ty with\n             MEM_gc -> \"MEM_gc\"\n           | MEM_rc_struct -> \"MEM_rc_struct\"\n           | MEM_rc_opaque -> \"MEM_rc_opaque\"\n           | MEM_interior -> \"MEM_interior\"\n       in\n-      let slotstr = Fmt.fmt_to_str Ast.fmt_slot slot in\n-      let str = step ^ \" \" ^ mctrl_str ^ \" \" ^ slotstr in\n+      let tystr = Fmt.fmt_to_str Ast.fmt_ty ty in\n+      let str = step ^ \" \" ^ mctrl_str ^ \" \" ^ tystr in\n         begin\n           annotate str;\n           trace_str cx.ctxt_sess.Session.sess_trace_gc str\n         end\n \n   (* Returns the offset of the slot-body in the initialized allocation. *)\n-  and init_exterior_slot (cell:Il.cell) (slot:Ast.slot) : unit =\n-    let mctrl = slot_mem_ctrl slot in\n+  and init_exterior (cell:Il.cell) (ty:Ast.ty) : unit =\n+    let mctrl = ty_mem_ctrl ty in\n       match mctrl with\n           MEM_gc\n         | MEM_rc_opaque\n         | MEM_rc_struct ->\n             let ctrl =\n               if mctrl = MEM_gc\n-              then Il.Cell (get_tydesc None (slot_ty slot))\n+              then Il.Cell (get_tydesc None ty)\n               else zero\n             in\n               iflog (fun _ -> annotate \"init exterior: malloc\");\n-              let sz = exterior_allocation_size slot in\n+              let sz = exterior_allocation_size ty in\n                 trans_malloc cell sz ctrl;\n                 iflog (fun _ -> annotate \"init exterior: load refcount\");\n                 let rc = exterior_rc_cell cell in\n                   mov rc one\n \n-      | MEM_interior -> bug () \"init_exterior_slot of MEM_interior\"\n+      | MEM_interior -> bug () \"init_exterior of MEM_interior\"\n+\n+  and deref_ty\n+      (initializing:bool)\n+      (cell:Il.cell)\n+      (ty:Ast.ty)\n+      : (Il.cell * Ast.ty) =\n+    match ty with\n+\n+      | Ast.TY_mutable ty\n+      | Ast.TY_constrained (ty, _) ->\n+          deref_ty initializing cell ty\n+\n+      | Ast.TY_exterior ty ->\n+          check_exterior_rty cell;\n+          if initializing\n+          then init_exterior cell ty;\n+          let cell =\n+            get_element_ptr_dyn_in_current_frame\n+              (deref cell)\n+              (Abi.exterior_rc_slot_field_body)\n+          in\n+            (* Init recursively so @@@@T chain works. *)\n+            deref_ty initializing cell ty\n+\n+      | _ -> (cell, ty)\n+\n \n   and deref_slot\n       (initializing:bool)\n       (cell:Il.cell)\n       (slot:Ast.slot)\n       : Il.cell =\n     match slot.Ast.slot_mode with\n-        Ast.MODE_interior _ ->\n+        Ast.MODE_interior ->\n           cell\n \n-      | Ast.MODE_exterior _ ->\n-          check_exterior_rty cell;\n-          if initializing\n-          then init_exterior_slot cell slot;\n-          get_element_ptr_dyn_in_current_frame\n-            (deref cell)\n-            Abi.exterior_rc_slot_field_body\n-\n       | Ast.MODE_alias _  ->\n           if initializing\n           then cell\n@@ -2881,24 +2851,32 @@ let trans_visitor\n       (initializing:bool)\n       (dst:Il.cell)\n       (src:Il.cell)\n-      (slots:Ast.ty_tup)\n+      (tys:Ast.ty_tup)\n       : unit =\n     Array.iteri\n       begin\n-        fun i slot ->\n+        fun i ty ->\n           let sub_dst_cell = get_element_ptr_dyn ty_params dst i in\n           let sub_src_cell = get_element_ptr_dyn ty_params src i in\n-            trans_copy_slot\n+            trans_copy_ty\n               ty_params initializing\n-              sub_dst_cell slot sub_src_cell slot None\n+              sub_dst_cell ty sub_src_cell ty None\n       end\n-      slots\n+      tys\n \n-  and trans_copy_slot\n+  and without_exterior t =\n+    match t with\n+      | Ast.TY_mutable t\n+      | Ast.TY_exterior t\n+      | Ast.TY_constrained (t, _) ->\n+          without_exterior t\n+      | _ -> t\n+\n+  and trans_copy_ty\n       (ty_params:Il.cell)\n       (initializing:bool)\n-      (dst:Il.cell) (dst_slot:Ast.slot)\n-      (src:Il.cell) (src_slot:Ast.slot)\n+      (dst:Il.cell) (dst_ty:Ast.ty)\n+      (src:Il.cell) (src_ty:Ast.ty)\n       (curr_iso:Ast.ty_iso option)\n       : unit =\n     let anno (weight:string) : unit =\n@@ -2908,13 +2886,12 @@ let trans_visitor\n             annotate\n               (Printf.sprintf \"%sweight copy: %a <- %a\"\n                  weight\n-                 Ast.sprintf_slot dst_slot\n-                 Ast.sprintf_slot src_slot)\n+                 Ast.sprintf_ty dst_ty\n+                 Ast.sprintf_ty src_ty)\n         end;\n     in\n-      assert (slot_ty src_slot = slot_ty dst_slot);\n-      match (slot_mem_ctrl src_slot,\n-             slot_mem_ctrl dst_slot) with\n+      assert (without_exterior src_ty = without_exterior dst_ty);\n+      match (ty_mem_ctrl src_ty, ty_mem_ctrl dst_ty) with\n \n         | (MEM_rc_opaque, MEM_rc_opaque)\n         | (MEM_gc, MEM_gc)\n@@ -2924,14 +2901,14 @@ let trans_visitor\n             add_to (exterior_rc_cell src) one;\n             if not initializing\n             then\n-              drop_slot ty_params dst dst_slot None;\n+              drop_ty ty_params dst dst_ty None;\n             mov dst (Il.Cell src)\n \n         | _ ->\n             (* Heavyweight copy: duplicate 1 level of the referent. *)\n             anno \"heavy\";\n-            trans_copy_slot_heavy ty_params initializing\n-              dst dst_slot src src_slot curr_iso\n+            trans_copy_ty_heavy ty_params initializing\n+              dst dst_ty src src_ty curr_iso\n \n   (* NB: heavyweight copying here does not mean \"producing a deep\n    * clone of the entire data tree rooted at the src operand\". It means\n@@ -2960,39 +2937,44 @@ let trans_visitor\n    * \n    *)\n \n-  and trans_copy_slot_heavy\n+  and trans_copy_ty_heavy\n       (ty_params:Il.cell)\n       (initializing:bool)\n-      (dst:Il.cell) (dst_slot:Ast.slot)\n-      (src:Il.cell) (src_slot:Ast.slot)\n+      (dst:Il.cell) (dst_ty:Ast.ty)\n+      (src:Il.cell) (src_ty:Ast.ty)\n       (curr_iso:Ast.ty_iso option)\n       : unit =\n-    assert (slot_ty src_slot = slot_ty dst_slot);\n+    assert (without_exterior src_ty = without_exterior dst_ty);\n     iflog (fun _ ->\n              annotate (\"heavy copy: slot preparation\"));\n \n-    let ty = slot_ty src_slot in\n+    let ty = without_exterior src_ty in\n     let ty = maybe_iso curr_iso ty in\n     let curr_iso = maybe_enter_iso ty curr_iso in\n-    let dst_slot = { dst_slot with Ast.slot_ty = Some ty } in\n-    let src_slot = { src_slot with Ast.slot_ty = Some ty } in\n-    let dst = deref_slot initializing dst dst_slot in\n-    let src = deref_slot false src src_slot in\n-      copy_ty ty_params ty dst src curr_iso\n+    let (dst, dst_ty) = deref_ty initializing dst dst_ty in\n+    let (src, src_ty) = deref_ty false src src_ty in\n+      assert (dst_ty = ty);\n+      assert (src_ty = ty);\n+      copy_ty ty_params dst src ty curr_iso\n \n   and trans_copy\n       (initializing:bool)\n       (dst:Ast.lval)\n       (src:Ast.expr)\n       : unit =\n-    let (dst_cell, dst_slot) = trans_lval_maybe_init initializing dst in\n-      match (slot_ty dst_slot, src) with\n-          (Ast.TY_vec _,\n+    let (dst_cell, dst_ty) = trans_lval_maybe_init initializing dst in\n+    let rec can_append t =\n+      match t with\n+          Ast.TY_vec _\n+        | Ast.TY_str -> true\n+        | Ast.TY_exterior t when can_append t -> true\n+        | _ -> false\n+    in\n+      match (dst_ty, src) with\n+          (t,\n            Ast.EXPR_binary (Ast.BINOP_add,\n                             Ast.ATOM_lval a, Ast.ATOM_lval b))\n-        | (Ast.TY_str,\n-           Ast.EXPR_binary (Ast.BINOP_add,\n-                            Ast.ATOM_lval a, Ast.ATOM_lval b)) ->\n+            when can_append t ->\n             (*\n              * Translate str or vec\n              * \n@@ -3003,14 +2985,14 @@ let trans_visitor\n              *   s = a;\n              *   s += b;\n              *)\n-            let (a_cell, a_slot) = trans_lval a in\n-            let (b_cell, b_slot) = trans_lval b in\n-              trans_copy_slot\n+            let (a_cell, a_ty) = trans_lval a in\n+            let (b_cell, b_ty) = trans_lval b in\n+              trans_copy_ty\n                 (get_ty_params_of_current_frame())\n-                initializing dst_cell dst_slot\n-                a_cell a_slot None;\n-              trans_vec_append dst_cell dst_slot\n-                (Il.Cell b_cell) (slot_ty b_slot)\n+                initializing dst_cell dst_ty\n+                a_cell a_ty None;\n+              trans_vec_append dst_cell dst_ty\n+                (Il.Cell b_cell) b_ty\n \n \n         | (Ast.TY_obj caller_obj_ty,\n@@ -3026,7 +3008,6 @@ let trans_visitor\n                     | _ -> bug () \"obj cast from non-obj type\"\n                 in\n                 let src_cell = need_cell (trans_atom a) in\n-                let src_slot = interior_slot src_ty in\n \n                 (* FIXME (issue #84): this is wrong. It treats the underlying\n                  * obj-state as the same as the callee and simply substitutes\n@@ -3036,16 +3017,16 @@ let trans_visitor\n                  * refcounted obj to hold the callee's vtbl+state pair, copy\n                  * that in as the state here.  *)\n                 let _ =\n-                  trans_copy_slot (get_ty_params_of_current_frame())\n+                  trans_copy_ty (get_ty_params_of_current_frame())\n                     initializing\n-                    dst_cell dst_slot\n-                    src_cell src_slot\n+                    dst_cell dst_ty\n+                    src_cell src_ty\n                 in\n                 let caller_vtbl_oper =\n                   get_forwarding_vtbl caller_obj_ty callee_obj_ty\n                 in\n-                let caller_obj =\n-                  deref_slot initializing dst_cell dst_slot\n+                let (caller_obj, _) =\n+                  deref_ty initializing dst_cell dst_ty\n                 in\n                 let caller_vtbl =\n                   get_element_ptr caller_obj Abi.binding_field_item\n@@ -3061,19 +3042,19 @@ let trans_visitor\n              * so copy is just MOV into the lval.\n              *)\n             let src_operand = trans_expr src in\n-              mov (deref_slot false dst_cell dst_slot) src_operand\n+              mov (fst (deref_ty false dst_cell dst_ty)) src_operand\n \n         | (_, Ast.EXPR_atom (Ast.ATOM_lval src_lval)) ->\n             if lval_is_direct_fn cx src_lval then\n               trans_copy_direct_fn dst_cell src_lval\n             else\n               (* Possibly-large structure copying *)\n-              let (src_cell, src_slot) = trans_lval src_lval in\n-                trans_copy_slot\n+              let (src_cell, src_ty) = trans_lval src_lval in\n+                trans_copy_ty\n                   (get_ty_params_of_current_frame())\n                   initializing\n-                  dst_cell dst_slot\n-                  src_cell src_slot\n+                  dst_cell dst_ty\n+                  src_cell src_ty\n                   None\n \n   and trans_copy_direct_fn\n@@ -3089,120 +3070,117 @@ let trans_visitor\n     let dst_pair_binding_cell =\n       get_element_ptr dst_cell Abi.binding_field_binding\n     in\n-\n       mov dst_pair_item_cell (crate_rel_imm fix);\n       mov dst_pair_binding_cell zero\n \n \n   and trans_init_structural_from_atoms\n       (dst:Il.cell)\n-      (dst_slots:Ast.slot array)\n+      (dst_tys:Ast.ty array)\n       (atoms:Ast.atom array)\n       : unit =\n     Array.iteri\n       begin\n         fun i atom ->\n-          trans_init_slot_from_atom\n-            CLONE_none\n+          trans_init_ty_from_atom\n             (get_element_ptr_dyn_in_current_frame dst i)\n-            dst_slots.(i)\n-            atom\n+            dst_tys.(i) atom\n       end\n       atoms\n \n   and trans_init_rec_update\n       (dst:Il.cell)\n-      (dst_slots:Ast.slot array)\n+      (dst_tys:Ast.ty array)\n       (trec:Ast.ty_rec)\n-      (atab:(Ast.ident * Ast.mode * bool * Ast.atom) array)\n+      (atab:(Ast.ident * Ast.atom) array)\n       (base:Ast.lval)\n       : unit =\n     Array.iteri\n       begin\n         fun i (fml_ident, _) ->\n-          let fml_entry _ (act_ident, _, _, atom) =\n+          let fml_entry _ (act_ident, atom) =\n             if act_ident = fml_ident then Some atom else None\n           in\n-          let slot = dst_slots.(i) in\n+          let dst_ty = dst_tys.(i) in\n             match arr_search atab fml_entry with\n                 Some atom ->\n-                  trans_init_slot_from_atom\n-                    CLONE_none\n+                  trans_init_ty_from_atom\n                     (get_element_ptr_dyn_in_current_frame dst i)\n-                    slot\n-                    atom\n+                    dst_ty atom\n               | None ->\n-                  let (src, _) = trans_lval base in\n-                    trans_copy_slot\n+                  let (src, src_ty) = trans_lval base in\n+                    trans_copy_ty\n                       (get_ty_params_of_current_frame()) true\n-                      (get_element_ptr_dyn_in_current_frame dst i) slot\n-                      (get_element_ptr_dyn_in_current_frame src i) slot\n+                      (get_element_ptr_dyn_in_current_frame dst i) dst_ty\n+                      (get_element_ptr_dyn_in_current_frame src i) src_ty\n                       None\n       end\n       trec\n \n-  and trans_init_slot_from_atom\n-      (clone:clone_ctrl)\n-      (dst:Il.cell) (dst_slot:Ast.slot)\n-      (atom:Ast.atom)\n+  and trans_init_ty_from_atom\n+      (dst:Il.cell) (ty:Ast.ty) (atom:Ast.atom)\n       : unit =\n-    let is_alias_cell =\n-      match dst_slot.Ast.slot_mode with\n-          Ast.MODE_alias _ -> true\n-        | _ -> false\n-    in\n-      match atom with\n-        | Ast.ATOM_literal _ ->\n-            let src = trans_atom atom in\n-              if is_alias_cell\n-              then\n-                match clone with\n-                    CLONE_none ->\n-                      (* Aliasing a literal is a bit weird since nobody\n-                       * else will ever see it, but it seems harmless.\n-                       *)\n-                      mov dst (Il.Cell (alias (Il.Mem (force_to_mem src))))\n-                  | _ ->\n-                      bug () \"attempting to clone alias cell\"\n-              else\n-                mov (deref_slot true dst dst_slot) src\n-        | Ast.ATOM_lval src_lval ->\n-            let (src, src_slot) = trans_lval src_lval in\n-              trans_init_slot_from_cell clone dst dst_slot src src_slot\n+    let src = Il.Mem (force_to_mem (trans_atom atom)) in\n+      trans_copy_ty (get_ty_params_of_current_frame())\n+       true dst ty src ty None\n \n   and trans_init_slot_from_cell\n+      (ty_params:Il.cell)\n       (clone:clone_ctrl)\n       (dst:Il.cell) (dst_slot:Ast.slot)\n-      (src:Il.cell) (src_slot:Ast.slot)\n+      (src:Il.cell) (src_ty:Ast.ty)\n       : unit =\n-    assert (slot_ty src_slot = slot_ty dst_slot);\n-    let is_alias_cell =\n-      match dst_slot.Ast.slot_mode with\n-          Ast.MODE_alias _ -> true\n-        | _ -> false\n-    in\n-      match clone with\n-          CLONE_chan clone_task ->\n+    let dst_ty = slot_ty dst_slot in\n+    assert (src_ty = dst_ty);\n+    match (dst_slot.Ast.slot_mode, clone) with\n+        (Ast.MODE_alias, CLONE_none) ->\n+          mov dst (Il.Cell (alias (Il.Mem (need_mem_cell src))))\n+\n+      | (Ast.MODE_interior, CLONE_none) ->\n+          trans_copy_ty\n+            ty_params true\n+            dst dst_ty src src_ty None\n+\n+      | (Ast.MODE_alias, _) ->\n+          bug () \"attempting to clone into alias slot\"\n+\n+      | (_, CLONE_chan clone_task) ->\n             let clone =\n-              if (type_contains_chan (slot_ty src_slot))\n+              if (type_contains_chan src_ty)\n               then CLONE_all clone_task\n               else CLONE_none\n             in\n-              trans_init_slot_from_cell clone dst dst_slot src src_slot\n-        | CLONE_none ->\n-            if is_alias_cell\n-            then mov dst (Il.Cell (alias src))\n-            else\n-              trans_copy_slot\n-                (get_ty_params_of_current_frame())\n-                true dst dst_slot src src_slot None\n-        | CLONE_all clone_task ->\n-            if is_alias_cell\n-            then bug () \"attempting to clone alias cell\"\n-            else\n-              clone_slot\n-                (get_ty_params_of_current_frame())\n-                clone_task dst src dst_slot None\n+              (* Feed back with massaged args. *)\n+              trans_init_slot_from_cell ty_params\n+                clone dst dst_slot src src_ty\n+\n+      | (_, CLONE_all clone_task) ->\n+          clone_ty ty_params clone_task dst src src_ty None\n+\n+\n+  and trans_init_slot_from_atom\n+      (clone:clone_ctrl)\n+      (dst:Il.cell) (dst_slot:Ast.slot)\n+      (src_atom:Ast.atom)\n+      : unit =\n+    match (dst_slot.Ast.slot_mode, clone, src_atom) with\n+        (Ast.MODE_alias, CLONE_none,\n+         Ast.ATOM_literal _) ->\n+          (* Aliasing a literal is a bit weird since nobody\n+           * else will ever see it, but it seems harmless.\n+           *)\n+          let src = trans_atom src_atom in\n+            mov dst (Il.Cell (alias (Il.Mem (force_to_mem src))))\n+\n+      | (Ast.MODE_alias, CLONE_chan _, _)\n+      | (Ast.MODE_alias, CLONE_all _, _) ->\n+          bug () \"attempting to clone into alias slot\"\n+      | _ ->\n+          let src = Il.Mem (force_to_mem (trans_atom src_atom)) in\n+            trans_init_slot_from_cell\n+              (get_ty_params_of_current_frame())\n+              clone dst dst_slot src (atom_type cx src_atom)\n+\n \n   and trans_be_fn\n       (cx:ctxt)\n@@ -3376,9 +3354,10 @@ let trans_visitor\n     (* Emit arg1 of any call: the task pointer. *)\n     iflog (fun _ -> annotate \"fn-call arg 1: task pointer\");\n     trans_init_slot_from_cell\n+      (get_ty_params_of_current_frame())\n       CLONE_none\n       arg_cell word_slot\n-      abi.Abi.abi_tp_cell word_slot\n+      abi.Abi.abi_tp_cell word_ty\n \n   and trans_argN\n       (clone:clone_ctrl)\n@@ -3509,9 +3488,11 @@ let trans_visitor\n                      annotate\n                        (Printf.sprintf \"fn-call ty param %d of %d\"\n                           i n_ty_params));\n-            trans_init_slot_from_cell CLONE_none\n+            trans_init_slot_from_cell\n+              (get_ty_params_of_current_frame())\n+              CLONE_none\n               (get_element_ptr callee_ty_params i) word_slot\n-              (get_tydesc None ty_param) word_slot\n+              (get_tydesc None ty_param) word_ty\n         end\n         call.call_callee_ty_params;\n \n@@ -3609,7 +3590,7 @@ let trans_visitor\n                            (Printf.sprintf\n                               \"extract bound arg %d as actual arg %d\"\n                               !bound_i arg_i));\n-                  get_element_ptr closure_args_cell (!bound_i);\n+                  get_element_ptr closure_args_cell (!bound_i)\n                 end\n               else\n                 begin\n@@ -3623,9 +3604,10 @@ let trans_visitor\n               iflog (fun _ -> annotate\n                        (Printf.sprintf\n                           \"copy into actual-arg %d\" arg_i));\n-              trans_copy_slot\n-                self_ty_params_cell\n-                true dst_cell slot src_cell slot None;\n+              trans_init_slot_from_cell\n+                self_ty_params_cell CLONE_none\n+                dst_cell slot\n+                (deref_slot false src_cell slot) (slot_ty slot);\n               incr (if is_bound then bound_i else unbound_i);\n           done;\n           assert ((!bound_i + !unbound_i) == n_args)\n@@ -3765,15 +3747,15 @@ let trans_visitor\n       let (pat, block) = arm.node in\n         (* Translates the pattern and returns the addresses of the branch\n          * instructions, which are taken if the match fails. *)\n-      let rec trans_pat pat src_cell src_slot =\n+      let rec trans_pat pat src_cell src_ty =\n         match pat with\n             Ast.PAT_lit lit ->\n               trans_compare Il.JNE (trans_lit lit) (Il.Cell src_cell)\n \n           | Ast.PAT_tag (lval, pats) ->\n               let tag_name = tag_ctor_name_to_tag_name (lval_to_name lval) in\n               let ty_tag =\n-                match slot_ty src_slot with\n+                match src_ty with\n                     Ast.TY_tag tag_ty -> tag_ty\n                   | Ast.TY_iso ti -> (ti.Ast.iso_group).(ti.Ast.iso_index)\n                   | _ -> bug cx \"expected tag type\"\n@@ -3782,9 +3764,6 @@ let trans_visitor\n               let tag_number = arr_idx tag_keys tag_name in\n               let ty_tup = Hashtbl.find ty_tag tag_name in\n \n-              (* NB: follow any exterior pointer as we go. *)\n-              let src_cell = deref_slot false src_cell src_slot in\n-\n               let tag_cell:Il.cell = get_element_ptr src_cell 0 in\n               let union_cell =\n                 get_element_ptr_dyn_in_current_frame src_cell 1\n@@ -3801,8 +3780,8 @@ let trans_visitor\n                 let elem_cell =\n                   get_element_ptr_dyn_in_current_frame tup_cell i\n                 in\n-                let elem_slot = ty_tup.(i) in\n-                  trans_pat elem_pat elem_cell elem_slot\n+                let elem_ty = ty_tup.(i) in\n+                  trans_pat elem_pat elem_cell elem_ty\n               in\n \n               let elem_jumps = Array.mapi trans_elem_pat pats in\n@@ -3811,11 +3790,10 @@ let trans_visitor\n           | Ast.PAT_slot (dst, _) ->\n               let dst_slot = get_slot cx dst.id in\n               let dst_cell = cell_of_block_slot dst.id in\n-                trans_copy_slot\n-                  (get_ty_params_of_current_frame()) true\n-                  dst_cell dst_slot\n-                  src_cell src_slot\n-                  None;\n+                trans_init_slot_from_cell\n+                  (get_ty_params_of_current_frame())\n+                  CLONE_none dst_cell dst_slot\n+                  src_cell src_ty;\n                 []                (* irrefutable *)\n \n           | Ast.PAT_wild -> []    (* irrefutable *)\n@@ -3909,16 +3887,16 @@ let trans_visitor\n     let (dst_slot, _) = fo.Ast.for_slot in\n     let dst_cell = cell_of_block_slot dst_slot.id in\n     let (head_stmts, seq) = fo.Ast.for_seq in\n-    let (seq_cell, seq_slot) = trans_lval_full false seq in\n-    let unit_slot = seq_unit_slot (slot_ty seq_slot) in\n+    let (seq_cell, seq_ty) = trans_lval_full false seq in\n+    let unit_ty = seq_unit_ty seq_ty in\n       Array.iter trans_stmt head_stmts;\n-      iter_seq_slots ty_params seq_cell seq_cell unit_slot\n+      iter_seq_parts ty_params seq_cell seq_cell unit_ty\n         begin\n-          fun _ src_cell unit_slot curr_iso ->\n-            trans_copy_slot\n-              ty_params true\n+          fun _ src_cell unit_ty _ ->\n+            trans_init_slot_from_cell\n+              ty_params CLONE_none\n               dst_cell dst_slot.node\n-              src_cell unit_slot curr_iso;\n+              src_cell unit_ty;\n             trans_block fo.Ast.for_body;\n         end\n         None\n@@ -3978,26 +3956,17 @@ let trans_visitor\n       mov vr zero;\n       trans_call_glue (code_of_operand block_fptr) None [| vr; fp |]\n \n-  and trans_vec_append dst_cell dst_slot src_oper src_ty =\n-    let (dst_elt_slot, trim_trailing_null) =\n-      match slot_ty dst_slot with\n-          Ast.TY_str -> (interior_slot (Ast.TY_mach TY_u8), true)\n-        | Ast.TY_vec e -> (e, false)\n-        | _ ->  bug () \"unexpected dst type in trans_vec_append\"\n-    in\n+  and trans_vec_append dst_cell dst_ty src_oper src_ty =\n+    let elt_ty = seq_unit_ty dst_ty in\n+    let trim_trailing_null = dst_ty = Ast.TY_str in\n+      assert (src_ty = dst_ty);\n       match src_ty with\n           Ast.TY_str\n         | Ast.TY_vec _ ->\n             let is_gc = if type_has_state src_ty then 1L else 0L in\n             let src_cell = need_cell src_oper in\n             let src_vec = deref src_cell in\n             let src_fill = get_element_ptr src_vec Abi.vec_elt_fill in\n-            let src_elt_slot =\n-              match src_ty with\n-                  Ast.TY_str -> interior_slot (Ast.TY_mach TY_u8)\n-                | Ast.TY_vec e -> e\n-                | _ -> bug () \"unexpected src type in trans_vec_append\"\n-            in\n             let dst_vec = deref dst_cell in\n             let dst_fill = get_element_ptr dst_vec Abi.vec_elt_fill in\n               if trim_trailing_null\n@@ -4018,12 +3987,11 @@ let trans_visitor\n               let dst_fill = get_element_ptr dst_vec Abi.vec_elt_fill in\n \n               (* Copy loop: *)\n-              let pty s = Il.AddrTy (slot_referent_type abi s) in\n-              let dptr = next_vreg_cell (pty dst_elt_slot) in\n-              let sptr = next_vreg_cell (pty src_elt_slot) in\n-              let dlim = next_vreg_cell (pty dst_elt_slot) in\n-              let dst_elt_sz = slot_sz_in_current_frame dst_elt_slot in\n-              let src_elt_sz = slot_sz_in_current_frame src_elt_slot in\n+              let eltp_rty = Il.AddrTy (referent_type abi elt_ty) in\n+              let dptr = next_vreg_cell eltp_rty in\n+              let sptr = next_vreg_cell eltp_rty in\n+              let dlim = next_vreg_cell eltp_rty in\n+              let elt_sz = ty_sz_in_current_frame elt_ty in\n               let dst_data =\n                 get_element_ptr_dyn_in_current_frame\n                   dst_vec Abi.vec_elt_data\n@@ -4041,20 +4009,20 @@ let trans_visitor\n                   emit (Il.jmp Il.JMP Il.CodeNone);\n                   let back_jmp_targ = mark () in\n                     (* copy slot *)\n-                    trans_copy_slot\n+                    trans_copy_ty\n                       (get_ty_params_of_current_frame()) true\n-                      (deref dptr) dst_elt_slot\n-                      (deref sptr) src_elt_slot\n+                      (deref dptr) elt_ty\n+                      (deref sptr) elt_ty\n                       None;\n-                    add_to dptr dst_elt_sz;\n-                    add_to sptr src_elt_sz;\n+                    add_to dptr elt_sz;\n+                    add_to sptr elt_sz;\n                     patch fwd_jmp;\n                     check_interrupt_flag ();\n                     let back_jmp =\n                       trans_compare Il.JB (Il.Cell dptr) (Il.Cell dlim) in\n                       List.iter\n                         (fun j -> patch_existing j back_jmp_targ) back_jmp;\n-                      let v = next_vreg_cell word_ty in\n+                      let v = next_vreg_cell word_sty in\n                         mov v (Il.Cell src_fill);\n                         add_to dst_fill (Il.Cell v);\n         | t ->\n@@ -4064,14 +4032,14 @@ let trans_visitor\n \n \n   and trans_copy_binop dst binop a_src =\n-    let (dst_cell, dst_slot) = trans_lval_maybe_init false dst in\n+    let (dst_cell, dst_ty) = trans_lval_maybe_init false dst in\n     let src_oper = trans_atom a_src in\n-      match slot_ty dst_slot with\n+      match dst_ty with\n           Ast.TY_str\n         | Ast.TY_vec _ when binop = Ast.BINOP_add ->\n-            trans_vec_append dst_cell dst_slot src_oper (atom_type cx a_src)\n+            trans_vec_append dst_cell dst_ty src_oper (atom_type cx a_src)\n         | _ ->\n-            let dst_cell = deref_slot false dst_cell dst_slot in\n+            let (dst_cell, _) = deref_ty false dst_cell dst_ty in\n             let op = trans_binop binop in\n               emit (Il.binary op dst_cell (Il.Cell dst_cell) src_oper);\n \n@@ -4159,46 +4127,43 @@ let trans_visitor\n           end\n \n       | Ast.STMT_init_rec (dst, atab, base) ->\n-          let (slot_cell, slot) = trans_lval_init dst in\n-          let (trec, dst_slots) =\n-            match slot_ty slot with\n+          let (slot_cell, ty) = trans_lval_init dst in\n+          let (trec, dst_tys) =\n+            match ty with\n                 Ast.TY_rec trec -> (trec, Array.map snd trec)\n               | _ ->\n                   bugi cx stmt.id\n                     \"non-rec destination type in stmt_init_rec\"\n           in\n-          let dst_cell = deref_slot true slot_cell slot in\n+          let (dst_cell, _) = deref_ty true slot_cell ty in\n             begin\n               match base with\n                   None ->\n-                    let atoms =\n-                      Array.map (fun (_, _, _, atom) -> atom) atab\n-                    in\n+                    let atoms = Array.map snd atab in\n                       trans_init_structural_from_atoms\n-                        dst_cell dst_slots atoms\n+                        dst_cell dst_tys atoms\n                 | Some base_lval ->\n                     trans_init_rec_update\n-                      dst_cell dst_slots trec atab base_lval\n+                      dst_cell dst_tys trec atab base_lval\n             end\n \n-      | Ast.STMT_init_tup (dst, mode_atoms) ->\n-          let (slot_cell, slot) = trans_lval_init dst in\n-          let dst_slots =\n-            match slot_ty slot with\n+      | Ast.STMT_init_tup (dst, atoms) ->\n+          let (slot_cell, ty) = trans_lval_init dst in\n+          let dst_tys =\n+            match ty with\n                 Ast.TY_tup ttup -> ttup\n               | _ ->\n                   bugi cx stmt.id\n                     \"non-tup destination type in stmt_init_tup\"\n           in\n-          let atoms = Array.map (fun (_, _, atom) -> atom) mode_atoms in\n-          let dst_cell = deref_slot true slot_cell slot in\n-            trans_init_structural_from_atoms dst_cell dst_slots atoms\n+          let (dst_cell, _) = deref_ty true slot_cell ty in\n+            trans_init_structural_from_atoms dst_cell dst_tys atoms\n \n \n       | Ast.STMT_init_str (dst, s) ->\n           trans_init_str dst s\n \n-      | Ast.STMT_init_vec (dst, _, atoms) ->\n+      | Ast.STMT_init_vec (dst, atoms) ->\n           trans_init_vec dst atoms\n \n       | Ast.STMT_init_port dst ->\n@@ -4424,7 +4389,7 @@ let trans_visitor\n \n   let trans_obj_ctor\n       (obj_id:node_id)\n-      (state:Ast.header_slots)\n+      (header:Ast.header_slots)\n       : unit =\n     trans_frame_entry obj_id;\n \n@@ -4439,21 +4404,14 @@ let trans_visitor\n         all_args_cell Abi.calltup_elt_ty_params\n     in\n \n-    let obj_args_tup = Array.map (fun (sloti,_) -> sloti.node) state in\n-    let obj_args_slot = interior_slot (Ast.TY_tup obj_args_tup) in\n-    let state_ty =\n-      Ast.TY_tup [| interior_slot Ast.TY_type;\n-                    obj_args_slot |]\n-    in\n-    let state_rty = slot_referent_type abi (interior_slot state_ty) in\n-    let state_ptr_slot = exterior_slot state_ty in\n-    let state_ptr_rty = slot_referent_type abi state_ptr_slot in\n-    let state_malloc_sz =\n-      calculate_sz_in_current_frame\n-        (SIZE_rt_add\n-           ((SIZE_fixed (word_n Abi.exterior_rc_header_size)),\n-            (Il.referent_ty_size word_bits state_rty)))\n+    let obj_args_tup =\n+      Array.map (fun (sloti,_) -> (slot_ty sloti.node)) header\n     in\n+    let obj_args_ty = Ast.TY_tup obj_args_tup in\n+    let state_ty = Ast.TY_tup [| Ast.TY_type; obj_args_ty |] in\n+    let state_ptr_ty = Ast.TY_exterior state_ty in\n+    let state_ptr_rty = referent_type abi state_ptr_ty in\n+    let state_malloc_sz = exterior_allocation_size state_ty in\n \n     let ctor_ty = Hashtbl.find cx.ctxt_all_item_types obj_id in\n     let obj_ty =\n@@ -4508,10 +4466,17 @@ let trans_visitor\n            * because the arg slot ids are actually given layout\n            * positions inside the object state, and are at different\n            * offsets within that state than within the current\n-           * frame. So we manually drop the argument tuple here,\n-           * without mentioning the arg slot ids.\n+           * frame. So we manually drop the argument slots here,\n+           * without mentioning the slot ids.\n            *)\n-          drop_slot frame_ty_params frame_args obj_args_slot None;\n+          Array.iteri\n+            (fun i (sloti, _) ->\n+               let cell =\n+                 get_element_ptr_dyn_in_current_frame\n+                   frame_args i\n+               in\n+                 drop_slot frame_ty_params cell sloti.node None)\n+            header;\n           trans_frame_exit obj_id false;\n   in\n \n@@ -4682,27 +4647,32 @@ let trans_visitor\n         | Ast.TY_iso tiso -> get_iso_tag tiso\n         | _ -> bugi cx tagid \"unexpected fn type for tag constructor\"\n     in\n-    let slots =\n-      Array.map (fun sloti -> referent_to_slot cx sloti.id) header_tup\n-    in\n     let tag_keys = sorted_htab_keys ttag in\n     let i = arr_idx tag_keys (Ast.NAME_base (Ast.BASE_ident n)) in\n     let _ = log cx \"tag variant: %s -> tag value #%d\" n i in\n     let (dst_cell, dst_slot) = get_current_output_cell_and_slot() in\n     let dst_cell = deref_slot true dst_cell dst_slot in\n-    let src = get_explicit_args_for_current_frame () in\n     let tag_cell = get_element_ptr dst_cell 0 in\n     let union_cell = get_element_ptr_dyn_in_current_frame dst_cell 1 in\n     let tag_body_cell = get_variant_ptr union_cell i in\n     let tag_body_rty = snd (need_mem_cell tag_body_cell) in\n+    let ty_params = get_ty_params_of_current_frame() in\n       (* A clever compiler will inline this. We are not clever. *)\n       iflog (fun _ -> annotate (Printf.sprintf \"write tag #%d\" i));\n       mov tag_cell (imm (Int64.of_int i));\n       iflog (fun _ -> annotate (\"copy tag-content tuple: tag_body_rty=\" ^\n                                   (Il.string_of_referent_ty tag_body_rty)));\n-      trans_copy_tup\n-        (get_ty_params_of_current_frame())\n-        true tag_body_cell src slots;\n+      Array.iteri\n+        begin\n+          fun i sloti ->\n+            let slot = sloti.node in\n+            let ty = slot_ty slot in\n+              trans_copy_ty ty_params true\n+                (get_element_ptr_dyn_in_current_frame tag_body_cell i) ty\n+                (deref_slot false (cell_of_block_slot sloti.id) slot) ty\n+                None;\n+        end\n+        header_tup;\n       trace_str cx.ctxt_sess.Session.sess_trace_tag\n         (\"finished tag constructor \" ^ n);\n       trans_frame_exit tagid true;"}, {"sha": "8c6b8bc3175d5079480bd878f41203a84338d8ce", "filename": "src/boot/me/transutil.ml", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fme%2Ftransutil.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fme%2Ftransutil.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftransutil.ml?ref=1f9fd2710ec9122ddddcedaab51650a92ad7c8cf", "patch": "@@ -112,29 +112,35 @@ let word_ty_signed_mach (abi:Abi.abi) : ty_mach =\n ;;\n \n \n-let slot_mem_ctrl (slot:Ast.slot) : mem_ctrl =\n-  let ty = slot_ty slot in\n-    match ty with\n-        Ast.TY_port _\n-      | Ast.TY_chan _\n-      | Ast.TY_task\n-      | Ast.TY_str -> MEM_rc_opaque\n-      | Ast.TY_vec _ ->\n-          if type_has_state ty\n-          then MEM_gc\n+let rec ty_mem_ctrl (ty:Ast.ty) : mem_ctrl =\n+  match ty with\n+      Ast.TY_port _\n+    | Ast.TY_chan _\n+    | Ast.TY_task\n+    | Ast.TY_str -> MEM_rc_opaque\n+    | Ast.TY_vec _ ->\n+        if type_has_state ty\n+        then MEM_gc\n+        else MEM_rc_opaque\n+    | Ast.TY_exterior t ->\n+        if type_has_state t\n+        then MEM_gc\n+        else\n+          if type_is_structured t\n+          then MEM_rc_struct\n           else MEM_rc_opaque\n-      | _ ->\n-          match slot.Ast.slot_mode with\n-              Ast.MODE_exterior _ when type_is_structured ty ->\n-                if type_has_state ty\n-                then MEM_gc\n-                else MEM_rc_struct\n-            | Ast.MODE_exterior _ ->\n-                if type_has_state ty\n-                then MEM_gc\n-                else MEM_rc_opaque\n-            | _ ->\n-                MEM_interior\n+    | Ast.TY_mutable t\n+    | Ast.TY_constrained (t, _) ->\n+        ty_mem_ctrl t\n+    | _ ->\n+        MEM_interior\n+;;\n+\n+let slot_mem_ctrl (slot:Ast.slot) : mem_ctrl =\n+  match slot.Ast.slot_mode with\n+      Ast.MODE_alias -> MEM_interior\n+    | Ast.MODE_interior ->\n+        ty_mem_ctrl (slot_ty slot)\n ;;\n \n \n@@ -200,33 +206,33 @@ let next_power_of_two (x:int64) : int64 =\n     Int64.add 1L (!xr)\n ;;\n \n-let iter_tup_slots\n+let iter_tup_parts\n     (get_element_ptr:'a -> int -> 'a)\n     (dst_ptr:'a)\n     (src_ptr:'a)\n     (slots:Ast.ty_tup)\n-    (f:'a -> 'a -> Ast.slot -> (Ast.ty_iso option) -> unit)\n+    (f:'a -> 'a -> Ast.ty -> (Ast.ty_iso option) -> unit)\n     (curr_iso:Ast.ty_iso option)\n     : unit =\n   Array.iteri\n     begin\n-      fun i slot ->\n+      fun i ty ->\n         f (get_element_ptr dst_ptr i)\n           (get_element_ptr src_ptr i)\n-          slot curr_iso\n+          ty curr_iso\n     end\n     slots\n ;;\n \n-let iter_rec_slots\n+let iter_rec_parts\n     (get_element_ptr:'a -> int -> 'a)\n     (dst_ptr:'a)\n     (src_ptr:'a)\n     (entries:Ast.ty_rec)\n-    (f:'a -> 'a -> Ast.slot -> (Ast.ty_iso option) -> unit)\n+    (f:'a -> 'a -> Ast.ty -> (Ast.ty_iso option) -> unit)\n     (curr_iso:Ast.ty_iso option)\n     : unit =\n-  iter_tup_slots get_element_ptr dst_ptr src_ptr\n+  iter_tup_parts get_element_ptr dst_ptr src_ptr\n     (Array.map snd entries) f curr_iso\n ;;\n "}, {"sha": "5311a4a4fb4f18e70df126e17bd36b7957843b82", "filename": "src/boot/me/type.ml", "status": "modified", "additions": 50, "deletions": 35, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fme%2Ftype.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fme%2Ftype.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftype.ml?ref=1f9fd2710ec9122ddddcedaab51650a92ad7c8cf", "patch": "@@ -33,6 +33,23 @@ type binopsig =\n   | BINOPSIG_plus_plus_plus     (* plusable a * plusable a -> plusable a *)\n ;;\n \n+\n+(* In some instances we will strip off a layer of mutability or exterior-ness,\n+ * as trans is willing to transplant and/or overlook mutability / exterior\n+ * differences wrt. many operators.\n+ * \n+ * Note: there is a secondary mutability-checking pass in effect.ml to ensure\n+ * you're not actually mutating the insides of an immutable. That's not the\n+ * typechecker's job.\n+ *)\n+let simplified t =\n+  match t with\n+      Ast.TY_mutable (Ast.TY_exterior t) -> t\n+    | Ast.TY_mutable t -> t\n+    | Ast.TY_exterior t -> t\n+    | _ -> t\n+;;\n+\n let rec tyspec_to_str (ts:tyspec) : string =\n \n   let fmt = Format.fprintf in\n@@ -253,17 +270,14 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n           (dct:dict)\n           (fields:Ast.ty_rec)\n           : unit =\n-        let rec find_slot (query:Ast.ident) i : Ast.slot =\n-          if i = Array.length fields\n-          then fail ()\n-          else match fields.(i) with\n-              (ident, slot) ->\n-                if ident = query then slot\n-                else find_slot query (i + 1)\n+        let find_ty (query:Ast.ident) : Ast.ty =\n+          match atab_search fields query with\n+              None -> fail()\n+            | Some t -> t\n         in\n \n         let check_entry ident tv =\n-          unify_slot (find_slot ident 0) None tv\n+          unify_ty (find_ty ident) tv\n         in\n           Hashtbl.iter check_entry dct\n       in\n@@ -290,18 +304,20 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n           | Ast.TY_fn _ | Ast.TY_obj _\n           | Ast.TY_param _ | Ast.TY_native _ | Ast.TY_type -> false\n           | Ast.TY_named _ -> bug () \"unexpected named type\"\n+          | Ast.TY_exterior ty\n+          | Ast.TY_mutable ty\n           | Ast.TY_constrained (ty, _) ->\n               is_comparable_or_ordered comparable ty\n       in\n \n       let floating (ty:Ast.ty) : bool =\n-        match ty with\n+        match simplified ty with\n             Ast.TY_mach TY_f32 | Ast.TY_mach TY_f64 -> true\n           | _ -> false\n       in\n \n       let integral (ty:Ast.ty) : bool =\n-        match ty with\n+        match simplified ty with\n             Ast.TY_int | Ast.TY_uint | Ast.TY_mach TY_u8 | Ast.TY_mach TY_u16\n           | Ast.TY_mach TY_u32 | Ast.TY_mach TY_u64 | Ast.TY_mach TY_i8\n           | Ast.TY_mach TY_i16 | Ast.TY_mach TY_i32\n@@ -313,7 +329,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n       let numeric (ty:Ast.ty) : bool = (integral ty) || (floating ty) in\n \n       let plusable (ty:Ast.ty) : bool =\n-        match ty with\n+        match simplified ty with\n             Ast.TY_str -> true\n           | Ast.TY_vec _ -> true\n           | _ -> numeric ty\n@@ -369,7 +385,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n           | (TYSPEC_collection tv, TYSPEC_resolved (params, ty)) ->\n               begin\n                 match ty with\n-                    Ast.TY_vec slot -> unify_slot slot None tv\n+                    Ast.TY_vec ty -> unify_ty ty tv\n                   | Ast.TY_str -> unify_ty (Ast.TY_mach TY_u8) tv\n                   | _ -> fail ()\n               end;\n@@ -439,12 +455,12 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n           | (TYSPEC_tuple tvs, TYSPEC_resolved (params, ty)) ->\n               begin\n                 match ty with\n-                    Ast.TY_tup (elem_slots:Ast.slot array) ->\n-                      if (Array.length elem_slots) < (Array.length tvs)\n+                    Ast.TY_tup (elem_tys:Ast.ty array) ->\n+                      if (Array.length elem_tys) <> (Array.length tvs)\n                       then fail ()\n                       else\n                         let check_elem i tv =\n-                          unify_slot (elem_slots.(i)) None tv\n+                          unify_ty (elem_tys.(i)) tv\n                         in\n                           Array.iteri check_elem tvs\n                   | _ -> fail ()\n@@ -455,9 +471,9 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n           | (TYSPEC_vector tv, TYSPEC_resolved (params, ty)) ->\n               begin\n                 match ty with\n-                    Ast.TY_vec slot ->\n-                      unify_slot slot None tv;\n-                      TYSPEC_resolved (params, ty)\n+                    Ast.TY_vec ty ->\n+                      unify_ty ty tv;\n+                      TYSPEC_resolved (params, Ast.TY_vec ty)\n                   | _ -> fail ()\n               end\n \n@@ -942,7 +958,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                 unify_lval' base base_tv;\n                 match !(resolve_tyvar base_tv) with\n                     TYSPEC_resolved (_, ty) ->\n-                      unify_ty (slot_ty (project_type_to_slot ty comp)) tv\n+                      unify_ty (project_type ty comp) tv\n                   | _ ->\n                       ()\n \n@@ -981,7 +997,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n         | Ast.STMT_init_rec (lval, fields, Some base) ->\n             let dct = Hashtbl.create 10 in\n             let tvrec = ref (TYSPEC_record dct) in\n-            let add_field (ident, _, _, atom) =\n+            let add_field (ident, atom) =\n               let tv = ref TYSPEC_all in\n                 unify_atom atom tv;\n                 Hashtbl.add dct ident tv\n@@ -994,7 +1010,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n \n         | Ast.STMT_init_rec (lval, fields, None) ->\n             let dct = Hashtbl.create 10 in\n-            let add_field (ident, _, _, atom) =\n+            let add_field (ident, atom) =\n               let tv = ref TYSPEC_all in\n                 unify_atom atom tv;\n                 Hashtbl.add dct ident tv\n@@ -1003,15 +1019,15 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n               unify_lval lval (ref (TYSPEC_record dct))\n \n         | Ast.STMT_init_tup (lval, members) ->\n-            let member_to_tv (_, _, atom) =\n+            let member_to_tv atom =\n               let tv = ref TYSPEC_all in\n                 unify_atom atom tv;\n                 tv\n             in\n             let member_tvs = Array.map member_to_tv members in\n               unify_lval lval (ref (TYSPEC_tuple member_tvs))\n \n-        | Ast.STMT_init_vec (lval, _, atoms) ->\n+        | Ast.STMT_init_vec (lval, atoms) ->\n             let tv = ref TYSPEC_all in\n             let unify_with_tv atom = unify_atom atom tv in\n               Array.iter unify_with_tv atoms;\n@@ -1181,8 +1197,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                     Ast.TY_fn (tsig, _) ->\n                       begin\n                         let vec_str =\n-                          interior_slot (Ast.TY_vec\n-                                           (interior_slot Ast.TY_str))\n+                          interior_slot (Ast.TY_vec Ast.TY_str)\n                         in\n                           match tsig.Ast.sig_input_slots with\n                               [| |] -> ()\n@@ -1236,13 +1251,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                 let tag_tv = ref TYSPEC_all in\n                   unify_ty tag_ty tag_tv;\n                   unify_tyvars expected tag_tv;\n-                  List.iter\n-                    begin\n-                      fun slot ->\n-                        match slot.Ast.slot_ty with\n-                          Some ty -> expect ty\n-                          | None -> bug () \"no slot type in tag slot tuple\"\n-                    end\n+                  List.iter expect\n                     (List.rev (Array.to_list tag_ty_tup));\n \n           | Ast.PAT_slot (sloti, _) ->\n@@ -1336,8 +1345,14 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n           let defn = Hashtbl.find cx.ctxt_all_defns id in\n             match defn with\n                 DEFN_slot slot_defn ->\n-                  Hashtbl.replace cx.ctxt_all_defns id\n-                    (DEFN_slot { slot_defn with Ast.slot_ty = Some ty })\n+                  begin\n+                    match slot_defn.Ast.slot_ty with\n+                        Some _ -> ()\n+                      | None ->\n+                          Hashtbl.replace cx.ctxt_all_defns id\n+                            (DEFN_slot { slot_defn with\n+                                           Ast.slot_ty = Some ty })\n+                  end\n               | _ -> bug () \"check_auto_tyvar: no slot defn\"\n         in\n \n@@ -1349,7 +1364,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n                   begin\n                     match !(resolve_tyvar tv) with\n                         TYSPEC_resolved ([||], ty) ->\n-                          (Ast.TY_vec (interior_slot ty))\n+                          (Ast.TY_vec ty)\n                       | _ ->\n                           err (Some id)\n                             \"unresolved vector-element type in %s (%d)\""}, {"sha": "79e4784566eeb7f717262f8224e61977a4dc4b3a", "filename": "src/boot/me/typestate.ml", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fme%2Ftypestate.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fme%2Ftypestate.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftypestate.ml?ref=1f9fd2710ec9122ddddcedaab51650a92ad7c8cf", "patch": "@@ -419,7 +419,7 @@ let condition_assigning_visitor\n               raise_precondition s.id precond;\n               raise_postcondition s.id postcond\n \n-        | Ast.STMT_init_vec (dst, _, atoms) ->\n+        | Ast.STMT_init_vec (dst, atoms) ->\n             let precond = slot_inits (atoms_slots cx atoms) in\n             let postcond = slot_inits (lval_slots cx dst) in\n               raise_precondition s.id precond;\n@@ -980,13 +980,19 @@ let lifecycle_visitor\n                 if initializing\n                 then\n                   begin\n-                    Hashtbl.add cx.ctxt_copy_stmt_is_init s.id ();\n+                    iflog cx\n+                      begin\n+                        fun _ ->\n+                          log cx \"noting lval %a init at stmt %a\"\n+                            Ast.sprintf_lval lv_dst Ast.sprintf_stmt s\n+                      end;\n+                    Hashtbl.replace cx.ctxt_copy_stmt_is_init s.id ();\n                     init_lval lv_dst\n                   end;\n \n           | Ast.STMT_init_rec (lv_dst, _, _)\n           | Ast.STMT_init_tup (lv_dst, _)\n-          | Ast.STMT_init_vec (lv_dst, _, _)\n+          | Ast.STMT_init_vec (lv_dst, _)\n           | Ast.STMT_init_str (lv_dst, _)\n           | Ast.STMT_init_port lv_dst\n           | Ast.STMT_init_chan (lv_dst, _) ->"}, {"sha": "64c08724a7274d55934b478c95a013e353cc42a0", "filename": "src/boot/me/walk.ml", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fme%2Fwalk.ml", "raw_url": "https://github.com/rust-lang/rust/raw/1f9fd2710ec9122ddddcedaab51650a92ad7c8cf/src%2Fboot%2Fme%2Fwalk.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fwalk.ml?ref=1f9fd2710ec9122ddddcedaab51650a92ad7c8cf", "patch": "@@ -262,7 +262,7 @@ and walk_mod_item\n       item\n \n \n-and walk_ty_tup v ttup = Array.iter (walk_slot v) ttup\n+and walk_ty_tup v ttup = Array.iter (walk_ty v) ttup\n \n and walk_ty_tag v ttag = Hashtbl.iter (fun _ t -> walk_ty_tup v t) ttag\n \n@@ -273,8 +273,8 @@ and walk_ty\n   let children _ =\n     match ty with\n         Ast.TY_tup ttup -> walk_ty_tup v ttup\n-      | Ast.TY_vec s -> walk_slot v s\n-      | Ast.TY_rec trec -> Array.iter (fun (_, s) -> walk_slot v s) trec\n+      | Ast.TY_vec s -> walk_ty v s\n+      | Ast.TY_rec trec -> Array.iter (fun (_, s) -> walk_ty v s) trec\n       | Ast.TY_tag ttag -> walk_ty_tag v ttag\n       | Ast.TY_iso tiso -> Array.iter (walk_ty_tag v) tiso.Ast.iso_group\n       | Ast.TY_fn tfn -> walk_ty_fn v tfn\n@@ -301,6 +301,8 @@ and walk_ty\n       | Ast.TY_nil -> ()\n       | Ast.TY_task -> ()\n       | Ast.TY_any -> ()\n+      | Ast.TY_exterior m -> walk_ty v m\n+      | Ast.TY_mutable m -> walk_ty v m\n   in\n     walk_bracketed\n       v.visit_ty_pre\n@@ -448,16 +450,16 @@ and walk_stmt\n \n       | Ast.STMT_init_rec (lv, atab, base) ->\n           walk_lval v lv;\n-          Array.iter (fun (_, _, _, a) -> walk_atom v a) atab;\n+          Array.iter (fun (_, a) -> walk_atom v a) atab;\n           walk_option (walk_lval v) base;\n \n-      | Ast.STMT_init_vec (lv, _, atoms) ->\n+      | Ast.STMT_init_vec (lv, atoms) ->\n           walk_lval v lv;\n           Array.iter (walk_atom v) atoms\n \n       | Ast.STMT_init_tup (lv, mut_atoms) ->\n           walk_lval v lv;\n-          Array.iter (fun (_, _, a) -> walk_atom v a) mut_atoms\n+          Array.iter (walk_atom v) mut_atoms\n \n       | Ast.STMT_init_str (lv, _) ->\n           walk_lval v lv\n@@ -469,6 +471,10 @@ and walk_stmt\n           walk_option (walk_lval v) port;\n           walk_lval v chan;\n \n+      | Ast.STMT_init_exterior (dst, src) ->\n+          walk_lval v dst;\n+          walk_atom v src\n+\n       | Ast.STMT_for f ->\n           walk_stmt_for f\n "}]}