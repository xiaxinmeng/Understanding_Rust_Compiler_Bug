{"sha": "80e5fe1a56bb95e8e89d5f8f0ff5122583bb5336", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwZTVmZTFhNTZiYjk1ZThlODlkNWY4ZjBmZjUxMjI1ODNiYjUzMzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-25T09:17:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-25T09:17:05Z"}, "message": "auto merge of #18176 : jkleint/rust/guide-borrow-wording, r=steveklabnik\n\nExplain the primary disadvantage of garbage collection is runtime\r\noverhead and unpredictable pauses.  Elucidate where the name \"race\r\ncondition\" comes from.  Emphasize that Rust can guarantee your code is\r\nfree of race conditions and other memory errors, with no runtime\r\noverhead.\r\n\r\ncc @steveklabnik", "tree": {"sha": "87294493552bcaf817cd1605507277c451174d46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87294493552bcaf817cd1605507277c451174d46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80e5fe1a56bb95e8e89d5f8f0ff5122583bb5336", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80e5fe1a56bb95e8e89d5f8f0ff5122583bb5336", "html_url": "https://github.com/rust-lang/rust/commit/80e5fe1a56bb95e8e89d5f8f0ff5122583bb5336", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80e5fe1a56bb95e8e89d5f8f0ff5122583bb5336/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a34b8dec697014f15e725215e17ea8d956c0ab1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a34b8dec697014f15e725215e17ea8d956c0ab1a", "html_url": "https://github.com/rust-lang/rust/commit/a34b8dec697014f15e725215e17ea8d956c0ab1a"}, {"sha": "f0b7065e6f2d8dcd64c536bb4ce3066186850a09", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0b7065e6f2d8dcd64c536bb4ce3066186850a09", "html_url": "https://github.com/rust-lang/rust/commit/f0b7065e6f2d8dcd64c536bb4ce3066186850a09"}], "stats": {"total": 33, "additions": 18, "deletions": 15}, "files": [{"sha": "c7b8e42b28cde24c6f10f488cb32c14910d01e2b", "filename": "src/doc/guide.md", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/80e5fe1a56bb95e8e89d5f8f0ff5122583bb5336/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/80e5fe1a56bb95e8e89d5f8f0ff5122583bb5336/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=80e5fe1a56bb95e8e89d5f8f0ff5122583bb5336", "patch": "@@ -3466,13 +3466,14 @@ for destroying that resource as well. Given that we're discussing pointers\n right now, let's discuss this in the context of memory allocation, though\n it applies to other resources as well.\n \n-When you allocate heap memory, you need a mechanism to free that memory.  Many\n-languages let the programmer control the allocation, and then use a garbage\n-collector to handle the deallocation. This is a valid, time-tested strategy,\n-but it's not without its drawbacks. Because the programmer does not have to\n-think as much about deallocation, allocation becomes something commonplace,\n-because it's easy. And if you need precise control over when something is\n-deallocated, leaving it up to your runtime can make this difficult.\n+When you allocate heap memory, you need a mechanism to free that memory. Many\n+languages use a garbage collector to handle deallocation. This is a valid,\n+time-tested strategy, but it's not without its drawbacks: it adds overhead, and\n+can lead to unpredictable pauses in execution. Because the programmer does not\n+have to think as much about deallocation, allocation becomes something\n+commonplace, leading to more memory usage. And if you need precise control\n+over when something is deallocated, leaving it up to your runtime can make this\n+difficult.\n \n Rust chooses a different path, and that path is called **ownership**. Any\n binding that creates a resource is the **owner** of that resource.\n@@ -3498,17 +3499,19 @@ memory. The length of time that the borrower is borrowing the pointer\n from you is called a **lifetime**.\n \n If two distinct bindings share a pointer, and the memory that pointer points to\n-is immutable, then there are no problems. But if it's mutable, both pointers\n-can attempt to write to the memory at the same time, causing a **race\n-condition**. Therefore, if someone wants to mutate something that they've\n-borrowed from you, you must not have lent out that pointer to anyone else.\n+is immutable, then there are no problems. But if it's mutable, the result of\n+changing it can vary unpredictably depending on who happens to access it first,\n+which is called a **race condition**. To avoid this, if someone wants to mutate\n+something that they've borrowed from you, you must not have lent out that\n+pointer to anyone else.\n \n Rust has a sophisticated system called the **borrow checker** to make sure that\n everyone plays by these rules. At compile time, it verifies that none of these\n-rules are broken. If there's no problem, our program compiles successfully, and\n-there is no runtime overhead for any of this. The borrow checker works only at\n-compile time. If the borrow checker did find a problem, it will report a\n-**lifetime error**, and your program will refuse to compile.\n+rules are broken. If our program compiles successfully, Rust can guarantee it\n+is free of data races and other memory errors, and there is no runtime overhead\n+for any of this. The borrow checker works only at compile time. If the borrow\n+checker did find a problem, it will report a **lifetime error**, and your\n+program will refuse to compile.\n \n That's a lot to take in. It's also one of the _most_ important concepts in\n all of Rust. Let's see this syntax in action:"}]}