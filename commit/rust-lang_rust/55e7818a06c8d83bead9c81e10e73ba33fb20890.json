{"sha": "55e7818a06c8d83bead9c81e10e73ba33fb20890", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ZTc4MThhMDZjOGQ4M2JlYWQ5YzgxZTEwZTczYmEzM2ZiMjA4OTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-15T08:16:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-15T08:16:39Z"}, "message": "Auto merge of #4619 - james9909:unused-self, r=flip1995\n\nAdd a lint for unused self\n\nchangelog: Adds a new lint: `unused_self`\n\nCloses #4550.", "tree": {"sha": "3a6db731f92fc6f71c69e5413f3b4e846c0c430d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a6db731f92fc6f71c69e5413f3b4e846c0c430d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55e7818a06c8d83bead9c81e10e73ba33fb20890", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55e7818a06c8d83bead9c81e10e73ba33fb20890", "html_url": "https://github.com/rust-lang/rust/commit/55e7818a06c8d83bead9c81e10e73ba33fb20890", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55e7818a06c8d83bead9c81e10e73ba33fb20890/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7", "html_url": "https://github.com/rust-lang/rust/commit/8fae2dd3c1bfed13bdd6c0cfd4170dd1363f25f7"}, {"sha": "adf58868e9fc380ef51af75a9727ddd16d87cdce", "url": "https://api.github.com/repos/rust-lang/rust/commits/adf58868e9fc380ef51af75a9727ddd16d87cdce", "html_url": "https://github.com/rust-lang/rust/commit/adf58868e9fc380ef51af75a9727ddd16d87cdce"}], "stats": {"total": 456, "additions": 373, "deletions": 83}, "files": [{"sha": "9dd04af611f415014c795202819059dd1f041778", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55e7818a06c8d83bead9c81e10e73ba33fb20890/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/55e7818a06c8d83bead9c81e10e73ba33fb20890/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=55e7818a06c8d83bead9c81e10e73ba33fb20890", "patch": "@@ -1236,6 +1236,7 @@ Released 2018-09-13\n [`unused_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_collect\n [`unused_io_amount`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_io_amount\n [`unused_label`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_label\n+[`unused_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_self\n [`unused_unit`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_unit\n [`use_debug`]: https://rust-lang.github.io/rust-clippy/master/index.html#use_debug\n [`use_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#use_self"}, {"sha": "986d920ac9682cdbf084fa97fc53a9e77667ea01", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55e7818a06c8d83bead9c81e10e73ba33fb20890/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/55e7818a06c8d83bead9c81e10e73ba33fb20890/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=55e7818a06c8d83bead9c81e10e73ba33fb20890", "patch": "@@ -6,7 +6,7 @@\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are 324 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+[There are 325 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n \n We have a bunch of lint categories to allow you to choose how much Clippy is supposed to ~~annoy~~ help you:\n "}, {"sha": "a1e4be260b490f45865eee4d38ffd4b545d783e1", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=55e7818a06c8d83bead9c81e10e73ba33fb20890", "patch": "@@ -39,7 +39,7 @@ declare_lint_pass!(DoubleComparisons => [DOUBLE_COMPARISONS]);\n \n impl<'a, 'tcx> DoubleComparisons {\n     #[allow(clippy::similar_names)]\n-    fn check_binop(self, cx: &LateContext<'a, 'tcx>, op: BinOpKind, lhs: &'tcx Expr, rhs: &'tcx Expr, span: Span) {\n+    fn check_binop(cx: &LateContext<'a, 'tcx>, op: BinOpKind, lhs: &'tcx Expr, rhs: &'tcx Expr, span: Span) {\n         let (lkind, llhs, lrhs, rkind, rlhs, rrhs) = match (&lhs.kind, &rhs.kind) {\n             (ExprKind::Binary(lb, llhs, lrhs), ExprKind::Binary(rb, rlhs, rrhs)) => {\n                 (lb.node, llhs, lrhs, rb.node, rlhs, rrhs)\n@@ -89,7 +89,7 @@ impl<'a, 'tcx> DoubleComparisons {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DoubleComparisons {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = expr.kind {\n-            self.check_binop(cx, kind.node, lhs, rhs, expr.span);\n+            Self::check_binop(cx, kind.node, lhs, rhs, expr.span);\n         }\n     }\n }"}, {"sha": "64f340dffa131de85a59afc42d2c1768ecfcaac2", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=55e7818a06c8d83bead9c81e10e73ba33fb20890", "patch": "@@ -32,20 +32,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EnumGlobUse {\n         let map = cx.tcx.hir();\n         // only check top level `use` statements\n         for item in &m.item_ids {\n-            self.lint_item(cx, map.expect_item(item.id));\n+            lint_item(cx, map.expect_item(item.id));\n         }\n     }\n }\n \n-impl EnumGlobUse {\n-    fn lint_item(self, cx: &LateContext<'_, '_>, item: &Item) {\n-        if item.vis.node.is_pub() {\n-            return; // re-exports are fine\n-        }\n-        if let ItemKind::Use(ref path, UseKind::Glob) = item.kind {\n-            if let Res::Def(DefKind::Enum, _) = path.res {\n-                span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n-            }\n+fn lint_item(cx: &LateContext<'_, '_>, item: &Item) {\n+    if item.vis.node.is_pub() {\n+        return; // re-exports are fine\n+    }\n+    if let ItemKind::Use(ref path, UseKind::Glob) = item.kind {\n+        if let Res::Def(DefKind::Enum, _) = path.res {\n+            span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n         }\n     }\n }"}, {"sha": "fcc247974c5783068f73800a7248602025e1041a", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=55e7818a06c8d83bead9c81e10e73ba33fb20890", "patch": "@@ -44,7 +44,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExcessivePrecision {\n             if let ty::Float(fty) = ty.kind;\n             if let hir::ExprKind::Lit(ref lit) = expr.kind;\n             if let LitKind::Float(sym, _) | LitKind::FloatUnsuffixed(sym) = lit.node;\n-            if let Some(sugg) = self.check(sym, fty);\n+            if let Some(sugg) = Self::check(sym, fty);\n             then {\n                 span_lint_and_sugg(\n                     cx,\n@@ -63,7 +63,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExcessivePrecision {\n impl ExcessivePrecision {\n     // None if nothing to lint, Some(suggestion) if lint necessary\n     #[must_use]\n-    fn check(self, sym: Symbol, fty: FloatTy) -> Option<String> {\n+    fn check(sym: Symbol, fty: FloatTy) -> Option<String> {\n         let max = max_digits(fty);\n         let sym_str = sym.as_str();\n         if dot_zero_exclusion(&sym_str) {"}, {"sha": "5b2619aa9ba7a97f15930f26893c327969c96438", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=55e7818a06c8d83bead9c81e10e73ba33fb20890", "patch": "@@ -222,7 +222,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n             }\n         }\n \n-        self.check_raw_ptr(cx, unsafety, decl, body, hir_id);\n+        Self::check_raw_ptr(cx, unsafety, decl, body, hir_id);\n         self.check_line_number(cx, span, body);\n     }\n \n@@ -282,7 +282,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n             }\n             if let hir::TraitMethod::Provided(eid) = *eid {\n                 let body = cx.tcx.hir().body(eid);\n-                self.check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.hir_id);\n+                Self::check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.hir_id);\n \n                 if attr.is_none() && cx.access_levels.is_exported(item.hir_id) {\n                     check_must_use_candidate(\n@@ -368,7 +368,6 @@ impl<'a, 'tcx> Functions {\n     }\n \n     fn check_raw_ptr(\n-        self,\n         cx: &LateContext<'a, 'tcx>,\n         unsafety: hir::Unsafety,\n         decl: &'tcx hir::FnDecl,"}, {"sha": "93e09315f86c504b30bffd99f1d98a5b8426c8b7", "filename": "clippy_lints/src/int_plus_one.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fint_plus_one.rs?ref=55e7818a06c8d83bead9c81e10e73ba33fb20890", "patch": "@@ -53,25 +53,25 @@ enum Side {\n \n impl IntPlusOne {\n     #[allow(clippy::cast_sign_loss)]\n-    fn check_lit(self, lit: &Lit, target_value: i128) -> bool {\n+    fn check_lit(lit: &Lit, target_value: i128) -> bool {\n         if let LitKind::Int(value, ..) = lit.kind {\n             return value == (target_value as u128);\n         }\n         false\n     }\n \n-    fn check_binop(self, cx: &EarlyContext<'_>, binop: BinOpKind, lhs: &Expr, rhs: &Expr) -> Option<String> {\n+    fn check_binop(cx: &EarlyContext<'_>, binop: BinOpKind, lhs: &Expr, rhs: &Expr) -> Option<String> {\n         match (binop, &lhs.kind, &rhs.kind) {\n             // case where `x - 1 >= ...` or `-1 + x >= ...`\n             (BinOpKind::Ge, &ExprKind::Binary(ref lhskind, ref lhslhs, ref lhsrhs), _) => {\n                 match (lhskind.node, &lhslhs.kind, &lhsrhs.kind) {\n                     // `-1 + x`\n-                    (BinOpKind::Add, &ExprKind::Lit(ref lit), _) if self.check_lit(lit, -1) => {\n-                        self.generate_recommendation(cx, binop, lhsrhs, rhs, Side::LHS)\n+                    (BinOpKind::Add, &ExprKind::Lit(ref lit), _) if Self::check_lit(lit, -1) => {\n+                        Self::generate_recommendation(cx, binop, lhsrhs, rhs, Side::LHS)\n                     },\n                     // `x - 1`\n-                    (BinOpKind::Sub, _, &ExprKind::Lit(ref lit)) if self.check_lit(lit, 1) => {\n-                        self.generate_recommendation(cx, binop, lhslhs, rhs, Side::LHS)\n+                    (BinOpKind::Sub, _, &ExprKind::Lit(ref lit)) if Self::check_lit(lit, 1) => {\n+                        Self::generate_recommendation(cx, binop, lhslhs, rhs, Side::LHS)\n                     },\n                     _ => None,\n                 }\n@@ -82,11 +82,11 @@ impl IntPlusOne {\n             {\n                 match (&rhslhs.kind, &rhsrhs.kind) {\n                     // `y + 1` and `1 + y`\n-                    (&ExprKind::Lit(ref lit), _) if self.check_lit(lit, 1) => {\n-                        self.generate_recommendation(cx, binop, rhsrhs, lhs, Side::RHS)\n+                    (&ExprKind::Lit(ref lit), _) if Self::check_lit(lit, 1) => {\n+                        Self::generate_recommendation(cx, binop, rhsrhs, lhs, Side::RHS)\n                     },\n-                    (_, &ExprKind::Lit(ref lit)) if self.check_lit(lit, 1) => {\n-                        self.generate_recommendation(cx, binop, rhslhs, lhs, Side::RHS)\n+                    (_, &ExprKind::Lit(ref lit)) if Self::check_lit(lit, 1) => {\n+                        Self::generate_recommendation(cx, binop, rhslhs, lhs, Side::RHS)\n                     },\n                     _ => None,\n                 }\n@@ -97,11 +97,11 @@ impl IntPlusOne {\n             {\n                 match (&lhslhs.kind, &lhsrhs.kind) {\n                     // `1 + x` and `x + 1`\n-                    (&ExprKind::Lit(ref lit), _) if self.check_lit(lit, 1) => {\n-                        self.generate_recommendation(cx, binop, lhsrhs, rhs, Side::LHS)\n+                    (&ExprKind::Lit(ref lit), _) if Self::check_lit(lit, 1) => {\n+                        Self::generate_recommendation(cx, binop, lhsrhs, rhs, Side::LHS)\n                     },\n-                    (_, &ExprKind::Lit(ref lit)) if self.check_lit(lit, 1) => {\n-                        self.generate_recommendation(cx, binop, lhslhs, rhs, Side::LHS)\n+                    (_, &ExprKind::Lit(ref lit)) if Self::check_lit(lit, 1) => {\n+                        Self::generate_recommendation(cx, binop, lhslhs, rhs, Side::LHS)\n                     },\n                     _ => None,\n                 }\n@@ -110,12 +110,12 @@ impl IntPlusOne {\n             (BinOpKind::Le, _, &ExprKind::Binary(ref rhskind, ref rhslhs, ref rhsrhs)) => {\n                 match (rhskind.node, &rhslhs.kind, &rhsrhs.kind) {\n                     // `-1 + y`\n-                    (BinOpKind::Add, &ExprKind::Lit(ref lit), _) if self.check_lit(lit, -1) => {\n-                        self.generate_recommendation(cx, binop, rhsrhs, lhs, Side::RHS)\n+                    (BinOpKind::Add, &ExprKind::Lit(ref lit), _) if Self::check_lit(lit, -1) => {\n+                        Self::generate_recommendation(cx, binop, rhsrhs, lhs, Side::RHS)\n                     },\n                     // `y - 1`\n-                    (BinOpKind::Sub, _, &ExprKind::Lit(ref lit)) if self.check_lit(lit, 1) => {\n-                        self.generate_recommendation(cx, binop, rhslhs, lhs, Side::RHS)\n+                    (BinOpKind::Sub, _, &ExprKind::Lit(ref lit)) if Self::check_lit(lit, 1) => {\n+                        Self::generate_recommendation(cx, binop, rhslhs, lhs, Side::RHS)\n                     },\n                     _ => None,\n                 }\n@@ -125,7 +125,6 @@ impl IntPlusOne {\n     }\n \n     fn generate_recommendation(\n-        self,\n         cx: &EarlyContext<'_>,\n         binop: BinOpKind,\n         node: &Expr,\n@@ -149,7 +148,7 @@ impl IntPlusOne {\n         None\n     }\n \n-    fn emit_warning(self, cx: &EarlyContext<'_>, block: &Expr, recommendation: String) {\n+    fn emit_warning(cx: &EarlyContext<'_>, block: &Expr, recommendation: String) {\n         span_lint_and_then(\n             cx,\n             INT_PLUS_ONE,\n@@ -170,8 +169,8 @@ impl IntPlusOne {\n impl EarlyLintPass for IntPlusOne {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, item: &Expr) {\n         if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = item.kind {\n-            if let Some(ref rec) = self.check_binop(cx, kind.node, lhs, rhs) {\n-                self.emit_warning(cx, item, rec.clone());\n+            if let Some(ref rec) = Self::check_binop(cx, kind.node, lhs, rhs) {\n+                Self::emit_warning(cx, item, rec.clone());\n             }\n         }\n     }"}, {"sha": "e8962c6e2071d97038b2d2e5e4aa2d5ade97189e", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=55e7818a06c8d83bead9c81e10e73ba33fb20890", "patch": "@@ -277,6 +277,7 @@ pub mod unicode;\n pub mod unsafe_removed_from_name;\n pub mod unused_io_amount;\n pub mod unused_label;\n+pub mod unused_self;\n pub mod unwrap;\n pub mod use_self;\n pub mod vec;\n@@ -606,6 +607,7 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n     reg.register_late_lint_pass(box trait_bounds::TraitBounds);\n     reg.register_late_lint_pass(box comparison_chain::ComparisonChain);\n     reg.register_late_lint_pass(box mul_add::MulAddCheck);\n+    reg.register_late_lint_pass(box unused_self::UnusedSelf);\n \n     reg.register_lint_group(\"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -683,6 +685,7 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         types::LINKEDLIST,\n         unicode::NON_ASCII_LITERAL,\n         unicode::UNICODE_NOT_NFC,\n+        unused_self::UNUSED_SELF,\n         use_self::USE_SELF,\n     ]);\n "}, {"sha": "badd2237073c57abc99029057a54ba3dc81355d0", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=55e7818a06c8d83bead9c81e10e73ba33fb20890", "patch": "@@ -350,13 +350,13 @@ impl EarlyLintPass for LiteralDigitGrouping {\n         }\n \n         if let ExprKind::Lit(ref lit) = expr.kind {\n-            self.check_lit(cx, lit)\n+            Self::check_lit(cx, lit)\n         }\n     }\n }\n \n impl LiteralDigitGrouping {\n-    fn check_lit(self, cx: &EarlyContext<'_>, lit: &Lit) {\n+    fn check_lit(cx: &EarlyContext<'_>, lit: &Lit) {\n         let in_macro = in_macro(lit.span);\n         match lit.kind {\n             LitKind::Int(..) => {"}, {"sha": "2f43daf4caf78259035919cf9c5877bed205a87c", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=55e7818a06c8d83bead9c81e10e73ba33fb20890", "patch": "@@ -437,7 +437,7 @@ impl EarlyLintPass for MiscEarlyLints {\n                     );\n                 }\n             },\n-            ExprKind::Lit(ref lit) => self.check_lit(cx, lit),\n+            ExprKind::Lit(ref lit) => Self::check_lit(cx, lit),\n             _ => (),\n         }\n     }\n@@ -469,7 +469,7 @@ impl EarlyLintPass for MiscEarlyLints {\n }\n \n impl MiscEarlyLints {\n-    fn check_lit(self, cx: &EarlyContext<'_>, lit: &Lit) {\n+    fn check_lit(cx: &EarlyContext<'_>, lit: &Lit) {\n         // We test if first character in snippet is a number, because the snippet could be an expansion\n         // from a built-in macro like `line!()` or a proc-macro like `#[wasm_bindgen]`.\n         // Note that this check also covers special case that `line!()` is eagerly expanded by compiler."}, {"sha": "5ed95a674b73fcd08cc77b7903bb01f505a0bb6a", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=55e7818a06c8d83bead9c81e10e73ba33fb20890", "patch": "@@ -117,7 +117,7 @@ impl Return {\n             ast::ExprKind::Ret(ref inner) => {\n                 // allow `#[cfg(a)] return a; #[cfg(b)] return b;`\n                 if !expr.attrs.iter().any(attr_is_cfg) {\n-                    self.emit_return_lint(\n+                    Self::emit_return_lint(\n                         cx,\n                         span.expect(\"`else return` is not possible\"),\n                         inner.as_ref().map(|i| i.span),\n@@ -146,13 +146,7 @@ impl Return {\n         }\n     }\n \n-    fn emit_return_lint(\n-        &mut self,\n-        cx: &EarlyContext<'_>,\n-        ret_span: Span,\n-        inner_span: Option<Span>,\n-        replacement: RetReplacement,\n-    ) {\n+    fn emit_return_lint(cx: &EarlyContext<'_>, ret_span: Span, inner_span: Option<Span>, replacement: RetReplacement) {\n         match inner_span {\n             Some(inner_span) => {\n                 if in_external_macro(cx.sess(), inner_span) || inner_span.from_expansion() {\n@@ -191,7 +185,7 @@ impl Return {\n     }\n \n     // Check for \"let x = EXPR; x\"\n-    fn check_let_return(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n+    fn check_let_return(cx: &EarlyContext<'_>, block: &ast::Block) {\n         let mut it = block.stmts.iter();\n \n         // we need both a let-binding stmt and an expr\n@@ -275,7 +269,7 @@ impl EarlyLintPass for Return {\n     }\n \n     fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n-        self.check_let_return(cx, block);\n+        Self::check_let_return(cx, block);\n         if_chain! {\n             if let Some(ref stmt) = block.stmts.last();\n             if let ast::StmtKind::Expr(ref expr) = stmt.kind;"}, {"sha": "41d8980e7463178bbdd85136af09d570ade84dde", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=55e7818a06c8d83bead9c81e10e73ba33fb20890", "patch": "@@ -244,7 +244,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n \n             // Check that take is applied to `repeat(0)`\n             if let Some(ref repeat_expr) = take_args.get(0);\n-            if self.is_repeat_zero(repeat_expr);\n+            if Self::is_repeat_zero(repeat_expr);\n \n             // Check that len expression is equals to `with_capacity` expression\n             if let Some(ref len_arg) = take_args.get(1);\n@@ -259,7 +259,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     }\n \n     /// Returns `true` if given expression is `repeat(0)`\n-    fn is_repeat_zero(&self, expr: &Expr) -> bool {\n+    fn is_repeat_zero(expr: &Expr) -> bool {\n         if_chain! {\n             if let ExprKind::Call(ref fn_expr, ref repeat_args) = expr.kind;\n             if let ExprKind::Path(ref qpath_repeat) = fn_expr.kind;"}, {"sha": "06b11b6c38c14c3116c6604fbff934f06a21f8db", "filename": "clippy_lints/src/unused_self.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Funused_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Funused_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_self.rs?ref=55e7818a06c8d83bead9c81e10e73ba33fb20890", "patch": "@@ -0,0 +1,102 @@\n+use if_chain::if_chain;\n+use rustc::hir::def::Res;\n+use rustc::hir::intravisit::{walk_path, NestedVisitorMap, Visitor};\n+use rustc::hir::{AssocItemKind, HirId, ImplItemKind, ImplItemRef, Item, ItemKind, Path};\n+use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::{declare_lint_pass, declare_tool_lint};\n+\n+use crate::utils::span_help_and_lint;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks methods that contain a `self` argument but don't use it\n+    ///\n+    /// **Why is this bad?** It may be clearer to define the method as an associated function instead\n+    /// of an instance method if it doesn't require `self`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// struct A;\n+    /// impl A {\n+    ///     fn method(&self) {}\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust,ignore\n+    /// struct A;\n+    /// impl A {\n+    ///     fn method() {}\n+    /// }\n+    /// ```\n+    pub UNUSED_SELF,\n+    pedantic,\n+    \"methods that contain a `self` argument but don't use it\"\n+}\n+\n+declare_lint_pass!(UnusedSelf => [UNUSED_SELF]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedSelf {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &Item) {\n+        if item.span.from_expansion() {\n+            return;\n+        }\n+        if let ItemKind::Impl(_, _, _, _, None, _, ref impl_item_refs) = item.kind {\n+            for impl_item_ref in impl_item_refs {\n+                if_chain! {\n+                    if let ImplItemRef {\n+                        kind: AssocItemKind::Method { has_self: true },\n+                        ..\n+                    } = impl_item_ref;\n+                    let impl_item = cx.tcx.hir().impl_item(impl_item_ref.id);\n+                    if let ImplItemKind::Method(_, body_id) = &impl_item.kind;\n+                    then {\n+                        let body = cx.tcx.hir().body(*body_id);\n+                        let self_param = &body.params[0];\n+                        let self_hir_id = self_param.pat.hir_id;\n+                        let mut visitor = UnusedSelfVisitor {\n+                            cx,\n+                            uses_self: false,\n+                            self_hir_id: &self_hir_id,\n+                        };\n+                        visitor.visit_body(body);\n+                        if !visitor.uses_self {\n+                            span_help_and_lint(\n+                                cx,\n+                                UNUSED_SELF,\n+                                self_param.span,\n+                                \"unused `self` argument\",\n+                                \"consider refactoring to a associated function\",\n+                            )\n+                        }\n+                    }\n+                }\n+            }\n+        };\n+    }\n+}\n+\n+struct UnusedSelfVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    uses_self: bool,\n+    self_hir_id: &'a HirId,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for UnusedSelfVisitor<'a, 'tcx> {\n+    fn visit_path(&mut self, path: &'tcx Path, _id: HirId) {\n+        if self.uses_self {\n+            // This function already uses `self`\n+            return;\n+        }\n+        if let Res::Local(hir_id) = &path.res {\n+            self.uses_self = self.self_hir_id == hir_id\n+        }\n+        walk_path(self, path);\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.cx.tcx.hir())\n+    }\n+}"}, {"sha": "0e8fcf8fd0fcf6f4cf0c7deb827a50f2f5460e6d", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e7818a06c8d83bead9c81e10e73ba33fb20890/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=55e7818a06c8d83bead9c81e10e73ba33fb20890", "patch": "@@ -169,13 +169,13 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n \n     fn eq_generic_arg(&mut self, left: &GenericArg, right: &GenericArg) -> bool {\n         match (left, right) {\n-            (GenericArg::Lifetime(l_lt), GenericArg::Lifetime(r_lt)) => self.eq_lifetime(l_lt, r_lt),\n+            (GenericArg::Lifetime(l_lt), GenericArg::Lifetime(r_lt)) => Self::eq_lifetime(l_lt, r_lt),\n             (GenericArg::Type(l_ty), GenericArg::Type(r_ty)) => self.eq_ty(l_ty, r_ty),\n             _ => false,\n         }\n     }\n \n-    fn eq_lifetime(&mut self, left: &Lifetime, right: &Lifetime) -> bool {\n+    fn eq_lifetime(left: &Lifetime, right: &Lifetime) -> bool {\n         left.name == right.name\n     }\n "}, {"sha": "d9ae1f70d42b64e886305846be6eb634504c48f3", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/55e7818a06c8d83bead9c81e10e73ba33fb20890/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e7818a06c8d83bead9c81e10e73ba33fb20890/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=55e7818a06c8d83bead9c81e10e73ba33fb20890", "patch": "@@ -6,7 +6,7 @@ pub use lint::Lint;\n pub use lint::LINT_LEVELS;\n \n // begin lint list, do not remove this comment, it\u2019s used in `update_lints`\n-pub const ALL_LINTS: [Lint; 324] = [\n+pub const ALL_LINTS: [Lint; 325] = [\n     Lint {\n         name: \"absurd_extreme_comparisons\",\n         group: \"correctness\",\n@@ -2086,6 +2086,13 @@ pub const ALL_LINTS: [Lint; 324] = [\n         deprecation: None,\n         module: \"unused_label\",\n     },\n+    Lint {\n+        name: \"unused_self\",\n+        group: \"pedantic\",\n+        desc: \"methods that contain a `self` argument but don\\'t use it\",\n+        deprecation: None,\n+        module: \"unused_self\",\n+    },\n     Lint {\n         name: \"unused_unit\",\n         group: \"style\","}, {"sha": "54a58e0c86a800eaf929f4aba48016990ef05255", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55e7818a06c8d83bead9c81e10e73ba33fb20890/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e7818a06c8d83bead9c81e10e73ba33fb20890/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=55e7818a06c8d83bead9c81e10e73ba33fb20890", "patch": "@@ -14,6 +14,7 @@\n     clippy::use_self,\n     clippy::useless_format,\n     clippy::wrong_self_convention,\n+    clippy::unused_self,\n     unused\n )]\n "}, {"sha": "c3dc08be00b90c0a40a1de775a7190364541e3c5", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/55e7818a06c8d83bead9c81e10e73ba33fb20890/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/55e7818a06c8d83bead9c81e10e73ba33fb20890/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=55e7818a06c8d83bead9c81e10e73ba33fb20890", "patch": "@@ -1,5 +1,5 @@\n error: defining a method called `add` on this type; consider implementing the `std::ops::Add` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:37:5\n+  --> $DIR/methods.rs:38:5\n    |\n LL | /     pub fn add(self, other: T) -> T {\n LL | |         self\n@@ -9,7 +9,7 @@ LL | |     }\n    = note: `-D clippy::should-implement-trait` implied by `-D warnings`\n \n error: methods called `new` usually return `Self`\n-  --> $DIR/methods.rs:153:5\n+  --> $DIR/methods.rs:154:5\n    |\n LL | /     fn new() -> i32 {\n LL | |         0\n@@ -19,7 +19,7 @@ LL | |     }\n    = note: `-D clippy::new-ret-no-self` implied by `-D warnings`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:175:13\n+  --> $DIR/methods.rs:176:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -31,7 +31,7 @@ LL | |                .unwrap_or(0);\n    = note: replace `map(|x| x + 1).unwrap_or(0)` with `map_or(0, |x| x + 1)`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:179:13\n+  --> $DIR/methods.rs:180:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -41,7 +41,7 @@ LL | |               ).unwrap_or(0);\n    | |____________________________^\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:183:13\n+  --> $DIR/methods.rs:184:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -51,15 +51,15 @@ LL | |                 });\n    | |__________________^\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:188:13\n+  --> $DIR/methods.rs:189:13\n    |\n LL |     let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:190:13\n+  --> $DIR/methods.rs:191:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -69,7 +69,7 @@ LL | |     ).unwrap_or(None);\n    | |_____________________^\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:194:13\n+  --> $DIR/methods.rs:195:13\n    |\n LL |       let _ = opt\n    |  _____________^\n@@ -80,15 +80,15 @@ LL | |         .unwrap_or(None);\n    = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:205:13\n+  --> $DIR/methods.rs:206:13\n    |\n LL |     let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `map(|p| format!(\"{}.\", p)).unwrap_or(id)` with `map_or(id, |p| format!(\"{}.\", p))`\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:209:13\n+  --> $DIR/methods.rs:210:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -100,7 +100,7 @@ LL | |                .unwrap_or_else(|| 0);\n    = note: replace `map(|x| x + 1).unwrap_or_else(|| 0)` with `map_or_else(|| 0, |x| x + 1)`\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:213:13\n+  --> $DIR/methods.rs:214:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -110,7 +110,7 @@ LL | |               ).unwrap_or_else(|| 0);\n    | |____________________________________^\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:217:13\n+  --> $DIR/methods.rs:218:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -120,7 +120,7 @@ LL | |                 );\n    | |_________________^\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:247:13\n+  --> $DIR/methods.rs:248:13\n    |\n LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -129,7 +129,7 @@ LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    = note: replace `filter(|&x| *x < 0).next()` with `find(|&x| *x < 0)`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:250:13\n+  --> $DIR/methods.rs:251:13\n    |\n LL |       let _ = v.iter().filter(|&x| {\n    |  _____________^\n@@ -139,33 +139,33 @@ LL | |                    ).next();\n    | |___________________________^\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:267:22\n+  --> $DIR/methods.rs:268:22\n    |\n LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x < 0)`\n    |\n    = note: `-D clippy::search-is-some` implied by `-D warnings`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:268:20\n+  --> $DIR/methods.rs:269:20\n    |\n LL |     let _ = (0..1).find(|x| **y == *x).is_some(); // one dereference less\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| **y == x)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:269:20\n+  --> $DIR/methods.rs:270:20\n    |\n LL |     let _ = (0..1).find(|x| *x == 0).is_some();\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| x == 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:270:22\n+  --> $DIR/methods.rs:271:22\n    |\n LL |     let _ = v.iter().find(|x| **x == 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x == 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:273:13\n+  --> $DIR/methods.rs:274:13\n    |\n LL |       let _ = v.iter().find(|&x| {\n    |  _____________^\n@@ -175,13 +175,13 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:279:22\n+  --> $DIR/methods.rs:280:22\n    |\n LL |     let _ = v.iter().position(|&x| x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:282:13\n+  --> $DIR/methods.rs:283:13\n    |\n LL |       let _ = v.iter().position(|&x| {\n    |  _____________^\n@@ -191,13 +191,13 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:288:22\n+  --> $DIR/methods.rs:289:22\n    |\n LL |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:291:13\n+  --> $DIR/methods.rs:292:13\n    |\n LL |       let _ = v.iter().rposition(|&x| {\n    |  _____________^\n@@ -207,7 +207,7 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n-  --> $DIR/methods.rs:306:13\n+  --> $DIR/methods.rs:307:13\n    |\n LL |     let _ = opt.unwrap();\n    |             ^^^^^^^^^^^^"}, {"sha": "9119c43c082ca4c87cbc04238baba20c5f21555b", "filename": "tests/ui/unused_self.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/55e7818a06c8d83bead9c81e10e73ba33fb20890/tests%2Fui%2Funused_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e7818a06c8d83bead9c81e10e73ba33fb20890/tests%2Fui%2Funused_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_self.rs?ref=55e7818a06c8d83bead9c81e10e73ba33fb20890", "patch": "@@ -0,0 +1,111 @@\n+#![warn(clippy::unused_self)]\n+#![allow(clippy::boxed_local)]\n+\n+mod unused_self {\n+    use std::pin::Pin;\n+    use std::sync::{Arc, Mutex};\n+\n+    struct A {}\n+\n+    impl A {\n+        fn unused_self_move(self) {}\n+        fn unused_self_ref(&self) {}\n+        fn unused_self_mut_ref(&mut self) {}\n+        fn unused_self_pin_ref(self: Pin<&Self>) {}\n+        fn unused_self_pin_mut_ref(self: Pin<&mut Self>) {}\n+        fn unused_self_pin_nested(self: Pin<Arc<Self>>) {}\n+        fn unused_self_box(self: Box<Self>) {}\n+        fn unused_with_other_used_args(&self, x: u8, y: u8) -> u8 {\n+            x + y\n+        }\n+        fn unused_self_class_method(&self) {\n+            Self::static_method();\n+        }\n+\n+        fn static_method() {}\n+    }\n+}\n+\n+mod used_self {\n+    use std::pin::Pin;\n+\n+    struct A {\n+        x: u8,\n+    }\n+\n+    impl A {\n+        fn used_self_move(self) -> u8 {\n+            self.x\n+        }\n+        fn used_self_ref(&self) -> u8 {\n+            self.x\n+        }\n+        fn used_self_mut_ref(&mut self) {\n+            self.x += 1\n+        }\n+        fn used_self_pin_ref(self: Pin<&Self>) -> u8 {\n+            self.x\n+        }\n+        fn used_self_box(self: Box<Self>) -> u8 {\n+            self.x\n+        }\n+        fn used_self_with_other_unused_args(&self, x: u8, y: u8) -> u8 {\n+            self.x\n+        }\n+        fn used_in_nested_closure(&self) -> u8 {\n+            let mut a = || -> u8 { self.x };\n+            a()\n+        }\n+\n+        #[allow(clippy::collapsible_if)]\n+        fn used_self_method_nested_conditions(&self, a: bool, b: bool, c: bool, d: bool) {\n+            if a {\n+                if b {\n+                    if c {\n+                        if d {\n+                            self.used_self_ref();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        fn foo(&self) -> u32 {\n+            let mut sum = 0u32;\n+            for i in 0..self.x {\n+                sum += i as u32;\n+            }\n+            sum\n+        }\n+\n+        fn bar(&mut self, x: u8) -> u32 {\n+            let mut y = 0u32;\n+            for i in 0..x {\n+                y += self.foo()\n+            }\n+            y\n+        }\n+    }\n+}\n+\n+mod not_applicable {\n+    use std::fmt;\n+\n+    struct A {}\n+\n+    impl fmt::Debug for A {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            write!(f, \"A\")\n+        }\n+    }\n+\n+    impl A {\n+        fn method(x: u8, y: u8) {}\n+    }\n+\n+    trait B {\n+        fn method(&self) {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "0534b40eabb75ebb2de8465990b82f185f89c97e", "filename": "tests/ui/unused_self.stderr", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/55e7818a06c8d83bead9c81e10e73ba33fb20890/tests%2Fui%2Funused_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/55e7818a06c8d83bead9c81e10e73ba33fb20890/tests%2Fui%2Funused_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_self.stderr?ref=55e7818a06c8d83bead9c81e10e73ba33fb20890", "patch": "@@ -0,0 +1,75 @@\n+error: unused `self` argument\n+  --> $DIR/unused_self.rs:11:29\n+   |\n+LL |         fn unused_self_move(self) {}\n+   |                             ^^^^\n+   |\n+   = note: `-D clippy::unused-self` implied by `-D warnings`\n+   = help: consider refactoring to a associated function\n+\n+error: unused `self` argument\n+  --> $DIR/unused_self.rs:12:28\n+   |\n+LL |         fn unused_self_ref(&self) {}\n+   |                            ^^^^^\n+   |\n+   = help: consider refactoring to a associated function\n+\n+error: unused `self` argument\n+  --> $DIR/unused_self.rs:13:32\n+   |\n+LL |         fn unused_self_mut_ref(&mut self) {}\n+   |                                ^^^^^^^^^\n+   |\n+   = help: consider refactoring to a associated function\n+\n+error: unused `self` argument\n+  --> $DIR/unused_self.rs:14:32\n+   |\n+LL |         fn unused_self_pin_ref(self: Pin<&Self>) {}\n+   |                                ^^^^\n+   |\n+   = help: consider refactoring to a associated function\n+\n+error: unused `self` argument\n+  --> $DIR/unused_self.rs:15:36\n+   |\n+LL |         fn unused_self_pin_mut_ref(self: Pin<&mut Self>) {}\n+   |                                    ^^^^\n+   |\n+   = help: consider refactoring to a associated function\n+\n+error: unused `self` argument\n+  --> $DIR/unused_self.rs:16:35\n+   |\n+LL |         fn unused_self_pin_nested(self: Pin<Arc<Self>>) {}\n+   |                                   ^^^^\n+   |\n+   = help: consider refactoring to a associated function\n+\n+error: unused `self` argument\n+  --> $DIR/unused_self.rs:17:28\n+   |\n+LL |         fn unused_self_box(self: Box<Self>) {}\n+   |                            ^^^^\n+   |\n+   = help: consider refactoring to a associated function\n+\n+error: unused `self` argument\n+  --> $DIR/unused_self.rs:18:40\n+   |\n+LL |         fn unused_with_other_used_args(&self, x: u8, y: u8) -> u8 {\n+   |                                        ^^^^^\n+   |\n+   = help: consider refactoring to a associated function\n+\n+error: unused `self` argument\n+  --> $DIR/unused_self.rs:21:37\n+   |\n+LL |         fn unused_self_class_method(&self) {\n+   |                                     ^^^^^\n+   |\n+   = help: consider refactoring to a associated function\n+\n+error: aborting due to 9 previous errors\n+"}]}