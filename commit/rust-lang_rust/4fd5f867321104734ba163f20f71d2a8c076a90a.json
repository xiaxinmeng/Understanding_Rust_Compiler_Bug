{"sha": "4fd5f867321104734ba163f20f71d2a8c076a90a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmZDVmODY3MzIxMTA0NzM0YmExNjNmMjBmNzFkMmE4YzA3NmE5MGE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-03-08T06:24:56Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-03-08T06:24:56Z"}, "message": "Add string_buffer (not used yet)", "tree": {"sha": "54518769792dcd609420d4dd0812a601c051e42c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54518769792dcd609420d4dd0812a601c051e42c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fd5f867321104734ba163f20f71d2a8c076a90a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fd5f867321104734ba163f20f71d2a8c076a90a", "html_url": "https://github.com/rust-lang/rust/commit/4fd5f867321104734ba163f20f71d2a8c076a90a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fd5f867321104734ba163f20f71d2a8c076a90a/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7417ab5aed7336cfc961e067cadf9114bb426a3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7417ab5aed7336cfc961e067cadf9114bb426a3d", "html_url": "https://github.com/rust-lang/rust/commit/7417ab5aed7336cfc961e067cadf9114bb426a3d"}], "stats": {"total": 291, "additions": 291, "deletions": 0}, "files": [{"sha": "f3ec7a33ecbe9285a89362c75cadd8de4ec61919", "filename": "src/string_buffer.rs", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/4fd5f867321104734ba163f20f71d2a8c076a90a/src%2Fstring_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd5f867321104734ba163f20f71d2a8c076a90a/src%2Fstring_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring_buffer.rs?ref=4fd5f867321104734ba163f20f71d2a8c076a90a", "patch": "@@ -0,0 +1,291 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A specialised string-like structure that is optimised for appending text and\n+// sequential reading.\n+\n+// TODO\n+// Debug\n+// docs\n+// char iterator\n+//   Chars -> CharsAndPos\n+// Eq\n+\n+extern crate unicode;\n+\n+use std::str::FromStr;\n+use std::{cmp, fmt};\n+\n+const MAX_CAPACITY: usize = 0xffff;\n+const INIT_CAPACITY: usize = 0xff; \n+\n+pub struct StringBuffer {\n+    first: Box<StringNode>,\n+    // last: &self StringNode\n+    // Optimisation that saves us from walking the whole list of nodes everytime\n+    // we append a string.\n+    last: *mut StringNode,\n+    // The length of the whole StringBuffer.\n+    len: usize,\n+}\n+\n+pub struct Chars<'a> {\n+    // Node we're currently iterating over.\n+    cur_node: &'a StringNode,\n+    // Byte in cur_node.\n+    cur_byte: usize,\n+    // Byte since start of StringBuffer.\n+    abs_byte: usize,\n+}\n+\n+struct StringNode {\n+    data: String,\n+    next: Option<Box<StringNode>>,\n+}\n+\n+impl StringBuffer {\n+    pub fn new() -> StringBuffer {\n+        StringBuffer::with_capacity(INIT_CAPACITY)\n+    }\n+\n+    pub fn with_capacity(capacity: usize) -> StringBuffer {\n+        let mut result = StringBuffer {\n+            first: box StringNode::with_capacity(capacity),\n+            last: 0 as *mut StringNode,\n+            len: 0,\n+        };\n+        result.last = &mut *result.first;\n+        result\n+    }\n+\n+    pub fn push_str(&mut self, text: &str) {\n+        self.len += text.len();\n+        unsafe {\n+            // Safety invariant: the `last` field will only ever point to\n+            // a node owned by self, and will live until destruction of self.\n+            self.last = (&mut *self.last).push_str(text);\n+        }\n+    }\n+\n+    pub fn chars<'a>(&'a self) -> Chars<'a> {\n+        Chars::new(&self.first)\n+    }\n+}\n+\n+impl StringNode {\n+    fn with_capacity(capacity: usize) -> StringNode {\n+        StringNode {\n+            data: String::with_capacity(capacity),\n+            next: None,\n+        }\n+    }\n+\n+    // Returns a reference to the new last node. \n+    fn push_str(&mut self, text: &str) -> &mut StringNode {\n+        if let Some(ref mut n) = self.next {\n+            return n.push_str(text);\n+        }\n+\n+        if self.data.capacity() - self.data.len() >= text.len() {\n+            self.data.push_str(text);\n+            self\n+        } else {\n+            self.data.shrink_to_fit();\n+            let next_cap = cmp::min(cmp::max(self.data.capacity(),\n+                                             INIT_CAPACITY) * 2,\n+                                    MAX_CAPACITY);\n+            let next_cap = cmp::max(next_cap, text.len());\n+            self.next = Some(box StringNode::with_capacity(next_cap));\n+            let next = self.next.as_mut().unwrap();\n+            next.push_str(text);\n+            &mut **next\n+        }\n+    }\n+}\n+\n+impl FromStr for StringBuffer {\n+    type Err = ();\n+    fn from_str(text: &str) -> Result<StringBuffer, ()> {\n+        let mut result = StringBuffer::with_capacity(cmp::max(INIT_CAPACITY, text.len()));\n+        result.push_str(text);\n+        Ok(result)\n+    }\n+}\n+\n+impl fmt::Display for StringBuffer {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        fn fmt_node(node: &StringNode, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+            try!(write!(fmt, \"{}\", node.data));\n+            if let Some(ref n) = node.next {\n+                fmt_node(n, fmt)\n+            } else {\n+                Ok(())\n+            }\n+        }\n+\n+        fmt_node(&self.first, fmt)\n+    }\n+}\n+\n+impl<'a> Iterator for Chars<'a> {\n+    type Item = (char, usize);\n+\n+    fn next(&mut self) -> Option<(char, usize)> {\n+        while self.cur_byte >= self.cur_node.data.len() {\n+            if let Some(ref n) = self.cur_node.next {\n+                self.cur_byte = 0;\n+                self.cur_node = n;\n+            } else {\n+                return None;                \n+            }\n+        }\n+\n+        let byte = self.abs_byte;\n+        let result = self.read_char();\n+\n+        return Some((result, byte));\n+    }\n+}\n+\n+impl<'a> Chars<'a> {\n+    fn new<'b>(first_node: &'b StringNode) -> Chars<'b> {\n+        Chars {\n+            cur_node: first_node,\n+            cur_byte: 0,\n+            abs_byte: 0,\n+        }\n+    }\n+\n+    fn read_char(&mut self) -> char {\n+        let first_byte = self.read_byte();\n+        let width = unicode::str::utf8_char_width(first_byte);\n+        if width == 1 {\n+            return first_byte as char\n+        }\n+        if width == 0 {\n+            panic!(\"non-utf8 char in StringBuffer\");\n+        }\n+        let mut buf = [first_byte, 0, 0, 0];\n+        {\n+            let mut start = 1;\n+            while start < width {\n+                buf[start] = self.read_byte();\n+                start += 1;\n+            }\n+        }\n+        match ::std::str::from_utf8(&buf[..width]).ok() {\n+            Some(s) => s.char_at(0),\n+            None => panic!(\"bad chars in StringBuffer\")\n+        }\n+    }\n+\n+    fn read_byte(&mut self) -> u8 {\n+        let result = self.cur_node.data.as_bytes()[self.cur_byte];\n+        self.cur_byte += 1;\n+        self.abs_byte += 1;\n+        result\n+    }\n+}\n+\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    // Bug #23157\n+    use super::{StringNode, INIT_CAPACITY};\n+\n+    #[test]\n+    fn test_new() {\n+        let s = StringBuffer::new();\n+        assert!(s.len == 0);\n+        assert!(s.to_string() == \"\");\n+        assert!(count_nodes(&s) == 1);\n+        assert!(first_capacity(&s) == INIT_CAPACITY);\n+\n+        let s = StringBuffer::with_capacity(64);\n+        assert!(s.len == 0);\n+        assert!(s.to_string() == \"\");\n+        assert!(count_nodes(&s) == 1);\n+        assert!(first_capacity(&s) == 64);\n+    }\n+\n+    #[test]\n+    fn test_from_str() {\n+        let s: StringBuffer = \"Hello\".parse().unwrap();\n+        assert!(s.len == 5);\n+        assert!(s.to_string() == \"Hello\");\n+        assert!(count_nodes(&s) == 1);\n+        assert!(first_capacity(&s) == INIT_CAPACITY);\n+\n+        let expected = \"Hello\";\n+        for ((i, (c, b)), cc) in s.chars().enumerate().zip(expected.chars()) {\n+            assert!(c == cc);\n+            assert!(i == b);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_push_str() {\n+        let mut s: StringBuffer = \"Hello\".parse().unwrap();\n+        assert!(first_capacity(&s) == INIT_CAPACITY);\n+\n+        s.push_str(\" world!\");\n+        assert!(s.to_string() == \"Hello world!\");\n+        assert!(s.len == 12);\n+        s.push_str(\" foo\");\n+        assert!(s.to_string() == \"Hello world! foo\");\n+        assert!(s.len == 16);\n+\n+        assert!(count_nodes(&s) == 1);\n+\n+        let expected = \"Hello world! foo\";\n+        for ((i, (c, b)), cc) in s.chars().enumerate().zip(expected.chars()) {\n+            assert!(c == cc);\n+            assert!(i == b);\n+        }\n+    }\n+\n+    // push_str requiring multiple nodes\n+    #[test]\n+    fn test_push_str_multi() {\n+        let mut s: StringBuffer = StringBuffer::with_capacity(2);\n+        assert!(first_capacity(&s) == 2);\n+\n+        s.push_str(\"Hello\");\n+        assert!(s.to_string() == \"Hello\");\n+        assert!(s.len == 5);\n+        assert!(count_nodes(&s) == 2);\n+        s.push_str(\" world!\");\n+        assert!(s.to_string() == \"Hello world!\");\n+        assert!(s.len == 12);\n+        assert!(count_nodes(&s) == 2);\n+\n+        let expected = \"Hello world!\";\n+        for ((i, (c, b)), cc) in s.chars().enumerate().zip(expected.chars()) {\n+            assert!(c == cc);\n+            assert!(i == b);\n+        }\n+    }\n+\n+    // TODO test unicode\n+\n+    fn count_nodes(s: &StringBuffer) -> usize {\n+        count_nodes_from(&s.first)\n+    }\n+    fn count_nodes_from(s: &StringNode) -> usize {\n+        match s.next {\n+            Some(ref n) => 1 + count_nodes_from(n),\n+            None => 1,\n+        }\n+    }\n+    fn first_capacity(s: &StringBuffer) -> usize {\n+        s.first.data.capacity()\n+    }\n+}"}]}