{"sha": "fd3a291db49fbb6a0198f8bb05990f9163cc1f66", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkM2EyOTFkYjQ5ZmJiNmEwMTk4ZjhiYjA1OTkwZjkxNjNjYzFmNjY=", "commit": {"author": {"name": "Christian Poveda", "email": "cpovedar@fnal.gov", "date": "2019-06-20T19:21:47Z"}, "committer": {"name": "Christian Poveda", "email": "cpovedar@fnal.gov", "date": "2019-06-21T19:55:37Z"}, "message": "Implement intptrcast methods", "tree": {"sha": "9c12fdfd319c3ce6aff677e75ee81db2c92e9a74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c12fdfd319c3ce6aff677e75ee81db2c92e9a74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd3a291db49fbb6a0198f8bb05990f9163cc1f66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd3a291db49fbb6a0198f8bb05990f9163cc1f66", "html_url": "https://github.com/rust-lang/rust/commit/fd3a291db49fbb6a0198f8bb05990f9163cc1f66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd3a291db49fbb6a0198f8bb05990f9163cc1f66/comments", "author": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "285e9a65cd61520a4da1f912d1b41e523cd3a5e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/285e9a65cd61520a4da1f912d1b41e523cd3a5e4", "html_url": "https://github.com/rust-lang/rust/commit/285e9a65cd61520a4da1f912d1b41e523cd3a5e4"}], "stats": {"total": 238, "additions": 179, "deletions": 59}, "files": [{"sha": "3e07f54fbd3e8692dc3ce9df2a2284b5ea2ffd64", "filename": "src/intptrcast.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fd3a291db49fbb6a0198f8bb05990f9163cc1f66/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd3a291db49fbb6a0198f8bb05990f9163cc1f66/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=fd3a291db49fbb6a0198f8bb05990f9163cc1f66", "patch": "@@ -0,0 +1,20 @@\n+use std::cell::RefCell;\n+\n+use rustc::mir::interpret::AllocId;\n+\n+pub type MemoryState = RefCell<GlobalState>;\n+\n+#[derive(Clone, Debug)]\n+pub struct GlobalState {\n+    pub vec: Vec<(u64, AllocId)>,\n+    pub addr: u64,\n+}\n+\n+impl Default for GlobalState {\n+    fn default() -> Self {\n+        GlobalState {\n+            vec: Vec::default(),\n+            addr: 2u64.pow(16)\n+        }\n+    }\n+}"}, {"sha": "f61abea62e0b6344704e2cb889bcecc985bbe5bf", "filename": "src/lib.rs", "status": "modified", "additions": 87, "deletions": 8, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/fd3a291db49fbb6a0198f8bb05990f9163cc1f66/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd3a291db49fbb6a0198f8bb05990f9163cc1f66/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=fd3a291db49fbb6a0198f8bb05990f9163cc1f66", "patch": "@@ -20,9 +20,12 @@ mod tls;\n mod range_map;\n mod mono_hash_map;\n mod stacked_borrows;\n+mod intptrcast;\n+mod memory;\n \n use std::collections::HashMap;\n use std::borrow::Cow;\n+use std::cell::RefCell;\n use std::rc::Rc;\n \n use rand::rngs::StdRng;\n@@ -48,6 +51,7 @@ use crate::range_map::RangeMap;\n pub use crate::helpers::{EvalContextExt as HelpersEvalContextExt};\n use crate::mono_hash_map::MonoHashMap;\n pub use crate::stacked_borrows::{EvalContextExt as StackedBorEvalContextExt};\n+use crate::memory::AllocExtra;\n \n // Used by priroda.\n pub use crate::stacked_borrows::{Tag, Permission, Stack, Stacks, Item};\n@@ -206,6 +210,8 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         }\n     }\n \n+    ecx.memory_mut().extra.seed = config.seed.clone();\n+    \n     assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n \n     Ok(ecx)\n@@ -386,8 +392,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     type MemoryKinds = MiriMemoryKind;\n \n     type FrameExtra = stacked_borrows::CallId;\n-    type MemoryExtra = stacked_borrows::MemoryState;\n-    type AllocExtra = stacked_borrows::Stacks;\n+    type MemoryExtra = memory::MemoryState;\n+    type AllocExtra = memory::AllocExtra;\n     type PointerTag = Tag;\n \n     type MemoryMap = MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<Tag, Self::AllocExtra>)>;\n@@ -515,14 +521,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         let (extra, base_tag) = Stacks::new_allocation(\n             id,\n             Size::from_bytes(alloc.bytes.len() as u64),\n-            Rc::clone(&memory.extra),\n+            Rc::clone(&memory.extra.stacked),\n             kind,\n         );\n         if kind != MiriMemoryKind::Static.into() {\n             assert!(alloc.relocations.is_empty(), \"Only statics can come initialized with inner pointers\");\n             // Now we can rely on the inner pointers being static, too.\n         }\n-        let mut memory_extra = memory.extra.borrow_mut();\n+        let mut memory_extra = memory.extra.stacked.borrow_mut();\n         let alloc: Allocation<Tag, Self::AllocExtra> = Allocation {\n             bytes: alloc.bytes,\n             relocations: Relocations::from_presorted(\n@@ -535,7 +541,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n             undef_mask: alloc.undef_mask,\n             align: alloc.align,\n             mutability: alloc.mutability,\n-            extra,\n+            extra: AllocExtra {\n+                stacks: extra,\n+                base_addr: RefCell::new(None),\n+            },\n         };\n         (Cow::Owned(alloc), base_tag)\n     }\n@@ -545,7 +554,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         id: AllocId,\n         memory: &Memory<'mir, 'tcx, Self>,\n     ) -> Self::PointerTag {\n-        memory.extra.borrow_mut().static_base_ptr(id)\n+        memory.extra.stacked.borrow_mut().static_base_ptr(id)\n     }\n \n     #[inline(always)]\n@@ -570,14 +579,84 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     fn stack_push(\n         ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n     ) -> InterpResult<'tcx, stacked_borrows::CallId> {\n-        Ok(ecx.memory().extra.borrow_mut().new_call())\n+        Ok(ecx.memory().extra.stacked.borrow_mut().new_call())\n     }\n \n     #[inline(always)]\n     fn stack_pop(\n         ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n         extra: stacked_borrows::CallId,\n     ) -> InterpResult<'tcx> {\n-        Ok(ecx.memory().extra.borrow_mut().end_call(extra))\n+        Ok(ecx.memory().extra.stacked.borrow_mut().end_call(extra))\n+    }\n+\n+    fn int_to_ptr(\n+        int: u64,\n+        memory: &Memory<'mir, 'tcx, Self>,\n+    ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n+        if int == 0 {\n+            return err!(InvalidNullPointerUsage);\n+        }\n+        \n+        if memory.extra.seed.is_none() {\n+            return err!(ReadBytesAsPointer);\n+        }\n+\n+        let extra = memory.extra.intptrcast.borrow();\n+        \n+        match extra.vec.binary_search_by_key(&int, |(int, _)| *int) {\n+            Ok(pos) => {\n+                let (_, alloc_id) = extra.vec[pos];\n+                Ok(Pointer::new_with_tag(alloc_id, Size::from_bytes(0), Tag::Untagged))\n+            }\n+            Err(pos) => {\n+                if pos > 0 {\n+                    let (glb, alloc_id) = extra.vec[pos - 1];\n+                    let offset = int - glb;\n+                    if offset <= memory.get(alloc_id)?.bytes.len() as u64 {\n+                        Ok(Pointer::new_with_tag(alloc_id, Size::from_bytes(offset), Tag::Untagged))\n+                    } else {\n+                        return err!(DanglingPointerDeref);\n+                    }\n+                } else {\n+                    return err!(DanglingPointerDeref);\n+                }\n+            }\n+        }\n+    }\n+ \n+    fn ptr_to_int(\n+        ptr: Pointer<Self::PointerTag>,\n+        memory: &Memory<'mir, 'tcx, Self>,\n+    ) -> InterpResult<'tcx, u64> {\n+        if memory.extra.seed.is_none() {\n+            return err!(ReadPointerAsBytes);\n+        }\n+\n+        let mut extra = memory.extra.intptrcast.borrow_mut();\n+\n+        let alloc = memory.get(ptr.alloc_id)?;\n+\n+        let base_addr = match alloc.extra.base_addr.borrow().clone() { \n+            Some(base_addr) => base_addr,\n+            None => {\n+                let base_addr = extra.addr;\n+                extra.addr += alloc.bytes.len() as u64;\n+\n+                *alloc.extra.base_addr.borrow_mut() = Some(base_addr);\n+\n+                let elem = (base_addr, ptr.alloc_id);\n+\n+                if let Err(pos) = extra.vec.binary_search(&elem) {\n+                    extra.vec.insert(pos, elem);\n+                } else {\n+                    return err!(Unreachable);\n+                }\n+\n+                base_addr\n+            }\n+        };\n+\n+        Ok(base_addr + ptr.offset.bytes())\n     }\n }"}, {"sha": "13ffd859adefaf465296993932b2e233ec763576", "filename": "src/memory.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fd3a291db49fbb6a0198f8bb05990f9163cc1f66/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd3a291db49fbb6a0198f8bb05990f9163cc1f66/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=fd3a291db49fbb6a0198f8bb05990f9163cc1f66", "patch": "@@ -0,0 +1,60 @@\n+use std::cell::RefCell;\n+\n+use rustc_mir::interpret::{Pointer, Allocation, AllocationExtra, InterpResult};\n+use rustc_target::abi::Size;\n+\n+use crate::{stacked_borrows, intptrcast};\n+use crate::stacked_borrows::{Tag, AccessKind};\n+\n+#[derive(Default, Clone, Debug)]\n+pub struct MemoryState {\n+    pub stacked: stacked_borrows::MemoryState,\n+    pub intptrcast: intptrcast::MemoryState,\n+    pub seed: Option<u64>,\n+}\n+\n+#[derive(Debug, Clone,)]\n+pub struct AllocExtra {\n+    pub stacks: stacked_borrows::Stacks,\n+    pub base_addr: RefCell<Option<u64>>,\n+}\n+\n+impl AllocationExtra<Tag> for AllocExtra {\n+    #[inline(always)]\n+    fn memory_read<'tcx>(\n+        alloc: &Allocation<Tag, AllocExtra>,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> InterpResult<'tcx> {\n+        trace!(\"read access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n+        alloc.extra.stacks.for_each(ptr, size, |stack, global| {\n+            stack.access(AccessKind::Read, ptr.tag, global)?;\n+            Ok(())\n+        })\n+    }\n+\n+    #[inline(always)]\n+    fn memory_written<'tcx>(\n+        alloc: &mut Allocation<Tag, AllocExtra>,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> InterpResult<'tcx> {\n+        trace!(\"write access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n+        alloc.extra.stacks.for_each(ptr, size, |stack, global| {\n+            stack.access(AccessKind::Write, ptr.tag, global)?;\n+            Ok(())\n+        })\n+    }\n+\n+    #[inline(always)]\n+    fn memory_deallocated<'tcx>(\n+        alloc: &mut Allocation<Tag, AllocExtra>,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> InterpResult<'tcx> {\n+        trace!(\"deallocation with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n+        alloc.extra.stacks.for_each(ptr, size, |stack, global| {\n+            stack.dealloc(ptr.tag, global)\n+        })\n+    }\n+}"}, {"sha": "ea70c28709cee0677c0cca270120b09d9cc9354f", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 12, "deletions": 51, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/fd3a291db49fbb6a0198f8bb05990f9163cc1f66/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd3a291db49fbb6a0198f8bb05990f9163cc1f66/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=fd3a291db49fbb6a0198f8bb05990f9163cc1f66", "patch": "@@ -10,8 +10,8 @@ use rustc::mir::RetagKind;\n \n use crate::{\n     InterpResult, InterpError, MiriEvalContext, HelpersEvalContextExt, Evaluator, MutValueVisitor,\n-    MemoryKind, MiriMemoryKind, RangeMap, Allocation, AllocationExtra, AllocId, CheckInAllocMsg,\n-    Pointer, Immediate, ImmTy, PlaceTy, MPlaceTy,\n+    MemoryKind, MiriMemoryKind, RangeMap, AllocId, CheckInAllocMsg, Pointer, Immediate, ImmTy, \n+    PlaceTy, MPlaceTy,\n };\n \n pub type PtrId = NonZeroU64;\n@@ -286,7 +286,7 @@ impl<'tcx> Stack {\n \n     /// Test if a memory `access` using pointer tagged `tag` is granted.\n     /// If yes, return the index of the item that granted it.\n-    fn access(\n+    pub(crate) fn access(\n         &mut self,\n         access: AccessKind,\n         tag: Tag,\n@@ -336,7 +336,7 @@ impl<'tcx> Stack {\n \n     /// Deallocate a location: Like a write access, but also there must be no\n     /// active protectors at all because we will remove all items.\n-    fn dealloc(\n+    pub(crate) fn dealloc(\n         &mut self,\n         tag: Tag,\n         global: &GlobalState,\n@@ -429,14 +429,15 @@ impl<'tcx> Stacks {\n         let stack = Stack {\n             borrows: vec![item],\n         };\n+\n         Stacks {\n             stacks: RefCell::new(RangeMap::new(size, stack)),\n-            global: extra,\n+            global: extra, \n         }\n     }\n \n     /// Call `f` on every stack in the range.\n-    fn for_each(\n+    pub(crate) fn for_each(\n         &self,\n         ptr: Pointer<Tag>,\n         size: Size,\n@@ -456,7 +457,7 @@ impl Stacks {\n     pub fn new_allocation(\n         id: AllocId,\n         size: Size,\n-        extra: MemoryState,\n+        extra: MemoryState, \n         kind: MemoryKind<MiriMemoryKind>,\n     ) -> (Self, Tag) {\n         let (tag, perm) = match kind {\n@@ -477,46 +478,6 @@ impl Stacks {\n     }\n }\n \n-impl AllocationExtra<Tag> for Stacks {\n-    #[inline(always)]\n-    fn memory_read<'tcx>(\n-        alloc: &Allocation<Tag, Stacks>,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx> {\n-        trace!(\"read access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        alloc.extra.for_each(ptr, size, |stack, global| {\n-            stack.access(AccessKind::Read, ptr.tag, global)?;\n-            Ok(())\n-        })\n-    }\n-\n-    #[inline(always)]\n-    fn memory_written<'tcx>(\n-        alloc: &mut Allocation<Tag, Stacks>,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx> {\n-        trace!(\"write access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        alloc.extra.for_each(ptr, size, |stack, global| {\n-            stack.access(AccessKind::Write, ptr.tag, global)?;\n-            Ok(())\n-        })\n-    }\n-\n-    #[inline(always)]\n-    fn memory_deallocated<'tcx>(\n-        alloc: &mut Allocation<Tag, Stacks>,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx> {\n-        trace!(\"deallocation with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        alloc.extra.for_each(ptr, size, |stack, global| {\n-            stack.dealloc(ptr.tag, global)\n-        })\n-    }\n-}\n-\n /// Retagging/reborrowing.  There is some policy in here, such as which permissions\n /// to grant for which references, and when to add protectors.\n impl<'mir, 'tcx> EvalContextPrivExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n@@ -553,14 +514,14 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     // We are only ever `SharedReadOnly` inside the frozen bits.\n                     let perm = if frozen { Permission::SharedReadOnly } else { Permission::SharedReadWrite };\n                     let item = Item { perm, tag: new_tag, protector };\n-                    alloc.extra.for_each(cur_ptr, size, |stack, global| {\n+                    alloc.extra.stacks.for_each(cur_ptr, size, |stack, global| {\n                         stack.grant(cur_ptr.tag, item, global)\n                     })\n                 });\n             }\n         };\n         let item = Item { perm, tag: new_tag, protector };\n-        alloc.extra.for_each(ptr, size, |stack, global| {\n+        alloc.extra.stacks.for_each(ptr, size, |stack, global| {\n             stack.grant(ptr.tag, item, global)\n         })\n     }\n@@ -587,7 +548,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Compute new borrow.\n         let new_tag = match kind {\n             RefKind::Raw { .. } => Tag::Untagged,\n-            _ => Tag::Tagged(this.memory().extra.borrow_mut().new_ptr()),\n+            _ => Tag::Tagged(this.memory().extra.stacked.borrow_mut().new_ptr()),\n         };\n \n         // Reborrow.\n@@ -621,7 +582,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 ty::RawPtr(tym) if kind == RetagKind::Raw =>\n                     Some((RefKind::Raw { mutable: tym.mutbl == MutMutable }, false)),\n                 // Boxes do not get a protector: protectors reflect that references outlive the call\n-                // they were passed in to; that's just not the case for boxes.\n+            // they were passed in to; that's just not the case for boxes.\n                 ty::Adt(..) if ty.is_box() => Some((RefKind::Unique { two_phase: false }, false)),\n                 _ => None,\n             }"}]}