{"sha": "a1db9311dc0ddb0dea68d2661442df2c6f4b382c", "node_id": "C_kwDOAAsO6NoAKGExZGI5MzExZGMwZGRiMGRlYTY4ZDI2NjE0NDJkZjJjNmY0YjM4MmM", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2022-10-10T05:17:04Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2022-10-24T20:05:39Z"}, "message": "Make an attempt of creating suggestions\n\nThey aren't perfect but better than nothing", "tree": {"sha": "bd82f3a40fb21fca03e7fd533706aafdfe0704c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd82f3a40fb21fca03e7fd533706aafdfe0704c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1db9311dc0ddb0dea68d2661442df2c6f4b382c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1db9311dc0ddb0dea68d2661442df2c6f4b382c", "html_url": "https://github.com/rust-lang/rust/commit/a1db9311dc0ddb0dea68d2661442df2c6f4b382c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1db9311dc0ddb0dea68d2661442df2c6f4b382c/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bd70dbb8855580ca75d37211fce74adc8fda734", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bd70dbb8855580ca75d37211fce74adc8fda734", "html_url": "https://github.com/rust-lang/rust/commit/9bd70dbb8855580ca75d37211fce74adc8fda734"}], "stats": {"total": 219, "additions": 156, "deletions": 63}, "files": [{"sha": "8d743c86d6df1fd33813dea29d59b77a676df487", "filename": "clippy_lints/src/manual_let_else.rs", "status": "modified", "additions": 51, "deletions": 27, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/a1db9311dc0ddb0dea68d2661442df2c6f4b382c/clippy_lints%2Fsrc%2Fmanual_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1db9311dc0ddb0dea68d2661442df2c6f4b382c/clippy_lints%2Fsrc%2Fmanual_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_let_else.rs?ref=a1db9311dc0ddb0dea68d2661442df2c6f4b382c", "patch": "@@ -1,16 +1,19 @@\n-use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::IfLetOrMatch;\n+use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::visitors::{for_each_expr, Descend};\n use clippy_utils::{meets_msrv, msrvs, peel_blocks};\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, MatchSource, Pat, PatKind, QPath, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::sym;\n+use rustc_span::Span;\n use serde::Deserialize;\n use std::ops::ControlFlow;\n \n@@ -80,20 +83,15 @@ impl<'tcx> LateLintPass<'tcx> for ManualLetElse {\n         };\n \n         match if_let_or_match {\n-            IfLetOrMatch::IfLet(_let_expr, let_pat, if_then, if_else) => if_chain! {\n+            IfLetOrMatch::IfLet(if_let_expr, let_pat, if_then, if_else) => if_chain! {\n                 if expr_is_simple_identity(let_pat, if_then);\n                 if let Some(if_else) = if_else;\n                 if expr_diverges(cx, if_else);\n                 then {\n-                    span_lint(\n-                        cx,\n-                        MANUAL_LET_ELSE,\n-                        stmt.span,\n-                        \"this could be rewritten as `let else`\",\n-                    );\n+                    emit_manual_let_else(cx, stmt.span, if_let_expr, let_pat, if_else);\n                 }\n             },\n-            IfLetOrMatch::Match(_match_expr, arms, source) => {\n+            IfLetOrMatch::Match(match_expr, arms, source) => {\n                 if self.matches_behaviour == MatchLintBehaviour::Never {\n                     return;\n                 }\n@@ -105,34 +103,60 @@ impl<'tcx> LateLintPass<'tcx> for ManualLetElse {\n                 if arms.len() != 2 {\n                     return;\n                 }\n-                let check_types = self.matches_behaviour == MatchLintBehaviour::WellKnownTypes;\n-                // We iterate over both arms, trying to find one that is an identity,\n-                // one that diverges. Our check needs to work regardless of the order\n-                // of both arms.\n-                let mut found_identity_arm = false;\n-                let mut found_diverging_arm = false;\n-                for arm in arms {\n-                    // Guards don't give us an easy mapping to let else\n-                    if arm.guard.is_some() {\n-                        return;\n-                    }\n-                    if expr_is_simple_identity(arm.pat, arm.body) {\n-                        found_identity_arm = true;\n-                    } else if expr_diverges(cx, arm.body) && pat_allowed_for_else(cx, arm.pat, check_types) {\n-                        found_diverging_arm = true;\n-                    }\n+                // Guards don't give us an easy mapping either\n+                if arms.iter().any(|arm| arm.guard.is_some()) {\n+                    return;\n                 }\n-                if !(found_identity_arm && found_diverging_arm) {\n+                let check_types = self.matches_behaviour == MatchLintBehaviour::WellKnownTypes;\n+                let diverging_arm_opt = arms\n+                    .iter()\n+                    .enumerate()\n+                    .find(|(_, arm)| expr_diverges(cx, arm.body) && pat_allowed_for_else(cx, arm.pat, check_types));\n+                let Some((idx, diverging_arm)) = diverging_arm_opt else { return; };\n+                let pat_arm = &arms[1 - idx];\n+                if !expr_is_simple_identity(pat_arm.pat, pat_arm.body) {\n                     return;\n                 }\n-                span_lint(cx, MANUAL_LET_ELSE, stmt.span, \"this could be rewritten as `let else`\");\n+\n+                emit_manual_let_else(cx, stmt.span, match_expr, pat_arm.pat, diverging_arm.body);\n             },\n         }\n     }\n \n     extract_msrv_attr!(LateContext);\n }\n \n+fn emit_manual_let_else(cx: &LateContext<'_>, span: Span, expr: &Expr<'_>, pat: &Pat<'_>, else_body: &Expr<'_>) {\n+    span_lint_and_then(\n+        cx,\n+        MANUAL_LET_ELSE,\n+        span,\n+        \"this could be rewritten as `let...else`\",\n+        |diag| {\n+            // This is far from perfect, for example there needs to be:\n+            // * mut additions for the bindings\n+            // * renamings of the bindings\n+            // * unused binding collision detection with existing ones\n+            // * putting patterns with at the top level | inside ()\n+            // for this to be machine applicable.\n+            let app = Applicability::HasPlaceholders;\n+\n+            if let Some(sn_pat) = snippet_opt(cx, pat.span) &&\n+                let Some(sn_expr) = snippet_opt(cx, expr.span) &&\n+                let Some(sn_else) = snippet_opt(cx, else_body.span)\n+            {\n+                let else_bl = if matches!(else_body.kind, ExprKind::Block(..)) {\n+                    sn_else\n+                } else {\n+                    format!(\"{{ {sn_else} }}\")\n+                };\n+                let sugg = format!(\"let {sn_pat} = {sn_expr} else {else_bl};\");\n+                diag.span_suggestion(span, \"consider writing\", sugg, app);\n+            }\n+        },\n+    );\n+}\n+\n fn expr_diverges(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n     fn is_never(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n         if let Some(ty) = cx.typeck_results().expr_ty_opt(expr) {"}, {"sha": "bd0ac69e46e8094e7240a432e2a2ec4b1aac4199", "filename": "tests/ui/manual_let_else.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a1db9311dc0ddb0dea68d2661442df2c6f4b382c/tests%2Fui%2Fmanual_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1db9311dc0ddb0dea68d2661442df2c6f4b382c/tests%2Fui%2Fmanual_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_let_else.rs?ref=a1db9311dc0ddb0dea68d2661442df2c6f4b382c", "patch": "@@ -158,14 +158,13 @@ fn not_fire() {\n         }\n     };\n \n-\n-    let v = if let Some(v_some) = g() {\n+    enum Uninhabited {}\n+    fn un() -> Uninhabited {\n+        panic!()\n+    }\n+    let v = if let Some(v_some) = None {\n         v_some\n     } else {\n-        enum Uninhabited {}\n-        fn un() -> Uninhabited {\n-            panic!()\n-        }\n         // Don't lint if the type is uninhabited but not !\n         un()\n     };"}, {"sha": "e073276d20cdb3f94ca5911618a0c1c24b72864e", "filename": "tests/ui/manual_let_else.stderr", "status": "modified", "additions": 88, "deletions": 18, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/a1db9311dc0ddb0dea68d2661442df2c6f4b382c/tests%2Fui%2Fmanual_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1db9311dc0ddb0dea68d2661442df2c6f4b382c/tests%2Fui%2Fmanual_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_let_else.stderr?ref=a1db9311dc0ddb0dea68d2661442df2c6f4b382c", "patch": "@@ -1,12 +1,12 @@\n-error: this could be rewritten as `let else`\n+error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else.rs:17:5\n    |\n LL |     let v = if let Some(v_some) = g() { v_some } else { return };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v_some) = g() else { return };`\n    |\n    = note: `-D clippy::manual-let-else` implied by `-D warnings`\n \n-error: this could be rewritten as `let else`\n+error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else.rs:18:5\n    |\n LL | /     let v = if let Some(v_some) = g() {\n@@ -15,8 +15,15 @@ LL | |     } else {\n LL | |         return;\n LL | |     };\n    | |______^\n+   |\n+help: consider writing\n+   |\n+LL ~     let Some(v_some) = g() else {\n+LL +         return;\n+LL +     };\n+   |\n \n-error: this could be rewritten as `let else`\n+error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else.rs:24:5\n    |\n LL | /     let v = if let Some(v) = g() {\n@@ -27,26 +34,35 @@ LL | |             { v }\n LL | |         return;\n LL | |     };\n    | |______^\n+   |\n+help: consider writing\n+   |\n+LL ~     let Some(v) = g() else {\n+LL +         // Some computation should still make it fire\n+LL +         g();\n+LL +         return;\n+LL +     };\n+   |\n \n-error: this could be rewritten as `let else`\n+error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else.rs:37:9\n    |\n LL |         let v = if let Some(v_some) = g() { v_some } else { continue };\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v_some) = g() else { continue };`\n \n-error: this could be rewritten as `let else`\n+error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else.rs:38:9\n    |\n LL |         let v = if let Some(v_some) = g() { v_some } else { break };\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v_some) = g() else { break };`\n \n-error: this could be rewritten as `let else`\n+error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else.rs:42:5\n    |\n LL |     let v = if let Some(v_some) = g() { v_some } else { panic!() };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v_some) = g() else { panic!() };`\n \n-error: this could be rewritten as `let else`\n+error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else.rs:45:5\n    |\n LL | /     let v = if let Some(v_some) = g() {\n@@ -55,8 +71,15 @@ LL | |     } else {\n LL | |         std::process::abort()\n LL | |     };\n    | |______^\n+   |\n+help: consider writing\n+   |\n+LL ~     let Some(v_some) = g() else {\n+LL +         std::process::abort()\n+LL +     };\n+   |\n \n-error: this could be rewritten as `let else`\n+error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else.rs:52:5\n    |\n LL | /     let v = if let Some(v_some) = g() {\n@@ -65,8 +88,15 @@ LL | |     } else {\n LL | |         if true { return } else { panic!() }\n LL | |     };\n    | |______^\n+   |\n+help: consider writing\n+   |\n+LL ~     let Some(v_some) = g() else {\n+LL +         if true { return } else { panic!() }\n+LL +     };\n+   |\n \n-error: this could be rewritten as `let else`\n+error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else.rs:59:5\n    |\n LL | /     let v = if let Some(v_some) = g() {\n@@ -77,8 +107,17 @@ LL | |     } else {\n LL | |         panic!(\"diverge\");\n LL | |     };\n    | |______^\n+   |\n+help: consider writing\n+   |\n+LL ~     let Some(v_some) = g() else { if true {\n+LL +         return;\n+LL +     } else {\n+LL +         panic!(\"diverge\");\n+LL +     } };\n+   |\n \n-error: this could be rewritten as `let else`\n+error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else.rs:68:5\n    |\n LL | /     let v = if let Some(v_some) = g() {\n@@ -89,8 +128,25 @@ LL | |         match (g(), g()) {\n LL | |         }\n LL | |     };\n    | |______^\n+   |\n+help: consider writing\n+   |\n+LL ~     let Some(v_some) = g() else {\n+LL +         match (g(), g()) {\n+LL +             (Some(_), None) => return,\n+LL +             (None, Some(_)) => {\n+LL +                 if true {\n+LL +                     return;\n+LL +                 } else {\n+LL +                     panic!();\n+LL +                 }\n+LL +             },\n+LL +             _ => return,\n+LL +         }\n+LL +     };\n+   |\n \n-error: this could be rewritten as `let else`\n+error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else.rs:85:5\n    |\n LL | /     let (v, w) = if let Some(v_some) = g().map(|v| (v, 42)) {\n@@ -99,8 +155,15 @@ LL | |     } else {\n LL | |         return;\n LL | |     };\n    | |______^\n+   |\n+help: consider writing\n+   |\n+LL ~     let Some(v_some) = g().map(|v| (v, 42)) else {\n+LL +         return;\n+LL +     };\n+   |\n \n-error: this could be rewritten as `let else`\n+error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else.rs:92:5\n    |\n LL | /     let v = if let (Some(v_some), w_some) = (g(), 0) {\n@@ -109,12 +172,19 @@ LL | |     } else {\n LL | |         return;\n LL | |     };\n    | |______^\n+   |\n+help: consider writing\n+   |\n+LL ~     let (Some(v_some), w_some) = (g(), 0) else {\n+LL +         return;\n+LL +     };\n+   |\n \n-error: this could be rewritten as `let else`\n+error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else.rs:101:13\n    |\n LL |             let $n = if let Some(v) = $e { v } else { return };\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v) = g() else { return };`\n ...\n LL |     create_binding_if_some!(w, g());\n    |     ------------------------------- in this macro invocation"}, {"sha": "38be5ac54547368b7fe98d336a1da5acc2e85db7", "filename": "tests/ui/manual_let_else_match.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a1db9311dc0ddb0dea68d2661442df2c6f4b382c/tests%2Fui%2Fmanual_let_else_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1db9311dc0ddb0dea68d2661442df2c6f4b382c/tests%2Fui%2Fmanual_let_else_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_let_else_match.stderr?ref=a1db9311dc0ddb0dea68d2661442df2c6f4b382c", "patch": "@@ -1,58 +1,58 @@\n-error: this could be rewritten as `let else`\n+error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else_match.rs:32:5\n    |\n LL | /     let v = match g() {\n LL | |         Some(v_some) => v_some,\n LL | |         None => return,\n LL | |     };\n-   | |______^\n+   | |______^ help: consider writing: `let Some(v_some) = g() else { return };`\n    |\n    = note: `-D clippy::manual-let-else` implied by `-D warnings`\n \n-error: this could be rewritten as `let else`\n+error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else_match.rs:37:5\n    |\n LL | /     let v = match g() {\n LL | |         Some(v_some) => v_some,\n LL | |         _ => return,\n LL | |     };\n-   | |______^\n+   | |______^ help: consider writing: `let Some(v_some) = g() else { return };`\n \n-error: this could be rewritten as `let else`\n+error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else_match.rs:44:9\n    |\n LL | /         let v = match h() {\n LL | |             (Some(_), Some(_)) | (None, None) => continue,\n LL | |             (Some(v), None) | (None, Some(v)) => v,\n LL | |         };\n-   | |__________^\n+   | |__________^ help: consider writing: `let (Some(v), None) | (None, Some(v)) = h() else { continue };`\n \n-error: this could be rewritten as `let else`\n+error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else_match.rs:49:9\n    |\n LL | /         let v = match build_enum() {\n LL | |             _ => continue,\n LL | |             Variant::Bar(v) | Variant::Baz(v) => v,\n LL | |         };\n-   | |__________^\n+   | |__________^ help: consider writing: `let Variant::Bar(v) | Variant::Baz(v) = build_enum() else { continue };`\n \n-error: this could be rewritten as `let else`\n+error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else_match.rs:57:5\n    |\n LL | /     let v = match f() {\n LL | |         Ok(v) => v,\n LL | |         Err(_) => return,\n LL | |     };\n-   | |______^\n+   | |______^ help: consider writing: `let Ok(v) = f() else { return };`\n \n-error: this could be rewritten as `let else`\n+error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else_match.rs:63:5\n    |\n LL | /     let v = match f().map_err(|_| ()) {\n LL | |         Ok(v) => v,\n LL | |         Err(()) => return,\n LL | |     };\n-   | |______^\n+   | |______^ help: consider writing: `let Ok(v) = f().map_err(|_| ()) else { return };`\n \n error: aborting due to 6 previous errors\n "}]}