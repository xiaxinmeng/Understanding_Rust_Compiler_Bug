{"sha": "302e9ae206ed148fc009d84c05ce0c99877ef6aa", "node_id": "C_kwDOAAsO6NoAKDMwMmU5YWUyMDZlZDE0OGZjMDA5ZDg0YzA1Y2UwYzk5ODc3ZWY2YWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-23T13:40:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-23T13:40:23Z"}, "message": "Auto merge of #2424 - RalfJung:weak-memory-debug, r=RalfJung\n\nadd a flag to print a diagnostic when an outdated value is returned from an atomic load\n\nHelps with https://github.com/rust-lang/miri/issues/2313. It can still be annoying to figure out *which* outdated load is the important one in case there are many of them (and the issue contains some ideas for how to help with that situation), but having this flag is better than nothing.\n\nThanks to `@cbeuw` for the [original patch](https://github.com/cbeuw/miri/commit/64d738cb00dbcfbe9cab29c77717f5af62c83ada) that I based this on.", "tree": {"sha": "40d81f277d083403ce6a714148e842556acbd7f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40d81f277d083403ce6a714148e842556acbd7f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/302e9ae206ed148fc009d84c05ce0c99877ef6aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/302e9ae206ed148fc009d84c05ce0c99877ef6aa", "html_url": "https://github.com/rust-lang/rust/commit/302e9ae206ed148fc009d84c05ce0c99877ef6aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/302e9ae206ed148fc009d84c05ce0c99877ef6aa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9aad98a3b61e77e31317c6fef86ffff6bac175a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9aad98a3b61e77e31317c6fef86ffff6bac175a", "html_url": "https://github.com/rust-lang/rust/commit/b9aad98a3b61e77e31317c6fef86ffff6bac175a"}, {"sha": "649b2164824c47419ffeffa7266f18a9cc84824e", "url": "https://api.github.com/repos/rust-lang/rust/commits/649b2164824c47419ffeffa7266f18a9cc84824e", "html_url": "https://github.com/rust-lang/rust/commit/649b2164824c47419ffeffa7266f18a9cc84824e"}], "stats": {"total": 62, "additions": 46, "deletions": 16}, "files": [{"sha": "fa235a45f5093e5a134739e4cc67f51b06fcfbb8", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/302e9ae206ed148fc009d84c05ce0c99877ef6aa/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/302e9ae206ed148fc009d84c05ce0c99877ef6aa/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=302e9ae206ed148fc009d84c05ce0c99877ef6aa", "patch": "@@ -377,6 +377,9 @@ to Miri failing to detect cases of undefined behavior in a program.\n   happening and where in your code would be a good place to look for it.\n   Specifying this argument multiple times does not overwrite the previous\n   values, instead it appends its values to the list. Listing a tag multiple times has no effect.\n+* `-Zmiri-track-weak-memory-loads` shows a backtrace when weak memory emulation returns an outdated\n+  value from a load. This can help diagnose problems that disappear under\n+  `-Zmiri-disable-weak-memory-emulation`.\n \n [function ABI]: https://doc.rust-lang.org/reference/items/functions.html#extern-function-qualifier\n "}, {"sha": "14694ac7b053678ed8d3546a2d780a0edf9b584b", "filename": "src/bin/miri.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/302e9ae206ed148fc009d84c05ce0c99877ef6aa/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/302e9ae206ed148fc009d84c05ce0c99877ef6aa/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=302e9ae206ed148fc009d84c05ce0c99877ef6aa", "patch": "@@ -358,6 +358,8 @@ fn main() {\n             miri_config.isolated_op = miri::IsolatedOp::Allow;\n         } else if arg == \"-Zmiri-disable-weak-memory-emulation\" {\n             miri_config.weak_memory_emulation = false;\n+        } else if arg == \"-Zmiri-track-weak-memory-loads\" {\n+            miri_config.track_outdated_loads = true;\n         } else if let Some(param) = arg.strip_prefix(\"-Zmiri-isolation-error=\") {\n             if matches!(isolation_enabled, Some(false)) {\n                 panic!(\"-Zmiri-isolation-error cannot be used along with -Zmiri-disable-isolation\");"}, {"sha": "6ea87a82cb924be5079c026e6cc486a493a2dc98", "filename": "src/concurrency/data_race.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/302e9ae206ed148fc009d84c05ce0c99877ef6aa/src%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/302e9ae206ed148fc009d84c05ce0c99877ef6aa/src%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fdata_race.rs?ref=302e9ae206ed148fc009d84c05ce0c99877ef6aa", "patch": "@@ -1187,12 +1187,15 @@ pub struct GlobalState {\n \n     /// The timestamp of last SC write performed by each thread\n     last_sc_write: RefCell<VClock>,\n+\n+    /// Track when an outdated (weak memory) load happens.\n+    pub track_outdated_loads: bool,\n }\n \n impl GlobalState {\n     /// Create a new global state, setup with just thread-id=0\n     /// advanced to timestamp = 1.\n-    pub fn new() -> Self {\n+    pub fn new(config: &MiriConfig) -> Self {\n         let mut global_state = GlobalState {\n             multi_threaded: Cell::new(false),\n             ongoing_action_data_race_free: Cell::new(false),\n@@ -1203,6 +1206,7 @@ impl GlobalState {\n             terminated_threads: RefCell::new(FxHashMap::default()),\n             last_sc_fence: RefCell::new(VClock::default()),\n             last_sc_write: RefCell::new(VClock::default()),\n+            track_outdated_loads: config.track_outdated_loads,\n         };\n \n         // Setup the main-thread since it is not explicitly created:"}, {"sha": "317258a028d0b074b3bf01b18b23bc4098e48c6c", "filename": "src/concurrency/weak_memory.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/302e9ae206ed148fc009d84c05ce0c99877ef6aa/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/302e9ae206ed148fc009d84c05ce0c99877ef6aa/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=302e9ae206ed148fc009d84c05ce0c99877ef6aa", "patch": "@@ -82,10 +82,7 @@ use rustc_const_eval::interpret::{\n };\n use rustc_data_structures::fx::FxHashMap;\n \n-use crate::{\n-    AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd, Provenance, ThreadManager, VClock, VTimestamp,\n-    VectorIdx,\n-};\n+use crate::*;\n \n use super::{\n     data_race::{GlobalState as DataRaceState, ThreadClockSet},\n@@ -113,6 +110,13 @@ pub(super) struct StoreBuffer {\n     buffer: VecDeque<StoreElement>,\n }\n \n+/// Whether a load returned the latest value or not.\n+#[derive(PartialEq, Eq)]\n+enum LoadRecency {\n+    Latest,\n+    Outdated,\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n struct StoreElement {\n     /// The identifier of the vector index, corresponding to a thread\n@@ -254,11 +258,11 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n         is_seqcst: bool,\n         rng: &mut (impl rand::Rng + ?Sized),\n         validate: impl FnOnce() -> InterpResult<'tcx>,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n+    ) -> InterpResult<'tcx, (ScalarMaybeUninit<Provenance>, LoadRecency)> {\n         // Having a live borrow to store_buffer while calling validate_atomic_load is fine\n         // because the race detector doesn't touch store_buffer\n \n-        let store_elem = {\n+        let (store_elem, recency) = {\n             // The `clocks` we got here must be dropped before calling validate_atomic_load\n             // as the race detector will update it\n             let (.., clocks) = global.current_thread_state(thread_mgr);\n@@ -274,7 +278,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n \n         let (index, clocks) = global.current_thread_state(thread_mgr);\n         let loaded = store_elem.load_impl(index, &clocks);\n-        Ok(loaded)\n+        Ok((loaded, recency))\n     }\n \n     fn buffered_write(\n@@ -296,7 +300,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n         is_seqcst: bool,\n         clocks: &ThreadClockSet,\n         rng: &mut R,\n-    ) -> &StoreElement {\n+    ) -> (&StoreElement, LoadRecency) {\n         use rand::seq::IteratorRandom;\n         let mut found_sc = false;\n         // FIXME: we want an inclusive take_while (stops after a false predicate, but\n@@ -359,9 +363,12 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n                 }\n             });\n \n-        candidates\n-            .choose(rng)\n-            .expect(\"store buffer cannot be empty, an element is populated on construction\")\n+        let chosen = candidates.choose(rng).expect(\"store buffer cannot be empty\");\n+        if std::ptr::eq(chosen, self.buffer.back().expect(\"store buffer cannot be empty\")) {\n+            (chosen, LoadRecency::Latest)\n+        } else {\n+            (chosen, LoadRecency::Outdated)\n+        }\n     }\n \n     /// ATOMIC STORE IMPL in the paper (except we don't need the location's vector clock)\n@@ -499,13 +506,16 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n                     alloc_range(base_offset, place.layout.size),\n                     latest_in_mo,\n                 )?;\n-                let loaded = buffer.buffered_read(\n+                let (loaded, recency) = buffer.buffered_read(\n                     global,\n                     &this.machine.threads,\n                     atomic == AtomicReadOrd::SeqCst,\n                     &mut *rng,\n                     validate,\n                 )?;\n+                if global.track_outdated_loads && recency == LoadRecency::Outdated {\n+                    register_diagnostic(NonHaltingDiagnostic::WeakMemoryOutdatedLoad);\n+                }\n \n                 return Ok(loaded);\n             }"}, {"sha": "a378df0ad82b461b9bf749004f58dca0214797df", "filename": "src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/302e9ae206ed148fc009d84c05ce0c99877ef6aa/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/302e9ae206ed148fc009d84c05ce0c99877ef6aa/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=302e9ae206ed148fc009d84c05ce0c99877ef6aa", "patch": "@@ -74,6 +74,7 @@ pub enum NonHaltingDiagnostic {\n     Int2Ptr {\n         details: bool,\n     },\n+    WeakMemoryOutdatedLoad,\n }\n \n /// Level of Miri specific diagnostics\n@@ -474,6 +475,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         format!(\"progress report: current operation being executed is here\"),\n                     Int2Ptr { .. } =>\n                         format!(\"integer-to-pointer cast\"),\n+                    WeakMemoryOutdatedLoad =>\n+                        format!(\"weak memory emulation: outdated value returned from load\"),\n                 };\n \n                 let (title, diag_level) = match e {\n@@ -485,7 +488,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     | CreatedCallId(..)\n                     | CreatedAlloc(..)\n                     | FreedAlloc(..)\n-                    | ProgressReport => (\"tracking was triggered\", DiagLevel::Note),\n+                    | ProgressReport\n+                    | WeakMemoryOutdatedLoad =>\n+                        (\"tracking was triggered\", DiagLevel::Note),\n                 };\n \n                 let helps = match e {"}, {"sha": "53264bd465914e943ba5bf4b405dcf73085d5117", "filename": "src/eval.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/302e9ae206ed148fc009d84c05ce0c99877ef6aa/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/302e9ae206ed148fc009d84c05ce0c99877ef6aa/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=302e9ae206ed148fc009d84c05ce0c99877ef6aa", "patch": "@@ -102,6 +102,8 @@ pub struct MiriConfig {\n     pub data_race_detector: bool,\n     /// Determine if weak memory emulation should be enabled. Requires data race detection to be enabled\n     pub weak_memory_emulation: bool,\n+    /// Track when an outdated (weak memory) load happens.\n+    pub track_outdated_loads: bool,\n     /// Rate of spurious failures for compare_exchange_weak atomic operations,\n     /// between 0.0 and 1.0, defaulting to 0.8 (80% chance of failure).\n     pub cmpxchg_weak_failure_rate: f64,\n@@ -143,6 +145,7 @@ impl Default for MiriConfig {\n             tracked_alloc_ids: HashSet::default(),\n             data_race_detector: true,\n             weak_memory_emulation: true,\n+            track_outdated_loads: false,\n             cmpxchg_weak_failure_rate: 0.8, // 80%\n             measureme_out: None,\n             panic_on_unsupported: false,"}, {"sha": "c77de4ec51ff2a2e11cb3ded9f0f094715986271", "filename": "src/machine.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/302e9ae206ed148fc009d84c05ce0c99877ef6aa/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/302e9ae206ed148fc009d84c05ce0c99877ef6aa/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=302e9ae206ed148fc009d84c05ce0c99877ef6aa", "patch": "@@ -376,8 +376,11 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n         } else {\n             None\n         };\n-        let data_race =\n-            if config.data_race_detector { Some(data_race::GlobalState::new()) } else { None };\n+        let data_race = if config.data_race_detector {\n+            Some(data_race::GlobalState::new(config))\n+        } else {\n+            None\n+        };\n         Evaluator {\n             stacked_borrows,\n             data_race,"}]}