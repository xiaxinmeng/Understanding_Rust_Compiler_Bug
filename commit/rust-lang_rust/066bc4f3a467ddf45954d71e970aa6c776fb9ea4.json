{"sha": "066bc4f3a467ddf45954d71e970aa6c776fb9ea4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NmJjNGYzYTQ2N2RkZjQ1OTU0ZDcxZTk3MGFhNmM3NzZmYjllYTQ=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-23T23:32:56Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-23T23:32:56Z"}, "message": "Simplify", "tree": {"sha": "0972ba951e42e984f691a7deaf294940c3a02449", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0972ba951e42e984f691a7deaf294940c3a02449"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/066bc4f3a467ddf45954d71e970aa6c776fb9ea4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/066bc4f3a467ddf45954d71e970aa6c776fb9ea4", "html_url": "https://github.com/rust-lang/rust/commit/066bc4f3a467ddf45954d71e970aa6c776fb9ea4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/066bc4f3a467ddf45954d71e970aa6c776fb9ea4/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "511ae17d07f3be1db0f1d6c43ee4fd51eae881f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/511ae17d07f3be1db0f1d6c43ee4fd51eae881f9", "html_url": "https://github.com/rust-lang/rust/commit/511ae17d07f3be1db0f1d6c43ee4fd51eae881f9"}], "stats": {"total": 52, "additions": 24, "deletions": 28}, "files": [{"sha": "c0a4080dedda73e138ec9b2ec4e02a35ceedc325", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/066bc4f3a467ddf45954d71e970aa6c776fb9ea4/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066bc4f3a467ddf45954d71e970aa6c776fb9ea4/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=066bc4f3a467ddf45954d71e970aa6c776fb9ea4", "patch": "@@ -6,15 +6,11 @@ use ide_db::{\n     search::{FileReference, ReferenceAccess, SearchScope},\n     RootDatabase,\n };\n-use syntax::{\n-    ast, match_ast, AstNode,\n-    SyntaxKind::{ASYNC_KW, AWAIT_KW, QUESTION, RETURN_KW, THIN_ARROW},\n-    SyntaxNode, SyntaxToken, TextRange, WalkEvent,\n-};\n+use syntax::{ast, match_ast, AstNode, SyntaxNode, SyntaxToken, TextRange, WalkEvent, T};\n \n use crate::{display::TryToNav, references, NavigationTarget};\n \n-pub struct DocumentHighlight {\n+pub struct HighlightedRange {\n     pub range: TextRange,\n     pub access: Option<ReferenceAccess>,\n }\n@@ -28,19 +24,19 @@ pub struct DocumentHighlight {\n pub(crate) fn highlight_related(\n     sema: &Semantics<RootDatabase>,\n     position: FilePosition,\n-) -> Option<Vec<DocumentHighlight>> {\n-    let _p = profile::span(\"document_highlight\");\n+) -> Option<Vec<HighlightedRange>> {\n+    let _p = profile::span(\"highlight_related\");\n     let syntax = sema.parse(position.file_id).syntax().clone();\n \n     let token = pick_best_token(syntax.token_at_offset(position.offset), |kind| match kind {\n-        QUESTION => 2, // prefer `?` when the cursor is sandwiched like `await$0?`\n-        AWAIT_KW | ASYNC_KW | THIN_ARROW | RETURN_KW => 1,\n+        T![?] => 2, // prefer `?` when the cursor is sandwiched like `await$0?`\n+        T![await] | T![async] | T![->] | T![return] => 1,\n         _ => 0,\n     })?;\n \n     match token.kind() {\n-        QUESTION | RETURN_KW | THIN_ARROW => highlight_exit_points(sema, token),\n-        AWAIT_KW | ASYNC_KW => highlight_yield_points(token),\n+        T![?] | T![return] | T![->] => highlight_exit_points(sema, token),\n+        T![await] | T![async] => highlight_yield_points(token),\n         _ => highlight_references(sema, &syntax, position),\n     }\n }\n@@ -49,7 +45,7 @@ fn highlight_references(\n     sema: &Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n     FilePosition { offset, file_id }: FilePosition,\n-) -> Option<Vec<DocumentHighlight>> {\n+) -> Option<Vec<HighlightedRange>> {\n     let def = references::find_def(sema, syntax, offset)?;\n     let usages = def.usages(sema).set_scope(Some(SearchScope::single_file(file_id))).all();\n \n@@ -63,7 +59,7 @@ fn highlight_references(\n     .and_then(|decl| {\n         let range = decl.focus_range?;\n         let access = references::decl_access(&def, syntax, range);\n-        Some(DocumentHighlight { range, access })\n+        Some(HighlightedRange { range, access })\n     });\n \n     let file_refs = usages.references.get(&file_id).map_or(&[][..], Vec::as_slice);\n@@ -72,40 +68,40 @@ fn highlight_references(\n     res.extend(\n         file_refs\n             .iter()\n-            .map(|&FileReference { access, range, .. }| DocumentHighlight { range, access }),\n+            .map(|&FileReference { access, range, .. }| HighlightedRange { range, access }),\n     );\n     Some(res)\n }\n \n fn highlight_exit_points(\n     sema: &Semantics<RootDatabase>,\n     token: SyntaxToken,\n-) -> Option<Vec<DocumentHighlight>> {\n+) -> Option<Vec<HighlightedRange>> {\n     fn hl(\n         sema: &Semantics<RootDatabase>,\n         body: Option<ast::Expr>,\n-    ) -> Option<Vec<DocumentHighlight>> {\n+    ) -> Option<Vec<HighlightedRange>> {\n         let mut highlights = Vec::new();\n         let body = body?;\n         walk(&body, |node| {\n             match_ast! {\n                 match node {\n                     ast::ReturnExpr(expr) => if let Some(token) = expr.return_token() {\n-                        highlights.push(DocumentHighlight {\n+                        highlights.push(HighlightedRange {\n                             access: None,\n                             range: token.text_range(),\n                         });\n                     },\n                     ast::TryExpr(try_) => if let Some(token) = try_.question_mark_token() {\n-                        highlights.push(DocumentHighlight {\n+                        highlights.push(HighlightedRange {\n                             access: None,\n                             range: token.text_range(),\n                         });\n                     },\n                     ast::Expr(expr) => match expr {\n                         ast::Expr::MethodCallExpr(_) | ast::Expr::CallExpr(_) | ast::Expr::MacroCall(_) => {\n                             if sema.type_of_expr(&expr).map_or(false, |ty| ty.is_never()) {\n-                                highlights.push(DocumentHighlight {\n+                                highlights.push(HighlightedRange {\n                                     access: None,\n                                     range: expr.syntax().text_range(),\n                                 });\n@@ -128,7 +124,7 @@ fn highlight_exit_points(\n             e => Some(e),\n         };\n         if let Some(tail) = tail {\n-            highlights.push(DocumentHighlight { access: None, range: tail.syntax().text_range() });\n+            highlights.push(HighlightedRange { access: None, range: tail.syntax().text_range() });\n         }\n         Some(highlights)\n     }\n@@ -149,19 +145,19 @@ fn highlight_exit_points(\n     None\n }\n \n-fn highlight_yield_points(token: SyntaxToken) -> Option<Vec<DocumentHighlight>> {\n+fn highlight_yield_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n     fn hl(\n         async_token: Option<SyntaxToken>,\n         body: Option<ast::Expr>,\n-    ) -> Option<Vec<DocumentHighlight>> {\n+    ) -> Option<Vec<HighlightedRange>> {\n         let mut highlights = Vec::new();\n-        highlights.push(DocumentHighlight { access: None, range: async_token?.text_range() });\n+        highlights.push(HighlightedRange { access: None, range: async_token?.text_range() });\n         if let Some(body) = body {\n             walk(&body, |node| {\n                 match_ast! {\n                     match node {\n                         ast::AwaitExpr(expr) => if let Some(token) = expr.await_token() {\n-                            highlights.push(DocumentHighlight {\n+                            highlights.push(HighlightedRange {\n                                 access: None,\n                                 range: token.text_range(),\n                             });"}, {"sha": "dc1448f636fc446a65548f5653253c048cb08397", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/066bc4f3a467ddf45954d71e970aa6c776fb9ea4/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066bc4f3a467ddf45954d71e970aa6c776fb9ea4/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=066bc4f3a467ddf45954d71e970aa6c776fb9ea4", "patch": "@@ -76,7 +76,7 @@ pub use crate::{\n     expand_macro::ExpandedMacro,\n     file_structure::{StructureNode, StructureNodeKind},\n     folding_ranges::{Fold, FoldKind},\n-    highlight_related::DocumentHighlight,\n+    highlight_related::HighlightedRange,\n     hover::{HoverAction, HoverConfig, HoverDocFormat, HoverGotoTypeData, HoverResult},\n     inlay_hints::{InlayHint, InlayHintsConfig, InlayKind},\n     markup::Markup,\n@@ -489,7 +489,7 @@ impl Analysis {\n     pub fn highlight_related(\n         &self,\n         position: FilePosition,\n-    ) -> Cancellable<Option<Vec<DocumentHighlight>>> {\n+    ) -> Cancellable<Option<Vec<HighlightedRange>>> {\n         self.with_db(|db| highlight_related::highlight_related(&Semantics::new(db), position))\n     }\n "}, {"sha": "3e6ab70e469c9ad4739938e65549b47cff6b8cbf", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/066bc4f3a467ddf45954d71e970aa6c776fb9ea4/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066bc4f3a467ddf45954d71e970aa6c776fb9ea4/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=066bc4f3a467ddf45954d71e970aa6c776fb9ea4", "patch": "@@ -1174,7 +1174,7 @@ pub(crate) fn handle_document_highlight(\n     };\n     let res = refs\n         .into_iter()\n-        .map(|ide::DocumentHighlight { range, access }| lsp_types::DocumentHighlight {\n+        .map(|ide::HighlightedRange { range, access }| lsp_types::DocumentHighlight {\n             range: to_proto::range(&line_index, range),\n             kind: access.map(to_proto::document_highlight_kind),\n         })"}]}