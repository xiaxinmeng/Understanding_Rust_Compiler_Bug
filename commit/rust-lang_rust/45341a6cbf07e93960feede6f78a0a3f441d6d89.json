{"sha": "45341a6cbf07e93960feede6f78a0a3f441d6d89", "node_id": "C_kwDOAAsO6NoAKDQ1MzQxYTZjYmYwN2U5Mzk2MGZlZWRlNmY3OGEwYTNmNDQxZDZkODk", "commit": {"author": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2021-12-24T22:15:52Z"}, "committer": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2021-12-28T17:58:29Z"}, "message": "Rename a couple variables", "tree": {"sha": "fd1b21cb4c6dbb885b0e4ff4f1733bea361ef6c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd1b21cb4c6dbb885b0e4ff4f1733bea361ef6c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45341a6cbf07e93960feede6f78a0a3f441d6d89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45341a6cbf07e93960feede6f78a0a3f441d6d89", "html_url": "https://github.com/rust-lang/rust/commit/45341a6cbf07e93960feede6f78a0a3f441d6d89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45341a6cbf07e93960feede6f78a0a3f441d6d89/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a38ed12ca37c7147a973824f70c1b909c9c686c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a38ed12ca37c7147a973824f70c1b909c9c686c", "html_url": "https://github.com/rust-lang/rust/commit/9a38ed12ca37c7147a973824f70c1b909c9c686c"}], "stats": {"total": 39, "additions": 21, "deletions": 18}, "files": [{"sha": "1204f1979f02aba3f024014bb9e7327a43895068", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/45341a6cbf07e93960feede6f78a0a3f441d6d89/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45341a6cbf07e93960feede6f78a0a3f441d6d89/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=45341a6cbf07e93960feede6f78a0a3f441d6d89", "patch": "@@ -73,7 +73,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let method = method.unwrap();\n         // HACK(eddyb) ignore self in the definition (see above).\n-        let expected_arg_tys = self.expected_inputs_for_expected_output(\n+        let expected_input_tys = self.expected_inputs_for_expected_output(\n             sp,\n             expected,\n             method.sig.output(),\n@@ -83,7 +83,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             sp,\n             expr,\n             &method.sig.inputs()[1..],\n-            &expected_arg_tys[..],\n+            &expected_input_tys[..],\n             args_no_rcvr,\n             method.sig.c_variadic,\n             tuple_arguments,\n@@ -249,18 +249,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             err.emit();\n         };\n \n-        let mut expected_arg_tys = expected_input_tys.to_vec();\n+        let mut expected_input_tys = expected_input_tys.to_vec();\n \n-        let formal_tys = if tuple_arguments == TupleArguments {\n+        let formal_input_tys = if tuple_arguments == TupleArguments {\n             let tuple_type = self.structurally_resolved_type(call_span, formal_input_tys[0]);\n             match tuple_type.kind() {\n                 ty::Tuple(arg_types) if arg_types.len() != provided_args.len() => {\n                     param_count_error(arg_types.len(), provided_args.len(), \"E0057\", false, false);\n-                    expected_arg_tys = vec![];\n+                    expected_input_tys = vec![];\n                     self.err_args(provided_args.len())\n                 }\n                 ty::Tuple(arg_types) => {\n-                    expected_arg_tys = match expected_arg_tys.get(0) {\n+                    expected_input_tys = match expected_input_tys.get(0) {\n                         Some(&ty) => match ty.kind() {\n                             ty::Tuple(ref tys) => tys.iter().map(|k| k.expect_ty()).collect(),\n                             _ => vec![],\n@@ -278,7 +278,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                          for the function trait is neither a tuple nor unit\"\n                     )\n                     .emit();\n-                    expected_arg_tys = vec![];\n+                    expected_input_tys = vec![];\n                     self.err_args(provided_args.len())\n                 }\n             }\n@@ -289,32 +289,35 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 formal_input_tys.to_vec()\n             } else {\n                 param_count_error(expected_arg_count, supplied_arg_count, \"E0060\", true, false);\n-                expected_arg_tys = vec![];\n+                expected_input_tys = vec![];\n                 self.err_args(supplied_arg_count)\n             }\n         } else {\n             // is the missing argument of type `()`?\n-            let sugg_unit = if expected_arg_tys.len() == 1 && supplied_arg_count == 0 {\n-                self.resolve_vars_if_possible(expected_arg_tys[0]).is_unit()\n+            let sugg_unit = if expected_input_tys.len() == 1 && supplied_arg_count == 0 {\n+                self.resolve_vars_if_possible(expected_input_tys[0]).is_unit()\n             } else if formal_input_tys.len() == 1 && supplied_arg_count == 0 {\n                 self.resolve_vars_if_possible(formal_input_tys[0]).is_unit()\n             } else {\n                 false\n             };\n             param_count_error(expected_arg_count, supplied_arg_count, \"E0061\", false, sugg_unit);\n \n-            expected_arg_tys = vec![];\n+            expected_input_tys = vec![];\n             self.err_args(supplied_arg_count)\n         };\n \n         debug!(\n-            \"check_argument_types: formal_tys={:?}\",\n-            formal_tys.iter().map(|t| self.ty_to_string(*t)).collect::<Vec<String>>()\n+            \"check_argument_types: formal_input_tys={:?}\",\n+            formal_input_tys.iter().map(|t| self.ty_to_string(*t)).collect::<Vec<String>>()\n         );\n \n-        // If there is no expectation, expect formal_tys.\n-        let expected_arg_tys =\n-            if !expected_arg_tys.is_empty() { expected_arg_tys } else { formal_tys.clone() };\n+        // If there is no expectation, expect formal_input_tys.\n+        let expected_input_tys = if !expected_input_tys.is_empty() {\n+            expected_input_tys\n+        } else {\n+            formal_input_tys.clone()\n+        };\n \n         let mut final_arg_types: Vec<(usize, Ty<'_>, Ty<'_>)> = vec![];\n \n@@ -366,12 +369,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     continue;\n                 }\n \n-                let formal_ty = formal_tys[i];\n+                let formal_ty = formal_input_tys[i];\n                 debug!(\"checking argument {}: {:?} = {:?}\", i, arg, formal_ty);\n \n                 // The special-cased logic below has three functions:\n                 // 1. Provide as good of an expected type as possible.\n-                let expected = Expectation::rvalue_hint(self, expected_arg_tys[i]);\n+                let expected = Expectation::rvalue_hint(self, expected_input_tys[i]);\n \n                 let checked_ty = self.check_expr_with_expectation(&arg, expected);\n "}]}