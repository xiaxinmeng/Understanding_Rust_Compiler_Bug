{"sha": "55efa966594cd375b6bace6c0b4481108806d8a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ZWZhOTY2NTk0Y2QzNzViNmJhY2U2YzBiNDQ4MTEwODgwNmQ4YTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-10T14:11:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-10T14:11:27Z"}, "message": "Auto merge of #5931 - montrivo:unit-arg, r=flip1995\n\nimprove the suggestion of the lint `unit-arg`\n\nFixes #5823\nFixes #6015\n\nChanges\n```\nhelp: move the expression in front of the call...\n  |\n3 |     g();\n  |\nhelp: ...and use a unit literal instead\n  |\n3 |     o.map_or((), |i| f(i))\n  |\n```\ninto\n```\nhelp: move the expression in front of the call and replace it with the unit literal `()`\n  |\n3 |     g();\n  |     o.map_or((), |i| f(i))\n  |\n```\nchangelog: improve the suggestion of the lint `unit-arg`", "tree": {"sha": "b7f7159f7ad13452213cc1d86a1c788f52336c2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7f7159f7ad13452213cc1d86a1c788f52336c2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55efa966594cd375b6bace6c0b4481108806d8a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55efa966594cd375b6bace6c0b4481108806d8a2", "html_url": "https://github.com/rust-lang/rust/commit/55efa966594cd375b6bace6c0b4481108806d8a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55efa966594cd375b6bace6c0b4481108806d8a2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e9769e78794cfc07f9774ffffd05e962ee3874f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e9769e78794cfc07f9774ffffd05e962ee3874f", "html_url": "https://github.com/rust-lang/rust/commit/0e9769e78794cfc07f9774ffffd05e962ee3874f"}, {"sha": "b220ddf146f4c11011b2e1b7f37ecb8e5485555b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b220ddf146f4c11011b2e1b7f37ecb8e5485555b", "html_url": "https://github.com/rust-lang/rust/commit/b220ddf146f4c11011b2e1b7f37ecb8e5485555b"}], "stats": {"total": 340, "additions": 203, "deletions": 137}, "files": [{"sha": "6c6188d61ad52fc6f492453ec95667fba4e67662", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 85, "deletions": 36, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/55efa966594cd375b6bace6c0b4481108806d8a2/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55efa966594cd375b6bace6c0b4481108806d8a2/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=55efa966594cd375b6bace6c0b4481108806d8a2", "patch": "@@ -11,8 +11,8 @@ use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{\n     BinOpKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericParamKind, HirId, ImplItem,\n-    ImplItemKind, Item, ItemKind, Lifetime, Local, MatchSource, MutTy, Mutability, QPath, Stmt, StmtKind, TraitFn,\n-    TraitItem, TraitItemKind, TyKind, UnOp,\n+    ImplItemKind, Item, ItemKind, Lifetime, Local, MatchSource, MutTy, Mutability, Node, QPath, Stmt, StmtKind,\n+    TraitFn, TraitItem, TraitItemKind, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n@@ -31,8 +31,8 @@ use crate::utils::paths;\n use crate::utils::{\n     clip, comparisons, differing_macro_contexts, higher, in_constant, indent_of, int_bits, is_type_diagnostic_item,\n     last_path_segment, match_def_path, match_path, method_chain_args, multispan_sugg, numeric_literal::NumericLiteral,\n-    qpath_res, sext, snippet, snippet_block_with_applicability, snippet_opt, snippet_with_applicability,\n-    snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, unsext,\n+    qpath_res, reindent_multiline, sext, snippet, snippet_opt, snippet_with_applicability, snippet_with_macro_callsite,\n+    span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, unsext,\n };\n \n declare_clippy_lint! {\n@@ -805,6 +805,45 @@ impl<'tcx> LateLintPass<'tcx> for UnitArg {\n     }\n }\n \n+fn fmt_stmts_and_call(\n+    cx: &LateContext<'_>,\n+    call_expr: &Expr<'_>,\n+    call_snippet: &str,\n+    args_snippets: &[impl AsRef<str>],\n+    non_empty_block_args_snippets: &[impl AsRef<str>],\n+) -> String {\n+    let call_expr_indent = indent_of(cx, call_expr.span).unwrap_or(0);\n+    let call_snippet_with_replacements = args_snippets\n+        .iter()\n+        .fold(call_snippet.to_owned(), |acc, arg| acc.replacen(arg.as_ref(), \"()\", 1));\n+\n+    let mut stmts_and_call = non_empty_block_args_snippets\n+        .iter()\n+        .map(|it| it.as_ref().to_owned())\n+        .collect::<Vec<_>>();\n+    stmts_and_call.push(call_snippet_with_replacements);\n+    stmts_and_call = stmts_and_call\n+        .into_iter()\n+        .map(|v| reindent_multiline(v.into(), true, Some(call_expr_indent)).into_owned())\n+        .collect();\n+\n+    let mut stmts_and_call_snippet = stmts_and_call.join(&format!(\"{}{}\", \";\\n\", \" \".repeat(call_expr_indent)));\n+    // expr is not in a block statement or result expression position, wrap in a block\n+    let parent_node = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(call_expr.hir_id));\n+    if !matches!(parent_node, Some(Node::Block(_))) && !matches!(parent_node, Some(Node::Stmt(_))) {\n+        let block_indent = call_expr_indent + 4;\n+        stmts_and_call_snippet =\n+            reindent_multiline(stmts_and_call_snippet.into(), true, Some(block_indent)).into_owned();\n+        stmts_and_call_snippet = format!(\n+            \"{{\\n{}{}\\n{}}}\",\n+            \" \".repeat(block_indent),\n+            &stmts_and_call_snippet,\n+            \" \".repeat(call_expr_indent)\n+        );\n+    }\n+    stmts_and_call_snippet\n+}\n+\n fn lint_unit_args(cx: &LateContext<'_>, expr: &Expr<'_>, args_to_recover: &[&Expr<'_>]) {\n     let mut applicability = Applicability::MachineApplicable;\n     let (singular, plural) = if args_to_recover.len() > 1 {\n@@ -847,43 +886,52 @@ fn lint_unit_args(cx: &LateContext<'_>, expr: &Expr<'_>, args_to_recover: &[&Exp\n                         Applicability::MaybeIncorrect,\n                     );\n                     or = \"or \";\n+                    applicability = Applicability::MaybeIncorrect;\n                 });\n-            let sugg = args_to_recover\n+\n+            let arg_snippets: Vec<String> = args_to_recover\n+                .iter()\n+                .filter_map(|arg| snippet_opt(cx, arg.span))\n+                .collect();\n+            let arg_snippets_without_empty_blocks: Vec<String> = args_to_recover\n                 .iter()\n                 .filter(|arg| !is_empty_block(arg))\n-                .enumerate()\n-                .map(|(i, arg)| {\n-                    let indent = if i == 0 {\n-                        0\n-                    } else {\n-                        indent_of(cx, expr.span).unwrap_or(0)\n-                    };\n-                    format!(\n-                        \"{}{};\",\n-                        \" \".repeat(indent),\n-                        snippet_block_with_applicability(cx, arg.span, \"..\", Some(expr.span), &mut applicability)\n-                    )\n-                })\n-                .collect::<Vec<String>>();\n-            let mut and = \"\";\n-            if !sugg.is_empty() {\n-                let plural = if sugg.len() > 1 { \"s\" } else { \"\" };\n-                db.span_suggestion(\n-                    expr.span.with_hi(expr.span.lo()),\n-                    &format!(\"{}move the expression{} in front of the call...\", or, plural),\n-                    format!(\"{}\\n\", sugg.join(\"\\n\")),\n-                    applicability,\n+                .filter_map(|arg| snippet_opt(cx, arg.span))\n+                .collect();\n+\n+            if let Some(call_snippet) = snippet_opt(cx, expr.span) {\n+                let sugg = fmt_stmts_and_call(\n+                    cx,\n+                    expr,\n+                    &call_snippet,\n+                    &arg_snippets,\n+                    &arg_snippets_without_empty_blocks,\n                 );\n-                and = \"...and \"\n+\n+                if arg_snippets_without_empty_blocks.is_empty() {\n+                    db.multipart_suggestion(\n+                        &format!(\"use {}unit literal{} instead\", singular, plural),\n+                        args_to_recover\n+                            .iter()\n+                            .map(|arg| (arg.span, \"()\".to_string()))\n+                            .collect::<Vec<_>>(),\n+                        applicability,\n+                    );\n+                } else {\n+                    let plural = arg_snippets_without_empty_blocks.len() > 1;\n+                    let empty_or_s = if plural { \"s\" } else { \"\" };\n+                    let it_or_them = if plural { \"them\" } else { \"it\" };\n+                    db.span_suggestion(\n+                        expr.span,\n+                        &format!(\n+                            \"{}move the expression{} in front of the call and replace {} with the unit literal `()`\",\n+                            or, empty_or_s, it_or_them\n+                        ),\n+                        sugg,\n+                        applicability,\n+                    );\n+                }\n             }\n-            db.multipart_suggestion(\n-                &format!(\"{}use {}unit literal{} instead\", and, singular, plural),\n-                args_to_recover\n-                    .iter()\n-                    .map(|arg| (arg.span, \"()\".to_string()))\n-                    .collect::<Vec<_>>(),\n-                applicability,\n-            );\n         },\n     );\n }\n@@ -2058,6 +2106,7 @@ impl PartialOrd for FullInt {\n         })\n     }\n }\n+\n impl Ord for FullInt {\n     #[must_use]\n     fn cmp(&self, other: &Self) -> Ordering {"}, {"sha": "3ebbfed6456273638409bceffc8f6faa9c572d02", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 54, "deletions": 42, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/55efa966594cd375b6bace6c0b4481108806d8a2/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55efa966594cd375b6bace6c0b4481108806d8a2/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=55efa966594cd375b6bace6c0b4481108806d8a2", "patch": "@@ -19,6 +19,7 @@ pub mod paths;\n pub mod ptr;\n pub mod sugg;\n pub mod usage;\n+\n pub use self::attrs::*;\n pub use self::diagnostics::*;\n pub use self::hir_utils::{both, eq_expr_value, over, SpanlessEq, SpanlessHash};\n@@ -108,6 +109,7 @@ pub fn in_macro(span: Span) -> bool {\n         false\n     }\n }\n+\n // If the snippet is empty, it's an attribute that was inserted during macro\n // expansion and we want to ignore those, because they could come from external\n // sources that the user has no control over.\n@@ -571,7 +573,7 @@ pub fn snippet_block<'a, T: LintContext>(\n ) -> Cow<'a, str> {\n     let snip = snippet(cx, span, default);\n     let indent = indent_relative_to.and_then(|s| indent_of(cx, s));\n-    trim_multiline(snip, true, indent)\n+    reindent_multiline(snip, true, indent)\n }\n \n /// Same as `snippet_block`, but adapts the applicability level by the rules of\n@@ -585,7 +587,7 @@ pub fn snippet_block_with_applicability<'a, T: LintContext>(\n ) -> Cow<'a, str> {\n     let snip = snippet_with_applicability(cx, span, default, applicability);\n     let indent = indent_relative_to.and_then(|s| indent_of(cx, s));\n-    trim_multiline(snip, true, indent)\n+    reindent_multiline(snip, true, indent)\n }\n \n /// Returns a new Span that extends the original Span to the first non-whitespace char of the first\n@@ -661,16 +663,16 @@ pub fn expr_block<'a, T: LintContext>(\n     }\n }\n \n-/// Trim indentation from a multiline string with possibility of ignoring the\n-/// first line.\n-fn trim_multiline(s: Cow<'_, str>, ignore_first: bool, indent: Option<usize>) -> Cow<'_, str> {\n-    let s_space = trim_multiline_inner(s, ignore_first, indent, ' ');\n-    let s_tab = trim_multiline_inner(s_space, ignore_first, indent, '\\t');\n-    trim_multiline_inner(s_tab, ignore_first, indent, ' ')\n+/// Reindent a multiline string with possibility of ignoring the first line.\n+#[allow(clippy::needless_pass_by_value)]\n+pub fn reindent_multiline(s: Cow<'_, str>, ignore_first: bool, indent: Option<usize>) -> Cow<'_, str> {\n+    let s_space = reindent_multiline_inner(&s, ignore_first, indent, ' ');\n+    let s_tab = reindent_multiline_inner(&s_space, ignore_first, indent, '\\t');\n+    reindent_multiline_inner(&s_tab, ignore_first, indent, ' ').into()\n }\n \n-fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, indent: Option<usize>, ch: char) -> Cow<'_, str> {\n-    let mut x = s\n+fn reindent_multiline_inner(s: &str, ignore_first: bool, indent: Option<usize>, ch: char) -> String {\n+    let x = s\n         .lines()\n         .skip(ignore_first as usize)\n         .filter_map(|l| {\n@@ -683,26 +685,20 @@ fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, indent: Option<usiz\n         })\n         .min()\n         .unwrap_or(0);\n-    if let Some(indent) = indent {\n-        x = x.saturating_sub(indent);\n-    }\n-    if x > 0 {\n-        Cow::Owned(\n-            s.lines()\n-                .enumerate()\n-                .map(|(i, l)| {\n-                    if (ignore_first && i == 0) || l.is_empty() {\n-                        l\n-                    } else {\n-                        l.split_at(x).1\n-                    }\n-                })\n-                .collect::<Vec<_>>()\n-                .join(\"\\n\"),\n-        )\n-    } else {\n-        s\n-    }\n+    let indent = indent.unwrap_or(0);\n+    s.lines()\n+        .enumerate()\n+        .map(|(i, l)| {\n+            if (ignore_first && i == 0) || l.is_empty() {\n+                l.to_owned()\n+            } else if x > indent {\n+                l.split_at(x - indent).1.to_owned()\n+            } else {\n+                \" \".repeat(indent - x) + l\n+            }\n+        })\n+        .collect::<Vec<String>>()\n+        .join(\"\\n\")\n }\n \n /// Gets the parent expression, if any \u2013- this is useful to constrain a lint.\n@@ -1474,26 +1470,26 @@ macro_rules! unwrap_cargo_metadata {\n \n #[cfg(test)]\n mod test {\n-    use super::{trim_multiline, without_block_comments};\n+    use super::{reindent_multiline, without_block_comments};\n \n     #[test]\n-    fn test_trim_multiline_single_line() {\n-        assert_eq!(\"\", trim_multiline(\"\".into(), false, None));\n-        assert_eq!(\"...\", trim_multiline(\"...\".into(), false, None));\n-        assert_eq!(\"...\", trim_multiline(\"    ...\".into(), false, None));\n-        assert_eq!(\"...\", trim_multiline(\"\\t...\".into(), false, None));\n-        assert_eq!(\"...\", trim_multiline(\"\\t\\t...\".into(), false, None));\n+    fn test_reindent_multiline_single_line() {\n+        assert_eq!(\"\", reindent_multiline(\"\".into(), false, None));\n+        assert_eq!(\"...\", reindent_multiline(\"...\".into(), false, None));\n+        assert_eq!(\"...\", reindent_multiline(\"    ...\".into(), false, None));\n+        assert_eq!(\"...\", reindent_multiline(\"\\t...\".into(), false, None));\n+        assert_eq!(\"...\", reindent_multiline(\"\\t\\t...\".into(), false, None));\n     }\n \n     #[test]\n     #[rustfmt::skip]\n-    fn test_trim_multiline_block() {\n+    fn test_reindent_multiline_block() {\n         assert_eq!(\"\\\n     if x {\n         y\n     } else {\n         z\n-    }\", trim_multiline(\"    if x {\n+    }\", reindent_multiline(\"    if x {\n             y\n         } else {\n             z\n@@ -1503,7 +1499,7 @@ mod test {\n     \\ty\n     } else {\n     \\tz\n-    }\", trim_multiline(\"    if x {\n+    }\", reindent_multiline(\"    if x {\n         \\ty\n         } else {\n         \\tz\n@@ -1512,21 +1508,37 @@ mod test {\n \n     #[test]\n     #[rustfmt::skip]\n-    fn test_trim_multiline_empty_line() {\n+    fn test_reindent_multiline_empty_line() {\n         assert_eq!(\"\\\n     if x {\n         y\n \n     } else {\n         z\n-    }\", trim_multiline(\"    if x {\n+    }\", reindent_multiline(\"    if x {\n             y\n \n         } else {\n             z\n         }\".into(), false, None));\n     }\n \n+    #[test]\n+    #[rustfmt::skip]\n+    fn test_reindent_multiline_lines_deeper() {\n+        assert_eq!(\"\\\n+        if x {\n+            y\n+        } else {\n+            z\n+        }\", reindent_multiline(\"\\\n+    if x {\n+        y\n+    } else {\n+        z\n+    }\".into(), true, Some(8)));\n+    }\n+\n     #[test]\n     fn test_without_block_comments_lines_without_block_comments() {\n         let result = without_block_comments(vec![\"/*\", \"\", \"*/\"]);"}, {"sha": "fec115ff29d6699cd82adafbf5d34dbcc1e25d3a", "filename": "tests/ui/unit_arg.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/55efa966594cd375b6bace6c0b4481108806d8a2/tests%2Fui%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55efa966594cd375b6bace6c0b4481108806d8a2/tests%2Fui%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_arg.rs?ref=55efa966594cd375b6bace6c0b4481108806d8a2", "patch": "@@ -1,5 +1,11 @@\n #![warn(clippy::unit_arg)]\n-#![allow(clippy::no_effect, unused_must_use, unused_variables)]\n+#![allow(\n+    clippy::no_effect,\n+    unused_must_use,\n+    unused_variables,\n+    clippy::unused_unit,\n+    clippy::or_fun_call\n+)]\n \n use std::fmt::Debug;\n \n@@ -47,6 +53,11 @@ fn bad() {\n             foo(3);\n         },\n     );\n+    // here Some(foo(2)) isn't the top level statement expression, wrap the suggestion in a block\n+    None.or(Some(foo(2)));\n+    // in this case, the suggestion can be inlined, no need for a surrounding block\n+    // foo(()); foo(()) instead of { foo(()); foo(()) }\n+    foo(foo(()))\n }\n \n fn ok() {"}, {"sha": "90fee3aab23b0c96cd3b8cff521f208ad8cff55d", "filename": "tests/ui/unit_arg.stderr", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/55efa966594cd375b6bace6c0b4481108806d8a2/tests%2Fui%2Funit_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/55efa966594cd375b6bace6c0b4481108806d8a2/tests%2Fui%2Funit_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_arg.stderr?ref=55efa966594cd375b6bace6c0b4481108806d8a2", "patch": "@@ -1,5 +1,5 @@\n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:23:5\n+  --> $DIR/unit_arg.rs:29:5\n    |\n LL | /     foo({\n LL | |         1;\n@@ -11,34 +11,28 @@ help: remove the semicolon from the last statement in the block\n    |\n LL |         1\n    |\n-help: or move the expression in front of the call...\n+help: or move the expression in front of the call and replace it with the unit literal `()`\n    |\n LL |     {\n LL |         1;\n LL |     };\n-   |\n-help: ...and use a unit literal instead\n-   |\n LL |     foo(());\n-   |         ^^\n+   |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:26:5\n+  --> $DIR/unit_arg.rs:32:5\n    |\n LL |     foo(foo(1));\n    |     ^^^^^^^^^^^\n    |\n-help: move the expression in front of the call...\n+help: move the expression in front of the call and replace it with the unit literal `()`\n    |\n LL |     foo(1);\n-   |\n-help: ...and use a unit literal instead\n-   |\n LL |     foo(());\n-   |         ^^\n+   |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:27:5\n+  --> $DIR/unit_arg.rs:33:5\n    |\n LL | /     foo({\n LL | |         foo(1);\n@@ -50,20 +44,17 @@ help: remove the semicolon from the last statement in the block\n    |\n LL |         foo(2)\n    |\n-help: or move the expression in front of the call...\n+help: or move the expression in front of the call and replace it with the unit literal `()`\n    |\n LL |     {\n LL |         foo(1);\n LL |         foo(2);\n LL |     };\n-   |\n-help: ...and use a unit literal instead\n-   |\n LL |     foo(());\n-   |         ^^\n+   |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:32:5\n+  --> $DIR/unit_arg.rs:38:5\n    |\n LL | /     b.bar({\n LL | |         1;\n@@ -74,35 +65,29 @@ help: remove the semicolon from the last statement in the block\n    |\n LL |         1\n    |\n-help: or move the expression in front of the call...\n+help: or move the expression in front of the call and replace it with the unit literal `()`\n    |\n LL |     {\n LL |         1;\n LL |     };\n-   |\n-help: ...and use a unit literal instead\n-   |\n LL |     b.bar(());\n-   |           ^^\n+   |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:35:5\n+  --> $DIR/unit_arg.rs:41:5\n    |\n LL |     taking_multiple_units(foo(0), foo(1));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: move the expressions in front of the call...\n+help: move the expressions in front of the call and replace them with the unit literal `()`\n    |\n LL |     foo(0);\n LL |     foo(1);\n-   |\n-help: ...and use unit literals instead\n-   |\n LL |     taking_multiple_units((), ());\n-   |                           ^^  ^^\n+   |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:36:5\n+  --> $DIR/unit_arg.rs:42:5\n    |\n LL | /     taking_multiple_units(foo(0), {\n LL | |         foo(1);\n@@ -114,21 +99,18 @@ help: remove the semicolon from the last statement in the block\n    |\n LL |         foo(2)\n    |\n-help: or move the expressions in front of the call...\n+help: or move the expressions in front of the call and replace them with the unit literal `()`\n    |\n LL |     foo(0);\n LL |     {\n LL |         foo(1);\n LL |         foo(2);\n LL |     };\n-   |\n-help: ...and use unit literals instead\n-   |\n LL |     taking_multiple_units((), ());\n-   |                           ^^  ^^\n+   |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:40:5\n+  --> $DIR/unit_arg.rs:46:5\n    |\n LL | /     taking_multiple_units(\n LL | |         {\n@@ -147,7 +129,7 @@ help: remove the semicolon from the last statement in the block\n    |\n LL |             foo(3)\n    |\n-help: or move the expressions in front of the call...\n+help: or move the expressions in front of the call and replace them with the unit literal `()`\n    |\n LL |     {\n LL |         foo(0);\n@@ -156,26 +138,44 @@ LL |     };\n LL |     {\n LL |         foo(2);\n  ...\n-help: ...and use unit literals instead\n+\n+error: passing a unit value to a function\n+  --> $DIR/unit_arg.rs:57:13\n+   |\n+LL |     None.or(Some(foo(2)));\n+   |             ^^^^^^^^^^^^\n    |\n-LL |         (),\n-LL |         (),\n+help: move the expression in front of the call and replace it with the unit literal `()`\n+   |\n+LL |     None.or({\n+LL |         foo(2);\n+LL |         Some(())\n+LL |     });\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:82:5\n+  --> $DIR/unit_arg.rs:60:5\n    |\n-LL |     Some(foo(1))\n+LL |     foo(foo(()))\n    |     ^^^^^^^^^^^^\n    |\n-help: move the expression in front of the call...\n+help: move the expression in front of the call and replace it with the unit literal `()`\n    |\n-LL |     foo(1);\n+LL |     foo(());\n+LL |     foo(())\n    |\n-help: ...and use a unit literal instead\n+\n+error: passing a unit value to a function\n+  --> $DIR/unit_arg.rs:93:5\n    |\n+LL |     Some(foo(1))\n+   |     ^^^^^^^^^^^^\n+   |\n+help: move the expression in front of the call and replace it with the unit literal `()`\n+   |\n+LL |     foo(1);\n LL |     Some(())\n-   |          ^^\n+   |\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 10 previous errors\n "}, {"sha": "456b12a2c6b1654a7b18b2325603f740593ce8aa", "filename": "tests/ui/unit_arg_empty_blocks.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/55efa966594cd375b6bace6c0b4481108806d8a2/tests%2Fui%2Funit_arg_empty_blocks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/55efa966594cd375b6bace6c0b4481108806d8a2/tests%2Fui%2Funit_arg_empty_blocks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_arg_empty_blocks.stderr?ref=55efa966594cd375b6bace6c0b4481108806d8a2", "patch": "@@ -22,30 +22,24 @@ error: passing unit values to a function\n LL |     taking_two_units({}, foo(0));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: move the expression in front of the call...\n+help: move the expression in front of the call and replace it with the unit literal `()`\n    |\n LL |     foo(0);\n-   |\n-help: ...and use unit literals instead\n-   |\n LL |     taking_two_units((), ());\n-   |                      ^^  ^^\n+   |\n \n error: passing unit values to a function\n   --> $DIR/unit_arg_empty_blocks.rs:18:5\n    |\n LL |     taking_three_units({}, foo(0), foo(1));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: move the expressions in front of the call...\n+help: move the expressions in front of the call and replace them with the unit literal `()`\n    |\n LL |     foo(0);\n LL |     foo(1);\n-   |\n-help: ...and use unit literals instead\n-   |\n LL |     taking_three_units((), (), ());\n-   |                        ^^  ^^  ^^\n+   |\n \n error: aborting due to 4 previous errors\n "}]}