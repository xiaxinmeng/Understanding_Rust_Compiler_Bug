{"sha": "111724f5e2baa8b54612295352ba7b17a29b6059", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExMTcyNGY1ZTJiYWE4YjU0NjEyMjk1MzUyYmE3YjE3YTI5YjYwNTk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-07T07:15:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-07T07:15:21Z"}, "message": "Rollup merge of #68985 - daboross:fix-35813, r=Centril\n\nParse & reject postfix operators after casts\n\nThis adds an explicit error messages for when parsing `x as Type[0]` or similar expressions. Our add an extra parse case for parsing any postfix operator (dot, indexing, method calls, await) that triggers directly after parsing `as` expressions.\n\nMy friend and I worked on this together, but they're still deciding on a github username and thus I'm submitting this for both of us.\n\nIt will immediately error out, but will also provide the rest of the parser with a useful parse tree to deal with.\n\nThere's one decision we made in how this produces the parse tree. In the situation `&x as T[0]`, one could imagine this parsing as either `&((x as T)[0])` or `((&x) as T)[0]`. We chose the latter for ease of implementation, and as it seemed the most intuitive.\n\nFeedback welcome! This is our first change to the parser section, and it might be completely horrible.\n\nFixes #35813.", "tree": {"sha": "a3ea342d66d0bf819c9220c0d01669c77418ca06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3ea342d66d0bf819c9220c0d01669c77418ca06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/111724f5e2baa8b54612295352ba7b17a29b6059", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeY0oJCRBK7hj4Ov3rIwAAdHIIAA6hZ3YhYlTjvM6LFQqVTnOC\nJpeUqYKgj3kIZ5yMxPkuvzN1KFR0hC38mQYBH27bIrtdr3EgMM5dhXOaxHBsykle\nd4iw6Qpldy8BhCrSK5zh8HCprHrQNB1StnuPZqXH/QUd71RXDeZbztbFl8wj4OOT\n5nIcP9qDFS7w+OCg8b9v9a6iLfPhJVCHHtc3HmCJAIY4emcrFKlB2IWESl1jGcSY\naDkQzpgFHBTIa73zs+3ig8bxrNAAPJWDwBpGlA2Zo3TClolf6/CUygoHrAMz7Q3B\n2hSV4RVcXCbZ6fgYtmXXEYW+P1jzLh5xythB9Kl+b2SF96fddsPWFlKCIgn6HaE=\n=cG0E\n-----END PGP SIGNATURE-----\n", "payload": "tree a3ea342d66d0bf819c9220c0d01669c77418ca06\nparent e8bb6c05ab455999ccfe10e178bc2ada9d450187\nparent 453c5051476fab4d09f6d16bdbf37043c5c26a27\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1583565321 +0100\ncommitter GitHub <noreply@github.com> 1583565321 +0100\n\nRollup merge of #68985 - daboross:fix-35813, r=Centril\n\nParse & reject postfix operators after casts\n\nThis adds an explicit error messages for when parsing `x as Type[0]` or similar expressions. Our add an extra parse case for parsing any postfix operator (dot, indexing, method calls, await) that triggers directly after parsing `as` expressions.\n\nMy friend and I worked on this together, but they're still deciding on a github username and thus I'm submitting this for both of us.\n\nIt will immediately error out, but will also provide the rest of the parser with a useful parse tree to deal with.\n\nThere's one decision we made in how this produces the parse tree. In the situation `&x as T[0]`, one could imagine this parsing as either `&((x as T)[0])` or `((&x) as T)[0]`. We chose the latter for ease of implementation, and as it seemed the most intuitive.\n\nFeedback welcome! This is our first change to the parser section, and it might be completely horrible.\n\nFixes #35813.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/111724f5e2baa8b54612295352ba7b17a29b6059", "html_url": "https://github.com/rust-lang/rust/commit/111724f5e2baa8b54612295352ba7b17a29b6059", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/111724f5e2baa8b54612295352ba7b17a29b6059/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8bb6c05ab455999ccfe10e178bc2ada9d450187", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8bb6c05ab455999ccfe10e178bc2ada9d450187", "html_url": "https://github.com/rust-lang/rust/commit/e8bb6c05ab455999ccfe10e178bc2ada9d450187"}, {"sha": "453c5051476fab4d09f6d16bdbf37043c5c26a27", "url": "https://api.github.com/repos/rust-lang/rust/commits/453c5051476fab4d09f6d16bdbf37043c5c26a27", "html_url": "https://github.com/rust-lang/rust/commit/453c5051476fab4d09f6d16bdbf37043c5c26a27"}], "stats": {"total": 686, "additions": 671, "deletions": 15}, "files": [{"sha": "e425ca6c4dd7f8f0274a3e3bd1545ccb5cbe0ecf", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 58, "deletions": 5, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/111724f5e2baa8b54612295352ba7b17a29b6059/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/111724f5e2baa8b54612295352ba7b17a29b6059/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=111724f5e2baa8b54612295352ba7b17a29b6059", "patch": "@@ -544,8 +544,8 @@ impl<'a> Parser<'a> {\n         // Save the state of the parser before parsing type normally, in case there is a\n         // LessThan comparison after this cast.\n         let parser_snapshot_before_type = self.clone();\n-        match self.parse_ty_no_plus() {\n-            Ok(rhs) => Ok(mk_expr(self, rhs)),\n+        let cast_expr = match self.parse_ty_no_plus() {\n+            Ok(rhs) => mk_expr(self, rhs),\n             Err(mut type_err) => {\n                 // Rewind to before attempting to parse the type with generics, to recover\n                 // from situations like `x as usize < y` in which we first tried to parse\n@@ -599,17 +599,70 @@ impl<'a> Parser<'a> {\n                             )\n                             .emit();\n \n-                        Ok(expr)\n+                        expr\n                     }\n                     Err(mut path_err) => {\n                         // Couldn't parse as a path, return original error and parser state.\n                         path_err.cancel();\n                         mem::replace(self, parser_snapshot_after_type);\n-                        Err(type_err)\n+                        return Err(type_err);\n                     }\n                 }\n             }\n-        }\n+        };\n+\n+        self.parse_and_disallow_postfix_after_cast(cast_expr)\n+    }\n+\n+    /// Parses a postfix operators such as `.`, `?`, or index (`[]`) after a cast,\n+    /// then emits an error and returns the newly parsed tree.\n+    /// The resulting parse tree for `&x as T[0]` has a precedence of `((&x) as T)[0]`.\n+    fn parse_and_disallow_postfix_after_cast(\n+        &mut self,\n+        cast_expr: P<Expr>,\n+    ) -> PResult<'a, P<Expr>> {\n+        // Save the memory location of expr before parsing any following postfix operators.\n+        // This will be compared with the memory location of the output expression.\n+        // If they different we can assume we parsed another expression because the existing expression is not reallocated.\n+        let addr_before = &*cast_expr as *const _ as usize;\n+        let span = cast_expr.span;\n+        let with_postfix = self.parse_dot_or_call_expr_with_(cast_expr, span)?;\n+        let changed = addr_before != &*with_postfix as *const _ as usize;\n+\n+        // Check if an illegal postfix operator has been added after the cast.\n+        // If the resulting expression is not a cast, or has a different memory location, it is an illegal postfix operator.\n+        if !matches!(with_postfix.kind, ExprKind::Cast(_, _) | ExprKind::Type(_, _)) || changed {\n+            let msg = format!(\n+                \"casts cannot be followed by {}\",\n+                match with_postfix.kind {\n+                    ExprKind::Index(_, _) => \"indexing\",\n+                    ExprKind::Try(_) => \"?\",\n+                    ExprKind::Field(_, _) => \"a field access\",\n+                    ExprKind::MethodCall(_, _) => \"a method call\",\n+                    ExprKind::Call(_, _) => \"a function call\",\n+                    ExprKind::Await(_) => \"`.await`\",\n+                    _ => unreachable!(\"parse_dot_or_call_expr_with_ shouldn't produce this\"),\n+                }\n+            );\n+            let mut err = self.struct_span_err(span, &msg);\n+            // If type ascription is \"likely an error\", the user will already be getting a useful\n+            // help message, and doesn't need a second.\n+            if self.last_type_ascription.map_or(false, |last_ascription| last_ascription.1) {\n+                self.maybe_annotate_with_ascription(&mut err, false);\n+            } else {\n+                let suggestions = vec![\n+                    (span.shrink_to_lo(), \"(\".to_string()),\n+                    (span.shrink_to_hi(), \")\".to_string()),\n+                ];\n+                err.multipart_suggestion(\n+                    \"try surrounding the expression in parentheses\",\n+                    suggestions,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            err.emit();\n+        };\n+        Ok(with_postfix)\n     }\n \n     fn parse_assoc_op_ascribe(&mut self, lhs: P<Expr>, lhs_span: Span) -> PResult<'a, P<Expr>> {"}, {"sha": "e725aa5d73d1f97d00f6f2a0c924826ffc1c7922", "filename": "src/test/ui/parser/issue-35813-postfix-after-cast.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/111724f5e2baa8b54612295352ba7b17a29b6059/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/111724f5e2baa8b54612295352ba7b17a29b6059/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.rs?ref=111724f5e2baa8b54612295352ba7b17a29b6059", "patch": "@@ -0,0 +1,171 @@\n+// edition:2018\n+#![crate_type = \"lib\"]\n+#![feature(type_ascription)]\n+use std::future::Future;\n+use std::pin::Pin;\n+\n+// This tests the parser for \"x as Y[z]\". It errors, but we want to give useful\n+// errors and parse such that further code gives useful errors.\n+pub fn index_after_as_cast() {\n+    vec![1, 2, 3] as Vec<i32>[0];\n+    //~^ ERROR: casts cannot be followed by indexing\n+    vec![1, 2, 3]: Vec<i32>[0];\n+    //~^ ERROR: casts cannot be followed by indexing\n+}\n+\n+pub fn index_after_cast_to_index() {\n+    (&[0]) as &[i32][0];\n+    //~^ ERROR: casts cannot be followed by indexing\n+    (&[0i32]): &[i32; 1][0];\n+    //~^ ERROR: casts cannot be followed by indexing\n+}\n+\n+pub fn cast_after_cast() {\n+    if 5u64 as i32 as u16 == 0u16 {\n+\n+    }\n+    if 5u64: u64: u64 == 0u64 {\n+\n+    }\n+    let _ = 5u64: u64: u64 as u8 as i8 == 9i8;\n+    let _ = 0i32: i32: i32;\n+    let _ = 0 as i32: i32;\n+    let _ = 0i32: i32 as i32;\n+    let _ = 0 as i32 as i32;\n+    let _ = 0i32: i32: i32 as u32 as i32;\n+}\n+\n+pub fn cast_cast_method_call() {\n+    let _ = 0i32: i32: i32.count_ones();\n+    //~^ ERROR: casts cannot be followed by a method call\n+    let _ = 0 as i32: i32.count_ones();\n+    //~^ ERROR: casts cannot be followed by a method call\n+    let _ = 0i32: i32 as i32.count_ones();\n+    //~^ ERROR: casts cannot be followed by a method call\n+    let _ = 0 as i32 as i32.count_ones();\n+    //~^ ERROR: casts cannot be followed by a method call\n+    let _ = 0i32: i32: i32 as u32 as i32.count_ones();\n+    //~^ ERROR: casts cannot be followed by a method call\n+    let _ = 0i32: i32.count_ones(): u32;\n+    //~^ ERROR: casts cannot be followed by a method call\n+    let _ = 0 as i32.count_ones(): u32;\n+    //~^ ERROR: casts cannot be followed by a method call\n+    let _ = 0i32: i32.count_ones() as u32;\n+    //~^ ERROR: casts cannot be followed by a method call\n+    let _ = 0 as i32.count_ones() as u32;\n+    //~^ ERROR: casts cannot be followed by a method call\n+    let _ = 0i32: i32: i32.count_ones() as u32 as i32;\n+    //~^ ERROR: casts cannot be followed by a method call\n+}\n+\n+pub fn multiline_error() {\n+    let _ = 0\n+        as i32\n+        .count_ones();\n+    //~^^^ ERROR: casts cannot be followed by a method call\n+}\n+\n+// this tests that the precedence for `!x as Y.Z` is still what we expect\n+pub fn precedence() {\n+    let x: i32 = &vec![1, 2, 3] as &Vec<i32>[0];\n+    //~^ ERROR: casts cannot be followed by indexing\n+}\n+\n+pub fn method_calls() {\n+    0 as i32.max(0);\n+    //~^ ERROR: casts cannot be followed by a method call\n+    0: i32.max(0);\n+    //~^ ERROR: casts cannot be followed by a method call\n+}\n+\n+pub fn complex() {\n+    let _ = format!(\n+        \"{} and {}\",\n+        if true { 33 } else { 44 } as i32.max(0),\n+        //~^ ERROR: casts cannot be followed by a method call\n+        if true { 33 } else { 44 }: i32.max(0)\n+        //~^ ERROR: casts cannot be followed by a method call\n+    );\n+}\n+\n+pub fn in_condition() {\n+    if 5u64 as i32.max(0) == 0 {\n+        //~^ ERROR: casts cannot be followed by a method call\n+    }\n+    if 5u64: u64.max(0) == 0 {\n+        //~^ ERROR: casts cannot be followed by a method call\n+    }\n+}\n+\n+pub fn inside_block() {\n+    let _ = if true {\n+        5u64 as u32.max(0) == 0\n+        //~^ ERROR: casts cannot be followed by a method call\n+    } else { false };\n+    let _ = if true {\n+        5u64: u64.max(0) == 0\n+        //~^ ERROR: casts cannot be followed by a method call\n+    } else { false };\n+}\n+\n+static bar: &[i32] = &(&[1,2,3] as &[i32][0..1]);\n+//~^ ERROR: casts cannot be followed by indexing\n+\n+static bar2: &[i32] = &(&[1i32,2,3]: &[i32; 3][0..1]);\n+//~^ ERROR: casts cannot be followed by indexing\n+\n+\n+pub fn cast_then_try() -> Result<u64,u64> {\n+    Err(0u64) as Result<u64,u64>?;\n+    //~^ ERROR: casts cannot be followed by ?\n+    Err(0u64): Result<u64,u64>?;\n+    //~^ ERROR: casts cannot be followed by ?\n+    Ok(1)\n+}\n+\n+\n+pub fn cast_then_call() {\n+    type F = fn(u8);\n+    // type ascription won't actually do [unique drop fn type] -> fn(u8) casts.\n+    let drop_ptr = drop as fn(u8);\n+    drop as F();\n+    //~^ ERROR: parenthesized type parameters may only be used with a `Fn` trait [E0214]\n+    drop_ptr: F();\n+    //~^ ERROR: parenthesized type parameters may only be used with a `Fn` trait [E0214]\n+}\n+\n+pub fn cast_to_fn_should_work() {\n+    let drop_ptr = drop as fn(u8);\n+    drop as fn(u8);\n+    drop_ptr: fn(u8);\n+}\n+\n+pub fn parens_after_cast_error() {\n+    let drop_ptr = drop as fn(u8);\n+    drop as fn(u8)(0);\n+    //~^ ERROR: casts cannot be followed by a function call\n+    drop_ptr: fn(u8)(0);\n+    //~^ ERROR: casts cannot be followed by a function call\n+}\n+\n+pub async fn cast_then_await() {\n+    Box::pin(noop()) as Pin<Box<dyn Future<Output = ()>>>.await;\n+    //~^ ERROR: casts cannot be followed by `.await`\n+\n+    Box::pin(noop()): Pin<Box<_>>.await;\n+    //~^ ERROR: casts cannot be followed by `.await`\n+}\n+\n+pub async fn noop() {}\n+\n+#[derive(Default)]\n+pub struct Foo {\n+    pub bar: u32,\n+}\n+\n+pub fn struct_field() {\n+    Foo::default() as Foo.bar;\n+    //~^ ERROR: cannot be followed by a field access\n+    Foo::default(): Foo.bar;\n+    //~^ ERROR: cannot be followed by a field access\n+}"}, {"sha": "255e9f409218b9df6d25c8f73d3a519c7793574c", "filename": "src/test/ui/parser/issue-35813-postfix-after-cast.stderr", "status": "added", "additions": 392, "deletions": 0, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/111724f5e2baa8b54612295352ba7b17a29b6059/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/111724f5e2baa8b54612295352ba7b17a29b6059/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.stderr?ref=111724f5e2baa8b54612295352ba7b17a29b6059", "patch": "@@ -0,0 +1,392 @@\n+error: casts cannot be followed by indexing\n+  --> $DIR/issue-35813-postfix-after-cast.rs:10:5\n+   |\n+LL |     vec![1, 2, 3] as Vec<i32>[0];\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     (vec![1, 2, 3] as Vec<i32>)[0];\n+   |     ^                         ^\n+\n+error: casts cannot be followed by indexing\n+  --> $DIR/issue-35813-postfix-after-cast.rs:12:5\n+   |\n+LL |     vec![1, 2, 3]: Vec<i32>[0];\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     (vec![1, 2, 3]: Vec<i32>)[0];\n+   |     ^                       ^\n+\n+error: casts cannot be followed by indexing\n+  --> $DIR/issue-35813-postfix-after-cast.rs:17:5\n+   |\n+LL |     (&[0]) as &[i32][0];\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     ((&[0]) as &[i32])[0];\n+   |     ^                ^\n+\n+error: casts cannot be followed by indexing\n+  --> $DIR/issue-35813-postfix-after-cast.rs:19:5\n+   |\n+LL |     (&[0i32]): &[i32; 1][0];\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     ((&[0i32]): &[i32; 1])[0];\n+   |     ^                    ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:39:13\n+   |\n+LL |     let _ = 0i32: i32: i32.count_ones();\n+   |             ^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0i32: i32: i32).count_ones();\n+   |             ^              ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:41:13\n+   |\n+LL |     let _ = 0 as i32: i32.count_ones();\n+   |             ^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0 as i32: i32).count_ones();\n+   |             ^             ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:43:13\n+   |\n+LL |     let _ = 0i32: i32 as i32.count_ones();\n+   |             ^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0i32: i32 as i32).count_ones();\n+   |             ^                ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:45:13\n+   |\n+LL |     let _ = 0 as i32 as i32.count_ones();\n+   |             ^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0 as i32 as i32).count_ones();\n+   |             ^               ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:47:13\n+   |\n+LL |     let _ = 0i32: i32: i32 as u32 as i32.count_ones();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0i32: i32: i32 as u32 as i32).count_ones();\n+   |             ^                            ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:49:13\n+   |\n+LL |     let _ = 0i32: i32.count_ones(): u32;\n+   |             ^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0i32: i32).count_ones(): u32;\n+   |             ^         ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:51:13\n+   |\n+LL |     let _ = 0 as i32.count_ones(): u32;\n+   |             ^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0 as i32).count_ones(): u32;\n+   |             ^        ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:53:13\n+   |\n+LL |     let _ = 0i32: i32.count_ones() as u32;\n+   |             ^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0i32: i32).count_ones() as u32;\n+   |             ^         ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:55:13\n+   |\n+LL |     let _ = 0 as i32.count_ones() as u32;\n+   |             ^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0 as i32).count_ones() as u32;\n+   |             ^        ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:57:13\n+   |\n+LL |     let _ = 0i32: i32: i32.count_ones() as u32 as i32;\n+   |             ^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0i32: i32: i32).count_ones() as u32 as i32;\n+   |             ^              ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:62:13\n+   |\n+LL |       let _ = 0\n+   |  _____________^\n+LL | |         as i32\n+   | |______________^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let _ = (0\n+LL |         as i32)\n+   |\n+\n+error: casts cannot be followed by indexing\n+  --> $DIR/issue-35813-postfix-after-cast.rs:70:18\n+   |\n+LL |     let x: i32 = &vec![1, 2, 3] as &Vec<i32>[0];\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     let x: i32 = (&vec![1, 2, 3] as &Vec<i32>)[0];\n+   |                  ^                           ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:75:5\n+   |\n+LL |     0 as i32.max(0);\n+   |     ^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     (0 as i32).max(0);\n+   |     ^        ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:77:5\n+   |\n+LL |     0: i32.max(0);\n+   |     ^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     (0: i32).max(0);\n+   |     ^      ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:92:8\n+   |\n+LL |     if 5u64 as i32.max(0) == 0 {\n+   |        ^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     if (5u64 as i32).max(0) == 0 {\n+   |        ^           ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:95:8\n+   |\n+LL |     if 5u64: u64.max(0) == 0 {\n+   |        ^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     if (5u64: u64).max(0) == 0 {\n+   |        ^         ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:102:9\n+   |\n+LL |         5u64 as u32.max(0) == 0\n+   |         ^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |         (5u64 as u32).max(0) == 0\n+   |         ^           ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:106:9\n+   |\n+LL |         5u64: u64.max(0) == 0\n+   |         ^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |         (5u64: u64).max(0) == 0\n+   |         ^         ^\n+\n+error: casts cannot be followed by indexing\n+  --> $DIR/issue-35813-postfix-after-cast.rs:111:24\n+   |\n+LL | static bar: &[i32] = &(&[1,2,3] as &[i32][0..1]);\n+   |                        ^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL | static bar: &[i32] = &((&[1,2,3] as &[i32])[0..1]);\n+   |                        ^                  ^\n+\n+error: casts cannot be followed by indexing\n+  --> $DIR/issue-35813-postfix-after-cast.rs:114:25\n+   |\n+LL | static bar2: &[i32] = &(&[1i32,2,3]: &[i32; 3][0..1]);\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL | static bar2: &[i32] = &((&[1i32,2,3]: &[i32; 3])[0..1]);\n+   |                         ^                      ^\n+\n+error: casts cannot be followed by ?\n+  --> $DIR/issue-35813-postfix-after-cast.rs:119:5\n+   |\n+LL |     Err(0u64) as Result<u64,u64>?;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     (Err(0u64) as Result<u64,u64>)?;\n+   |     ^                            ^\n+\n+error: casts cannot be followed by ?\n+  --> $DIR/issue-35813-postfix-after-cast.rs:121:5\n+   |\n+LL |     Err(0u64): Result<u64,u64>?;\n+   |     ^^^^^^^^^-^^^^^^^^^^^^^^^^\n+   |              |\n+   |              help: maybe write a path separator here: `::`\n+   |\n+   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n+   = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n+\n+error: casts cannot be followed by a function call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:145:5\n+   |\n+LL |     drop as fn(u8)(0);\n+   |     ^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     (drop as fn(u8))(0);\n+   |     ^              ^\n+\n+error: casts cannot be followed by a function call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:147:5\n+   |\n+LL |     drop_ptr: fn(u8)(0);\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     (drop_ptr: fn(u8))(0);\n+   |     ^                ^\n+\n+error: casts cannot be followed by `.await`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:152:5\n+   |\n+LL |     Box::pin(noop()) as Pin<Box<dyn Future<Output = ()>>>.await;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     (Box::pin(noop()) as Pin<Box<dyn Future<Output = ()>>>).await;\n+   |     ^                                                     ^\n+\n+error: casts cannot be followed by `.await`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:155:5\n+   |\n+LL |     Box::pin(noop()): Pin<Box<_>>.await;\n+   |     ^^^^^^^^^^^^^^^^-^^^^^^^^^^^^\n+   |                     |\n+   |                     help: maybe write a path separator here: `::`\n+   |\n+   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n+   = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n+\n+error: casts cannot be followed by a field access\n+  --> $DIR/issue-35813-postfix-after-cast.rs:167:5\n+   |\n+LL |     Foo::default() as Foo.bar;\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     (Foo::default() as Foo).bar;\n+   |     ^                     ^\n+\n+error: casts cannot be followed by a field access\n+  --> $DIR/issue-35813-postfix-after-cast.rs:169:5\n+   |\n+LL |     Foo::default(): Foo.bar;\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |     (Foo::default(): Foo).bar;\n+   |     ^                   ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:84:9\n+   |\n+LL |         if true { 33 } else { 44 } as i32.max(0),\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |         (if true { 33 } else { 44 } as i32).max(0),\n+   |         ^                                 ^\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:86:9\n+   |\n+LL |         if true { 33 } else { 44 }: i32.max(0)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try surrounding the expression in parentheses\n+   |\n+LL |         (if true { 33 } else { 44 }: i32).max(0)\n+   |         ^                               ^\n+\n+error[E0214]: parenthesized type parameters may only be used with a `Fn` trait\n+  --> $DIR/issue-35813-postfix-after-cast.rs:131:13\n+   |\n+LL |     drop as F();\n+   |             ^^^ only `Fn` traits may use parentheses\n+\n+error[E0214]: parenthesized type parameters may only be used with a `Fn` trait\n+  --> $DIR/issue-35813-postfix-after-cast.rs:133:15\n+   |\n+LL |     drop_ptr: F();\n+   |               ^^^ only `Fn` traits may use parentheses\n+\n+error: aborting due to 36 previous errors\n+\n+For more information about this error, try `rustc --explain E0214`."}, {"sha": "8d6fd2abb6d5f133fb2f85f79d5ace8c28ca75e0", "filename": "src/test/ui/type/ascription/issue-54516.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/111724f5e2baa8b54612295352ba7b17a29b6059/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-54516.rs", "raw_url": "https://github.com/rust-lang/rust/raw/111724f5e2baa8b54612295352ba7b17a29b6059/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-54516.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-54516.rs?ref=111724f5e2baa8b54612295352ba7b17a29b6059", "patch": "@@ -2,5 +2,7 @@ use std::collections::BTreeMap;\n \n fn main() {\n     println!(\"{}\", std::mem:size_of::<BTreeMap<u32, u32>>());\n-    //~^ ERROR expected one of\n+    //~^ ERROR casts cannot be followed by a function call\n+    //~| ERROR expected value, found module `std::mem` [E0423]\n+    //~| ERROR cannot find type `size_of` in this scope [E0412]\n }"}, {"sha": "fdf35700ef94cf278af823c94ad56a0ff24495fa", "filename": "src/test/ui/type/ascription/issue-54516.stderr", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/111724f5e2baa8b54612295352ba7b17a29b6059/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-54516.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/111724f5e2baa8b54612295352ba7b17a29b6059/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-54516.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-54516.stderr?ref=111724f5e2baa8b54612295352ba7b17a29b6059", "patch": "@@ -1,13 +1,31 @@\n-error: expected one of `!`, `,`, or `::`, found `(`\n-  --> $DIR/issue-54516.rs:4:58\n+error: casts cannot be followed by a function call\n+  --> $DIR/issue-54516.rs:4:20\n    |\n LL |     println!(\"{}\", std::mem:size_of::<BTreeMap<u32, u32>>());\n-   |                            -                             ^ expected one of `!`, `,`, or `::`\n+   |                    ^^^^^^^^-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                            |\n    |                            help: maybe write a path separator here: `::`\n    |\n    = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n    = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n \n-error: aborting due to previous error\n+error[E0423]: expected value, found module `std::mem`\n+  --> $DIR/issue-54516.rs:4:20\n+   |\n+LL |     println!(\"{}\", std::mem:size_of::<BTreeMap<u32, u32>>());\n+   |                    ^^^^^^^^- help: maybe you meant to write a path separator here: `::`\n+   |                    |\n+   |                    not a value\n+\n+error[E0412]: cannot find type `size_of` in this scope\n+  --> $DIR/issue-54516.rs:4:29\n+   |\n+LL |     println!(\"{}\", std::mem:size_of::<BTreeMap<u32, u32>>());\n+   |                            -^^^^^^^ not found in this scope\n+   |                            |\n+   |                            help: maybe you meant to write a path separator here: `::`\n+\n+error: aborting due to 3 previous errors\n \n+Some errors have detailed explanations: E0412, E0423.\n+For more information about an error, try `rustc --explain E0412`."}, {"sha": "bcf9f88cb414b0ac93d260d555d8bd2cf0e54864", "filename": "src/test/ui/type/ascription/issue-60933.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/111724f5e2baa8b54612295352ba7b17a29b6059/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-60933.rs", "raw_url": "https://github.com/rust-lang/rust/raw/111724f5e2baa8b54612295352ba7b17a29b6059/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-60933.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-60933.rs?ref=111724f5e2baa8b54612295352ba7b17a29b6059", "patch": "@@ -1,4 +1,6 @@\n fn main() {\n     let u: usize = std::mem:size_of::<u32>();\n-    //~^ ERROR expected one of\n+    //~^ ERROR casts cannot be followed by a function call\n+    //~| ERROR expected value, found module `std::mem` [E0423]\n+    //~| ERROR cannot find type `size_of` in this scope [E0412]\n }"}, {"sha": "cd9ae8f49f4f1e8c7406bc91ff44b99a2d50d158", "filename": "src/test/ui/type/ascription/issue-60933.stderr", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/111724f5e2baa8b54612295352ba7b17a29b6059/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-60933.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/111724f5e2baa8b54612295352ba7b17a29b6059/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-60933.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-60933.stderr?ref=111724f5e2baa8b54612295352ba7b17a29b6059", "patch": "@@ -1,13 +1,31 @@\n-error: expected one of `!`, `::`, or `;`, found `(`\n-  --> $DIR/issue-60933.rs:2:43\n+error: casts cannot be followed by a function call\n+  --> $DIR/issue-60933.rs:2:20\n    |\n LL |     let u: usize = std::mem:size_of::<u32>();\n-   |                            -              ^ expected one of `!`, `::`, or `;`\n+   |                    ^^^^^^^^-^^^^^^^^^^^^^^\n    |                            |\n    |                            help: maybe write a path separator here: `::`\n    |\n    = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n    = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n \n-error: aborting due to previous error\n+error[E0423]: expected value, found module `std::mem`\n+  --> $DIR/issue-60933.rs:2:20\n+   |\n+LL |     let u: usize = std::mem:size_of::<u32>();\n+   |                    ^^^^^^^^- help: maybe you meant to write a path separator here: `::`\n+   |                    |\n+   |                    not a value\n+\n+error[E0412]: cannot find type `size_of` in this scope\n+  --> $DIR/issue-60933.rs:2:29\n+   |\n+LL |     let u: usize = std::mem:size_of::<u32>();\n+   |                            -^^^^^^^ not found in this scope\n+   |                            |\n+   |                            help: maybe you meant to write a path separator here: `::`\n+\n+error: aborting due to 3 previous errors\n \n+Some errors have detailed explanations: E0412, E0423.\n+For more information about an error, try `rustc --explain E0412`."}]}