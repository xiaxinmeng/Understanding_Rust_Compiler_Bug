{"sha": "b01b481db3ed9e13ab2fedc711f7cdabc8c1c53c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwMWI0ODFkYjNlZDllMTNhYjJmZWRjNzExZjdjZGFiYzhjMWM1M2M=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-01-25T04:59:11Z"}, "committer": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-01-26T20:47:24Z"}, "message": "Added/improved comments", "tree": {"sha": "d3dbe10900a2e9b4fd6467134096ade37b70f398", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3dbe10900a2e9b4fd6467134096ade37b70f398"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b01b481db3ed9e13ab2fedc711f7cdabc8c1c53c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b01b481db3ed9e13ab2fedc711f7cdabc8c1c53c", "html_url": "https://github.com/rust-lang/rust/commit/b01b481db3ed9e13ab2fedc711f7cdabc8c1c53c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b01b481db3ed9e13ab2fedc711f7cdabc8c1c53c/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d4ed65585ebdd1e5cd7aa37936682675825b919", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d4ed65585ebdd1e5cd7aa37936682675825b919", "html_url": "https://github.com/rust-lang/rust/commit/6d4ed65585ebdd1e5cd7aa37936682675825b919"}], "stats": {"total": 78, "additions": 61, "deletions": 17}, "files": [{"sha": "f6c4359167f63d1ac833d9468768674021310661", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 61, "deletions": 17, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/b01b481db3ed9e13ab2fedc711f7cdabc8c1c53c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01b481db3ed9e13ab2fedc711f7cdabc8c1c53c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=b01b481db3ed9e13ab2fedc711f7cdabc8c1c53c", "patch": "@@ -161,6 +161,12 @@ struct MatcherPos {\n     /// Moreover, matchers and repetitions can be nested; the `matches` field is shared (hence the\n     /// `Rc`) among all \"nested\" matchers. `match_lo`, `match_cur`, and `match_hi` keep track of\n     /// the current position of the `self` matcher position in the shared `matches` list.\n+    ///\n+    /// Also, note that while we are descending into a sequence, matchers are given their own\n+    /// `matches` vector. Only once we reach the end of a full repetition of the sequence do we add\n+    /// all bound matches from the submatcher into the shared top-level `matches` vector. If `sep`\n+    /// and `up` are `Some`, then `matches` is _not_ the shared top-level list. Instead, if one\n+    /// wants the shared `matches`, one should use `up.matches`.\n     matches: Vec<Rc<Vec<NamedMatch>>>,\n     /// The position in `matches` corresponding to the first metavar in this matcher's sequence of\n     /// token trees. In other words, the first metavar in the first token of `top_elts` corresponds\n@@ -255,7 +261,7 @@ fn initial_matcher_pos(ms: Vec<TokenTree>, lo: BytePos) -> Box<MatcherPos> {\n         // Haven't descended into any delimiters, so empty stack\n         stack: vec![],\n \n-        // Haven't descended into any sequences, so both of these are `None`\n+        // Haven't descended into any sequences, so both of these are `None`.\n         sep: None,\n         up: None,\n     })\n@@ -355,6 +361,28 @@ fn token_name_eq(t1: &Token, t2: &Token) -> bool {\n     }\n }\n \n+/// Process the matcher positions of `cur_items` until it is empty. In the process, this will\n+/// produce more items in `next_items`, `eof_items`, and `bb_items`.\n+///\n+/// For more info about the how this happens, see the module-level doc comments and the inline\n+/// comments of this function.\n+///\n+/// # Parameters\n+///\n+/// - `sess`: the parsing session into which errors are emitted.\n+/// - `cur_items`: the set of current items to be processed. This should be empty by the end of a\n+///   successful execution of this function.\n+/// - `next_items`: the set of newly generated items. These are used to replenish `cur_items` in\n+///   the function `parse`.\n+/// - `eof_items`: the set of items that would be valid if this was the EOF.\n+/// - `bb_items`: the set of items that are waiting for the black-box parser.\n+/// - `token`: the current token of the parser.\n+/// - `span`: the `Span` in the source code corresponding to the token trees we are trying to match\n+///   against the matcher positions in `cur_items`.\n+///\n+/// # Returns\n+///\n+/// A `ParseResult`. Note that matches are kept track of through the items generated.\n fn inner_parse_loop(\n     sess: &ParseSess,\n     cur_items: &mut SmallVector<Box<MatcherPos>>,\n@@ -364,8 +392,11 @@ fn inner_parse_loop(\n     token: &Token,\n     span: syntax_pos::Span,\n ) -> ParseResult<()> {\n+    // Pop items from `cur_items` until it is empty.\n     while let Some(mut item) = cur_items.pop() {\n-        // When unzipped trees end, remove them\n+        // When unzipped trees end, remove them. This corresponds to backtracking out of a\n+        // delimited submatcher into which we already descended. In backtracking out again, we need\n+        // to advance the \"dot\" past the delimiters in the outer matcher.\n         while item.idx >= item.top_elts.len() {\n             match item.stack.pop() {\n                 Some(MatcherTtFrame { elts, idx }) => {\n@@ -376,37 +407,46 @@ fn inner_parse_loop(\n             }\n         }\n \n+        // Get the current position of the \"dot\" (`idx`) in `item` and the number of token trees in\n+        // the matcher (`len`).\n         let idx = item.idx;\n         let len = item.top_elts.len();\n \n-        // at end of sequence\n+        // If `idx >= len`, then we are at or past the end of the matcher of `item`.\n         if idx >= len {\n-            // We are repeating iff there is a parent\n+            // We are repeating iff there is a parent. If the matcher is inside of a repetition,\n+            // then we could be at the end of a sequence or at the beginning of the next\n+            // repetition.\n             if item.up.is_some() {\n-                // Disregarding the separator, add the \"up\" case to the tokens that should be\n-                // examined.\n-                // (remove this condition to make trailing seps ok)\n+                // At this point, regardless of whether there is a separator, we should add all\n+                // matches from the complete repetition of the sequence to the shared, top-level\n+                // `matches` list (actually, `up.matches`, which could itself not be the top-level,\n+                // but anyway...). Moreover, we add another item to `cur_items` in which the \"dot\"\n+                // is at the end of the `up` matcher. This ensures that the \"dot\" in the `up`\n+                // matcher is also advanced sufficiently.\n+                //\n+                // NOTE: removing the condition `idx == len` allows trailing separators.\n                 if idx == len {\n+                    // Get the `up` matcher\n                     let mut new_pos = item.up.clone().unwrap();\n \n-                    // update matches (the MBE \"parse tree\") by appending\n-                    // each tree as a subtree.\n-\n-                    // Only touch the binders we have actually bound\n+                    // Add matches from this repetition to the `matches` of `up`\n                     for idx in item.match_lo..item.match_hi {\n                         let sub = item.matches[idx].clone();\n                         let span = span.with_lo(item.sp_lo);\n                         new_pos.push_match(idx, MatchedSeq(sub, span));\n                     }\n \n+                    // Move the \"dot\" past the repetition in `up`\n                     new_pos.match_cur = item.match_hi;\n                     new_pos.idx += 1;\n                     cur_items.push(new_pos);\n                 }\n \n-                // Check if we need a separator\n+                // Check if we need a separator.\n                 if idx == len && item.sep.is_some() {\n-                    // We have a separator, and it is the current token.\n+                    // We have a separator, and it is the current token. We can advance past the\n+                    // separator token.\n                     if item.sep\n                         .as_ref()\n                         .map(|sep| token_name_eq(token, sep))\n@@ -415,14 +455,18 @@ fn inner_parse_loop(\n                         item.idx += 1;\n                         next_items.push(item);\n                     }\n-                } else {\n-                    // we don't need a separator\n+                }\n+                // We don't need a separator. Move the \"dot\" back to the beginning of the matcher\n+                // and try to match again.\n+                else {\n                     item.match_cur = item.match_lo;\n                     item.idx = 0;\n                     cur_items.push(item);\n                 }\n-            } else {\n-                // We aren't repeating, so we must be potentially at the end of the input.\n+            }\n+            // If we are not in a repetition, then being at the end of a matcher means that we have\n+            // reached the potential end of the input.\n+            else {\n                 eof_items.push(item);\n             }\n         } else {"}]}