{"sha": "07600c939b594b39f560bc969caca2e92498435a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3NjAwYzkzOWI1OTRiMzlmNTYwYmM5NjljYWNhMmU5MjQ5ODQzNWE=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2019-01-09T17:40:30Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2019-01-10T19:10:11Z"}, "message": "Drop \"solved\" constraints during region expansion\n\nOnce a region has been expanded to cover a fixed region, a corresponding\nRegSubVar constraint won't have any effect on the expansion anymore, the\nsame is true for constraints where the variable on the RHS has already\nreached static scope. By removing those constraints from the set that\nwe're iterating over, we remove a lot of needless overhead in case of\nslow convergences (i.e. lots of iterations).\n\nFor the unicode_normalization crate, this about cuts the time required\nfor item_bodies checking in half.", "tree": {"sha": "ebb6e2ac2d31f3a72a507541bebc6cf6ed576274", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebb6e2ac2d31f3a72a507541bebc6cf6ed576274"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07600c939b594b39f560bc969caca2e92498435a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07600c939b594b39f560bc969caca2e92498435a", "html_url": "https://github.com/rust-lang/rust/commit/07600c939b594b39f560bc969caca2e92498435a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07600c939b594b39f560bc969caca2e92498435a/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "664c7797f6bfddf9f5e67474c2fd8017f91d7110", "url": "https://api.github.com/repos/rust-lang/rust/commits/664c7797f6bfddf9f5e67474c2fd8017f91d7110", "html_url": "https://github.com/rust-lang/rust/commit/664c7797f6bfddf9f5e67474c2fd8017f91d7110"}], "stats": {"total": 24, "additions": 16, "deletions": 8}, "files": [{"sha": "2a93217b9b423b3efb74eccae15c2e99c785669d", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/07600c939b594b39f560bc969caca2e92498435a/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07600c939b594b39f560bc969caca2e92498435a/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=07600c939b594b39f560bc969caca2e92498435a", "patch": "@@ -13,6 +13,7 @@ use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n };\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use smallvec::SmallVec;\n use std::fmt;\n use std::u32;\n use ty::fold::TypeFoldable;\n@@ -190,19 +191,24 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n             match *constraint {\n                 Constraint::RegSubVar(a_region, b_vid) => {\n                     let b_data = var_values.value_mut(b_vid);\n-                    self.expand_node(a_region, b_vid, b_data)\n+                    (self.expand_node(a_region, b_vid, b_data), false)\n                 }\n                 Constraint::VarSubVar(a_vid, b_vid) => match *var_values.value(a_vid) {\n-                    VarValue::ErrorValue => false,\n+                    VarValue::ErrorValue => (false, false),\n                     VarValue::Value(a_region) => {\n                         let b_node = var_values.value_mut(b_vid);\n-                        self.expand_node(a_region, b_vid, b_node)\n+                        let changed = self.expand_node(a_region, b_vid, b_node);\n+                        let retain = match *b_node {\n+                            VarValue::Value(ReStatic) | VarValue::ErrorValue => false,\n+                            _ => true\n+                        };\n+                        (changed, retain)\n                     }\n                 },\n                 Constraint::RegSubReg(..) | Constraint::VarSubReg(..) => {\n                     // These constraints are checked after expansion\n                     // is done, in `collect_errors`.\n-                    false\n+                    (false, false)\n                 }\n             }\n         })\n@@ -710,21 +716,23 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n \n     fn iterate_until_fixed_point<F>(&self, tag: &str, mut body: F)\n     where\n-        F: FnMut(&Constraint<'tcx>, &SubregionOrigin<'tcx>) -> bool,\n+        F: FnMut(&Constraint<'tcx>, &SubregionOrigin<'tcx>) -> (bool, bool),\n     {\n+        let mut constraints: SmallVec<[_; 16]> = self.data.constraints.iter().collect();\n         let mut iteration = 0;\n         let mut changed = true;\n         while changed {\n             changed = false;\n             iteration += 1;\n             debug!(\"---- {} Iteration {}{}\", \"#\", tag, iteration);\n-            for (constraint, origin) in &self.data.constraints {\n-                let edge_changed = body(constraint, origin);\n+            constraints.retain(|(constraint, origin)| {\n+                let (edge_changed, retain) = body(constraint, origin);\n                 if edge_changed {\n                     debug!(\"Updated due to constraint {:?}\", constraint);\n                     changed = true;\n                 }\n-            }\n+                retain\n+            });\n         }\n         debug!(\"---- {} Complete after {} iteration(s)\", tag, iteration);\n     }"}]}