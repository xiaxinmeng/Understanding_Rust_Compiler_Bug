{"sha": "237e267b8050bac6e24d412f0d577c5ca9d57ca1", "node_id": "C_kwDOAAsO6NoAKDIzN2UyNjdiODA1MGJhYzZlMjRkNDEyZjBkNTc3YzVjYTlkNTdjYTE", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-05T16:24:22Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-18T14:59:19Z"}, "message": "Refactor visit_fn.", "tree": {"sha": "0f71a884a28356da3fc5a7fc454185f178b5a2d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f71a884a28356da3fc5a7fc454185f178b5a2d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/237e267b8050bac6e24d412f0d577c5ca9d57ca1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/237e267b8050bac6e24d412f0d577c5ca9d57ca1", "html_url": "https://github.com/rust-lang/rust/commit/237e267b8050bac6e24d412f0d577c5ca9d57ca1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/237e267b8050bac6e24d412f0d577c5ca9d57ca1/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80c6a1f275b8cc03773f716fc470889bf344ec03", "url": "https://api.github.com/repos/rust-lang/rust/commits/80c6a1f275b8cc03773f716fc470889bf344ec03", "html_url": "https://github.com/rust-lang/rust/commit/80c6a1f275b8cc03773f716fc470889bf344ec03"}], "stats": {"total": 163, "additions": 97, "deletions": 66}, "files": [{"sha": "fce2404950587515aecf2b5fff0894f1208adddd", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 96, "deletions": 65, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/237e267b8050bac6e24d412f0d577c5ca9d57ca1/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237e267b8050bac6e24d412f0d577c5ca9d57ca1/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=237e267b8050bac6e24d412f0d577c5ca9d57ca1", "patch": "@@ -746,86 +746,117 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             self.diagnostic_metadata.current_function = Some((fn_kind, sp));\n         }\n         debug!(\"(resolving function) entering function\");\n-        let declaration = fn_kind.decl();\n \n         // Create a value rib for the function.\n         self.with_rib(ValueNS, rib_kind, |this| {\n             // Create a label rib for the function.\n             this.with_label_rib(FnItemRibKind, |this| {\n-                let async_node_id = fn_kind.header().and_then(|h| h.asyncness.opt_return_id());\n+                match fn_kind {\n+                    FnKind::Fn(_, _, sig, _, generics, body) => {\n+                        this.visit_generics(generics);\n \n-                if let FnKind::Fn(_, _, _, _, generics, _) = fn_kind {\n-                    this.visit_generics(generics);\n-                }\n+                        let declaration = &sig.decl;\n+                        let async_node_id = sig.header.asyncness.opt_return_id();\n \n-                if let Some(async_node_id) = async_node_id {\n-                    // In `async fn`, argument-position elided lifetimes\n-                    // must be transformed into fresh generic parameters so that\n-                    // they can be applied to the opaque `impl Trait` return type.\n-                    this.with_lifetime_rib(\n-                        LifetimeRibKind::AnonymousCreateParameter(fn_id),\n-                        |this| {\n+                        // Argument-position elided lifetimes must be transformed into fresh\n+                        // generic parameters.  This is especially useful for `async fn`, where\n+                        // these fresh generic parameters can be applied to the opaque `impl Trait`\n+                        // return type.\n+                        this.with_lifetime_rib(\n+                            if async_node_id.is_some() {\n+                                LifetimeRibKind::AnonymousCreateParameter(fn_id)\n+                            } else {\n+                                LifetimeRibKind::AnonymousPassThrough(fn_id, false)\n+                            },\n                             // Add each argument to the rib.\n-                            this.resolve_params(&declaration.inputs)\n-                        },\n-                    );\n-\n-                    // Construct the list of in-scope lifetime parameters for async lowering.\n-                    // We include all lifetime parameters, either named or \"Fresh\".\n-                    // The order of those parameters does not matter, as long as it is\n-                    // deterministic.\n-                    let mut extra_lifetime_params =\n-                        this.r.extra_lifetime_params_map.get(&fn_id).cloned().unwrap_or_default();\n-                    for rib in this.lifetime_ribs.iter().rev() {\n-                        extra_lifetime_params.extend(\n-                            rib.bindings\n-                                .iter()\n-                                .map(|(&ident, &(node_id, res))| (ident, node_id, res)),\n+                            |this| this.resolve_params(&declaration.inputs),\n                         );\n-                        match rib.kind {\n-                            LifetimeRibKind::Item => break,\n-                            LifetimeRibKind::AnonymousCreateParameter(id) => {\n-                                if let Some(earlier_fresh) =\n-                                    this.r.extra_lifetime_params_map.get(&id)\n-                                {\n-                                    extra_lifetime_params.extend(earlier_fresh);\n+\n+                        // Construct the list of in-scope lifetime parameters for async lowering.\n+                        // We include all lifetime parameters, either named or \"Fresh\".\n+                        // The order of those parameters does not matter, as long as it is\n+                        // deterministic.\n+                        if let Some(async_node_id) = async_node_id {\n+                            let mut extra_lifetime_params = this\n+                                .r\n+                                .extra_lifetime_params_map\n+                                .get(&fn_id)\n+                                .cloned()\n+                                .unwrap_or_default();\n+                            for rib in this.lifetime_ribs.iter().rev() {\n+                                extra_lifetime_params.extend(\n+                                    rib.bindings\n+                                        .iter()\n+                                        .map(|(&ident, &(node_id, res))| (ident, node_id, res)),\n+                                );\n+                                match rib.kind {\n+                                    LifetimeRibKind::Item => break,\n+                                    LifetimeRibKind::AnonymousCreateParameter(binder) => {\n+                                        if let Some(earlier_fresh) =\n+                                            this.r.extra_lifetime_params_map.get(&binder)\n+                                        {\n+                                            extra_lifetime_params.extend(earlier_fresh);\n+                                        }\n+                                    }\n+                                    _ => {}\n                                 }\n                             }\n-                            _ => {}\n+                            this.r\n+                                .extra_lifetime_params_map\n+                                .insert(async_node_id, extra_lifetime_params);\n                         }\n-                    }\n-                    this.r.extra_lifetime_params_map.insert(async_node_id, extra_lifetime_params);\n \n-                    this.with_lifetime_rib(\n-                        LifetimeRibKind::AnonymousPassThrough(async_node_id, true),\n-                        |this| visit::walk_fn_ret_ty(this, &declaration.output),\n-                    );\n-                } else {\n-                    // Add each argument to the rib.\n-                    this.with_lifetime_rib(\n-                        LifetimeRibKind::AnonymousPassThrough(fn_id, false),\n-                        |this| this.resolve_params(&declaration.inputs),\n-                    );\n-                    this.with_lifetime_rib(\n-                        LifetimeRibKind::AnonymousPassThrough(fn_id, true),\n-                        |this| visit::walk_fn_ret_ty(this, &declaration.output),\n-                    );\n-                };\n+                        this.with_lifetime_rib(\n+                            LifetimeRibKind::AnonymousPassThrough(\n+                                // For async fn, the return type appears inside a custom\n+                                // `impl Future` RPIT, so we override the binder's id.\n+                                async_node_id.unwrap_or(fn_id),\n+                                true,\n+                            ),\n+                            |this| visit::walk_fn_ret_ty(this, &declaration.output),\n+                        );\n \n-                // Ignore errors in function bodies if this is rustdoc\n-                // Be sure not to set this until the function signature has been resolved.\n-                let previous_state = replace(&mut this.in_func_body, true);\n-                // Resolve the function body, potentially inside the body of an async closure\n-                this.with_lifetime_rib(\n-                    LifetimeRibKind::AnonymousPassThrough(fn_id, false),\n-                    |this| match fn_kind {\n-                        FnKind::Fn(.., body) => walk_list!(this, visit_block, body),\n-                        FnKind::Closure(_, body) => this.visit_expr(body),\n-                    },\n-                );\n+                        if let Some(body) = body {\n+                            // Ignore errors in function bodies if this is rustdoc\n+                            // Be sure not to set this until the function signature has been resolved.\n+                            let previous_state = replace(&mut this.in_func_body, true);\n+                            // Resolve the function body, potentially inside the body of an async closure\n+                            this.with_lifetime_rib(\n+                                LifetimeRibKind::AnonymousPassThrough(fn_id, false),\n+                                |this| this.visit_block(body),\n+                            );\n \n-                debug!(\"(resolving function) leaving function\");\n-                this.in_func_body = previous_state;\n+                            debug!(\"(resolving function) leaving function\");\n+                            this.in_func_body = previous_state;\n+                        }\n+                    }\n+                    FnKind::Closure(declaration, body) => {\n+                        // Do not attempt to create generic lifetime parameters.\n+                        // FIXME: Revisit this decision once `for<>` bounds on closures become a\n+                        // thing.\n+                        this.with_lifetime_rib(\n+                            LifetimeRibKind::AnonymousPassThrough(fn_id, false),\n+                            // Add each argument to the rib.\n+                            |this| this.resolve_params(&declaration.inputs),\n+                        );\n+                        this.with_lifetime_rib(\n+                            LifetimeRibKind::AnonymousPassThrough(fn_id, true),\n+                            |this| visit::walk_fn_ret_ty(this, &declaration.output),\n+                        );\n+\n+                        // Ignore errors in function bodies if this is rustdoc\n+                        // Be sure not to set this until the function signature has been resolved.\n+                        let previous_state = replace(&mut this.in_func_body, true);\n+                        // Resolve the function body, potentially inside the body of an async closure\n+                        this.with_lifetime_rib(\n+                            LifetimeRibKind::AnonymousPassThrough(fn_id, false),\n+                            |this| this.visit_expr(body),\n+                        );\n+\n+                        debug!(\"(resolving function) leaving function\");\n+                        this.in_func_body = previous_state;\n+                    }\n+                }\n             })\n         });\n         self.diagnostic_metadata.current_function = previous_value;"}, {"sha": "9e4e56793ca9eeaa4ea725f77826bc87797b10d6", "filename": "src/test/ui/issues/issue-37884.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237e267b8050bac6e24d412f0d577c5ca9d57ca1/src%2Ftest%2Fui%2Fissues%2Fissue-37884.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/237e267b8050bac6e24d412f0d577c5ca9d57ca1/src%2Ftest%2Fui%2Fissues%2Fissue-37884.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37884.stderr?ref=237e267b8050bac6e24d412f0d577c5ca9d57ca1", "patch": "@@ -11,7 +11,7 @@ LL | |     }\n    |\n    = note: expected fn pointer `fn(&mut RepeatMut<'a, T>) -> Option<_>`\n               found fn pointer `fn(&'a mut RepeatMut<'a, T>) -> Option<_>`\n-note: the anonymous lifetime #1 defined here...\n+note: the anonymous lifetime as defined here...\n   --> $DIR/issue-37884.rs:6:5\n    |\n LL |     fn next(&'a mut self) -> Option<Self::Item>"}]}