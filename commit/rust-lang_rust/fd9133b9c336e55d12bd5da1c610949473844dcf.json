{"sha": "fd9133b9c336e55d12bd5da1c610949473844dcf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkOTEzM2I5YzMzNmU1NWQxMmJkNWRhMWM2MTA5NDk0NzM4NDRkY2Y=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-08-18T05:39:46Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-09-12T00:05:18Z"}, "message": "Suggest boxed trait objects in tail `match` and `if` expressions\n\nWhen encountering a `match` or `if` as a tail expression where the\ndifferent arms do not have the same type *and* the return type of that\n`fn` is an `impl Trait`, check whether those arms can implement `Trait`\nand if so, suggest using boxed trait objects.", "tree": {"sha": "f3ba6b3c91171f432620059dde9d29448d3fc638", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3ba6b3c91171f432620059dde9d29448d3fc638"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd9133b9c336e55d12bd5da1c610949473844dcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd9133b9c336e55d12bd5da1c610949473844dcf", "html_url": "https://github.com/rust-lang/rust/commit/fd9133b9c336e55d12bd5da1c610949473844dcf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd9133b9c336e55d12bd5da1c610949473844dcf/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8ee33714becbda0f1deddf1befe0383b4aad135", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8ee33714becbda0f1deddf1befe0383b4aad135", "html_url": "https://github.com/rust-lang/rust/commit/c8ee33714becbda0f1deddf1befe0383b4aad135"}], "stats": {"total": 215, "additions": 203, "deletions": 12}, "files": [{"sha": "e772aacfbf9ec59813ddd740744d582e956eff0b", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/fd9133b9c336e55d12bd5da1c610949473844dcf/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9133b9c336e55d12bd5da1c610949473844dcf/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=fd9133b9c336e55d12bd5da1c610949473844dcf", "patch": "@@ -617,11 +617,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 ref prior_arms,\n                 last_ty,\n                 scrut_hir_id,\n+                suggest_box,\n+                arm_span,\n                 ..\n             }) => match source {\n                 hir::MatchSource::IfLetDesugar { .. } => {\n                     let msg = \"`if let` arms have incompatible types\";\n                     err.span_label(cause.span, msg);\n+                    if let Some(ret_sp) = suggest_box {\n+                        self.suggest_boxing_for_return_impl_trait(\n+                            err,\n+                            ret_sp,\n+                            prior_arms.iter().chain(std::iter::once(&arm_span)).map(|s| *s),\n+                        );\n+                    }\n                 }\n                 hir::MatchSource::TryDesugar => {\n                     if let Some(ty::error::ExpectedFound { expected, .. }) = exp_found {\n@@ -675,9 +684,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             Applicability::MachineApplicable,\n                         );\n                     }\n+                    if let Some(ret_sp) = suggest_box {\n+                        // Get return type span and point to it.\n+                        self.suggest_boxing_for_return_impl_trait(\n+                            err,\n+                            ret_sp,\n+                            prior_arms.iter().chain(std::iter::once(&arm_span)).map(|s| *s),\n+                        );\n+                    }\n                 }\n             },\n-            ObligationCauseCode::IfExpression(box IfExpressionCause { then, outer, semicolon }) => {\n+            ObligationCauseCode::IfExpression(box IfExpressionCause {\n+                then,\n+                else_sp,\n+                outer,\n+                semicolon,\n+                suggest_box,\n+            }) => {\n                 err.span_label(then, \"expected because of this\");\n                 if let Some(sp) = outer {\n                     err.span_label(sp, \"`if` and `else` have incompatible types\");\n@@ -690,11 +713,52 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         Applicability::MachineApplicable,\n                     );\n                 }\n+                if let Some(ret_sp) = suggest_box {\n+                    self.suggest_boxing_for_return_impl_trait(\n+                        err,\n+                        ret_sp,\n+                        vec![then, else_sp].into_iter(),\n+                    );\n+                }\n             }\n             _ => (),\n         }\n     }\n \n+    fn suggest_boxing_for_return_impl_trait(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        return_sp: Span,\n+        arm_spans: impl Iterator<Item = Span>,\n+    ) {\n+        let snippet = self\n+            .tcx\n+            .sess\n+            .source_map()\n+            .span_to_snippet(return_sp)\n+            .unwrap_or_else(|_| \"dyn Trait\".to_string());\n+        err.span_suggestion_verbose(\n+            return_sp,\n+            \"you could change the return type to be a boxed trait object\",\n+            format!(\"Box<dyn {}>\", &snippet[5..]),\n+            Applicability::MaybeIncorrect,\n+        );\n+        let sugg = arm_spans\n+            .flat_map(|sp| {\n+                vec![\n+                    (sp.shrink_to_lo(), \"Box::new(\".to_string()),\n+                    (sp.shrink_to_hi(), \")\".to_string()),\n+                ]\n+                .into_iter()\n+            })\n+            .collect::<Vec<_>>();\n+        err.multipart_suggestion(\n+            \"if you change the return type to expect trait objects box the returned expressions\",\n+            sugg,\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+\n     /// Given that `other_ty` is the same as a type argument for `name` in `sub`, populate `value`\n     /// highlighting `name` and every type argument that isn't at `pos` (which is `other_ty`), and\n     /// populate `other_value` with `other_ty`."}, {"sha": "71582b7ed735d276c94847a1adbd6a0a386ce36d", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd9133b9c336e55d12bd5da1c610949473844dcf/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9133b9c336e55d12bd5da1c610949473844dcf/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=fd9133b9c336e55d12bd5da1c610949473844dcf", "patch": "@@ -350,13 +350,16 @@ pub struct MatchExpressionArmCause<'tcx> {\n     pub prior_arms: Vec<Span>,\n     pub last_ty: Ty<'tcx>,\n     pub scrut_hir_id: hir::HirId,\n+    pub suggest_box: Option<Span>,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct IfExpressionCause {\n     pub then: Span,\n+    pub else_sp: Span,\n     pub outer: Option<Span>,\n     pub semicolon: Option<Span>,\n+    pub suggest_box: Option<Span>,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]"}, {"sha": "98e53a258794cd7067834dda0362f6854c87c012", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 76, "deletions": 9, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/fd9133b9c336e55d12bd5da1c610949473844dcf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9133b9c336e55d12bd5da1c610949473844dcf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=fd9133b9c336e55d12bd5da1c610949473844dcf", "patch": "@@ -1,28 +1,31 @@\n use crate::check::coercion::CoerceMany;\n use crate::check::{Diverges, Expectation, FnCtxt, Needs};\n-use rustc_hir as hir;\n-use rustc_hir::ExprKind;\n+use rustc_hir::{self as hir, ExprKind};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_middle::ty::Ty;\n+use rustc_infer::traits::Obligation;\n+use rustc_middle::ty::{self, ToPredicate, Ty};\n use rustc_span::Span;\n-use rustc_trait_selection::traits::ObligationCauseCode;\n-use rustc_trait_selection::traits::{IfExpressionCause, MatchExpressionArmCause, ObligationCause};\n+use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n+use rustc_trait_selection::traits::{\n+    IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n+};\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_match(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         scrut: &'tcx hir::Expr<'tcx>,\n         arms: &'tcx [hir::Arm<'tcx>],\n-        expected: Expectation<'tcx>,\n+        orig_expected: Expectation<'tcx>,\n         match_src: hir::MatchSource,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n \n         use hir::MatchSource::*;\n         let (source_if, if_no_else, force_scrutinee_bool) = match match_src {\n             IfDesugar { contains_else_clause } => (true, !contains_else_clause, true),\n-            IfLetDesugar { contains_else_clause } => (true, !contains_else_clause, false),\n+            IfLetDesugar { contains_else_clause, .. } => (true, !contains_else_clause, false),\n             WhileDesugar => (false, false, true),\n             _ => (false, false, false),\n         };\n@@ -69,7 +72,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // type in that case)\n         let mut all_arms_diverge = Diverges::WarnedAlways;\n \n-        let expected = expected.adjust_for_branches(self);\n+        let expected = orig_expected.adjust_for_branches(self);\n \n         let mut coercion = {\n             let coerce_first = match expected {\n@@ -112,14 +115,74 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_expr_with_expectation(&arm.body, expected)\n             };\n             all_arms_diverge &= self.diverges.get();\n+\n+            // When we have a `match` as a tail expression in a `fn` with a returned `impl Trait`\n+            // we check if the different arms would work with boxed trait objects instead and\n+            // provide a structured suggestion in that case.\n+            let suggest_box = match (\n+                orig_expected,\n+                self.body_id\n+                    .owner\n+                    .to_def_id()\n+                    .as_local()\n+                    .and_then(|id| self.ret_coercion_impl_trait.map(|ty| (id, ty))),\n+            ) {\n+                (Expectation::ExpectHasType(expected), Some((id, ty)))\n+                    if self.in_tail_expr && self.can_coerce(arm_ty, expected) =>\n+                {\n+                    let impl_trait_ret_ty = self.infcx.instantiate_opaque_types(\n+                        id,\n+                        self.body_id,\n+                        self.param_env,\n+                        &ty,\n+                        arm.body.span,\n+                    );\n+                    let mut suggest_box = !impl_trait_ret_ty.obligations.is_empty();\n+                    for o in impl_trait_ret_ty.obligations {\n+                        match o.predicate.skip_binders_unchecked() {\n+                            ty::PredicateAtom::Trait(t, constness) => {\n+                                let pred = ty::PredicateAtom::Trait(\n+                                    ty::TraitPredicate {\n+                                        trait_ref: ty::TraitRef {\n+                                            def_id: t.def_id(),\n+                                            substs: self.infcx.tcx.mk_substs_trait(arm_ty, &[]),\n+                                        },\n+                                    },\n+                                    constness,\n+                                );\n+                                let obl = Obligation::new(\n+                                    o.cause.clone(),\n+                                    self.param_env,\n+                                    pred.to_predicate(self.infcx.tcx),\n+                                );\n+                                suggest_box &= self.infcx.predicate_must_hold_modulo_regions(&obl);\n+                                if !suggest_box {\n+                                    break;\n+                                }\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                    if suggest_box { self.ret_type_span.clone() } else { None }\n+                }\n+                _ => None,\n+            };\n+\n             if source_if {\n                 let then_expr = &arms[0].body;\n                 match (i, if_no_else) {\n                     (0, _) => coercion.coerce(self, &self.misc(expr.span), &arm.body, arm_ty),\n                     (_, true) => {} // Handled above to avoid duplicated type errors (#60254).\n                     (_, _) => {\n                         let then_ty = prior_arm_ty.unwrap();\n-                        let cause = self.if_cause(expr.span, then_expr, &arm.body, then_ty, arm_ty);\n+                        let cause = self.if_cause(\n+                            expr.span,\n+                            then_expr,\n+                            &arm.body,\n+                            then_ty,\n+                            arm_ty,\n+                            suggest_box,\n+                        );\n                         coercion.coerce(self, &cause, &arm.body, arm_ty);\n                     }\n                 }\n@@ -142,6 +205,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             prior_arms: other_arms.clone(),\n                             last_ty: prior_arm_ty.unwrap(),\n                             scrut_hir_id: scrut.hir_id,\n+                            suggest_box,\n                         }),\n                     ),\n                 };\n@@ -266,6 +330,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         else_expr: &'tcx hir::Expr<'tcx>,\n         then_ty: Ty<'tcx>,\n         else_ty: Ty<'tcx>,\n+        suggest_box: Option<Span>,\n     ) -> ObligationCause<'tcx> {\n         let mut outer_sp = if self.tcx.sess.source_map().is_multiline(span) {\n             // The `if`/`else` isn't in one line in the output, include some context to make it\n@@ -353,8 +418,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             error_sp,\n             ObligationCauseCode::IfExpression(box IfExpressionCause {\n                 then: then_sp,\n+                else_sp: error_sp,\n                 outer: outer_sp,\n                 semicolon: remove_semicolon,\n+                suggest_box,\n             }),\n         )\n     }"}, {"sha": "d6abf5f225da82c8832960a0ccccd43477161dcf", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fd9133b9c336e55d12bd5da1c610949473844dcf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9133b9c336e55d12bd5da1c610949473844dcf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=fd9133b9c336e55d12bd5da1c610949473844dcf", "patch": "@@ -570,6 +570,14 @@ pub struct FnCtxt<'a, 'tcx> {\n     /// any).\n     ret_coercion: Option<RefCell<DynamicCoerceMany<'tcx>>>,\n \n+    ret_coercion_impl_trait: Option<Ty<'tcx>>,\n+\n+    ret_type_span: Option<Span>,\n+\n+    /// Used exclusively to reduce cost of advanced evaluation used for\n+    /// more helpful diagnostics.\n+    in_tail_expr: bool,\n+\n     /// First span of a return site that we find. Used in error messages.\n     ret_coercion_span: RefCell<Option<Span>>,\n \n@@ -1302,10 +1310,15 @@ fn check_fn<'a, 'tcx>(\n     let hir = tcx.hir();\n \n     let declared_ret_ty = fn_sig.output();\n+\n     let revealed_ret_ty =\n         fcx.instantiate_opaque_types_from_value(fn_id, &declared_ret_ty, decl.output.span());\n     debug!(\"check_fn: declared_ret_ty: {}, revealed_ret_ty: {}\", declared_ret_ty, revealed_ret_ty);\n     fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(revealed_ret_ty)));\n+    fcx.ret_type_span = Some(decl.output.span());\n+    if let ty::Opaque(..) = declared_ret_ty.kind() {\n+        fcx.ret_coercion_impl_trait = Some(declared_ret_ty);\n+    }\n     fn_sig = tcx.mk_fn_sig(\n         fn_sig.inputs().iter().cloned(),\n         revealed_ret_ty,\n@@ -1366,6 +1379,7 @@ fn check_fn<'a, 'tcx>(\n \n     inherited.typeck_results.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n \n+    fcx.in_tail_expr = true;\n     if let ty::Dynamic(..) = declared_ret_ty.kind() {\n         // FIXME: We need to verify that the return type is `Sized` after the return expression has\n         // been evaluated so that we have types available for all the nodes being returned, but that\n@@ -1385,6 +1399,7 @@ fn check_fn<'a, 'tcx>(\n         fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n         fcx.check_return_expr(&body.value);\n     }\n+    fcx.in_tail_expr = false;\n \n     // We insert the deferred_generator_interiors entry after visiting the body.\n     // This ensures that all nested generators appear before the entry of this generator.\n@@ -3084,6 +3099,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             param_env,\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_coercion: None,\n+            ret_coercion_impl_trait: None,\n+            ret_type_span: None,\n+            in_tail_expr: false,\n             ret_coercion_span: RefCell::new(None),\n             resume_yield_tys: None,\n             ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal, hir::CRATE_HIR_ID)),"}, {"sha": "1a477e5db99ac0a7af726252416521bc3af08ba6", "filename": "src/test/ui/point-to-type-err-cause-on-impl-trait-return.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd9133b9c336e55d12bd5da1c610949473844dcf/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd9133b9c336e55d12bd5da1c610949473844dcf/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.rs?ref=fd9133b9c336e55d12bd5da1c610949473844dcf", "patch": "@@ -53,7 +53,13 @@ fn cat() -> impl std::fmt::Display {\n             1u32 //~ ERROR mismatched types\n         }\n     }\n-        }\n+}\n+\n+fn dog() -> impl std::fmt::Display {\n+    match 13 {\n+        0 => 0i32,\n+        1 => 1u32, //~ ERROR `match` arms have incompatible types\n+        _ => 2u32,\n     }\n }\n "}, {"sha": "a198203e24529f5e468655333707cd2b4d8a8d64", "filename": "src/test/ui/point-to-type-err-cause-on-impl-trait-return.stderr", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fd9133b9c336e55d12bd5da1c610949473844dcf/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd9133b9c336e55d12bd5da1c610949473844dcf/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr?ref=fd9133b9c336e55d12bd5da1c610949473844dcf", "patch": "@@ -72,6 +72,17 @@ LL | |         1u32\n    | |         ^^^^ expected `i32`, found `u32`\n LL | |     }\n    | |_____- `if` and `else` have incompatible types\n+   |\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn qux() -> Box<dyn std::fmt::Display> {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: if you change the return type to expect trait objects box the returned expressions\n+   |\n+LL |         Box::new(0i32)\n+LL |     } else {\n+LL |         Box::new(1u32)\n+   |\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:35:14\n@@ -136,6 +147,28 @@ help: you could change the return type to be a boxed trait object\n LL | fn cat() -> Box<dyn std::fmt::Display> {\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 7 previous errors\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:61:14\n+   |\n+LL | /     match 13 {\n+LL | |         0 => 0i32,\n+   | |              ---- this is found to be of type `i32`\n+LL | |         1 => 1u32,\n+   | |              ^^^^ expected `i32`, found `u32`\n+LL | |         _ => 2u32,\n+LL | |     }\n+   | |_____- `match` arms have incompatible types\n+   |\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn dog() -> Box<dyn std::fmt::Display> {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: if you change the return type to expect trait objects box the returned expressions\n+   |\n+LL |         0 => Box::new(0i32),\n+LL |         1 => Box::new(1u32),\n+   |\n+\n+error: aborting due to 8 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}]}