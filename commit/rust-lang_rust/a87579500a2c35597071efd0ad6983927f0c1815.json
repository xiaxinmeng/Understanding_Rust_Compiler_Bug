{"sha": "a87579500a2c35597071efd0ad6983927f0c1815", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4NzU3OTUwMGEyYzM1NTk3MDcxZWZkMGFkNjk4MzkyN2YwYzE4MTU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-27T14:46:02Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-27T18:16:00Z"}, "message": "Move Ty", "tree": {"sha": "9805b3dcbf8d767b2fc0623f42794068f3660d44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9805b3dcbf8d767b2fc0623f42794068f3660d44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a87579500a2c35597071efd0ad6983927f0c1815", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a87579500a2c35597071efd0ad6983927f0c1815", "html_url": "https://github.com/rust-lang/rust/commit/a87579500a2c35597071efd0ad6983927f0c1815", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a87579500a2c35597071efd0ad6983927f0c1815/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "368653081558ab389c6543d6b5027859e26beb3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/368653081558ab389c6543d6b5027859e26beb3b", "html_url": "https://github.com/rust-lang/rust/commit/368653081558ab389c6543d6b5027859e26beb3b"}], "stats": {"total": 3117, "additions": 1602, "deletions": 1515}, "files": [{"sha": "c9227c911d42f0fb20530b423d4d994fe1cff7e8", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -1023,6 +1023,7 @@ dependencies = [\n name = \"ra_hir_ty\"\n version = \"0.1.0\"\n dependencies = [\n+ \"arrayvec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"chalk-ir 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n  \"chalk-rust-ir 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\",\n  \"chalk-solve 0.1.0 (git+https://github.com/jackh726/chalk.git?rev=095cd38a4f16337913bba487f2055b9ca0179f30)\","}, {"sha": "87c78d98e143bbd54b4d18e15b24153eebceec9e", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -6,8 +6,10 @@ use std::sync::Arc;\n \n use hir_def::{\n     adt::VariantData,\n+    body::{Body, BodySourceMap},\n     builtin_type::BuiltinType,\n     docs::Documentation,\n+    expr::{BindingAnnotation, Pat, PatId},\n     per_ns::PerNs,\n     resolver::HasResolver,\n     type_ref::{Mutability, TypeRef},\n@@ -20,12 +22,12 @@ use hir_expand::{\n     name::{self, AsName},\n     AstId, MacroDefId,\n };\n+use hir_ty::expr::ExprValidator;\n use ra_db::{CrateId, Edition, FileId, FilePosition};\n use ra_syntax::{ast, AstNode, SyntaxNode};\n \n use crate::{\n     db::{DefDatabase, HirDatabase},\n-    expr::{BindingAnnotation, Body, BodySourceMap, ExprValidator, Pat, PatId},\n     ty::display::HirFormatter,\n     ty::{\n         self, InEnvironment, InferenceResult, TraitEnvironment, TraitRef, Ty, TyDefId, TypeCtor,\n@@ -353,8 +355,8 @@ impl Struct {\n             .map(|(id, _)| StructField { parent: self.into(), id })\n     }\n \n-    pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.ty(self.id.into())\n+    pub fn ty(self, db: &impl HirDatabase) -> Type {\n+        Type::from_def(db, self.id.module(db).krate, self.id)\n     }\n \n     pub fn constructor_ty(self, db: &impl HirDatabase) -> Ty {\n@@ -380,8 +382,8 @@ impl Union {\n         Module { id: self.id.module(db) }\n     }\n \n-    pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.ty(self.id.into())\n+    pub fn ty(self, db: &impl HirDatabase) -> Type {\n+        Type::from_def(db, self.id.module(db).krate, self.id)\n     }\n \n     pub fn fields(self, db: &impl HirDatabase) -> Vec<StructField> {\n@@ -441,8 +443,8 @@ impl Enum {\n             .map(|(id, _)| EnumVariant { parent: self, id })\n     }\n \n-    pub fn ty(self, db: &impl HirDatabase) -> Ty {\n-        db.ty(self.id.into())\n+    pub fn ty(self, db: &impl HirDatabase) -> Type {\n+        Type::from_def(db, self.id.module(db).krate, self.id)\n     }\n }\n \n@@ -640,7 +642,7 @@ impl Function {\n     pub fn diagnostics(self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n         let infer = self.infer(db);\n         infer.add_diagnostics(db, self.id, sink);\n-        let mut validator = ExprValidator::new(self, infer, sink);\n+        let mut validator = ExprValidator::new(self.id, infer, sink);\n         validator.validate_body(db);\n     }\n }\n@@ -946,13 +948,12 @@ impl ImplBlock {\n         db.impl_data(self.id).target_type.clone()\n     }\n \n-    pub fn target_ty(&self, db: &impl HirDatabase) -> Ty {\n-        Ty::from_hir(db, &self.id.resolver(db), &self.target_type(db))\n-    }\n-\n-    pub fn target_trait_ref(&self, db: &impl HirDatabase) -> Option<TraitRef> {\n-        let target_ty = self.target_ty(db);\n-        TraitRef::from_hir(db, &self.id.resolver(db), &self.target_trait(db)?, Some(target_ty))\n+    pub fn target_ty(&self, db: &impl HirDatabase) -> Type {\n+        let impl_data = db.impl_data(self.id);\n+        let resolver = self.id.resolver(db);\n+        let environment = TraitEnvironment::lower(db, &resolver);\n+        let ty = Ty::from_hir(db, &resolver, &impl_data.target_type);\n+        Type { krate: self.id.module(db).krate, ty: InEnvironment { value: ty, environment } }\n     }\n \n     pub fn items(&self, db: &impl DefDatabase) -> Vec<AssocItem> {\n@@ -1130,6 +1131,22 @@ impl Type {\n         Some(adt.into())\n     }\n \n+    // FIXME: provide required accessors such that it becomes implementable from outside.\n+    pub fn is_equal_for_find_impls(&self, other: &Type) -> bool {\n+        match (&self.ty.value, &other.ty.value) {\n+            (Ty::Apply(a_original_ty), Ty::Apply(ty::ApplicationTy { ctor, parameters })) => {\n+                match ctor {\n+                    TypeCtor::Ref(..) => match parameters.as_single() {\n+                        Ty::Apply(a_ty) => a_original_ty.ctor == a_ty.ctor,\n+                        _ => false,\n+                    },\n+                    _ => a_original_ty.ctor == *ctor,\n+                }\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     fn derived(&self, ty: Ty) -> Type {\n         Type {\n             krate: self.krate,"}, {"sha": "bfae3660b41fa2e68c58ce20a2ce4aedb823417e", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 6, "deletions": 111, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -1,18 +1,5 @@\n //! FIXME: write short doc here\n \n-use std::sync::Arc;\n-\n-use hir_def::{DefWithBodyId, GenericDefId, ImplId, LocalStructFieldId, TraitId, VariantId};\n-use ra_arena::map::ArenaMap;\n-use ra_db::{salsa, CrateId};\n-\n-use crate::ty::{\n-    method_resolution::CrateImplBlocks,\n-    traits::{AssocTyValue, Impl},\n-    CallableDef, FnSig, GenericPredicate, InferenceResult, Substs, Ty, TyDefId, TypeCtor,\n-    ValueTyDefId,\n-};\n-\n pub use hir_def::db::{\n     BodyQuery, BodyWithSourceMapQuery, ConstDataQuery, CrateDefMapQuery, CrateLangItemsQuery,\n     DefDatabase, DefDatabaseStorage, DocumentationQuery, EnumDataQuery, ExprScopesQuery,\n@@ -24,104 +11,12 @@ pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, MacroArgQuery, MacroDefQuery, MacroExpandQuery,\n     ParseMacroQuery,\n };\n-\n-#[salsa::query_group(HirDatabaseStorage)]\n-#[salsa::requires(salsa::Database)]\n-pub trait HirDatabase: DefDatabase {\n-    #[salsa::invoke(crate::ty::infer_query)]\n-    fn infer(&self, def: DefWithBodyId) -> Arc<InferenceResult>;\n-\n-    #[salsa::invoke(crate::ty::ty_query)]\n-    fn ty(&self, def: TyDefId) -> Ty;\n-\n-    #[salsa::invoke(crate::ty::value_ty_query)]\n-    fn value_ty(&self, def: ValueTyDefId) -> Ty;\n-\n-    #[salsa::invoke(crate::ty::field_types_query)]\n-    fn field_types(&self, var: VariantId) -> Arc<ArenaMap<LocalStructFieldId, Ty>>;\n-\n-    #[salsa::invoke(crate::ty::callable_item_sig)]\n-    fn callable_item_signature(&self, def: CallableDef) -> FnSig;\n-\n-    #[salsa::invoke(crate::ty::generic_predicates_for_param_query)]\n-    fn generic_predicates_for_param(\n-        &self,\n-        def: GenericDefId,\n-        param_idx: u32,\n-    ) -> Arc<[GenericPredicate]>;\n-\n-    #[salsa::invoke(crate::ty::generic_predicates_query)]\n-    fn generic_predicates(&self, def: GenericDefId) -> Arc<[GenericPredicate]>;\n-\n-    #[salsa::invoke(crate::ty::generic_defaults_query)]\n-    fn generic_defaults(&self, def: GenericDefId) -> Substs;\n-\n-    #[salsa::invoke(crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query)]\n-    fn impls_in_crate(&self, krate: CrateId) -> Arc<CrateImplBlocks>;\n-\n-    #[salsa::invoke(crate::ty::traits::impls_for_trait_query)]\n-    fn impls_for_trait(&self, krate: CrateId, trait_: TraitId) -> Arc<[ImplId]>;\n-\n-    /// This provides the Chalk trait solver instance. Because Chalk always\n-    /// works from a specific crate, this query is keyed on the crate; and\n-    /// because Chalk does its own internal caching, the solver is wrapped in a\n-    /// Mutex and the query does an untracked read internally, to make sure the\n-    /// cached state is thrown away when input facts change.\n-    #[salsa::invoke(crate::ty::traits::trait_solver_query)]\n-    fn trait_solver(&self, krate: CrateId) -> crate::ty::traits::TraitSolver;\n-\n-    // Interned IDs for Chalk integration\n-    #[salsa::interned]\n-    fn intern_type_ctor(&self, type_ctor: TypeCtor) -> crate::ty::TypeCtorId;\n-    #[salsa::interned]\n-    fn intern_chalk_impl(&self, impl_: Impl) -> crate::ty::traits::GlobalImplId;\n-    #[salsa::interned]\n-    fn intern_assoc_ty_value(\n-        &self,\n-        assoc_ty_value: AssocTyValue,\n-    ) -> crate::ty::traits::AssocTyValueId;\n-\n-    #[salsa::invoke(crate::ty::traits::chalk::associated_ty_data_query)]\n-    fn associated_ty_data(\n-        &self,\n-        id: chalk_ir::TypeId,\n-    ) -> Arc<chalk_rust_ir::AssociatedTyDatum<chalk_ir::family::ChalkIr>>;\n-\n-    #[salsa::invoke(crate::ty::traits::chalk::trait_datum_query)]\n-    fn trait_datum(\n-        &self,\n-        krate: CrateId,\n-        trait_id: chalk_ir::TraitId,\n-    ) -> Arc<chalk_rust_ir::TraitDatum<chalk_ir::family::ChalkIr>>;\n-\n-    #[salsa::invoke(crate::ty::traits::chalk::struct_datum_query)]\n-    fn struct_datum(\n-        &self,\n-        krate: CrateId,\n-        struct_id: chalk_ir::StructId,\n-    ) -> Arc<chalk_rust_ir::StructDatum<chalk_ir::family::ChalkIr>>;\n-\n-    #[salsa::invoke(crate::ty::traits::chalk::impl_datum_query)]\n-    fn impl_datum(\n-        &self,\n-        krate: CrateId,\n-        impl_id: chalk_ir::ImplId,\n-    ) -> Arc<chalk_rust_ir::ImplDatum<chalk_ir::family::ChalkIr>>;\n-\n-    #[salsa::invoke(crate::ty::traits::chalk::associated_ty_value_query)]\n-    fn associated_ty_value(\n-        &self,\n-        krate: CrateId,\n-        id: chalk_rust_ir::AssociatedTyValueId,\n-    ) -> Arc<chalk_rust_ir::AssociatedTyValue<chalk_ir::family::ChalkIr>>;\n-\n-    #[salsa::invoke(crate::ty::traits::trait_solve_query)]\n-    fn trait_solve(\n-        &self,\n-        krate: CrateId,\n-        goal: crate::ty::Canonical<crate::ty::InEnvironment<crate::ty::Obligation>>,\n-    ) -> Option<crate::ty::traits::Solution>;\n-}\n+pub use hir_ty::db::{\n+    AssociatedTyDataQuery, CallableItemSignatureQuery, FieldTypesQuery, GenericDefaultsQuery,\n+    GenericPredicatesQuery, HirDatabase, HirDatabaseStorage, ImplDatumQuery, ImplsForTraitQuery,\n+    ImplsInCrateQuery, InferQuery, StructDatumQuery, TraitDatumQuery, TraitSolveQuery, TyQuery,\n+    ValueTyQuery,\n+};\n \n #[test]\n fn hir_database_is_object_safe() {"}, {"sha": "a9040ea3d566db18b8c45f311b58d1c9ca21c1ee", "filename": "crates/ra_hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 90, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -1,93 +1,4 @@\n //! FIXME: write short doc here\n-\n-use std::any::Any;\n-\n-use hir_expand::HirFileId;\n-use ra_syntax::{ast, AstNode, AstPtr, SyntaxNodePtr};\n-\n-use crate::{db::AstDatabase, Name, Source};\n-\n pub use hir_def::diagnostics::UnresolvedModule;\n pub use hir_expand::diagnostics::{AstDiagnostic, Diagnostic, DiagnosticSink};\n-\n-#[derive(Debug)]\n-pub struct NoSuchField {\n-    pub file: HirFileId,\n-    pub field: AstPtr<ast::RecordField>,\n-}\n-\n-impl Diagnostic for NoSuchField {\n-    fn message(&self) -> String {\n-        \"no such field\".to_string()\n-    }\n-\n-    fn source(&self) -> Source<SyntaxNodePtr> {\n-        Source { file_id: self.file, value: self.field.into() }\n-    }\n-\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct MissingFields {\n-    pub file: HirFileId,\n-    pub field_list: AstPtr<ast::RecordFieldList>,\n-    pub missed_fields: Vec<Name>,\n-}\n-\n-impl Diagnostic for MissingFields {\n-    fn message(&self) -> String {\n-        use std::fmt::Write;\n-        let mut message = String::from(\"Missing structure fields:\\n\");\n-        for field in &self.missed_fields {\n-            write!(message, \"- {}\\n\", field).unwrap();\n-        }\n-        message\n-    }\n-    fn source(&self) -> Source<SyntaxNodePtr> {\n-        Source { file_id: self.file, value: self.field_list.into() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n-impl AstDiagnostic for MissingFields {\n-    type AST = ast::RecordFieldList;\n-\n-    fn ast(&self, db: &impl AstDatabase) -> Self::AST {\n-        let root = db.parse_or_expand(self.source().file_id).unwrap();\n-        let node = self.source().value.to_node(&root);\n-        ast::RecordFieldList::cast(node).unwrap()\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct MissingOkInTailExpr {\n-    pub file: HirFileId,\n-    pub expr: AstPtr<ast::Expr>,\n-}\n-\n-impl Diagnostic for MissingOkInTailExpr {\n-    fn message(&self) -> String {\n-        \"wrap return expression in Ok\".to_string()\n-    }\n-    fn source(&self) -> Source<SyntaxNodePtr> {\n-        Source { file_id: self.file, value: self.expr.into() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n-impl AstDiagnostic for MissingOkInTailExpr {\n-    type AST = ast::Expr;\n-\n-    fn ast(&self, db: &impl AstDatabase) -> Self::AST {\n-        let root = db.parse_or_expand(self.file).unwrap();\n-        let node = self.source().value.to_node(&root);\n-        ast::Expr::cast(node).unwrap()\n-    }\n-}\n+pub use hir_ty::diagnostics::{MissingFields, MissingOkInTailExpr, NoSuchField};"}, {"sha": "3c12c61f030afa4a7ad0309b60b0b764a9f479aa", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -32,28 +32,20 @@ pub mod db;\n pub mod source_binder;\n \n mod ty;\n-mod expr;\n pub mod diagnostics;\n-mod util;\n \n mod from_id;\n mod code_model;\n \n pub mod from_source;\n \n-#[cfg(test)]\n-mod test_db;\n-#[cfg(test)]\n-mod marks;\n-\n pub use crate::{\n     code_model::{\n         src::HasSource, Adt, AssocItem, AttrDef, Const, Container, Crate, CrateDependency,\n         DefWithBody, Docs, Enum, EnumVariant, FieldSource, Function, GenericDef, GenericParam,\n         HasAttrs, ImplBlock, Import, Local, MacroDef, Module, ModuleDef, ModuleSource, ScopeDef,\n         Static, Struct, StructField, Trait, Type, TypeAlias, Union, VariantDef,\n     },\n-    expr::ExprScopes,\n     from_source::FromSource,\n     source_binder::{PathResolution, ScopeEntryWithSyntax, SourceAnalyzer},\n     ty::{\n@@ -64,6 +56,7 @@ pub use crate::{\n };\n \n pub use hir_def::{\n+    body::scope::ExprScopes,\n     builtin_type::BuiltinType,\n     docs::Documentation,\n     path::{Path, PathKind},"}, {"sha": "76c493f1a836acbaef7101f56217164c5348b09f", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -8,6 +8,10 @@\n use std::sync::Arc;\n \n use hir_def::{\n+    body::{\n+        scope::{ExprScopes, ScopeId},\n+        BodySourceMap,\n+    },\n     expr::{ExprId, PatId},\n     path::known,\n     resolver::{self, resolver_for_scope, HasResolver, Resolver, TypeNs, ValueNs},\n@@ -25,7 +29,6 @@ use ra_syntax::{\n \n use crate::{\n     db::HirDatabase,\n-    expr::{BodySourceMap, ExprScopes, ScopeId},\n     ty::{\n         method_resolution::{self, implements_trait},\n         InEnvironment, TraitEnvironment, Ty,\n@@ -91,7 +94,7 @@ pub struct SourceAnalyzer {\n     body_owner: Option<DefWithBody>,\n     body_source_map: Option<Arc<BodySourceMap>>,\n     infer: Option<Arc<crate::ty::InferenceResult>>,\n-    scopes: Option<Arc<crate::expr::ExprScopes>>,\n+    scopes: Option<Arc<ExprScopes>>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -455,21 +458,6 @@ impl SourceAnalyzer {\n             macro_file_kind: to_macro_file_kind(macro_call.value),\n         })\n     }\n-\n-    #[cfg(test)]\n-    pub(crate) fn body_source_map(&self) -> Arc<BodySourceMap> {\n-        self.body_source_map.clone().unwrap()\n-    }\n-\n-    #[cfg(test)]\n-    pub(crate) fn inference_result(&self) -> Arc<crate::ty::InferenceResult> {\n-        self.infer.clone().unwrap()\n-    }\n-\n-    #[cfg(test)]\n-    pub(crate) fn analyzed_declaration(&self) -> Option<DefWithBody> {\n-        self.body_owner\n-    }\n }\n \n fn scope_for("}, {"sha": "4ed69c00dc4f8a951429b7d1f6071800a90762fb", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1110, "changes": 1111, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -1,1113 +1,4 @@\n //! The type system. We currently use this to infer types for completion, hover\n //! information and various assists.\n \n-mod autoderef;\n-pub(crate) mod primitive;\n-pub(crate) mod traits;\n-pub(crate) mod method_resolution;\n-mod op;\n-mod lower;\n-mod infer;\n-pub(crate) mod display;\n-pub(crate) mod utils;\n-\n-#[cfg(test)]\n-mod tests;\n-\n-use std::ops::Deref;\n-use std::sync::Arc;\n-use std::{fmt, iter, mem};\n-\n-use hir_def::{\n-    expr::ExprId, generics::GenericParams, type_ref::Mutability, AdtId, ContainerId, DefWithBodyId,\n-    GenericDefId, HasModule, Lookup, TraitId, TypeAliasId,\n-};\n-use hir_expand::name::Name;\n-use ra_db::{impl_intern_key, salsa, CrateId};\n-\n-use crate::{\n-    db::HirDatabase,\n-    ty::primitive::{FloatTy, IntTy, Uncertain},\n-    util::make_mut_slice,\n-};\n-use display::{HirDisplay, HirFormatter};\n-\n-pub(crate) use autoderef::autoderef;\n-pub(crate) use infer::{infer_query, InferTy, InferenceResult};\n-pub use lower::CallableDef;\n-pub(crate) use lower::{\n-    callable_item_sig, field_types_query, generic_defaults_query,\n-    generic_predicates_for_param_query, generic_predicates_query, ty_query, value_ty_query,\n-    TyDefId, ValueTyDefId,\n-};\n-pub(crate) use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironment};\n-\n-/// A type constructor or type name: this might be something like the primitive\n-/// type `bool`, a struct like `Vec`, or things like function pointers or\n-/// tuples.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum TypeCtor {\n-    /// The primitive boolean type. Written as `bool`.\n-    Bool,\n-\n-    /// The primitive character type; holds a Unicode scalar value\n-    /// (a non-surrogate code point). Written as `char`.\n-    Char,\n-\n-    /// A primitive integer type. For example, `i32`.\n-    Int(Uncertain<IntTy>),\n-\n-    /// A primitive floating-point type. For example, `f64`.\n-    Float(Uncertain<FloatTy>),\n-\n-    /// Structures, enumerations and unions.\n-    Adt(AdtId),\n-\n-    /// The pointee of a string slice. Written as `str`.\n-    Str,\n-\n-    /// The pointee of an array slice.  Written as `[T]`.\n-    Slice,\n-\n-    /// An array with the given length. Written as `[T; n]`.\n-    Array,\n-\n-    /// A raw pointer. Written as `*mut T` or `*const T`\n-    RawPtr(Mutability),\n-\n-    /// A reference; a pointer with an associated lifetime. Written as\n-    /// `&'a mut T` or `&'a T`.\n-    Ref(Mutability),\n-\n-    /// The anonymous type of a function declaration/definition. Each\n-    /// function has a unique type, which is output (for a function\n-    /// named `foo` returning an `i32`) as `fn() -> i32 {foo}`.\n-    ///\n-    /// This includes tuple struct / enum variant constructors as well.\n-    ///\n-    /// For example the type of `bar` here:\n-    ///\n-    /// ```\n-    /// fn foo() -> i32 { 1 }\n-    /// let bar = foo; // bar: fn() -> i32 {foo}\n-    /// ```\n-    FnDef(CallableDef),\n-\n-    /// A pointer to a function.  Written as `fn() -> i32`.\n-    ///\n-    /// For example the type of `bar` here:\n-    ///\n-    /// ```\n-    /// fn foo() -> i32 { 1 }\n-    /// let bar: fn() -> i32 = foo;\n-    /// ```\n-    FnPtr { num_args: u16 },\n-\n-    /// The never type `!`.\n-    Never,\n-\n-    /// A tuple type.  For example, `(i32, bool)`.\n-    Tuple { cardinality: u16 },\n-\n-    /// Represents an associated item like `Iterator::Item`.  This is used\n-    /// when we have tried to normalize a projection like `T::Item` but\n-    /// couldn't find a better representation.  In that case, we generate\n-    /// an **application type** like `(Iterator::Item)<T>`.\n-    AssociatedType(TypeAliasId),\n-\n-    /// The type of a specific closure.\n-    ///\n-    /// The closure signature is stored in a `FnPtr` type in the first type\n-    /// parameter.\n-    Closure { def: DefWithBodyId, expr: ExprId },\n-}\n-\n-/// This exists just for Chalk, because Chalk just has a single `StructId` where\n-/// we have different kinds of ADTs, primitive types and special type\n-/// constructors like tuples and function pointers.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct TypeCtorId(salsa::InternId);\n-impl_intern_key!(TypeCtorId);\n-\n-impl TypeCtor {\n-    pub fn num_ty_params(self, db: &impl HirDatabase) -> usize {\n-        match self {\n-            TypeCtor::Bool\n-            | TypeCtor::Char\n-            | TypeCtor::Int(_)\n-            | TypeCtor::Float(_)\n-            | TypeCtor::Str\n-            | TypeCtor::Never => 0,\n-            TypeCtor::Slice\n-            | TypeCtor::Array\n-            | TypeCtor::RawPtr(_)\n-            | TypeCtor::Ref(_)\n-            | TypeCtor::Closure { .. } // 1 param representing the signature of the closure\n-            => 1,\n-            TypeCtor::Adt(adt) => {\n-                let generic_params = db.generic_params(AdtId::from(adt).into());\n-                generic_params.count_params_including_parent()\n-            }\n-            TypeCtor::FnDef(callable) => {\n-                let generic_params = db.generic_params(callable.into());\n-                generic_params.count_params_including_parent()\n-            }\n-            TypeCtor::AssociatedType(type_alias) => {\n-                let generic_params = db.generic_params(type_alias.into());\n-                generic_params.count_params_including_parent()\n-            }\n-            TypeCtor::FnPtr { num_args } => num_args as usize + 1,\n-            TypeCtor::Tuple { cardinality } => cardinality as usize,\n-        }\n-    }\n-\n-    pub fn krate(self, db: &impl HirDatabase) -> Option<CrateId> {\n-        match self {\n-            TypeCtor::Bool\n-            | TypeCtor::Char\n-            | TypeCtor::Int(_)\n-            | TypeCtor::Float(_)\n-            | TypeCtor::Str\n-            | TypeCtor::Never\n-            | TypeCtor::Slice\n-            | TypeCtor::Array\n-            | TypeCtor::RawPtr(_)\n-            | TypeCtor::Ref(_)\n-            | TypeCtor::FnPtr { .. }\n-            | TypeCtor::Tuple { .. } => None,\n-            // Closure's krate is irrelevant for coherence I would think?\n-            TypeCtor::Closure { .. } => None,\n-            TypeCtor::Adt(adt) => Some(adt.module(db).krate),\n-            TypeCtor::FnDef(callable) => Some(callable.krate(db)),\n-            TypeCtor::AssociatedType(type_alias) => Some(type_alias.lookup(db).module(db).krate),\n-        }\n-    }\n-\n-    pub fn as_generic_def(self) -> Option<GenericDefId> {\n-        match self {\n-            TypeCtor::Bool\n-            | TypeCtor::Char\n-            | TypeCtor::Int(_)\n-            | TypeCtor::Float(_)\n-            | TypeCtor::Str\n-            | TypeCtor::Never\n-            | TypeCtor::Slice\n-            | TypeCtor::Array\n-            | TypeCtor::RawPtr(_)\n-            | TypeCtor::Ref(_)\n-            | TypeCtor::FnPtr { .. }\n-            | TypeCtor::Tuple { .. }\n-            | TypeCtor::Closure { .. } => None,\n-            TypeCtor::Adt(adt) => Some(adt.into()),\n-            TypeCtor::FnDef(callable) => Some(callable.into()),\n-            TypeCtor::AssociatedType(type_alias) => Some(type_alias.into()),\n-        }\n-    }\n-}\n-\n-/// A nominal type with (maybe 0) type parameters. This might be a primitive\n-/// type like `bool`, a struct, tuple, function pointer, reference or\n-/// several other things.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct ApplicationTy {\n-    pub ctor: TypeCtor,\n-    pub parameters: Substs,\n-}\n-\n-/// A \"projection\" type corresponds to an (unnormalized)\n-/// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n-/// trait and all its parameters are fully known.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct ProjectionTy {\n-    pub associated_ty: TypeAliasId,\n-    pub parameters: Substs,\n-}\n-\n-impl ProjectionTy {\n-    pub fn trait_ref(&self, db: &impl HirDatabase) -> TraitRef {\n-        TraitRef { trait_: self.trait_(db).into(), substs: self.parameters.clone() }\n-    }\n-\n-    fn trait_(&self, db: &impl HirDatabase) -> TraitId {\n-        match self.associated_ty.lookup(db).container {\n-            ContainerId::TraitId(it) => it,\n-            _ => panic!(\"projection ty without parent trait\"),\n-        }\n-    }\n-}\n-\n-impl TypeWalk for ProjectionTy {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        self.parameters.walk(f);\n-    }\n-\n-    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n-        self.parameters.walk_mut_binders(f, binders);\n-    }\n-}\n-\n-/// A type.\n-///\n-/// See also the `TyKind` enum in rustc (librustc/ty/sty.rs), which represents\n-/// the same thing (but in a different way).\n-///\n-/// This should be cheap to clone.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum Ty {\n-    /// A nominal type with (maybe 0) type parameters. This might be a primitive\n-    /// type like `bool`, a struct, tuple, function pointer, reference or\n-    /// several other things.\n-    Apply(ApplicationTy),\n-\n-    /// A \"projection\" type corresponds to an (unnormalized)\n-    /// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n-    /// trait and all its parameters are fully known.\n-    Projection(ProjectionTy),\n-\n-    /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n-    Param {\n-        /// The index of the parameter (starting with parameters from the\n-        /// surrounding impl, then the current function).\n-        idx: u32,\n-        /// The name of the parameter, for displaying.\n-        // FIXME get rid of this\n-        name: Name,\n-    },\n-\n-    /// A bound type variable. Used during trait resolution to represent Chalk\n-    /// variables, and in `Dyn` and `Opaque` bounds to represent the `Self` type.\n-    Bound(u32),\n-\n-    /// A type variable used during type checking. Not to be confused with a\n-    /// type parameter.\n-    Infer(InferTy),\n-\n-    /// A trait object (`dyn Trait` or bare `Trait` in pre-2018 Rust).\n-    ///\n-    /// The predicates are quantified over the `Self` type, i.e. `Ty::Bound(0)`\n-    /// represents the `Self` type inside the bounds. This is currently\n-    /// implicit; Chalk has the `Binders` struct to make it explicit, but it\n-    /// didn't seem worth the overhead yet.\n-    Dyn(Arc<[GenericPredicate]>),\n-\n-    /// An opaque type (`impl Trait`).\n-    ///\n-    /// The predicates are quantified over the `Self` type; see `Ty::Dyn` for\n-    /// more.\n-    Opaque(Arc<[GenericPredicate]>),\n-\n-    /// A placeholder for a type which could not be computed; this is propagated\n-    /// to avoid useless error messages. Doubles as a placeholder where type\n-    /// variables are inserted before type checking, since we want to try to\n-    /// infer a better type here anyway -- for the IDE use case, we want to try\n-    /// to infer as much as possible even in the presence of type errors.\n-    Unknown,\n-}\n-\n-/// A list of substitutions for generic parameters.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Substs(Arc<[Ty]>);\n-\n-impl TypeWalk for Substs {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        for t in self.0.iter() {\n-            t.walk(f);\n-        }\n-    }\n-\n-    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n-        for t in make_mut_slice(&mut self.0) {\n-            t.walk_mut_binders(f, binders);\n-        }\n-    }\n-}\n-\n-impl Substs {\n-    pub fn empty() -> Substs {\n-        Substs(Arc::new([]))\n-    }\n-\n-    pub fn single(ty: Ty) -> Substs {\n-        Substs(Arc::new([ty]))\n-    }\n-\n-    pub fn prefix(&self, n: usize) -> Substs {\n-        Substs(self.0[..std::cmp::min(self.0.len(), n)].into())\n-    }\n-\n-    pub fn as_single(&self) -> &Ty {\n-        if self.0.len() != 1 {\n-            panic!(\"expected substs of len 1, got {:?}\", self);\n-        }\n-        &self.0[0]\n-    }\n-\n-    /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n-    pub fn identity(generic_params: &GenericParams) -> Substs {\n-        Substs(\n-            generic_params\n-                .params_including_parent()\n-                .into_iter()\n-                .map(|p| Ty::Param { idx: p.idx, name: p.name.clone() })\n-                .collect(),\n-        )\n-    }\n-\n-    /// Return Substs that replace each parameter by a bound variable.\n-    pub fn bound_vars(generic_params: &GenericParams) -> Substs {\n-        Substs(\n-            generic_params\n-                .params_including_parent()\n-                .into_iter()\n-                .map(|p| Ty::Bound(p.idx))\n-                .collect(),\n-        )\n-    }\n-\n-    pub fn build_for_def(db: &impl HirDatabase, def: impl Into<GenericDefId>) -> SubstsBuilder {\n-        let def = def.into();\n-        let params = db.generic_params(def);\n-        let param_count = params.count_params_including_parent();\n-        Substs::builder(param_count)\n-    }\n-\n-    pub fn build_for_generics(generic_params: &GenericParams) -> SubstsBuilder {\n-        Substs::builder(generic_params.count_params_including_parent())\n-    }\n-\n-    pub fn build_for_type_ctor(db: &impl HirDatabase, type_ctor: TypeCtor) -> SubstsBuilder {\n-        Substs::builder(type_ctor.num_ty_params(db))\n-    }\n-\n-    fn builder(param_count: usize) -> SubstsBuilder {\n-        SubstsBuilder { vec: Vec::with_capacity(param_count), param_count }\n-    }\n-}\n-\n-#[derive(Debug, Clone)]\n-pub struct SubstsBuilder {\n-    vec: Vec<Ty>,\n-    param_count: usize,\n-}\n-\n-impl SubstsBuilder {\n-    pub fn build(self) -> Substs {\n-        assert_eq!(self.vec.len(), self.param_count);\n-        Substs(self.vec.into())\n-    }\n-\n-    pub fn push(mut self, ty: Ty) -> Self {\n-        self.vec.push(ty);\n-        self\n-    }\n-\n-    fn remaining(&self) -> usize {\n-        self.param_count - self.vec.len()\n-    }\n-\n-    pub fn fill_with_bound_vars(self, starting_from: u32) -> Self {\n-        self.fill((starting_from..).map(Ty::Bound))\n-    }\n-\n-    pub fn fill_with_params(self) -> Self {\n-        let start = self.vec.len() as u32;\n-        self.fill((start..).map(|idx| Ty::Param { idx, name: Name::missing() }))\n-    }\n-\n-    pub fn fill_with_unknown(self) -> Self {\n-        self.fill(iter::repeat(Ty::Unknown))\n-    }\n-\n-    pub fn fill(mut self, filler: impl Iterator<Item = Ty>) -> Self {\n-        self.vec.extend(filler.take(self.remaining()));\n-        assert_eq!(self.remaining(), 0);\n-        self\n-    }\n-\n-    pub fn use_parent_substs(mut self, parent_substs: &Substs) -> Self {\n-        assert!(self.vec.is_empty());\n-        assert!(parent_substs.len() <= self.param_count);\n-        self.vec.extend(parent_substs.iter().cloned());\n-        self\n-    }\n-}\n-\n-impl Deref for Substs {\n-    type Target = [Ty];\n-\n-    fn deref(&self) -> &[Ty] {\n-        &self.0\n-    }\n-}\n-\n-/// A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait.\n-/// Name to be bikeshedded: TraitBound? TraitImplements?\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct TraitRef {\n-    /// FIXME name?\n-    pub trait_: TraitId,\n-    pub substs: Substs,\n-}\n-\n-impl TraitRef {\n-    pub fn self_ty(&self) -> &Ty {\n-        &self.substs[0]\n-    }\n-}\n-\n-impl TypeWalk for TraitRef {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        self.substs.walk(f);\n-    }\n-\n-    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n-        self.substs.walk_mut_binders(f, binders);\n-    }\n-}\n-\n-/// Like `generics::WherePredicate`, but with resolved types: A condition on the\n-/// parameters of a generic item.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum GenericPredicate {\n-    /// The given trait needs to be implemented for its type parameters.\n-    Implemented(TraitRef),\n-    /// An associated type bindings like in `Iterator<Item = T>`.\n-    Projection(ProjectionPredicate),\n-    /// We couldn't resolve the trait reference. (If some type parameters can't\n-    /// be resolved, they will just be Unknown).\n-    Error,\n-}\n-\n-impl GenericPredicate {\n-    pub fn is_error(&self) -> bool {\n-        match self {\n-            GenericPredicate::Error => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_implemented(&self) -> bool {\n-        match self {\n-            GenericPredicate::Implemented(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn trait_ref(&self, db: &impl HirDatabase) -> Option<TraitRef> {\n-        match self {\n-            GenericPredicate::Implemented(tr) => Some(tr.clone()),\n-            GenericPredicate::Projection(proj) => Some(proj.projection_ty.trait_ref(db)),\n-            GenericPredicate::Error => None,\n-        }\n-    }\n-}\n-\n-impl TypeWalk for GenericPredicate {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        match self {\n-            GenericPredicate::Implemented(trait_ref) => trait_ref.walk(f),\n-            GenericPredicate::Projection(projection_pred) => projection_pred.walk(f),\n-            GenericPredicate::Error => {}\n-        }\n-    }\n-\n-    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n-        match self {\n-            GenericPredicate::Implemented(trait_ref) => trait_ref.walk_mut_binders(f, binders),\n-            GenericPredicate::Projection(projection_pred) => {\n-                projection_pred.walk_mut_binders(f, binders)\n-            }\n-            GenericPredicate::Error => {}\n-        }\n-    }\n-}\n-\n-/// Basically a claim (currently not validated / checked) that the contained\n-/// type / trait ref contains no inference variables; any inference variables it\n-/// contained have been replaced by bound variables, and `num_vars` tells us how\n-/// many there are. This is used to erase irrelevant differences between types\n-/// before using them in queries.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Canonical<T> {\n-    pub value: T,\n-    pub num_vars: usize,\n-}\n-\n-/// A function signature as seen by type inference: Several parameter types and\n-/// one return type.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct FnSig {\n-    params_and_return: Arc<[Ty]>,\n-}\n-\n-impl FnSig {\n-    pub fn from_params_and_return(mut params: Vec<Ty>, ret: Ty) -> FnSig {\n-        params.push(ret);\n-        FnSig { params_and_return: params.into() }\n-    }\n-\n-    pub fn from_fn_ptr_substs(substs: &Substs) -> FnSig {\n-        FnSig { params_and_return: Arc::clone(&substs.0) }\n-    }\n-\n-    pub fn params(&self) -> &[Ty] {\n-        &self.params_and_return[0..self.params_and_return.len() - 1]\n-    }\n-\n-    pub fn ret(&self) -> &Ty {\n-        &self.params_and_return[self.params_and_return.len() - 1]\n-    }\n-}\n-\n-impl TypeWalk for FnSig {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        for t in self.params_and_return.iter() {\n-            t.walk(f);\n-        }\n-    }\n-\n-    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n-        for t in make_mut_slice(&mut self.params_and_return) {\n-            t.walk_mut_binders(f, binders);\n-        }\n-    }\n-}\n-\n-impl Ty {\n-    pub fn simple(ctor: TypeCtor) -> Ty {\n-        Ty::Apply(ApplicationTy { ctor, parameters: Substs::empty() })\n-    }\n-    pub fn apply_one(ctor: TypeCtor, param: Ty) -> Ty {\n-        Ty::Apply(ApplicationTy { ctor, parameters: Substs::single(param) })\n-    }\n-    pub fn apply(ctor: TypeCtor, parameters: Substs) -> Ty {\n-        Ty::Apply(ApplicationTy { ctor, parameters })\n-    }\n-    pub fn unit() -> Self {\n-        Ty::apply(TypeCtor::Tuple { cardinality: 0 }, Substs::empty())\n-    }\n-\n-    pub fn as_reference(&self) -> Option<(&Ty, Mutability)> {\n-        match self {\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::Ref(mutability), parameters }) => {\n-                Some((parameters.as_single(), *mutability))\n-            }\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn as_adt(&self) -> Option<(AdtId, &Substs)> {\n-        match self {\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::Adt(adt_def), parameters }) => {\n-                Some((*adt_def, parameters))\n-            }\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn as_tuple(&self) -> Option<&Substs> {\n-        match self {\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::Tuple { .. }, parameters }) => {\n-                Some(parameters)\n-            }\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn as_callable(&self) -> Option<(CallableDef, &Substs)> {\n-        match self {\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::FnDef(callable_def), parameters }) => {\n-                Some((*callable_def, parameters))\n-            }\n-            _ => None,\n-        }\n-    }\n-\n-    fn builtin_deref(&self) -> Option<Ty> {\n-        match self {\n-            Ty::Apply(a_ty) => match a_ty.ctor {\n-                TypeCtor::Ref(..) => Some(Ty::clone(a_ty.parameters.as_single())),\n-                TypeCtor::RawPtr(..) => Some(Ty::clone(a_ty.parameters.as_single())),\n-                _ => None,\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    fn callable_sig(&self, db: &impl HirDatabase) -> Option<FnSig> {\n-        match self {\n-            Ty::Apply(a_ty) => match a_ty.ctor {\n-                TypeCtor::FnPtr { .. } => Some(FnSig::from_fn_ptr_substs(&a_ty.parameters)),\n-                TypeCtor::FnDef(def) => {\n-                    let sig = db.callable_item_signature(def);\n-                    Some(sig.subst(&a_ty.parameters))\n-                }\n-                TypeCtor::Closure { .. } => {\n-                    let sig_param = &a_ty.parameters[0];\n-                    sig_param.callable_sig(db)\n-                }\n-                _ => None,\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    /// If this is a type with type parameters (an ADT or function), replaces\n-    /// the `Substs` for these type parameters with the given ones. (So e.g. if\n-    /// `self` is `Option<_>` and the substs contain `u32`, we'll have\n-    /// `Option<u32>` afterwards.)\n-    pub fn apply_substs(self, substs: Substs) -> Ty {\n-        match self {\n-            Ty::Apply(ApplicationTy { ctor, parameters: previous_substs }) => {\n-                assert_eq!(previous_substs.len(), substs.len());\n-                Ty::Apply(ApplicationTy { ctor, parameters: substs })\n-            }\n-            _ => self,\n-        }\n-    }\n-\n-    /// Returns the type parameters of this type if it has some (i.e. is an ADT\n-    /// or function); so if `self` is `Option<u32>`, this returns the `u32`.\n-    pub fn substs(&self) -> Option<Substs> {\n-        match self {\n-            Ty::Apply(ApplicationTy { parameters, .. }) => Some(parameters.clone()),\n-            _ => None,\n-        }\n-    }\n-\n-    /// If this is an `impl Trait` or `dyn Trait`, returns that trait.\n-    pub fn inherent_trait(&self) -> Option<TraitId> {\n-        match self {\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n-                predicates.iter().find_map(|pred| match pred {\n-                    GenericPredicate::Implemented(tr) => Some(tr.trait_),\n-                    _ => None,\n-                })\n-            }\n-            _ => None,\n-        }\n-    }\n-}\n-\n-/// This allows walking structures that contain types to do something with those\n-/// types, similar to Chalk's `Fold` trait.\n-pub trait TypeWalk {\n-    fn walk(&self, f: &mut impl FnMut(&Ty));\n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n-        self.walk_mut_binders(&mut |ty, _binders| f(ty), 0);\n-    }\n-    /// Walk the type, counting entered binders.\n-    ///\n-    /// `Ty::Bound` variables use DeBruijn indexing, which means that 0 refers\n-    /// to the innermost binder, 1 to the next, etc.. So when we want to\n-    /// substitute a certain bound variable, we can't just walk the whole type\n-    /// and blindly replace each instance of a certain index; when we 'enter'\n-    /// things that introduce new bound variables, we have to keep track of\n-    /// that. Currently, the only thing that introduces bound variables on our\n-    /// side are `Ty::Dyn` and `Ty::Opaque`, which each introduce a bound\n-    /// variable for the self type.\n-    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize);\n-\n-    fn fold(mut self, f: &mut impl FnMut(Ty) -> Ty) -> Self\n-    where\n-        Self: Sized,\n-    {\n-        self.walk_mut(&mut |ty_mut| {\n-            let ty = mem::replace(ty_mut, Ty::Unknown);\n-            *ty_mut = f(ty);\n-        });\n-        self\n-    }\n-\n-    /// Replaces type parameters in this type using the given `Substs`. (So e.g.\n-    /// if `self` is `&[T]`, where type parameter T has index 0, and the\n-    /// `Substs` contain `u32` at index 0, we'll have `&[u32]` afterwards.)\n-    fn subst(self, substs: &Substs) -> Self\n-    where\n-        Self: Sized,\n-    {\n-        self.fold(&mut |ty| match ty {\n-            Ty::Param { idx, name } => {\n-                substs.get(idx as usize).cloned().unwrap_or(Ty::Param { idx, name })\n-            }\n-            ty => ty,\n-        })\n-    }\n-\n-    /// Substitutes `Ty::Bound` vars (as opposed to type parameters).\n-    fn subst_bound_vars(mut self, substs: &Substs) -> Self\n-    where\n-        Self: Sized,\n-    {\n-        self.walk_mut_binders(\n-            &mut |ty, binders| match ty {\n-                &mut Ty::Bound(idx) => {\n-                    if idx as usize >= binders && (idx as usize - binders) < substs.len() {\n-                        *ty = substs.0[idx as usize - binders].clone();\n-                    }\n-                }\n-                _ => {}\n-            },\n-            0,\n-        );\n-        self\n-    }\n-\n-    /// Shifts up `Ty::Bound` vars by `n`.\n-    fn shift_bound_vars(self, n: i32) -> Self\n-    where\n-        Self: Sized,\n-    {\n-        self.fold(&mut |ty| match ty {\n-            Ty::Bound(idx) => {\n-                assert!(idx as i32 >= -n);\n-                Ty::Bound((idx as i32 + n) as u32)\n-            }\n-            ty => ty,\n-        })\n-    }\n-}\n-\n-impl TypeWalk for Ty {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        match self {\n-            Ty::Apply(a_ty) => {\n-                for t in a_ty.parameters.iter() {\n-                    t.walk(f);\n-                }\n-            }\n-            Ty::Projection(p_ty) => {\n-                for t in p_ty.parameters.iter() {\n-                    t.walk(f);\n-                }\n-            }\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n-                for p in predicates.iter() {\n-                    p.walk(f);\n-                }\n-            }\n-            Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n-        }\n-        f(self);\n-    }\n-\n-    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n-        match self {\n-            Ty::Apply(a_ty) => {\n-                a_ty.parameters.walk_mut_binders(f, binders);\n-            }\n-            Ty::Projection(p_ty) => {\n-                p_ty.parameters.walk_mut_binders(f, binders);\n-            }\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n-                for p in make_mut_slice(predicates) {\n-                    p.walk_mut_binders(f, binders + 1);\n-                }\n-            }\n-            Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n-        }\n-        f(self, binders);\n-    }\n-}\n-\n-impl HirDisplay for &Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        HirDisplay::hir_fmt(*self, f)\n-    }\n-}\n-\n-impl HirDisplay for ApplicationTy {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        if f.should_truncate() {\n-            return write!(f, \"\u2026\");\n-        }\n-\n-        match self.ctor {\n-            TypeCtor::Bool => write!(f, \"bool\")?,\n-            TypeCtor::Char => write!(f, \"char\")?,\n-            TypeCtor::Int(t) => write!(f, \"{}\", t)?,\n-            TypeCtor::Float(t) => write!(f, \"{}\", t)?,\n-            TypeCtor::Str => write!(f, \"str\")?,\n-            TypeCtor::Slice => {\n-                let t = self.parameters.as_single();\n-                write!(f, \"[{}]\", t.display(f.db))?;\n-            }\n-            TypeCtor::Array => {\n-                let t = self.parameters.as_single();\n-                write!(f, \"[{};_]\", t.display(f.db))?;\n-            }\n-            TypeCtor::RawPtr(m) => {\n-                let t = self.parameters.as_single();\n-                write!(f, \"*{}{}\", m.as_keyword_for_ptr(), t.display(f.db))?;\n-            }\n-            TypeCtor::Ref(m) => {\n-                let t = self.parameters.as_single();\n-                write!(f, \"&{}{}\", m.as_keyword_for_ref(), t.display(f.db))?;\n-            }\n-            TypeCtor::Never => write!(f, \"!\")?,\n-            TypeCtor::Tuple { .. } => {\n-                let ts = &self.parameters;\n-                if ts.len() == 1 {\n-                    write!(f, \"({},)\", ts[0].display(f.db))?;\n-                } else {\n-                    write!(f, \"(\")?;\n-                    f.write_joined(&*ts.0, \", \")?;\n-                    write!(f, \")\")?;\n-                }\n-            }\n-            TypeCtor::FnPtr { .. } => {\n-                let sig = FnSig::from_fn_ptr_substs(&self.parameters);\n-                write!(f, \"fn(\")?;\n-                f.write_joined(sig.params(), \", \")?;\n-                write!(f, \") -> {}\", sig.ret().display(f.db))?;\n-            }\n-            TypeCtor::FnDef(def) => {\n-                let sig = f.db.callable_item_signature(def);\n-                let name = match def {\n-                    CallableDef::FunctionId(ff) => f.db.function_data(ff).name.clone(),\n-                    CallableDef::StructId(s) => {\n-                        f.db.struct_data(s).name.clone().unwrap_or_else(Name::missing)\n-                    }\n-                    CallableDef::EnumVariantId(e) => {\n-                        let enum_data = f.db.enum_data(e.parent);\n-                        enum_data.variants[e.local_id].name.clone().unwrap_or_else(Name::missing)\n-                    }\n-                };\n-                match def {\n-                    CallableDef::FunctionId(_) => write!(f, \"fn {}\", name)?,\n-                    CallableDef::StructId(_) | CallableDef::EnumVariantId(_) => {\n-                        write!(f, \"{}\", name)?\n-                    }\n-                }\n-                if self.parameters.len() > 0 {\n-                    write!(f, \"<\")?;\n-                    f.write_joined(&*self.parameters.0, \", \")?;\n-                    write!(f, \">\")?;\n-                }\n-                write!(f, \"(\")?;\n-                f.write_joined(sig.params(), \", \")?;\n-                write!(f, \") -> {}\", sig.ret().display(f.db))?;\n-            }\n-            TypeCtor::Adt(def_id) => {\n-                let name = match def_id {\n-                    AdtId::StructId(it) => f.db.struct_data(it).name.clone(),\n-                    AdtId::UnionId(it) => f.db.union_data(it).name.clone(),\n-                    AdtId::EnumId(it) => f.db.enum_data(it).name.clone(),\n-                }\n-                .unwrap_or_else(Name::missing);\n-                write!(f, \"{}\", name)?;\n-                if self.parameters.len() > 0 {\n-                    write!(f, \"<\")?;\n-                    f.write_joined(&*self.parameters.0, \", \")?;\n-                    write!(f, \">\")?;\n-                }\n-            }\n-            TypeCtor::AssociatedType(type_alias) => {\n-                let trait_ = match type_alias.lookup(f.db).container {\n-                    ContainerId::TraitId(it) => it,\n-                    _ => panic!(\"not an associated type\"),\n-                };\n-                let trait_name = f.db.trait_data(trait_).name.clone().unwrap_or_else(Name::missing);\n-                let name = f.db.type_alias_data(type_alias).name.clone();\n-                write!(f, \"{}::{}\", trait_name, name)?;\n-                if self.parameters.len() > 0 {\n-                    write!(f, \"<\")?;\n-                    f.write_joined(&*self.parameters.0, \", \")?;\n-                    write!(f, \">\")?;\n-                }\n-            }\n-            TypeCtor::Closure { .. } => {\n-                let sig = self.parameters[0]\n-                    .callable_sig(f.db)\n-                    .expect(\"first closure parameter should contain signature\");\n-                write!(f, \"|\")?;\n-                f.write_joined(sig.params(), \", \")?;\n-                write!(f, \"| -> {}\", sig.ret().display(f.db))?;\n-            }\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl HirDisplay for ProjectionTy {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        if f.should_truncate() {\n-            return write!(f, \"\u2026\");\n-        }\n-\n-        let trait_name =\n-            f.db.trait_data(self.trait_(f.db)).name.clone().unwrap_or_else(Name::missing);\n-        write!(f, \"<{} as {}\", self.parameters[0].display(f.db), trait_name,)?;\n-        if self.parameters.len() > 1 {\n-            write!(f, \"<\")?;\n-            f.write_joined(&self.parameters[1..], \", \")?;\n-            write!(f, \">\")?;\n-        }\n-        write!(f, \">::{}\", f.db.type_alias_data(self.associated_ty).name)?;\n-        Ok(())\n-    }\n-}\n-\n-impl HirDisplay for Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        if f.should_truncate() {\n-            return write!(f, \"\u2026\");\n-        }\n-\n-        match self {\n-            Ty::Apply(a_ty) => a_ty.hir_fmt(f)?,\n-            Ty::Projection(p_ty) => p_ty.hir_fmt(f)?,\n-            Ty::Param { name, .. } => write!(f, \"{}\", name)?,\n-            Ty::Bound(idx) => write!(f, \"?{}\", idx)?,\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n-                match self {\n-                    Ty::Dyn(_) => write!(f, \"dyn \")?,\n-                    Ty::Opaque(_) => write!(f, \"impl \")?,\n-                    _ => unreachable!(),\n-                };\n-                // Note: This code is written to produce nice results (i.e.\n-                // corresponding to surface Rust) for types that can occur in\n-                // actual Rust. It will have weird results if the predicates\n-                // aren't as expected (i.e. self types = $0, projection\n-                // predicates for a certain trait come after the Implemented\n-                // predicate for that trait).\n-                let mut first = true;\n-                let mut angle_open = false;\n-                for p in predicates.iter() {\n-                    match p {\n-                        GenericPredicate::Implemented(trait_ref) => {\n-                            if angle_open {\n-                                write!(f, \">\")?;\n-                            }\n-                            if !first {\n-                                write!(f, \" + \")?;\n-                            }\n-                            // We assume that the self type is $0 (i.e. the\n-                            // existential) here, which is the only thing that's\n-                            // possible in actual Rust, and hence don't print it\n-                            write!(\n-                                f,\n-                                \"{}\",\n-                                f.db.trait_data(trait_ref.trait_)\n-                                    .name\n-                                    .clone()\n-                                    .unwrap_or_else(Name::missing)\n-                            )?;\n-                            if trait_ref.substs.len() > 1 {\n-                                write!(f, \"<\")?;\n-                                f.write_joined(&trait_ref.substs[1..], \", \")?;\n-                                // there might be assoc type bindings, so we leave the angle brackets open\n-                                angle_open = true;\n-                            }\n-                        }\n-                        GenericPredicate::Projection(projection_pred) => {\n-                            // in types in actual Rust, these will always come\n-                            // after the corresponding Implemented predicate\n-                            if angle_open {\n-                                write!(f, \", \")?;\n-                            } else {\n-                                write!(f, \"<\")?;\n-                                angle_open = true;\n-                            }\n-                            let name =\n-                                f.db.type_alias_data(projection_pred.projection_ty.associated_ty)\n-                                    .name\n-                                    .clone();\n-                            write!(f, \"{} = \", name)?;\n-                            projection_pred.ty.hir_fmt(f)?;\n-                        }\n-                        GenericPredicate::Error => {\n-                            if angle_open {\n-                                // impl Trait<X, {error}>\n-                                write!(f, \", \")?;\n-                            } else if !first {\n-                                // impl Trait + {error}\n-                                write!(f, \" + \")?;\n-                            }\n-                            p.hir_fmt(f)?;\n-                        }\n-                    }\n-                    first = false;\n-                }\n-                if angle_open {\n-                    write!(f, \">\")?;\n-                }\n-            }\n-            Ty::Unknown => write!(f, \"{{unknown}}\")?,\n-            Ty::Infer(..) => write!(f, \"_\")?,\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl TraitRef {\n-    fn hir_fmt_ext(&self, f: &mut HirFormatter<impl HirDatabase>, use_as: bool) -> fmt::Result {\n-        if f.should_truncate() {\n-            return write!(f, \"\u2026\");\n-        }\n-\n-        self.substs[0].hir_fmt(f)?;\n-        if use_as {\n-            write!(f, \" as \")?;\n-        } else {\n-            write!(f, \": \")?;\n-        }\n-        write!(f, \"{}\", f.db.trait_data(self.trait_).name.clone().unwrap_or_else(Name::missing))?;\n-        if self.substs.len() > 1 {\n-            write!(f, \"<\")?;\n-            f.write_joined(&self.substs[1..], \", \")?;\n-            write!(f, \">\")?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl HirDisplay for TraitRef {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        self.hir_fmt_ext(f, false)\n-    }\n-}\n-\n-impl HirDisplay for &GenericPredicate {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        HirDisplay::hir_fmt(*self, f)\n-    }\n-}\n-\n-impl HirDisplay for GenericPredicate {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        if f.should_truncate() {\n-            return write!(f, \"\u2026\");\n-        }\n-\n-        match self {\n-            GenericPredicate::Implemented(trait_ref) => trait_ref.hir_fmt(f)?,\n-            GenericPredicate::Projection(projection_pred) => {\n-                write!(f, \"<\")?;\n-                projection_pred.projection_ty.trait_ref(f.db).hir_fmt_ext(f, true)?;\n-                write!(\n-                    f,\n-                    \">::{} = {}\",\n-                    f.db.type_alias_data(projection_pred.projection_ty.associated_ty).name,\n-                    projection_pred.ty.display(f.db)\n-                )?;\n-            }\n-            GenericPredicate::Error => write!(f, \"{{error}}\")?,\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl HirDisplay for Obligation {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        match self {\n-            Obligation::Trait(tr) => write!(f, \"Implements({})\", tr.display(f.db)),\n-            Obligation::Projection(proj) => write!(\n-                f,\n-                \"Normalize({} => {})\",\n-                proj.projection_ty.display(f.db),\n-                proj.ty.display(f.db)\n-            ),\n-        }\n-    }\n-}\n+pub use hir_ty::*;"}, {"sha": "12dc9657255a9839902afad68200deada898d44b", "filename": "crates/ra_hir/src/ty/primitive.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/368653081558ab389c6543d6b5027859e26beb3b/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368653081558ab389c6543d6b5027859e26beb3b/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs?ref=368653081558ab389c6543d6b5027859e26beb3b", "patch": "@@ -1,3 +0,0 @@\n-//! FIXME: write short doc here\n-\n-pub use hir_ty::primitive::{FloatBitness, FloatTy, IntBitness, IntTy, Signedness, Uncertain};"}, {"sha": "0095ee45d3c60fddf8a2db5f7892a4c219cc7e2e", "filename": "crates/ra_hir/src/util.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/368653081558ab389c6543d6b5027859e26beb3b/crates%2Fra_hir%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368653081558ab389c6543d6b5027859e26beb3b/crates%2Fra_hir%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Futil.rs?ref=368653081558ab389c6543d6b5027859e26beb3b", "patch": "@@ -1,12 +0,0 @@\n-//! Internal utility functions.\n-\n-use std::sync::Arc;\n-\n-/// Helper for mutating `Arc<[T]>` (i.e. `Arc::make_mut` for Arc slices).\n-/// The underlying values are cloned if there are other strong references.\n-pub(crate) fn make_mut_slice<T: Clone>(a: &mut Arc<[T]>) -> &mut [T] {\n-    if Arc::get_mut(a).is_none() {\n-        *a = a.iter().cloned().collect();\n-    }\n-    Arc::get_mut(a).unwrap()\n-}"}, {"sha": "ddf464c60510b95e024058ff77c02dee843614a4", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -27,7 +27,7 @@ pub mod body;\n pub mod resolver;\n \n mod trace;\n-mod nameres;\n+pub mod nameres;\n \n #[cfg(test)]\n mod test_db;"}, {"sha": "199afff493cdf5d43095c8166ed393c2af70cd5e", "filename": "crates/ra_hir_ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2FCargo.toml?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -8,6 +8,7 @@ authors = [\"rust-analyzer developers\"]\n doctest = false\n \n [dependencies]\n+arrayvec = \"0.5.1\"\n log = \"0.4.5\"\n rustc-hash = \"1.0\"\n parking_lot = \"0.10.0\""}, {"sha": "9d1d4e48c6e69edbf848e88134327d8003f6bf3c", "filename": "crates/ra_hir_ty/src/autoderef.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -19,7 +19,7 @@ use super::{\n \n const AUTODEREF_RECURSION_LIMIT: usize = 10;\n \n-pub(crate) fn autoderef<'a>(\n+pub fn autoderef<'a>(\n     db: &'a impl HirDatabase,\n     krate: Option<CrateId>,\n     ty: InEnvironment<Canonical<Ty>>,", "previous_filename": "crates/ra_hir/src/ty/autoderef.rs"}, {"sha": "aa2659c4bff60c0eaaad0cb5cd06e1732d941fdc", "filename": "crates/ra_hir_ty/src/db.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -0,0 +1,116 @@\n+//! FIXME: write short doc here\n+\n+use std::sync::Arc;\n+\n+use hir_def::{\n+    db::DefDatabase, DefWithBodyId, GenericDefId, ImplId, LocalStructFieldId, TraitId, VariantId,\n+};\n+use ra_arena::map::ArenaMap;\n+use ra_db::{salsa, CrateId};\n+\n+use crate::{\n+    method_resolution::CrateImplBlocks,\n+    traits::{AssocTyValue, Impl},\n+    CallableDef, FnSig, GenericPredicate, InferenceResult, Substs, Ty, TyDefId, TypeCtor,\n+    ValueTyDefId,\n+};\n+\n+#[salsa::query_group(HirDatabaseStorage)]\n+#[salsa::requires(salsa::Database)]\n+pub trait HirDatabase: DefDatabase {\n+    #[salsa::invoke(crate::infer_query)]\n+    fn infer(&self, def: DefWithBodyId) -> Arc<InferenceResult>;\n+\n+    #[salsa::invoke(crate::lower::ty_query)]\n+    fn ty(&self, def: TyDefId) -> Ty;\n+\n+    #[salsa::invoke(crate::lower::value_ty_query)]\n+    fn value_ty(&self, def: ValueTyDefId) -> Ty;\n+\n+    #[salsa::invoke(crate::lower::field_types_query)]\n+    fn field_types(&self, var: VariantId) -> Arc<ArenaMap<LocalStructFieldId, Ty>>;\n+\n+    #[salsa::invoke(crate::callable_item_sig)]\n+    fn callable_item_signature(&self, def: CallableDef) -> FnSig;\n+\n+    #[salsa::invoke(crate::lower::generic_predicates_for_param_query)]\n+    fn generic_predicates_for_param(\n+        &self,\n+        def: GenericDefId,\n+        param_idx: u32,\n+    ) -> Arc<[GenericPredicate]>;\n+\n+    #[salsa::invoke(crate::lower::generic_predicates_query)]\n+    fn generic_predicates(&self, def: GenericDefId) -> Arc<[GenericPredicate]>;\n+\n+    #[salsa::invoke(crate::lower::generic_defaults_query)]\n+    fn generic_defaults(&self, def: GenericDefId) -> Substs;\n+\n+    #[salsa::invoke(crate::method_resolution::CrateImplBlocks::impls_in_crate_query)]\n+    fn impls_in_crate(&self, krate: CrateId) -> Arc<CrateImplBlocks>;\n+\n+    #[salsa::invoke(crate::traits::impls_for_trait_query)]\n+    fn impls_for_trait(&self, krate: CrateId, trait_: TraitId) -> Arc<[ImplId]>;\n+\n+    /// This provides the Chalk trait solver instance. Because Chalk always\n+    /// works from a specific crate, this query is keyed on the crate; and\n+    /// because Chalk does its own internal caching, the solver is wrapped in a\n+    /// Mutex and the query does an untracked read internally, to make sure the\n+    /// cached state is thrown away when input facts change.\n+    #[salsa::invoke(crate::traits::trait_solver_query)]\n+    fn trait_solver(&self, krate: CrateId) -> crate::traits::TraitSolver;\n+\n+    // Interned IDs for Chalk integration\n+    #[salsa::interned]\n+    fn intern_type_ctor(&self, type_ctor: TypeCtor) -> crate::TypeCtorId;\n+    #[salsa::interned]\n+    fn intern_chalk_impl(&self, impl_: Impl) -> crate::traits::GlobalImplId;\n+    #[salsa::interned]\n+    fn intern_assoc_ty_value(&self, assoc_ty_value: AssocTyValue) -> crate::traits::AssocTyValueId;\n+\n+    #[salsa::invoke(crate::traits::chalk::associated_ty_data_query)]\n+    fn associated_ty_data(\n+        &self,\n+        id: chalk_ir::TypeId,\n+    ) -> Arc<chalk_rust_ir::AssociatedTyDatum<chalk_ir::family::ChalkIr>>;\n+\n+    #[salsa::invoke(crate::traits::chalk::trait_datum_query)]\n+    fn trait_datum(\n+        &self,\n+        krate: CrateId,\n+        trait_id: chalk_ir::TraitId,\n+    ) -> Arc<chalk_rust_ir::TraitDatum<chalk_ir::family::ChalkIr>>;\n+\n+    #[salsa::invoke(crate::traits::chalk::struct_datum_query)]\n+    fn struct_datum(\n+        &self,\n+        krate: CrateId,\n+        struct_id: chalk_ir::StructId,\n+    ) -> Arc<chalk_rust_ir::StructDatum<chalk_ir::family::ChalkIr>>;\n+\n+    #[salsa::invoke(crate::traits::chalk::impl_datum_query)]\n+    fn impl_datum(\n+        &self,\n+        krate: CrateId,\n+        impl_id: chalk_ir::ImplId,\n+    ) -> Arc<chalk_rust_ir::ImplDatum<chalk_ir::family::ChalkIr>>;\n+\n+    #[salsa::invoke(crate::traits::chalk::associated_ty_value_query)]\n+    fn associated_ty_value(\n+        &self,\n+        krate: CrateId,\n+        id: chalk_rust_ir::AssociatedTyValueId,\n+    ) -> Arc<chalk_rust_ir::AssociatedTyValue<chalk_ir::family::ChalkIr>>;\n+\n+    #[salsa::invoke(crate::traits::trait_solve_query)]\n+    fn trait_solve(\n+        &self,\n+        krate: CrateId,\n+        goal: crate::Canonical<crate::InEnvironment<crate::Obligation>>,\n+    ) -> Option<crate::traits::Solution>;\n+}\n+\n+#[test]\n+fn hir_database_is_object_safe() {\n+    fn _assert_object_safe(_: &dyn HirDatabase) {}\n+}"}, {"sha": "4a13fac239a98c20ea497cade350b2d029f03aa4", "filename": "crates/ra_hir_ty/src/diagnostics.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -0,0 +1,91 @@\n+//! FIXME: write short doc here\n+\n+use std::any::Any;\n+\n+use hir_expand::{db::AstDatabase, name::Name, HirFileId, Source};\n+use ra_syntax::{ast, AstNode, AstPtr, SyntaxNodePtr};\n+\n+pub use hir_def::diagnostics::UnresolvedModule;\n+pub use hir_expand::diagnostics::{AstDiagnostic, Diagnostic, DiagnosticSink};\n+\n+#[derive(Debug)]\n+pub struct NoSuchField {\n+    pub file: HirFileId,\n+    pub field: AstPtr<ast::RecordField>,\n+}\n+\n+impl Diagnostic for NoSuchField {\n+    fn message(&self) -> String {\n+        \"no such field\".to_string()\n+    }\n+\n+    fn source(&self) -> Source<SyntaxNodePtr> {\n+        Source { file_id: self.file, value: self.field.into() }\n+    }\n+\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct MissingFields {\n+    pub file: HirFileId,\n+    pub field_list: AstPtr<ast::RecordFieldList>,\n+    pub missed_fields: Vec<Name>,\n+}\n+\n+impl Diagnostic for MissingFields {\n+    fn message(&self) -> String {\n+        use std::fmt::Write;\n+        let mut message = String::from(\"Missing structure fields:\\n\");\n+        for field in &self.missed_fields {\n+            write!(message, \"- {}\\n\", field).unwrap();\n+        }\n+        message\n+    }\n+    fn source(&self) -> Source<SyntaxNodePtr> {\n+        Source { file_id: self.file, value: self.field_list.into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+impl AstDiagnostic for MissingFields {\n+    type AST = ast::RecordFieldList;\n+\n+    fn ast(&self, db: &impl AstDatabase) -> Self::AST {\n+        let root = db.parse_or_expand(self.source().file_id).unwrap();\n+        let node = self.source().value.to_node(&root);\n+        ast::RecordFieldList::cast(node).unwrap()\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct MissingOkInTailExpr {\n+    pub file: HirFileId,\n+    pub expr: AstPtr<ast::Expr>,\n+}\n+\n+impl Diagnostic for MissingOkInTailExpr {\n+    fn message(&self) -> String {\n+        \"wrap return expression in Ok\".to_string()\n+    }\n+    fn source(&self) -> Source<SyntaxNodePtr> {\n+        Source { file_id: self.file, value: self.expr.into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+impl AstDiagnostic for MissingOkInTailExpr {\n+    type AST = ast::Expr;\n+\n+    fn ast(&self, db: &impl AstDatabase) -> Self::AST {\n+        let root = db.parse_or_expand(self.file).unwrap();\n+        let node = self.source().value.to_node(&root);\n+        ast::Expr::cast(node).unwrap()\n+    }\n+}"}, {"sha": "9bb3ece6c8db60e301a885d568e7323ca3ae6d49", "filename": "crates/ra_hir_ty/src/display.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "previous_filename": "crates/ra_hir/src/ty/display.rs"}, {"sha": "5c65f9370799f85842dd807fdf9c69c1ae6e02c4", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "renamed", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -2,17 +2,20 @@\n \n use std::sync::Arc;\n \n-use hir_def::{path::known, resolver::HasResolver, AdtId};\n-use hir_expand::diagnostics::DiagnosticSink;\n+use hir_def::{\n+    path::{known, Path},\n+    resolver::HasResolver,\n+    AdtId, FunctionId,\n+};\n+use hir_expand::{diagnostics::DiagnosticSink, name::Name};\n use ra_syntax::ast;\n use ra_syntax::AstPtr;\n use rustc_hash::FxHashSet;\n \n use crate::{\n     db::HirDatabase,\n     diagnostics::{MissingFields, MissingOkInTailExpr},\n-    ty::{ApplicationTy, InferenceResult, Ty, TypeCtor},\n-    Function, Name, Path, Struct,\n+    ApplicationTy, InferenceResult, Ty, TypeCtor,\n };\n \n pub use hir_def::{\n@@ -26,23 +29,23 @@ pub use hir_def::{\n     },\n };\n \n-pub(crate) struct ExprValidator<'a, 'b: 'a> {\n-    func: Function,\n+pub struct ExprValidator<'a, 'b: 'a> {\n+    func: FunctionId,\n     infer: Arc<InferenceResult>,\n     sink: &'a mut DiagnosticSink<'b>,\n }\n \n impl<'a, 'b> ExprValidator<'a, 'b> {\n-    pub(crate) fn new(\n-        func: Function,\n+    pub fn new(\n+        func: FunctionId,\n         infer: Arc<InferenceResult>,\n         sink: &'a mut DiagnosticSink<'b>,\n     ) -> ExprValidator<'a, 'b> {\n         ExprValidator { func, infer, sink }\n     }\n \n-    pub(crate) fn validate_body(&mut self, db: &impl HirDatabase) {\n-        let body = self.func.body(db);\n+    pub fn validate_body(&mut self, db: &impl HirDatabase) {\n+        let body = db.body(self.func.into());\n \n         for e in body.exprs.iter() {\n             if let (id, Expr::RecordLit { path, fields, spread }) = e {\n@@ -69,16 +72,18 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         }\n \n         let struct_def = match self.infer[id].as_adt() {\n-            Some((AdtId::StructId(s), _)) => Struct::from(s),\n+            Some((AdtId::StructId(s), _)) => s,\n             _ => return,\n         };\n+        let struct_data = db.struct_data(struct_def);\n \n         let lit_fields: FxHashSet<_> = fields.iter().map(|f| &f.name).collect();\n-        let missed_fields: Vec<Name> = struct_def\n-            .fields(db)\n+        let missed_fields: Vec<Name> = struct_data\n+            .variant_data\n+            .fields()\n             .iter()\n-            .filter_map(|f| {\n-                let name = f.name(db);\n+            .filter_map(|(_f, d)| {\n+                let name = d.name.clone();\n                 if lit_fields.contains(&name) {\n                     None\n                 } else {\n@@ -89,7 +94,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         if missed_fields.is_empty() {\n             return;\n         }\n-        let source_map = self.func.body_source_map(db);\n+        let (_, source_map) = db.body_with_source_map(self.func.into());\n \n         if let Some(source_ptr) = source_map.expr_syntax(id) {\n             if let Some(expr) = source_ptr.value.a() {\n@@ -121,7 +126,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n \n         let std_result_path = known::std_result_result();\n \n-        let resolver = self.func.id.resolver(db);\n+        let resolver = self.func.resolver(db);\n         let std_result_enum = match resolver.resolve_known_enum(db, &std_result_path) {\n             Some(it) => it,\n             _ => return,\n@@ -134,7 +139,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         };\n \n         if params.len() == 2 && &params[0] == &mismatch.actual {\n-            let source_map = self.func.body_source_map(db);\n+            let (_, source_map) = db.body_with_source_map(self.func.into());\n \n             if let Some(source_ptr) = source_map.expr_syntax(id) {\n                 if let Some(expr) = source_ptr.value.a() {", "previous_filename": "crates/ra_hir/src/expr.rs"}, {"sha": "1e9f4b208d46220e202fce24e4a9162709d2ab1c", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -41,11 +41,11 @@ use super::{\n     ApplicationTy, InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor,\n     TypeWalk, Uncertain,\n };\n-use crate::{db::HirDatabase, ty::infer::diagnostics::InferenceDiagnostic};\n+use crate::{db::HirDatabase, infer::diagnostics::InferenceDiagnostic};\n \n macro_rules! ty_app {\n     ($ctor:pat, $param:pat) => {\n-        crate::ty::Ty::Apply(crate::ty::ApplicationTy { ctor: $ctor, parameters: $param })\n+        crate::Ty::Apply(crate::ApplicationTy { ctor: $ctor, parameters: $param })\n     };\n     ($ctor:pat) => {\n         ty_app!($ctor, _)\n@@ -128,8 +128,8 @@ pub struct InferenceResult {\n     /// For each associated item record what it resolves to\n     assoc_resolutions: FxHashMap<ExprOrPatId, AssocItemId>,\n     diagnostics: Vec<InferenceDiagnostic>,\n-    pub(super) type_of_expr: ArenaMap<ExprId, Ty>,\n-    pub(super) type_of_pat: ArenaMap<PatId, Ty>,\n+    pub type_of_expr: ArenaMap<ExprId, Ty>,\n+    pub type_of_pat: ArenaMap<PatId, Ty>,\n     pub(super) type_mismatches: ArenaMap<ExprId, TypeMismatch>,\n }\n \n@@ -158,7 +158,7 @@ impl InferenceResult {\n     pub fn type_mismatch_for_expr(&self, expr: ExprId) -> Option<&TypeMismatch> {\n         self.type_mismatches.get(expr)\n     }\n-    pub(crate) fn add_diagnostics(\n+    pub fn add_diagnostics(\n         &self,\n         db: &impl HirDatabase,\n         owner: FunctionId,", "previous_filename": "crates/ra_hir/src/ty/infer.rs"}, {"sha": "d66a21932fc75cfc7028fedf72f279f2f8ef52f1", "filename": "crates/ra_hir_ty/src/infer/coerce.rs", "status": "renamed", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -13,10 +13,7 @@ use hir_def::{\n use rustc_hash::FxHashMap;\n use test_utils::tested_by;\n \n-use crate::{\n-    db::HirDatabase,\n-    ty::{autoderef, Substs, TraitRef, Ty, TypeCtor, TypeWalk},\n-};\n+use crate::{autoderef, db::HirDatabase, Substs, TraitRef, Ty, TypeCtor, TypeWalk};\n \n use super::{InEnvironment, InferTy, InferenceContext, TypeVarValue};\n ", "previous_filename": "crates/ra_hir/src/ty/infer/coerce.rs"}, {"sha": "2f9ca4bbbfd87a44449ea1b394b10f0149eefa21", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "renamed", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -14,12 +14,9 @@ use hir_def::{\n use hir_expand::name::{self, Name};\n \n use crate::{\n-    db::HirDatabase,\n-    ty::{\n-        autoderef, method_resolution, op, traits::InEnvironment, utils::variant_data, CallableDef,\n-        InferTy, IntTy, Mutability, Obligation, ProjectionPredicate, ProjectionTy, Substs,\n-        TraitRef, Ty, TypeCtor, TypeWalk, Uncertain,\n-    },\n+    autoderef, db::HirDatabase, method_resolution, op, traits::InEnvironment, utils::variant_data,\n+    CallableDef, InferTy, IntTy, Mutability, Obligation, ProjectionPredicate, ProjectionTy, Substs,\n+    TraitRef, Ty, TypeCtor, TypeWalk, Uncertain,\n };\n \n use super::{BindingMode, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch};", "previous_filename": "crates/ra_hir/src/ty/infer/expr.rs"}, {"sha": "1ebb362399a9d9cdac14a01b4fc50f388f19d9cb", "filename": "crates/ra_hir_ty/src/infer/pat.rs", "status": "renamed", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -12,10 +12,7 @@ use hir_expand::name::Name;\n use test_utils::tested_by;\n \n use super::{BindingMode, InferenceContext};\n-use crate::{\n-    db::HirDatabase,\n-    ty::{utils::variant_data, Substs, Ty, TypeCtor, TypeWalk},\n-};\n+use crate::{db::HirDatabase, utils::variant_data, Substs, Ty, TypeCtor, TypeWalk};\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn infer_tuple_struct_pat(", "previous_filename": "crates/ra_hir/src/ty/infer/pat.rs"}, {"sha": "e6676e1aa84d26b58a0c39e375034693ace01f81", "filename": "crates/ra_hir_ty/src/infer/path.rs", "status": "renamed", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -1,16 +1,13 @@\n //! Path expression resolution.\n \n use hir_def::{\n-    path::{Path, PathSegment},\n+    path::{Path, PathKind, PathSegment},\n     resolver::{HasResolver, ResolveValueResult, Resolver, TypeNs, ValueNs},\n     AssocItemId, ContainerId, Lookup,\n };\n use hir_expand::name::Name;\n \n-use crate::{\n-    db::HirDatabase,\n-    ty::{method_resolution, Substs, Ty, TypeWalk, ValueTyDefId},\n-};\n+use crate::{db::HirDatabase, method_resolution, Substs, Ty, TypeWalk, ValueTyDefId};\n \n use super::{ExprOrPatId, InferenceContext, TraitRef};\n \n@@ -33,7 +30,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         path: &Path,\n         id: ExprOrPatId,\n     ) -> Option<Ty> {\n-        let (value, self_subst) = if let crate::PathKind::Type(type_ref) = &path.kind {\n+        let (value, self_subst) = if let PathKind::Type(type_ref) = &path.kind {\n             if path.segments.is_empty() {\n                 // This can't actually happen syntax-wise\n                 return None;", "previous_filename": "crates/ra_hir/src/ty/infer/path.rs"}, {"sha": "f3a8756785d852fe87b64970eed8247c90df68e3", "filename": "crates/ra_hir_ty/src/infer/unify.rs", "status": "renamed", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -2,12 +2,8 @@\n \n use super::{InferenceContext, Obligation};\n use crate::{\n-    db::HirDatabase,\n-    ty::{\n-        Canonical, InEnvironment, InferTy, ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty,\n-        TypeWalk,\n-    },\n-    util::make_mut_slice,\n+    db::HirDatabase, utils::make_mut_slice, Canonical, InEnvironment, InferTy, ProjectionPredicate,\n+    ProjectionTy, Substs, TraitRef, Ty, TypeWalk,\n };\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {", "previous_filename": "crates/ra_hir/src/ty/infer/unify.rs"}, {"sha": "f2584632682ad40cd33cff6f8b204815e97d1c56", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 1132, "deletions": 2, "changes": 1134, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -1,4 +1,1134 @@\n-//! Work in Progress: everything related to types, type inference and trait\n-//! solving.\n+//! The type system. We currently use this to infer types for completion, hover\n+//! information and various assists.\n \n+macro_rules! impl_froms {\n+    ($e:ident: $($v:ident $(($($sv:ident),*))?),*) => {\n+        $(\n+            impl From<$v> for $e {\n+                fn from(it: $v) -> $e {\n+                    $e::$v(it)\n+                }\n+            }\n+            $($(\n+                impl From<$sv> for $e {\n+                    fn from(it: $sv) -> $e {\n+                        $e::$v($v::$sv(it))\n+                    }\n+                }\n+            )*)?\n+        )*\n+    }\n+}\n+\n+mod autoderef;\n pub mod primitive;\n+pub mod traits;\n+pub mod method_resolution;\n+mod op;\n+mod lower;\n+mod infer;\n+pub mod display;\n+pub(crate) mod utils;\n+pub mod db;\n+pub mod diagnostics;\n+pub mod expr;\n+\n+#[cfg(test)]\n+mod tests;\n+#[cfg(test)]\n+mod test_db;\n+mod marks;\n+\n+use std::ops::Deref;\n+use std::sync::Arc;\n+use std::{fmt, iter, mem};\n+\n+use hir_def::{\n+    expr::ExprId, generics::GenericParams, type_ref::Mutability, AdtId, ContainerId, DefWithBodyId,\n+    GenericDefId, HasModule, Lookup, TraitId, TypeAliasId,\n+};\n+use hir_expand::name::Name;\n+use ra_db::{impl_intern_key, salsa, CrateId};\n+\n+use crate::{\n+    db::HirDatabase,\n+    primitive::{FloatTy, IntTy, Uncertain},\n+    utils::make_mut_slice,\n+};\n+use display::{HirDisplay, HirFormatter};\n+\n+pub use autoderef::autoderef;\n+pub use infer::{infer_query, InferTy, InferenceResult};\n+pub use lower::CallableDef;\n+pub use lower::{callable_item_sig, TyDefId, ValueTyDefId};\n+pub use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironment};\n+\n+/// A type constructor or type name: this might be something like the primitive\n+/// type `bool`, a struct like `Vec`, or things like function pointers or\n+/// tuples.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum TypeCtor {\n+    /// The primitive boolean type. Written as `bool`.\n+    Bool,\n+\n+    /// The primitive character type; holds a Unicode scalar value\n+    /// (a non-surrogate code point). Written as `char`.\n+    Char,\n+\n+    /// A primitive integer type. For example, `i32`.\n+    Int(Uncertain<IntTy>),\n+\n+    /// A primitive floating-point type. For example, `f64`.\n+    Float(Uncertain<FloatTy>),\n+\n+    /// Structures, enumerations and unions.\n+    Adt(AdtId),\n+\n+    /// The pointee of a string slice. Written as `str`.\n+    Str,\n+\n+    /// The pointee of an array slice.  Written as `[T]`.\n+    Slice,\n+\n+    /// An array with the given length. Written as `[T; n]`.\n+    Array,\n+\n+    /// A raw pointer. Written as `*mut T` or `*const T`\n+    RawPtr(Mutability),\n+\n+    /// A reference; a pointer with an associated lifetime. Written as\n+    /// `&'a mut T` or `&'a T`.\n+    Ref(Mutability),\n+\n+    /// The anonymous type of a function declaration/definition. Each\n+    /// function has a unique type, which is output (for a function\n+    /// named `foo` returning an `i32`) as `fn() -> i32 {foo}`.\n+    ///\n+    /// This includes tuple struct / enum variant constructors as well.\n+    ///\n+    /// For example the type of `bar` here:\n+    ///\n+    /// ```\n+    /// fn foo() -> i32 { 1 }\n+    /// let bar = foo; // bar: fn() -> i32 {foo}\n+    /// ```\n+    FnDef(CallableDef),\n+\n+    /// A pointer to a function.  Written as `fn() -> i32`.\n+    ///\n+    /// For example the type of `bar` here:\n+    ///\n+    /// ```\n+    /// fn foo() -> i32 { 1 }\n+    /// let bar: fn() -> i32 = foo;\n+    /// ```\n+    FnPtr { num_args: u16 },\n+\n+    /// The never type `!`.\n+    Never,\n+\n+    /// A tuple type.  For example, `(i32, bool)`.\n+    Tuple { cardinality: u16 },\n+\n+    /// Represents an associated item like `Iterator::Item`.  This is used\n+    /// when we have tried to normalize a projection like `T::Item` but\n+    /// couldn't find a better representation.  In that case, we generate\n+    /// an **application type** like `(Iterator::Item)<T>`.\n+    AssociatedType(TypeAliasId),\n+\n+    /// The type of a specific closure.\n+    ///\n+    /// The closure signature is stored in a `FnPtr` type in the first type\n+    /// parameter.\n+    Closure { def: DefWithBodyId, expr: ExprId },\n+}\n+\n+/// This exists just for Chalk, because Chalk just has a single `StructId` where\n+/// we have different kinds of ADTs, primitive types and special type\n+/// constructors like tuples and function pointers.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct TypeCtorId(salsa::InternId);\n+impl_intern_key!(TypeCtorId);\n+\n+impl TypeCtor {\n+    pub fn num_ty_params(self, db: &impl HirDatabase) -> usize {\n+        match self {\n+            TypeCtor::Bool\n+            | TypeCtor::Char\n+            | TypeCtor::Int(_)\n+            | TypeCtor::Float(_)\n+            | TypeCtor::Str\n+            | TypeCtor::Never => 0,\n+            TypeCtor::Slice\n+            | TypeCtor::Array\n+            | TypeCtor::RawPtr(_)\n+            | TypeCtor::Ref(_)\n+            | TypeCtor::Closure { .. } // 1 param representing the signature of the closure\n+            => 1,\n+            TypeCtor::Adt(adt) => {\n+                let generic_params = db.generic_params(AdtId::from(adt).into());\n+                generic_params.count_params_including_parent()\n+            }\n+            TypeCtor::FnDef(callable) => {\n+                let generic_params = db.generic_params(callable.into());\n+                generic_params.count_params_including_parent()\n+            }\n+            TypeCtor::AssociatedType(type_alias) => {\n+                let generic_params = db.generic_params(type_alias.into());\n+                generic_params.count_params_including_parent()\n+            }\n+            TypeCtor::FnPtr { num_args } => num_args as usize + 1,\n+            TypeCtor::Tuple { cardinality } => cardinality as usize,\n+        }\n+    }\n+\n+    pub fn krate(self, db: &impl HirDatabase) -> Option<CrateId> {\n+        match self {\n+            TypeCtor::Bool\n+            | TypeCtor::Char\n+            | TypeCtor::Int(_)\n+            | TypeCtor::Float(_)\n+            | TypeCtor::Str\n+            | TypeCtor::Never\n+            | TypeCtor::Slice\n+            | TypeCtor::Array\n+            | TypeCtor::RawPtr(_)\n+            | TypeCtor::Ref(_)\n+            | TypeCtor::FnPtr { .. }\n+            | TypeCtor::Tuple { .. } => None,\n+            // Closure's krate is irrelevant for coherence I would think?\n+            TypeCtor::Closure { .. } => None,\n+            TypeCtor::Adt(adt) => Some(adt.module(db).krate),\n+            TypeCtor::FnDef(callable) => Some(callable.krate(db)),\n+            TypeCtor::AssociatedType(type_alias) => Some(type_alias.lookup(db).module(db).krate),\n+        }\n+    }\n+\n+    pub fn as_generic_def(self) -> Option<GenericDefId> {\n+        match self {\n+            TypeCtor::Bool\n+            | TypeCtor::Char\n+            | TypeCtor::Int(_)\n+            | TypeCtor::Float(_)\n+            | TypeCtor::Str\n+            | TypeCtor::Never\n+            | TypeCtor::Slice\n+            | TypeCtor::Array\n+            | TypeCtor::RawPtr(_)\n+            | TypeCtor::Ref(_)\n+            | TypeCtor::FnPtr { .. }\n+            | TypeCtor::Tuple { .. }\n+            | TypeCtor::Closure { .. } => None,\n+            TypeCtor::Adt(adt) => Some(adt.into()),\n+            TypeCtor::FnDef(callable) => Some(callable.into()),\n+            TypeCtor::AssociatedType(type_alias) => Some(type_alias.into()),\n+        }\n+    }\n+}\n+\n+/// A nominal type with (maybe 0) type parameters. This might be a primitive\n+/// type like `bool`, a struct, tuple, function pointer, reference or\n+/// several other things.\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct ApplicationTy {\n+    pub ctor: TypeCtor,\n+    pub parameters: Substs,\n+}\n+\n+/// A \"projection\" type corresponds to an (unnormalized)\n+/// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n+/// trait and all its parameters are fully known.\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct ProjectionTy {\n+    pub associated_ty: TypeAliasId,\n+    pub parameters: Substs,\n+}\n+\n+impl ProjectionTy {\n+    pub fn trait_ref(&self, db: &impl HirDatabase) -> TraitRef {\n+        TraitRef { trait_: self.trait_(db).into(), substs: self.parameters.clone() }\n+    }\n+\n+    fn trait_(&self, db: &impl HirDatabase) -> TraitId {\n+        match self.associated_ty.lookup(db).container {\n+            ContainerId::TraitId(it) => it,\n+            _ => panic!(\"projection ty without parent trait\"),\n+        }\n+    }\n+}\n+\n+impl TypeWalk for ProjectionTy {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        self.parameters.walk(f);\n+    }\n+\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        self.parameters.walk_mut_binders(f, binders);\n+    }\n+}\n+\n+/// A type.\n+///\n+/// See also the `TyKind` enum in rustc (librustc/ty/sty.rs), which represents\n+/// the same thing (but in a different way).\n+///\n+/// This should be cheap to clone.\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum Ty {\n+    /// A nominal type with (maybe 0) type parameters. This might be a primitive\n+    /// type like `bool`, a struct, tuple, function pointer, reference or\n+    /// several other things.\n+    Apply(ApplicationTy),\n+\n+    /// A \"projection\" type corresponds to an (unnormalized)\n+    /// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n+    /// trait and all its parameters are fully known.\n+    Projection(ProjectionTy),\n+\n+    /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n+    Param {\n+        /// The index of the parameter (starting with parameters from the\n+        /// surrounding impl, then the current function).\n+        idx: u32,\n+        /// The name of the parameter, for displaying.\n+        // FIXME get rid of this\n+        name: Name,\n+    },\n+\n+    /// A bound type variable. Used during trait resolution to represent Chalk\n+    /// variables, and in `Dyn` and `Opaque` bounds to represent the `Self` type.\n+    Bound(u32),\n+\n+    /// A type variable used during type checking. Not to be confused with a\n+    /// type parameter.\n+    Infer(InferTy),\n+\n+    /// A trait object (`dyn Trait` or bare `Trait` in pre-2018 Rust).\n+    ///\n+    /// The predicates are quantified over the `Self` type, i.e. `Ty::Bound(0)`\n+    /// represents the `Self` type inside the bounds. This is currently\n+    /// implicit; Chalk has the `Binders` struct to make it explicit, but it\n+    /// didn't seem worth the overhead yet.\n+    Dyn(Arc<[GenericPredicate]>),\n+\n+    /// An opaque type (`impl Trait`).\n+    ///\n+    /// The predicates are quantified over the `Self` type; see `Ty::Dyn` for\n+    /// more.\n+    Opaque(Arc<[GenericPredicate]>),\n+\n+    /// A placeholder for a type which could not be computed; this is propagated\n+    /// to avoid useless error messages. Doubles as a placeholder where type\n+    /// variables are inserted before type checking, since we want to try to\n+    /// infer a better type here anyway -- for the IDE use case, we want to try\n+    /// to infer as much as possible even in the presence of type errors.\n+    Unknown,\n+}\n+\n+/// A list of substitutions for generic parameters.\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct Substs(Arc<[Ty]>);\n+\n+impl TypeWalk for Substs {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        for t in self.0.iter() {\n+            t.walk(f);\n+        }\n+    }\n+\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        for t in make_mut_slice(&mut self.0) {\n+            t.walk_mut_binders(f, binders);\n+        }\n+    }\n+}\n+\n+impl Substs {\n+    pub fn empty() -> Substs {\n+        Substs(Arc::new([]))\n+    }\n+\n+    pub fn single(ty: Ty) -> Substs {\n+        Substs(Arc::new([ty]))\n+    }\n+\n+    pub fn prefix(&self, n: usize) -> Substs {\n+        Substs(self.0[..std::cmp::min(self.0.len(), n)].into())\n+    }\n+\n+    pub fn as_single(&self) -> &Ty {\n+        if self.0.len() != 1 {\n+            panic!(\"expected substs of len 1, got {:?}\", self);\n+        }\n+        &self.0[0]\n+    }\n+\n+    /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n+    pub fn identity(generic_params: &GenericParams) -> Substs {\n+        Substs(\n+            generic_params\n+                .params_including_parent()\n+                .into_iter()\n+                .map(|p| Ty::Param { idx: p.idx, name: p.name.clone() })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Return Substs that replace each parameter by a bound variable.\n+    pub fn bound_vars(generic_params: &GenericParams) -> Substs {\n+        Substs(\n+            generic_params\n+                .params_including_parent()\n+                .into_iter()\n+                .map(|p| Ty::Bound(p.idx))\n+                .collect(),\n+        )\n+    }\n+\n+    pub fn build_for_def(db: &impl HirDatabase, def: impl Into<GenericDefId>) -> SubstsBuilder {\n+        let def = def.into();\n+        let params = db.generic_params(def);\n+        let param_count = params.count_params_including_parent();\n+        Substs::builder(param_count)\n+    }\n+\n+    pub fn build_for_generics(generic_params: &GenericParams) -> SubstsBuilder {\n+        Substs::builder(generic_params.count_params_including_parent())\n+    }\n+\n+    pub fn build_for_type_ctor(db: &impl HirDatabase, type_ctor: TypeCtor) -> SubstsBuilder {\n+        Substs::builder(type_ctor.num_ty_params(db))\n+    }\n+\n+    fn builder(param_count: usize) -> SubstsBuilder {\n+        SubstsBuilder { vec: Vec::with_capacity(param_count), param_count }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct SubstsBuilder {\n+    vec: Vec<Ty>,\n+    param_count: usize,\n+}\n+\n+impl SubstsBuilder {\n+    pub fn build(self) -> Substs {\n+        assert_eq!(self.vec.len(), self.param_count);\n+        Substs(self.vec.into())\n+    }\n+\n+    pub fn push(mut self, ty: Ty) -> Self {\n+        self.vec.push(ty);\n+        self\n+    }\n+\n+    fn remaining(&self) -> usize {\n+        self.param_count - self.vec.len()\n+    }\n+\n+    pub fn fill_with_bound_vars(self, starting_from: u32) -> Self {\n+        self.fill((starting_from..).map(Ty::Bound))\n+    }\n+\n+    pub fn fill_with_params(self) -> Self {\n+        let start = self.vec.len() as u32;\n+        self.fill((start..).map(|idx| Ty::Param { idx, name: Name::missing() }))\n+    }\n+\n+    pub fn fill_with_unknown(self) -> Self {\n+        self.fill(iter::repeat(Ty::Unknown))\n+    }\n+\n+    pub fn fill(mut self, filler: impl Iterator<Item = Ty>) -> Self {\n+        self.vec.extend(filler.take(self.remaining()));\n+        assert_eq!(self.remaining(), 0);\n+        self\n+    }\n+\n+    pub fn use_parent_substs(mut self, parent_substs: &Substs) -> Self {\n+        assert!(self.vec.is_empty());\n+        assert!(parent_substs.len() <= self.param_count);\n+        self.vec.extend(parent_substs.iter().cloned());\n+        self\n+    }\n+}\n+\n+impl Deref for Substs {\n+    type Target = [Ty];\n+\n+    fn deref(&self) -> &[Ty] {\n+        &self.0\n+    }\n+}\n+\n+/// A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait.\n+/// Name to be bikeshedded: TraitBound? TraitImplements?\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct TraitRef {\n+    /// FIXME name?\n+    pub trait_: TraitId,\n+    pub substs: Substs,\n+}\n+\n+impl TraitRef {\n+    pub fn self_ty(&self) -> &Ty {\n+        &self.substs[0]\n+    }\n+}\n+\n+impl TypeWalk for TraitRef {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        self.substs.walk(f);\n+    }\n+\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        self.substs.walk_mut_binders(f, binders);\n+    }\n+}\n+\n+/// Like `generics::WherePredicate`, but with resolved types: A condition on the\n+/// parameters of a generic item.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum GenericPredicate {\n+    /// The given trait needs to be implemented for its type parameters.\n+    Implemented(TraitRef),\n+    /// An associated type bindings like in `Iterator<Item = T>`.\n+    Projection(ProjectionPredicate),\n+    /// We couldn't resolve the trait reference. (If some type parameters can't\n+    /// be resolved, they will just be Unknown).\n+    Error,\n+}\n+\n+impl GenericPredicate {\n+    pub fn is_error(&self) -> bool {\n+        match self {\n+            GenericPredicate::Error => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_implemented(&self) -> bool {\n+        match self {\n+            GenericPredicate::Implemented(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn trait_ref(&self, db: &impl HirDatabase) -> Option<TraitRef> {\n+        match self {\n+            GenericPredicate::Implemented(tr) => Some(tr.clone()),\n+            GenericPredicate::Projection(proj) => Some(proj.projection_ty.trait_ref(db)),\n+            GenericPredicate::Error => None,\n+        }\n+    }\n+}\n+\n+impl TypeWalk for GenericPredicate {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        match self {\n+            GenericPredicate::Implemented(trait_ref) => trait_ref.walk(f),\n+            GenericPredicate::Projection(projection_pred) => projection_pred.walk(f),\n+            GenericPredicate::Error => {}\n+        }\n+    }\n+\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        match self {\n+            GenericPredicate::Implemented(trait_ref) => trait_ref.walk_mut_binders(f, binders),\n+            GenericPredicate::Projection(projection_pred) => {\n+                projection_pred.walk_mut_binders(f, binders)\n+            }\n+            GenericPredicate::Error => {}\n+        }\n+    }\n+}\n+\n+/// Basically a claim (currently not validated / checked) that the contained\n+/// type / trait ref contains no inference variables; any inference variables it\n+/// contained have been replaced by bound variables, and `num_vars` tells us how\n+/// many there are. This is used to erase irrelevant differences between types\n+/// before using them in queries.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Canonical<T> {\n+    pub value: T,\n+    pub num_vars: usize,\n+}\n+\n+/// A function signature as seen by type inference: Several parameter types and\n+/// one return type.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct FnSig {\n+    params_and_return: Arc<[Ty]>,\n+}\n+\n+impl FnSig {\n+    pub fn from_params_and_return(mut params: Vec<Ty>, ret: Ty) -> FnSig {\n+        params.push(ret);\n+        FnSig { params_and_return: params.into() }\n+    }\n+\n+    pub fn from_fn_ptr_substs(substs: &Substs) -> FnSig {\n+        FnSig { params_and_return: Arc::clone(&substs.0) }\n+    }\n+\n+    pub fn params(&self) -> &[Ty] {\n+        &self.params_and_return[0..self.params_and_return.len() - 1]\n+    }\n+\n+    pub fn ret(&self) -> &Ty {\n+        &self.params_and_return[self.params_and_return.len() - 1]\n+    }\n+}\n+\n+impl TypeWalk for FnSig {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        for t in self.params_and_return.iter() {\n+            t.walk(f);\n+        }\n+    }\n+\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        for t in make_mut_slice(&mut self.params_and_return) {\n+            t.walk_mut_binders(f, binders);\n+        }\n+    }\n+}\n+\n+impl Ty {\n+    pub fn simple(ctor: TypeCtor) -> Ty {\n+        Ty::Apply(ApplicationTy { ctor, parameters: Substs::empty() })\n+    }\n+    pub fn apply_one(ctor: TypeCtor, param: Ty) -> Ty {\n+        Ty::Apply(ApplicationTy { ctor, parameters: Substs::single(param) })\n+    }\n+    pub fn apply(ctor: TypeCtor, parameters: Substs) -> Ty {\n+        Ty::Apply(ApplicationTy { ctor, parameters })\n+    }\n+    pub fn unit() -> Self {\n+        Ty::apply(TypeCtor::Tuple { cardinality: 0 }, Substs::empty())\n+    }\n+\n+    pub fn as_reference(&self) -> Option<(&Ty, Mutability)> {\n+        match self {\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::Ref(mutability), parameters }) => {\n+                Some((parameters.as_single(), *mutability))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn as_adt(&self) -> Option<(AdtId, &Substs)> {\n+        match self {\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::Adt(adt_def), parameters }) => {\n+                Some((*adt_def, parameters))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn as_tuple(&self) -> Option<&Substs> {\n+        match self {\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::Tuple { .. }, parameters }) => {\n+                Some(parameters)\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn as_callable(&self) -> Option<(CallableDef, &Substs)> {\n+        match self {\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::FnDef(callable_def), parameters }) => {\n+                Some((*callable_def, parameters))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    fn builtin_deref(&self) -> Option<Ty> {\n+        match self {\n+            Ty::Apply(a_ty) => match a_ty.ctor {\n+                TypeCtor::Ref(..) => Some(Ty::clone(a_ty.parameters.as_single())),\n+                TypeCtor::RawPtr(..) => Some(Ty::clone(a_ty.parameters.as_single())),\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    fn callable_sig(&self, db: &impl HirDatabase) -> Option<FnSig> {\n+        match self {\n+            Ty::Apply(a_ty) => match a_ty.ctor {\n+                TypeCtor::FnPtr { .. } => Some(FnSig::from_fn_ptr_substs(&a_ty.parameters)),\n+                TypeCtor::FnDef(def) => {\n+                    let sig = db.callable_item_signature(def);\n+                    Some(sig.subst(&a_ty.parameters))\n+                }\n+                TypeCtor::Closure { .. } => {\n+                    let sig_param = &a_ty.parameters[0];\n+                    sig_param.callable_sig(db)\n+                }\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    /// If this is a type with type parameters (an ADT or function), replaces\n+    /// the `Substs` for these type parameters with the given ones. (So e.g. if\n+    /// `self` is `Option<_>` and the substs contain `u32`, we'll have\n+    /// `Option<u32>` afterwards.)\n+    pub fn apply_substs(self, substs: Substs) -> Ty {\n+        match self {\n+            Ty::Apply(ApplicationTy { ctor, parameters: previous_substs }) => {\n+                assert_eq!(previous_substs.len(), substs.len());\n+                Ty::Apply(ApplicationTy { ctor, parameters: substs })\n+            }\n+            _ => self,\n+        }\n+    }\n+\n+    /// Returns the type parameters of this type if it has some (i.e. is an ADT\n+    /// or function); so if `self` is `Option<u32>`, this returns the `u32`.\n+    pub fn substs(&self) -> Option<Substs> {\n+        match self {\n+            Ty::Apply(ApplicationTy { parameters, .. }) => Some(parameters.clone()),\n+            _ => None,\n+        }\n+    }\n+\n+    /// If this is an `impl Trait` or `dyn Trait`, returns that trait.\n+    pub fn inherent_trait(&self) -> Option<TraitId> {\n+        match self {\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                predicates.iter().find_map(|pred| match pred {\n+                    GenericPredicate::Implemented(tr) => Some(tr.trait_),\n+                    _ => None,\n+                })\n+            }\n+            _ => None,\n+        }\n+    }\n+}\n+\n+/// This allows walking structures that contain types to do something with those\n+/// types, similar to Chalk's `Fold` trait.\n+pub trait TypeWalk {\n+    fn walk(&self, f: &mut impl FnMut(&Ty));\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+        self.walk_mut_binders(&mut |ty, _binders| f(ty), 0);\n+    }\n+    /// Walk the type, counting entered binders.\n+    ///\n+    /// `Ty::Bound` variables use DeBruijn indexing, which means that 0 refers\n+    /// to the innermost binder, 1 to the next, etc.. So when we want to\n+    /// substitute a certain bound variable, we can't just walk the whole type\n+    /// and blindly replace each instance of a certain index; when we 'enter'\n+    /// things that introduce new bound variables, we have to keep track of\n+    /// that. Currently, the only thing that introduces bound variables on our\n+    /// side are `Ty::Dyn` and `Ty::Opaque`, which each introduce a bound\n+    /// variable for the self type.\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize);\n+\n+    fn fold(mut self, f: &mut impl FnMut(Ty) -> Ty) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        self.walk_mut(&mut |ty_mut| {\n+            let ty = mem::replace(ty_mut, Ty::Unknown);\n+            *ty_mut = f(ty);\n+        });\n+        self\n+    }\n+\n+    /// Replaces type parameters in this type using the given `Substs`. (So e.g.\n+    /// if `self` is `&[T]`, where type parameter T has index 0, and the\n+    /// `Substs` contain `u32` at index 0, we'll have `&[u32]` afterwards.)\n+    fn subst(self, substs: &Substs) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        self.fold(&mut |ty| match ty {\n+            Ty::Param { idx, name } => {\n+                substs.get(idx as usize).cloned().unwrap_or(Ty::Param { idx, name })\n+            }\n+            ty => ty,\n+        })\n+    }\n+\n+    /// Substitutes `Ty::Bound` vars (as opposed to type parameters).\n+    fn subst_bound_vars(mut self, substs: &Substs) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        self.walk_mut_binders(\n+            &mut |ty, binders| match ty {\n+                &mut Ty::Bound(idx) => {\n+                    if idx as usize >= binders && (idx as usize - binders) < substs.len() {\n+                        *ty = substs.0[idx as usize - binders].clone();\n+                    }\n+                }\n+                _ => {}\n+            },\n+            0,\n+        );\n+        self\n+    }\n+\n+    /// Shifts up `Ty::Bound` vars by `n`.\n+    fn shift_bound_vars(self, n: i32) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        self.fold(&mut |ty| match ty {\n+            Ty::Bound(idx) => {\n+                assert!(idx as i32 >= -n);\n+                Ty::Bound((idx as i32 + n) as u32)\n+            }\n+            ty => ty,\n+        })\n+    }\n+}\n+\n+impl TypeWalk for Ty {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        match self {\n+            Ty::Apply(a_ty) => {\n+                for t in a_ty.parameters.iter() {\n+                    t.walk(f);\n+                }\n+            }\n+            Ty::Projection(p_ty) => {\n+                for t in p_ty.parameters.iter() {\n+                    t.walk(f);\n+                }\n+            }\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                for p in predicates.iter() {\n+                    p.walk(f);\n+                }\n+            }\n+            Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n+        }\n+        f(self);\n+    }\n+\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        match self {\n+            Ty::Apply(a_ty) => {\n+                a_ty.parameters.walk_mut_binders(f, binders);\n+            }\n+            Ty::Projection(p_ty) => {\n+                p_ty.parameters.walk_mut_binders(f, binders);\n+            }\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                for p in make_mut_slice(predicates) {\n+                    p.walk_mut_binders(f, binders + 1);\n+                }\n+            }\n+            Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n+        }\n+        f(self, binders);\n+    }\n+}\n+\n+impl HirDisplay for &Ty {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        HirDisplay::hir_fmt(*self, f)\n+    }\n+}\n+\n+impl HirDisplay for ApplicationTy {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"\u2026\");\n+        }\n+\n+        match self.ctor {\n+            TypeCtor::Bool => write!(f, \"bool\")?,\n+            TypeCtor::Char => write!(f, \"char\")?,\n+            TypeCtor::Int(t) => write!(f, \"{}\", t)?,\n+            TypeCtor::Float(t) => write!(f, \"{}\", t)?,\n+            TypeCtor::Str => write!(f, \"str\")?,\n+            TypeCtor::Slice => {\n+                let t = self.parameters.as_single();\n+                write!(f, \"[{}]\", t.display(f.db))?;\n+            }\n+            TypeCtor::Array => {\n+                let t = self.parameters.as_single();\n+                write!(f, \"[{};_]\", t.display(f.db))?;\n+            }\n+            TypeCtor::RawPtr(m) => {\n+                let t = self.parameters.as_single();\n+                write!(f, \"*{}{}\", m.as_keyword_for_ptr(), t.display(f.db))?;\n+            }\n+            TypeCtor::Ref(m) => {\n+                let t = self.parameters.as_single();\n+                write!(f, \"&{}{}\", m.as_keyword_for_ref(), t.display(f.db))?;\n+            }\n+            TypeCtor::Never => write!(f, \"!\")?,\n+            TypeCtor::Tuple { .. } => {\n+                let ts = &self.parameters;\n+                if ts.len() == 1 {\n+                    write!(f, \"({},)\", ts[0].display(f.db))?;\n+                } else {\n+                    write!(f, \"(\")?;\n+                    f.write_joined(&*ts.0, \", \")?;\n+                    write!(f, \")\")?;\n+                }\n+            }\n+            TypeCtor::FnPtr { .. } => {\n+                let sig = FnSig::from_fn_ptr_substs(&self.parameters);\n+                write!(f, \"fn(\")?;\n+                f.write_joined(sig.params(), \", \")?;\n+                write!(f, \") -> {}\", sig.ret().display(f.db))?;\n+            }\n+            TypeCtor::FnDef(def) => {\n+                let sig = f.db.callable_item_signature(def);\n+                let name = match def {\n+                    CallableDef::FunctionId(ff) => f.db.function_data(ff).name.clone(),\n+                    CallableDef::StructId(s) => {\n+                        f.db.struct_data(s).name.clone().unwrap_or_else(Name::missing)\n+                    }\n+                    CallableDef::EnumVariantId(e) => {\n+                        let enum_data = f.db.enum_data(e.parent);\n+                        enum_data.variants[e.local_id].name.clone().unwrap_or_else(Name::missing)\n+                    }\n+                };\n+                match def {\n+                    CallableDef::FunctionId(_) => write!(f, \"fn {}\", name)?,\n+                    CallableDef::StructId(_) | CallableDef::EnumVariantId(_) => {\n+                        write!(f, \"{}\", name)?\n+                    }\n+                }\n+                if self.parameters.len() > 0 {\n+                    write!(f, \"<\")?;\n+                    f.write_joined(&*self.parameters.0, \", \")?;\n+                    write!(f, \">\")?;\n+                }\n+                write!(f, \"(\")?;\n+                f.write_joined(sig.params(), \", \")?;\n+                write!(f, \") -> {}\", sig.ret().display(f.db))?;\n+            }\n+            TypeCtor::Adt(def_id) => {\n+                let name = match def_id {\n+                    AdtId::StructId(it) => f.db.struct_data(it).name.clone(),\n+                    AdtId::UnionId(it) => f.db.union_data(it).name.clone(),\n+                    AdtId::EnumId(it) => f.db.enum_data(it).name.clone(),\n+                }\n+                .unwrap_or_else(Name::missing);\n+                write!(f, \"{}\", name)?;\n+                if self.parameters.len() > 0 {\n+                    write!(f, \"<\")?;\n+                    f.write_joined(&*self.parameters.0, \", \")?;\n+                    write!(f, \">\")?;\n+                }\n+            }\n+            TypeCtor::AssociatedType(type_alias) => {\n+                let trait_ = match type_alias.lookup(f.db).container {\n+                    ContainerId::TraitId(it) => it,\n+                    _ => panic!(\"not an associated type\"),\n+                };\n+                let trait_name = f.db.trait_data(trait_).name.clone().unwrap_or_else(Name::missing);\n+                let name = f.db.type_alias_data(type_alias).name.clone();\n+                write!(f, \"{}::{}\", trait_name, name)?;\n+                if self.parameters.len() > 0 {\n+                    write!(f, \"<\")?;\n+                    f.write_joined(&*self.parameters.0, \", \")?;\n+                    write!(f, \">\")?;\n+                }\n+            }\n+            TypeCtor::Closure { .. } => {\n+                let sig = self.parameters[0]\n+                    .callable_sig(f.db)\n+                    .expect(\"first closure parameter should contain signature\");\n+                write!(f, \"|\")?;\n+                f.write_joined(sig.params(), \", \")?;\n+                write!(f, \"| -> {}\", sig.ret().display(f.db))?;\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for ProjectionTy {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"\u2026\");\n+        }\n+\n+        let trait_name =\n+            f.db.trait_data(self.trait_(f.db)).name.clone().unwrap_or_else(Name::missing);\n+        write!(f, \"<{} as {}\", self.parameters[0].display(f.db), trait_name,)?;\n+        if self.parameters.len() > 1 {\n+            write!(f, \"<\")?;\n+            f.write_joined(&self.parameters[1..], \", \")?;\n+            write!(f, \">\")?;\n+        }\n+        write!(f, \">::{}\", f.db.type_alias_data(self.associated_ty).name)?;\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Ty {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"\u2026\");\n+        }\n+\n+        match self {\n+            Ty::Apply(a_ty) => a_ty.hir_fmt(f)?,\n+            Ty::Projection(p_ty) => p_ty.hir_fmt(f)?,\n+            Ty::Param { name, .. } => write!(f, \"{}\", name)?,\n+            Ty::Bound(idx) => write!(f, \"?{}\", idx)?,\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                match self {\n+                    Ty::Dyn(_) => write!(f, \"dyn \")?,\n+                    Ty::Opaque(_) => write!(f, \"impl \")?,\n+                    _ => unreachable!(),\n+                };\n+                // Note: This code is written to produce nice results (i.e.\n+                // corresponding to surface Rust) for types that can occur in\n+                // actual Rust. It will have weird results if the predicates\n+                // aren't as expected (i.e. self types = $0, projection\n+                // predicates for a certain trait come after the Implemented\n+                // predicate for that trait).\n+                let mut first = true;\n+                let mut angle_open = false;\n+                for p in predicates.iter() {\n+                    match p {\n+                        GenericPredicate::Implemented(trait_ref) => {\n+                            if angle_open {\n+                                write!(f, \">\")?;\n+                            }\n+                            if !first {\n+                                write!(f, \" + \")?;\n+                            }\n+                            // We assume that the self type is $0 (i.e. the\n+                            // existential) here, which is the only thing that's\n+                            // possible in actual Rust, and hence don't print it\n+                            write!(\n+                                f,\n+                                \"{}\",\n+                                f.db.trait_data(trait_ref.trait_)\n+                                    .name\n+                                    .clone()\n+                                    .unwrap_or_else(Name::missing)\n+                            )?;\n+                            if trait_ref.substs.len() > 1 {\n+                                write!(f, \"<\")?;\n+                                f.write_joined(&trait_ref.substs[1..], \", \")?;\n+                                // there might be assoc type bindings, so we leave the angle brackets open\n+                                angle_open = true;\n+                            }\n+                        }\n+                        GenericPredicate::Projection(projection_pred) => {\n+                            // in types in actual Rust, these will always come\n+                            // after the corresponding Implemented predicate\n+                            if angle_open {\n+                                write!(f, \", \")?;\n+                            } else {\n+                                write!(f, \"<\")?;\n+                                angle_open = true;\n+                            }\n+                            let name =\n+                                f.db.type_alias_data(projection_pred.projection_ty.associated_ty)\n+                                    .name\n+                                    .clone();\n+                            write!(f, \"{} = \", name)?;\n+                            projection_pred.ty.hir_fmt(f)?;\n+                        }\n+                        GenericPredicate::Error => {\n+                            if angle_open {\n+                                // impl Trait<X, {error}>\n+                                write!(f, \", \")?;\n+                            } else if !first {\n+                                // impl Trait + {error}\n+                                write!(f, \" + \")?;\n+                            }\n+                            p.hir_fmt(f)?;\n+                        }\n+                    }\n+                    first = false;\n+                }\n+                if angle_open {\n+                    write!(f, \">\")?;\n+                }\n+            }\n+            Ty::Unknown => write!(f, \"{{unknown}}\")?,\n+            Ty::Infer(..) => write!(f, \"_\")?,\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl TraitRef {\n+    fn hir_fmt_ext(&self, f: &mut HirFormatter<impl HirDatabase>, use_as: bool) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"\u2026\");\n+        }\n+\n+        self.substs[0].hir_fmt(f)?;\n+        if use_as {\n+            write!(f, \" as \")?;\n+        } else {\n+            write!(f, \": \")?;\n+        }\n+        write!(f, \"{}\", f.db.trait_data(self.trait_).name.clone().unwrap_or_else(Name::missing))?;\n+        if self.substs.len() > 1 {\n+            write!(f, \"<\")?;\n+            f.write_joined(&self.substs[1..], \", \")?;\n+            write!(f, \">\")?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for TraitRef {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        self.hir_fmt_ext(f, false)\n+    }\n+}\n+\n+impl HirDisplay for &GenericPredicate {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        HirDisplay::hir_fmt(*self, f)\n+    }\n+}\n+\n+impl HirDisplay for GenericPredicate {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"\u2026\");\n+        }\n+\n+        match self {\n+            GenericPredicate::Implemented(trait_ref) => trait_ref.hir_fmt(f)?,\n+            GenericPredicate::Projection(projection_pred) => {\n+                write!(f, \"<\")?;\n+                projection_pred.projection_ty.trait_ref(f.db).hir_fmt_ext(f, true)?;\n+                write!(\n+                    f,\n+                    \">::{} = {}\",\n+                    f.db.type_alias_data(projection_pred.projection_ty.associated_ty).name,\n+                    projection_pred.ty.display(f.db)\n+                )?;\n+            }\n+            GenericPredicate::Error => write!(f, \"{{error}}\")?,\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Obligation {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        match self {\n+            Obligation::Trait(tr) => write!(f, \"Implements({})\", tr.display(f.db)),\n+            Obligation::Projection(proj) => write!(\n+                f,\n+                \"Normalize({} => {})\",\n+                proj.projection_ty.display(f.db),\n+                proj.ty.display(f.db)\n+            ),\n+        }\n+    }\n+}"}, {"sha": "53d955a1240a19a7a2689824a3850fd61699b12a", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "renamed", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -11,7 +11,7 @@ use std::sync::Arc;\n use hir_def::{\n     builtin_type::BuiltinType,\n     generics::WherePredicate,\n-    path::{GenericArg, Path, PathSegment},\n+    path::{GenericArg, Path, PathKind, PathSegment},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TypeBound, TypeRef},\n     AdtId, AstItemDef, ConstId, EnumId, EnumVariantId, FunctionId, GenericDefId, HasModule,\n@@ -26,15 +26,13 @@ use super::{\n };\n use crate::{\n     db::HirDatabase,\n-    ty::{\n-        primitive::{FloatTy, IntTy},\n-        utils::{all_super_traits, associated_type_by_name_including_super_traits, variant_data},\n-    },\n-    util::make_mut_slice,\n+    primitive::{FloatTy, IntTy},\n+    utils::make_mut_slice,\n+    utils::{all_super_traits, associated_type_by_name_including_super_traits, variant_data},\n };\n \n impl Ty {\n-    pub(crate) fn from_hir(db: &impl HirDatabase, resolver: &Resolver, type_ref: &TypeRef) -> Self {\n+    pub fn from_hir(db: &impl HirDatabase, resolver: &Resolver, type_ref: &TypeRef) -> Self {\n         match type_ref {\n             TypeRef::Never => Ty::simple(TypeCtor::Never),\n             TypeRef::Tuple(inner) => {\n@@ -103,7 +101,7 @@ impl Ty {\n             TypeRef::Path(path) => path,\n             _ => return None,\n         };\n-        if let crate::PathKind::Type(_) = &path.kind {\n+        if let PathKind::Type(_) = &path.kind {\n             return None;\n         }\n         if path.segments.len() > 1 {\n@@ -204,7 +202,7 @@ impl Ty {\n \n     pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Ty {\n         // Resolve the path (in type namespace)\n-        if let crate::PathKind::Type(type_ref) = &path.kind {\n+        if let PathKind::Type(type_ref) = &path.kind {\n             let ty = Ty::from_hir(db, resolver, &type_ref);\n             let remaining_segments = &path.segments[..];\n             return Ty::from_type_relative_path(db, resolver, ty, remaining_segments);\n@@ -421,7 +419,7 @@ impl TraitRef {\n         substs_from_path_segment(db, resolver, segment, Some(resolved.into()), !has_self_param)\n     }\n \n-    pub(crate) fn for_trait(db: &impl HirDatabase, trait_: TraitId) -> TraitRef {\n+    pub fn for_trait(db: &impl HirDatabase, trait_: TraitId) -> TraitRef {\n         let substs = Substs::identity(&db.generic_params(trait_.into()));\n         TraitRef { trait_, substs }\n     }\n@@ -495,7 +493,7 @@ fn assoc_type_bindings_from_type_bound<'a>(\n }\n \n /// Build the signature of a callable item (function, struct or enum variant).\n-pub(crate) fn callable_item_sig(db: &impl HirDatabase, def: CallableDef) -> FnSig {\n+pub fn callable_item_sig(db: &impl HirDatabase, def: CallableDef) -> FnSig {\n     match def {\n         CallableDef::FunctionId(f) => fn_sig_for_fn(db, f),\n         CallableDef::StructId(s) => fn_sig_for_struct_constructor(db, s),\n@@ -544,7 +542,7 @@ pub(crate) fn generic_predicates_for_param_query(\n }\n \n impl TraitEnvironment {\n-    pub(crate) fn lower(db: &impl HirDatabase, resolver: &Resolver) -> Arc<TraitEnvironment> {\n+    pub fn lower(db: &impl HirDatabase, resolver: &Resolver) -> Arc<TraitEnvironment> {\n         let predicates = resolver\n             .where_predicates_in_scope()\n             .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))", "previous_filename": "crates/ra_hir/src/ty/lower.rs"}, {"sha": "0f754eb9c75515c3ed8767723127102802a6da16", "filename": "crates/ra_hir_ty/src/marks.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "previous_filename": "crates/ra_hir/src/marks.rs"}, {"sha": "53c541eb8e7343cb7346805dd4b7eb5faf1b9ae3", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "renamed", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -16,8 +16,9 @@ use rustc_hash::FxHashMap;\n \n use crate::{\n     db::HirDatabase,\n-    ty::primitive::{FloatBitness, Uncertain},\n-    ty::{utils::all_super_traits, Ty, TypeCtor},\n+    primitive::{FloatBitness, Uncertain},\n+    utils::all_super_traits,\n+    Ty, TypeCtor,\n };\n \n use super::{autoderef, Canonical, InEnvironment, TraitEnvironment, TraitRef};\n@@ -97,7 +98,7 @@ impl CrateImplBlocks {\n }\n \n impl Ty {\n-    pub(crate) fn def_crates(\n+    pub fn def_crates(\n         &self,\n         db: &impl HirDatabase,\n         cur_crate: CrateId,\n@@ -176,7 +177,7 @@ pub enum LookupMode {\n // This would be nicer if it just returned an iterator, but that runs into\n // lifetime problems, because we need to borrow temp `CrateImplBlocks`.\n // FIXME add a context type here?\n-pub(crate) fn iterate_method_candidates<T>(\n+pub fn iterate_method_candidates<T>(\n     ty: &Canonical<Ty>,\n     db: &impl HirDatabase,\n     resolver: &Resolver,\n@@ -323,7 +324,7 @@ fn is_valid_candidate(\n     }\n }\n \n-pub(crate) fn implements_trait(\n+pub fn implements_trait(\n     ty: &Canonical<Ty>,\n     db: &impl HirDatabase,\n     resolver: &Resolver,", "previous_filename": "crates/ra_hir/src/ty/method_resolution.rs"}, {"sha": "09c47a76d0cc1d5c6213714816579c50a2a10805", "filename": "crates/ra_hir_ty/src/op.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fop.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -2,7 +2,7 @@\n use hir_def::expr::{BinaryOp, CmpOp};\n \n use super::{InferTy, Ty, TypeCtor};\n-use crate::ty::ApplicationTy;\n+use crate::ApplicationTy;\n \n pub(super) fn binary_op_return_ty(op: BinaryOp, rhs_ty: Ty) -> Ty {\n     match op {", "previous_filename": "crates/ra_hir/src/ty/op.rs"}, {"sha": "0e51f4130f3f33f5d97ff2d6eaff03ebec4c6a4d", "filename": "crates/ra_hir_ty/src/test_db.rs", "status": "renamed", "additions": 45, "deletions": 24, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -2,20 +2,20 @@\n \n use std::{panic, sync::Arc};\n \n-use hir_def::{db::DefDatabase, ModuleId};\n+use hir_def::{db::DefDatabase, AssocItemId, ModuleDefId, ModuleId};\n use hir_expand::diagnostics::DiagnosticSink;\n use parking_lot::Mutex;\n use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, RelativePath, SourceDatabase};\n \n-use crate::{db, debug::HirDebugHelper};\n+use crate::{db::HirDatabase, expr::ExprValidator};\n \n #[salsa::database(\n     ra_db::SourceDatabaseExtStorage,\n     ra_db::SourceDatabaseStorage,\n-    db::InternDatabaseStorage,\n-    db::AstDatabaseStorage,\n-    db::DefDatabaseStorage,\n-    db::HirDatabaseStorage\n+    hir_expand::db::AstDatabaseStorage,\n+    hir_def::db::InternDatabaseStorage,\n+    hir_def::db::DefDatabaseStorage,\n+    crate::db::HirDatabaseStorage\n )]\n #[derive(Debug, Default)]\n pub struct TestDB {\n@@ -67,32 +67,53 @@ impl FileLoader for TestDB {\n     }\n }\n \n-// FIXME: improve `WithFixture` to bring useful hir debugging back\n-impl HirDebugHelper for TestDB {\n-    fn crate_name(&self, _krate: CrateId) -> Option<String> {\n-        None\n-    }\n-\n-    fn file_path(&self, _file_id: FileId) -> Option<String> {\n-        None\n+impl TestDB {\n+    pub fn module_for_file(&self, file_id: FileId) -> ModuleId {\n+        for &krate in self.relevant_crates(file_id).iter() {\n+            let crate_def_map = self.crate_def_map(krate);\n+            for (module_id, data) in crate_def_map.modules.iter() {\n+                if data.definition == Some(file_id) {\n+                    return ModuleId { krate, module_id };\n+                }\n+            }\n+        }\n+        panic!(\"Can't find module for file\")\n     }\n-}\n \n-impl TestDB {\n+    // FIXME: don't duplicate this\n     pub fn diagnostics(&self) -> String {\n         let mut buf = String::new();\n         let crate_graph = self.crate_graph();\n         for krate in crate_graph.iter().next() {\n             let crate_def_map = self.crate_def_map(krate);\n+\n+            let mut fns = Vec::new();\n             for (module_id, _) in crate_def_map.modules.iter() {\n-                let module_id = ModuleId { krate, module_id };\n-                let module = crate::Module::from(module_id);\n-                module.diagnostics(\n-                    self,\n-                    &mut DiagnosticSink::new(|d| {\n-                        buf += &format!(\"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n-                    }),\n-                )\n+                for decl in crate_def_map[module_id].scope.declarations() {\n+                    match decl {\n+                        ModuleDefId::FunctionId(f) => fns.push(f),\n+                        _ => (),\n+                    }\n+                }\n+\n+                for &impl_id in crate_def_map[module_id].impls.iter() {\n+                    let impl_data = self.impl_data(impl_id);\n+                    for item in impl_data.items.iter() {\n+                        if let AssocItemId::FunctionId(f) = item {\n+                            fns.push(*f)\n+                        }\n+                    }\n+                }\n+            }\n+\n+            for f in fns {\n+                let infer = self.infer(f.into());\n+                let mut sink = DiagnosticSink::new(|d| {\n+                    buf += &format!(\"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n+                });\n+                infer.add_diagnostics(self, f, &mut sink);\n+                let mut validator = ExprValidator::new(f, infer, &mut sink);\n+                validator.validate_body(self);\n             }\n         }\n         buf", "previous_filename": "crates/ra_hir/src/test_db.rs"}, {"sha": "c1744663a6afcdac33303343a23ab0d0743c4fdb", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "renamed", "additions": 86, "deletions": 24, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -4,20 +4,20 @@ mod coercion;\n use std::fmt::Write;\n use std::sync::Arc;\n \n+use hir_def::{\n+    body::BodySourceMap, db::DefDatabase, nameres::CrateDefMap, AssocItemId, DefWithBodyId,\n+    LocalModuleId, Lookup, ModuleDefId,\n+};\n+use hir_expand::Source;\n use insta::assert_snapshot;\n use ra_db::{fixture::WithFixture, salsa::Database, FilePosition, SourceDatabase};\n use ra_syntax::{\n     algo,\n     ast::{self, AstNode},\n-    SyntaxKind::*,\n };\n-use rustc_hash::FxHashSet;\n use test_utils::covers;\n \n-use crate::{\n-    expr::BodySourceMap, test_db::TestDB, ty::display::HirDisplay, ty::InferenceResult, Source,\n-    SourceAnalyzer,\n-};\n+use crate::{db::HirDatabase, display::HirDisplay, test_db::TestDB, InferenceResult};\n \n // These tests compare the inference results for all expressions in a file\n // against snapshots of the expected results using insta. Use cargo-insta to\n@@ -4674,10 +4674,20 @@ fn test<T, U>() where T: Trait<U::Item>, U: Trait<T::Item> {\n fn type_at_pos(db: &TestDB, pos: FilePosition) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();\n-    let analyzer =\n-        SourceAnalyzer::new(db, Source::new(pos.file_id.into(), expr.syntax()), Some(pos.offset));\n-    let ty = analyzer.type_of(db, &expr).unwrap();\n-    ty.display(db).to_string()\n+\n+    let module = db.module_for_file(pos.file_id);\n+    let crate_def_map = db.crate_def_map(module.krate);\n+    for decl in crate_def_map[module.module_id].scope.declarations() {\n+        if let ModuleDefId::FunctionId(func) = decl {\n+            let (_body, source_map) = db.body_with_source_map(func.into());\n+            if let Some(expr_id) = source_map.node_expr(Source::new(pos.file_id.into(), &expr)) {\n+                let infer = db.infer(func.into());\n+                let ty = &infer[expr_id];\n+                return ty.display(db).to_string();\n+            }\n+        }\n+    }\n+    panic!(\"Can't find expression\")\n }\n \n fn type_at(content: &str) -> String {\n@@ -4687,7 +4697,6 @@ fn type_at(content: &str) -> String {\n \n fn infer(content: &str) -> String {\n     let (db, file_id) = TestDB::with_single_file(content);\n-    let source_file = db.parse(file_id).ok().unwrap();\n \n     let mut acc = String::new();\n \n@@ -4740,20 +4749,69 @@ fn infer(content: &str) -> String {\n         }\n     };\n \n-    let mut analyzed = FxHashSet::default();\n-    for node in source_file.syntax().descendants() {\n-        if node.kind() == FN_DEF || node.kind() == CONST_DEF || node.kind() == STATIC_DEF {\n-            let analyzer = SourceAnalyzer::new(&db, Source::new(file_id.into(), &node), None);\n-            if analyzed.insert(analyzer.analyzed_declaration()) {\n-                infer_def(analyzer.inference_result(), analyzer.body_source_map());\n-            }\n+    let module = db.module_for_file(file_id);\n+    let crate_def_map = db.crate_def_map(module.krate);\n+\n+    let mut defs: Vec<DefWithBodyId> = Vec::new();\n+    visit_module(&db, &crate_def_map, module.module_id, &mut |it| defs.push(it));\n+    defs.sort_by_key(|def| match def {\n+        DefWithBodyId::FunctionId(it) => {\n+            it.lookup(&db).ast_id.to_node(&db).syntax().text_range().start()\n+        }\n+        DefWithBodyId::ConstId(it) => {\n+            it.lookup(&db).ast_id.to_node(&db).syntax().text_range().start()\n+        }\n+        DefWithBodyId::StaticId(it) => {\n+            it.lookup(&db).ast_id.to_node(&db).syntax().text_range().start()\n         }\n+    });\n+    for def in defs {\n+        let (_body, source_map) = db.body_with_source_map(def);\n+        let infer = db.infer(def);\n+        infer_def(infer, source_map);\n     }\n \n     acc.truncate(acc.trim_end().len());\n     acc\n }\n \n+fn visit_module(\n+    db: &TestDB,\n+    crate_def_map: &CrateDefMap,\n+    module_id: LocalModuleId,\n+    cb: &mut dyn FnMut(DefWithBodyId),\n+) {\n+    for decl in crate_def_map[module_id].scope.declarations() {\n+        match decl {\n+            ModuleDefId::FunctionId(it) => cb(it.into()),\n+            ModuleDefId::ConstId(it) => cb(it.into()),\n+            ModuleDefId::StaticId(it) => cb(it.into()),\n+            ModuleDefId::TraitId(it) => {\n+                let trait_data = db.trait_data(it);\n+                for &(_, item) in trait_data.items.iter() {\n+                    match item {\n+                        AssocItemId::FunctionId(it) => cb(it.into()),\n+                        AssocItemId::ConstId(it) => cb(it.into()),\n+                        AssocItemId::TypeAliasId(_) => (),\n+                    }\n+                }\n+            }\n+            ModuleDefId::ModuleId(it) => visit_module(db, crate_def_map, it.module_id, cb),\n+            _ => (),\n+        }\n+    }\n+    for &impl_id in crate_def_map[module_id].impls.iter() {\n+        let impl_data = db.impl_data(impl_id);\n+        for &item in impl_data.items.iter() {\n+            match item {\n+                AssocItemId::FunctionId(it) => cb(it.into()),\n+                AssocItemId::ConstId(it) => cb(it.into()),\n+                AssocItemId::TypeAliasId(_) => (),\n+            }\n+        }\n+    }\n+}\n+\n fn ellipsize(mut text: String, max_len: usize) -> String {\n     if text.len() <= max_len {\n         return text;\n@@ -4783,10 +4841,12 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n     \",\n     );\n     {\n-        let file = db.parse(pos.file_id).ok().unwrap();\n-        let node = file.syntax().token_at_offset(pos.offset).right_biased().unwrap().parent();\n         let events = db.log_executed(|| {\n-            SourceAnalyzer::new(&db, Source::new(pos.file_id.into(), &node), None);\n+            let module = db.module_for_file(pos.file_id);\n+            let crate_def_map = db.crate_def_map(module.krate);\n+            visit_module(&db, &crate_def_map, module.module_id, &mut |def| {\n+                db.infer(def);\n+            });\n         });\n         assert!(format!(\"{:?}\", events).contains(\"infer\"))\n     }\n@@ -4803,10 +4863,12 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n     db.query_mut(ra_db::FileTextQuery).set(pos.file_id, Arc::new(new_text));\n \n     {\n-        let file = db.parse(pos.file_id).ok().unwrap();\n-        let node = file.syntax().token_at_offset(pos.offset).right_biased().unwrap().parent();\n         let events = db.log_executed(|| {\n-            SourceAnalyzer::new(&db, Source::new(pos.file_id.into(), &node), None);\n+            let module = db.module_for_file(pos.file_id);\n+            let crate_def_map = db.crate_def_map(module.krate);\n+            visit_module(&db, &crate_def_map, module.module_id, &mut |def| {\n+                db.infer(def);\n+            });\n         });\n         assert!(!format!(\"{:?}\", events).contains(\"infer\"), \"{:#?}\", events)\n     }", "previous_filename": "crates/ra_hir/src/ty/tests.rs"}, {"sha": "1530fcc6378a55e895dae1793df0edf6bf933b25", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "previous_filename": "crates/ra_hir/src/ty/tests/coercion.rs"}, {"sha": "c202f545a3799852f93f47dbc1be8872a08b796c", "filename": "crates/ra_hir_ty/src/tests/never_type.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "previous_filename": "crates/ra_hir/src/ty/tests/never_type.rs"}, {"sha": "76189a60b14e1e4381f5500681ebd978d7aa5820", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "previous_filename": "crates/ra_hir/src/ty/traits.rs"}, {"sha": "810e8c21a67a8d50d1f563984dc3ecbef15b0279", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "renamed", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -11,8 +11,8 @@ use chalk_rust_ir::{AssociatedTyDatum, AssociatedTyValue, ImplDatum, StructDatum\n use ra_db::CrateId;\n \n use hir_def::{\n-    lang_item::LangItemTarget, resolver::HasResolver, AssocItemId, AstItemDef, ContainerId,\n-    GenericDefId, ImplId, Lookup, TraitId, TypeAliasId,\n+    expr::Expr, lang_item::LangItemTarget, resolver::HasResolver, AssocItemId, AstItemDef,\n+    ContainerId, GenericDefId, ImplId, Lookup, TraitId, TypeAliasId,\n };\n use hir_expand::name;\n \n@@ -21,8 +21,8 @@ use ra_db::salsa::{InternId, InternKey};\n use super::{AssocTyValue, Canonical, ChalkContext, Impl, Obligation};\n use crate::{\n     db::HirDatabase,\n-    ty::display::HirDisplay,\n-    ty::{ApplicationTy, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk},\n+    display::HirDisplay,\n+    {ApplicationTy, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk},\n };\n \n /// This represents a trait whose name we could not resolve.\n@@ -723,7 +723,7 @@ fn closure_fn_trait_impl_datum(\n     let _output = db.trait_data(fn_once_trait).associated_type_by_name(&name::OUTPUT_TYPE)?;\n \n     let num_args: u16 = match &db.body(data.def.into())[data.expr] {\n-        crate::expr::Expr::Lambda { args, .. } => args.len() as u16,\n+        Expr::Lambda { args, .. } => args.len() as u16,\n         _ => {\n             log::warn!(\"closure for closure type {:?} not found\", data);\n             0\n@@ -823,7 +823,7 @@ fn closure_fn_trait_output_assoc_ty_value(\n     let impl_id = Impl::ClosureFnTraitImpl(data.clone()).to_chalk(db);\n \n     let num_args: u16 = match &db.body(data.def.into())[data.expr] {\n-        crate::expr::Expr::Lambda { args, .. } => args.len() as u16,\n+        Expr::Lambda { args, .. } => args.len() as u16,\n         _ => {\n             log::warn!(\"closure for closure type {:?} not found\", data);\n             0\n@@ -869,38 +869,38 @@ fn id_to_chalk<T: InternKey>(salsa_id: T) -> chalk_ir::RawId {\n     chalk_ir::RawId { index: salsa_id.as_intern_id().as_u32() }\n }\n \n-impl From<chalk_ir::StructId> for crate::ty::TypeCtorId {\n+impl From<chalk_ir::StructId> for crate::TypeCtorId {\n     fn from(struct_id: chalk_ir::StructId) -> Self {\n         id_from_chalk(struct_id.0)\n     }\n }\n \n-impl From<crate::ty::TypeCtorId> for chalk_ir::StructId {\n-    fn from(type_ctor_id: crate::ty::TypeCtorId) -> Self {\n+impl From<crate::TypeCtorId> for chalk_ir::StructId {\n+    fn from(type_ctor_id: crate::TypeCtorId) -> Self {\n         chalk_ir::StructId(id_to_chalk(type_ctor_id))\n     }\n }\n \n-impl From<chalk_ir::ImplId> for crate::ty::traits::GlobalImplId {\n+impl From<chalk_ir::ImplId> for crate::traits::GlobalImplId {\n     fn from(impl_id: chalk_ir::ImplId) -> Self {\n         id_from_chalk(impl_id.0)\n     }\n }\n \n-impl From<crate::ty::traits::GlobalImplId> for chalk_ir::ImplId {\n-    fn from(impl_id: crate::ty::traits::GlobalImplId) -> Self {\n+impl From<crate::traits::GlobalImplId> for chalk_ir::ImplId {\n+    fn from(impl_id: crate::traits::GlobalImplId) -> Self {\n         chalk_ir::ImplId(id_to_chalk(impl_id))\n     }\n }\n \n-impl From<chalk_rust_ir::AssociatedTyValueId> for crate::ty::traits::AssocTyValueId {\n+impl From<chalk_rust_ir::AssociatedTyValueId> for crate::traits::AssocTyValueId {\n     fn from(id: chalk_rust_ir::AssociatedTyValueId) -> Self {\n         id_from_chalk(id.0)\n     }\n }\n \n-impl From<crate::ty::traits::AssocTyValueId> for chalk_rust_ir::AssociatedTyValueId {\n-    fn from(assoc_ty_value_id: crate::ty::traits::AssocTyValueId) -> Self {\n+impl From<crate::traits::AssocTyValueId> for chalk_rust_ir::AssociatedTyValueId {\n+    fn from(assoc_ty_value_id: crate::traits::AssocTyValueId) -> Self {\n         chalk_rust_ir::AssociatedTyValueId(id_to_chalk(assoc_ty_value_id))\n     }\n }", "previous_filename": "crates/ra_hir/src/ty/traits/chalk.rs"}, {"sha": "e4ba890efa16f0a8245315645df043244de3ab53", "filename": "crates/ra_hir_ty/src/utils.rs", "status": "renamed", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Futils.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -73,3 +73,12 @@ pub(super) fn variant_data(db: &impl DefDatabase, var: VariantId) -> Arc<Variant\n         }\n     }\n }\n+\n+/// Helper for mutating `Arc<[T]>` (i.e. `Arc::make_mut` for Arc slices).\n+/// The underlying values are cloned if there are other strong references.\n+pub(crate) fn make_mut_slice<T: Clone>(a: &mut Arc<[T]>) -> &mut [T] {\n+    if Arc::get_mut(a).is_none() {\n+        *a = a.iter().cloned().collect();\n+    }\n+    Arc::get_mut(a).unwrap()\n+}", "previous_filename": "crates/ra_hir/src/ty/utils.rs"}, {"sha": "aa480e399b2fbdec548dc8840c3e7a5bd308aa58", "filename": "crates/ra_ide_api/src/impls.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir::{ApplicationTy, FromSource, ImplBlock, Ty, TypeCtor};\n+use hir::{FromSource, ImplBlock};\n use ra_db::SourceDatabase;\n use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n \n@@ -61,7 +61,7 @@ fn impls_for_def(\n     Some(\n         impls\n             .into_iter()\n-            .filter(|impl_block| is_equal_for_find_impls(&ty, &impl_block.target_ty(db)))\n+            .filter(|impl_block| ty.is_equal_for_find_impls(&impl_block.target_ty(db)))\n             .map(|imp| imp.to_nav(db))\n             .collect(),\n     )\n@@ -82,19 +82,6 @@ fn impls_for_trait(\n     Some(impls.into_iter().map(|imp| imp.to_nav(db)).collect())\n }\n \n-fn is_equal_for_find_impls(original_ty: &Ty, impl_ty: &Ty) -> bool {\n-    match (original_ty, impl_ty) {\n-        (Ty::Apply(a_original_ty), Ty::Apply(ApplicationTy { ctor, parameters })) => match ctor {\n-            TypeCtor::Ref(..) => match parameters.as_single() {\n-                Ty::Apply(a_ty) => a_original_ty.ctor == a_ty.ctor,\n-                _ => false,\n-            },\n-            _ => a_original_ty.ctor == *ctor,\n-        },\n-        _ => false,\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use crate::mock_analysis::analysis_and_position;"}, {"sha": "e0653b460f2663b2bc88966069d5c072d2953b0e", "filename": "xtask/tests/tidy-tests/docs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a87579500a2c35597071efd0ad6983927f0c1815/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87579500a2c35597071efd0ad6983927f0c1815/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs?ref=a87579500a2c35597071efd0ad6983927f0c1815", "patch": "@@ -83,6 +83,7 @@ fn no_docs_comments() {\n         \"ra_syntax\",\n         \"ra_text_edit\",\n         \"ra_tt\",\n+        \"ra_hir_ty\",\n     ];\n \n     let mut has_fixmes = whitelist.iter().map(|it| (*it, false)).collect::<HashMap<&str, bool>>();"}]}