{"sha": "287d69ddacba3f5945b70695fb721b2f055d3ee6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4N2Q2OWRkYWNiYTNmNTk0NWI3MDY5NWZiNzIxYjJmMDU1ZDNlZTY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-06-25T08:29:51Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-06-25T08:32:59Z"}, "message": "Sketch out gc glue.", "tree": {"sha": "435f6ee0d9fe239ea0b500c7d90182d4a4c98859", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/435f6ee0d9fe239ea0b500c7d90182d4a4c98859"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/287d69ddacba3f5945b70695fb721b2f055d3ee6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/287d69ddacba3f5945b70695fb721b2f055d3ee6", "html_url": "https://github.com/rust-lang/rust/commit/287d69ddacba3f5945b70695fb721b2f055d3ee6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/287d69ddacba3f5945b70695fb721b2f055d3ee6/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85a701c8f668fc03e6340682956e7ca7d9cf54bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/85a701c8f668fc03e6340682956e7ca7d9cf54bc", "html_url": "https://github.com/rust-lang/rust/commit/85a701c8f668fc03e6340682956e7ca7d9cf54bc"}], "stats": {"total": 123, "additions": 111, "deletions": 12}, "files": [{"sha": "47d08169720667b1a0af4ef550b32f28fab6c8cd", "filename": "src/boot/be/x86.ml", "status": "modified", "additions": 111, "deletions": 12, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/287d69ddacba3f5945b70695fb721b2f055d3ee6/src%2Fboot%2Fbe%2Fx86.ml", "raw_url": "https://github.com/rust-lang/rust/raw/287d69ddacba3f5945b70695fb721b2f055d3ee6/src%2Fboot%2Fbe%2Fx86.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fx86.ml?ref=287d69ddacba3f5945b70695fb721b2f055d3ee6", "patch": "@@ -738,10 +738,10 @@ let emit_native_call_in_thunk\n           mov (word_at (h edx)) (ro eax)\n ;;\n \n-let unwind_glue\n+\n+let crawl_stack_calling_glue\n     (e:Il.emitter)\n-    (nabi:nabi)\n-    (exit_task_fixup:fixup)\n+    (glue_field:int)\n     : unit =\n \n   let fp_n = word_n (Il.Hreg ebp) in\n@@ -753,7 +753,6 @@ let unwind_glue\n   let add x y = emit (Il.binary Il.ADD (rc x) (ro x) (ro y)) in\n   let codefix fix = Il.CodePtr (Il.ImmPtr (fix, Il.CodeTy)) in\n   let mark fix = Il.emit_full e (Some fix) [] Il.Dead in\n-  let glue_field = Abi.frame_glue_fns_field_drop in\n \n   let repeat_jmp_fix = new_fixup \"repeat jump\" in\n   let skip_jmp_fix = new_fixup \"skip jump\" in\n@@ -764,6 +763,8 @@ let unwind_glue\n       (rc esp)\n       (c (edx_n Abi.task_field_rust_sp));\n \n+    push (ro ebp);                      (* save ebp at entry            *)\n+\n     mark repeat_jmp_fix;\n \n     mov (rc esi) (c (fp_n (-1)));       (* esi <- crate ptr             *)\n@@ -776,14 +777,14 @@ let unwind_glue\n     add edx esi;                        (* add crate ptr to disp.       *)\n     mov\n       (rc ecx)\n-      (c (edx_n glue_field));           (* ecx <- drop glue             *)\n+      (c (edx_n glue_field));           (* ecx <-  glue                 *)\n     emit (Il.cmp (ro ecx) (immi 0L));\n \n     emit\n       (Il.jmp Il.JE\n          (codefix skip_jmp_fix));       (* if glue-fn is nonzero        *)\n     add ecx esi;                        (* add crate ptr to disp.       *)\n-    push (ro ebp);                      (* frame-to-drop                *)\n+    push (ro ebp);                      (* frame-arg                    *)\n     push (c task_ptr);                  (* form usual call to glue      *)\n     push (immi 0L);                     (* outptr                       *)\n     emit (Il.call (rc eax)\n@@ -803,15 +804,113 @@ let unwind_glue\n \n     (* exit path. *)\n     mark exit_jmp_fix;\n+    pop (rc ebp);                       (* restore ebp                    *)\n+;;\n \n-    let callee =\n-      Abi.load_fixup_codeptr\n-        e (h eax) exit_task_fixup false nabi.nabi_indirect\n-    in\n-      emit_c_call\n-        e (rc eax) (h edx) (h ecx) nabi false callee [| (c task_ptr) |];\n+let gc_glue\n+    (e:Il.emitter)\n+    : unit =\n+  (* Mark pass. *)\n+  crawl_stack_calling_glue e Abi.frame_glue_fns_field_mark;\n+\n+  (* Sweep pass. *)\n+  let emit = Il.emit e in\n+  let mov dst src = emit (Il.umov dst src) in\n+  let push x = emit (Il.Push x) in\n+  let pop x = emit (Il.Pop x) in\n+  let band x y = emit (Il.binary Il.AND x (c x) y) in\n+  let add x y = emit (Il.binary Il.ADD (rc x) (ro x) (ro y)) in\n+  let edx_n = word_n (Il.Hreg edx) in\n+  let ecx_n = word_n (Il.Hreg ecx) in\n+  let codefix fix = Il.CodePtr (Il.ImmPtr (fix, Il.CodeTy)) in\n+  let mark fix = Il.emit_full e (Some fix) [] Il.Dead in\n+\n+  let repeat_jmp_fix = new_fixup \"repeat jump\" in\n+  let skip_jmp_fix = new_fixup \"skip jump\" in\n+  let exit_jmp_fix = new_fixup \"exit jump\" in\n+\n+    mov (rc edx) (c task_ptr);\n+    mov (rc edx) (c (edx_n Abi.task_field_gc_alloc_chain));\n+    mark repeat_jmp_fix;\n+    emit (Il.cmp (ro edx) (immi 0L));\n+    emit (Il.jmp Il.JE\n+            (codefix exit_jmp_fix));            (* if nonzero             *)\n+    mov (rc ecx)                                (* Load GC ctrl word      *)\n+      (c (edx_n Abi.exterior_gc_slot_field_ctrl));\n+\n+    band                                        (* Clear in-memory mark.  *)\n+      (edx_n Abi.exterior_gc_slot_field_ctrl)\n+      (immi 0xfffffffffffffffeL);\n+    band (rc ecx) (immi 1L);                    (* Check in-reg mark.     *)\n+    emit (Il.cmp (ro edx) (immi 0L));\n+    emit\n+      (Il.jmp Il.JNE\n+         (codefix skip_jmp_fix));               (* if unmarked (garbage)  *)\n+\n+    (* NB: ecx is a type descriptor now. *)\n+    mov (rc eax)                                (* Load glue tydesc-off.  *)\n+      (c (ecx_n Abi.tydesc_field_free_glue));\n+    add eax ecx;                                (* Add to tydesc*         *)\n+\n+    (* FIXME: this path is all wrong, for three reasons.\n+     *\n+     * First, it needs to unlink the values that it frees from the gc\n+     * chain. Currently it's going to leave dead pointers on it.\n+     *\n+     * Second, the *normal* gc-drop path actually has to do that as well;\n+     * it's not, and that's a problem.\n+     *\n+     * Third, it actually needs to walk in two full passes over the chain:\n+     *\n+     *    - In pass #1, it goes through and disposes of all mutable exterior\n+     *      slots in each record. That is, rc-- the referent, and then\n+     *      null-out.  If the rc-- gets to zero, that just means the mutable\n+     *      is part of the garbage set currently being collected. But a\n+     *      mutable may be live-and-outside; this detaches the garbage set\n+     *      from the non-garbage set within the mutable heap.\n+     *\n+     *    - In pass #2, run the normal free-glue. This winds up doing the\n+     *      immutables only, since all the mutables were nulled out in pass\n+     *      #1. This is where you do the unlinking from the double-linked\n+     *      chain mentioned above.\n+     *\n+     * So .. this will still take a little more doing.\n+     *\n+     *)\n+\n+    push (ro edx);                      (* gc_val to drop                 *)\n+    push (c task_ptr);                  (* form usual call to glue        *)\n+    push (immi 0L);                     (* outptr                         *)\n+    emit (Il.call (rc eax)\n+            (reg_codeptr (h eax)));     (* call glue_fn, trashing eax.    *)\n+    pop (rc eax);\n+    pop (rc eax);\n+    pop (rc eax);\n+\n+    mark skip_jmp_fix;\n+    mov (rc ecx)                                (* Advance down chain     *)\n+      (c (edx_n Abi.exterior_gc_slot_field_next));\n+    emit (Il.jmp Il.JMP\n+            (codefix repeat_jmp_fix));          (* loop                   *)\n+    mark exit_jmp_fix;\n+;;\n+\n+\n+let unwind_glue\n+    (e:Il.emitter)\n+    (nabi:nabi)\n+    (exit_task_fixup:fixup)\n+    : unit =\n+  crawl_stack_calling_glue e Abi.frame_glue_fns_field_drop;\n+  let callee =\n+    Abi.load_fixup_codeptr\n+      e (h eax) exit_task_fixup false nabi.nabi_indirect\n+  in\n+    emit_c_call\n+      e (rc eax) (h edx) (h ecx) nabi false callee [| (c task_ptr) |];\n ;;\n \n+\n (* Puts result in eax; clobbers ecx, edx in the process. *)\n let rec calculate_sz (e:Il.emitter) (size:size) : unit =\n   let emit = Il.emit e in"}]}