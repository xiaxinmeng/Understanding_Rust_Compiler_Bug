{"sha": "36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2Zjk1YWIzZmE2NTRkNjRjMWJhNzdiYzQ5NGM1Y2VjZjI5ZDcyMjk=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-12-01T15:08:58Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-12-27T18:20:28Z"}, "message": "Fallout in other crates.", "tree": {"sha": "ffda1c1b42d43797de2277b73295b369b5a89b61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffda1c1b42d43797de2277b73295b369b5a89b61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "html_url": "https://github.com/rust-lang/rust/commit/36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c737c0702134888a88cb847c5286c600a78ffea9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c737c0702134888a88cb847c5286c600a78ffea9", "html_url": "https://github.com/rust-lang/rust/commit/c737c0702134888a88cb847c5286c600a78ffea9"}], "stats": {"total": 474, "additions": 248, "deletions": 226}, "files": [{"sha": "fea01db4d54cce91dabf70f1e8ed3bc727e24c80", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -983,7 +983,7 @@ impl UnreachablePub {\n         cx: &LateContext<'_, '_>,\n         what: &str,\n         id: hir::HirId,\n-        vis: &hir::Visibility,\n+        vis: &hir::Visibility<'_>,\n         span: Span,\n         exportable: bool,\n     ) {\n@@ -1065,7 +1065,7 @@ declare_lint_pass!(\n );\n \n impl TypeAliasBounds {\n-    fn is_type_variable_assoc(qpath: &hir::QPath) -> bool {\n+    fn is_type_variable_assoc(qpath: &hir::QPath<'_>) -> bool {\n         match *qpath {\n             hir::QPath::TypeRelative(ref ty, _) => {\n                 // If this is a type variable, we found a `T::Assoc`.\n@@ -1081,7 +1081,7 @@ impl TypeAliasBounds {\n         }\n     }\n \n-    fn suggest_changing_assoc_types(ty: &hir::Ty, err: &mut DiagnosticBuilder<'_>) {\n+    fn suggest_changing_assoc_types(ty: &hir::Ty<'_>, err: &mut DiagnosticBuilder<'_>) {\n         // Access to associates types should use `<T as Bound>::Assoc`, which does not need a\n         // bound.  Let's see if this type does that.\n \n@@ -1095,7 +1095,7 @@ impl TypeAliasBounds {\n                 intravisit::NestedVisitorMap::None\n             }\n \n-            fn visit_qpath(&mut self, qpath: &'v hir::QPath, id: hir::HirId, span: Span) {\n+            fn visit_qpath(&mut self, qpath: &'v hir::QPath<'v>, id: hir::HirId, span: Span) {\n                 if TypeAliasBounds::is_type_variable_assoc(qpath) {\n                     self.err.span_help(\n                         span,\n@@ -1533,7 +1533,7 @@ impl ExplicitOutlivesRequirements {\n \n     fn collect_outlived_lifetimes<'tcx>(\n         &self,\n-        param: &'tcx hir::GenericParam,\n+        param: &'tcx hir::GenericParam<'tcx>,\n         tcx: TyCtxt<'tcx>,\n         inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n         ty_generics: &'tcx ty::Generics,\n@@ -1554,7 +1554,7 @@ impl ExplicitOutlivesRequirements {\n     fn collect_outlives_bound_spans<'tcx>(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        bounds: &hir::GenericBounds,\n+        bounds: &hir::GenericBounds<'_>,\n         inferred_outlives: &[ty::Region<'tcx>],\n         infer_static: bool,\n     ) -> Vec<(usize, Span)> {\n@@ -1585,7 +1585,7 @@ impl ExplicitOutlivesRequirements {\n     fn consolidate_outlives_bound_spans(\n         &self,\n         lo: Span,\n-        bounds: &hir::GenericBounds,\n+        bounds: &hir::GenericBounds<'_>,\n         bound_spans: Vec<(usize, Span)>,\n     ) -> Vec<Span> {\n         if bounds.is_empty() {"}, {"sha": "12e6730e8919e90f481a5be7a740987a73105c46", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -293,7 +293,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         }\n     }\n \n-    fn check_generic_param(&mut self, cx: &LateContext<'_, '_>, param: &hir::GenericParam) {\n+    fn check_generic_param(&mut self, cx: &LateContext<'_, '_>, param: &hir::GenericParam<'_>) {\n         if let GenericParamKind::Lifetime { .. } = param.kind {\n             self.check_snake_case(cx, \"lifetime\", &param.name.ident());\n         }\n@@ -303,7 +303,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         &mut self,\n         cx: &LateContext<'_, '_>,\n         fk: FnKind<'_>,\n-        _: &hir::FnDecl,\n+        _: &hir::FnDecl<'_>,\n         _: &hir::Body<'_>,\n         _: Span,\n         id: hir::HirId,\n@@ -425,7 +425,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n         }\n     }\n \n-    fn check_generic_param(&mut self, cx: &LateContext<'_, '_>, param: &hir::GenericParam) {\n+    fn check_generic_param(&mut self, cx: &LateContext<'_, '_>, param: &hir::GenericParam<'_>) {\n         if let GenericParamKind::Const { .. } = param.kind {\n             NonUpperCaseGlobals::check_upper_case(cx, \"const parameter\", &param.name.ident());\n         }"}, {"sha": "65018194af2d31e2a2b79774248fdb1e1536df66", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -963,12 +963,12 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_foreign_fn(&mut self, id: hir::HirId, decl: &hir::FnDecl) {\n+    fn check_foreign_fn(&mut self, id: hir::HirId, decl: &hir::FnDecl<'_>) {\n         let def_id = self.cx.tcx.hir().local_def_id(id);\n         let sig = self.cx.tcx.fn_sig(def_id);\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n \n-        for (input_ty, input_hir) in sig.inputs().iter().zip(&decl.inputs) {\n+        for (input_ty, input_hir) in sig.inputs().iter().zip(decl.inputs) {\n             self.check_type_for_ffi_and_report_errors(input_hir.span, input_ty, false);\n         }\n "}, {"sha": "0fe53011d4f461daa28a0ee7ddc17d97991ed136", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -664,7 +664,7 @@ impl EncodeContext<'tcx> {\n         id: hir::HirId,\n         md: &hir::Mod<'_>,\n         attrs: &[ast::Attribute],\n-        vis: &hir::Visibility,\n+        vis: &hir::Visibility<'_>,\n     ) {\n         let tcx = self.tcx;\n         let def_id = tcx.hir().local_def_id(id);\n@@ -1547,7 +1547,7 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n         let def_id = self.tcx.hir().local_def_id(ni.hir_id);\n         self.encode_info_for_foreign_item(def_id, ni);\n     }\n-    fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n+    fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n         intravisit::walk_generics(self, generics);\n         self.encode_info_for_generics(generics);\n     }\n@@ -1568,7 +1568,7 @@ impl EncodeContext<'tcx> {\n         }\n     }\n \n-    fn encode_info_for_generics(&mut self, generics: &hir::Generics) {\n+    fn encode_info_for_generics(&mut self, generics: &hir::Generics<'tcx>) {\n         for param in &generics.params {\n             let def_id = self.tcx.hir().local_def_id(param.hir_id);\n             match param.kind {"}, {"sha": "37e2b68692d5e7030f70aa42c79a7a924074b905", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -410,7 +410,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> Option<RegionName> {\n         let mir_hir_id = infcx.tcx.hir().as_local_hir_id(mir_def_id)?;\n         let fn_decl = infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n-        let argument_hir_ty: &hir::Ty = fn_decl.inputs.get(argument_index)?;\n+        let argument_hir_ty: &hir::Ty<'_> = fn_decl.inputs.get(argument_index)?;\n         match argument_hir_ty.kind {\n             // This indicates a variable with no type annotation, like\n             // `|x|`... in that case, we can't highlight the type but\n@@ -504,10 +504,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n-        argument_hir_ty: &hir::Ty,\n+        argument_hir_ty: &hir::Ty<'_>,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n-        let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty)> =\n+        let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty<'_>)> =\n             &mut vec![(argument_ty, argument_hir_ty)];\n \n         while let Some((ty, hir_ty)) = search_stack.pop() {\n@@ -570,7 +570,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // just worry about trying to match up the rustc type\n                 // with the HIR types:\n                 (ty::Tuple(elem_tys), hir::TyKind::Tup(elem_hir_tys)) => {\n-                    search_stack.extend(elem_tys.iter().map(|k| k.expect_ty()).zip(elem_hir_tys));\n+                    search_stack.extend(elem_tys.iter().map(|k| k.expect_ty()).zip(*elem_hir_tys));\n                 }\n \n                 (ty::Slice(elem_ty), hir::TyKind::Slice(elem_hir_ty))\n@@ -600,9 +600,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         substs: SubstsRef<'tcx>,\n         needle_fr: RegionVid,\n-        last_segment: &'hir hir::PathSegment,\n+        last_segment: &'hir hir::PathSegment<'hir>,\n         renctx: &mut RegionErrorNamingCtx,\n-        search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty)>,\n+        search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty<'hir>)>,\n     ) -> Option<RegionName> {\n         // Did the user give explicit arguments? (e.g., `Foo<..>`)\n         let args = last_segment.args.as_ref()?;\n@@ -647,8 +647,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         substs: SubstsRef<'tcx>,\n         needle_fr: RegionVid,\n-        args: &'hir hir::GenericArgs,\n-        search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty)>,\n+        args: &'hir hir::GenericArgs<'hir>,\n+        search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty<'hir>)>,\n     ) -> Option<&'hir hir::Lifetime> {\n         for (kind, hir_arg) in substs.iter().zip(&args.args) {\n             match (kind.unpack(), hir_arg) {"}, {"sha": "8cf49edd0a2760eecd951a8ab62ab5e699b737c3", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -255,7 +255,7 @@ fn const_not_var(\n     err: &mut DiagnosticBuilder<'_>,\n     tcx: TyCtxt<'_>,\n     pat: &Pat<'_>,\n-    path: &hir::Path,\n+    path: &hir::Path<'_>,\n ) {\n     let descr = path.res.descr();\n     err.span_label("}, {"sha": "c782eda917fe2a03f5c3682d7f6cfa436d472c16", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -732,7 +732,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     /// Takes a HIR Path. If the path is a constant, evaluates it and feeds\n     /// it to `const_to_pat`. Any other path (like enum variants without fields)\n     /// is converted to the corresponding pattern via `lower_variant_or_leaf`.\n-    fn lower_path(&mut self, qpath: &hir::QPath, id: hir::HirId, span: Span) -> Pat<'tcx> {\n+    fn lower_path(&mut self, qpath: &hir::QPath<'_>, id: hir::HirId, span: Span) -> Pat<'tcx> {\n         let ty = self.tables.node_type(id);\n         let res = self.tables.qpath_res(qpath, id);\n         let is_associated_const = match res {"}, {"sha": "39647b587f56ed77b2f4c6528f6efe94ad1dfa92", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -77,7 +77,7 @@ fn mir_keys(tcx: TyCtxt<'_>, krate: CrateNum) -> &DefIdSet {\n             &mut self,\n             v: &'tcx hir::VariantData<'tcx>,\n             _: ast::Name,\n-            _: &'tcx hir::Generics,\n+            _: &'tcx hir::Generics<'tcx>,\n             _: hir::HirId,\n             _: Span,\n         ) {"}, {"sha": "09d6d2a1be2510c904dc8634a0c7fb9762d07af9", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -229,7 +229,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         &mut self,\n         def: &'tcx hir::VariantData<'tcx>,\n         _: ast::Name,\n-        _: &hir::Generics,\n+        _: &hir::Generics<'_>,\n         _: hir::HirId,\n         _: syntax_pos::Span,\n     ) {\n@@ -295,12 +295,12 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         self.in_pat = false;\n     }\n \n-    fn visit_path(&mut self, path: &'tcx hir::Path, _: hir::HirId) {\n+    fn visit_path(&mut self, path: &'tcx hir::Path<'tcx>, _: hir::HirId) {\n         self.handle_res(path.res);\n         intravisit::walk_path(self, path);\n     }\n \n-    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n         match ty.kind {\n             TyKind::Def(item_id, _) => {\n                 let item = self.tcx.hir().expect_item(item_id.id);\n@@ -619,7 +619,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n     fn visit_variant(\n         &mut self,\n         variant: &'tcx hir::Variant<'tcx>,\n-        g: &'tcx hir::Generics,\n+        g: &'tcx hir::Generics<'tcx>,\n         id: hir::HirId,\n     ) {\n         if self.should_warn_about_variant(&variant) {"}, {"sha": "49ec8d01d952df899417c4e0d5a3b6f28152885e", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -160,15 +160,15 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_expr(self, ex)\n     }\n \n-    fn visit_ty(&mut self, t: &'v hir::Ty) {\n+    fn visit_ty(&mut self, t: &'v hir::Ty<'v>) {\n         self.record(\"Ty\", Id::Node(t.hir_id), t);\n         hir_visit::walk_ty(self, t)\n     }\n \n     fn visit_fn(\n         &mut self,\n         fk: hir_visit::FnKind<'v>,\n-        fd: &'v hir::FnDecl,\n+        fd: &'v hir::FnDecl<'v>,\n         b: hir::BodyId,\n         s: Span,\n         id: hir::HirId,\n@@ -177,7 +177,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_fn(self, fk, fd, b, s, id)\n     }\n \n-    fn visit_where_predicate(&mut self, predicate: &'v hir::WherePredicate) {\n+    fn visit_where_predicate(&mut self, predicate: &'v hir::WherePredicate<'v>) {\n         self.record(\"WherePredicate\", Id::None, predicate);\n         hir_visit::walk_where_predicate(self, predicate)\n     }\n@@ -192,7 +192,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_impl_item(self, ii)\n     }\n \n-    fn visit_param_bound(&mut self, bounds: &'v hir::GenericBound) {\n+    fn visit_param_bound(&mut self, bounds: &'v hir::GenericBound<'v>) {\n         self.record(\"GenericBound\", Id::None, bounds);\n         hir_visit::walk_param_bound(self, bounds)\n     }\n@@ -205,7 +205,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     fn visit_variant(\n         &mut self,\n         v: &'v hir::Variant<'v>,\n-        g: &'v hir::Generics,\n+        g: &'v hir::Generics<'v>,\n         item_id: hir::HirId,\n     ) {\n         self.record(\"Variant\", Id::None, v);\n@@ -217,22 +217,22 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_lifetime(self, lifetime)\n     }\n \n-    fn visit_qpath(&mut self, qpath: &'v hir::QPath, id: hir::HirId, span: Span) {\n+    fn visit_qpath(&mut self, qpath: &'v hir::QPath<'v>, id: hir::HirId, span: Span) {\n         self.record(\"QPath\", Id::None, qpath);\n         hir_visit::walk_qpath(self, qpath, id, span)\n     }\n \n-    fn visit_path(&mut self, path: &'v hir::Path, _id: hir::HirId) {\n+    fn visit_path(&mut self, path: &'v hir::Path<'v>, _id: hir::HirId) {\n         self.record(\"Path\", Id::None, path);\n         hir_visit::walk_path(self, path)\n     }\n \n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v hir::PathSegment) {\n+    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v hir::PathSegment<'v>) {\n         self.record(\"PathSegment\", Id::None, path_segment);\n         hir_visit::walk_path_segment(self, path_span, path_segment)\n     }\n \n-    fn visit_assoc_type_binding(&mut self, type_binding: &'v hir::TypeBinding) {\n+    fn visit_assoc_type_binding(&mut self, type_binding: &'v hir::TypeBinding<'v>) {\n         self.record(\"TypeBinding\", Id::Node(type_binding.hir_id), type_binding);\n         hir_visit::walk_assoc_type_binding(self, type_binding)\n     }"}, {"sha": "4f7db91dcdaa6605b13528005ad66b4fe5f3df81", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -162,7 +162,7 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n     fn visit_fn(\n         &mut self,\n         fk: FnKind<'tcx>,\n-        fd: &'tcx hir::FnDecl,\n+        fd: &'tcx hir::FnDecl<'tcx>,\n         b: hir::BodyId,\n         s: Span,\n         id: HirId,\n@@ -351,7 +351,7 @@ impl IrMaps<'tcx> {\n fn visit_fn<'tcx>(\n     ir: &mut IrMaps<'tcx>,\n     fk: FnKind<'tcx>,\n-    decl: &'tcx hir::FnDecl,\n+    decl: &'tcx hir::FnDecl<'tcx>,\n     body_id: hir::BodyId,\n     sp: Span,\n     id: hir::HirId,\n@@ -1285,7 +1285,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn access_path(\n         &mut self,\n         hir_id: HirId,\n-        path: &hir::Path,\n+        path: &hir::Path<'_>,\n         succ: LiveNode,\n         acc: u32,\n     ) -> LiveNode {"}, {"sha": "c00f5752e1be07650dea0bf96e923713d311a90b", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -378,7 +378,7 @@ impl Visitor<'tcx> for PubRestrictedVisitor<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::All(&self.tcx.hir())\n     }\n-    fn visit_vis(&mut self, vis: &'tcx hir::Visibility) {\n+    fn visit_vis(&mut self, vis: &'tcx hir::Visibility<'tcx>) {\n         self.has_pub_restricted = self.has_pub_restricted || vis.node.is_pub_restricted();\n     }\n }\n@@ -644,7 +644,10 @@ impl EmbargoVisitor<'tcx> {\n     ///\n     /// FIXME: This solution won't work with glob imports and doesn't respect\n     /// namespaces. See <https://github.com/rust-lang/rust/pull/57922#discussion_r251234202>.\n-    fn update_visibility_of_intermediate_use_statements(&mut self, segments: &[hir::PathSegment]) {\n+    fn update_visibility_of_intermediate_use_statements(\n+        &mut self,\n+        segments: &[hir::PathSegment<'_>],\n+    ) {\n         if let Some([module, segment]) = segments.rchunks_exact(2).next() {\n             if let Some(item) = module\n                 .res\n@@ -1199,7 +1202,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         self.in_body = orig_in_body;\n     }\n \n-    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty) {\n+    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty<'tcx>) {\n         self.span = hir_ty.span;\n         if self.in_body {\n             // Types in bodies.\n@@ -1218,7 +1221,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_ty(self, hir_ty);\n     }\n \n-    fn visit_trait_ref(&mut self, trait_ref: &'tcx hir::TraitRef) {\n+    fn visit_trait_ref(&mut self, trait_ref: &'tcx hir::TraitRef<'tcx>) {\n         self.span = trait_ref.path.span;\n         if !self.in_body {\n             // Avoid calling `hir_trait_to_predicates` in bodies, it will ICE.\n@@ -1282,7 +1285,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     // we prohibit access to private statics from other crates, this allows to give\n     // more code internal visibility at link time. (Access to private functions\n     // is already prohibited by type privacy for function types.)\n-    fn visit_qpath(&mut self, qpath: &'tcx hir::QPath, id: hir::HirId, span: Span) {\n+    fn visit_qpath(&mut self, qpath: &'tcx hir::QPath<'tcx>, id: hir::HirId, span: Span) {\n         let def = match self.tables.qpath_res(qpath, id) {\n             Res::Def(kind, def_id) => Some((kind, def_id)),\n             _ => None,\n@@ -1397,7 +1400,7 @@ struct ObsoleteCheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n }\n \n impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n-    fn path_is_private_type(&self, path: &hir::Path) -> bool {\n+    fn path_is_private_type(&self, path: &hir::Path<'_>) -> bool {\n         let did = match path.res {\n             Res::PrimTy(..) | Res::SelfTy(..) | Res::Err => return false,\n             res => res.def_id(),\n@@ -1423,15 +1426,15 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         self.access_levels.is_public(trait_id)\n     }\n \n-    fn check_generic_bound(&mut self, bound: &hir::GenericBound) {\n+    fn check_generic_bound(&mut self, bound: &hir::GenericBound<'_>) {\n         if let hir::GenericBound::Trait(ref trait_ref, _) = *bound {\n             if self.path_is_private_type(&trait_ref.trait_ref.path) {\n                 self.old_error_set.insert(trait_ref.trait_ref.hir_ref_id);\n             }\n         }\n     }\n \n-    fn item_is_public(&self, id: &hir::HirId, vis: &hir::Visibility) -> bool {\n+    fn item_is_public(&self, id: &hir::HirId, vis: &hir::Visibility<'_>) -> bool {\n         self.access_levels.is_reachable(*id) || vis.node.is_pub()\n     }\n }\n@@ -1441,7 +1444,7 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for ObsoleteCheckTypeForPrivatenessVisitor<'a\n         NestedVisitorMap::None\n     }\n \n-    fn visit_ty(&mut self, ty: &hir::Ty) {\n+    fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n         if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = ty.kind {\n             if self.inner.path_is_private_type(path) {\n                 self.contains_private = true;\n@@ -1649,13 +1652,13 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         intravisit::walk_item(self, item);\n     }\n \n-    fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n+    fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n         for param in &generics.params {\n-            for bound in &param.bounds {\n+            for bound in param.bounds {\n                 self.check_generic_bound(bound);\n             }\n         }\n-        for predicate in &generics.where_clause.predicates {\n+        for predicate in generics.where_clause.predicates {\n             match predicate {\n                 hir::WherePredicate::BoundPredicate(bound_pred) => {\n                     for bound in bound_pred.bounds.iter() {\n@@ -1676,7 +1679,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n+    fn visit_ty(&mut self, t: &'tcx hir::Ty<'tcx>) {\n         if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = t.kind {\n             if self.path_is_private_type(path) {\n                 self.old_error_set.insert(t.hir_id);\n@@ -1688,7 +1691,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn visit_variant(\n         &mut self,\n         v: &'tcx hir::Variant<'tcx>,\n-        g: &'tcx hir::Generics,\n+        g: &'tcx hir::Generics<'tcx>,\n         item_id: hir::HirId,\n     ) {\n         if self.access_levels.is_reachable(v.id) {"}, {"sha": "f3ac159a3aa2aad59507b821ba916218970ec5d3", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 52, "deletions": 42, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -85,7 +85,7 @@ pub trait AstConv<'tcx> {\n         &self,\n         span: Span,\n         item_def_id: DefId,\n-        item_segment: &hir::PathSegment,\n+        item_segment: &hir::PathSegment<'_>,\n         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Ty<'tcx>;\n \n@@ -114,7 +114,7 @@ struct ConvertedBinding<'a, 'tcx> {\n \n enum ConvertedBindingKind<'a, 'tcx> {\n     Equality(Ty<'tcx>),\n-    Constraint(&'a [hir::GenericBound]),\n+    Constraint(&'a [hir::GenericBound<'a>]),\n }\n \n #[derive(PartialEq)]\n@@ -186,7 +186,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         span: Span,\n         def_id: DefId,\n-        item_segment: &hir::PathSegment,\n+        item_segment: &hir::PathSegment<'_>,\n     ) -> SubstsRef<'tcx> {\n         let (substs, assoc_bindings, _) = self.create_substs_for_ast_path(\n             span,\n@@ -203,7 +203,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     }\n \n     /// Report error if there is an explicit type parameter when using `impl Trait`.\n-    fn check_impl_trait(tcx: TyCtxt<'_>, seg: &hir::PathSegment, generics: &ty::Generics) -> bool {\n+    fn check_impl_trait(\n+        tcx: TyCtxt<'_>,\n+        seg: &hir::PathSegment<'_>,\n+        generics: &ty::Generics,\n+    ) -> bool {\n         let explicit = !seg.infer_args;\n         let impl_trait = generics.params.iter().any(|param| match param.kind {\n             ty::GenericParamDefKind::Type {\n@@ -248,14 +252,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         tcx: TyCtxt<'_>,\n         span: Span,\n         def: &ty::Generics,\n-        seg: &hir::PathSegment,\n+        seg: &hir::PathSegment<'_>,\n         is_method_call: bool,\n     ) -> bool {\n-        let empty_args = P(hir::GenericArgs {\n-            args: HirVec::new(),\n-            bindings: HirVec::new(),\n-            parenthesized: false,\n-        });\n+        let empty_args =\n+            P(hir::GenericArgs { args: HirVec::new(), bindings: &[], parenthesized: false });\n         let suppress_mismatch = Self::check_impl_trait(tcx, seg, &def);\n         Self::check_generic_arg_count(\n             tcx,\n@@ -275,7 +276,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         tcx: TyCtxt<'_>,\n         span: Span,\n         def: &ty::Generics,\n-        args: &hir::GenericArgs,\n+        args: &hir::GenericArgs<'_>,\n         position: GenericArgPosition,\n         has_self: bool,\n         infer_args: bool,\n@@ -471,8 +472,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         parent_substs: &[subst::GenericArg<'tcx>],\n         has_self: bool,\n         self_ty: Option<Ty<'tcx>>,\n-        args_for_def_id: impl Fn(DefId) -> (Option<&'b GenericArgs>, bool),\n-        provided_kind: impl Fn(&GenericParamDef, &GenericArg) -> subst::GenericArg<'tcx>,\n+        args_for_def_id: impl Fn(DefId) -> (Option<&'b GenericArgs<'b>>, bool),\n+        provided_kind: impl Fn(&GenericParamDef, &GenericArg<'_>) -> subst::GenericArg<'tcx>,\n         mut inferred_kind: impl FnMut(\n             Option<&[subst::GenericArg<'tcx>]>,\n             &GenericParamDef,\n@@ -619,7 +620,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         span: Span,\n         def_id: DefId,\n         parent_substs: &[subst::GenericArg<'tcx>],\n-        generic_args: &'a hir::GenericArgs,\n+        generic_args: &'a hir::GenericArgs<'_>,\n         infer_args: bool,\n         self_ty: Option<Ty<'tcx>>,\n     ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Option<Vec<Span>>) {\n@@ -794,7 +795,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         tcx: TyCtxt<'tcx>,\n         span: Span,\n         item_def_id: DefId,\n-        item_segment: &hir::PathSegment,\n+        item_segment: &hir::PathSegment<'_>,\n         parent_substs: SubstsRef<'tcx>,\n     ) -> SubstsRef<'tcx> {\n         if tcx.generics_of(item_def_id).params.is_empty() {\n@@ -895,7 +896,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// are disallowed. Otherwise, they are pushed onto the vector given.\n     pub fn instantiate_mono_trait_ref(\n         &self,\n-        trait_ref: &hir::TraitRef,\n+        trait_ref: &hir::TraitRef<'_>,\n         self_ty: Ty<'tcx>,\n     ) -> ty::TraitRef<'tcx> {\n         self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n@@ -911,7 +912,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// The given trait-ref must actually be a trait.\n     pub(super) fn instantiate_poly_trait_ref_inner(\n         &self,\n-        trait_ref: &hir::TraitRef,\n+        trait_ref: &hir::TraitRef<'_>,\n         span: Span,\n         self_ty: Ty<'tcx>,\n         bounds: &mut Bounds<'tcx>,\n@@ -986,7 +987,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// however.\n     pub fn instantiate_poly_trait_ref(\n         &self,\n-        poly_trait_ref: &hir::PolyTraitRef,\n+        poly_trait_ref: &hir::PolyTraitRef<'_>,\n         self_ty: Ty<'tcx>,\n         bounds: &mut Bounds<'tcx>,\n     ) -> Option<Vec<Span>> {\n@@ -1004,7 +1005,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         span: Span,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n-        trait_segment: &hir::PathSegment,\n+        trait_segment: &hir::PathSegment<'_>,\n     ) -> ty::TraitRef<'tcx> {\n         let (substs, assoc_bindings, _) =\n             self.create_substs_for_ast_trait_ref(span, trait_def_id, self_ty, trait_segment);\n@@ -1018,7 +1019,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         span: Span,\n         trait_def_id: DefId,\n-        trait_segment: &'a hir::PathSegment,\n+        trait_segment: &'a hir::PathSegment<'a>,\n     ) {\n         let trait_def = self.tcx().trait_def(trait_def_id);\n \n@@ -1076,7 +1077,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         span: Span,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n-        trait_segment: &'a hir::PathSegment,\n+        trait_segment: &'a hir::PathSegment<'a>,\n     ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Option<Vec<Span>>) {\n         debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\", trait_segment);\n \n@@ -1104,7 +1105,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     }\n \n     // Returns `true` if a bounds list includes `?Sized`.\n-    pub fn is_unsized(&self, ast_bounds: &[hir::GenericBound], span: Span) -> bool {\n+    pub fn is_unsized(&self, ast_bounds: &[hir::GenericBound<'_>], span: Span) -> bool {\n         let tcx = self.tcx();\n \n         // Try to find an unbound in bounds.\n@@ -1168,7 +1169,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn add_bounds(\n         &self,\n         param_ty: Ty<'tcx>,\n-        ast_bounds: &[hir::GenericBound],\n+        ast_bounds: &[hir::GenericBound<'_>],\n         bounds: &mut Bounds<'tcx>,\n     ) {\n         let mut trait_bounds = Vec::new();\n@@ -1212,7 +1213,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     pub fn compute_bounds(\n         &self,\n         param_ty: Ty<'tcx>,\n-        ast_bounds: &[hir::GenericBound],\n+        ast_bounds: &[hir::GenericBound<'_>],\n         sized_by_default: SizedByDefault,\n         span: Span,\n     ) -> Bounds<'tcx> {\n@@ -1388,15 +1389,20 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         Ok(())\n     }\n \n-    fn ast_path_to_ty(&self, span: Span, did: DefId, item_segment: &hir::PathSegment) -> Ty<'tcx> {\n+    fn ast_path_to_ty(\n+        &self,\n+        span: Span,\n+        did: DefId,\n+        item_segment: &hir::PathSegment<'_>,\n+    ) -> Ty<'tcx> {\n         let substs = self.ast_path_substs_for_ty(span, did, item_segment);\n         self.normalize_ty(span, self.tcx().at(span).type_of(did).subst(self.tcx(), substs))\n     }\n \n     fn conv_object_ty_poly_trait_ref(\n         &self,\n         span: Span,\n-        trait_bounds: &[hir::PolyTraitRef],\n+        trait_bounds: &[hir::PolyTraitRef<'_>],\n         lifetime: &hir::Lifetime,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx();\n@@ -1617,7 +1623,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         associated_types: FxHashMap<Span, BTreeSet<DefId>>,\n         potential_assoc_types: Vec<Span>,\n-        trait_bounds: &[hir::PolyTraitRef],\n+        trait_bounds: &[hir::PolyTraitRef<'_>],\n     ) {\n         if !associated_types.values().any(|v| v.len() > 0) {\n             return;\n@@ -2046,7 +2052,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         span: Span,\n         qself_ty: Ty<'tcx>,\n         qself_res: Res,\n-        assoc_segment: &hir::PathSegment,\n+        assoc_segment: &hir::PathSegment<'_>,\n         permit_variants: bool,\n     ) -> Result<(Ty<'tcx>, DefKind, DefId), ErrorReported> {\n         let tcx = self.tcx();\n@@ -2204,8 +2210,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         span: Span,\n         opt_self_ty: Option<Ty<'tcx>>,\n         item_def_id: DefId,\n-        trait_segment: &hir::PathSegment,\n-        item_segment: &hir::PathSegment,\n+        trait_segment: &hir::PathSegment<'_>,\n+        item_segment: &hir::PathSegment<'_>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx();\n \n@@ -2265,7 +2271,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self.normalize_ty(span, tcx.mk_projection(item_def_id, item_substs))\n     }\n \n-    pub fn prohibit_generics<'a, T: IntoIterator<Item = &'a hir::PathSegment>>(\n+    pub fn prohibit_generics<'a, T: IntoIterator<Item = &'a hir::PathSegment<'a>>>(\n         &self,\n         segments: T,\n     ) -> bool {\n@@ -2311,7 +2317,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     break;\n                 }\n             }\n-            for binding in &segment.generic_args().bindings {\n+            for binding in segment.generic_args().bindings {\n                 has_err = true;\n                 Self::prohibit_assoc_ty_binding(self.tcx(), binding.span);\n                 break;\n@@ -2333,7 +2339,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     // FIXME(eddyb, varkor) handle type paths here too, not just value ones.\n     pub fn def_ids_for_value_path_segments(\n         &self,\n-        segments: &[hir::PathSegment],\n+        segments: &[hir::PathSegment<'_>],\n         self_ty: Option<Ty<'tcx>>,\n         kind: DefKind,\n         def_id: DefId,\n@@ -2461,7 +2467,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     pub fn res_to_ty(\n         &self,\n         opt_self_ty: Option<Ty<'tcx>>,\n-        path: &hir::Path,\n+        path: &hir::Path<'_>,\n         permit_variants: bool,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx();\n@@ -2510,7 +2516,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             Res::Def(DefKind::TyParam, def_id) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(&path.segments);\n+                self.prohibit_generics(path.segments);\n \n                 let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n                 let item_id = tcx.hir().get_parent_node(hir_id);\n@@ -2522,13 +2528,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             Res::SelfTy(Some(_), None) => {\n                 // `Self` in trait or type alias.\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(&path.segments);\n+                self.prohibit_generics(path.segments);\n                 tcx.types.self_param\n             }\n             Res::SelfTy(_, Some(def_id)) => {\n                 // `Self` in impl (we know the concrete type).\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(&path.segments);\n+                self.prohibit_generics(path.segments);\n                 // Try to evaluate any array length constants.\n                 self.normalize_ty(span, tcx.at(span).type_of(def_id))\n             }\n@@ -2545,7 +2551,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             Res::PrimTy(prim_ty) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(&path.segments);\n+                self.prohibit_generics(path.segments);\n                 match prim_ty {\n                     hir::Bool => tcx.types.bool,\n                     hir::Char => tcx.types.char,\n@@ -2565,7 +2571,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n     /// Parses the programmer's textual representation of a type into our\n     /// internal notion of a type.\n-    pub fn ast_ty_to_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n+    pub fn ast_ty_to_ty(&self, ast_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n         debug!(\"ast_ty_to_ty(id={:?}, ast_ty={:?} ty_ty={:?})\", ast_ty.hir_id, ast_ty, ast_ty.kind);\n \n         let tcx = self.tcx();\n@@ -2698,7 +2704,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         tcx.mk_const(const_)\n     }\n \n-    pub fn impl_trait_ty_to_ty(&self, def_id: DefId, lifetimes: &[hir::GenericArg]) -> Ty<'tcx> {\n+    pub fn impl_trait_ty_to_ty(\n+        &self,\n+        def_id: DefId,\n+        lifetimes: &[hir::GenericArg<'_>],\n+    ) -> Ty<'tcx> {\n         debug!(\"impl_trait_ty_to_ty(def_id={:?}, lifetimes={:?})\", def_id, lifetimes);\n         let tcx = self.tcx();\n \n@@ -2733,7 +2743,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         ty\n     }\n \n-    pub fn ty_of_arg(&self, ty: &hir::Ty, expected_ty: Option<Ty<'tcx>>) -> Ty<'tcx> {\n+    pub fn ty_of_arg(&self, ty: &hir::Ty<'_>, expected_ty: Option<Ty<'tcx>>) -> Ty<'tcx> {\n         match ty.kind {\n             hir::TyKind::Infer if expected_ty.is_some() => {\n                 self.record_ty(ty.hir_id, expected_ty.unwrap(), ty.span);\n@@ -2747,7 +2757,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         unsafety: hir::Unsafety,\n         abi: abi::Abi,\n-        decl: &hir::FnDecl,\n+        decl: &hir::FnDecl<'_>,\n     ) -> ty::PolyFnSig<'tcx> {\n         debug!(\"ty_of_fn\");\n "}, {"sha": "a94a6929450e615b41ac80f179105767cdd199bf", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -37,7 +37,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &hir::Expr<'_>,\n         _capture: hir::CaptureBy,\n-        decl: &'tcx hir::FnDecl,\n+        decl: &'tcx hir::FnDecl<'tcx>,\n         body_id: hir::BodyId,\n         gen: Option<hir::Movability>,\n         expected: Expectation<'tcx>,\n@@ -59,7 +59,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &hir::Expr<'_>,\n         opt_kind: Option<ty::ClosureKind>,\n-        decl: &'tcx hir::FnDecl,\n+        decl: &'tcx hir::FnDecl<'tcx>,\n         body: &'tcx hir::Body<'tcx>,\n         gen: Option<hir::Movability>,\n         expected_sig: Option<ExpectedSig<'tcx>>,\n@@ -282,7 +282,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn sig_of_closure(\n         &self,\n         expr_def_id: DefId,\n-        decl: &hir::FnDecl,\n+        decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n         expected_sig: Option<ExpectedSig<'tcx>>,\n     ) -> ClosureSignatures<'tcx> {\n@@ -298,7 +298,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn sig_of_closure_no_expectation(\n         &self,\n         expr_def_id: DefId,\n-        decl: &hir::FnDecl,\n+        decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n     ) -> ClosureSignatures<'tcx> {\n         debug!(\"sig_of_closure_no_expectation()\");\n@@ -358,7 +358,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn sig_of_closure_with_expectation(\n         &self,\n         expr_def_id: DefId,\n-        decl: &hir::FnDecl,\n+        decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n         expected_sig: ExpectedSig<'tcx>,\n     ) -> ClosureSignatures<'tcx> {\n@@ -413,7 +413,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn sig_of_closure_with_mismatched_number_of_arguments(\n         &self,\n         expr_def_id: DefId,\n-        decl: &hir::FnDecl,\n+        decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n         expected_sig: ExpectedSig<'tcx>,\n     ) -> ClosureSignatures<'tcx> {\n@@ -446,7 +446,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_supplied_sig_against_expectation(\n         &self,\n         expr_def_id: DefId,\n-        decl: &hir::FnDecl,\n+        decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n         expected_sigs: &ClosureSignatures<'tcx>,\n     ) -> InferResult<'tcx, ()> {\n@@ -535,7 +535,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn supplied_sig_of_closure(\n         &self,\n         expr_def_id: DefId,\n-        decl: &hir::FnDecl,\n+        decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n     ) -> ty::PolyFnSig<'tcx> {\n         let astconv: &dyn AstConv<'_> = self;\n@@ -687,7 +687,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Converts the types that the user supplied, in case that doing\n     /// so should yield an error, but returns back a signature where\n     /// all parameters are of type `TyErr`.\n-    fn error_sig_of_closure(&self, decl: &hir::FnDecl) -> ty::PolyFnSig<'tcx> {\n+    fn error_sig_of_closure(&self, decl: &hir::FnDecl<'_>) -> ty::PolyFnSig<'tcx> {\n         let astconv: &dyn AstConv<'_> = self;\n \n         let supplied_arguments = decl.inputs.iter().map(|a| {"}, {"sha": "79bad233fd10dbe9341040388d52de2ee4d37a03", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -873,12 +873,12 @@ fn compare_synthetic_generics<'tcx>(\n                         let impl_m = tcx.hir().as_local_hir_id(impl_m.def_id)?;\n                         let impl_m = tcx.hir().impl_item(hir::ImplItemId { hir_id: impl_m });\n                         let input_tys = match impl_m.kind {\n-                            hir::ImplItemKind::Method(ref sig, _) => &sig.decl.inputs,\n+                            hir::ImplItemKind::Method(ref sig, _) => sig.decl.inputs,\n                             _ => unreachable!(),\n                         };\n                         struct Visitor(Option<Span>, hir::def_id::DefId);\n                         impl<'v> hir::intravisit::Visitor<'v> for Visitor {\n-                            fn visit_ty(&mut self, ty: &'v hir::Ty) {\n+                            fn visit_ty(&mut self, ty: &'v hir::Ty<'v>) {\n                                 hir::intravisit::walk_ty(self, ty);\n                                 if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) =\n                                     ty.kind"}, {"sha": "6c4b4ee179806f7dd2c5620979ba08f4a9159cdf", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -469,7 +469,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_expr_path(&self, qpath: &hir::QPath, expr: &'tcx hir::Expr<'tcx>) -> Ty<'tcx> {\n+    fn check_expr_path(&self, qpath: &hir::QPath<'_>, expr: &'tcx hir::Expr<'tcx>) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let (res, opt_ty, segs) = self.resolve_ty_and_res_ufcs(qpath, expr.hir_id, expr.span);\n         let ty = match res {\n@@ -853,7 +853,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_method_call(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n-        segment: &hir::PathSegment,\n+        segment: &hir::PathSegment<'_>,\n         span: Span,\n         args: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n@@ -893,7 +893,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn report_extended_method_error(\n         &self,\n-        segment: &hir::PathSegment,\n+        segment: &hir::PathSegment<'_>,\n         span: Span,\n         args: &'tcx [hir::Expr<'tcx>],\n         rcvr_t: Ty<'tcx>,\n@@ -941,7 +941,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_expr_cast(\n         &self,\n         e: &'tcx hir::Expr<'tcx>,\n-        t: &'tcx hir::Ty,\n+        t: &'tcx hir::Ty<'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         // Find the type of `e`. Supply hints based on the type we are casting to,\n@@ -1087,7 +1087,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &hir::Expr<'_>,\n         expected: Expectation<'tcx>,\n-        qpath: &QPath,\n+        qpath: &QPath<'_>,\n         fields: &'tcx [hir::Field<'tcx>],\n         base_expr: &'tcx Option<&'tcx hir::Expr<'tcx>>,\n     ) -> Ty<'tcx> {"}, {"sha": "4b5963af283a0e53ce530c2d207b320bc26b9c75", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         call_expr: &'tcx hir::Expr<'tcx>,\n         unadjusted_self_ty: Ty<'tcx>,\n         pick: probe::Pick<'tcx>,\n-        segment: &hir::PathSegment,\n+        segment: &hir::PathSegment<'_>,\n     ) -> ConfirmResult<'tcx> {\n         debug!(\n             \"confirm(unadjusted_self_ty={:?}, pick={:?}, generic_args={:?})\",\n@@ -69,7 +69,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         &mut self,\n         unadjusted_self_ty: Ty<'tcx>,\n         pick: probe::Pick<'tcx>,\n-        segment: &hir::PathSegment,\n+        segment: &hir::PathSegment<'_>,\n     ) -> ConfirmResult<'tcx> {\n         // Adjust the self expression the user provided and obtain the adjusted type.\n         let self_ty = self.adjust_self_ty(unadjusted_self_ty, &pick);\n@@ -292,7 +292,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n     fn instantiate_method_substs(\n         &mut self,\n         pick: &probe::Pick<'tcx>,\n-        seg: &hir::PathSegment,\n+        seg: &hir::PathSegment<'_>,\n         parent_substs: SubstsRef<'tcx>,\n     ) -> SubstsRef<'tcx> {\n         // Determine the values for the generic parameters of the method."}, {"sha": "877b1a3cc24c65589d0bad1eabd0322d93ebf751", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -178,7 +178,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn lookup_method(\n         &self,\n         self_ty: Ty<'tcx>,\n-        segment: &hir::PathSegment,\n+        segment: &hir::PathSegment<'_>,\n         span: Span,\n         call_expr: &'tcx hir::Expr<'tcx>,\n         self_expr: &'tcx hir::Expr<'tcx>,"}, {"sha": "d98a11b879ec64c1add9109253b7ea8347695e32", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -953,7 +953,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n #[derive(Copy, Clone)]\n pub enum SelfSource<'a> {\n-    QPath(&'a hir::Ty),\n+    QPath(&'a hir::Ty<'a>),\n     MethodCall(&'a hir::Expr<'a> /* rcvr */),\n }\n "}, {"sha": "c6c3ada49e312e267269c1bed4d6cb5279359d3e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -784,7 +784,7 @@ fn adt_destructor(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::Destructor> {\n fn primary_body_of(\n     tcx: TyCtxt<'_>,\n     id: hir::HirId,\n-) -> Option<(hir::BodyId, Option<&hir::Ty>, Option<&hir::FnHeader>, Option<&hir::FnDecl>)> {\n+) -> Option<(hir::BodyId, Option<&hir::Ty<'_>>, Option<&hir::FnHeader>, Option<&hir::FnDecl<'_>>)> {\n     match tcx.hir().get(id) {\n         Node::Item(item) => match item.kind {\n             hir::ItemKind::Const(ref ty, body) | hir::ItemKind::Static(ref ty, _, body) => {\n@@ -1196,7 +1196,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n     fn visit_fn(\n         &mut self,\n         _: intravisit::FnKind<'tcx>,\n-        _: &'tcx hir::FnDecl,\n+        _: &'tcx hir::FnDecl<'tcx>,\n         _: hir::BodyId,\n         _: Span,\n         _: hir::HirId,\n@@ -1228,7 +1228,7 @@ fn check_fn<'a, 'tcx>(\n     inherited: &'a Inherited<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     fn_sig: ty::FnSig<'tcx>,\n-    decl: &'tcx hir::FnDecl,\n+    decl: &'tcx hir::FnDecl<'tcx>,\n     fn_id: hir::HirId,\n     body: &'tcx hir::Body<'tcx>,\n     can_be_generator: Option<hir::Movability>,\n@@ -1902,7 +1902,7 @@ fn check_impl_items_against_trait<'tcx>(\n     full_impl_span: Span,\n     impl_id: DefId,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n-    impl_item_refs: &[hir::ImplItemRef],\n+    impl_item_refs: &[hir::ImplItemRef<'_>],\n ) {\n     let impl_span = tcx.sess.source_map().def_span(full_impl_span);\n \n@@ -2511,7 +2511,7 @@ pub fn check_enum<'tcx>(\n     check_transparent(tcx, sp, def_id);\n }\n \n-fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, span: Span, qpath: &QPath) {\n+fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, span: Span, qpath: &QPath<'_>) {\n     span_err!(\n         tcx.sess,\n         span,\n@@ -2600,7 +2600,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         &self,\n         span: Span,\n         item_def_id: DefId,\n-        item_segment: &hir::PathSegment,\n+        item_segment: &hir::PathSegment<'_>,\n         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Ty<'tcx> {\n         let (trait_ref, _) = self.replace_bound_vars_with_fresh_vars(\n@@ -3105,13 +3105,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn to_ty(&self, ast_t: &hir::Ty) -> Ty<'tcx> {\n+    pub fn to_ty(&self, ast_t: &hir::Ty<'_>) -> Ty<'tcx> {\n         let t = AstConv::ast_ty_to_ty(self, ast_t);\n         self.register_wf_obligation(t, ast_t.span, traits::MiscObligation);\n         t\n     }\n \n-    pub fn to_ty_saving_user_provided_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n+    pub fn to_ty_saving_user_provided_ty(&self, ast_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n         let ty = self.to_ty(ast_ty);\n         debug!(\"to_ty_saving_user_provided_ty: ty={:?}\", ty);\n \n@@ -4100,7 +4100,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn check_struct_path(\n         &self,\n-        qpath: &QPath,\n+        qpath: &QPath<'_>,\n         hir_id: hir::HirId,\n     ) -> Option<(&'tcx ty::VariantDef, Ty<'tcx>)> {\n         let path_span = match *qpath {\n@@ -4159,7 +4159,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // The newly resolved definition is written into `type_dependent_defs`.\n     fn finish_resolving_struct_path(\n         &self,\n-        qpath: &QPath,\n+        qpath: &QPath<'_>,\n         path_span: Span,\n         hir_id: hir::HirId,\n     ) -> (Res, Ty<'tcx>) {\n@@ -4194,10 +4194,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// resolution. The newly resolved definition is written into `type_dependent_defs`.\n     pub fn resolve_ty_and_res_ufcs<'b>(\n         &self,\n-        qpath: &'b QPath,\n+        qpath: &'b QPath<'b>,\n         hir_id: hir::HirId,\n         span: Span,\n-    ) -> (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment]) {\n+    ) -> (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment<'b>]) {\n         debug!(\"resolve_ty_and_res_ufcs: qpath={:?} hir_id={:?} span={:?}\", qpath, hir_id, span);\n         let (ty, qself, item_segment) = match *qpath {\n             QPath::Resolved(ref opt_qself, ref path) => {\n@@ -4545,13 +4545,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Given a function block's `HirId`, returns its `FnDecl` if it exists, or `None` otherwise.\n-    fn get_parent_fn_decl(&self, blk_id: hir::HirId) -> Option<(&'tcx hir::FnDecl, ast::Ident)> {\n+    fn get_parent_fn_decl(\n+        &self,\n+        blk_id: hir::HirId,\n+    ) -> Option<(&'tcx hir::FnDecl<'tcx>, ast::Ident)> {\n         let parent = self.tcx.hir().get(self.tcx.hir().get_parent_item(blk_id));\n         self.get_node_fn_decl(parent).map(|(fn_decl, ident, _)| (fn_decl, ident))\n     }\n \n     /// Given a function `Node`, return its `FnDecl` if it exists, or `None` otherwise.\n-    fn get_node_fn_decl(&self, node: Node<'tcx>) -> Option<(&'tcx hir::FnDecl, ast::Ident, bool)> {\n+    fn get_node_fn_decl(\n+        &self,\n+        node: Node<'tcx>,\n+    ) -> Option<(&'tcx hir::FnDecl<'tcx>, ast::Ident, bool)> {\n         match node {\n             Node::Item(&hir::Item { ident, kind: hir::ItemKind::Fn(ref sig, ..), .. }) => {\n                 // This is less than ideal, it will not suggest a return type span on any\n@@ -4575,7 +4581,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Given a `HirId`, return the `FnDecl` of the method it is enclosed by and whether a\n     /// suggestion can be made, `None` otherwise.\n-    pub fn get_fn_decl(&self, blk_id: hir::HirId) -> Option<(&'tcx hir::FnDecl, bool)> {\n+    pub fn get_fn_decl(&self, blk_id: hir::HirId) -> Option<(&'tcx hir::FnDecl<'tcx>, bool)> {\n         // Get enclosing Fn, if it is a function or a trait method, unless there's a `loop` or\n         // `while` before reaching it, as block tail returns are not available in them.\n         self.tcx.hir().get_return_block(blk_id).and_then(|blk_id| {\n@@ -4908,7 +4914,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn suggest_missing_return_type(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        fn_decl: &hir::FnDecl,\n+        fn_decl: &hir::FnDecl<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n         can_suggest: bool,\n@@ -5075,7 +5081,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // number of type parameters and type.\n     pub fn instantiate_value_path(\n         &self,\n-        segments: &[hir::PathSegment],\n+        segments: &[hir::PathSegment<'_>],\n         self_ty: Option<Ty<'tcx>>,\n         res: Res,\n         span: Span,"}, {"sha": "156126a748a2123664812c067e05239a1574d5b5", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -554,7 +554,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_struct(\n         &self,\n         pat: &'tcx Pat<'tcx>,\n-        qpath: &hir::QPath,\n+        qpath: &hir::QPath<'_>,\n         fields: &'tcx [hir::FieldPat<'tcx>],\n         etc: bool,\n         expected: Ty<'tcx>,\n@@ -587,8 +587,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_path(\n         &self,\n         pat: &Pat<'_>,\n-        path_resolution: (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment]),\n-        qpath: &hir::QPath,\n+        path_resolution: (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment<'b>]),\n+        qpath: &hir::QPath<'_>,\n         expected: Ty<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n@@ -622,7 +622,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_tuple_struct(\n         &self,\n         pat: &Pat<'_>,\n-        qpath: &hir::QPath,\n+        qpath: &hir::QPath<'_>,\n         subpats: &'tcx [&'tcx Pat<'tcx>],\n         ddpos: Option<usize>,\n         expected: Ty<'tcx>,\n@@ -724,7 +724,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         pat_span: Span,\n         res: Res,\n-        qpath: &hir::QPath,\n+        qpath: &hir::QPath<'_>,\n         subpats: &'tcx [&'tcx Pat<'tcx>],\n         fields: &'tcx [ty::FieldDef],\n         expected: Ty<'tcx>,"}, {"sha": "a42b666f11620cecab155cc55a6591c65abeb9b9", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -421,7 +421,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n     fn visit_fn(\n         &mut self,\n         fk: intravisit::FnKind<'tcx>,\n-        _: &'tcx hir::FnDecl,\n+        _: &'tcx hir::FnDecl<'tcx>,\n         body_id: hir::BodyId,\n         span: Span,\n         hir_id: hir::HirId,"}, {"sha": "fa829d1b990d01d6cb170ed1b6721f3e9989dbf7", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -391,8 +391,8 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: hir::HirId, ty_span: Span, allow_fo\n fn check_impl<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     item: &'tcx hir::Item<'tcx>,\n-    ast_self_ty: &hir::Ty,\n-    ast_trait_ref: &Option<hir::TraitRef>,\n+    ast_self_ty: &hir::Ty<'_>,\n+    ast_trait_ref: &Option<hir::TraitRef<'_>>,\n ) {\n     debug!(\"check_impl: {:?}\", item);\n \n@@ -961,7 +961,7 @@ fn receiver_is_implemented(\n fn check_variances_for_type_defn<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     item: &hir::Item<'tcx>,\n-    hir_generics: &hir::Generics,\n+    hir_generics: &hir::Generics<'_>,\n ) {\n     let item_def_id = tcx.hir().local_def_id(item.hir_id);\n     let ty = tcx.type_of(item_def_id);"}, {"sha": "2db6e24be052b3f61a8502ef6fe4b1cab2d20c22", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -310,7 +310,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n         self.write_ty_to_tables(l.hir_id, var_ty);\n     }\n \n-    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty) {\n+    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty<'tcx>) {\n         intravisit::walk_ty(self, hir_ty);\n         let ty = self.fcx.node_ty(hir_ty.hir_id);\n         let ty = self.resolve(&ty, &hir_ty.span);"}, {"sha": "eee292c55a8a4ab16110b52c2c0d3d7e5dc544ef", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -20,7 +20,7 @@ impl UnsafetyChecker<'tcx> {\n     fn check_unsafety_coherence(\n         &mut self,\n         item: &'v hir::Item<'v>,\n-        impl_generics: Option<&hir::Generics>,\n+        impl_generics: Option<&hir::Generics<'_>>,\n         unsafety: hir::Unsafety,\n         polarity: hir::ImplPolarity,\n     ) {"}, {"sha": "9604a9ade929e079057d1246bcc09af880c6230b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -116,7 +116,7 @@ impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n         intravisit::walk_item(self, item);\n     }\n \n-    fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n+    fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n         for param in &generics.params {\n             match param.kind {\n                 hir::GenericParamKind::Lifetime { .. } => {}\n@@ -173,7 +173,7 @@ impl ItemCtxt<'tcx> {\n         ItemCtxt { tcx, item_def_id }\n     }\n \n-    pub fn to_ty(&self, ast_ty: &'tcx hir::Ty) -> Ty<'tcx> {\n+    pub fn to_ty(&self, ast_ty: &'tcx hir::Ty<'tcx>) -> Ty<'tcx> {\n         AstConv::ast_ty_to_ty(self, ast_ty)\n     }\n }\n@@ -216,7 +216,7 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n         &self,\n         span: Span,\n         item_def_id: DefId,\n-        item_segment: &hir::PathSegment,\n+        item_segment: &hir::PathSegment<'_>,\n         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Ty<'tcx> {\n         if let Some(trait_ref) = poly_trait_ref.no_bound_vars() {\n@@ -343,7 +343,7 @@ impl ItemCtxt<'tcx> {\n     /// bounds for a type parameter `X` if `X::Foo` is used.\n     fn type_parameter_bounds_in_generics(\n         &self,\n-        ast_generics: &'tcx hir::Generics,\n+        ast_generics: &'tcx hir::Generics<'tcx>,\n         param_id: hir::HirId,\n         ty: Ty<'tcx>,\n         only_self_bounds: OnlySelfBounds,\n@@ -386,7 +386,7 @@ impl ItemCtxt<'tcx> {\n /// parameter with ID `param_id`. We use this so as to avoid running\n /// `ast_ty_to_ty`, because we want to avoid triggering an all-out\n /// conversion of the type to avoid inducing unnecessary cycles.\n-fn is_param(tcx: TyCtxt<'_>, ast_ty: &hir::Ty, param_id: hir::HirId) -> bool {\n+fn is_param(tcx: TyCtxt<'_>, ast_ty: &hir::Ty<'_>, param_id: hir::HirId) -> bool {\n     if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ast_ty.kind {\n         match path.res {\n             Res::SelfTy(Some(def_id), None) | Res::Def(DefKind::TyParam, def_id) => {\n@@ -803,7 +803,7 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n             NestedVisitorMap::None\n         }\n \n-        fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n+        fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n             if self.has_late_bound_regions.is_some() {\n                 return;\n             }\n@@ -819,7 +819,7 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n \n         fn visit_poly_trait_ref(\n             &mut self,\n-            tr: &'tcx hir::PolyTraitRef,\n+            tr: &'tcx hir::PolyTraitRef<'tcx>,\n             m: hir::TraitBoundModifier,\n         ) {\n             if self.has_late_bound_regions.is_some() {\n@@ -852,8 +852,8 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n \n     fn has_late_bound_regions<'tcx>(\n         tcx: TyCtxt<'tcx>,\n-        generics: &'tcx hir::Generics,\n-        decl: &'tcx hir::FnDecl,\n+        generics: &'tcx hir::Generics<'tcx>,\n+        decl: &'tcx hir::FnDecl<'tcx>,\n     ) -> Option<Span> {\n         let mut visitor = LateBoundRegionsDetector {\n             tcx,\n@@ -1699,7 +1699,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     }\n }\n \n-pub fn get_infer_ret_ty(output: &'_ hir::FunctionRetTy) -> Option<&hir::Ty> {\n+pub fn get_infer_ret_ty(output: &'hir hir::FunctionRetTy<'hir>) -> Option<&'hir hir::Ty<'hir>> {\n     if let hir::FunctionRetTy::Return(ref ty) = output {\n         if let hir::TyKind::Infer = ty.kind {\n             return Some(&**ty);\n@@ -1841,8 +1841,8 @@ fn impl_polarity(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ImplPolarity {\n /// `resolve_lifetime::early_bound_lifetimes`.\n fn early_bound_lifetimes_from_generics<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'tcx>,\n-    generics: &'a hir::Generics,\n-) -> impl Iterator<Item = &'a hir::GenericParam> + Captures<'tcx> {\n+    generics: &'a hir::Generics<'a>,\n+) -> impl Iterator<Item = &'a hir::GenericParam<'a>> + Captures<'tcx> {\n     generics.params.iter().filter(move |param| match param.kind {\n         GenericParamKind::Lifetime { .. } => !tcx.is_late_bound(param.hir_id),\n         _ => false,\n@@ -1947,7 +1947,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n-    const NO_GENERICS: &hir::Generics = &hir::Generics::empty();\n+    const NO_GENERICS: &hir::Generics<'_> = &hir::Generics::empty();\n \n     let mut predicates = UniquePredicates::new();\n \n@@ -2116,7 +2116,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n \n     // Add in the bounds that appear in the where-clause.\n     let where_clause = &ast_generics.where_clause;\n-    for predicate in &where_clause.predicates {\n+    for predicate in where_clause.predicates {\n         match predicate {\n             &hir::WherePredicate::BoundPredicate(ref bound_pred) => {\n                 let ty = icx.to_ty(&bound_pred.bounded_ty);\n@@ -2323,7 +2323,7 @@ fn associated_item_predicates(\n fn predicates_from_bound<'tcx>(\n     astconv: &dyn AstConv<'tcx>,\n     param_ty: Ty<'tcx>,\n-    bound: &'tcx hir::GenericBound,\n+    bound: &'tcx hir::GenericBound<'tcx>,\n ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n     match *bound {\n         hir::GenericBound::Trait(ref tr, hir::TraitBoundModifier::None) => {\n@@ -2343,7 +2343,7 @@ fn predicates_from_bound<'tcx>(\n fn compute_sig_of_foreign_fn_decl<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n-    decl: &'tcx hir::FnDecl,\n+    decl: &'tcx hir::FnDecl<'tcx>,\n     abi: abi::Abi,\n ) -> ty::PolyFnSig<'tcx> {\n     let unsafety = if abi == abi::Abi::RustIntrinsic {\n@@ -2359,7 +2359,7 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n         && abi != abi::Abi::PlatformIntrinsic\n         && !tcx.features().simd_ffi\n     {\n-        let check = |ast_ty: &hir::Ty, ty: Ty<'_>| {\n+        let check = |ast_ty: &hir::Ty<'_>, ty: Ty<'_>| {\n             if ty.is_simd() {\n                 tcx.sess\n                     .struct_span_err("}, {"sha": "55b2ad44467902cc1fac67a2869df1615100ebf2", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -89,7 +89,7 @@ impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n fn enforce_impl_params_are_constrained(\n     tcx: TyCtxt<'_>,\n     impl_def_id: DefId,\n-    impl_item_refs: &[hir::ImplItemRef],\n+    impl_item_refs: &[hir::ImplItemRef<'_>],\n ) {\n     // Every lifetime used in an associated type must be constrained.\n     let impl_self_ty = tcx.type_of(impl_def_id);\n@@ -201,7 +201,7 @@ fn report_unused_parameter(tcx: TyCtxt<'_>, span: Span, kind: &str, name: &str)\n }\n \n /// Enforce that we do not have two items in an impl with the same name.\n-fn enforce_impl_items_are_distinct(tcx: TyCtxt<'_>, impl_item_refs: &[hir::ImplItemRef]) {\n+fn enforce_impl_items_are_distinct(tcx: TyCtxt<'_>, impl_item_refs: &[hir::ImplItemRef<'_>]) {\n     let mut seen_type_items = FxHashMap::default();\n     let mut seen_value_items = FxHashMap::default();\n     for impl_item_ref in impl_item_refs {"}, {"sha": "d9b7e98ea75c35f0501fbd2d578c1083bcacfde2", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -119,7 +119,7 @@ pub struct TypeAndSubsts<'tcx> {\n     ty: Ty<'tcx>,\n }\n \n-fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_>, decl: &hir::FnDecl, abi: Abi, span: Span) {\n+fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_>, decl: &hir::FnDecl<'_>, abi: Abi, span: Span) {\n     if decl.c_variadic && !(abi == Abi::C || abi == Abi::Cdecl) {\n         let mut err = struct_span_err!(\n             tcx.sess,\n@@ -356,7 +356,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorReported> {\n \n /// A quasi-deprecated helper used in rustdoc and clippy to get\n /// the type from a HIR node.\n-pub fn hir_ty_to_ty<'tcx>(tcx: TyCtxt<'tcx>, hir_ty: &hir::Ty) -> Ty<'tcx> {\n+pub fn hir_ty_to_ty<'tcx>(tcx: TyCtxt<'tcx>, hir_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n     // In case there are any projections, etc., find the \"environment\"\n     // def-ID that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing.\n@@ -367,7 +367,10 @@ pub fn hir_ty_to_ty<'tcx>(tcx: TyCtxt<'tcx>, hir_ty: &hir::Ty) -> Ty<'tcx> {\n     astconv::AstConv::ast_ty_to_ty(&item_cx, hir_ty)\n }\n \n-pub fn hir_trait_to_predicates<'tcx>(tcx: TyCtxt<'tcx>, hir_trait: &hir::TraitRef) -> Bounds<'tcx> {\n+pub fn hir_trait_to_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    hir_trait: &hir::TraitRef<'_>,\n+) -> Bounds<'tcx> {\n     // In case there are any projections, etc., find the \"environment\"\n     // def-ID that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing."}, {"sha": "db17d23c910e29bdd16914f39bbebcabdecee24e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -306,7 +306,7 @@ impl Clean<Attributes> for [ast::Attribute] {\n     }\n }\n \n-impl Clean<GenericBound> for hir::GenericBound {\n+impl Clean<GenericBound> for hir::GenericBound<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n         match *self {\n             hir::GenericBound::Outlives(lt) => GenericBound::Outlives(lt.clean(cx)),\n@@ -406,7 +406,7 @@ impl Clean<Lifetime> for hir::Lifetime {\n     }\n }\n \n-impl Clean<Lifetime> for hir::GenericParam {\n+impl Clean<Lifetime> for hir::GenericParam<'_> {\n     fn clean(&self, _: &DocContext<'_>) -> Lifetime {\n         match self.kind {\n             hir::GenericParamKind::Lifetime { .. } => {\n@@ -469,7 +469,7 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n     }\n }\n \n-impl Clean<WherePredicate> for hir::WherePredicate {\n+impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> WherePredicate {\n         match *self {\n             hir::WherePredicate::BoundPredicate(ref wbp) => WherePredicate::BoundPredicate {\n@@ -615,7 +615,7 @@ impl Clean<GenericParamDef> for ty::GenericParamDef {\n     }\n }\n \n-impl Clean<GenericParamDef> for hir::GenericParam {\n+impl Clean<GenericParamDef> for hir::GenericParam<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n             hir::GenericParamKind::Lifetime { .. } => {\n@@ -657,12 +657,12 @@ impl Clean<GenericParamDef> for hir::GenericParam {\n     }\n }\n \n-impl Clean<Generics> for hir::Generics {\n+impl Clean<Generics> for hir::Generics<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Generics {\n         // Synthetic type-parameters are inserted after normal ones.\n         // In order for normal parameters to be able to refer to synthetic ones,\n         // scans them first.\n-        fn is_impl_trait(param: &hir::GenericParam) -> bool {\n+        fn is_impl_trait(param: &hir::GenericParam<'_>) -> bool {\n             match param.kind {\n                 hir::GenericParamKind::Type { synthetic, .. } => {\n                     synthetic == Some(hir::SyntheticTyParamKind::ImplTrait)\n@@ -892,7 +892,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n }\n \n impl<'a> Clean<Method>\n-    for (&'a hir::FnSig<'a>, &'a hir::Generics, hir::BodyId, Option<hir::Defaultness>)\n+    for (&'a hir::FnSig<'a>, &'a hir::Generics<'a>, hir::BodyId, Option<hir::Defaultness>)\n {\n     fn clean(&self, cx: &DocContext<'_>) -> Method {\n         let (generics, decl) =\n@@ -933,7 +933,7 @@ impl Clean<Item> for doctree::Function<'_> {\n     }\n }\n \n-impl<'a> Clean<Arguments> for (&'a [hir::Ty], &'a [ast::Ident]) {\n+impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], &'a [ast::Ident]) {\n     fn clean(&self, cx: &DocContext<'_>) -> Arguments {\n         Arguments {\n             values: self\n@@ -953,7 +953,7 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty], &'a [ast::Ident]) {\n     }\n }\n \n-impl<'a> Clean<Arguments> for (&'a [hir::Ty], hir::BodyId) {\n+impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], hir::BodyId) {\n     fn clean(&self, cx: &DocContext<'_>) -> Arguments {\n         let body = cx.tcx.hir().body(self.1);\n \n@@ -971,9 +971,9 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty], hir::BodyId) {\n     }\n }\n \n-impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl, A)\n+impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl<'a>, A)\n where\n-    (&'a [hir::Ty], A): Clean<Arguments>,\n+    (&'a [hir::Ty<'a>], A): Clean<Arguments>,\n {\n     fn clean(&self, cx: &DocContext<'_>) -> FnDecl {\n         FnDecl {\n@@ -1013,7 +1013,7 @@ impl<'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n     }\n }\n \n-impl Clean<FunctionRetTy> for hir::FunctionRetTy {\n+impl Clean<FunctionRetTy> for hir::FunctionRetTy<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> FunctionRetTy {\n         match *self {\n             hir::Return(ref typ) => Return(typ.clean(cx)),\n@@ -1075,13 +1075,13 @@ impl Clean<bool> for hir::IsAuto {\n     }\n }\n \n-impl Clean<Type> for hir::TraitRef {\n+impl Clean<Type> for hir::TraitRef<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Type {\n         resolve_type(cx, self.path.clean(cx), self.hir_ref_id)\n     }\n }\n \n-impl Clean<PolyTrait> for hir::PolyTraitRef {\n+impl Clean<PolyTrait> for hir::PolyTraitRef<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> PolyTrait {\n         PolyTrait {\n             trait_: self.trait_ref.clean(cx),\n@@ -1324,7 +1324,7 @@ impl Clean<Item> for ty::AssocItem {\n     }\n }\n \n-impl Clean<Type> for hir::Ty {\n+impl Clean<Type> for hir::Ty<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Type {\n         use rustc::hir::*;\n \n@@ -1480,7 +1480,7 @@ impl Clean<Type> for hir::Ty {\n                 if let ty::Projection(proj) = ty.kind {\n                     res = Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id);\n                 }\n-                let trait_path = hir::Path { span: self.span, res, segments: vec![].into() };\n+                let trait_path = hir::Path { span: self.span, res, segments: &[] };\n                 Type::QPath {\n                     name: segment.ident.name.clean(cx),\n                     self_type: box qself.clean(cx),\n@@ -1760,7 +1760,7 @@ impl Clean<Item> for ty::FieldDef {\n     }\n }\n \n-impl Clean<Visibility> for hir::Visibility {\n+impl Clean<Visibility> for hir::Visibility<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Visibility {\n         match self.node {\n             hir::VisibilityKind::Public => Visibility::Public,\n@@ -1937,7 +1937,7 @@ impl Clean<Span> for syntax_pos::Span {\n     }\n }\n \n-impl Clean<Path> for hir::Path {\n+impl Clean<Path> for hir::Path<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Path {\n         Path {\n             global: self.is_global(),\n@@ -1947,7 +1947,7 @@ impl Clean<Path> for hir::Path {\n     }\n }\n \n-impl Clean<GenericArgs> for hir::GenericArgs {\n+impl Clean<GenericArgs> for hir::GenericArgs<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> GenericArgs {\n         if self.parenthesized {\n             let output = self.bindings[0].ty().clean(cx);\n@@ -1979,7 +1979,7 @@ impl Clean<GenericArgs> for hir::GenericArgs {\n     }\n }\n \n-impl Clean<PathSegment> for hir::PathSegment {\n+impl Clean<PathSegment> for hir::PathSegment<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> PathSegment {\n         PathSegment { name: self.ident.name.clean(cx), args: self.generic_args().clean(cx) }\n     }\n@@ -2038,7 +2038,7 @@ impl Clean<Item> for doctree::OpaqueTy<'_> {\n     }\n }\n \n-impl Clean<BareFunctionDecl> for hir::BareFnTy {\n+impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> BareFunctionDecl {\n         let (generic_params, decl) = enter_impl_trait(cx, || {\n             (self.generic_params.clean(cx), (&*self.decl, &self.param_names[..]).clean(cx))\n@@ -2377,13 +2377,13 @@ impl Clean<Deprecation> for attr::Deprecation {\n     }\n }\n \n-impl Clean<TypeBinding> for hir::TypeBinding {\n+impl Clean<TypeBinding> for hir::TypeBinding<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> TypeBinding {\n         TypeBinding { name: self.ident.name.clean(cx), kind: self.kind.clean(cx) }\n     }\n }\n \n-impl Clean<TypeBindingKind> for hir::TypeBindingKind {\n+impl Clean<TypeBindingKind> for hir::TypeBindingKind<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> TypeBindingKind {\n         match *self {\n             hir::TypeBindingKind::Equality { ref ty } => {"}, {"sha": "46eddede0d518c5924667885db820d7c32dfcbed", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f95ab3fa654d64c1ba77bc494c5cecf29d7229/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=36f95ab3fa654d64c1ba77bc494c5cecf29d7229", "patch": "@@ -28,7 +28,7 @@ pub struct Module<'hir> {\n     pub statics: Vec<Static<'hir>>,\n     pub constants: Vec<Constant<'hir>>,\n     pub traits: Vec<Trait<'hir>>,\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub impls: Vec<Impl<'hir>>,\n     pub foreigns: Vec<ForeignItem<'hir>>,\n     pub macros: Vec<Macro<'hir>>,\n@@ -41,7 +41,7 @@ impl Module<'hir> {\n     pub fn new(\n         name: Option<Name>,\n         attrs: &'hir [ast::Attribute],\n-        vis: &'hir hir::Visibility,\n+        vis: &'hir hir::Visibility<'hir>,\n     ) -> Module<'hir> {\n         Module {\n             name: name,\n@@ -83,31 +83,31 @@ pub enum StructType {\n }\n \n pub struct Struct<'hir> {\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub id: hir::HirId,\n     pub struct_type: StructType,\n     pub name: Name,\n-    pub generics: &'hir hir::Generics,\n+    pub generics: &'hir hir::Generics<'hir>,\n     pub attrs: &'hir [ast::Attribute],\n     pub fields: &'hir [hir::StructField<'hir>],\n     pub whence: Span,\n }\n \n pub struct Union<'hir> {\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub id: hir::HirId,\n     pub struct_type: StructType,\n     pub name: Name,\n-    pub generics: &'hir hir::Generics,\n+    pub generics: &'hir hir::Generics<'hir>,\n     pub attrs: &'hir [ast::Attribute],\n     pub fields: &'hir [hir::StructField<'hir>],\n     pub whence: Span,\n }\n \n pub struct Enum<'hir> {\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub variants: Vec<Variant<'hir>>,\n-    pub generics: &'hir hir::Generics,\n+    pub generics: &'hir hir::Generics<'hir>,\n     pub attrs: &'hir [ast::Attribute],\n     pub id: hir::HirId,\n     pub whence: Span,\n@@ -123,54 +123,54 @@ pub struct Variant<'hir> {\n }\n \n pub struct Function<'hir> {\n-    pub decl: &'hir hir::FnDecl,\n+    pub decl: &'hir hir::FnDecl<'hir>,\n     pub attrs: &'hir [ast::Attribute],\n     pub id: hir::HirId,\n     pub name: Name,\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub header: hir::FnHeader,\n     pub whence: Span,\n-    pub generics: &'hir hir::Generics,\n+    pub generics: &'hir hir::Generics<'hir>,\n     pub body: hir::BodyId,\n }\n \n pub struct Typedef<'hir> {\n-    pub ty: &'hir hir::Ty,\n-    pub gen: &'hir hir::Generics,\n+    pub ty: &'hir hir::Ty<'hir>,\n+    pub gen: &'hir hir::Generics<'hir>,\n     pub name: Name,\n     pub id: hir::HirId,\n     pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n }\n \n pub struct OpaqueTy<'hir> {\n-    pub opaque_ty: &'hir hir::OpaqueTy,\n+    pub opaque_ty: &'hir hir::OpaqueTy<'hir>,\n     pub name: Name,\n     pub id: hir::HirId,\n     pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n }\n \n #[derive(Debug)]\n pub struct Static<'hir> {\n-    pub type_: &'hir hir::Ty,\n+    pub type_: &'hir hir::Ty<'hir>,\n     pub mutability: hir::Mutability,\n     pub expr: hir::BodyId,\n     pub name: Name,\n     pub attrs: &'hir [ast::Attribute],\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub id: hir::HirId,\n     pub whence: Span,\n }\n \n pub struct Constant<'hir> {\n-    pub type_: &'hir hir::Ty,\n+    pub type_: &'hir hir::Ty<'hir>,\n     pub expr: hir::BodyId,\n     pub name: Name,\n     pub attrs: &'hir [ast::Attribute],\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub id: hir::HirId,\n     pub whence: Span,\n }\n@@ -180,41 +180,41 @@ pub struct Trait<'hir> {\n     pub unsafety: hir::Unsafety,\n     pub name: Name,\n     pub items: Vec<&'hir hir::TraitItem<'hir>>,\n-    pub generics: &'hir hir::Generics,\n-    pub bounds: &'hir [hir::GenericBound],\n+    pub generics: &'hir hir::Generics<'hir>,\n+    pub bounds: &'hir [hir::GenericBound<'hir>],\n     pub attrs: &'hir [ast::Attribute],\n     pub id: hir::HirId,\n     pub whence: Span,\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n }\n \n pub struct TraitAlias<'hir> {\n     pub name: Name,\n-    pub generics: &'hir hir::Generics,\n-    pub bounds: &'hir [hir::GenericBound],\n+    pub generics: &'hir hir::Generics<'hir>,\n+    pub bounds: &'hir [hir::GenericBound<'hir>],\n     pub attrs: &'hir [ast::Attribute],\n     pub id: hir::HirId,\n     pub whence: Span,\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n }\n \n #[derive(Debug)]\n pub struct Impl<'hir> {\n     pub unsafety: hir::Unsafety,\n     pub polarity: hir::ImplPolarity,\n     pub defaultness: hir::Defaultness,\n-    pub generics: &'hir hir::Generics,\n-    pub trait_: &'hir Option<hir::TraitRef>,\n-    pub for_: &'hir hir::Ty,\n+    pub generics: &'hir hir::Generics<'hir>,\n+    pub trait_: &'hir Option<hir::TraitRef<'hir>>,\n+    pub for_: &'hir hir::Ty<'hir>,\n     pub items: Vec<&'hir hir::ImplItem<'hir>>,\n     pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub id: hir::HirId,\n }\n \n pub struct ForeignItem<'hir> {\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub id: hir::HirId,\n     pub name: Name,\n     pub kind: &'hir hir::ForeignItemKind<'hir>,\n@@ -238,17 +238,17 @@ pub struct ExternCrate<'hir> {\n     pub name: Name,\n     pub cnum: CrateNum,\n     pub path: Option<String>,\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n }\n \n pub struct Import<'hir> {\n     pub name: Name,\n     pub id: hir::HirId,\n-    pub vis: &'hir hir::Visibility,\n+    pub vis: &'hir hir::Visibility<'hir>,\n     pub attrs: &'hir [ast::Attribute],\n-    pub path: &'hir hir::Path,\n+    pub path: &'hir hir::Path<'hir>,\n     pub glob: bool,\n     pub whence: Span,\n }"}]}