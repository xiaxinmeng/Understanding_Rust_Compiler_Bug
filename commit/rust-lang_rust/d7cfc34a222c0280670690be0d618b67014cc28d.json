{"sha": "d7cfc34a222c0280670690be0d618b67014cc28d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3Y2ZjMzRhMjIyYzAyODA2NzA2OTBiZTBkNjE4YjY3MDE0Y2MyOGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-02T00:31:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-02T00:31:03Z"}, "message": "auto merge of #16119 : steveklabnik/rust/guide_pointers, r=brson\n\nThis is the next section of the guide, and it's on pointers. It's not done yet, as I need to write the section on ownership and borrowing, but I figured I'd share the rest now, to get feedback on the rest of it while I take some time to get that right.", "tree": {"sha": "1f487f7b562dfb512afbdafbbf9c00663e330be8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f487f7b562dfb512afbdafbbf9c00663e330be8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7cfc34a222c0280670690be0d618b67014cc28d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7cfc34a222c0280670690be0d618b67014cc28d", "html_url": "https://github.com/rust-lang/rust/commit/d7cfc34a222c0280670690be0d618b67014cc28d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7cfc34a222c0280670690be0d618b67014cc28d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "292caefb26c7f99a064a1ed6a8ba37ec5375e88e", "url": "https://api.github.com/repos/rust-lang/rust/commits/292caefb26c7f99a064a1ed6a8ba37ec5375e88e", "html_url": "https://github.com/rust-lang/rust/commit/292caefb26c7f99a064a1ed6a8ba37ec5375e88e"}, {"sha": "a74197e3f140ebba2bb11d3c8dfcb26c26a278dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a74197e3f140ebba2bb11d3c8dfcb26c26a278dd", "html_url": "https://github.com/rust-lang/rust/commit/a74197e3f140ebba2bb11d3c8dfcb26c26a278dd"}], "stats": {"total": 262, "additions": 255, "deletions": 7}, "files": [{"sha": "aab610fb174a7767336950dfdb0b1e56fe09ac3e", "filename": "src/doc/guide.md", "status": "modified", "additions": 255, "deletions": 7, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/d7cfc34a222c0280670690be0d618b67014cc28d/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/d7cfc34a222c0280670690be0d618b67014cc28d/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=d7cfc34a222c0280670690be0d618b67014cc28d", "patch": "@@ -3387,23 +3387,271 @@ out.\n \n # Pointers\n \n+In systems programming, pointers are an incredibly important topic. Rust has a\n+very rich set of pointers, and they operate differently than in many other\n+languages. They are important enough that we have a specific [Pointer\n+Guide](/guide-pointers.html) that goes into pointers in much detail. In fact,\n+while you're currently reading this guide, which covers the language in broad\n+overview, there are a number of other guides that put a specific topic under a\n+microscope. You can find the list of guides on the [documentation index\n+page](/index.html#guides).\n+\n+In this section, we'll assume that you're familiar with pointers as a general\n+concept. If you aren't, please read the [introduction to\n+pointers](/guide-pointers.html#an-introduction) section of the Pointer Guide,\n+and then come back here. We'll wait.\n+\n+Got the gist? Great. Let's talk about pointers in Rust.\n+\n+## References\n+\n+The most primitive form of pointer in Rust is called a **reference**.\n+References are created using the ampersand (`&`). Here's a simple\n+reference:\n+\n+```{rust}\n+let x = 5i;\n+let y = &x;\n+```\n+\n+`y` is a reference to `x`. To dereference (get the value being referred to\n+rather than the reference itself) `y`, we use the asterisk (`*`):\n+\n+```{rust}\n+let x = 5i;\n+let y = &x;\n+\n+assert_eq!(5i, *y);\n+```\n+\n+Like any `let` binding, references are immutable by default.\n+\n+You can declare that functions take a reference:\n+\n+```{rust}\n+fn add_one(x: &int) -> int { *x + 1 }\n+\n+fn main() {\n+    assert_eq!(6, add_one(&5));\n+}\n+```\n+\n+As you can see, we can make a reference from a literal by applying `&` as well.\n+Of course, in this simple function, there's not a lot of reason to take `x` by\n+reference. It's just an example of the syntax.\n+\n+Because references are immutable, you can have multiple references that\n+**alias** (point to the same place):\n+\n+```{rust}\n+let x = 5i;\n+let y = &x;\n+let z = &x;\n+```\n+\n+We can make a mutable reference by using `&mut` instead of `&`:\n+\n+```{rust}\n+let mut x = 5i;\n+let y = &mut x;\n+```\n+\n+Note that `x` must also be mutable. If it isn't, like this:\n+\n+```{rust,ignore}\n+let x = 5i;\n+let y = &mut x;\n+```\n+\n+Rust will complain:\n+\n+```{ignore,notrust}\n+6:19 error: cannot borrow immutable local variable `x` as mutable\n+ let y = &mut x;\n+              ^\n+```\n+\n+We don't want a mutable reference to immutable data! This error message uses a\n+term we haven't talked about yet, 'borrow.' We'll get to that in just a moment.\n+\n+This simple example actually illustrates a lot of Rust's power: Rust has\n+prevented us, at compile time, from breaking our own rules. Because Rust's\n+references check these kinds of rules entirely at compile time, there's no\n+runtime overhead for this safety.  At runtime, these are the same as a raw\n+machine pointer, like in C or C++.  We've just double-checked ahead of time\n+that we haven't done anything dangerous.\n+\n+Rust will also prevent us from creating two mutable references that alias.\n+This won't work:\n+\n+```{rust,ignore}\n+let mut x = 5i;\n+let y = &mut x;\n+let z = &mut x;\n+```\n+\n+It gives us this error:\n+\n+```{notrust,ignore}\n+error: cannot borrow `x` as mutable more than once at a time\n+     let z = &mut x;\n+                  ^\n+note: previous borrow of `x` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x` until the borrow ends\n+     let y = &mut x;\n+                  ^\n+note: previous borrow ends here\n+ fn main() {\n+     let mut x = 5i;\n+     let y = &mut x;\n+     let z = &mut x;\n+ }\n+ ^\n+```\n+\n+This is a big error message. Let's dig into it for a moment. There are three\n+parts: the error and two notes. The error says what we expected, we cannot have\n+two pointers that point to the same memory.\n+\n+The two notes give some extra context. Rust's error messages often contain this\n+kind of extra information when the error is complex. Rust is telling us two\n+things: first, that the reason we cannot **borrow** `x` as `z` is that we\n+previously borrowed `x` as `y`. The second note shows where `y`'s borrowing\n+ends.\n+\n+Wait, borrowing?\n+\n+In order to truly understand this error, we have to learn a few new concepts:\n+**ownership**, **borrowing**, and **lifetimes**.\n+\n+## Ownership, borrowing, and lifetimes\n+\n+## Boxes\n+\n+All of our references so far have been to variables we've created on the stack.\n+In Rust, the simplest way to allocate heap variables is using a *box*.  To\n+create a box, use the `box` keyword:\n+ \n+```{rust}\n+let x = box 5i;\n+```\n+\n+This allocates an integer `5` on the heap, and creates a binding `x` that\n+refers to it.. The great thing about boxed pointers is that we don't have to\n+manually free this allocation! If we write \n+\n+```{rust}\n+{\n+    let x = box 5i;\n+    // do stuff\n+}\n+```\n+\n+then Rust will automatically free `x` at the end of the block. This isn't\n+because Rust has a garbage collector -- it doesn't. Instead, Rust uses static\n+analysis to determine the *lifetime* of `x`, and then generates code to free it\n+once it's sure the `x` won't be used again. This Rust code will do the same\n+thing as the following C code:\n+\n+```{c,ignore}\n+{\n+    int *x = (int *)malloc(sizeof(int));\n+    // do stuff\n+    free(x);\n+}\n+```\n+\n+This means we get the benefits of manual memory management, but the compiler\n+ensures that we don't do something wrong. We can't forget to `free` our memory.\n+\n+Boxes are the sole owner of their contents, so you cannot take a mutable\n+reference to them and then use the original box:\n+\n+```{rust,ignore}\n+let mut x = box 5i;\n+let y = &mut x;\n+\n+*x; // you might expect 5, but this is actually an error\n+```\n+\n+This gives us this error:\n+\n+```{notrust,ignore}\n+8:7 error: cannot use `*x` because it was mutably borrowed\n+ *x;\n+ ^~\n+ 6:19 note: borrow of `x` occurs here\n+ let y = &mut x;\n+              ^\n+```\n+\n+As long as `y` is borrowing the contents, we cannot use `x`. After `y` is\n+done borrowing the value, we can use it again. This works fine:\n+\n+```{rust}\n+let mut x = box 5i;\n+\n+{\n+    let y = &mut x;\n+} // y goes out of scope at the end of the block\n+\n+*x;\n+```\n+\n+## Rc and Arc\n+\n+Sometimes, you need to allocate something on the heap, but give out multiple\n+references to the memory. Rust's `Rc<T>` (pronounced 'arr cee tee') and\n+`Arc<T>` types (again, the `T` is for generics, we'll learn more later) provide\n+you with this ability.  **Rc** stands for 'reference counted,' and **Arc** for\n+'atomically reference counted.' This is how Rust keeps track of the multiple\n+owners: every time we make a new reference to the `Rc<T>`, we add one to its\n+internal 'reference count.' Every time a reference goes out of scope, we\n+subtract one from the count. When the count is zero, the `Rc<T>` can be safely\n+deallocated. `Arc<T>` is almost identical to `Rc<T>`, except for one thing: The\n+'atomically' in 'Arc' means that increasing and decreasing the count uses a\n+thread-safe mechanism to do so. Why two types? `Rc<T>` is faster, so if you're\n+not in a multi-threaded scenario, you can have that advantage. Since we haven't\n+talked about threading yet in Rust, we'll show you `Rc<T>` for the rest of this\n+section.\n+\n+To create an `Rc<T>`, use `Rc::new()`:\n+\n+```{rust}\n+use std::rc::Rc;\n+\n+let x = Rc::new(5i);\n+```\n+\n+To create a second reference, use the `.clone()` method:\n+\n+```{rust}\n+use std::rc::Rc;\n+\n+let x = Rc::new(5i);\n+let y = x.clone();\n+```\n+\n+The `Rc<T>` will live as long as any of its references are alive. After they\n+all go out of scope, the memory will be `free`d.\n+\n+If you use `Rc<T>` or `Arc<T>`, you have to be careful about introducing\n+cycles. If you have two `Rc<T>`s that point to each other, the reference counts\n+will never drop to zero, and you'll have a memory leak. To learn more, check\n+out [the section on `Rc<T>` and `Arc<T>` in the pointers\n+guide](http://doc.rust-lang.org/guide-pointers.html#rc-and-arc).\n+\n+# Patterns\n+\n # Lambdas\n \n # iterators\n \n-\n # Generics\n \n # Traits\n \n # Operators and built-in Traits\n \n-# Ownership and Lifetimes\n-\n-Move vs. Copy\n-\n-Allocation\n-\n # Tasks\n \n # Macros"}]}