{"sha": "22992358bc74956f53b1a2ab99ae245cd3ca5550", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyOTkyMzU4YmM3NDk1NmY1M2IxYTJhYjk5YWUyNDVjZDNjYTU1NTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-18T23:58:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-18T23:58:38Z"}, "message": "Auto merge of #22436 - nikomatsakis:issue-22246-bound-lifetimes-of-assoc-types, r=nikomatsakis\n\nTake 2. This PR includes a bunch of refactoring that was part of an experimental branch implementing [implied bounds]. That particular idea isn't ready to go yet, but the refactoring proved useful for fixing #22246. The implied bounds branch also exposed #22110 so a simple fix for that is included here. I still think some more refactoring would be a good idea here -- in particular I think most of the code in wf.rs is kind of duplicating the logic in implicator and should go, but I decided to post this PR and call it a day before diving into that. I'll write a bit more details about the solutions I adopted in the various bugs. I patched the two issues I was concerned about, which was the handling of supertraits and HRTB (the latter turned out to be fine, so I added a comment explaining why.)\r\n\r\nr? @pnkfelix (for now, anyway)\r\ncc @aturon \r\n\r\n[implied bounds]: http://smallcultfollowing.com/babysteps/blog/2014/07/06/implied-bounds/", "tree": {"sha": "960927f60e213cd3c87ccc3165df97ca17043dfb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/960927f60e213cd3c87ccc3165df97ca17043dfb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22992358bc74956f53b1a2ab99ae245cd3ca5550", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22992358bc74956f53b1a2ab99ae245cd3ca5550", "html_url": "https://github.com/rust-lang/rust/commit/22992358bc74956f53b1a2ab99ae245cd3ca5550", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22992358bc74956f53b1a2ab99ae245cd3ca5550/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "html_url": "https://github.com/rust-lang/rust/commit/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5"}, {"sha": "9bb3b3772d4be69b0f619bd9456255a9e3bc7d9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bb3b3772d4be69b0f619bd9456255a9e3bc7d9e", "html_url": "https://github.com/rust-lang/rust/commit/9bb3b3772d4be69b0f619bd9456255a9e3bc7d9e"}], "stats": {"total": 980, "additions": 684, "deletions": 296}, "files": [{"sha": "8dbac7f515ea8fc23412fda8f8c49192efceaecf", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -838,7 +838,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     // the method call infrastructure should have\n                     // replaced all late-bound regions with variables:\n                     let self_ty = ty::ty_fn_sig(method_ty).input(0);\n-                    let self_ty = ty::assert_no_late_bound_regions(self.tcx(), &self_ty);\n+                    let self_ty = ty::no_late_bound_regions(self.tcx(), &self_ty).unwrap();\n \n                     let (m, r) = match self_ty.sty {\n                         ty::ty_rptr(r, ref m) => (m.mutbl, r),"}, {"sha": "235f3f994c65e40aa79c901e4f5a8cd4e7067126", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -212,7 +212,7 @@ impl<K:UnifyKey> UnificationTable<K> {\n     }\n }\n \n-impl<K> sv::SnapshotVecDelegate for Delegate<K> {\n+impl<K:UnifyKey> sv::SnapshotVecDelegate for Delegate<K> {\n     type Value = VarValue<K>;\n     type Undo = ();\n "}, {"sha": "4be7bb9c365a16d57d846ac70a178dfda6f944ff", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -281,7 +281,6 @@ pub type McResult<T> = Result<T, ()>;\n /// know that no errors have occurred, so we simply consult the tcx and we\n /// can be sure that only `Ok` results will occur.\n pub trait Typer<'tcx> : ty::ClosureTyper<'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n     fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>>;\n     fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>>;\n     fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool;\n@@ -905,8 +904,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let base_cmt = match method_ty {\n             Some(method_ty) => {\n                 let ref_ty =\n-                    ty::assert_no_late_bound_regions(\n-                        self.tcx(), &ty::ty_fn_ret(method_ty)).unwrap();\n+                    ty::no_late_bound_regions(\n+                        self.tcx(), &ty::ty_fn_ret(method_ty)).unwrap().unwrap();\n                 self.cat_rvalue_node(node.id(), node.span(), ref_ty)\n             }\n             None => base_cmt\n@@ -996,7 +995,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n                 // FIXME(#20649) -- why are we using the `self_ty` as the element type...?\n                 let self_ty = ty::ty_fn_sig(method_ty).input(0);\n-                ty::assert_no_late_bound_regions(self.tcx(), &self_ty)\n+                ty::no_late_bound_regions(self.tcx(), &self_ty).unwrap()\n             }\n             None => {\n                 match ty::array_element_ty(self.tcx(), base_cmt.ty) {\n@@ -1336,8 +1335,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         // types are generated by method resolution and always have\n         // all late-bound regions fully instantiated, so we just want\n         // to skip past the binder.\n-        ty::assert_no_late_bound_regions(self.tcx(), &ty::ty_fn_ret(method_ty))\n-            .unwrap() // overloaded ops do not diverge, either\n+        ty::no_late_bound_regions(self.tcx(), &ty::ty_fn_ret(method_ty))\n+           .unwrap()\n+           .unwrap() // overloaded ops do not diverge, either\n     }\n }\n "}, {"sha": "a9cac4be3e368026e319a32b890df4a6f36263fb", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use middle::infer::{InferCtxt};\n-use middle::mem_categorization::Typer;\n use middle::ty::{self, RegionEscape, Ty};\n use std::collections::HashSet;\n use std::collections::hash_map::Entry::{Occupied, Vacant};"}, {"sha": "57c9fa7a4d964a0b834e473247e2278f24631761", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 33, "deletions": 14, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -15,9 +15,9 @@ pub use self::FulfillmentErrorCode::*;\n pub use self::Vtable::*;\n pub use self::ObligationCauseCode::*;\n \n-use middle::mem_categorization::Typer;\n use middle::subst;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, HasProjectionTypes, Ty};\n+use middle::ty_fold::TypeFoldable;\n use middle::infer::{self, InferCtxt};\n use std::slice::Iter;\n use std::rc::Rc;\n@@ -432,25 +432,44 @@ pub fn normalize_param_env<'a,'tcx>(param_env: &ty::ParameterEnvironment<'a,'tcx\n     debug!(\"normalize_param_env(param_env={})\",\n            param_env.repr(tcx));\n \n-    let predicates: Vec<ty::Predicate<'tcx>> = {\n-        let infcx = infer::new_infer_ctxt(tcx);\n-        let mut selcx = &mut SelectionContext::new(&infcx, param_env);\n-        let mut fulfill_cx = FulfillmentContext::new();\n-        let Normalized { value: predicates, obligations } =\n-            project::normalize(selcx, cause, &param_env.caller_bounds);\n-        for obligation in obligations {\n-            fulfill_cx.register_predicate_obligation(selcx.infcx(), obligation);\n-        }\n-        try!(fulfill_cx.select_all_or_error(selcx.infcx(), param_env));\n-        predicates.iter().map(|p| infcx.resolve_type_vars_if_possible(p)).collect()\n-    };\n+    let infcx = infer::new_infer_ctxt(tcx);\n+    let predicates = try!(fully_normalize(&infcx, param_env, cause, &param_env.caller_bounds));\n \n     debug!(\"normalize_param_env: predicates={}\",\n            predicates.repr(tcx));\n \n     Ok(param_env.with_caller_bounds(predicates))\n }\n \n+pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n+                                  closure_typer: &ty::ClosureTyper<'tcx>,\n+                                  cause: ObligationCause<'tcx>,\n+                                  value: &T)\n+                                  -> Result<T, Vec<FulfillmentError<'tcx>>>\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr<'tcx>\n+{\n+    let tcx = closure_typer.tcx();\n+\n+    debug!(\"normalize_param_env(value={})\",\n+           value.repr(tcx));\n+\n+    let mut selcx = &mut SelectionContext::new(infcx, closure_typer);\n+    let mut fulfill_cx = FulfillmentContext::new();\n+    let Normalized { value: normalized_value, obligations } =\n+        project::normalize(selcx, cause, value);\n+    debug!(\"normalize_param_env: normalized_value={} obligations={}\",\n+           normalized_value.repr(tcx),\n+           obligations.repr(tcx));\n+    for obligation in obligations {\n+        fulfill_cx.register_predicate_obligation(selcx.infcx(), obligation);\n+    }\n+    try!(fulfill_cx.select_all_or_error(infcx, closure_typer));\n+    let resolved_value = infcx.resolve_type_vars_if_possible(&normalized_value);\n+    debug!(\"normalize_param_env: resolved_value={}\",\n+           resolved_value.repr(tcx));\n+    Ok(resolved_value)\n+}\n+\n impl<'tcx,O> Obligation<'tcx,O> {\n     pub fn new(cause: ObligationCause<'tcx>,\n                trait_ref: O)"}, {"sha": "027415de998dfbae2049fe51b8d1f83fed696955", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 14, "deletions": 58, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -32,7 +32,6 @@ use super::object_safety;\n use super::{util};\n \n use middle::fast_reject;\n-use middle::mem_categorization::Typer;\n use middle::subst::{Subst, Substs, TypeSpace, VecPerParamSpace};\n use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n use middle::infer;\n@@ -653,8 +652,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let is_dup =\n                     (0..candidates.len())\n                     .filter(|&j| i != j)\n-                    .any(|j| self.candidate_should_be_dropped_in_favor_of(stack,\n-                                                                          &candidates[i],\n+                    .any(|j| self.candidate_should_be_dropped_in_favor_of(&candidates[i],\n                                                                           &candidates[j]));\n                 if is_dup {\n                     debug!(\"Dropping candidate #{}/{}: {}\",\n@@ -1236,31 +1234,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.evaluate_predicates_recursively(stack, selection.iter_nested())\n     }\n \n-    /// Returns true if `candidate_i` should be dropped in favor of `candidate_j`.\n-    ///\n-    /// This is generally true if either:\n-    /// - candidate i and candidate j are equivalent; or,\n-    /// - candidate i is a concrete impl and candidate j is a where clause bound,\n-    ///   and the concrete impl is applicable to the types in the where clause bound.\n-    ///\n-    /// The last case refers to cases where there are blanket impls (often conditional\n-    /// blanket impls) as well as a where clause. This can come down to one of two cases:\n-    ///\n-    /// - The impl is truly unconditional (it has no where clauses\n-    ///   of its own), in which case the where clause is\n-    ///   unnecessary, because coherence requires that we would\n-    ///   pick that particular impl anyhow (at least so long as we\n-    ///   don't have specialization).\n-    ///\n-    /// - The impl is conditional, in which case we may not have winnowed it out\n-    ///   because we don't know if the conditions apply, but the where clause is basically\n-    ///   telling us that there is some impl, though not necessarily the one we see.\n-    ///\n-    /// In both cases we prefer to take the where clause, which is\n-    /// essentially harmless.  See issue #18453 for more details of\n-    /// a case where doing the opposite caused us harm.\n+    /// Returns true if `candidate_i` should be dropped in favor of\n+    /// `candidate_j`.  Generally speaking we will drop duplicate\n+    /// candidates and prefer where-clause candidates.\n     fn candidate_should_be_dropped_in_favor_of<'o>(&mut self,\n-                                                   stack: &TraitObligationStack<'o, 'tcx>,\n                                                    candidate_i: &SelectionCandidate<'tcx>,\n                                                    candidate_j: &SelectionCandidate<'tcx>)\n                                                    -> bool\n@@ -1270,37 +1247,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         match (candidate_i, candidate_j) {\n-            (&ImplCandidate(impl_def_id), &ParamCandidate(ref bound)) => {\n-                debug!(\"Considering whether to drop param {} in favor of impl {}\",\n-                       candidate_i.repr(self.tcx()),\n-                       candidate_j.repr(self.tcx()));\n-\n-                self.infcx.probe(|snapshot| {\n-                    let (skol_obligation_trait_ref, skol_map) =\n-                        self.infcx().skolemize_late_bound_regions(\n-                            &stack.obligation.predicate, snapshot);\n-                    let impl_substs =\n-                        self.rematch_impl(impl_def_id, stack.obligation, snapshot,\n-                                          &skol_map, skol_obligation_trait_ref.trait_ref.clone());\n-                    let impl_trait_ref =\n-                        ty::impl_trait_ref(self.tcx(), impl_def_id).unwrap();\n-                    let impl_trait_ref =\n-                        impl_trait_ref.subst(self.tcx(), &impl_substs.value);\n-                    let poly_impl_trait_ref =\n-                        ty::Binder(impl_trait_ref);\n-                    let origin =\n-                        infer::RelateOutputImplTypes(stack.obligation.cause.span);\n-                    self.infcx\n-                        .sub_poly_trait_refs(false, origin, poly_impl_trait_ref, bound.clone())\n-                        .is_ok()\n-                })\n-            }\n-            (&BuiltinCandidate(_), &ParamCandidate(_)) => {\n-                // If we have a where-clause like `Option<K> : Send`,\n-                // then we wind up in a situation where there is a\n-                // default rule (`Option<K>:Send if K:Send) and the\n-                // where-clause that both seem applicable. Just take\n-                // the where-clause in that case.\n+            (&ImplCandidate(..), &ParamCandidate(..)) |\n+            (&ClosureCandidate(..), &ParamCandidate(..)) |\n+            (&FnPointerCandidate(..), &ParamCandidate(..)) |\n+            (&BuiltinCandidate(..), &ParamCandidate(..)) => {\n+                // We basically prefer always prefer to use a\n+                // where-clause over another option. Where clauses\n+                // impose the burden of finding the exact match onto\n+                // the caller. Using an impl in preference of a where\n+                // clause can also lead us to \"overspecialize\", as in\n+                // #18453.\n                 true\n             }\n             (&ProjectionCandidate, &ParamCandidate(_)) => {"}, {"sha": "e3eda02b0a8429a0e7283995f4534e756cd89291", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -2337,6 +2337,10 @@ impl ClosureKind {\n }\n \n pub trait ClosureTyper<'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.param_env().tcx\n+    }\n+\n     fn param_env<'a>(&'a self) -> &'a ty::ParameterEnvironment<'a, 'tcx>;\n \n     /// Is this a `Fn`, `FnMut` or `FnOnce` closure? During typeck,\n@@ -4384,8 +4388,8 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                                     // overloaded deref operators have all late-bound\n                                     // regions fully instantiated and coverge\n                                     let fn_ret =\n-                                        ty::assert_no_late_bound_regions(cx,\n-                                                                         &ty_fn_ret(method_ty));\n+                                        ty::no_late_bound_regions(cx,\n+                                                                  &ty_fn_ret(method_ty)).unwrap();\n                                     adjusted_ty = fn_ret.unwrap();\n                                 }\n                                 None => {}\n@@ -5186,7 +5190,7 @@ impl<'tcx> VariantInfo<'tcx> {\n                 let arg_tys = if args.len() > 0 {\n                     // the regions in the argument types come from the\n                     // enum def'n, and hence will all be early bound\n-                    ty::assert_no_late_bound_regions(cx, &ty_fn_args(ctor_ty))\n+                    ty::no_late_bound_regions(cx, &ty_fn_args(ctor_ty)).unwrap()\n                 } else {\n                     Vec::new()\n                 };\n@@ -6463,10 +6467,6 @@ impl<'tcx> ctxt<'tcx> {\n }\n \n impl<'a,'tcx> mc::Typer<'tcx> for ParameterEnvironment<'a,'tcx> {\n-    fn tcx(&self) -> &ty::ctxt<'tcx> {\n-        self.tcx\n-    }\n-\n     fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n         Ok(ty::node_id_to_type(self.tcx, id))\n     }\n@@ -6677,14 +6677,17 @@ pub fn binds_late_bound_regions<'tcx, T>(\n     count_late_bound_regions(tcx, value) > 0\n }\n \n-pub fn assert_no_late_bound_regions<'tcx, T>(\n+pub fn no_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     value: &Binder<T>)\n-    -> T\n+    -> Option<T>\n     where T : TypeFoldable<'tcx> + Repr<'tcx> + Clone\n {\n-    assert!(!binds_late_bound_regions(tcx, value));\n-    value.0.clone()\n+    if binds_late_bound_regions(tcx, value) {\n+        None\n+    } else {\n+        Some(value.0.clone())\n+    }\n }\n \n /// Replace any late-bound regions bound in `value` with `'static`. Useful in trans but also"}, {"sha": "d0f5aa8cf003b5e36f8996913723cbb6cfeaffeb", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -16,7 +16,6 @@ use borrowck::gather_loans::move_error::{MoveError, MoveErrorCollector};\n use borrowck::move_data::*;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n-use rustc::middle::mem_categorization::Typer;\n use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n use rustc::middle::ty;\n use rustc::util::ppaux::Repr;"}, {"sha": "da5c847a04607e7cc79fc8e3de8e01726906d578", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -10,7 +10,6 @@\n \n use borrowck::BorrowckCtxt;\n use rustc::middle::mem_categorization as mc;\n-use rustc::middle::mem_categorization::Typer;\n use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n use rustc::middle::ty;\n use rustc::util::ppaux::UserString;"}, {"sha": "3709490d8dad796121c83ad626222ebb2a023708", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -637,10 +637,6 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n }\n \n impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n-        self.tcx()\n-    }\n-\n     fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n         Ok(node_id_type(self, id))\n     }"}, {"sha": "7a05cc5527662d4d5cf03c57e9ba373662eec22d", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -781,8 +781,8 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let ix_datum = unpack_datum!(bcx, trans(bcx, idx));\n \n             let ref_ty = // invoked methods have LB regions instantiated:\n-                ty::assert_no_late_bound_regions(\n-                    bcx.tcx(), &ty::ty_fn_ret(method_ty)).unwrap();\n+                ty::no_late_bound_regions(\n+                    bcx.tcx(), &ty::ty_fn_ret(method_ty)).unwrap().unwrap();\n             let elt_ty = match ty::deref(ref_ty, true) {\n                 None => {\n                     bcx.tcx().sess.span_bug(index_expr.span,\n@@ -2214,8 +2214,8 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n \n             let ref_ty = // invoked methods have their LB regions instantiated\n-                ty::assert_no_late_bound_regions(\n-                    ccx.tcx(), &ty::ty_fn_ret(method_ty)).unwrap();\n+                ty::no_late_bound_regions(\n+                    ccx.tcx(), &ty::ty_fn_ret(method_ty)).unwrap().unwrap();\n             let scratch = rvalue_scratch_datum(bcx, ref_ty, \"overloaded_deref\");\n \n             unpack_result!(bcx, trans_overloaded_op(bcx, expr, method_call,"}, {"sha": "0d30741978a5a5c109a285b04bbf142045ac3509", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -509,7 +509,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let ctor_scheme = ty::lookup_item_type(tcx, enum_def);\n     let ctor_predicates = ty::lookup_predicates(tcx, enum_def);\n     let path_scheme = if ty::is_fn_ty(ctor_scheme.ty) {\n-        let fn_ret = ty::assert_no_late_bound_regions(tcx, &ty::ty_fn_ret(ctor_scheme.ty));\n+        let fn_ret = ty::no_late_bound_regions(tcx, &ty::ty_fn_ret(ctor_scheme.ty)).unwrap();\n         ty::TypeScheme {\n             ty: fn_ret.unwrap(),\n             generics: ctor_scheme.generics,"}, {"sha": "7354ea7377c36126f40d9e22d25e83177ae2d09c", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -367,8 +367,8 @@ impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n                 // (This always bites me, should find a way to\n                 // refactor it.)\n                 let method_sig =\n-                    ty::assert_no_late_bound_regions(fcx.tcx(),\n-                                                     ty::ty_fn_sig(method_callee.ty));\n+                    ty::no_late_bound_regions(fcx.tcx(),\n+                                              ty::ty_fn_sig(method_callee.ty)).unwrap();\n \n                 debug!(\"attempt_resolution: method_callee={}\",\n                        method_callee.repr(fcx.tcx()));"}, {"sha": "da25719baaa4ab3f06e67dec3adfcb5420b94465", "filename": "src/librustc_typeck/check/implicator.rs", "status": "renamed", "additions": 177, "deletions": 117, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -10,52 +10,74 @@\n \n // #![warn(deprecated_mode)]\n \n-pub use self::WfConstraint::*;\n-\n use astconv::object_region_bounds;\n-use middle::infer::GenericKind;\n-use middle::subst::{ParamSpace, Subst, Substs};\n-use middle::ty::{self, Ty};\n-use middle::ty_fold::{TypeFolder};\n+use middle::infer::{InferCtxt, GenericKind};\n+use middle::subst::{Substs};\n+use middle::traits;\n+use middle::ty::{self, ToPolyTraitRef, Ty};\n+use middle::ty_fold::{TypeFoldable, TypeFolder};\n \n+use std::rc::Rc;\n use syntax::ast;\n+use syntax::codemap::Span;\n \n+use util::common::ErrorReported;\n use util::ppaux::Repr;\n \n // Helper functions related to manipulating region types.\n \n-pub enum WfConstraint<'tcx> {\n-    RegionSubRegionConstraint(Option<Ty<'tcx>>, ty::Region, ty::Region),\n-    RegionSubGenericConstraint(Option<Ty<'tcx>>, ty::Region, GenericKind<'tcx>),\n+pub enum Implication<'tcx> {\n+    RegionSubRegion(Option<Ty<'tcx>>, ty::Region, ty::Region),\n+    RegionSubGeneric(Option<Ty<'tcx>>, ty::Region, GenericKind<'tcx>),\n+    Predicate(ast::DefId, ty::Predicate<'tcx>),\n }\n \n-struct Wf<'a, 'tcx: 'a> {\n-    tcx: &'a ty::ctxt<'tcx>,\n+struct Implicator<'a, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a,'tcx>,\n+    closure_typer: &'a (ty::ClosureTyper<'tcx>+'a),\n+    body_id: ast::NodeId,\n     stack: Vec<(ty::Region, Option<Ty<'tcx>>)>,\n-    out: Vec<WfConstraint<'tcx>>,\n+    span: Span,\n+    out: Vec<Implication<'tcx>>,\n }\n \n /// This routine computes the well-formedness constraints that must hold for the type `ty` to\n /// appear in a context with lifetime `outer_region`\n-pub fn region_wf_constraints<'tcx>(\n-    tcx: &ty::ctxt<'tcx>,\n+pub fn implications<'a,'tcx>(\n+    infcx: &'a InferCtxt<'a,'tcx>,\n+    closure_typer: &ty::ClosureTyper<'tcx>,\n+    body_id: ast::NodeId,\n     ty: Ty<'tcx>,\n-    outer_region: ty::Region)\n-    -> Vec<WfConstraint<'tcx>>\n+    outer_region: ty::Region,\n+    span: Span)\n+    -> Vec<Implication<'tcx>>\n {\n+    debug!(\"implications(body_id={}, ty={}, outer_region={})\",\n+           body_id,\n+           ty.repr(closure_typer.tcx()),\n+           outer_region.repr(closure_typer.tcx()));\n+\n     let mut stack = Vec::new();\n     stack.push((outer_region, None));\n-    let mut wf = Wf { tcx: tcx,\n-                      stack: stack,\n-                      out: Vec::new() };\n+    let mut wf = Implicator { closure_typer: closure_typer,\n+                              infcx: infcx,\n+                              body_id: body_id,\n+                              span: span,\n+                              stack: stack,\n+                              out: Vec::new() };\n     wf.accumulate_from_ty(ty);\n+    debug!(\"implications: out={}\", wf.out.repr(closure_typer.tcx()));\n     wf.out\n }\n \n-impl<'a, 'tcx> Wf<'a, 'tcx> {\n+impl<'a, 'tcx> Implicator<'a, 'tcx> {\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n     fn accumulate_from_ty(&mut self, ty: Ty<'tcx>) {\n-        debug!(\"Wf::accumulate_from_ty(ty={})\",\n-               ty.repr(self.tcx));\n+        debug!(\"accumulate_from_ty(ty={})\",\n+               ty.repr(self.tcx()));\n \n         match ty.sty {\n             ty::ty_bool |\n@@ -96,13 +118,13 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n \n             ty::ty_trait(ref t) => {\n                 let required_region_bounds =\n-                    object_region_bounds(self.tcx, &t.principal, t.bounds.builtin_bounds);\n+                    object_region_bounds(self.tcx(), &t.principal, t.bounds.builtin_bounds);\n                 self.accumulate_from_object_ty(ty, t.bounds.region_bound, required_region_bounds)\n             }\n \n             ty::ty_enum(def_id, substs) |\n             ty::ty_struct(def_id, substs) => {\n-                let item_scheme = ty::lookup_item_type(self.tcx, def_id);\n+                let item_scheme = ty::lookup_item_type(self.tcx(), def_id);\n                 self.accumulate_from_adt(ty, def_id, &item_scheme.generics, substs)\n             }\n \n@@ -141,9 +163,9 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n             }\n \n             ty::ty_open(_) => {\n-                self.tcx.sess.bug(\n+                self.tcx().sess.bug(\n                     &format!(\"Unexpected type encountered while doing wf check: {}\",\n-                            ty.repr(self.tcx))[]);\n+                            ty.repr(self.tcx()))[]);\n             }\n         }\n     }\n@@ -197,7 +219,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n                                   opt_ty: Option<Ty<'tcx>>,\n                                   r_a: ty::Region,\n                                   r_b: ty::Region) {\n-        self.out.push(RegionSubRegionConstraint(opt_ty, r_a, r_b));\n+        self.out.push(Implication::RegionSubRegion(opt_ty, r_a, r_b));\n     }\n \n     /// Pushes a constraint that `param_ty` must outlive the top region on the stack.\n@@ -211,7 +233,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n     fn push_projection_constraint_from_top(&mut self,\n                                            projection_ty: &ty::ProjectionTy<'tcx>) {\n         let &(region, opt_ty) = self.stack.last().unwrap();\n-        self.out.push(RegionSubGenericConstraint(\n+        self.out.push(Implication::RegionSubGeneric(\n             opt_ty, region, GenericKind::Projection(projection_ty.clone())));\n     }\n \n@@ -220,110 +242,120 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n                              region: ty::Region,\n                              opt_ty: Option<Ty<'tcx>>,\n                              param_ty: ty::ParamTy) {\n-        self.out.push(RegionSubGenericConstraint(\n+        self.out.push(Implication::RegionSubGeneric(\n             opt_ty, region, GenericKind::Param(param_ty)));\n     }\n \n     fn accumulate_from_adt(&mut self,\n                            ty: Ty<'tcx>,\n                            def_id: ast::DefId,\n-                           generics: &ty::Generics<'tcx>,\n+                           _generics: &ty::Generics<'tcx>,\n                            substs: &Substs<'tcx>)\n     {\n-        // The generic declarations from the type, appropriately\n-        // substituted for the actual substitutions.\n-        let generics = generics.subst(self.tcx, substs);\n-\n-        // Variance of each type/region parameter.\n-        let variances = ty::item_variances(self.tcx, def_id);\n-\n-        for &space in &ParamSpace::all() {\n-            let region_params = substs.regions().get_slice(space);\n-            let region_variances = variances.regions.get_slice(space);\n-            let region_param_defs = generics.regions.get_slice(space);\n-            assert_eq!(region_params.len(), region_variances.len());\n-            for (&region_param, (&region_variance, region_param_def)) in\n-                region_params.iter().zip(\n-                    region_variances.iter().zip(\n-                        region_param_defs.iter()))\n-            {\n-                match region_variance {\n-                    ty::Covariant | ty::Bivariant => {\n-                        // Ignore covariant or bivariant region\n-                        // parameters.  To understand why, consider a\n-                        // struct `Foo<'a>`. If `Foo` contains any\n-                        // references with lifetime `'a`, then `'a` must\n-                        // be at least contravariant (and possibly\n-                        // invariant). The only way to have a covariant\n-                        // result is if `Foo` contains only a field with a\n-                        // type like `fn() -> &'a T`; i.e., a bare\n-                        // function that can produce a reference of\n-                        // lifetime `'a`. In this case, there is no\n-                        // *actual data* with lifetime `'a` that is\n-                        // reachable. (Presumably this bare function is\n-                        // really returning static data.)\n-                    }\n-\n-                    ty::Contravariant | ty::Invariant => {\n-                        // If the parameter is contravariant or\n-                        // invariant, there may indeed be reachable\n-                        // data with this lifetime. See other case for\n-                        // more details.\n-                        self.push_region_constraint_from_top(region_param);\n+        let predicates =\n+            ty::lookup_predicates(self.tcx(), def_id).instantiate(self.tcx(), substs);\n+        let predicates = match self.fully_normalize(&predicates) {\n+            Ok(predicates) => predicates,\n+            Err(ErrorReported) => { return; }\n+        };\n+\n+        for predicate in predicates.predicates.as_slice() {\n+            match *predicate {\n+                ty::Predicate::Trait(ref data) => {\n+                    self.accumulate_from_assoc_types_transitive(data);\n+                }\n+                ty::Predicate::Equate(..) => { }\n+                ty::Predicate::Projection(..) => { }\n+                ty::Predicate::RegionOutlives(ref data) => {\n+                    match ty::no_late_bound_regions(self.tcx(), data) {\n+                        None => { }\n+                        Some(ty::OutlivesPredicate(r_a, r_b)) => {\n+                            self.push_sub_region_constraint(Some(ty), r_b, r_a);\n+                        }\n                     }\n                 }\n-\n-                for &region_bound in &region_param_def.bounds {\n-                    // The type declared a constraint like\n-                    //\n-                    //     'b : 'a\n-                    //\n-                    // which means that `'a <= 'b` (after\n-                    // substitution).  So take the region we\n-                    // substituted for `'a` (`region_bound`) and make\n-                    // it a subregion of the region we substituted\n-                    // `'b` (`region_param`).\n-                    self.push_sub_region_constraint(\n-                        Some(ty), region_bound, region_param);\n+                ty::Predicate::TypeOutlives(ref data) => {\n+                    match ty::no_late_bound_regions(self.tcx(), data) {\n+                        None => { }\n+                        Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n+                            self.stack.push((r_b, Some(ty)));\n+                            self.accumulate_from_ty(ty_a);\n+                            self.stack.pop().unwrap();\n+                        }\n+                    }\n                 }\n             }\n+        }\n \n-            let types = substs.types.get_slice(space);\n-            let type_variances = variances.types.get_slice(space);\n-            let type_param_defs = generics.types.get_slice(space);\n-            assert_eq!(types.len(), type_variances.len());\n-            for (&type_param_ty, (&variance, type_param_def)) in\n-                types.iter().zip(\n-                    type_variances.iter().zip(\n-                        type_param_defs.iter()))\n-            {\n-                debug!(\"type_param_ty={} variance={}\",\n-                       type_param_ty.repr(self.tcx),\n-                       variance.repr(self.tcx));\n-\n-                match variance {\n-                    ty::Contravariant | ty::Bivariant => {\n-                        // As above, except that in this it is a\n-                        // *contravariant* reference that indices that no\n-                        // actual data of type T is reachable.\n-                    }\n+        let obligations = predicates.predicates\n+                                    .into_iter()\n+                                    .map(|pred| Implication::Predicate(def_id, pred));\n+        self.out.extend(obligations);\n \n-                    ty::Covariant | ty::Invariant => {\n-                        self.accumulate_from_ty(type_param_ty);\n-                    }\n+        let variances = ty::item_variances(self.tcx(), def_id);\n+\n+        for (&region, &variance) in substs.regions().iter().zip(variances.regions.iter()) {\n+            match variance {\n+                ty::Contravariant | ty::Invariant => {\n+                    // If any data with this lifetime is reachable\n+                    // within, it must be at least contravariant.\n+                    self.push_region_constraint_from_top(region)\n                 }\n+                ty::Covariant | ty::Bivariant => { }\n+            }\n+        }\n \n-                // Inspect bounds on this type parameter for any\n-                // region bounds.\n-                for &r in &type_param_def.bounds.region_bounds {\n-                    self.stack.push((r, Some(ty)));\n-                    self.accumulate_from_ty(type_param_ty);\n-                    self.stack.pop().unwrap();\n+        for (&ty, &variance) in substs.types.iter().zip(variances.types.iter()) {\n+            match variance {\n+                ty::Covariant | ty::Invariant => {\n+                    // If any data of this type is reachable within,\n+                    // it must be at least covariant.\n+                    self.accumulate_from_ty(ty);\n                 }\n+                ty::Contravariant | ty::Bivariant => { }\n+            }\n+        }\n+    }\n+\n+    /// Given that there is a requirement that `Foo<X> : 'a`, where\n+    /// `Foo` is declared like `struct Foo<T> where T : SomeTrait`,\n+    /// this code finds all the associated types defined in\n+    /// `SomeTrait` (and supertraits) and adds a requirement that `<X\n+    /// as SomeTrait>::N : 'a` (where `N` is some associated type\n+    /// defined in `SomeTrait`). This rule only applies to\n+    /// trait-bounds that are not higher-ranked, because we cannot\n+    /// project out of a HRTB. This rule helps code using associated\n+    /// types to compile, see Issue #22246 for an example.\n+    fn accumulate_from_assoc_types_transitive(&mut self,\n+                                              data: &ty::PolyTraitPredicate<'tcx>)\n+    {\n+        for poly_trait_ref in traits::supertraits(self.tcx(), data.to_poly_trait_ref()) {\n+            match ty::no_late_bound_regions(self.tcx(), &poly_trait_ref) {\n+                Some(trait_ref) => { self.accumulate_from_assoc_types(trait_ref); }\n+                None => { }\n             }\n         }\n     }\n \n+    fn accumulate_from_assoc_types(&mut self,\n+                                   trait_ref: Rc<ty::TraitRef<'tcx>>)\n+    {\n+        let trait_def_id = trait_ref.def_id;\n+        let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n+        let assoc_type_projections: Vec<_> =\n+            trait_def.associated_type_names\n+                     .iter()\n+                     .map(|&name| ty::mk_projection(self.tcx(), trait_ref.clone(), name))\n+                     .collect();\n+        let tys = match self.fully_normalize(&assoc_type_projections) {\n+            Ok(tys) => { tys }\n+            Err(ErrorReported) => { return; }\n+        };\n+        for ty in tys {\n+            self.accumulate_from_ty(ty);\n+        }\n+    }\n+\n     fn accumulate_from_object_ty(&mut self,\n                                  ty: Ty<'tcx>,\n                                  region_bound: ty::Region,\n@@ -372,25 +404,53 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n         for &r_d in &required_region_bounds {\n             // Each of these is an instance of the `'c <= 'b`\n             // constraint above\n-            self.out.push(RegionSubRegionConstraint(Some(ty), r_d, r_c));\n+            self.out.push(Implication::RegionSubRegion(Some(ty), r_d, r_c));\n+        }\n+    }\n+\n+    fn fully_normalize<T>(&self, value: &T) -> Result<T,ErrorReported>\n+        where T : TypeFoldable<'tcx> + ty::HasProjectionTypes + Clone + Repr<'tcx>\n+    {\n+        let value =\n+            traits::fully_normalize(self.infcx,\n+                                    self.closure_typer,\n+                                    traits::ObligationCause::misc(self.span, self.body_id),\n+                                    value);\n+        match value {\n+            Ok(value) => Ok(value),\n+            Err(errors) => {\n+                // I don't like reporting these errors here, but I\n+                // don't know where else to report them just now. And\n+                // I don't really expect errors to arise here\n+                // frequently. I guess the best option would be to\n+                // propagate them out.\n+                traits::report_fulfillment_errors(self.infcx, &errors);\n+                Err(ErrorReported)\n+            }\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for WfConstraint<'tcx> {\n+impl<'tcx> Repr<'tcx> for Implication<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n-            RegionSubRegionConstraint(_, ref r_a, ref r_b) => {\n-                format!(\"RegionSubRegionConstraint({}, {})\",\n+            Implication::RegionSubRegion(_, ref r_a, ref r_b) => {\n+                format!(\"RegionSubRegion({}, {})\",\n                         r_a.repr(tcx),\n                         r_b.repr(tcx))\n             }\n \n-            RegionSubGenericConstraint(_, ref r, ref p) => {\n-                format!(\"RegionSubGenericConstraint({}, {})\",\n+            Implication::RegionSubGeneric(_, ref r, ref p) => {\n+                format!(\"RegionSubGeneric({}, {})\",\n                         r.repr(tcx),\n                         p.repr(tcx))\n             }\n+\n+            Implication::Predicate(ref def_id, ref p) => {\n+                format!(\"Predicate({}, {})\",\n+                        def_id.repr(tcx),\n+                        p.repr(tcx))\n+            }\n         }\n     }\n }", "previous_filename": "src/librustc_typeck/check/regionmanip.rs"}, {"sha": "3c2888e227803cead4903225fd156d7729fa58fe", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -131,7 +131,7 @@ pub mod dropck;\n pub mod _match;\n pub mod vtable;\n pub mod writeback;\n-pub mod regionmanip;\n+pub mod implicator;\n pub mod regionck;\n pub mod coercion;\n pub mod demand;\n@@ -309,9 +309,6 @@ pub struct FnCtxt<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n-    fn tcx(&self) -> &ty::ctxt<'tcx> {\n-        self.ccx.tcx\n-    }\n     fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n         let ty = self.node_ty(id);\n         self.resolve_type_vars_or_error(&ty)\n@@ -484,7 +481,8 @@ pub fn check_item_types(ccx: &CrateCtxt) {\n fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            decl: &'tcx ast::FnDecl,\n                            body: &'tcx ast::Block,\n-                           id: ast::NodeId,\n+                           fn_id: ast::NodeId,\n+                           fn_span: Span,\n                            raw_fty: Ty<'tcx>,\n                            param_env: ty::ParameterEnvironment<'a, 'tcx>)\n {\n@@ -502,13 +500,13 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let fn_sig =\n                 inh.normalize_associated_types_in(&inh.param_env, body.span, body.id, &fn_sig);\n \n-            let fcx = check_fn(ccx, fn_ty.unsafety, id, &fn_sig,\n-                               decl, id, body, &inh);\n+            let fcx = check_fn(ccx, fn_ty.unsafety, fn_id, &fn_sig,\n+                               decl, fn_id, body, &inh);\n \n             vtable::select_all_fcx_obligations_and_apply_defaults(&fcx);\n-            upvar::closure_analyze_fn(&fcx, id, decl, body);\n+            upvar::closure_analyze_fn(&fcx, fn_id, decl, body);\n             vtable::select_all_fcx_obligations_or_error(&fcx);\n-            regionck::regionck_fn(&fcx, id, decl, body);\n+            regionck::regionck_fn(&fcx, fn_id, fn_span, decl, body);\n             writeback::resolve_type_vars_in_fn(&fcx, decl, body);\n         }\n         _ => ccx.tcx.sess.impossible_case(body.span,\n@@ -721,7 +719,7 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n       ast::ItemFn(ref decl, _, _, _, ref body) => {\n         let fn_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n         let param_env = ParameterEnvironment::for_item(ccx.tcx, it.id);\n-        check_bare_fn(ccx, &**decl, &**body, it.id, fn_pty.ty, param_env);\n+        check_bare_fn(ccx, &**decl, &**body, it.id, it.span, fn_pty.ty, param_env);\n       }\n       ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n         debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n@@ -868,6 +866,7 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                   &*method.pe_fn_decl(),\n                   &*method.pe_body(),\n                   method.id,\n+                  method.span,\n                   fty,\n                   param_env);\n }\n@@ -2050,8 +2049,8 @@ fn make_overloaded_lvalue_return_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     match method {\n         Some(method) => {\n             let ref_ty = // invoked methods have all LB regions instantiated\n-                ty::assert_no_late_bound_regions(\n-                    fcx.tcx(), &ty::ty_fn_ret(method.ty));\n+                ty::no_late_bound_regions(\n+                    fcx.tcx(), &ty::ty_fn_ret(method.ty)).unwrap();\n             match method_call {\n                 Some(method_call) => {\n                     fcx.inh.method_map.borrow_mut().insert(method_call,"}, {"sha": "4e5550a2106a98aa64cc38dfc118e1e97af829b8", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 74, "deletions": 54, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -85,7 +85,7 @@\n use astconv::AstConv;\n use check::dropck;\n use check::FnCtxt;\n-use check::regionmanip;\n+use check::implicator;\n use check::vtable;\n use middle::def;\n use middle::mem_categorization as mc;\n@@ -97,12 +97,12 @@ use middle::infer::{self, GenericKind};\n use middle::pat_util;\n use util::ppaux::{ty_to_string, Repr};\n \n+use std::mem;\n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n-use self::RepeatingScope::Repeating;\n use self::SubjectNode::Subject;\n \n // a variation on try that just returns unit\n@@ -114,7 +114,7 @@ macro_rules! ignore_err {\n // PUBLIC ENTRY POINTS\n \n pub fn regionck_expr(fcx: &FnCtxt, e: &ast::Expr) {\n-    let mut rcx = Rcx::new(fcx, Repeating(e.id), Subject(e.id));\n+    let mut rcx = Rcx::new(fcx, RepeatingScope(e.id), e.id, Subject(e.id));\n     if fcx.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n         rcx.visit_expr(e);\n@@ -124,22 +124,23 @@ pub fn regionck_expr(fcx: &FnCtxt, e: &ast::Expr) {\n }\n \n pub fn regionck_item(fcx: &FnCtxt, item: &ast::Item) {\n-    let mut rcx = Rcx::new(fcx, Repeating(item.id), Subject(item.id));\n+    let mut rcx = Rcx::new(fcx, RepeatingScope(item.id), item.id, Subject(item.id));\n     rcx.visit_region_obligations(item.id);\n     rcx.resolve_regions_and_report_errors();\n }\n \n-pub fn regionck_fn(fcx: &FnCtxt, id: ast::NodeId, decl: &ast::FnDecl, blk: &ast::Block) {\n-    let mut rcx = Rcx::new(fcx, Repeating(blk.id), Subject(id));\n+pub fn regionck_fn(fcx: &FnCtxt,\n+                   fn_id: ast::NodeId,\n+                   fn_span: Span,\n+                   decl: &ast::FnDecl,\n+                   blk: &ast::Block) {\n+    debug!(\"regionck_fn(id={})\", fn_id);\n+    let mut rcx = Rcx::new(fcx, RepeatingScope(blk.id), blk.id, Subject(fn_id));\n     if fcx.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n-        rcx.visit_fn_body(id, decl, blk);\n+        rcx.visit_fn_body(fn_id, decl, blk, fn_span);\n     }\n \n-    // Region checking a fn can introduce new trait obligations,\n-    // particularly around closure bounds.\n-    vtable::select_all_fcx_obligations_or_error(fcx);\n-\n     rcx.resolve_regions_and_report_errors();\n }\n \n@@ -148,7 +149,7 @@ pub fn regionck_fn(fcx: &FnCtxt, id: ast::NodeId, decl: &ast::FnDecl, blk: &ast:\n pub fn regionck_ensure_component_tys_wf<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   span: Span,\n                                                   component_tys: &[Ty<'tcx>]) {\n-    let mut rcx = Rcx::new(fcx, Repeating(0), SubjectNode::None);\n+    let mut rcx = Rcx::new(fcx, RepeatingScope(0), 0, SubjectNode::None);\n     for &component_ty in component_tys {\n         // Check that each type outlives the empty region. Since the\n         // empty region is a subregion of all others, this can't fail\n@@ -167,6 +168,9 @@ pub struct Rcx<'a, 'tcx: 'a> {\n \n     region_bound_pairs: Vec<(ty::Region, GenericKind<'tcx>)>,\n \n+    // id of innermost fn body id\n+    body_id: ast::NodeId,\n+\n     // id of innermost fn or loop\n     repeating_scope: ast::NodeId,\n \n@@ -189,16 +193,18 @@ fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n     }\n }\n \n-pub enum RepeatingScope { Repeating(ast::NodeId) }\n+struct RepeatingScope(ast::NodeId);\n pub enum SubjectNode { Subject(ast::NodeId), None }\n \n impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     pub fn new(fcx: &'a FnCtxt<'a, 'tcx>,\n                initial_repeating_scope: RepeatingScope,\n+               initial_body_id: ast::NodeId,\n                subject: SubjectNode) -> Rcx<'a, 'tcx> {\n-        let Repeating(initial_repeating_scope) = initial_repeating_scope;\n+        let RepeatingScope(initial_repeating_scope) = initial_repeating_scope;\n         Rcx { fcx: fcx,\n               repeating_scope: initial_repeating_scope,\n+              body_id: initial_body_id,\n               subject: subject,\n               region_bound_pairs: Vec::new()\n         }\n@@ -208,10 +214,12 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         self.fcx.ccx.tcx\n     }\n \n-    pub fn set_repeating_scope(&mut self, scope: ast::NodeId) -> ast::NodeId {\n-        let old_scope = self.repeating_scope;\n-        self.repeating_scope = scope;\n-        old_scope\n+    fn set_body_id(&mut self, body_id: ast::NodeId) -> ast::NodeId {\n+        mem::replace(&mut self.body_id, body_id)\n+    }\n+\n+    fn set_repeating_scope(&mut self, scope: ast::NodeId) -> ast::NodeId {\n+        mem::replace(&mut self.repeating_scope, scope)\n     }\n \n     /// Try to resolve the type for the given node, returning t_err if an error results.  Note that\n@@ -269,9 +277,11 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     fn visit_fn_body(&mut self,\n                      id: ast::NodeId,\n                      fn_decl: &ast::FnDecl,\n-                     body: &ast::Block)\n+                     body: &ast::Block,\n+                     span: Span)\n     {\n         // When we enter a function, we can derive\n+        debug!(\"visit_fn_body(id={})\", id);\n \n         let fn_sig_map = self.fcx.inh.fn_sig_map.borrow();\n         let fn_sig = match fn_sig_map.get(&id) {\n@@ -283,17 +293,24 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         };\n \n         let len = self.region_bound_pairs.len();\n-        self.relate_free_regions(&fn_sig[], body.id);\n+        let old_body_id = self.set_body_id(body.id);\n+        self.relate_free_regions(&fn_sig[], body.id, span);\n         link_fn_args(self, CodeExtent::from_node_id(body.id), &fn_decl.inputs[]);\n         self.visit_block(body);\n         self.visit_region_obligations(body.id);\n         self.region_bound_pairs.truncate(len);\n+        self.set_body_id(old_body_id);\n     }\n \n     fn visit_region_obligations(&mut self, node_id: ast::NodeId)\n     {\n         debug!(\"visit_region_obligations: node_id={}\", node_id);\n \n+        // region checking can introduce new pending obligations\n+        // which, when processed, might generate new region\n+        // obligations. So make sure we process those.\n+        vtable::select_all_fcx_obligations_or_error(self.fcx);\n+\n         // Make a copy of the region obligations vec because we'll need\n         // to be able to borrow the fulfillment-cx below when projecting.\n         let region_obligations =\n@@ -326,7 +343,8 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     /// Tests: `src/test/compile-fail/regions-free-region-ordering-*.rs`\n     fn relate_free_regions(&mut self,\n                            fn_sig_tys: &[Ty<'tcx>],\n-                           body_id: ast::NodeId) {\n+                           body_id: ast::NodeId,\n+                           span: Span) {\n         debug!(\"relate_free_regions >>\");\n         let tcx = self.tcx();\n \n@@ -335,25 +353,22 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             debug!(\"relate_free_regions(t={})\", ty.repr(tcx));\n             let body_scope = CodeExtent::from_node_id(body_id);\n             let body_scope = ty::ReScope(body_scope);\n-            let constraints =\n-                regionmanip::region_wf_constraints(\n-                    tcx,\n-                    ty,\n-                    body_scope);\n-            for constraint in &constraints {\n-                debug!(\"constraint: {}\", constraint.repr(tcx));\n-                match *constraint {\n-                    regionmanip::RegionSubRegionConstraint(_,\n-                                              ty::ReFree(free_a),\n-                                              ty::ReFree(free_b)) => {\n+            let implications = implicator::implications(self.fcx.infcx(), self.fcx, body_id,\n+                                                        ty, body_scope, span);\n+            for implication in implications {\n+                debug!(\"implication: {}\", implication.repr(tcx));\n+                match implication {\n+                    implicator::Implication::RegionSubRegion(_,\n+                                                             ty::ReFree(free_a),\n+                                                             ty::ReFree(free_b)) => {\n                         tcx.region_maps.relate_free_regions(free_a, free_b);\n                     }\n-                    regionmanip::RegionSubRegionConstraint(_,\n-                                              ty::ReFree(free_a),\n-                                              ty::ReInfer(ty::ReVar(vid_b))) => {\n+                    implicator::Implication::RegionSubRegion(_,\n+                                                             ty::ReFree(free_a),\n+                                                             ty::ReInfer(ty::ReVar(vid_b))) => {\n                         self.fcx.inh.infcx.add_given(free_a, vid_b);\n                     }\n-                    regionmanip::RegionSubRegionConstraint(..) => {\n+                    implicator::Implication::RegionSubRegion(..) => {\n                         // In principle, we could record (and take\n                         // advantage of) every relationship here, but\n                         // we are also free not to -- it simply means\n@@ -364,12 +379,13 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                         // relationship that arises here, but\n                         // presently we do not.)\n                     }\n-                    regionmanip::RegionSubGenericConstraint(_, r_a, ref generic_b) => {\n-                        debug!(\"RegionSubGenericConstraint: {} <= {}\",\n+                    implicator::Implication::RegionSubGeneric(_, r_a, ref generic_b) => {\n+                        debug!(\"RegionSubGeneric: {} <= {}\",\n                                r_a.repr(tcx), generic_b.repr(tcx));\n \n                         self.region_bound_pairs.push((r_a, generic_b.clone()));\n                     }\n+                    implicator::Implication::Predicate(..) => { }\n                 }\n             }\n         }\n@@ -400,8 +416,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Rcx<'a, 'tcx> {\n     // regions, until regionck, as described in #3238.\n \n     fn visit_fn(&mut self, _fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n-                b: &'v ast::Block, _s: Span, id: ast::NodeId) {\n-        self.visit_fn_body(id, fd, b)\n+                b: &'v ast::Block, span: Span, id: ast::NodeId) {\n+        self.visit_fn_body(id, fd, b, span)\n     }\n \n     fn visit_item(&mut self, i: &ast::Item) { visit_item(self, i); }\n@@ -628,7 +644,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                     constrain_call(rcx, expr, Some(&**base),\n                                    None::<ast::Expr>.iter(), true);\n                     let fn_ret = // late-bound regions in overloaded method calls are instantiated\n-                        ty::assert_no_late_bound_regions(rcx.tcx(), &ty::ty_fn_ret(method.ty));\n+                        ty::no_late_bound_regions(rcx.tcx(), &ty::ty_fn_ret(method.ty)).unwrap();\n                     fn_ret.unwrap()\n                 }\n                 None => rcx.resolve_node_type(base.id)\n@@ -975,7 +991,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 // was applied on the base type, as that is always the case.\n                 let fn_sig = ty::ty_fn_sig(method.ty);\n                 let fn_sig = // late-bound regions should have been instantiated\n-                    ty::assert_no_late_bound_regions(rcx.tcx(), fn_sig);\n+                    ty::no_late_bound_regions(rcx.tcx(), fn_sig).unwrap();\n                 let self_ty = fn_sig.inputs[0];\n                 let (m, r) = match self_ty.sty {\n                     ty::ty_rptr(r, ref m) => (m.mutbl, r),\n@@ -1481,28 +1497,32 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n            ty.repr(rcx.tcx()),\n            region.repr(rcx.tcx()));\n \n-    let constraints =\n-        regionmanip::region_wf_constraints(\n-            rcx.tcx(),\n-            ty,\n-            region);\n-    for constraint in &constraints {\n-        debug!(\"constraint: {}\", constraint.repr(rcx.tcx()));\n-        match *constraint {\n-            regionmanip::RegionSubRegionConstraint(None, r_a, r_b) => {\n+    let implications = implicator::implications(rcx.fcx.infcx(), rcx.fcx, rcx.body_id,\n+                                                ty, region, origin.span());\n+    for implication in implications {\n+        debug!(\"implication: {}\", implication.repr(rcx.tcx()));\n+        match implication {\n+            implicator::Implication::RegionSubRegion(None, r_a, r_b) => {\n                 rcx.fcx.mk_subr(origin.clone(), r_a, r_b);\n             }\n-            regionmanip::RegionSubRegionConstraint(Some(ty), r_a, r_b) => {\n+            implicator::Implication::RegionSubRegion(Some(ty), r_a, r_b) => {\n                 let o1 = infer::ReferenceOutlivesReferent(ty, origin.span());\n                 rcx.fcx.mk_subr(o1, r_a, r_b);\n             }\n-            regionmanip::RegionSubGenericConstraint(None, r_a, ref generic_b) => {\n+            implicator::Implication::RegionSubGeneric(None, r_a, ref generic_b) => {\n                 generic_must_outlive(rcx, origin.clone(), r_a, generic_b);\n             }\n-            regionmanip::RegionSubGenericConstraint(Some(ty), r_a, ref generic_b) => {\n+            implicator::Implication::RegionSubGeneric(Some(ty), r_a, ref generic_b) => {\n                 let o1 = infer::ReferenceOutlivesReferent(ty, origin.span());\n                 generic_must_outlive(rcx, o1, r_a, generic_b);\n             }\n+            implicator::Implication::Predicate(def_id, predicate) => {\n+                let cause = traits::ObligationCause::new(origin.span(),\n+                                                         rcx.body_id,\n+                                                         traits::ItemObligation(def_id));\n+                let obligation = traits::Obligation::new(cause, predicate);\n+                rcx.fcx.register_predicate(obligation);\n+            }\n         }\n     }\n }"}, {"sha": "d124282d391281c65137ec6c2a1cccad466a3ecc", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -97,14 +97,10 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 self.check_item_type(item);\n             }\n             ast::ItemStruct(ref struct_def, _) => {\n-                self.check_type_defn(item, |fcx| {\n-                    vec![struct_variant(fcx, &**struct_def)]\n-                });\n+                self.check_type_defn(item, |fcx| vec![struct_variant(fcx, &**struct_def)]);\n             }\n             ast::ItemEnum(ref enum_def, _) => {\n-                self.check_type_defn(item, |fcx| {\n-                    enum_variants(fcx, enum_def)\n-                });\n+                self.check_type_defn(item, |fcx| enum_variants(fcx, enum_def));\n             }\n             ast::ItemTrait(..) => {\n                 let trait_predicates =\n@@ -578,8 +574,8 @@ fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     // the regions in the argument types come from the\n                     // enum def'n, and hence will all be early bound\n                     let arg_tys =\n-                        ty::assert_no_late_bound_regions(\n-                            fcx.tcx(), &ty::ty_fn_args(ctor_ty));\n+                        ty::no_late_bound_regions(\n+                            fcx.tcx(), &ty::ty_fn_args(ctor_ty)).unwrap();\n                     AdtVariant {\n                         fields: args.iter().enumerate().map(|(index, arg)| {\n                             let arg_ty = arg_tys[index];"}, {"sha": "fa26c9c54c8f4c2a6450a8ba435f8e4f8cf64b94", "filename": "src/test/compile-fail/regions-assoc-type-in-supertrait-outlives-container.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-in-supertrait-outlives-container.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-in-supertrait-outlives-container.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-in-supertrait-outlives-container.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are imposing the requirement that every associated\n+// type of a bound that appears in the where clause on a struct must\n+// outlive the location in which the type appears, even when the\n+// associted type is in a supertype. Issue #22246.\n+\n+#![allow(dead_code)]\n+\n+use std::mem::transmute;\n+use std::ops::Deref;\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub trait TheTrait {\n+    type TheAssocType;\n+\n+    fn dummy(&self) { }\n+}\n+\n+pub trait TheSubTrait : TheTrait {\n+}\n+\n+pub struct TheType<'b> {\n+    m: [fn(&'b()); 0]\n+}\n+\n+impl<'b> TheTrait for TheType<'b> {\n+    type TheAssocType = &'b ();\n+}\n+\n+impl<'b> TheSubTrait for TheType<'b> {\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub struct WithAssoc<T:TheSubTrait> {\n+    m: [T; 0]\n+}\n+\n+fn with_assoc<'a,'b>() {\n+    // For this type to be valid, the rules require that all\n+    // associated types of traits that appear in `WithAssoc` must\n+    // outlive 'a. In this case, that means TheType<'b>::TheAssocType,\n+    // which is &'b (), must outlive 'a.\n+\n+    let _: &'a WithAssoc<TheType<'b>> = loop { }; //~ ERROR cannot infer\n+}\n+\n+fn main() {\n+}"}, {"sha": "7d955065ff45519a3af62c32a58fe8c0d95bd44e", "filename": "src/test/compile-fail/regions-assoc-type-outlives-container-hrtb.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container-hrtb.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that structs with higher-ranked where clauses don't generate\n+// \"outlives\" requirements. Issue #22246.\n+\n+#![allow(dead_code)]\n+#![feature(rustc_attrs)]\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub trait TheTrait<'b> {\n+    type TheAssocType;\n+\n+    fn dummy(&'b self) { }\n+}\n+\n+pub struct TheType<'b> {\n+    m: [fn(&'b()); 0]\n+}\n+\n+impl<'a,'b> TheTrait<'a> for TheType<'b> {\n+    type TheAssocType = &'b ();\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub struct WithHrAssoc<T>\n+    where for<'a> T : TheTrait<'a>\n+{\n+    m: [T; 0]\n+}\n+\n+fn with_assoc<'a,'b>() {\n+    // We get no error here because the where clause has a higher-ranked assoc type,\n+    // which could not be projected from.\n+\n+    let _: &'a WithHrAssoc<TheType<'b>> = loop { };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub trait TheSubTrait : for<'a> TheTrait<'a> {\n+}\n+\n+impl<'b> TheSubTrait for TheType<'b> { }\n+\n+pub struct WithHrAssocSub<T>\n+    where T : TheSubTrait\n+{\n+    m: [T; 0]\n+}\n+\n+fn with_assoc_sub<'a,'b>() {\n+    // Same here, because although the where clause is not HR, it\n+    // extends a trait in a HR way.\n+\n+    let _: &'a WithHrAssocSub<TheType<'b>> = loop { };\n+}\n+\n+#[rustc_error]\n+fn main() { //~ ERROR compilation successful\n+}"}, {"sha": "6ee65fbdf919bb97ac37c44d9ae93fd520d1bccc", "filename": "src/test/compile-fail/regions-assoc-type-outlives-container-wc.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container-wc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container-wc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container-wc.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are imposing the requirement that every associated\n+// type of a bound that appears in the where clause on a struct must\n+// outlive the location in which the type appears, even when the\n+// constraint is in a where clause not a bound. Issue #22246.\n+\n+#![allow(dead_code)]\n+\n+use std::mem::transmute;\n+use std::ops::Deref;\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub trait TheTrait {\n+    type TheAssocType;\n+\n+    fn dummy(&self) { }\n+}\n+\n+pub struct TheType<'b> {\n+    m: [fn(&'b()); 0]\n+}\n+\n+impl<'b> TheTrait for TheType<'b> {\n+    type TheAssocType = &'b ();\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub struct WithAssoc<T> where T : TheTrait {\n+    m: [T; 0]\n+}\n+\n+fn with_assoc<'a,'b>() {\n+    // For this type to be valid, the rules require that all\n+    // associated types of traits that appear in `WithAssoc` must\n+    // outlive 'a. In this case, that means TheType<'b>::TheAssocType,\n+    // which is &'b (), must outlive 'a.\n+\n+    let _: &'a WithAssoc<TheType<'b>> = loop { }; //~ ERROR cannot infer\n+}\n+\n+fn main() {\n+}"}, {"sha": "49a0726fa3b7be3acca1abefcf42f53c29ec2966", "filename": "src/test/compile-fail/regions-assoc-type-outlives-container.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are imposing the requirement that every associated\n+// type of a bound that appears in the where clause on a struct must\n+// outlive the location in which the type appears. Issue #22246.\n+\n+#![allow(dead_code)]\n+\n+use std::mem::transmute;\n+use std::ops::Deref;\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub trait TheTrait {\n+    type TheAssocType;\n+\n+    fn dummy(&self) { }\n+}\n+\n+pub struct TheType<'b> {\n+    m: [fn(&'b()); 0]\n+}\n+\n+impl<'b> TheTrait for TheType<'b> {\n+    type TheAssocType = &'b ();\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub struct WithAssoc<T:TheTrait> {\n+    m: [T; 0]\n+}\n+\n+pub struct WithoutAssoc<T> {\n+    m: [T; 0]\n+}\n+\n+fn with_assoc<'a,'b>() {\n+    // For this type to be valid, the rules require that all\n+    // associated types of traits that appear in `WithAssoc` must\n+    // outlive 'a. In this case, that means TheType<'b>::TheAssocType,\n+    // which is &'b (), must outlive 'a.\n+\n+    let _: &'a WithAssoc<TheType<'b>> = loop { }; //~ ERROR cannot infer\n+}\n+\n+fn with_assoc1<'a,'b>() where 'b : 'a {\n+    // For this type to be valid, the rules require that all\n+    // associated types of traits that appear in `WithAssoc` must\n+    // outlive 'a. In this case, that means TheType<'b>::TheAssocType,\n+    // which is &'b (), must outlive 'a, so 'b : 'a must hold, and\n+    // that is in the where clauses, so we're fine.\n+\n+    let _: &'a WithAssoc<TheType<'b>> = loop { };\n+}\n+\n+fn without_assoc<'a,'b>() {\n+    // Here there are no associated types and the `'b` appearing in\n+    // `TheType<'b>` is purely covariant, so there is no requirement\n+    // that `'b:'a` holds.\n+\n+    let _: &'a WithoutAssoc<TheType<'b>> = loop { };\n+}\n+\n+fn call_with_assoc<'a,'b>() {\n+    // As `with_assoc`, but just checking that we impose the same rule\n+    // on the value supplied for the type argument, even when there is\n+    // no data.\n+\n+    call::<&'a WithAssoc<TheType<'b>>>();\n+    //~^ ERROR cannot infer\n+}\n+\n+fn call_without_assoc<'a,'b>() {\n+    // As `without_assoc`, but in a distinct scenario.\n+\n+    call::<&'a WithoutAssoc<TheType<'b>>>();\n+}\n+\n+fn call<T>() { }\n+\n+fn main() {\n+}"}, {"sha": "f5c34d6b34e9d8761be05546615cb4056c9ab21e", "filename": "src/test/run-pass/regions-issue-22246.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Ftest%2Frun-pass%2Fregions-issue-22246.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Ftest%2Frun-pass%2Fregions-issue-22246.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-issue-22246.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #22246 -- we should be able to deduce\n+// that `&'a B::Owned` implies that `B::Owned : 'a`.\n+\n+#![allow(dead_code)]\n+\n+use std::ops::Deref;\n+\n+pub trait ToOwned {\n+    type Owned: Borrow<Self>;\n+    fn to_owned(&self) -> Self::Owned;\n+}\n+\n+pub trait Borrow<Borrowed> {\n+    fn borrow(&self) -> &Borrowed;\n+}\n+\n+pub struct Foo<B:ToOwned> {\n+    owned: B::Owned\n+}\n+\n+fn foo<B:ToOwned>(this: &Foo<B>) -> &B {\n+    this.owned.borrow()\n+}\n+\n+fn main() { }"}, {"sha": "9cdcf4945d8ba6d52af24171c1bfb7ba26ff89f1", "filename": "src/test/run-pass/traits-issue-22110.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Ftest%2Frun-pass%2Ftraits-issue-22110.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22992358bc74956f53b1a2ab99ae245cd3ca5550/src%2Ftest%2Frun-pass%2Ftraits-issue-22110.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-issue-22110.rs?ref=22992358bc74956f53b1a2ab99ae245cd3ca5550", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test an issue where we reported ambiguity between the where-clause\n+// and the blanket impl. The only important thing is that compilation\n+// succeeds here. Issue #22110.\n+\n+#![allow(dead_code)]\n+\n+trait Foo<A> {\n+    fn foo(&self, a: A);\n+}\n+\n+impl<A,F:Fn(A)> Foo<A> for F {\n+    fn foo(&self, _: A) { }\n+}\n+\n+fn baz<A,F:for<'a> Foo<(&'a A,)>>(_: F) { }\n+\n+fn components<T,A>(t: fn(&A))\n+    where fn(&A) : for<'a> Foo<(&'a A,)>,\n+{\n+    baz(t)\n+}\n+\n+fn main() {\n+}"}]}