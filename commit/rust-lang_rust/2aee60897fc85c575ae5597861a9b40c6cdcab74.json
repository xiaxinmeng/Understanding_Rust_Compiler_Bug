{"sha": "2aee60897fc85c575ae5597861a9b40c6cdcab74", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhZWU2MDg5N2ZjODVjNTc1YWU1NTk3ODYxYTliNDBjNmNkY2FiNzQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-26T07:39:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-26T07:39:00Z"}, "message": "Rollup merge of #73102 - petrochenkov:flatgroup, r=Aaron1011\n\nproc_macro: Stop flattening groups with dummy spans\n\nReduce the scope of the hack described in https://github.com/rust-lang/rust/issues/72545#issuecomment-640276791.\n\nWe still pass AST fragments to attribute and derive macros as single nonterminal tokens rather than as tokens streams, but now use a precise flag instead of the span-based heuristic that could do lead to incorrect behavior in unrelated cases.\n\nhttps://github.com/rust-lang/rust/pull/73345 attempts to fully resolve this issue, but there are some compatibility issues to be addressed.", "tree": {"sha": "d75f2c574ab8d4490243d65720ccd54da881ddf7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d75f2c574ab8d4490243d65720ccd54da881ddf7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2aee60897fc85c575ae5597861a9b40c6cdcab74", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe9aYUCRBK7hj4Ov3rIwAAdHIIADPIhFMcBL2AldGpNBZw3Vlt\nIRRjNA++DXOC9ZMSAdAHxDiuHwZ4WnndMLSP8LRR47Co37sXY+X5jDhSEpVujc1b\n7Igga4arBfLT9k74Sb7dhBCI9GJOtXag5O26rtf2iZBZ+/awkM8DvbU09MWZ+GwS\nY8TV3B5p85pEAiJoWzwhBNYXS0e6cYTBvypsDVN+fGCfrxkSqulPRF0DDcxQpoQn\n2WgZ8wFN/49yn0rhbActBw2r79uVNOXNHuBMQIKAOWlyoo52diRUX5bpsUMtlPPP\nZ+lGVCrLU8UcmOlFOaU9QiwU6tkRaSKwU2s2n8roB07NaPjNpEFKy95PhC89RqU=\n=Ew4M\n-----END PGP SIGNATURE-----\n", "payload": "tree d75f2c574ab8d4490243d65720ccd54da881ddf7\nparent a25fbb971095391667e2ec1f05d0d579adb7f3e8\nparent 77b0ed70b3658cb7ba7b18f68519b3baf953213b\nauthor Manish Goregaokar <manishsmail@gmail.com> 1593157140 -0700\ncommitter GitHub <noreply@github.com> 1593157140 -0700\n\nRollup merge of #73102 - petrochenkov:flatgroup, r=Aaron1011\n\nproc_macro: Stop flattening groups with dummy spans\n\nReduce the scope of the hack described in https://github.com/rust-lang/rust/issues/72545#issuecomment-640276791.\n\nWe still pass AST fragments to attribute and derive macros as single nonterminal tokens rather than as tokens streams, but now use a precise flag instead of the span-based heuristic that could do lead to incorrect behavior in unrelated cases.\n\nhttps://github.com/rust-lang/rust/pull/73345 attempts to fully resolve this issue, but there are some compatibility issues to be addressed.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2aee60897fc85c575ae5597861a9b40c6cdcab74", "html_url": "https://github.com/rust-lang/rust/commit/2aee60897fc85c575ae5597861a9b40c6cdcab74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2aee60897fc85c575ae5597861a9b40c6cdcab74/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a25fbb971095391667e2ec1f05d0d579adb7f3e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a25fbb971095391667e2ec1f05d0d579adb7f3e8", "html_url": "https://github.com/rust-lang/rust/commit/a25fbb971095391667e2ec1f05d0d579adb7f3e8"}, {"sha": "77b0ed70b3658cb7ba7b18f68519b3baf953213b", "url": "https://api.github.com/repos/rust-lang/rust/commits/77b0ed70b3658cb7ba7b18f68519b3baf953213b", "html_url": "https://github.com/rust-lang/rust/commit/77b0ed70b3658cb7ba7b18f68519b3baf953213b"}], "stats": {"total": 126, "additions": 76, "deletions": 50}, "files": [{"sha": "6c128f0176f6699a21e625f105ce82e780079946", "filename": "src/librustc_ast/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fattr%2Fmod.rs?ref=2aee60897fc85c575ae5597861a9b40c6cdcab74", "patch": "@@ -475,7 +475,7 @@ impl MetaItem {\n                 let span = span.with_hi(segments.last().unwrap().ident.span.hi());\n                 Path { span, segments }\n             }\n-            Some(TokenTree::Token(Token { kind: token::Interpolated(nt), .. })) => match *nt {\n+            Some(TokenTree::Token(Token { kind: token::Interpolated(nt, _), .. })) => match *nt {\n                 token::Nonterminal::NtMeta(ref item) => return item.meta(item.path.span),\n                 token::Nonterminal::NtPath(ref path) => path.clone(),\n                 _ => return None,"}, {"sha": "0cbf9020306609fa82ae7e5c34831a29968ab690", "filename": "src/librustc_ast/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_ast%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_ast%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fmut_visit.rs?ref=2aee60897fc85c575ae5597861a9b40c6cdcab74", "patch": "@@ -656,7 +656,7 @@ pub fn noop_visit_token<T: MutVisitor>(t: &mut Token, vis: &mut T) {\n             *span = ident.span;\n             return; // Avoid visiting the span for the second time.\n         }\n-        token::Interpolated(nt) => {\n+        token::Interpolated(nt, _) => {\n             let mut nt = Lrc::make_mut(nt);\n             vis.visit_interpolated(&mut nt);\n         }"}, {"sha": "89be3e6e212ccb4d9b6a2335795047d8b98c745e", "filename": "src/librustc_ast/token.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_ast%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_ast%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftoken.rs?ref=2aee60897fc85c575ae5597861a9b40c6cdcab74", "patch": "@@ -182,6 +182,15 @@ fn ident_can_begin_type(name: Symbol, span: Span, is_raw: bool) -> bool {\n             .contains(&name)\n }\n \n+/// A hack used to pass AST fragments to attribute and derive macros\n+/// as a single nonterminal token instead of a token stream.\n+/// FIXME: It needs to be removed, but there are some compatibility issues (see #73345).\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+pub enum FlattenGroup {\n+    Yes,\n+    No,\n+}\n+\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum TokenKind {\n     /* Expression-operator symbols. */\n@@ -236,7 +245,7 @@ pub enum TokenKind {\n     /// treat regular and interpolated lifetime identifiers in the same way.\n     Lifetime(Symbol),\n \n-    Interpolated(Lrc<Nonterminal>),\n+    Interpolated(Lrc<Nonterminal>, FlattenGroup),\n \n     // Can be expanded into several tokens.\n     /// A doc comment.\n@@ -343,7 +352,7 @@ impl Token {\n     /// if they keep spans or perform edition checks.\n     pub fn uninterpolated_span(&self) -> Span {\n         match &self.kind {\n-            Interpolated(nt) => nt.span(),\n+            Interpolated(nt, _) => nt.span(),\n             _ => self.span,\n         }\n     }\n@@ -382,7 +391,7 @@ impl Token {\n             ModSep                            | // global path\n             Lifetime(..)                      | // labeled loop\n             Pound                             => true, // expression attributes\n-            Interpolated(ref nt) => match **nt {\n+            Interpolated(ref nt, _) => match **nt {\n                 NtLiteral(..) |\n                 NtExpr(..)    |\n                 NtBlock(..)   |\n@@ -408,7 +417,7 @@ impl Token {\n             Lifetime(..)                | // lifetime bound in trait object\n             Lt | BinOp(Shl)             | // associated path\n             ModSep                      => true, // global path\n-            Interpolated(ref nt) => match **nt {\n+            Interpolated(ref nt, _) => match **nt {\n                 NtTy(..) | NtPath(..) => true,\n                 _ => false,\n             },\n@@ -420,7 +429,7 @@ impl Token {\n     pub fn can_begin_const_arg(&self) -> bool {\n         match self.kind {\n             OpenDelim(Brace) => true,\n-            Interpolated(ref nt) => match **nt {\n+            Interpolated(ref nt, _) => match **nt {\n                 NtExpr(..) | NtBlock(..) | NtLiteral(..) => true,\n                 _ => false,\n             },\n@@ -455,7 +464,7 @@ impl Token {\n         match self.uninterpolate().kind {\n             Literal(..) | BinOp(Minus) => true,\n             Ident(name, false) if name.is_bool_lit() => true,\n-            Interpolated(ref nt) => match &**nt {\n+            Interpolated(ref nt, _) => match &**nt {\n                 NtLiteral(_) => true,\n                 NtExpr(e) => match &e.kind {\n                     ast::ExprKind::Lit(_) => true,\n@@ -476,7 +485,7 @@ impl Token {\n     // otherwise returns the original token.\n     pub fn uninterpolate(&self) -> Cow<'_, Token> {\n         match &self.kind {\n-            Interpolated(nt) => match **nt {\n+            Interpolated(nt, _) => match **nt {\n                 NtIdent(ident, is_raw) => {\n                     Cow::Owned(Token::new(Ident(ident.name, is_raw), ident.span))\n                 }\n@@ -523,7 +532,7 @@ impl Token {\n \n     /// Returns `true` if the token is an interpolated path.\n     fn is_path(&self) -> bool {\n-        if let Interpolated(ref nt) = self.kind {\n+        if let Interpolated(ref nt, _) = self.kind {\n             if let NtPath(..) = **nt {\n                 return true;\n             }\n@@ -535,7 +544,7 @@ impl Token {\n     /// That is, is this a pre-parsed expression dropped into the token stream\n     /// (which happens while parsing the result of macro expansion)?\n     pub fn is_whole_expr(&self) -> bool {\n-        if let Interpolated(ref nt) = self.kind {\n+        if let Interpolated(ref nt, _) = self.kind {\n             if let NtExpr(_) | NtLiteral(_) | NtPath(_) | NtIdent(..) | NtBlock(_) = **nt {\n                 return true;\n             }\n@@ -546,7 +555,7 @@ impl Token {\n \n     // Is the token an interpolated block (`$b:block`)?\n     pub fn is_whole_block(&self) -> bool {\n-        if let Interpolated(ref nt) = self.kind {\n+        if let Interpolated(ref nt, _) = self.kind {\n             if let NtBlock(..) = **nt {\n                 return true;\n             }\n@@ -724,7 +733,7 @@ impl Token {\n                 b == d && (a == c || a == kw::DollarCrate || c == kw::DollarCrate)\n             }\n \n-            (&Interpolated(_), &Interpolated(_)) => false,\n+            (&Interpolated(..), &Interpolated(..)) => false,\n \n             _ => panic!(\"forgot to add a token?\"),\n         }"}, {"sha": "ea59f867c59d24aaf7241c1284d4a50b48fda602", "filename": "src/librustc_ast/util/literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_ast%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_ast%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Futil%2Fliteral.rs?ref=2aee60897fc85c575ae5597861a9b40c6cdcab74", "patch": "@@ -205,7 +205,7 @@ impl Lit {\n                 token::Lit::new(token::Bool, name, None)\n             }\n             token::Literal(lit) => lit,\n-            token::Interpolated(ref nt) => {\n+            token::Interpolated(ref nt, _) => {\n                 if let token::NtExpr(expr) | token::NtLiteral(expr) = &**nt {\n                     if let ast::ExprKind::Lit(lit) = &expr.kind {\n                         return Ok(lit.clone());"}, {"sha": "38a4dfa7a77b6be13d7d57cbf62ca0c7f4179769", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=2aee60897fc85c575ae5597861a9b40c6cdcab74", "patch": "@@ -1027,7 +1027,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     fn lower_token(&mut self, token: Token) -> TokenStream {\n         match token.kind {\n-            token::Interpolated(nt) => {\n+            token::Interpolated(nt, _) => {\n                 let tts = (self.nt_to_tokenstream)(&nt, &self.sess.parse_sess, token.span);\n                 self.lower_token_stream(tts)\n             }"}, {"sha": "c0c8b5dda51825f5da54fdf0cbe5c0ff38748f82", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=2aee60897fc85c575ae5597861a9b40c6cdcab74", "patch": "@@ -266,7 +266,7 @@ fn token_kind_to_string_ext(tok: &TokenKind, convert_dollar_crate: Option<Span>)\n         token::Shebang(s) => format!(\"/* shebang: {}*/\", s),\n         token::Unknown(s) => s.to_string(),\n \n-        token::Interpolated(ref nt) => nonterminal_to_string(nt),\n+        token::Interpolated(ref nt, _) => nonterminal_to_string(nt),\n     }\n }\n "}, {"sha": "d4c756c9ec7f877dc356d675439eec8fd0fa4143", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=2aee60897fc85c575ae5597861a9b40c6cdcab74", "patch": "@@ -4,7 +4,7 @@ use crate::module::DirectoryOwnership;\n use rustc_ast::ast::{self, Attribute, NodeId, PatKind};\n use rustc_ast::mut_visit::{self, MutVisitor};\n use rustc_ast::ptr::P;\n-use rustc_ast::token;\n+use rustc_ast::token::{self, FlattenGroup};\n use rustc_ast::tokenstream::{self, TokenStream, TokenTree};\n use rustc_ast::visit::{AssocCtxt, Visitor};\n use rustc_attr::{self as attr, Deprecation, HasAttrs, Stability};\n@@ -142,7 +142,7 @@ impl Annotatable {\n             | Annotatable::StructField(..)\n             | Annotatable::Variant(..) => panic!(\"unexpected annotatable\"),\n         };\n-        TokenTree::token(token::Interpolated(Lrc::new(nt)), DUMMY_SP).into()\n+        TokenTree::token(token::Interpolated(Lrc::new(nt), FlattenGroup::Yes), DUMMY_SP).into()\n     }\n \n     pub fn expect_item(self) -> P<ast::Item> {\n@@ -374,7 +374,7 @@ where\n         impl MutVisitor for AvoidInterpolatedIdents {\n             fn visit_tt(&mut self, tt: &mut tokenstream::TokenTree) {\n                 if let tokenstream::TokenTree::Token(token) = tt {\n-                    if let token::Interpolated(nt) = &token.kind {\n+                    if let token::Interpolated(nt, _) = &token.kind {\n                         if let token::NtIdent(ident, is_raw) = **nt {\n                             *tt = tokenstream::TokenTree::token(\n                                 token::Ident(ident.name, is_raw),"}, {"sha": "c90a438c25eceda37151a02b1ce4dfa928380f25", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=2aee60897fc85c575ae5597861a9b40c6cdcab74", "patch": "@@ -785,12 +785,12 @@ fn may_begin_with(token: &Token, name: Symbol) -> bool {\n         sym::literal => token.can_begin_literal_maybe_minus(),\n         sym::vis => match token.kind {\n             // The follow-set of :vis + \"priv\" keyword + interpolated\n-            token::Comma | token::Ident(..) | token::Interpolated(_) => true,\n+            token::Comma | token::Ident(..) | token::Interpolated(..) => true,\n             _ => token.can_begin_type(),\n         },\n         sym::block => match token.kind {\n             token::OpenDelim(token::Brace) => true,\n-            token::Interpolated(ref nt) => match **nt {\n+            token::Interpolated(ref nt, _) => match **nt {\n                 token::NtItem(_)\n                 | token::NtPat(_)\n                 | token::NtTy(_)\n@@ -804,7 +804,7 @@ fn may_begin_with(token: &Token, name: Symbol) -> bool {\n         },\n         sym::path | sym::meta => match token.kind {\n             token::ModSep | token::Ident(..) => true,\n-            token::Interpolated(ref nt) => match **nt {\n+            token::Interpolated(ref nt, _) => match **nt {\n                 token::NtPath(_) | token::NtMeta(_) => true,\n                 _ => may_be_ident(&nt),\n             },\n@@ -823,12 +823,12 @@ fn may_begin_with(token: &Token, name: Symbol) -> bool {\n             token::ModSep |                     // path\n             token::Lt |                         // path (UFCS constant)\n             token::BinOp(token::Shl) => true,   // path (double UFCS)\n-            token::Interpolated(ref nt) => may_be_ident(nt),\n+            token::Interpolated(ref nt, _) => may_be_ident(nt),\n             _ => false,\n         },\n         sym::lifetime => match token.kind {\n             token::Lifetime(_) => true,\n-            token::Interpolated(ref nt) => match **nt {\n+            token::Interpolated(ref nt, _) => match **nt {\n                 token::NtLifetime(_) | token::NtTT(_) => true,\n                 _ => false,\n             },"}, {"sha": "486f0a6420d6e1c7e172bb6229a754975adbe35d", "filename": "src/librustc_expand/mbe/transcribe.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs?ref=2aee60897fc85c575ae5597861a9b40c6cdcab74", "patch": "@@ -4,7 +4,7 @@ use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq, NamedMatch};\n \n use rustc_ast::ast::MacCall;\n use rustc_ast::mut_visit::{self, MutVisitor};\n-use rustc_ast::token::{self, NtTT, Token};\n+use rustc_ast::token::{self, FlattenGroup, NtTT, Token};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n@@ -240,7 +240,10 @@ pub(super) fn transcribe<'a>(\n                             result.push(tt.clone().into());\n                         } else {\n                             marker.visit_span(&mut sp);\n-                            let token = TokenTree::token(token::Interpolated(nt.clone()), sp);\n+                            let token = TokenTree::token(\n+                                token::Interpolated(nt.clone(), FlattenGroup::No),\n+                                sp,\n+                            );\n                             result.push(token.into());\n                         }\n                     } else {"}, {"sha": "1e26c832a2621c0416e5fb90279c832a3bab0bc6", "filename": "src/librustc_expand/proc_macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_expand%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_expand%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro.rs?ref=2aee60897fc85c575ae5597861a9b40c6cdcab74", "patch": "@@ -2,7 +2,7 @@ use crate::base::{self, *};\n use crate::proc_macro_server;\n \n use rustc_ast::ast::{self, ItemKind, MetaItemKind, NestedMetaItem};\n-use rustc_ast::token;\n+use rustc_ast::token::{self, FlattenGroup};\n use rustc_ast::tokenstream::{self, TokenStream};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, ErrorReported};\n@@ -102,7 +102,7 @@ impl MultiItemModifier for ProcMacroDerive {\n             }\n         }\n \n-        let token = token::Interpolated(Lrc::new(token::NtItem(item)));\n+        let token = token::Interpolated(Lrc::new(token::NtItem(item)), FlattenGroup::Yes);\n         let input = tokenstream::TokenTree::token(token, DUMMY_SP).into();\n \n         let server = proc_macro_server::Rustc::new(ecx);"}, {"sha": "c88b5a37f718a0f5db4a838963946405ac277888", "filename": "src/librustc_expand/proc_macro_server.rs", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_expand%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_expand%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro_server.rs?ref=2aee60897fc85c575ae5597861a9b40c6cdcab74", "patch": "@@ -1,7 +1,7 @@\n use crate::base::ExtCtxt;\n \n use rustc_ast::ast;\n-use rustc_ast::token;\n+use rustc_ast::token::{self, FlattenGroup};\n use rustc_ast::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint};\n use rustc_ast::util::comments;\n use rustc_ast_pretty::pprust;\n@@ -60,7 +60,12 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n         let Token { kind, span } = match tree {\n             tokenstream::TokenTree::Delimited(span, delim, tts) => {\n                 let delimiter = Delimiter::from_internal(delim);\n-                return TokenTree::Group(Group { delimiter, stream: tts, span });\n+                return TokenTree::Group(Group {\n+                    delimiter,\n+                    stream: tts,\n+                    span,\n+                    flatten: FlattenGroup::No,\n+                });\n             }\n             tokenstream::TokenTree::Token(token) => token,\n         };\n@@ -167,19 +172,21 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n                     delimiter: Delimiter::Bracket,\n                     stream,\n                     span: DelimSpan::from_single(span),\n+                    flatten: FlattenGroup::No,\n                 }));\n                 if style == ast::AttrStyle::Inner {\n                     stack.push(tt!(Punct::new('!', false)));\n                 }\n                 tt!(Punct::new('#', false))\n             }\n \n-            Interpolated(nt) => {\n+            Interpolated(nt, flatten) => {\n                 let stream = nt_to_tokenstream(&nt, sess, span);\n                 TokenTree::Group(Group {\n                     delimiter: Delimiter::None,\n                     stream,\n                     span: DelimSpan::from_single(span),\n+                    flatten,\n                 })\n             }\n \n@@ -195,7 +202,7 @@ impl ToInternal<TokenStream> for TokenTree<Group, Punct, Ident, Literal> {\n \n         let (ch, joint, span) = match self {\n             TokenTree::Punct(Punct { ch, joint, span }) => (ch, joint, span),\n-            TokenTree::Group(Group { delimiter, stream, span }) => {\n+            TokenTree::Group(Group { delimiter, stream, span, .. }) => {\n                 return tokenstream::TokenTree::Delimited(span, delimiter.to_internal(), stream)\n                     .into();\n             }\n@@ -283,6 +290,10 @@ pub struct Group {\n     delimiter: Delimiter,\n     stream: TokenStream,\n     span: DelimSpan,\n+    /// A hack used to pass AST fragments to attribute and derive macros\n+    /// as a single nonterminal token instead of a token stream.\n+    /// FIXME: It needs to be removed, but there are some compatibility issues (see #73345).\n+    flatten: FlattenGroup,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n@@ -437,14 +448,12 @@ impl server::TokenStreamIter for Rustc<'_> {\n                 let next = iter.cursor.next_with_joint()?;\n                 Some(TokenTree::from_internal((next, self.sess, &mut iter.stack)))\n             })?;\n-            // HACK: The condition \"dummy span + group with empty delimiter\" represents an AST\n-            // fragment approximately converted into a token stream. This may happen, for\n-            // example, with inputs to proc macro attributes, including derives. Such \"groups\"\n-            // need to flattened during iteration over stream's token trees.\n-            // Eventually this needs to be removed in favor of keeping original token trees\n-            // and not doing the roundtrip through AST.\n+            // A hack used to pass AST fragments to attribute and derive macros\n+            // as a single nonterminal token instead of a token stream.\n+            // Such token needs to be \"unwrapped\" and not represented as a delimited group.\n+            // FIXME: It needs to be removed, but there are some compatibility issues (see #73345).\n             if let TokenTree::Group(ref group) = tree {\n-                if group.delimiter == Delimiter::None && group.span.entire().is_dummy() {\n+                if matches!(group.flatten, FlattenGroup::Yes) {\n                     iter.cursor.append(group.stream.clone());\n                     continue;\n                 }\n@@ -456,7 +465,12 @@ impl server::TokenStreamIter for Rustc<'_> {\n \n impl server::Group for Rustc<'_> {\n     fn new(&mut self, delimiter: Delimiter, stream: Self::TokenStream) -> Self::Group {\n-        Group { delimiter, stream, span: DelimSpan::from_single(server::Span::call_site(self)) }\n+        Group {\n+            delimiter,\n+            stream,\n+            span: DelimSpan::from_single(server::Span::call_site(self)),\n+            flatten: FlattenGroup::No,\n+        }\n     }\n     fn delimiter(&mut self, group: &Self::Group) -> Delimiter {\n         group.delimiter"}, {"sha": "b8cb146145b98c7771c8f1987e34ab3db3ca1213", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=2aee60897fc85c575ae5597861a9b40c6cdcab74", "patch": "@@ -155,7 +155,7 @@ impl<'a> Parser<'a> {\n     /// The delimiters or `=` are still put into the resulting token stream.\n     pub fn parse_attr_item(&mut self) -> PResult<'a, ast::AttrItem> {\n         let item = match self.token.kind {\n-            token::Interpolated(ref nt) => match **nt {\n+            token::Interpolated(ref nt, _) => match **nt {\n                 Nonterminal::NtMeta(ref item) => Some(item.clone().into_inner()),\n                 _ => None,\n             },\n@@ -254,7 +254,7 @@ impl<'a> Parser<'a> {\n     ///     meta_item_inner : (meta_item | UNSUFFIXED_LIT) (',' meta_item_inner)? ;\n     pub fn parse_meta_item(&mut self) -> PResult<'a, ast::MetaItem> {\n         let nt_meta = match self.token.kind {\n-            token::Interpolated(ref nt) => match **nt {\n+            token::Interpolated(ref nt, _) => match **nt {\n                 token::NtMeta(ref e) => Some(e.clone()),\n                 _ => None,\n             },"}, {"sha": "2745b18a8cd51e44b13ced0f8f797653523bd3b1", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=2aee60897fc85c575ae5597861a9b40c6cdcab74", "patch": "@@ -26,7 +26,7 @@ use std::mem;\n /// `token::Interpolated` tokens.\n macro_rules! maybe_whole_expr {\n     ($p:expr) => {\n-        if let token::Interpolated(nt) = &$p.token.kind {\n+        if let token::Interpolated(nt, _) = &$p.token.kind {\n             match &**nt {\n                 token::NtExpr(e) | token::NtLiteral(e) => {\n                     let e = e.clone();"}, {"sha": "10df16964da084d32d6c64f590ed1406d08fd603", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=2aee60897fc85c575ae5597861a9b40c6cdcab74", "patch": "@@ -1780,7 +1780,7 @@ impl<'a> Parser<'a> {\n \n     fn is_named_param(&self) -> bool {\n         let offset = match self.token.kind {\n-            token::Interpolated(ref nt) => match **nt {\n+            token::Interpolated(ref nt, _) => match **nt {\n                 token::NtPat(..) => return self.look_ahead(1, |t| t == &token::Colon),\n                 _ => 0,\n             },"}, {"sha": "04074479a21a4e22c333b1339a96246f4c792312", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=2aee60897fc85c575ae5597861a9b40c6cdcab74", "patch": "@@ -54,7 +54,7 @@ enum BlockMode {\n #[macro_export]\n macro_rules! maybe_whole {\n     ($p:expr, $constructor:ident, |$x:ident| $e:expr) => {\n-        if let token::Interpolated(nt) = &$p.token.kind {\n+        if let token::Interpolated(nt, _) = &$p.token.kind {\n             if let token::$constructor(x) = &**nt {\n                 let $x = x.clone();\n                 $p.bump();\n@@ -69,7 +69,7 @@ macro_rules! maybe_whole {\n macro_rules! maybe_recover_from_interpolated_ty_qpath {\n     ($self: expr, $allow_qpath_recovery: expr) => {\n         if $allow_qpath_recovery && $self.look_ahead(1, |t| t == &token::ModSep) {\n-            if let token::Interpolated(nt) = &$self.token.kind {\n+            if let token::Interpolated(nt, _) = &$self.token.kind {\n                 if let token::NtTy(ty) = &**nt {\n                     let ty = ty.clone();\n                     $self.bump();\n@@ -922,7 +922,7 @@ impl<'a> Parser<'a> {\n                 if self.eat(&token::Eq) {\n                     let eq_span = self.prev_token.span;\n                     let mut is_interpolated_expr = false;\n-                    if let token::Interpolated(nt) = &self.token.kind {\n+                    if let token::Interpolated(nt, _) = &self.token.kind {\n                         if let token::NtExpr(..) = **nt {\n                             is_interpolated_expr = true;\n                         }"}, {"sha": "742183d36973562b4d082a33b20239325a9f5bb7", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=2aee60897fc85c575ae5597861a9b40c6cdcab74", "patch": "@@ -515,7 +515,7 @@ impl<'a> Parser<'a> {\n         self.recover_additional_muts();\n \n         // Make sure we don't allow e.g. `let mut $p;` where `$p:pat`.\n-        if let token::Interpolated(ref nt) = self.token.kind {\n+        if let token::Interpolated(ref nt, _) = self.token.kind {\n             if let token::NtPat(_) = **nt {\n                 self.expected_ident_found().emit();\n             }"}, {"sha": "72faa68d0b2434a866579f1e5c04726a01fa0aab", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=2aee60897fc85c575ae5597861a9b40c6cdcab74", "patch": "@@ -1325,7 +1325,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     fn visit_token(&mut self, t: Token) {\n-        if let token::Interpolated(nt) = t.kind {\n+        if let token::Interpolated(nt, _) = t.kind {\n             if let token::NtExpr(ref expr) = *nt {\n                 if let ast::ExprKind::MacCall(..) = expr.kind {\n                     self.visit_invoc(expr.id);"}, {"sha": "dc8d1a8d3fdf98e97851bc6ca71a026ae0aabc83", "filename": "src/librustc_resolve/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_resolve%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aee60897fc85c575ae5597861a9b40c6cdcab74/src%2Flibrustc_resolve%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdef_collector.rs?ref=2aee60897fc85c575ae5597861a9b40c6cdcab74", "patch": "@@ -256,7 +256,7 @@ impl<'a, 'b> visit::Visitor<'a> for DefCollector<'a, 'b> {\n     }\n \n     fn visit_token(&mut self, t: Token) {\n-        if let token::Interpolated(nt) = t.kind {\n+        if let token::Interpolated(nt, _) = t.kind {\n             if let token::NtExpr(ref expr) = *nt {\n                 if let ExprKind::MacCall(..) = expr.kind {\n                     self.visit_macro_invoc(expr.id);"}]}