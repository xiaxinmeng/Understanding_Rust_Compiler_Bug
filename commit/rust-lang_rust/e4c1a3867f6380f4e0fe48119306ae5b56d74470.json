{"sha": "e4c1a3867f6380f4e0fe48119306ae5b56d74470", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0YzFhMzg2N2Y2MzgwZjRlMGZlNDgxMTkzMDZhZTViNTZkNzQ0NzA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-19T09:26:58Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-10-05T07:12:56Z"}, "message": "VecDeque: avoid more aliasing issues by working with raw pointers instead of references", "tree": {"sha": "c9ea33a4d768d90afb0a936428d648c2c16ec74f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9ea33a4d768d90afb0a936428d648c2c16ec74f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4c1a3867f6380f4e0fe48119306ae5b56d74470", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4c1a3867f6380f4e0fe48119306ae5b56d74470", "html_url": "https://github.com/rust-lang/rust/commit/e4c1a3867f6380f4e0fe48119306ae5b56d74470", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4c1a3867f6380f4e0fe48119306ae5b56d74470/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f251dc446f753edc0797bfcc5ed48ad8f477e9ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/f251dc446f753edc0797bfcc5ed48ad8f477e9ad", "html_url": "https://github.com/rust-lang/rust/commit/f251dc446f753edc0797bfcc5ed48ad8f477e9ad"}], "stats": {"total": 43, "additions": 31, "deletions": 12}, "files": [{"sha": "0f34786b18af44e1810c34032eb38c118d194b17", "filename": "library/alloc/src/collections/vec_deque.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e4c1a3867f6380f4e0fe48119306ae5b56d74470/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c1a3867f6380f4e0fe48119306ae5b56d74470/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs?ref=e4c1a3867f6380f4e0fe48119306ae5b56d74470", "patch": "@@ -2500,6 +2500,25 @@ impl<T> RingSlices for &mut [T] {\n     }\n }\n \n+impl<T> RingSlices for *mut [T] {\n+    fn slice(self, from: usize, to: usize) -> Self {\n+        assert!(from <= to && to < self.len());\n+        // Not using `get_unchecked_mut` to keep this a safe operation.\n+        let len = to - from;\n+        ptr::slice_from_raw_parts_mut(self.as_mut_ptr().wrapping_add(from), len)\n+    }\n+\n+    fn split_at(self, mid: usize) -> (Self, Self) {\n+        let len = self.len();\n+        let ptr = self.as_mut_ptr();\n+        assert!(mid <= len);\n+        (\n+            ptr::slice_from_raw_parts_mut(ptr, mid),\n+            ptr::slice_from_raw_parts_mut(ptr.wrapping_add(mid), len - mid),\n+        )\n+    }\n+}\n+\n /// Calculate the number of elements left to be read in the buffer\n #[inline]\n fn count(tail: usize, head: usize, size: usize) -> usize {\n@@ -2678,10 +2697,10 @@ pub struct IterMut<'a, T: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // FIXME: this creates a reference to the full ring, including the part\n-        // to which we already handed out mutable references via `next()`. This\n-        // is an aliasing violation.\n-        let (front, back) = RingSlices::ring_slices(unsafe { &*self.ring }, self.head, self.tail);\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n+        // We also ensure everything is dereferencable and in-bounds.\n+        let (front, back) = unsafe { (&*front, &*back) };\n         f.debug_tuple(\"IterMut\").field(&front).field(&back).finish()\n     }\n }\n@@ -2714,10 +2733,10 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n     where\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        // FIXME: this creates a reference to the full ring, including the part\n-        // to which we already handed out mutable references via `next()`. This\n-        // is an aliasing violation.\n-        let (front, back) = RingSlices::ring_slices(unsafe { &mut *self.ring }, self.head, self.tail);\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n+        // We also ensure everything is dereferencable and in-bounds.\n+        let (front, back) = unsafe { (&mut *front, &mut *back) };\n         accum = front.iter_mut().fold(accum, &mut f);\n         back.iter_mut().fold(accum, &mut f)\n     }\n@@ -2757,10 +2776,10 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     where\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        // FIXME: this creates a reference to the full ring, including the part\n-        // to which we already handed out mutable references via `next()`. This\n-        // is an aliasing violation.\n-        let (front, back) = RingSlices::ring_slices(unsafe { &mut *self.ring }, self.head, self.tail);\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n+        // We also ensure everything is dereferencable and in-bounds.\n+        let (front, back) = unsafe { (&mut *front, &mut *back) };\n         accum = back.iter_mut().rfold(accum, &mut f);\n         front.iter_mut().rfold(accum, &mut f)\n     }"}]}