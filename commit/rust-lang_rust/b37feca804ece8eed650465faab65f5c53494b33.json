{"sha": "b37feca804ece8eed650465faab65f5c53494b33", "node_id": "C_kwDOAAsO6NoAKGIzN2ZlY2E4MDRlY2U4ZWVkNjUwNDY1ZmFhYjY1ZjVjNTM0OTRiMzM", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-11-14T21:24:18Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-11-14T21:24:18Z"}, "message": "Give precendence to regions from member constaints when inferring concrete types.", "tree": {"sha": "3759189c818d72e70425b003c6bd05f2aeda2428", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3759189c818d72e70425b003c6bd05f2aeda2428"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b37feca804ece8eed650465faab65f5c53494b33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b37feca804ece8eed650465faab65f5c53494b33", "html_url": "https://github.com/rust-lang/rust/commit/b37feca804ece8eed650465faab65f5c53494b33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b37feca804ece8eed650465faab65f5c53494b33/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b552965a93b28a6f184c75fe4e6fcc5129dc1d1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b552965a93b28a6f184c75fe4e6fcc5129dc1d1a", "html_url": "https://github.com/rust-lang/rust/commit/b552965a93b28a6f184c75fe4e6fcc5129dc1d1a"}], "stats": {"total": 62, "additions": 45, "deletions": 17}, "files": [{"sha": "b5e00f471d26a0d266e021e330cfeb78f56fef1f", "filename": "compiler/rustc_borrowck/src/member_constraints.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b37feca804ece8eed650465faab65f5c53494b33/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37feca804ece8eed650465faab65f5c53494b33/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs?ref=b37feca804ece8eed650465faab65f5c53494b33", "patch": "@@ -11,6 +11,7 @@ use std::ops::Index;\n \n /// Compactly stores a set of `R0 member of [R1...Rn]` constraints,\n /// indexed by the region `R0`.\n+#[derive(Debug)]\n pub(crate) struct MemberConstraintSet<'tcx, R>\n where\n     R: Copy + Eq,\n@@ -31,6 +32,7 @@ where\n }\n \n /// Represents a `R0 member of [R1..Rn]` constraint\n+#[derive(Debug)]\n pub(crate) struct NllMemberConstraint<'tcx> {\n     next_constraint: Option<NllMemberConstraintIndex>,\n "}, {"sha": "b35abbd107b9ce7e148603f91207a64c513e1f84", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b37feca804ece8eed650465faab65f5c53494b33/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37feca804ece8eed650465faab65f5c53494b33/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=b37feca804ece8eed650465faab65f5c53494b33", "patch": "@@ -128,6 +128,7 @@ pub struct RegionInferenceContext<'tcx> {\n /// adds a new lower bound to the SCC it is analyzing: so you wind up\n /// with `'R: 'O` where `'R` is the pick-region and `'O` is the\n /// minimal viable option.\n+#[derive(Debug)]\n pub(crate) struct AppliedMemberConstraint {\n     /// The SCC that was affected. (The \"member region\".)\n     ///"}, {"sha": "fe49e3a4ba9c8366f496c4520d493a6529326ff4", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b37feca804ece8eed650465faab65f5c53494b33/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37feca804ece8eed650465faab65f5c53494b33/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=b37feca804ece8eed650465faab65f5c53494b33", "patch": "@@ -1,4 +1,4 @@\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::OpaqueTyOrigin;\n@@ -63,17 +63,21 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         opaque_ty_decls: VecMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n     ) -> VecMap<LocalDefId, OpaqueHiddenType<'tcx>> {\n         let mut result: VecMap<LocalDefId, OpaqueHiddenType<'tcx>> = VecMap::new();\n+\n+        let member_constraints: FxHashMap<_, _> = self\n+            .member_constraints\n+            .all_indices()\n+            .map(|ci| (self.member_constraints[ci].key, ci))\n+            .collect();\n+        debug!(?member_constraints);\n+\n         for (opaque_type_key, (concrete_type, origin)) in opaque_ty_decls {\n             let substs = opaque_type_key.substs;\n             debug!(?concrete_type, ?substs);\n \n             let mut subst_regions = vec![self.universal_regions.fr_static];\n-            let universal_substs = infcx.tcx.fold_regions(substs, |region, _| {\n-                if let ty::RePlaceholder(..) = region.kind() {\n-                    // Higher kinded regions don't need remapping, they don't refer to anything outside of this the substs.\n-                    return region;\n-                }\n-                let vid = self.to_region_vid(region);\n+\n+            let to_universal_region = |vid, subst_regions: &mut Vec<_>| {\n                 trace!(?vid);\n                 let scc = self.constraint_sccs.scc(vid);\n                 trace!(?scc);\n@@ -94,10 +98,33 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         infcx.tcx.lifetimes.re_static\n                     }\n                 }\n+            };\n+\n+            // Start by inserting universal regions from the member_constraint choice regions.\n+            // This will ensure they get precedence when folding the regions in the concrete type.\n+            if let Some(&ci) = member_constraints.get(&opaque_type_key) {\n+                for &vid in self.member_constraints.choice_regions(ci) {\n+                    to_universal_region(vid, &mut subst_regions);\n+                }\n+            }\n+            debug!(?subst_regions);\n+\n+            // Next, insert universal regions from substs, so we can translate regions that appear\n+            // in them but are not subject to member constraints, for instance closure substs.\n+            let universal_substs = infcx.tcx.fold_regions(substs, |region, _| {\n+                if let ty::RePlaceholder(..) = region.kind() {\n+                    // Higher kinded regions don't need remapping, they don't refer to anything outside of this the substs.\n+                    return region;\n+                }\n+                let vid = self.to_region_vid(region);\n+                to_universal_region(vid, &mut subst_regions)\n             });\n+            debug!(?universal_substs);\n+            debug!(?subst_regions);\n \n-            subst_regions.sort();\n-            subst_regions.dedup();\n+            // Deduplicate the set of regions while keeping the chosen order.\n+            let subst_regions = subst_regions.into_iter().collect::<FxIndexSet<_>>();\n+            debug!(?subst_regions);\n \n             let universal_concrete_type =\n                 infcx.tcx.fold_regions(concrete_type, |region, _| match *region {\n@@ -108,8 +135,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         .unwrap_or(infcx.tcx.lifetimes.re_erased),\n                     _ => region,\n                 });\n-\n-            debug!(?universal_concrete_type, ?universal_substs);\n+            debug!(?universal_concrete_type);\n \n             let opaque_type_key =\n                 OpaqueTypeKey { def_id: opaque_type_key.def_id, substs: universal_substs };"}, {"sha": "31bdb049e76a5c5b76071fa324da8893022c8a68", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b37feca804ece8eed650465faab65f5c53494b33/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37feca804ece8eed650465faab65f5c53494b33/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=b37feca804ece8eed650465faab65f5c53494b33", "patch": "@@ -1257,7 +1257,7 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, TyEncodable, TyDecodable, Lift)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, HashStable, TyEncodable, TyDecodable, Lift)]\n #[derive(TypeFoldable, TypeVisitable)]\n pub struct OpaqueTypeKey<'tcx> {\n     pub def_id: LocalDefId,\n@@ -1333,17 +1333,16 @@ impl<'tcx> OpaqueHiddenType<'tcx> {\n         debug!(?id_substs);\n \n         // This zip may have several times the same lifetime in `substs` paired with a different\n-        // lifetime from `id_substs`.  In that case, we actually want to pick the last one, as it\n-        // is the one we introduced in the impl-trait desugaring to be meaningful.  The other ones\n-        // are redundant.\n+        // lifetime from `id_substs`.  Simply `collect`ing the iterator is the correct behaviour:\n+        // it will pick the last one, which is the one we introduced in the impl-trait desugaring.\n         let map = substs.iter().zip(id_substs);\n \n         let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> = match origin {\n             // HACK: The HIR lowering for async fn does not generate\n             // any `+ Captures<'x>` bounds for the `impl Future<...>`, so all async fns with lifetimes\n             // would now fail to compile. We should probably just make hir lowering fill this in properly.\n-            OpaqueTyOrigin::FnReturn(_) | OpaqueTyOrigin::AsyncFn(_) => map.collect(),\n-            OpaqueTyOrigin::TyAlias => {\n+            OpaqueTyOrigin::AsyncFn(_) => map.collect(),\n+            OpaqueTyOrigin::FnReturn(_) | OpaqueTyOrigin::TyAlias => {\n                 // Opaque types may only use regions that are bound. So for\n                 // ```rust\n                 // type Foo<'a, 'b, 'c> = impl Trait<'a> + 'b;"}]}