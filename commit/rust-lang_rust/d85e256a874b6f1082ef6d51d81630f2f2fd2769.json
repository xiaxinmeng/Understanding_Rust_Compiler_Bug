{"sha": "d85e256a874b6f1082ef6d51d81630f2f2fd2769", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4NWUyNTZhODc0YjZmMTA4MmVmNmQ1MWQ4MTYzMGYyZjJmZDI3Njk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-28T22:19:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-28T22:19:52Z"}, "message": "Rollup merge of #60742 - varkor:fn-const-array-parameter, r=eddyb\n\nAllow const parameters in array sizes to be unified\n\nFixes https://github.com/rust-lang/rust/issues/60632.\nFixes https://github.com/rust-lang/rust/issues/60744.\nFixes https://github.com/rust-lang/rust/pull/60923.\n(The last commit should probably be viewed in isolation, as it just renames things from `type` to `kind`.)\n\nr? @eddyb", "tree": {"sha": "76d3bdabf1267e787462ac14364bc53579cc787e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76d3bdabf1267e787462ac14364bc53579cc787e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d85e256a874b6f1082ef6d51d81630f2f2fd2769", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc7bQICRBK7hj4Ov3rIwAAdHIIAG9ZRkNM60R2OuvTH6A22eNF\nnvQJO221Dz4+0B2fJ2VGHdDEwPD9dm4LrqH7sP4ylogIbQVrYTsbMFbFHQJdZc4o\nIN3gEz8W33FD5PEq7aogHGsCbmWd9o/PWzeOXF/BiiZuhj5dbcb4f1kq888rzIik\ncge+P/ge18x+9CuTFIBavqn7yUkY8JLMeYq5vtjL6Wr2g03ZmmSvxzilQ8eKjz2d\nCfLyVm0DH76oPYOkhfhgH1Soy7eySE4qMRbr1eYvbbkNIS7WAtbil1TLh/Sc0/A1\nQIosz57+gTdiPitseBnTopgI369Xdl3X/ti7Kr0uppF2vdkG1QSeG0PuwaF9fzk=\n=I5zU\n-----END PGP SIGNATURE-----\n", "payload": "tree 76d3bdabf1267e787462ac14364bc53579cc787e\nparent 721268583759224d0f6476e0b8b196cc8afbdea0\nparent 6233d1fee5df70258b02bb549967bc9319014081\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1559081992 +0200\ncommitter GitHub <noreply@github.com> 1559081992 +0200\n\nRollup merge of #60742 - varkor:fn-const-array-parameter, r=eddyb\n\nAllow const parameters in array sizes to be unified\n\nFixes https://github.com/rust-lang/rust/issues/60632.\nFixes https://github.com/rust-lang/rust/issues/60744.\nFixes https://github.com/rust-lang/rust/pull/60923.\n(The last commit should probably be viewed in isolation, as it just renames things from `type` to `kind`.)\n\nr? @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d85e256a874b6f1082ef6d51d81630f2f2fd2769", "html_url": "https://github.com/rust-lang/rust/commit/d85e256a874b6f1082ef6d51d81630f2f2fd2769", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d85e256a874b6f1082ef6d51d81630f2f2fd2769/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "721268583759224d0f6476e0b8b196cc8afbdea0", "url": "https://api.github.com/repos/rust-lang/rust/commits/721268583759224d0f6476e0b8b196cc8afbdea0", "html_url": "https://github.com/rust-lang/rust/commit/721268583759224d0f6476e0b8b196cc8afbdea0"}, {"sha": "6233d1fee5df70258b02bb549967bc9319014081", "url": "https://api.github.com/repos/rust-lang/rust/commits/6233d1fee5df70258b02bb549967bc9319014081", "html_url": "https://github.com/rust-lang/rust/commit/6233d1fee5df70258b02bb549967bc9319014081"}], "stats": {"total": 593, "additions": 395, "deletions": 198}, "files": [{"sha": "f87c6977f33d0261ea99cd3339b5184aa5c4a1ad", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -652,7 +652,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         for sp in prior_arms {\n                             err.span_label(*sp, format!(\n                                 \"this is found to be of type `{}`\",\n-                                self.resolve_type_vars_if_possible(&last_ty),\n+                                self.resolve_vars_if_possible(&last_ty),\n                             ));\n                         }\n                     } else if let Some(sp) = prior_arms.last() {\n@@ -1278,7 +1278,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n     ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n-        let exp_found = self.resolve_type_vars_if_possible(exp_found);\n+        let exp_found = self.resolve_vars_if_possible(exp_found);\n         if exp_found.references_error() {\n             return None;\n         }\n@@ -1291,7 +1291,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         exp_found: &ty::error::ExpectedFound<T>,\n     ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n-        let exp_found = self.resolve_type_vars_if_possible(exp_found);\n+        let exp_found = self.resolve_vars_if_possible(exp_found);\n         if exp_found.references_error() {\n             return None;\n         }"}, {"sha": "972ffbe1820a5569ee59ae336b4f89652e4dcce2", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -24,7 +24,7 @@ impl<'a, 'gcx, 'tcx> FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n         });\n         match ty_opt {\n             Some(ty) => {\n-                let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n+                let ty = self.infcx.resolve_vars_if_possible(&ty);\n                 ty.walk().any(|inner_ty| {\n                     inner_ty == self.target_ty || match (&inner_ty.sty, &self.target_ty.sty) {\n                         (&Infer(TyVar(a_vid)), &Infer(TyVar(b_vid))) => {\n@@ -94,7 +94,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         span: Span,\n         ty: Ty<'tcx>\n     ) -> DiagnosticBuilder<'gcx> {\n-        let ty = self.resolve_type_vars_if_possible(&ty);\n+        let ty = self.resolve_vars_if_possible(&ty);\n         let name = self.extract_type_name(&ty, None);\n \n         let mut err_span = span;\n@@ -166,7 +166,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         span: Span,\n         ty: Ty<'tcx>\n     ) -> DiagnosticBuilder<'gcx> {\n-        let ty = self.resolve_type_vars_if_possible(&ty);\n+        let ty = self.resolve_vars_if_possible(&ty);\n         let name = self.extract_type_name(&ty, None);\n \n         let mut err = struct_span_err!(self.tcx.sess,"}, {"sha": "1dd391950254dd55db1ea4b198d84138489ef6f7", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -210,11 +210,11 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n             _ => (),\n         }\n \n-        let expected_trait_ref = self.infcx.resolve_type_vars_if_possible(&ty::TraitRef {\n+        let expected_trait_ref = self.infcx.resolve_vars_if_possible(&ty::TraitRef {\n             def_id: trait_def_id,\n             substs: expected_substs,\n         });\n-        let actual_trait_ref = self.infcx.resolve_type_vars_if_possible(&ty::TraitRef {\n+        let actual_trait_ref = self.infcx.resolve_vars_if_possible(&ty::TraitRef {\n             def_id: trait_def_id,\n             substs: actual_substs,\n         });"}, {"sha": "7461d8bc72860ec7ffbe44a23004bf1d0c84095c", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let (mut fudger, value) = self.probe(|snapshot| {\n             match f() {\n                 Ok(value) => {\n-                    let value = self.resolve_type_vars_if_possible(&value);\n+                    let value = self.resolve_vars_if_possible(&value);\n \n                     // At this point, `value` could in principle refer\n                     // to inference variables that have been created during"}, {"sha": "a4a7efdbc9e3e204d9687b9afeffba6b46dae0fa", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -1174,7 +1174,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Process the region constraints and report any errors that\n     /// result. After this, no more unification operations should be\n     /// done -- or the compiler will panic -- but it is legal to use\n-    /// `resolve_type_vars_if_possible` as well as `fully_resolve`.\n+    /// `resolve_vars_if_possible` as well as `fully_resolve`.\n     pub fn resolve_regions_and_report_errors(\n         &self,\n         region_context: DefId,\n@@ -1262,7 +1262,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n-        self.resolve_type_vars_if_possible(&t).to_string()\n+        self.resolve_vars_if_possible(&t).to_string()\n     }\n \n     pub fn tys_to_string(&self, ts: &[Ty<'tcx>]) -> String {\n@@ -1271,7 +1271,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn trait_ref_to_string(&self, t: &ty::TraitRef<'tcx>) -> String {\n-        self.resolve_type_vars_if_possible(t).to_string()\n+        self.resolve_vars_if_possible(t).to_string()\n     }\n \n     /// If `TyVar(vid)` resolves to a type, return that type. Else, return the\n@@ -1297,28 +1297,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.type_variables.borrow_mut().root_var(var)\n     }\n \n-    /// Where possible, replaces type/int/float variables in\n+    /// Where possible, replaces type/const variables in\n     /// `value` with their final value. Note that region variables\n-    /// are unaffected. If a type variable has not been unified, it\n+    /// are unaffected. If a type/const variable has not been unified, it\n     /// is left as is. This is an idempotent operation that does\n     /// not affect inference state in any way and so you can do it\n     /// at will.\n-    pub fn resolve_type_vars_if_possible<T>(&self, value: &T) -> T\n+    pub fn resolve_vars_if_possible<T>(&self, value: &T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         if !value.needs_infer() {\n             return value.clone(); // avoid duplicated subst-folding\n         }\n-        let mut r = resolve::OpportunisticTypeResolver::new(self);\n+        let mut r = resolve::OpportunisticVarResolver::new(self);\n         value.fold_with(&mut r)\n     }\n \n     /// Returns first unresolved variable contained in `T`. In the\n     /// process of visiting `T`, this will resolve (where possible)\n     /// type variables in `T`, but it never constructs the final,\n     /// resolved type, so it's more efficient than\n-    /// `resolve_type_vars_if_possible()`.\n+    /// `resolve_vars_if_possible()`.\n     pub fn unresolved_type_vars<T>(&self, value: &T) -> Option<(Ty<'tcx>, Option<Span>)>\n     where\n         T: TypeFoldable<'tcx>,\n@@ -1389,7 +1389,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     where\n         M: FnOnce(String) -> DiagnosticBuilder<'tcx>,\n     {\n-        let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n+        let actual_ty = self.resolve_vars_if_possible(&actual_ty);\n         debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n \n         // Don't report an error if actual type is `Error`.\n@@ -1446,7 +1446,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         ty: Ty<'tcx>,\n         span: Span,\n     ) -> bool {\n-        let ty = self.resolve_type_vars_if_possible(&ty);\n+        let ty = self.resolve_vars_if_possible(&ty);\n \n         // Even if the type may have no inference variables, during\n         // type-checking closure types are in local tables only."}, {"sha": "220b7b5fa67feeb45eb52358ab561c00929e6a59", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -286,7 +286,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         let tcx = self.tcx;\n \n-        let concrete_ty = self.resolve_type_vars_if_possible(&opaque_defn.concrete_ty);\n+        let concrete_ty = self.resolve_vars_if_possible(&opaque_defn.concrete_ty);\n \n         debug!(\"constrain_opaque_type: concrete_ty={:?}\", concrete_ty);\n "}, {"sha": "3e626999200fea98900e671761c1feea6d703efc", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -168,7 +168,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n         debug!(\"add_implied_bounds()\");\n \n         for &ty in fn_sig_tys {\n-            let ty = infcx.resolve_type_vars_if_possible(&ty);\n+            let ty = infcx.resolve_vars_if_possible(&ty);\n             debug!(\"add_implied_bounds: ty = {}\", ty);\n             let implied_bounds = infcx.implied_outlives_bounds(self.param_env, body_id, ty, span);\n             self.add_outlives_bounds(Some(infcx), implied_bounds)"}, {"sha": "90b3be213854c93e0b0059f24e323c2c40569409", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -177,7 +177,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 sup_type, sub_region, origin\n             );\n \n-            let sup_type = self.resolve_type_vars_if_possible(&sup_type);\n+            let sup_type = self.resolve_vars_if_possible(&sup_type);\n \n             if let Some(region_bound_pairs) = region_bound_pairs_map.get(&body_id) {\n                 let outlives = &mut TypeOutlives::new(\n@@ -215,7 +215,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             implicit_region_bound,\n             param_env,\n         );\n-        let ty = self.resolve_type_vars_if_possible(&ty);\n+        let ty = self.resolve_vars_if_possible(&ty);\n         outlives.type_must_outlive(origin, ty, region);\n     }\n }"}, {"sha": "95bae8f2bd1afb7b4326f18be4ecf1dd3f4f296e", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -1,28 +1,28 @@\n use super::{InferCtxt, FixupError, FixupResult, Span, type_variable::TypeVariableOrigin};\n use crate::mir::interpret::ConstValue;\n-use crate::ty::{self, Ty, TyCtxt, TypeFoldable, InferConst};\n+use crate::ty::{self, Ty, Const, TyCtxt, TypeFoldable, InferConst, TypeFlags};\n use crate::ty::fold::{TypeFolder, TypeVisitor};\n \n ///////////////////////////////////////////////////////////////////////////\n-// OPPORTUNISTIC TYPE RESOLVER\n+// OPPORTUNISTIC VAR RESOLVER\n \n-/// The opportunistic type resolver can be used at any time. It simply replaces\n-/// type variables that have been unified with the things they have\n+/// The opportunistic resolver can be used at any time. It simply replaces\n+/// type/const variables that have been unified with the things they have\n /// been unified with (similar to `shallow_resolve`, but deep). This is\n /// useful for printing messages etc but also required at various\n /// points for correctness.\n-pub struct OpportunisticTypeResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct OpportunisticVarResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> OpportunisticTypeResolver<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> OpportunisticVarResolver<'a, 'gcx, 'tcx> {\n     #[inline]\n     pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n-        OpportunisticTypeResolver { infcx }\n+        OpportunisticVarResolver { infcx }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeResolver<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticVarResolver<'a, 'gcx, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n@@ -31,8 +31,17 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeResolver<'a, 'g\n         if !t.has_infer_types() {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n-            let t0 = self.infcx.shallow_resolve(t);\n-            t0.super_fold_with(self)\n+            let t = self.infcx.shallow_resolve(t);\n+            t.super_fold_with(self)\n+        }\n+    }\n+\n+    fn fold_const(&mut self, ct: &'tcx Const<'tcx>) -> &'tcx Const<'tcx> {\n+        if !ct.has_type_flags(TypeFlags::HAS_CT_INFER) {\n+            ct // micro-optimize -- if there is nothing in this const that this fold affects...\n+        } else {\n+            let ct = self.infcx.shallow_resolve(ct);\n+            ct.super_fold_with(self)\n         }\n     }\n }"}, {"sha": "8d7c6f18a854f23913db941643cdeabcdd977a70", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -458,10 +458,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             .unwrap_or(true)\n     }\n \n-    fn resolve_type_vars_if_possible<T>(&self, value: &T) -> T\n+    fn resolve_vars_if_possible<T>(&self, value: &T) -> T\n         where T: TypeFoldable<'tcx>\n     {\n-        self.infcx.map(|infcx| infcx.resolve_type_vars_if_possible(value))\n+        self.infcx.map(|infcx| infcx.resolve_vars_if_possible(value))\n             .unwrap_or_else(|| value.clone())\n     }\n \n@@ -475,7 +475,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                                   -> McResult<Ty<'tcx>> {\n         match ty {\n             Some(ty) => {\n-                let ty = self.resolve_type_vars_if_possible(&ty);\n+                let ty = self.resolve_vars_if_possible(&ty);\n                 if ty.references_error() || ty.is_ty_var() {\n                     debug!(\"resolve_type_vars_or_error: error from {:?}\", ty);\n                     Err(())\n@@ -602,7 +602,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         where F: FnOnce() -> McResult<cmt_<'tcx>>\n     {\n         debug!(\"cat_expr_adjusted_with({:?}): {:?}\", adjustment, expr);\n-        let target = self.resolve_type_vars_if_possible(&adjustment.target);\n+        let target = self.resolve_vars_if_possible(&adjustment.target);\n         match adjustment.kind {\n             adjustment::Adjust::Deref(overloaded) => {\n                 // Equivalent to *expr or something similar."}, {"sha": "7505b3c1be8444b1995938f93b80c259bb4e2716", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -307,9 +307,9 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 continue;\n             }\n \n-            // Call infcx.resolve_type_vars_if_possible to see if we can\n+            // Call infcx.resolve_vars_if_possible to see if we can\n             // get rid of any inference variables.\n-            let obligation = infcx.resolve_type_vars_if_possible(\n+            let obligation = infcx.resolve_vars_if_possible(\n                 &Obligation::new(dummy_cause.clone(), new_env, pred)\n             );\n             let result = select.select(&obligation);\n@@ -642,7 +642,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 fresh_preds.insert(self.clean_pred(select.infcx(), predicate));\n \n             // Resolve any inference variables that we can, to help selection succeed\n-            predicate = select.infcx().resolve_type_vars_if_possible(&predicate);\n+            predicate = select.infcx().resolve_vars_if_possible(&predicate);\n \n             // We only add a predicate as a user-displayable bound if\n             // it involves a generic parameter, and doesn't contain"}, {"sha": "a7b5e6cf41b779981a49d74ff4f09b1fa0c0775d", "filename": "src/librustc/traits/chalk_fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -33,7 +33,7 @@ fn in_environment(\n     obligation: PredicateObligation<'tcx>\n ) -> InEnvironment<'tcx, PredicateObligation<'tcx>> {\n     assert!(!infcx.is_in_snapshot());\n-    let obligation = infcx.resolve_type_vars_if_possible(&obligation);\n+    let obligation = infcx.resolve_vars_if_possible(&obligation);\n \n     let environment = match obligation.param_env.def_id {\n         Some(def_id) => infcx.tcx.environment(def_id),"}, {"sha": "591557eb2bea5785efbea87f5f0883a0f498d7d7", "filename": "src/librustc/traits/codegen/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -153,11 +153,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             bug!(\"Encountered errors `{:?}` resolving bounds after type-checking\", errors);\n         }\n \n-        let result = self.resolve_type_vars_if_possible(result);\n+        let result = self.resolve_vars_if_possible(result);\n         let result = self.tcx.erase_regions(&result);\n \n         self.tcx.lift_to_global(&result).unwrap_or_else(||\n-            bug!(\"Uninferred types/regions in `{:?}`\", result)\n+            bug!(\"Uninferred types/regions/consts in `{:?}`\", result)\n         )\n     }\n }"}, {"sha": "c6521a931bb29b0876e5f003ad40ece17beecabd", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -155,7 +155,7 @@ fn overlap_within_probe(\n         a_impl_header.predicates\n                      .iter()\n                      .chain(&b_impl_header.predicates)\n-                     .map(|p| infcx.resolve_type_vars_if_possible(p))\n+                     .map(|p| infcx.resolve_vars_if_possible(p))\n                      .map(|p| Obligation { cause: ObligationCause::dummy(),\n                                            param_env,\n                                            recursion_depth: 0,\n@@ -171,7 +171,7 @@ fn overlap_within_probe(\n         return None\n     }\n \n-    let impl_header = selcx.infcx().resolve_type_vars_if_possible(&a_impl_header);\n+    let impl_header = selcx.infcx().resolve_vars_if_possible(&a_impl_header);\n     let intercrate_ambiguity_causes = selcx.take_intercrate_ambiguity_causes();\n     debug!(\"overlap: intercrate_ambiguity_causes={:#?}\", intercrate_ambiguity_causes);\n "}, {"sha": "5a2bf07b065f8747ea20c2898718afa7da71a5a2", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -186,7 +186,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                error: &MismatchedProjectionTypes<'tcx>)\n     {\n         let predicate =\n-            self.resolve_type_vars_if_possible(&obligation.predicate);\n+            self.resolve_vars_if_possible(&obligation.predicate);\n \n         if predicate.references_error() {\n             return\n@@ -531,7 +531,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         where T: fmt::Display + TypeFoldable<'tcx>\n     {\n         let predicate =\n-            self.resolve_type_vars_if_possible(&obligation.predicate);\n+            self.resolve_vars_if_possible(&obligation.predicate);\n         let mut err = struct_span_err!(self.tcx.sess, obligation.cause.span, E0275,\n                                        \"overflow evaluating the requirement `{}`\",\n                                        predicate);\n@@ -553,7 +553,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// we do not suggest increasing the overflow limit, which is not\n     /// going to help).\n     pub fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> ! {\n-        let cycle = self.resolve_type_vars_if_possible(&cycle.to_owned());\n+        let cycle = self.resolve_vars_if_possible(&cycle.to_owned());\n         assert!(cycle.len() > 0);\n \n         debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n@@ -589,7 +589,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn get_parent_trait_ref(&self, code: &ObligationCauseCode<'tcx>) -> Option<String> {\n         match code {\n             &ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n-                let parent_trait_ref = self.resolve_type_vars_if_possible(\n+                let parent_trait_ref = self.resolve_vars_if_possible(\n                     &data.parent_trait_ref);\n                 match self.get_parent_trait_ref(&data.parent_code) {\n                     Some(t) => Some(t),\n@@ -625,7 +625,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 match obligation.predicate {\n                     ty::Predicate::Trait(ref trait_predicate) => {\n                         let trait_predicate =\n-                            self.resolve_type_vars_if_possible(trait_predicate);\n+                            self.resolve_vars_if_possible(trait_predicate);\n \n                         if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n                             return;\n@@ -749,7 +749,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     }\n \n                     ty::Predicate::RegionOutlives(ref predicate) => {\n-                        let predicate = self.resolve_type_vars_if_possible(predicate);\n+                        let predicate = self.resolve_vars_if_possible(predicate);\n                         let err = self.region_outlives_predicate(&obligation.cause,\n                                                                  &predicate).err().unwrap();\n                         struct_span_err!(\n@@ -761,7 +761,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n                     ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n                         let predicate =\n-                            self.resolve_type_vars_if_possible(&obligation.predicate);\n+                            self.resolve_vars_if_possible(&obligation.predicate);\n                         struct_span_err!(self.tcx.sess, span, E0280,\n                             \"the requirement `{}` is not satisfied\",\n                             predicate)\n@@ -852,8 +852,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             OutputTypeParameterMismatch(ref found_trait_ref, ref expected_trait_ref, _) => {\n-                let found_trait_ref = self.resolve_type_vars_if_possible(&*found_trait_ref);\n-                let expected_trait_ref = self.resolve_type_vars_if_possible(&*expected_trait_ref);\n+                let found_trait_ref = self.resolve_vars_if_possible(&*found_trait_ref);\n+                let expected_trait_ref = self.resolve_vars_if_possible(&*expected_trait_ref);\n \n                 if expected_trait_ref.self_ty().references_error() {\n                     return;\n@@ -1345,7 +1345,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // ambiguous impls. The latter *ought* to be a\n         // coherence violation, so we don't report it here.\n \n-        let predicate = self.resolve_type_vars_if_possible(&obligation.predicate);\n+        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n         let span = obligation.cause.span;\n \n         debug!(\"maybe_report_ambiguity(predicate={:?}, obligation={:?})\",\n@@ -1617,7 +1617,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.note(\"shared static variables must have a type that implements `Sync`\");\n             }\n             ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n-                let parent_trait_ref = self.resolve_type_vars_if_possible(&data.parent_trait_ref);\n+                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n                 let ty = parent_trait_ref.skip_binder().self_ty();\n                 err.note(&format!(\"required because it appears within the type `{}`\", ty));\n                 obligated_types.push(ty);\n@@ -1631,7 +1631,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             ObligationCauseCode::ImplDerivedObligation(ref data) => {\n-                let parent_trait_ref = self.resolve_type_vars_if_possible(&data.parent_trait_ref);\n+                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n                 err.note(\n                     &format!(\"required because of the requirements on the impl of `{}` for `{}`\",\n                              parent_trait_ref,\n@@ -1672,7 +1672,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n                                cause_code: &ObligationCauseCode<'tcx>) -> bool {\n         if let ObligationCauseCode::BuiltinDerivedObligation(ref data) = cause_code {\n-            let parent_trait_ref = self.resolve_type_vars_if_possible(&data.parent_trait_ref);\n+            let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n \n             if obligated_types.iter().any(|ot| ot == &parent_trait_ref.skip_binder().self_ty()) {\n                 return true;"}, {"sha": "c7943d16885bd018e134b4d4e48051dc5305e22d", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -178,7 +178,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     {\n         // this helps to reduce duplicate errors, as well as making\n         // debug output much nicer to read and so on.\n-        let obligation = infcx.resolve_type_vars_if_possible(&obligation);\n+        let obligation = infcx.resolve_vars_if_possible(&obligation);\n \n         debug!(\"register_predicate_obligation(obligation={:?})\", obligation);\n \n@@ -261,7 +261,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n             }) {\n                 debug!(\"process_predicate: pending obligation {:?} still stalled on {:?}\",\n                        self.selcx.infcx()\n-                           .resolve_type_vars_if_possible(&pending_obligation.obligation),\n+                           .resolve_vars_if_possible(&pending_obligation.obligation),\n                        pending_obligation.stalled_on);\n                 return ProcessResult::Unchanged;\n             }\n@@ -272,7 +272,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n \n         if obligation.predicate.has_infer_types() {\n             obligation.predicate =\n-                self.selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n+                self.selcx.infcx().resolve_vars_if_possible(&obligation.predicate);\n         }\n \n         debug!(\"process_obligation: obligation = {:?}\", obligation);\n@@ -318,7 +318,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                             trait_ref_type_vars(self.selcx, data.to_poly_trait_ref());\n \n                         debug!(\"process_predicate: pending obligation {:?} now stalled on {:?}\",\n-                               self.selcx.infcx().resolve_type_vars_if_possible(obligation),\n+                               self.selcx.infcx().resolve_vars_if_possible(obligation),\n                                pending_obligation.stalled_on);\n \n                         ProcessResult::Unchanged\n@@ -519,7 +519,7 @@ fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 't\n {\n     t.skip_binder() // ok b/c this check doesn't care about regions\n      .input_types()\n-     .map(|t| selcx.infcx().resolve_type_vars_if_possible(&t))\n+     .map(|t| selcx.infcx().resolve_vars_if_possible(&t))\n      .filter(|t| t.has_infer_types())\n      .flat_map(|t| t.walk())\n      .filter(|t| match t.sty { ty::Infer(_) => true, _ => false })"}, {"sha": "c135b0b759c6f2d3574917667d4e8db90c41a72a", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -927,7 +927,7 @@ pub fn fully_normalize<'a, 'gcx, 'tcx, T>(\n     debug!(\"fully_normalize: select_all_or_error start\");\n     fulfill_cx.select_all_or_error(infcx)?;\n     debug!(\"fully_normalize: select_all_or_error complete\");\n-    let resolved_value = infcx.resolve_type_vars_if_possible(&normalized_value);\n+    let resolved_value = infcx.resolve_vars_if_possible(&normalized_value);\n     debug!(\"fully_normalize: resolved_value={:?}\", resolved_value);\n     Ok(resolved_value)\n }"}, {"sha": "88bb3172c5e79f84edea0de30cca5d111c2b0653", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -312,7 +312,7 @@ impl<'a, 'b, 'gcx, 'tcx> AssocTypeNormalizer<'a, 'b, 'gcx, 'tcx> {\n     }\n \n     fn fold<T:TypeFoldable<'tcx>>(&mut self, value: &T) -> T {\n-        let value = self.selcx.infcx().resolve_type_vars_if_possible(value);\n+        let value = self.selcx.infcx().resolve_vars_if_possible(value);\n \n         if !value.has_projections() {\n             value\n@@ -508,7 +508,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n {\n     let infcx = selcx.infcx();\n \n-    let projection_ty = infcx.resolve_type_vars_if_possible(&projection_ty);\n+    let projection_ty = infcx.resolve_vars_if_possible(&projection_ty);\n     let cache_key = ProjectionCacheKey { ty: projection_ty };\n \n     debug!(\"opt_normalize_projection_type(\\\n@@ -1614,7 +1614,7 @@ impl<'cx, 'gcx, 'tcx> ProjectionCacheKey<'tcx> {\n                 // from a specific call to `opt_normalize_projection_type` - if\n                 // there's no precise match, the original cache entry is \"stranded\"\n                 // anyway.\n-                ty: infcx.resolve_type_vars_if_possible(&predicate.projection_ty)\n+                ty: infcx.resolve_vars_if_possible(&predicate.projection_ty)\n             })\n     }\n }"}, {"sha": "c4aa14d2b7ebcb69472d82ab5d0db1e3db695668", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -54,7 +54,7 @@ impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n                     &orig_values,\n                     result)\n                 {\n-                    let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n+                    let ty = self.infcx.resolve_vars_if_possible(&ty);\n                     let kinds = value.into_kinds_reporting_overflows(tcx, span, ty);\n                     return InferOk {\n                         value: kinds,"}, {"sha": "5933d2366e81c337a16652a2a5faa0e935d11a59", "filename": "src/librustc/traits/query/type_op/custom.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -97,7 +97,7 @@ fn scrape_region_constraints<'gcx, 'tcx, R>(\n         region_obligations\n             .iter()\n             .map(|(_, r_o)| (r_o.sup_type, r_o.sub_region))\n-            .map(|(ty, r)| (infcx.resolve_type_vars_if_possible(&ty), r)),\n+            .map(|(ty, r)| (infcx.resolve_vars_if_possible(&ty), r)),\n         &region_constraint_data,\n     );\n "}, {"sha": "ba96233b85328191b0491c8e5c0793f410313b62", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -1463,7 +1463,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         let obligation = &stack.obligation;\n         let predicate = self.infcx()\n-            .resolve_type_vars_if_possible(&obligation.predicate);\n+            .resolve_vars_if_possible(&obligation.predicate);\n \n         // OK to skip binder because of the nature of the\n         // trait-ref-is-knowable check, which does not care about\n@@ -1621,7 +1621,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             cause: obligation.cause.clone(),\n             recursion_depth: obligation.recursion_depth,\n             predicate: self.infcx()\n-                .resolve_type_vars_if_possible(&obligation.predicate),\n+                .resolve_vars_if_possible(&obligation.predicate),\n         };\n \n         if obligation.predicate.skip_binder().self_ty().is_ty_var() {\n@@ -1737,7 +1737,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         snapshot: &CombinedSnapshot<'_, 'tcx>,\n     ) -> bool {\n         let poly_trait_predicate = self.infcx()\n-            .resolve_type_vars_if_possible(&obligation.predicate);\n+            .resolve_vars_if_possible(&obligation.predicate);\n         let (placeholder_trait_predicate, placeholder_map) = self.infcx()\n             .replace_bound_vars_with_placeholders(&poly_trait_predicate);\n         debug!("}, {"sha": "b5d45d040fb99e25382a9876e1f2d34bb85b4f5b", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -278,7 +278,7 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n \n                 // Now resolve the *substitution* we built for the target earlier, replacing\n                 // the inference variables inside with whatever we got from fulfillment.\n-                Ok(infcx.resolve_type_vars_if_possible(&target_substs))\n+                Ok(infcx.resolve_vars_if_possible(&target_substs))\n             }\n         }\n     })"}, {"sha": "09426fe19e11eac2c21991aae10fc21dd6c9dc01", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -80,6 +80,12 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             }\n         };\n \n+        macro_rules! pluralise {\n+            ($x:expr) => {\n+                if $x != 1 { \"s\" } else { \"\" }\n+            };\n+        }\n+\n         match *self {\n             CyclicTy(_) => write!(f, \"cyclic type of infinite size\"),\n             Mismatch => write!(f, \"types differ\"),\n@@ -94,17 +100,21 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                        values.found)\n             }\n             Mutability => write!(f, \"types differ in mutability\"),\n-            FixedArraySize(values) => {\n-                write!(f, \"expected an array with a fixed size of {} elements, \\\n-                           found one with {} elements\",\n+            TupleSize(values) => {\n+                write!(f, \"expected a tuple with {} element{}, \\\n+                           found one with {} element{}\",\n                        values.expected,\n-                       values.found)\n+                       pluralise!(values.expected),\n+                       values.found,\n+                       pluralise!(values.found))\n             }\n-            TupleSize(values) => {\n-                write!(f, \"expected a tuple with {} elements, \\\n-                           found one with {} elements\",\n+            FixedArraySize(values) => {\n+                write!(f, \"expected an array with a fixed size of {} element{}, \\\n+                           found one with {} element{}\",\n                        values.expected,\n-                       values.found)\n+                       pluralise!(values.expected),\n+                       values.found,\n+                       pluralise!(values.found))\n             }\n             ArgCount => {\n                 write!(f, \"incorrect number of function parameters\")\n@@ -157,16 +167,17 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                        tcx.def_path_str(values.found))\n             }),\n             ProjectionBoundsLength(ref values) => {\n-                write!(f, \"expected {} associated type bindings, found {}\",\n+                write!(f, \"expected {} associated type binding{}, found {}\",\n                        values.expected,\n+                       pluralise!(values.expected),\n                        values.found)\n             },\n             ExistentialMismatch(ref values) => {\n                 report_maybe_different(f, &format!(\"trait `{}`\", values.expected),\n                                        &format!(\"trait `{}`\", values.found))\n             }\n             ConstMismatch(ref values) => {\n-                write!(f, \"expected `{:?}`, found `{:?}`\", values.expected, values.found)\n+                write!(f, \"expected `{}`, found `{}`\", values.expected, values.found)\n             }\n         }\n     }"}, {"sha": "0440be13a7271faa361d58ee08ba859f74937170", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 46, "deletions": 56, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -8,9 +8,7 @@ use crate::hir::def_id::DefId;\n use crate::ty::subst::{Kind, UnpackedKind, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use crate::ty::error::{ExpectedFound, TypeError};\n-use crate::mir::interpret::{GlobalId, ConstValue, Scalar};\n-use crate::util::common::ErrorReported;\n-use syntax_pos::DUMMY_SP;\n+use crate::mir::interpret::{ConstValue, Scalar, GlobalId};\n use std::rc::Rc;\n use std::iter;\n use rustc_target::spec::abi;\n@@ -474,55 +472,19 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n         (&ty::Array(a_t, sz_a), &ty::Array(b_t, sz_b)) =>\n         {\n             let t = relation.relate(&a_t, &b_t)?;\n-            let to_u64 = |x: ty::Const<'tcx>| -> Result<u64, ErrorReported> {\n-                match x.val {\n-                    // FIXME(const_generics): this doesn't work right now,\n-                    // because it tries to relate an `Infer` to a `Param`.\n-                    ConstValue::Unevaluated(def_id, substs) => {\n-                        // FIXME(eddyb) get the right param_env.\n-                        let param_env = ty::ParamEnv::empty();\n-                        if let Some(substs) = tcx.lift_to_global(&substs) {\n-                            let instance = ty::Instance::resolve(\n-                                tcx.global_tcx(),\n-                                param_env,\n-                                def_id,\n-                                substs,\n-                            );\n-                            if let Some(instance) = instance {\n-                                let cid = GlobalId {\n-                                    instance,\n-                                    promoted: None,\n-                                };\n-                                if let Some(s) = tcx.const_eval(param_env.and(cid))\n-                                                    .ok()\n-                                                    .map(|c| c.unwrap_usize(tcx)) {\n-                                    return Ok(s)\n-                                }\n-                            }\n+            match relation.relate(&sz_a, &sz_b) {\n+                Ok(sz) => Ok(tcx.mk_ty(ty::Array(t, sz))),\n+                Err(err) => {\n+                    // Check whether the lengths are both concrete/known values,\n+                    // but are unequal, for better diagnostics.\n+                    match (sz_a.assert_usize(tcx), sz_b.assert_usize(tcx)) {\n+                        (Some(sz_a_val), Some(sz_b_val)) => {\n+                            Err(TypeError::FixedArraySize(\n+                                expected_found(relation, &sz_a_val, &sz_b_val)\n+                            ))\n                         }\n-                        tcx.sess.delay_span_bug(tcx.def_span(def_id),\n-                            \"array length could not be evaluated\");\n-                        Err(ErrorReported)\n+                        _ => return Err(err),\n                     }\n-                    _ => x.assert_usize(tcx).ok_or_else(|| {\n-                        tcx.sess.delay_span_bug(DUMMY_SP,\n-                            \"array length could not be evaluated\");\n-                        ErrorReported\n-                    })\n-                }\n-            };\n-            match (to_u64(*sz_a), to_u64(*sz_b)) {\n-                (Ok(sz_a_u64), Ok(sz_b_u64)) => {\n-                    if sz_a_u64 == sz_b_u64 {\n-                        Ok(tcx.mk_ty(ty::Array(t, sz_a)))\n-                    } else {\n-                        Err(TypeError::FixedArraySize(\n-                            expected_found(relation, &sz_a_u64, &sz_b_u64)))\n-                    }\n-                }\n-                // We reported an error or will ICE, so we can return Error.\n-                (Err(ErrorReported), _) | (_, Err(ErrorReported)) => {\n-                    Ok(tcx.types.err)\n                 }\n             }\n         }\n@@ -598,11 +560,36 @@ where\n {\n     let tcx = relation.tcx();\n \n+    let eagerly_eval = |x: &'tcx ty::Const<'tcx>| {\n+        if let ConstValue::Unevaluated(def_id, substs) = x.val {\n+            // FIXME(eddyb) get the right param_env.\n+            let param_env = ty::ParamEnv::empty();\n+            if let Some(substs) = tcx.lift_to_global(&substs) {\n+                let instance = ty::Instance::resolve(\n+                    tcx.global_tcx(),\n+                    param_env,\n+                    def_id,\n+                    substs,\n+                );\n+                if let Some(instance) = instance {\n+                    let cid = GlobalId {\n+                        instance,\n+                        promoted: None,\n+                    };\n+                    if let Ok(ct) = tcx.const_eval(param_env.and(cid)) {\n+                        return ct.val;\n+                    }\n+                }\n+            }\n+        }\n+        x.val\n+    };\n+\n     // Currently, the values that can be unified are those that\n     // implement both `PartialEq` and `Eq`, corresponding to\n     // `structural_match` types.\n     // FIXME(const_generics): check for `structural_match` synthetic attribute.\n-    match (a.val, b.val) {\n+    match (eagerly_eval(a), eagerly_eval(b)) {\n         (ConstValue::Infer(_), _) | (_, ConstValue::Infer(_)) => {\n             // The caller should handle these cases!\n             bug!(\"var types encountered in super_relate_consts: {:?} {:?}\", a, b)\n@@ -613,8 +600,13 @@ where\n         (ConstValue::Placeholder(p1), ConstValue::Placeholder(p2)) if p1 == p2 => {\n             Ok(a)\n         }\n-        (ConstValue::Scalar(Scalar::Raw { .. }), _) if a == b => {\n-            Ok(a)\n+        (a_val @ ConstValue::Scalar(Scalar::Raw { .. }), b_val @ _)\n+            if a.ty == b.ty && a_val == b_val =>\n+        {\n+            Ok(tcx.mk_const(ty::Const {\n+                val: a_val,\n+                ty: a.ty,\n+            }))\n         }\n         (ConstValue::ByRef(..), _) => {\n             bug!(\n@@ -635,9 +627,7 @@ where\n                 }))\n             }\n \n-            _ => {\n-            Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n-        }\n+        _ => Err(TypeError::ConstMismatch(expected_found(relation, &a, &b))),\n     }\n }\n "}, {"sha": "20b7f7eef0a16d4f06b3d433d799971f4ae98b66", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -1263,7 +1263,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         debug!(\n                             \"eq_opaque_type_and_type: concrete_ty={:?}={:?} opaque_defn_ty={:?}\",\n                             opaque_decl.concrete_ty,\n-                            infcx.resolve_type_vars_if_possible(&opaque_decl.concrete_ty),\n+                            infcx.resolve_vars_if_possible(&opaque_decl.concrete_ty),\n                             opaque_defn_ty\n                         );\n                         obligations.add(infcx"}, {"sha": "96c647ca31e6fca339194abb83faba601471d514", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -411,7 +411,7 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     }\n \n     fn debug_ex_clause(&mut self, value: &'v ChalkExClause<'tcx>) -> Box<dyn Debug + 'v> {\n-        let string = format!(\"{:?}\", self.infcx.resolve_type_vars_if_possible(value));\n+        let string = format!(\"{:?}\", self.infcx.resolve_vars_if_possible(value));\n         Box::new(string)\n     }\n "}, {"sha": "c1f14cd3f8ed51e182382e2fc33ede2103625ca7", "filename": "src/librustc_traits/chalk_context/program_clauses/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -57,7 +57,7 @@ impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n         use rustc::traits::WhereClause::*;\n         use rustc::infer::canonical::OriginalQueryValues;\n \n-        let goal = self.infcx.resolve_type_vars_if_possible(goal);\n+        let goal = self.infcx.resolve_vars_if_possible(goal);\n \n         debug!(\"program_clauses(goal = {:?})\", goal);\n "}, {"sha": "f1b8588790b72a4fe3fbbdb3c2399b17c95e6594", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -111,8 +111,8 @@ impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     ) -> Fallible<ChalkExClause<'tcx>> {\n         debug!(\n             \"apply_answer_subst(ex_clause = {:?}, selected_goal = {:?})\",\n-            self.infcx.resolve_type_vars_if_possible(&ex_clause),\n-            self.infcx.resolve_type_vars_if_possible(selected_goal)\n+            self.infcx.resolve_vars_if_possible(&ex_clause),\n+            self.infcx.resolve_vars_if_possible(selected_goal)\n         );\n \n         let (answer_subst, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars("}, {"sha": "73bb3fb5b9a2de6972ccf3e3b86f1a0d4091b250", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -121,7 +121,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n                 ty::Predicate::TypeOutlives(ref data) => match data.no_bound_vars() {\n                     None => vec![],\n                     Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                        let ty_a = infcx.resolve_type_vars_if_possible(&ty_a);\n+                        let ty_a = infcx.resolve_vars_if_possible(&ty_a);\n                         let mut components = smallvec![];\n                         tcx.push_outlives_components(ty_a, &mut components);\n                         implied_bounds_from_components(r_b, components)"}, {"sha": "24fa5e97752a67e84e526e67219402bdb473876f", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -36,7 +36,7 @@ fn normalize_ty_after_erasing_regions<'tcx>(\n                     None,\n                 );\n \n-                let normalized_value = infcx.resolve_type_vars_if_possible(&normalized_value);\n+                let normalized_value = infcx.resolve_vars_if_possible(&normalized_value);\n                 let normalized_value = infcx.tcx.erase_regions(&normalized_value);\n                 tcx.lift_to_global(&normalized_value).unwrap()\n             }"}, {"sha": "5a84e0cb85a6ec0643c7153be6ee40daf9731ffc", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -226,7 +226,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // Now that we know the types can be unified we find the unified type and use\n                 // it to type the entire expression.\n-                let common_type = self.resolve_type_vars_if_possible(&lhs_ty);\n+                let common_type = self.resolve_vars_if_possible(&lhs_ty);\n \n                 // subtyping doesn't matter here, as the value is some kind of scalar\n                 self.demand_eqtype_pat(pat.span, expected, lhs_ty, discrim_span);"}, {"sha": "38c3ee776369aa49c750803067fef773a4e08f46", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n             body_id,\n             param_env,\n             steps: vec![],\n-            cur_ty: infcx.resolve_type_vars_if_possible(&base_ty),\n+            cur_ty: infcx.resolve_vars_if_possible(&base_ty),\n             obligations: vec![],\n             at_start: true,\n             include_raw_pointers: false,\n@@ -152,7 +152,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n                ty, normalized_ty, obligations);\n         self.obligations.extend(obligations);\n \n-        Some(self.infcx.resolve_type_vars_if_possible(&normalized_ty))\n+        Some(self.infcx.resolve_vars_if_possible(&normalized_ty))\n     }\n \n     /// Returns the final type, generating an error if it is an\n@@ -164,7 +164,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n     /// Returns the final type we ended up with, which may well be an\n     /// inference variable (we will resolve it first, if possible).\n     pub fn maybe_ambiguous_final_ty(&self) -> Ty<'tcx> {\n-        self.infcx.resolve_type_vars_if_possible(&self.cur_ty)\n+        self.infcx.resolve_vars_if_possible(&self.cur_ty)\n     }\n \n     pub fn step_count(&self) -> usize {"}, {"sha": "f8cad733ca1c87abcc292ab32d8998dc58d3f52f", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -82,7 +82,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     {\n         debug!(\"pointer_kind({:?}, {:?})\", t, span);\n \n-        let t = self.resolve_type_vars_if_possible(&t);\n+        let t = self.resolve_vars_if_possible(&t);\n \n         if t.references_error() {\n             return Err(ErrorReported);\n@@ -334,7 +334,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         let tstr = fcx.ty_to_string(self.cast_ty);\n         let mut err = type_error_struct!(fcx.tcx.sess, self.span, self.expr_ty, E0620,\n                                          \"cast to unsized type: `{}` as `{}`\",\n-                                         fcx.resolve_type_vars_if_possible(&self.expr_ty),\n+                                         fcx.resolve_vars_if_possible(&self.expr_ty),\n                                          tstr);\n         match self.expr_ty.sty {\n             ty::Ref(_, _, mt) => {"}, {"sha": "419f61b0ee2c061444fcedd18eeb585f45eb9a7b", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -282,7 +282,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let input_tys = if is_fn {\n             let arg_param_ty = trait_ref.skip_binder().substs.type_at(1);\n-            let arg_param_ty = self.resolve_type_vars_if_possible(&arg_param_ty);\n+            let arg_param_ty = self.resolve_vars_if_possible(&arg_param_ty);\n             debug!(\"deduce_sig_from_projection: arg_param_ty={:?}\", arg_param_ty);\n \n             match arg_param_ty.sty {\n@@ -295,7 +295,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         let ret_param_ty = projection.skip_binder().ty;\n-        let ret_param_ty = self.resolve_type_vars_if_possible(&ret_param_ty);\n+        let ret_param_ty = self.resolve_vars_if_possible(&ret_param_ty);\n         debug!(\"deduce_sig_from_projection: ret_param_ty={:?}\", ret_param_ty);\n \n         let sig = self.tcx.mk_fn_sig("}, {"sha": "d64be24f7538f548fbb0eedc44b8110bf1a623bf", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -575,7 +575,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 // Uncertain or unimplemented.\n                 Ok(None) => {\n                     if trait_ref.def_id() == unsize_did {\n-                        let trait_ref = self.resolve_type_vars_if_possible(&trait_ref);\n+                        let trait_ref = self.resolve_vars_if_possible(&trait_ref);\n                         let self_ty = trait_ref.skip_binder().self_ty();\n                         let unsize_ty = trait_ref.skip_binder().input_types().nth(1).unwrap();\n                         debug!(\"coerce_unsized: ambiguous unsize case for {:?}\", trait_ref);"}, {"sha": "3785c3c8684b4961ba835a0636c8e9fcb1e0cf8c", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -48,7 +48,7 @@ impl<'a, 'gcx, 'tcx> InteriorVisitor<'a, 'gcx, 'tcx> {\n         });\n \n         if let Some(yield_span) = live_across_yield {\n-            let ty = self.fcx.resolve_type_vars_if_possible(&ty);\n+            let ty = self.fcx.resolve_vars_if_possible(&ty);\n \n             debug!(\"type in expr = {:?}, scope = {:?}, type = {:?}, count = {}, yield_span = {:?}\",\n                    expr, scope, ty, self.expr_count, yield_span);"}, {"sha": "493486321ac2fed0e8dacfb92024984370e0617a", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -511,7 +511,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         let base_ty = self.tables.borrow().expr_adjustments(base_expr).last()\n             .map_or_else(|| self.node_ty(expr.hir_id), |adj| adj.target);\n-        let base_ty = self.resolve_type_vars_if_possible(&base_ty);\n+        let base_ty = self.resolve_vars_if_possible(&base_ty);\n \n         // Need to deref because overloaded place ops take self by-reference.\n         let base_ty = base_ty.builtin_deref(false)"}, {"sha": "213d53cf48254a38ca10619e1c8d2e6a0f10cc13", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     scope: ProbeScope)\n                     -> probe::PickResult<'tcx> {\n         let mode = probe::Mode::MethodCall;\n-        let self_ty = self.resolve_type_vars_if_possible(&self_ty);\n+        let self_ty = self.resolve_vars_if_possible(&self_ty);\n         self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n                             self_ty, call_expr.hir_id, scope)\n     }"}, {"sha": "d78e013708277f15f2a1260df49e8b3f28a2dce5", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -1338,7 +1338,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                             // and point at it rather than reporting the entire\n                             // trait-ref?\n                             result = ProbeResult::NoMatch;\n-                            let trait_ref = self.resolve_type_vars_if_possible(&trait_ref);\n+                            let trait_ref = self.resolve_vars_if_possible(&trait_ref);\n                             possibly_unsatisfied_predicates.push(trait_ref);\n                         }\n                     }\n@@ -1351,7 +1351,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n             // Evaluate those obligations to see if they might possibly hold.\n             for o in candidate_obligations.into_iter().chain(sub_obligations) {\n-                let o = self.resolve_type_vars_if_possible(&o);\n+                let o = self.resolve_vars_if_possible(&o);\n                 if !self.predicate_may_hold(&o) {\n                     result = ProbeResult::NoMatch;\n                     if let &ty::Predicate::Trait(ref pred) = &o.predicate {\n@@ -1364,7 +1364,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 if let (Some(return_ty), Some(xform_ret_ty)) =\n                     (self.return_type, probe.xform_ret_ty)\n                 {\n-                    let xform_ret_ty = self.resolve_type_vars_if_possible(&xform_ret_ty);\n+                    let xform_ret_ty = self.resolve_vars_if_possible(&xform_ret_ty);\n                     debug!(\"comparing return_ty {:?} with xform ret ty {:?}\",\n                            return_ty,\n                            probe.xform_ret_ty);"}, {"sha": "d2fcb987bc2d853958a187c9b1778a64bb4735d9", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -196,7 +196,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }) => {\n                 let tcx = self.tcx;\n \n-                let actual = self.resolve_type_vars_if_possible(&rcvr_ty);\n+                let actual = self.resolve_vars_if_possible(&rcvr_ty);\n                 let ty_str = self.ty_to_string(actual);\n                 let is_method = mode == Mode::MethodCall;\n                 let item_kind = if is_method {"}, {"sha": "8701d751f2d91aefb234162a2282496254aab30a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -330,13 +330,13 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n         match self {\n             NoExpectation => NoExpectation,\n             ExpectCastableToType(t) => {\n-                ExpectCastableToType(fcx.resolve_type_vars_if_possible(&t))\n+                ExpectCastableToType(fcx.resolve_vars_if_possible(&t))\n             }\n             ExpectHasType(t) => {\n-                ExpectHasType(fcx.resolve_type_vars_if_possible(&t))\n+                ExpectHasType(fcx.resolve_vars_if_possible(&t))\n             }\n             ExpectRvalueLikeUnsized(t) => {\n-                ExpectRvalueLikeUnsized(fcx.resolve_type_vars_if_possible(&t))\n+                ExpectRvalueLikeUnsized(fcx.resolve_vars_if_possible(&t))\n             }\n         }\n     }\n@@ -2067,7 +2067,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Resolves type variables in `ty` if possible. Unlike the infcx\n-    /// version (resolve_type_vars_if_possible), this version will\n+    /// version (resolve_vars_if_possible), this version will\n     /// also select obligations if it seems useful, in an effort\n     /// to get more type information.\n     fn resolve_type_vars_with_obligations(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n@@ -2080,7 +2080,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // If `ty` is a type variable, see whether we already know what it is.\n-        ty = self.resolve_type_vars_if_possible(&ty);\n+        ty = self.resolve_vars_if_possible(&ty);\n         if !ty.has_infer_types() {\n             debug!(\"resolve_type_vars_with_obligations: ty={:?}\", ty);\n             return ty;\n@@ -2091,7 +2091,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // indirect dependencies that don't seem worth tracking\n         // precisely.\n         self.select_obligations_where_possible(false);\n-        ty = self.resolve_type_vars_if_possible(&ty);\n+        ty = self.resolve_vars_if_possible(&ty);\n \n         debug!(\"resolve_type_vars_with_obligations: ty={:?}\", ty);\n         ty\n@@ -2127,7 +2127,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     #[inline]\n     pub fn write_ty(&self, id: hir::HirId, ty: Ty<'tcx>) {\n         debug!(\"write_ty({:?}, {:?}) in fcx {}\",\n-               id, self.resolve_type_vars_if_possible(&ty), self.tag());\n+               id, self.resolve_vars_if_possible(&ty), self.tag());\n         self.tables.borrow_mut().node_types_mut().insert(id, ty);\n \n         if ty.references_error() {\n@@ -2950,9 +2950,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         } else {\n             // is the missing argument of type `()`?\n             let sugg_unit = if expected_arg_tys.len() == 1 && supplied_arg_count == 0 {\n-                self.resolve_type_vars_if_possible(&expected_arg_tys[0]).is_unit()\n+                self.resolve_vars_if_possible(&expected_arg_tys[0]).is_unit()\n             } else if fn_inputs.len() == 1 && supplied_arg_count == 0 {\n-                self.resolve_type_vars_if_possible(&fn_inputs[0]).is_unit()\n+                self.resolve_vars_if_possible(&fn_inputs[0]).is_unit()\n             } else {\n                 false\n             };\n@@ -3063,7 +3063,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     ty::FnDef(..) => {\n                         let ptr_ty = self.tcx.mk_fn_ptr(arg_ty.fn_sig(self.tcx));\n-                        let ptr_ty = self.resolve_type_vars_if_possible(&ptr_ty);\n+                        let ptr_ty = self.resolve_vars_if_possible(&ptr_ty);\n                         variadic_error(tcx.sess, arg.span, arg_ty, &ptr_ty.to_string());\n                     }\n                     _ => {}\n@@ -3253,7 +3253,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // Record all the argument types, with the substitutions\n             // produced from the above subtyping unification.\n             Ok(formal_args.iter().map(|ty| {\n-                self.resolve_type_vars_if_possible(ty)\n+                self.resolve_vars_if_possible(ty)\n             }).collect())\n         }).unwrap_or_default();\n         debug!(\"expected_inputs_for_expected_output(formal={:?} -> {:?}, expected={:?} -> {:?})\",\n@@ -4333,9 +4333,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Find the type of `e`. Supply hints based on the type we are casting to,\n                 // if appropriate.\n                 let t_cast = self.to_ty_saving_user_provided_ty(t);\n-                let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n+                let t_cast = self.resolve_vars_if_possible(&t_cast);\n                 let t_expr = self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n-                let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n+                let t_cast = self.resolve_vars_if_possible(&t_cast);\n \n                 // Eagerly check for some obvious errors.\n                 if t_expr.references_error() || t_cast.references_error() {"}, {"sha": "0bab63582aaa1830dad70f7819b96036a1192b79", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -618,7 +618,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 method.sig.output()\n             }\n             Err(()) => {\n-                let actual = self.resolve_type_vars_if_possible(&operand_ty);\n+                let actual = self.resolve_vars_if_possible(&operand_ty);\n                 if !actual.references_error() {\n                     let mut err = struct_span_err!(self.tcx.sess, ex.span, E0600,\n                                      \"cannot apply unary operator `{}` to type `{}`\","}, {"sha": "62c9c7c8b1c37d9446dd2c565d5f79e620a9a2e1", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -270,7 +270,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// of b will be `&<R0>.i32` and then `*b` will require that `<R0>` be bigger than the let and\n     /// the `*b` expression, so we will effectively resolve `<R0>` to be the block B.\n     pub fn resolve_type(&self, unresolved_ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.resolve_type_vars_if_possible(&unresolved_ty)\n+        self.resolve_vars_if_possible(&unresolved_ty)\n     }\n \n     /// Try to resolve the type for the given node."}, {"sha": "a856013b719fea3708e40c6f5d60454fadb7f950", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -138,7 +138,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             hir::ExprKind::Unary(hir::UnNeg, ref inner)\n             | hir::ExprKind::Unary(hir::UnNot, ref inner) => {\n                 let inner_ty = self.fcx.node_ty(inner.hir_id);\n-                let inner_ty = self.fcx.resolve_type_vars_if_possible(&inner_ty);\n+                let inner_ty = self.fcx.resolve_vars_if_possible(&inner_ty);\n \n                 if inner_ty.is_scalar() {\n                     let mut tables = self.fcx.tables.borrow_mut();\n@@ -149,10 +149,10 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             hir::ExprKind::Binary(ref op, ref lhs, ref rhs)\n             | hir::ExprKind::AssignOp(ref op, ref lhs, ref rhs) => {\n                 let lhs_ty = self.fcx.node_ty(lhs.hir_id);\n-                let lhs_ty = self.fcx.resolve_type_vars_if_possible(&lhs_ty);\n+                let lhs_ty = self.fcx.resolve_vars_if_possible(&lhs_ty);\n \n                 let rhs_ty = self.fcx.node_ty(rhs.hir_id);\n-                let rhs_ty = self.fcx.resolve_type_vars_if_possible(&rhs_ty);\n+                let rhs_ty = self.fcx.resolve_vars_if_possible(&rhs_ty);\n \n                 if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n                     let mut tables = self.fcx.tables.borrow_mut();\n@@ -192,7 +192,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             // All valid indexing looks like this; might encounter non-valid indexes at this point\n             if let ty::Ref(_, base_ty, _) = tables.expr_ty_adjusted(&base).sty {\n                 let index_ty = tables.expr_ty_adjusted(&index);\n-                let index_ty = self.fcx.resolve_type_vars_if_possible(&index_ty);\n+                let index_ty = self.fcx.resolve_vars_if_possible(&index_ty);\n \n                 if base_ty.builtin_index().is_some() && index_ty == self.fcx.tcx.types.usize {\n                     // Remove the method call record"}, {"sha": "2696aea5e89931bfa7e6287a80fe4db5464f3e36", "filename": "src/test/ui/array-break-length.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Farray-break-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Farray-break-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-break-length.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -1,9 +1,11 @@\n fn main() {\n     loop {\n         |_: [_; break]| {} //~ ERROR: `break` outside of loop\n+        //~^ ERROR mismatched types\n     }\n \n     loop {\n         |_: [_; continue]| {} //~ ERROR: `continue` outside of loop\n+        //~^ ERROR mismatched types\n     }\n }"}, {"sha": "0e0dc8f623e6815cd98feaae98cf9605198ea1cf", "filename": "src/test/ui/array-break-length.stderr", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Farray-break-length.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Farray-break-length.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-break-length.stderr?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -5,11 +5,30 @@ LL |         |_: [_; break]| {}\n    |                 ^^^^^ cannot break outside of a loop\n \n error[E0268]: `continue` outside of loop\n-  --> $DIR/array-break-length.rs:7:17\n+  --> $DIR/array-break-length.rs:8:17\n    |\n LL |         |_: [_; continue]| {}\n    |                 ^^^^^^^^ cannot break outside of a loop\n \n-error: aborting due to 2 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/array-break-length.rs:3:9\n+   |\n+LL |         |_: [_; break]| {}\n+   |         ^^^^^^^^^^^^^^^^^^ expected (), found closure\n+   |\n+   = note: expected type `()`\n+              found type `[closure@$DIR/array-break-length.rs:3:9: 3:27]`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/array-break-length.rs:8:9\n+   |\n+LL |         |_: [_; continue]| {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^ expected (), found closure\n+   |\n+   = note: expected type `()`\n+              found type `[closure@$DIR/array-break-length.rs:8:9: 8:30]`\n+\n+error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0268`.\n+Some errors have detailed explanations: E0268, E0308.\n+For more information about an error, try `rustc --explain E0268`."}, {"sha": "a7f16d70ba8600d083f246acc285f0f9c6fb24d7", "filename": "src/test/ui/closures/closure-array-break-length.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fclosures%2Fclosure-array-break-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fclosures%2Fclosure-array-break-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-array-break-length.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -2,6 +2,8 @@ fn main() {\n     |_: [_; continue]| {}; //~ ERROR: `continue` outside of loop\n \n     while |_: [_; continue]| {} {} //~ ERROR: `continue` outside of loop\n+    //~^ ERROR mismatched types\n \n     while |_: [_; break]| {} {} //~ ERROR: `break` outside of loop\n+    //~^ ERROR mismatched types\n }"}, {"sha": "46fbd3e0fae0be8d7b980ff9971850bc3d23b502", "filename": "src/test/ui/closures/closure-array-break-length.stderr", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fclosures%2Fclosure-array-break-length.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fclosures%2Fclosure-array-break-length.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-array-break-length.stderr?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -11,11 +11,30 @@ LL |     while |_: [_; continue]| {} {}\n    |                   ^^^^^^^^ cannot break outside of a loop\n \n error[E0268]: `break` outside of loop\n-  --> $DIR/closure-array-break-length.rs:6:19\n+  --> $DIR/closure-array-break-length.rs:7:19\n    |\n LL |     while |_: [_; break]| {} {}\n    |                   ^^^^^ cannot break outside of a loop\n \n-error: aborting due to 3 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/closure-array-break-length.rs:4:11\n+   |\n+LL |     while |_: [_; continue]| {} {}\n+   |           ^^^^^^^^^^^^^^^^^^^^^ expected bool, found closure\n+   |\n+   = note: expected type `bool`\n+              found type `[closure@$DIR/closure-array-break-length.rs:4:11: 4:32]`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/closure-array-break-length.rs:7:11\n+   |\n+LL |     while |_: [_; break]| {} {}\n+   |           ^^^^^^^^^^^^^^^^^^ expected bool, found closure\n+   |\n+   = note: expected type `bool`\n+              found type `[closure@$DIR/closure-array-break-length.rs:7:11: 7:29]`\n+\n+error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0268`.\n+Some errors have detailed explanations: E0268, E0308.\n+For more information about an error, try `rustc --explain E0268`."}, {"sha": "9a11bd3d0313a5802d6c9a292d6bd792be8cbd97", "filename": "src/test/ui/const-generics/broken-mir-1.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-1.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+pub trait Foo {\n+    fn foo(&self);\n+}\n+\n+\n+impl<T, const N: usize> Foo for [T; N] {\n+    fn foo(&self) {\n+        let _ = &self;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "55dc7fcb7cc722a2e08cb88bbfc78ba5cac0f6f5", "filename": "src/test/ui/const-generics/broken-mir-1.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-1.stderr?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -0,0 +1,6 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/broken-mir-1.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+"}, {"sha": "fb9a63ea738fa8767a768be2ec300bc50bb336a4", "filename": "src/test/ui/const-generics/broken-mir-2.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-2.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -0,0 +1,9 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+use std::fmt::Debug;\n+\n+#[derive(Debug)]\n+struct S<T: Debug, const N: usize>([T; N]); //~ ERROR `[T; _]` doesn't implement `std::fmt::Debug`\n+\n+fn main() {}"}, {"sha": "fb9b88bde0a259ebc88e6822c61740b98d1d5b90", "filename": "src/test/ui/const-generics/broken-mir-2.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-2.stderr?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -0,0 +1,19 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/broken-mir-2.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+\n+error[E0277]: `[T; _]` doesn't implement `std::fmt::Debug`\n+  --> $DIR/broken-mir-2.rs:7:36\n+   |\n+LL | struct S<T: Debug, const N: usize>([T; N]);\n+   |                                    ^^^^^^ `[T; _]` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+   |\n+   = help: the trait `std::fmt::Debug` is not implemented for `[T; _]`\n+   = note: required because of the requirements on the impl of `std::fmt::Debug` for `&[T; _]`\n+   = note: required for the cast to the object type `dyn std::fmt::Debug`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "26496ec4a90b9d7f80d82cc7dac1547be37249c1", "filename": "src/test/ui/const-generics/cannot-infer-type-for-const-param.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-type-for-const-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-type-for-const-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-type-for-const-param.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -8,4 +8,5 @@ struct Foo<const NUM_BYTES: usize>(pub [u8; NUM_BYTES]);\n \n fn main() {\n     let _ = Foo::<3>([1, 2, 3]); //~ ERROR type annotations needed\n+    //~^ ERROR mismatched types\n }"}, {"sha": "fb151648f2f9b9b3d0e9e5aa14f83b6b2b74650b", "filename": "src/test/ui/const-generics/cannot-infer-type-for-const-param.stderr", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-type-for-const-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-type-for-const-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-type-for-const-param.stderr?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -10,6 +10,16 @@ error[E0282]: type annotations needed\n LL |     let _ = Foo::<3>([1, 2, 3]);\n    |                   ^ cannot infer type for `{integer}`\n \n-error: aborting due to previous error\n+error[E0308]: mismatched types\n+  --> $DIR/cannot-infer-type-for-const-param.rs:10:22\n+   |\n+LL |     let _ = Foo::<3>([1, 2, 3]);\n+   |                      ^^^^^^^^^ expected `3`, found `3usize`\n+   |\n+   = note: expected type `[u8; _]`\n+              found type `[u8; 3]`\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0282`.\n+Some errors have detailed explanations: E0282, E0308.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "d3d17cca4da27a7e65c022f4c766e439d71079f2", "filename": "src/test/ui/const-generics/fn-taking-const-generic-array.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Ffn-taking-const-generic-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Ffn-taking-const-generic-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-taking-const-generic-array.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -0,0 +1,16 @@\n+// run-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+use std::fmt::Display;\n+\n+fn print_slice<T: Display, const N: usize>(slice: &[T; N]) {\n+    for x in slice.iter() {\n+        println!(\"{}\", x);\n+    }\n+}\n+\n+fn main() {\n+    print_slice(&[1, 2, 3]);\n+}"}, {"sha": "367041283251fcf5fb6c298d0cf7158831f4f524", "filename": "src/test/ui/const-generics/fn-taking-const-generic-array.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Ffn-taking-const-generic-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Ffn-taking-const-generic-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-taking-const-generic-array.stderr?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -0,0 +1,6 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/fn-taking-const-generic-array.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+"}, {"sha": "1e064fbd970640044e53cd22a2d2d9a0fa6b6d50", "filename": "src/test/ui/const-generics/uninferred-consts-during-codegen-1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-1.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -0,0 +1,18 @@\n+// run-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+use std::fmt;\n+\n+struct Array<T, const N: usize>([T; N]);\n+\n+impl<T: fmt::Debug, const N: usize> fmt::Debug for Array<T, {N}> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_list().entries(self.0.iter()).finish()\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(format!(\"{:?}\", Array([1, 2, 3])), \"[1, 2, 3]\");\n+}"}, {"sha": "eb2e446396c3380448e3b24cd40dca8ca597e592", "filename": "src/test/ui/const-generics/uninferred-consts-during-codegen-1.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-1.stderr?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -0,0 +1,6 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/uninferred-consts-during-codegen-1.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+"}, {"sha": "0cf505906f626ee873e8d0df42ef26c993169753", "filename": "src/test/ui/const-generics/uninferred-consts-during-codegen-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-2.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -0,0 +1,18 @@\n+// run-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+use std::fmt;\n+\n+struct Array<T>(T);\n+\n+impl<T: fmt::Debug, const N: usize> fmt::Debug for Array<[T; N]> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_list().entries((&self.0 as &[T]).iter()).finish()\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(format!(\"{:?}\", Array([1, 2, 3])), \"[1, 2, 3]\");\n+}"}, {"sha": "eaa20bb7892226204560f5cc3f0da9cbcbcbb420", "filename": "src/test/ui/const-generics/uninferred-consts-during-codegen-2.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-2.stderr?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -0,0 +1,6 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/uninferred-consts-during-codegen-2.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+"}, {"sha": "2f5661e32a90e37dde994653e5b6472649e4e423", "filename": "src/test/ui/consts/const-array-oob-arith.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconsts%2Fconst-array-oob-arith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconsts%2Fconst-array-oob-arith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-array-oob-arith.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -4,8 +4,12 @@ const ARR: [i32; 6] = [42, 43, 44, 45, 46, 47];\n const IDX: usize = 3;\n const VAL: i32 = ARR[IDX];\n const BONG: [i32; (ARR[0] - 41) as usize] = [5];\n-const BLUB: [i32; (ARR[0] - 40) as usize] = [5]; //~ ERROR: mismatched types\n-const BOO: [i32; (ARR[0] - 41) as usize] = [5, 99]; //~ ERROR: mismatched types\n+const BLUB: [i32; (ARR[0] - 40) as usize] = [5];\n+//~^ ERROR: mismatched types\n+//~| expected an array with a fixed size of 2 elements, found one with 1 element\n+const BOO: [i32; (ARR[0] - 41) as usize] = [5, 99];\n+//~^ ERROR: mismatched types\n+//~| expected an array with a fixed size of 1 element, found one with 2 elements\n \n fn main() {\n     let _ = VAL;"}, {"sha": "987e7ddf4d91e66ce42ee0236319ac6b1fa8fd2b", "filename": "src/test/ui/consts/const-array-oob-arith.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconsts%2Fconst-array-oob-arith.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Fconsts%2Fconst-array-oob-arith.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-array-oob-arith.stderr?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -2,16 +2,16 @@ error[E0308]: mismatched types\n   --> $DIR/const-array-oob-arith.rs:7:45\n    |\n LL | const BLUB: [i32; (ARR[0] - 40) as usize] = [5];\n-   |                                             ^^^ expected an array with a fixed size of 2 elements, found one with 1 elements\n+   |                                             ^^^ expected an array with a fixed size of 2 elements, found one with 1 element\n    |\n    = note: expected type `[i32; 2]`\n               found type `[i32; 1]`\n \n error[E0308]: mismatched types\n-  --> $DIR/const-array-oob-arith.rs:8:44\n+  --> $DIR/const-array-oob-arith.rs:10:44\n    |\n LL | const BOO: [i32; (ARR[0] - 41) as usize] = [5, 99];\n-   |                                            ^^^^^^^ expected an array with a fixed size of 1 elements, found one with 2 elements\n+   |                                            ^^^^^^^ expected an array with a fixed size of 1 element, found one with 2 elements\n    |\n    = note: expected type `[i32; 1]`\n               found type `[i32; 2]`"}, {"sha": "4f505c05a6a2ce9021d7c263138a573318988007", "filename": "src/test/ui/tuple/tuple-arity-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Ftuple%2Ftuple-arity-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Ftuple%2Ftuple-arity-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Ftuple-arity-mismatch.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -13,5 +13,5 @@ fn main() {\n     //~^ ERROR mismatched types\n     //~| expected type `(isize, f64)`\n     //~| found type `(isize,)`\n-    //~| expected a tuple with 2 elements, found one with 1 elements\n+    //~| expected a tuple with 2 elements, found one with 1 element\n }"}, {"sha": "6946a60c59af9b1e6a0bef1a55cf9d86369b7514", "filename": "src/test/ui/tuple/tuple-arity-mismatch.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Ftuple%2Ftuple-arity-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Ftuple%2Ftuple-arity-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Ftuple-arity-mismatch.stderr?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -11,7 +11,7 @@ error[E0308]: mismatched types\n   --> $DIR/tuple-arity-mismatch.rs:12:20\n    |\n LL |     let y = first ((1,));\n-   |                    ^^^^ expected a tuple with 2 elements, found one with 1 elements\n+   |                    ^^^^ expected a tuple with 2 elements, found one with 1 element\n    |\n    = note: expected type `(isize, f64)`\n               found type `(isize,)`"}, {"sha": "5ad50ffcbc389cabdef2eba58d1d284275495aed", "filename": "src/test/ui/type/type-dependent-def-issue-49241.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.rs?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -3,4 +3,5 @@ fn main() {\n     const l: usize = v.count(); //~ ERROR attempt to use a non-constant value in a constant\n     let s: [u32; l] = v.into_iter().collect();\n     //~^ ERROR evaluation of constant value failed\n+    //~^^ ERROR a collection of type\n }"}, {"sha": "851004d10589712426b56cbdf720aba562b201fb", "filename": "src/test/ui/type/type-dependent-def-issue-49241.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d85e256a874b6f1082ef6d51d81630f2f2fd2769/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.stderr?ref=d85e256a874b6f1082ef6d51d81630f2f2fd2769", "patch": "@@ -10,7 +10,15 @@ error[E0080]: evaluation of constant value failed\n LL |     let s: [u32; l] = v.into_iter().collect();\n    |                  ^ referenced constant has errors\n \n-error: aborting due to 2 previous errors\n+error[E0277]: a collection of type `[u32; _]` cannot be built from an iterator over elements of type `{integer}`\n+  --> $DIR/type-dependent-def-issue-49241.rs:4:37\n+   |\n+LL |     let s: [u32; l] = v.into_iter().collect();\n+   |                                     ^^^^^^^ a collection of type `[u32; _]` cannot be built from `std::iter::Iterator<Item={integer}>`\n+   |\n+   = help: the trait `std::iter::FromIterator<{integer}>` is not implemented for `[u32; _]`\n+\n+error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0080, E0435.\n+Some errors have detailed explanations: E0080, E0277, E0435.\n For more information about an error, try `rustc --explain E0080`."}]}