{"sha": "df2e8bb5940a9bca7bc455189f4ea5e70a071fb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmMmU4YmI1OTQwYTliY2E3YmM0NTUxODlmNGVhNWU3MGEwNzFmYjg=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-07-31T22:06:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-07-31T22:06:31Z"}, "message": "Merge pull request #2873 from aloucks/auto-detect-newline-style\n\nAuto-detect newline style by default", "tree": {"sha": "422721f631d2425865eb50d184c576449b4b87c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/422721f631d2425865eb50d184c576449b4b87c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df2e8bb5940a9bca7bc455189f4ea5e70a071fb8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbYN1nCRBK7hj4Ov3rIwAAdHIIAEVVFKth0WaDoz70KNH3H+Jm\nU0WvY5VMXf6PA6rXTjTlqzNyT8Rg5Su790F4DZByg+/00N1mnizCLa/T7ytfKYSh\nryVieV/S6DGKj3b65qZLMEDcm66/lfCXedMFLc6Wth1rERMi8sZHYlbmzBWaxxm5\ncjVehqkMAxZ3CCi2tEEHNOIrBPkd/YIEK+espvVAferu5mCxaJwitcEOVGM53IsZ\nMmABRCF0XxuZ/8GI5nO4D5nAl3Af/uO2jYKpbqOVEqV/+Co1Qn8O8ps1e2D4TdfY\nQ90xPvXLbFS8lBfQ2oyEiRqvbl2KZme9x2aiT26TfGPZEHbRZAgTzqybrQb/8NY=\n=unXS\n-----END PGP SIGNATURE-----\n", "payload": "tree 422721f631d2425865eb50d184c576449b4b87c7\nparent ca6b360c8a2c40bec3cf04bb4c9198ad30779309\nparent dab572e0b0c3ee7373d51a76af5bdf0c7e81ce68\nauthor Nick Cameron <nrc@ncameron.org> 1533074791 +1200\ncommitter GitHub <noreply@github.com> 1533074791 +1200\n\nMerge pull request #2873 from aloucks/auto-detect-newline-style\n\nAuto-detect newline style by default"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df2e8bb5940a9bca7bc455189f4ea5e70a071fb8", "html_url": "https://github.com/rust-lang/rust/commit/df2e8bb5940a9bca7bc455189f4ea5e70a071fb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df2e8bb5940a9bca7bc455189f4ea5e70a071fb8/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca6b360c8a2c40bec3cf04bb4c9198ad30779309", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca6b360c8a2c40bec3cf04bb4c9198ad30779309", "html_url": "https://github.com/rust-lang/rust/commit/ca6b360c8a2c40bec3cf04bb4c9198ad30779309"}, {"sha": "dab572e0b0c3ee7373d51a76af5bdf0c7e81ce68", "url": "https://api.github.com/repos/rust-lang/rust/commits/dab572e0b0c3ee7373d51a76af5bdf0c7e81ce68", "html_url": "https://github.com/rust-lang/rust/commit/dab572e0b0c3ee7373d51a76af5bdf0c7e81ce68"}], "stats": {"total": 172, "additions": 139, "deletions": 33}, "files": [{"sha": "ab91f11be04ea200e75ac0daf91a29474840913a", "filename": "Configurations.md", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/df2e8bb5940a9bca7bc455189f4ea5e70a071fb8/Configurations.md", "raw_url": "https://github.com/rust-lang/rust/raw/df2e8bb5940a9bca7bc455189f4ea5e70a071fb8/Configurations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Configurations.md?ref=df2e8bb5940a9bca7bc455189f4ea5e70a071fb8", "patch": "@@ -1338,10 +1338,29 @@ fn main() {\n \n Unix or Windows line endings\n \n-- **Default value**: `\"Native\"`\n-- **Possible values**: `\"Native\"`, `\"Unix\"`, `\"Windows\"`\n+- **Default value**: `\"Auto\"`\n+- **Possible values**: `\"Auto\"`, `\"Native\"`, `\"Unix\"`, `\"Windows\"`\n - **Stable**: Yes\n \n+#### `Auto` (default):\n+\n+The newline style is detected automatically on a per-file basis. Files\n+with mixed line endings will be converted to the first detected line\n+ending style.\n+\n+#### `Native`\n+\n+Line endings will be converted to `\\r\\n` on Windows and `\\n` on all\n+other platforms.\n+\n+#### `Unix`\n+\n+Line endings will be converted to `\\n`.\n+\n+#### `Windows`\n+\n+Line endings will be converted to `\\r\\n`.\n+\n ## `normalize_comments`\n \n Convert /* */ comments to // comments where possible"}, {"sha": "f240c7b13c68b1ffcf0df9f86a7ba3e0b0b3b085", "filename": "src/config/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df2e8bb5940a9bca7bc455189f4ea5e70a071fb8/src%2Fconfig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df2e8bb5940a9bca7bc455189f4ea5e70a071fb8/src%2Fconfig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fmod.rs?ref=df2e8bb5940a9bca7bc455189f4ea5e70a071fb8", "patch": "@@ -39,7 +39,7 @@ create_config! {\n     max_width: usize, 100, true, \"Maximum width of each line\";\n     hard_tabs: bool, false, true, \"Use tab characters for indentation, spaces for alignment\";\n     tab_spaces: usize, 4, true, \"Number of spaces per tab\";\n-    newline_style: NewlineStyle, NewlineStyle::Native, true, \"Unix or Windows line endings\";\n+    newline_style: NewlineStyle, NewlineStyle::Auto, true, \"Unix or Windows line endings\";\n     use_small_heuristics: Heuristics, Heuristics::Default, true, \"Whether to use different \\\n         formatting for items and expressions if they satisfy a heuristic notion of 'small'\";\n     indent_style: IndentStyle, IndentStyle::Block, false, \"How do we indent expressions or items\";"}, {"sha": "d2a74f5467763ac810fa2972ecce968f7b71c789", "filename": "src/config/options.rs", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/df2e8bb5940a9bca7bc455189f4ea5e70a071fb8/src%2Fconfig%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df2e8bb5940a9bca7bc455189f4ea5e70a071fb8/src%2Fconfig%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Foptions.rs?ref=df2e8bb5940a9bca7bc455189f4ea5e70a071fb8", "patch": "@@ -105,11 +105,68 @@ macro_rules! configuration_option_enum{\n }\n \n configuration_option_enum! { NewlineStyle:\n+    Auto, // Auto-detect based on the raw source input\n     Windows, // \\r\\n\n     Unix, // \\n\n     Native, // \\r\\n in Windows, \\n on other platforms\n }\n \n+impl NewlineStyle {\n+    fn auto_detect(raw_input_text: &str) -> NewlineStyle {\n+        if let Some(pos) = raw_input_text.find('\\n') {\n+            let pos = pos.saturating_sub(1);\n+            if let Some('\\r') = raw_input_text.chars().nth(pos) {\n+                NewlineStyle::Windows\n+            } else {\n+                NewlineStyle::Unix\n+            }\n+        } else {\n+            NewlineStyle::Native\n+        }\n+    }\n+\n+    fn native() -> NewlineStyle {\n+        if cfg!(windows) {\n+            NewlineStyle::Windows\n+        } else {\n+            NewlineStyle::Unix\n+        }\n+    }\n+\n+    /// Apply this newline style to the formatted text. When the style is set\n+    /// to `Auto`, the `raw_input_text` is used to detect the existing line\n+    /// endings.\n+    ///\n+    /// If the style is set to `Auto` and `raw_input_text` contains no\n+    /// newlines, the `Native` style will be used.\n+    pub(crate) fn apply(self, formatted_text: &mut String, raw_input_text: &str) {\n+        use NewlineStyle::*;\n+        let mut style = self;\n+        if style == Auto {\n+            style = Self::auto_detect(raw_input_text);\n+        }\n+        if style == Native {\n+            style = Self::native();\n+        }\n+        match style {\n+            Windows => {\n+                let mut transformed = String::with_capacity(2 * formatted_text.capacity());\n+                for c in formatted_text.chars() {\n+                    match c {\n+                        '\\n' => transformed.push_str(\"\\r\\n\"),\n+                        '\\r' => continue,\n+                        c => transformed.push(c),\n+                    }\n+                }\n+                *formatted_text = transformed;\n+            }\n+            Unix => return,\n+            Native => unreachable!(\"NewlineStyle::Native\"),\n+            Auto => unreachable!(\"NewlineStyle::Auto\"),\n+        }\n+    }\n+}\n+\n configuration_option_enum! { BraceStyle:\n     AlwaysNextLine,\n     PreferSameLine,\n@@ -367,3 +424,59 @@ impl Edition {\n         }\n     }\n }\n+\n+#[test]\n+fn test_newline_style_auto_detect() {\n+    let lf = \"One\\nTwo\\nThree\";\n+    let crlf = \"One\\r\\nTwo\\r\\nThree\";\n+    let none = \"One Two Three\";\n+\n+    assert_eq!(NewlineStyle::Unix, NewlineStyle::auto_detect(lf));\n+    assert_eq!(NewlineStyle::Windows, NewlineStyle::auto_detect(crlf));\n+    assert_eq!(NewlineStyle::Native, NewlineStyle::auto_detect(none));\n+}\n+\n+#[test]\n+fn test_newline_style_auto_apply() {\n+    let auto = NewlineStyle::Auto;\n+\n+    let formatted_text = \"One\\nTwo\\nThree\";\n+    let raw_input_text = \"One\\nTwo\\nThree\";\n+\n+    let mut out = String::from(formatted_text);\n+    auto.apply(&mut out, raw_input_text);\n+    assert_eq!(\"One\\nTwo\\nThree\", &out, \"auto should detect 'lf'\");\n+\n+    let formatted_text = \"One\\nTwo\\nThree\";\n+    let raw_input_text = \"One\\r\\nTwo\\r\\nThree\";\n+\n+    let mut out = String::from(formatted_text);\n+    auto.apply(&mut out, raw_input_text);\n+    assert_eq!(\"One\\r\\nTwo\\r\\nThree\", &out, \"auto should detect 'crlf'\");\n+\n+    #[cfg(not(windows))]\n+    {\n+        let formatted_text = \"One\\nTwo\\nThree\";\n+        let raw_input_text = \"One Two Three\";\n+\n+        let mut out = String::from(formatted_text);\n+        auto.apply(&mut out, raw_input_text);\n+        assert_eq!(\n+            \"One\\nTwo\\nThree\", &out,\n+            \"auto-native-unix should detect 'lf'\"\n+        );\n+    }\n+\n+    #[cfg(windows)]\n+    {\n+        let formatted_text = \"One\\nTwo\\nThree\";\n+        let raw_input_text = \"One Two Three\";\n+\n+        let mut out = String::from(formatted_text);\n+        auto.apply(&mut out, raw_input_text);\n+        assert_eq!(\n+            \"One\\r\\nTwo\\r\\nThree\", &out,\n+            \"auto-native-windows should detect 'crlf'\"\n+        );\n+    }\n+}"}, {"sha": "d29c93981745a06322fcf6e3c1bdb432d90d2f2c", "filename": "src/formatting.rs", "status": "modified", "additions": 4, "deletions": 30, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/df2e8bb5940a9bca7bc455189f4ea5e70a071fb8/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df2e8bb5940a9bca7bc455189f4ea5e70a071fb8/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=df2e8bb5940a9bca7bc455189f4ea5e70a071fb8", "patch": "@@ -13,7 +13,7 @@ use syntax::errors::Handler;\n use syntax::parse::{self, ParseSess};\n \n use comment::{CharClasses, FullCodeCharKind};\n-use config::{Config, FileName, NewlineStyle, Verbosity};\n+use config::{Config, FileName, Verbosity};\n use issues::BadIssueSeeker;\n use visitor::{FmtVisitor, SnippetProvider};\n use {filemap, modules, ErrorKind, FormatReport, Input, Session};\n@@ -166,7 +166,9 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n             &self.config,\n             &self.report,\n         );\n-        replace_with_system_newlines(&mut visitor.buffer, &self.config);\n+        self.config\n+            .newline_style()\n+            .apply(&mut visitor.buffer, &big_snippet);\n \n         if visitor.macro_rewrite_failure {\n             self.report.add_macro_format_failure();\n@@ -645,34 +647,6 @@ fn make_parse_sess(codemap: Rc<CodeMap>, config: &Config) -> ParseSess {\n     ParseSess::with_span_handler(tty_handler, codemap)\n }\n \n-fn replace_with_system_newlines(text: &mut String, config: &Config) -> () {\n-    let style = if config.newline_style() == NewlineStyle::Native {\n-        if cfg!(windows) {\n-            NewlineStyle::Windows\n-        } else {\n-            NewlineStyle::Unix\n-        }\n-    } else {\n-        config.newline_style()\n-    };\n-\n-    match style {\n-        NewlineStyle::Unix => return,\n-        NewlineStyle::Windows => {\n-            let mut transformed = String::with_capacity(text.capacity());\n-            for c in text.chars() {\n-                match c {\n-                    '\\n' => transformed.push_str(\"\\r\\n\"),\n-                    '\\r' => continue,\n-                    c => transformed.push(c),\n-                }\n-            }\n-            *text = transformed;\n-        }\n-        NewlineStyle::Native => unreachable!(),\n-    }\n-}\n-\n fn should_emit_verbose<F>(is_stdin: bool, config: &Config, f: F)\n where\n     F: Fn(),"}]}