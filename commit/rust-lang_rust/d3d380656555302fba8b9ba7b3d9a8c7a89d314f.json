{"sha": "d3d380656555302fba8b9ba7b3d9a8c7a89d314f", "node_id": "C_kwDOAAsO6NoAKGQzZDM4MDY1NjU1NTMwMmZiYThiOWJhN2IzZDlhOGM3YTg5ZDMxNGY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-07T11:07:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-07T11:07:12Z"}, "message": "Auto merge of #12991 - TiddoLangerak:extract-method-from-trait-into-impl-root, r=Veykril\n\nFeat: extracted method from trait impl is placed in existing impl\n\n**Before**\n\nhttps://user-images.githubusercontent.com/1759192/183872883-3b0eafd2-d1dc-440e-9e66-38e3372f8b64.mp4\n\n**After**\n\nhttps://user-images.githubusercontent.com/1759192/183875769-87f34c7d-52f0-4dfc-9766-f591ee738ebb.mp4\n\nPreviously, when triggering a method extraction from within an impl trait block, then this would always create a new impl block for\nthe struct, even if there already is one. Now, if there is already an existing trait-less impl block, then it'll put the extracted method in there.\n\n**Caveats**:\n- It currently requires the target impl block to be non-empty. This limitation is because the current architecture takes a `node_to_insert_after` as reference for where to insert the extracted function. An empty impl block doesn't have such a reference node, since it's empty. It seems that supporting this requires a much larger and more complex change.\n- This is my first contribution in rust, so apologies for any beginner mistakes.", "tree": {"sha": "4527812df7a8c510b8883c35f3aeb66eeba1c40e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4527812df7a8c510b8883c35f3aeb66eeba1c40e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3d380656555302fba8b9ba7b3d9a8c7a89d314f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3d380656555302fba8b9ba7b3d9a8c7a89d314f", "html_url": "https://github.com/rust-lang/rust/commit/d3d380656555302fba8b9ba7b3d9a8c7a89d314f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3d380656555302fba8b9ba7b3d9a8c7a89d314f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "364820a296a22e46827621eb861c69d748640ecc", "url": "https://api.github.com/repos/rust-lang/rust/commits/364820a296a22e46827621eb861c69d748640ecc", "html_url": "https://github.com/rust-lang/rust/commit/364820a296a22e46827621eb861c69d748640ecc"}, {"sha": "f24fbc20274962860e15e1160bfdaade543092bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/f24fbc20274962860e15e1160bfdaade543092bf", "html_url": "https://github.com/rust-lang/rust/commit/f24fbc20274962860e15e1160bfdaade543092bf"}], "stats": {"total": 270, "additions": 266, "deletions": 4}, "files": [{"sha": "c1e2f19ab18b2502989555158aaff00a9e63554d", "filename": "crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 266, "deletions": 4, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/d3d380656555302fba8b9ba7b3d9a8c7a89d314f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3d380656555302fba8b9ba7b3d9a8c7a89d314f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=d3d380656555302fba8b9ba7b3d9a8c7a89d314f", "patch": "@@ -109,8 +109,6 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n             let params =\n                 body.extracted_function_params(ctx, &container_info, locals_used.iter().copied());\n \n-            let extracted_from_trait_impl = body.extracted_from_trait_impl();\n-\n             let name = make_function_name(&semantics_scope);\n \n             let fun = Function {\n@@ -129,8 +127,11 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n \n             builder.replace(target_range, make_call(ctx, &fun, old_indent));\n \n+            let has_impl_wrapper =\n+                insert_after.ancestors().any(|a| a.kind() == SyntaxKind::IMPL && a != insert_after);\n+\n             let fn_def = match fun.self_param_adt(ctx) {\n-                Some(adt) if extracted_from_trait_impl => {\n+                Some(adt) if anchor == Anchor::Method && !has_impl_wrapper => {\n                     let fn_def = format_function(ctx, module, &fun, old_indent, new_indent + 1);\n                     generate_impl_text(&adt, &fn_def).replace(\"{\\n\\n\", \"{\")\n                 }\n@@ -272,7 +273,7 @@ enum FunType {\n }\n \n /// Where to put extracted function definition\n-#[derive(Debug)]\n+#[derive(Debug, Eq, PartialEq, Clone, Copy)]\n enum Anchor {\n     /// Extract free function and put right after current top-level function\n     Freestanding,\n@@ -1245,6 +1246,14 @@ fn node_to_insert_after(body: &FunctionBody, anchor: Anchor) -> Option<SyntaxNod\n     while let Some(next_ancestor) = ancestors.next() {\n         match next_ancestor.kind() {\n             SyntaxKind::SOURCE_FILE => break,\n+            SyntaxKind::IMPL => {\n+                if body.extracted_from_trait_impl() && matches!(anchor, Anchor::Method) {\n+                    let impl_node = find_non_trait_impl(&next_ancestor);\n+                    if let target_node @ Some(_) = impl_node.as_ref().and_then(last_impl_member) {\n+                        return target_node;\n+                    }\n+                }\n+            }\n             SyntaxKind::ITEM_LIST if !matches!(anchor, Anchor::Freestanding) => continue,\n             SyntaxKind::ITEM_LIST => {\n                 if ancestors.peek().map(SyntaxNode::kind) == Some(SyntaxKind::MODULE) {\n@@ -1265,6 +1274,29 @@ fn node_to_insert_after(body: &FunctionBody, anchor: Anchor) -> Option<SyntaxNod\n     last_ancestor\n }\n \n+fn find_non_trait_impl(trait_impl: &SyntaxNode) -> Option<ast::Impl> {\n+    let as_impl = ast::Impl::cast(trait_impl.clone())?;\n+    let impl_type = Some(impl_type_name(&as_impl)?);\n+\n+    let sibblings = trait_impl.parent()?.children();\n+    sibblings\n+        .filter_map(ast::Impl::cast)\n+        .find(|s| impl_type_name(s) == impl_type && !is_trait_impl(s))\n+}\n+\n+fn last_impl_member(impl_node: &ast::Impl) -> Option<SyntaxNode> {\n+    let last_child = impl_node.assoc_item_list()?.assoc_items().last()?;\n+    Some(last_child.syntax().clone())\n+}\n+\n+fn is_trait_impl(node: &ast::Impl) -> bool {\n+    node.trait_().is_some()\n+}\n+\n+fn impl_type_name(impl_node: &ast::Impl) -> Option<String> {\n+    Some(impl_node.self_ty()?.to_string())\n+}\n+\n fn make_call(ctx: &AssistContext<'_>, fun: &Function, indent: IndentLevel) -> String {\n     let ret_ty = fun.return_type(ctx);\n \n@@ -5051,6 +5083,236 @@ impl Struct {\n         );\n     }\n \n+    #[test]\n+    fn extract_method_from_trait_with_existing_non_empty_impl_block() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl Struct {\n+    fn foo() {}\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        $0self.0 + 2$0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl Struct {\n+    fn foo() {}\n+\n+    fn $0fun_name(&self) -> i32 {\n+        self.0 + 2\n+    }\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        self.fun_name()\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_function_from_trait_with_existing_non_empty_impl_block() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl Struct {\n+    fn foo() {}\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        let three_squared = $03 * 3$0;\n+        self.0 + three_squared\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl Struct {\n+    fn foo() {}\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        let three_squared = fun_name();\n+        self.0 + three_squared\n+    }\n+}\n+\n+fn $0fun_name() -> i32 {\n+    3 * 3\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_method_from_trait_with_multiple_existing_impl_blocks() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct(i32);\n+struct StructBefore(i32);\n+struct StructAfter(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl StructBefore {\n+    fn foo(){}\n+}\n+\n+impl Struct {\n+    fn foo(){}\n+}\n+\n+impl StructAfter {\n+    fn foo(){}\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        $0self.0 + 2$0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct(i32);\n+struct StructBefore(i32);\n+struct StructAfter(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl StructBefore {\n+    fn foo(){}\n+}\n+\n+impl Struct {\n+    fn foo(){}\n+\n+    fn $0fun_name(&self) -> i32 {\n+        self.0 + 2\n+    }\n+}\n+\n+impl StructAfter {\n+    fn foo(){}\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        self.fun_name()\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_method_from_trait_with_multiple_existing_trait_impl_blocks() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+trait TraitBefore {\n+    fn before(&self) -> i32;\n+}\n+trait TraitAfter {\n+    fn after(&self) -> i32;\n+}\n+\n+impl TraitBefore for Struct {\n+    fn before(&self) -> i32 {\n+        42\n+    }\n+}\n+\n+impl Struct {\n+    fn foo(){}\n+}\n+\n+impl TraitAfter for Struct {\n+    fn after(&self) -> i32 {\n+        42\n+    }\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        $0self.0 + 2$0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+trait TraitBefore {\n+    fn before(&self) -> i32;\n+}\n+trait TraitAfter {\n+    fn after(&self) -> i32;\n+}\n+\n+impl TraitBefore for Struct {\n+    fn before(&self) -> i32 {\n+        42\n+    }\n+}\n+\n+impl Struct {\n+    fn foo(){}\n+\n+    fn $0fun_name(&self) -> i32 {\n+        self.0 + 2\n+    }\n+}\n+\n+impl TraitAfter for Struct {\n+    fn after(&self) -> i32 {\n+        42\n+    }\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        self.fun_name()\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n     #[test]\n     fn closure_arguments() {\n         check_assist("}]}