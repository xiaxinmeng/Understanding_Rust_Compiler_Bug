{"sha": "70fbdb95809e94e3c6537eac78d47656a601bfe3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwZmJkYjk1ODA5ZTk0ZTNjNjUzN2VhYzc4ZDQ3NjU2YTYwMWJmZTM=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-12-17T20:42:42Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-12-17T20:42:42Z"}, "message": "Merge pull request #4206 from paulstansifer/macro_tutorial_improvements\n\nMacro tutorial improvements", "tree": {"sha": "b949b54497776a46cf86a86f0023507bb909ae8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b949b54497776a46cf86a86f0023507bb909ae8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70fbdb95809e94e3c6537eac78d47656a601bfe3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70fbdb95809e94e3c6537eac78d47656a601bfe3", "html_url": "https://github.com/rust-lang/rust/commit/70fbdb95809e94e3c6537eac78d47656a601bfe3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70fbdb95809e94e3c6537eac78d47656a601bfe3/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ceca0e8bf591a10be62af55c7a0f2e1daa4d5cca", "url": "https://api.github.com/repos/rust-lang/rust/commits/ceca0e8bf591a10be62af55c7a0f2e1daa4d5cca", "html_url": "https://github.com/rust-lang/rust/commit/ceca0e8bf591a10be62af55c7a0f2e1daa4d5cca"}, {"sha": "7c103f2da995cc5d29d5219f998dfd1aab772b59", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c103f2da995cc5d29d5219f998dfd1aab772b59", "html_url": "https://github.com/rust-lang/rust/commit/7c103f2da995cc5d29d5219f998dfd1aab772b59"}], "stats": {"total": 209, "additions": 200, "deletions": 9}, "files": [{"sha": "1def470755c317de0163a8b9ebde0220ba7d6b7a", "filename": "doc/tutorial-macros.md", "status": "modified", "additions": 200, "deletions": 9, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/70fbdb95809e94e3c6537eac78d47656a601bfe3/doc%2Ftutorial-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/70fbdb95809e94e3c6537eac78d47656a601bfe3/doc%2Ftutorial-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-macros.md?ref=70fbdb95809e94e3c6537eac78d47656a601bfe3", "patch": "@@ -25,9 +25,9 @@ match input_2 {\n # }\n ~~~~\n \n-This code could become tiresome if repeated many times. However, there is no\n-straightforward way to rewrite it without the repeated code, using functions\n-alone. There is a solution, though: defining a macro to solve the problem. Macros are\n+This code could become tiresome if repeated many times. However, no function\n+can capture its functionality to make it possible to rewrite the repetition\n+away. Rust's macro system, however, can eliminate the repetition. Macros are\n lightweight custom syntax extensions, themselves defined using the\n `macro_rules!` syntax extension. The following `early_return` macro captures\n the pattern in the above code:\n@@ -65,7 +65,7 @@ macro. It appears on the left-hand side of the `=>` in a macro definition. It\n conforms to the following rules:\n \n 1. It must be surrounded by parentheses.\n-2. `$` has special meaning.\n+2. `$` has special meaning (described below).\n 3. The `()`s, `[]`s, and `{}`s it contains must balance. For example, `([)` is\n forbidden.\n \n@@ -118,10 +118,11 @@ expression, `() => (let $x=$val)` is a macro that expands to a statement, and\n `() => (1,2,3)` is a macro that expands to a syntax errror).\n \n Except for permissibility of `$name` (and `$(...)*`, discussed below), the\n-right-hand side of a macro definition follows the same rules as ordinary\n-Rust syntax. In particular, macro invocations (including invocations of the\n-macro currently being defined) are permitted in expression, statement, and\n-item locations.\n+right-hand side of a macro definition is ordinary Rust syntax. In particular,\n+macro invocations (including invocations of the macro currently being defined)\n+are permitted in expression, statement, and item locations. However, nothing\n+else about the code is examined or executed by the macro system; execution\n+still has to wait until runtime.\n \n ## Interpolation location\n \n@@ -199,7 +200,196 @@ parsing `e`. Changing the invocation syntax to require a distinctive token in\n front can solve the problem. In the above example, `$(T $t:ty)* E $e:exp`\n solves the problem.\n \n-## A final note\n+# Macro argument pattern matching\n+\n+Now consider code like the following:\n+\n+## Motivation\n+\n+~~~~\n+# enum t1 { good_1(t2, uint), bad_1 };\n+# pub struct t2 { body: t3 }\n+# enum t3 { good_2(uint), bad_2};\n+# fn f(x: t1) -> uint {\n+match x {\n+    good_1(g1, val) => {\n+        match g1.body {\n+            good_2(result) => {\n+                // complicated stuff goes here\n+                return result + val;\n+            },\n+            _ => fail ~\"Didn't get good_2\"\n+        }\n+    }\n+    _ => return 0 // default value\n+}\n+# }\n+~~~~\n+\n+All the complicated stuff is deeply indented, and the error-handling code is\n+separated from matches that fail. We'd like to write a macro that performs\n+a match, but with a syntax that suits the problem better. The following macro\n+can solve the problem:\n+\n+~~~~\n+macro_rules! biased_match (\n+    // special case: `let (x) = ...` is illegal, so use `let x = ...` instead\n+    ( ($e:expr) ~ ($p:pat) else $err:stmt ;\n+      binds $bind_res:ident\n+    ) => (\n+        let $bind_res = match $e {\n+            $p => ( $bind_res ),\n+            _ => { $err }\n+        };\n+    );\n+    // more than one name; use a tuple\n+    ( ($e:expr) ~ ($p:pat) else $err:stmt ;\n+      binds $( $bind_res:ident ),*\n+    ) => (\n+        let ( $( $bind_res ),* ) = match $e {\n+            $p => ( $( $bind_res ),* ),\n+            _ => { $err }\n+        };\n+    )\n+)\n+\n+# enum t1 { good_1(t2, uint), bad_1 };\n+# pub struct t2 { body: t3 }\n+# enum t3 { good_2(uint), bad_2};\n+# fn f(x: t1) -> uint {\n+biased_match!((x)       ~ (good_1(g1, val)) else { return 0 };\n+              binds g1, val )\n+biased_match!((g1.body) ~ (good_2(result) )\n+                  else { fail ~\"Didn't get good_2\" };\n+              binds result )\n+// complicated stuff goes here\n+return result + val;\n+# }\n+~~~~\n+\n+This solves the indentation problem. But if we have a lot of chained matches\n+like this, we might prefer to write a single macro invocation. The input\n+pattern we want is clear:\n+~~~~\n+# macro_rules! b(\n+    ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n+      binds $( $bind_res:ident ),*\n+    )\n+# => (0))\n+~~~~\n+\n+However, it's not possible to directly expand to nested match statements. But\n+there is a solution.\n+\n+## The recusive approach to macro writing\n+\n+A macro may accept multiple different input grammars. The first one to\n+successfully match the actual argument to a macro invocation is the one that\n+\"wins\".\n+\n+\n+In the case of the example above, we want to write a recursive macro to\n+process the semicolon-terminated lines, one-by-one. So, we want the following\n+input patterns:\n+\n+~~~~\n+# macro_rules! b(\n+    ( binds $( $bind_res:ident ),* )\n+# => (0))\n+~~~~\n+...and:\n+\n+~~~~\n+# macro_rules! b(\n+    (    ($e     :expr) ~ ($p     :pat) else $err     :stmt ;\n+      $( ($e_rest:expr) ~ ($p_rest:pat) else $err_rest:stmt ; )*\n+      binds  $( $bind_res:ident ),*\n+    )\n+# => (0))\n+~~~~\n+\n+The resulting macro looks like this. Note that the separation into\n+`biased_match!` and `biased_match_rec!` occurs only because we have an outer\n+piece of syntax (the `let`) which we only want to transcribe once.\n+\n+~~~~\n+\n+macro_rules! biased_match_rec (\n+    // Handle the first layer\n+    (   ($e     :expr) ~ ($p     :pat) else $err     :stmt ;\n+     $( ($e_rest:expr) ~ ($p_rest:pat) else $err_rest:stmt ; )*\n+     binds $( $bind_res:ident ),*\n+    ) => (\n+        match $e {\n+            $p => {\n+                // Recursively handle the next layer\n+                biased_match_rec!($( ($e_rest) ~ ($p_rest) else $err_rest ; )*\n+                                  binds $( $bind_res ),*\n+                )\n+            }\n+            _ => { $err }\n+        }\n+    );\n+    ( binds $( $bind_res:ident ),* ) => ( ($( $bind_res ),*) )\n+)\n+\n+// Wrap the whole thing in a `let`.\n+macro_rules! biased_match (\n+    // special case: `let (x) = ...` is illegal, so use `let x = ...` instead\n+    ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n+      binds $bind_res:ident\n+    ) => (\n+        let ( $( $bind_res ),* ) = biased_match_rec!(\n+            $( ($e) ~ ($p) else $err ; )*\n+            binds $bind_res\n+        );\n+    );\n+    // more than one name: use a tuple\n+    ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n+      binds  $( $bind_res:ident ),*\n+    ) => (\n+        let ( $( $bind_res ),* ) = biased_match_rec!(\n+            $( ($e) ~ ($p) else $err ; )*\n+            binds $( $bind_res ),*\n+        );\n+    )\n+)\n+\n+\n+# enum t1 { good_1(t2, uint), bad_1 };\n+# pub struct t2 { body: t3 }\n+# enum t3 { good_2(uint), bad_2};\n+# fn f(x: t1) -> uint {\n+biased_match!(\n+    (x)       ~ (good_1(g1, val)) else { return 0 };\n+    (g1.body) ~ (good_2(result) ) else { fail ~\"Didn't get good_2\" };\n+    binds val, result )\n+// complicated stuff goes here\n+return result + val;\n+# }\n+~~~~\n+\n+This technique is applicable in many cases where transcribing a result \"all\n+at once\" is not possible. It resembles ordinary functional programming in some\n+respects, but it is important to recognize the differences.\n+\n+The first difference is important, but also easy to forget: the transcription\n+(right-hand) side of a `macro_rules!` rule is literal syntax, which can only\n+be executed at run-time. If a piece of transcription syntax does not itself\n+appear inside another macro invocation, it will become part of the final\n+program. If it is inside a macro invocation (for example, the recursive\n+invocation of `biased_match_rec!`), it does have the opprotunity to affect\n+transcription, but only through the process of attempted pattern matching.\n+\n+The second difference is related: the evaluation order of macros feels\n+\"backwards\" compared to ordinary programming. Given an invocation\n+`m1!(m2!())`, the expander first expands `m1!`, giving it as input the literal\n+syntax `m2!()`. If it transcribes its argument unchanged into an appropriate\n+position (in particular, not as an argument to yet another macro invocation),\n+the expander will then proceed to evaluate `m2!()` (along with any other macro\n+invocations `m1!(m2!())` produced).\n+\n+# A final note\n \n Macros, as currently implemented, are not for the faint of heart. Even\n ordinary syntax errors can be more difficult to debug when they occur inside a\n@@ -208,3 +398,4 @@ tricky. Invoking the `log_syntax!` macro can help elucidate intermediate\n states, invoking `trace_macros!(true)` will automatically print those\n intermediate states out, and passing the flag `--pretty expanded` as a\n command-line argument to the compiler will show the result of expansion.\n+"}]}