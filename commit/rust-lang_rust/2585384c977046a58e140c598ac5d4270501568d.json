{"sha": "2585384c977046a58e140c598ac5d4270501568d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ODUzODRjOTc3MDQ2YTU4ZTE0MGM1OThhYzVkNDI3MDUwMTU2OGQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-05-11T20:09:49Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-05-11T20:10:07Z"}, "message": "First working monomorphic type-reflection.", "tree": {"sha": "9d5deda44a10740a4d94ebae8ef8afc8e15a12e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d5deda44a10740a4d94ebae8ef8afc8e15a12e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2585384c977046a58e140c598ac5d4270501568d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2585384c977046a58e140c598ac5d4270501568d", "html_url": "https://github.com/rust-lang/rust/commit/2585384c977046a58e140c598ac5d4270501568d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2585384c977046a58e140c598ac5d4270501568d/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dbf881e87baad3ab7ff33b56777e8411541e036", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dbf881e87baad3ab7ff33b56777e8411541e036", "html_url": "https://github.com/rust-lang/rust/commit/5dbf881e87baad3ab7ff33b56777e8411541e036"}], "stats": {"total": 228, "additions": 210, "deletions": 18}, "files": [{"sha": "b2ea0ec7076985a6661fecad604f4fda5a7f3cdf", "filename": "src/rustc/front/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2585384c977046a58e140c598ac5d4270501568d/src%2Frustc%2Ffront%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585384c977046a58e140c598ac5d4270501568d/src%2Frustc%2Ffront%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fintrinsic.rs?ref=2585384c977046a58e140c598ac5d4270501568d", "patch": "@@ -18,6 +18,7 @@ mod intrinsic {\n     }\n \n     iface ty_visitor {\n+        fn visit_bot();\n         fn visit_nil();\n         fn visit_bool();\n \n@@ -36,6 +37,8 @@ mod intrinsic {\n         fn visit_float();\n         fn visit_f32();\n         fn visit_f64();\n+\n+        fn visit_char();\n         fn visit_str();\n \n         fn visit_vec(cells_mut: bool,\n@@ -68,6 +71,7 @@ mod intrinsic {\n     iface val_visitor {\n \n         // Basic types we can visit directly.\n+        fn visit_bot();\n         fn visit_nil();\n         fn visit_bool(b: &bool);\n \n@@ -87,6 +91,8 @@ mod intrinsic {\n         fn visit_f32(f: &f32);\n         fn visit_f64(f: &f64);\n \n+        fn visit_char(c: &char);\n+\n         // Vecs and strs we can provide a stub view of.\n         fn visit_str(repr: &vec::unsafe::vec_repr,\n                      visit_cell: fn(uint,self));"}, {"sha": "521cf50ee3e5bd53011cb68b96ee309e379759f5", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 71, "deletions": 15, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/2585384c977046a58e140c598ac5d4270501568d/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585384c977046a58e140c598ac5d4270501568d/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=2585384c977046a58e140c598ac5d4270501568d", "patch": "@@ -782,7 +782,7 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::native_item,\n                    ref_id: option<ast::node_id>) {\n     let fcx = new_fn_ctxt_w_id(ccx, path, decl, item.id,\n                                some(substs), some(item.span));\n-    let bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n+    let mut bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n     let tp_ty = substs.tys[0], lltp_ty = type_of::type_of(ccx, tp_ty);\n     alt check item.ident {\n       \"size_of\" {\n@@ -835,27 +835,83 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::native_item,\n               fcx.llretptr);\n       }\n       \"visit_ty\" {\n-        let vp_ty = substs.tys[1], _llvp_ty = type_of::type_of(ccx, vp_ty);\n+\n+        // signature: fn visit_ty<T,V:ty_visitor>(tv: V);\n+\n+        let tp_ty = substs.tys[0];\n+        let vp_ty = substs.tys[1];\n         let visitor = get_param(decl, first_real_arg);\n-        // FIXME: implement a proper iface-call. Nontrivial.\n-        Call(bcx, visitor, []);\n+\n+        // We're going to synthesize a monomorphized vtbl call here much\n+        // like what impl::trans_monomorphized_callee does, but without\n+        // having quite as much source machinery to go on.\n+\n+        alt impl::find_vtable_in_fn_ctxt(substs,\n+                                         1u, /* n_param */\n+                                         0u  /* n_bound */ ) {\n+\n+          typeck::vtable_static(impl_did, impl_substs, sub_origins) {\n+\n+            let (tyname, args) = alt ty::get(tp_ty).struct {\n+              ty::ty_bot { (\"bot\", []) }\n+              ty::ty_nil { (\"nil\", []) }\n+              ty::ty_bool { (\"bool\", []) }\n+              ty::ty_int(ast::ty_i) { (\"int\", []) }\n+              ty::ty_int(ast::ty_char) { (\"char\", []) }\n+              ty::ty_int(ast::ty_i8) { (\"i8\", []) }\n+              ty::ty_int(ast::ty_i16) { (\"i16\", []) }\n+              ty::ty_int(ast::ty_i32) { (\"i32\", []) }\n+              ty::ty_int(ast::ty_i64) { (\"i64\", []) }\n+              ty::ty_uint(ast::ty_u) { (\"uint\", []) }\n+              ty::ty_uint(ast::ty_u8) { (\"u8\", []) }\n+              ty::ty_uint(ast::ty_u16) { (\"u16\", []) }\n+              ty::ty_uint(ast::ty_u32) { (\"u32\", []) }\n+              ty::ty_uint(ast::ty_u64) { (\"u64\", []) }\n+              ty::ty_float(ast::ty_f) { (\"float\", []) }\n+              ty::ty_float(ast::ty_f32) { (\"f32\", []) }\n+              ty::ty_float(ast::ty_f64) { (\"f64\", []) }\n+              ty::ty_str { (\"str\", []) }\n+              _ {\n+                bcx.sess().unimpl(\"trans::native::visit_ty on \"\n+                                  + ty_to_str(ccx.tcx, tp_ty));\n+              }\n+            };\n+\n+            let mth_id = impl::method_with_name(ccx, impl_did,\n+                                                \"visit_\" + tyname);\n+            let mth_ty = ty::lookup_item_type(ccx.tcx, mth_id).ty;\n+\n+            // FIXME: is this safe? There is no callee AST node,\n+            // we're synthesizing it.\n+            let callee_id = (-1) as ast::node_id;\n+\n+            let dest = ignore;\n+\n+            bcx = trans_call_inner(bcx,\n+                                   mth_ty,\n+                                   ty::mk_nil(ccx.tcx),\n+                                   {|bcx|\n+                                       let lval =\n+                                           lval_static_fn_inner\n+                                           (bcx, mth_id, callee_id,\n+                                            impl_substs,  some(sub_origins));\n+                                       {env: self_env(visitor, vp_ty, none)\n+                                        with lval}\n+                                   }, arg_vals(args), dest);\n+          }\n+          _ {\n+            ccx.sess.span_bug(item.span,\n+                              \"non-static callee in 'visit_ty' intrinsinc\");\n+          }\n+        }\n       }\n \n       \"visit_val\" {\n-        let vp_ty = substs.tys[1], _llvp_ty = type_of::type_of(ccx, vp_ty);\n-        let val = get_param(decl, first_real_arg);\n-        let visitor = get_param(decl, first_real_arg + 1u);\n-        // FIXME: implement a proper iface-call. Nontrivial.\n-        Call(bcx, visitor, [val]);\n+        bcx.sess().unimpl(\"trans::native::visit_val\");\n       }\n \n       \"visit_val_pair\" {\n-        let vp_ty = substs.tys[1], _llvp_ty = type_of::type_of(ccx, vp_ty);\n-        let a = get_param(decl, first_real_arg);\n-        let b = get_param(decl, first_real_arg + 1u);\n-        let visitor = get_param(decl, first_real_arg + 2u);\n-        // FIXME: implement a proper iface-call. Nontrivial.\n-        Call(bcx, visitor, [a, b]);\n+        bcx.sess().unimpl(\"trans::native::visit_val_pair\");\n       }\n     }\n     build_return(bcx);"}, {"sha": "65cc2a949b515dd859be87815407cfc0834aa716", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2585384c977046a58e140c598ac5d4270501568d/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585384c977046a58e140c598ac5d4270501568d/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=2585384c977046a58e140c598ac5d4270501568d", "patch": "@@ -76,9 +76,9 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n       ast_map::node_native_item(i@@{node: native_item_fn(_, _), _}, abi, _) {\n         if abi == native_abi_rust_intrinsic {\n             let flags = alt check i.ident {\n-              \"size_of\" |\n-              \"pref_align_of\" | \"min_align_of\" | \"init\" |\n-              \"reinterpret_cast\" { use_repr }\n+              \"visit_ty\" | \"visit_val\" | \"visit_val_pair\" { 3u }\n+              \"size_of\" |  \"pref_align_of\" | \"min_align_of\" |\n+              \"init\" |  \"reinterpret_cast\" { use_repr }\n               \"get_tydesc\" | \"needs_drop\" { use_tydesc }\n               \"forget\" | \"addr_of\" { 0u }\n             };"}, {"sha": "f5c991ccde4d96b132ec83b86f66f4ac35c5bc07", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/2585384c977046a58e140c598ac5d4270501568d/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585384c977046a58e140c598ac5d4270501568d/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=2585384c977046a58e140c598ac5d4270501568d", "patch": "@@ -0,0 +1,130 @@\n+// xfail-test\n+//\n+// This works on stage2 currently. Once we have a snapshot\n+// and some fiddling with inject_intrinsic (and possibly another\n+// snapshot after _that_) it can be un-xfailed and changed\n+// to use the intrinsic:: interface and native module.\n+//\n+\n+iface ty_visitor {\n+    fn visit_bot();\n+    fn visit_nil();\n+    fn visit_bool();\n+\n+    fn visit_int();\n+    fn visit_i8();\n+    fn visit_i16();\n+    fn visit_i32();\n+    fn visit_i64();\n+\n+    fn visit_uint();\n+    fn visit_u8();\n+    fn visit_u16();\n+    fn visit_u32();\n+    fn visit_u64();\n+\n+    fn visit_float();\n+    fn visit_f32();\n+    fn visit_f64();\n+\n+    fn visit_char();\n+    fn visit_str();\n+\n+    fn visit_vec(cells_mut: bool,\n+                 visit_cell: fn(uint, self));\n+\n+    fn visit_box(inner_mut: bool,\n+                 visit_inner: fn(self));\n+\n+    fn visit_uniq(inner_mut: bool,\n+                  visit_inner: fn(self));\n+\n+    fn visit_ptr(inner_mut: bool,\n+                 visit_inner: fn(self));\n+\n+    fn visit_rptr(inner_mut: bool,\n+                  visit_inner: fn(self));\n+\n+    fn visit_rec(n_fields: uint,\n+                 field_name: fn(uint) -> str/&,\n+                 field_mut: fn(uint) -> bool,\n+                 visit_field: fn(uint, self));\n+    fn visit_tup(n_fields: uint,\n+                 visit_field: fn(uint, self));\n+    fn visit_enum(n_variants: uint,\n+                  variant: uint,\n+                  variant_name: fn(uint) -> str/&,\n+                  visit_variant: fn(uint, self));\n+}\n+\n+enum my_visitor = { mut types: [str] };\n+\n+impl of ty_visitor for my_visitor {\n+    fn visit_bot() { self.types += [\"bot\"] }\n+    fn visit_nil() { self.types += [\"nil\"] }\n+    fn visit_bool() { self.types += [\"bool\"] }\n+\n+    fn visit_int() { self.types += [\"int\"] }\n+    fn visit_i8() { self.types += [\"i8\"] }\n+    fn visit_i16() { self.types += [\"i16\"] }\n+    fn visit_i32() { }\n+    fn visit_i64() { }\n+\n+    fn visit_uint() { }\n+    fn visit_u8() { }\n+    fn visit_u16() { }\n+    fn visit_u32() { }\n+    fn visit_u64() { }\n+\n+    fn visit_float() { }\n+    fn visit_f32() { }\n+    fn visit_f64() { }\n+\n+    fn visit_char() { }\n+    fn visit_str() { }\n+\n+    fn visit_vec(_cells_mut: bool,\n+                 _visit_cell: fn(uint, my_visitor)) { }\n+\n+    fn visit_box(_inner_mut: bool,\n+                 _visit_inner: fn(my_visitor)) { }\n+\n+    fn visit_uniq(_inner_mut: bool,\n+                  _visit_inner: fn(my_visitor)) { }\n+\n+    fn visit_ptr(_inner_mut: bool,\n+                 _visit_inner: fn(my_visitor)) { }\n+\n+    fn visit_rptr(_inner_mut: bool,\n+                  _visit_inner: fn(my_visitor)) { }\n+\n+    fn visit_rec(_n_fields: uint,\n+                 _field_name: fn(uint) -> str/&,\n+                 _field_mut: fn(uint) -> bool,\n+                 _visit_field: fn(uint, my_visitor)) { }\n+    fn visit_tup(_n_fields: uint,\n+                 _visit_field: fn(uint, my_visitor)) { }\n+    fn visit_enum(_n_variants: uint,\n+                  _variant: uint,\n+                  _variant_name: fn(uint) -> str/&,\n+                  _visit_variant: fn(uint, my_visitor)) { }\n+}\n+\n+#[abi = \"rust-intrinsic\"]\n+native mod rusti {\n+    fn visit_ty<T,V:ty_visitor>(tv: V);\n+}\n+\n+fn main() {\n+    let v = my_visitor({mut types: []});\n+\n+    rusti::visit_ty::<bool,my_visitor>(v);\n+    rusti::visit_ty::<int,my_visitor>(v);\n+    rusti::visit_ty::<i8,my_visitor>(v);\n+    rusti::visit_ty::<i16,my_visitor>(v);\n+\n+    for v.types.each {|s|\n+        io::println(#fmt(\"type: %s\", s));\n+    }\n+    assert v.types == [\"bool\", \"int\", \"i8\", \"i16\"];\n+}"}]}