{"sha": "00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwZDg3ZTBkODE5OGZmYjI2ODI1MWI1YWYyZWIyY2UxOTI0OWM3Zjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-27T02:32:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-27T02:32:15Z"}, "message": "auto merge of #11058 : pcwalton/rust/demuting, r=pcwalton\n\nr? @alexcrichton", "tree": {"sha": "cee6dd55e5bef0dfae18766a3a15a61095aab672", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cee6dd55e5bef0dfae18766a3a15a61095aab672"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "html_url": "https://github.com/rust-lang/rust/commit/00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f74b8f0d3a90fd3b64afa38b9470d9a45cd04ee9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f74b8f0d3a90fd3b64afa38b9470d9a45cd04ee9", "html_url": "https://github.com/rust-lang/rust/commit/f74b8f0d3a90fd3b64afa38b9470d9a45cd04ee9"}, {"sha": "ad160146fdf55a3efb8dcdf7d428ae09a20eca01", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad160146fdf55a3efb8dcdf7d428ae09a20eca01", "html_url": "https://github.com/rust-lang/rust/commit/ad160146fdf55a3efb8dcdf7d428ae09a20eca01"}], "stats": {"total": 8826, "additions": 5230, "deletions": 3596}, "files": [{"sha": "27d7a1dee99227e48b0e343f5158e8dcf5399948", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 44, "deletions": 40, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -593,22 +593,13 @@ pub mod writer {\n     use std::io::extensions::u64_to_be_bytes;\n \n     // ebml writing\n-    pub struct Encoder {\n+    pub struct Encoder<'a> {\n         // FIXME(#5665): this should take a trait object\n-        writer: @mut MemWriter,\n+        writer: &'a mut MemWriter,\n         priv size_positions: ~[uint],\n     }\n \n-    impl Clone for Encoder {\n-        fn clone(&self) -> Encoder {\n-            Encoder {\n-                writer: self.writer,\n-                size_positions: self.size_positions.clone(),\n-            }\n-        }\n-    }\n-\n-    fn write_sized_vuint(w: @mut MemWriter, n: uint, size: uint) {\n+    fn write_sized_vuint(w: &mut MemWriter, n: uint, size: uint) {\n         match size {\n             1u => w.write(&[0x80u8 | (n as u8)]),\n             2u => w.write(&[0x40u8 | ((n >> 8_u) as u8), n as u8]),\n@@ -620,15 +611,15 @@ pub mod writer {\n         };\n     }\n \n-    fn write_vuint(w: @mut MemWriter, n: uint) {\n+    fn write_vuint(w: &mut MemWriter, n: uint) {\n         if n < 0x7f_u { write_sized_vuint(w, n, 1u); return; }\n         if n < 0x4000_u { write_sized_vuint(w, n, 2u); return; }\n         if n < 0x200000_u { write_sized_vuint(w, n, 3u); return; }\n         if n < 0x10000000_u { write_sized_vuint(w, n, 4u); return; }\n         fail!(\"vint to write too big: {}\", n);\n     }\n \n-    pub fn Encoder(w: @mut MemWriter) -> Encoder {\n+    pub fn Encoder<'a>(w: &'a mut MemWriter) -> Encoder<'a> {\n         let size_positions: ~[uint] = ~[];\n         Encoder {\n             writer: w,\n@@ -637,7 +628,15 @@ pub mod writer {\n     }\n \n     // FIXME (#2741): Provide a function to write the standard ebml header.\n-    impl Encoder {\n+    impl<'a> Encoder<'a> {\n+        /// XXX(pcwalton): Workaround for badness in trans. DO NOT USE ME.\n+        pub unsafe fn unsafe_clone(&self) -> Encoder<'a> {\n+            Encoder {\n+                writer: cast::transmute_copy(&self.writer),\n+                size_positions: self.size_positions.clone(),\n+            }\n+        }\n+\n         pub fn start_tag(&mut self, tag_id: uint) {\n             debug!(\"Start tag {}\", tag_id);\n \n@@ -739,7 +738,7 @@ pub mod writer {\n     // Totally lame approach.\n     static DEBUG: bool = true;\n \n-    impl Encoder {\n+    impl<'a> Encoder<'a> {\n         // used internally to emit things like the vector length and so on\n         fn _emit_tagged_uint(&mut self, t: EbmlEncoderTag, v: uint) {\n             assert!(v <= 0xFFFF_FFFF_u);\n@@ -755,17 +754,15 @@ pub mod writer {\n             // try and check failures more quickly.\n             if DEBUG { self.wr_tagged_str(EsLabel as uint, label) }\n         }\n-    }\n \n-    impl Encoder {\n         pub fn emit_opaque(&mut self, f: |&mut Encoder|) {\n             self.start_tag(EsOpaque as uint);\n             f(self);\n             self.end_tag();\n         }\n     }\n \n-    impl ::serialize::Encoder for Encoder {\n+    impl<'a> ::serialize::Encoder for Encoder<'a> {\n         fn emit_nil(&mut self) {}\n \n         fn emit_uint(&mut self, v: uint) {\n@@ -820,7 +817,7 @@ pub mod writer {\n             self.wr_tagged_str(EsStr as uint, v)\n         }\n \n-        fn emit_enum(&mut self, name: &str, f: |&mut Encoder|) {\n+        fn emit_enum(&mut self, name: &str, f: |&mut Encoder<'a>|) {\n             self._emit_label(name);\n             self.start_tag(EsEnum as uint);\n             f(self);\n@@ -831,98 +828,103 @@ pub mod writer {\n                              _: &str,\n                              v_id: uint,\n                              _: uint,\n-                             f: |&mut Encoder|) {\n+                             f: |&mut Encoder<'a>|) {\n             self._emit_tagged_uint(EsEnumVid, v_id);\n             self.start_tag(EsEnumBody as uint);\n             f(self);\n             self.end_tag();\n         }\n \n-        fn emit_enum_variant_arg(&mut self, _: uint, f: |&mut Encoder|) {\n+        fn emit_enum_variant_arg(&mut self, _: uint, f: |&mut Encoder<'a>|) {\n             f(self)\n         }\n \n         fn emit_enum_struct_variant(&mut self,\n                                     v_name: &str,\n                                     v_id: uint,\n                                     cnt: uint,\n-                                    f: |&mut Encoder|) {\n+                                    f: |&mut Encoder<'a>|) {\n             self.emit_enum_variant(v_name, v_id, cnt, f)\n         }\n \n         fn emit_enum_struct_variant_field(&mut self,\n                                           _: &str,\n                                           idx: uint,\n-                                          f: |&mut Encoder|) {\n+                                          f: |&mut Encoder<'a>|) {\n             self.emit_enum_variant_arg(idx, f)\n         }\n \n-        fn emit_struct(&mut self, _: &str, _len: uint, f: |&mut Encoder|) {\n+        fn emit_struct(&mut self,\n+                       _: &str,\n+                       _len: uint,\n+                       f: |&mut Encoder<'a>|) {\n             f(self)\n         }\n \n         fn emit_struct_field(&mut self,\n                              name: &str,\n                              _: uint,\n-                             f: |&mut Encoder|) {\n+                             f: |&mut Encoder<'a>|) {\n             self._emit_label(name);\n             f(self)\n         }\n \n-        fn emit_tuple(&mut self, len: uint, f: |&mut Encoder|) {\n+        fn emit_tuple(&mut self, len: uint, f: |&mut Encoder<'a>|) {\n             self.emit_seq(len, f)\n         }\n-        fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Encoder|) {\n+        fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n             self.emit_seq_elt(idx, f)\n         }\n \n         fn emit_tuple_struct(&mut self,\n                              _: &str,\n                              len: uint,\n-                             f: |&mut Encoder|) {\n+                             f: |&mut Encoder<'a>|) {\n             self.emit_seq(len, f)\n         }\n-        fn emit_tuple_struct_arg(&mut self, idx: uint, f: |&mut Encoder|) {\n+        fn emit_tuple_struct_arg(&mut self,\n+                                 idx: uint,\n+                                 f: |&mut Encoder<'a>|) {\n             self.emit_seq_elt(idx, f)\n         }\n \n-        fn emit_option(&mut self, f: |&mut Encoder|) {\n+        fn emit_option(&mut self, f: |&mut Encoder<'a>|) {\n             self.emit_enum(\"Option\", f);\n         }\n         fn emit_option_none(&mut self) {\n             self.emit_enum_variant(\"None\", 0, 0, |_| ())\n         }\n-        fn emit_option_some(&mut self, f: |&mut Encoder|) {\n+        fn emit_option_some(&mut self, f: |&mut Encoder<'a>|) {\n             self.emit_enum_variant(\"Some\", 1, 1, f)\n         }\n \n-        fn emit_seq(&mut self, len: uint, f: |&mut Encoder|) {\n+        fn emit_seq(&mut self, len: uint, f: |&mut Encoder<'a>|) {\n             self.start_tag(EsVec as uint);\n             self._emit_tagged_uint(EsVecLen, len);\n             f(self);\n             self.end_tag();\n         }\n \n-        fn emit_seq_elt(&mut self, _idx: uint, f: |&mut Encoder|) {\n+        fn emit_seq_elt(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n             self.start_tag(EsVecElt as uint);\n             f(self);\n             self.end_tag();\n         }\n \n-        fn emit_map(&mut self, len: uint, f: |&mut Encoder|) {\n+        fn emit_map(&mut self, len: uint, f: |&mut Encoder<'a>|) {\n             self.start_tag(EsMap as uint);\n             self._emit_tagged_uint(EsMapLen, len);\n             f(self);\n             self.end_tag();\n         }\n \n-        fn emit_map_elt_key(&mut self, _idx: uint, f: |&mut Encoder|) {\n+        fn emit_map_elt_key(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n             self.start_tag(EsMapKey as uint);\n             f(self);\n             self.end_tag();\n         }\n \n-        fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder|) {\n+        fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n             self.start_tag(EsMapVal as uint);\n             f(self);\n             self.end_tag();\n@@ -948,9 +950,11 @@ mod tests {\n     fn test_option_int() {\n         fn test_v(v: Option<int>) {\n             debug!(\"v == {:?}\", v);\n-            let wr = @mut MemWriter::new();\n-            let mut ebml_w = writer::Encoder(wr);\n-            v.encode(&mut ebml_w);\n+            let mut wr = MemWriter::new();\n+            {\n+                let mut ebml_w = writer::Encoder(&mut wr);\n+                v.encode(&mut ebml_w);\n+            }\n             let ebml_doc = reader::Doc(*wr.inner_ref());\n             let mut deser = reader::Decoder(ebml_doc);\n             let v1 = serialize::Decodable::decode(&mut deser);"}, {"sha": "07457b1db27ccdb7f35128f9a7e8d0d778a6da68", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -187,7 +187,11 @@ impl Archive {\n \n         let mut rustpath = filesearch::rust_path();\n         rustpath.push(self.sess.filesearch.get_target_lib_path());\n-        let path = self.sess.opts.addl_lib_search_paths.iter();\n+        let addl_lib_search_paths = self.sess\n+                                        .opts\n+                                        .addl_lib_search_paths\n+                                        .borrow();\n+        let path = addl_lib_search_paths.get().iter();\n         for path in path.chain(rustpath.iter()) {\n             debug!(\"looking for {} inside {}\", name, path.display());\n             let test = path.join(oslibname.as_slice());"}, {"sha": "a85d5f35b5a3de8aae23719813e2f882222fd2c4", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -208,8 +208,9 @@ pub mod write {\n             // Emit the bytecode if we're either saving our temporaries or\n             // emitting an rlib. Whenever an rlib is create, the bytecode is\n             // inserted into the archive in order to allow LTO against it.\n+            let outputs = sess.outputs.borrow();\n             if sess.opts.save_temps ||\n-               sess.outputs.iter().any(|&o| o == session::OutputRlib) {\n+               outputs.get().iter().any(|&o| o == session::OutputRlib) {\n                 output.with_extension(\"bc\").with_c_str(|buf| {\n                     llvm::LLVMWriteBitcodeToFile(llmod, buf);\n                 })\n@@ -520,15 +521,20 @@ pub fn symbol_hash(tcx: ty::ctxt,\n     hash.to_managed()\n }\n \n-pub fn get_symbol_hash(ccx: &mut CrateContext, t: ty::t) -> @str {\n-    match ccx.type_hashcodes.find(&t) {\n-      Some(&h) => h,\n-      None => {\n-        let hash = symbol_hash(ccx.tcx, &mut ccx.symbol_hasher, t, &ccx.link_meta);\n-        ccx.type_hashcodes.insert(t, hash);\n-        hash\n-      }\n+pub fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> @str {\n+    {\n+        let type_hashcodes = ccx.type_hashcodes.borrow();\n+        match type_hashcodes.get().find(&t) {\n+            Some(&h) => return h,\n+            None => {}\n+        }\n     }\n+\n+    let mut type_hashcodes = ccx.type_hashcodes.borrow_mut();\n+    let mut symbol_hasher = ccx.symbol_hasher.borrow_mut();\n+    let hash = symbol_hash(ccx.tcx, symbol_hasher.get(), t, &ccx.link_meta);\n+    type_hashcodes.get().insert(t, hash);\n+    hash\n }\n \n \n@@ -657,7 +663,7 @@ pub fn exported_name(sess: Session,\n     mangle(sess, path, Some(hash), Some(vers.as_slice()))\n }\n \n-pub fn mangle_exported_name(ccx: &mut CrateContext,\n+pub fn mangle_exported_name(ccx: &CrateContext,\n                             path: path,\n                             t: ty::t) -> ~str {\n     let hash = get_symbol_hash(ccx, t);\n@@ -666,7 +672,7 @@ pub fn mangle_exported_name(ccx: &mut CrateContext,\n                          ccx.link_meta.pkgid.version_or_default());\n }\n \n-pub fn mangle_internal_name_by_type_only(ccx: &mut CrateContext,\n+pub fn mangle_internal_name_by_type_only(ccx: &CrateContext,\n                                          t: ty::t,\n                                          name: &str) -> ~str {\n     let s = ppaux::ty_to_short_str(ccx.tcx, t);\n@@ -678,7 +684,7 @@ pub fn mangle_internal_name_by_type_only(ccx: &mut CrateContext,\n                   None);\n }\n \n-pub fn mangle_internal_name_by_type_and_seq(ccx: &mut CrateContext,\n+pub fn mangle_internal_name_by_type_and_seq(ccx: &CrateContext,\n                                             t: ty::t,\n                                             name: &str) -> ~str {\n     let s = ppaux::ty_to_str(ccx.tcx, t);\n@@ -690,15 +696,15 @@ pub fn mangle_internal_name_by_type_and_seq(ccx: &mut CrateContext,\n                   None);\n }\n \n-pub fn mangle_internal_name_by_path_and_seq(ccx: &mut CrateContext,\n+pub fn mangle_internal_name_by_path_and_seq(ccx: &CrateContext,\n                                             mut path: path,\n                                             flav: &str) -> ~str {\n     let (_, name) = gensym_name(flav);\n     path.push(name);\n     mangle(ccx.sess, path, None, None)\n }\n \n-pub fn mangle_internal_name_by_path(ccx: &mut CrateContext, path: path) -> ~str {\n+pub fn mangle_internal_name_by_path(ccx: &CrateContext, path: path) -> ~str {\n     mangle(ccx.sess, path, None, None)\n }\n \n@@ -740,7 +746,8 @@ pub fn link_binary(sess: Session,\n                    out_filename: &Path,\n                    lm: &LinkMeta) -> ~[Path] {\n     let mut out_filenames = ~[];\n-    for &output in sess.outputs.iter() {\n+    let outputs = sess.outputs.borrow();\n+    for &output in outputs.get().iter() {\n         let out_file = link_binary_output(sess, trans, output, obj_filename,\n                                           out_filename, lm);\n         out_filenames.push(out_file);\n@@ -848,7 +855,9 @@ fn link_rlib(sess: Session,\n              out_filename: &Path) -> Archive {\n     let mut a = Archive::create(sess, out_filename, obj_filename);\n \n-    for &(ref l, kind) in sess.cstore.get_used_libraries().iter() {\n+    let used_libraries = sess.cstore.get_used_libraries();\n+    let used_libraries = used_libraries.borrow();\n+    for &(ref l, kind) in used_libraries.get().iter() {\n         match kind {\n             cstore::NativeStatic => {\n                 a.add_native_library(l.as_slice());\n@@ -1082,7 +1091,9 @@ fn link_args(sess: Session,\n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n     args.push_all(sess.opts.linker_args);\n-    for arg in sess.cstore.get_used_link_args().iter() {\n+    let used_link_args = sess.cstore.get_used_link_args();\n+    let used_link_args = used_link_args.borrow();\n+    for arg in used_link_args.get().iter() {\n         args.push(arg.clone());\n     }\n     return args;\n@@ -1100,7 +1111,8 @@ fn link_args(sess: Session,\n // in the current crate. Upstream crates with native library dependencies\n // may have their native library pulled in above.\n fn add_local_native_libraries(args: &mut ~[~str], sess: Session) {\n-    for path in sess.opts.addl_lib_search_paths.iter() {\n+    let addl_lib_search_paths = sess.opts.addl_lib_search_paths.borrow();\n+    for path in addl_lib_search_paths.get().iter() {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         args.push(\"-L\" + path.as_str().unwrap().to_owned());\n     }\n@@ -1111,7 +1123,9 @@ fn add_local_native_libraries(args: &mut ~[~str], sess: Session) {\n         args.push(\"-L\" + path.as_str().unwrap().to_owned());\n     }\n \n-    for &(ref l, kind) in sess.cstore.get_used_libraries().iter() {\n+    let used_libraries = sess.cstore.get_used_libraries();\n+    let used_libraries = used_libraries.borrow();\n+    for &(ref l, kind) in used_libraries.get().iter() {\n         match kind {\n             cstore::NativeUnknown | cstore::NativeStatic => {\n                 args.push(\"-l\" + *l);"}, {"sha": "2425b36687e2dacc951b123036449156d549acf8", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -20,7 +20,8 @@ use std::libc;\n pub fn run(sess: session::Session, llmod: ModuleRef,\n            tm: TargetMachineRef, reachable: &[~str]) {\n     // Make sure we actually can run LTO\n-    for output in sess.outputs.iter() {\n+    let outputs = sess.outputs.borrow();\n+    for output in outputs.get().iter() {\n         match *output {\n             session::OutputExecutable | session::OutputStaticlib => {}\n             _ => {"}, {"sha": "2b9acb1db9d546407ac65901379af00586ed3032", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -26,6 +26,7 @@ use middle;\n use util::common::time;\n use util::ppaux;\n \n+use std::cell::{Cell, RefCell};\n use std::hashmap::{HashMap,HashSet};\n use std::io;\n use std::io::fs;\n@@ -165,8 +166,8 @@ pub fn phase_2_configure_and_expand(sess: Session,\n                                     mut crate: ast::Crate) -> ast::Crate {\n     let time_passes = sess.time_passes();\n \n-    *sess.building_library = session::building_library(sess.opts, &crate);\n-    *sess.outputs = session::collect_outputs(sess.opts, crate.attrs);\n+    sess.building_library.set(session::building_library(sess.opts, &crate));\n+    sess.outputs.set(session::collect_outputs(sess.opts, crate.attrs));\n \n     time(time_passes, \"gated feature checking\", (), |_|\n          front::feature_gate::check_crate(sess, &crate));\n@@ -211,7 +212,7 @@ pub struct CrateAnalysis {\n     exported_items: middle::privacy::ExportedItems,\n     ty_cx: ty::ctxt,\n     maps: astencode::Maps,\n-    reachable: @mut HashSet<ast::NodeId>\n+    reachable: @RefCell<HashSet<ast::NodeId>>\n }\n \n /// Run the resolution, typechecking, region checking and other\n@@ -271,8 +272,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n                                           method_map, ty_cx));\n \n     let maps = (external_exports, last_private_map);\n-    let exported_items =\n-        time(time_passes, \"privacy checking\", maps, |(a, b)|\n+    let exported_items = time(time_passes, \"privacy checking\", maps, |(a, b)|\n              middle::privacy::check_crate(ty_cx, &method_map, &exp_map2,\n                                           a, b, crate));\n \n@@ -308,9 +308,16 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n         time(time_passes, \"reachability checking\", (), |_|\n              reachable::find_reachable(ty_cx, method_map, &exported_items));\n \n-    time(time_passes, \"death checking\", (), |_|\n-         middle::dead::check_crate(ty_cx, method_map,\n-                                   &exported_items, reachable_map, crate));\n+    {\n+        let reachable_map = reachable_map.borrow();\n+        time(time_passes, \"death checking\", (), |_| {\n+             middle::dead::check_crate(ty_cx,\n+                                       method_map,\n+                                       &exported_items,\n+                                       reachable_map.get(),\n+                                       crate)\n+        });\n+    }\n \n     time(time_passes, \"lint checking\", (), |_|\n          lint::check_crate(ty_cx, method_map, &exported_items, crate));\n@@ -562,13 +569,14 @@ pub fn pretty_print_input(sess: Session,\n \n     let src = sess.codemap.get_filemap(source_name(input)).src;\n     let rdr = @mut MemReader::new(src.as_bytes().to_owned());\n+    let stdout = io::stdout();\n     pprust::print_crate(sess.codemap,\n                         token::get_ident_interner(),\n                         sess.span_diagnostic,\n                         &crate,\n                         source_name(input),\n                         rdr as @mut io::Reader,\n-                        @mut io::stdout() as @mut io::Writer,\n+                        @mut stdout as @mut io::Writer,\n                         annotation,\n                         is_expanded);\n }\n@@ -815,7 +823,7 @@ pub fn build_session_options(binary: @str,\n         lint_opts: lint_opts,\n         save_temps: save_temps,\n         output_type: output_type,\n-        addl_lib_search_paths: @mut addl_lib_search_paths,\n+        addl_lib_search_paths: @RefCell::new(addl_lib_search_paths),\n         ar: ar,\n         linker: linker,\n         linker_args: linker_args,\n@@ -854,7 +862,7 @@ pub fn build_session_(sopts: @session::options,\n     let target_cfg = build_target_config(sopts, demitter);\n     let p_s = parse::new_parse_sess_special_handler(span_diagnostic_handler,\n                                                     cm);\n-    let cstore = @mut CStore::new(token::get_ident_interner());\n+    let cstore = @CStore::new(token::get_ident_interner());\n     let filesearch = filesearch::mk_filesearch(\n         &sopts.maybe_sysroot,\n         sopts.target_triple,\n@@ -866,15 +874,15 @@ pub fn build_session_(sopts: @session::options,\n         parse_sess: p_s,\n         codemap: cm,\n         // For a library crate, this is always none\n-        entry_fn: @mut None,\n-        entry_type: @mut None,\n+        entry_fn: RefCell::new(None),\n+        entry_type: Cell::new(None),\n         span_diagnostic: span_diagnostic_handler,\n         filesearch: filesearch,\n-        building_library: @mut false,\n+        building_library: Cell::new(false),\n         working_dir: os::getcwd(),\n-        lints: @mut HashMap::new(),\n-        node_id: @mut 1,\n-        outputs: @mut ~[],\n+        lints: RefCell::new(HashMap::new()),\n+        node_id: Cell::new(1),\n+        outputs: @RefCell::new(~[]),\n     }\n }\n \n@@ -1031,7 +1039,7 @@ pub fn build_output_filenames(input: &input,\n               }\n           }\n \n-          if *sess.building_library {\n+          if sess.building_library.get() {\n               out_path = dirpath.join(os::dll_filename(stem));\n               obj_path = {\n                   let mut p = dirpath.join(stem);\n@@ -1052,7 +1060,7 @@ pub fn build_output_filenames(input: &input,\n             out_file.with_extension(obj_suffix)\n         };\n \n-        if *sess.building_library {\n+        if sess.building_library.get() {\n             sess.warn(\"ignoring specified output filename for library.\");\n         }\n \n@@ -1073,7 +1081,7 @@ pub fn early_error(emitter: @diagnostic::Emitter, msg: &str) -> ! {\n     fail!();\n }\n \n-pub fn list_metadata(sess: Session, path: &Path, out: @mut io::Writer) {\n+pub fn list_metadata(sess: Session, path: &Path, out: &mut io::Writer) {\n     metadata::loader::list_file_metadata(\n         token::get_ident_interner(),\n         session::sess_os_to_meta_os(sess.targ_cfg.os), path, out);"}, {"sha": "e3167dee0680986b634d974eca7f6968cfbd6fdf", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -28,6 +28,7 @@ use syntax::abi;\n use syntax::parse::token;\n use syntax;\n \n+use std::cell::{Cell, RefCell};\n use std::hashmap::{HashMap,HashSet};\n \n pub struct config {\n@@ -147,9 +148,9 @@ pub struct options {\n     lint_opts: ~[(lint::lint, lint::level)],\n     save_temps: bool,\n     output_type: back::link::output_type,\n-    addl_lib_search_paths: @mut HashSet<Path>, // This is mutable for rustpkg, which\n-                                               // updates search paths based on the\n-                                               // parsed code\n+    // This is mutable for rustpkg, which updates search paths based on the\n+    // parsed code.\n+    addl_lib_search_paths: @RefCell<HashSet<Path>>,\n     ar: Option<~str>,\n     linker: Option<~str>,\n     linker_args: ~[~str],\n@@ -201,19 +202,20 @@ pub enum OutputStyle {\n pub struct Session_ {\n     targ_cfg: @config,\n     opts: @options,\n-    cstore: @mut metadata::cstore::CStore,\n+    cstore: @metadata::cstore::CStore,\n     parse_sess: @mut ParseSess,\n     codemap: @codemap::CodeMap,\n     // For a library crate, this is always none\n-    entry_fn: @mut Option<(NodeId, codemap::Span)>,\n-    entry_type: @mut Option<EntryFnType>,\n+    entry_fn: RefCell<Option<(NodeId, codemap::Span)>>,\n+    entry_type: Cell<Option<EntryFnType>>,\n     span_diagnostic: @mut diagnostic::span_handler,\n     filesearch: @filesearch::FileSearch,\n-    building_library: @mut bool,\n+    building_library: Cell<bool>,\n     working_dir: Path,\n-    lints: @mut HashMap<ast::NodeId, ~[(lint::lint, codemap::Span, ~str)]>,\n-    node_id: @mut ast::NodeId,\n-    outputs: @mut ~[OutputStyle],\n+    lints: RefCell<HashMap<ast::NodeId,\n+                           ~[(lint::lint, codemap::Span, ~str)]>>,\n+    node_id: Cell<ast::NodeId>,\n+    outputs: @RefCell<~[OutputStyle]>,\n }\n \n pub type Session = @Session_;\n@@ -269,20 +271,21 @@ impl Session_ {\n                     id: ast::NodeId,\n                     sp: Span,\n                     msg: ~str) {\n-        match self.lints.find_mut(&id) {\n+        let mut lints = self.lints.borrow_mut();\n+        match lints.get().find_mut(&id) {\n             Some(arr) => { arr.push((lint, sp, msg)); return; }\n             None => {}\n         }\n-        self.lints.insert(id, ~[(lint, sp, msg)]);\n+        lints.get().insert(id, ~[(lint, sp, msg)]);\n     }\n     pub fn next_node_id(&self) -> ast::NodeId {\n         self.reserve_node_ids(1)\n     }\n     pub fn reserve_node_ids(&self, count: ast::NodeId) -> ast::NodeId {\n-        let v = *self.node_id;\n+        let v = self.node_id.get();\n \n         match v.checked_add(&count) {\n-            Some(next) => { *self.node_id = next; }\n+            Some(next) => { self.node_id.set(next); }\n             None => self.bug(\"Input too large, ran out of node ids!\")\n         }\n \n@@ -382,7 +385,7 @@ pub fn basic_options() -> @options {\n         lint_opts: ~[],\n         save_temps: false,\n         output_type: link::output_type_exe,\n-        addl_lib_search_paths: @mut HashSet::new(),\n+        addl_lib_search_paths: @RefCell::new(HashSet::new()),\n         ar: None,\n         linker: None,\n         linker_args: ~[],"}, {"sha": "03f9a3459a3a90243ff68a80acb2325e93ba75a6", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -69,7 +69,7 @@ impl fold::ast_fold for StandardLibraryInjector {\n             span: dummy_sp()\n         }];\n \n-        if use_uv(&crate) && !*self.sess.building_library {\n+        if use_uv(&crate) && !self.sess.building_library.get() {\n             vis.push(ast::view_item {\n                 node: ast::view_item_extern_mod(self.sess.ident_of(\"green\"),\n                                                 None,"}, {"sha": "47ef4b94058ba1cc32157c3d5753fee2f83dbf00", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -14,6 +14,7 @@\n use driver::session;\n use front::config;\n \n+use std::cell::RefCell;\n use std::vec;\n use syntax::ast_util::*;\n use syntax::attr::AttrMetaMethods;\n@@ -38,9 +39,9 @@ struct Test {\n \n struct TestCtxt {\n     sess: session::Session,\n-    path: ~[ast::Ident],\n+    path: RefCell<~[ast::Ident]>,\n     ext_cx: @ExtCtxt,\n-    testfns: ~[Test],\n+    testfns: RefCell<~[Test]>,\n     is_extra: bool,\n     config: ast::CrateConfig,\n }\n@@ -62,7 +63,7 @@ pub fn modify_for_testing(sess: session::Session,\n }\n \n struct TestHarnessGenerator {\n-    cx: @mut TestCtxt,\n+    cx: @TestCtxt,\n }\n \n impl fold::ast_fold for TestHarnessGenerator {\n@@ -78,9 +79,12 @@ impl fold::ast_fold for TestHarnessGenerator {\n     }\n \n     fn fold_item(&self, i: @ast::item) -> SmallVector<@ast::item> {\n-        self.cx.path.push(i.ident);\n+        {\n+            let mut path = self.cx.path.borrow_mut();\n+            path.get().push(i.ident);\n+        }\n         debug!(\"current path: {}\",\n-               ast_util::path_name_i(self.cx.path.clone()));\n+               ast_util::path_name_i(self.cx.path.get()));\n \n         if is_test_fn(self.cx, i) || is_bench_fn(i) {\n             match i.node {\n@@ -95,29 +99,35 @@ impl fold::ast_fold for TestHarnessGenerator {\n                     debug!(\"this is a test function\");\n                     let test = Test {\n                         span: i.span,\n-                        path: self.cx.path.clone(),\n+                        path: self.cx.path.get(),\n                         bench: is_bench_fn(i),\n                         ignore: is_ignored(self.cx, i),\n                         should_fail: should_fail(i)\n                     };\n-                    self.cx.testfns.push(test);\n+                    {\n+                        let mut testfns = self.cx.testfns.borrow_mut();\n+                        testfns.get().push(test);\n+                    }\n                     // debug!(\"have {} test/bench functions\",\n                     //        cx.testfns.len());\n                 }\n             }\n         }\n \n         let res = fold::noop_fold_item(i, self);\n-        self.cx.path.pop();\n+        {\n+            let mut path = self.cx.path.borrow_mut();\n+            path.get().pop();\n+        }\n         res\n     }\n \n     fn fold_mod(&self, m: &ast::_mod) -> ast::_mod {\n         // Remove any #[main] from the AST so it doesn't clash with\n         // the one we're going to add. Only if compiling an executable.\n \n-        fn nomain(cx: @mut TestCtxt, item: @ast::item) -> @ast::item {\n-            if !*cx.sess.building_library {\n+        fn nomain(cx: @TestCtxt, item: @ast::item) -> @ast::item {\n+            if !cx.sess.building_library.get() {\n                 @ast::item {\n                     attrs: item.attrs.iter().filter_map(|attr| {\n                         if \"main\" != attr.name() {\n@@ -144,11 +154,11 @@ impl fold::ast_fold for TestHarnessGenerator {\n \n fn generate_test_harness(sess: session::Session, crate: ast::Crate)\n                          -> ast::Crate {\n-    let cx: @mut TestCtxt = @mut TestCtxt {\n+    let cx: @TestCtxt = @TestCtxt {\n         sess: sess,\n         ext_cx: ExtCtxt::new(sess.parse_sess, sess.opts.cfg.clone()),\n-        path: ~[],\n-        testfns: ~[],\n+        path: RefCell::new(~[]),\n+        testfns: RefCell::new(~[]),\n         is_extra: is_extra(&crate),\n         config: crate.config.clone(),\n     };\n@@ -180,7 +190,7 @@ fn strip_test_functions(crate: ast::Crate) -> ast::Crate {\n     })\n }\n \n-fn is_test_fn(cx: @mut TestCtxt, i: @ast::item) -> bool {\n+fn is_test_fn(cx: @TestCtxt, i: @ast::item) -> bool {\n     let has_test_attr = attr::contains_name(i.attrs, \"test\");\n \n     fn has_test_signature(i: @ast::item) -> bool {\n@@ -233,7 +243,7 @@ fn is_bench_fn(i: @ast::item) -> bool {\n     return has_bench_attr && has_test_signature(i);\n }\n \n-fn is_ignored(cx: @mut TestCtxt, i: @ast::item) -> bool {\n+fn is_ignored(cx: @TestCtxt, i: @ast::item) -> bool {\n     i.attrs.iter().any(|attr| {\n         // check ignore(cfg(foo, bar))\n         \"ignore\" == attr.name() && match attr.meta_item_list() {\n@@ -382,10 +392,13 @@ fn is_extra(crate: &ast::Crate) -> bool {\n }\n \n fn mk_test_descs(cx: &TestCtxt) -> @ast::Expr {\n-    debug!(\"building test vector from {} tests\", cx.testfns.len());\n     let mut descs = ~[];\n-    for test in cx.testfns.iter() {\n-        descs.push(mk_test_desc_and_fn_rec(cx, test));\n+    {\n+        let testfns = cx.testfns.borrow();\n+        debug!(\"building test vector from {} tests\", testfns.get().len());\n+        for test in testfns.get().iter() {\n+            descs.push(mk_test_desc_and_fn_rec(cx, test));\n+        }\n     }\n \n     let inner_expr = @ast::Expr {"}, {"sha": "a9f67e3108998e38fcbdd996b72e78385b612aad", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -275,8 +275,9 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n     if ls {\n         match input {\n           d::file_input(ref ifile) => {\n+            let mut stdout = io::stdout();\n             d::list_metadata(sess, &(*ifile),\n-                                  @mut io::stdout() as @mut io::Writer);\n+                                  &mut stdout as &mut io::Writer);\n           }\n           d::str_input(_) => {\n             d::early_error(demitter, \"can not list metadata for stdin\");"}, {"sha": "50a35e9d1bf81f7de36ed6e671de1036d65dcec5", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -11,6 +11,7 @@\n #[allow(non_uppercase_pattern_statics)];\n \n use std::c_str::ToCStr;\n+use std::cell::RefCell;\n use std::hashmap::HashMap;\n use std::libc::{c_uint, c_ushort, c_void, free};\n use std::str::raw::from_c_str;\n@@ -1804,32 +1805,24 @@ pub fn SetFunctionAttribute(Fn: ValueRef, attr: Attribute) {\n /* Memory-managed object interface to type handles. */\n \n pub struct TypeNames {\n-    type_names: HashMap<TypeRef, ~str>,\n-    named_types: HashMap<~str, TypeRef>\n+    named_types: RefCell<HashMap<~str, TypeRef>>,\n }\n \n impl TypeNames {\n     pub fn new() -> TypeNames {\n         TypeNames {\n-            type_names: HashMap::new(),\n-            named_types: HashMap::new()\n+            named_types: RefCell::new(HashMap::new())\n         }\n     }\n \n-    pub fn associate_type(&mut self, s: &str, t: &Type) {\n-        assert!(self.type_names.insert(t.to_ref(), s.to_owned()));\n-        assert!(self.named_types.insert(s.to_owned(), t.to_ref()));\n-    }\n-\n-    pub fn find_name<'r>(&'r self, ty: &Type) -> Option<&'r str> {\n-        match self.type_names.find(&ty.to_ref()) {\n-            Some(a) => Some(a.slice(0, a.len())),\n-            None => None\n-        }\n+    pub fn associate_type(&self, s: &str, t: &Type) {\n+        let mut named_types = self.named_types.borrow_mut();\n+        assert!(named_types.get().insert(s.to_owned(), t.to_ref()));\n     }\n \n     pub fn find_type(&self, s: &str) -> Option<Type> {\n-        self.named_types.find_equiv(&s).map(|x| Type::from_ref(*x))\n+        let named_types = self.named_types.borrow();\n+        named_types.get().find_equiv(&s).map(|x| Type::from_ref(*x))\n     }\n \n     pub fn type_to_str(&self, ty: Type) -> ~str {"}, {"sha": "de5ae08cf5756361652ab759e05ca8965114caf1", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -15,6 +15,7 @@ use metadata::cstore;\n use metadata::decoder;\n use metadata::loader;\n \n+use std::cell::RefCell;\n use std::hashmap::HashMap;\n use syntax::ast;\n use syntax::abi;\n@@ -33,22 +34,30 @@ pub fn read_crates(sess: Session,\n                    crate: &ast::Crate,\n                    os: loader::Os,\n                    intr: @ident_interner) {\n-    let e = @mut Env {\n+    let mut e = Env {\n         sess: sess,\n         os: os,\n-        crate_cache: @mut ~[],\n+        crate_cache: @RefCell::new(~[]),\n         next_crate_num: 1,\n         intr: intr\n     };\n-    let mut v = ReadCrateVisitor{ e:e };\n-    visit_crate(e, crate);\n-    visit::walk_crate(&mut v, crate, ());\n-    dump_crates(*e.crate_cache);\n-    warn_if_multiple_versions(e, sess.diagnostic(), *e.crate_cache);\n+    visit_crate(&e, crate);\n+    {\n+        let mut v = ReadCrateVisitor {\n+            e: &mut e\n+        };\n+        visit::walk_crate(&mut v, crate, ());\n+    }\n+    let crate_cache = e.crate_cache.borrow();\n+    dump_crates(*crate_cache.get());\n+    warn_if_multiple_versions(&mut e, sess.diagnostic(), *crate_cache.get());\n }\n \n-struct ReadCrateVisitor { e:@mut Env }\n-impl visit::Visitor<()> for ReadCrateVisitor {\n+struct ReadCrateVisitor<'a> {\n+    e: &'a mut Env,\n+}\n+\n+impl<'a> visit::Visitor<()> for ReadCrateVisitor<'a> {\n     fn visit_view_item(&mut self, a:&ast::view_item, _:()) {\n         visit_view_item(self.e, a);\n         visit::walk_view_item(self, a, ());\n@@ -76,7 +85,7 @@ fn dump_crates(crate_cache: &[cache_entry]) {\n     }\n }\n \n-fn warn_if_multiple_versions(e: @mut Env,\n+fn warn_if_multiple_versions(e: &mut Env,\n                              diag: @mut span_handler,\n                              crate_cache: &[cache_entry]) {\n     if crate_cache.len() != 0u {\n@@ -103,7 +112,7 @@ fn warn_if_multiple_versions(e: @mut Env,\n struct Env {\n     sess: Session,\n     os: loader::Os,\n-    crate_cache: @mut ~[cache_entry],\n+    crate_cache: @RefCell<~[cache_entry]>,\n     next_crate_num: ast::CrateNum,\n     intr: @ident_interner\n }\n@@ -121,7 +130,7 @@ fn visit_crate(e: &Env, c: &ast::Crate) {\n     }\n }\n \n-fn visit_view_item(e: @mut Env, i: &ast::view_item) {\n+fn visit_view_item(e: &mut Env, i: &ast::view_item) {\n     match i.node {\n       ast::view_item_extern_mod(ident, path_opt, _, id) => {\n           let ident = token::ident_to_str(&ident);\n@@ -234,7 +243,8 @@ fn visit_item(e: &Env, i: @ast::item) {\n }\n \n fn existing_match(e: &Env, name: @str, version: @str, hash: &str) -> Option<ast::CrateNum> {\n-    for c in e.crate_cache.iter() {\n+    let crate_cache = e.crate_cache.borrow();\n+    for c in crate_cache.get().iter() {\n         let pkgid_version = match c.pkgid.version {\n             None => @\"0.0\",\n             Some(ref ver) => ver.to_managed(),\n@@ -248,7 +258,7 @@ fn existing_match(e: &Env, name: @str, version: @str, hash: &str) -> Option<ast:\n     None\n }\n \n-fn resolve_crate(e: @mut Env,\n+fn resolve_crate(e: &mut Env,\n                  ident: @str,\n                  name: @str,\n                  version: @str,\n@@ -277,12 +287,15 @@ fn resolve_crate(e: @mut Env,\n \n         // Claim this crate number and cache it\n         let cnum = e.next_crate_num;\n-        e.crate_cache.push(cache_entry {\n-            cnum: cnum,\n-            span: span,\n-            hash: hash,\n-            pkgid: pkgid,\n-        });\n+        {\n+            let mut crate_cache = e.crate_cache.borrow_mut();\n+            crate_cache.get().push(cache_entry {\n+                cnum: cnum,\n+                span: span,\n+                hash: hash,\n+                pkgid: pkgid,\n+            });\n+        }\n         e.next_crate_num += 1;\n \n         // Now resolve the crates referenced by this crate\n@@ -311,7 +324,7 @@ fn resolve_crate(e: @mut Env,\n }\n \n // Go through the crate metadata and load any crates that it references\n-fn resolve_crate_deps(e: @mut Env, cdata: &[u8]) -> cstore::cnum_map {\n+fn resolve_crate_deps(e: &mut Env, cdata: &[u8]) -> cstore::cnum_map {\n     debug!(\"resolving deps of external crate\");\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers\n@@ -340,5 +353,5 @@ fn resolve_crate_deps(e: @mut Env, cdata: &[u8]) -> cstore::cnum_map {\n           }\n         }\n     }\n-    return @mut cnum_map;\n+    return @RefCell::new(cnum_map);\n }"}, {"sha": "ffb6eb367927398634fb511dc06a929f49dc9195", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -30,19 +30,19 @@ pub struct StaticMethodInfo {\n     vis: ast::visibility,\n }\n \n-pub fn get_symbol(cstore: @mut cstore::CStore, def: ast::DefId) -> ~str {\n+pub fn get_symbol(cstore: @cstore::CStore, def: ast::DefId) -> ~str {\n     let cdata = cstore.get_crate_data(def.crate).data();\n     return decoder::get_symbol(cdata, def.node);\n }\n \n-pub fn get_type_param_count(cstore: @mut cstore::CStore, def: ast::DefId)\n+pub fn get_type_param_count(cstore: @cstore::CStore, def: ast::DefId)\n                          -> uint {\n     let cdata = cstore.get_crate_data(def.crate).data();\n     return decoder::get_type_param_count(cdata, def.node);\n }\n \n /// Iterates over all the language items in the given crate.\n-pub fn each_lang_item(cstore: @mut cstore::CStore,\n+pub fn each_lang_item(cstore: @cstore::CStore,\n                       cnum: ast::CrateNum,\n                       f: |ast::NodeId, uint| -> bool)\n                       -> bool {\n@@ -51,7 +51,7 @@ pub fn each_lang_item(cstore: @mut cstore::CStore,\n }\n \n /// Iterates over each child of the given item.\n-pub fn each_child_of_item(cstore: @mut cstore::CStore,\n+pub fn each_child_of_item(cstore: @cstore::CStore,\n                           def_id: ast::DefId,\n                           callback: |decoder::DefLike,\n                                      ast::Ident,\n@@ -68,7 +68,7 @@ pub fn each_child_of_item(cstore: @mut cstore::CStore,\n }\n \n /// Iterates over each top-level crate item.\n-pub fn each_top_level_item_of_crate(cstore: @mut cstore::CStore,\n+pub fn each_top_level_item_of_crate(cstore: @cstore::CStore,\n                                     cnum: ast::CrateNum,\n                                     callback: |decoder::DefLike,\n                                                ast::Ident,\n@@ -131,21 +131,21 @@ pub fn get_method(tcx: ty::ctxt, def: ast::DefId) -> ty::Method {\n     decoder::get_method(tcx.cstore.intr, cdata, def.node, tcx)\n }\n \n-pub fn get_method_name_and_explicit_self(cstore: @mut cstore::CStore,\n+pub fn get_method_name_and_explicit_self(cstore: @cstore::CStore,\n                                          def: ast::DefId)\n                                      -> (ast::Ident, ast::explicit_self_)\n {\n     let cdata = cstore.get_crate_data(def.crate);\n     decoder::get_method_name_and_explicit_self(cstore.intr, cdata, def.node)\n }\n \n-pub fn get_trait_method_def_ids(cstore: @mut cstore::CStore,\n+pub fn get_trait_method_def_ids(cstore: @cstore::CStore,\n                                 def: ast::DefId) -> ~[ast::DefId] {\n     let cdata = cstore.get_crate_data(def.crate);\n     decoder::get_trait_method_def_ids(cdata, def.node)\n }\n \n-pub fn get_item_variances(cstore: @mut cstore::CStore,\n+pub fn get_item_variances(cstore: @cstore::CStore,\n                           def: ast::DefId) -> ty::ItemVariances {\n     let cdata = cstore.get_crate_data(def.crate);\n     decoder::get_item_variances(cdata, def.node)\n@@ -165,27 +165,27 @@ pub fn get_supertraits(tcx: ty::ctxt, def: ast::DefId) -> ~[@ty::TraitRef] {\n     decoder::get_supertraits(cdata, def.node, tcx)\n }\n \n-pub fn get_type_name_if_impl(cstore: @mut cstore::CStore, def: ast::DefId)\n+pub fn get_type_name_if_impl(cstore: @cstore::CStore, def: ast::DefId)\n                           -> Option<ast::Ident> {\n     let cdata = cstore.get_crate_data(def.crate);\n     decoder::get_type_name_if_impl(cdata, def.node)\n }\n \n-pub fn get_static_methods_if_impl(cstore: @mut cstore::CStore,\n+pub fn get_static_methods_if_impl(cstore: @cstore::CStore,\n                                   def: ast::DefId)\n                                -> Option<~[StaticMethodInfo]> {\n     let cdata = cstore.get_crate_data(def.crate);\n     decoder::get_static_methods_if_impl(cstore.intr, cdata, def.node)\n }\n \n-pub fn get_item_attrs(cstore: @mut cstore::CStore,\n+pub fn get_item_attrs(cstore: @cstore::CStore,\n                       def_id: ast::DefId,\n                       f: |~[@ast::MetaItem]|) {\n     let cdata = cstore.get_crate_data(def_id.crate);\n     decoder::get_item_attrs(cdata, def_id.node, f)\n }\n \n-pub fn get_struct_fields(cstore: @mut cstore::CStore,\n+pub fn get_struct_fields(cstore: @cstore::CStore,\n                          def: ast::DefId)\n                       -> ~[ty::field_ty] {\n     let cdata = cstore.get_crate_data(def.crate);\n@@ -247,43 +247,43 @@ pub fn get_impl_vtables(tcx: ty::ctxt,\n     decoder::get_impl_vtables(cdata, def.node, tcx)\n }\n \n-pub fn get_impl_method(cstore: @mut cstore::CStore,\n+pub fn get_impl_method(cstore: @cstore::CStore,\n                        def: ast::DefId,\n                        mname: ast::Ident)\n                     -> Option<ast::DefId> {\n     let cdata = cstore.get_crate_data(def.crate);\n     decoder::get_impl_method(cstore.intr, cdata, def.node, mname)\n }\n \n-pub fn get_item_visibility(cstore: @mut cstore::CStore,\n+pub fn get_item_visibility(cstore: @cstore::CStore,\n                            def_id: ast::DefId)\n                         -> ast::visibility {\n     let cdata = cstore.get_crate_data(def_id.crate);\n     decoder::get_item_visibility(cdata, def_id.node)\n }\n \n-pub fn get_native_libraries(cstore: @mut cstore::CStore,\n+pub fn get_native_libraries(cstore: @cstore::CStore,\n                             crate_num: ast::CrateNum)\n                                 -> ~[(cstore::NativeLibaryKind, ~str)] {\n     let cdata = cstore.get_crate_data(crate_num);\n     decoder::get_native_libraries(cdata)\n }\n \n-pub fn each_impl(cstore: @mut cstore::CStore,\n+pub fn each_impl(cstore: @cstore::CStore,\n                  crate_num: ast::CrateNum,\n                  callback: |ast::DefId|) {\n     let cdata = cstore.get_crate_data(crate_num);\n     decoder::each_impl(cdata, callback)\n }\n \n-pub fn each_implementation_for_type(cstore: @mut cstore::CStore,\n+pub fn each_implementation_for_type(cstore: @cstore::CStore,\n                                     def_id: ast::DefId,\n                                     callback: |ast::DefId|) {\n     let cdata = cstore.get_crate_data(def_id.crate);\n     decoder::each_implementation_for_type(cdata, def_id.node, callback)\n }\n \n-pub fn each_implementation_for_trait(cstore: @mut cstore::CStore,\n+pub fn each_implementation_for_trait(cstore: @cstore::CStore,\n                                      def_id: ast::DefId,\n                                      callback: |ast::DefId|) {\n     let cdata = cstore.get_crate_data(def_id.crate);\n@@ -293,7 +293,7 @@ pub fn each_implementation_for_trait(cstore: @mut cstore::CStore,\n /// If the given def ID describes a method belonging to a trait (either a\n /// default method or an implementation of a trait method), returns the ID of\n /// the trait that the method belongs to. Otherwise, returns `None`.\n-pub fn get_trait_of_method(cstore: @mut cstore::CStore,\n+pub fn get_trait_of_method(cstore: @cstore::CStore,\n                            def_id: ast::DefId,\n                            tcx: ty::ctxt)\n                            -> Option<ast::DefId> {"}, {"sha": "f567665256bdc5002554926bb5ad2abd7a62ad40", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 48, "deletions": 37, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -15,6 +15,7 @@\n use metadata::decoder;\n use metadata::loader;\n \n+use std::cell::RefCell;\n use std::hashmap::HashMap;\n use syntax::ast;\n use syntax::parse::token::ident_interner;\n@@ -23,7 +24,7 @@ use syntax::parse::token::ident_interner;\n // local crate numbers (as generated during this session). Each external\n // crate may refer to types in other external crates, and each has their\n // own crate numbers.\n-pub type cnum_map = @mut HashMap<ast::CrateNum, ast::CrateNum>;\n+pub type cnum_map = @RefCell<HashMap<ast::CrateNum, ast::CrateNum>>;\n \n pub enum MetadataBlob {\n     MetadataVec(~[u8]),\n@@ -60,11 +61,11 @@ pub struct CrateSource {\n }\n \n pub struct CStore {\n-    priv metas: HashMap <ast::CrateNum, @crate_metadata>,\n-    priv extern_mod_crate_map: extern_mod_crate_map,\n-    priv used_crate_sources: ~[CrateSource],\n-    priv used_libraries: ~[(~str, NativeLibaryKind)],\n-    priv used_link_args: ~[~str],\n+    priv metas: RefCell<HashMap<ast::CrateNum, @crate_metadata>>,\n+    priv extern_mod_crate_map: RefCell<extern_mod_crate_map>,\n+    priv used_crate_sources: RefCell<~[CrateSource]>,\n+    priv used_libraries: RefCell<~[(~str, NativeLibaryKind)]>,\n+    priv used_link_args: RefCell<~[~str]>,\n     intr: @ident_interner\n }\n \n@@ -74,17 +75,18 @@ type extern_mod_crate_map = HashMap<ast::NodeId, ast::CrateNum>;\n impl CStore {\n     pub fn new(intr: @ident_interner) -> CStore {\n         CStore {\n-            metas: HashMap::new(),\n-            extern_mod_crate_map: HashMap::new(),\n-            used_crate_sources: ~[],\n-            used_libraries: ~[],\n-            used_link_args: ~[],\n+            metas: RefCell::new(HashMap::new()),\n+            extern_mod_crate_map: RefCell::new(HashMap::new()),\n+            used_crate_sources: RefCell::new(~[]),\n+            used_libraries: RefCell::new(~[]),\n+            used_link_args: RefCell::new(~[]),\n             intr: intr\n         }\n     }\n \n     pub fn get_crate_data(&self, cnum: ast::CrateNum) -> @crate_metadata {\n-        *self.metas.get(&cnum)\n+        let metas = self.metas.borrow();\n+        *metas.get().get(&cnum)\n     }\n \n     pub fn get_crate_hash(&self, cnum: ast::CrateNum) -> @str {\n@@ -97,80 +99,89 @@ impl CStore {\n         decoder::get_crate_vers(cdata.data())\n     }\n \n-    pub fn set_crate_data(&mut self, cnum: ast::CrateNum, data: @crate_metadata) {\n-        self.metas.insert(cnum, data);\n+    pub fn set_crate_data(&self, cnum: ast::CrateNum, data: @crate_metadata) {\n+        let mut metas = self.metas.borrow_mut();\n+        metas.get().insert(cnum, data);\n     }\n \n     pub fn have_crate_data(&self, cnum: ast::CrateNum) -> bool {\n-        self.metas.contains_key(&cnum)\n+        let metas = self.metas.borrow();\n+        metas.get().contains_key(&cnum)\n     }\n \n     pub fn iter_crate_data(&self, i: |ast::CrateNum, @crate_metadata|) {\n-        for (&k, &v) in self.metas.iter() {\n+        let metas = self.metas.borrow();\n+        for (&k, &v) in metas.get().iter() {\n             i(k, v);\n         }\n     }\n \n-    pub fn add_used_crate_source(&mut self, src: CrateSource) {\n-        if !self.used_crate_sources.contains(&src) {\n-            self.used_crate_sources.push(src);\n+    pub fn add_used_crate_source(&self, src: CrateSource) {\n+        let mut used_crate_sources = self.used_crate_sources.borrow_mut();\n+        if !used_crate_sources.get().contains(&src) {\n+            used_crate_sources.get().push(src);\n         }\n     }\n \n-    pub fn get_used_crate_sources<'a>(&'a self) -> &'a [CrateSource] {\n-        self.used_crate_sources.as_slice()\n-    }\n-\n     pub fn get_used_crates(&self, prefer: LinkagePreference)\n                            -> ~[(ast::CrateNum, Option<Path>)] {\n-        self.used_crate_sources.iter()\n+        let used_crate_sources = self.used_crate_sources.borrow();\n+        used_crate_sources.get()\n+            .iter()\n             .map(|src| (src.cnum, match prefer {\n                 RequireDynamic => src.dylib.clone(),\n                 RequireStatic => src.rlib.clone(),\n             }))\n             .collect()\n     }\n \n-    pub fn add_used_library(&mut self, lib: ~str, kind: NativeLibaryKind) -> bool {\n+    pub fn add_used_library(&self, lib: ~str, kind: NativeLibaryKind)\n+                            -> bool {\n         assert!(!lib.is_empty());\n-        if self.used_libraries.iter().any(|&(ref x, _)| x == &lib) {\n+        let mut used_libraries = self.used_libraries.borrow_mut();\n+        if used_libraries.get().iter().any(|&(ref x, _)| x == &lib) {\n             return false;\n         }\n-        self.used_libraries.push((lib, kind));\n+        used_libraries.get().push((lib, kind));\n         true\n     }\n \n-    pub fn get_used_libraries<'a>(&'a self) -> &'a [(~str, NativeLibaryKind)] {\n-        self.used_libraries.as_slice()\n+    pub fn get_used_libraries<'a>(&'a self)\n+                              -> &'a RefCell<~[(~str, NativeLibaryKind)]> {\n+        &self.used_libraries\n     }\n \n-    pub fn add_used_link_args(&mut self, args: &str) {\n+    pub fn add_used_link_args(&self, args: &str) {\n+        let mut used_link_args = self.used_link_args.borrow_mut();\n         for s in args.split(' ') {\n-            self.used_link_args.push(s.to_owned());\n+            used_link_args.get().push(s.to_owned());\n         }\n     }\n \n-    pub fn get_used_link_args<'a>(&'a self) -> &'a [~str] {\n-        self.used_link_args.as_slice()\n+    pub fn get_used_link_args<'a>(&'a self) -> &'a RefCell<~[~str]> {\n+        &self.used_link_args\n     }\n \n-    pub fn add_extern_mod_stmt_cnum(&mut self,\n+    pub fn add_extern_mod_stmt_cnum(&self,\n                                     emod_id: ast::NodeId,\n                                     cnum: ast::CrateNum) {\n-        self.extern_mod_crate_map.insert(emod_id, cnum);\n+        let mut extern_mod_crate_map = self.extern_mod_crate_map.borrow_mut();\n+        extern_mod_crate_map.get().insert(emod_id, cnum);\n     }\n \n     pub fn find_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId)\n                                      -> Option<ast::CrateNum> {\n-        self.extern_mod_crate_map.find(&emod_id).map(|x| *x)\n+        let extern_mod_crate_map = self.extern_mod_crate_map.borrow();\n+        extern_mod_crate_map.get().find(&emod_id).map(|x| *x)\n     }\n \n     // returns hashes of crates directly used by this crate. Hashes are sorted by\n     // (crate name, crate version, crate hash) in lexicographic order (not semver)\n     pub fn get_dep_hashes(&self) -> ~[@str] {\n         let mut result = ~[];\n \n-        for (_, &cnum) in self.extern_mod_crate_map.iter() {\n+        let extern_mod_crate_map = self.extern_mod_crate_map.borrow();\n+        for (_, &cnum) in extern_mod_crate_map.get().iter() {\n             let cdata = self.get_crate_data(cnum);\n             let hash = decoder::get_crate_hash(cdata.data());\n             let vers = decoder::get_crate_vers(cdata.data());"}, {"sha": "a0b339cc91d74e772a82ed031978da931accd95f", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -494,6 +494,7 @@ pub fn get_symbol(data: &[u8], id: ast::NodeId) -> ~str {\n }\n \n // Something that a name can resolve to.\n+#[deriving(Clone)]\n pub enum DefLike {\n     DlDef(ast::Def),\n     DlImpl(ast::DefId),\n@@ -1109,7 +1110,7 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n }\n \n fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n-                         out: @mut io::Writer) {\n+                         out: &mut io::Writer) {\n     write!(out, \"=Crate Attributes ({})=\\n\", hash);\n \n     let r = get_attributes(md);\n@@ -1152,7 +1153,7 @@ pub fn get_crate_deps(data: &[u8]) -> ~[CrateDep] {\n     return deps;\n }\n \n-fn list_crate_deps(data: &[u8], out: @mut io::Writer) {\n+fn list_crate_deps(data: &[u8], out: &mut io::Writer) {\n     write!(out, \"=External Dependencies=\\n\");\n \n     let r = get_crate_deps(data);\n@@ -1179,7 +1180,7 @@ pub fn get_crate_vers(data: &[u8]) -> @str {\n }\n \n pub fn list_crate_metadata(intr: @ident_interner, bytes: &[u8],\n-                           out: @mut io::Writer) {\n+                           out: &mut io::Writer) {\n     let hash = get_crate_hash(bytes);\n     let md = reader::Doc(bytes);\n     list_crate_attributes(intr, md, hash, out);\n@@ -1196,9 +1197,15 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n         return ast::DefId { crate: cdata.cnum, node: did.node };\n     }\n \n-    match cdata.cnum_map.find(&did.crate) {\n-      option::Some(&n) => ast::DefId { crate: n, node: did.node },\n-      option::None => fail!(\"didn't find a crate in the cnum_map\")\n+    let cnum_map = cdata.cnum_map.borrow();\n+    match cnum_map.get().find(&did.crate) {\n+        Some(&n) => {\n+            ast::DefId {\n+                crate: n,\n+                node: did.node,\n+            }\n+        }\n+        None => fail!(\"didn't find a crate in the cnum_map\")\n     }\n }\n "}, {"sha": "7bd87f5dff816148e04f3de621c3bfa5b3c1cef8", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 213, "deletions": 141, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -22,6 +22,7 @@ use middle::typeck;\n use middle;\n \n use std::cast;\n+use std::cell::{Cell, RefCell};\n use std::hashmap::{HashMap, HashSet};\n use std::io::mem::MemWriter;\n use std::io::{Writer, Seek, Decorator};\n@@ -48,7 +49,7 @@ use syntax;\n use writer = extra::ebml::writer;\n \n // used by astencode:\n-type abbrev_map = @mut HashMap<ty::t, tyencode::ty_abbrev>;\n+type abbrev_map = @RefCell<HashMap<ty::t, tyencode::ty_abbrev>>;\n \n pub type encode_inlined_item<'a> = 'a |ecx: &EncodeContext,\n                                              ebml_w: &mut writer::Encoder,\n@@ -59,48 +60,45 @@ pub struct EncodeParams<'a> {\n     diag: @mut span_handler,\n     tcx: ty::ctxt,\n     reexports2: middle::resolve::ExportMap2,\n-    item_symbols: &'a HashMap<ast::NodeId, ~str>,\n-    discrim_symbols: &'a HashMap<ast::NodeId, @str>,\n-    non_inlineable_statics: &'a HashSet<ast::NodeId>,\n+    item_symbols: &'a RefCell<HashMap<ast::NodeId, ~str>>,\n+    non_inlineable_statics: &'a RefCell<HashSet<ast::NodeId>>,\n     link_meta: &'a LinkMeta,\n-    cstore: @mut cstore::CStore,\n+    cstore: @cstore::CStore,\n     encode_inlined_item: encode_inlined_item<'a>,\n-    reachable: @mut HashSet<ast::NodeId>,\n+    reachable: @RefCell<HashSet<ast::NodeId>>,\n }\n \n struct Stats {\n-    inline_bytes: u64,\n-    attr_bytes: u64,\n-    dep_bytes: u64,\n-    lang_item_bytes: u64,\n-    native_lib_bytes: u64,\n-    impl_bytes: u64,\n-    misc_bytes: u64,\n-    item_bytes: u64,\n-    index_bytes: u64,\n-    zero_bytes: u64,\n-    total_bytes: u64,\n-\n-    n_inlines: uint\n+    inline_bytes: Cell<u64>,\n+    attr_bytes: Cell<u64>,\n+    dep_bytes: Cell<u64>,\n+    lang_item_bytes: Cell<u64>,\n+    native_lib_bytes: Cell<u64>,\n+    impl_bytes: Cell<u64>,\n+    misc_bytes: Cell<u64>,\n+    item_bytes: Cell<u64>,\n+    index_bytes: Cell<u64>,\n+    zero_bytes: Cell<u64>,\n+    total_bytes: Cell<u64>,\n }\n \n pub struct EncodeContext<'a> {\n     diag: @mut span_handler,\n     tcx: ty::ctxt,\n-    stats: @mut Stats,\n+    stats: @Stats,\n     reexports2: middle::resolve::ExportMap2,\n-    item_symbols: &'a HashMap<ast::NodeId, ~str>,\n-    discrim_symbols: &'a HashMap<ast::NodeId, @str>,\n-    non_inlineable_statics: &'a HashSet<ast::NodeId>,\n+    item_symbols: &'a RefCell<HashMap<ast::NodeId, ~str>>,\n+    non_inlineable_statics: &'a RefCell<HashSet<ast::NodeId>>,\n     link_meta: &'a LinkMeta,\n     cstore: &'a cstore::CStore,\n     encode_inlined_item: encode_inlined_item<'a>,\n     type_abbrevs: abbrev_map,\n-    reachable: @mut HashSet<ast::NodeId>,\n+    reachable: @RefCell<HashSet<ast::NodeId>>,\n }\n \n pub fn reachable(ecx: &EncodeContext, id: NodeId) -> bool {\n-    ecx.reachable.contains(&id)\n+    let reachable = ecx.reachable.borrow();\n+    reachable.get().contains(&id)\n }\n \n fn encode_name(ecx: &EncodeContext,\n@@ -283,7 +281,8 @@ fn encode_symbol(ecx: &EncodeContext,\n                  ebml_w: &mut writer::Encoder,\n                  id: NodeId) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n-    match ecx.item_symbols.find(&id) {\n+    let item_symbols = ecx.item_symbols.borrow();\n+    match item_symbols.get().find(&id) {\n         Some(x) => {\n             debug!(\"encode_symbol(id={:?}, str={})\", id, *x);\n             ebml_w.writer.write(x.as_bytes());\n@@ -338,7 +337,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                             id: NodeId,\n                             variants: &[P<variant>],\n                             path: &[ast_map::path_elt],\n-                            index: @mut ~[entry<i64>],\n+                            index: @RefCell<~[entry<i64>]>,\n                             generics: &ast::Generics) {\n     debug!(\"encode_enum_variant_info(id={:?})\", id);\n \n@@ -348,8 +347,13 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                                ast::DefId { crate: LOCAL_CRATE, node: id });\n     for variant in variants.iter() {\n         let def_id = local_def(variant.node.id);\n-        index.push(entry {val: variant.node.id as i64,\n-                          pos: ebml_w.writer.tell()});\n+        {\n+            let mut index = index.borrow_mut();\n+            index.get().push(entry {\n+                val: variant.node.id as i64,\n+                pos: ebml_w.writer.tell(),\n+            });\n+        }\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         match variant.node.kind {\n@@ -442,9 +446,11 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                                          ebml_w: &mut writer::Encoder,\n                                          exp: &middle::resolve::Export2)\n                                          -> bool {\n-    match ecx.tcx.inherent_impls.find(&exp.def_id) {\n+    let inherent_impls = ecx.tcx.inherent_impls.borrow();\n+    match inherent_impls.get().find(&exp.def_id) {\n         Some(implementations) => {\n-            for &base_impl in implementations.iter() {\n+            let implementations = implementations.borrow();\n+            for &base_impl in implementations.get().iter() {\n                 for &m in base_impl.methods.iter() {\n                     if m.explicit_self == ast::sty_static {\n                         encode_reexported_static_method(ecx, ebml_w, exp,\n@@ -463,7 +469,8 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n                                           ebml_w: &mut writer::Encoder,\n                                           exp: &middle::resolve::Export2)\n                                           -> bool {\n-    match ecx.tcx.trait_methods_cache.find(&exp.def_id) {\n+    let trait_methods_cache = ecx.tcx.trait_methods_cache.borrow();\n+    match trait_methods_cache.get().find(&exp.def_id) {\n         Some(methods) => {\n             for &m in methods.iter() {\n                 if m.explicit_self == ast::sty_static {\n@@ -553,7 +560,8 @@ fn encode_reexports(ecx: &EncodeContext,\n                     id: NodeId,\n                     path: &[ast_map::path_elt]) {\n     debug!(\"(encoding info for module) encoding reexports for {}\", id);\n-    match ecx.reexports2.find(&id) {\n+    let reexports2 = ecx.reexports2.borrow();\n+    match reexports2.get().find(&id) {\n         Some(ref exports) => {\n             debug!(\"(encoding info for module) found reexports for {}\", id);\n             for exp in exports.iter() {\n@@ -715,7 +723,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n                           ebml_w: &mut writer::Encoder,\n                           path: &[ast_map::path_elt],\n                           fields: &[struct_field],\n-                          global_index: @mut ~[entry<i64>])\n+                          global_index: @RefCell<~[entry<i64>]>)\n                           -> ~[entry<i64>] {\n     /* Each class has its own index, since different classes\n        may have fields with the same name */\n@@ -731,7 +739,13 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n \n         let id = field.node.id;\n         index.push(entry {val: id as i64, pos: ebml_w.writer.tell()});\n-        global_index.push(entry {val: id as i64, pos: ebml_w.writer.tell()});\n+        {\n+            let mut global_index = global_index.borrow_mut();\n+            global_index.get().push(entry {\n+                val: id as i64,\n+                pos: ebml_w.writer.tell(),\n+            });\n+        }\n         ebml_w.start_tag(tag_items_data_item);\n         debug!(\"encode_info_for_struct: doing {} {}\",\n                tcx.sess.str_of(nm), id);\n@@ -750,9 +764,15 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                path: &[ast_map::path_elt],\n                                name: ast::Ident,\n                                ctor_id: NodeId,\n-                               index: @mut ~[entry<i64>],\n+                               index: @RefCell<~[entry<i64>]>,\n                                struct_id: NodeId) {\n-    index.push(entry { val: ctor_id as i64, pos: ebml_w.writer.tell() });\n+    {\n+        let mut index = index.borrow_mut();\n+        index.get().push(entry {\n+            val: ctor_id as i64,\n+            pos: ebml_w.writer.tell(),\n+        });\n+    }\n \n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(ctor_id));\n@@ -762,7 +782,8 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n     encode_path(ecx, ebml_w, path, ast_map::path_name(name));\n     encode_parent_item(ebml_w, local_def(struct_id));\n \n-    if ecx.item_symbols.contains_key(&ctor_id) {\n+    let item_symbols = ecx.item_symbols.borrow();\n+    if item_symbols.get().contains_key(&ctor_id) {\n         encode_symbol(ecx, ebml_w, ctor_id);\n     }\n \n@@ -860,10 +881,12 @@ fn should_inline(attrs: &[Attribute]) -> bool {\n fn encode_inherent_implementations(ecx: &EncodeContext,\n                                    ebml_w: &mut writer::Encoder,\n                                    def_id: DefId) {\n-    match ecx.tcx.inherent_impls.find(&def_id) {\n+    let inherent_impls = ecx.tcx.inherent_impls.borrow();\n+    match inherent_impls.get().find(&def_id) {\n         None => {}\n         Some(&implementations) => {\n-            for implementation in implementations.iter() {\n+            let implementations = implementations.borrow();\n+            for implementation in implementations.get().iter() {\n                 ebml_w.start_tag(tag_items_data_item_inherent_impl);\n                 encode_def_id(ebml_w, implementation.did);\n                 ebml_w.end_tag();\n@@ -876,10 +899,12 @@ fn encode_inherent_implementations(ecx: &EncodeContext,\n fn encode_extension_implementations(ecx: &EncodeContext,\n                                     ebml_w: &mut writer::Encoder,\n                                     trait_def_id: DefId) {\n-    match ecx.tcx.trait_impls.find(&trait_def_id) {\n+    let trait_impls = ecx.tcx.trait_impls.borrow();\n+    match trait_impls.get().find(&trait_def_id) {\n         None => {}\n         Some(&implementations) => {\n-            for implementation in implementations.iter() {\n+            let implementations = implementations.borrow();\n+            for implementation in implementations.get().iter() {\n                 ebml_w.start_tag(tag_items_data_item_extension_impl);\n                 encode_def_id(ebml_w, implementation.did);\n                 ebml_w.end_tag();\n@@ -891,14 +916,18 @@ fn encode_extension_implementations(ecx: &EncodeContext,\n fn encode_info_for_item(ecx: &EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         item: @item,\n-                        index: @mut ~[entry<i64>],\n+                        index: @RefCell<~[entry<i64>]>,\n                         path: &[ast_map::path_elt],\n                         vis: ast::visibility) {\n     let tcx = ecx.tcx;\n \n     fn add_to_index(item: @item, ebml_w: &writer::Encoder,\n-                     index: @mut ~[entry<i64>]) {\n-        index.push(entry { val: item.id as i64, pos: ebml_w.writer.tell() });\n+                     index: @RefCell<~[entry<i64>]>) {\n+        let mut index = index.borrow_mut();\n+        index.get().push(entry {\n+            val: item.id as i64,\n+            pos: ebml_w.writer.tell(),\n+        });\n     }\n     let add_to_index: || = || add_to_index(item, ebml_w, index);\n \n@@ -921,7 +950,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(ecx, ebml_w, item.ident);\n         let elt = ast_map::path_pretty_name(item.ident, item.id as u64);\n         encode_path(ecx, ebml_w, path, elt);\n-        if !ecx.non_inlineable_statics.contains(&item.id) {\n+\n+        let non_inlineable;\n+        {\n+            let non_inlineable_statics = ecx.non_inlineable_statics.borrow();\n+            non_inlineable = non_inlineable_statics.get().contains(&item.id);\n+        }\n+\n+        if !non_inlineable {\n             (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n         }\n         encode_visibility(ebml_w, vis);\n@@ -1072,7 +1108,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n       item_impl(_, ref opt_trait, ty, ref ast_methods) => {\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n-        let imp = tcx.impls.get(&def_id);\n+        let impls = tcx.impls.borrow();\n+        let imp = impls.get().get(&def_id);\n \n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n@@ -1121,8 +1158,13 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 Some(ast_methods[i])\n             } else { None };\n \n-            index.push(entry {val: m.def_id.node as i64,\n-                              pos: ebml_w.writer.tell()});\n+            {\n+                let mut index = index.borrow_mut();\n+                index.get().push(entry {\n+                    val: m.def_id.node as i64,\n+                    pos: ebml_w.writer.tell(),\n+                });\n+            }\n             encode_info_for_method(ecx,\n                                    ebml_w,\n                                    *m,\n@@ -1177,8 +1219,13 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             let method_ty = ty::method(tcx, method_def_id);\n \n-            index.push(entry {val: method_def_id.node as i64,\n-                              pos: ebml_w.writer.tell()});\n+            {\n+                let mut index = index.borrow_mut();\n+                index.get().push(entry {\n+                    val: method_def_id.node as i64,\n+                    pos: ebml_w.writer.tell(),\n+                });\n+            }\n \n             ebml_w.start_tag(tag_items_data_item);\n \n@@ -1242,10 +1289,16 @@ fn encode_info_for_item(ecx: &EncodeContext,\n fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 ebml_w: &mut writer::Encoder,\n                                 nitem: @foreign_item,\n-                                index: @mut ~[entry<i64>],\n+                                index: @RefCell<~[entry<i64>]>,\n                                 path: &ast_map::path,\n                                 abi: AbiSet) {\n-    index.push(entry { val: nitem.id as i64, pos: ebml_w.writer.tell() });\n+    {\n+        let mut index = index.borrow_mut();\n+        index.get().push(entry {\n+            val: nitem.id as i64,\n+            pos: ebml_w.writer.tell(),\n+        });\n+    }\n \n     ebml_w.start_tag(tag_items_data_item);\n     match nitem.node {\n@@ -1280,11 +1333,16 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n \n fn my_visit_expr(_e:@Expr) { }\n \n-fn my_visit_item(i:@item, items: ast_map::map, ebml_w:&writer::Encoder,\n-                 ecx_ptr:*int, index: @mut ~[entry<i64>]) {\n+fn my_visit_item(i: @item,\n+                 items: ast_map::map,\n+                 ebml_w: &mut writer::Encoder,\n+                 ecx_ptr: *int,\n+                 index: @RefCell<~[entry<i64>]>) {\n     match items.get_copy(&i.id) {\n         ast_map::node_item(_, pt) => {\n-            let mut ebml_w = ebml_w.clone();\n+            let mut ebml_w = unsafe {\n+                ebml_w.unsafe_clone()\n+            };\n             // See above\n             let ecx : &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n             encode_info_for_item(ecx, &mut ebml_w, i, index, *pt, i.vis);\n@@ -1293,8 +1351,11 @@ fn my_visit_item(i:@item, items: ast_map::map, ebml_w:&writer::Encoder,\n     }\n }\n \n-fn my_visit_foreign_item(ni:@foreign_item, items: ast_map::map, ebml_w:&writer::Encoder,\n-                         ecx_ptr:*int, index: @mut ~[entry<i64>]) {\n+fn my_visit_foreign_item(ni: @foreign_item,\n+                         items: ast_map::map,\n+                         ebml_w: &mut writer::Encoder,\n+                         ecx_ptr:*int,\n+                         index: @RefCell<~[entry<i64>]>) {\n     match items.get_copy(&ni.id) {\n         ast_map::node_foreign_item(_, abi, _, pt) => {\n             debug!(\"writing foreign item {}::{}\",\n@@ -1303,9 +1364,11 @@ fn my_visit_foreign_item(ni:@foreign_item, items: ast_map::map, ebml_w:&writer::\n                        token::get_ident_interner()),\n                    token::ident_to_str(&ni.ident));\n \n-            let mut ebml_w = ebml_w.clone();\n+            let mut ebml_w = unsafe {\n+                ebml_w.unsafe_clone()\n+            };\n             // See above\n-            let ecx : &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n+            let ecx: &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n             encode_info_for_foreign_item(ecx,\n                                          &mut ebml_w,\n                                          ni,\n@@ -1318,15 +1381,14 @@ fn my_visit_foreign_item(ni:@foreign_item, items: ast_map::map, ebml_w:&writer::\n     }\n }\n \n-struct EncodeVisitor {\n-    ebml_w_for_visit_item: writer::Encoder,\n-    ebml_w_for_visit_foreign_item: writer::Encoder,\n+struct EncodeVisitor<'a,'b> {\n+    ebml_w_for_visit_item: &'a mut writer::Encoder<'b>,\n     ecx_ptr:*int,\n     items: ast_map::map,\n-    index: @mut ~[entry<i64>],\n+    index: @RefCell<~[entry<i64>]>,\n }\n \n-impl visit::Visitor<()> for EncodeVisitor {\n+impl<'a,'b> visit::Visitor<()> for EncodeVisitor<'a,'b> {\n     fn visit_expr(&mut self, ex:@Expr, _:()) {\n         visit::walk_expr(self, ex, ());\n         my_visit_expr(ex);\n@@ -1335,15 +1397,15 @@ impl visit::Visitor<()> for EncodeVisitor {\n         visit::walk_item(self, i, ());\n         my_visit_item(i,\n                       self.items,\n-                      &self.ebml_w_for_visit_item,\n+                      self.ebml_w_for_visit_item,\n                       self.ecx_ptr,\n                       self.index);\n     }\n     fn visit_foreign_item(&mut self, ni:@foreign_item, _:()) {\n         visit::walk_foreign_item(self, ni, ());\n         my_visit_foreign_item(ni,\n                               self.items,\n-                              &self.ebml_w_for_visit_foreign_item,\n+                              self.ebml_w_for_visit_item,\n                               self.ecx_ptr,\n                               self.index);\n     }\n@@ -1353,9 +1415,15 @@ fn encode_info_for_items(ecx: &EncodeContext,\n                          ebml_w: &mut writer::Encoder,\n                          crate: &Crate)\n                          -> ~[entry<i64>] {\n-    let index = @mut ~[];\n+    let index = @RefCell::new(~[]);\n     ebml_w.start_tag(tag_items_data);\n-    index.push(entry { val: CRATE_NODE_ID as i64, pos: ebml_w.writer.tell() });\n+    {\n+        let mut index = index.borrow_mut();\n+        index.get().push(entry {\n+            val: CRATE_NODE_ID as i64,\n+            pos: ebml_w.writer.tell(),\n+        });\n+    }\n     encode_info_for_mod(ecx,\n                         ebml_w,\n                         &crate.module,\n@@ -1367,18 +1435,19 @@ fn encode_info_for_items(ecx: &EncodeContext,\n \n     // See comment in `encode_side_tables_for_ii` in astencode\n     let ecx_ptr : *int = unsafe { cast::transmute(ecx) };\n-    let mut visitor = EncodeVisitor {\n-        index: index,\n-        items: items,\n-        ecx_ptr: ecx_ptr,\n-        ebml_w_for_visit_item: (*ebml_w).clone(),\n-        ebml_w_for_visit_foreign_item: (*ebml_w).clone(),\n-    };\n+    {\n+        let mut visitor = EncodeVisitor {\n+            index: index,\n+            items: items,\n+            ecx_ptr: ecx_ptr,\n+            ebml_w_for_visit_item: &mut *ebml_w,\n+        };\n \n-    visit::walk_crate(&mut visitor, crate, ());\n+        visit::walk_crate(&mut visitor, crate, ());\n+    }\n \n     ebml_w.end_tag();\n-    return /*bad*/(*index).clone();\n+    return /*bad*/(*index).get();\n }\n \n \n@@ -1387,24 +1456,27 @@ fn encode_info_for_items(ecx: &EncodeContext,\n fn create_index<T:Clone + Hash + IterBytes + 'static>(\n                 index: ~[entry<T>])\n                 -> ~[@~[entry<T>]] {\n-    let mut buckets: ~[@mut ~[entry<T>]] = ~[];\n-    for _ in range(0u, 256u) { buckets.push(@mut ~[]); };\n+    let mut buckets: ~[@RefCell<~[entry<T>]>] = ~[];\n+    for _ in range(0u, 256u) {\n+        buckets.push(@RefCell::new(~[]));\n+    }\n     for elt in index.iter() {\n         let h = elt.val.hash() as uint;\n-        buckets[h % 256].push((*elt).clone());\n+        let mut bucket = buckets[h % 256].borrow_mut();\n+        bucket.get().push((*elt).clone());\n     }\n \n     let mut buckets_frozen = ~[];\n     for bucket in buckets.iter() {\n-        buckets_frozen.push(@/*bad*/(**bucket).clone());\n+        buckets_frozen.push(@/*bad*/(**bucket).get());\n     }\n     return buckets_frozen;\n }\n \n fn encode_index<T:'static>(\n                 ebml_w: &mut writer::Encoder,\n                 buckets: ~[@~[entry<T>]],\n-                write_fn: |@mut MemWriter, &T|) {\n+                write_fn: |&mut MemWriter, &T|) {\n     ebml_w.start_tag(tag_index);\n     let mut bucket_locs = ~[];\n     ebml_w.start_tag(tag_index_buckets);\n@@ -1434,7 +1506,7 @@ fn encode_index<T:'static>(\n     ebml_w.end_tag();\n }\n \n-fn write_i64(writer: @mut MemWriter, &n: &i64) {\n+fn write_i64(writer: &mut MemWriter, &n: &i64) {\n     let wr: &mut MemWriter = writer;\n     assert!(n < 0x7fff_ffff);\n     wr.write_be_u32(n as u32);\n@@ -1588,7 +1660,9 @@ fn encode_lang_items(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n fn encode_native_libraries(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_native_libraries);\n \n-    for &(ref lib, kind) in ecx.cstore.get_used_libraries().iter() {\n+    let used_libraries = ecx.tcx.sess.cstore.get_used_libraries();\n+    let used_libraries = used_libraries.borrow();\n+    for &(ref lib, kind) in used_libraries.get().iter() {\n         match kind {\n             cstore::NativeStatic => {} // these libraries are not propagated\n             cstore::NativeFramework | cstore::NativeUnknown => {\n@@ -1610,17 +1684,18 @@ fn encode_native_libraries(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.end_tag();\n }\n \n-struct ImplVisitor<'a> {\n+struct ImplVisitor<'a,'b> {\n     ecx: &'a EncodeContext<'a>,\n-    ebml_w: &'a mut writer::Encoder,\n+    ebml_w: &'a mut writer::Encoder<'b>,\n }\n \n-impl<'a> Visitor<()> for ImplVisitor<'a> {\n+impl<'a,'b> Visitor<()> for ImplVisitor<'a,'b> {\n     fn visit_item(&mut self, item: @item, _: ()) {\n         match item.node {\n             item_impl(_, Some(ref trait_ref), _, _) => {\n                 let def_map = self.ecx.tcx.def_map;\n-                let trait_def = def_map.get_copy(&trait_ref.ref_id);\n+                let def_map = def_map.borrow();\n+                let trait_def = def_map.get().get_copy(&trait_ref.ref_id);\n                 let def_id = ast_util::def_id_of_def(trait_def);\n \n                 // Load eagerly if this is an implementation of the Drop trait\n@@ -1721,43 +1796,40 @@ pub static metadata_encoding_version : &'static [u8] =\n       0, 0, 0, 1 ];\n \n pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n-    let wr = @mut MemWriter::new();\n+    let mut wr = MemWriter::new();\n     let stats = Stats {\n-        inline_bytes: 0,\n-        attr_bytes: 0,\n-        dep_bytes: 0,\n-        lang_item_bytes: 0,\n-        native_lib_bytes: 0,\n-        impl_bytes: 0,\n-        misc_bytes: 0,\n-        item_bytes: 0,\n-        index_bytes: 0,\n-        zero_bytes: 0,\n-        total_bytes: 0,\n-        n_inlines: 0\n+        inline_bytes: Cell::new(0),\n+        attr_bytes: Cell::new(0),\n+        dep_bytes: Cell::new(0),\n+        lang_item_bytes: Cell::new(0),\n+        native_lib_bytes: Cell::new(0),\n+        impl_bytes: Cell::new(0),\n+        misc_bytes: Cell::new(0),\n+        item_bytes: Cell::new(0),\n+        index_bytes: Cell::new(0),\n+        zero_bytes: Cell::new(0),\n+        total_bytes: Cell::new(0),\n     };\n     let EncodeParams {\n         item_symbols,\n         diag,\n         tcx,\n         reexports2,\n-        discrim_symbols,\n         cstore,\n         encode_inlined_item,\n         link_meta,\n         reachable,\n         non_inlineable_statics,\n         ..\n     } = parms;\n-    let type_abbrevs = @mut HashMap::new();\n-    let stats = @mut stats;\n+    let type_abbrevs = @RefCell::new(HashMap::new());\n+    let stats = @stats;\n     let ecx = EncodeContext {\n         diag: diag,\n         tcx: tcx,\n         stats: stats,\n         reexports2: reexports2,\n         item_symbols: item_symbols,\n-        discrim_symbols: discrim_symbols,\n         non_inlineable_statics: non_inlineable_statics,\n         link_meta: link_meta,\n         cstore: cstore,\n@@ -1766,81 +1838,81 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n         reachable: reachable,\n      };\n \n-    let mut ebml_w = writer::Encoder(wr);\n+    let mut ebml_w = writer::Encoder(&mut wr);\n \n     encode_hash(&mut ebml_w, ecx.link_meta.crate_hash);\n \n-    let mut i = wr.tell();\n+    let mut i = ebml_w.writer.tell();\n     let crate_attrs = synthesize_crate_attrs(&ecx, crate);\n     encode_attributes(&mut ebml_w, crate_attrs);\n-    ecx.stats.attr_bytes = wr.tell() - i;\n+    ecx.stats.attr_bytes.set(ebml_w.writer.tell() - i);\n \n-    i = wr.tell();\n+    i = ebml_w.writer.tell();\n     encode_crate_deps(&ecx, &mut ebml_w, ecx.cstore);\n-    ecx.stats.dep_bytes = wr.tell() - i;\n+    ecx.stats.dep_bytes.set(ebml_w.writer.tell() - i);\n \n     // Encode the language items.\n-    i = wr.tell();\n+    i = ebml_w.writer.tell();\n     encode_lang_items(&ecx, &mut ebml_w);\n-    ecx.stats.lang_item_bytes = wr.tell() - i;\n+    ecx.stats.lang_item_bytes.set(ebml_w.writer.tell() - i);\n \n     // Encode the native libraries used\n-    i = wr.tell();\n+    i = ebml_w.writer.tell();\n     encode_native_libraries(&ecx, &mut ebml_w);\n-    ecx.stats.native_lib_bytes = wr.tell() - i;\n+    ecx.stats.native_lib_bytes.set(ebml_w.writer.tell() - i);\n \n     // Encode the def IDs of impls, for coherence checking.\n-    i = wr.tell();\n+    i = ebml_w.writer.tell();\n     encode_impls(&ecx, crate, &mut ebml_w);\n-    ecx.stats.impl_bytes = wr.tell() - i;\n+    ecx.stats.impl_bytes.set(ebml_w.writer.tell() - i);\n \n     // Encode miscellaneous info.\n-    i = wr.tell();\n+    i = ebml_w.writer.tell();\n     encode_misc_info(&ecx, crate, &mut ebml_w);\n-    ecx.stats.misc_bytes = wr.tell() - i;\n+    ecx.stats.misc_bytes.set(ebml_w.writer.tell() - i);\n \n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);\n-    i = wr.tell();\n+    i = ebml_w.writer.tell();\n     let items_index = encode_info_for_items(&ecx, &mut ebml_w, crate);\n-    ecx.stats.item_bytes = wr.tell() - i;\n+    ecx.stats.item_bytes.set(ebml_w.writer.tell() - i);\n \n-    i = wr.tell();\n+    i = ebml_w.writer.tell();\n     let items_buckets = create_index(items_index);\n     encode_index(&mut ebml_w, items_buckets, write_i64);\n-    ecx.stats.index_bytes = wr.tell() - i;\n+    ecx.stats.index_bytes.set(ebml_w.writer.tell() - i);\n     ebml_w.end_tag();\n \n-    ecx.stats.total_bytes = wr.tell();\n+    ecx.stats.total_bytes.set(ebml_w.writer.tell());\n \n     if (tcx.sess.meta_stats()) {\n-        for e in wr.inner_ref().iter() {\n+        for e in ebml_w.writer.inner_ref().iter() {\n             if *e == 0 {\n-                ecx.stats.zero_bytes += 1;\n+                ecx.stats.zero_bytes.set(ecx.stats.zero_bytes.get() + 1);\n             }\n         }\n \n         println(\"metadata stats:\");\n-        println!(\"    inline bytes: {}\", ecx.stats.inline_bytes);\n-        println!(\" attribute bytes: {}\", ecx.stats.attr_bytes);\n-        println!(\"       dep bytes: {}\", ecx.stats.dep_bytes);\n-        println!(\" lang item bytes: {}\", ecx.stats.lang_item_bytes);\n-        println!(\"    native bytes: {}\", ecx.stats.native_lib_bytes);\n-        println!(\"      impl bytes: {}\", ecx.stats.impl_bytes);\n-        println!(\"      misc bytes: {}\", ecx.stats.misc_bytes);\n-        println!(\"      item bytes: {}\", ecx.stats.item_bytes);\n-        println!(\"     index bytes: {}\", ecx.stats.index_bytes);\n-        println!(\"      zero bytes: {}\", ecx.stats.zero_bytes);\n-        println!(\"     total bytes: {}\", ecx.stats.total_bytes);\n+        println!(\"    inline bytes: {}\", ecx.stats.inline_bytes.get());\n+        println!(\" attribute bytes: {}\", ecx.stats.attr_bytes.get());\n+        println!(\"       dep bytes: {}\", ecx.stats.dep_bytes.get());\n+        println!(\" lang item bytes: {}\", ecx.stats.lang_item_bytes.get());\n+        println!(\"    native bytes: {}\", ecx.stats.native_lib_bytes.get());\n+        println!(\"      impl bytes: {}\", ecx.stats.impl_bytes.get());\n+        println!(\"      misc bytes: {}\", ecx.stats.misc_bytes.get());\n+        println!(\"      item bytes: {}\", ecx.stats.item_bytes.get());\n+        println!(\"     index bytes: {}\", ecx.stats.index_bytes.get());\n+        println!(\"      zero bytes: {}\", ecx.stats.zero_bytes.get());\n+        println!(\"     total bytes: {}\", ecx.stats.total_bytes.get());\n     }\n \n     // Pad this, since something (LLVM, presumably) is cutting off the\n     // remaining % 4 bytes.\n-    wr.write(&[0u8, 0u8, 0u8, 0u8]);\n+    ebml_w.writer.write(&[0u8, 0u8, 0u8, 0u8]);\n \n     // This is a horrible thing to do to the outer MemWriter, but thankfully we\n     // don't use it again so... it's ok right?\n-    return util::replace(wr.inner_mut_ref(), ~[]);\n+    return util::replace(ebml_w.writer.inner_mut_ref(), ~[]);\n }\n \n // Get the encoded string for a type\n@@ -1850,7 +1922,7 @@ pub fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> ~str {\n         ds: def_to_str,\n         tcx: tcx,\n         abbrevs: tyencode::ac_no_abbrevs};\n-    let wr = @mut MemWriter::new();\n-    tyencode::enc_ty(wr, cx, t);\n+    let mut wr = MemWriter::new();\n+    tyencode::enc_ty(&mut wr, cx, t);\n     str::from_utf8_owned(wr.inner_ref().to_owned())\n }"}, {"sha": "692cc12ec6f5df13627eec46d28cd69ca1b4a9ca", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use std::cell::RefCell;\n use std::option;\n use std::os;\n use std::io;\n@@ -42,11 +42,11 @@ pub trait FileSearch {\n \n pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n                      target_triple: &str,\n-                     addl_lib_search_paths: @mut HashSet<Path>)\n+                     addl_lib_search_paths: @RefCell<HashSet<Path>>)\n                   -> @FileSearch {\n     struct FileSearchImpl {\n         sysroot: @Path,\n-        addl_lib_search_paths: @mut HashSet<Path>,\n+        addl_lib_search_paths: @RefCell<HashSet<Path>>,\n         target_triple: ~str\n     }\n     impl FileSearch for FileSearchImpl {\n@@ -56,9 +56,10 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n             let mut visited_dirs = HashSet::new();\n             let mut found = false;\n \n+            let addl_lib_search_paths = self.addl_lib_search_paths.borrow();\n             debug!(\"filesearch: searching additional lib search paths [{:?}]\",\n-                   self.addl_lib_search_paths.len());\n-            for path in self.addl_lib_search_paths.iter() {\n+                   addl_lib_search_paths.get().len());\n+            for path in addl_lib_search_paths.get().iter() {\n                 match f(path) {\n                     FileMatches => found = true,\n                     FileDoesntMatch => ()"}, {"sha": "e954fc06c9435f9bc9c1759f65ca4859283172e3", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -380,7 +380,7 @@ pub fn read_meta_section_name(os: Os) -> &'static str {\n pub fn list_file_metadata(intr: @ident_interner,\n                           os: Os,\n                           path: &Path,\n-                          out: @mut io::Writer) {\n+                          out: &mut io::Writer) {\n     match get_metadata_section(os, path) {\n       option::Some(bytes) => decoder::list_crate_metadata(intr,\n                                                           bytes.as_slice(),"}, {"sha": "2e989f48b8002c4a5c5cf78e71da230434e8a8c7", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -380,15 +380,21 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         let key = ty::creader_cache_key {cnum: st.crate,\n                                          pos: pos,\n                                          len: len };\n-        match st.tcx.rcache.find(&key) {\n-          Some(&tt) => return tt,\n+\n+        let tt_opt = {\n+            let rcache = st.tcx.rcache.borrow();\n+            rcache.get().find_copy(&key)\n+        };\n+        match tt_opt {\n+          Some(tt) => return tt,\n           None => {\n             let mut ps = PState {\n                 pos: pos,\n                 .. *st\n             };\n             let tt = parse_ty(&mut ps, |x,y| conv(x,y));\n-            st.tcx.rcache.insert(key, tt);\n+            let mut rcache = st.tcx.rcache.borrow_mut();\n+            rcache.get().insert(key, tt);\n             return tt;\n           }\n         }"}, {"sha": "06d74055af40cdc150c921de0ece3eca37a7073a", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 53, "deletions": 36, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -10,6 +10,7 @@\n \n // Type encoding\n \n+use std::cell::RefCell;\n use std::hashmap::HashMap;\n use std::io;\n use std::io::{Decorator, Writer, Seek};\n@@ -50,32 +51,45 @@ pub struct ty_abbrev {\n \n pub enum abbrev_ctxt {\n     ac_no_abbrevs,\n-    ac_use_abbrevs(@mut HashMap<ty::t, ty_abbrev>),\n+    ac_use_abbrevs(@RefCell<HashMap<ty::t, ty_abbrev>>),\n }\n \n-fn mywrite(w: @mut MemWriter, fmt: &fmt::Arguments) {\n+fn mywrite(w: &mut MemWriter, fmt: &fmt::Arguments) {\n     fmt::write(&mut *w as &mut io::Writer, fmt);\n }\n \n-pub fn enc_ty(w: @mut MemWriter, cx: @ctxt, t: ty::t) {\n+pub fn enc_ty(w: &mut MemWriter, cx: @ctxt, t: ty::t) {\n     match cx.abbrevs {\n       ac_no_abbrevs => {\n-        let result_str = match cx.tcx.short_names_cache.find(&t) {\n-            Some(&s) => s,\n+          let result_str_opt;\n+          {\n+              let short_names_cache = cx.tcx.short_names_cache.borrow();\n+              result_str_opt = short_names_cache.get()\n+                                                .find(&t)\n+                                                .map(|result| *result);\n+          }\n+          let result_str = match result_str_opt {\n+            Some(s) => s,\n             None => {\n-                let wr = @mut MemWriter::new();\n+                let wr = &mut MemWriter::new();\n                 enc_sty(wr, cx, &ty::get(t).sty);\n                 let s = str::from_utf8(*wr.inner_ref()).to_managed();\n-                cx.tcx.short_names_cache.insert(t, s);\n+                let mut short_names_cache = cx.tcx\n+                                              .short_names_cache\n+                                              .borrow_mut();\n+                short_names_cache.get().insert(t, s);\n                 s\n-          }\n-        };\n-        w.write(result_str.as_bytes());\n+            }\n+          };\n+          w.write(result_str.as_bytes());\n       }\n       ac_use_abbrevs(abbrevs) => {\n-          match abbrevs.find(&t) {\n-              Some(a) => { w.write(a.s.as_bytes()); return; }\n-              None => {}\n+          {\n+              let mut abbrevs = abbrevs.borrow_mut();\n+              match abbrevs.get().find(&t) {\n+                  Some(a) => { w.write(a.s.as_bytes()); return; }\n+                  None => {}\n+              }\n           }\n           let pos = w.tell();\n           enc_sty(w, cx, &ty::get(t).sty);\n@@ -94,44 +108,47 @@ pub fn enc_ty(w: @mut MemWriter, cx: @ctxt, t: ty::t) {\n               let a = ty_abbrev { pos: pos as uint,\n                                   len: len as uint,\n                                   s: s };\n-              abbrevs.insert(t, a);\n+              {\n+                  let mut abbrevs = abbrevs.borrow_mut();\n+                  abbrevs.get().insert(t, a);\n+              }\n           }\n           return;\n       }\n     }\n }\n \n-fn enc_mutability(w: @mut MemWriter, mt: ast::Mutability) {\n+fn enc_mutability(w: &mut MemWriter, mt: ast::Mutability) {\n     match mt {\n         MutImmutable => (),\n         MutMutable => mywrite!(w, \"m\"),\n     }\n }\n \n-fn enc_mt(w: @mut MemWriter, cx: @ctxt, mt: ty::mt) {\n+fn enc_mt(w: &mut MemWriter, cx: @ctxt, mt: ty::mt) {\n     enc_mutability(w, mt.mutbl);\n     enc_ty(w, cx, mt.ty);\n }\n \n-fn enc_opt<T>(w: @mut MemWriter, t: Option<T>, enc_f: |T|) {\n+fn enc_opt<T>(w: &mut MemWriter, t: Option<T>, enc_f: |&mut MemWriter, T|) {\n     match t {\n         None => mywrite!(w, \"n\"),\n         Some(v) => {\n             mywrite!(w, \"s\");\n-            enc_f(v);\n+            enc_f(w, v);\n         }\n     }\n }\n \n-fn enc_substs(w: @mut MemWriter, cx: @ctxt, substs: &ty::substs) {\n+fn enc_substs(w: &mut MemWriter, cx: @ctxt, substs: &ty::substs) {\n     enc_region_substs(w, cx, &substs.regions);\n-    enc_opt(w, substs.self_ty, |t| enc_ty(w, cx, t));\n+    enc_opt(w, substs.self_ty, |w, t| enc_ty(w, cx, t));\n     mywrite!(w, \"[\");\n     for t in substs.tps.iter() { enc_ty(w, cx, *t); }\n     mywrite!(w, \"]\");\n }\n \n-fn enc_region_substs(w: @mut MemWriter, cx: @ctxt, substs: &ty::RegionSubsts) {\n+fn enc_region_substs(w: &mut MemWriter, cx: @ctxt, substs: &ty::RegionSubsts) {\n     match *substs {\n         ty::ErasedRegions => {\n             mywrite!(w, \"e\");\n@@ -146,7 +163,7 @@ fn enc_region_substs(w: @mut MemWriter, cx: @ctxt, substs: &ty::RegionSubsts) {\n     }\n }\n \n-fn enc_region(w: @mut MemWriter, cx: @ctxt, r: ty::Region) {\n+fn enc_region(w: &mut MemWriter, cx: @ctxt, r: ty::Region) {\n     match r {\n         ty::ReLateBound(id, br) => {\n             mywrite!(w, \"b[{}|\", id);\n@@ -180,7 +197,7 @@ fn enc_region(w: @mut MemWriter, cx: @ctxt, r: ty::Region) {\n     }\n }\n \n-fn enc_bound_region(w: @mut MemWriter, cx: @ctxt, br: ty::BoundRegion) {\n+fn enc_bound_region(w: &mut MemWriter, cx: @ctxt, br: ty::BoundRegion) {\n     match br {\n         ty::BrAnon(idx) => {\n             mywrite!(w, \"a{}|\", idx);\n@@ -196,7 +213,7 @@ fn enc_bound_region(w: @mut MemWriter, cx: @ctxt, br: ty::BoundRegion) {\n     }\n }\n \n-pub fn enc_vstore(w: @mut MemWriter, cx: @ctxt, v: ty::vstore) {\n+pub fn enc_vstore(w: &mut MemWriter, cx: @ctxt, v: ty::vstore) {\n     mywrite!(w, \"/\");\n     match v {\n         ty::vstore_fixed(u) => mywrite!(w, \"{}|\", u),\n@@ -209,12 +226,12 @@ pub fn enc_vstore(w: @mut MemWriter, cx: @ctxt, v: ty::vstore) {\n     }\n }\n \n-pub fn enc_trait_ref(w: @mut MemWriter, cx: @ctxt, s: &ty::TraitRef) {\n+pub fn enc_trait_ref(w: &mut MemWriter, cx: @ctxt, s: &ty::TraitRef) {\n     mywrite!(w, \"{}|\", (cx.ds)(s.def_id));\n     enc_substs(w, cx, &s.substs);\n }\n \n-pub fn enc_trait_store(w: @mut MemWriter, cx: @ctxt, s: ty::TraitStore) {\n+pub fn enc_trait_store(w: &mut MemWriter, cx: @ctxt, s: ty::TraitStore) {\n     match s {\n         ty::UniqTraitStore => mywrite!(w, \"~\"),\n         ty::BoxTraitStore => mywrite!(w, \"@\"),\n@@ -225,7 +242,7 @@ pub fn enc_trait_store(w: @mut MemWriter, cx: @ctxt, s: ty::TraitStore) {\n     }\n }\n \n-fn enc_sty(w: @mut MemWriter, cx: @ctxt, st: &ty::sty) {\n+fn enc_sty(w: &mut MemWriter, cx: @ctxt, st: &ty::sty) {\n     match *st {\n         ty::ty_nil => mywrite!(w, \"n\"),\n         ty::ty_bot => mywrite!(w, \"z\"),\n@@ -325,23 +342,23 @@ fn enc_sty(w: @mut MemWriter, cx: @ctxt, st: &ty::sty) {\n     }\n }\n \n-fn enc_sigil(w: @mut MemWriter, sigil: Sigil) {\n+fn enc_sigil(w: &mut MemWriter, sigil: Sigil) {\n     match sigil {\n         ManagedSigil => mywrite!(w, \"@\"),\n         OwnedSigil => mywrite!(w, \"~\"),\n         BorrowedSigil => mywrite!(w, \"&\"),\n     }\n }\n \n-fn enc_purity(w: @mut MemWriter, p: purity) {\n+fn enc_purity(w: &mut MemWriter, p: purity) {\n     match p {\n         impure_fn => mywrite!(w, \"i\"),\n         unsafe_fn => mywrite!(w, \"u\"),\n         extern_fn => mywrite!(w, \"c\")\n     }\n }\n \n-fn enc_abi_set(w: @mut MemWriter, abis: AbiSet) {\n+fn enc_abi_set(w: &mut MemWriter, abis: AbiSet) {\n     mywrite!(w, \"[\");\n     abis.each(|abi| {\n         mywrite!(w, \"{},\", abi.name());\n@@ -350,20 +367,20 @@ fn enc_abi_set(w: @mut MemWriter, abis: AbiSet) {\n     mywrite!(w, \"]\")\n }\n \n-fn enc_onceness(w: @mut MemWriter, o: Onceness) {\n+fn enc_onceness(w: &mut MemWriter, o: Onceness) {\n     match o {\n         Once => mywrite!(w, \"o\"),\n         Many => mywrite!(w, \"m\")\n     }\n }\n \n-pub fn enc_bare_fn_ty(w: @mut MemWriter, cx: @ctxt, ft: &ty::BareFnTy) {\n+pub fn enc_bare_fn_ty(w: &mut MemWriter, cx: @ctxt, ft: &ty::BareFnTy) {\n     enc_purity(w, ft.purity);\n     enc_abi_set(w, ft.abis);\n     enc_fn_sig(w, cx, &ft.sig);\n }\n \n-fn enc_closure_ty(w: @mut MemWriter, cx: @ctxt, ft: &ty::ClosureTy) {\n+fn enc_closure_ty(w: &mut MemWriter, cx: @ctxt, ft: &ty::ClosureTy) {\n     enc_sigil(w, ft.sigil);\n     enc_purity(w, ft.purity);\n     enc_onceness(w, ft.onceness);\n@@ -374,7 +391,7 @@ fn enc_closure_ty(w: @mut MemWriter, cx: @ctxt, ft: &ty::ClosureTy) {\n     enc_fn_sig(w, cx, &ft.sig);\n }\n \n-fn enc_fn_sig(w: @mut MemWriter, cx: @ctxt, fsig: &ty::FnSig) {\n+fn enc_fn_sig(w: &mut MemWriter, cx: @ctxt, fsig: &ty::FnSig) {\n     mywrite!(w, \"[{}|\", fsig.binder_id);\n     for ty in fsig.inputs.iter() {\n         enc_ty(w, cx, *ty);\n@@ -388,7 +405,7 @@ fn enc_fn_sig(w: @mut MemWriter, cx: @ctxt, fsig: &ty::FnSig) {\n     enc_ty(w, cx, fsig.output);\n }\n \n-fn enc_bounds(w: @mut MemWriter, cx: @ctxt, bs: &ty::ParamBounds) {\n+fn enc_bounds(w: &mut MemWriter, cx: @ctxt, bs: &ty::ParamBounds) {\n     for bound in bs.builtin_bounds.iter() {\n         match bound {\n             ty::BoundSend => mywrite!(w, \"S\"),\n@@ -407,7 +424,7 @@ fn enc_bounds(w: @mut MemWriter, cx: @ctxt, bs: &ty::ParamBounds) {\n     mywrite!(w, \".\");\n }\n \n-pub fn enc_type_param_def(w: @mut MemWriter, cx: @ctxt, v: &ty::TypeParameterDef) {\n+pub fn enc_type_param_def(w: &mut MemWriter, cx: @ctxt, v: &ty::TypeParameterDef) {\n     mywrite!(w, \"{}:{}|\", cx.tcx.sess.str_of(v.ident), (cx.ds)(v.def_id));\n     enc_bounds(w, cx, v.bounds);\n }"}, {"sha": "38f23a900d8902672924395346854347774b4a6c", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 78, "deletions": 37, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -788,7 +788,7 @@ trait ebml_writer_helpers {\n                  tpbt: ty::ty_param_bounds_and_ty);\n }\n \n-impl ebml_writer_helpers for writer::Encoder {\n+impl<'a> ebml_writer_helpers for writer::Encoder<'a> {\n     fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: ty::t) {\n         self.emit_opaque(|this| e::write_type(ecx, this, ty))\n     }\n@@ -840,8 +840,10 @@ trait write_tag_and_id {\n     fn id(&mut self, id: ast::NodeId);\n }\n \n-impl write_tag_and_id for writer::Encoder {\n-    fn tag(&mut self, tag_id: c::astencode_tag, f: |&mut writer::Encoder|) {\n+impl<'a> write_tag_and_id for writer::Encoder<'a> {\n+    fn tag(&mut self,\n+           tag_id: c::astencode_tag,\n+           f: |&mut writer::Encoder<'a>|) {\n         self.start_tag(tag_id as uint);\n         f(self);\n         self.end_tag();\n@@ -852,18 +854,23 @@ impl write_tag_and_id for writer::Encoder {\n     }\n }\n \n-struct SideTableEncodingIdVisitor {\n+struct SideTableEncodingIdVisitor<'a,'b> {\n     ecx_ptr: *libc::c_void,\n-    new_ebml_w: writer::Encoder,\n+    new_ebml_w: &'a mut writer::Encoder<'b>,\n     maps: Maps,\n }\n \n-impl ast_util::IdVisitingOperation for SideTableEncodingIdVisitor {\n+impl<'a,'b> ast_util::IdVisitingOperation for\n+        SideTableEncodingIdVisitor<'a,'b> {\n     fn visit_id(&self, id: ast::NodeId) {\n         // Note: this will cause a copy of ebml_w, which is bad as\n         // it is mutable. But I believe it's harmless since we generate\n         // balanced EBML.\n-        let mut new_ebml_w = self.new_ebml_w.clone();\n+        //\n+        // XXX(pcwalton): Don't copy this way.\n+        let mut new_ebml_w = unsafe {\n+            self.new_ebml_w.unsafe_clone()\n+        };\n         // See above\n         let ecx: &e::EncodeContext = unsafe {\n             cast::transmute(self.ecx_ptr)\n@@ -877,7 +884,9 @@ fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n                              ebml_w: &mut writer::Encoder,\n                              ii: &ast::inlined_item) {\n     ebml_w.start_tag(c::tag_table as uint);\n-    let new_ebml_w = (*ebml_w).clone();\n+    let mut new_ebml_w = unsafe {\n+        ebml_w.unsafe_clone()\n+    };\n \n     // Because the ast visitor uses @IdVisitingOperation, I can't pass in\n     // ecx directly, but /I/ know that it'll be fine since the lifetime is\n@@ -886,7 +895,7 @@ fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n         ecx_ptr: unsafe {\n             cast::transmute(ecx)\n         },\n-        new_ebml_w: new_ebml_w,\n+        new_ebml_w: &mut new_ebml_w,\n         maps: maps,\n     });\n     ebml_w.end_tag();\n@@ -901,7 +910,8 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     debug!(\"Encoding side tables for id {}\", id);\n \n     {\n-        let r = tcx.def_map.find(&id);\n+        let def_map = tcx.def_map.borrow();\n+        let r = def_map.get().find(&id);\n         for def in r.iter() {\n             ebml_w.tag(c::tag_table_def, |ebml_w| {\n                 ebml_w.id(id);\n@@ -911,7 +921,8 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     {\n-        let r = tcx.node_types.find(&(id as uint));\n+        let node_types = tcx.node_types.borrow();\n+        let r = node_types.get().find(&(id as uint));\n         for &ty in r.iter() {\n             ebml_w.tag(c::tag_table_node_type, |ebml_w| {\n                 ebml_w.id(id);\n@@ -923,7 +934,8 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     {\n-        let r = tcx.node_type_substs.find(&id);\n+        let node_type_substs = tcx.node_type_substs.borrow();\n+        let r = node_type_substs.get().find(&id);\n         for tys in r.iter() {\n             ebml_w.tag(c::tag_table_node_type_subst, |ebml_w| {\n                 ebml_w.id(id);\n@@ -935,7 +947,8 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     {\n-        let r = tcx.freevars.find(&id);\n+        let freevars = tcx.freevars.borrow();\n+        let r = freevars.get().find(&id);\n         for &fv in r.iter() {\n             ebml_w.tag(c::tag_table_freevars, |ebml_w| {\n                 ebml_w.id(id);\n@@ -950,7 +963,8 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     let lid = ast::DefId { crate: ast::LOCAL_CRATE, node: id };\n     {\n-        let r = tcx.tcache.find(&lid);\n+        let tcache = tcx.tcache.borrow();\n+        let r = tcache.get().find(&lid);\n         for &tpbt in r.iter() {\n             ebml_w.tag(c::tag_table_tcache, |ebml_w| {\n                 ebml_w.id(id);\n@@ -962,8 +976,11 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     {\n-        let r = tcx.ty_param_defs.find(&id);\n-        for &type_param_def in r.iter() {\n+        let r = {\n+            let ty_param_defs = tcx.ty_param_defs.borrow();\n+            ty_param_defs.get().find(&id).map(|def| *def)\n+        };\n+        for type_param_def in r.iter() {\n             ebml_w.tag(c::tag_table_param_defs, |ebml_w| {\n                 ebml_w.id(id);\n                 ebml_w.tag(c::tag_table_val, |ebml_w| {\n@@ -974,7 +991,8 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     {\n-        let r = maps.method_map.find(&id);\n+        let method_map = maps.method_map.borrow();\n+        let r = method_map.get().find(&id);\n         for &mme in r.iter() {\n             ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n                 ebml_w.id(id);\n@@ -986,7 +1004,8 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     {\n-        let r = maps.vtable_map.find(&id);\n+        let vtable_map = maps.vtable_map.borrow();\n+        let r = vtable_map.get().find(&id);\n         for &dr in r.iter() {\n             ebml_w.tag(c::tag_table_vtable_map, |ebml_w| {\n                 ebml_w.id(id);\n@@ -998,7 +1017,8 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     {\n-        let r = tcx.adjustments.find(&id);\n+        let adjustments = tcx.adjustments.borrow();\n+        let r = adjustments.get().find(&id);\n         for adj in r.iter() {\n             ebml_w.tag(c::tag_table_adjustments, |ebml_w| {\n                 ebml_w.id(id);\n@@ -1010,7 +1030,8 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     {\n-        let r = maps.capture_map.find(&id);\n+        let capture_map = maps.capture_map.borrow();\n+        let r = capture_map.get().find(&id);\n         for &cap_vars in r.iter() {\n             ebml_w.tag(c::tag_table_capture_map, |ebml_w| {\n                 ebml_w.id(id);\n@@ -1218,54 +1239,72 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                 match value {\n                     c::tag_table_def => {\n                         let def = decode_def(xcx, val_doc);\n-                        dcx.tcx.def_map.insert(id, def);\n+                        let mut def_map = dcx.tcx.def_map.borrow_mut();\n+                        def_map.get().insert(id, def);\n                     }\n                     c::tag_table_node_type => {\n                         let ty = val_dsr.read_ty(xcx);\n                         debug!(\"inserting ty for node {:?}: {}\",\n                                id, ty_to_str(dcx.tcx, ty));\n-                        dcx.tcx.node_types.insert(id as uint, ty);\n+                        let mut node_types = dcx.tcx.node_types.borrow_mut();\n+                        node_types.get().insert(id as uint, ty);\n                     }\n                     c::tag_table_node_type_subst => {\n                         let tys = val_dsr.read_tys(xcx);\n-                        dcx.tcx.node_type_substs.insert(id, tys);\n+                        let mut node_type_substs = dcx.tcx\n+                                                      .node_type_substs\n+                                                      .borrow_mut();\n+                        node_type_substs.get().insert(id, tys);\n                     }\n                     c::tag_table_freevars => {\n                         let fv_info = @val_dsr.read_to_vec(|val_dsr| {\n                             @val_dsr.read_freevar_entry(xcx)\n                         });\n-                        dcx.tcx.freevars.insert(id, fv_info);\n+                        let mut freevars = dcx.tcx.freevars.borrow_mut();\n+                        freevars.get().insert(id, fv_info);\n                     }\n                     c::tag_table_tcache => {\n                         let tpbt = val_dsr.read_ty_param_bounds_and_ty(xcx);\n                         let lid = ast::DefId { crate: ast::LOCAL_CRATE, node: id };\n-                        dcx.tcx.tcache.insert(lid, tpbt);\n+                        let mut tcache = dcx.tcx.tcache.borrow_mut();\n+                        tcache.get().insert(lid, tpbt);\n                     }\n                     c::tag_table_param_defs => {\n                         let bounds = val_dsr.read_type_param_def(xcx);\n-                        dcx.tcx.ty_param_defs.insert(id, bounds);\n+                        let mut ty_param_defs = dcx.tcx\n+                                                   .ty_param_defs\n+                                                   .borrow_mut();\n+                        ty_param_defs.get().insert(id, bounds);\n                     }\n                     c::tag_table_method_map => {\n-                        dcx.maps.method_map.insert(\n-                            id,\n-                            val_dsr.read_method_map_entry(xcx));\n+                        let entry = val_dsr.read_method_map_entry(xcx);\n+                        let mut method_map = dcx.maps.method_map.borrow_mut();\n+                        method_map.get().insert(id, entry);\n                     }\n                     c::tag_table_vtable_map => {\n-                        dcx.maps.vtable_map.insert(\n-                            id,\n-                            val_dsr.read_vtable_res(xcx.dcx.tcx, xcx.dcx.cdata));\n+                        let vtable_res =\n+                            val_dsr.read_vtable_res(xcx.dcx.tcx,\n+                                                    xcx.dcx.cdata);\n+                        let mut vtable_map = dcx.maps.vtable_map.borrow_mut();\n+                        vtable_map.get().insert(id, vtable_res);\n                     }\n                     c::tag_table_adjustments => {\n                         let adj: @ty::AutoAdjustment = @Decodable::decode(val_dsr);\n                         adj.tr(xcx);\n-                        dcx.tcx.adjustments.insert(id, adj);\n+                        let mut adjustments = dcx.tcx\n+                                                 .adjustments\n+                                                 .borrow_mut();\n+                        adjustments.get().insert(id, adj);\n                     }\n                     c::tag_table_capture_map => {\n                         let cvars =\n                             at_vec::to_managed_move(\n                                 val_dsr.read_to_vec(\n                                     |val_dsr| val_dsr.read_capture_var(xcx)));\n-                        dcx.maps.capture_map.insert(id, cvars);\n+                        let mut capture_map = dcx.maps\n+                                                 .capture_map\n+                                                 .borrow_mut();\n+                        capture_map.get().insert(id, cvars);\n                     }\n                     _ => {\n                         xcx.dcx.tcx.sess.bug(\n@@ -1335,9 +1374,11 @@ fn roundtrip(in_item: Option<@ast::item>) {\n     use std::io::mem::MemWriter;\n \n     let in_item = in_item.unwrap();\n-    let wr = @mut MemWriter::new();\n-    let mut ebml_w = writer::Encoder(wr);\n-    encode_item_ast(&mut ebml_w, in_item);\n+    let mut wr = MemWriter::new();\n+    {\n+        let mut ebml_w = writer::Encoder(&mut wr);\n+        encode_item_ast(&mut ebml_w, in_item);\n+    }\n     let ebml_doc = reader::Doc(wr.inner_ref().as_slice());\n     let out_item = decode_item_ast(ebml_doc);\n "}, {"sha": "6176f5601c14b4f3c58a5be131440cbe5f1822a4", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -18,7 +18,6 @@\n // 4. moves do not affect things loaned out in any way\n \n \n-use std::hashmap::HashSet;\n use mc = middle::mem_categorization;\n use middle::borrowck::*;\n use middle::moves;\n@@ -37,7 +36,6 @@ struct CheckLoanCtxt<'a> {\n     dfcx_loans: &'a LoanDataFlow,\n     move_data: @move_data::FlowedMoveData,\n     all_loans: &'a [Loan],\n-    reported: @mut HashSet<ast::NodeId>,\n }\n \n impl<'a> Visitor<()> for CheckLoanCtxt<'a> {\n@@ -75,7 +73,6 @@ pub fn check_loans(bccx: &BorrowckCtxt,\n         dfcx_loans: dfcx_loans,\n         move_data: @move_data,\n         all_loans: all_loans,\n-        reported: @mut HashSet::new(),\n     };\n \n     clcx.visit_block(body, ());\n@@ -296,9 +293,13 @@ impl<'a> CheckLoanCtxt<'a> {\n     pub fn check_assignment(&self, expr: @ast::Expr) {\n         // We don't use cat_expr() here because we don't want to treat\n         // auto-ref'd parameters in overloaded operators as rvalues.\n-        let cmt = match self.bccx.tcx.adjustments.find(&expr.id) {\n+        let adj = {\n+            let adjustments = self.bccx.tcx.adjustments.borrow();\n+            adjustments.get().find_copy(&expr.id)\n+        };\n+        let cmt = match adj {\n             None => self.bccx.cat_expr_unadjusted(expr),\n-            Some(&adj) => self.bccx.cat_expr_autoderefd(expr, adj)\n+            Some(adj) => self.bccx.cat_expr_autoderefd(expr, adj)\n         };\n \n         debug!(\"check_assignment(cmt={})\", cmt.repr(self.tcx()));\n@@ -356,7 +357,10 @@ impl<'a> CheckLoanCtxt<'a> {\n                     mc::cat_local(id) |\n                     mc::cat_arg(id) |\n                     mc::cat_self(id) => {\n-                        this.tcx().used_mut_nodes.insert(id);\n+                        let mut used_mut_nodes = this.tcx()\n+                                                     .used_mut_nodes\n+                                                     .borrow_mut();\n+                        used_mut_nodes.get().insert(id);\n                         return;\n                     }\n \n@@ -415,7 +419,10 @@ impl<'a> CheckLoanCtxt<'a> {\n                         derefs: deref_count\n                     };\n                     debug!(\"Inserting write guard at {:?}\", key);\n-                    this.bccx.write_guard_map.insert(key);\n+                    let mut write_guard_map = this.bccx\n+                                                  .write_guard_map\n+                                                  .borrow_mut();\n+                    write_guard_map.get().insert(key);\n                 }\n \n                 _ => {}\n@@ -709,7 +716,8 @@ fn check_loans_in_fn<'a>(this: &mut CheckLoanCtxt<'a>,\n     fn check_captured_variables(this: &CheckLoanCtxt,\n                                 closure_id: ast::NodeId,\n                                 span: Span) {\n-        let cap_vars = this.bccx.capture_map.get(&closure_id);\n+        let capture_map = this.bccx.capture_map.borrow();\n+        let cap_vars = capture_map.get().get(&closure_id);\n         for cap_var in cap_vars.iter() {\n             let var_id = ast_util::def_id_of_def(cap_var.def).node;\n             let var_path = @LpVar(var_id);\n@@ -762,6 +770,7 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n     this.check_for_conflicting_loans(expr.id);\n     this.check_move_out_from_expr(expr);\n \n+    let method_map = this.bccx.method_map.borrow();\n     match expr.node {\n       ast::ExprSelf |\n       ast::ExprPath(..) => {\n@@ -786,15 +795,15 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n       }\n       ast::ExprIndex(callee_id, _, rval) |\n       ast::ExprBinary(callee_id, _, _, rval)\n-      if this.bccx.method_map.contains_key(&expr.id) => {\n+      if method_map.get().contains_key(&expr.id) => {\n         this.check_call(expr,\n                         None,\n                         callee_id,\n                         expr.span,\n                         [rval]);\n       }\n       ast::ExprUnary(callee_id, _, _) | ast::ExprIndex(callee_id, _, _)\n-      if this.bccx.method_map.contains_key(&expr.id) => {\n+      if method_map.get().contains_key(&expr.id) => {\n         this.check_call(expr,\n                         None,\n                         callee_id,"}, {"sha": "907a8e8fdd97584c441a1011ec81ba3611d80063", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -23,7 +23,7 @@ use syntax::codemap::Span;\n use util::ppaux::{UserString};\n \n pub fn gather_decl(bccx: &BorrowckCtxt,\n-                   move_data: &mut MoveData,\n+                   move_data: &MoveData,\n                    decl_id: ast::NodeId,\n                    _decl_span: Span,\n                    var_id: ast::NodeId) {\n@@ -32,23 +32,23 @@ pub fn gather_decl(bccx: &BorrowckCtxt,\n }\n \n pub fn gather_move_from_expr(bccx: &BorrowckCtxt,\n-                             move_data: &mut MoveData,\n+                             move_data: &MoveData,\n                              move_expr: @ast::Expr,\n                              cmt: mc::cmt) {\n     gather_move_from_expr_or_pat(bccx, move_data, move_expr.id,\n                                  MoveExpr(move_expr), cmt);\n }\n \n pub fn gather_move_from_pat(bccx: &BorrowckCtxt,\n-                            move_data: &mut MoveData,\n+                            move_data: &MoveData,\n                             move_pat: @ast::Pat,\n                             cmt: mc::cmt) {\n     gather_move_from_expr_or_pat(bccx, move_data, move_pat.id,\n                                  MovePat(move_pat), cmt);\n }\n \n fn gather_move_from_expr_or_pat(bccx: &BorrowckCtxt,\n-                                move_data: &mut MoveData,\n+                                move_data: &MoveData,\n                                 move_id: ast::NodeId,\n                                 move_kind: MoveKind,\n                                 cmt: mc::cmt) {\n@@ -67,9 +67,10 @@ fn gather_move_from_expr_or_pat(bccx: &BorrowckCtxt,\n }\n \n pub fn gather_captures(bccx: &BorrowckCtxt,\n-                       move_data: &mut MoveData,\n+                       move_data: &MoveData,\n                        closure_expr: @ast::Expr) {\n-    let captured_vars = bccx.capture_map.get(&closure_expr.id);\n+    let capture_map = bccx.capture_map.borrow();\n+    let captured_vars = capture_map.get().get(&closure_expr.id);\n     for captured_var in captured_vars.iter() {\n         match captured_var.mode {\n             moves::CapMove => {\n@@ -84,7 +85,7 @@ pub fn gather_captures(bccx: &BorrowckCtxt,\n }\n \n pub fn gather_assignment(bccx: &BorrowckCtxt,\n-                         move_data: &mut MoveData,\n+                         move_data: &MoveData,\n                          assignment_id: ast::NodeId,\n                          assignment_span: Span,\n                          assignee_loan_path: @LoanPath,"}, {"sha": "38598e8b78fc9512a2d45abdf6f6e2442c8aeeef", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -279,7 +279,9 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n         // Add a record of what is required\n         let rm_key = root_map_key {id: cmt_deref.id, derefs: derefs};\n         let root_info = RootInfo {scope: root_scope, freeze: opt_dyna};\n-        self.bccx.root_map.insert(rm_key, root_info);\n+\n+        let mut root_map = self.bccx.root_map.borrow_mut();\n+        root_map.get().insert(rm_key, root_info);\n \n         debug!(\"root_key: {:?} root_info: {:?}\", rm_key, root_info);\n         Ok(())\n@@ -303,7 +305,10 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             mc::cat_local(id) |\n             mc::cat_self(id) |\n             mc::cat_arg(id) => {\n-                self.bccx.moved_variables_set.contains(&id)\n+                let moved_variables_set = self.bccx\n+                                              .moved_variables_set\n+                                              .borrow();\n+                moved_variables_set.get().contains(&id)\n             }\n             mc::cat_rvalue(..) |\n             mc::cat_static_item |"}, {"sha": "36e35760400d018c6470e83f6c9591aa825e7a81", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -26,6 +26,7 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::{Repr};\n \n+use std::cell::RefCell;\n use syntax::ast;\n use syntax::ast_util::id_range;\n use syntax::codemap::Span;\n@@ -67,8 +68,8 @@ mod gather_moves;\n struct GatherLoanCtxt<'a> {\n     bccx: &'a BorrowckCtxt,\n     id_range: id_range,\n-    move_data: @mut move_data::MoveData,\n-    all_loans: @mut ~[Loan],\n+    move_data: @move_data::MoveData,\n+    all_loans: @RefCell<~[Loan]>,\n     item_ub: ast::NodeId,\n     repeating_ids: ~[ast::NodeId]\n }\n@@ -85,7 +86,7 @@ impl<'a> visit::Visitor<()> for GatherLoanCtxt<'a> {\n         gather_loans_in_fn(self, fk, fd, b, s, n);\n     }\n     fn visit_stmt(&mut self, s:@Stmt, _:()) {\n-        add_stmt_to_map(self, s);\n+        visit::walk_stmt(self, s, ());\n     }\n     fn visit_pat(&mut self, p:&Pat, _:()) {\n         add_pat_to_id_range(self, p);\n@@ -103,14 +104,14 @@ impl<'a> visit::Visitor<()> for GatherLoanCtxt<'a> {\n pub fn gather_loans(bccx: &BorrowckCtxt,\n                     decl: &ast::fn_decl,\n                     body: ast::P<ast::Block>)\n-                    -> (id_range, @mut ~[Loan], @mut move_data::MoveData) {\n+                    -> (id_range, @RefCell<~[Loan]>, @move_data::MoveData) {\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n         id_range: id_range::max(),\n-        all_loans: @mut ~[],\n+        all_loans: @RefCell::new(~[]),\n         item_ub: body.id,\n         repeating_ids: ~[body.id],\n-        move_data: @mut MoveData::new()\n+        move_data: @MoveData::new()\n     };\n     glcx.gather_fn_arg_patterns(decl, body);\n \n@@ -208,7 +209,8 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n \n     // If this expression is borrowed, have to ensure it remains valid:\n     {\n-        let r = tcx.adjustments.find(&ex.id);\n+        let adjustments = tcx.adjustments.borrow();\n+        let r = adjustments.get().find(&ex.id);\n         for &adjustments in r.iter() {\n             this.guarantee_adjustments(ex, *adjustments);\n         }\n@@ -222,6 +224,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n     }\n \n     // Special checks for various kinds of expressions:\n+    let method_map = this.bccx.method_map.borrow();\n     match ex.node {\n       ast::ExprAddrOf(mutbl, base) => {\n         let base_cmt = this.bccx.cat_expr(base);\n@@ -269,7 +272,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n \n       ast::ExprIndex(_, _, arg) |\n       ast::ExprBinary(_, _, _, arg)\n-      if this.bccx.method_map.contains_key(&ex.id) => {\n+      if method_map.get().contains_key(&ex.id) => {\n           // Arguments in method calls are always passed by ref.\n           //\n           // Currently these do not use adjustments, so we have to\n@@ -509,9 +512,9 @@ impl<'a> GatherLoanCtxt<'a> {\n                     self.mark_loan_path_as_mutated(loan_path);\n                 }\n \n-                let all_loans = &mut *self.all_loans; // FIXME(#5074)\n+                let all_loans = self.all_loans.borrow();\n                 Loan {\n-                    index: all_loans.len(),\n+                    index: all_loans.get().len(),\n                     loan_path: loan_path,\n                     cmt: cmt,\n                     mutbl: req_mutbl,\n@@ -529,7 +532,10 @@ impl<'a> GatherLoanCtxt<'a> {\n         // let loan_path = loan.loan_path;\n         // let loan_gen_scope = loan.gen_scope;\n         // let loan_kill_scope = loan.kill_scope;\n-        self.all_loans.push(loan);\n+        {\n+            let mut all_loans = self.all_loans.borrow_mut();\n+            all_loans.get().push(loan);\n+        }\n \n         // if loan_gen_scope != borrow_id {\n             // FIXME(#6268) Nested method calls\n@@ -605,7 +611,10 @@ impl<'a> GatherLoanCtxt<'a> {\n \n         match *loan_path {\n             LpVar(local_id) => {\n-                self.tcx().used_mut_nodes.insert(local_id);\n+                let mut used_mut_nodes = self.tcx()\n+                                             .used_mut_nodes\n+                                             .borrow_mut();\n+                used_mut_nodes.get().insert(local_id);\n             }\n             LpExtend(base, mc::McInherited, _) => {\n                 self.mark_loan_path_as_mutated(base);\n@@ -823,15 +832,3 @@ impl<'a> GatherLoanCtxt<'a> {\n     }\n }\n \n-// Setting up info that preserve needs.\n-// This is just the most convenient place to do it.\n-fn add_stmt_to_map(this: &mut GatherLoanCtxt,\n-                   stmt: @ast::Stmt) {\n-    match stmt.node {\n-        ast::StmtExpr(_, id) | ast::StmtSemi(_, id) => {\n-            this.bccx.stmt_map.insert(id);\n-        }\n-        _ => ()\n-    }\n-    visit::walk_stmt(this, stmt, ());\n-}"}, {"sha": "61e5d1f25fe7c3ccf3ef4836f0d1f9369f342294", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 32, "deletions": 39, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -17,9 +17,9 @@ use middle::typeck;\n use middle::moves;\n use middle::dataflow::DataFlowContext;\n use middle::dataflow::DataFlowOperator;\n-use util::common::stmt_set;\n use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n+use std::cell::{Cell, RefCell};\n use std::hashmap::{HashSet, HashMap};\n use std::ops::{BitOr, BitAnd};\n use std::result::{Result};\n@@ -82,15 +82,12 @@ pub fn check_crate(\n         moved_variables_set: moved_variables_set,\n         capture_map: capture_map,\n         root_map: root_map(),\n-        loan_map: @mut HashMap::new(),\n-        write_guard_map: @mut HashSet::new(),\n-        stmt_map: @mut HashSet::new(),\n-        stats: @mut BorrowStats {\n-            loaned_paths_same: 0,\n-            loaned_paths_imm: 0,\n-            stable_paths: 0,\n-            req_pure_paths: 0,\n-            guaranteed_paths: 0,\n+        write_guard_map: @RefCell::new(HashSet::new()),\n+        stats: @BorrowStats {\n+            loaned_paths_same: Cell::new(0),\n+            loaned_paths_imm: Cell::new(0),\n+            stable_paths: Cell::new(0),\n+            guaranteed_paths: Cell::new(0),\n         }\n     };\n     let bccx = &mut bccx;\n@@ -100,22 +97,20 @@ pub fn check_crate(\n     if tcx.sess.borrowck_stats() {\n         println(\"--- borrowck stats ---\");\n         println!(\"paths requiring guarantees: {}\",\n-                 bccx.stats.guaranteed_paths);\n+                 bccx.stats.guaranteed_paths.get());\n         println!(\"paths requiring loans     : {}\",\n-                 make_stat(bccx, bccx.stats.loaned_paths_same));\n+                 make_stat(bccx, bccx.stats.loaned_paths_same.get()));\n         println!(\"paths requiring imm loans : {}\",\n-                 make_stat(bccx, bccx.stats.loaned_paths_imm));\n+                 make_stat(bccx, bccx.stats.loaned_paths_imm.get()));\n         println!(\"stable paths              : {}\",\n-                 make_stat(bccx, bccx.stats.stable_paths));\n-        println!(\"paths requiring purity    : {}\",\n-                 make_stat(bccx, bccx.stats.req_pure_paths));\n+                 make_stat(bccx, bccx.stats.stable_paths.get()));\n     }\n \n     return (bccx.root_map, bccx.write_guard_map);\n \n     fn make_stat(bccx: &mut BorrowckCtxt, stat: uint) -> ~str {\n         let stat_f = stat as f64;\n-        let total = bccx.stats.guaranteed_paths as f64;\n+        let total = bccx.stats.guaranteed_paths.get() as f64;\n         format!(\"{} ({:.0f}%)\", stat  , stat_f * 100.0 / total)\n     }\n }\n@@ -138,16 +133,18 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n             // Check the body of fn items.\n             let (id_range, all_loans, move_data) =\n                 gather_loans::gather_loans(this, decl, body);\n-            let mut loan_dfcx =\n-                DataFlowContext::new(this.tcx,\n-                                     this.method_map,\n-                                     LoanDataFlowOperator,\n-                                     id_range,\n-                                     all_loans.len());\n-            for (loan_idx, loan) in all_loans.iter().enumerate() {\n+\n+            let all_loans = all_loans.borrow();\n+            let mut loan_dfcx = DataFlowContext::new(this.tcx,\n+                                                     this.method_map,\n+                                                     LoanDataFlowOperator,\n+                                                     id_range,\n+                                                     all_loans.get().len());\n+            for (loan_idx, loan) in all_loans.get().iter().enumerate() {\n                 loan_dfcx.add_gen(loan.gen_scope, loan_idx);\n                 loan_dfcx.add_kill(loan.kill_scope, loan_idx);\n             }\n+\n             loan_dfcx.propagate(body);\n \n             let flowed_moves = move_data::FlowedMoveData::new(move_data,\n@@ -157,7 +154,7 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n                                                               body);\n \n             check_loans::check_loans(this, &loan_dfcx, flowed_moves,\n-                                     *all_loans, body);\n+                                     *all_loans.get(), body);\n         }\n     }\n \n@@ -174,24 +171,19 @@ pub struct BorrowckCtxt {\n     moved_variables_set: moves::MovedVariablesSet,\n     capture_map: moves::CaptureMap,\n     root_map: root_map,\n-    loan_map: LoanMap,\n     write_guard_map: write_guard_map,\n-    stmt_map: stmt_set,\n \n     // Statistics:\n-    stats: @mut BorrowStats\n+    stats: @BorrowStats\n }\n \n pub struct BorrowStats {\n-    loaned_paths_same: uint,\n-    loaned_paths_imm: uint,\n-    stable_paths: uint,\n-    req_pure_paths: uint,\n-    guaranteed_paths: uint\n+    loaned_paths_same: Cell<uint>,\n+    loaned_paths_imm: Cell<uint>,\n+    stable_paths: Cell<uint>,\n+    guaranteed_paths: Cell<uint>,\n }\n \n-pub type LoanMap = @mut HashMap<ast::NodeId, @Loan>;\n-\n // The keys to the root map combine the `id` of the deref expression\n // with the number of types that it is *autodereferenced*. So, for\n // example, imagine I have a variable `x: @@@T` and an expression\n@@ -223,7 +215,7 @@ pub struct root_map_key {\n \n // A set containing IDs of expressions of gc'd type that need to have a write\n // guard.\n-pub type write_guard_map = @mut HashSet<root_map_key>;\n+pub type write_guard_map = @RefCell<HashSet<root_map_key>>;\n \n pub type BckResult<T> = Result<T, BckError>;\n \n@@ -413,10 +405,10 @@ pub struct RootInfo {\n     freeze: Option<DynaFreezeKind> // Some() if we should freeze box at runtime\n }\n \n-pub type root_map = @mut HashMap<root_map_key, RootInfo>;\n+pub type root_map = @RefCell<HashMap<root_map_key, RootInfo>>;\n \n pub fn root_map() -> root_map {\n-    return @mut HashMap::new();\n+    return @RefCell::new(HashMap::new());\n }\n \n pub enum DynaFreezeKind {\n@@ -481,7 +473,8 @@ impl BorrowckCtxt {\n     }\n \n     pub fn is_move(&self, id: ast::NodeId) -> bool {\n-        self.moves_map.contains(&id)\n+        let moves_map = self.moves_map.borrow();\n+        moves_map.get().contains(&id)\n     }\n \n     pub fn cat_expr(&self, expr: @ast::Expr) -> mc::cmt {"}, {"sha": "6d3bdc3fe4f1d60413cffe5c9c8e624d7c1a68bf", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 195, "deletions": 106, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -15,7 +15,7 @@ comments in the section \"Moves and initialization\" and in `doc.rs`.\n \n */\n \n-\n+use std::cell::RefCell;\n use std::hashmap::{HashMap, HashSet};\n use std::uint;\n use middle::borrowck::*;\n@@ -32,32 +32,33 @@ use util::ppaux::Repr;\n \n pub struct MoveData {\n     /// Move paths. See section \"Move paths\" in `doc.rs`.\n-    paths: ~[MovePath],\n+    paths: RefCell<~[MovePath]>,\n \n     /// Cache of loan path to move path index, for easy lookup.\n-    path_map: HashMap<@LoanPath, MovePathIndex>,\n+    path_map: RefCell<HashMap<@LoanPath, MovePathIndex>>,\n \n     /// Each move or uninitialized variable gets an entry here.\n-    moves: ~[Move],\n+    moves: RefCell<~[Move]>,\n \n     /// Assignments to a variable, like `x = foo`. These are assigned\n     /// bits for dataflow, since we must track them to ensure that\n     /// immutable variables are assigned at most once along each path.\n-    var_assignments: ~[Assignment],\n+    var_assignments: RefCell<~[Assignment]>,\n \n     /// Assignments to a path, like `x.f = foo`. These are not\n     /// assigned dataflow bits, but we track them because they still\n     /// kill move bits.\n-    path_assignments: ~[Assignment],\n-    assignee_ids: HashSet<ast::NodeId>,\n+    path_assignments: RefCell<~[Assignment]>,\n+    assignee_ids: RefCell<HashSet<ast::NodeId>>,\n }\n \n pub struct FlowedMoveData {\n-    move_data: @mut MoveData,\n-    //         ^~~~~~~~~~~~~\n-    // It makes me sad to use @mut here, except that due to\n-    // the visitor design, this is what gather_loans\n-    // must produce.\n+    move_data: @MoveData,\n+    //         ^~~~~~~~~\n+    // It makes me sad to use @ here, except that due to\n+    // the old visitor design, this is what gather_loans\n+    // used to have to produce, and this code hasn't been\n+    // updated.\n \n     dfcx_moves: MoveDataFlow,\n \n@@ -165,36 +166,66 @@ pub type AssignDataFlow = DataFlowContext<AssignDataFlowOperator>;\n impl MoveData {\n     pub fn new() -> MoveData {\n         MoveData {\n-            paths: ~[],\n-            path_map: HashMap::new(),\n-            moves: ~[],\n-            path_assignments: ~[],\n-            var_assignments: ~[],\n-            assignee_ids: HashSet::new(),\n+            paths: RefCell::new(~[]),\n+            path_map: RefCell::new(HashMap::new()),\n+            moves: RefCell::new(~[]),\n+            path_assignments: RefCell::new(~[]),\n+            var_assignments: RefCell::new(~[]),\n+            assignee_ids: RefCell::new(HashSet::new()),\n         }\n     }\n \n-    fn path<'a>(&'a self, index: MovePathIndex) -> &'a MovePath {\n-        //! Type safe indexing operator\n-        &self.paths[*index]\n+    fn path_loan_path(&self, index: MovePathIndex) -> @LoanPath {\n+        let paths = self.paths.borrow();\n+        paths.get()[*index].loan_path\n     }\n \n-    fn mut_path<'a>(&'a mut self, index: MovePathIndex) -> &'a mut MovePath {\n-        //! Type safe indexing operator\n-        &mut self.paths[*index]\n+    fn path_parent(&self, index: MovePathIndex) -> MovePathIndex {\n+        let paths = self.paths.borrow();\n+        paths.get()[*index].parent\n+    }\n+\n+    fn path_first_move(&self, index: MovePathIndex) -> MoveIndex {\n+        let paths = self.paths.borrow();\n+        paths.get()[*index].first_move\n+    }\n+\n+    fn path_first_child(&self, index: MovePathIndex) -> MovePathIndex {\n+        let paths = self.paths.borrow();\n+        paths.get()[*index].first_child\n+    }\n+\n+    fn path_next_sibling(&self, index: MovePathIndex) -> MovePathIndex {\n+        let paths = self.paths.borrow();\n+        paths.get()[*index].next_sibling\n+    }\n+\n+    fn set_path_first_move(&self,\n+                           index: MovePathIndex,\n+                           first_move: MoveIndex) {\n+        let mut paths = self.paths.borrow_mut();\n+        paths.get()[*index].first_move = first_move\n     }\n \n-    fn move<'a>(&'a self, index: MoveIndex) -> &'a Move {\n+    fn set_path_first_child(&self,\n+                            index: MovePathIndex,\n+                            first_child: MovePathIndex) {\n+        let mut paths = self.paths.borrow_mut();\n+        paths.get()[*index].first_child = first_child\n+    }\n+\n+    fn move_next_move(&self, index: MoveIndex) -> MoveIndex {\n         //! Type safe indexing operator\n-        &self.moves[*index]\n+        let moves = self.moves.borrow();\n+        moves.get()[*index].next_move\n     }\n \n     fn is_var_path(&self, index: MovePathIndex) -> bool {\n         //! True if `index` refers to a variable\n-        self.path(index).parent == InvalidMovePathIndex\n+        self.path_parent(index) == InvalidMovePathIndex\n     }\n \n-    pub fn move_path(&mut self,\n+    pub fn move_path(&self,\n                      tcx: ty::ctxt,\n                      lp: @LoanPath) -> MovePathIndex {\n         /*!\n@@ -203,18 +234,22 @@ impl MoveData {\n          * base paths that do not yet have an index.\n          */\n \n-        match self.path_map.find(&lp) {\n-            Some(&index) => {\n-                return index;\n+        {\n+            let path_map = self.path_map.borrow();\n+            match path_map.get().find(&lp) {\n+                Some(&index) => {\n+                    return index;\n+                }\n+                None => {}\n             }\n-            None => {}\n         }\n \n         let index = match *lp {\n             LpVar(..) => {\n-                let index = MovePathIndex(self.paths.len());\n+                let mut paths = self.paths.borrow_mut();\n+                let index = MovePathIndex(paths.get().len());\n \n-                self.paths.push(MovePath {\n+                paths.get().push(MovePath {\n                     loan_path: lp,\n                     parent: InvalidMovePathIndex,\n                     first_move: InvalidMoveIndex,\n@@ -227,18 +262,25 @@ impl MoveData {\n \n             LpExtend(base, _, _) => {\n                 let parent_index = self.move_path(tcx, base);\n-                let index = MovePathIndex(self.paths.len());\n \n-                let next_sibling = self.path(parent_index).first_child;\n-                self.mut_path(parent_index).first_child = index;\n-\n-                self.paths.push(MovePath {\n-                    loan_path: lp,\n-                    parent: parent_index,\n-                    first_move: InvalidMoveIndex,\n-                    first_child: InvalidMovePathIndex,\n-                    next_sibling: next_sibling,\n-                });\n+                let index = {\n+                    let paths = self.paths.borrow();\n+                    MovePathIndex(paths.get().len())\n+                };\n+\n+                let next_sibling = self.path_first_child(parent_index);\n+                self.set_path_first_child(parent_index, index);\n+\n+                {\n+                    let mut paths = self.paths.borrow_mut();\n+                    paths.get().push(MovePath {\n+                        loan_path: lp,\n+                        parent: parent_index,\n+                        first_move: InvalidMoveIndex,\n+                        first_child: InvalidMovePathIndex,\n+                        next_sibling: next_sibling,\n+                    });\n+                }\n \n                 index\n             }\n@@ -248,15 +290,19 @@ impl MoveData {\n                lp.repr(tcx),\n                index);\n \n-        assert_eq!(*index, self.paths.len() - 1);\n-        self.path_map.insert(lp, index);\n+        let paths = self.paths.borrow();\n+        assert_eq!(*index, paths.get().len() - 1);\n+\n+        let mut path_map = self.path_map.borrow_mut();\n+        path_map.get().insert(lp, index);\n         return index;\n     }\n \n     fn existing_move_path(&self,\n                           lp: @LoanPath)\n                           -> Option<MovePathIndex> {\n-        self.path_map.find_copy(&lp)\n+        let path_map = self.path_map.borrow();\n+        path_map.get().find_copy(&lp)\n     }\n \n     fn existing_base_paths(&self,\n@@ -275,7 +321,11 @@ impl MoveData {\n          * paths of `lp` to `result`, but does not add new move paths\n          */\n \n-        match self.path_map.find_copy(&lp) {\n+        let index_opt = {\n+            let path_map = self.path_map.borrow();\n+            path_map.get().find_copy(&lp)\n+        };\n+        match index_opt {\n             Some(index) => {\n                 self.each_base_path(index, |p| {\n                     result.push(p);\n@@ -294,7 +344,7 @@ impl MoveData {\n \n     }\n \n-    pub fn add_move(&mut self,\n+    pub fn add_move(&self,\n                     tcx: ty::ctxt,\n                     lp: @LoanPath,\n                     id: ast::NodeId,\n@@ -310,20 +360,26 @@ impl MoveData {\n                kind);\n \n         let path_index = self.move_path(tcx, lp);\n-        let move_index = MoveIndex(self.moves.len());\n-\n-        let next_move = self.path(path_index).first_move;\n-        self.mut_path(path_index).first_move = move_index;\n+        let move_index = {\n+            let moves = self.moves.borrow();\n+            MoveIndex(moves.get().len())\n+        };\n \n-        self.moves.push(Move {\n-            path: path_index,\n-            id: id,\n-            kind: kind,\n-            next_move: next_move\n-        });\n+        let next_move = self.path_first_move(path_index);\n+        self.set_path_first_move(path_index, move_index);\n+\n+        {\n+            let mut moves = self.moves.borrow_mut();\n+            moves.get().push(Move {\n+                path: path_index,\n+                id: id,\n+                kind: kind,\n+                next_move: next_move\n+            });\n+        }\n     }\n \n-    pub fn add_assignment(&mut self,\n+    pub fn add_assignment(&self,\n                           tcx: ty::ctxt,\n                           lp: @LoanPath,\n                           assign_id: ast::NodeId,\n@@ -339,7 +395,10 @@ impl MoveData {\n \n         let path_index = self.move_path(tcx, lp);\n \n-        self.assignee_ids.insert(assignee_id);\n+        {\n+            let mut assignee_ids = self.assignee_ids.borrow_mut();\n+            assignee_ids.get().insert(assignee_id);\n+        }\n \n         let assignment = Assignment {\n             path: path_index,\n@@ -348,15 +407,19 @@ impl MoveData {\n         };\n \n         if self.is_var_path(path_index) {\n+            let mut var_assignments = self.var_assignments.borrow_mut();\n             debug!(\"add_assignment[var](lp={}, assignment={}, path_index={:?})\",\n-                   lp.repr(tcx), self.var_assignments.len(), path_index);\n+                   lp.repr(tcx), var_assignments.get().len(), path_index);\n \n-            self.var_assignments.push(assignment);\n+            var_assignments.get().push(assignment);\n         } else {\n             debug!(\"add_assignment[path](lp={}, path_index={:?})\",\n                    lp.repr(tcx), path_index);\n \n-            self.path_assignments.push(assignment);\n+            {\n+                let mut path_assignments = self.path_assignments.borrow_mut();\n+                path_assignments.get().push(assignment);\n+            }\n         }\n     }\n \n@@ -372,41 +435,60 @@ impl MoveData {\n          * killed by scoping. See `doc.rs` for more details.\n          */\n \n-        for (i, move) in self.moves.iter().enumerate() {\n-            dfcx_moves.add_gen(move.id, i);\n+        {\n+            let moves = self.moves.borrow();\n+            for (i, move) in moves.get().iter().enumerate() {\n+                dfcx_moves.add_gen(move.id, i);\n+            }\n         }\n \n-        for (i, assignment) in self.var_assignments.iter().enumerate() {\n-            dfcx_assign.add_gen(assignment.id, i);\n-            self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n+        {\n+            let var_assignments = self.var_assignments.borrow();\n+            for (i, assignment) in var_assignments.get().iter().enumerate() {\n+                dfcx_assign.add_gen(assignment.id, i);\n+                self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n+            }\n         }\n \n-        for assignment in self.path_assignments.iter() {\n-            self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n+        {\n+            let path_assignments = self.path_assignments.borrow();\n+            for assignment in path_assignments.get().iter() {\n+                self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n+            }\n         }\n \n         // Kill all moves related to a variable `x` when it goes out\n         // of scope:\n-        for path in self.paths.iter() {\n-            match *path.loan_path {\n-                LpVar(id) => {\n-                    let kill_id = tcx.region_maps.encl_scope(id);\n-                    let path = *self.path_map.get(&path.loan_path);\n-                    self.kill_moves(path, kill_id, dfcx_moves);\n+        {\n+            let paths = self.paths.borrow();\n+            for path in paths.get().iter() {\n+                match *path.loan_path {\n+                    LpVar(id) => {\n+                        let kill_id = tcx.region_maps.encl_scope(id);\n+                        let path = {\n+                            let path_map = self.path_map.borrow();\n+                            *path_map.get().get(&path.loan_path)\n+                        };\n+                        self.kill_moves(path, kill_id, dfcx_moves);\n+                    }\n+                    LpExtend(..) => {}\n                 }\n-                LpExtend(..) => {}\n             }\n         }\n \n         // Kill all assignments when the variable goes out of scope:\n-        for (assignment_index, assignment) in self.var_assignments.iter().enumerate() {\n-            match *self.path(assignment.path).loan_path {\n-                LpVar(id) => {\n-                    let kill_id = tcx.region_maps.encl_scope(id);\n-                    dfcx_assign.add_kill(kill_id, assignment_index);\n-                }\n-                LpExtend(..) => {\n-                    tcx.sess.bug(\"Var assignment for non var path\");\n+        {\n+            let var_assignments = self.var_assignments.borrow();\n+            for (assignment_index, assignment) in\n+                    var_assignments.get().iter().enumerate() {\n+                match *self.path_loan_path(assignment.path) {\n+                    LpVar(id) => {\n+                        let kill_id = tcx.region_maps.encl_scope(id);\n+                        dfcx_assign.add_kill(kill_id, assignment_index);\n+                    }\n+                    LpExtend(..) => {\n+                        tcx.sess.bug(\"Var assignment for non var path\");\n+                    }\n                 }\n             }\n         }\n@@ -419,7 +501,7 @@ impl MoveData {\n             if !f(p) {\n                 return false;\n             }\n-            p = self.path(p).parent;\n+            p = self.path_parent(p);\n         }\n         return true;\n     }\n@@ -432,12 +514,12 @@ impl MoveData {\n             return false;\n         }\n \n-        let mut p = self.path(index).first_child;\n+        let mut p = self.path_first_child(index);\n         while p != InvalidMovePathIndex {\n             if !self.each_extending_path(p, |x| f(x)) {\n                 return false;\n             }\n-            p = self.path(p).next_sibling;\n+            p = self.path_next_sibling(p);\n         }\n \n         return true;\n@@ -449,13 +531,13 @@ impl MoveData {\n                             -> bool {\n         let mut ret = true;\n         self.each_extending_path(index0, |index| {\n-            let mut p = self.path(index).first_move;\n+            let mut p = self.path_first_move(index);\n             while p != InvalidMoveIndex {\n                 if !f(p) {\n                     ret = false;\n                     break;\n                 }\n-                p = self.move(p).next_move;\n+                p = self.move_next_move(p);\n             }\n             ret\n         });\n@@ -474,25 +556,28 @@ impl MoveData {\n }\n \n impl FlowedMoveData {\n-    pub fn new(move_data: @mut MoveData,\n+    pub fn new(move_data: @MoveData,\n                tcx: ty::ctxt,\n                method_map: typeck::method_map,\n                id_range: ast_util::id_range,\n                body: &ast::Block)\n-               -> FlowedMoveData\n-    {\n-        let mut dfcx_moves =\n+               -> FlowedMoveData {\n+        let mut dfcx_moves = {\n+            let moves = move_data.moves.borrow();\n             DataFlowContext::new(tcx,\n                                  method_map,\n                                  MoveDataFlowOperator,\n                                  id_range,\n-                                 move_data.moves.len());\n-        let mut dfcx_assign =\n+                                 moves.get().len())\n+        };\n+        let mut dfcx_assign = {\n+            let var_assignments = move_data.var_assignments.borrow();\n             DataFlowContext::new(tcx,\n                                  method_map,\n                                  AssignDataFlowOperator,\n                                  id_range,\n-                                 move_data.var_assignments.len());\n+                                 var_assignments.get().len())\n+        };\n         move_data.add_gen_kills(tcx, &mut dfcx_moves, &mut dfcx_assign);\n         dfcx_moves.propagate(body);\n         dfcx_assign.propagate(body);\n@@ -512,9 +597,10 @@ impl FlowedMoveData {\n          */\n \n         self.dfcx_moves.each_gen_bit_frozen(id, |index| {\n-            let move = &self.move_data.moves[index];\n+            let moves = self.move_data.moves.borrow();\n+            let move = &moves.get()[index];\n             let moved_path = move.path;\n-            f(move, self.move_data.path(moved_path).loan_path)\n+            f(move, self.move_data.path_loan_path(moved_path))\n         })\n     }\n \n@@ -550,12 +636,13 @@ impl FlowedMoveData {\n         let mut ret = true;\n \n         self.dfcx_moves.each_bit_on_entry_frozen(id, |index| {\n-            let move = &self.move_data.moves[index];\n+            let moves = self.move_data.moves.borrow();\n+            let move = &moves.get()[index];\n             let moved_path = move.path;\n             if base_indices.iter().any(|x| x == &moved_path) {\n                 // Scenario 1 or 2: `loan_path` or some base path of\n                 // `loan_path` was moved.\n-                if !f(move, self.move_data.path(moved_path).loan_path) {\n+                if !f(move, self.move_data.path_loan_path(moved_path)) {\n                     ret = false;\n                 }\n             } else {\n@@ -564,7 +651,7 @@ impl FlowedMoveData {\n                         if p == loan_path_index {\n                             // Scenario 3: some extension of `loan_path`\n                             // was moved\n-                            f(move, self.move_data.path(moved_path).loan_path)\n+                            f(move, self.move_data.path_loan_path(moved_path))\n                         } else {\n                             true\n                         }\n@@ -581,7 +668,8 @@ impl FlowedMoveData {\n                        -> bool {\n         //! True if `id` is the id of the LHS of an assignment\n \n-        self.move_data.assignee_ids.iter().any(|x| x == &id)\n+        let assignee_ids = self.move_data.assignee_ids.borrow();\n+        assignee_ids.get().iter().any(|x| x == &id)\n     }\n \n     pub fn each_assignment_of(&self,\n@@ -606,7 +694,8 @@ impl FlowedMoveData {\n         };\n \n         self.dfcx_assign.each_bit_on_entry_frozen(id, |index| {\n-            let assignment = &self.move_data.var_assignments[index];\n+            let var_assignments = self.move_data.var_assignments.borrow();\n+            let assignment = &var_assignments.get()[index];\n             if assignment.path == loan_path_index && !f(assignment) {\n                 false\n             } else {"}, {"sha": "d5823e025be10a7f0afa7d07f750c5043d3cb574", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -496,7 +496,8 @@ impl CFGBuilder {\n             }\n \n             Some(_) => {\n-                match self.tcx.def_map.find(&expr.id) {\n+                let def_map = self.tcx.def_map.borrow();\n+                match def_map.get().find(&expr.id) {\n                     Some(&ast::DefLabel(loop_id)) => {\n                         for l in self.loop_scopes.iter() {\n                             if l.loop_id == loop_id {\n@@ -519,6 +520,7 @@ impl CFGBuilder {\n     }\n \n     fn is_method_call(&self, expr: &ast::Expr) -> bool {\n-        self.method_map.contains_key(&expr.id)\n+        let method_map = self.method_map.borrow();\n+        method_map.get().contains_key(&expr.id)\n     }\n }"}, {"sha": "4dfdd00c27ad6cec195fa4371feb664ee798ca6e", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -15,6 +15,7 @@ use middle::ty;\n use middle::typeck;\n use util::ppaux;\n \n+use std::cell::RefCell;\n use syntax::ast::*;\n use syntax::codemap;\n use syntax::{ast_util, ast_map};\n@@ -122,7 +123,8 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n           }\n           ExprLit(@codemap::Spanned {node: lit_str(..), ..}) => { }\n           ExprBinary(..) | ExprUnary(..) => {\n-            if method_map.contains_key(&e.id) {\n+            let method_map = method_map.borrow();\n+            if method_map.get().contains_key(&e.id) {\n                 sess.span_err(e.span, \"user-defined operators are not \\\n                                        allowed in constant expressions\");\n             }\n@@ -146,7 +148,8 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n                     e.span, \"paths in constants may only refer to \\\n                              items without type parameters\");\n             }\n-            match def_map.find(&e.id) {\n+            let def_map = def_map.borrow();\n+            match def_map.get().find(&e.id) {\n               Some(&DefStatic(..)) |\n               Some(&DefFn(_, _)) |\n               Some(&DefVariant(_, _, _)) |\n@@ -165,7 +168,8 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n             }\n           }\n           ExprCall(callee, _, NoSugar) => {\n-            match def_map.find(&callee.id) {\n+            let def_map = def_map.borrow();\n+            match def_map.get().find(&callee.id) {\n                 Some(&DefStruct(..)) => {}    // OK.\n                 Some(&DefVariant(..)) => {}    // OK.\n                 _ => {\n@@ -214,7 +218,7 @@ struct env {\n     sess: Session,\n     ast_map: ast_map::map,\n     def_map: resolve::DefMap,\n-    idstack: @mut ~[NodeId]\n+    idstack: @RefCell<~[NodeId]>,\n }\n \n struct CheckItemRecursionVisitor {\n@@ -232,7 +236,7 @@ pub fn check_item_recursion(sess: Session,\n         sess: sess,\n         ast_map: ast_map,\n         def_map: def_map,\n-        idstack: @mut ~[]\n+        idstack: @RefCell::new(~[]),\n     };\n \n     let mut visitor = CheckItemRecursionVisitor { env: env };\n@@ -241,25 +245,36 @@ pub fn check_item_recursion(sess: Session,\n \n impl Visitor<()> for CheckItemRecursionVisitor {\n     fn visit_item(&mut self, it: @item, _: ()) {\n-        if self.env.idstack.iter().any(|x| x == &(it.id)) {\n-            self.env.sess.span_fatal(self.env.root_it.span, \"recursive constant\");\n+        {\n+            let mut idstack = self.env.idstack.borrow_mut();\n+            if idstack.get().iter().any(|x| x == &(it.id)) {\n+                self.env.sess.span_fatal(self.env.root_it.span,\n+                                         \"recursive constant\");\n+            }\n+            idstack.get().push(it.id);\n         }\n-        self.env.idstack.push(it.id);\n         visit::walk_item(self, it, ());\n-        self.env.idstack.pop();\n+        {\n+            let mut idstack = self.env.idstack.borrow_mut();\n+            idstack.get().pop();\n+        }\n     }\n \n     fn visit_expr(&mut self, e: @Expr, _: ()) {\n         match e.node {\n-            ExprPath(..) => match self.env.def_map.find(&e.id) {\n-                Some(&DefStatic(def_id, _)) if ast_util::is_local(def_id) =>\n-                    match self.env.ast_map.get_copy(&def_id.node) {\n-                        ast_map::node_item(it, _) => {\n-                            self.visit_item(it, ());\n-                        }\n-                        _ => fail!(\"const not bound to an item\")\n-                    },\n-                _ => ()\n+            ExprPath(..) => {\n+                let def_map = self.env.def_map.borrow();\n+                match def_map.get().find(&e.id) {\n+                    Some(&DefStatic(def_id, _)) if\n+                            ast_util::is_local(def_id) =>\n+                        match self.env.ast_map.get_copy(&def_id.node) {\n+                            ast_map::node_item(it, _) => {\n+                                self.visit_item(it, ());\n+                            }\n+                            _ => fail!(\"const not bound to an item\")\n+                        },\n+                    _ => ()\n+                }\n             },\n             _ => ()\n         }"}, {"sha": "35ac2190888a5b60e9218fe36a4f05d7b4ab7911", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -121,8 +121,12 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n \n             // Check that we do not match against a static NaN (#6804)\n             let pat_matches_nan: |&Pat| -> bool = |p| {\n-                match cx.tcx.def_map.find(&p.id) {\n-                    Some(&DefStatic(did, false)) => {\n+                let opt_def = {\n+                    let def_map = cx.tcx.def_map.borrow();\n+                    def_map.get().find_copy(&p.id)\n+                };\n+                match opt_def {\n+                    Some(DefStatic(did, false)) => {\n                         let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n                         match eval_const_expr(cx.tcx, const_expr) {\n                             const_float(f) if f.is_nan() => true,\n@@ -334,9 +338,13 @@ fn pat_ctor_id(cx: &MatchCheckCtxt, p: @Pat) -> Option<ctor> {\n     match pat.node {\n       PatWild | PatWildMulti => { None }\n       PatIdent(_, _, _) | PatEnum(_, _) => {\n-        match cx.tcx.def_map.find(&pat.id) {\n-          Some(&DefVariant(_, id, _)) => Some(variant(id)),\n-          Some(&DefStatic(did, false)) => {\n+        let opt_def = {\n+            let def_map = cx.tcx.def_map.borrow();\n+            def_map.get().find_copy(&pat.id)\n+        };\n+        match opt_def {\n+          Some(DefVariant(_, id, _)) => Some(variant(id)),\n+          Some(DefStatic(did, false)) => {\n             let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n             Some(val(eval_const_expr(cx.tcx, const_expr)))\n           }\n@@ -348,7 +356,8 @@ fn pat_ctor_id(cx: &MatchCheckCtxt, p: @Pat) -> Option<ctor> {\n         Some(range(eval_const_expr(cx.tcx, lo), eval_const_expr(cx.tcx, hi)))\n       }\n       PatStruct(..) => {\n-        match cx.tcx.def_map.find(&pat.id) {\n+        let def_map = cx.tcx.def_map.borrow();\n+        match def_map.get().find(&pat.id) {\n           Some(&DefVariant(_, id, _)) => Some(variant(id)),\n           _ => Some(single)\n         }\n@@ -370,7 +379,8 @@ fn is_wild(cx: &MatchCheckCtxt, p: @Pat) -> bool {\n     match pat.node {\n       PatWild | PatWildMulti => { true }\n       PatIdent(_, _, _) => {\n-        match cx.tcx.def_map.find(&pat.id) {\n+        let def_map = cx.tcx.def_map.borrow();\n+        match def_map.get().find(&pat.id) {\n           Some(&DefVariant(_, _, _)) | Some(&DefStatic(..)) => { false }\n           _ => { true }\n         }\n@@ -551,15 +561,19 @@ fn specialize(cx: &MatchCheckCtxt,\n                 Some(vec::append(vec::from_elem(arity, wild_multi()), r.tail()))\n             }\n             PatIdent(_, _, _) => {\n-                match cx.tcx.def_map.find(&pat_id) {\n-                    Some(&DefVariant(_, id, _)) => {\n+                let opt_def = {\n+                    let def_map = cx.tcx.def_map.borrow();\n+                    def_map.get().find_copy(&pat_id)\n+                };\n+                match opt_def {\n+                    Some(DefVariant(_, id, _)) => {\n                         if variant(id) == *ctor_id {\n                             Some(r.tail().to_owned())\n                         } else {\n                             None\n                         }\n                     }\n-                    Some(&DefStatic(did, _)) => {\n+                    Some(DefStatic(did, _)) => {\n                         let const_expr =\n                             lookup_const_by_id(cx.tcx, did).unwrap();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n@@ -608,7 +622,11 @@ fn specialize(cx: &MatchCheckCtxt,\n                 }\n             }\n             PatEnum(_, args) => {\n-                match cx.tcx.def_map.get_copy(&pat_id) {\n+                let opt_def = {\n+                    let def_map = cx.tcx.def_map.borrow();\n+                    def_map.get().get_copy(&pat_id)\n+                };\n+                match opt_def {\n                     DefStatic(did, _) => {\n                         let const_expr =\n                             lookup_const_by_id(cx.tcx, did).unwrap();\n@@ -668,7 +686,11 @@ fn specialize(cx: &MatchCheckCtxt,\n             }\n             PatStruct(_, ref pattern_fields, _) => {\n                 // Is this a struct or an enum variant?\n-                match cx.tcx.def_map.get_copy(&pat_id) {\n+                let opt_def = {\n+                    let def_map = cx.tcx.def_map.borrow();\n+                    def_map.get().get_copy(&pat_id)\n+                };\n+                match opt_def {\n                     DefVariant(_, variant_id, _) => {\n                         if variant(variant_id) == *ctor_id {\n                             let struct_fields = ty::lookup_struct_fields(cx.tcx, variant_id);\n@@ -838,13 +860,17 @@ fn check_fn(v: &mut CheckMatchVisitor,\n }\n \n fn is_refutable(cx: &MatchCheckCtxt, pat: &Pat) -> bool {\n-    match cx.tcx.def_map.find(&pat.id) {\n-      Some(&DefVariant(enum_id, _, _)) => {\n+    let opt_def = {\n+        let def_map = cx.tcx.def_map.borrow();\n+        def_map.get().find_copy(&pat.id)\n+    };\n+    match opt_def {\n+      Some(DefVariant(enum_id, _, _)) => {\n         if ty::enum_variants(cx.tcx, enum_id).len() != 1u {\n             return true;\n         }\n       }\n-      Some(&DefStatic(..)) => return true,\n+      Some(DefStatic(..)) => return true,\n       _ => ()\n     }\n \n@@ -889,7 +915,8 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                     by_ref_span = Some(span);\n                 }\n                 BindByValue(_) => {\n-                    if cx.moves_map.contains(&id) {\n+                    let moves_map = cx.moves_map.borrow();\n+                    if moves_map.get().contains(&id) {\n                         any_by_move = true;\n                     }\n                 }\n@@ -926,7 +953,8 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n             if pat_is_binding(def_map, p) {\n                 match p.node {\n                     PatIdent(_, _, sub) => {\n-                        if cx.moves_map.contains(&p.id) {\n+                        let moves_map = cx.moves_map.borrow();\n+                        if moves_map.get().contains(&p.id) {\n                             check_move(p, sub);\n                         }\n                     }"}, {"sha": "d0dd36cda96052066f0c54e888afe3eff2a556b0", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 46, "deletions": 25, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -19,6 +19,7 @@ use syntax::visit;\n use syntax::visit::Visitor;\n use syntax::ast::*;\n \n+use std::cell::RefCell;\n use std::hashmap::{HashMap, HashSet};\n \n //\n@@ -77,11 +78,17 @@ pub fn join_all<It: Iterator<constness>>(mut cs: It) -> constness {\n }\n \n pub fn lookup_const(tcx: ty::ctxt, e: &Expr) -> Option<@Expr> {\n-    match tcx.def_map.find(&e.id) {\n-        Some(&ast::DefStatic(def_id, false)) =>\n-            lookup_const_by_id(tcx, def_id),\n-        Some(&ast::DefVariant(enum_def, variant_def, _)) =>\n-            lookup_variant_by_id(tcx, enum_def, variant_def),\n+    let opt_def = {\n+        let def_map = tcx.def_map.borrow();\n+        def_map.get().find_copy(&e.id)\n+    };\n+    match opt_def {\n+        Some(ast::DefStatic(def_id, false)) => {\n+            lookup_const_by_id(tcx, def_id)\n+        }\n+        Some(ast::DefVariant(enum_def, variant_def, _)) => {\n+            lookup_variant_by_id(tcx, enum_def, variant_def)\n+        }\n         _ => None\n     }\n }\n@@ -111,16 +118,19 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n             Some(_) => None\n         }\n     } else {\n-        match tcx.extern_const_variants.find(&variant_def) {\n-            Some(&e) => return e,\n-            None => {}\n+        {\n+            let extern_const_variants = tcx.extern_const_variants.borrow();\n+            match extern_const_variants.get().find(&variant_def) {\n+                Some(&e) => return e,\n+                None => {}\n+            }\n         }\n         let maps = astencode::Maps {\n-            root_map: @mut HashMap::new(),\n-            method_map: @mut HashMap::new(),\n-            vtable_map: @mut HashMap::new(),\n-            write_guard_map: @mut HashSet::new(),\n-            capture_map: @mut HashMap::new()\n+            root_map: @RefCell::new(HashMap::new()),\n+            method_map: @RefCell::new(HashMap::new()),\n+            vtable_map: @RefCell::new(HashMap::new()),\n+            write_guard_map: @RefCell::new(HashSet::new()),\n+            capture_map: @RefCell::new(HashMap::new())\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, enum_def,\n             |a, b, c, d| astencode::decode_inlined_item(a,\n@@ -136,8 +146,12 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n             },\n             _ => None\n         };\n-        tcx.extern_const_variants.insert(variant_def, e);\n-        return e;\n+        {\n+            let mut extern_const_variants = tcx.extern_const_variants\n+                                               .borrow_mut();\n+            extern_const_variants.get().insert(variant_def, e);\n+            return e;\n+        }\n     }\n }\n \n@@ -154,16 +168,19 @@ pub fn lookup_const_by_id(tcx: ty::ctxt,\n             Some(_) => None\n         }\n     } else {\n-        match tcx.extern_const_statics.find(&def_id) {\n-            Some(&e) => return e,\n-            None => {}\n+        {\n+            let extern_const_statics = tcx.extern_const_statics.borrow();\n+            match extern_const_statics.get().find(&def_id) {\n+                Some(&e) => return e,\n+                None => {}\n+            }\n         }\n         let maps = astencode::Maps {\n-            root_map: @mut HashMap::new(),\n-            method_map: @mut HashMap::new(),\n-            vtable_map: @mut HashMap::new(),\n-            write_guard_map: @mut HashSet::new(),\n-            capture_map: @mut HashMap::new()\n+            root_map: @RefCell::new(HashMap::new()),\n+            method_map: @RefCell::new(HashMap::new()),\n+            vtable_map: @RefCell::new(HashMap::new()),\n+            write_guard_map: @RefCell::new(HashSet::new()),\n+            capture_map: @RefCell::new(HashMap::new())\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, def_id,\n             |a, b, c, d| astencode::decode_inlined_item(a, b, maps, c, d)) {\n@@ -173,8 +190,12 @@ pub fn lookup_const_by_id(tcx: ty::ctxt,\n             },\n             _ => None\n         };\n-        tcx.extern_const_statics.insert(def_id, e);\n-        return e;\n+        {\n+            let mut extern_const_statics = tcx.extern_const_statics\n+                                              .borrow_mut();\n+            extern_const_statics.get().insert(def_id, e);\n+            return e;\n+        }\n     }\n }\n "}, {"sha": "142c69a5233eff5e9cc20cc067aba60fe5c0f8dd", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -874,7 +874,8 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n             }\n \n             Some(_) => {\n-                match self.tcx().def_map.find(&expr.id) {\n+                let def_map = self.tcx().def_map.borrow();\n+                match def_map.get().find(&expr.id) {\n                     Some(&ast::DefLabel(loop_id)) => {\n                         match loop_scopes.iter().position(|l| l.loop_id == loop_id) {\n                             Some(i) => i,\n@@ -899,7 +900,8 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     }\n \n     fn is_method_call(&self, expr: &ast::Expr) -> bool {\n-        self.dfcx.method_map.contains_key(&expr.id)\n+        let method_map = self.dfcx.method_map.borrow();\n+        method_map.get().contains_key(&expr.id)\n     }\n \n     fn reset(&mut self, bits: &mut [uint]) {"}, {"sha": "d26954ad458566c264e6824e23d3458a65a55aef", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -63,7 +63,8 @@ impl MarkSymbolVisitor {\n     }\n \n     fn lookup_and_handle_definition(&mut self, id: &ast::NodeId) {\n-        let def = match self.tcx.def_map.find(id) {\n+        let def_map = self.tcx.def_map.borrow();\n+        let def = match def_map.get().find(id) {\n             Some(&def) => def,\n             None => return\n         };\n@@ -134,7 +135,8 @@ impl Visitor<()> for MarkSymbolVisitor {\n     fn visit_expr(&mut self, expr: @ast::Expr, _: ()) {\n         match expr.node {\n             ast::ExprMethodCall(..) => {\n-                match self.method_map.find(&expr.id) {\n+                let method_map = self.method_map.borrow();\n+                match method_map.get().find(&expr.id) {\n                     Some(&typeck::method_map_entry {\n                         origin: typeck::method_static(def_id),\n                         ..\n@@ -211,7 +213,7 @@ fn create_and_seed_worklist(tcx: ty::ctxt,\n     }\n \n     // Seed entry point\n-    match *tcx.sess.entry_fn {\n+    match tcx.sess.entry_fn.get() {\n         Some((id, _)) => worklist.push(id),\n         None => ()\n     }\n@@ -282,10 +284,12 @@ impl DeadVisitor {\n         // method of a private type is used, but the type itself is never\n         // called directly.\n         let def_id = local_def(id);\n-        match self.tcx.inherent_impls.find(&def_id) {\n+        let inherent_impls = self.tcx.inherent_impls.borrow();\n+        match inherent_impls.get().find(&def_id) {\n             None => (),\n             Some(ref impl_list) => {\n-                for impl_ in impl_list.iter() {\n+                let impl_list = impl_list.borrow();\n+                for impl_ in impl_list.get().iter() {\n                     for method in impl_.methods.iter() {\n                         if self.live_symbols.contains(&method.def_id.node) {\n                             return true;"}, {"sha": "d4c566d4a604a22e31b60fdcbf3a0d61b424a4cf", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -56,7 +56,8 @@ impl EffectCheckVisitor {\n             UnsafeBlock(block_id) => {\n                 // OK, but record this.\n                 debug!(\"effect: recording unsafe block as used: {:?}\", block_id);\n-                let _ = self.tcx.used_unsafe.insert(block_id);\n+                let mut used_unsafe = self.tcx.used_unsafe.borrow_mut();\n+                let _ = used_unsafe.get().insert(block_id);\n             }\n             UnsafeFn => {}\n         }"}, {"sha": "53a8b93c232da086dd394eb4bf3daf9cfa782386", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -45,14 +45,14 @@ impl Visitor<()> for EntryContext {\n }\n \n pub fn find_entry_point(session: Session, crate: &Crate, ast_map: ast_map::map) {\n-    if *session.building_library {\n+    if session.building_library.get() {\n         // No need to find a main function\n         return;\n     }\n \n     // If the user wants no main function at all, then stop here.\n     if attr::contains_name(crate.attrs, \"no_main\") {\n-        *session.entry_type = Some(session::EntryNone);\n+        session.entry_type.set(Some(session::EntryNone));\n         return\n     }\n \n@@ -122,16 +122,16 @@ fn find_item(item: @item, ctxt: &mut EntryContext) {\n \n fn configure_main(this: &mut EntryContext) {\n     if this.start_fn.is_some() {\n-        *this.session.entry_fn = this.start_fn;\n-        *this.session.entry_type = Some(session::EntryStart);\n+        this.session.entry_fn.set(this.start_fn);\n+        this.session.entry_type.set(Some(session::EntryStart));\n     } else if this.attr_main_fn.is_some() {\n-        *this.session.entry_fn = this.attr_main_fn;\n-        *this.session.entry_type = Some(session::EntryMain);\n+        this.session.entry_fn.set(this.attr_main_fn);\n+        this.session.entry_type.set(Some(session::EntryMain));\n     } else if this.main_fn.is_some() {\n-        *this.session.entry_fn = this.main_fn;\n-        *this.session.entry_type = Some(session::EntryMain);\n+        this.session.entry_fn.set(this.main_fn);\n+        this.session.entry_type.set(Some(session::EntryMain));\n     } else {\n-        if !*this.session.building_library {\n+        if !this.session.building_library.get() {\n             // No main function\n             this.session.err(\"main function not found\");\n             if !this.non_main_fns.is_empty() {"}, {"sha": "9d7dc6fdc7e8fa42054f3b5ef49dfd2de6f2611f", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -30,11 +30,11 @@ pub struct freevar_entry {\n     span: Span     //< First span where it is accessed (there can be multiple)\n }\n pub type freevar_info = @~[@freevar_entry];\n-pub type freevar_map = @mut HashMap<ast::NodeId, freevar_info>;\n+pub type freevar_map = HashMap<ast::NodeId, freevar_info>;\n \n struct CollectFreevarsVisitor {\n-    seen: @mut HashMap<ast::NodeId, ()>,\n-    refs: @mut ~[@freevar_entry],\n+    seen: HashMap<ast::NodeId, ()>,\n+    refs: ~[@freevar_entry],\n     def_map: resolve::DefMap,\n }\n \n@@ -52,7 +52,8 @@ impl Visitor<int> for CollectFreevarsVisitor {\n               }\n               ast::ExprPath(..) | ast::ExprSelf => {\n                   let mut i = 0;\n-                  match self.def_map.find(&expr.id) {\n+                  let def_map = self.def_map.borrow();\n+                  match def_map.get().find(&expr.id) {\n                     None => fail!(\"path not found\"),\n                     Some(&df) => {\n                       let mut def = df;\n@@ -90,8 +91,8 @@ impl Visitor<int> for CollectFreevarsVisitor {\n // in order to start the search.\n fn collect_freevars(def_map: resolve::DefMap, blk: ast::P<ast::Block>)\n     -> freevar_info {\n-    let seen = @mut HashMap::new();\n-    let refs = @mut ~[];\n+    let seen = HashMap::new();\n+    let refs = ~[];\n \n     let mut v = CollectFreevarsVisitor {\n         seen: seen,\n@@ -100,7 +101,11 @@ fn collect_freevars(def_map: resolve::DefMap, blk: ast::P<ast::Block>)\n     };\n \n     v.visit_block(blk, 1);\n-    return @(*refs).clone();\n+    let CollectFreevarsVisitor {\n+        refs,\n+        ..\n+    } = v;\n+    return @refs;\n }\n \n struct AnnotateFreevarsVisitor {\n@@ -124,21 +129,24 @@ impl Visitor<()> for AnnotateFreevarsVisitor {\n // one pass. This could be improved upon if it turns out to matter.\n pub fn annotate_freevars(def_map: resolve::DefMap, crate: &ast::Crate) ->\n    freevar_map {\n-    let freevars = @mut HashMap::new();\n-\n     let mut visitor = AnnotateFreevarsVisitor {\n         def_map: def_map,\n-        freevars: freevars,\n+        freevars: HashMap::new(),\n     };\n     visit::walk_crate(&mut visitor, crate, ());\n \n-    return freevars;\n+    let AnnotateFreevarsVisitor {\n+        freevars,\n+        ..\n+    } = visitor;\n+    freevars\n }\n \n pub fn get_freevars(tcx: ty::ctxt, fid: ast::NodeId) -> freevar_info {\n-    match tcx.freevars.find(&fid) {\n-      None => fail!(\"get_freevars: {} has no freevars\", fid),\n-      Some(&d) => return d\n+    let freevars = tcx.freevars.borrow();\n+    match freevars.get().find(&fid) {\n+        None => fail!(\"get_freevars: {} has no freevars\", fid),\n+        Some(&d) => return d\n     }\n }\n "}, {"sha": "e426f92759fac4ecac6793771041895b8b0a10b0", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -116,11 +116,18 @@ fn check_struct_safe_for_destructor(cx: &mut Context,\n }\n \n fn check_impl_of_trait(cx: &mut Context, it: @item, trait_ref: &trait_ref, self_type: &Ty) {\n-    let ast_trait_def = cx.tcx.def_map.find(&trait_ref.ref_id)\n-                            .expect(\"trait ref not in def map!\");\n+    let def_map = cx.tcx.def_map.borrow();\n+    let ast_trait_def = def_map.get()\n+                               .find(&trait_ref.ref_id)\n+                               .expect(\"trait ref not in def map!\");\n     let trait_def_id = ast_util::def_id_of_def(*ast_trait_def);\n-    let trait_def = cx.tcx.trait_defs.find(&trait_def_id)\n-                        .expect(\"trait def not in trait-defs map!\");\n+    let trait_def;\n+    {\n+        let trait_defs = cx.tcx.trait_defs.borrow();\n+        trait_def = *trait_defs.get()\n+                               .find(&trait_def_id)\n+                               .expect(\"trait def not in trait-defs map!\");\n+    }\n \n     // If this trait has builtin-kind supertraits, meet them.\n     let self_ty: ty::t = ty::node_id_to_type(cx.tcx, it.id);\n@@ -139,7 +146,7 @@ fn check_impl_of_trait(cx: &mut Context, it: @item, trait_ref: &trait_ref, self_\n         match self_type.node {\n             ty_path(_, ref bounds, path_node_id) => {\n                 assert!(bounds.is_none());\n-                let struct_def = cx.tcx.def_map.get_copy(&path_node_id);\n+                let struct_def = def_map.get().get_copy(&path_node_id);\n                 let struct_did = ast_util::def_id_of_def(struct_def);\n                 check_struct_safe_for_destructor(cx, self_type.span, struct_did);\n             }\n@@ -264,11 +271,14 @@ pub fn check_expr(cx: &mut Context, e: @Expr) {\n         None => e.id,\n     };\n     {\n-        let r = cx.tcx.node_type_substs.find(&type_parameter_id);\n+        let node_type_substs = cx.tcx.node_type_substs.borrow();\n+        let r = node_type_substs.get().find(&type_parameter_id);\n         for ts in r.iter() {\n+            let def_map = cx.tcx.def_map.borrow();\n             let type_param_defs = match e.node {\n               ExprPath(_) => {\n-                let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&e.id));\n+                let did = ast_util::def_id_of_def(def_map.get()\n+                                                         .get_copy(&e.id));\n                 ty::lookup_item_type(cx.tcx, did).generics.type_param_defs\n               }\n               _ => {\n@@ -326,9 +336,11 @@ pub fn check_expr(cx: &mut Context, e: @Expr) {\n fn check_ty(cx: &mut Context, aty: &Ty) {\n     match aty.node {\n       ty_path(_, _, id) => {\n-          let r = cx.tcx.node_type_substs.find(&id);\n+          let node_type_substs = cx.tcx.node_type_substs.borrow();\n+          let r = node_type_substs.get().find(&id);\n           for ts in r.iter() {\n-              let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&id));\n+              let def_map = cx.tcx.def_map.borrow();\n+              let did = ast_util::def_id_of_def(def_map.get().get_copy(&id));\n               let type_param_defs =\n                   ty::lookup_item_type(cx.tcx, did).generics.type_param_defs;\n               for (&ty, type_param_def) in ts.iter().zip(type_param_defs.iter()) {"}, {"sha": "d94bfe1447e019486819152e7e62e7fb9e028df5", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -712,7 +712,8 @@ fn check_item_ctypes(cx: &Context, it: &ast::item) {\n     fn check_ty(cx: &Context, ty: &ast::Ty) {\n         match ty.node {\n             ast::ty_path(_, _, id) => {\n-                match cx.tcx.def_map.get_copy(&id) {\n+                let def_map = cx.tcx.def_map.borrow();\n+                match def_map.get().get_copy(&id) {\n                     ast::DefPrimTy(ast::ty_int(ast::ty_i)) => {\n                         cx.span_lint(ctypes, ty.span,\n                                 \"found rust type `int` in foreign module, while \\\n@@ -983,7 +984,8 @@ fn check_item_non_uppercase_statics(cx: &Context, it: &ast::item) {\n \n fn check_pat_non_uppercase_statics(cx: &Context, p: &ast::Pat) {\n     // Lint for constants that look like binding identifiers (#7526)\n-    match (&p.node, cx.tcx.def_map.find(&p.id)) {\n+    let def_map = cx.tcx.def_map.borrow();\n+    match (&p.node, def_map.get().find(&p.id)) {\n         (&ast::PatIdent(_, ref path, _), Some(&ast::DefStatic(_, false))) => {\n             // last identifier alone is right choice for this lint.\n             let ident = path.segments.last().identifier;\n@@ -1001,8 +1003,9 @@ fn check_unused_unsafe(cx: &Context, e: &ast::Expr) {\n     match e.node {\n         // Don't warn about generated blocks, that'll just pollute the output.\n         ast::ExprBlock(ref blk) => {\n+            let used_unsafe = cx.tcx.used_unsafe.borrow();\n             if blk.rules == ast::UnsafeBlock(ast::UserProvided) &&\n-                !cx.tcx.used_unsafe.contains(&blk.id) {\n+                !used_unsafe.get().contains(&blk.id) {\n                 cx.span_lint(unused_unsafe, blk.span,\n                              \"unnecessary `unsafe` block\");\n             }\n@@ -1037,7 +1040,8 @@ fn check_unused_mut_pat(cx: &Context, p: &ast::Pat) {\n                 }\n             };\n \n-            if !initial_underscore && !cx.tcx.used_mut_nodes.contains(&p.id) {\n+            let used_mut_nodes = cx.tcx.used_mut_nodes.borrow();\n+            if !initial_underscore && !used_mut_nodes.get().contains(&p.id) {\n                 cx.span_lint(unused_mut, p.span,\n                              \"variable does not need to be mutable\");\n             }\n@@ -1073,7 +1077,11 @@ fn check_unnecessary_allocation(cx: &Context, e: &ast::Expr) {\n         cx.span_lint(unnecessary_allocation, e.span, msg);\n     };\n \n-    match cx.tcx.adjustments.find_copy(&e.id) {\n+    let adjustment = {\n+        let adjustments = cx.tcx.adjustments.borrow();\n+        adjustments.get().find_copy(&e.id)\n+    };\n+    match adjustment {\n         Some(@ty::AutoDerefRef(ty::AutoDerefRef { autoref, .. })) => {\n             match (allocation, autoref) {\n                 (VectorAllocation, Some(ty::AutoBorrowVec(..))) => {\n@@ -1141,7 +1149,14 @@ fn check_missing_doc_method(cx: &Context, m: &ast::method) {\n         crate: ast::LOCAL_CRATE,\n         node: m.id\n     };\n-    match cx.tcx.methods.find(&did) {\n+\n+    let method_opt;\n+    {\n+        let methods = cx.tcx.methods.borrow();\n+        method_opt = methods.get().find(&did).map(|method| *method);\n+    }\n+\n+    match method_opt {\n         None => cx.tcx.sess.span_bug(m.span, \"missing method descriptor?!\"),\n         Some(md) => {\n             match md.container {\n@@ -1184,13 +1199,15 @@ fn check_missing_doc_variant(cx: &Context, v: &ast::variant) {\n fn check_stability(cx: &Context, e: &ast::Expr) {\n     let id = match e.node {\n         ast::ExprPath(..) | ast::ExprStruct(..) => {\n-            match cx.tcx.def_map.find(&e.id) {\n+            let def_map = cx.tcx.def_map.borrow();\n+            match def_map.get().find(&e.id) {\n                 Some(&def) => ast_util::def_id_of_def(def),\n                 None => return\n             }\n         }\n         ast::ExprMethodCall(..) => {\n-            match cx.method_map.find(&e.id) {\n+            let method_map = cx.method_map.borrow();\n+            match method_map.get().find(&e.id) {\n                 Some(&typeck::method_map_entry { origin, .. }) => {\n                     match origin {\n                         typeck::method_static(def_id) => {\n@@ -1413,7 +1430,8 @@ impl<'a> Visitor<()> for Context<'a> {\n \n impl<'a> IdVisitingOperation for Context<'a> {\n     fn visit_id(&self, id: ast::NodeId) {\n-        match self.tcx.sess.lints.pop(&id) {\n+        let mut lints = self.tcx.sess.lints.borrow_mut();\n+        match lints.get().pop(&id) {\n             None => {}\n             Some(l) => {\n                 for (lint, span, msg) in l.move_iter() {\n@@ -1465,7 +1483,8 @@ pub fn check_crate(tcx: ty::ctxt,\n \n     // If we missed any lints added to the session, then there's a bug somewhere\n     // in the iteration code.\n-    for (id, v) in tcx.sess.lints.iter() {\n+    let lints = tcx.sess.lints.borrow();\n+    for (id, v) in lints.get().iter() {\n         for &(lint, span, ref msg) in v.iter() {\n             tcx.sess.span_bug(span, format!(\"unprocessed lint {:?} at {}: {}\",\n                                             lint,"}, {"sha": "8532f959a2cd11e1c43a383f48e561a679a38cf9", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 172, "deletions": 111, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -110,6 +110,7 @@ use middle::typeck;\n use middle::moves;\n \n use std::cast::transmute;\n+use std::cell::{Cell, RefCell};\n use std::hashmap::HashMap;\n use std::io;\n use std::str;\n@@ -154,13 +155,13 @@ fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n \n struct LivenessVisitor;\n \n-impl Visitor<@mut IrMaps> for LivenessVisitor {\n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:P<Block>, s:Span, n:NodeId, e:@mut IrMaps) {\n+impl Visitor<@IrMaps> for LivenessVisitor {\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:P<Block>, s:Span, n:NodeId, e:@IrMaps) {\n         visit_fn(self, fk, fd, b, s, n, e);\n     }\n-    fn visit_local(&mut self, l:@Local, e:@mut IrMaps) { visit_local(self, l, e); }\n-    fn visit_expr(&mut self, ex:@Expr, e:@mut IrMaps) { visit_expr(self, ex, e); }\n-    fn visit_arm(&mut self, a:&Arm, e:@mut IrMaps) { visit_arm(self, a, e); }\n+    fn visit_local(&mut self, l:@Local, e:@IrMaps) { visit_local(self, l, e); }\n+    fn visit_expr(&mut self, ex:@Expr, e:@IrMaps) { visit_expr(self, ex, e); }\n+    fn visit_arm(&mut self, a:&Arm, e:@IrMaps) { visit_arm(self, a, e); }\n }\n \n pub fn check_crate(tcx: ty::ctxt,\n@@ -169,9 +170,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                    crate: &Crate) {\n     let mut visitor = LivenessVisitor;\n \n-    let initial_maps = @mut IrMaps(tcx,\n-                                   method_map,\n-                                   capture_map);\n+    let initial_maps = @IrMaps(tcx, method_map, capture_map);\n     visit::walk_crate(&mut visitor, crate, initial_maps);\n     tcx.sess.abort_if_errors();\n }\n@@ -244,13 +243,13 @@ struct IrMaps {\n     method_map: typeck::method_map,\n     capture_map: moves::CaptureMap,\n \n-    num_live_nodes: uint,\n-    num_vars: uint,\n-    live_node_map: HashMap<NodeId, LiveNode>,\n-    variable_map: HashMap<NodeId, Variable>,\n-    capture_info_map: HashMap<NodeId, @~[CaptureInfo]>,\n-    var_kinds: ~[VarKind],\n-    lnks: ~[LiveNodeKind],\n+    num_live_nodes: Cell<uint>,\n+    num_vars: Cell<uint>,\n+    live_node_map: RefCell<HashMap<NodeId, LiveNode>>,\n+    variable_map: RefCell<HashMap<NodeId, Variable>>,\n+    capture_info_map: RefCell<HashMap<NodeId, @~[CaptureInfo]>>,\n+    var_kinds: RefCell<~[VarKind]>,\n+    lnks: RefCell<~[LiveNodeKind]>,\n }\n \n fn IrMaps(tcx: ty::ctxt,\n@@ -261,45 +260,50 @@ fn IrMaps(tcx: ty::ctxt,\n         tcx: tcx,\n         method_map: method_map,\n         capture_map: capture_map,\n-        num_live_nodes: 0,\n-        num_vars: 0,\n-        live_node_map: HashMap::new(),\n-        variable_map: HashMap::new(),\n-        capture_info_map: HashMap::new(),\n-        var_kinds: ~[],\n-        lnks: ~[],\n+        num_live_nodes: Cell::new(0),\n+        num_vars: Cell::new(0),\n+        live_node_map: RefCell::new(HashMap::new()),\n+        variable_map: RefCell::new(HashMap::new()),\n+        capture_info_map: RefCell::new(HashMap::new()),\n+        var_kinds: RefCell::new(~[]),\n+        lnks: RefCell::new(~[]),\n     }\n }\n \n impl IrMaps {\n-    pub fn add_live_node(&mut self, lnk: LiveNodeKind) -> LiveNode {\n-        let ln = LiveNode(self.num_live_nodes);\n-        self.lnks.push(lnk);\n-        self.num_live_nodes += 1;\n+    pub fn add_live_node(&self, lnk: LiveNodeKind) -> LiveNode {\n+        let num_live_nodes = self.num_live_nodes.get();\n+        let ln = LiveNode(num_live_nodes);\n+        let mut lnks = self.lnks.borrow_mut();\n+        lnks.get().push(lnk);\n+        self.num_live_nodes.set(num_live_nodes + 1);\n \n         debug!(\"{} is of kind {}\", ln.to_str(),\n                live_node_kind_to_str(lnk, self.tcx));\n \n         ln\n     }\n \n-    pub fn add_live_node_for_node(&mut self,\n-                                  node_id: NodeId,\n-                                  lnk: LiveNodeKind) {\n+    pub fn add_live_node_for_node(&self, node_id: NodeId, lnk: LiveNodeKind) {\n         let ln = self.add_live_node(lnk);\n-        self.live_node_map.insert(node_id, ln);\n+        let mut live_node_map = self.live_node_map.borrow_mut();\n+        live_node_map.get().insert(node_id, ln);\n \n         debug!(\"{} is node {}\", ln.to_str(), node_id);\n     }\n \n-    pub fn add_variable(&mut self, vk: VarKind) -> Variable {\n-        let v = Variable(self.num_vars);\n-        self.var_kinds.push(vk);\n-        self.num_vars += 1;\n+    pub fn add_variable(&self, vk: VarKind) -> Variable {\n+        let v = Variable(self.num_vars.get());\n+        {\n+            let mut var_kinds = self.var_kinds.borrow_mut();\n+            var_kinds.get().push(vk);\n+        }\n+        self.num_vars.set(self.num_vars.get() + 1);\n \n         match vk {\n             Local(LocalInfo { id: node_id, .. }) | Arg(node_id, _) => {\n-                self.variable_map.insert(node_id, v);\n+                let mut variable_map = self.variable_map.borrow_mut();\n+                variable_map.get().insert(node_id, v);\n             },\n             ImplicitRet => {}\n         }\n@@ -309,8 +313,9 @@ impl IrMaps {\n         v\n     }\n \n-    pub fn variable(&mut self, node_id: NodeId, span: Span) -> Variable {\n-        match self.variable_map.find(&node_id) {\n+    pub fn variable(&self, node_id: NodeId, span: Span) -> Variable {\n+        let variable_map = self.variable_map.borrow();\n+        match variable_map.get().find(&node_id) {\n           Some(&var) => var,\n           None => {\n             self.tcx.sess.span_bug(\n@@ -319,30 +324,34 @@ impl IrMaps {\n         }\n     }\n \n-    pub fn variable_name(&mut self, var: Variable) -> @str {\n-        match self.var_kinds[*var] {\n+    pub fn variable_name(&self, var: Variable) -> @str {\n+        let var_kinds = self.var_kinds.borrow();\n+        match var_kinds.get()[*var] {\n             Local(LocalInfo { ident: nm, .. }) | Arg(_, nm) => {\n                 self.tcx.sess.str_of(nm)\n             },\n             ImplicitRet => @\"<implicit-ret>\"\n         }\n     }\n \n-    pub fn set_captures(&mut self, node_id: NodeId, cs: ~[CaptureInfo]) {\n-        self.capture_info_map.insert(node_id, @cs);\n+    pub fn set_captures(&self, node_id: NodeId, cs: ~[CaptureInfo]) {\n+        let mut capture_info_map = self.capture_info_map.borrow_mut();\n+        capture_info_map.get().insert(node_id, @cs);\n     }\n \n-    pub fn captures(&mut self, expr: &Expr) -> @~[CaptureInfo] {\n-        match self.capture_info_map.find(&expr.id) {\n+    pub fn captures(&self, expr: &Expr) -> @~[CaptureInfo] {\n+        let capture_info_map = self.capture_info_map.borrow();\n+        match capture_info_map.get().find(&expr.id) {\n           Some(&caps) => caps,\n           None => {\n             self.tcx.sess.span_bug(expr.span, \"no registered caps\");\n           }\n         }\n     }\n \n-    pub fn lnk(&mut self, ln: LiveNode) -> LiveNodeKind {\n-        self.lnks[*ln]\n+    pub fn lnk(&self, ln: LiveNode) -> LiveNodeKind {\n+        let lnks = self.lnks.borrow();\n+        lnks.get()[*ln]\n     }\n }\n \n@@ -367,14 +376,12 @@ fn visit_fn(v: &mut LivenessVisitor,\n             body: P<Block>,\n             sp: Span,\n             id: NodeId,\n-            this: @mut IrMaps) {\n+            this: @IrMaps) {\n     debug!(\"visit_fn: id={}\", id);\n     let _i = ::util::common::indenter();\n \n     // swap in a new set of IR maps for this function body:\n-    let fn_maps = @mut IrMaps(this.tcx,\n-                              this.method_map,\n-                              this.capture_map);\n+    let fn_maps = @IrMaps(this.tcx, this.method_map, this.capture_map);\n \n     unsafe {\n         debug!(\"creating fn_maps: {}\", transmute::<&IrMaps, *IrMaps>(fn_maps));\n@@ -428,7 +435,7 @@ fn visit_fn(v: &mut LivenessVisitor,\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n \n-fn visit_local(v: &mut LivenessVisitor, local: @Local, this: @mut IrMaps) {\n+fn visit_local(v: &mut LivenessVisitor, local: @Local, this: @IrMaps) {\n     let def_map = this.tcx.def_map;\n     pat_util::pat_bindings(def_map, local.pat, |bm, p_id, sp, path| {\n         debug!(\"adding local variable {}\", p_id);\n@@ -452,7 +459,7 @@ fn visit_local(v: &mut LivenessVisitor, local: @Local, this: @mut IrMaps) {\n     visit::walk_local(v, local, this);\n }\n \n-fn visit_arm(v: &mut LivenessVisitor, arm: &Arm, this: @mut IrMaps) {\n+fn visit_arm(v: &mut LivenessVisitor, arm: &Arm, this: @IrMaps) {\n     let def_map = this.tcx.def_map;\n     for pat in arm.pats.iter() {\n         pat_util::pat_bindings(def_map, *pat, |bm, p_id, sp, path| {\n@@ -475,11 +482,12 @@ fn visit_arm(v: &mut LivenessVisitor, arm: &Arm, this: @mut IrMaps) {\n     visit::walk_arm(v, arm, this);\n }\n \n-fn visit_expr(v: &mut LivenessVisitor, expr: @Expr, this: @mut IrMaps) {\n+fn visit_expr(v: &mut LivenessVisitor, expr: @Expr, this: @IrMaps) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       ExprPath(_) | ExprSelf => {\n-        let def = this.tcx.def_map.get_copy(&expr.id);\n+        let def_map = this.tcx.def_map.borrow();\n+        let def = def_map.get().get_copy(&expr.id);\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n         if moves::moved_variable_node_id_from_def(def).is_some() {\n             this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -495,7 +503,8 @@ fn visit_expr(v: &mut LivenessVisitor, expr: @Expr, this: @mut IrMaps) {\n         // being the location that the variable is used.  This results\n         // in better error messages than just pointing at the closure\n         // construction site.\n-        let cvs = this.capture_map.get(&expr.id);\n+        let capture_map = this.capture_map.borrow();\n+        let cvs = capture_map.get().get(&expr.id);\n         let mut call_caps = ~[];\n         for cv in cvs.iter() {\n             match moves::moved_variable_node_id_from_def(cv.def) {\n@@ -576,42 +585,45 @@ static ACC_READ: uint = 1u;\n static ACC_WRITE: uint = 2u;\n static ACC_USE: uint = 4u;\n \n-type LiveNodeMap = @mut HashMap<NodeId, LiveNode>;\n+type LiveNodeMap = @RefCell<HashMap<NodeId, LiveNode>>;\n \n pub struct Liveness {\n     tcx: ty::ctxt,\n-    ir: @mut IrMaps,\n+    ir: @IrMaps,\n     s: Specials,\n-    successors: @mut ~[LiveNode],\n-    users: @mut ~[Users],\n+    successors: @RefCell<~[LiveNode]>,\n+    users: @RefCell<~[Users]>,\n     // The list of node IDs for the nested loop scopes\n     // we're in.\n-    loop_scope: @mut ~[NodeId],\n+    loop_scope: @RefCell<~[NodeId]>,\n     // mappings from loop node ID to LiveNode\n     // (\"break\" label should map to loop node ID,\n     // it probably doesn't now)\n     break_ln: LiveNodeMap,\n     cont_ln: LiveNodeMap\n }\n \n-fn Liveness(ir: @mut IrMaps, specials: Specials) -> Liveness {\n+fn Liveness(ir: @IrMaps, specials: Specials) -> Liveness {\n     Liveness {\n         ir: ir,\n         tcx: ir.tcx,\n         s: specials,\n-        successors: @mut vec::from_elem(ir.num_live_nodes, invalid_node()),\n-        users: @mut vec::from_elem(ir.num_live_nodes * ir.num_vars,\n-                                   invalid_users()),\n-        loop_scope: @mut ~[],\n-        break_ln: @mut HashMap::new(),\n-        cont_ln: @mut HashMap::new()\n+        successors: @RefCell::new(vec::from_elem(ir.num_live_nodes.get(),\n+                                                 invalid_node())),\n+        users: @RefCell::new(vec::from_elem(ir.num_live_nodes.get() *\n+                                            ir.num_vars.get(),\n+                                            invalid_users())),\n+        loop_scope: @RefCell::new(~[]),\n+        break_ln: @RefCell::new(HashMap::new()),\n+        cont_ln: @RefCell::new(HashMap::new()),\n     }\n }\n \n impl Liveness {\n     pub fn live_node(&self, node_id: NodeId, span: Span) -> LiveNode {\n-        let ir: &mut IrMaps = self.ir;\n-        match ir.live_node_map.find(&node_id) {\n+        let ir: &IrMaps = self.ir;\n+        let live_node_map = ir.live_node_map.borrow();\n+        match live_node_map.get().find(&node_id) {\n           Some(&ln) => ln,\n           None => {\n             // This must be a mismatch between the ir_map construction\n@@ -668,13 +680,14 @@ impl Liveness {\n     }\n \n     pub fn idx(&self, ln: LiveNode, var: Variable) -> uint {\n-        *ln * self.ir.num_vars + *var\n+        *ln * self.ir.num_vars.get() + *var\n     }\n \n     pub fn live_on_entry(&self, ln: LiveNode, var: Variable)\n                          -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n-        let reader = self.users[self.idx(ln, var)].reader;\n+        let users = self.users.borrow();\n+        let reader = users.get()[self.idx(ln, var)].reader;\n         if reader.is_valid() {Some(self.ir.lnk(reader))} else {None}\n     }\n \n@@ -683,24 +696,34 @@ impl Liveness {\n     */\n     pub fn live_on_exit(&self, ln: LiveNode, var: Variable)\n                         -> Option<LiveNodeKind> {\n-        self.live_on_entry(self.successors[*ln], var)\n+        let successor = {\n+            let successors = self.successors.borrow();\n+            successors.get()[*ln]\n+        };\n+        self.live_on_entry(successor, var)\n     }\n \n     pub fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n         assert!(ln.is_valid());\n-        self.users[self.idx(ln, var)].used\n+        let users = self.users.borrow();\n+        users.get()[self.idx(ln, var)].used\n     }\n \n     pub fn assigned_on_entry(&self, ln: LiveNode, var: Variable)\n                              -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n-        let writer = self.users[self.idx(ln, var)].writer;\n+        let users = self.users.borrow();\n+        let writer = users.get()[self.idx(ln, var)].writer;\n         if writer.is_valid() {Some(self.ir.lnk(writer))} else {None}\n     }\n \n     pub fn assigned_on_exit(&self, ln: LiveNode, var: Variable)\n                             -> Option<LiveNodeKind> {\n-        self.assigned_on_entry(self.successors[*ln], var)\n+        let successor = {\n+            let successors = self.successors.borrow();\n+            successors.get()[*ln]\n+        };\n+        self.assigned_on_entry(successor, var)\n     }\n \n     pub fn indices2(&self,\n@@ -709,7 +732,7 @@ impl Liveness {\n                     op: |uint, uint|) {\n         let node_base_idx = self.idx(ln, Variable(0u));\n         let succ_base_idx = self.idx(succ_ln, Variable(0u));\n-        for var_idx in range(0u, self.ir.num_vars) {\n+        for var_idx in range(0u, self.ir.num_vars.get()) {\n             op(node_base_idx + var_idx, succ_base_idx + var_idx);\n         }\n     }\n@@ -719,7 +742,7 @@ impl Liveness {\n                       ln: LiveNode,\n                       test: |uint| -> LiveNode) {\n         let node_base_idx = self.idx(ln, Variable(0));\n-        for var_idx in range(0u, self.ir.num_vars) {\n+        for var_idx in range(0u, self.ir.num_vars.get()) {\n             let idx = node_base_idx + var_idx;\n             if test(idx).is_valid() {\n                 write!(wr, \" {}\", Variable(var_idx).to_str());\n@@ -733,17 +756,21 @@ impl Liveness {\n                            sp: Span)\n                            -> NodeId {\n         match opt_label {\n-            Some(_) => // Refers to a labeled loop. Use the results of resolve\n-                      // to find with one\n-                match self.tcx.def_map.find(&id) {\n+            Some(_) => {\n+                // Refers to a labeled loop. Use the results of resolve\n+                // to find with one\n+                let def_map = self.tcx.def_map.borrow();\n+                match def_map.get().find(&id) {\n                     Some(&DefLabel(loop_id)) => loop_id,\n                     _ => self.tcx.sess.span_bug(sp, \"Label on break/loop \\\n                                                      doesn't refer to a loop\")\n-                },\n+                }\n+            }\n             None => {\n                 // Vanilla 'break' or 'loop', so use the enclosing\n                 // loop scope\n-                if self.loop_scope.len() == 0 {\n+                let loop_scope = self.loop_scope.borrow();\n+                if loop_scope.get().len() == 0 {\n                     self.tcx.sess.span_bug(sp, \"break outside loop\");\n                 } else {\n                     // FIXME(#5275): this shouldn't have to be a method...\n@@ -754,23 +781,37 @@ impl Liveness {\n     }\n \n     pub fn last_loop_scope(&self) -> NodeId {\n-        let loop_scope = &mut *self.loop_scope;\n-        *loop_scope.last()\n+        let loop_scope = self.loop_scope.borrow();\n+        *loop_scope.get().last()\n     }\n \n     pub fn ln_str(&self, ln: LiveNode) -> ~str {\n         str::from_utf8_owned(io::mem::with_mem_writer(|wr| {\n             let wr = wr as &mut io::Writer;\n-            write!(wr, \"[ln({}) of kind {:?} reads\", *ln, self.ir.lnks[*ln]);\n-            self.write_vars(wr, ln, |idx| self.users[idx].reader );\n+            {\n+                let lnks = self.ir.lnks.borrow();\n+                write!(wr,\n+                       \"[ln({}) of kind {:?} reads\",\n+                       *ln,\n+                       lnks.get()[*ln]);\n+            }\n+            let users = self.users.borrow();\n+            self.write_vars(wr, ln, |idx| users.get()[idx].reader);\n             write!(wr, \"  writes\");\n-            self.write_vars(wr, ln, |idx| self.users[idx].writer );\n-            write!(wr, \"  precedes {}]\", self.successors[*ln].to_str());\n+            self.write_vars(wr, ln, |idx| users.get()[idx].writer);\n+            let successor = {\n+                let successors = self.successors.borrow();\n+                successors.get()[*ln]\n+            };\n+            write!(wr, \"  precedes {}]\", successor.to_str());\n         }))\n     }\n \n     pub fn init_empty(&self, ln: LiveNode, succ_ln: LiveNode) {\n-        self.successors[*ln] = succ_ln;\n+        {\n+            let mut successors = self.successors.borrow_mut();\n+            successors.get()[*ln] = succ_ln;\n+        }\n \n         // It is not necessary to initialize the\n         // values to empty because this is the value\n@@ -784,9 +825,14 @@ impl Liveness {\n \n     pub fn init_from_succ(&self, ln: LiveNode, succ_ln: LiveNode) {\n         // more efficient version of init_empty() / merge_from_succ()\n-        self.successors[*ln] = succ_ln;\n+        {\n+            let mut successors = self.successors.borrow_mut();\n+            successors.get()[*ln] = succ_ln;\n+        }\n+\n         self.indices2(ln, succ_ln, |idx, succ_idx| {\n-            self.users[idx] = self.users[succ_idx]\n+            let mut users = self.users.borrow_mut();\n+            users.get()[idx] = users.get()[succ_idx]\n         });\n         debug!(\"init_from_succ(ln={}, succ={})\",\n                self.ln_str(ln), self.ln_str(succ_ln));\n@@ -801,13 +847,13 @@ impl Liveness {\n \n         let mut changed = false;\n         self.indices2(ln, succ_ln, |idx, succ_idx| {\n-            let users = &mut *self.users;\n-            changed |= copy_if_invalid(users[succ_idx].reader,\n-                                       &mut users[idx].reader);\n-            changed |= copy_if_invalid(users[succ_idx].writer,\n-                                       &mut users[idx].writer);\n-            if users[succ_idx].used && !users[idx].used {\n-                users[idx].used = true;\n+            let mut users = self.users.borrow_mut();\n+            changed |= copy_if_invalid(users.get()[succ_idx].reader,\n+                                       &mut users.get()[idx].reader);\n+            changed |= copy_if_invalid(users.get()[succ_idx].writer,\n+                                       &mut users.get()[idx].writer);\n+            if users.get()[succ_idx].used && !users.get()[idx].used {\n+                users.get()[idx].used = true;\n                 changed = true;\n             }\n         });\n@@ -832,8 +878,9 @@ impl Liveness {\n     // this) so we just clear out all the data.\n     pub fn define(&self, writer: LiveNode, var: Variable) {\n         let idx = self.idx(writer, var);\n-        self.users[idx].reader = invalid_node();\n-        self.users[idx].writer = invalid_node();\n+        let mut users = self.users.borrow_mut();\n+        users.get()[idx].reader = invalid_node();\n+        users.get()[idx].writer = invalid_node();\n \n         debug!(\"{} defines {} (idx={}): {}\", writer.to_str(), var.to_str(),\n                idx, self.ln_str(writer));\n@@ -842,8 +889,8 @@ impl Liveness {\n     // Either read, write, or both depending on the acc bitset\n     pub fn acc(&self, ln: LiveNode, var: Variable, acc: uint) {\n         let idx = self.idx(ln, var);\n-        let users = &mut *self.users;\n-        let user = &mut users[idx];\n+        let mut users = self.users.borrow_mut();\n+        let user = &mut users.get()[idx];\n \n         if (acc & ACC_WRITE) != 0 {\n             user.reader = invalid_node();\n@@ -881,7 +928,7 @@ impl Liveness {\n         // hack to skip the loop unless debug! is enabled:\n         debug!(\"^^ liveness computation results for body {} (entry={})\",\n                {\n-                   for ln_idx in range(0u, self.ir.num_live_nodes) {\n+                   for ln_idx in range(0u, self.ir.num_live_nodes.get()) {\n                        debug!(\"{}\", self.ln_str(LiveNode(ln_idx)));\n                    }\n                    body.id\n@@ -1090,7 +1137,8 @@ impl Liveness {\n               // Now that we know the label we're going to,\n               // look it up in the break loop nodes table\n \n-              match self.break_ln.find(&sc) {\n+              let break_ln = self.break_ln.borrow();\n+              match break_ln.get().find(&sc) {\n                   Some(&b) => b,\n                   None => self.tcx.sess.span_bug(expr.span,\n                                                  \"Break to unknown label\")\n@@ -1104,7 +1152,8 @@ impl Liveness {\n               // Now that we know the label we're going to,\n               // look it up in the continue loop nodes table\n \n-              match self.cont_ln.find(&sc) {\n+              let cont_ln = self.cont_ln.borrow();\n+              match cont_ln.get().find(&sc) {\n                   Some(&b) => b,\n                   None => self.tcx.sess.span_bug(expr.span,\n                                                  \"Loop to unknown label\")\n@@ -1299,7 +1348,8 @@ impl Liveness {\n \n     pub fn access_path(&self, expr: &Expr, succ: LiveNode, acc: uint)\n                        -> LiveNode {\n-        let def = self.tcx.def_map.get_copy(&expr.id);\n+        let def_map = self.tcx.def_map.borrow();\n+        let def = def_map.get().get_copy(&expr.id);\n         match moves::moved_variable_node_id_from_def(def) {\n           Some(nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n@@ -1380,12 +1430,22 @@ impl Liveness {\n                            cont_ln: LiveNode,\n                            f: || -> R)\n                            -> R {\n-      debug!(\"with_loop_nodes: {} {}\", loop_node_id, *break_ln);\n-        self.loop_scope.push(loop_node_id);\n-        self.break_ln.insert(loop_node_id, break_ln);\n-        self.cont_ln.insert(loop_node_id, cont_ln);\n+        debug!(\"with_loop_nodes: {} {}\", loop_node_id, *break_ln);\n+        {\n+            let mut loop_scope = self.loop_scope.borrow_mut();\n+            loop_scope.get().push(loop_node_id);\n+        }\n+        {\n+            let mut this_break_ln = self.break_ln.borrow_mut();\n+            let mut this_cont_ln = self.cont_ln.borrow_mut();\n+            this_break_ln.get().insert(loop_node_id, break_ln);\n+            this_cont_ln.get().insert(loop_node_id, cont_ln);\n+        }\n         let r = f();\n-        self.loop_scope.pop();\n+        {\n+            let mut loop_scope = self.loop_scope.borrow_mut();\n+            loop_scope.get().pop();\n+        }\n         r\n     }\n }\n@@ -1517,7 +1577,8 @@ impl Liveness {\n     pub fn check_lvalue(&mut self, expr: @Expr) {\n         match expr.node {\n           ExprPath(_) => {\n-            match self.tcx.def_map.get_copy(&expr.id) {\n+            let def_map = self.tcx.def_map.borrow();\n+            match def_map.get().get_copy(&expr.id) {\n               DefLocal(nid, _) => {\n                 // Assignment to an immutable variable or argument: only legal\n                 // if there is no later assignment. If this local is actually"}, {"sha": "b39ddecf8c4f6c2759b1d666a93eb1a824efa5eb", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -340,7 +340,8 @@ impl mem_categorization_ctxt {\n     }\n \n     pub fn cat_expr(&self, expr: @ast::Expr) -> cmt {\n-        match self.tcx.adjustments.find(&expr.id) {\n+        let adjustments = self.tcx.adjustments.borrow();\n+        match adjustments.get().find(&expr.id) {\n             None => {\n                 // No adjustments.\n                 self.cat_expr_unadjusted(expr)\n@@ -389,7 +390,8 @@ impl mem_categorization_ctxt {\n         let expr_ty = self.expr_ty(expr);\n         match expr.node {\n           ast::ExprUnary(_, ast::UnDeref, e_base) => {\n-            if self.method_map.contains_key(&expr.id) {\n+            let method_map = self.method_map.borrow();\n+            if method_map.get().contains_key(&expr.id) {\n                 return self.cat_rvalue_node(expr, expr_ty);\n             }\n \n@@ -400,14 +402,16 @@ impl mem_categorization_ctxt {\n           ast::ExprField(base, f_name, _) => {\n             // Method calls are now a special syntactic form,\n             // so `a.b` should always be a field.\n-            assert!(!self.method_map.contains_key(&expr.id));\n+            let method_map = self.method_map.borrow();\n+            assert!(!method_map.get().contains_key(&expr.id));\n \n             let base_cmt = self.cat_expr(base);\n             self.cat_field(expr, base_cmt, f_name, self.expr_ty(expr))\n           }\n \n           ast::ExprIndex(_, base, _) => {\n-            if self.method_map.contains_key(&expr.id) {\n+            let method_map = self.method_map.borrow();\n+            if method_map.get().contains_key(&expr.id) {\n                 return self.cat_rvalue_node(expr, expr_ty);\n             }\n \n@@ -416,7 +420,8 @@ impl mem_categorization_ctxt {\n           }\n \n           ast::ExprPath(_) | ast::ExprSelf => {\n-            let def = self.tcx.def_map.get_copy(&expr.id);\n+            let def_map = self.tcx.def_map.borrow();\n+            let def = def_map.get().get_copy(&expr.id);\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n@@ -884,7 +889,8 @@ impl mem_categorization_ctxt {\n             // variant(..)\n           }\n           ast::PatEnum(_, Some(ref subpats)) => {\n-            match self.tcx.def_map.find(&pat.id) {\n+            let def_map = self.tcx.def_map.borrow();\n+            match def_map.get().find(&pat.id) {\n                 Some(&ast::DefVariant(enum_did, _, _)) => {\n                     // variant(x, y, z)\n \n@@ -1070,7 +1076,8 @@ pub fn field_mutbl(tcx: ty::ctxt,\n         }\n       }\n       ty::ty_enum(..) => {\n-        match tcx.def_map.get_copy(&node_id) {\n+        let def_map = tcx.def_map.borrow();\n+        match def_map.get().get_copy(&node_id) {\n           ast::DefVariant(_, variant_id, _) => {\n             let r = ty::lookup_struct_fields(tcx, variant_id);\n             for fld in r.iter() {"}, {"sha": "f4f0c5c8073d545099ff7ad0ef10f904b96afef2", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 45, "deletions": 19, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -130,13 +130,14 @@ and so on.\n use middle::pat_util::{pat_bindings};\n use middle::freevars;\n use middle::ty;\n-use middle::typeck::{method_map};\n+use middle::typeck::method_map;\n use util::ppaux;\n use util::ppaux::Repr;\n use util::common::indenter;\n use util::ppaux::UserString;\n \n use std::at_vec;\n+use std::cell::RefCell;\n use std::hashmap::{HashSet, HashMap};\n use syntax::ast::*;\n use syntax::ast_util;\n@@ -158,17 +159,17 @@ pub struct CaptureVar {\n     mode: CaptureMode // How variable is being accessed\n }\n \n-pub type CaptureMap = @mut HashMap<NodeId, @[CaptureVar]>;\n+pub type CaptureMap = @RefCell<HashMap<NodeId, @[CaptureVar]>>;\n \n-pub type MovesMap = @mut HashSet<NodeId>;\n+pub type MovesMap = @RefCell<HashSet<NodeId>>;\n \n /**\n  * Set of variable node-ids that are moved.\n  *\n  * Note: The `VariableMovesMap` stores expression ids that\n  * are moves, whereas this set stores the ids of the variables\n  * that are moved at some point */\n-pub type MovedVariablesSet = @mut HashSet<NodeId>;\n+pub type MovedVariablesSet = @RefCell<HashSet<NodeId>>;\n \n /** See the section Output on the module comment for explanation. */\n #[deriving(Clone)]\n@@ -214,9 +215,9 @@ pub fn compute_moves(tcx: ty::ctxt,\n         tcx: tcx,\n         method_map: method_map,\n         move_maps: MoveMaps {\n-            moves_map: @mut HashSet::new(),\n-            capture_map: @mut HashMap::new(),\n-            moved_variables_set: @mut HashSet::new()\n+            moves_map: @RefCell::new(HashSet::new()),\n+            capture_map: @RefCell::new(HashMap::new()),\n+            moved_variables_set: @RefCell::new(HashSet::new())\n         }\n     };\n     let visit_cx = &mut visit_cx;\n@@ -282,7 +283,10 @@ impl VisitContext {\n \n         let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n         if ty::type_moves_by_default(self.tcx, expr_ty) {\n-            self.move_maps.moves_map.insert(expr.id);\n+            {\n+                let mut moves_map = self.move_maps.moves_map.borrow_mut();\n+                moves_map.get().insert(expr.id);\n+            }\n             self.use_expr(expr, Move);\n         } else {\n             self.use_expr(expr, Read);\n@@ -321,11 +325,14 @@ impl VisitContext {\n         // `expr_mode` refers to the post-adjustment value.  If one of\n         // those adjustments is to take a reference, then it's only\n         // reading the underlying expression, not moving it.\n-        let comp_mode = match self.tcx.adjustments.find(&expr.id) {\n-            Some(&@ty::AutoDerefRef(\n-                ty::AutoDerefRef {\n-                    autoref: Some(_), ..})) => Read,\n-            _ => expr_mode\n+        let comp_mode = {\n+            let adjustments = self.tcx.adjustments.borrow();\n+            match adjustments.get().find(&expr.id) {\n+                Some(&@ty::AutoDerefRef(\n+                    ty::AutoDerefRef {\n+                        autoref: Some(_), ..})) => Read,\n+                _ => expr_mode\n+            }\n         };\n \n         debug!(\"comp_mode = {:?}\", comp_mode);\n@@ -334,10 +341,15 @@ impl VisitContext {\n             ExprPath(..) | ExprSelf => {\n                 match comp_mode {\n                     Move => {\n-                        let def = self.tcx.def_map.get_copy(&expr.id);\n+                        let def_map = self.tcx.def_map.borrow();\n+                        let def = def_map.get().get_copy(&expr.id);\n                         let r = moved_variable_node_id_from_def(def);\n                         for &id in r.iter() {\n-                            self.move_maps.moved_variables_set.insert(id);\n+                            let mut moved_variables_set =\n+                                self.move_maps\n+                                    .moved_variables_set\n+                                    .borrow_mut();\n+                            moved_variables_set.get().insert(id);\n                         }\n                     }\n                     Read => {}\n@@ -384,7 +396,12 @@ impl VisitContext {\n                 // closures should be noncopyable, they shouldn't move by default;\n                 // calling a closure should only consume it if it's once.\n                 if mode == Move {\n-                    self.move_maps.moves_map.insert(callee.id);\n+                    {\n+                        let mut moves_map = self.move_maps\n+                                                .moves_map\n+                                                .borrow_mut();\n+                        moves_map.get().insert(callee.id);\n+                    }\n                 }\n                 self.use_expr(callee, mode);\n                 self.use_fn_args(callee.id, *args);\n@@ -561,7 +578,12 @@ impl VisitContext {\n                     self.use_pat(a.pat);\n                 }\n                 let cap_vars = self.compute_captures(expr.id);\n-                self.move_maps.capture_map.insert(expr.id, cap_vars);\n+                {\n+                    let mut capture_map = self.move_maps\n+                                              .capture_map\n+                                              .borrow_mut();\n+                    capture_map.get().insert(expr.id, cap_vars);\n+                }\n                 self.consume_block(body);\n             }\n \n@@ -582,7 +604,8 @@ impl VisitContext {\n                                    receiver_expr: @Expr,\n                                    arg_exprs: &[@Expr])\n                                    -> bool {\n-        if !self.method_map.contains_key(&expr.id) {\n+        let method_map = self.method_map.borrow();\n+        if !method_map.get().contains_key(&expr.id) {\n             return false;\n         }\n \n@@ -633,7 +656,10 @@ impl VisitContext {\n                    id, bm, binding_moves);\n \n             if binding_moves {\n-                self.move_maps.moves_map.insert(id);\n+                {\n+                    let mut moves_map = self.move_maps.moves_map.borrow_mut();\n+                    moves_map.get().insert(id);\n+                }\n             }\n         })\n     }"}, {"sha": "85217a7d55ece2d75ab5b1a69bdd70439a624b52", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -31,7 +31,8 @@ pub fn pat_id_map(dm: resolve::DefMap, pat: &Pat) -> PatIdMap {\n pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n         PatEnum(_, _) | PatIdent(_, _, None) | PatStruct(..) => {\n-            match dm.find(&pat.id) {\n+            let dm = dm.borrow();\n+            match dm.get().find(&pat.id) {\n                 Some(&DefVariant(..)) | Some(&DefStruct(..)) => true,\n                 _ => false\n             }\n@@ -43,7 +44,8 @@ pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: &Pat) -> bool {\n pub fn pat_is_const(dm: resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n         PatIdent(_, _, None) | PatEnum(..) => {\n-            match dm.find(&pat.id) {\n+            let dm = dm.borrow();\n+            match dm.get().find(&pat.id) {\n                 Some(&DefStatic(_, false)) => true,\n                 _ => false\n             }"}, {"sha": "707446a78fe217473f9ea3f2294ceecb0cf9507f", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -220,7 +220,8 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n             ast::item_impl(_, _, ref ty, ref methods) => {\n                 let public_ty = match ty.node {\n                     ast::ty_path(_, _, id) => {\n-                        match self.tcx.def_map.get_copy(&id) {\n+                        let def_map = self.tcx.def_map.borrow();\n+                        match def_map.get().get_copy(&id) {\n                             ast::DefPrimTy(..) => true,\n                             def => {\n                                 let did = def_id_of_def(def);\n@@ -293,8 +294,9 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n         // This code is here instead of in visit_item so that the\n         // crate module gets processed as well.\n         if self.prev_exported {\n-            assert!(self.exp_map2.contains_key(&id), \"wut {:?}\", id);\n-            for export in self.exp_map2.get(&id).iter() {\n+            let exp_map2 = self.exp_map2.borrow();\n+            assert!(exp_map2.get().contains_key(&id), \"wut {:?}\", id);\n+            for export in exp_map2.get().get(&id).iter() {\n                 if is_local(export.def_id) && export.reexport {\n                     self.reexports.insert(export.def_id.node);\n                 }\n@@ -340,7 +342,9 @@ impl<'a> PrivacyVisitor<'a> {\n                 return Allowable;\n             }\n             debug!(\"privacy - is {:?} a public method\", did);\n-            return match self.tcx.methods.find(&did) {\n+\n+            let methods = self.tcx.methods.borrow();\n+            return match methods.get().find(&did) {\n                 Some(meth) => {\n                     debug!(\"privacy - well at least it's a method: {:?}\", meth);\n                     match meth.container {\n@@ -556,7 +560,8 @@ impl<'a> PrivacyVisitor<'a> {\n     // Checks that a path is in scope.\n     fn check_path(&mut self, span: Span, path_id: ast::NodeId, path: &ast::Path) {\n         debug!(\"privacy - path {}\", self.nodestr(path_id));\n-        let def = self.tcx.def_map.get_copy(&path_id);\n+        let def_map = self.tcx.def_map.borrow();\n+        let def = def_map.get().get_copy(&path_id);\n         let ck = |tyname: &str| {\n             let origdid = def_id_of_def(def);\n             match *self.last_private_map.get(&path_id) {\n@@ -569,7 +574,8 @@ impl<'a> PrivacyVisitor<'a> {\n                 }\n             }\n         };\n-        match self.tcx.def_map.get_copy(&path_id) {\n+        let def_map = self.tcx.def_map.borrow();\n+        match def_map.get().get_copy(&path_id) {\n             ast::DefStaticMethod(..) => ck(\"static method\"),\n             ast::DefFn(..) => ck(\"function\"),\n             ast::DefStatic(..) => ck(\"static\"),\n@@ -619,7 +625,8 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n             ast::ExprField(base, ident, _) => {\n                 // Method calls are now a special syntactic form,\n                 // so `a.b` should always be a field.\n-                assert!(!self.method_map.contains_key(&expr.id));\n+                let method_map = self.method_map.borrow();\n+                assert!(!method_map.get().contains_key(&expr.id));\n \n                 // With type_autoderef, make sure we don't\n                 // allow pointers to violate privacy\n@@ -638,7 +645,8 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                                            ty::expr_ty(self.tcx, base));\n                 match ty::get(t).sty {\n                     ty::ty_enum(_, _) | ty::ty_struct(_, _) => {\n-                        let entry = match self.method_map.find(&expr.id) {\n+                        let method_map = self.method_map.borrow();\n+                        let entry = match method_map.get().find(&expr.id) {\n                             None => {\n                                 self.tcx.sess.span_bug(expr.span,\n                                                        \"method call not in \\\n@@ -660,7 +668,8 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n-                        match self.tcx.def_map.get_copy(&expr.id) {\n+                        let def_map = self.tcx.def_map.borrow();\n+                        match def_map.get().get_copy(&expr.id) {\n                             ast::DefVariant(_, variant_id, _) => {\n                                 for field in fields.iter() {\n                                     self.check_field(expr.span, variant_id,\n@@ -745,7 +754,8 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n-                        match self.tcx.def_map.find(&pattern.id) {\n+                        let def_map = self.tcx.def_map.borrow();\n+                        match def_map.get().find(&pattern.id) {\n                             Some(&ast::DefVariant(_, variant_id, _)) => {\n                                 for field in fields.iter() {\n                                     self.check_field(pattern.span, variant_id,"}, {"sha": "bbf366c0b061f0ff2c8bd0667c36c8d9958a92d5", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 60, "deletions": 26, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -19,6 +19,7 @@ use middle::ty;\n use middle::typeck;\n use middle::privacy;\n \n+use std::cell::RefCell;\n use std::hashmap::HashSet;\n use syntax::ast;\n use syntax::ast_map;\n@@ -84,17 +85,17 @@ struct ReachableContext {\n     // methods they've been resolved to.\n     method_map: typeck::method_map,\n     // The set of items which must be exported in the linkage sense.\n-    reachable_symbols: @mut HashSet<ast::NodeId>,\n+    reachable_symbols: @RefCell<HashSet<ast::NodeId>>,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n     // and will be scanned for further references.\n-    worklist: @mut ~[ast::NodeId],\n+    worklist: @RefCell<~[ast::NodeId]>,\n }\n \n struct MarkSymbolVisitor {\n-    worklist: @mut ~[ast::NodeId],\n+    worklist: @RefCell<~[ast::NodeId]>,\n     method_map: typeck::method_map,\n     tcx: ty::ctxt,\n-    reachable_symbols: @mut HashSet<ast::NodeId>,\n+    reachable_symbols: @RefCell<HashSet<ast::NodeId>>,\n }\n \n impl Visitor<()> for MarkSymbolVisitor {\n@@ -103,7 +104,8 @@ impl Visitor<()> for MarkSymbolVisitor {\n \n         match expr.node {\n             ast::ExprPath(_) => {\n-                let def = match self.tcx.def_map.find(&expr.id) {\n+                let def_map = self.tcx.def_map.borrow();\n+                let def = match def_map.get().find(&expr.id) {\n                     Some(&def) => def,\n                     None => {\n                         self.tcx.sess.span_bug(expr.span,\n@@ -115,28 +117,35 @@ impl Visitor<()> for MarkSymbolVisitor {\n                 if is_local(def_id) {\n                     if ReachableContext::\n                         def_id_represents_local_inlined_item(self.tcx, def_id) {\n-                            self.worklist.push(def_id.node)\n+                            {\n+                                let mut worklist = self.worklist.borrow_mut();\n+                                worklist.get().push(def_id.node)\n+                            }\n                     } else {\n                         match def {\n                             // If this path leads to a static, then we may have\n                             // to do some work to figure out whether the static\n                             // is indeed reachable (address_insignificant\n                             // statics are *never* reachable).\n                             ast::DefStatic(..) => {\n-                                self.worklist.push(def_id.node);\n+                                let mut worklist = self.worklist.borrow_mut();\n+                                worklist.get().push(def_id.node);\n                             }\n \n                             // If this wasn't a static, then this destination is\n                             // surely reachable.\n                             _ => {\n-                                self.reachable_symbols.insert(def_id.node);\n+                                let mut reachable_symbols =\n+                                    self.reachable_symbols.borrow_mut();\n+                                reachable_symbols.get().insert(def_id.node);\n                             }\n                         }\n                     }\n                 }\n             }\n             ast::ExprMethodCall(..) => {\n-                match self.method_map.find(&expr.id) {\n+                let method_map = self.method_map.borrow();\n+                match method_map.get().find(&expr.id) {\n                     Some(&typeck::method_map_entry {\n                         origin: typeck::method_static(def_id),\n                         ..\n@@ -146,9 +155,17 @@ impl Visitor<()> for MarkSymbolVisitor {\n                                 def_id_represents_local_inlined_item(\n                                     self.tcx,\n                                     def_id) {\n-                                    self.worklist.push(def_id.node)\n+                                {\n+                                    let mut worklist = self.worklist\n+                                                           .borrow_mut();\n+                                    worklist.get().push(def_id.node)\n                                 }\n-                            self.reachable_symbols.insert(def_id.node);\n+                            }\n+                            {\n+                                let mut reachable_symbols =\n+                                    self.reachable_symbols.borrow_mut();\n+                                reachable_symbols.get().insert(def_id.node);\n+                            }\n                         }\n                     }\n                     Some(_) => {}\n@@ -177,8 +194,8 @@ impl ReachableContext {\n         ReachableContext {\n             tcx: tcx,\n             method_map: method_map,\n-            reachable_symbols: @mut HashSet::new(),\n-            worklist: @mut ~[],\n+            reachable_symbols: @RefCell::new(HashSet::new()),\n+            worklist: @RefCell::new(~[]),\n         }\n     }\n \n@@ -257,11 +274,19 @@ impl ReachableContext {\n     fn propagate(&self) {\n         let mut visitor = self.init_visitor();\n         let mut scanned = HashSet::new();\n-        while self.worklist.len() > 0 {\n-            let search_item = self.worklist.pop();\n-            if scanned.contains(&search_item) {\n-                continue\n-            }\n+        loop {\n+            let search_item = {\n+                let mut worklist = self.worklist.borrow_mut();\n+                if worklist.get().len() == 0 {\n+                    break\n+                }\n+                let search_item = worklist.get().pop();\n+                if scanned.contains(&search_item) {\n+                    continue\n+                }\n+                search_item\n+            };\n+\n             scanned.insert(search_item);\n             match self.tcx.items.find(&search_item) {\n                 Some(item) => self.propagate_node(item, search_item,\n@@ -279,7 +304,7 @@ impl ReachableContext {\n     fn propagate_node(&self, node: &ast_map::ast_node,\n                       search_item: ast::NodeId,\n                       visitor: &mut MarkSymbolVisitor) {\n-        if !*self.tcx.sess.building_library {\n+        if !self.tcx.sess.building_library.get() {\n             // If we are building an executable, then there's no need to flag\n             // anything as external except for `extern fn` types. These\n             // functions may still participate in some form of native interface,\n@@ -289,7 +314,9 @@ impl ReachableContext {\n                 ast_map::node_item(item, _) => {\n                     match item.node {\n                         ast::item_fn(_, ast::extern_fn, _, _, _) => {\n-                            self.reachable_symbols.insert(search_item);\n+                            let mut reachable_symbols =\n+                                self.reachable_symbols.borrow_mut();\n+                            reachable_symbols.get().insert(search_item);\n                         }\n                         _ => {}\n                     }\n@@ -301,7 +328,8 @@ impl ReachableContext {\n             // continue to participate in linkage after this product is\n             // produced. In this case, we traverse the ast node, recursing on\n             // all reachable nodes from this one.\n-            self.reachable_symbols.insert(search_item);\n+            let mut reachable_symbols = self.reachable_symbols.borrow_mut();\n+            reachable_symbols.get().insert(search_item);\n         }\n \n         match *node {\n@@ -318,7 +346,9 @@ impl ReachableContext {\n                     ast::item_static(..) => {\n                         if attr::contains_name(item.attrs,\n                                                \"address_insignificant\") {\n-                            self.reachable_symbols.remove(&search_item);\n+                            let mut reachable_symbols =\n+                                self.reachable_symbols.borrow_mut();\n+                            reachable_symbols.get().remove(&search_item);\n                         }\n                     }\n \n@@ -374,9 +404,12 @@ impl ReachableContext {\n     // this properly would result in the necessity of computing *type*\n     // reachability, which might result in a compile time loss.\n     fn mark_destructors_reachable(&self) {\n-        for (_, destructor_def_id) in self.tcx.destructor_for_type.iter() {\n+        let destructor_for_type = self.tcx.destructor_for_type.borrow();\n+        for (_, destructor_def_id) in destructor_for_type.get().iter() {\n             if destructor_def_id.crate == ast::LOCAL_CRATE {\n-                self.reachable_symbols.insert(destructor_def_id.node);\n+                let mut reachable_symbols = self.reachable_symbols\n+                                                .borrow_mut();\n+                reachable_symbols.get().insert(destructor_def_id.node);\n             }\n         }\n     }\n@@ -385,13 +418,14 @@ impl ReachableContext {\n pub fn find_reachable(tcx: ty::ctxt,\n                       method_map: typeck::method_map,\n                       exported_items: &privacy::ExportedItems)\n-                      -> @mut HashSet<ast::NodeId> {\n+                      -> @RefCell<HashSet<ast::NodeId>> {\n     let reachable_context = ReachableContext::new(tcx, method_map);\n \n     // Step 1: Seed the worklist with all nodes which were found to be public as\n     //         a result of the privacy pass\n     for &id in exported_items.iter() {\n-        reachable_context.worklist.push(id);\n+        let mut worklist = reachable_context.worklist.borrow_mut();\n+        worklist.get().push(id);\n     }\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch."}, {"sha": "3f8f2f35100d7d60ff891720e9fa6631e8d9a9ba", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -25,6 +25,7 @@ use driver::session::Session;\n use middle::ty::{FreeRegion};\n use middle::ty;\n \n+use std::cell::RefCell;\n use std::hashmap::{HashMap, HashSet};\n use syntax::codemap::Span;\n use syntax::{ast, visit};\n@@ -50,9 +51,9 @@ The region maps encode information about region relationships.\n     necessarily how I think things ought to work\n */\n pub struct RegionMaps {\n-    priv scope_map: HashMap<ast::NodeId, ast::NodeId>,\n-    priv free_region_map: HashMap<FreeRegion, ~[FreeRegion]>,\n-    priv cleanup_scopes: HashSet<ast::NodeId>\n+    priv scope_map: RefCell<HashMap<ast::NodeId, ast::NodeId>>,\n+    priv free_region_map: RefCell<HashMap<FreeRegion, ~[FreeRegion]>>,\n+    priv cleanup_scopes: RefCell<HashSet<ast::NodeId>>,\n }\n \n #[deriving(Clone)]\n@@ -68,13 +69,14 @@ struct RegionResolutionVisitor {\n     sess: Session,\n \n     // Generated maps:\n-    region_maps: @mut RegionMaps,\n+    region_maps: @RegionMaps,\n }\n \n \n impl RegionMaps {\n-    pub fn relate_free_regions(&mut self, sub: FreeRegion, sup: FreeRegion) {\n-        match self.free_region_map.find_mut(&sub) {\n+    pub fn relate_free_regions(&self, sub: FreeRegion, sup: FreeRegion) {\n+        let mut free_region_map = self.free_region_map.borrow_mut();\n+        match free_region_map.get().find_mut(&sub) {\n             Some(sups) => {\n                 if !sups.iter().any(|x| x == &sup) {\n                     sups.push(sup);\n@@ -86,49 +88,55 @@ impl RegionMaps {\n \n         debug!(\"relate_free_regions(sub={:?}, sup={:?})\", sub, sup);\n \n-        self.free_region_map.insert(sub, ~[sup]);\n+        free_region_map.get().insert(sub, ~[sup]);\n     }\n \n-    pub fn record_parent(&mut self, sub: ast::NodeId, sup: ast::NodeId) {\n+    pub fn record_parent(&self, sub: ast::NodeId, sup: ast::NodeId) {\n         debug!(\"record_parent(sub={:?}, sup={:?})\", sub, sup);\n         assert!(sub != sup);\n \n-        self.scope_map.insert(sub, sup);\n+        let mut scope_map = self.scope_map.borrow_mut();\n+        scope_map.get().insert(sub, sup);\n     }\n \n-    pub fn record_cleanup_scope(&mut self, scope_id: ast::NodeId) {\n+    pub fn record_cleanup_scope(&self, scope_id: ast::NodeId) {\n         //! Records that a scope is a CLEANUP SCOPE.  This is invoked\n         //! from within regionck.  We wait until regionck because we do\n         //! not know which operators are overloaded until that point,\n         //! and only overloaded operators result in cleanup scopes.\n \n-        self.cleanup_scopes.insert(scope_id);\n+        let mut cleanup_scopes = self.cleanup_scopes.borrow_mut();\n+        cleanup_scopes.get().insert(scope_id);\n     }\n \n     pub fn opt_encl_scope(&self, id: ast::NodeId) -> Option<ast::NodeId> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n \n-        self.scope_map.find(&id).map(|x| *x)\n+        let scope_map = self.scope_map.borrow();\n+        scope_map.get().find(&id).map(|x| *x)\n     }\n \n     pub fn encl_scope(&self, id: ast::NodeId) -> ast::NodeId {\n         //! Returns the narrowest scope that encloses `id`, if any.\n \n-        match self.scope_map.find(&id) {\n+        let scope_map = self.scope_map.borrow();\n+        match scope_map.get().find(&id) {\n             Some(&r) => r,\n             None => { fail!(\"No enclosing scope for id {:?}\", id); }\n         }\n     }\n \n     pub fn is_cleanup_scope(&self, scope_id: ast::NodeId) -> bool {\n-        self.cleanup_scopes.contains(&scope_id)\n+        let cleanup_scopes = self.cleanup_scopes.borrow();\n+        cleanup_scopes.get().contains(&scope_id)\n     }\n \n     pub fn cleanup_scope(&self, expr_id: ast::NodeId) -> ast::NodeId {\n         //! Returns the scope when temps in expr will be cleaned up\n \n         let mut id = self.encl_scope(expr_id);\n-        while !self.cleanup_scopes.contains(&id) {\n+        let cleanup_scopes = self.cleanup_scopes.borrow();\n+        while !cleanup_scopes.get().contains(&id) {\n             id = self.encl_scope(id);\n         }\n         return id;\n@@ -157,7 +165,8 @@ impl RegionMaps {\n \n         let mut s = subscope;\n         while superscope != s {\n-            match self.scope_map.find(&s) {\n+            let scope_map = self.scope_map.borrow();\n+            match scope_map.get().find(&s) {\n                 None => {\n                     debug!(\"is_subscope_of({:?}, {:?}, s={:?})=false\",\n                            subscope, superscope, s);\n@@ -193,7 +202,8 @@ impl RegionMaps {\n         let mut queue = ~[sub];\n         let mut i = 0;\n         while i < queue.len() {\n-            match self.free_region_map.find(&queue[i]) {\n+            let free_region_map = self.free_region_map.borrow();\n+            match free_region_map.get().find(&queue[i]) {\n                 Some(parents) => {\n                     for parent in parents.iter() {\n                         if *parent == sup {\n@@ -298,7 +308,8 @@ impl RegionMaps {\n             let mut result = ~[scope];\n             let mut scope = scope;\n             loop {\n-                match this.scope_map.find(&scope) {\n+                let scope_map = this.scope_map.borrow();\n+                match scope_map.get().find(&scope) {\n                     None => return result,\n                     Some(&superscope) => {\n                         result.push(superscope);\n@@ -493,13 +504,11 @@ impl Visitor<Context> for RegionResolutionVisitor {\n     }\n }\n \n-pub fn resolve_crate(sess: Session,\n-                     crate: &ast::Crate) -> @mut RegionMaps\n-{\n-    let region_maps = @mut RegionMaps {\n-        scope_map: HashMap::new(),\n-        free_region_map: HashMap::new(),\n-        cleanup_scopes: HashSet::new(),\n+pub fn resolve_crate(sess: Session, crate: &ast::Crate) -> @RegionMaps {\n+    let region_maps = @RegionMaps {\n+        scope_map: RefCell::new(HashMap::new()),\n+        free_region_map: RefCell::new(HashMap::new()),\n+        cleanup_scopes: RefCell::new(HashSet::new()),\n     };\n     let cx = Context {parent: None,\n                       var_parent: None};"}, {"sha": "40934b985d346da1bee2f7e7b60ebc337e39d8e6", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 670, "deletions": 444, "changes": 1114, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8"}, {"sha": "d62a58460d043745c1dfb347e956da52ce6484bd", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -18,6 +18,7 @@\n  */\n \n use driver::session;\n+use std::cell::RefCell;\n use std::hashmap::HashMap;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -33,7 +34,7 @@ pub type NamedRegionMap = HashMap<ast::NodeId, ast::DefRegion>;\n \n struct LifetimeContext {\n     sess: session::Session,\n-    named_region_map: @mut NamedRegionMap,\n+    named_region_map: @RefCell<NamedRegionMap>,\n }\n \n enum ScopeChain<'a> {\n@@ -43,12 +44,11 @@ enum ScopeChain<'a> {\n     RootScope\n }\n \n-pub fn crate(sess: session::Session,\n-             crate: &ast::Crate)\n-             -> @mut NamedRegionMap {\n+pub fn crate(sess: session::Session, crate: &ast::Crate)\n+             -> @RefCell<NamedRegionMap> {\n     let mut ctxt = LifetimeContext {\n         sess: sess,\n-        named_region_map: @mut HashMap::new()\n+        named_region_map: @RefCell::new(HashMap::new())\n     };\n     visit::walk_crate(&mut ctxt, crate, &RootScope);\n     sess.abort_if_errors();\n@@ -305,7 +305,8 @@ impl LifetimeContext {\n                                 self.sess.intr()),\n                 lifetime_ref.id,\n                 def);\n-        self.named_region_map.insert(lifetime_ref.id, def);\n+        let mut named_region_map = self.named_region_map.borrow_mut();\n+        named_region_map.get().insert(lifetime_ref.id, def);\n     }\n }\n "}, {"sha": "949a4369f0b3cf1037102947081e11bc5e8c2b6f", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 104, "deletions": 79, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -219,6 +219,7 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::{Repr, vec_map_to_str};\n \n+use std::cell::Cell;\n use std::hashmap::HashMap;\n use std::ptr;\n use std::vec;\n@@ -310,7 +311,7 @@ pub enum opt_result {\n     lower_bound(Result),\n     range_result(Result, Result),\n }\n-fn trans_opt(bcx: @mut Block, o: &Opt) -> opt_result {\n+fn trans_opt(bcx: @Block, o: &Opt) -> opt_result {\n     let _icx = push_ctxt(\"match::trans_opt\");\n     let ccx = bcx.ccx();\n     let bcx = bcx;\n@@ -345,10 +346,11 @@ fn trans_opt(bcx: @mut Block, o: &Opt) -> opt_result {\n     }\n }\n \n-fn variant_opt(bcx: @mut Block, pat_id: ast::NodeId)\n+fn variant_opt(bcx: @Block, pat_id: ast::NodeId)\n     -> Opt {\n     let ccx = bcx.ccx();\n-    match ccx.tcx.def_map.get_copy(&pat_id) {\n+    let def_map = ccx.tcx.def_map.borrow();\n+    match def_map.get().get_copy(&pat_id) {\n         ast::DefVariant(enum_id, var_id, _) => {\n             let variants = ty::enum_variants(ccx.tcx, enum_id);\n             for v in (*variants).iter() {\n@@ -396,7 +398,7 @@ type BindingsMap = HashMap<Ident, BindingInfo>;\n \n #[deriving(Clone)]\n struct ArmData<'a> {\n-    bodycx: @mut Block,\n+    bodycx: @Block,\n     arm: &'a ast::Arm,\n     bindings_map: @BindingsMap\n }\n@@ -435,7 +437,7 @@ fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     return false;\n }\n \n-fn expand_nested_bindings<'r>(bcx: @mut Block,\n+fn expand_nested_bindings<'r>(bcx: @Block,\n                                   m: &[Match<'r>],\n                                   col: uint,\n                                   val: ValueRef)\n@@ -469,7 +471,7 @@ fn expand_nested_bindings<'r>(bcx: @mut Block,\n     })\n }\n \n-fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::Pat) {\n+fn assert_is_binding_or_wild(bcx: @Block, p: @ast::Pat) {\n     if !pat_is_binding_or_wild(bcx.tcx().def_map, p) {\n         bcx.sess().span_bug(\n             p.span,\n@@ -480,7 +482,7 @@ fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::Pat) {\n \n type enter_pat<'a> = 'a |@ast::Pat| -> Option<~[@ast::Pat]>;\n \n-fn enter_match<'r>(bcx: @mut Block,\n+fn enter_match<'r>(bcx: @Block,\n                        dm: DefMap,\n                        m: &[Match<'r>],\n                        col: uint,\n@@ -529,7 +531,7 @@ fn enter_match<'r>(bcx: @mut Block,\n     return result;\n }\n \n-fn enter_default<'r>(bcx: @mut Block,\n+fn enter_default<'r>(bcx: @Block,\n                      dm: DefMap,\n                      m: &[Match<'r>],\n                      col: uint,\n@@ -599,7 +601,7 @@ fn enter_default<'r>(bcx: @mut Block,\n // <nmatsakis> so all patterns must either be records (resp. tuples) or\n //             wildcards\n \n-fn enter_opt<'r>(bcx: @mut Block,\n+fn enter_opt<'r>(bcx: @Block,\n                      m: &[Match<'r>],\n                      opt: &Opt,\n                      col: uint,\n@@ -621,7 +623,10 @@ fn enter_opt<'r>(bcx: @mut Block,\n         let answer = match p.node {\n             ast::PatEnum(..) |\n             ast::PatIdent(_, _, None) if pat_is_const(tcx.def_map, p) => {\n-                let const_def = tcx.def_map.get_copy(&p.id);\n+                let const_def = {\n+                    let def_map = tcx.def_map.borrow();\n+                    def_map.get().get_copy(&p.id)\n+                };\n                 let const_def_id = ast_util::def_id_of_def(const_def);\n                 if opt_eq(tcx, &lit(ConstLit(const_def_id)), opt) {\n                     Some(~[])\n@@ -658,7 +663,11 @@ fn enter_opt<'r>(bcx: @mut Block,\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n                     // Look up the struct variant ID.\n                     let struct_id;\n-                    match tcx.def_map.get_copy(&p.id) {\n+                    let defn = {\n+                        let def_map = tcx.def_map.borrow();\n+                        def_map.get().get_copy(&p.id)\n+                    };\n+                    match defn {\n                         ast::DefVariant(_, found_struct_id, _) => {\n                             struct_id = found_struct_id;\n                         }\n@@ -735,7 +744,7 @@ fn enter_opt<'r>(bcx: @mut Block,\n     })\n }\n \n-fn enter_rec_or_struct<'r>(bcx: @mut Block,\n+fn enter_rec_or_struct<'r>(bcx: @Block,\n                                dm: DefMap,\n                                m: &[Match<'r>],\n                                col: uint,\n@@ -770,7 +779,7 @@ fn enter_rec_or_struct<'r>(bcx: @mut Block,\n     })\n }\n \n-fn enter_tup<'r>(bcx: @mut Block,\n+fn enter_tup<'r>(bcx: @Block,\n                      dm: DefMap,\n                      m: &[Match<'r>],\n                      col: uint,\n@@ -796,7 +805,7 @@ fn enter_tup<'r>(bcx: @mut Block,\n     })\n }\n \n-fn enter_tuple_struct<'r>(bcx: @mut Block,\n+fn enter_tuple_struct<'r>(bcx: @Block,\n                               dm: DefMap,\n                               m: &[Match<'r>],\n                               col: uint,\n@@ -822,7 +831,7 @@ fn enter_tuple_struct<'r>(bcx: @mut Block,\n     })\n }\n \n-fn enter_box<'r>(bcx: @mut Block,\n+fn enter_box<'r>(bcx: @Block,\n                      dm: DefMap,\n                      m: &[Match<'r>],\n                      col: uint,\n@@ -849,7 +858,7 @@ fn enter_box<'r>(bcx: @mut Block,\n     })\n }\n \n-fn enter_uniq<'r>(bcx: @mut Block,\n+fn enter_uniq<'r>(bcx: @Block,\n                       dm: DefMap,\n                       m: &[Match<'r>],\n                       col: uint,\n@@ -876,7 +885,7 @@ fn enter_uniq<'r>(bcx: @mut Block,\n     })\n }\n \n-fn enter_region<'r>(bcx: @mut Block,\n+fn enter_region<'r>(bcx: @Block,\n                         dm: DefMap,\n                         m: &[Match<'r>],\n                         col: uint,\n@@ -906,7 +915,7 @@ fn enter_region<'r>(bcx: @mut Block,\n // Returns the options in one column of matches. An option is something that\n // needs to be conditionally matched at runtime; for example, the discriminant\n // on a set of enum variants or a literal.\n-fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n+fn get_options(bcx: @Block, m: &[Match], col: uint) -> ~[Opt] {\n     let ccx = bcx.ccx();\n     fn add_to_set(tcx: ty::ctxt, set: &mut ~[Opt], val: Opt) {\n         if set.iter().any(|l| opt_eq(tcx, l, &val)) {return;}\n@@ -939,16 +948,20 @@ fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n             ast::PatIdent(..) => {\n                 // This is one of: an enum variant, a unit-like struct, or a\n                 // variable binding.\n-                match ccx.tcx.def_map.find(&cur.id) {\n-                    Some(&ast::DefVariant(..)) => {\n+                let opt_def = {\n+                    let def_map = ccx.tcx.def_map.borrow();\n+                    def_map.get().find_copy(&cur.id)\n+                };\n+                match opt_def {\n+                    Some(ast::DefVariant(..)) => {\n                         add_to_set(ccx.tcx, &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n-                    Some(&ast::DefStruct(..)) => {\n+                    Some(ast::DefStruct(..)) => {\n                         add_to_set(ccx.tcx, &mut found,\n                                    lit(UnitLikeStructLit(cur.id)));\n                     }\n-                    Some(&ast::DefStatic(const_did, false)) => {\n+                    Some(ast::DefStatic(const_did, false)) => {\n                         add_to_set(ccx.tcx, &mut found,\n                                    lit(ConstLit(const_did)));\n                     }\n@@ -958,13 +971,17 @@ fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n             ast::PatEnum(..) | ast::PatStruct(..) => {\n                 // This could be one of: a tuple-like enum variant, a\n                 // struct-like enum variant, or a struct.\n-                match ccx.tcx.def_map.find(&cur.id) {\n-                    Some(&ast::DefFn(..)) |\n-                    Some(&ast::DefVariant(..)) => {\n+                let opt_def = {\n+                    let def_map = ccx.tcx.def_map.borrow();\n+                    def_map.get().find_copy(&cur.id)\n+                };\n+                match opt_def {\n+                    Some(ast::DefFn(..)) |\n+                    Some(ast::DefVariant(..)) => {\n                         add_to_set(ccx.tcx, &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n-                    Some(&ast::DefStatic(const_did, false)) => {\n+                    Some(ast::DefStatic(const_did, false)) => {\n                         add_to_set(ccx.tcx, &mut found,\n                                    lit(ConstLit(const_did)));\n                     }\n@@ -990,10 +1007,10 @@ fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n \n struct ExtractedBlock {\n     vals: ~[ValueRef],\n-    bcx: @mut Block\n+    bcx: @Block\n }\n \n-fn extract_variant_args(bcx: @mut Block,\n+fn extract_variant_args(bcx: @Block,\n                             repr: &adt::Repr,\n                             disr_val: ty::Disr,\n                             val: ValueRef)\n@@ -1006,7 +1023,7 @@ fn extract_variant_args(bcx: @mut Block,\n     ExtractedBlock { vals: args, bcx: bcx }\n }\n \n-fn match_datum(bcx: @mut Block, val: ValueRef, pat_id: ast::NodeId) -> Datum {\n+fn match_datum(bcx: @Block, val: ValueRef, pat_id: ast::NodeId) -> Datum {\n     //! Helper for converting from the ValueRef that we pass around in\n     //! the match code, which is always by ref, into a Datum. Eventually\n     //! we should just pass around a Datum and be done with it.\n@@ -1016,7 +1033,7 @@ fn match_datum(bcx: @mut Block, val: ValueRef, pat_id: ast::NodeId) -> Datum {\n }\n \n \n-fn extract_vec_elems(bcx: @mut Block,\n+fn extract_vec_elems(bcx: @Block,\n                          pat_span: Span,\n                          pat_id: ast::NodeId,\n                          elem_count: uint,\n@@ -1069,7 +1086,7 @@ fn extract_vec_elems(bcx: @mut Block,\n /// Function returns None if there is no struct pattern.\n /// Function doesn't collect fields from struct-like enum variants.\n /// Function can return empty list if there is only wildcard struct pattern.\n-fn collect_record_or_struct_fields(bcx: @mut Block,\n+fn collect_record_or_struct_fields(bcx: @Block,\n                                        m: &[Match],\n                                        col: uint)\n                                     -> Option<~[ast::Ident]> {\n@@ -1105,22 +1122,23 @@ fn collect_record_or_struct_fields(bcx: @mut Block,\n     }\n }\n \n-fn pats_require_rooting(bcx: @mut Block,\n+fn pats_require_rooting(bcx: @Block,\n                             m: &[Match],\n                             col: uint)\n                          -> bool {\n     m.iter().any(|br| {\n         let pat_id = br.pats[col].id;\n         let key = root_map_key {id: pat_id, derefs: 0u };\n-        bcx.ccx().maps.root_map.contains_key(&key)\n+        let root_map = bcx.ccx().maps.root_map.borrow();\n+        root_map.get().contains_key(&key)\n     })\n }\n \n-fn root_pats_as_necessary(mut bcx: @mut Block,\n+fn root_pats_as_necessary(mut bcx: @Block,\n                               m: &[Match],\n                               col: uint,\n                               val: ValueRef)\n-                           -> @mut Block {\n+                           -> @Block {\n     for br in m.iter() {\n         let pat_id = br.pats[col].id;\n         if pat_id != 0 {\n@@ -1163,12 +1181,13 @@ fn any_tup_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::PatTup(_))\n }\n \n-fn any_tuple_struct_pat(bcx: @mut Block, m: &[Match], col: uint) -> bool {\n+fn any_tuple_struct_pat(bcx: @Block, m: &[Match], col: uint) -> bool {\n     m.iter().any(|br| {\n         let pat = br.pats[col];\n         match pat.node {\n             ast::PatEnum(_, Some(_)) => {\n-                match bcx.tcx().def_map.find(&pat.id) {\n+                let def_map = bcx.tcx().def_map.borrow();\n+                match def_map.get().find(&pat.id) {\n                     Some(&ast::DefFn(..)) |\n                     Some(&ast::DefStruct(..)) => true,\n                     _ => false\n@@ -1184,22 +1203,22 @@ trait CustomFailureHandler {\n }\n \n struct DynamicFailureHandler {\n-    bcx: @mut Block,\n+    bcx: @Block,\n     sp: Span,\n     msg: @str,\n-    finished: @mut Option<BasicBlockRef>,\n+    finished: @Cell<Option<BasicBlockRef>>,\n }\n \n impl CustomFailureHandler for DynamicFailureHandler {\n     fn handle_fail(&self) -> BasicBlockRef {\n-        match *self.finished {\n+        match self.finished.get() {\n             Some(bb) => return bb,\n             _ => (),\n         }\n \n         let fail_cx = sub_block(self.bcx, \"case_fallthrough\");\n         controlflow::trans_fail(fail_cx, Some(self.sp), self.msg);\n-        *self.finished = Some(fail_cx.llbb);\n+        self.finished.set(Some(fail_cx.llbb));\n         fail_cx.llbb\n     }\n }\n@@ -1271,7 +1290,7 @@ pub enum branch_kind { no_branch, single, switch, compare, compare_vec_len, }\n // Compiles a comparison between two things.\n //\n // NB: This must produce an i1, not a Rust bool (i8).\n-fn compare_values(cx: @mut Block,\n+fn compare_values(cx: @Block,\n                       lhs: ValueRef,\n                       rhs: ValueRef,\n                       rhs_t: ty::t)\n@@ -1314,10 +1333,10 @@ fn compare_values(cx: @mut Block,\n     }\n }\n \n-fn store_non_ref_bindings(bcx: @mut Block,\n+fn store_non_ref_bindings(bcx: @Block,\n                           bindings_map: &BindingsMap,\n                           mut opt_temp_cleanups: Option<&mut ~[ValueRef]>)\n-                          -> @mut Block\n+                          -> @Block\n {\n     /*!\n      *\n@@ -1348,17 +1367,15 @@ fn store_non_ref_bindings(bcx: @mut Block,\n     return bcx;\n }\n \n-fn insert_lllocals(bcx: @mut Block,\n+fn insert_lllocals(bcx: @Block,\n                    bindings_map: &BindingsMap,\n-                   add_cleans: bool) -> @mut Block {\n+                   add_cleans: bool) -> @Block {\n     /*!\n      * For each binding in `data.bindings_map`, adds an appropriate entry into\n      * the `fcx.lllocals` map.  If add_cleans is true, then adds cleanups for\n      * the bindings.\n      */\n \n-    let llmap = bcx.fcx.lllocals;\n-\n     for (&ident, &binding_info) in bindings_map.iter() {\n         let llval = match binding_info.trmode {\n             // By value bindings: use the stack slot that we\n@@ -1377,8 +1394,13 @@ fn insert_lllocals(bcx: @mut Block,\n             }\n         };\n \n-        debug!(\"binding {:?} to {}\", binding_info.id, bcx.val_to_str(llval));\n-        llmap.insert(binding_info.id, llval);\n+        {\n+            debug!(\"binding {:?} to {}\",\n+                   binding_info.id,\n+                   bcx.val_to_str(llval));\n+            let mut llmap = bcx.fcx.lllocals.borrow_mut();\n+            llmap.get().insert(binding_info.id, llval);\n+        }\n \n         if bcx.sess().opts.extra_debuginfo {\n             debuginfo::create_match_binding_metadata(bcx,\n@@ -1391,13 +1413,13 @@ fn insert_lllocals(bcx: @mut Block,\n     return bcx;\n }\n \n-fn compile_guard(bcx: @mut Block,\n+fn compile_guard(bcx: @Block,\n                      guard_expr: &ast::Expr,\n                      data: &ArmData,\n                      m: &[Match],\n                      vals: &[ValueRef],\n                      chk: FailureHandler)\n-                  -> @mut Block {\n+                  -> @Block {\n     debug!(\"compile_guard(bcx={}, guard_expr={}, m={}, vals={})\",\n            bcx.to_str(),\n            bcx.expr_to_str(guard_expr),\n@@ -1432,7 +1454,7 @@ fn compile_guard(bcx: @mut Block,\n         bcx\n     });\n \n-    fn drop_bindings(bcx: @mut Block, data: &ArmData) -> @mut Block {\n+    fn drop_bindings(bcx: @Block, data: &ArmData) -> @Block {\n         let mut bcx = bcx;\n         for (_, &binding_info) in data.bindings_map.iter() {\n             match binding_info.trmode {\n@@ -1441,13 +1463,14 @@ fn compile_guard(bcx: @mut Block,\n                 }\n                 TrByRef => {}\n             }\n-            bcx.fcx.lllocals.remove(&binding_info.id);\n+            let mut lllocals = bcx.fcx.lllocals.borrow_mut();\n+            lllocals.get().remove(&binding_info.id);\n         }\n         return bcx;\n     }\n }\n \n-fn compile_submatch(bcx: @mut Block,\n+fn compile_submatch(bcx: @Block,\n                     m: &[Match],\n                     vals: &[ValueRef],\n                     chk: FailureHandler) {\n@@ -1499,7 +1522,7 @@ fn compile_submatch(bcx: @mut Block,\n     }\n }\n \n-fn compile_submatch_continue(mut bcx: @mut Block,\n+fn compile_submatch_continue(mut bcx: @Block,\n                              m: &[Match],\n                              vals: &[ValueRef],\n                              chk: FailureHandler,\n@@ -1816,18 +1839,18 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n     }\n }\n \n-pub fn trans_match(bcx: @mut Block,\n+pub fn trans_match(bcx: @Block,\n                    match_expr: &ast::Expr,\n                    discr_expr: &ast::Expr,\n                    arms: &[ast::Arm],\n-                   dest: Dest) -> @mut Block {\n+                   dest: Dest) -> @Block {\n     let _icx = push_ctxt(\"match::trans_match\");\n     with_scope(bcx, match_expr.info(), \"match\", |bcx| {\n         trans_match_inner(bcx, discr_expr, arms, dest)\n     })\n }\n \n-fn create_bindings_map(bcx: @mut Block, pat: @ast::Pat) -> BindingsMap {\n+fn create_bindings_map(bcx: @Block, pat: @ast::Pat) -> BindingsMap {\n     // Create the bindings map, which is a mapping from each binding name\n     // to an alloca() that will be the value for that local variable.\n     // Note that we use the names because each binding will have many ids\n@@ -1867,18 +1890,18 @@ fn create_bindings_map(bcx: @mut Block, pat: @ast::Pat) -> BindingsMap {\n     return bindings_map;\n }\n \n-fn trans_match_inner(scope_cx: @mut Block,\n+fn trans_match_inner(scope_cx: @Block,\n                          discr_expr: &ast::Expr,\n                          arms: &[ast::Arm],\n-                         dest: Dest) -> @mut Block {\n+                         dest: Dest) -> @Block {\n     let _icx = push_ctxt(\"match::trans_match_inner\");\n     let mut bcx = scope_cx;\n     let tcx = bcx.tcx();\n \n     let discr_datum = unpack_datum!(bcx, {\n         expr::trans_to_datum(bcx, discr_expr)\n     });\n-    if bcx.unreachable {\n+    if bcx.unreachable.get() {\n         return bcx;\n     }\n \n@@ -1906,7 +1929,7 @@ fn trans_match_inner(scope_cx: @mut Block,\n     let chk = {\n         if ty::type_is_empty(tcx, t) {\n             // Special case for empty types\n-            let fail_cx = @mut None;\n+            let fail_cx = @Cell::new(None);\n             let fail_handler = @DynamicFailureHandler {\n                 bcx: scope_cx,\n                 sp: discr_expr.span,\n@@ -1952,10 +1975,10 @@ enum IrrefutablePatternBindingMode {\n     BindArgument\n }\n \n-pub fn store_local(bcx: @mut Block,\n+pub fn store_local(bcx: @Block,\n                    pat: @ast::Pat,\n                    opt_init_expr: Option<@ast::Expr>)\n-                   -> @mut Block {\n+                   -> @Block {\n     /*!\n      * Generates code for a local variable declaration like\n      * `let <pat>;` or `let <pat> = <opt_init_expr>`.\n@@ -2006,7 +2029,7 @@ pub fn store_local(bcx: @mut Block,\n         }\n     };\n \n-    fn create_dummy_locals(mut bcx: @mut Block, pat: @ast::Pat) -> @mut Block {\n+    fn create_dummy_locals(mut bcx: @Block, pat: @ast::Pat) -> @Block {\n         // create dummy memory for the variables if we have no\n         // value to store into them immediately\n         let tcx = bcx.tcx();\n@@ -2019,10 +2042,10 @@ pub fn store_local(bcx: @mut Block,\n     }\n }\n \n-pub fn store_arg(mut bcx: @mut Block,\n+pub fn store_arg(mut bcx: @Block,\n                  pat: @ast::Pat,\n                  llval: ValueRef)\n-                 -> @mut Block {\n+                 -> @Block {\n     /*!\n      * Generates code for argument patterns like `fn foo(<pat>: T)`.\n      * Creates entries in the `llargs` map for each of the bindings\n@@ -2056,7 +2079,8 @@ pub fn store_arg(mut bcx: @mut Block,\n         // Optimized path for `x: T` case. This just adopts\n         // `llval` wholesale as the pointer for `x`, avoiding the\n         // general logic which may copy out of `llval`.\n-        bcx.fcx.llargs.insert(pat.id, llval);\n+        let mut llargs = bcx.fcx.llargs.borrow_mut();\n+        llargs.get().insert(pat.id, llval);\n     } else {\n         // General path. Copy out the values that are used in the\n         // pattern.\n@@ -2066,30 +2090,30 @@ pub fn store_arg(mut bcx: @mut Block,\n     return bcx;\n }\n \n-fn mk_binding_alloca(mut bcx: @mut Block,\n+fn mk_binding_alloca(mut bcx: @Block,\n                      p_id: ast::NodeId,\n                      path: &ast::Path,\n                      binding_mode: IrrefutablePatternBindingMode,\n-                     populate: |@mut Block, ty::t, ValueRef| -> @mut Block)\n-                     -> @mut Block {\n+                     populate: |@Block, ty::t, ValueRef| -> @Block)\n+                     -> @Block {\n     let var_ty = node_id_type(bcx, p_id);\n     let ident = ast_util::path_to_ident(path);\n     let llval = alloc_ty(bcx, var_ty, bcx.ident(ident));\n     bcx = populate(bcx, var_ty, llval);\n-    let llmap = match binding_mode {\n-        BindLocal => bcx.fcx.lllocals,\n-        BindArgument => bcx.fcx.llargs\n+    let mut llmap = match binding_mode {\n+        BindLocal => bcx.fcx.lllocals.borrow_mut(),\n+        BindArgument => bcx.fcx.llargs.borrow_mut(),\n     };\n-    llmap.insert(p_id, llval);\n+    llmap.get().insert(p_id, llval);\n     add_clean(bcx, llval, var_ty);\n     return bcx;\n }\n \n-fn bind_irrefutable_pat(bcx: @mut Block,\n+fn bind_irrefutable_pat(bcx: @Block,\n                         pat: @ast::Pat,\n                         val: ValueRef,\n                         binding_mode: IrrefutablePatternBindingMode)\n-                        -> @mut Block {\n+                        -> @Block {\n     /*!\n      * A simple version of the pattern matching code that only handles\n      * irrefutable patterns. This is used in let/argument patterns,\n@@ -2159,7 +2183,8 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n             }\n         }\n         ast::PatEnum(_, ref sub_pats) => {\n-            match bcx.tcx().def_map.find(&pat.id) {\n+            let def_map = bcx.tcx().def_map.borrow();\n+            match def_map.get().find(&pat.id) {\n                 Some(&ast::DefVariant(enum_id, var_id, _)) => {\n                     let repr = adt::represent_node(bcx, pat.id);\n                     let vinfo = ty::enum_variant_with_id(ccx.tcx,"}, {"sha": "5d70a3ad2664cb538231c85d08fde999194ec33a", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 38, "deletions": 33, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -111,24 +111,29 @@ pub struct Struct {\n  * these, for places in trans where the `ty::t` isn't directly\n  * available.\n  */\n-pub fn represent_node(bcx: @mut Block, node: ast::NodeId) -> @Repr {\n+pub fn represent_node(bcx: @Block, node: ast::NodeId) -> @Repr {\n     represent_type(bcx.ccx(), node_id_type(bcx, node))\n }\n \n /// Decides how to represent a given type.\n-pub fn represent_type(cx: &mut CrateContext, t: ty::t) -> @Repr {\n+pub fn represent_type(cx: &CrateContext, t: ty::t) -> @Repr {\n     debug!(\"Representing: {}\", ty_to_str(cx.tcx, t));\n-    match cx.adt_reprs.find(&t) {\n-        Some(repr) => return *repr,\n-        None => { }\n+    {\n+        let adt_reprs = cx.adt_reprs.borrow();\n+        match adt_reprs.get().find(&t) {\n+            Some(repr) => return *repr,\n+            None => {}\n+        }\n     }\n+\n     let repr = @represent_type_uncached(cx, t);\n     debug!(\"Represented as: {:?}\", repr)\n-    cx.adt_reprs.insert(t, repr);\n+    let mut adt_reprs = cx.adt_reprs.borrow_mut();\n+    adt_reprs.get().insert(t, repr);\n     return repr;\n }\n \n-fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n+fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n     match ty::get(t).sty {\n         ty::ty_tup(ref elems) => {\n             return Univariant(mk_struct(cx, *elems, false), false)\n@@ -250,7 +255,7 @@ pub fn is_ffi_safe(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n // this should probably all be in ty\n struct Case { discr: Disr, tys: ~[ty::t] }\n impl Case {\n-    fn is_zerolen(&self, cx: &mut CrateContext) -> bool {\n+    fn is_zerolen(&self, cx: &CrateContext) -> bool {\n         mk_struct(cx, self.tys, false).size == 0\n     }\n     fn find_ptr(&self) -> Option<uint> {\n@@ -268,7 +273,7 @@ fn get_cases(tcx: ty::ctxt, def_id: ast::DefId, substs: &ty::substs) -> ~[Case]\n }\n \n \n-fn mk_struct(cx: &mut CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n+fn mk_struct(cx: &CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n     let lltys = tys.map(|&ty| type_of::sizing_type_of(cx, ty));\n     let llty_rec = Type::struct_(lltys, packed);\n     Struct {\n@@ -286,15 +291,15 @@ struct IntBounds {\n     uhi: u64\n }\n \n-fn mk_cenum(cx: &mut CrateContext, hint: Hint, bounds: &IntBounds) -> Repr {\n+fn mk_cenum(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> Repr {\n     let it = range_to_inttype(cx, hint, bounds);\n     match it {\n         attr::SignedInt(_) => CEnum(it, bounds.slo as Disr, bounds.shi as Disr),\n         attr::UnsignedInt(_) => CEnum(it, bounds.ulo, bounds.uhi)\n     }\n }\n \n-fn range_to_inttype(cx: &mut CrateContext, hint: Hint, bounds: &IntBounds) -> IntType {\n+fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntType {\n     debug!(\"range_to_inttype: {:?} {:?}\", hint, bounds);\n     // Lists of sizes to try.  u64 is always allowed as a fallback.\n     static choose_shortest: &'static[IntType] = &[\n@@ -334,14 +339,14 @@ fn range_to_inttype(cx: &mut CrateContext, hint: Hint, bounds: &IntBounds) -> In\n     return attr::UnsignedInt(ast::ty_u64);\n }\n \n-pub fn ll_inttype(cx: &mut CrateContext, ity: IntType) -> Type {\n+pub fn ll_inttype(cx: &CrateContext, ity: IntType) -> Type {\n     match ity {\n         attr::SignedInt(t) => Type::int_from_ty(cx, t),\n         attr::UnsignedInt(t) => Type::uint_from_ty(cx, t)\n     }\n }\n \n-fn bounds_usable(cx: &mut CrateContext, ity: IntType, bounds: &IntBounds) -> bool {\n+fn bounds_usable(cx: &CrateContext, ity: IntType, bounds: &IntBounds) -> bool {\n     debug!(\"bounds_usable: {:?} {:?}\", ity, bounds);\n     match ity {\n         attr::SignedInt(_) => {\n@@ -375,24 +380,24 @@ pub fn ty_of_inttype(ity: IntType) -> ty::t {\n  * and fill in the actual contents in a second pass to prevent\n  * unbounded recursion; see also the comments in `trans::type_of`.\n  */\n-pub fn type_of(cx: &mut CrateContext, r: &Repr) -> Type {\n+pub fn type_of(cx: &CrateContext, r: &Repr) -> Type {\n     generic_type_of(cx, r, None, false)\n }\n-pub fn sizing_type_of(cx: &mut CrateContext, r: &Repr) -> Type {\n+pub fn sizing_type_of(cx: &CrateContext, r: &Repr) -> Type {\n     generic_type_of(cx, r, None, true)\n }\n-pub fn incomplete_type_of(cx: &mut CrateContext, r: &Repr, name: &str) -> Type {\n+pub fn incomplete_type_of(cx: &CrateContext, r: &Repr, name: &str) -> Type {\n     generic_type_of(cx, r, Some(name), false)\n }\n-pub fn finish_type_of(cx: &mut CrateContext, r: &Repr, llty: &mut Type) {\n+pub fn finish_type_of(cx: &CrateContext, r: &Repr, llty: &mut Type) {\n     match *r {\n         CEnum(..) | General(..) => { }\n         Univariant(ref st, _) | NullablePointer{ nonnull: ref st, .. } =>\n             llty.set_struct_body(struct_llfields(cx, st, false), st.packed)\n     }\n }\n \n-fn generic_type_of(cx: &mut CrateContext, r: &Repr, name: Option<&str>, sizing: bool) -> Type {\n+fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool) -> Type {\n     match *r {\n         CEnum(ity, _, _) => ll_inttype(cx, ity),\n         Univariant(ref st, _) | NullablePointer{ nonnull: ref st, .. } => {\n@@ -444,7 +449,7 @@ fn generic_type_of(cx: &mut CrateContext, r: &Repr, name: Option<&str>, sizing:\n     }\n }\n \n-fn struct_llfields(cx: &mut CrateContext, st: &Struct, sizing: bool) -> ~[Type] {\n+fn struct_llfields(cx: &CrateContext, st: &Struct, sizing: bool) -> ~[Type] {\n     if sizing {\n         st.fields.map(|&ty| type_of::sizing_type_of(cx, ty))\n     } else {\n@@ -458,7 +463,7 @@ fn struct_llfields(cx: &mut CrateContext, st: &Struct, sizing: bool) -> ~[Type]\n  *\n  * This should ideally be less tightly tied to `_match`.\n  */\n-pub fn trans_switch(bcx: @mut Block, r: &Repr, scrutinee: ValueRef)\n+pub fn trans_switch(bcx: @Block, r: &Repr, scrutinee: ValueRef)\n     -> (_match::branch_kind, Option<ValueRef>) {\n     match *r {\n         CEnum(..) | General(..) => {\n@@ -476,7 +481,7 @@ pub fn trans_switch(bcx: @mut Block, r: &Repr, scrutinee: ValueRef)\n \n \n /// Obtain the actual discriminant of a value.\n-pub fn trans_get_discr(bcx: @mut Block, r: &Repr, scrutinee: ValueRef, cast_to: Option<Type>)\n+pub fn trans_get_discr(bcx: @Block, r: &Repr, scrutinee: ValueRef, cast_to: Option<Type>)\n     -> ValueRef {\n     let signed;\n     let val;\n@@ -505,7 +510,7 @@ pub fn trans_get_discr(bcx: @mut Block, r: &Repr, scrutinee: ValueRef, cast_to:\n     }\n }\n \n-fn nullable_bitdiscr(bcx: @mut Block, nonnull: &Struct, nndiscr: Disr, ptrfield: uint,\n+fn nullable_bitdiscr(bcx: @Block, nonnull: &Struct, nndiscr: Disr, ptrfield: uint,\n                      scrutinee: ValueRef) -> ValueRef {\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     let llptr = Load(bcx, GEPi(bcx, scrutinee, [0, ptrfield]));\n@@ -514,7 +519,7 @@ fn nullable_bitdiscr(bcx: @mut Block, nonnull: &Struct, nndiscr: Disr, ptrfield:\n }\n \n /// Helper for cases where the discriminant is simply loaded.\n-fn load_discr(bcx: @mut Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n+fn load_discr(bcx: @Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n     -> ValueRef {\n     let llty = ll_inttype(bcx.ccx(), ity);\n     assert_eq!(val_ty(ptr), llty.ptr_to());\n@@ -542,7 +547,7 @@ fn load_discr(bcx: @mut Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr\n  *\n  * This should ideally be less tightly tied to `_match`.\n  */\n-pub fn trans_case(bcx: @mut Block, r: &Repr, discr: Disr) -> _match::opt_result {\n+pub fn trans_case(bcx: @Block, r: &Repr, discr: Disr) -> _match::opt_result {\n     match *r {\n         CEnum(ity, _, _) => {\n             _match::single_result(rslt(bcx, C_integral(ll_inttype(bcx.ccx(), ity),\n@@ -567,7 +572,7 @@ pub fn trans_case(bcx: @mut Block, r: &Repr, discr: Disr) -> _match::opt_result\n  * representation.  The fields, if any, should then be initialized via\n  * `trans_field_ptr`.\n  */\n-pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr) {\n+pub fn trans_start_init(bcx: @Block, r: &Repr, val: ValueRef, discr: Disr) {\n     match *r {\n         CEnum(ity, min, max) => {\n             assert_discr_in_range(ity, min, max, discr);\n@@ -623,7 +628,7 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n }\n \n /// Access a field, at a point when the value's case is known.\n-pub fn trans_field_ptr(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr,\n+pub fn trans_field_ptr(bcx: @Block, r: &Repr, val: ValueRef, discr: Disr,\n                        ix: uint) -> ValueRef {\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n@@ -656,7 +661,7 @@ pub fn trans_field_ptr(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr,\n     }\n }\n \n-fn struct_field_ptr(bcx: @mut Block, st: &Struct, val: ValueRef, ix: uint,\n+fn struct_field_ptr(bcx: @Block, st: &Struct, val: ValueRef, ix: uint,\n               needs_cast: bool) -> ValueRef {\n     let ccx = bcx.ccx();\n \n@@ -672,7 +677,7 @@ fn struct_field_ptr(bcx: @mut Block, st: &Struct, val: ValueRef, ix: uint,\n }\n \n /// Access the struct drop flag, if present.\n-pub fn trans_drop_flag_ptr(bcx: @mut Block, r: &Repr, val: ValueRef) -> ValueRef {\n+pub fn trans_drop_flag_ptr(bcx: @Block, r: &Repr, val: ValueRef) -> ValueRef {\n     match *r {\n         Univariant(ref st, true) => GEPi(bcx, val, [0, st.fields.len() - 1]),\n         _ => bcx.ccx().sess.bug(\"tried to get drop flag of non-droppable type\")\n@@ -700,7 +705,7 @@ pub fn trans_drop_flag_ptr(bcx: @mut Block, r: &Repr, val: ValueRef) -> ValueRef\n  * this could be changed in the future to avoid allocating unnecessary\n  * space after values of shorter-than-maximum cases.\n  */\n-pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: Disr,\n+pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n                    vals: &[ValueRef]) -> ValueRef {\n     match *r {\n         CEnum(ity, min, max) => {\n@@ -745,7 +750,7 @@ pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: Disr,\n  * a two-element struct will locate it at offset 4, and accesses to it\n  * will read the wrong memory.\n  */\n-fn build_const_struct(ccx: &mut CrateContext, st: &Struct, vals: &[ValueRef])\n+fn build_const_struct(ccx: &CrateContext, st: &Struct, vals: &[ValueRef])\n     -> ~[ValueRef] {\n     assert_eq!(vals.len(), st.fields.len());\n \n@@ -786,7 +791,7 @@ fn padding(size: u64) -> ValueRef {\n fn roundup(x: u64, a: u64) -> u64 { ((x + (a - 1)) / a) * a }\n \n /// Get the discriminant of a constant value.  (Not currently used.)\n-pub fn const_get_discrim(ccx: &mut CrateContext, r: &Repr, val: ValueRef)\n+pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef)\n     -> Disr {\n     match *r {\n         CEnum(ity, _, _) => {\n@@ -820,7 +825,7 @@ pub fn const_get_discrim(ccx: &mut CrateContext, r: &Repr, val: ValueRef)\n  * (Not to be confused with `common::const_get_elt`, which operates on\n  * raw LLVM-level structs and arrays.)\n  */\n-pub fn const_get_field(ccx: &mut CrateContext, r: &Repr, val: ValueRef,\n+pub fn const_get_field(ccx: &CrateContext, r: &Repr, val: ValueRef,\n                        _discr: Disr, ix: uint) -> ValueRef {\n     match *r {\n         CEnum(..) => ccx.sess.bug(\"element access in C-like enum const\"),\n@@ -831,7 +836,7 @@ pub fn const_get_field(ccx: &mut CrateContext, r: &Repr, val: ValueRef,\n }\n \n /// Extract field of struct-like const, skipping our alignment padding.\n-fn const_struct_field(ccx: &mut CrateContext, val: ValueRef, ix: uint)\n+fn const_struct_field(ccx: &CrateContext, val: ValueRef, ix: uint)\n     -> ValueRef {\n     // Get the ix-th non-undef element of the struct.\n     let mut real_ix = 0; // actual position in the struct"}, {"sha": "5dd7c0c3b44f13ce5544eb2b04d1c29c082d8e33", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -27,7 +27,7 @@ use middle::trans::type_::Type;\n use syntax::ast;\n \n // Take an inline assembly expression and splat it out via LLVM\n-pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n+pub fn trans_inline_asm(bcx: @Block, ia: &ast::inline_asm) -> @Block {\n \n     let mut bcx = bcx;\n     let mut constraints = ~[];"}, {"sha": "0b2ee710e991324e011b552ddc82f303469f80c5", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 407, "deletions": 301, "changes": 708, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -69,6 +69,7 @@ use util::sha2::Sha256;\n use middle::trans::type_::Type;\n \n use std::c_str::ToCStr;\n+use std::cell::{Cell, RefCell};\n use std::hashmap::HashMap;\n use std::libc::c_uint;\n use std::vec;\n@@ -131,21 +132,21 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n }\n \n pub struct StatRecorder<'a> {\n-    ccx: @mut CrateContext,\n+    ccx: @CrateContext,\n     name: &'a str,\n     start: u64,\n     istart: uint,\n }\n \n impl<'a> StatRecorder<'a> {\n-    pub fn new(ccx: @mut CrateContext,\n+    pub fn new(ccx: @CrateContext,\n                name: &'a str) -> StatRecorder<'a> {\n         let start = if ccx.sess.trans_stats() {\n             time::precise_time_ns()\n         } else {\n             0\n         };\n-        let istart = ccx.stats.n_llvm_insns;\n+        let istart = ccx.stats.n_llvm_insns.get();\n         StatRecorder {\n             ccx: ccx,\n             name: name,\n@@ -161,13 +162,16 @@ impl<'a> Drop for StatRecorder<'a> {\n         if self.ccx.sess.trans_stats() {\n             let end = time::precise_time_ns();\n             let elapsed = ((end - self.start) / 1_000_000) as uint;\n-            let iend = self.ccx.stats.n_llvm_insns;\n-            self.ccx.stats.fn_stats.push((self.name.to_owned(),\n-                                          elapsed,\n-                                          iend - self.istart));\n-            self.ccx.stats.n_fns += 1;\n+            let iend = self.ccx.stats.n_llvm_insns.get();\n+            {\n+                let mut fn_stats = self.ccx.stats.fn_stats.borrow_mut();\n+                fn_stats.get().push((self.name.to_owned(),\n+                                     elapsed,\n+                                     iend - self.istart));\n+            }\n+            self.ccx.stats.n_fns.set(self.ccx.stats.n_fns.get() + 1);\n             // Reset LLVM insn count to avoid compound costs.\n-            self.ccx.stats.n_llvm_insns = self.istart;\n+            self.ccx.stats.n_llvm_insns.set(self.istart);\n         }\n     }\n }\n@@ -203,21 +207,27 @@ pub fn get_extern_fn(externs: &mut ExternMap, llmod: ModuleRef, name: &str,\n     f\n }\n \n-fn get_extern_rust_fn(ccx: &mut CrateContext, inputs: &[ty::t], output: ty::t,\n+fn get_extern_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t,\n                       name: &str, did: ast::DefId) -> ValueRef {\n-    match ccx.externs.find_equiv(&name) {\n-        Some(n) => return *n,\n-        None => ()\n+    {\n+        let externs = ccx.externs.borrow();\n+        match externs.get().find_equiv(&name) {\n+            Some(n) => return *n,\n+            None => ()\n+        }\n     }\n+\n     let f = decl_rust_fn(ccx, inputs, output, name);\n     csearch::get_item_attrs(ccx.tcx.cstore, did, |meta_items| {\n         set_llvm_fn_attrs(meta_items.iter().map(|&x| attr::mk_attr(x)).to_owned_vec(), f)\n     });\n-    ccx.externs.insert(name.to_owned(), f);\n+\n+    let mut externs = ccx.externs.borrow_mut();\n+    externs.get().insert(name.to_owned(), f);\n     f\n }\n \n-fn decl_rust_fn(ccx: &mut CrateContext, inputs: &[ty::t], output: ty::t, name: &str) -> ValueRef {\n+fn decl_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t, name: &str) -> ValueRef {\n     let llfty = type_of_rust_fn(ccx, inputs, output);\n     let llfn = decl_cdecl_fn(ccx.llmod, name, llfty);\n \n@@ -270,7 +280,7 @@ fn decl_rust_fn(ccx: &mut CrateContext, inputs: &[ty::t], output: ty::t, name: &\n     llfn\n }\n \n-pub fn decl_internal_rust_fn(ccx: &mut CrateContext, inputs: &[ty::t], output: ty::t,\n+pub fn decl_internal_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t,\n                              name: &str) -> ValueRef {\n     let llfn = decl_rust_fn(ccx, inputs, output, name);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n@@ -297,7 +307,7 @@ pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n // known.\n //\n // The runtime equivalent is box_body() in \"rust_internal.h\".\n-pub fn opaque_box_body(bcx: @mut Block,\n+pub fn opaque_box_body(bcx: @Block,\n                        body_t: ty::t,\n                        boxptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"opaque_box_body\");\n@@ -310,14 +320,14 @@ pub fn opaque_box_body(bcx: @mut Block,\n \n // malloc_raw_dyn: allocates a box to contain a given type, but with a\n // potentially dynamic size.\n-pub fn malloc_raw_dyn(bcx: @mut Block,\n+pub fn malloc_raw_dyn(bcx: @Block,\n                       t: ty::t,\n                       heap: heap,\n                       size: ValueRef) -> Result {\n     let _icx = push_ctxt(\"malloc_raw\");\n     let ccx = bcx.ccx();\n \n-    fn require_alloc_fn(bcx: @mut Block, t: ty::t, it: LangItem) -> ast::DefId {\n+    fn require_alloc_fn(bcx: @Block, t: ty::t, it: LangItem) -> ast::DefId {\n         let li = &bcx.tcx().lang_items;\n         match li.require(it) {\n             Ok(id) => id,\n@@ -377,21 +387,21 @@ pub fn malloc_raw_dyn(bcx: @mut Block,\n // malloc_raw: expects an unboxed type and returns a pointer to\n // enough space for a box of that type.  This includes a rust_opaque_box\n // header.\n-pub fn malloc_raw(bcx: @mut Block, t: ty::t, heap: heap) -> Result {\n+pub fn malloc_raw(bcx: @Block, t: ty::t, heap: heap) -> Result {\n     let ty = type_of(bcx.ccx(), t);\n     let size = llsize_of(bcx.ccx(), ty);\n     malloc_raw_dyn(bcx, t, heap, size)\n }\n \n pub struct MallocResult {\n-    bcx: @mut Block,\n+    bcx: @Block,\n     smart_ptr: ValueRef,\n     body: ValueRef\n }\n \n // malloc_general_dyn: usefully wraps malloc_raw_dyn; allocates a smart\n // pointer, and pulls out the body\n-pub fn malloc_general_dyn(bcx: @mut Block, t: ty::t, heap: heap, size: ValueRef)\n+pub fn malloc_general_dyn(bcx: @Block, t: ty::t, heap: heap, size: ValueRef)\n     -> MallocResult {\n     assert!(heap != heap_exchange);\n     let _icx = push_ctxt(\"malloc_general\");\n@@ -405,21 +415,21 @@ pub fn malloc_general_dyn(bcx: @mut Block, t: ty::t, heap: heap, size: ValueRef)\n     }\n }\n \n-pub fn malloc_general(bcx: @mut Block, t: ty::t, heap: heap) -> MallocResult {\n+pub fn malloc_general(bcx: @Block, t: ty::t, heap: heap) -> MallocResult {\n     let ty = type_of(bcx.ccx(), t);\n     assert!(heap != heap_exchange);\n     malloc_general_dyn(bcx, t, heap, llsize_of(bcx.ccx(), ty))\n }\n \n-pub fn heap_for_unique(bcx: @mut Block, t: ty::t) -> heap {\n+pub fn heap_for_unique(bcx: @Block, t: ty::t) -> heap {\n     if ty::type_contents(bcx.tcx(), t).owns_managed() {\n         heap_managed_unique\n     } else {\n         heap_exchange\n     }\n }\n \n-pub fn maybe_set_managed_unique_rc(bcx: @mut Block, bx: ValueRef, heap: heap) {\n+pub fn maybe_set_managed_unique_rc(bcx: @Block, bx: ValueRef, heap: heap) {\n     assert!(heap != heap_exchange);\n     if heap == heap_managed_unique {\n         // In cases where we are looking at a unique-typed allocation in the\n@@ -434,21 +444,24 @@ pub fn maybe_set_managed_unique_rc(bcx: @mut Block, bx: ValueRef, heap: heap) {\n \n // Type descriptor and type glue stuff\n \n-pub fn get_tydesc_simple(ccx: &mut CrateContext, t: ty::t) -> ValueRef {\n+pub fn get_tydesc_simple(ccx: &CrateContext, t: ty::t) -> ValueRef {\n     get_tydesc(ccx, t).tydesc\n }\n \n-pub fn get_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n-    match ccx.tydescs.find(&t) {\n-        Some(&inf) => {\n-            return inf;\n+pub fn get_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n+    {\n+        let tydescs = ccx.tydescs.borrow();\n+        match tydescs.get().find(&t) {\n+            Some(&inf) => return inf,\n+            _ => { }\n         }\n-        _ => { }\n     }\n \n-    ccx.stats.n_static_tydescs += 1u;\n+    ccx.stats.n_static_tydescs.set(ccx.stats.n_static_tydescs.get() + 1u);\n     let inf = glue::declare_tydesc(ccx, t);\n-    ccx.tydescs.insert(t, inf);\n+\n+    let mut tydescs = ccx.tydescs.borrow_mut();\n+    tydescs.get().insert(t, inf);\n     return inf;\n }\n \n@@ -506,15 +519,16 @@ pub fn set_no_split_stack(f: ValueRef) {\n \n // Double-check that we never ask LLVM to declare the same symbol twice. It\n // silently mangles such symbols, breaking our linkage model.\n-pub fn note_unique_llvm_symbol(ccx: &mut CrateContext, sym: @str) {\n-    if ccx.all_llvm_symbols.contains(&sym) {\n+pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: @str) {\n+    let mut all_llvm_symbols = ccx.all_llvm_symbols.borrow_mut();\n+    if all_llvm_symbols.get().contains(&sym) {\n         ccx.sess.bug(~\"duplicate LLVM symbol: \" + sym);\n     }\n-    ccx.all_llvm_symbols.insert(sym);\n+    all_llvm_symbols.get().insert(sym);\n }\n \n \n-pub fn get_res_dtor(ccx: @mut CrateContext,\n+pub fn get_res_dtor(ccx: @CrateContext,\n                     did: ast::DefId,\n                     parent_id: ast::DefId,\n                     substs: &[ty::t])\n@@ -555,11 +569,15 @@ pub fn get_res_dtor(ccx: @mut CrateContext,\n                                      None,\n                                      ty::lookup_item_type(tcx, parent_id).ty);\n         let llty = type_of_dtor(ccx, class_ty);\n-        get_extern_fn(&mut ccx.externs,\n-                      ccx.llmod,\n-                      name,\n-                      lib::llvm::CCallConv,\n-                      llty)\n+\n+        {\n+            let mut externs = ccx.externs.borrow_mut();\n+            get_extern_fn(externs.get(),\n+                          ccx.llmod,\n+                          name,\n+                          lib::llvm::CCallConv,\n+                          llty)\n+        }\n     }\n }\n \n@@ -579,7 +597,7 @@ pub fn maybe_name_value(cx: &CrateContext, v: ValueRef, s: &str) {\n pub enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n \n // NB: This produces an i1, not a Rust bool (i8).\n-pub fn compare_scalar_types(cx: @mut Block,\n+pub fn compare_scalar_types(cx: @Block,\n                             lhs: ValueRef,\n                             rhs: ValueRef,\n                             t: ty::t,\n@@ -611,14 +629,14 @@ pub fn compare_scalar_types(cx: @mut Block,\n \n \n // A helper function to do the actual comparison of scalar values.\n-pub fn compare_scalar_values(cx: @mut Block,\n+pub fn compare_scalar_values(cx: @Block,\n                              lhs: ValueRef,\n                              rhs: ValueRef,\n                              nt: scalar_type,\n                              op: ast::BinOp)\n                           -> ValueRef {\n     let _icx = push_ctxt(\"compare_scalar_values\");\n-    fn die(cx: @mut Block) -> ! {\n+    fn die(cx: @Block) -> ! {\n         cx.tcx().sess.bug(\"compare_scalar_values: must be a\\\n                            comparison operator\");\n     }\n@@ -672,25 +690,25 @@ pub fn compare_scalar_values(cx: @mut Block,\n     }\n }\n \n-pub type val_and_ty_fn<'a> = 'a |@mut Block, ValueRef, ty::t|\n-                                       -> @mut Block;\n+pub type val_and_ty_fn<'a> = 'a |@Block, ValueRef, ty::t|\n+                                       -> @Block;\n \n-pub fn load_inbounds(cx: @mut Block, p: ValueRef, idxs: &[uint]) -> ValueRef {\n+pub fn load_inbounds(cx: @Block, p: ValueRef, idxs: &[uint]) -> ValueRef {\n     return Load(cx, GEPi(cx, p, idxs));\n }\n \n-pub fn store_inbounds(cx: @mut Block, v: ValueRef, p: ValueRef, idxs: &[uint]) {\n+pub fn store_inbounds(cx: @Block, v: ValueRef, p: ValueRef, idxs: &[uint]) {\n     Store(cx, v, GEPi(cx, p, idxs));\n }\n \n // Iterates through the elements of a structural type.\n-pub fn iter_structural_ty(cx: @mut Block, av: ValueRef, t: ty::t,\n-                          f: val_and_ty_fn) -> @mut Block {\n+pub fn iter_structural_ty(cx: @Block, av: ValueRef, t: ty::t,\n+                          f: val_and_ty_fn) -> @Block {\n     let _icx = push_ctxt(\"iter_structural_ty\");\n \n-    fn iter_variant(cx: @mut Block, repr: &adt::Repr, av: ValueRef,\n+    fn iter_variant(cx: @Block, repr: &adt::Repr, av: ValueRef,\n                     variant: @ty::VariantInfo,\n-                    tps: &[ty::t], f: val_and_ty_fn) -> @mut Block {\n+                    tps: &[ty::t], f: val_and_ty_fn) -> @Block {\n         let _icx = push_ctxt(\"iter_variant\");\n         let tcx = cx.tcx();\n         let mut cx = cx;\n@@ -776,7 +794,7 @@ pub fn iter_structural_ty(cx: @mut Block, av: ValueRef, t: ty::t,\n     return cx;\n }\n \n-pub fn cast_shift_expr_rhs(cx: @mut Block, op: ast::BinOp,\n+pub fn cast_shift_expr_rhs(cx: @Block, op: ast::BinOp,\n                            lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     cast_shift_rhs(op, lhs, rhs,\n                    |a,b| Trunc(cx, a, b),\n@@ -818,8 +836,8 @@ pub fn cast_shift_rhs(op: ast::BinOp,\n     }\n }\n \n-pub fn fail_if_zero(cx: @mut Block, span: Span, divrem: ast::BinOp,\n-                    rhs: ValueRef, rhs_t: ty::t) -> @mut Block {\n+pub fn fail_if_zero(cx: @Block, span: Span, divrem: ast::BinOp,\n+                    rhs: ValueRef, rhs_t: ty::t) -> @Block {\n     let text = if divrem == ast::BiDiv {\n         @\"attempted to divide by zero\"\n     } else {\n@@ -848,7 +866,7 @@ pub fn null_env_ptr(ccx: &CrateContext) -> ValueRef {\n     C_null(Type::opaque_box(ccx).ptr_to())\n }\n \n-pub fn trans_external_path(ccx: &mut CrateContext, did: ast::DefId, t: ty::t) -> ValueRef {\n+pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> ValueRef {\n     let name = csearch::get_symbol(ccx.sess.cstore, did);\n     match ty::get(t).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n@@ -861,7 +879,8 @@ pub fn trans_external_path(ccx: &mut CrateContext, did: ast::DefId, t: ty::t) ->\n                     let c = foreign::llvm_calling_convention(ccx, fn_ty.abis);\n                     let cconv = c.unwrap_or(lib::llvm::CCallConv);\n                     let llty = type_of_fn_from_ty(ccx, t);\n-                    get_extern_fn(&mut ccx.externs, ccx.llmod, name, cconv, llty)\n+                    let mut externs = ccx.externs.borrow_mut();\n+                    get_extern_fn(externs.get(), ccx.llmod, name, cconv, llty)\n                 }\n             }\n         }\n@@ -870,19 +889,20 @@ pub fn trans_external_path(ccx: &mut CrateContext, did: ast::DefId, t: ty::t) ->\n         }\n         _ => {\n             let llty = type_of(ccx, t);\n-            get_extern_const(&mut ccx.externs, ccx.llmod, name, llty)\n+            let mut externs = ccx.externs.borrow_mut();\n+            get_extern_const(externs.get(), ccx.llmod, name, llty)\n         }\n     }\n }\n \n-pub fn invoke(bcx: @mut Block,\n+pub fn invoke(bcx: @Block,\n               llfn: ValueRef,\n               llargs: ~[ValueRef],\n               attributes: &[(uint, lib::llvm::Attribute)],\n               call_info: Option<NodeInfo>)\n-           -> (ValueRef, @mut Block) {\n+           -> (ValueRef, @Block) {\n     let _icx = push_ctxt(\"invoke_\");\n-    if bcx.unreachable {\n+    if bcx.unreachable.get() {\n         return (C_null(Type::i8()), bcx);\n     }\n \n@@ -934,7 +954,7 @@ pub fn invoke(bcx: @mut Block,\n     }\n }\n \n-pub fn need_invoke(bcx: @mut Block) -> bool {\n+pub fn need_invoke(bcx: @Block) -> bool {\n     if bcx.ccx().sess.no_landing_pads() {\n         return false;\n     }\n@@ -950,11 +970,12 @@ pub fn need_invoke(bcx: @mut Block) -> bool {\n \n     // Walk the scopes to look for cleanups\n     let mut cur = bcx;\n-    let mut cur_scope = cur.scope;\n+    let mut cur_scope = cur.scope.get();\n     loop {\n         cur_scope = match cur_scope {\n             Some(inf) => {\n-                for cleanup in inf.cleanups.iter() {\n+                let cleanups = inf.cleanups.borrow();\n+                for cleanup in cleanups.get().iter() {\n                     match *cleanup {\n                         clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) => {\n                             if cleanup_type == normal_exit_and_unwind {\n@@ -970,26 +991,26 @@ pub fn need_invoke(bcx: @mut Block) -> bool {\n                     Some(next) => next,\n                     None => return false\n                 };\n-                cur.scope\n+                cur.scope.get()\n             }\n         }\n     }\n }\n \n-pub fn have_cached_lpad(bcx: @mut Block) -> bool {\n+pub fn have_cached_lpad(bcx: @Block) -> bool {\n     let mut res = false;\n     in_lpad_scope_cx(bcx, |inf| {\n-        match inf.landing_pad {\n+        match inf.landing_pad.get() {\n           Some(_) => res = true,\n           None => res = false\n         }\n     });\n     return res;\n }\n \n-pub fn in_lpad_scope_cx(bcx: @mut Block, f: |si: &mut ScopeInfo|) {\n+pub fn in_lpad_scope_cx(bcx: @Block, f: |si: &ScopeInfo|) {\n     let mut bcx = bcx;\n-    let mut cur_scope = bcx.scope;\n+    let mut cur_scope = bcx.scope.get();\n     loop {\n         cur_scope = match cur_scope {\n             Some(inf) => {\n@@ -1001,24 +1022,24 @@ pub fn in_lpad_scope_cx(bcx: @mut Block, f: |si: &mut ScopeInfo|) {\n             }\n             None => {\n                 bcx = block_parent(bcx);\n-                bcx.scope\n+                bcx.scope.get()\n             }\n         }\n     }\n }\n \n-pub fn get_landing_pad(bcx: @mut Block) -> BasicBlockRef {\n+pub fn get_landing_pad(bcx: @Block) -> BasicBlockRef {\n     let _icx = push_ctxt(\"get_landing_pad\");\n \n     let mut cached = None;\n     let mut pad_bcx = bcx; // Guaranteed to be set below\n     in_lpad_scope_cx(bcx, |inf| {\n         // If there is a valid landing pad still around, use it\n-        match inf.landing_pad {\n+        match inf.landing_pad.get() {\n           Some(target) => cached = Some(target),\n           None => {\n             pad_bcx = lpad_block(bcx, \"unwind\");\n-            inf.landing_pad = Some(pad_bcx.llbb);\n+            inf.landing_pad.set(Some(pad_bcx.llbb));\n           }\n         }\n     });\n@@ -1039,11 +1060,11 @@ pub fn get_landing_pad(bcx: @mut Block) -> BasicBlockRef {\n \n     // We store the retval in a function-central alloca, so that calls to\n     // Resume can find it.\n-    match bcx.fcx.personality {\n+    match bcx.fcx.personality.get() {\n       Some(addr) => Store(pad_bcx, llretval, addr),\n       None => {\n         let addr = alloca(pad_bcx, val_ty(llretval), \"\");\n-        bcx.fcx.personality = Some(addr);\n+        bcx.fcx.personality.set(Some(addr));\n         Store(pad_bcx, llretval, addr);\n       }\n     }\n@@ -1053,9 +1074,9 @@ pub fn get_landing_pad(bcx: @mut Block) -> BasicBlockRef {\n     return pad_bcx.llbb;\n }\n \n-pub fn find_bcx_for_scope(bcx: @mut Block, scope_id: ast::NodeId) -> @mut Block {\n+pub fn find_bcx_for_scope(bcx: @Block, scope_id: ast::NodeId) -> @Block {\n     let mut bcx_sid = bcx;\n-    let mut cur_scope = bcx_sid.scope;\n+    let mut cur_scope = bcx_sid.scope.get();\n     loop {\n         cur_scope = match cur_scope {\n             Some(inf) => {\n@@ -1075,14 +1096,14 @@ pub fn find_bcx_for_scope(bcx: @mut Block, scope_id: ast::NodeId) -> @mut Block\n                     None => bcx.tcx().sess.bug(format!(\"no enclosing scope with id {}\", scope_id)),\n                     Some(bcx_par) => bcx_par\n                 };\n-                bcx_sid.scope\n+                bcx_sid.scope.get()\n             }\n         }\n     }\n }\n \n \n-pub fn do_spill(bcx: @mut Block, v: ValueRef, t: ty::t) -> ValueRef {\n+pub fn do_spill(bcx: @Block, v: ValueRef, t: ty::t) -> ValueRef {\n     if ty::type_is_bot(t) {\n         return C_null(Type::i8p());\n     }\n@@ -1093,31 +1114,31 @@ pub fn do_spill(bcx: @mut Block, v: ValueRef, t: ty::t) -> ValueRef {\n \n // Since this function does *not* root, it is the caller's responsibility to\n // ensure that the referent is pointed to by a root.\n-pub fn do_spill_noroot(cx: @mut Block, v: ValueRef) -> ValueRef {\n+pub fn do_spill_noroot(cx: @Block, v: ValueRef) -> ValueRef {\n     let llptr = alloca(cx, val_ty(v), \"\");\n     Store(cx, v, llptr);\n     return llptr;\n }\n \n-pub fn spill_if_immediate(cx: @mut Block, v: ValueRef, t: ty::t) -> ValueRef {\n+pub fn spill_if_immediate(cx: @Block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = push_ctxt(\"spill_if_immediate\");\n     if type_is_immediate(cx.ccx(), t) { return do_spill(cx, v, t); }\n     return v;\n }\n \n-pub fn load_if_immediate(cx: @mut Block, v: ValueRef, t: ty::t) -> ValueRef {\n+pub fn load_if_immediate(cx: @Block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = push_ctxt(\"load_if_immediate\");\n     if type_is_immediate(cx.ccx(), t) { return Load(cx, v); }\n     return v;\n }\n \n-pub fn ignore_lhs(_bcx: @mut Block, local: &ast::Local) -> bool {\n+pub fn ignore_lhs(_bcx: @Block, local: &ast::Local) -> bool {\n     match local.pat.node {\n         ast::PatWild => true, _ => false\n     }\n }\n \n-pub fn init_local(bcx: @mut Block, local: &ast::Local) -> @mut Block {\n+pub fn init_local(bcx: @Block, local: &ast::Local) -> @Block {\n \n     debug!(\"init_local(bcx={}, local.id={:?})\",\n            bcx.to_str(), local.id);\n@@ -1138,7 +1159,7 @@ pub fn init_local(bcx: @mut Block, local: &ast::Local) -> @mut Block {\n     _match::store_local(bcx, local.pat, local.init)\n }\n \n-pub fn trans_stmt(cx: @mut Block, s: &ast::Stmt) -> @mut Block {\n+pub fn trans_stmt(cx: @Block, s: &ast::Stmt) -> @Block {\n     let _icx = push_ctxt(\"trans_stmt\");\n     debug!(\"trans_stmt({})\", stmt_to_str(s, cx.tcx().sess.intr()));\n \n@@ -1171,25 +1192,25 @@ pub fn trans_stmt(cx: @mut Block, s: &ast::Stmt) -> @mut Block {\n \n // You probably don't want to use this one. See the\n // next three functions instead.\n-pub fn new_block(cx: @mut FunctionContext,\n-                 parent: Option<@mut Block>,\n-                 scope: Option<@mut ScopeInfo>,\n+pub fn new_block(cx: @FunctionContext,\n+                 parent: Option<@Block>,\n+                 scope: Option<@ScopeInfo>,\n                  is_lpad: bool,\n                  name: &str,\n                  opt_node_info: Option<NodeInfo>)\n-              -> @mut Block {\n+              -> @Block {\n     unsafe {\n         let llbb = name.with_c_str(|buf| {\n             llvm::LLVMAppendBasicBlockInContext(cx.ccx.llcx, cx.llfn, buf)\n         });\n-        let bcx = @mut Block::new(llbb,\n+        let bcx = @Block::new(llbb,\n                                   parent,\n                                   is_lpad,\n                                   opt_node_info,\n                                   cx);\n-        bcx.scope = scope;\n+        bcx.scope.set(scope);\n         for cx in parent.iter() {\n-            if cx.unreachable {\n+            if cx.unreachable.get() {\n                 Unreachable(bcx);\n                 break;\n             }\n@@ -1198,61 +1219,62 @@ pub fn new_block(cx: @mut FunctionContext,\n     }\n }\n \n-pub fn simple_block_scope(parent: Option<@mut ScopeInfo>,\n-                          node_info: Option<NodeInfo>) -> @mut ScopeInfo {\n-    @mut ScopeInfo {\n+pub fn simple_block_scope(parent: Option<@ScopeInfo>,\n+                          node_info: Option<NodeInfo>)\n+                          -> @ScopeInfo {\n+    @ScopeInfo {\n         parent: parent,\n         loop_break: None,\n         loop_label: None,\n-        cleanups: ~[],\n-        cleanup_paths: ~[],\n-        landing_pad: None,\n+        cleanups: RefCell::new(~[]),\n+        cleanup_paths: RefCell::new(~[]),\n+        landing_pad: Cell::new(None),\n         node_info: node_info,\n     }\n }\n \n // Use this when you're at the top block of a function or the like.\n-pub fn top_scope_block(fcx: @mut FunctionContext, opt_node_info: Option<NodeInfo>)\n-                    -> @mut Block {\n+pub fn top_scope_block(fcx: @FunctionContext, opt_node_info: Option<NodeInfo>)\n+                    -> @Block {\n     return new_block(fcx, None, Some(simple_block_scope(None, opt_node_info)), false,\n                   \"function top level\", opt_node_info);\n }\n \n-pub fn scope_block(bcx: @mut Block,\n+pub fn scope_block(bcx: @Block,\n                    opt_node_info: Option<NodeInfo>,\n-                   n: &str) -> @mut Block {\n+                   n: &str) -> @Block {\n     return new_block(bcx.fcx, Some(bcx), Some(simple_block_scope(None, opt_node_info)), bcx.is_lpad,\n                   n, opt_node_info);\n }\n \n-pub fn loop_scope_block(bcx: @mut Block,\n-                        loop_break: @mut Block,\n+pub fn loop_scope_block(bcx: @Block,\n+                        loop_break: @Block,\n                         loop_label: Option<Name>,\n                         n: &str,\n-                        opt_node_info: Option<NodeInfo>) -> @mut Block {\n-    return new_block(bcx.fcx, Some(bcx), Some(@mut ScopeInfo {\n+                        opt_node_info: Option<NodeInfo>) -> @Block {\n+    return new_block(bcx.fcx, Some(bcx), Some(@ScopeInfo {\n         parent: None,\n         loop_break: Some(loop_break),\n         loop_label: loop_label,\n-        cleanups: ~[],\n-        cleanup_paths: ~[],\n-        landing_pad: None,\n+        cleanups: RefCell::new(~[]),\n+        cleanup_paths: RefCell::new(~[]),\n+        landing_pad: Cell::new(None),\n         node_info: opt_node_info,\n     }), bcx.is_lpad, n, opt_node_info);\n }\n \n // Use this when creating a block for the inside of a landing pad.\n-pub fn lpad_block(bcx: @mut Block, n: &str) -> @mut Block {\n+pub fn lpad_block(bcx: @Block, n: &str) -> @Block {\n     new_block(bcx.fcx, Some(bcx), None, true, n, None)\n }\n \n // Use this when you're making a general CFG BB within a scope.\n-pub fn sub_block(bcx: @mut Block, n: &str) -> @mut Block {\n+pub fn sub_block(bcx: @Block, n: &str) -> @Block {\n     new_block(bcx.fcx, Some(bcx), None, bcx.is_lpad, n, None)\n }\n \n-pub fn raw_block(fcx: @mut FunctionContext, is_lpad: bool, llbb: BasicBlockRef) -> @mut Block {\n-    @mut Block::new(llbb, None, is_lpad, None, fcx)\n+pub fn raw_block(fcx: @FunctionContext, is_lpad: bool, llbb: BasicBlockRef) -> @Block {\n+    @Block::new(llbb, None, is_lpad, None, fcx)\n }\n \n \n@@ -1263,19 +1285,21 @@ pub fn raw_block(fcx: @mut FunctionContext, is_lpad: bool, llbb: BasicBlockRef)\n // need to make sure those variables go out of scope when the block ends.  We\n // do that by running a 'cleanup' function for each variable.\n // trans_block_cleanups runs all the cleanup functions for the block.\n-pub fn trans_block_cleanups(bcx: @mut Block, cleanups: ~[cleanup]) -> @mut Block {\n+pub fn trans_block_cleanups(bcx: @Block, cleanups: ~[cleanup]) -> @Block {\n     trans_block_cleanups_(bcx, cleanups, false)\n }\n \n-pub fn trans_block_cleanups_(bcx: @mut Block,\n+pub fn trans_block_cleanups_(bcx: @Block,\n                              cleanups: &[cleanup],\n                              /* cleanup_cx: block, */\n-                             is_lpad: bool) -> @mut Block {\n+                             is_lpad: bool) -> @Block {\n     let _icx = push_ctxt(\"trans_block_cleanups\");\n     // NB: Don't short-circuit even if this block is unreachable because\n     // GC-based cleanup needs to the see that the roots are live.\n     let no_lpads = bcx.ccx().sess.no_landing_pads();\n-    if bcx.unreachable && !no_lpads { return bcx; }\n+    if bcx.unreachable.get() && !no_lpads {\n+        return bcx\n+    }\n     let mut bcx = bcx;\n     for cu in cleanups.rev_iter() {\n         match *cu {\n@@ -1294,7 +1318,7 @@ pub fn trans_block_cleanups_(bcx: @mut Block,\n // In the last argument, Some(block) mean jump to this block, and none means\n // this is a landing pad and leaving should be accomplished with a resume\n // instruction.\n-pub fn cleanup_and_leave(bcx: @mut Block,\n+pub fn cleanup_and_leave(bcx: @Block,\n                          upto: Option<BasicBlockRef>,\n                          leave: Option<BasicBlockRef>) {\n     let _icx = push_ctxt(\"cleanup_and_leave\");\n@@ -1304,18 +1328,24 @@ pub fn cleanup_and_leave(bcx: @mut Block,\n     loop {\n         debug!(\"cleanup_and_leave: leaving {}\", cur.to_str());\n \n-        let mut cur_scope = cur.scope;\n+        let mut cur_scope = cur.scope.get();\n         loop {\n             cur_scope = match cur_scope {\n                 Some (inf) if !inf.empty_cleanups() => {\n                     let (sub_cx, dest, inf_cleanups) = {\n-                        let inf = &mut *inf;\n+                        let inf = &*inf;\n                         let mut skip = 0;\n                         let mut dest = None;\n                         {\n-                            let r = (*inf).cleanup_paths.rev_iter().find(|cp| cp.target == leave);\n+                            let cleanup_paths = inf.cleanup_paths.borrow();\n+                            let r = cleanup_paths.get()\n+                                                 .rev_iter()\n+                                                 .find(|cp| {\n+                                cp.target == leave\n+                            });\n                             for cp in r.iter() {\n-                                if cp.size == inf.cleanups.len() {\n+                                let cleanups = inf.cleanups.borrow();\n+                                if cp.size == cleanups.get().len() {\n                                     Br(bcx, cp.dest);\n                                     return;\n                                 }\n@@ -1326,12 +1356,15 @@ pub fn cleanup_and_leave(bcx: @mut Block,\n                         }\n                         let sub_cx = sub_block(bcx, \"cleanup\");\n                         Br(bcx, sub_cx.llbb);\n-                        inf.cleanup_paths.push(cleanup_path {\n+                        let cleanups = inf.cleanups.borrow();\n+                        let mut cleanup_paths = inf.cleanup_paths\n+                                                   .borrow_mut();\n+                        cleanup_paths.get().push(cleanup_path {\n                             target: leave,\n-                            size: inf.cleanups.len(),\n+                            size: cleanups.get().len(),\n                             dest: sub_cx.llbb\n                         });\n-                        (sub_cx, dest, inf.cleanups.tailn(skip).to_owned())\n+                        (sub_cx, dest, cleanups.get().tailn(skip).to_owned())\n                     };\n                     bcx = trans_block_cleanups_(sub_cx,\n                                                 inf_cleanups,\n@@ -1359,24 +1392,27 @@ pub fn cleanup_and_leave(bcx: @mut Block,\n     match leave {\n       Some(target) => Br(bcx, target),\n       None => {\n-          let ll_load = Load(bcx, bcx.fcx.personality.unwrap());\n+          let ll_load = Load(bcx, bcx.fcx.personality.get().unwrap());\n           Resume(bcx, ll_load);\n       }\n     }\n }\n \n-pub fn cleanup_block(bcx: @mut Block, upto: Option<BasicBlockRef>) -> @mut Block{\n+pub fn cleanup_block(bcx: @Block, upto: Option<BasicBlockRef>) -> @Block{\n     let _icx = push_ctxt(\"cleanup_block\");\n     let mut cur = bcx;\n     let mut bcx = bcx;\n     loop {\n         debug!(\"cleanup_block: {}\", cur.to_str());\n \n-        let mut cur_scope = cur.scope;\n+        let mut cur_scope = cur.scope.get();\n         loop {\n             cur_scope = match cur_scope {\n-                Some (inf) => {\n-                    bcx = trans_block_cleanups_(bcx, inf.cleanups.to_owned(), false);\n+                Some(inf) => {\n+                    let cleanups = inf.cleanups.borrow();\n+                    bcx = trans_block_cleanups_(bcx,\n+                                                cleanups.get().to_owned(),\n+                                                false);\n                     inf.parent\n                 }\n                 None => break\n@@ -1395,60 +1431,60 @@ pub fn cleanup_block(bcx: @mut Block, upto: Option<BasicBlockRef>) -> @mut Block\n     bcx\n }\n \n-pub fn cleanup_and_Br(bcx: @mut Block, upto: @mut Block, target: BasicBlockRef) {\n+pub fn cleanup_and_Br(bcx: @Block, upto: @Block, target: BasicBlockRef) {\n     let _icx = push_ctxt(\"cleanup_and_Br\");\n     cleanup_and_leave(bcx, Some(upto.llbb), Some(target));\n }\n \n-pub fn leave_block(bcx: @mut Block, out_of: @mut Block) -> @mut Block {\n+pub fn leave_block(bcx: @Block, out_of: @Block) -> @Block {\n     let _icx = push_ctxt(\"leave_block\");\n     let next_cx = sub_block(block_parent(out_of), \"next\");\n-    if bcx.unreachable { Unreachable(next_cx); }\n+    if bcx.unreachable.get() {\n+        Unreachable(next_cx);\n+    }\n     cleanup_and_Br(bcx, out_of, next_cx.llbb);\n     next_cx\n }\n \n-pub fn with_scope(bcx: @mut Block,\n+pub fn with_scope(bcx: @Block,\n                   opt_node_info: Option<NodeInfo>,\n                   name: &str,\n-                  f: |@mut Block| -> @mut Block)\n-                  -> @mut Block {\n+                  f: |@Block| -> @Block)\n+                  -> @Block {\n     let _icx = push_ctxt(\"with_scope\");\n \n     debug!(\"with_scope(bcx={}, opt_node_info={:?}, name={})\",\n            bcx.to_str(), opt_node_info, name);\n     let _indenter = indenter();\n \n-    let scope = simple_block_scope(bcx.scope, opt_node_info);\n-    bcx.scope = Some(scope);\n+    let scope = simple_block_scope(bcx.scope.get(), opt_node_info);\n+    bcx.scope.set(Some(scope));\n     let ret = f(bcx);\n-    let ret = trans_block_cleanups_(ret, (scope.cleanups).clone(), false);\n-    bcx.scope = scope.parent;\n+    let ret = trans_block_cleanups_(ret, scope.cleanups.get(), false);\n+    bcx.scope.set(scope.parent);\n     ret\n }\n \n-pub fn with_scope_result(bcx: @mut Block,\n+pub fn with_scope_result(bcx: @Block,\n                          opt_node_info: Option<NodeInfo>,\n                          _name: &str,\n-                         f: |@mut Block| -> Result)\n+                         f: |@Block| -> Result)\n                          -> Result {\n     let _icx = push_ctxt(\"with_scope_result\");\n \n-    let scope = simple_block_scope(bcx.scope, opt_node_info);\n-    bcx.scope = Some(scope);\n+    let scope = simple_block_scope(bcx.scope.get(), opt_node_info);\n+    bcx.scope.set(Some(scope));\n     let Result { bcx: out_bcx, val } = f(bcx);\n-    let out_bcx = trans_block_cleanups_(out_bcx,\n-                                        (scope.cleanups).clone(),\n-                                        false);\n-    bcx.scope = scope.parent;\n+    let out_bcx = trans_block_cleanups_(out_bcx, scope.cleanups.get(), false);\n+    bcx.scope.set(scope.parent);\n \n     rslt(out_bcx, val)\n }\n \n-pub fn with_scope_datumblock(bcx: @mut Block,\n+pub fn with_scope_datumblock(bcx: @Block,\n                              opt_node_info: Option<NodeInfo>,\n                              name: &str,\n-                             f: |@mut Block| -> datum::DatumBlock)\n+                             f: |@Block| -> datum::DatumBlock)\n                              -> datum::DatumBlock {\n     use middle::trans::datum::DatumBlock;\n \n@@ -1473,20 +1509,22 @@ pub fn block_locals(b: &ast::Block, it: |@ast::Local|) {\n     }\n }\n \n-pub fn with_cond(bcx: @mut Block,\n+pub fn with_cond(bcx: @Block,\n                  val: ValueRef,\n-                 f: |@mut Block| -> @mut Block)\n-                 -> @mut Block {\n+                 f: |@Block| -> @Block)\n+                 -> @Block {\n     let _icx = push_ctxt(\"with_cond\");\n     let next_cx = base::sub_block(bcx, \"next\");\n     let cond_cx = base::sub_block(bcx, \"cond\");\n     CondBr(bcx, val, cond_cx.llbb, next_cx.llbb);\n     let after_cx = f(cond_cx);\n-    if !after_cx.terminated { Br(after_cx, next_cx.llbb); }\n+    if !after_cx.terminated.get() {\n+        Br(after_cx, next_cx.llbb);\n+    }\n     next_cx\n }\n \n-pub fn call_memcpy(cx: @mut Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n+pub fn call_memcpy(cx: @Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n     let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n     let key = match ccx.sess.targ_cfg.arch {\n@@ -1502,7 +1540,7 @@ pub fn call_memcpy(cx: @mut Block, dst: ValueRef, src: ValueRef, n_bytes: ValueR\n     Call(cx, memcpy, [dst_ptr, src_ptr, size, align, volatile], []);\n }\n \n-pub fn memcpy_ty(bcx: @mut Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n+pub fn memcpy_ty(bcx: @Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n     let _icx = push_ctxt(\"memcpy_ty\");\n     let ccx = bcx.ccx();\n     if ty::type_is_structural(t) {\n@@ -1515,8 +1553,8 @@ pub fn memcpy_ty(bcx: @mut Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n     }\n }\n \n-pub fn zero_mem(cx: @mut Block, llptr: ValueRef, t: ty::t) {\n-    if cx.unreachable { return; }\n+pub fn zero_mem(cx: @Block, llptr: ValueRef, t: ty::t) {\n+    if cx.unreachable.get() { return; }\n     let _icx = push_ctxt(\"zero_mem\");\n     let bcx = cx;\n     let ccx = cx.ccx();\n@@ -1547,7 +1585,7 @@ pub fn memzero(b: &Builder, llptr: ValueRef, ty: Type) {\n     b.call(llintrinsicfn, [llptr, llzeroval, size, align, volatile], []);\n }\n \n-pub fn alloc_ty(bcx: @mut Block, t: ty::t, name: &str) -> ValueRef {\n+pub fn alloc_ty(bcx: @Block, t: ty::t, name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let ty = type_of::type_of(ccx, t);\n@@ -1556,13 +1594,13 @@ pub fn alloc_ty(bcx: @mut Block, t: ty::t, name: &str) -> ValueRef {\n     return val;\n }\n \n-pub fn alloca(cx: @mut Block, ty: Type, name: &str) -> ValueRef {\n+pub fn alloca(cx: @Block, ty: Type, name: &str) -> ValueRef {\n     alloca_maybe_zeroed(cx, ty, name, false)\n }\n \n-pub fn alloca_maybe_zeroed(cx: @mut Block, ty: Type, name: &str, zero: bool) -> ValueRef {\n+pub fn alloca_maybe_zeroed(cx: @Block, ty: Type, name: &str, zero: bool) -> ValueRef {\n     let _icx = push_ctxt(\"alloca\");\n-    if cx.unreachable {\n+    if cx.unreachable.get() {\n         unsafe {\n             return llvm::LLVMGetUndef(ty.ptr_to().to_ref());\n         }\n@@ -1571,15 +1609,15 @@ pub fn alloca_maybe_zeroed(cx: @mut Block, ty: Type, name: &str, zero: bool) ->\n     let p = Alloca(cx, ty, name);\n     if zero {\n         let b = cx.fcx.ccx.builder();\n-        b.position_before(cx.fcx.alloca_insert_pt.unwrap());\n+        b.position_before(cx.fcx.alloca_insert_pt.get().unwrap());\n         memzero(&b, p, ty);\n     }\n     p\n }\n \n-pub fn arrayalloca(cx: @mut Block, ty: Type, v: ValueRef) -> ValueRef {\n+pub fn arrayalloca(cx: @Block, ty: Type, v: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"arrayalloca\");\n-    if cx.unreachable {\n+    if cx.unreachable.get() {\n         unsafe {\n             return llvm::LLVMGetUndef(ty.to_ref());\n         }\n@@ -1612,13 +1650,13 @@ pub fn mk_return_basic_block(llfn: ValueRef) -> BasicBlockRef {\n \n // Creates and returns space for, or returns the argument representing, the\n // slot where the return value of the function must go.\n-pub fn make_return_pointer(fcx: @mut FunctionContext, output_type: ty::t) -> ValueRef {\n+pub fn make_return_pointer(fcx: @FunctionContext, output_type: ty::t) -> ValueRef {\n     unsafe {\n         if type_of::return_uses_outptr(fcx.ccx, output_type) {\n             llvm::LLVMGetParam(fcx.llfn, 0)\n         } else {\n             let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n-            let bcx = fcx.entry_bcx.unwrap();\n+            let bcx = fcx.entry_bcx.get().unwrap();\n             Alloca(bcx, lloutputtype, \"__make_return_pointer\")\n         }\n     }\n@@ -1630,7 +1668,7 @@ pub fn make_return_pointer(fcx: @mut FunctionContext, output_type: ty::t) -> Val\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n-pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n+pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n                         path: path,\n                         llfndecl: ValueRef,\n                         id: ast::NodeId,\n@@ -1639,7 +1677,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n                         param_substs: Option<@param_substs>,\n                         opt_node_info: Option<NodeInfo>,\n                         sp: Option<Span>)\n-                     -> @mut FunctionContext {\n+                     -> @FunctionContext {\n     for p in param_substs.iter() { p.validate(); }\n \n     debug!(\"new_fn_ctxt_w_id(path={}, id={:?}, \\\n@@ -1657,38 +1695,39 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n     let uses_outptr = type_of::return_uses_outptr(ccx, substd_output_type);\n     let debug_context = debuginfo::create_function_debug_context(ccx, id, param_substs, llfndecl);\n \n-    let fcx = @mut FunctionContext {\n+    let fcx = @FunctionContext {\n           llfn: llfndecl,\n           llenv: unsafe {\n-              llvm::LLVMGetUndef(Type::i8p().to_ref())\n+              Cell::new(llvm::LLVMGetUndef(Type::i8p().to_ref()))\n           },\n-          llretptr: None,\n-          entry_bcx: None,\n-          alloca_insert_pt: None,\n-          llreturn: None,\n-          llself: None,\n-          personality: None,\n+          llretptr: Cell::new(None),\n+          entry_bcx: RefCell::new(None),\n+          alloca_insert_pt: Cell::new(None),\n+          llreturn: Cell::new(None),\n+          llself: Cell::new(None),\n+          personality: Cell::new(None),\n           caller_expects_out_pointer: uses_outptr,\n-          llargs: @mut HashMap::new(),\n-          lllocals: @mut HashMap::new(),\n-          llupvars: @mut HashMap::new(),\n+          llargs: RefCell::new(HashMap::new()),\n+          lllocals: RefCell::new(HashMap::new()),\n+          llupvars: RefCell::new(HashMap::new()),\n           id: id,\n           param_substs: param_substs,\n           span: sp,\n           path: path,\n           ccx: ccx,\n           debug_context: debug_context,\n     };\n-    fcx.llenv = unsafe {\n+    fcx.llenv.set(unsafe {\n           llvm::LLVMGetParam(llfndecl, fcx.env_arg_pos() as c_uint)\n-    };\n+    });\n \n     unsafe {\n         let entry_bcx = top_scope_block(fcx, opt_node_info);\n         Load(entry_bcx, C_null(Type::i8p()));\n \n-        fcx.entry_bcx = Some(entry_bcx);\n-        fcx.alloca_insert_pt = Some(llvm::LLVMGetFirstInstruction(entry_bcx.llbb));\n+        fcx.entry_bcx.set(Some(entry_bcx));\n+        fcx.alloca_insert_pt.set(Some(\n+                llvm::LLVMGetFirstInstruction(entry_bcx.llbb)));\n     }\n \n     if !ty::type_is_voidish(ccx.tcx, substd_output_type) {\n@@ -1698,18 +1737,19 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n             // Otherwise, we normally allocate the llretptr, unless we\n             // have been instructed to skip it for immediate return\n             // values.\n-            fcx.llretptr = Some(make_return_pointer(fcx, substd_output_type));\n+            fcx.llretptr.set(Some(make_return_pointer(fcx,\n+                                                      substd_output_type)));\n         }\n     }\n     fcx\n }\n \n-pub fn new_fn_ctxt(ccx: @mut CrateContext,\n+pub fn new_fn_ctxt(ccx: @CrateContext,\n                    path: path,\n                    llfndecl: ValueRef,\n                    output_type: ty::t,\n                    sp: Option<Span>)\n-                -> @mut FunctionContext {\n+                -> @FunctionContext {\n     new_fn_ctxt_w_id(ccx, path, llfndecl, -1, output_type, false, None, None, sp)\n }\n \n@@ -1727,19 +1767,19 @@ pub fn new_fn_ctxt(ccx: @mut CrateContext,\n // spaces that have been created for them (by code in the llallocas field of\n // the function's fn_ctxt).  create_llargs_for_fn_args populates the llargs\n // field of the fn_ctxt with\n-pub fn create_llargs_for_fn_args(cx: @mut FunctionContext,\n+pub fn create_llargs_for_fn_args(cx: @FunctionContext,\n                                  self_arg: self_arg,\n                                  args: &[ast::arg])\n                               -> ~[ValueRef] {\n     let _icx = push_ctxt(\"create_llargs_for_fn_args\");\n \n     match self_arg {\n       impl_self(tt, self_mode) => {\n-        cx.llself = Some(ValSelfData {\n-            v: cx.llenv,\n+        cx.llself.set(Some(ValSelfData {\n+            v: cx.llenv.get(),\n             t: tt,\n             is_copy: self_mode == ty::ByCopy\n-        });\n+        }));\n       }\n       no_self => ()\n     }\n@@ -1751,19 +1791,19 @@ pub fn create_llargs_for_fn_args(cx: @mut FunctionContext,\n     })\n }\n \n-pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n-                            bcx: @mut Block,\n+pub fn copy_args_to_allocas(fcx: @FunctionContext,\n+                            bcx: @Block,\n                             args: &[ast::arg],\n                             raw_llargs: &[ValueRef],\n-                            arg_tys: &[ty::t]) -> @mut Block {\n+                            arg_tys: &[ty::t]) -> @Block {\n     debug!(\"copy_args_to_allocas: raw_llargs={} arg_tys={}\",\n            raw_llargs.llrepr(fcx.ccx),\n            arg_tys.repr(fcx.ccx.tcx));\n \n     let _icx = push_ctxt(\"copy_args_to_allocas\");\n     let mut bcx = bcx;\n \n-    match fcx.llself {\n+    match fcx.llself.get() {\n         Some(slf) => {\n             let self_val = if slf.is_copy\n                     && datum::appropriate_mode(bcx.ccx(), slf.t).is_by_value() {\n@@ -1775,7 +1815,7 @@ pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n                 PointerCast(bcx, slf.v, type_of(bcx.ccx(), slf.t).ptr_to())\n             };\n \n-            fcx.llself = Some(ValSelfData {v: self_val, ..slf});\n+            fcx.llself.set(Some(ValSelfData {v: self_val, ..slf}));\n             add_clean(bcx, self_val, slf.t);\n \n             if fcx.ccx.sess.opts.extra_debuginfo {\n@@ -1815,12 +1855,12 @@ pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n \n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n-pub fn finish_fn(fcx: @mut FunctionContext, last_bcx: @mut Block) {\n+pub fn finish_fn(fcx: @FunctionContext, last_bcx: @Block) {\n     let _icx = push_ctxt(\"finish_fn\");\n \n-    let ret_cx = match fcx.llreturn {\n+    let ret_cx = match fcx.llreturn.get() {\n         Some(llreturn) => {\n-            if !last_bcx.terminated {\n+            if !last_bcx.terminated.get() {\n                 Br(last_bcx, llreturn);\n             }\n             raw_block(fcx, false, llreturn)\n@@ -1833,13 +1873,13 @@ pub fn finish_fn(fcx: @mut FunctionContext, last_bcx: @mut Block) {\n }\n \n // Builds the return block for a function.\n-pub fn build_return_block(fcx: &FunctionContext, ret_cx: @mut Block) {\n+pub fn build_return_block(fcx: &FunctionContext, ret_cx: @Block) {\n     // Return the value if this function immediate; otherwise, return void.\n-    if fcx.llretptr.is_none() || fcx.caller_expects_out_pointer {\n+    if fcx.llretptr.get().is_none() || fcx.caller_expects_out_pointer {\n         return RetVoid(ret_cx);\n     }\n \n-    let retptr = Value(fcx.llretptr.unwrap());\n+    let retptr = Value(fcx.llretptr.get().unwrap());\n     let retval = match retptr.get_dominating_store(ret_cx) {\n         // If there's only a single store to the ret slot, we can directly return\n         // the value that was stored and omit the store and the alloca\n@@ -1854,7 +1894,7 @@ pub fn build_return_block(fcx: &FunctionContext, ret_cx: @mut Block) {\n             retval\n         }\n         // Otherwise, load the return value from the ret slot\n-        None => Load(ret_cx, fcx.llretptr.unwrap())\n+        None => Load(ret_cx, fcx.llretptr.get().unwrap())\n     };\n \n \n@@ -1866,7 +1906,7 @@ pub enum self_arg { impl_self(ty::t, ty::SelfMode), no_self, }\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n-pub fn trans_closure(ccx: @mut CrateContext,\n+pub fn trans_closure(ccx: @CrateContext,\n                      path: path,\n                      decl: &ast::fn_decl,\n                      body: &ast::Block,\n@@ -1876,8 +1916,9 @@ pub fn trans_closure(ccx: @mut CrateContext,\n                      id: ast::NodeId,\n                      _attributes: &[ast::Attribute],\n                      output_type: ty::t,\n-                     maybe_load_env: |@mut FunctionContext|) {\n-    ccx.stats.n_closures += 1;\n+                     maybe_load_env: |@FunctionContext|) {\n+    ccx.stats.n_closures.set(ccx.stats.n_closures.get() + 1);\n+\n     let _icx = push_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);\n \n@@ -1896,7 +1937,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n \n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n-    let bcx_top = fcx.entry_bcx.unwrap();\n+    let bcx_top = fcx.entry_bcx.get().unwrap();\n     let mut bcx = bcx_top;\n     let block_ty = node_id_type(bcx, body.id);\n \n@@ -1920,19 +1961,20 @@ pub fn trans_closure(ccx: @mut CrateContext,\n     if body.expr.is_none() || ty::type_is_voidish(bcx.tcx(), block_ty) {\n         bcx = controlflow::trans_block(bcx, body, expr::Ignore);\n     } else {\n-        let dest = expr::SaveIn(fcx.llretptr.unwrap());\n+        let dest = expr::SaveIn(fcx.llretptr.get().unwrap());\n         bcx = controlflow::trans_block(bcx, body, dest);\n     }\n \n-    match fcx.llreturn {\n+    match fcx.llreturn.get() {\n         Some(llreturn) => cleanup_and_Br(bcx, bcx_top, llreturn),\n         None => bcx = cleanup_block(bcx, Some(bcx_top.llbb))\n     };\n \n     // Put return block after all other blocks.\n     // This somewhat improves single-stepping experience in debugger.\n     unsafe {\n-        for &llreturn in fcx.llreturn.iter() {\n+        let llreturn = fcx.llreturn.get();\n+        for &llreturn in llreturn.iter() {\n             llvm::LLVMMoveBasicBlockAfter(llreturn, bcx.llbb);\n         }\n     }\n@@ -1943,7 +1985,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n \n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n-pub fn trans_fn(ccx: @mut CrateContext,\n+pub fn trans_fn(ccx: @CrateContext,\n                 path: path,\n                 decl: &ast::fn_decl,\n                 body: &ast::Block,\n@@ -1973,7 +2015,7 @@ pub fn trans_fn(ccx: @mut CrateContext,\n                   |_fcx| { });\n }\n \n-fn insert_synthetic_type_entries(bcx: @mut Block,\n+fn insert_synthetic_type_entries(bcx: @Block,\n                                  fn_args: &[ast::arg],\n                                  arg_tys: &[ty::t])\n {\n@@ -1996,11 +2038,13 @@ fn insert_synthetic_type_entries(bcx: @mut Block,\n \n         let pat_id = fn_args[i].pat.id;\n         let arg_ty = arg_tys[i];\n-        tcx.node_types.insert(pat_id as uint, arg_ty);\n+\n+        let mut node_types = tcx.node_types.borrow_mut();\n+        node_types.get().insert(pat_id as uint, arg_ty);\n     }\n }\n \n-pub fn trans_enum_variant(ccx: @mut CrateContext,\n+pub fn trans_enum_variant(ccx: @CrateContext,\n                           _enum_id: ast::NodeId,\n                           variant: &ast::variant,\n                           args: &[ast::variant_arg],\n@@ -2018,7 +2062,7 @@ pub fn trans_enum_variant(ccx: @mut CrateContext,\n         llfndecl);\n }\n \n-pub fn trans_tuple_struct(ccx: @mut CrateContext,\n+pub fn trans_tuple_struct(ccx: @CrateContext,\n                           fields: &[ast::struct_field],\n                           ctor_id: ast::NodeId,\n                           param_substs: Option<@param_substs>,\n@@ -2050,7 +2094,7 @@ impl IdAndTy for ast::struct_field {\n }\n \n pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n-    ccx: @mut CrateContext,\n+    ccx: @CrateContext,\n     ctor_id: ast::NodeId,\n     args: &[A],\n     disr: ty::Disr,\n@@ -2108,27 +2152,30 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n \n     let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n \n-    let bcx = fcx.entry_bcx.unwrap();\n+    let bcx = fcx.entry_bcx.get().unwrap();\n \n     insert_synthetic_type_entries(bcx, fn_args, arg_tys);\n     let bcx = copy_args_to_allocas(fcx, bcx, fn_args, raw_llargs, arg_tys);\n \n     let repr = adt::represent_type(ccx, result_ty);\n-    adt::trans_start_init(bcx, repr, fcx.llretptr.unwrap(), disr);\n+    adt::trans_start_init(bcx, repr, fcx.llretptr.get().unwrap(), disr);\n     for (i, fn_arg) in fn_args.iter().enumerate() {\n         let lldestptr = adt::trans_field_ptr(bcx,\n                                              repr,\n-                                             fcx.llretptr.unwrap(),\n+                                             fcx.llretptr.get().unwrap(),\n                                              disr,\n                                              i);\n-        let llarg = fcx.llargs.get_copy(&fn_arg.pat.id);\n+        let llarg = {\n+            let llargs = fcx.llargs.borrow();\n+            llargs.get().get_copy(&fn_arg.pat.id)\n+        };\n         let arg_ty = arg_tys[i];\n         memcpy_ty(bcx, lldestptr, llarg, arg_ty);\n     }\n     finish_fn(fcx, bcx);\n }\n \n-pub fn trans_enum_def(ccx: @mut CrateContext, enum_definition: &ast::enum_def,\n+pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::enum_def,\n                       id: ast::NodeId, vi: @~[@ty::VariantInfo],\n                       i: &mut uint) {\n     for &variant in enum_definition.variants.iter() {\n@@ -2152,7 +2199,7 @@ pub fn trans_enum_def(ccx: @mut CrateContext, enum_definition: &ast::enum_def,\n }\n \n pub struct TransItemVisitor {\n-    ccx: @mut CrateContext,\n+    ccx: @CrateContext,\n }\n \n impl Visitor<()> for TransItemVisitor {\n@@ -2161,7 +2208,7 @@ impl Visitor<()> for TransItemVisitor {\n     }\n }\n \n-pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n+pub fn trans_item(ccx: @CrateContext, item: &ast::item) {\n     let _icx = push_ctxt(\"trans_item\");\n     let path = match ccx.tcx.items.get_copy(&item.id) {\n         ast_map::node_item(_, p) => p,\n@@ -2227,7 +2274,9 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n                                       \"cannot have static_assert on a mutable \\\n                                        static\");\n               }\n-              let v = ccx.const_values.get_copy(&item.id);\n+\n+              let const_values = ccx.const_values.borrow();\n+              let v = const_values.get().get_copy(&item.id);\n               unsafe {\n                   if !(llvm::LLVMConstIntGetZExtValue(v) != 0) {\n                       ccx.sess.span_fatal(expr.span, \"static assertion failed\");\n@@ -2255,7 +2304,7 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n     }\n }\n \n-pub fn trans_struct_def(ccx: @mut CrateContext, struct_def: @ast::struct_def) {\n+pub fn trans_struct_def(ccx: @CrateContext, struct_def: @ast::struct_def) {\n     // If this is a tuple-like struct, translate the constructor.\n     match struct_def.ctor_id {\n         // We only need to translate a constructor if there are fields;\n@@ -2274,27 +2323,33 @@ pub fn trans_struct_def(ccx: @mut CrateContext, struct_def: @ast::struct_def) {\n // separate modules in the compiled program.  That's because modules exist\n // only as a convenience for humans working with the code, to organize names\n // and control visibility.\n-pub fn trans_mod(ccx: @mut CrateContext, m: &ast::_mod) {\n+pub fn trans_mod(ccx: @CrateContext, m: &ast::_mod) {\n     let _icx = push_ctxt(\"trans_mod\");\n     for item in m.items.iter() {\n         trans_item(ccx, *item);\n     }\n }\n \n-fn finish_register_fn(ccx: @mut CrateContext, sp: Span, sym: ~str, node_id: ast::NodeId,\n+fn finish_register_fn(ccx: @CrateContext, sp: Span, sym: ~str, node_id: ast::NodeId,\n                       llfn: ValueRef) {\n-    ccx.item_symbols.insert(node_id, sym);\n+    {\n+        let mut item_symbols = ccx.item_symbols.borrow_mut();\n+        item_symbols.get().insert(node_id, sym);\n+    }\n \n-    if !ccx.reachable.contains(&node_id) {\n-        lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n+    {\n+        let reachable = ccx.reachable.borrow();\n+        if !reachable.get().contains(&node_id) {\n+            lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n+        }\n     }\n \n-    if is_entry_fn(&ccx.sess, node_id) && !*ccx.sess.building_library {\n+    if is_entry_fn(&ccx.sess, node_id) && !ccx.sess.building_library.get() {\n         create_entry_wrapper(ccx, sp, llfn);\n     }\n }\n \n-pub fn register_fn(ccx: @mut CrateContext,\n+pub fn register_fn(ccx: @CrateContext,\n                    sp: Span,\n                    sym: ~str,\n                    node_id: ast::NodeId,\n@@ -2314,7 +2369,7 @@ pub fn register_fn(ccx: @mut CrateContext,\n }\n \n // only use this for foreign function ABIs and glue, use `register_fn` for Rust functions\n-pub fn register_fn_llvmty(ccx: @mut CrateContext,\n+pub fn register_fn_llvmty(ccx: @CrateContext,\n                           sp: Span,\n                           sym: ~str,\n                           node_id: ast::NodeId,\n@@ -2331,18 +2386,18 @@ pub fn register_fn_llvmty(ccx: @mut CrateContext,\n }\n \n pub fn is_entry_fn(sess: &Session, node_id: ast::NodeId) -> bool {\n-    match *sess.entry_fn {\n+    match sess.entry_fn.get() {\n         Some((entry_id, _)) => node_id == entry_id,\n         None => false\n     }\n }\n \n // Create a _rust_main(args: ~[str]) function which will be called from the\n // runtime rust_start function\n-pub fn create_entry_wrapper(ccx: @mut CrateContext,\n+pub fn create_entry_wrapper(ccx: @CrateContext,\n                            _sp: Span,\n                            main_llfn: ValueRef) {\n-    let et = ccx.sess.entry_type.unwrap();\n+    let et = ccx.sess.entry_type.get().unwrap();\n     match et {\n         session::EntryMain => {\n             create_entry_fn(ccx, main_llfn, true);\n@@ -2351,7 +2406,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n         session::EntryNone => {}    // Do nothing.\n     }\n \n-    fn create_entry_fn(ccx: @mut CrateContext,\n+    fn create_entry_fn(ccx: @CrateContext,\n                        rust_main: ValueRef,\n                        use_start_lang_item: bool) {\n         let llfty = Type::func([ccx.int_type, Type::i8().ptr_to().ptr_to()],\n@@ -2413,7 +2468,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n     }\n }\n \n-pub fn fill_fn_pair(bcx: @mut Block, pair: ValueRef, llfn: ValueRef,\n+pub fn fill_fn_pair(bcx: @Block, pair: ValueRef, llfn: ValueRef,\n                     llenvptr: ValueRef) {\n     let ccx = bcx.ccx();\n     let code_cell = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n@@ -2427,7 +2482,7 @@ pub fn item_path(ccx: &CrateContext, id: &ast::NodeId) -> path {\n     ty::item_path(ccx.tcx, ast_util::local_def(*id))\n }\n \n-fn exported_name(ccx: &mut CrateContext, path: path, ty: ty::t, attrs: &[ast::Attribute]) -> ~str {\n+fn exported_name(ccx: &CrateContext, path: path, ty: ty::t, attrs: &[ast::Attribute]) -> ~str {\n     match attr::first_attr_value_str_by_name(attrs, \"export_name\") {\n         // Use provided name\n         Some(name) => name.to_owned(),\n@@ -2441,10 +2496,14 @@ fn exported_name(ccx: &mut CrateContext, path: path, ty: ty::t, attrs: &[ast::At\n     }\n }\n \n-pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n+pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n     debug!(\"get_item_val(id=`{:?}`)\", id);\n \n-    let val = ccx.item_vals.find_copy(&id);\n+    let val = {\n+        let item_vals = ccx.item_vals.borrow();\n+        item_vals.get().find_copy(&id)\n+    };\n+\n     match val {\n         Some(v) => v,\n         None => {\n@@ -2465,18 +2524,27 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                             // using the current crate's name/version\n                             // information in the hash of the symbol\n                             debug!(\"making {}\", sym);\n-                            let sym = match ccx.external_srcs.find(&i.id) {\n-                                Some(&did) => {\n-                                    debug!(\"but found in other crate...\");\n-                                    csearch::get_symbol(ccx.sess.cstore, did)\n+                            let sym = {\n+                                let external_srcs = ccx.external_srcs\n+                                                       .borrow();\n+                                match external_srcs.get().find(&i.id) {\n+                                    Some(&did) => {\n+                                        debug!(\"but found in other crate...\");\n+                                        csearch::get_symbol(ccx.sess.cstore,\n+                                                            did)\n+                                    }\n+                                    None => sym\n                                 }\n-                                None => sym\n                             };\n \n                             // We need the translated value here, because for enums the\n                             // LLVM type is not fully determined by the Rust type.\n                             let (v, inlineable) = consts::const_expr(ccx, expr);\n-                            ccx.const_values.insert(id, v);\n+                            {\n+                                let mut const_values = ccx.const_values\n+                                                          .borrow_mut();\n+                                const_values.get().insert(id, v);\n+                            }\n                             let mut inlineable = inlineable;\n \n                             unsafe {\n@@ -2485,18 +2553,27 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                                     llvm::LLVMAddGlobal(ccx.llmod, llty, buf)\n                                 });\n \n-                                if !ccx.reachable.contains(&id) {\n-                                    lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n+                                {\n+                                    let reachable = ccx.reachable.borrow();\n+                                    if !reachable.get().contains(&id) {\n+                                        lib::llvm::SetLinkage(\n+                                            g,\n+                                            lib::llvm::InternalLinkage);\n+                                    }\n                                 }\n \n                                 // Apply the `unnamed_addr` attribute if\n                                 // requested\n                                 if attr::contains_name(i.attrs,\n                                                        \"address_insignificant\"){\n-                                    if ccx.reachable.contains(&id) {\n-                                        ccx.sess.span_bug(i.span,\n-                                            \"insignificant static is \\\n-                                             reachable\");\n+                                    {\n+                                        let reachable =\n+                                            ccx.reachable.borrow();\n+                                        if reachable.get().contains(&id) {\n+                                            ccx.sess.span_bug(i.span,\n+                                                \"insignificant static is \\\n+                                                 reachable\");\n+                                        }\n                                     }\n                                     lib::llvm::SetUnnamedAddr(g, true);\n \n@@ -2525,9 +2602,15 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n \n                                 if !inlineable {\n                                     debug!(\"{} not inlined\", sym);\n-                                    ccx.non_inlineable_statics.insert(id);\n+                                    let mut non_inlineable_statics =\n+                                        ccx.non_inlineable_statics\n+                                           .borrow_mut();\n+                                    non_inlineable_statics.get().insert(id);\n                                 }\n-                                ccx.item_symbols.insert(i.id, sym);\n+\n+                                let mut item_symbols = ccx.item_symbols\n+                                                          .borrow_mut();\n+                                item_symbols.get().insert(i.id, sym);\n                                 g\n                             }\n                         }\n@@ -2595,7 +2678,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                             // library then we've already declared the crate map\n                             // so use that instead.\n                             if attr::contains_name(ni.attrs, \"crate_map\") {\n-                                if *ccx.sess.building_library {\n+                                if ccx.sess.building_library.get() {\n                                     let s = \"_rust_crate_map_toplevel\";\n                                     let g = unsafe {\n                                         s.with_c_str(|buf| {\n@@ -2679,17 +2762,21 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n             // foreign items (extern fns and extern statics) don't have internal\n             // linkage b/c that doesn't quite make sense. Otherwise items can\n             // have internal linkage if they're not reachable.\n-            if !foreign && !ccx.reachable.contains(&id) {\n-                lib::llvm::SetLinkage(val, lib::llvm::InternalLinkage);\n+            {\n+                let reachable = ccx.reachable.borrow();\n+                if !foreign && !reachable.get().contains(&id) {\n+                    lib::llvm::SetLinkage(val, lib::llvm::InternalLinkage);\n+                }\n             }\n \n-            ccx.item_vals.insert(id, val);\n+            let mut item_vals = ccx.item_vals.borrow_mut();\n+            item_vals.get().insert(id, val);\n             val\n         }\n     }\n }\n \n-pub fn register_method(ccx: @mut CrateContext,\n+pub fn register_method(ccx: @CrateContext,\n                        id: ast::NodeId,\n                        path: @ast_map::path,\n                        m: @ast::method) -> ValueRef {\n@@ -2705,7 +2792,7 @@ pub fn register_method(ccx: @mut CrateContext,\n     llfn\n }\n \n-pub fn vp2i(cx: @mut Block, v: ValueRef) -> ValueRef {\n+pub fn vp2i(cx: @Block, v: ValueRef) -> ValueRef {\n     let ccx = cx.ccx();\n     return PtrToInt(cx, v, ccx.int_type);\n }\n@@ -2873,14 +2960,14 @@ pub fn declare_dbg_intrinsics(llmod: ModuleRef, intrinsics: &mut HashMap<&'stati\n          \"llvm.dbg.value\",   [Type::metadata(), Type::i64(), Type::metadata()], Type::void());\n }\n \n-pub fn trap(bcx: @mut Block) {\n+pub fn trap(bcx: @Block) {\n     match bcx.ccx().intrinsics.find_equiv(& &\"llvm.trap\") {\n       Some(&x) => { Call(bcx, x, [], []); },\n       _ => bcx.sess().bug(\"unbound llvm.trap in trap\")\n     }\n }\n \n-pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n+pub fn decl_gc_metadata(ccx: &CrateContext, llmod_id: &str) {\n     if !ccx.sess.opts.gc || !ccx.uses_gc {\n         return;\n     }\n@@ -2894,14 +2981,19 @@ pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n     unsafe {\n         llvm::LLVMSetGlobalConstant(gc_metadata, True);\n         lib::llvm::SetLinkage(gc_metadata, lib::llvm::ExternalLinkage);\n-        ccx.module_data.insert(~\"_gc_module_metadata\", gc_metadata);\n+\n+        let mut module_data = ccx.module_data.borrow_mut();\n+        module_data.get().insert(~\"_gc_module_metadata\", gc_metadata);\n     }\n }\n \n-pub fn create_module_map(ccx: &mut CrateContext) -> (ValueRef, uint) {\n+pub fn create_module_map(ccx: &CrateContext) -> (ValueRef, uint) {\n     let str_slice_type = Type::struct_([Type::i8p(), ccx.int_type], false);\n     let elttype = Type::struct_([str_slice_type, ccx.int_type], false);\n-    let maptype = Type::array(&elttype, ccx.module_data.len() as u64);\n+    let maptype = {\n+        let module_data = ccx.module_data.borrow();\n+        Type::array(&elttype, module_data.get().len() as u64)\n+    };\n     let map = \"_rust_mod_map\".with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, maptype.to_ref(), buf)\n@@ -2913,16 +3005,22 @@ pub fn create_module_map(ccx: &mut CrateContext) -> (ValueRef, uint) {\n     // This is not ideal, but the borrow checker doesn't\n     // like the multiple borrows. At least, it doesn't\n     // like them on the current snapshot. (2013-06-14)\n-    let mut keys = ~[];\n-    for (k, _) in ccx.module_data.iter() {\n-        keys.push(k.to_managed());\n-    }\n+    let keys = {\n+        let mut keys = ~[];\n+        let module_data = ccx.module_data.borrow();\n+        for (k, _) in module_data.get().iter() {\n+            keys.push(k.to_managed());\n+        }\n+        keys\n+    };\n \n     for key in keys.iter() {\n-            let val = *ccx.module_data.find_equiv(key).unwrap();\n+            let llestrval = C_estr_slice(ccx, *key);\n+            let module_data = ccx.module_data.borrow();\n+            let val = *module_data.get().find_equiv(key).unwrap();\n             let v_ptr = p2i(ccx, val);\n             let elt = C_struct([\n-                C_estr_slice(ccx, *key),\n+                llestrval,\n                 v_ptr\n             ], false);\n             elts.push(elt);\n@@ -2946,7 +3044,7 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     let mut n_subcrates = 1;\n     let cstore = sess.cstore;\n     while cstore.have_crate_data(n_subcrates) { n_subcrates += 1; }\n-    let is_top = !*sess.building_library || sess.gen_crate_map();\n+    let is_top = !sess.building_library.get() || sess.gen_crate_map();\n     let sym_name = if is_top {\n         ~\"_rust_crate_map_toplevel\"\n     } else {\n@@ -2977,7 +3075,7 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     return (sym_name, map);\n }\n \n-pub fn fill_crate_map(ccx: @mut CrateContext, map: ValueRef) {\n+pub fn fill_crate_map(ccx: @CrateContext, map: ValueRef) {\n     let mut subcrates: ~[ValueRef] = ~[];\n     let mut i = 1;\n     let cstore = ccx.sess.cstore;\n@@ -3039,14 +3137,12 @@ pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::encode_\n \n         let diag = cx.sess.diagnostic();\n         let item_symbols = &cx.item_symbols;\n-        let discrim_symbols = &cx.discrim_symbols;\n         let link_meta = &cx.link_meta;\n         encoder::EncodeParams {\n             diag: diag,\n             tcx: cx.tcx,\n             reexports2: cx.exp_map2,\n             item_symbols: item_symbols,\n-            discrim_symbols: discrim_symbols,\n             non_inlineable_statics: &cx.non_inlineable_statics,\n             link_meta: link_meta,\n             cstore: cx.sess.cstore,\n@@ -3058,7 +3154,9 @@ pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::encode_\n pub fn write_metadata(cx: &CrateContext, crate: &ast::Crate) -> ~[u8] {\n     use extra::flate;\n \n-    if !*cx.sess.building_library { return ~[]; }\n+    if !cx.sess.building_library.get() {\n+        return ~[]\n+    }\n \n     let encode_inlined_item: encoder::encode_inlined_item =\n         |ecx, ebml_w, path, ii|\n@@ -3109,7 +3207,7 @@ pub fn trans_crate(sess: session::Session,\n     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n     let llmod_id = link_meta.pkgid.name.clone() + \".rc\";\n \n-    let ccx = @mut CrateContext::new(sess,\n+    let ccx = @CrateContext::new(sess,\n                                      llmod_id,\n                                      analysis.ty_cx,\n                                      analysis.exp_map2,\n@@ -3131,8 +3229,7 @@ pub fn trans_crate(sess: session::Session,\n     // __rust_crate_map_toplevel symbol (extra underscore) which it will\n     // subsequently fail to find. So to mitigate that we just introduce\n     // an alias from the symbol it expects to the one that actually exists.\n-    if ccx.sess.targ_cfg.os == OsWin32 &&\n-       !*ccx.sess.building_library {\n+    if ccx.sess.targ_cfg.os == OsWin32 && !ccx.sess.building_library.get() {\n \n         let maptype = val_ty(ccx.crate_map).to_ref();\n \n@@ -3153,39 +3250,48 @@ pub fn trans_crate(sess: session::Session,\n     let metadata = write_metadata(ccx, &crate);\n     if ccx.sess.trans_stats() {\n         println(\"--- trans stats ---\");\n-        println!(\"n_static_tydescs: {}\", ccx.stats.n_static_tydescs);\n-        println!(\"n_glues_created: {}\", ccx.stats.n_glues_created);\n-        println!(\"n_null_glues: {}\", ccx.stats.n_null_glues);\n-        println!(\"n_real_glues: {}\", ccx.stats.n_real_glues);\n-\n-        println!(\"n_fns: {}\", ccx.stats.n_fns);\n-        println!(\"n_monos: {}\", ccx.stats.n_monos);\n-        println!(\"n_inlines: {}\", ccx.stats.n_inlines);\n-        println!(\"n_closures: {}\", ccx.stats.n_closures);\n+        println!(\"n_static_tydescs: {}\", ccx.stats.n_static_tydescs.get());\n+        println!(\"n_glues_created: {}\", ccx.stats.n_glues_created.get());\n+        println!(\"n_null_glues: {}\", ccx.stats.n_null_glues.get());\n+        println!(\"n_real_glues: {}\", ccx.stats.n_real_glues.get());\n+\n+        println!(\"n_fns: {}\", ccx.stats.n_fns.get());\n+        println!(\"n_monos: {}\", ccx.stats.n_monos.get());\n+        println!(\"n_inlines: {}\", ccx.stats.n_inlines.get());\n+        println!(\"n_closures: {}\", ccx.stats.n_closures.get());\n         println(\"fn stats:\");\n-\n-        ccx.stats.fn_stats.sort_by(|&(_, _, insns_a), &(_, _, insns_b)| insns_b.cmp(&insns_a));\n-\n-        for tuple in ccx.stats.fn_stats.iter() {\n-            match *tuple {\n-                (ref name, ms, insns) => {\n-                    println!(\"{} insns, {} ms, {}\", insns, ms, *name);\n+        {\n+            let mut fn_stats = ccx.stats.fn_stats.borrow_mut();\n+            fn_stats.get().sort_by(|&(_, _, insns_a), &(_, _, insns_b)| {\n+                insns_b.cmp(&insns_a)\n+            });\n+            for tuple in fn_stats.get().iter() {\n+                match *tuple {\n+                    (ref name, ms, insns) => {\n+                        println!(\"{} insns, {} ms, {}\", insns, ms, *name);\n+                    }\n                 }\n             }\n         }\n     }\n     if ccx.sess.count_llvm_insns() {\n-        for (k, v) in ccx.stats.llvm_insns.iter() {\n+        let llvm_insns = ccx.stats.llvm_insns.borrow();\n+        for (k, v) in llvm_insns.get().iter() {\n             println!(\"{:7u} {}\", *v, *k);\n         }\n     }\n \n     let llcx = ccx.llcx;\n     let link_meta = ccx.link_meta.clone();\n     let llmod = ccx.llmod;\n-    let mut reachable = ccx.reachable.iter().filter_map(|id| {\n-        ccx.item_symbols.find(id).map(|s| s.to_owned())\n-    }).to_owned_vec();\n+\n+    let mut reachable = {\n+        let reachable_map = ccx.reachable.borrow();\n+        reachable_map.get().iter().filter_map(|id| {\n+            let item_symbols = ccx.item_symbols.borrow();\n+            item_symbols.get().find(id).map(|s| s.to_owned())\n+        }).to_owned_vec()\n+    };\n \n     // Make sure that some other crucial symbols are not eliminated from the\n     // module. This includes the main function, the crate map (used for debug"}, {"sha": "faf210c1a9ea0c373b746697055406051c2e23a4", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 114, "deletions": 112, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -23,12 +23,12 @@ use middle::trans::type_::Type;\n use std::cast;\n use std::libc::{c_uint, c_ulonglong, c_char};\n \n-pub fn terminate(cx: &mut Block, _: &str) {\n-    cx.terminated = true;\n+pub fn terminate(cx: &Block, _: &str) {\n+    cx.terminated.set(true);\n }\n \n pub fn check_not_terminated(cx: &Block) {\n-    if cx.terminated {\n+    if cx.terminated.get() {\n         fail!(\"already terminated!\");\n     }\n }\n@@ -47,45 +47,45 @@ pub fn B(cx: &Block) -> Builder {\n // for (fail/break/return statements, call to diverging functions, etc), and\n // further instructions to the block should simply be ignored.\n \n-pub fn RetVoid(cx: &mut Block) {\n-    if cx.unreachable { return; }\n+pub fn RetVoid(cx: &Block) {\n+    if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"RetVoid\");\n     B(cx).ret_void();\n }\n \n-pub fn Ret(cx: @mut Block, V: ValueRef) {\n-    if cx.unreachable { return; }\n+pub fn Ret(cx: @Block, V: ValueRef) {\n+    if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"Ret\");\n     B(cx).ret(V);\n }\n \n-pub fn AggregateRet(cx: @mut Block, RetVals: &[ValueRef]) {\n-    if cx.unreachable { return; }\n+pub fn AggregateRet(cx: @Block, RetVals: &[ValueRef]) {\n+    if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"AggregateRet\");\n     B(cx).aggregate_ret(RetVals);\n }\n \n-pub fn Br(cx: @mut Block, Dest: BasicBlockRef) {\n-    if cx.unreachable { return; }\n+pub fn Br(cx: @Block, Dest: BasicBlockRef) {\n+    if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"Br\");\n     B(cx).br(Dest);\n }\n \n-pub fn CondBr(cx: @mut Block, If: ValueRef, Then: BasicBlockRef,\n+pub fn CondBr(cx: @Block, If: ValueRef, Then: BasicBlockRef,\n               Else: BasicBlockRef) {\n-    if cx.unreachable { return; }\n+    if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"CondBr\");\n     B(cx).cond_br(If, Then, Else);\n }\n \n-pub fn Switch(cx: &mut Block, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n+pub fn Switch(cx: &Block, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n     -> ValueRef {\n-    if cx.unreachable { return _Undef(V); }\n+    if cx.unreachable.get() { return _Undef(V); }\n     check_not_terminated(cx);\n     terminate(cx, \"Switch\");\n     B(cx).switch(V, Else, NumCases)\n@@ -98,21 +98,21 @@ pub fn AddCase(S: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef) {\n     }\n }\n \n-pub fn IndirectBr(cx: &mut Block, Addr: ValueRef, NumDests: uint) {\n-    if cx.unreachable { return; }\n+pub fn IndirectBr(cx: &Block, Addr: ValueRef, NumDests: uint) {\n+    if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"IndirectBr\");\n     B(cx).indirect_br(Addr, NumDests);\n }\n \n-pub fn Invoke(cx: @mut Block,\n+pub fn Invoke(cx: @Block,\n               Fn: ValueRef,\n               Args: &[ValueRef],\n               Then: BasicBlockRef,\n               Catch: BasicBlockRef,\n               attributes: &[(uint, lib::llvm::Attribute)])\n            -> ValueRef {\n-    if cx.unreachable {\n+    if cx.unreachable.get() {\n         return C_null(Type::i8());\n     }\n     check_not_terminated(cx);\n@@ -123,10 +123,12 @@ pub fn Invoke(cx: @mut Block,\n     B(cx).invoke(Fn, Args, Then, Catch, attributes)\n }\n \n-pub fn Unreachable(cx: &mut Block) {\n-    if cx.unreachable { return; }\n-    cx.unreachable = true;\n-    if !cx.terminated {\n+pub fn Unreachable(cx: &Block) {\n+    if cx.unreachable.get() {\n+        return\n+    }\n+    cx.unreachable.set(true);\n+    if !cx.terminated.get() {\n         B(cx).unreachable();\n     }\n }\n@@ -139,202 +141,202 @@ pub fn _Undef(val: ValueRef) -> ValueRef {\n \n /* Arithmetic */\n pub fn Add(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).add(LHS, RHS)\n }\n \n pub fn NSWAdd(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).nswadd(LHS, RHS)\n }\n \n pub fn NUWAdd(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).nuwadd(LHS, RHS)\n }\n \n pub fn FAdd(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).fadd(LHS, RHS)\n }\n \n pub fn Sub(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).sub(LHS, RHS)\n }\n \n pub fn NSWSub(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).nswsub(LHS, RHS)\n }\n \n pub fn NUWSub(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).nuwsub(LHS, RHS)\n }\n \n pub fn FSub(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).fsub(LHS, RHS)\n }\n \n pub fn Mul(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).mul(LHS, RHS)\n }\n \n pub fn NSWMul(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).nswmul(LHS, RHS)\n }\n \n pub fn NUWMul(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).nuwmul(LHS, RHS)\n }\n \n pub fn FMul(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).fmul(LHS, RHS)\n }\n \n pub fn UDiv(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).udiv(LHS, RHS)\n }\n \n pub fn SDiv(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).sdiv(LHS, RHS)\n }\n \n pub fn ExactSDiv(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).exactsdiv(LHS, RHS)\n }\n \n pub fn FDiv(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).fdiv(LHS, RHS)\n }\n \n pub fn URem(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).urem(LHS, RHS)\n }\n \n pub fn SRem(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).srem(LHS, RHS)\n }\n \n pub fn FRem(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).frem(LHS, RHS)\n }\n \n pub fn Shl(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).shl(LHS, RHS)\n }\n \n pub fn LShr(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).lshr(LHS, RHS)\n }\n \n pub fn AShr(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).ashr(LHS, RHS)\n }\n \n pub fn And(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).and(LHS, RHS)\n }\n \n pub fn Or(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).or(LHS, RHS)\n }\n \n pub fn Xor(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).xor(LHS, RHS)\n }\n \n pub fn BinOp(cx: &Block, Op: Opcode, LHS: ValueRef, RHS: ValueRef)\n           -> ValueRef {\n-    if cx.unreachable { return _Undef(LHS); }\n+    if cx.unreachable.get() { return _Undef(LHS); }\n     B(cx).binop(Op, LHS, RHS)\n }\n \n pub fn Neg(cx: &Block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(V); }\n+    if cx.unreachable.get() { return _Undef(V); }\n     B(cx).neg(V)\n }\n \n pub fn NSWNeg(cx: &Block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(V); }\n+    if cx.unreachable.get() { return _Undef(V); }\n     B(cx).nswneg(V)\n }\n \n pub fn NUWNeg(cx: &Block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(V); }\n+    if cx.unreachable.get() { return _Undef(V); }\n     B(cx).nuwneg(V)\n }\n pub fn FNeg(cx: &Block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(V); }\n+    if cx.unreachable.get() { return _Undef(V); }\n     B(cx).fneg(V)\n }\n \n pub fn Not(cx: &Block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(V); }\n+    if cx.unreachable.get() { return _Undef(V); }\n     B(cx).not(V)\n }\n \n /* Memory */\n pub fn Malloc(cx: &Block, Ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         B(cx).malloc(Ty)\n     }\n }\n \n pub fn ArrayMalloc(cx: &Block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         B(cx).array_malloc(Ty, Val)\n     }\n }\n \n pub fn Alloca(cx: &Block, Ty: Type, name: &str) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n         let b = cx.fcx.ccx.builder();\n-        b.position_before(cx.fcx.alloca_insert_pt.unwrap());\n+        b.position_before(cx.fcx.alloca_insert_pt.get().unwrap());\n         b.alloca(Ty, name)\n     }\n }\n \n pub fn ArrayAlloca(cx: &Block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n         let b = cx.fcx.ccx.builder();\n-        b.position_before(cx.fcx.alloca_insert_pt.unwrap());\n+        b.position_before(cx.fcx.alloca_insert_pt.get().unwrap());\n         b.array_alloca(Ty, Val)\n     }\n }\n \n pub fn Free(cx: &Block, PointerVal: ValueRef) {\n-    if cx.unreachable { return; }\n+    if cx.unreachable.get() { return; }\n     B(cx).free(PointerVal)\n }\n \n pub fn Load(cx: &Block, PointerVal: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n-        if cx.unreachable {\n+        if cx.unreachable.get() {\n             let ty = val_ty(PointerVal);\n             let eltty = if ty.kind() == lib::llvm::Array {\n                 ty.element_type()\n@@ -350,7 +352,7 @@ pub fn Load(cx: &Block, PointerVal: ValueRef) -> ValueRef {\n pub fn AtomicLoad(cx: &Block, PointerVal: ValueRef, order: AtomicOrdering) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n-        if cx.unreachable {\n+        if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(ccx.int_type.to_ref());\n         }\n         B(cx).atomic_load(PointerVal, order)\n@@ -360,7 +362,7 @@ pub fn AtomicLoad(cx: &Block, PointerVal: ValueRef, order: AtomicOrdering) -> Va\n \n pub fn LoadRangeAssert(cx: &Block, PointerVal: ValueRef, lo: c_ulonglong,\n                        hi: c_ulonglong, signed: lib::llvm::Bool) -> ValueRef {\n-    if cx.unreachable {\n+    if cx.unreachable.get() {\n         let ccx = cx.fcx.ccx;\n         let ty = val_ty(PointerVal);\n         let eltty = if ty.kind() == lib::llvm::Array {\n@@ -377,18 +379,18 @@ pub fn LoadRangeAssert(cx: &Block, PointerVal: ValueRef, lo: c_ulonglong,\n }\n \n pub fn Store(cx: &Block, Val: ValueRef, Ptr: ValueRef) {\n-    if cx.unreachable { return; }\n+    if cx.unreachable.get() { return; }\n     B(cx).store(Val, Ptr)\n }\n \n pub fn AtomicStore(cx: &Block, Val: ValueRef, Ptr: ValueRef, order: AtomicOrdering) {\n-    if cx.unreachable { return; }\n+    if cx.unreachable.get() { return; }\n     B(cx).atomic_store(Val, Ptr, order)\n }\n \n pub fn GEP(cx: &Block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         B(cx).gep(Pointer, Indices)\n     }\n }\n@@ -398,170 +400,170 @@ pub fn GEP(cx: &Block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n #[inline]\n pub fn GEPi(cx: &Block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         B(cx).gepi(base, ixs)\n     }\n }\n \n pub fn InBoundsGEP(cx: &Block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         B(cx).inbounds_gep(Pointer, Indices)\n     }\n }\n \n pub fn StructGEP(cx: &Block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         B(cx).struct_gep(Pointer, Idx)\n     }\n }\n \n pub fn GlobalString(cx: &Block, _Str: *c_char) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         B(cx).global_string(_Str)\n     }\n }\n \n pub fn GlobalStringPtr(cx: &Block, _Str: *c_char) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         B(cx).global_string_ptr(_Str)\n     }\n }\n \n /* Casts */\n pub fn Trunc(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).trunc(Val, DestTy)\n     }\n }\n \n pub fn ZExt(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).zext(Val, DestTy)\n     }\n }\n \n pub fn SExt(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).sext(Val, DestTy)\n     }\n }\n \n pub fn FPToUI(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fptoui(Val, DestTy)\n     }\n }\n \n pub fn FPToSI(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fptosi(Val, DestTy)\n     }\n }\n \n pub fn UIToFP(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).uitofp(Val, DestTy)\n     }\n }\n \n pub fn SIToFP(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).sitofp(Val, DestTy)\n     }\n }\n \n pub fn FPTrunc(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fptrunc(Val, DestTy)\n     }\n }\n \n pub fn FPExt(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fpext(Val, DestTy)\n     }\n }\n \n pub fn PtrToInt(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).ptrtoint(Val, DestTy)\n     }\n }\n \n pub fn IntToPtr(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).inttoptr(Val, DestTy)\n     }\n }\n \n pub fn BitCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).bitcast(Val, DestTy)\n     }\n }\n \n pub fn ZExtOrBitCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).zext_or_bitcast(Val, DestTy)\n     }\n }\n \n pub fn SExtOrBitCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).sext_or_bitcast(Val, DestTy)\n     }\n }\n \n pub fn TruncOrBitCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).trunc_or_bitcast(Val, DestTy)\n     }\n }\n \n pub fn Cast(cx: &Block, Op: Opcode, Val: ValueRef, DestTy: Type, _: *u8)\n      -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).cast(Op, Val, DestTy)\n     }\n }\n \n pub fn PointerCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).pointercast(Val, DestTy)\n     }\n }\n \n pub fn IntCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).intcast(Val, DestTy)\n     }\n }\n \n pub fn FPCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fpcast(Val, DestTy)\n     }\n }\n@@ -571,30 +573,30 @@ pub fn FPCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n pub fn ICmp(cx: &Block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n      -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         B(cx).icmp(Op, LHS, RHS)\n     }\n }\n \n pub fn FCmp(cx: &Block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n      -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         B(cx).fcmp(Op, LHS, RHS)\n     }\n }\n \n /* Miscellaneous instructions */\n pub fn EmptyPhi(cx: &Block, Ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         B(cx).empty_phi(Ty)\n     }\n }\n \n pub fn Phi(cx: &Block, Ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef]) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         B(cx).phi(Ty, vals, bbs)\n     }\n }\n@@ -639,116 +641,116 @@ pub fn InlineAsmCall(cx: &Block, asm: *c_char, cons: *c_char,\n \n pub fn Call(cx: &Block, Fn: ValueRef, Args: &[ValueRef],\n             attributes: &[(uint, lib::llvm::Attribute)]) -> ValueRef {\n-    if cx.unreachable { return _UndefReturn(cx, Fn); }\n+    if cx.unreachable.get() { return _UndefReturn(cx, Fn); }\n     B(cx).call(Fn, Args, attributes)\n }\n \n pub fn CallWithConv(cx: &Block, Fn: ValueRef, Args: &[ValueRef], Conv: CallConv,\n                     attributes: &[(uint, lib::llvm::Attribute)]) -> ValueRef {\n-    if cx.unreachable { return _UndefReturn(cx, Fn); }\n+    if cx.unreachable.get() { return _UndefReturn(cx, Fn); }\n     B(cx).call_with_conv(Fn, Args, Conv, attributes)\n }\n \n pub fn AtomicFence(cx: &Block, order: AtomicOrdering) {\n-    if cx.unreachable { return; }\n+    if cx.unreachable.get() { return; }\n     B(cx).atomic_fence(order)\n }\n \n pub fn Select(cx: &Block, If: ValueRef, Then: ValueRef, Else: ValueRef) -> ValueRef {\n-    if cx.unreachable { return _Undef(Then); }\n+    if cx.unreachable.get() { return _Undef(Then); }\n     B(cx).select(If, Then, Else)\n }\n \n pub fn VAArg(cx: &Block, list: ValueRef, Ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         B(cx).va_arg(list, Ty)\n     }\n }\n \n pub fn ExtractElement(cx: &Block, VecVal: ValueRef, Index: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).extract_element(VecVal, Index)\n     }\n }\n \n pub fn InsertElement(cx: &Block, VecVal: ValueRef, EltVal: ValueRef,\n                      Index: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).insert_element(VecVal, EltVal, Index)\n     }\n }\n \n pub fn ShuffleVector(cx: &Block, V1: ValueRef, V2: ValueRef,\n                      Mask: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).shuffle_vector(V1, V2, Mask)\n     }\n }\n \n pub fn VectorSplat(cx: &Block, NumElts: uint, EltVal: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).vector_splat(NumElts, EltVal)\n     }\n }\n \n pub fn ExtractValue(cx: &Block, AggVal: ValueRef, Index: uint) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).extract_value(AggVal, Index)\n     }\n }\n \n pub fn InsertValue(cx: &Block, AggVal: ValueRef, EltVal: ValueRef, Index: uint) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).insert_value(AggVal, EltVal, Index)\n     }\n }\n \n pub fn IsNull(cx: &Block, Val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         B(cx).is_null(Val)\n     }\n }\n \n pub fn IsNotNull(cx: &Block, Val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         B(cx).is_not_null(Val)\n     }\n }\n \n pub fn PtrDiff(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n-        if cx.unreachable { return llvm::LLVMGetUndef(ccx.int_type.to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(ccx.int_type.to_ref()); }\n         B(cx).ptrdiff(LHS, RHS)\n     }\n }\n \n pub fn Trap(cx: &Block) {\n-    if cx.unreachable { return; }\n+    if cx.unreachable.get() { return; }\n     B(cx).trap();\n }\n \n pub fn LandingPad(cx: &Block, Ty: Type, PersFn: ValueRef,\n                   NumClauses: uint) -> ValueRef {\n     check_not_terminated(cx);\n-    assert!(!cx.unreachable);\n+    assert!(!cx.unreachable.get());\n     B(cx).landing_pad(Ty, PersFn, NumClauses)\n }\n \n pub fn SetCleanup(cx: &Block, LandingPad: ValueRef) {\n     B(cx).set_cleanup(LandingPad)\n }\n \n-pub fn Resume(cx: @mut Block, Exn: ValueRef) -> ValueRef {\n+pub fn Resume(cx: @Block, Exn: ValueRef) -> ValueRef {\n     check_not_terminated(cx);\n     terminate(cx, \"Resume\");\n     B(cx).resume(Exn)"}, {"sha": "eacc6f84db11874ffa25942299a3a330e12a85f7", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -25,7 +25,7 @@ use std::ptr::is_not_null;\n \n pub struct Builder {\n     llbuilder: BuilderRef,\n-    ccx: @mut CrateContext,\n+    ccx: @CrateContext,\n }\n \n // This is a really awful way to get a zero-length c-string, but better (and a\n@@ -38,7 +38,7 @@ pub fn noname() -> *c_char {\n }\n \n impl Builder {\n-    pub fn new(ccx: @mut CrateContext) -> Builder {\n+    pub fn new(ccx: @CrateContext) -> Builder {\n         Builder {\n             llbuilder: ccx.builder.B,\n             ccx: ccx,\n@@ -47,11 +47,14 @@ impl Builder {\n \n     pub fn count_insn(&self, category: &str) {\n         if self.ccx.sess.trans_stats() {\n-            self.ccx.stats.n_llvm_insns += 1;\n+            self.ccx.stats.n_llvm_insns.set(self.ccx\n+                                                .stats\n+                                                .n_llvm_insns\n+                                                .get() + 1);\n         }\n         if self.ccx.sess.count_llvm_insns() {\n             base::with_insn_ctxt(|v| {\n-                let h = &mut self.ccx.stats.llvm_insns;\n+                let mut h = self.ccx.stats.llvm_insns.borrow_mut();\n \n                 // Build version of path with cycles removed.\n \n@@ -79,11 +82,11 @@ impl Builder {\n                 s.push_char('/');\n                 s.push_str(category);\n \n-                let n = match h.find(&s) {\n+                let n = match h.get().find(&s) {\n                     Some(&n) => n,\n                     _ => 0u\n                 };\n-                h.insert(s, n+1u);\n+                h.get().insert(s, n+1u);\n             })\n         }\n     }"}, {"sha": "bb05221ae10190880eb1add628ad1438fe90c3a4", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -89,7 +89,7 @@ pub struct FnType {\n     ret_ty: ArgType,\n }\n \n-pub fn compute_abi_info(ccx: &mut CrateContext,\n+pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {"}, {"sha": "a73c098805d6a9898910110252c18beb43ad41fd", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -127,7 +127,7 @@ fn is_reg_ty(ty: Type) -> bool {\n     }\n }\n \n-pub fn compute_abi_info(_ccx: &mut CrateContext,\n+pub fn compute_abi_info(_ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {"}, {"sha": "54155cd3f7825f05aa7ceed61f6abdb2c7f88dc5", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -158,7 +158,7 @@ fn struct_ty(ty: Type) -> Type {\n     return Type::struct_(fields, false);\n }\n \n-pub fn compute_abi_info(_ccx: &mut CrateContext,\n+pub fn compute_abi_info(_ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {"}, {"sha": "616dc0703a73e7616c4e8369c9fab3a4ba6c1c47", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -16,7 +16,7 @@ use super::common::*;\n use super::machine::*;\n use middle::trans::type_::Type;\n \n-pub fn compute_abi_info(ccx: &mut CrateContext,\n+pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {"}, {"sha": "564efa8c06864770cebfe9bacefb1aeac04a4770", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -332,7 +332,7 @@ fn llreg_ty(cls: &[RegClass]) -> Type {\n     return Type::struct_(tys, false);\n }\n \n-pub fn compute_abi_info(_ccx: &mut CrateContext,\n+pub fn compute_abi_info(_ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {"}, {"sha": "df916f0463bcef67048b15d38b231e65acf96793", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -71,11 +71,11 @@ pub enum CalleeData {\n }\n \n pub struct Callee {\n-    bcx: @mut Block,\n+    bcx: @Block,\n     data: CalleeData\n }\n \n-pub fn trans(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n+pub fn trans(bcx: @Block, expr: &ast::Expr) -> Callee {\n     let _icx = push_ctxt(\"trans_callee\");\n     debug!(\"callee::trans(expr={})\", expr.repr(bcx.tcx()));\n \n@@ -90,7 +90,7 @@ pub fn trans(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n     // any other expressions are closures:\n     return datum_callee(bcx, expr);\n \n-    fn datum_callee(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n+    fn datum_callee(bcx: @Block, expr: &ast::Expr) -> Callee {\n         let DatumBlock {bcx, datum} = expr::trans_to_datum(bcx, expr);\n         match ty::get(datum.ty).sty {\n             ty::ty_bare_fn(..) => {\n@@ -109,11 +109,11 @@ pub fn trans(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n         }\n     }\n \n-    fn fn_callee(bcx: @mut Block, fd: FnData) -> Callee {\n+    fn fn_callee(bcx: @Block, fd: FnData) -> Callee {\n         return Callee {bcx: bcx, data: Fn(fd)};\n     }\n \n-    fn trans_def(bcx: @mut Block, def: ast::Def, ref_expr: &ast::Expr) -> Callee {\n+    fn trans_def(bcx: @Block, def: ast::Def, ref_expr: &ast::Expr) -> Callee {\n         match def {\n             ast::DefFn(did, _) |\n             ast::DefStaticMethod(did, ast::FromImpl(_), _) => {\n@@ -158,14 +158,14 @@ pub fn trans(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n     }\n }\n \n-pub fn trans_fn_ref_to_callee(bcx: @mut Block,\n+pub fn trans_fn_ref_to_callee(bcx: @Block,\n                               def_id: ast::DefId,\n                               ref_id: ast::NodeId) -> Callee {\n     Callee {bcx: bcx,\n             data: Fn(trans_fn_ref(bcx, def_id, ref_id))}\n }\n \n-pub fn trans_fn_ref(bcx: @mut Block,\n+pub fn trans_fn_ref(bcx: @Block,\n                     def_id: ast::DefId,\n                     ref_id: ast::NodeId) -> FnData {\n     /*!\n@@ -185,7 +185,7 @@ pub fn trans_fn_ref(bcx: @mut Block,\n }\n \n pub fn trans_fn_ref_with_vtables_to_callee(\n-        bcx: @mut Block,\n+        bcx: @Block,\n         def_id: ast::DefId,\n         ref_id: ast::NodeId,\n         type_params: &[ty::t],\n@@ -196,7 +196,7 @@ pub fn trans_fn_ref_with_vtables_to_callee(\n                                                type_params, vtables))}\n }\n \n-fn resolve_default_method_vtables(bcx: @mut Block,\n+fn resolve_default_method_vtables(bcx: @Block,\n                                   impl_id: ast::DefId,\n                                   method: &ty::Method,\n                                   substs: &ty::substs,\n@@ -239,7 +239,7 @@ fn resolve_default_method_vtables(bcx: @mut Block,\n \n \n pub fn trans_fn_ref_with_vtables(\n-        bcx: @mut Block,       //\n+        bcx: @Block,       //\n         def_id: ast::DefId,   // def id of fn\n         ref_id: ast::NodeId,  // node id of use of fn; may be zero if N/A\n         type_params: &[ty::t], // values for fn's ty params\n@@ -444,13 +444,13 @@ pub fn trans_fn_ref_with_vtables(\n // ______________________________________________________________________\n // Translating calls\n \n-pub fn trans_call(in_cx: @mut Block,\n+pub fn trans_call(in_cx: @Block,\n                   call_ex: &ast::Expr,\n                   f: &ast::Expr,\n                   args: CallArgs,\n                   id: ast::NodeId,\n                   dest: expr::Dest)\n-                  -> @mut Block {\n+                  -> @Block {\n     let _icx = push_ctxt(\"trans_call\");\n     trans_call_inner(in_cx,\n                      call_ex.info(),\n@@ -462,13 +462,13 @@ pub fn trans_call(in_cx: @mut Block,\n                      DontAutorefArg).bcx\n }\n \n-pub fn trans_method_call(in_cx: @mut Block,\n+pub fn trans_method_call(in_cx: @Block,\n                          call_ex: &ast::Expr,\n                          callee_id: ast::NodeId,\n                          rcvr: &ast::Expr,\n                          args: CallArgs,\n                          dest: expr::Dest)\n-                         -> @mut Block {\n+                         -> @Block {\n     let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_ex={}, rcvr={})\",\n            call_ex.repr(in_cx.tcx()),\n@@ -479,7 +479,11 @@ pub fn trans_method_call(in_cx: @mut Block,\n         node_id_type(in_cx, callee_id),\n         expr_ty(in_cx, call_ex),\n         |cx| {\n-            match cx.ccx().maps.method_map.find_copy(&call_ex.id) {\n+            let origin_opt = {\n+                let mut method_map = cx.ccx().maps.method_map.borrow_mut();\n+                method_map.get().find_copy(&call_ex.id)\n+            };\n+            match origin_opt {\n                 Some(origin) => {\n                     debug!(\"origin for {}: {}\",\n                            call_ex.repr(in_cx.tcx()),\n@@ -500,7 +504,7 @@ pub fn trans_method_call(in_cx: @mut Block,\n         DontAutorefArg).bcx\n }\n \n-pub fn trans_lang_call(bcx: @mut Block,\n+pub fn trans_lang_call(bcx: @Block,\n                        did: ast::DefId,\n                        args: &[ValueRef],\n                        dest: Option<expr::Dest>)\n@@ -527,12 +531,12 @@ pub fn trans_lang_call(bcx: @mut Block,\n                              DontAutorefArg)\n }\n \n-pub fn trans_lang_call_with_type_params(bcx: @mut Block,\n+pub fn trans_lang_call_with_type_params(bcx: @Block,\n                                         did: ast::DefId,\n                                         args: &[ValueRef],\n                                         type_params: &[ty::t],\n                                         dest: expr::Dest)\n-    -> @mut Block {\n+    -> @Block {\n     let fty;\n     if did.crate == ast::LOCAL_CRATE {\n         fty = ty::node_id_to_type(bcx.tcx(), did.node);\n@@ -567,11 +571,11 @@ pub fn trans_lang_call_with_type_params(bcx: @mut Block,\n         ArgVals(args), Some(dest), DontAutorefArg).bcx;\n }\n \n-pub fn trans_call_inner(in_cx: @mut Block,\n+pub fn trans_call_inner(in_cx: @Block,\n                         call_info: Option<NodeInfo>,\n                         callee_ty: ty::t,\n                         ret_ty: ty::t,\n-                        get_callee: |@mut Block| -> Callee,\n+                        get_callee: |@Block| -> Callee,\n                         args: CallArgs,\n                         dest: Option<expr::Dest>,\n                         autoref_arg: AutorefArg)\n@@ -755,11 +759,11 @@ pub enum CallArgs<'a> {\n     ArgVals(&'a [ValueRef])\n }\n \n-pub fn trans_args(cx: @mut Block,\n+pub fn trans_args(cx: @Block,\n                   args: CallArgs,\n                   fn_ty: ty::t,\n                   autoref_arg: AutorefArg,\n-                  llargs: &mut ~[ValueRef]) -> @mut Block\n+                  llargs: &mut ~[ValueRef]) -> @Block\n {\n     let _icx = push_ctxt(\"trans_args\");\n     let mut temp_cleanups = ~[];\n@@ -814,7 +818,7 @@ pub enum AutorefArg {\n \n // temp_cleanups: cleanups that should run only if failure occurs before the\n // call takes place:\n-pub fn trans_arg_expr(bcx: @mut Block,\n+pub fn trans_arg_expr(bcx: @Block,\n                       formal_arg_ty: ty::t,\n                       self_mode: ty::SelfMode,\n                       arg_expr: &ast::Expr,"}, {"sha": "1d56601cfba44910fbef7a45348b6e185662a71a", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -155,15 +155,15 @@ pub fn mk_closure_tys(tcx: ty::ctxt,\n     return cdata_ty;\n }\n \n-fn heap_for_unique_closure(bcx: @mut Block, t: ty::t) -> heap {\n+fn heap_for_unique_closure(bcx: @Block, t: ty::t) -> heap {\n     if ty::type_contents(bcx.tcx(), t).owns_managed() {\n         heap_managed_unique\n     } else {\n         heap_exchange_closure\n     }\n }\n \n-pub fn allocate_cbox(bcx: @mut Block, sigil: ast::Sigil, cdata_ty: ty::t)\n+pub fn allocate_cbox(bcx: @Block, sigil: ast::Sigil, cdata_ty: ty::t)\n                   -> Result {\n     let _icx = push_ctxt(\"closure::allocate_cbox\");\n     let ccx = bcx.ccx();\n@@ -188,14 +188,14 @@ pub fn allocate_cbox(bcx: @mut Block, sigil: ast::Sigil, cdata_ty: ty::t)\n pub struct ClosureResult {\n     llbox: ValueRef, // llvalue of ptr to closure\n     cdata_ty: ty::t, // type of the closure data\n-    bcx: @mut Block       // final bcx\n+    bcx: @Block       // final bcx\n }\n \n // Given a block context and a list of tydescs and values to bind\n // construct a closure out of them. If copying is true, it is a\n // heap allocated closure that copies the upvars into environment.\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n-pub fn store_environment(bcx: @mut Block,\n+pub fn store_environment(bcx: @Block,\n                          bound_values: ~[EnvValue],\n                          sigil: ast::Sigil)\n                          -> ClosureResult {\n@@ -257,7 +257,7 @@ pub fn store_environment(bcx: @mut Block,\n \n // Given a context and a list of upvars, build a closure. This just\n // collects the upvars and packages them up for store_environment.\n-pub fn build_closure(bcx0: @mut Block,\n+pub fn build_closure(bcx0: @Block,\n                      cap_vars: &[moves::CaptureVar],\n                      sigil: ast::Sigil) -> ClosureResult {\n     let _icx = push_ctxt(\"closure::build_closure\");\n@@ -293,7 +293,7 @@ pub fn build_closure(bcx0: @mut Block,\n // Given an enclosing block context, a new function context, a closure type,\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n-pub fn load_environment(fcx: @mut FunctionContext,\n+pub fn load_environment(fcx: @FunctionContext,\n                         cdata_ty: ty::t,\n                         cap_vars: &[moves::CaptureVar],\n                         sigil: ast::Sigil) {\n@@ -304,10 +304,10 @@ pub fn load_environment(fcx: @mut FunctionContext,\n         return;\n     }\n \n-    let bcx = fcx.entry_bcx.unwrap();\n+    let bcx = fcx.entry_bcx.get().unwrap();\n \n     // Load a pointer to the closure data, skipping over the box header:\n-    let llcdata = opaque_box_body(bcx, cdata_ty, fcx.llenv);\n+    let llcdata = opaque_box_body(bcx, cdata_ty, fcx.llenv.get());\n \n     // Store the pointer to closure data in an alloca for debug info because that's what the\n     // llvm.dbg.declare intrinsic expects\n@@ -328,7 +328,11 @@ pub fn load_environment(fcx: @mut FunctionContext,\n             ast::ManagedSigil | ast::OwnedSigil => {}\n         }\n         let def_id = ast_util::def_id_of_def(cap_var.def);\n-        fcx.llupvars.insert(def_id.node, upvarptr);\n+\n+        {\n+            let mut llupvars = fcx.llupvars.borrow_mut();\n+            llupvars.get().insert(def_id.node, upvarptr);\n+        }\n \n         for &env_pointer_alloca in env_pointer_alloca.iter() {\n             debuginfo::create_captured_var_metadata(\n@@ -345,13 +349,13 @@ pub fn load_environment(fcx: @mut FunctionContext,\n     }\n }\n \n-pub fn trans_expr_fn(bcx: @mut Block,\n+pub fn trans_expr_fn(bcx: @Block,\n                      sigil: ast::Sigil,\n                      decl: &ast::fn_decl,\n                      body: &ast::Block,\n                      outer_id: ast::NodeId,\n                      user_id: ast::NodeId,\n-                     dest: expr::Dest) -> @mut Block {\n+                     dest: expr::Dest) -> @Block {\n     /*!\n      *\n      * Translates the body of a closure expression.\n@@ -400,7 +404,10 @@ pub fn trans_expr_fn(bcx: @mut Block,\n \n     let Result {bcx: bcx, val: closure} = match sigil {\n         ast::BorrowedSigil | ast::ManagedSigil | ast::OwnedSigil => {\n-            let cap_vars = ccx.maps.capture_map.get_copy(&user_id);\n+            let cap_vars = {\n+                let capture_map = ccx.maps.capture_map.borrow();\n+                capture_map.get().get_copy(&user_id)\n+            };\n             let ClosureResult {llbox, cdata_ty, bcx}\n                 = build_closure(bcx, cap_vars, sigil);\n             trans_closure(ccx,\n@@ -422,12 +429,12 @@ pub fn trans_expr_fn(bcx: @mut Block,\n     return bcx;\n }\n \n-pub fn make_closure_glue(cx: @mut Block,\n+pub fn make_closure_glue(cx: @Block,\n                          v: ValueRef,\n                          t: ty::t,\n-                         glue_fn: |@mut Block, v: ValueRef, t: ty::t|\n-                                   -> @mut Block)\n-                         -> @mut Block {\n+                         glue_fn: |@Block, v: ValueRef, t: ty::t|\n+                                   -> @Block)\n+                         -> @Block {\n     let _icx = push_ctxt(\"closure::make_closure_glue\");\n     let bcx = cx;\n     let tcx = cx.tcx();\n@@ -447,10 +454,10 @@ pub fn make_closure_glue(cx: @mut Block,\n }\n \n pub fn make_opaque_cbox_drop_glue(\n-    bcx: @mut Block,\n+    bcx: @Block,\n     sigil: ast::Sigil,\n     cboxptr: ValueRef)     // ptr to the opaque closure\n-    -> @mut Block {\n+    -> @Block {\n     let _icx = push_ctxt(\"closure::make_opaque_cbox_drop_glue\");\n     match sigil {\n         ast::BorrowedSigil => bcx,\n@@ -465,11 +472,11 @@ pub fn make_opaque_cbox_drop_glue(\n     }\n }\n \n-pub fn make_opaque_cbox_free_glue(\n-    bcx: @mut Block,\n-    sigil: ast::Sigil,\n-    cbox: ValueRef)     // ptr to ptr to the opaque closure\n-    -> @mut Block {\n+/// `cbox` is a pointer to a pointer to an opaque closure.\n+pub fn make_opaque_cbox_free_glue(bcx: @Block,\n+                                  sigil: ast::Sigil,\n+                                  cbox: ValueRef)\n+                                  -> @Block {\n     let _icx = push_ctxt(\"closure::make_opaque_cbox_free_glue\");\n     match sigil {\n         ast::BorrowedSigil => {"}, {"sha": "0fadcbe53be09dbda230b9c8e2ecdd0b877e02bd", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 189, "deletions": 152, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -35,6 +35,7 @@ use middle::trans::type_::Type;\n use std::c_str::ToCStr;\n use std::cast::transmute;\n use std::cast;\n+use std::cell::{Cell, RefCell};\n use std::hashmap::HashMap;\n use std::libc::{c_uint, c_longlong, c_ulonglong, c_char};\n use std::vec;\n@@ -46,7 +47,7 @@ use syntax::{ast, ast_map};\n \n pub use middle::trans::context::CrateContext;\n \n-fn type_is_newtype_immediate(ccx: &mut CrateContext, ty: ty::t) -> bool {\n+fn type_is_newtype_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n     match ty::get(ty).sty {\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::struct_fields(ccx.tcx, def_id, substs);\n@@ -58,7 +59,7 @@ fn type_is_newtype_immediate(ccx: &mut CrateContext, ty: ty::t) -> bool {\n     }\n }\n \n-pub fn type_is_immediate(ccx: &mut CrateContext, ty: ty::t) -> bool {\n+pub fn type_is_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n     use middle::trans::machine::llsize_of_alloc;\n     use middle::trans::type_of::sizing_type_of;\n     let tcx = ccx.tcx;\n@@ -92,10 +93,10 @@ pub struct tydesc_info {\n     align: ValueRef,\n     borrow_offset: ValueRef,\n     name: ValueRef,\n-    take_glue: Option<ValueRef>,\n-    drop_glue: Option<ValueRef>,\n-    free_glue: Option<ValueRef>,\n-    visit_glue: Option<ValueRef>\n+    take_glue: Cell<Option<ValueRef>>,\n+    drop_glue: Cell<Option<ValueRef>>,\n+    free_glue: Cell<Option<ValueRef>>,\n+    visit_glue: Cell<Option<ValueRef>>,\n }\n \n /*\n@@ -125,18 +126,18 @@ pub struct tydesc_info {\n  */\n \n pub struct Stats {\n-    n_static_tydescs: uint,\n-    n_glues_created: uint,\n-    n_null_glues: uint,\n-    n_real_glues: uint,\n-    n_fns: uint,\n-    n_monos: uint,\n-    n_inlines: uint,\n-    n_closures: uint,\n-    n_llvm_insns: uint,\n-    llvm_insn_ctxt: ~[~str],\n-    llvm_insns: HashMap<~str, uint>,\n-    fn_stats: ~[(~str, uint, uint)] // (ident, time-in-ms, llvm-instructions)\n+    n_static_tydescs: Cell<uint>,\n+    n_glues_created: Cell<uint>,\n+    n_null_glues: Cell<uint>,\n+    n_real_glues: Cell<uint>,\n+    n_fns: Cell<uint>,\n+    n_monos: Cell<uint>,\n+    n_inlines: Cell<uint>,\n+    n_closures: Cell<uint>,\n+    n_llvm_insns: Cell<uint>,\n+    llvm_insns: RefCell<HashMap<~str, uint>>,\n+    // (ident, time-in-ms, llvm-instructions)\n+    fn_stats: RefCell<~[(~str, uint, uint)]>,\n }\n \n pub struct BuilderRef_res {\n@@ -205,46 +206,46 @@ pub struct FunctionContext {\n \n     // The implicit environment argument that arrives in the function we're\n     // creating.\n-    llenv: ValueRef,\n+    llenv: Cell<ValueRef>,\n \n     // The place to store the return value. If the return type is immediate,\n     // this is an alloca in the function. Otherwise, it's the hidden first\n     // parameter to the function. After function construction, this should\n     // always be Some.\n-    llretptr: Option<ValueRef>,\n+    llretptr: Cell<Option<ValueRef>>,\n \n-    entry_bcx: Option<@mut Block>,\n+    entry_bcx: RefCell<Option<@Block>>,\n \n     // These elements: \"hoisted basic blocks\" containing\n     // administrative activities that have to happen in only one place in\n     // the function, due to LLVM's quirks.\n     // A marker for the place where we want to insert the function's static\n     // allocas, so that LLVM will coalesce them into a single alloca call.\n-    alloca_insert_pt: Option<ValueRef>,\n-    llreturn: Option<BasicBlockRef>,\n+    alloca_insert_pt: Cell<Option<ValueRef>>,\n+    llreturn: Cell<Option<BasicBlockRef>>,\n     // The 'self' value currently in use in this function, if there\n     // is one.\n     //\n     // NB: This is the type of the self *variable*, not the self *type*. The\n     // self type is set only for default methods, while the self variable is\n     // set for all methods.\n-    llself: Option<ValSelfData>,\n+    llself: Cell<Option<ValSelfData>>,\n     // The a value alloca'd for calls to upcalls.rust_personality. Used when\n     // outputting the resume instruction.\n-    personality: Option<ValueRef>,\n+    personality: Cell<Option<ValueRef>>,\n \n     // True if the caller expects this fn to use the out pointer to\n     // return. Either way, your code should write into llretptr, but if\n     // this value is false, llretptr will be a local alloca.\n     caller_expects_out_pointer: bool,\n \n     // Maps arguments to allocas created for them in llallocas.\n-    llargs: @mut HashMap<ast::NodeId, ValueRef>,\n+    llargs: RefCell<HashMap<ast::NodeId, ValueRef>>,\n     // Maps the def_ids for local variables to the allocas created for\n     // them in llallocas.\n-    lllocals: @mut HashMap<ast::NodeId, ValueRef>,\n+    lllocals: RefCell<HashMap<ast::NodeId, ValueRef>>,\n     // Same as above, but for closure upvars\n-    llupvars: @mut HashMap<ast::NodeId, ValueRef>,\n+    llupvars: RefCell<HashMap<ast::NodeId, ValueRef>>,\n \n     // The NodeId of the function, or -1 if it doesn't correspond to\n     // a user-defined function.\n@@ -260,7 +261,7 @@ pub struct FunctionContext {\n     path: path,\n \n     // This function's enclosing crate context.\n-    ccx: @mut CrateContext,\n+    ccx: @CrateContext,\n \n     // Used and maintained by the debuginfo module.\n     debug_context: debuginfo::FunctionDebugContext,\n@@ -288,26 +289,28 @@ impl FunctionContext {\n         }\n     }\n \n-    pub fn cleanup(&mut self) {\n+    pub fn cleanup(&self) {\n         unsafe {\n-            llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt.unwrap());\n+            llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt\n+                                                     .get()\n+                                                     .unwrap());\n         }\n         // Remove the cycle between fcx and bcx, so memory can be freed\n-        self.entry_bcx = None;\n+        self.entry_bcx.set(None);\n     }\n \n-    pub fn get_llreturn(&mut self) -> BasicBlockRef {\n-        if self.llreturn.is_none() {\n-            self.llreturn = Some(base::mk_return_basic_block(self.llfn));\n+    pub fn get_llreturn(&self) -> BasicBlockRef {\n+        if self.llreturn.get().is_none() {\n+            self.llreturn.set(Some(base::mk_return_basic_block(self.llfn)));\n         }\n \n-        self.llreturn.unwrap()\n+        self.llreturn.get().unwrap()\n     }\n }\n \n-pub fn warn_not_to_commit(ccx: &mut CrateContext, msg: &str) {\n-    if !ccx.do_not_commit_warning_issued {\n-        ccx.do_not_commit_warning_issued = true;\n+pub fn warn_not_to_commit(ccx: &CrateContext, msg: &str) {\n+    if !ccx.do_not_commit_warning_issued.get() {\n+        ccx.do_not_commit_warning_issued.set(true);\n         ccx.sess.warn(msg.to_str() + \" -- do not commit like this!\");\n     }\n }\n@@ -331,7 +334,7 @@ pub enum cleantype {\n \n /// A cleanup function: a built-in destructor.\n pub trait CleanupFunction {\n-    fn clean(&self, block: @mut Block) -> @mut Block;\n+    fn clean(&self, block: @Block) -> @Block;\n }\n \n /// A cleanup function that calls the \"drop glue\" (destructor function) on\n@@ -342,7 +345,7 @@ pub struct TypeDroppingCleanupFunction {\n }\n \n impl CleanupFunction for TypeDroppingCleanupFunction {\n-    fn clean(&self, block: @mut Block) -> @mut Block {\n+    fn clean(&self, block: @Block) -> @Block {\n         glue::drop_ty(block, self.val, self.t)\n     }\n }\n@@ -355,7 +358,7 @@ pub struct ImmediateTypeDroppingCleanupFunction {\n }\n \n impl CleanupFunction for ImmediateTypeDroppingCleanupFunction {\n-    fn clean(&self, block: @mut Block) -> @mut Block {\n+    fn clean(&self, block: @Block) -> @Block {\n         glue::drop_ty_immediate(block, self.val, self.t)\n     }\n }\n@@ -371,7 +374,7 @@ pub struct WriteGuardReleasingCleanupFunction {\n }\n \n impl CleanupFunction for WriteGuardReleasingCleanupFunction {\n-    fn clean(&self, bcx: @mut Block) -> @mut Block {\n+    fn clean(&self, bcx: @Block) -> @Block {\n         write_guard::return_to_mut(bcx,\n                                    self.root_key,\n                                    self.frozen_val_ref,\n@@ -387,7 +390,7 @@ pub struct GCHeapFreeingCleanupFunction {\n }\n \n impl CleanupFunction for GCHeapFreeingCleanupFunction {\n-    fn clean(&self, bcx: @mut Block) -> @mut Block {\n+    fn clean(&self, bcx: @Block) -> @Block {\n         glue::trans_free(bcx, self.ptr)\n     }\n }\n@@ -398,7 +401,7 @@ pub struct ExchangeHeapFreeingCleanupFunction {\n }\n \n impl CleanupFunction for ExchangeHeapFreeingCleanupFunction {\n-    fn clean(&self, bcx: @mut Block) -> @mut Block {\n+    fn clean(&self, bcx: @Block) -> @Block {\n         glue::trans_exchange_free(bcx, self.ptr)\n     }\n }\n@@ -427,14 +430,21 @@ pub struct cleanup_path {\n     dest: BasicBlockRef\n }\n \n-pub fn shrink_scope_clean(scope_info: &mut ScopeInfo, size: uint) {\n-    scope_info.landing_pad = None;\n-    scope_info.cleanup_paths = scope_info.cleanup_paths.iter()\n-            .take_while(|&cu| cu.size <= size).map(|&x|x).collect();\n+pub fn shrink_scope_clean(scope_info: &ScopeInfo, size: uint) {\n+    scope_info.landing_pad.set(None);\n+    let new_cleanup_paths = {\n+        let cleanup_paths = scope_info.cleanup_paths.borrow();\n+        cleanup_paths.get()\n+                     .iter()\n+                     .take_while(|&cu| cu.size <= size)\n+                     .map(|&x| x)\n+                     .collect()\n+    };\n+    scope_info.cleanup_paths.set(new_cleanup_paths)\n }\n \n-pub fn grow_scope_clean(scope_info: &mut ScopeInfo) {\n-    scope_info.landing_pad = None;\n+pub fn grow_scope_clean(scope_info: &ScopeInfo) {\n+    scope_info.landing_pad.set(None);\n }\n \n pub fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n@@ -445,7 +455,7 @@ pub fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n     }\n }\n \n-pub fn add_clean(bcx: @mut Block, val: ValueRef, t: ty::t) {\n+pub fn add_clean(bcx: @Block, val: ValueRef, t: ty::t) {\n     if !ty::type_needs_drop(bcx.tcx(), t) {\n         return\n     }\n@@ -454,61 +464,70 @@ pub fn add_clean(bcx: @mut Block, val: ValueRef, t: ty::t) {\n \n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     in_scope_cx(bcx, None, |scope_info| {\n-        scope_info.cleanups.push(clean(@TypeDroppingCleanupFunction {\n-            val: val,\n-            t: t,\n-        } as @CleanupFunction,\n-        cleanup_type));\n+        {\n+            let mut cleanups = scope_info.cleanups.borrow_mut();\n+            cleanups.get().push(clean(@TypeDroppingCleanupFunction {\n+                val: val,\n+                t: t,\n+            } as @CleanupFunction,\n+            cleanup_type));\n+        }\n         grow_scope_clean(scope_info);\n     })\n }\n \n-pub fn add_clean_temp_immediate(cx: @mut Block, val: ValueRef, ty: ty::t) {\n+pub fn add_clean_temp_immediate(cx: @Block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n     debug!(\"add_clean_temp_immediate({}, {}, {})\",\n            cx.to_str(), cx.val_to_str(val),\n            ty.repr(cx.tcx()));\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     in_scope_cx(cx, None, |scope_info| {\n-        scope_info.cleanups.push(clean_temp(val,\n-            @ImmediateTypeDroppingCleanupFunction {\n-                val: val,\n-                t: ty,\n-            } as @CleanupFunction,\n-            cleanup_type));\n+        {\n+            let mut cleanups = scope_info.cleanups.borrow_mut();\n+            cleanups.get().push(clean_temp(val,\n+                @ImmediateTypeDroppingCleanupFunction {\n+                    val: val,\n+                    t: ty,\n+                } as @CleanupFunction,\n+                cleanup_type));\n+        }\n         grow_scope_clean(scope_info);\n     })\n }\n \n-pub fn add_clean_temp_mem(bcx: @mut Block, val: ValueRef, t: ty::t) {\n+pub fn add_clean_temp_mem(bcx: @Block, val: ValueRef, t: ty::t) {\n     add_clean_temp_mem_in_scope_(bcx, None, val, t);\n }\n \n-pub fn add_clean_temp_mem_in_scope(bcx: @mut Block,\n+pub fn add_clean_temp_mem_in_scope(bcx: @Block,\n                                    scope_id: ast::NodeId,\n                                    val: ValueRef,\n                                    t: ty::t) {\n     add_clean_temp_mem_in_scope_(bcx, Some(scope_id), val, t);\n }\n \n-pub fn add_clean_temp_mem_in_scope_(bcx: @mut Block, scope_id: Option<ast::NodeId>,\n+pub fn add_clean_temp_mem_in_scope_(bcx: @Block, scope_id: Option<ast::NodeId>,\n                                     val: ValueRef, t: ty::t) {\n     if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n     debug!(\"add_clean_temp_mem({}, {}, {})\",\n            bcx.to_str(), bcx.val_to_str(val),\n            t.repr(bcx.tcx()));\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     in_scope_cx(bcx, scope_id, |scope_info| {\n-        scope_info.cleanups.push(clean_temp(val,\n-            @TypeDroppingCleanupFunction {\n-                val: val,\n-                t: t,\n-            } as @CleanupFunction,\n-            cleanup_type));\n+        {\n+            let mut cleanups = scope_info.cleanups.borrow_mut();\n+            cleanups.get().push(clean_temp(val,\n+                @TypeDroppingCleanupFunction {\n+                    val: val,\n+                    t: t,\n+                } as @CleanupFunction,\n+                cleanup_type));\n+        }\n         grow_scope_clean(scope_info);\n     })\n }\n-pub fn add_clean_return_to_mut(bcx: @mut Block,\n+pub fn add_clean_return_to_mut(bcx: @Block,\n                                scope_id: ast::NodeId,\n                                root_key: root_map_key,\n                                frozen_val_ref: ValueRef,\n@@ -528,20 +547,23 @@ pub fn add_clean_return_to_mut(bcx: @mut Block,\n            bcx.val_to_str(frozen_val_ref),\n            bcx.val_to_str(bits_val_ref));\n     in_scope_cx(bcx, Some(scope_id), |scope_info| {\n-        scope_info.cleanups.push(clean_temp(\n-                frozen_val_ref,\n-                @WriteGuardReleasingCleanupFunction {\n-                    root_key: root_key,\n-                    frozen_val_ref: frozen_val_ref,\n-                    bits_val_ref: bits_val_ref,\n-                    filename_val: filename_val,\n-                    line_val: line_val,\n-                } as @CleanupFunction,\n-                normal_exit_only));\n+        {\n+            let mut cleanups = scope_info.cleanups.borrow_mut();\n+            cleanups.get().push(clean_temp(\n+                    frozen_val_ref,\n+                    @WriteGuardReleasingCleanupFunction {\n+                        root_key: root_key,\n+                        frozen_val_ref: frozen_val_ref,\n+                        bits_val_ref: bits_val_ref,\n+                        filename_val: filename_val,\n+                        line_val: line_val,\n+                    } as @CleanupFunction,\n+                    normal_exit_only));\n+        }\n         grow_scope_clean(scope_info);\n     })\n }\n-pub fn add_clean_free(cx: @mut Block, ptr: ValueRef, heap: heap) {\n+pub fn add_clean_free(cx: @Block, ptr: ValueRef, heap: heap) {\n     let free_fn = match heap {\n         heap_managed | heap_managed_unique => {\n             @GCHeapFreeingCleanupFunction {\n@@ -555,9 +577,12 @@ pub fn add_clean_free(cx: @mut Block, ptr: ValueRef, heap: heap) {\n         }\n     };\n     in_scope_cx(cx, None, |scope_info| {\n-        scope_info.cleanups.push(clean_temp(ptr,\n-                                            free_fn,\n-                                            normal_exit_and_unwind));\n+        {\n+            let mut cleanups = scope_info.cleanups.borrow_mut();\n+            cleanups.get().push(clean_temp(ptr,\n+                                           free_fn,\n+                                           normal_exit_and_unwind));\n+        }\n         grow_scope_clean(scope_info);\n     })\n }\n@@ -566,50 +591,58 @@ pub fn add_clean_free(cx: @mut Block, ptr: ValueRef, heap: heap) {\n // to a system where we can also cancel the cleanup on local variables, but\n // this will be more involved. For now, we simply zero out the local, and the\n // drop glue checks whether it is zero.\n-pub fn revoke_clean(cx: @mut Block, val: ValueRef) {\n+pub fn revoke_clean(cx: @Block, val: ValueRef) {\n     in_scope_cx(cx, None, |scope_info| {\n-        let cleanup_pos = scope_info.cleanups.iter().position(\n-            |cu| match *cu {\n-                clean_temp(v, _, _) if v == val => true,\n-                _ => false\n-            });\n+        let cleanup_pos = {\n+            let mut cleanups = scope_info.cleanups.borrow_mut();\n+            cleanups.get().iter().position(|cu| {\n+                match *cu {\n+                    clean_temp(v, _, _) if v == val => true,\n+                    _ => false\n+                }\n+            })\n+        };\n         for i in cleanup_pos.iter() {\n-            scope_info.cleanups =\n-                vec::append(scope_info.cleanups.slice(0u, *i).to_owned(),\n-                            scope_info.cleanups.slice(*i + 1u,\n-                                                      scope_info.cleanups.len()));\n+            let new_cleanups = {\n+                let cleanups = scope_info.cleanups.borrow();\n+                vec::append(cleanups.get().slice(0u, *i).to_owned(),\n+                            cleanups.get().slice(*i + 1u, cleanups.get()\n+                                                                  .len()))\n+            };\n+            scope_info.cleanups.set(new_cleanups);\n             shrink_scope_clean(scope_info, *i);\n         }\n     })\n }\n \n-pub fn block_cleanups(bcx: &mut Block) -> ~[cleanup] {\n-    match bcx.scope {\n+pub fn block_cleanups(bcx: &Block) -> ~[cleanup] {\n+    match bcx.scope.get() {\n        None  => ~[],\n-       Some(inf) => inf.cleanups.clone(),\n+       Some(inf) => inf.cleanups.get(),\n     }\n }\n \n pub struct ScopeInfo {\n-    parent: Option<@mut ScopeInfo>,\n-    loop_break: Option<@mut Block>,\n+    parent: Option<@ScopeInfo>,\n+    loop_break: Option<@Block>,\n     loop_label: Option<Name>,\n     // A list of functions that must be run at when leaving this\n     // block, cleaning up any variables that were introduced in the\n     // block.\n-    cleanups: ~[cleanup],\n+    cleanups: RefCell<~[cleanup]>,\n     // Existing cleanup paths that may be reused, indexed by destination and\n     // cleared when the set of cleanups changes.\n-    cleanup_paths: ~[cleanup_path],\n+    cleanup_paths: RefCell<~[cleanup_path]>,\n     // Unwinding landing pad. Also cleared when cleanups change.\n-    landing_pad: Option<BasicBlockRef>,\n+    landing_pad: Cell<Option<BasicBlockRef>>,\n     // info about the AST node this scope originated from, if any\n     node_info: Option<NodeInfo>,\n }\n \n impl ScopeInfo {\n-    pub fn empty_cleanups(&mut self) -> bool {\n-        self.cleanups.is_empty()\n+    pub fn empty_cleanups(&self) -> bool {\n+        let cleanups = self.cleanups.borrow();\n+        cleanups.get().is_empty()\n     }\n }\n \n@@ -657,41 +690,40 @@ pub struct Block {\n     // instructions into that block by way of this block context.\n     // The block pointing to this one in the function's digraph.\n     llbb: BasicBlockRef,\n-    terminated: bool,\n-    unreachable: bool,\n-    parent: Option<@mut Block>,\n+    terminated: Cell<bool>,\n+    unreachable: Cell<bool>,\n+    parent: Option<@Block>,\n     // The current scope within this basic block\n-    scope: Option<@mut ScopeInfo>,\n+    scope: RefCell<Option<@ScopeInfo>>,\n     // Is this block part of a landing pad?\n     is_lpad: bool,\n     // info about the AST node this block originated from, if any\n     node_info: Option<NodeInfo>,\n     // The function context for the function to which this block is\n     // attached.\n-    fcx: @mut FunctionContext\n+    fcx: @FunctionContext\n }\n \n impl Block {\n-\n     pub fn new(llbb: BasicBlockRef,\n-               parent: Option<@mut Block>,\n+               parent: Option<@Block>,\n                is_lpad: bool,\n                node_info: Option<NodeInfo>,\n-               fcx: @mut FunctionContext)\n-            -> Block {\n+               fcx: @FunctionContext)\n+               -> Block {\n         Block {\n             llbb: llbb,\n-            terminated: false,\n-            unreachable: false,\n+            terminated: Cell::new(false),\n+            unreachable: Cell::new(false),\n             parent: parent,\n-            scope: None,\n+            scope: RefCell::new(None),\n             is_lpad: is_lpad,\n             node_info: node_info,\n             fcx: fcx\n         }\n     }\n \n-    pub fn ccx(&self) -> @mut CrateContext { self.fcx.ccx }\n+    pub fn ccx(&self) -> @CrateContext { self.fcx.ccx }\n     pub fn tcx(&self) -> ty::ctxt { self.fcx.ccx.tcx }\n     pub fn sess(&self) -> Session { self.fcx.ccx.sess }\n \n@@ -716,7 +748,8 @@ impl Block {\n     }\n \n     pub fn def(&self, nid: ast::NodeId) -> ast::Def {\n-        match self.tcx().def_map.find(&nid) {\n+        let def_map = self.tcx().def_map.borrow();\n+        match def_map.get().find(&nid) {\n             Some(&v) => v,\n             None => {\n                 self.tcx().sess.bug(format!(\n@@ -748,16 +781,16 @@ impl Block {\n }\n \n pub struct Result {\n-    bcx: @mut Block,\n+    bcx: @Block,\n     val: ValueRef\n }\n \n-pub fn rslt(bcx: @mut Block, val: ValueRef) -> Result {\n+pub fn rslt(bcx: @Block, val: ValueRef) -> Result {\n     Result {bcx: bcx, val: val}\n }\n \n impl Result {\n-    pub fn unpack(&self, bcx: &mut @mut Block) -> ValueRef {\n+    pub fn unpack(&self, bcx: &mut @Block) -> ValueRef {\n         *bcx = self.bcx;\n         return self.val;\n     }\n@@ -769,11 +802,11 @@ pub fn val_ty(v: ValueRef) -> Type {\n     }\n }\n \n-pub fn in_scope_cx(cx: @mut Block,\n+pub fn in_scope_cx(cx: @Block,\n                    scope_id: Option<ast::NodeId>,\n-                   f: |si: &mut ScopeInfo|) {\n+                   f: |si: &ScopeInfo|) {\n     let mut cur = cx;\n-    let mut cur_scope = cur.scope;\n+    let mut cur_scope = cur.scope.get();\n     loop {\n         cur_scope = match cur_scope {\n             Some(inf) => match scope_id {\n@@ -795,13 +828,13 @@ pub fn in_scope_cx(cx: @mut Block,\n             },\n             None => {\n                 cur = block_parent(cur);\n-                cur.scope\n+                cur.scope.get()\n             }\n         }\n     }\n }\n \n-pub fn block_parent(cx: @mut Block) -> @mut Block {\n+pub fn block_parent(cx: @Block) -> @Block {\n     match cx.parent {\n       Some(b) => b,\n       None    => cx.sess().bug(format!(\"block_parent called on root block {:?}\",\n@@ -887,11 +920,14 @@ pub fn C_u8(i: uint) -> ValueRef {\n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-pub fn C_cstr(cx: &mut CrateContext, s: @str) -> ValueRef {\n+pub fn C_cstr(cx: &CrateContext, s: @str) -> ValueRef {\n     unsafe {\n-        match cx.const_cstr_cache.find_equiv(&s) {\n-            Some(&llval) => return llval,\n-            None => ()\n+        {\n+            let const_cstr_cache = cx.const_cstr_cache.borrow();\n+            match const_cstr_cache.get().find_equiv(&s) {\n+                Some(&llval) => return llval,\n+                None => ()\n+            }\n         }\n \n         let sc = llvm::LLVMConstStringInContext(cx.llcx,\n@@ -906,23 +942,23 @@ pub fn C_cstr(cx: &mut CrateContext, s: @str) -> ValueRef {\n         llvm::LLVMSetGlobalConstant(g, True);\n         lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n \n-        cx.const_cstr_cache.insert(s, g);\n-\n-        return g;\n+        let mut const_cstr_cache = cx.const_cstr_cache.borrow_mut();\n+        const_cstr_cache.get().insert(s, g);\n+        g\n     }\n }\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n-pub fn C_estr_slice(cx: &mut CrateContext, s: @str) -> ValueRef {\n+pub fn C_estr_slice(cx: &CrateContext, s: @str) -> ValueRef {\n     unsafe {\n         let len = s.len();\n         let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), Type::i8p().to_ref());\n         C_struct([cs, C_uint(cx, len)], false)\n     }\n }\n \n-pub fn C_binary_slice(cx: &mut CrateContext, data: &[u8]) -> ValueRef {\n+pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n     unsafe {\n         let len = data.len();\n         let lldata = C_bytes(data);\n@@ -1070,17 +1106,17 @@ pub struct mono_id_ {\n \n pub type mono_id = @mono_id_;\n \n-pub fn umax(cx: @mut Block, a: ValueRef, b: ValueRef) -> ValueRef {\n+pub fn umax(cx: @Block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);\n     return build::Select(cx, cond, b, a);\n }\n \n-pub fn umin(cx: @mut Block, a: ValueRef, b: ValueRef) -> ValueRef {\n+pub fn umin(cx: @Block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);\n     return build::Select(cx, cond, a, b);\n }\n \n-pub fn align_to(cx: @mut Block, off: ValueRef, align: ValueRef) -> ValueRef {\n+pub fn align_to(cx: @Block, off: ValueRef, align: ValueRef) -> ValueRef {\n     let mask = build::Sub(cx, align, C_int(cx.ccx(), 1));\n     let bumped = build::Add(cx, off, mask);\n     return build::And(cx, bumped, build::Not(cx, mask));\n@@ -1105,7 +1141,7 @@ pub fn path_str(sess: session::Session, p: &[path_elt]) -> ~str {\n     r\n }\n \n-pub fn monomorphize_type(bcx: &mut Block, t: ty::t) -> ty::t {\n+pub fn monomorphize_type(bcx: &Block, t: ty::t) -> ty::t {\n     match bcx.fcx.param_substs {\n         Some(substs) => {\n             ty::subst_tps(bcx.tcx(), substs.tys, substs.self_ty, t)\n@@ -1118,23 +1154,23 @@ pub fn monomorphize_type(bcx: &mut Block, t: ty::t) -> ty::t {\n     }\n }\n \n-pub fn node_id_type(bcx: &mut Block, id: ast::NodeId) -> ty::t {\n+pub fn node_id_type(bcx: &Block, id: ast::NodeId) -> ty::t {\n     let tcx = bcx.tcx();\n     let t = ty::node_id_to_type(tcx, id);\n     monomorphize_type(bcx, t)\n }\n \n-pub fn expr_ty(bcx: &mut Block, ex: &ast::Expr) -> ty::t {\n+pub fn expr_ty(bcx: &Block, ex: &ast::Expr) -> ty::t {\n     node_id_type(bcx, ex.id)\n }\n \n-pub fn expr_ty_adjusted(bcx: &mut Block, ex: &ast::Expr) -> ty::t {\n+pub fn expr_ty_adjusted(bcx: &Block, ex: &ast::Expr) -> ty::t {\n     let tcx = bcx.tcx();\n     let t = ty::expr_ty_adjusted(tcx, ex);\n     monomorphize_type(bcx, t)\n }\n \n-pub fn node_id_type_params(bcx: &mut Block, id: ast::NodeId) -> ~[ty::t] {\n+pub fn node_id_type_params(bcx: &Block, id: ast::NodeId) -> ~[ty::t] {\n     let tcx = bcx.tcx();\n     let params = ty::node_id_to_type_params(tcx, id);\n \n@@ -1154,9 +1190,10 @@ pub fn node_id_type_params(bcx: &mut Block, id: ast::NodeId) -> ~[ty::t] {\n     }\n }\n \n-pub fn node_vtables(bcx: @mut Block, id: ast::NodeId)\n+pub fn node_vtables(bcx: @Block, id: ast::NodeId)\n                  -> Option<typeck::vtable_res> {\n-    let raw_vtables = bcx.ccx().maps.vtable_map.find(&id);\n+    let vtable_map = bcx.ccx().maps.vtable_map.borrow();\n+    let raw_vtables = vtable_map.get().find(&id);\n     raw_vtables.map(|vts| resolve_vtables_in_fn_ctxt(bcx.fcx, *vts))\n }\n \n@@ -1254,7 +1291,7 @@ pub fn dummy_substs(tps: ~[ty::t]) -> ty::substs {\n     }\n }\n \n-pub fn filename_and_line_num_from_span(bcx: @mut Block,\n+pub fn filename_and_line_num_from_span(bcx: @Block,\n                                        span: Span) -> (ValueRef, ValueRef) {\n     let loc = bcx.sess().parse_sess.cm.lookup_char_pos(span.lo);\n     let filename_cstr = C_cstr(bcx.ccx(), loc.file.name);\n@@ -1264,11 +1301,11 @@ pub fn filename_and_line_num_from_span(bcx: @mut Block,\n }\n \n // Casts a Rust bool value to an i1.\n-pub fn bool_to_i1(bcx: @mut Block, llval: ValueRef) -> ValueRef {\n+pub fn bool_to_i1(bcx: @Block, llval: ValueRef) -> ValueRef {\n     build::ICmp(bcx, lib::llvm::IntNE, llval, C_bool(false))\n }\n \n-pub fn langcall(bcx: @mut Block, span: Option<Span>, msg: &str,\n+pub fn langcall(bcx: @Block, span: Option<Span>, msg: &str,\n                 li: LangItem) -> ast::DefId {\n     match bcx.tcx().lang_items.require(li) {\n         Ok(id) => id,"}, {"sha": "19dc19262c0224e390c973a57fbbaafaa34255d3", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 47, "deletions": 27, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -35,7 +35,7 @@ use std::libc::c_uint;\n use std::vec;\n use syntax::{ast, ast_util, ast_map};\n \n-pub fn const_lit(cx: &mut CrateContext, e: &ast::Expr, lit: ast::lit)\n+pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::lit)\n     -> ValueRef {\n     let _icx = push_ctxt(\"trans_lit\");\n     match lit.node {\n@@ -76,15 +76,16 @@ pub fn const_lit(cx: &mut CrateContext, e: &ast::Expr, lit: ast::lit)\n     }\n }\n \n-pub fn const_ptrcast(cx: &mut CrateContext, a: ValueRef, t: Type) -> ValueRef {\n+pub fn const_ptrcast(cx: &CrateContext, a: ValueRef, t: Type) -> ValueRef {\n     unsafe {\n         let b = llvm::LLVMConstPointerCast(a, t.ptr_to().to_ref());\n-        assert!(cx.const_globals.insert(b as int, a));\n+        let mut const_globals = cx.const_globals.borrow_mut();\n+        assert!(const_globals.get().insert(b as int, a));\n         b\n     }\n }\n \n-fn const_vec(cx: @mut CrateContext, e: &ast::Expr, es: &[@ast::Expr]) -> (ValueRef, Type, bool) {\n+fn const_vec(cx: @CrateContext, e: &ast::Expr, es: &[@ast::Expr]) -> (ValueRef, Type, bool) {\n     let vec_ty = ty::expr_ty(cx.tcx, e);\n     let unit_ty = ty::sequence_element_type(cx.tcx, vec_ty);\n     let llunitty = type_of::type_of(cx, unit_ty);\n@@ -98,7 +99,7 @@ fn const_vec(cx: @mut CrateContext, e: &ast::Expr, es: &[@ast::Expr]) -> (ValueR\n     (v, llunitty, inlineable.iter().fold(true, |a, &b| a && b))\n }\n \n-fn const_addr_of(cx: &mut CrateContext, cv: ValueRef) -> ValueRef {\n+fn const_addr_of(cx: &CrateContext, cv: ValueRef) -> ValueRef {\n     unsafe {\n         let gv = \"const\".with_c_str(|name| {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(cv).to_ref(), name)\n@@ -110,8 +111,9 @@ fn const_addr_of(cx: &mut CrateContext, cv: ValueRef) -> ValueRef {\n     }\n }\n \n-fn const_deref_ptr(cx: &mut CrateContext, v: ValueRef) -> ValueRef {\n-    let v = match cx.const_globals.find(&(v as int)) {\n+fn const_deref_ptr(cx: &CrateContext, v: ValueRef) -> ValueRef {\n+    let const_globals = cx.const_globals.borrow();\n+    let v = match const_globals.get().find(&(v as int)) {\n         Some(&v) => v,\n         None => v\n     };\n@@ -121,13 +123,13 @@ fn const_deref_ptr(cx: &mut CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-fn const_deref_newtype(cx: &mut CrateContext, v: ValueRef, t: ty::t)\n+fn const_deref_newtype(cx: &CrateContext, v: ValueRef, t: ty::t)\n     -> ValueRef {\n     let repr = adt::represent_type(cx, t);\n     adt::const_get_field(cx, repr, v, 0, 0)\n }\n \n-fn const_deref(cx: &mut CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n+fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n     -> (ValueRef, ty::t) {\n     match ty::deref(cx.tcx, t, explicit) {\n         Some(ref mt) => {\n@@ -153,9 +155,12 @@ fn const_deref(cx: &mut CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n     }\n }\n \n-pub fn get_const_val(cx: @mut CrateContext,\n+pub fn get_const_val(cx: @CrateContext,\n                      mut def_id: ast::DefId) -> (ValueRef, bool) {\n-    let contains_key = cx.const_values.contains_key(&def_id.node);\n+    let contains_key = {\n+        let const_values = cx.const_values.borrow();\n+        const_values.get().contains_key(&def_id.node)\n+    };\n     if !ast_util::is_local(def_id) || !contains_key {\n         if !ast_util::is_local(def_id) {\n             def_id = inline::maybe_instantiate_inline(cx, def_id);\n@@ -169,16 +174,22 @@ pub fn get_const_val(cx: @mut CrateContext,\n             _ => cx.tcx.sess.bug(\"expected a const to be an item\")\n         }\n     }\n-    (cx.const_values.get_copy(&def_id.node),\n-     !cx.non_inlineable_statics.contains(&def_id.node))\n+\n+    let const_values = cx.const_values.borrow();\n+    let non_inlineable_statics = cx.non_inlineable_statics.borrow();\n+    (const_values.get().get_copy(&def_id.node),\n+     !non_inlineable_statics.get().contains(&def_id.node))\n }\n \n-pub fn const_expr(cx: @mut CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n+pub fn const_expr(cx: @CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n     let (llconst, inlineable) = const_expr_unadjusted(cx, e);\n     let mut llconst = llconst;\n     let mut inlineable = inlineable;\n     let ety = ty::expr_ty(cx.tcx, e);\n-    let adjustment = cx.tcx.adjustments.find_copy(&e.id);\n+    let adjustment = {\n+        let adjustments = cx.tcx.adjustments.borrow();\n+        adjustments.get().find_copy(&e.id)\n+    };\n     match adjustment {\n         None => { }\n         Some(@ty::AutoAddEnv(ty::ReStatic, ast::BorrowedSigil)) => {\n@@ -257,9 +268,9 @@ pub fn const_expr(cx: @mut CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n \n // the bool returned is whether this expression can be inlined into other crates\n // if it's assigned to a static.\n-fn const_expr_unadjusted(cx: @mut CrateContext,\n+fn const_expr_unadjusted(cx: @CrateContext,\n                          e: &ast::Expr) -> (ValueRef, bool) {\n-    fn map_list(cx: @mut CrateContext,\n+    fn map_list(cx: @CrateContext,\n                 exprs: &[@ast::Expr]) -> (~[ValueRef], bool) {\n         exprs.iter().map(|&e| const_expr(cx, e))\n              .fold((~[], true), |(L, all_inlineable), (val, inlineable)| {\n@@ -574,8 +585,12 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n             assert!(pth.segments.iter().all(|seg| seg.types.is_empty()));\n \n             let tcx = cx.tcx;\n-            match tcx.def_map.find(&e.id) {\n-                Some(&ast::DefFn(def_id, _purity)) => {\n+            let opt_def = {\n+                let def_map = tcx.def_map.borrow();\n+                def_map.get().find_copy(&e.id)\n+            };\n+            match opt_def {\n+                Some(ast::DefFn(def_id, _purity)) => {\n                     if !ast_util::is_local(def_id) {\n                         let ty = csearch::get_type(cx.tcx, def_id).ty;\n                         (base::trans_external_path(cx, def_id, ty), true)\n@@ -584,18 +599,18 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n                         (base::get_item_val(cx, def_id.node), true)\n                     }\n                 }\n-                Some(&ast::DefStatic(def_id, false)) => {\n+                Some(ast::DefStatic(def_id, false)) => {\n                     get_const_val(cx, def_id)\n                 }\n-                Some(&ast::DefVariant(enum_did, variant_did, _)) => {\n+                Some(ast::DefVariant(enum_did, variant_did, _)) => {\n                     let ety = ty::expr_ty(cx.tcx, e);\n                     let repr = adt::represent_type(cx, ety);\n                     let vinfo = ty::enum_variant_with_id(cx.tcx,\n                                                          enum_did,\n                                                          variant_did);\n                     (adt::trans_const(cx, repr, vinfo.disr_val, []), true)\n                 }\n-                Some(&ast::DefStruct(_)) => {\n+                Some(ast::DefStruct(_)) => {\n                     let ety = ty::expr_ty(cx.tcx, e);\n                     let llty = type_of::type_of(cx, ety);\n                     (C_null(llty), true)\n@@ -607,14 +622,18 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n           }\n           ast::ExprCall(callee, ref args, _) => {\n               let tcx = cx.tcx;\n-              match tcx.def_map.find(&callee.id) {\n-                  Some(&ast::DefStruct(_)) => {\n+              let opt_def = {\n+                  let def_map = tcx.def_map.borrow();\n+                  def_map.get().find_copy(&callee.id)\n+              };\n+              match opt_def {\n+                  Some(ast::DefStruct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx, e);\n                       let repr = adt::represent_type(cx, ety);\n                       let (arg_vals, inlineable) = map_list(cx, *args);\n                       (adt::trans_const(cx, repr, 0, arg_vals), inlineable)\n                   }\n-                  Some(&ast::DefVariant(enum_did, variant_did, _)) => {\n+                  Some(ast::DefVariant(enum_did, variant_did, _)) => {\n                       let ety = ty::expr_ty(cx.tcx, e);\n                       let repr = adt::represent_type(cx, ety);\n                       let vinfo = ty::enum_variant_with_id(cx.tcx,\n@@ -634,13 +653,14 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n     }\n }\n \n-pub fn trans_const(ccx: @mut CrateContext, m: ast::Mutability, id: ast::NodeId) {\n+pub fn trans_const(ccx: @CrateContext, m: ast::Mutability, id: ast::NodeId) {\n     unsafe {\n         let _icx = push_ctxt(\"trans_const\");\n         let g = base::get_item_val(ccx, id);\n         // At this point, get_item_val has already translated the\n         // constant's initializer to determine its LLVM type.\n-        let v = ccx.const_values.get_copy(&id);\n+        let const_values = ccx.const_values.borrow();\n+        let v = const_values.get().get_copy(&id);\n         llvm::LLVMSetInitializer(g, v);\n         if m != ast::MutMutable {\n             llvm::LLVMSetGlobalConstant(g, True);"}, {"sha": "dbdadb46f49219ac13da2b200f33cf6fefd3bb7b", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 66, "deletions": 74, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -27,6 +27,7 @@ use middle::trans::type_::Type;\n \n use util::sha2::Sha256;\n \n+use std::cell::{Cell, RefCell};\n use std::c_str::ToCStr;\n use std::hashmap::{HashMap, HashSet};\n use std::local_data;\n@@ -44,36 +45,33 @@ pub struct CrateContext {\n      metadata_llmod: ModuleRef,\n      td: TargetData,\n      tn: TypeNames,\n-     externs: ExternMap,\n+     externs: RefCell<ExternMap>,\n      intrinsics: HashMap<&'static str, ValueRef>,\n-     item_vals: HashMap<ast::NodeId, ValueRef>,\n+     item_vals: RefCell<HashMap<ast::NodeId, ValueRef>>,\n      exp_map2: resolve::ExportMap2,\n-     reachable: @mut HashSet<ast::NodeId>,\n-     item_symbols: HashMap<ast::NodeId, ~str>,\n+     reachable: @RefCell<HashSet<ast::NodeId>>,\n+     item_symbols: RefCell<HashMap<ast::NodeId, ~str>>,\n      link_meta: LinkMeta,\n-     enum_sizes: HashMap<ty::t, uint>,\n-     discrims: HashMap<ast::DefId, ValueRef>,\n-     discrim_symbols: HashMap<ast::NodeId, @str>,\n-     tydescs: HashMap<ty::t, @mut tydesc_info>,\n+     tydescs: RefCell<HashMap<ty::t, @tydesc_info>>,\n      // Set when running emit_tydescs to enforce that no more tydescs are\n      // created.\n-     finished_tydescs: bool,\n+     finished_tydescs: Cell<bool>,\n      // Track mapping of external ids to local items imported for inlining\n-     external: HashMap<ast::DefId, Option<ast::NodeId>>,\n+     external: RefCell<HashMap<ast::DefId, Option<ast::NodeId>>>,\n      // Backwards version of the `external` map (inlined items to where they\n      // came from)\n-     external_srcs: HashMap<ast::NodeId, ast::DefId>,\n+     external_srcs: RefCell<HashMap<ast::NodeId, ast::DefId>>,\n      // A set of static items which cannot be inlined into other crates. This\n      // will pevent in ii_item() structures from being encoded into the metadata\n      // that is generated\n-     non_inlineable_statics: HashSet<ast::NodeId>,\n+     non_inlineable_statics: RefCell<HashSet<ast::NodeId>>,\n      // Cache instances of monomorphized functions\n-     monomorphized: HashMap<mono_id, ValueRef>,\n-     monomorphizing: HashMap<ast::DefId, uint>,\n+     monomorphized: RefCell<HashMap<mono_id, ValueRef>>,\n+     monomorphizing: RefCell<HashMap<ast::DefId, uint>>,\n      // Cache generated vtables\n-     vtables: HashMap<(ty::t, mono_id), ValueRef>,\n+     vtables: RefCell<HashMap<(ty::t, mono_id), ValueRef>>,\n      // Cache of constant strings,\n-     const_cstr_cache: HashMap<@str, ValueRef>,\n+     const_cstr_cache: RefCell<HashMap<@str, ValueRef>>,\n \n      // Reverse-direction for const ptrs cast from globals.\n      // Key is an int, cast from a ValueRef holding a *T,\n@@ -83,27 +81,26 @@ pub struct CrateContext {\n      // when we ptrcast, and we have to ptrcast during translation\n      // of a [T] const because we form a slice, a [*T,int] pair, not\n      // a pointer to an LLVM array type.\n-     const_globals: HashMap<int, ValueRef>,\n+     const_globals: RefCell<HashMap<int, ValueRef>>,\n \n      // Cache of emitted const values\n-     const_values: HashMap<ast::NodeId, ValueRef>,\n+     const_values: RefCell<HashMap<ast::NodeId, ValueRef>>,\n \n      // Cache of external const values\n-     extern_const_values: HashMap<ast::DefId, ValueRef>,\n+     extern_const_values: RefCell<HashMap<ast::DefId, ValueRef>>,\n \n-     impl_method_cache: HashMap<(ast::DefId, ast::Name), ast::DefId>,\n+     impl_method_cache: RefCell<HashMap<(ast::DefId, ast::Name), ast::DefId>>,\n \n-     module_data: HashMap<~str, ValueRef>,\n-     lltypes: HashMap<ty::t, Type>,\n-     llsizingtypes: HashMap<ty::t, Type>,\n-     adt_reprs: HashMap<ty::t, @adt::Repr>,\n-     symbol_hasher: Sha256,\n-     type_hashcodes: HashMap<ty::t, @str>,\n-     type_short_names: HashMap<ty::t, ~str>,\n-     all_llvm_symbols: HashSet<@str>,\n+     module_data: RefCell<HashMap<~str, ValueRef>>,\n+     lltypes: RefCell<HashMap<ty::t, Type>>,\n+     llsizingtypes: RefCell<HashMap<ty::t, Type>>,\n+     adt_reprs: RefCell<HashMap<ty::t, @adt::Repr>>,\n+     symbol_hasher: RefCell<Sha256>,\n+     type_hashcodes: RefCell<HashMap<ty::t, @str>>,\n+     all_llvm_symbols: RefCell<HashSet<@str>>,\n      tcx: ty::ctxt,\n      maps: astencode::Maps,\n-     stats: @mut Stats,\n+     stats: @Stats,\n      tydesc_type: Type,\n      int_type: Type,\n      opaque_vec_type: Type,\n@@ -115,7 +112,7 @@ pub struct CrateContext {\n      // is not emitted by LLVM's GC pass when no functions use GC.\n      uses_gc: bool,\n      dbg_cx: Option<debuginfo::CrateDebugContext>,\n-     do_not_commit_warning_issued: bool\n+     do_not_commit_warning_issued: Cell<bool>,\n }\n \n impl CrateContext {\n@@ -126,7 +123,7 @@ impl CrateContext {\n                maps: astencode::Maps,\n                symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n-               reachable: @mut HashSet<ast::NodeId>)\n+               reachable: @RefCell<HashSet<ast::NodeId>>)\n                -> CrateContext {\n         unsafe {\n             let llcx = llvm::LLVMContextCreate();\n@@ -150,7 +147,7 @@ impl CrateContext {\n             let targ_cfg = sess.targ_cfg;\n \n             let td = mk_target_data(sess.targ_cfg.target_strs.data_layout);\n-            let mut tn = TypeNames::new();\n+            let tn = TypeNames::new();\n \n             let mut intrinsics = base::declare_intrinsics(llmod);\n             if sess.opts.extra_debuginfo {\n@@ -184,52 +181,47 @@ impl CrateContext {\n                   metadata_llmod: metadata_llmod,\n                   td: td,\n                   tn: tn,\n-                  externs: HashMap::new(),\n+                  externs: RefCell::new(HashMap::new()),\n                   intrinsics: intrinsics,\n-                  item_vals: HashMap::new(),\n+                  item_vals: RefCell::new(HashMap::new()),\n                   exp_map2: emap2,\n                   reachable: reachable,\n-                  item_symbols: HashMap::new(),\n+                  item_symbols: RefCell::new(HashMap::new()),\n                   link_meta: link_meta,\n-                  enum_sizes: HashMap::new(),\n-                  discrims: HashMap::new(),\n-                  discrim_symbols: HashMap::new(),\n-                  tydescs: HashMap::new(),\n-                  finished_tydescs: false,\n-                  external: HashMap::new(),\n-                  external_srcs: HashMap::new(),\n-                  non_inlineable_statics: HashSet::new(),\n-                  monomorphized: HashMap::new(),\n-                  monomorphizing: HashMap::new(),\n-                  vtables: HashMap::new(),\n-                  const_cstr_cache: HashMap::new(),\n-                  const_globals: HashMap::new(),\n-                  const_values: HashMap::new(),\n-                  extern_const_values: HashMap::new(),\n-                  impl_method_cache: HashMap::new(),\n-                  module_data: HashMap::new(),\n-                  lltypes: HashMap::new(),\n-                  llsizingtypes: HashMap::new(),\n-                  adt_reprs: HashMap::new(),\n-                  symbol_hasher: symbol_hasher,\n-                  type_hashcodes: HashMap::new(),\n-                  type_short_names: HashMap::new(),\n-                  all_llvm_symbols: HashSet::new(),\n+                  tydescs: RefCell::new(HashMap::new()),\n+                  finished_tydescs: Cell::new(false),\n+                  external: RefCell::new(HashMap::new()),\n+                  external_srcs: RefCell::new(HashMap::new()),\n+                  non_inlineable_statics: RefCell::new(HashSet::new()),\n+                  monomorphized: RefCell::new(HashMap::new()),\n+                  monomorphizing: RefCell::new(HashMap::new()),\n+                  vtables: RefCell::new(HashMap::new()),\n+                  const_cstr_cache: RefCell::new(HashMap::new()),\n+                  const_globals: RefCell::new(HashMap::new()),\n+                  const_values: RefCell::new(HashMap::new()),\n+                  extern_const_values: RefCell::new(HashMap::new()),\n+                  impl_method_cache: RefCell::new(HashMap::new()),\n+                  module_data: RefCell::new(HashMap::new()),\n+                  lltypes: RefCell::new(HashMap::new()),\n+                  llsizingtypes: RefCell::new(HashMap::new()),\n+                  adt_reprs: RefCell::new(HashMap::new()),\n+                  symbol_hasher: RefCell::new(symbol_hasher),\n+                  type_hashcodes: RefCell::new(HashMap::new()),\n+                  all_llvm_symbols: RefCell::new(HashSet::new()),\n                   tcx: tcx,\n                   maps: maps,\n-                  stats: @mut Stats {\n-                    n_static_tydescs: 0u,\n-                    n_glues_created: 0u,\n-                    n_null_glues: 0u,\n-                    n_real_glues: 0u,\n-                    n_fns: 0u,\n-                    n_monos: 0u,\n-                    n_inlines: 0u,\n-                    n_closures: 0u,\n-                    n_llvm_insns: 0u,\n-                    llvm_insn_ctxt: ~[],\n-                    llvm_insns: HashMap::new(),\n-                    fn_stats: ~[]\n+                  stats: @Stats {\n+                    n_static_tydescs: Cell::new(0u),\n+                    n_glues_created: Cell::new(0u),\n+                    n_null_glues: Cell::new(0u),\n+                    n_real_glues: Cell::new(0u),\n+                    n_fns: Cell::new(0u),\n+                    n_monos: Cell::new(0u),\n+                    n_inlines: Cell::new(0u),\n+                    n_closures: Cell::new(0u),\n+                    n_llvm_insns: Cell::new(0u),\n+                    llvm_insns: RefCell::new(HashMap::new()),\n+                    fn_stats: RefCell::new(~[]),\n                   },\n                   tydesc_type: tydesc_type,\n                   int_type: int_type,\n@@ -239,12 +231,12 @@ impl CrateContext {\n                   crate_map_name: crate_map_name,\n                   uses_gc: false,\n                   dbg_cx: dbg_cx,\n-                  do_not_commit_warning_issued: false\n+                  do_not_commit_warning_issued: Cell::new(false),\n             }\n         }\n     }\n \n-    pub fn builder(@mut self) -> Builder {\n+    pub fn builder(@self) -> Builder {\n         Builder::new(self)\n     }\n "}, {"sha": "0770e52f90a3d4d5159ca868c2747833b182f1be", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -28,7 +28,7 @@ use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::visit::Visitor;\n \n-pub fn trans_block(bcx: @mut Block, b: &ast::Block, dest: expr::Dest) -> @mut Block {\n+pub fn trans_block(bcx: @Block, b: &ast::Block, dest: expr::Dest) -> @Block {\n     let _icx = push_ctxt(\"trans_block\");\n     let mut bcx = bcx;\n     for s in b.stmts.iter() {\n@@ -39,18 +39,18 @@ pub fn trans_block(bcx: @mut Block, b: &ast::Block, dest: expr::Dest) -> @mut Bl\n             bcx = expr::trans_into(bcx, e, dest);\n         }\n         None => {\n-            assert!(dest == expr::Ignore || bcx.unreachable);\n+            assert!(dest == expr::Ignore || bcx.unreachable.get());\n         }\n     }\n     return bcx;\n }\n \n-pub fn trans_if(bcx: @mut Block,\n+pub fn trans_if(bcx: @Block,\n             cond: &ast::Expr,\n             thn: ast::P<ast::Block>,\n             els: Option<@ast::Expr>,\n             dest: expr::Dest)\n-         -> @mut Block {\n+         -> @Block {\n     debug!(\"trans_if(bcx={}, cond={}, thn={:?}, dest={})\",\n            bcx.to_str(), bcx.expr_to_str(cond), thn.id,\n            dest.to_str(bcx.ccx()));\n@@ -137,8 +137,8 @@ pub fn trans_if(bcx: @mut Block,\n     return next_bcx;\n \n     // trans `else [ if { .. } ... | { .. } ]`\n-    fn trans_if_else(else_bcx_in: @mut Block, elexpr: @ast::Expr,\n-                     dest: expr::Dest, cleanup: bool) -> @mut Block {\n+    fn trans_if_else(else_bcx_in: @Block, elexpr: @ast::Expr,\n+                     dest: expr::Dest, cleanup: bool) -> @Block {\n         let else_bcx_out = match elexpr.node {\n             ast::ExprIf(_, _, _) => {\n                 let elseif_blk = ast_util::block_from_expr(elexpr);\n@@ -159,11 +159,11 @@ pub fn trans_if(bcx: @mut Block,\n     }\n }\n \n-pub fn join_blocks(parent_bcx: @mut Block, in_cxs: &[@mut Block]) -> @mut Block {\n+pub fn join_blocks(parent_bcx: @Block, in_cxs: &[@Block]) -> @Block {\n     let out = sub_block(parent_bcx, \"join\");\n     let mut reachable = false;\n     for bcx in in_cxs.iter() {\n-        if !bcx.unreachable {\n+        if !bcx.unreachable.get() {\n             Br(*bcx, out.llbb);\n             reachable = true;\n         }\n@@ -174,7 +174,7 @@ pub fn join_blocks(parent_bcx: @mut Block, in_cxs: &[@mut Block]) -> @mut Block\n     return out;\n }\n \n-pub fn trans_while(bcx: @mut Block, cond: &ast::Expr, body: &ast::Block) -> @mut Block {\n+pub fn trans_while(bcx: @Block, cond: &ast::Expr, body: &ast::Block) -> @Block {\n     let _icx = push_ctxt(\"trans_while\");\n     let next_bcx = sub_block(bcx, \"while next\");\n \n@@ -213,10 +213,10 @@ pub fn trans_while(bcx: @mut Block, cond: &ast::Expr, body: &ast::Block) -> @mut\n     return next_bcx;\n }\n \n-pub fn trans_loop(bcx:@mut Block,\n+pub fn trans_loop(bcx:@Block,\n                   body: &ast::Block,\n                   opt_label: Option<Name>)\n-               -> @mut Block {\n+               -> @Block {\n     let _icx = push_ctxt(\"trans_loop\");\n     let next_bcx = sub_block(bcx, \"next\");\n     let body_bcx_in = loop_scope_block(bcx, next_bcx, opt_label, \"`loop`\",\n@@ -227,14 +227,14 @@ pub fn trans_loop(bcx:@mut Block,\n     return next_bcx;\n }\n \n-pub fn trans_break_cont(bcx: @mut Block,\n+pub fn trans_break_cont(bcx: @Block,\n                         opt_label: Option<Name>,\n                         to_end: bool)\n-                     -> @mut Block {\n+                     -> @Block {\n     let _icx = push_ctxt(\"trans_break_cont\");\n     // Locate closest loop block, outputting cleanup as we go.\n     let mut unwind = bcx;\n-    let mut cur_scope = unwind.scope;\n+    let mut cur_scope = unwind.scope.get();\n     let mut target;\n     loop {\n         cur_scope = match cur_scope {\n@@ -266,13 +266,15 @@ pub fn trans_break_cont(bcx: @mut Block,\n                     Some(bcx) => bcx,\n                         // This is a return from a loop body block\n                         None => {\n-                            Store(bcx, C_bool(!to_end), bcx.fcx.llretptr.unwrap());\n+                            Store(bcx,\n+                                  C_bool(!to_end),\n+                                  bcx.fcx.llretptr.get().unwrap());\n                             cleanup_and_leave(bcx, None, Some(bcx.fcx.get_llreturn()));\n                             Unreachable(bcx);\n                             return bcx;\n                         }\n                 };\n-                unwind.scope\n+                unwind.scope.get()\n             }\n         }\n     }\n@@ -281,18 +283,18 @@ pub fn trans_break_cont(bcx: @mut Block,\n     return bcx;\n }\n \n-pub fn trans_break(bcx: @mut Block, label_opt: Option<Name>) -> @mut Block {\n+pub fn trans_break(bcx: @Block, label_opt: Option<Name>) -> @Block {\n     return trans_break_cont(bcx, label_opt, true);\n }\n \n-pub fn trans_cont(bcx: @mut Block, label_opt: Option<Name>) -> @mut Block {\n+pub fn trans_cont(bcx: @Block, label_opt: Option<Name>) -> @Block {\n     return trans_break_cont(bcx, label_opt, false);\n }\n \n-pub fn trans_ret(bcx: @mut Block, e: Option<@ast::Expr>) -> @mut Block {\n+pub fn trans_ret(bcx: @Block, e: Option<@ast::Expr>) -> @Block {\n     let _icx = push_ctxt(\"trans_ret\");\n     let mut bcx = bcx;\n-    let dest = match bcx.fcx.llretptr {\n+    let dest = match bcx.fcx.llretptr.get() {\n         None => expr::Ignore,\n         Some(retptr) => expr::SaveIn(retptr),\n     };\n@@ -307,10 +309,10 @@ pub fn trans_ret(bcx: @mut Block, e: Option<@ast::Expr>) -> @mut Block {\n     return bcx;\n }\n \n-pub fn trans_fail_expr(bcx: @mut Block,\n+pub fn trans_fail_expr(bcx: @Block,\n                        sp_opt: Option<Span>,\n                        fail_expr: Option<@ast::Expr>)\n-                    -> @mut Block {\n+                    -> @Block {\n     let _icx = push_ctxt(\"trans_fail_expr\");\n     let mut bcx = bcx;\n     match fail_expr {\n@@ -323,7 +325,7 @@ pub fn trans_fail_expr(bcx: @mut Block,\n             if ty::type_is_str(arg_datum.ty) {\n                 let (lldata, _) = arg_datum.get_vec_base_and_len_no_root(bcx);\n                 return trans_fail_value(bcx, sp_opt, lldata);\n-            } else if bcx.unreachable || ty::type_is_bot(arg_datum.ty) {\n+            } else if bcx.unreachable.get() || ty::type_is_bot(arg_datum.ty) {\n                 return bcx;\n             } else {\n                 bcx.sess().span_bug(\n@@ -335,19 +337,19 @@ pub fn trans_fail_expr(bcx: @mut Block,\n     }\n }\n \n-pub fn trans_fail(bcx: @mut Block,\n+pub fn trans_fail(bcx: @Block,\n                   sp_opt: Option<Span>,\n                   fail_str: @str)\n-               -> @mut Block {\n+               -> @Block {\n     let _icx = push_ctxt(\"trans_fail\");\n     let V_fail_str = C_cstr(bcx.ccx(), fail_str);\n     return trans_fail_value(bcx, sp_opt, V_fail_str);\n }\n \n-fn trans_fail_value(bcx: @mut Block,\n+fn trans_fail_value(bcx: @Block,\n                     sp_opt: Option<Span>,\n                     V_fail_str: ValueRef)\n-                 -> @mut Block {\n+                 -> @Block {\n     let _icx = push_ctxt(\"trans_fail_value\");\n     let ccx = bcx.ccx();\n     let (V_filename, V_line) = match sp_opt {\n@@ -370,8 +372,8 @@ fn trans_fail_value(bcx: @mut Block,\n     return bcx;\n }\n \n-pub fn trans_fail_bounds_check(bcx: @mut Block, sp: Span,\n-                               index: ValueRef, len: ValueRef) -> @mut Block {\n+pub fn trans_fail_bounds_check(bcx: @Block, sp: Span,\n+                               index: ValueRef, len: ValueRef) -> @Block {\n     let _icx = push_ctxt(\"trans_fail_bounds_check\");\n     let (filename, line) = filename_and_line_num_from_span(bcx, sp);\n     let args = ~[filename, line, index, len];"}, {"sha": "6b8ff815a8360d94ecb6d7b14e4f611943ef9b22", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -128,7 +128,7 @@ pub struct Datum {\n }\n \n pub struct DatumBlock {\n-    bcx: @mut Block,\n+    bcx: @Block,\n     datum: Datum,\n }\n \n@@ -165,14 +165,14 @@ pub fn immediate_rvalue(val: ValueRef, ty: ty::t) -> Datum {\n     return Datum {val: val, ty: ty, mode: ByValue};\n }\n \n-pub fn immediate_rvalue_bcx(bcx: @mut Block,\n+pub fn immediate_rvalue_bcx(bcx: @Block,\n                             val: ValueRef,\n                             ty: ty::t)\n                          -> DatumBlock {\n     return DatumBlock {bcx: bcx, datum: immediate_rvalue(val, ty)};\n }\n \n-pub fn scratch_datum(bcx: @mut Block, ty: ty::t, name: &str, zero: bool) -> Datum {\n+pub fn scratch_datum(bcx: @Block, ty: ty::t, name: &str, zero: bool) -> Datum {\n     /*!\n      * Allocates temporary space on the stack using alloca() and\n      * returns a by-ref Datum pointing to it.  If `zero` is true, the\n@@ -188,7 +188,7 @@ pub fn scratch_datum(bcx: @mut Block, ty: ty::t, name: &str, zero: bool) -> Datu\n     Datum { val: scratch, ty: ty, mode: ByRef(RevokeClean) }\n }\n \n-pub fn appropriate_mode(ccx: &mut CrateContext, ty: ty::t) -> DatumMode {\n+pub fn appropriate_mode(ccx: &CrateContext, ty: ty::t) -> DatumMode {\n     /*!\n      * Indicates the \"appropriate\" mode for this value,\n      * which is either by ref or by value, depending\n@@ -206,10 +206,10 @@ pub fn appropriate_mode(ccx: &mut CrateContext, ty: ty::t) -> DatumMode {\n \n impl Datum {\n     pub fn store_to(&self,\n-                    bcx: @mut Block,\n+                    bcx: @Block,\n                     action: CopyAction,\n                     dst: ValueRef)\n-                    -> @mut Block {\n+                    -> @Block {\n         /*!\n          *\n          * Stores this value into its final home.  This moves if\n@@ -224,9 +224,9 @@ impl Datum {\n     }\n \n     pub fn store_to_dest(&self,\n-                         bcx: @mut Block,\n+                         bcx: @Block,\n                          dest: expr::Dest)\n-                         -> @mut Block {\n+                         -> @Block {\n         match dest {\n             expr::Ignore => {\n                 return bcx;\n@@ -238,30 +238,30 @@ impl Datum {\n     }\n \n     pub fn store_to_datum(&self,\n-                          bcx: @mut Block,\n+                          bcx: @Block,\n                           action: CopyAction,\n                           datum: Datum)\n-                          -> @mut Block {\n+                          -> @Block {\n         debug!(\"store_to_datum(self={}, action={:?}, datum={})\",\n                self.to_str(bcx.ccx()), action, datum.to_str(bcx.ccx()));\n         assert!(datum.mode.is_by_ref());\n         self.store_to(bcx, action, datum.val)\n     }\n \n-    pub fn move_to_datum(&self, bcx: @mut Block, action: CopyAction, datum: Datum)\n-                         -> @mut Block {\n+    pub fn move_to_datum(&self, bcx: @Block, action: CopyAction, datum: Datum)\n+                         -> @Block {\n         assert!(datum.mode.is_by_ref());\n         self.move_to(bcx, action, datum.val)\n     }\n \n-    pub fn copy_to_datum(&self, bcx: @mut Block, action: CopyAction, datum: Datum)\n-                         -> @mut Block {\n+    pub fn copy_to_datum(&self, bcx: @Block, action: CopyAction, datum: Datum)\n+                         -> @Block {\n         assert!(datum.mode.is_by_ref());\n         self.copy_to(bcx, action, datum.val)\n     }\n \n-    pub fn copy_to(&self, bcx: @mut Block, action: CopyAction, dst: ValueRef)\n-                   -> @mut Block {\n+    pub fn copy_to(&self, bcx: @Block, action: CopyAction, dst: ValueRef)\n+                   -> @Block {\n         /*!\n          *\n          * Copies the value into `dst`, which should be a pointer to a\n@@ -304,10 +304,10 @@ impl Datum {\n     }\n \n     pub fn copy_to_no_check(&self,\n-                            bcx: @mut Block,\n+                            bcx: @Block,\n                             action: CopyAction,\n                             dst: ValueRef)\n-                            -> @mut Block {\n+                            -> @Block {\n         /*!\n          *\n          * A helper for `copy_to()` which does not check to see if we\n@@ -335,8 +335,8 @@ impl Datum {\n     // This works like copy_val, except that it deinitializes the source.\n     // Since it needs to zero out the source, src also needs to be an lval.\n     //\n-    pub fn move_to(&self, bcx: @mut Block, action: CopyAction, dst: ValueRef)\n-                   -> @mut Block {\n+    pub fn move_to(&self, bcx: @Block, action: CopyAction, dst: ValueRef)\n+                   -> @Block {\n         let _icx = push_ctxt(\"move_to\");\n         let mut bcx = bcx;\n \n@@ -365,7 +365,7 @@ impl Datum {\n         return bcx;\n     }\n \n-    pub fn add_clean(&self, bcx: @mut Block) {\n+    pub fn add_clean(&self, bcx: @Block) {\n         /*!\n          * Schedules this datum for cleanup in `bcx`.  The datum\n          * must be an rvalue.\n@@ -385,7 +385,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn cancel_clean(&self, bcx: @mut Block) {\n+    pub fn cancel_clean(&self, bcx: @Block) {\n         if ty::type_needs_drop(bcx.tcx(), self.ty) {\n             match self.mode {\n                 ByValue |\n@@ -410,7 +410,7 @@ impl Datum {\n              self.mode)\n     }\n \n-    pub fn to_value_datum(&self, bcx: @mut Block) -> Datum {\n+    pub fn to_value_datum(&self, bcx: @Block) -> Datum {\n         /*!\n          *\n          * Yields a by-value form of this datum.  This may involve\n@@ -427,7 +427,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn to_value_llval(&self, bcx: @mut Block) -> ValueRef {\n+    pub fn to_value_llval(&self, bcx: @Block) -> ValueRef {\n         /*!\n          *\n          * Yields the value itself. */\n@@ -448,7 +448,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn to_ref_datum(&self, bcx: @mut Block) -> Datum {\n+    pub fn to_ref_datum(&self, bcx: @Block) -> Datum {\n         /*!\n          * Yields a by-ref form of this datum.  This may involve\n          * creation of a temporary stack slot.  The value returned by\n@@ -465,7 +465,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn to_ref_llval(&self, bcx: @mut Block) -> ValueRef {\n+    pub fn to_ref_llval(&self, bcx: @Block) -> ValueRef {\n         match self.mode {\n             ByRef(_) => self.val,\n             ByValue => {\n@@ -492,13 +492,13 @@ impl Datum {\n         }\n     }\n \n-    pub fn appropriate_mode(&self, ccx: &mut CrateContext) -> DatumMode {\n+    pub fn appropriate_mode(&self, ccx: &CrateContext) -> DatumMode {\n         /*! See the `appropriate_mode()` function */\n \n         appropriate_mode(ccx, self.ty)\n     }\n \n-    pub fn to_appropriate_llval(&self, bcx: @mut Block) -> ValueRef {\n+    pub fn to_appropriate_llval(&self, bcx: @Block) -> ValueRef {\n         /*!\n          *\n          * Yields an llvalue with the `appropriate_mode()`. */\n@@ -509,7 +509,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn to_appropriate_datum(&self, bcx: @mut Block) -> Datum {\n+    pub fn to_appropriate_datum(&self, bcx: @Block) -> Datum {\n         /*!\n          *\n          * Yields a datum with the `appropriate_mode()`. */\n@@ -521,7 +521,7 @@ impl Datum {\n     }\n \n     pub fn get_element(&self,\n-                       bcx: @mut Block,\n+                       bcx: @Block,\n                        ty: ty::t,\n                        source: DatumCleanup,\n                        gep: |ValueRef| -> ValueRef)\n@@ -534,7 +534,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn drop_val(&self, bcx: @mut Block) -> @mut Block {\n+    pub fn drop_val(&self, bcx: @Block) -> @Block {\n         if !ty::type_needs_drop(bcx.tcx(), self.ty) {\n             return bcx;\n         }\n@@ -545,7 +545,7 @@ impl Datum {\n         };\n     }\n \n-    pub fn box_body(&self, bcx: @mut Block) -> Datum {\n+    pub fn box_body(&self, bcx: @Block) -> Datum {\n         /*!\n          *\n          * This datum must represent an @T or ~T box.  Returns a new\n@@ -578,7 +578,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn to_rptr(&self, bcx: @mut Block) -> Datum {\n+    pub fn to_rptr(&self, bcx: @Block) -> Datum {\n         //! Returns a new datum of region-pointer type containing the\n         //! the same ptr as this datum (after converting to by-ref\n         //! using `to_ref_llval()`).\n@@ -599,12 +599,12 @@ impl Datum {\n     /// derefs: Number of times deref'd already.\n     /// is_auto: If true, only deref if auto-derefable.\n     pub fn try_deref(&self,\n-                     bcx: @mut Block,\n+                     bcx: @Block,\n                      span: Span,\n                      expr_id: ast::NodeId,\n                      derefs: uint,\n                      is_auto: bool)\n-                     -> (Option<Datum>, @mut Block) {\n+                     -> (Option<Datum>, @Block) {\n         let ccx = bcx.ccx();\n \n         debug!(\"try_deref(expr_id={:?}, derefs={:?}, is_auto={}, self={:?})\",\n@@ -703,7 +703,7 @@ impl Datum {\n             }\n         }\n \n-        fn deref_ptr(bcx: @mut Block, lv: &Datum, ty: ty::t) -> Datum {\n+        fn deref_ptr(bcx: @Block, lv: &Datum, ty: ty::t) -> Datum {\n             Datum {\n                 val: lv.to_value_llval(bcx),\n                 ty: ty,\n@@ -713,7 +713,7 @@ impl Datum {\n     }\n \n     /// expr: The deref expression.\n-    pub fn deref(&self, bcx: @mut Block, expr: &ast::Expr, derefs: uint)\n+    pub fn deref(&self, bcx: @Block, expr: &ast::Expr, derefs: uint)\n                  -> DatumBlock {\n         match self.try_deref(bcx, expr.span, expr.id, derefs, false) {\n             (Some(lvres), bcx) => DatumBlock { bcx: bcx, datum: lvres },\n@@ -725,7 +725,7 @@ impl Datum {\n     }\n \n     pub fn autoderef(&self,\n-                     bcx: @mut Block,\n+                     bcx: @Block,\n                      span: Span,\n                      expr_id: ast::NodeId,\n                      max: uint)\n@@ -758,11 +758,11 @@ impl Datum {\n     }\n \n     pub fn get_vec_base_and_byte_len(&self,\n-                                     mut bcx: @mut Block,\n+                                     mut bcx: @Block,\n                                      span: Span,\n                                      expr_id: ast::NodeId,\n                                      derefs: uint)\n-                                     -> (@mut Block, ValueRef, ValueRef) {\n+                                     -> (@Block, ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Performs rooting\n         //! and write guards checks.\n \n@@ -772,7 +772,7 @@ impl Datum {\n         (bcx, base, len)\n     }\n \n-    pub fn get_vec_base_and_byte_len_no_root(&self, bcx: @mut Block)\n+    pub fn get_vec_base_and_byte_len_no_root(&self, bcx: @Block)\n                                              -> (ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Des not root\n         //! nor perform write guard checks.\n@@ -782,11 +782,11 @@ impl Datum {\n     }\n \n     pub fn get_vec_base_and_len(&self,\n-                                     mut bcx: @mut Block,\n+                                     mut bcx: @Block,\n                                      span: Span,\n                                      expr_id: ast::NodeId,\n                                      derefs: uint)\n-                                     -> (@mut Block, ValueRef, ValueRef) {\n+                                     -> (@Block, ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Performs rooting\n         //! and write guards checks.\n \n@@ -796,7 +796,7 @@ impl Datum {\n         (bcx, base, len)\n     }\n \n-    pub fn get_vec_base_and_len_no_root(&self, bcx: @mut Block)\n+    pub fn get_vec_base_and_len_no_root(&self, bcx: @Block)\n                                              -> (ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Des not root\n         //! nor perform write guard checks.\n@@ -806,21 +806,21 @@ impl Datum {\n     }\n \n     pub fn root_and_write_guard(&self,\n-                                bcx: @mut Block,\n+                                bcx: @Block,\n                                 span: Span,\n                                 expr_id: ast::NodeId,\n                                 derefs: uint)\n-                                -> @mut Block {\n+                                -> @Block {\n         write_guard::root_and_write_guard(self, bcx, span, expr_id, derefs)\n     }\n \n-    pub fn to_result(&self, bcx: @mut Block) -> common::Result {\n+    pub fn to_result(&self, bcx: @Block) -> common::Result {\n         rslt(bcx, self.to_appropriate_llval(bcx))\n     }\n }\n \n impl DatumBlock {\n-    pub fn unpack(&self, bcx: &mut @mut Block) -> Datum {\n+    pub fn unpack(&self, bcx: &mut @Block) -> Datum {\n         *bcx = self.bcx;\n         return self.datum;\n     }\n@@ -830,22 +830,22 @@ impl DatumBlock {\n         *self\n     }\n \n-    pub fn drop_val(&self) -> @mut Block {\n+    pub fn drop_val(&self) -> @Block {\n         self.datum.drop_val(self.bcx)\n     }\n \n     pub fn store_to(&self,\n                     action: CopyAction,\n                     dst: ValueRef)\n-                    -> @mut Block {\n+                    -> @Block {\n         self.datum.store_to(self.bcx, action, dst)\n     }\n \n-    pub fn copy_to(&self, action: CopyAction, dst: ValueRef) -> @mut Block {\n+    pub fn copy_to(&self, action: CopyAction, dst: ValueRef) -> @Block {\n         self.datum.copy_to(self.bcx, action, dst)\n     }\n \n-    pub fn move_to(&self, action: CopyAction, dst: ValueRef) -> @mut Block {\n+    pub fn move_to(&self, action: CopyAction, dst: ValueRef) -> @Block {\n         self.datum.move_to(self.bcx, action, dst)\n     }\n \n@@ -857,7 +857,7 @@ impl DatumBlock {\n         rslt(self.bcx, self.datum.to_appropriate_llval(self.bcx))\n     }\n \n-    pub fn ccx(&self) -> @mut CrateContext {\n+    pub fn ccx(&self) -> @CrateContext {\n         self.bcx.ccx()\n     }\n "}, {"sha": "d81eaf8fab87565527d3d7ca145462ee47265273", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 174, "deletions": 129, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -142,6 +142,7 @@ use middle::pat_util;\n use util::ppaux;\n \n use std::c_str::ToCStr;\n+use std::cell::{Cell, RefCell};\n use std::hashmap::HashMap;\n use std::hashmap::HashSet;\n use std::libc::{c_uint, c_ulonglong, c_longlong};\n@@ -174,13 +175,13 @@ pub struct CrateDebugContext {\n     priv crate_file: ~str,\n     priv llcontext: ContextRef,\n     priv builder: DIBuilderRef,\n-    priv current_debug_location: DebugLocation,\n-    priv created_files: HashMap<~str, DIFile>,\n-    priv created_types: HashMap<uint, DIType>,\n-    priv namespace_map: HashMap<~[ast::Ident], @NamespaceTreeNode>,\n+    priv current_debug_location: Cell<DebugLocation>,\n+    priv created_files: RefCell<HashMap<~str, DIFile>>,\n+    priv created_types: RefCell<HashMap<uint, DIType>>,\n+    priv namespace_map: RefCell<HashMap<~[ast::Ident], @NamespaceTreeNode>>,\n     // This collection is used to assert that composite types (structs, enums, ...) have their\n     // members only set once:\n-    priv composite_types_completed: HashSet<DIType>,\n+    priv composite_types_completed: RefCell<HashSet<DIType>>,\n }\n \n impl CrateDebugContext {\n@@ -193,11 +194,11 @@ impl CrateDebugContext {\n             crate_file: crate,\n             llcontext: llcontext,\n             builder: builder,\n-            current_debug_location: UnknownLocation,\n-            created_files: HashMap::new(),\n-            created_types: HashMap::new(),\n-            namespace_map: HashMap::new(),\n-            composite_types_completed: HashSet::new(),\n+            current_debug_location: Cell::new(UnknownLocation),\n+            created_files: RefCell::new(HashMap::new()),\n+            created_types: RefCell::new(HashMap::new()),\n+            namespace_map: RefCell::new(HashMap::new()),\n+            composite_types_completed: RefCell::new(HashSet::new()),\n         };\n     }\n }\n@@ -221,21 +222,6 @@ impl FunctionDebugContext {\n         }\n     }\n \n-    fn get_mut_ref<'a>(&'a mut self,\n-                       cx: &CrateContext,\n-                       span: Span)\n-                    -> &'a mut FunctionDebugContextData {\n-        match *self {\n-            FunctionDebugContext(~ref mut data) => data,\n-            DebugInfoDisabled => {\n-                cx.sess.span_bug(span, FunctionDebugContext::debuginfo_disabled_message());\n-            }\n-            FunctionWithoutDebugInfo => {\n-                cx.sess.span_bug(span, FunctionDebugContext::should_be_ignored_message());\n-            }\n-        }\n-    }\n-\n     fn debuginfo_disabled_message() -> &'static str {\n         \"debuginfo: Error trying to access FunctionDebugContext although debug info is disabled!\"\n     }\n@@ -247,10 +233,10 @@ impl FunctionDebugContext {\n }\n \n struct FunctionDebugContextData {\n-    scope_map: HashMap<ast::NodeId, DIScope>,\n+    scope_map: RefCell<HashMap<ast::NodeId, DIScope>>,\n     fn_metadata: DISubprogram,\n-    argument_counter: uint,\n-    source_locations_enabled: bool,\n+    argument_counter: Cell<uint>,\n+    source_locations_enabled: Cell<bool>,\n }\n \n enum VariableAccess<'a> {\n@@ -268,7 +254,7 @@ enum VariableKind {\n }\n \n /// Create any deferred debug metadata nodes\n-pub fn finalize(cx: @mut CrateContext) {\n+pub fn finalize(cx: @CrateContext) {\n     if cx.dbg_cx.is_none() {\n         return;\n     }\n@@ -284,7 +270,7 @@ pub fn finalize(cx: @mut CrateContext) {\n /// Creates debug information for the given local variable.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_local_var_metadata(bcx: @mut Block,\n+pub fn create_local_var_metadata(bcx: @Block,\n                                  local: &ast::Local) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n@@ -297,11 +283,15 @@ pub fn create_local_var_metadata(bcx: @mut Block,\n         let var_ident = ast_util::path_to_ident(path_ref);\n         let var_type = node_id_type(bcx, node_id);\n \n-        let llptr = match bcx.fcx.lllocals.find_copy(&node_id) {\n-            Some(v) => v,\n-            None => {\n-                bcx.tcx().sess.span_bug(span,\n-                    format!(\"No entry in lllocals table for {:?}\", node_id));\n+        let llptr = {\n+            let lllocals = bcx.fcx.lllocals.borrow();\n+            match lllocals.get().find_copy(&node_id) {\n+                Some(v) => v,\n+                None => {\n+                    bcx.tcx().sess.span_bug(span,\n+                        format!(\"No entry in lllocals table for {:?}\",\n+                                node_id));\n+                }\n             }\n         };\n \n@@ -320,7 +310,7 @@ pub fn create_local_var_metadata(bcx: @mut Block,\n /// Creates debug information for a variable captured in a closure.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_captured_var_metadata(bcx: @mut Block,\n+pub fn create_captured_var_metadata(bcx: @Block,\n                                     node_id: ast::NodeId,\n                                     env_data_type: ty::t,\n                                     env_pointer: ValueRef,\n@@ -387,7 +377,7 @@ pub fn create_captured_var_metadata(bcx: @mut Block,\n /// Creates debug information for a local variable introduced in the head of a match-statement arm.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_match_binding_metadata(bcx: @mut Block,\n+pub fn create_match_binding_metadata(bcx: @Block,\n                                      variable_ident: ast::Ident,\n                                      node_id: ast::NodeId,\n                                      variable_type: ty::t,\n@@ -396,10 +386,17 @@ pub fn create_match_binding_metadata(bcx: @mut Block,\n         return;\n     }\n \n-    let llptr = match bcx.fcx.lllocals.find_copy(&node_id) {\n-        Some(v) => v,\n-        None => {\n-            bcx.tcx().sess.span_bug(span, format!(\"No entry in lllocals table for {:?}\", node_id));\n+    let llptr = {\n+        let lllocals = bcx.fcx.lllocals.borrow();\n+        match lllocals.get().find_copy(&node_id) {\n+            Some(v) => v,\n+            None => {\n+                bcx.tcx()\n+                   .sess\n+                   .span_bug(span,\n+                             format!(\"No entry in lllocals table for {:?}\",\n+                                     node_id));\n+            }\n         }\n     };\n \n@@ -417,7 +414,7 @@ pub fn create_match_binding_metadata(bcx: @mut Block,\n /// Creates debug information for the self argument of a method.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_self_argument_metadata(bcx: @mut Block,\n+pub fn create_self_argument_metadata(bcx: @Block,\n                                      type_of_self: ty::t,\n                                      llptr: ValueRef) {\n     if fn_should_be_ignored(bcx.fcx) {\n@@ -447,9 +444,9 @@ pub fn create_self_argument_metadata(bcx: @mut Block,\n     let scope_metadata = bcx.fcx.debug_context.get_ref(bcx.ccx(), span).fn_metadata;\n \n     let argument_index = {\n-        let counter = &mut bcx.fcx.debug_context.get_mut_ref(bcx.ccx(), span).argument_counter;\n-        let argument_index = *counter;\n-        *counter += 1;\n+        let counter = &bcx.fcx.debug_context.get_ref(bcx.ccx(), span).argument_counter;\n+        let argument_index = counter.get();\n+        counter.set(argument_index + 1);\n         argument_index\n     };\n \n@@ -492,7 +489,7 @@ pub fn create_self_argument_metadata(bcx: @mut Block,\n /// Creates debug information for the given function argument.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_argument_metadata(bcx: @mut Block,\n+pub fn create_argument_metadata(bcx: @Block,\n                                 arg: &ast::arg) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n@@ -505,11 +502,15 @@ pub fn create_argument_metadata(bcx: @mut Block,\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n \n     pat_util::pat_bindings(def_map, arg.pat, |_, node_id, span, path_ref| {\n-        let llptr = match bcx.fcx.llargs.find_copy(&node_id) {\n-            Some(v) => v,\n-            None => {\n-                bcx.tcx().sess.span_bug(span,\n-                    format!(\"No entry in llargs table for {:?}\", node_id));\n+        let llptr = {\n+            let llargs = bcx.fcx.llargs.borrow();\n+            match llargs.get().find_copy(&node_id) {\n+                Some(v) => v,\n+                None => {\n+                    bcx.tcx().sess.span_bug(span,\n+                        format!(\"No entry in llargs table for {:?}\",\n+                                node_id));\n+                }\n             }\n         };\n \n@@ -522,9 +523,9 @@ pub fn create_argument_metadata(bcx: @mut Block,\n         let argument_ident = ast_util::path_to_ident(path_ref);\n \n         let argument_index = {\n-            let counter = &mut fcx.debug_context.get_mut_ref(cx, span).argument_counter;\n-            let argument_index = *counter;\n-            *counter += 1;\n+            let counter = &fcx.debug_context.get_ref(cx, span).argument_counter;\n+            let argument_index = counter.get();\n+            counter.set(argument_index + 1);\n             argument_index\n         };\n \n@@ -553,7 +554,7 @@ pub fn set_source_location(fcx: &FunctionContext,\n \n     debug!(\"set_source_location: {}\", cx.sess.codemap.span_to_str(span));\n \n-    if fcx.debug_context.get_ref(cx, span).source_locations_enabled {\n+    if fcx.debug_context.get_ref(cx, span).source_locations_enabled.get() {\n         let loc = span_start(cx, span);\n         let scope = scope_metadata(fcx, node_id, span);\n \n@@ -580,9 +581,11 @@ pub fn clear_source_location(fcx: &FunctionContext) {\n /// when beginning to translate a new function. This functions switches source location emitting on\n /// and must therefore be called before the first real statement/expression of the function is\n /// translated.\n-pub fn start_emitting_source_locations(fcx: &mut FunctionContext) {\n+pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n     match fcx.debug_context {\n-        FunctionDebugContext(~ref mut data) => data.source_locations_enabled = true,\n+        FunctionDebugContext(~ref data) => {\n+            data.source_locations_enabled.set(true)\n+        },\n         _ => { /* safe to ignore */ }\n     }\n }\n@@ -592,7 +595,7 @@ pub fn start_emitting_source_locations(fcx: &mut FunctionContext) {\n /// Returns the FunctionDebugContext for the function which holds state needed for debug info\n /// creation. The function may also return another variant of the FunctionDebugContext enum which\n /// indicates why no debuginfo should be created for the function.\n-pub fn create_function_debug_context(cx: &mut CrateContext,\n+pub fn create_function_debug_context(cx: &CrateContext,\n                                      fn_ast_id: ast::NodeId,\n                                      param_substs: Option<@param_substs>,\n                                      llfn: ValueRef) -> FunctionDebugContext {\n@@ -716,7 +719,10 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n     // (by being externally visible or by being inlined into something externally visible). It might\n     // better to use the `exported_items` set from `driver::CrateAnalysis` in the future, but (atm)\n     // this set is not available in the translation pass.\n-    let is_local_to_unit = !cx.reachable.contains(&fn_ast_id);\n+    let is_local_to_unit = {\n+        let reachable = cx.reachable.borrow();\n+        !reachable.get().contains(&fn_ast_id)\n+    };\n \n     let fn_metadata = function_name.with_c_str(|function_name| {\n                           linkage_name.with_c_str(|linkage_name| {\n@@ -742,22 +748,29 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n     });\n \n     // Initialize fn debug context (including scope map and namespace map)\n-    let mut fn_debug_context = ~FunctionDebugContextData {\n-        scope_map: HashMap::new(),\n+    let fn_debug_context = ~FunctionDebugContextData {\n+        scope_map: RefCell::new(HashMap::new()),\n         fn_metadata: fn_metadata,\n-        argument_counter: 1,\n-        source_locations_enabled: false,\n+        argument_counter: Cell::new(1),\n+        source_locations_enabled: Cell::new(false),\n     };\n \n     let arg_pats = fn_decl.inputs.map(|arg_ref| arg_ref.pat);\n-    populate_scope_map(cx, arg_pats, top_level_block, fn_metadata, &mut fn_debug_context.scope_map);\n+    {\n+        let mut scope_map = fn_debug_context.scope_map.borrow_mut();\n+        populate_scope_map(cx,\n+                           arg_pats,\n+                           top_level_block,\n+                           fn_metadata,\n+                           scope_map.get());\n+    }\n \n     // Clear the debug location so we don't assign them in the function prelude\n     set_debug_location(cx, UnknownLocation);\n \n     return FunctionDebugContext(fn_debug_context);\n \n-    fn get_function_signature(cx: &mut CrateContext,\n+    fn get_function_signature(cx: &CrateContext,\n                               fn_ast_id: ast::NodeId,\n                               fn_decl: &ast::fn_decl,\n                               param_substs: Option<@param_substs>,\n@@ -805,7 +818,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         return create_DIArray(DIB(cx), signature);\n     }\n \n-    fn get_template_parameters(cx: &mut CrateContext,\n+    fn get_template_parameters(cx: &CrateContext,\n                                generics: &ast::Generics,\n                                param_substs: Option<@param_substs>,\n                                file_metadata: DIFile,\n@@ -917,7 +930,7 @@ fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n     };\n }\n \n-fn compile_unit_metadata(cx: @mut CrateContext) {\n+fn compile_unit_metadata(cx: @CrateContext) {\n     let dcx = debug_context(cx);\n     let crate_name: &str = dcx.crate_file;\n \n@@ -951,14 +964,14 @@ fn compile_unit_metadata(cx: @mut CrateContext) {\n     });\n }\n \n-fn declare_local(bcx: @mut Block,\n+fn declare_local(bcx: @Block,\n                  variable_ident: ast::Ident,\n                  variable_type: ty::t,\n                  scope_metadata: DIScope,\n                  variable_access: VariableAccess,\n                  variable_kind: VariableKind,\n                  span: Span) {\n-    let cx: &mut CrateContext = bcx.ccx();\n+    let cx: &CrateContext = bcx.ccx();\n \n     let filename = span_start(cx, span).file.name;\n     let file_metadata = file_metadata(cx, filename);\n@@ -1023,17 +1036,24 @@ fn declare_local(bcx: @mut Block,\n \n     match variable_kind {\n         ArgumentVariable(_) | CapturedVariable => {\n-            assert!(!bcx.fcx.debug_context.get_ref(cx, span).source_locations_enabled);\n+            assert!(!bcx.fcx\n+                        .debug_context\n+                        .get_ref(cx, span)\n+                        .source_locations_enabled\n+                        .get());\n             set_debug_location(cx, UnknownLocation);\n         }\n         _ => { /* nothing to do */ }\n     }\n }\n \n-fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n-    match debug_context(cx).created_files.find_equiv(&full_path) {\n-        Some(file_metadata) => return *file_metadata,\n-        None => ()\n+fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n+    {\n+        let created_files = debug_context(cx).created_files.borrow();\n+        match created_files.get().find_equiv(&full_path) {\n+            Some(file_metadata) => return *file_metadata,\n+            None => ()\n+        }\n     }\n \n     debug!(\"file_metadata: {}\", full_path);\n@@ -1056,7 +1076,8 @@ fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n             })\n         });\n \n-    debug_context(cx).created_files.insert(full_path.to_owned(), file_metadata);\n+    let mut created_files = debug_context(cx).created_files.borrow_mut();\n+    created_files.get().insert(full_path.to_owned(), file_metadata);\n     return file_metadata;\n }\n \n@@ -1066,8 +1087,9 @@ fn scope_metadata(fcx: &FunctionContext,\n                   span: Span)\n                -> DIScope {\n     let scope_map = &fcx.debug_context.get_ref(fcx.ccx, span).scope_map;\n+    let scope_map = scope_map.borrow();\n \n-    match scope_map.find_copy(&node_id) {\n+    match scope_map.get().find_copy(&node_id) {\n         Some(scope_metadata) => scope_metadata,\n         None => {\n             let node = fcx.ccx.tcx.items.get_copy(&node_id);\n@@ -1078,7 +1100,7 @@ fn scope_metadata(fcx: &FunctionContext,\n     }\n }\n \n-fn basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n+fn basic_type_metadata(cx: &CrateContext, t: ty::t) -> DIType {\n \n     debug!(\"basic_type_metadata: {:?}\", ty::get(t));\n \n@@ -1124,7 +1146,7 @@ fn basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n     return ty_metadata;\n }\n \n-fn pointer_type_metadata(cx: &mut CrateContext,\n+fn pointer_type_metadata(cx: &CrateContext,\n                          pointer_type: ty::t,\n                          pointee_type_metadata: DIType)\n                       -> DIType {\n@@ -1145,7 +1167,7 @@ fn pointer_type_metadata(cx: &mut CrateContext,\n }\n \n trait MemberDescriptionFactory {\n-    fn create_member_descriptions(&self, cx: &mut CrateContext)\n+    fn create_member_descriptions(&self, cx: &CrateContext)\n                                   -> ~[MemberDescription];\n }\n \n@@ -1155,7 +1177,7 @@ struct StructMemberDescriptionFactory {\n }\n \n impl MemberDescriptionFactory for StructMemberDescriptionFactory {\n-    fn create_member_descriptions(&self, cx: &mut CrateContext)\n+    fn create_member_descriptions(&self, cx: &CrateContext)\n                                   -> ~[MemberDescription] {\n         self.fields.map(|field| {\n             let name = if field.ident.name == special_idents::unnamed_field.name {\n@@ -1174,7 +1196,7 @@ impl MemberDescriptionFactory for StructMemberDescriptionFactory {\n     }\n }\n \n-fn prepare_struct_metadata(cx: &mut CrateContext,\n+fn prepare_struct_metadata(cx: &CrateContext,\n                            struct_type: ty::t,\n                            def_id: ast::DefId,\n                            substs: &ty::substs,\n@@ -1222,7 +1244,7 @@ enum RecursiveTypeDescription {\n \n impl RecursiveTypeDescription {\n \n-    fn finalize(&self, cx: &mut CrateContext) -> DICompositeType {\n+    fn finalize(&self, cx: &CrateContext) -> DICompositeType {\n         match *self {\n             FinalMetadata(metadata) => metadata,\n             UnfinishedMetadata {\n@@ -1233,7 +1255,11 @@ impl RecursiveTypeDescription {\n                 member_description_factory\n             } => {\n                 // Insert the stub into the cache in order to allow recursive references ...\n-                debug_context(cx).created_types.insert(cache_id, metadata_stub);\n+                {\n+                    let mut created_types = debug_context(cx).created_types\n+                                                             .borrow_mut();\n+                    created_types.get().insert(cache_id, metadata_stub);\n+                }\n \n                 // ... then create the member descriptions ...\n                 let member_descriptions = member_description_factory.\n@@ -1258,7 +1284,7 @@ struct TupleMemberDescriptionFactory {\n }\n \n impl MemberDescriptionFactory for TupleMemberDescriptionFactory {\n-    fn create_member_descriptions(&self, cx: &mut CrateContext)\n+    fn create_member_descriptions(&self, cx: &CrateContext)\n                                   -> ~[MemberDescription] {\n         self.component_types.map(|&component_type| {\n             MemberDescription {\n@@ -1271,7 +1297,7 @@ impl MemberDescriptionFactory for TupleMemberDescriptionFactory {\n     }\n }\n \n-fn prepare_tuple_metadata(cx: &mut CrateContext,\n+fn prepare_tuple_metadata(cx: &CrateContext,\n                           tuple_type: ty::t,\n                           component_types: &[ty::t],\n                           span: Span)\n@@ -1309,7 +1335,7 @@ struct GeneralMemberDescriptionFactory {\n }\n \n impl MemberDescriptionFactory for GeneralMemberDescriptionFactory {\n-    fn create_member_descriptions(&self, cx: &mut CrateContext)\n+    fn create_member_descriptions(&self, cx: &CrateContext)\n                                   -> ~[MemberDescription] {\n         // Capture type_rep, so we don't have to copy the struct_defs array\n         let struct_defs = match *self.type_rep {\n@@ -1356,7 +1382,7 @@ struct EnumVariantMemberDescriptionFactory {\n }\n \n impl MemberDescriptionFactory for EnumVariantMemberDescriptionFactory {\n-    fn create_member_descriptions(&self, cx: &mut CrateContext)\n+    fn create_member_descriptions(&self, cx: &CrateContext)\n                                   -> ~[MemberDescription] {\n         self.args.iter().enumerate().map(|(i, &(name, ty))| {\n             MemberDescription {\n@@ -1372,7 +1398,7 @@ impl MemberDescriptionFactory for EnumVariantMemberDescriptionFactory {\n     }\n }\n \n-fn describe_variant(cx: &mut CrateContext,\n+fn describe_variant(cx: &CrateContext,\n                     struct_def: &adt::Struct,\n                     variant_info: &ty::VariantInfo,\n                     discriminant_type_metadata: Option<DIType>,\n@@ -1435,7 +1461,7 @@ fn describe_variant(cx: &mut CrateContext,\n     (metadata_stub, variant_llvm_type, member_description_factory)\n }\n \n-fn prepare_enum_metadata(cx: &mut CrateContext,\n+fn prepare_enum_metadata(cx: &CrateContext,\n                          enum_type: ty::t,\n                          enum_def_id: ast::DefId,\n                          span: Span)\n@@ -1600,7 +1626,7 @@ struct MemberDescription {\n /// Creates debug information for a composite type, that is, anything that results in a LLVM struct.\n ///\n /// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums.\n-fn composite_type_metadata(cx: &mut CrateContext,\n+fn composite_type_metadata(cx: &CrateContext,\n                            composite_llvm_type: Type,\n                            composite_type_name: &str,\n                            member_descriptions: &[MemberDescription],\n@@ -1627,7 +1653,7 @@ fn composite_type_metadata(cx: &mut CrateContext,\n     return composite_type_metadata;\n }\n \n-fn set_members_of_composite_type(cx: &mut CrateContext,\n+fn set_members_of_composite_type(cx: &CrateContext,\n                                  composite_type_metadata: DICompositeType,\n                                  composite_llvm_type: Type,\n                                  member_descriptions: &[MemberDescription],\n@@ -1637,11 +1663,16 @@ fn set_members_of_composite_type(cx: &mut CrateContext,\n     // used instead of a new one created in create_struct_stub. This would cause a hard to trace\n     // assertion in DICompositeType::SetTypeArray(). The following check makes sure that we get a\n     // better error message if this should happen again due to some regression.\n-    if debug_context(cx).composite_types_completed.contains(&composite_type_metadata) {\n-        cx.sess.span_bug(definition_span, \"debuginfo::set_members_of_composite_type() - Already \\\n-                                           completed forward declaration re-encountered.\");\n-    } else {\n-        debug_context(cx).composite_types_completed.insert(composite_type_metadata);\n+    {\n+        let mut composite_types_completed =\n+            debug_context(cx).composite_types_completed.borrow_mut();\n+        if composite_types_completed.get().contains(&composite_type_metadata) {\n+            cx.sess.span_bug(definition_span, \"debuginfo::set_members_of_composite_type() - \\\n+                                               Already completed forward declaration \\\n+                                               re-encountered.\");\n+        } else {\n+            composite_types_completed.get().insert(composite_type_metadata);\n+        }\n     }\n \n     let loc = span_start(cx, definition_span);\n@@ -1682,7 +1713,7 @@ fn set_members_of_composite_type(cx: &mut CrateContext,\n \n // A convenience wrapper around LLVMDIBuilderCreateStructType(). Does not do any caching, does not\n // add any fields to the struct. This can be done later with set_members_of_composite_type().\n-fn create_struct_stub(cx: &mut CrateContext,\n+fn create_struct_stub(cx: &CrateContext,\n                       struct_llvm_type: Type,\n                       struct_type_name: &str,\n                       containing_scope: DIScope,\n@@ -1725,7 +1756,7 @@ fn create_struct_stub(cx: &mut CrateContext,\n     };\n }\n \n-fn boxed_type_metadata(cx: &mut CrateContext,\n+fn boxed_type_metadata(cx: &CrateContext,\n                        content_type_name: Option<&str>,\n                        content_llvm_type: Type,\n                        content_type_metadata: DIType,\n@@ -1804,7 +1835,7 @@ fn boxed_type_metadata(cx: &mut CrateContext,\n     }\n }\n \n-fn fixed_vec_metadata(cx: &mut CrateContext,\n+fn fixed_vec_metadata(cx: &CrateContext,\n                       element_type: ty::t,\n                       len: uint,\n                       span: Span)\n@@ -1831,7 +1862,7 @@ fn fixed_vec_metadata(cx: &mut CrateContext,\n     };\n }\n \n-fn vec_metadata(cx: &mut CrateContext,\n+fn vec_metadata(cx: &CrateContext,\n                 element_type: ty::t,\n                 span: Span)\n              -> DICompositeType {\n@@ -1891,7 +1922,7 @@ fn vec_metadata(cx: &mut CrateContext,\n         span);\n }\n \n-fn boxed_vec_metadata(cx: &mut CrateContext,\n+fn boxed_vec_metadata(cx: &CrateContext,\n                       element_type: ty::t,\n                       span: Span)\n                    -> DICompositeType {\n@@ -1908,7 +1939,7 @@ fn boxed_vec_metadata(cx: &mut CrateContext,\n         span);\n }\n \n-fn vec_slice_metadata(cx: &mut CrateContext,\n+fn vec_slice_metadata(cx: &CrateContext,\n                       vec_type: ty::t,\n                       element_type: ty::t,\n                       span: Span)\n@@ -1953,7 +1984,7 @@ fn vec_slice_metadata(cx: &mut CrateContext,\n         file_metadata,\n         span);\n \n-    fn slice_layout_is_correct(cx: &mut CrateContext,\n+    fn slice_layout_is_correct(cx: &CrateContext,\n                                member_llvm_types: &[Type],\n                                element_type: ty::t)\n                             -> bool {\n@@ -1963,7 +1994,7 @@ fn vec_slice_metadata(cx: &mut CrateContext,\n     }\n }\n \n-fn subroutine_type_metadata(cx: &mut CrateContext,\n+fn subroutine_type_metadata(cx: &CrateContext,\n                             signature: &ty::FnSig,\n                             span: Span)\n                          -> DICompositeType {\n@@ -1991,7 +2022,7 @@ fn subroutine_type_metadata(cx: &mut CrateContext,\n     };\n }\n \n-fn trait_metadata(cx: &mut CrateContext,\n+fn trait_metadata(cx: &CrateContext,\n                   def_id: ast::DefId,\n                   trait_type: ty::t,\n                   substs: &ty::substs,\n@@ -2032,17 +2063,21 @@ fn cache_id_for_type(t: ty::t) -> uint {\n     ty::type_id(t)\n }\n \n-fn type_metadata(cx: &mut CrateContext,\n+fn type_metadata(cx: &CrateContext,\n                  t: ty::t,\n                  usage_site_span: Span)\n               -> DIType {\n     let cache_id = cache_id_for_type(t);\n-    match debug_context(cx).created_types.find(&cache_id) {\n-        Some(type_metadata) => return *type_metadata,\n-        None => ()\n+\n+    {\n+        let created_types = debug_context(cx).created_types.borrow();\n+        match created_types.get().find(&cache_id) {\n+            Some(type_metadata) => return *type_metadata,\n+            None => ()\n+        }\n     }\n \n-    fn create_pointer_to_box_metadata(cx: &mut CrateContext,\n+    fn create_pointer_to_box_metadata(cx: &CrateContext,\n                                       pointer_type: ty::t,\n                                       type_in_box: ty::t)\n                                    -> DIType {\n@@ -2153,7 +2188,8 @@ fn type_metadata(cx: &mut CrateContext,\n         _ => cx.sess.bug(format!(\"debuginfo: unexpected type in type_metadata: {:?}\", sty))\n     };\n \n-    debug_context(cx).created_types.insert(cache_id, type_metadata);\n+    let mut created_types = debug_context(cx).created_types.borrow_mut();\n+    created_types.get().insert(cache_id, type_metadata);\n     return type_metadata;\n }\n \n@@ -2173,8 +2209,8 @@ impl DebugLocation {\n     }\n }\n \n-fn set_debug_location(cx: &mut CrateContext, debug_location: DebugLocation) {\n-    if debug_location == debug_context(cx).current_debug_location {\n+fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n+    if debug_location == debug_context(cx).current_debug_location.get() {\n         return;\n     }\n \n@@ -2201,7 +2237,7 @@ fn set_debug_location(cx: &mut CrateContext, debug_location: DebugLocation) {\n         llvm::LLVMSetCurrentDebugLocation(cx.builder.B, metadata_node);\n     }\n \n-    debug_context(cx).current_debug_location = debug_location;\n+    debug_context(cx).current_debug_location.set(debug_location);\n }\n \n //=-------------------------------------------------------------------------------------------------\n@@ -2213,7 +2249,7 @@ fn span_start(cx: &CrateContext, span: Span) -> codemap::Loc {\n     cx.sess.codemap.lookup_char_pos(span.lo)\n }\n \n-fn size_and_align_of(cx: &mut CrateContext, llvm_type: Type) -> (uint, uint) {\n+fn size_and_align_of(cx: &CrateContext, llvm_type: Type) -> (uint, uint) {\n     (machine::llsize_of_alloc(cx, llvm_type), machine::llalign_of_min(cx, llvm_type))\n }\n \n@@ -2222,8 +2258,9 @@ fn bytes_to_bits(bytes: uint) -> c_ulonglong {\n }\n \n #[inline]\n-fn debug_context<'a>(cx: &'a mut CrateContext) -> &'a mut CrateDebugContext {\n-    cx.dbg_cx.get_mut_ref()\n+fn debug_context<'a>(cx: &'a CrateContext) -> &'a CrateDebugContext {\n+    let debug_context: &'a CrateDebugContext = cx.dbg_cx.get_ref();\n+    debug_context\n }\n \n #[inline]\n@@ -2239,12 +2276,13 @@ fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n }\n \n fn assert_type_for_node_id(cx: &CrateContext, node_id: ast::NodeId, error_span: Span) {\n-    if !cx.tcx.node_types.contains_key(&(node_id as uint)) {\n+    let node_types = cx.tcx.node_types.borrow();\n+    if !node_types.get().contains_key(&(node_id as uint)) {\n         cx.sess.span_bug(error_span, \"debuginfo: Could not find type for node id!\");\n     }\n }\n \n-fn get_namespace_and_span_for_item(cx: &mut CrateContext,\n+fn get_namespace_and_span_for_item(cx: &CrateContext,\n                                    def_id: ast::DefId,\n                                    warning_span: Span)\n                                 -> (DIScope, Span) {\n@@ -2275,7 +2313,7 @@ fn get_namespace_and_span_for_item(cx: &mut CrateContext,\n // scope, creating DIScope DIEs along the way, and introducing *artificial* lexical scope\n // descriptors where necessary. These artificial scopes allow GDB to correctly handle name\n // shadowing.\n-fn populate_scope_map(cx: &mut CrateContext,\n+fn populate_scope_map(cx: &CrateContext,\n                       arg_pats: &[@ast::Pat],\n                       fn_entry_block: &ast::Block,\n                       fn_metadata: DISubprogram,\n@@ -2308,11 +2346,11 @@ fn populate_scope_map(cx: &mut CrateContext,\n     });\n \n     // local helper functions for walking the AST.\n-    fn with_new_scope(cx: &mut CrateContext,\n+    fn with_new_scope(cx: &CrateContext,\n                       scope_span: Span,\n                       scope_stack: &mut ~[ScopeStackEntry],\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>,\n-                      inner_walk: |&mut CrateContext,\n+                      inner_walk: |&CrateContext,\n                                    &mut ~[ScopeStackEntry],\n                                    &mut HashMap<ast::NodeId, DIScope>|) {\n         // Create a new lexical scope and push it onto the stack\n@@ -2345,7 +2383,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n         scope_stack.pop();\n     }\n \n-    fn walk_block(cx: &mut CrateContext,\n+    fn walk_block(cx: &CrateContext,\n                   block: &ast::Block,\n                   scope_stack: &mut ~[ScopeStackEntry],\n                   scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n@@ -2368,7 +2406,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n         }\n     }\n \n-    fn walk_decl(cx: &mut CrateContext,\n+    fn walk_decl(cx: &CrateContext,\n                  decl: &ast::Decl,\n                  scope_stack: &mut ~[ScopeStackEntry],\n                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n@@ -2386,7 +2424,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n         }\n     }\n \n-    fn walk_pattern(cx: &mut CrateContext,\n+    fn walk_pattern(cx: &CrateContext,\n                     pat: @ast::Pat,\n                     scope_stack: &mut ~[ScopeStackEntry],\n                     scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n@@ -2533,7 +2571,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n         }\n     }\n \n-    fn walk_expr(cx: &mut CrateContext,\n+    fn walk_expr(cx: &CrateContext,\n                  exp: &ast::Expr,\n                  scope_stack: &mut ~[ScopeStackEntry],\n                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n@@ -2771,7 +2809,7 @@ impl NamespaceTreeNode {\n     }\n }\n \n-fn namespace_for_item(cx: &mut CrateContext,\n+fn namespace_for_item(cx: &CrateContext,\n                       def_id: ast::DefId,\n                       warning_span: Span)\n                    -> @NamespaceTreeNode {\n@@ -2805,7 +2843,10 @@ fn namespace_for_item(cx: &mut CrateContext,\n         let ident = path_element.ident();\n         current_key.push(ident);\n \n-        let existing_node = debug_context(cx).namespace_map.find_copy(&current_key);\n+        let existing_node = {\n+            let namespace_map = debug_context(cx).namespace_map.borrow();\n+            namespace_map.get().find_copy(&current_key)\n+        };\n         let current_node = match existing_node {\n             Some(existing_node) => existing_node,\n             None => {\n@@ -2833,7 +2874,11 @@ fn namespace_for_item(cx: &mut CrateContext,\n                     parent: parent_node,\n                 };\n \n-                debug_context(cx).namespace_map.insert(current_key.clone(), node);\n+                {\n+                    let mut namespace_map = debug_context(cx).namespace_map\n+                                                             .borrow_mut();\n+                    namespace_map.get().insert(current_key.clone(), node);\n+                }\n \n                 node\n             }"}, {"sha": "2990a27391fe6f9f9fd047cb73df6f3ff1ffcb0a", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 125, "deletions": 77, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -175,14 +175,17 @@ impl Dest {\n     }\n }\n \n-pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n+pub fn trans_to_datum(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n     debug!(\"trans_to_datum(expr={})\", bcx.expr_to_str(expr));\n \n     let mut bcx = bcx;\n     let mut datum = unpack_datum!(bcx, trans_to_datum_unadjusted(bcx, expr));\n-    let adjustment = match bcx.tcx().adjustments.find_copy(&expr.id) {\n-        None => { return DatumBlock {bcx: bcx, datum: datum}; }\n-        Some(adj) => { adj }\n+    let adjustment = {\n+        let adjustments = bcx.tcx().adjustments.borrow();\n+        match adjustments.get().find_copy(&expr.id) {\n+            None => { return DatumBlock {bcx: bcx, datum: datum}; }\n+            Some(adj) => { adj }\n+        }\n     };\n     debug!(\"unadjusted datum: {}\", datum.to_str(bcx.ccx()));\n     match *adjustment {\n@@ -229,11 +232,11 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n     debug!(\"after adjustments, datum={}\", datum.to_str(bcx.ccx()));\n     return DatumBlock {bcx: bcx, datum: datum};\n \n-    fn auto_ref(bcx: @mut Block, datum: Datum) -> DatumBlock {\n+    fn auto_ref(bcx: @Block, datum: Datum) -> DatumBlock {\n         DatumBlock {bcx: bcx, datum: datum.to_rptr(bcx)}\n     }\n \n-    fn auto_borrow_fn(bcx: @mut Block,\n+    fn auto_borrow_fn(bcx: @Block,\n                       adjusted_ty: ty::t,\n                       datum: Datum) -> DatumBlock {\n         // Currently, all closure types are represented precisely the\n@@ -244,7 +247,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n                                   mode: datum.mode}}\n     }\n \n-    fn auto_slice(bcx: @mut Block,\n+    fn auto_slice(bcx: @Block,\n                   autoderefs: uint,\n                   expr: &ast::Expr,\n                   datum: Datum) -> DatumBlock {\n@@ -273,7 +276,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         DatumBlock {bcx: bcx, datum: scratch}\n     }\n \n-    fn add_env(bcx: @mut Block, expr: &ast::Expr, datum: Datum) -> DatumBlock {\n+    fn add_env(bcx: @Block, expr: &ast::Expr, datum: Datum) -> DatumBlock {\n         // This is not the most efficient thing possible; since closures\n         // are two words it'd be better if this were compiled in\n         // 'dest' mode, but I can't find a nice way to structure the\n@@ -292,15 +295,15 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         DatumBlock {bcx: bcx, datum: scratch}\n     }\n \n-    fn auto_slice_and_ref(bcx: @mut Block,\n+    fn auto_slice_and_ref(bcx: @Block,\n                           autoderefs: uint,\n                           expr: &ast::Expr,\n                           datum: Datum) -> DatumBlock {\n         let DatumBlock { bcx, datum } = auto_slice(bcx, autoderefs, expr, datum);\n         auto_ref(bcx, datum)\n     }\n \n-    fn auto_borrow_obj(mut bcx: @mut Block,\n+    fn auto_borrow_obj(mut bcx: @Block,\n                        autoderefs: uint,\n                        expr: &ast::Expr,\n                        source_datum: Datum) -> DatumBlock {\n@@ -414,8 +417,12 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n     }\n }\n \n-pub fn trans_into(bcx: @mut Block, expr: &ast::Expr, dest: Dest) -> @mut Block {\n-    if bcx.tcx().adjustments.contains_key(&expr.id) {\n+pub fn trans_into(bcx: @Block, expr: &ast::Expr, dest: Dest) -> @Block {\n+    let adjustment_found = {\n+        let adjustments = bcx.tcx().adjustments.borrow();\n+        adjustments.get().contains_key(&expr.id)\n+    };\n+    if adjustment_found {\n         // use trans_to_datum, which is mildly less efficient but\n         // which will perform the adjustments:\n         let datumblock = trans_to_datum(bcx, expr);\n@@ -472,26 +479,30 @@ pub fn trans_into(bcx: @mut Block, expr: &ast::Expr, dest: Dest) -> @mut Block {\n     };\n }\n \n-fn trans_lvalue(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n+fn trans_lvalue(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n     /*!\n      *\n      * Translates an lvalue expression, always yielding a by-ref\n      * datum.  Generally speaking you should call trans_to_datum()\n      * instead, but sometimes we call trans_lvalue() directly as a\n      * means of asserting that a particular expression is an lvalue. */\n \n-    return match bcx.tcx().adjustments.find(&expr.id) {\n+    let adjustment_opt = {\n+        let adjustments = bcx.tcx().adjustments.borrow();\n+        adjustments.get().find_copy(&expr.id)\n+    };\n+    match adjustment_opt {\n         None => trans_lvalue_unadjusted(bcx, expr),\n         Some(_) => {\n             bcx.sess().span_bug(\n                 expr.span,\n                 format!(\"trans_lvalue() called on an expression \\\n                       with adjustments\"));\n         }\n-    };\n+    }\n }\n \n-fn trans_to_datum_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n+fn trans_to_datum_unadjusted(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n     /*!\n      * Translates an expression into a datum.  If this expression\n      * is an rvalue, this will result in a temporary value being\n@@ -551,13 +562,13 @@ fn trans_to_datum_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         }\n     }\n \n-    fn nil(bcx: @mut Block, ty: ty::t) -> DatumBlock {\n+    fn nil(bcx: @Block, ty: ty::t) -> DatumBlock {\n         let datum = immediate_rvalue(C_nil(), ty);\n         DatumBlock {bcx: bcx, datum: datum}\n     }\n }\n \n-fn trans_rvalue_datum_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n+fn trans_rvalue_datum_unadjusted(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_rvalue_datum_unadjusted\");\n \n     match expr.node {\n@@ -579,7 +590,10 @@ fn trans_rvalue_datum_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBloc\n         }\n         ast::ExprBinary(_, op, lhs, rhs) => {\n             // if overloaded, would be RvalueDpsExpr\n-            assert!(!bcx.ccx().maps.method_map.contains_key(&expr.id));\n+            {\n+                let method_map = bcx.ccx().maps.method_map.borrow();\n+                assert!(!method_map.get().contains_key(&expr.id));\n+            }\n \n             return trans_binary(bcx, expr, op, lhs, rhs);\n         }\n@@ -608,11 +622,11 @@ fn trans_rvalue_datum_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBloc\n     }\n }\n \n-fn trans_rvalue_stmt_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> @mut Block {\n+fn trans_rvalue_stmt_unadjusted(bcx: @Block, expr: &ast::Expr) -> @Block {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_rvalue_stmt\");\n \n-    if bcx.unreachable {\n+    if bcx.unreachable.get() {\n         return bcx;\n     }\n \n@@ -660,8 +674,8 @@ fn trans_rvalue_stmt_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> @mut Block\n     };\n }\n \n-fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: &ast::Expr,\n-                               dest: Dest) -> @mut Block {\n+fn trans_rvalue_dps_unadjusted(bcx: @Block, expr: &ast::Expr,\n+                               dest: Dest) -> @Block {\n     let _icx = push_ctxt(\"trans_rvalue_dps_unadjusted\");\n     let tcx = bcx.tcx();\n \n@@ -785,8 +799,8 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: &ast::Expr,\n     }\n }\n \n-fn trans_def_dps_unadjusted(bcx: @mut Block, ref_expr: &ast::Expr,\n-                            def: ast::Def, dest: Dest) -> @mut Block {\n+fn trans_def_dps_unadjusted(bcx: @Block, ref_expr: &ast::Expr,\n+                            def: ast::Def, dest: Dest) -> @Block {\n     let _icx = push_ctxt(\"trans_def_dps_unadjusted\");\n     let ccx = bcx.ccx();\n \n@@ -835,7 +849,7 @@ fn trans_def_dps_unadjusted(bcx: @mut Block, ref_expr: &ast::Expr,\n     }\n }\n \n-fn trans_def_datum_unadjusted(bcx: @mut Block,\n+fn trans_def_datum_unadjusted(bcx: @Block,\n                               ref_expr: &ast::Expr,\n                               def: ast::Def) -> DatumBlock\n {\n@@ -870,7 +884,7 @@ fn trans_def_datum_unadjusted(bcx: @mut Block,\n     }\n }\n \n-fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n+fn trans_lvalue_unadjusted(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n     /*!\n      *\n      * Translates an lvalue expression, always yielding a by-ref\n@@ -907,7 +921,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         }\n     };\n \n-    fn trans_rec_field(bcx: @mut Block,\n+    fn trans_rec_field(bcx: @Block,\n                        base: &ast::Expr,\n                        field: ast::Ident) -> DatumBlock {\n         //! Translates `base.field`.\n@@ -931,7 +945,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         })\n     }\n \n-    fn trans_index(bcx: @mut Block,\n+    fn trans_index(bcx: @Block,\n                    index_expr: &ast::Expr,\n                    base: &ast::Expr,\n                    idx: &ast::Expr) -> DatumBlock {\n@@ -985,7 +999,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         };\n     }\n \n-    fn trans_def_lvalue(bcx: @mut Block,\n+    fn trans_def_lvalue(bcx: @Block,\n                         ref_expr: &ast::Expr,\n                         def: ast::Def)\n         -> DatumBlock\n@@ -997,7 +1011,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n             ast::DefStatic(did, _) => {\n                 let const_ty = expr_ty(bcx, ref_expr);\n \n-                fn get_did(ccx: @mut CrateContext, did: ast::DefId)\n+                fn get_did(ccx: @CrateContext, did: ast::DefId)\n                     -> ast::DefId {\n                     if did.crate != ast::LOCAL_CRATE {\n                         inline::maybe_instantiate_inline(ccx, did)\n@@ -1006,7 +1020,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n                     }\n                 }\n \n-                fn get_val(bcx: @mut Block, did: ast::DefId, const_ty: ty::t)\n+                fn get_val(bcx: @Block, did: ast::DefId, const_ty: ty::t)\n                            -> ValueRef {\n                     // For external constants, we don't inline.\n                     if did.crate == ast::LOCAL_CRATE {\n@@ -1018,8 +1032,10 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n                         PointerCast(bcx, val, pty)\n                     } else {\n                         {\n-                            let extern_const_values = &bcx.ccx().extern_const_values;\n-                            match extern_const_values.find(&did) {\n+                            let extern_const_values = bcx.ccx()\n+                                                         .extern_const_values\n+                                                         .borrow();\n+                            match extern_const_values.get().find(&did) {\n                                 None => {}  // Continue.\n                                 Some(llval) => {\n                                     return *llval;\n@@ -1037,8 +1053,9 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n                                                     llty.to_ref(),\n                                                     buf)\n                             });\n-                            let extern_const_values = &mut bcx.ccx().extern_const_values;\n-                            extern_const_values.insert(did, llval);\n+                            let mut extern_const_values =\n+                                bcx.ccx().extern_const_values.borrow_mut();\n+                            extern_const_values.get().insert(did, llval);\n                             llval\n                         }\n                     }\n@@ -1063,14 +1080,15 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n     }\n }\n \n-pub fn trans_local_var(bcx: @mut Block, def: ast::Def) -> Datum {\n+pub fn trans_local_var(bcx: @Block, def: ast::Def) -> Datum {\n     let _icx = push_ctxt(\"trans_local_var\");\n \n     return match def {\n         ast::DefUpvar(nid, _, _, _) => {\n             // Can't move upvars, so this is never a ZeroMemLastUse.\n             let local_ty = node_id_type(bcx, nid);\n-            match bcx.fcx.llupvars.find(&nid) {\n+            let llupvars = bcx.fcx.llupvars.borrow();\n+            match llupvars.get().find(&nid) {\n                 Some(&val) => {\n                     Datum {\n                         val: val,\n@@ -1085,14 +1103,16 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::Def) -> Datum {\n             }\n         }\n         ast::DefArg(nid, _) => {\n-            take_local(bcx, bcx.fcx.llargs, nid)\n+            let llargs = bcx.fcx.llargs.borrow();\n+            take_local(bcx, llargs.get(), nid)\n         }\n         ast::DefLocal(nid, _) | ast::DefBinding(nid, _) => {\n-            take_local(bcx, bcx.fcx.lllocals, nid)\n+            let lllocals = bcx.fcx.lllocals.borrow();\n+            take_local(bcx, lllocals.get(), nid)\n         }\n         ast::DefSelf(nid, _) => {\n-            let self_info: ValSelfData = match bcx.fcx.llself {\n-                Some(ref self_info) => *self_info,\n+            let self_info: ValSelfData = match bcx.fcx.llself.get() {\n+                Some(self_info) => self_info,\n                 None => {\n                     bcx.sess().bug(format!(\n                         \"trans_local_var: reference to self \\\n@@ -1115,7 +1135,7 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::Def) -> Datum {\n         }\n     };\n \n-    fn take_local(bcx: @mut Block,\n+    fn take_local(bcx: @Block,\n                   table: &HashMap<ast::NodeId, ValueRef>,\n                   nid: ast::NodeId) -> Datum {\n         let v = match table.find(&nid) {\n@@ -1160,7 +1180,11 @@ pub fn with_field_tys<R>(\n                         ty.repr(tcx)));\n                 }\n                 Some(node_id) => {\n-                    match tcx.def_map.get_copy(&node_id) {\n+                    let opt_def = {\n+                        let def_map = tcx.def_map.borrow();\n+                        def_map.get().get_copy(&node_id)\n+                    };\n+                    match opt_def {\n                         ast::DefVariant(enum_id, variant_id, _) => {\n                             let variant_info = ty::enum_variant_with_id(\n                                 tcx, enum_id, variant_id);\n@@ -1184,12 +1208,12 @@ pub fn with_field_tys<R>(\n     }\n }\n \n-fn trans_rec_or_struct(bcx: @mut Block,\n+fn trans_rec_or_struct(bcx: @Block,\n                        fields: &[ast::Field],\n                        base: Option<@ast::Expr>,\n                        expr_span: codemap::Span,\n                        id: ast::NodeId,\n-                       dest: Dest) -> @mut Block\n+                       dest: Dest) -> @Block\n {\n     let _icx = push_ctxt(\"trans_rec\");\n     let bcx = bcx;\n@@ -1263,10 +1287,10 @@ struct StructBaseInfo {\n  * - `optbase` contains information on the base struct (if any) from\n  * which remaining fields are copied; see comments on `StructBaseInfo`.\n  */\n-fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: ty::Disr,\n+fn trans_adt(bcx: @Block, repr: &adt::Repr, discr: ty::Disr,\n              fields: &[(uint, @ast::Expr)],\n              optbase: Option<StructBaseInfo>,\n-             dest: Dest) -> @mut Block {\n+             dest: Dest) -> @Block {\n     let _icx = push_ctxt(\"trans_adt\");\n     let mut bcx = bcx;\n     let addr = match dest {\n@@ -1311,15 +1335,15 @@ fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: ty::Disr,\n }\n \n \n-fn trans_immediate_lit(bcx: @mut Block, expr: &ast::Expr,\n+fn trans_immediate_lit(bcx: @Block, expr: &ast::Expr,\n                        lit: ast::lit) -> DatumBlock {\n     // must not be a string constant, that is a RvalueDpsExpr\n     let _icx = push_ctxt(\"trans_immediate_lit\");\n     let ty = expr_ty(bcx, expr);\n     immediate_rvalue_bcx(bcx, consts::const_lit(bcx.ccx(), expr, lit), ty)\n }\n \n-fn trans_unary_datum(bcx: @mut Block,\n+fn trans_unary_datum(bcx: @Block,\n                      un_expr: &ast::Expr,\n                      op: ast::UnOp,\n                      sub_expr: &ast::Expr) -> DatumBlock {\n@@ -1329,7 +1353,10 @@ fn trans_unary_datum(bcx: @mut Block,\n     assert!(op != ast::UnDeref);\n \n     // if overloaded, would be RvalueDpsExpr\n-    assert!(!bcx.ccx().maps.method_map.contains_key(&un_expr.id));\n+    {\n+        let method_map = bcx.ccx().maps.method_map.borrow();\n+        assert!(!method_map.get().contains_key(&un_expr.id));\n+    }\n \n     let un_ty = expr_ty(bcx, un_expr);\n     let sub_ty = expr_ty(bcx, sub_expr);\n@@ -1379,7 +1406,7 @@ fn trans_unary_datum(bcx: @mut Block,\n         }\n     };\n \n-    fn trans_boxed_expr(bcx: @mut Block,\n+    fn trans_boxed_expr(bcx: @Block,\n                         box_ty: ty::t,\n                         contents: &ast::Expr,\n                         contents_ty: ty::t,\n@@ -1408,7 +1435,7 @@ fn trans_unary_datum(bcx: @mut Block,\n     }\n }\n \n-fn trans_addr_of(bcx: @mut Block, expr: &ast::Expr,\n+fn trans_addr_of(bcx: @Block, expr: &ast::Expr,\n                  subexpr: &ast::Expr) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_addr_of\");\n     let mut bcx = bcx;\n@@ -1419,7 +1446,7 @@ fn trans_addr_of(bcx: @mut Block, expr: &ast::Expr,\n \n // Important to get types for both lhs and rhs, because one might be _|_\n // and the other not.\n-fn trans_eager_binop(bcx: @mut Block,\n+fn trans_eager_binop(bcx: @Block,\n                      binop_expr: &ast::Expr,\n                      binop_ty: ty::t,\n                      op: ast::BinOp,\n@@ -1522,7 +1549,7 @@ fn trans_eager_binop(bcx: @mut Block,\n // refinement types would obviate the need for this\n enum lazy_binop_ty { lazy_and, lazy_or }\n \n-fn trans_lazy_binop(bcx: @mut Block,\n+fn trans_lazy_binop(bcx: @Block,\n                     binop_expr: &ast::Expr,\n                     op: lazy_binop_ty,\n                     a: &ast::Expr,\n@@ -1537,7 +1564,7 @@ fn trans_lazy_binop(bcx: @mut Block,\n         })\n     };\n \n-    if past_lhs.unreachable {\n+    if past_lhs.unreachable.get() {\n         return immediate_rvalue_bcx(past_lhs, lhs, binop_ty);\n     }\n \n@@ -1556,7 +1583,7 @@ fn trans_lazy_binop(bcx: @mut Block,\n         })\n     };\n \n-    if past_rhs.unreachable {\n+    if past_rhs.unreachable.get() {\n         return immediate_rvalue_bcx(join, lhs, binop_ty);\n     }\n \n@@ -1567,7 +1594,7 @@ fn trans_lazy_binop(bcx: @mut Block,\n     return immediate_rvalue_bcx(join, phi, binop_ty);\n }\n \n-fn trans_binary(bcx: @mut Block,\n+fn trans_binary(bcx: @Block,\n                 binop_expr: &ast::Expr,\n                 op: ast::BinOp,\n                 lhs: &ast::Expr,\n@@ -1593,15 +1620,18 @@ fn trans_binary(bcx: @mut Block,\n     }\n }\n \n-fn trans_overloaded_op(bcx: @mut Block,\n+fn trans_overloaded_op(bcx: @Block,\n                        expr: &ast::Expr,\n                        callee_id: ast::NodeId,\n                        rcvr: &ast::Expr,\n                        args: ~[@ast::Expr],\n                        ret_ty: ty::t,\n                        dest: Dest)\n-                       -> @mut Block {\n-    let origin = bcx.ccx().maps.method_map.get_copy(&expr.id);\n+                       -> @Block {\n+    let origin = {\n+        let method_map = bcx.ccx().maps.method_map.borrow();\n+        method_map.get().get_copy(&expr.id)\n+    };\n     let fty = node_id_type(bcx, callee_id);\n     callee::trans_call_inner(bcx,\n                              expr.info(),\n@@ -1618,7 +1648,7 @@ fn trans_overloaded_op(bcx: @mut Block,\n                              DoAutorefArg).bcx\n }\n \n-fn int_cast(bcx: @mut Block, lldsttype: Type, llsrctype: Type,\n+fn int_cast(bcx: @Block, lldsttype: Type, llsrctype: Type,\n             llsrc: ValueRef, signed: bool) -> ValueRef {\n     let _icx = push_ctxt(\"int_cast\");\n     unsafe {\n@@ -1636,7 +1666,7 @@ fn int_cast(bcx: @mut Block, lldsttype: Type, llsrctype: Type,\n     }\n }\n \n-fn float_cast(bcx: @mut Block, lldsttype: Type, llsrctype: Type,\n+fn float_cast(bcx: @Block, lldsttype: Type, llsrctype: Type,\n               llsrc: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"float_cast\");\n     let srcsz = llsrctype.float_width();\n@@ -1672,7 +1702,7 @@ pub fn cast_type_kind(t: ty::t) -> cast_kind {\n     }\n }\n \n-fn trans_imm_cast(bcx: @mut Block, expr: &ast::Expr,\n+fn trans_imm_cast(bcx: @Block, expr: &ast::Expr,\n                   id: ast::NodeId) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_cast\");\n     let ccx = bcx.ccx();\n@@ -1747,12 +1777,12 @@ fn trans_imm_cast(bcx: @mut Block, expr: &ast::Expr,\n     return immediate_rvalue_bcx(bcx, newval, t_out);\n }\n \n-fn trans_assign_op(bcx: @mut Block,\n+fn trans_assign_op(bcx: @Block,\n                    expr: &ast::Expr,\n                    callee_id: ast::NodeId,\n                    op: ast::BinOp,\n                    dst: &ast::Expr,\n-                   src: @ast::Expr) -> @mut Block\n+                   src: @ast::Expr) -> @Block\n {\n     let _icx = push_ctxt(\"trans_assign_op\");\n     let mut bcx = bcx;\n@@ -1763,7 +1793,11 @@ fn trans_assign_op(bcx: @mut Block,\n     let dst_datum = unpack_datum!(bcx, trans_lvalue_unadjusted(bcx, dst));\n \n     // A user-defined operator method\n-    if bcx.ccx().maps.method_map.find(&expr.id).is_some() {\n+    let found = {\n+        let method_map = bcx.ccx().maps.method_map.borrow();\n+        method_map.get().find(&expr.id).is_some()\n+    };\n+    if found {\n         // FIXME(#2528) evaluates the receiver twice!!\n         let scratch = scratch_datum(bcx, dst_datum.ty, \"__assign_op\", false);\n         let bcx = trans_overloaded_op(bcx,\n@@ -1788,16 +1822,20 @@ fn trans_assign_op(bcx: @mut Block,\n     return result_datum.copy_to_datum(bcx, DROP_EXISTING, dst_datum);\n }\n \n-pub fn trans_log_level(bcx: @mut Block) -> DatumBlock {\n+pub fn trans_log_level(bcx: @Block) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_log_level\");\n     let ccx = bcx.ccx();\n \n     let (modpath, modname) = {\n-        let srccrate = match ccx.external_srcs.find(&bcx.fcx.id) {\n-            Some(&src) => {\n-                ccx.sess.cstore.get_crate_data(src.crate).name\n-            }\n-            None => ccx.link_meta.pkgid.name.to_managed(),\n+        let srccrate;\n+        {\n+            let external_srcs = ccx.external_srcs.borrow();\n+            srccrate = match external_srcs.get().find(&bcx.fcx.id) {\n+                Some(&src) => {\n+                    ccx.sess.cstore.get_crate_data(src.crate).name\n+                }\n+                None => ccx.link_meta.pkgid.name.to_managed(),\n+            };\n         };\n         let mut modpath = ~[path_mod(ccx.sess.ident_of(srccrate))];\n         for e in bcx.fcx.path.iter() {\n@@ -1810,8 +1848,15 @@ pub fn trans_log_level(bcx: @mut Block) -> DatumBlock {\n         (modpath, modname)\n     };\n \n-    let global = if ccx.module_data.contains_key(&modname) {\n-        ccx.module_data.get_copy(&modname)\n+    let module_data_exists;\n+    {\n+        let module_data = ccx.module_data.borrow();\n+        module_data_exists = module_data.get().contains_key(&modname);\n+    }\n+\n+    let global = if module_data_exists {\n+        let mut module_data = ccx.module_data.borrow_mut();\n+        module_data.get().get_copy(&modname)\n     } else {\n         let s = link::mangle_internal_name_by_path_and_seq(\n             ccx, modpath, \"loglevel\");\n@@ -1824,8 +1869,11 @@ pub fn trans_log_level(bcx: @mut Block) -> DatumBlock {\n             llvm::LLVMSetInitializer(global, C_null(Type::i32()));\n             lib::llvm::SetLinkage(global, lib::llvm::InternalLinkage);\n         }\n-        ccx.module_data.insert(modname, global);\n-        global\n+        {\n+            let mut module_data = ccx.module_data.borrow_mut();\n+            module_data.get().insert(modname, global);\n+            global\n+        }\n     };\n \n     return immediate_rvalue_bcx(bcx, Load(bcx, global), ty::mk_u32());"}, {"sha": "21f268fb9471fcf81080a2ff30b2b03da54ecf29", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -72,7 +72,7 @@ struct LlvmSignature {\n ///////////////////////////////////////////////////////////////////////////\n // Calls to external functions\n \n-pub fn llvm_calling_convention(ccx: &mut CrateContext,\n+pub fn llvm_calling_convention(ccx: &CrateContext,\n                                abis: AbiSet) -> Option<CallConv> {\n     let os = ccx.sess.targ_cfg.os;\n     let arch = ccx.sess.targ_cfg.arch;\n@@ -105,7 +105,7 @@ pub fn llvm_calling_convention(ccx: &mut CrateContext,\n }\n \n \n-pub fn register_foreign_item_fn(ccx: @mut CrateContext,\n+pub fn register_foreign_item_fn(ccx: @CrateContext,\n                                 abis: AbiSet,\n                                 path: &ast_map::path,\n                                 foreign_item: @ast::foreign_item) -> ValueRef {\n@@ -146,19 +146,27 @@ pub fn register_foreign_item_fn(ccx: @mut CrateContext,\n \n     // Create the LLVM value for the C extern fn\n     let llfn_ty = lltype_for_fn_from_foreign_types(&tys);\n-    let llfn = base::get_extern_fn(&mut ccx.externs, ccx.llmod,\n-                                   lname, cc, llfn_ty);\n+\n+    let llfn;\n+    {\n+        let mut externs = ccx.externs.borrow_mut();\n+        llfn = base::get_extern_fn(externs.get(),\n+                                   ccx.llmod,\n+                                   lname,\n+                                   cc,\n+                                   llfn_ty);\n+    };\n     add_argument_attributes(&tys, llfn);\n \n     return llfn;\n }\n \n-pub fn trans_native_call(bcx: @mut Block,\n+pub fn trans_native_call(bcx: @Block,\n                          callee_ty: ty::t,\n                          llfn: ValueRef,\n                          llretptr: ValueRef,\n                          llargs_rust: &[ValueRef],\n-                         passed_arg_tys: ~[ty::t]) -> @mut Block {\n+                         passed_arg_tys: ~[ty::t]) -> @Block {\n     /*!\n      * Prepares a call to a native function. This requires adapting\n      * from the Rust argument passing rules to the native rules.\n@@ -341,7 +349,7 @@ pub fn trans_native_call(bcx: @mut Block,\n     return bcx;\n }\n \n-pub fn trans_foreign_mod(ccx: @mut CrateContext,\n+pub fn trans_foreign_mod(ccx: @CrateContext,\n                          foreign_mod: &ast::foreign_mod) {\n     let _icx = push_ctxt(\"foreign::trans_foreign_mod\");\n     for &foreign_item in foreign_mod.items.iter() {\n@@ -360,7 +368,8 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         }\n \n         let lname = link_name(ccx, foreign_item);\n-        ccx.item_symbols.insert(foreign_item.id, lname.to_owned());\n+        let mut item_symbols = ccx.item_symbols.borrow_mut();\n+        item_symbols.get().insert(foreign_item.id, lname.to_owned());\n     }\n }\n \n@@ -389,7 +398,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n // inline the one into the other. Of course we could just generate the\n // correct code in the first place, but this is much simpler.\n \n-pub fn register_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n+pub fn register_rust_fn_with_foreign_abi(ccx: @CrateContext,\n                                          sp: Span,\n                                          sym: ~str,\n                                          node_id: ast::NodeId)\n@@ -418,7 +427,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n     llfn\n }\n \n-pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n+pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n                                       path: &ast_map::path,\n                                       decl: &ast::fn_decl,\n                                       body: &ast::Block,\n@@ -436,7 +445,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n         return build_wrap_fn(ccx, llrustfn, llwrapfn, &tys);\n     }\n \n-    fn build_rust_fn(ccx: @mut CrateContext,\n+    fn build_rust_fn(ccx: @CrateContext,\n                      path: &ast_map::path,\n                      decl: &ast::fn_decl,\n                      body: &ast::Block,\n@@ -485,7 +494,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n         return llfndecl;\n     }\n \n-    unsafe fn build_wrap_fn(ccx: @mut CrateContext,\n+    unsafe fn build_wrap_fn(ccx: @CrateContext,\n                             llrustfn: ValueRef,\n                             llwrapfn: ValueRef,\n                             tys: &ForeignTypes) {\n@@ -737,7 +746,7 @@ pub fn link_name(ccx: &CrateContext, i: @ast::foreign_item) -> @str {\n     }\n }\n \n-fn foreign_signature(ccx: &mut CrateContext, fn_sig: &ty::FnSig, arg_tys: &[ty::t])\n+fn foreign_signature(ccx: &CrateContext, fn_sig: &ty::FnSig, arg_tys: &[ty::t])\n                      -> LlvmSignature {\n     /*!\n      * The ForeignSignature is the LLVM types of the arguments/return type\n@@ -756,12 +765,12 @@ fn foreign_signature(ccx: &mut CrateContext, fn_sig: &ty::FnSig, arg_tys: &[ty::\n     }\n }\n \n-fn foreign_types_for_id(ccx: &mut CrateContext,\n+fn foreign_types_for_id(ccx: &CrateContext,\n                         id: ast::NodeId) -> ForeignTypes {\n     foreign_types_for_fn_ty(ccx, ty::node_id_to_type(ccx.tcx, id))\n }\n \n-fn foreign_types_for_fn_ty(ccx: &mut CrateContext,\n+fn foreign_types_for_fn_ty(ccx: &CrateContext,\n                            ty: ty::t) -> ForeignTypes {\n     let fn_sig = match ty::get(ty).sty {\n         ty::ty_bare_fn(ref fn_ty) => fn_ty.sig.clone(),\n@@ -833,7 +842,7 @@ fn lltype_for_fn_from_foreign_types(tys: &ForeignTypes) -> Type {\n     }\n }\n \n-pub fn lltype_for_foreign_fn(ccx: &mut CrateContext, ty: ty::t) -> Type {\n+pub fn lltype_for_foreign_fn(ccx: &CrateContext, ty: ty::t) -> Type {\n     let fn_types = foreign_types_for_fn_ty(ccx, ty);\n     lltype_for_fn_from_foreign_types(&fn_types)\n }"}, {"sha": "cff0f5b316c3fef43c066ae372fc260db285c6c4", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 97, "deletions": 75, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -37,26 +37,27 @@ use util::ppaux::ty_to_short_str;\n use middle::trans::type_::Type;\n \n use std::c_str::ToCStr;\n+use std::cell::Cell;\n use std::libc::c_uint;\n use syntax::ast;\n \n-pub fn trans_free(cx: @mut Block, v: ValueRef) -> @mut Block {\n+pub fn trans_free(cx: @Block, v: ValueRef) -> @Block {\n     let _icx = push_ctxt(\"trans_free\");\n     callee::trans_lang_call(cx,\n         langcall(cx, None, \"\", FreeFnLangItem),\n         [PointerCast(cx, v, Type::i8p())],\n         Some(expr::Ignore)).bcx\n }\n \n-pub fn trans_exchange_free(cx: @mut Block, v: ValueRef) -> @mut Block {\n+pub fn trans_exchange_free(cx: @Block, v: ValueRef) -> @Block {\n     let _icx = push_ctxt(\"trans_exchange_free\");\n     callee::trans_lang_call(cx,\n         langcall(cx, None, \"\", ExchangeFreeFnLangItem),\n         [PointerCast(cx, v, Type::i8p())],\n         Some(expr::Ignore)).bcx\n }\n \n-pub fn take_ty(cx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n+pub fn take_ty(cx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"take_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n@@ -65,7 +66,7 @@ pub fn take_ty(cx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     return cx;\n }\n \n-pub fn drop_ty(cx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n+pub fn drop_ty(cx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"drop_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n@@ -74,14 +75,14 @@ pub fn drop_ty(cx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     return cx;\n }\n \n-pub fn drop_ty_immediate(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n+pub fn drop_ty_immediate(bcx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     let _icx = push_ctxt(\"drop_ty_immediate\");\n     let vp = alloca(bcx, type_of(bcx.ccx(), t), \"\");\n     Store(bcx, v, vp);\n     drop_ty(bcx, vp, t)\n }\n \n-pub fn free_ty(cx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n+pub fn free_ty(cx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"free_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n@@ -90,7 +91,7 @@ pub fn free_ty(cx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     return cx;\n }\n \n-pub fn free_ty_immediate(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n+pub fn free_ty_immediate(bcx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     let _icx = push_ctxt(\"free_ty_immediate\");\n     match ty::get(t).sty {\n       ty::ty_uniq(_) |\n@@ -108,8 +109,8 @@ pub fn free_ty_immediate(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     }\n }\n \n-pub fn lazily_emit_all_tydesc_glue(ccx: @mut CrateContext,\n-                                   static_ti: @mut tydesc_info) {\n+pub fn lazily_emit_all_tydesc_glue(ccx: @CrateContext,\n+                                   static_ti: @tydesc_info) {\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_take_glue, static_ti);\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, static_ti);\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_free_glue, static_ti);\n@@ -173,23 +174,24 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n     return t;\n }\n \n-pub fn lazily_emit_simplified_tydesc_glue(ccx: @mut CrateContext,\n+pub fn lazily_emit_simplified_tydesc_glue(ccx: @CrateContext,\n                                           field: uint,\n-                                          ti: &mut tydesc_info) -> bool {\n+                                          ti: &tydesc_info)\n+                                          -> bool {\n     let _icx = push_ctxt(\"lazily_emit_simplified_tydesc_glue\");\n     let simpl = simplified_glue_type(ccx.tcx, field, ti.ty);\n     if simpl != ti.ty {\n         let simpl_ti = get_tydesc(ccx, simpl);\n         lazily_emit_tydesc_glue(ccx, field, simpl_ti);\n         {\n             if field == abi::tydesc_field_take_glue {\n-                ti.take_glue = simpl_ti.take_glue;\n+                ti.take_glue.set(simpl_ti.take_glue.get());\n             } else if field == abi::tydesc_field_drop_glue {\n-                ti.drop_glue = simpl_ti.drop_glue;\n+                ti.drop_glue.set(simpl_ti.drop_glue.get());\n             } else if field == abi::tydesc_field_free_glue {\n-                ti.free_glue = simpl_ti.free_glue;\n+                ti.free_glue.set(simpl_ti.free_glue.get());\n             } else if field == abi::tydesc_field_visit_glue {\n-                ti.visit_glue = simpl_ti.visit_glue;\n+                ti.visit_glue.set(simpl_ti.visit_glue.get());\n             }\n         }\n         return true;\n@@ -198,9 +200,9 @@ pub fn lazily_emit_simplified_tydesc_glue(ccx: @mut CrateContext,\n }\n \n \n-pub fn lazily_emit_tydesc_glue(ccx: @mut CrateContext,\n+pub fn lazily_emit_tydesc_glue(ccx: @CrateContext,\n                                field: uint,\n-                               ti: @mut tydesc_info) {\n+                               ti: @tydesc_info) {\n     let _icx = push_ctxt(\"lazily_emit_tydesc_glue\");\n     let llfnty = Type::glue_fn(type_of(ccx, ti.ty).ptr_to());\n \n@@ -209,52 +211,52 @@ pub fn lazily_emit_tydesc_glue(ccx: @mut CrateContext,\n     }\n \n     if field == abi::tydesc_field_take_glue {\n-        match ti.take_glue {\n+        match ti.take_glue.get() {\n           Some(_) => (),\n           None => {\n             debug!(\"+++ lazily_emit_tydesc_glue TAKE {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"take\");\n-            ti.take_glue = Some(glue_fn);\n+            ti.take_glue.set(Some(glue_fn));\n             make_generic_glue(ccx, ti.ty, glue_fn, make_take_glue, \"take\");\n             debug!(\"--- lazily_emit_tydesc_glue TAKE {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n     } else if field == abi::tydesc_field_drop_glue {\n-        match ti.drop_glue {\n+        match ti.drop_glue.get() {\n           Some(_) => (),\n           None => {\n             debug!(\"+++ lazily_emit_tydesc_glue DROP {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"drop\");\n-            ti.drop_glue = Some(glue_fn);\n+            ti.drop_glue.set(Some(glue_fn));\n             make_generic_glue(ccx, ti.ty, glue_fn, make_drop_glue, \"drop\");\n             debug!(\"--- lazily_emit_tydesc_glue DROP {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n     } else if field == abi::tydesc_field_free_glue {\n-        match ti.free_glue {\n+        match ti.free_glue.get() {\n           Some(_) => (),\n           None => {\n             debug!(\"+++ lazily_emit_tydesc_glue FREE {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"free\");\n-            ti.free_glue = Some(glue_fn);\n+            ti.free_glue.set(Some(glue_fn));\n             make_generic_glue(ccx, ti.ty, glue_fn, make_free_glue, \"free\");\n             debug!(\"--- lazily_emit_tydesc_glue FREE {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n     } else if field == abi::tydesc_field_visit_glue {\n-        match ti.visit_glue {\n+        match ti.visit_glue.get() {\n           Some(_) => (),\n           None => {\n             debug!(\"+++ lazily_emit_tydesc_glue VISIT {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"visit\");\n-            ti.visit_glue = Some(glue_fn);\n+            ti.visit_glue.set(Some(glue_fn));\n             make_generic_glue(ccx, ti.ty, glue_fn, make_visit_glue, \"visit\");\n             debug!(\"--- lazily_emit_tydesc_glue VISIT {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n@@ -264,29 +266,29 @@ pub fn lazily_emit_tydesc_glue(ccx: @mut CrateContext,\n }\n \n // See [Note-arg-mode]\n-pub fn call_tydesc_glue_full(bcx: @mut Block,\n+pub fn call_tydesc_glue_full(bcx: @Block,\n                              v: ValueRef,\n                              tydesc: ValueRef,\n                              field: uint,\n-                             static_ti: Option<@mut tydesc_info>) {\n+                             static_ti: Option<@tydesc_info>) {\n     let _icx = push_ctxt(\"call_tydesc_glue_full\");\n     let ccx = bcx.ccx();\n     // NB: Don't short-circuit even if this block is unreachable because\n     // GC-based cleanup needs to the see that the roots are live.\n-    if bcx.unreachable && !ccx.sess.no_landing_pads() { return; }\n+    if bcx.unreachable.get() && !ccx.sess.no_landing_pads() { return; }\n \n     let static_glue_fn = match static_ti {\n       None => None,\n       Some(sti) => {\n         lazily_emit_tydesc_glue(ccx, field, sti);\n         if field == abi::tydesc_field_take_glue {\n-            sti.take_glue\n+            sti.take_glue.get()\n         } else if field == abi::tydesc_field_drop_glue {\n-            sti.drop_glue\n+            sti.drop_glue.get()\n         } else if field == abi::tydesc_field_free_glue {\n-            sti.free_glue\n+            sti.free_glue.get()\n         } else if field == abi::tydesc_field_visit_glue {\n-            sti.visit_glue\n+            sti.visit_glue.get()\n         } else {\n             None\n         }\n@@ -323,15 +325,15 @@ pub fn call_tydesc_glue_full(bcx: @mut Block,\n }\n \n // See [Note-arg-mode]\n-pub fn call_tydesc_glue(cx: @mut Block, v: ValueRef, t: ty::t, field: uint)\n-    -> @mut Block {\n+pub fn call_tydesc_glue(cx: @Block, v: ValueRef, t: ty::t, field: uint)\n+    -> @Block {\n     let _icx = push_ctxt(\"call_tydesc_glue\");\n     let ti = get_tydesc(cx.ccx(), t);\n     call_tydesc_glue_full(cx, v, ti.tydesc, field, Some(ti));\n     return cx;\n }\n \n-pub fn make_visit_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n+pub fn make_visit_glue(bcx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     let _icx = push_ctxt(\"make_visit_glue\");\n     with_scope(bcx, None, \"visitor cleanup\", |bcx| {\n         let mut bcx = bcx;\n@@ -350,7 +352,7 @@ pub fn make_visit_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     })\n }\n \n-pub fn make_free_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n+pub fn make_free_glue(bcx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_free_glue\");\n     match ty::get(t).sty {\n@@ -387,17 +389,17 @@ pub fn make_free_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     }\n }\n \n-pub fn trans_struct_drop_flag(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did: ast::DefId,\n-                              class_did: ast::DefId, substs: &ty::substs) -> @mut Block {\n+pub fn trans_struct_drop_flag(bcx: @Block, t: ty::t, v0: ValueRef, dtor_did: ast::DefId,\n+                              class_did: ast::DefId, substs: &ty::substs) -> @Block {\n     let repr = adt::represent_type(bcx.ccx(), t);\n     let drop_flag = adt::trans_drop_flag_ptr(bcx, repr, v0);\n     with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag)), |cx| {\n         trans_struct_drop(cx, t, v0, dtor_did, class_did, substs)\n     })\n }\n \n-pub fn trans_struct_drop(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did: ast::DefId,\n-                         class_did: ast::DefId, substs: &ty::substs) -> @mut Block {\n+pub fn trans_struct_drop(bcx: @Block, t: ty::t, v0: ValueRef, dtor_did: ast::DefId,\n+                         class_did: ast::DefId, substs: &ty::substs) -> @Block {\n     let repr = adt::represent_type(bcx.ccx(), t);\n \n     // Find and call the actual destructor\n@@ -434,7 +436,7 @@ pub fn trans_struct_drop(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did: ast:\n     })\n }\n \n-pub fn make_drop_glue(bcx: @mut Block, v0: ValueRef, t: ty::t) -> @mut Block {\n+pub fn make_drop_glue(bcx: @Block, v0: ValueRef, t: ty::t) -> @Block {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n     let ccx = bcx.ccx();\n@@ -505,10 +507,10 @@ pub fn make_drop_glue(bcx: @mut Block, v0: ValueRef, t: ty::t) -> @mut Block {\n }\n \n // box_ptr_ptr is optional, it is constructed if not supplied.\n-pub fn decr_refcnt_maybe_free(bcx: @mut Block, box_ptr: ValueRef,\n+pub fn decr_refcnt_maybe_free(bcx: @Block, box_ptr: ValueRef,\n                               box_ptr_ptr: Option<ValueRef>,\n                               t: ty::t)\n-                           -> @mut Block {\n+                           -> @Block {\n     let _icx = push_ctxt(\"decr_refcnt_maybe_free\");\n     let ccx = bcx.ccx();\n \n@@ -534,7 +536,7 @@ pub fn decr_refcnt_maybe_free(bcx: @mut Block, box_ptr: ValueRef,\n }\n \n \n-pub fn make_take_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n+pub fn make_take_glue(bcx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     let _icx = push_ctxt(\"make_take_glue\");\n     // NB: v is a *pointer* to type t here, not a direct value.\n     match ty::get(t).sty {\n@@ -575,7 +577,7 @@ pub fn make_take_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     }\n }\n \n-pub fn incr_refcnt_of_boxed(cx: @mut Block, box_ptr: ValueRef) {\n+pub fn incr_refcnt_of_boxed(cx: @Block, box_ptr: ValueRef) {\n     let _icx = push_ctxt(\"incr_refcnt_of_boxed\");\n     let ccx = cx.ccx();\n     let rc_ptr = GEPi(cx, box_ptr, [0u, abi::box_field_refcnt]);\n@@ -586,10 +588,10 @@ pub fn incr_refcnt_of_boxed(cx: @mut Block, box_ptr: ValueRef) {\n \n \n // Generates the declaration for (but doesn't emit) a type descriptor.\n-pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n+pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n     // If emit_tydescs already ran, then we shouldn't be creating any new\n     // tydescs.\n-    assert!(!ccx.finished_tydescs);\n+    assert!(!ccx.finished_tydescs.get());\n \n     let llty = type_of(ccx, t);\n \n@@ -623,26 +625,26 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n \n     let ty_name = C_estr_slice(ccx, ppaux::ty_to_str(ccx.tcx, t).to_managed());\n \n-    let inf = @mut tydesc_info {\n+    let inf = @tydesc_info {\n         ty: t,\n         tydesc: gvar,\n         size: llsize,\n         align: llalign,\n         borrow_offset: borrow_offset,\n         name: ty_name,\n-        take_glue: None,\n-        drop_glue: None,\n-        free_glue: None,\n-        visit_glue: None\n+        take_glue: Cell::new(None),\n+        drop_glue: Cell::new(None),\n+        free_glue: Cell::new(None),\n+        visit_glue: Cell::new(None),\n     };\n     debug!(\"--- declare_tydesc {}\", ppaux::ty_to_str(ccx.tcx, t));\n     return inf;\n }\n \n-pub type glue_helper<'a> = 'a |@mut Block, ValueRef, ty::t|\n-                                     -> @mut Block;\n+pub type glue_helper<'a> = 'a |@Block, ValueRef, ty::t|\n+                                     -> @Block;\n \n-pub fn declare_generic_glue(ccx: &mut CrateContext, t: ty::t, llfnty: Type,\n+pub fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n                             name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"declare_generic_glue\");\n     let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, (~\"glue_\" + name)).to_managed();\n@@ -652,15 +654,15 @@ pub fn declare_generic_glue(ccx: &mut CrateContext, t: ty::t, llfnty: Type,\n     return llfn;\n }\n \n-pub fn make_generic_glue_inner(ccx: @mut CrateContext,\n+pub fn make_generic_glue_inner(ccx: @CrateContext,\n                                t: ty::t,\n                                llfn: ValueRef,\n                                helper: glue_helper)\n                             -> ValueRef {\n     let _icx = push_ctxt(\"make_generic_glue_inner\");\n     let fcx = new_fn_ctxt(ccx, ~[], llfn, ty::mk_nil(), None);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n-    ccx.stats.n_glues_created += 1u;\n+    ccx.stats.n_glues_created.set(ccx.stats.n_glues_created.get() + 1u);\n     // All glue functions take values passed *by alias*; this is a\n     // requirement since in many contexts glue is invoked indirectly and\n     // the caller has no idea if it's dealing with something that can be\n@@ -669,7 +671,7 @@ pub fn make_generic_glue_inner(ccx: @mut CrateContext,\n     // llfn is expected be declared to take a parameter of the appropriate\n     // type, so we don't need to explicitly cast the function parameter.\n \n-    let bcx = fcx.entry_bcx.unwrap();\n+    let bcx = fcx.entry_bcx.get().unwrap();\n     let rawptr0_arg = fcx.arg_pos(0u);\n     let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, rawptr0_arg as c_uint) };\n     let bcx = helper(bcx, llrawptr0, t);\n@@ -679,7 +681,7 @@ pub fn make_generic_glue_inner(ccx: @mut CrateContext,\n     return llfn;\n }\n \n-pub fn make_generic_glue(ccx: @mut CrateContext,\n+pub fn make_generic_glue(ccx: @CrateContext,\n                          t: ty::t,\n                          llfn: ValueRef,\n                          helper: glue_helper,\n@@ -691,55 +693,75 @@ pub fn make_generic_glue(ccx: @mut CrateContext,\n     make_generic_glue_inner(ccx, t, llfn, helper)\n }\n \n-pub fn emit_tydescs(ccx: &mut CrateContext) {\n+pub fn emit_tydescs(ccx: &CrateContext) {\n     let _icx = push_ctxt(\"emit_tydescs\");\n     // As of this point, allow no more tydescs to be created.\n-    ccx.finished_tydescs = true;\n+    ccx.finished_tydescs.set(true);\n     let glue_fn_ty = Type::generic_glue_fn(ccx).ptr_to();\n-    let tyds = &mut ccx.tydescs;\n-    for (_, &val) in tyds.iter() {\n+    let mut tyds = ccx.tydescs.borrow_mut();\n+    for (_, &val) in tyds.get().iter() {\n         let ti = val;\n \n         // Each of the glue functions needs to be cast to a generic type\n         // before being put into the tydesc because we only have a singleton\n         // tydesc type. Then we'll recast each function to its real type when\n         // calling it.\n         let take_glue =\n-            match ti.take_glue {\n-              None => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n+            match ti.take_glue.get() {\n+              None => {\n+                  ccx.stats.n_null_glues.set(ccx.stats.n_null_glues.get() +\n+                                             1);\n+                  C_null(glue_fn_ty)\n+              }\n               Some(v) => {\n                 unsafe {\n-                    ccx.stats.n_real_glues += 1u;\n+                    ccx.stats.n_real_glues.set(ccx.stats.n_real_glues.get() +\n+                                               1);\n                     llvm::LLVMConstPointerCast(v, glue_fn_ty.to_ref())\n                 }\n               }\n             };\n         let drop_glue =\n-            match ti.drop_glue {\n-              None => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n+            match ti.drop_glue.get() {\n+              None => {\n+                  ccx.stats.n_null_glues.set(ccx.stats.n_null_glues.get() +\n+                                             1u);\n+                  C_null(glue_fn_ty)\n+              }\n               Some(v) => {\n                 unsafe {\n-                    ccx.stats.n_real_glues += 1u;\n+                    ccx.stats.n_real_glues.set(ccx.stats.n_real_glues.get() +\n+                                               1);\n                     llvm::LLVMConstPointerCast(v, glue_fn_ty.to_ref())\n                 }\n               }\n             };\n         let free_glue =\n-            match ti.free_glue {\n-              None => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n+            match ti.free_glue.get() {\n+              None => {\n+                  ccx.stats.n_null_glues.set(ccx.stats.n_null_glues.get() +\n+                                             1u);\n+                  C_null(glue_fn_ty)\n+              }\n               Some(v) => {\n                 unsafe {\n-                    ccx.stats.n_real_glues += 1u;\n+                    ccx.stats.n_real_glues.set(ccx.stats.n_real_glues.get() +\n+                                               1);\n                     llvm::LLVMConstPointerCast(v, glue_fn_ty.to_ref())\n                 }\n               }\n             };\n         let visit_glue =\n-            match ti.visit_glue {\n-              None => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n+            match ti.visit_glue.get() {\n+              None => {\n+                  ccx.stats.n_null_glues.set(ccx.stats.n_null_glues.get() +\n+                                             1u);\n+                  C_null(glue_fn_ty)\n+              }\n               Some(v) => {\n                 unsafe {\n-                    ccx.stats.n_real_glues += 1u;\n+                    ccx.stats.n_real_glues.set(ccx.stats.n_real_glues.get() +\n+                                               1);\n                     llvm::LLVMConstPointerCast(v, glue_fn_ty.to_ref())\n                 }\n               }"}, {"sha": "bea58929323aaae762399bb4fbf4fd7e2442e54b", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 53, "deletions": 27, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -23,21 +23,24 @@ use syntax::ast_map::path_name;\n use syntax::ast_util::local_def;\n use syntax::attr;\n \n-pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::DefId)\n+pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n     -> ast::DefId {\n     let _icx = push_ctxt(\"maybe_instantiate_inline\");\n-    match ccx.external.find(&fn_id) {\n-        Some(&Some(node_id)) => {\n-            // Already inline\n-            debug!(\"maybe_instantiate_inline({}): already inline as node id {}\",\n-                   ty::item_path_str(ccx.tcx, fn_id), node_id);\n-            return local_def(node_id);\n-        }\n-        Some(&None) => {\n-            return fn_id; // Not inlinable\n-        }\n-        None => {\n-            // Not seen yet\n+    {\n+        let external = ccx.external.borrow();\n+        match external.get().find(&fn_id) {\n+            Some(&Some(node_id)) => {\n+                // Already inline\n+                debug!(\"maybe_instantiate_inline({}): already inline as node id {}\",\n+                       ty::item_path_str(ccx.tcx, fn_id), node_id);\n+                return local_def(node_id);\n+            }\n+            Some(&None) => {\n+                return fn_id; // Not inlinable\n+            }\n+            None => {\n+                // Not seen yet\n+            }\n         }\n     }\n \n@@ -49,13 +52,19 @@ pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::DefId)\n             });\n     return match csearch_result {\n         csearch::not_found => {\n-            ccx.external.insert(fn_id, None);\n+            let mut external = ccx.external.borrow_mut();\n+            external.get().insert(fn_id, None);\n             fn_id\n         }\n         csearch::found(ast::ii_item(item)) => {\n-            ccx.external.insert(fn_id, Some(item.id));\n-            ccx.external_srcs.insert(item.id, fn_id);\n-            ccx.stats.n_inlines += 1;\n+            {\n+                let mut external = ccx.external.borrow_mut();\n+                let mut external_srcs = ccx.external_srcs.borrow_mut();\n+                external.get().insert(fn_id, Some(item.id));\n+                external_srcs.get().insert(item.id, fn_id);\n+            }\n+\n+            ccx.stats.n_inlines.set(ccx.stats.n_inlines.get() + 1);\n             trans_item(ccx, item);\n \n             // We're bringing an external global into this crate, but we don't\n@@ -82,28 +91,39 @@ pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::DefId)\n             local_def(item.id)\n         }\n         csearch::found(ast::ii_foreign(item)) => {\n-          ccx.external.insert(fn_id, Some(item.id));\n-          ccx.external_srcs.insert(item.id, fn_id);\n-          local_def(item.id)\n+            {\n+                let mut external = ccx.external.borrow_mut();\n+                let mut external_srcs = ccx.external_srcs.borrow_mut();\n+                external.get().insert(fn_id, Some(item.id));\n+                external_srcs.get().insert(item.id, fn_id);\n+            }\n+            local_def(item.id)\n         }\n         csearch::found_parent(parent_id, ast::ii_item(item)) => {\n-          ccx.external.insert(parent_id, Some(item.id));\n-          ccx.external_srcs.insert(item.id, parent_id);\n+            {\n+                let mut external = ccx.external.borrow_mut();\n+                let mut external_srcs = ccx.external_srcs.borrow_mut();\n+                external.get().insert(parent_id, Some(item.id));\n+                external_srcs.get().insert(item.id, parent_id);\n+            }\n+\n           let mut my_id = 0;\n           match item.node {\n             ast::item_enum(_, _) => {\n               let vs_here = ty::enum_variants(ccx.tcx, local_def(item.id));\n               let vs_there = ty::enum_variants(ccx.tcx, parent_id);\n               for (here, there) in vs_here.iter().zip(vs_there.iter()) {\n                   if there.id == fn_id { my_id = here.id.node; }\n-                  ccx.external.insert(there.id, Some(here.id.node));\n+                  let mut external = ccx.external.borrow_mut();\n+                  external.get().insert(there.id, Some(here.id.node));\n               }\n             }\n             ast::item_struct(ref struct_def, _) => {\n               match struct_def.ctor_id {\n                 None => {}\n                 Some(ctor_id) => {\n-                    let _ = ccx.external.insert(fn_id, Some(ctor_id));\n+                    let mut external = ccx.external.borrow_mut();\n+                    let _ = external.get().insert(fn_id, Some(ctor_id));\n                     my_id = ctor_id;\n                 }\n               }\n@@ -119,9 +139,15 @@ pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::DefId)\n              with a non-item parent\");\n         }\n         csearch::found(ast::ii_method(impl_did, is_provided, mth)) => {\n-          ccx.stats.n_inlines += 1;\n-          ccx.external.insert(fn_id, Some(mth.id));\n-          ccx.external_srcs.insert(mth.id, fn_id);\n+            {\n+                let mut external = ccx.external.borrow_mut();\n+                let mut external_srcs = ccx.external_srcs.borrow_mut();\n+                external.get().insert(fn_id, Some(mth.id));\n+                external_srcs.get().insert(mth.id, fn_id);\n+            }\n+\n+          ccx.stats.n_inlines.set(ccx.stats.n_inlines.get() + 1);\n+\n           // If this is a default method, we can't look up the\n           // impl type. But we aren't going to translate anyways, so don't.\n           if is_provided { return local_def(mth.id); }"}, {"sha": "02df3ff9c2046f380a6dbfbc8106d4957211bf63", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -29,7 +29,7 @@ use util::ppaux::ty_to_str;\n use middle::trans::machine::llsize_of;\n use middle::trans::type_::Type;\n \n-pub fn trans_intrinsic(ccx: @mut CrateContext,\n+pub fn trans_intrinsic(ccx: @CrateContext,\n                        decl: ValueRef,\n                        item: &ast::foreign_item,\n                        path: ast_map::path,\n@@ -38,7 +38,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                        ref_id: Option<ast::NodeId>) {\n     debug!(\"trans_intrinsic(item.ident={})\", ccx.sess.str_of(item.ident));\n \n-    fn simple_llvm_intrinsic(bcx: @mut Block, name: &'static str, num_args: uint) {\n+    fn simple_llvm_intrinsic(bcx: @Block, name: &'static str, num_args: uint) {\n         assert!(num_args <= 4);\n         let mut args = [0 as ValueRef, ..4];\n         let first_real_arg = bcx.fcx.arg_pos(0u);\n@@ -50,7 +50,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         Ret(bcx, llcall);\n     }\n \n-    fn with_overflow_instrinsic(bcx: @mut Block, name: &'static str, t: ty::t) {\n+    fn with_overflow_instrinsic(bcx: @Block, name: &'static str, t: ty::t) {\n         let first_real_arg = bcx.fcx.arg_pos(0u);\n         let a = get_param(bcx.fcx.llfn, first_real_arg);\n         let b = get_param(bcx.fcx.llfn, first_real_arg + 1);\n@@ -73,7 +73,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         }\n     }\n \n-    fn copy_intrinsic(bcx: @mut Block, allow_overlap: bool, tp_ty: ty::t) {\n+    fn copy_intrinsic(bcx: @Block, allow_overlap: bool, tp_ty: ty::t) {\n         let ccx = bcx.ccx();\n         let lltp_ty = type_of::type_of(ccx, tp_ty);\n         let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n@@ -104,7 +104,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         RetVoid(bcx);\n     }\n \n-    fn memset_intrinsic(bcx: @mut Block, tp_ty: ty::t) {\n+    fn memset_intrinsic(bcx: @Block, tp_ty: ty::t) {\n         let ccx = bcx.ccx();\n         let lltp_ty = type_of::type_of(ccx, tp_ty);\n         let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n@@ -126,7 +126,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         RetVoid(bcx);\n     }\n \n-    fn count_zeros_intrinsic(bcx: @mut Block, name: &'static str) {\n+    fn count_zeros_intrinsic(bcx: @Block, name: &'static str) {\n         let x = get_param(bcx.fcx.llfn, bcx.fcx.arg_pos(0u));\n         let y = C_i1(false);\n         let llfn = bcx.ccx().intrinsics.get_copy(&name);\n@@ -148,7 +148,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n \n     set_always_inline(fcx.llfn);\n \n-    let mut bcx = fcx.entry_bcx.unwrap();\n+    let mut bcx = fcx.entry_bcx.get().unwrap();\n     let first_real_arg = fcx.arg_pos(0u);\n \n     let nm = ccx.sess.str_of(item.ident);\n@@ -290,7 +290,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             // NB: This needs to be kept in lockstep with the TypeId struct in\n             //     libstd/unstable/intrinsics.rs\n             let val = C_named_struct(type_of::type_of(ccx, output_type), [C_u64(hash)]);\n-            match bcx.fcx.llretptr {\n+            match bcx.fcx.llretptr.get() {\n                 Some(ptr) => {\n                     Store(bcx, val, ptr);\n                     RetVoid(bcx);\n@@ -301,7 +301,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         \"init\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            match bcx.fcx.llretptr {\n+            match bcx.fcx.llretptr.get() {\n                 Some(ptr) => { Store(bcx, C_null(lltp_ty), ptr); RetVoid(bcx); }\n                 None if ty::type_is_nil(tp_ty) => RetVoid(bcx),\n                 None => Ret(bcx, C_null(lltp_ty)),\n@@ -349,7 +349,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             if !ty::type_is_voidish(ccx.tcx, out_type) {\n                 let llsrcval = get_param(decl, first_real_arg);\n                 if type_is_immediate(ccx, in_type) {\n-                    match fcx.llretptr {\n+                    match fcx.llretptr.get() {\n                         Some(llretptr) => {\n                             Store(bcx, llsrcval, PointerCast(bcx, llretptr, llintype.ptr_to()));\n                             RetVoid(bcx);\n@@ -379,7 +379,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                     // NB: Do not use a Load and Store here. This causes massive\n                     // code bloat when `transmute` is used on large structural\n                     // types.\n-                    let lldestptr = fcx.llretptr.unwrap();\n+                    let lldestptr = fcx.llretptr.get().unwrap();\n                     let lldestptr = PointerCast(bcx, lldestptr, Type::i8p());\n                     let llsrcptr = PointerCast(bcx, llsrcval, Type::i8p());\n "}, {"sha": "f4df98870bbdfa8133e96e1d8ad9b05f8fcbfa60", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 46, "deletions": 30, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -46,7 +46,7 @@ for non-monomorphized methods only.  Other methods will\n be generated once they are invoked with specific type parameters,\n see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n */\n-pub fn trans_impl(ccx: @mut CrateContext,\n+pub fn trans_impl(ccx: @CrateContext,\n                   path: path,\n                   name: ast::Ident,\n                   methods: &[@ast::method],\n@@ -97,7 +97,7 @@ pub fn trans_impl(ccx: @mut CrateContext,\n /// * `impl_id`: the node ID of the impl this method is inside\n ///\n /// XXX(pcwalton) Can we take `path` by reference?\n-pub fn trans_method(ccx: @mut CrateContext,\n+pub fn trans_method(ccx: @CrateContext,\n                     path: path,\n                     method: &ast::method,\n                     param_substs: Option<@param_substs>,\n@@ -138,7 +138,7 @@ pub fn trans_method(ccx: @mut CrateContext,\n              []);\n }\n \n-pub fn trans_self_arg(bcx: @mut Block,\n+pub fn trans_self_arg(bcx: @Block,\n                       base: &ast::Expr,\n                       temp_cleanups: &mut ~[ValueRef],\n                       mentry: typeck::method_map_entry) -> Result {\n@@ -154,7 +154,7 @@ pub fn trans_self_arg(bcx: @mut Block,\n                    DontAutorefArg)\n }\n \n-pub fn trans_method_callee(bcx: @mut Block,\n+pub fn trans_method_callee(bcx: @Block,\n                            callee_id: ast::NodeId,\n                            this: &ast::Expr,\n                            mentry: typeck::method_map_entry)\n@@ -212,7 +212,7 @@ pub fn trans_method_callee(bcx: @mut Block,\n     }\n }\n \n-pub fn trans_static_method_callee(bcx: @mut Block,\n+pub fn trans_static_method_callee(bcx: @Block,\n                                   method_id: ast::DefId,\n                                   trait_id: ast::DefId,\n                                   callee_id: ast::NodeId)\n@@ -262,8 +262,11 @@ pub fn trans_static_method_callee(bcx: @mut Block,\n     debug!(\"trans_static_method_callee: method_id={:?}, callee_id={:?}, \\\n             name={}\", method_id, callee_id, ccx.sess.str_of(mname));\n \n-    let vtbls = resolve_vtables_in_fn_ctxt(\n-        bcx.fcx, ccx.maps.vtable_map.get_copy(&callee_id));\n+    let vtbls = {\n+        let vtable_map = ccx.maps.vtable_map.borrow();\n+        vtable_map.get().get_copy(&callee_id)\n+    };\n+    let vtbls = resolve_vtables_in_fn_ctxt(bcx.fcx, vtbls);\n \n     match vtbls[bound_index][0] {\n         typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n@@ -293,25 +296,30 @@ pub fn trans_static_method_callee(bcx: @mut Block,\n     }\n }\n \n-pub fn method_with_name(ccx: &mut CrateContext,\n+pub fn method_with_name(ccx: &CrateContext,\n                         impl_id: ast::DefId,\n                         name: ast::Name) -> ast::DefId {\n-    let meth_id_opt = ccx.impl_method_cache.find_copy(&(impl_id, name));\n-    match meth_id_opt {\n-        Some(m) => return m,\n-        None => {}\n+    {\n+        let impl_method_cache = ccx.impl_method_cache.borrow();\n+        let meth_id_opt = impl_method_cache.get().find_copy(&(impl_id, name));\n+        match meth_id_opt {\n+            Some(m) => return m,\n+            None => {}\n+        }\n     }\n \n-    let imp = ccx.tcx.impls.find(&impl_id)\n+    let impls = ccx.tcx.impls.borrow();\n+    let imp = impls.get().find(&impl_id)\n         .expect(\"could not find impl while translating\");\n     let meth = imp.methods.iter().find(|m| m.ident.name == name)\n         .expect(\"could not find method while translating\");\n \n-    ccx.impl_method_cache.insert((impl_id, name), meth.def_id);\n+    let mut impl_method_cache = ccx.impl_method_cache.borrow_mut();\n+    impl_method_cache.get().insert((impl_id, name), meth.def_id);\n     meth.def_id\n }\n \n-pub fn trans_monomorphized_callee(bcx: @mut Block,\n+pub fn trans_monomorphized_callee(bcx: @Block,\n                                   callee_id: ast::NodeId,\n                                   base: &ast::Expr,\n                                   mentry: typeck::method_map_entry,\n@@ -368,7 +376,7 @@ pub fn trans_monomorphized_callee(bcx: @mut Block,\n \n }\n \n-pub fn combine_impl_and_methods_tps(bcx: @mut Block,\n+pub fn combine_impl_and_methods_tps(bcx: @Block,\n                                     mth_did: ast::DefId,\n                                     callee_id: ast::NodeId,\n                                     rcvr_substs: &[ty::t],\n@@ -417,7 +425,7 @@ pub fn combine_impl_and_methods_tps(bcx: @mut Block,\n     return (ty_substs, vtables);\n }\n \n-pub fn trans_trait_callee(bcx: @mut Block,\n+pub fn trans_trait_callee(bcx: @Block,\n                           callee_id: ast::NodeId,\n                           n_method: uint,\n                           self_expr: &ast::Expr)\n@@ -459,7 +467,7 @@ pub fn trans_trait_callee(bcx: @mut Block,\n                                   Some(self_scratch.val))\n }\n \n-pub fn trans_trait_callee_from_llval(bcx: @mut Block,\n+pub fn trans_trait_callee_from_llval(bcx: @Block,\n                                      callee_ty: ty::t,\n                                      n_method: uint,\n                                      llpair: ValueRef,\n@@ -505,7 +513,7 @@ pub fn trans_trait_callee_from_llval(bcx: @mut Block,\n     };\n }\n \n-pub fn vtable_id(ccx: @mut CrateContext,\n+pub fn vtable_id(ccx: @CrateContext,\n                  origin: &typeck::vtable_origin)\n               -> mono_id {\n     match origin {\n@@ -530,7 +538,7 @@ pub fn vtable_id(ccx: @mut CrateContext,\n \n /// Creates a returns a dynamic vtable for the given type and vtable origin.\n /// This is used only for objects.\n-pub fn get_vtable(bcx: @mut Block,\n+pub fn get_vtable(bcx: @Block,\n                   self_ty: ty::t,\n                   origins: typeck::vtable_param_res)\n                   -> ValueRef {\n@@ -539,9 +547,12 @@ pub fn get_vtable(bcx: @mut Block,\n \n     // Check the cache.\n     let hash_id = (self_ty, vtable_id(ccx, &origins[0]));\n-    match ccx.vtables.find(&hash_id) {\n-        Some(&val) => { return val }\n-        None => { }\n+    {\n+        let vtables = ccx.vtables.borrow();\n+        match vtables.get().find(&hash_id) {\n+            Some(&val) => { return val }\n+            None => { }\n+        }\n     }\n \n     // Not in the cache. Actually build it.\n@@ -559,12 +570,14 @@ pub fn get_vtable(bcx: @mut Block,\n     glue::lazily_emit_all_tydesc_glue(ccx, tydesc);\n \n     let vtable = make_vtable(ccx, tydesc, methods);\n-    ccx.vtables.insert(hash_id, vtable);\n+\n+    let mut vtables = ccx.vtables.borrow_mut();\n+    vtables.get().insert(hash_id, vtable);\n     return vtable;\n }\n \n /// Helper function to declare and initialize the vtable.\n-pub fn make_vtable(ccx: &mut CrateContext,\n+pub fn make_vtable(ccx: &CrateContext,\n                    tydesc: &tydesc_info,\n                    ptrs: &[ValueRef])\n                    -> ValueRef {\n@@ -588,7 +601,7 @@ pub fn make_vtable(ccx: &mut CrateContext,\n     }\n }\n \n-fn emit_vtable_methods(bcx: @mut Block,\n+fn emit_vtable_methods(bcx: @Block,\n                        impl_id: ast::DefId,\n                        substs: &[ty::t],\n                        vtables: typeck::vtable_res)\n@@ -629,12 +642,12 @@ fn emit_vtable_methods(bcx: @mut Block,\n     })\n }\n \n-pub fn trans_trait_cast(bcx: @mut Block,\n+pub fn trans_trait_cast(bcx: @Block,\n                         val: &ast::Expr,\n                         id: ast::NodeId,\n                         dest: expr::Dest,\n                         _store: ty::TraitStore)\n-                     -> @mut Block {\n+                     -> @Block {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"impl::trans_cast\");\n \n@@ -660,8 +673,11 @@ pub fn trans_trait_cast(bcx: @mut Block,\n     // Store the vtable into the pair or triple.\n     // This is structured a bit funny because of dynamic borrow failures.\n     let origins = {\n-        let res = ccx.maps.vtable_map.get(&id);\n-        let res = resolve_vtables_in_fn_ctxt(bcx.fcx, *res);\n+        let res = {\n+            let vtable_map = ccx.maps.vtable_map.borrow();\n+            *vtable_map.get().get(&id)\n+        };\n+        let res = resolve_vtables_in_fn_ctxt(bcx.fcx, res);\n         res[0]\n     };\n     let vtable = get_vtable(bcx, v_ty, origins);"}, {"sha": "cf6bebbb1a2a788ecfce17c80dafc856509b895a", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -28,7 +28,7 @@ use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::local_def;\n \n-pub fn monomorphic_fn(ccx: @mut CrateContext,\n+pub fn monomorphic_fn(ccx: @CrateContext,\n                       fn_id: ast::DefId,\n                       real_substs: &ty::substs,\n                       vtables: Option<typeck::vtable_res>,\n@@ -76,13 +76,16 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n            psubsts.repr(ccx.tcx),\n            hash_id);\n \n-    match ccx.monomorphized.find(&hash_id) {\n-      Some(&val) => {\n-        debug!(\"leaving monomorphic fn {}\",\n-               ty::item_path_str(ccx.tcx, fn_id));\n-        return (val, must_cast);\n-      }\n-      None => ()\n+    {\n+        let monomorphized = ccx.monomorphized.borrow();\n+        match monomorphized.get().find(&hash_id) {\n+          Some(&val) => {\n+            debug!(\"leaving monomorphic fn {}\",\n+                   ty::item_path_str(ccx.tcx, fn_id));\n+            return (val, must_cast);\n+          }\n+          None => ()\n+        }\n     }\n \n     let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n@@ -179,19 +182,24 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n         _ => fail!(\"expected bare rust fn or an intrinsic\")\n     };\n \n-    ccx.stats.n_monos += 1;\n+    ccx.stats.n_monos.set(ccx.stats.n_monos.get() + 1);\n \n-    let depth = match ccx.monomorphizing.find(&fn_id) {\n-        Some(&d) => d, None => 0\n-    };\n-    // Random cut-off -- code that needs to instantiate the same function\n-    // recursively more than thirty times can probably safely be assumed to be\n-    // causing an infinite expansion.\n-    if depth > 30 {\n-        ccx.sess.span_fatal(\n-            span, \"overly deep expansion of inlined function\");\n+    let depth;\n+    {\n+        let mut monomorphizing = ccx.monomorphizing.borrow_mut();\n+        depth = match monomorphizing.get().find(&fn_id) {\n+            Some(&d) => d, None => 0\n+        };\n+\n+        // Random cut-off -- code that needs to instantiate the same function\n+        // recursively more than thirty times can probably safely be assumed\n+        // to be causing an infinite expansion.\n+        if depth > 30 {\n+            ccx.sess.span_fatal(\n+                span, \"overly deep expansion of inlined function\");\n+        }\n+        monomorphizing.get().insert(fn_id, depth + 1);\n     }\n-    ccx.monomorphizing.insert(fn_id, depth + 1);\n \n     let (_, elt) = gensym_name(ccx.sess.str_of(name));\n     let mut pt = (*pt).clone();\n@@ -201,7 +209,8 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n \n     let mk_lldecl = || {\n         let lldecl = decl_internal_rust_fn(ccx, f.sig.inputs, f.sig.output, s);\n-        ccx.monomorphized.insert(hash_id, lldecl);\n+        let mut monomorphized = ccx.monomorphized.borrow_mut();\n+        monomorphized.get().insert(hash_id, lldecl);\n         lldecl\n     };\n \n@@ -288,13 +297,17 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n         ccx.tcx.sess.bug(format!(\"Can't monomorphize a {:?}\", map_node))\n       }\n     };\n-    ccx.monomorphizing.insert(fn_id, depth);\n+\n+    {\n+        let mut monomorphizing = ccx.monomorphizing.borrow_mut();\n+        monomorphizing.get().insert(fn_id, depth);\n+    }\n \n     debug!(\"leaving monomorphic fn {}\", ty::item_path_str(ccx.tcx, fn_id));\n     (lldecl, must_cast)\n }\n \n-pub fn make_mono_id(ccx: @mut CrateContext,\n+pub fn make_mono_id(ccx: @CrateContext,\n                     item: ast::DefId,\n                     substs: &param_substs) -> mono_id {\n     // FIXME (possibly #5801): Need a lot of type hints to get"}, {"sha": "c30f421c9e54f2edf5a3f485a1b8640c0b95c6a1", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -37,9 +37,9 @@ use middle::trans::type_::Type;\n pub struct Reflector {\n     visitor_val: ValueRef,\n     visitor_methods: @~[@ty::Method],\n-    final_bcx: @mut Block,\n+    final_bcx: @Block,\n     tydesc_ty: Type,\n-    bcx: @mut Block\n+    bcx: @Block\n }\n \n impl Reflector {\n@@ -306,11 +306,11 @@ impl Reflector {\n                     //\n                     llvm::LLVMGetParam(llfdecl, fcx.arg_pos(0u) as c_uint)\n                 };\n-                let mut bcx = fcx.entry_bcx.unwrap();\n+                let mut bcx = fcx.entry_bcx.get().unwrap();\n                 let arg = BitCast(bcx, arg, llptrty);\n                 let ret = adt::trans_get_discr(bcx, repr, arg, Some(Type::i64()));\n-                Store(bcx, ret, fcx.llretptr.unwrap());\n-                match fcx.llreturn {\n+                Store(bcx, ret, fcx.llretptr.get().unwrap());\n+                match fcx.llreturn.get() {\n                     Some(llreturn) => cleanup_and_Br(bcx, bcx, llreturn),\n                     None => bcx = cleanup_block(bcx, Some(bcx.llbb))\n                 };\n@@ -382,11 +382,11 @@ impl Reflector {\n }\n \n // Emit a sequence of calls to visit_ty::visit_foo\n-pub fn emit_calls_to_trait_visit_ty(bcx: @mut Block,\n+pub fn emit_calls_to_trait_visit_ty(bcx: @Block,\n                                     t: ty::t,\n                                     visitor_val: ValueRef,\n                                     visitor_trait_id: DefId)\n-                                 -> @mut Block {\n+                                 -> @Block {\n     let final = sub_block(bcx, \"final\");\n     let tydesc_ty = ty::get_tydesc_ty(bcx.ccx().tcx).unwrap();\n     let tydesc_ty = type_of(bcx.ccx(), tydesc_ty);"}, {"sha": "17423c1dd020297b06c33254ee2d1e735fd55d86", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -53,38 +53,38 @@ pub fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     }\n }\n \n-pub fn get_fill(bcx: @mut Block, vptr: ValueRef) -> ValueRef {\n+pub fn get_fill(bcx: @Block, vptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::get_fill\");\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]))\n }\n-pub fn set_fill(bcx: @mut Block, vptr: ValueRef, fill: ValueRef) {\n+pub fn set_fill(bcx: @Block, vptr: ValueRef, fill: ValueRef) {\n     Store(bcx, fill, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]));\n }\n-pub fn get_alloc(bcx: @mut Block, vptr: ValueRef) -> ValueRef {\n+pub fn get_alloc(bcx: @Block, vptr: ValueRef) -> ValueRef {\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_alloc]))\n }\n \n-pub fn get_bodyptr(bcx: @mut Block, vptr: ValueRef, t: ty::t) -> ValueRef {\n+pub fn get_bodyptr(bcx: @Block, vptr: ValueRef, t: ty::t) -> ValueRef {\n     if ty::type_contents(bcx.tcx(), t).owns_managed() {\n         GEPi(bcx, vptr, [0u, abi::box_field_body])\n     } else {\n         vptr\n     }\n }\n \n-pub fn get_dataptr(bcx: @mut Block, vptr: ValueRef) -> ValueRef {\n+pub fn get_dataptr(bcx: @Block, vptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::get_dataptr\");\n     GEPi(bcx, vptr, [0u, abi::vec_elt_elems, 0u])\n }\n \n-pub fn pointer_add_byte(bcx: @mut Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n+pub fn pointer_add_byte(bcx: @Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::pointer_add_byte\");\n     let old_ty = val_ty(ptr);\n     let bptr = PointerCast(bcx, ptr, Type::i8p());\n     return PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n-pub fn alloc_raw(bcx: @mut Block, unit_ty: ty::t,\n+pub fn alloc_raw(bcx: @Block, unit_ty: ty::t,\n                  fill: ValueRef, alloc: ValueRef, heap: heap) -> Result {\n     let _icx = push_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n@@ -107,12 +107,12 @@ pub fn alloc_raw(bcx: @mut Block, unit_ty: ty::t,\n     }\n }\n \n-pub fn alloc_uniq_raw(bcx: @mut Block, unit_ty: ty::t,\n+pub fn alloc_uniq_raw(bcx: @Block, unit_ty: ty::t,\n                       fill: ValueRef, alloc: ValueRef) -> Result {\n     alloc_raw(bcx, unit_ty, fill, alloc, base::heap_for_unique(bcx, unit_ty))\n }\n \n-pub fn alloc_vec(bcx: @mut Block,\n+pub fn alloc_vec(bcx: @Block,\n                  unit_ty: ty::t,\n                  elts: uint,\n                  heap: heap)\n@@ -130,8 +130,8 @@ pub fn alloc_vec(bcx: @mut Block,\n     return rslt(bcx, vptr);\n }\n \n-pub fn make_drop_glue_unboxed(bcx: @mut Block, vptr: ValueRef, vec_ty: ty::t) ->\n-   @mut Block {\n+pub fn make_drop_glue_unboxed(bcx: @Block, vptr: ValueRef, vec_ty: ty::t) ->\n+   @Block {\n     let _icx = push_ctxt(\"tvec::make_drop_glue_unboxed\");\n     let tcx = bcx.tcx();\n     let unit_ty = ty::sequence_element_type(tcx, vec_ty);\n@@ -160,11 +160,11 @@ impl VecTypes {\n     }\n }\n \n-pub fn trans_fixed_vstore(bcx: @mut Block,\n+pub fn trans_fixed_vstore(bcx: @Block,\n                           vstore_expr: &ast::Expr,\n                           content_expr: &ast::Expr,\n                           dest: expr::Dest)\n-                       -> @mut Block {\n+                       -> @Block {\n     //!\n     //\n     // [...] allocates a fixed-size array and moves it around \"by value\".\n@@ -189,11 +189,11 @@ pub fn trans_fixed_vstore(bcx: @mut Block,\n     };\n }\n \n-pub fn trans_slice_vstore(bcx: @mut Block,\n+pub fn trans_slice_vstore(bcx: @Block,\n                           vstore_expr: &ast::Expr,\n                           content_expr: &ast::Expr,\n                           dest: expr::Dest)\n-                       -> @mut Block {\n+                       -> @Block {\n     //!\n     //\n     // &[...] allocates memory on the stack and writes the values into it,\n@@ -247,11 +247,11 @@ pub fn trans_slice_vstore(bcx: @mut Block,\n     return bcx;\n }\n \n-pub fn trans_lit_str(bcx: @mut Block,\n+pub fn trans_lit_str(bcx: @Block,\n                      lit_expr: &ast::Expr,\n                      str_lit: @str,\n                      dest: Dest)\n-                  -> @mut Block {\n+                  -> @Block {\n     //!\n     //\n     // Literal strings translate to slices into static memory.  This is\n@@ -282,7 +282,7 @@ pub fn trans_lit_str(bcx: @mut Block,\n }\n \n \n-pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: &ast::Expr,\n+pub fn trans_uniq_or_managed_vstore(bcx: @Block, heap: heap, vstore_expr: &ast::Expr,\n                                     content_expr: &ast::Expr) -> DatumBlock {\n     //!\n     //\n@@ -343,12 +343,12 @@ pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: &a\n     return immediate_rvalue_bcx(bcx, val, vt.vec_ty);\n }\n \n-pub fn write_content(bcx: @mut Block,\n+pub fn write_content(bcx: @Block,\n                      vt: &VecTypes,\n                      vstore_expr: &ast::Expr,\n                      content_expr: &ast::Expr,\n                      dest: Dest)\n-                  -> @mut Block {\n+                  -> @Block {\n     let _icx = push_ctxt(\"tvec::write_content\");\n     let mut bcx = bcx;\n \n@@ -433,12 +433,12 @@ pub fn write_content(bcx: @mut Block,\n     }\n }\n \n-pub fn vec_types_from_expr(bcx: @mut Block, vec_expr: &ast::Expr) -> VecTypes {\n+pub fn vec_types_from_expr(bcx: @Block, vec_expr: &ast::Expr) -> VecTypes {\n     let vec_ty = node_id_type(bcx, vec_expr.id);\n     vec_types(bcx, vec_ty)\n }\n \n-pub fn vec_types(bcx: @mut Block, vec_ty: ty::t) -> VecTypes {\n+pub fn vec_types(bcx: @Block, vec_ty: ty::t) -> VecTypes {\n     let ccx = bcx.ccx();\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     let llunit_ty = type_of::type_of(ccx, unit_ty);\n@@ -452,7 +452,7 @@ pub fn vec_types(bcx: @mut Block, vec_ty: ty::t) -> VecTypes {\n               llunit_alloc_size: llunit_alloc_size}\n }\n \n-pub fn elements_required(bcx: @mut Block, content_expr: &ast::Expr) -> uint {\n+pub fn elements_required(bcx: @Block, content_expr: &ast::Expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n     match content_expr.node {\n@@ -468,7 +468,7 @@ pub fn elements_required(bcx: @mut Block, content_expr: &ast::Expr) -> uint {\n     }\n }\n \n-pub fn get_base_and_byte_len(bcx: @mut Block, llval: ValueRef,\n+pub fn get_base_and_byte_len(bcx: @Block, llval: ValueRef,\n                         vec_ty: ty::t) -> (ValueRef, ValueRef) {\n     //!\n     //\n@@ -505,7 +505,7 @@ pub fn get_base_and_byte_len(bcx: @mut Block, llval: ValueRef,\n     }\n }\n \n-pub fn get_base_and_len(bcx: @mut Block, llval: ValueRef, vec_ty: ty::t) -> (ValueRef, ValueRef) {\n+pub fn get_base_and_len(bcx: @Block, llval: ValueRef, vec_ty: ty::t) -> (ValueRef, ValueRef) {\n     //!\n     //\n     // Converts a vector into the slice pair.  The vector should be stored in\n@@ -539,15 +539,15 @@ pub fn get_base_and_len(bcx: @mut Block, llval: ValueRef, vec_ty: ty::t) -> (Val\n     }\n }\n \n-pub type iter_vec_block<'a> = 'a |@mut Block, ValueRef, ty::t|\n-                                        -> @mut Block;\n+pub type iter_vec_block<'a> = 'a |@Block, ValueRef, ty::t|\n+                                        -> @Block;\n \n-pub fn iter_vec_loop(bcx: @mut Block,\n+pub fn iter_vec_loop(bcx: @Block,\n                      data_ptr: ValueRef,\n                      vt: &VecTypes,\n                      count: ValueRef,\n                      f: iter_vec_block\n-                     ) -> @mut Block {\n+                     ) -> @Block {\n     let _icx = push_ctxt(\"tvec::iter_vec_loop\");\n \n     let next_bcx = sub_block(bcx, \"iter_vec_loop: while next\");\n@@ -597,8 +597,8 @@ pub fn iter_vec_loop(bcx: @mut Block,\n     next_bcx\n }\n \n-pub fn iter_vec_raw(bcx: @mut Block, data_ptr: ValueRef, vec_ty: ty::t,\n-                    fill: ValueRef, f: iter_vec_block) -> @mut Block {\n+pub fn iter_vec_raw(bcx: @Block, data_ptr: ValueRef, vec_ty: ty::t,\n+                    fill: ValueRef, f: iter_vec_block) -> @Block {\n     let _icx = push_ctxt(\"tvec::iter_vec_raw\");\n \n     let vt = vec_types(bcx, vec_ty);\n@@ -632,15 +632,15 @@ pub fn iter_vec_raw(bcx: @mut Block, data_ptr: ValueRef, vec_ty: ty::t,\n     }\n }\n \n-pub fn iter_vec_uniq(bcx: @mut Block, vptr: ValueRef, vec_ty: ty::t,\n-                     fill: ValueRef, f: iter_vec_block) -> @mut Block {\n+pub fn iter_vec_uniq(bcx: @Block, vptr: ValueRef, vec_ty: ty::t,\n+                     fill: ValueRef, f: iter_vec_block) -> @Block {\n     let _icx = push_ctxt(\"tvec::iter_vec_uniq\");\n     let data_ptr = get_dataptr(bcx, get_bodyptr(bcx, vptr, vec_ty));\n     iter_vec_raw(bcx, data_ptr, vec_ty, fill, f)\n }\n \n-pub fn iter_vec_unboxed(bcx: @mut Block, body_ptr: ValueRef, vec_ty: ty::t,\n-                        f: iter_vec_block) -> @mut Block {\n+pub fn iter_vec_unboxed(bcx: @Block, body_ptr: ValueRef, vec_ty: ty::t,\n+                        f: iter_vec_block) -> @Block {\n     let _icx = push_ctxt(\"tvec::iter_vec_unboxed\");\n     let fill = get_fill(bcx, body_ptr);\n     let dataptr = get_dataptr(bcx, body_ptr);"}, {"sha": "fae677497b869d0634d94d6f09ea9aa9d1373592", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -187,7 +187,7 @@ impl Type {\n         Type::array(&Type::i8().ptr_to(), 1)\n     }\n \n-    pub fn generic_glue_fn(cx: &mut CrateContext) -> Type {\n+    pub fn generic_glue_fn(cx: &CrateContext) -> Type {\n         match cx.tn.find_type(\"glue_fn\") {\n             Some(ty) => return ty,\n             None => ()"}, {"sha": "c1e6e46676181d533eed05daa52dcf85ec407fda", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -21,15 +21,15 @@ use middle::trans::type_::Type;\n use syntax::ast;\n use syntax::opt_vec;\n \n-pub fn arg_is_indirect(ccx: &mut CrateContext, arg_ty: ty::t) -> bool {\n+pub fn arg_is_indirect(ccx: &CrateContext, arg_ty: ty::t) -> bool {\n     !type_is_immediate(ccx, arg_ty)\n }\n \n-pub fn return_uses_outptr(ccx: &mut CrateContext, ty: ty::t) -> bool {\n+pub fn return_uses_outptr(ccx: &CrateContext, ty: ty::t) -> bool {\n     !type_is_immediate(ccx, ty)\n }\n \n-pub fn type_of_explicit_arg(ccx: &mut CrateContext, arg_ty: ty::t) -> Type {\n+pub fn type_of_explicit_arg(ccx: &CrateContext, arg_ty: ty::t) -> Type {\n     let llty = type_of(ccx, arg_ty);\n     if arg_is_indirect(ccx, arg_ty) {\n         llty.ptr_to()\n@@ -38,12 +38,12 @@ pub fn type_of_explicit_arg(ccx: &mut CrateContext, arg_ty: ty::t) -> Type {\n     }\n }\n \n-pub fn type_of_explicit_args(ccx: &mut CrateContext,\n+pub fn type_of_explicit_args(ccx: &CrateContext,\n                              inputs: &[ty::t]) -> ~[Type] {\n     inputs.map(|&arg_ty| type_of_explicit_arg(ccx, arg_ty))\n }\n \n-pub fn type_of_rust_fn(cx: &mut CrateContext,\n+pub fn type_of_rust_fn(cx: &CrateContext,\n                        inputs: &[ty::t],\n                        output: ty::t) -> Type {\n     let mut atys: ~[Type] = ~[];\n@@ -71,7 +71,7 @@ pub fn type_of_rust_fn(cx: &mut CrateContext,\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n-pub fn type_of_fn_from_ty(cx: &mut CrateContext, fty: ty::t) -> Type {\n+pub fn type_of_fn_from_ty(cx: &CrateContext, fty: ty::t) -> Type {\n     return match ty::get(fty).sty {\n         ty::ty_closure(ref f) => {\n             type_of_rust_fn(cx, f.sig.inputs, f.sig.output)\n@@ -100,10 +100,13 @@ pub fn type_of_fn_from_ty(cx: &mut CrateContext, fty: ty::t) -> Type {\n //     type behind pointers. This can help prevent infinite loops for\n //     recursive types. For example, enum types rely on this behavior.\n \n-pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n-    match cx.llsizingtypes.find_copy(&t) {\n-        Some(t) => return t,\n-        None => ()\n+pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n+    {\n+        let llsizingtypes = cx.llsizingtypes.borrow();\n+        match llsizingtypes.get().find_copy(&t) {\n+            Some(t) => return t,\n+            None => ()\n+        }\n     }\n \n     let llsizingty = match ty::get(t).sty {\n@@ -166,18 +169,20 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n         }\n     };\n \n-    cx.llsizingtypes.insert(t, llsizingty);\n+    let mut llsizingtypes = cx.llsizingtypes.borrow_mut();\n+    llsizingtypes.get().insert(t, llsizingty);\n     llsizingty\n }\n \n // NB: If you update this, be sure to update `sizing_type_of()` as well.\n-pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n+pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     // Check the cache.\n-    match cx.lltypes.find(&t) {\n-        Some(&llty) => {\n-            return llty;\n+    {\n+        let lltypes = cx.lltypes.borrow();\n+        match lltypes.get().find(&t) {\n+            Some(&llty) => return llty,\n+            None => ()\n         }\n-        None => ()\n     }\n \n     debug!(\"type_of {} {:?}\", t.repr(cx.tcx), t);\n@@ -197,7 +202,8 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n                 t_norm.repr(cx.tcx),\n                 t_norm,\n                 cx.tn.type_to_str(llty));\n-        cx.lltypes.insert(t, llty);\n+        let mut lltypes = cx.lltypes.borrow_mut();\n+        lltypes.get().insert(t, llty);\n         return llty;\n     }\n \n@@ -316,7 +322,10 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n             t.repr(cx.tcx),\n             t,\n             cx.tn.type_to_str(llty));\n-    cx.lltypes.insert(t, llty);\n+    {\n+        let mut lltypes = cx.lltypes.borrow_mut();\n+        lltypes.get().insert(t, llty);\n+    }\n \n     // If this was an enum or struct, fill in the type now.\n     match ty::get(t).sty {\n@@ -350,7 +359,7 @@ pub fn llvm_type_name(cx: &CrateContext,\n     }\n }\n \n-pub fn type_of_dtor(ccx: &mut CrateContext, self_ty: ty::t) -> Type {\n+pub fn type_of_dtor(ccx: &CrateContext, self_ty: ty::t) -> Type {\n     let self_ty = type_of(ccx, self_ty).ptr_to();\n     Type::func([self_ty], &Type::void())\n }"}, {"sha": "a184ecda20db45b65b9fbf8cb80e7f7bb2e60c4d", "filename": "src/librustc/middle/trans/uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -17,8 +17,8 @@ use middle::trans::datum::immediate_rvalue;\n use middle::trans::glue;\n use middle::ty;\n \n-pub fn make_free_glue(bcx: @mut Block, vptrptr: ValueRef, box_ty: ty::t)\n-    -> @mut Block {\n+pub fn make_free_glue(bcx: @Block, vptrptr: ValueRef, box_ty: ty::t)\n+    -> @Block {\n     let _icx = push_ctxt(\"uniq::make_free_glue\");\n     let box_datum = immediate_rvalue(Load(bcx, vptrptr), box_ty);\n "}, {"sha": "14045f8ab744e4c12f10e2f6b378751ec68cf77f", "filename": "src/librustc/middle/trans/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -49,7 +49,7 @@ impl Value {\n     /// This only performs a search for a trivially dominating store. The store\n     /// must be the only user of this value, and there must not be any conditional\n     /// branches between the store and the given block.\n-    pub fn get_dominating_store(self, bcx: &mut Block) -> Option<Value> {\n+    pub fn get_dominating_store(self, bcx: &Block) -> Option<Value> {\n         match self.get_single_user().and_then(|user| user.as_store_inst()) {\n             Some(store) => {\n                 store.get_parent().and_then(|store_bb| {"}, {"sha": "3b60dc3dd378907176972b78da09d02d764e0942", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -34,38 +34,42 @@ use syntax::ast;\n use middle::trans::type_::Type;\n \n pub fn root_and_write_guard(datum: &Datum,\n-                            mut bcx: @mut Block,\n+                            mut bcx: @Block,\n                             span: Span,\n                             expr_id: ast::NodeId,\n-                            derefs: uint) -> @mut Block {\n+                            derefs: uint) -> @Block {\n     let key = root_map_key { id: expr_id, derefs: derefs };\n     debug!(\"write_guard::root_and_write_guard(key={:?})\", key);\n \n     // root the autoderef'd value, if necessary:\n     //\n     // (Note: root'd values are always boxes)\n     let ccx = bcx.ccx();\n-    bcx = match ccx.maps.root_map.find(&key) {\n-        None => bcx,\n-        Some(&root_info) => root(datum, bcx, span, key, root_info)\n+    bcx = {\n+        let root_map = ccx.maps.root_map.borrow();\n+        match root_map.get().find(&key) {\n+            None => bcx,\n+            Some(&root_info) => root(datum, bcx, span, key, root_info)\n+        }\n     };\n \n     // Perform the write guard, if necessary.\n     //\n     // (Note: write-guarded values are always boxes)\n-    if ccx.maps.write_guard_map.contains(&key) {\n+    let write_guard_map = ccx.maps.write_guard_map.borrow();\n+    if write_guard_map.get().contains(&key) {\n         perform_write_guard(datum, bcx, span)\n     } else {\n         bcx\n     }\n }\n \n-pub fn return_to_mut(mut bcx: @mut Block,\n+pub fn return_to_mut(mut bcx: @Block,\n                      root_key: root_map_key,\n                      frozen_val_ref: ValueRef,\n                      bits_val_ref: ValueRef,\n                      filename_val: ValueRef,\n-                     line_val: ValueRef) -> @mut Block {\n+                     line_val: ValueRef) -> @Block {\n     debug!(\"write_guard::return_to_mut(root_key={:?}, {}, {}, {})\",\n            root_key,\n            bcx.to_str(),\n@@ -102,10 +106,10 @@ pub fn return_to_mut(mut bcx: @mut Block,\n }\n \n fn root(datum: &Datum,\n-        mut bcx: @mut Block,\n+        mut bcx: @Block,\n         span: Span,\n         root_key: root_map_key,\n-        root_info: RootInfo) -> @mut Block {\n+        root_info: RootInfo) -> @Block {\n     //! In some cases, borrowck will decide that an @T/@[]/@str\n     //! value must be rooted for the program to be safe.  In that\n     //! case, we will call this function, which will stash a copy\n@@ -120,7 +124,10 @@ fn root(datum: &Datum,\n     let scratch = scratch_datum(bcx, datum.ty, \"__write_guard\", true);\n     datum.copy_to_datum(bcx, INIT, scratch);\n     let cleanup_bcx = find_bcx_for_scope(bcx, root_info.scope);\n-    add_clean_temp_mem_in_scope(cleanup_bcx, root_info.scope, scratch.val, scratch.ty);\n+    add_clean_temp_mem_in_scope(cleanup_bcx,\n+                                root_info.scope,\n+                                scratch.val,\n+                                scratch.ty);\n \n     // Now, consider also freezing it.\n     match root_info.freeze {\n@@ -165,18 +172,22 @@ fn root(datum: &Datum,\n                     Some(expr::Ignore)).bcx;\n             }\n \n-            add_clean_return_to_mut(\n-                cleanup_bcx, root_info.scope, root_key, scratch.val, scratch_bits.val,\n-                filename, line);\n+            add_clean_return_to_mut(cleanup_bcx,\n+                                    root_info.scope,\n+                                    root_key,\n+                                    scratch.val,\n+                                    scratch_bits.val,\n+                                    filename,\n+                                    line);\n         }\n     }\n \n     bcx\n }\n \n fn perform_write_guard(datum: &Datum,\n-                       bcx: @mut Block,\n-                       span: Span) -> @mut Block {\n+                       bcx: @Block,\n+                       span: Span) -> @Block {\n     debug!(\"perform_write_guard\");\n \n     let llval = datum.to_value_llval(bcx);"}, {"sha": "60bbca6cf358a64712dabb8725781d37b658920b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 296, "deletions": 193, "changes": 489, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use driver::session;\n use metadata::csearch;\n use metadata;\n@@ -30,6 +29,7 @@ use util::ppaux::{Repr, UserString};\n use util::common::{indenter};\n \n use std::cast;\n+use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::hashmap::{HashMap, HashSet};\n use std::ops;\n@@ -174,7 +174,7 @@ pub struct creader_cache_key {\n     len: uint\n }\n \n-type creader_cache = @mut HashMap<creader_cache_key, t>;\n+type creader_cache = RefCell<HashMap<creader_cache_key, t>>;\n \n struct intern_key {\n     sty: *sty,\n@@ -264,15 +264,15 @@ pub type ctxt = @ctxt_;\n /// later on.\n struct ctxt_ {\n     diag: @mut syntax::diagnostic::span_handler,\n-    interner: @mut HashMap<intern_key, ~t_box_>,\n-    next_id: @mut uint,\n-    cstore: @mut metadata::cstore::CStore,\n+    interner: RefCell<HashMap<intern_key, ~t_box_>>,\n+    next_id: Cell<uint>,\n+    cstore: @metadata::cstore::CStore,\n     sess: session::Session,\n     def_map: resolve::DefMap,\n \n-    named_region_map: @mut resolve_lifetime::NamedRegionMap,\n+    named_region_map: @RefCell<resolve_lifetime::NamedRegionMap>,\n \n-    region_maps: @mut middle::region::RegionMaps,\n+    region_maps: @middle::region::RegionMaps,\n \n     // Stores the types for various nodes in the AST.  Note that this table\n     // is not guaranteed to be populated until after typeck.  See\n@@ -283,93 +283,93 @@ struct ctxt_ {\n     // of this node.  This only applies to nodes that refer to entities\n     // parameterized by type parameters, such as generic fns, types, or\n     // other items.\n-    node_type_substs: @mut HashMap<NodeId, ~[t]>,\n+    node_type_substs: RefCell<HashMap<NodeId, ~[t]>>,\n \n     // Maps from a method to the method \"descriptor\"\n-    methods: @mut HashMap<DefId, @Method>,\n+    methods: RefCell<HashMap<DefId, @Method>>,\n \n     // Maps from a trait def-id to a list of the def-ids of its methods\n-    trait_method_def_ids: @mut HashMap<DefId, @~[DefId]>,\n+    trait_method_def_ids: RefCell<HashMap<DefId, @~[DefId]>>,\n \n     // A cache for the trait_methods() routine\n-    trait_methods_cache: @mut HashMap<DefId, @~[@Method]>,\n+    trait_methods_cache: RefCell<HashMap<DefId, @~[@Method]>>,\n \n-    impl_trait_cache: @mut HashMap<ast::DefId, Option<@ty::TraitRef>>,\n+    impl_trait_cache: RefCell<HashMap<ast::DefId, Option<@ty::TraitRef>>>,\n \n-    trait_refs: @mut HashMap<NodeId, @TraitRef>,\n-    trait_defs: @mut HashMap<DefId, @TraitDef>,\n+    trait_refs: RefCell<HashMap<NodeId, @TraitRef>>,\n+    trait_defs: RefCell<HashMap<DefId, @TraitDef>>,\n \n     /// Despite its name, `items` does not only map NodeId to an item but\n     /// also to expr/stmt/local/arg/etc\n     items: ast_map::map,\n-    intrinsic_defs: @mut HashMap<ast::DefId, t>,\n-    freevars: freevars::freevar_map,\n+    intrinsic_defs: RefCell<HashMap<ast::DefId, t>>,\n+    freevars: RefCell<freevars::freevar_map>,\n     tcache: type_cache,\n     rcache: creader_cache,\n-    short_names_cache: @mut HashMap<t, @str>,\n-    needs_unwind_cleanup_cache: @mut HashMap<t, bool>,\n-    tc_cache: @mut HashMap<uint, TypeContents>,\n-    ast_ty_to_ty_cache: @mut HashMap<NodeId, ast_ty_to_ty_cache_entry>,\n-    enum_var_cache: @mut HashMap<DefId, @~[@VariantInfo]>,\n-    ty_param_defs: @mut HashMap<ast::NodeId, TypeParameterDef>,\n-    adjustments: @mut HashMap<ast::NodeId, @AutoAdjustment>,\n-    normalized_cache: @mut HashMap<t, t>,\n+    short_names_cache: RefCell<HashMap<t, @str>>,\n+    needs_unwind_cleanup_cache: RefCell<HashMap<t, bool>>,\n+    tc_cache: RefCell<HashMap<uint, TypeContents>>,\n+    ast_ty_to_ty_cache: RefCell<HashMap<NodeId, ast_ty_to_ty_cache_entry>>,\n+    enum_var_cache: RefCell<HashMap<DefId, @~[@VariantInfo]>>,\n+    ty_param_defs: RefCell<HashMap<ast::NodeId, TypeParameterDef>>,\n+    adjustments: RefCell<HashMap<ast::NodeId, @AutoAdjustment>>,\n+    normalized_cache: RefCell<HashMap<t, t>>,\n     lang_items: middle::lang_items::LanguageItems,\n     // A mapping of fake provided method def_ids to the default implementation\n-    provided_method_sources: @mut HashMap<ast::DefId, ast::DefId>,\n-    supertraits: @mut HashMap<ast::DefId, @~[@TraitRef]>,\n+    provided_method_sources: RefCell<HashMap<ast::DefId, ast::DefId>>,\n+    supertraits: RefCell<HashMap<ast::DefId, @~[@TraitRef]>>,\n \n     // Maps from def-id of a type or region parameter to its\n     // (inferred) variance.\n-    item_variance_map: @mut HashMap<ast::DefId, @ItemVariances>,\n+    item_variance_map: RefCell<HashMap<ast::DefId, @ItemVariances>>,\n \n     // A mapping from the def ID of an enum or struct type to the def ID\n     // of the method that implements its destructor. If the type is not\n     // present in this map, it does not have a destructor. This map is\n     // populated during the coherence phase of typechecking.\n-    destructor_for_type: @mut HashMap<ast::DefId, ast::DefId>,\n+    destructor_for_type: RefCell<HashMap<ast::DefId, ast::DefId>>,\n \n     // A method will be in this list if and only if it is a destructor.\n-    destructors: @mut HashSet<ast::DefId>,\n+    destructors: RefCell<HashSet<ast::DefId>>,\n \n     // Maps a trait onto a list of impls of that trait.\n-    trait_impls: @mut HashMap<ast::DefId, @mut ~[@Impl]>,\n+    trait_impls: RefCell<HashMap<ast::DefId, @RefCell<~[@Impl]>>>,\n \n     // Maps a def_id of a type to a list of its inherent impls.\n     // Contains implementations of methods that are inherent to a type.\n     // Methods in these implementations don't need to be exported.\n-    inherent_impls: @mut HashMap<ast::DefId, @mut ~[@Impl]>,\n+    inherent_impls: RefCell<HashMap<ast::DefId, @RefCell<~[@Impl]>>>,\n \n     // Maps a def_id of an impl to an Impl structure.\n     // Note that this contains all of the impls that we know about,\n     // including ones in other crates. It's not clear that this is the best\n     // way to do it.\n-    impls: @mut HashMap<ast::DefId, @Impl>,\n+    impls: RefCell<HashMap<ast::DefId, @Impl>>,\n \n     // Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     // present in this set can be warned about.\n-    used_unsafe: @mut HashSet<ast::NodeId>,\n+    used_unsafe: RefCell<HashSet<ast::NodeId>>,\n \n     // Set of nodes which mark locals as mutable which end up getting used at\n     // some point. Local variable definitions not in this set can be warned\n     // about.\n-    used_mut_nodes: @mut HashSet<ast::NodeId>,\n+    used_mut_nodes: RefCell<HashSet<ast::NodeId>>,\n \n     // vtable resolution information for impl declarations\n     impl_vtables: typeck::impl_vtable_map,\n \n     // The set of external nominal types whose implementations have been read.\n     // This is used for lazy resolution of methods.\n-    populated_external_types: @mut HashSet<ast::DefId>,\n+    populated_external_types: RefCell<HashSet<ast::DefId>>,\n \n     // The set of external traits whose implementations have been read. This\n     // is used for lazy resolution of traits.\n-    populated_external_traits: @mut HashSet<ast::DefId>,\n+    populated_external_traits: RefCell<HashSet<ast::DefId>>,\n \n     // These two caches are used by const_eval when decoding external statics\n     // and variants that are found.\n-    extern_const_statics: @mut HashMap<ast::DefId, Option<@ast::Expr>>,\n-    extern_const_variants: @mut HashMap<ast::DefId, Option<@ast::Expr>>,\n+    extern_const_statics: RefCell<HashMap<ast::DefId, Option<@ast::Expr>>>,\n+    extern_const_variants: RefCell<HashMap<ast::DefId, Option<@ast::Expr>>>,\n }\n \n pub enum tbox_flag {\n@@ -953,73 +953,65 @@ pub struct ty_param_substs_and_ty {\n     ty: ty::t\n }\n \n-type type_cache = @mut HashMap<ast::DefId, ty_param_bounds_and_ty>;\n-\n-pub type node_type_table = @mut HashMap<uint,t>;\n-\n-fn mk_rcache() -> creader_cache {\n-    return @mut HashMap::new();\n-}\n+type type_cache = RefCell<HashMap<ast::DefId, ty_param_bounds_and_ty>>;\n \n-pub fn new_ty_hash<V:'static>() -> @mut HashMap<t, V> {\n-    @mut HashMap::new()\n-}\n+pub type node_type_table = RefCell<HashMap<uint,t>>;\n \n pub fn mk_ctxt(s: session::Session,\n                dm: resolve::DefMap,\n-               named_region_map: @mut resolve_lifetime::NamedRegionMap,\n+               named_region_map: @RefCell<resolve_lifetime::NamedRegionMap>,\n                amap: ast_map::map,\n                freevars: freevars::freevar_map,\n-               region_maps: @mut middle::region::RegionMaps,\n+               region_maps: @middle::region::RegionMaps,\n                lang_items: middle::lang_items::LanguageItems)\n             -> ctxt {\n     @ctxt_ {\n         named_region_map: named_region_map,\n-        item_variance_map: @mut HashMap::new(),\n+        item_variance_map: RefCell::new(HashMap::new()),\n         diag: s.diagnostic(),\n-        interner: @mut HashMap::new(),\n-        next_id: @mut primitives::LAST_PRIMITIVE_ID,\n+        interner: RefCell::new(HashMap::new()),\n+        next_id: Cell::new(primitives::LAST_PRIMITIVE_ID),\n         cstore: s.cstore,\n         sess: s,\n         def_map: dm,\n         region_maps: region_maps,\n-        node_types: @mut HashMap::new(),\n-        node_type_substs: @mut HashMap::new(),\n-        trait_refs: @mut HashMap::new(),\n-        trait_defs: @mut HashMap::new(),\n+        node_types: RefCell::new(HashMap::new()),\n+        node_type_substs: RefCell::new(HashMap::new()),\n+        trait_refs: RefCell::new(HashMap::new()),\n+        trait_defs: RefCell::new(HashMap::new()),\n         items: amap,\n-        intrinsic_defs: @mut HashMap::new(),\n-        freevars: freevars,\n-        tcache: @mut HashMap::new(),\n-        rcache: mk_rcache(),\n-        short_names_cache: new_ty_hash(),\n-        needs_unwind_cleanup_cache: new_ty_hash(),\n-        tc_cache: @mut HashMap::new(),\n-        ast_ty_to_ty_cache: @mut HashMap::new(),\n-        enum_var_cache: @mut HashMap::new(),\n-        methods: @mut HashMap::new(),\n-        trait_method_def_ids: @mut HashMap::new(),\n-        trait_methods_cache: @mut HashMap::new(),\n-        impl_trait_cache: @mut HashMap::new(),\n-        ty_param_defs: @mut HashMap::new(),\n-        adjustments: @mut HashMap::new(),\n-        normalized_cache: new_ty_hash(),\n+        intrinsic_defs: RefCell::new(HashMap::new()),\n+        freevars: RefCell::new(freevars),\n+        tcache: RefCell::new(HashMap::new()),\n+        rcache: RefCell::new(HashMap::new()),\n+        short_names_cache: RefCell::new(HashMap::new()),\n+        needs_unwind_cleanup_cache: RefCell::new(HashMap::new()),\n+        tc_cache: RefCell::new(HashMap::new()),\n+        ast_ty_to_ty_cache: RefCell::new(HashMap::new()),\n+        enum_var_cache: RefCell::new(HashMap::new()),\n+        methods: RefCell::new(HashMap::new()),\n+        trait_method_def_ids: RefCell::new(HashMap::new()),\n+        trait_methods_cache: RefCell::new(HashMap::new()),\n+        impl_trait_cache: RefCell::new(HashMap::new()),\n+        ty_param_defs: RefCell::new(HashMap::new()),\n+        adjustments: RefCell::new(HashMap::new()),\n+        normalized_cache: RefCell::new(HashMap::new()),\n         lang_items: lang_items,\n-        provided_method_sources: @mut HashMap::new(),\n-        supertraits: @mut HashMap::new(),\n-        destructor_for_type: @mut HashMap::new(),\n-        destructors: @mut HashSet::new(),\n-        trait_impls: @mut HashMap::new(),\n-        inherent_impls:  @mut HashMap::new(),\n-        impls:  @mut HashMap::new(),\n-        used_unsafe: @mut HashSet::new(),\n-        used_mut_nodes: @mut HashSet::new(),\n-        impl_vtables: @mut HashMap::new(),\n-        populated_external_types: @mut HashSet::new(),\n-        populated_external_traits: @mut HashSet::new(),\n-\n-        extern_const_statics: @mut HashMap::new(),\n-        extern_const_variants: @mut HashMap::new(),\n+        provided_method_sources: RefCell::new(HashMap::new()),\n+        supertraits: RefCell::new(HashMap::new()),\n+        destructor_for_type: RefCell::new(HashMap::new()),\n+        destructors: RefCell::new(HashSet::new()),\n+        trait_impls: RefCell::new(HashMap::new()),\n+        inherent_impls: RefCell::new(HashMap::new()),\n+        impls: RefCell::new(HashMap::new()),\n+        used_unsafe: RefCell::new(HashSet::new()),\n+        used_mut_nodes: RefCell::new(HashSet::new()),\n+        impl_vtables: RefCell::new(HashMap::new()),\n+        populated_external_types: RefCell::new(HashSet::new()),\n+        populated_external_traits: RefCell::new(HashSet::new()),\n+\n+        extern_const_statics: RefCell::new(HashMap::new()),\n+        extern_const_variants: RefCell::new(HashMap::new()),\n      }\n }\n \n@@ -1042,9 +1034,13 @@ pub fn mk_t(cx: ctxt, st: sty) -> t {\n     };\n \n     let key = intern_key { sty: to_unsafe_ptr(&st) };\n-    match cx.interner.find(&key) {\n-      Some(t) => unsafe { return cast::transmute(&t.sty); },\n-      _ => ()\n+\n+    {\n+        let mut interner = cx.interner.borrow_mut();\n+        match interner.get().find(&key) {\n+          Some(t) => unsafe { return cast::transmute(&t.sty); },\n+          _ => ()\n+        }\n     }\n \n     let mut flags = 0u;\n@@ -1128,7 +1124,7 @@ pub fn mk_t(cx: ctxt, st: sty) -> t {\n \n     let t = ~t_box_ {\n         sty: st,\n-        id: *cx.next_id,\n+        id: cx.next_id.get(),\n         flags: flags,\n     };\n \n@@ -1138,9 +1134,10 @@ pub fn mk_t(cx: ctxt, st: sty) -> t {\n         sty: sty_ptr,\n     };\n \n-    cx.interner.insert(key, t);\n+    let mut interner = cx.interner.borrow_mut();\n+    interner.get().insert(key, t);\n \n-    *cx.next_id += 1;\n+    cx.next_id.set(cx.next_id.get() + 1);\n \n     unsafe {\n         cast::transmute::<*sty, t>(sty_ptr)\n@@ -1662,15 +1659,21 @@ pub fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n // that only contain scalars and shared boxes can avoid unwind\n // cleanups.\n pub fn type_needs_unwind_cleanup(cx: ctxt, ty: t) -> bool {\n-    match cx.needs_unwind_cleanup_cache.find(&ty) {\n-      Some(&result) => return result,\n-      None => ()\n+    {\n+        let needs_unwind_cleanup_cache = cx.needs_unwind_cleanup_cache\n+                                           .borrow();\n+        match needs_unwind_cleanup_cache.get().find(&ty) {\n+            Some(&result) => return result,\n+            None => ()\n+        }\n     }\n \n     let mut tycache = HashSet::new();\n     let needs_unwind_cleanup =\n         type_needs_unwind_cleanup_(cx, ty, &mut tycache, false);\n-    cx.needs_unwind_cleanup_cache.insert(ty, needs_unwind_cleanup);\n+    let mut needs_unwind_cleanup_cache = cx.needs_unwind_cleanup_cache\n+                                           .borrow_mut();\n+    needs_unwind_cleanup_cache.get().insert(ty, needs_unwind_cleanup);\n     return needs_unwind_cleanup;\n }\n \n@@ -1958,14 +1961,20 @@ pub fn type_is_freezable(cx: ctxt, t: ty::t) -> bool {\n \n pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n     let ty_id = type_id(ty);\n-    match cx.tc_cache.find(&ty_id) {\n-        Some(tc) => { return *tc; }\n-        None => {}\n+\n+    {\n+        let tc_cache = cx.tc_cache.borrow();\n+        match tc_cache.get().find(&ty_id) {\n+            Some(tc) => { return *tc; }\n+            None => {}\n+        }\n     }\n \n     let mut cache = HashMap::new();\n     let result = tc_ty(cx, ty, &mut cache);\n-    cx.tc_cache.insert(ty_id, result);\n+\n+    let mut tc_cache = cx.tc_cache.borrow_mut();\n+    tc_cache.get().insert(ty_id, result);\n     return result;\n \n     fn tc_ty(cx: ctxt,\n@@ -1998,9 +2007,12 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             Some(tc) => { return *tc; }\n             None => {}\n         }\n-        match cx.tc_cache.find(&ty_id) {    // Must check both caches!\n-            Some(tc) => { return *tc; }\n-            None => {}\n+        {\n+            let tc_cache = cx.tc_cache.borrow();\n+            match tc_cache.get().find(&ty_id) {    // Must check both caches!\n+                Some(tc) => { return *tc; }\n+                None => {}\n+            }\n         }\n         cache.insert(ty_id, TC::None);\n \n@@ -2103,7 +2115,8 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 // def-id.\n                 assert_eq!(p.def_id.crate, ast::LOCAL_CRATE);\n \n-                let tp_def = cx.ty_param_defs.get(&p.def_id.node);\n+                let ty_param_defs = cx.ty_param_defs.borrow();\n+                let tp_def = ty_param_defs.get().get(&p.def_id.node);\n                 kind_bounds_to_contents(cx,\n                                         tp_def.bounds.builtin_bounds,\n                                         tp_def.bounds.trait_bounds)\n@@ -2548,7 +2561,8 @@ pub fn type_is_sized(cx: ctxt, ty: ty::t) -> bool {\n     match get(ty).sty {\n         // FIXME(#6308) add trait, vec, str, etc here.\n         ty_param(p) => {\n-            let param_def = cx.ty_param_defs.get(&p.def_id.node);\n+            let ty_param_defs = cx.ty_param_defs.borrow();\n+            let param_def = ty_param_defs.get().get(&p.def_id.node);\n             if param_def.bounds.builtin_bounds.contains_elem(BoundSized) {\n                 return true;\n             }\n@@ -2648,7 +2662,8 @@ pub fn index_sty(sty: &sty) -> Option<mt> {\n }\n \n pub fn node_id_to_trait_ref(cx: ctxt, id: ast::NodeId) -> @ty::TraitRef {\n-    match cx.trait_refs.find(&id) {\n+    let trait_refs = cx.trait_refs.borrow();\n+    match trait_refs.get().find(&id) {\n        Some(&t) => t,\n        None => cx.sess.bug(\n            format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n@@ -2659,7 +2674,8 @@ pub fn node_id_to_trait_ref(cx: ctxt, id: ast::NodeId) -> @ty::TraitRef {\n \n pub fn node_id_to_type(cx: ctxt, id: ast::NodeId) -> t {\n     //printfln!(\"{:?}/{:?}\", id, cx.node_types.len());\n-    match cx.node_types.find(&(id as uint)) {\n+    let node_types = cx.node_types.borrow();\n+    match node_types.get().find(&(id as uint)) {\n        Some(&t) => t,\n        None => cx.sess.bug(\n            format!(\"node_id_to_type: no type for node `{}`\",\n@@ -2670,14 +2686,16 @@ pub fn node_id_to_type(cx: ctxt, id: ast::NodeId) -> t {\n \n // XXX(pcwalton): Makes a copy, bleh. Probably better to not do that.\n pub fn node_id_to_type_params(cx: ctxt, id: ast::NodeId) -> ~[t] {\n-    match cx.node_type_substs.find(&id) {\n+    let node_type_substs = cx.node_type_substs.borrow();\n+    match node_type_substs.get().find(&id) {\n       None => return ~[],\n       Some(ts) => return (*ts).clone(),\n     }\n }\n \n fn node_id_has_type_params(cx: ctxt, id: ast::NodeId) -> bool {\n-    cx.node_type_substs.contains_key(&id)\n+    let node_type_substs = cx.node_type_substs.borrow();\n+    node_type_substs.get().contains_key(&id)\n }\n \n pub fn fn_is_variadic(fty: t) -> bool {\n@@ -2851,14 +2869,18 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: &ast::Expr) -> t {\n      */\n \n     let unadjusted_ty = expr_ty(cx, expr);\n-    adjust_ty(cx, expr.span, unadjusted_ty, cx.adjustments.find_copy(&expr.id))\n+    let adjustment = {\n+        let adjustments = cx.adjustments.borrow();\n+        adjustments.get().find_copy(&expr.id)\n+    };\n+    adjust_ty(cx, expr.span, unadjusted_ty, adjustment)\n }\n \n pub fn adjust_ty(cx: ctxt,\n                  span: Span,\n                  unadjusted_ty: ty::t,\n-                 adjustment: Option<@AutoAdjustment>) -> ty::t\n-{\n+                 adjustment: Option<@AutoAdjustment>)\n+                 -> ty::t {\n     /*! See `expr_ty_adjusted` */\n \n     return match adjustment {\n@@ -3027,7 +3049,8 @@ pub fn method_call_type_param_defs(tcx: ctxt,\n                                    method_map: typeck::method_map,\n                                    id: ast::NodeId)\n                                    -> Option<@~[TypeParameterDef]> {\n-    method_map.find(&id).map(|method| {\n+    let method_map = method_map.borrow();\n+    method_map.get().find(&id).map(|method| {\n         match method.origin {\n           typeck::method_static(did) => {\n             // n.b.: When we encode impl methods, the bounds\n@@ -3057,7 +3080,8 @@ pub fn method_call_type_param_defs(tcx: ctxt,\n }\n \n pub fn resolve_expr(tcx: ctxt, expr: &ast::Expr) -> ast::Def {\n-    match tcx.def_map.find(&expr.id) {\n+    let def_map = tcx.def_map.borrow();\n+    match def_map.get().find(&expr.id) {\n         Some(&def) => def,\n         None => {\n             tcx.sess.span_bug(expr.span, format!(\n@@ -3090,14 +3114,17 @@ pub enum ExprKind {\n pub fn expr_kind(tcx: ctxt,\n                  method_map: typeck::method_map,\n                  expr: &ast::Expr) -> ExprKind {\n-    if method_map.contains_key(&expr.id) {\n-        // Overloaded operations are generally calls, and hence they are\n-        // generated via DPS.  However, assign_op (e.g., `x += y`) is an\n-        // exception, as its result is always unit.\n-        return match expr.node {\n-            ast::ExprAssignOp(..) => RvalueStmtExpr,\n-            _ => RvalueDpsExpr\n-        };\n+    {\n+        let method_map = method_map.borrow();\n+        if method_map.get().contains_key(&expr.id) {\n+            // Overloaded operations are generally calls, and hence they are\n+            // generated via DPS.  However, assign_op (e.g., `x += y`) is an\n+            // exception, as its result is always unit.\n+            return match expr.node {\n+                ast::ExprAssignOp(..) => RvalueStmtExpr,\n+                _ => RvalueDpsExpr\n+            };\n+        }\n     }\n \n     match expr.node {\n@@ -3151,7 +3178,8 @@ pub fn expr_kind(tcx: ctxt,\n         }\n \n         ast::ExprCast(..) => {\n-            match tcx.node_types.find(&(expr.id as uint)) {\n+            let node_types = tcx.node_types.borrow();\n+            match node_types.get().find(&(expr.id as uint)) {\n                 Some(&t) => {\n                     if type_is_trait(t) {\n                         RvalueDpsExpr\n@@ -3501,7 +3529,8 @@ pub fn def_has_ty_params(def: ast::Def) -> bool {\n }\n \n pub fn provided_source(cx: ctxt, id: ast::DefId) -> Option<ast::DefId> {\n-    cx.provided_method_sources.find(&id).map(|x| *x)\n+    let provided_method_sources = cx.provided_method_sources.borrow();\n+    provided_method_sources.get().find(&id).map(|x| *x)\n }\n \n pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> ~[@Method] {\n@@ -3522,13 +3551,14 @@ pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> ~[@Method] {\n     }\n }\n \n-pub fn trait_supertraits(cx: ctxt,\n-                         id: ast::DefId) -> @~[@TraitRef]\n-{\n+pub fn trait_supertraits(cx: ctxt, id: ast::DefId) -> @~[@TraitRef] {\n     // Check the cache.\n-    match cx.supertraits.find(&id) {\n-        Some(&trait_refs) => { return trait_refs; }\n-        None => {}  // Continue.\n+    {\n+        let supertraits = cx.supertraits.borrow();\n+        match supertraits.get().find(&id) {\n+            Some(&trait_refs) => { return trait_refs; }\n+            None => {}  // Continue.\n+        }\n     }\n \n     // Not in the cache. It had better be in the metadata, which means it\n@@ -3538,7 +3568,8 @@ pub fn trait_supertraits(cx: ctxt,\n     // Get the supertraits out of the metadata and create the\n     // TraitRef for each.\n     let result = @csearch::get_supertraits(cx, id);\n-    cx.supertraits.insert(id, result);\n+    let mut supertraits = cx.supertraits.borrow_mut();\n+    supertraits.get().insert(id, result);\n     return result;\n }\n \n@@ -3583,34 +3614,44 @@ pub fn trait_method(cx: ctxt, trait_did: ast::DefId, idx: uint) -> @Method {\n \n \n pub fn trait_methods(cx: ctxt, trait_did: ast::DefId) -> @~[@Method] {\n-    match cx.trait_methods_cache.find(&trait_did) {\n+    let mut trait_methods_cache = cx.trait_methods_cache.borrow_mut();\n+    match trait_methods_cache.get().find(&trait_did) {\n         Some(&methods) => methods,\n         None => {\n             let def_ids = ty::trait_method_def_ids(cx, trait_did);\n             let methods = @def_ids.map(|d| ty::method(cx, *d));\n-            cx.trait_methods_cache.insert(trait_did, methods);\n+            trait_methods_cache.get().insert(trait_did, methods);\n             methods\n         }\n     }\n }\n \n pub fn method(cx: ctxt, id: ast::DefId) -> @Method {\n-    lookup_locally_or_in_crate_store(\n-        \"methods\", id, cx.methods,\n-        || @csearch::get_method(cx, id))\n+    let mut methods = cx.methods.borrow_mut();\n+    lookup_locally_or_in_crate_store(\"methods\", id, methods.get(), || {\n+        @csearch::get_method(cx, id)\n+    })\n }\n \n pub fn trait_method_def_ids(cx: ctxt, id: ast::DefId) -> @~[DefId] {\n-    lookup_locally_or_in_crate_store(\n-        \"trait_method_def_ids\", id, cx.trait_method_def_ids,\n-        || @csearch::get_trait_method_def_ids(cx.cstore, id))\n+    let mut trait_method_def_ids = cx.trait_method_def_ids.borrow_mut();\n+    lookup_locally_or_in_crate_store(\"trait_method_def_ids\",\n+                                     id,\n+                                     trait_method_def_ids.get(),\n+                                     || {\n+        @csearch::get_trait_method_def_ids(cx.cstore, id)\n+    })\n }\n \n pub fn impl_trait_ref(cx: ctxt, id: ast::DefId) -> Option<@TraitRef> {\n-    match cx.impl_trait_cache.find(&id) {\n-        Some(&ret) => { return ret; }\n-        None => {}\n+    {\n+        let mut impl_trait_cache = cx.impl_trait_cache.borrow_mut();\n+        match impl_trait_cache.get().find(&id) {\n+            Some(&ret) => { return ret; }\n+            None => {}\n+        }\n     }\n+\n     let ret = if id.crate == ast::LOCAL_CRATE {\n         debug!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n         match cx.items.find(&id.node) {\n@@ -3628,12 +3669,17 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::DefId) -> Option<@TraitRef> {\n     } else {\n         csearch::get_impl_trait(cx, id)\n     };\n-    cx.impl_trait_cache.insert(id, ret);\n+\n+    let mut impl_trait_cache = cx.impl_trait_cache.borrow_mut();\n+    impl_trait_cache.get().insert(id, ret);\n     return ret;\n }\n \n pub fn trait_ref_to_def_id(tcx: ctxt, tr: &ast::trait_ref) -> ast::DefId {\n-    let def = tcx.def_map.find(&tr.ref_id).expect(\"no def-map entry for trait\");\n+    let def_map = tcx.def_map.borrow();\n+    let def = def_map.get()\n+                     .find(&tr.ref_id)\n+                     .expect(\"no def-map entry for trait\");\n     ast_util::def_id_of_def(*def)\n }\n \n@@ -3773,7 +3819,8 @@ impl DtorKind {\n /* If struct_id names a struct with a dtor, return Some(the dtor's id).\n    Otherwise return none. */\n pub fn ty_dtor(cx: ctxt, struct_id: DefId) -> DtorKind {\n-    match cx.destructor_for_type.find(&struct_id) {\n+    let destructor_for_type = cx.destructor_for_type.borrow();\n+    match destructor_for_type.get().find(&struct_id) {\n         Some(&method_def_id) => {\n             let flag = !has_attr(cx, struct_id, \"unsafe_no_drop_flag\");\n \n@@ -3852,9 +3899,12 @@ pub fn type_is_empty(cx: ctxt, t: t) -> bool {\n }\n \n pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @~[@VariantInfo] {\n-    match cx.enum_var_cache.find(&id) {\n-      Some(&variants) => return variants,\n-      _ => { /* fallthrough */ }\n+    {\n+        let enum_var_cache = cx.enum_var_cache.borrow();\n+        match enum_var_cache.get().find(&id) {\n+            Some(&variants) => return variants,\n+            _ => { /* fallthrough */ }\n+        }\n     }\n \n     let result = if ast::LOCAL_CRATE != id.crate {\n@@ -3901,8 +3951,12 @@ pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @~[@VariantInfo] {\n           _ => cx.sess.bug(\"enum_variants: id not bound to an enum\")\n         }\n     };\n-    cx.enum_var_cache.insert(id, result);\n-    result\n+\n+    {\n+        let mut enum_var_cache = cx.enum_var_cache.borrow_mut();\n+        enum_var_cache.get().insert(id, result);\n+        result\n+    }\n }\n \n \n@@ -3927,22 +3981,25 @@ pub fn enum_variant_with_id(cx: ctxt,\n pub fn lookup_item_type(cx: ctxt,\n                         did: ast::DefId)\n                      -> ty_param_bounds_and_ty {\n+    let mut tcache = cx.tcache.borrow_mut();\n     lookup_locally_or_in_crate_store(\n-        \"tcache\", did, cx.tcache,\n+        \"tcache\", did, tcache.get(),\n         || csearch::get_type(cx, did))\n }\n \n pub fn lookup_impl_vtables(cx: ctxt,\n                            did: ast::DefId)\n                      -> typeck::impl_res {\n+    let mut impl_vtables = cx.impl_vtables.borrow_mut();\n     lookup_locally_or_in_crate_store(\n-        \"impl_vtables\", did, cx.impl_vtables,\n+        \"impl_vtables\", did, impl_vtables.get(),\n         || csearch::get_impl_vtables(cx, did) )\n }\n \n /// Given the did of a trait, returns its canonical trait ref.\n pub fn lookup_trait_def(cx: ctxt, did: ast::DefId) -> @ty::TraitDef {\n-    match cx.trait_defs.find(&did) {\n+    let mut trait_defs = cx.trait_defs.borrow_mut();\n+    match trait_defs.get().find(&did) {\n         Some(&trait_def) => {\n             // The item is in this crate. The caller should have added it to the\n             // type cache already\n@@ -3951,7 +4008,7 @@ pub fn lookup_trait_def(cx: ctxt, did: ast::DefId) -> @ty::TraitDef {\n         None => {\n             assert!(did.crate != ast::LOCAL_CRATE);\n             let trait_def = @csearch::get_trait_def(cx, did);\n-            cx.trait_defs.insert(did, trait_def);\n+            trait_defs.get().insert(did, trait_def);\n             return trait_def;\n         }\n     }\n@@ -4022,15 +4079,17 @@ pub fn lookup_field_type(tcx: ctxt,\n                       -> ty::t {\n     let t = if id.crate == ast::LOCAL_CRATE {\n         node_id_to_type(tcx, id.node)\n-    }\n-    else {\n-        match tcx.tcache.find(&id) {\n-           Some(&ty_param_bounds_and_ty {ty, ..}) => ty,\n-           None => {\n-               let tpt = csearch::get_field_type(tcx, struct_id, id);\n-               tcx.tcache.insert(id, tpt);\n-               tpt.ty\n-           }\n+    } else {\n+        {\n+            let mut tcache = tcx.tcache.borrow_mut();\n+            match tcache.get().find(&id) {\n+               Some(&ty_param_bounds_and_ty {ty, ..}) => ty,\n+               None => {\n+                   let tpt = csearch::get_field_type(tcx, struct_id, id);\n+                   tcache.get().insert(id, tpt);\n+                   tpt.ty\n+               }\n+            }\n         }\n     };\n     subst(tcx, substs, t)\n@@ -4213,13 +4272,20 @@ pub fn normalize_ty(cx: ctxt, t: t) -> t {\n         fn tcx(&self) -> ty::ctxt { **self }\n \n         fn fold_ty(&mut self, t: ty::t) -> ty::t {\n-            match self.tcx().normalized_cache.find_copy(&t) {\n+            let normalized_opt = {\n+                let normalized_cache = self.tcx().normalized_cache.borrow();\n+                normalized_cache.get().find_copy(&t)\n+            };\n+            match normalized_opt {\n                 Some(u) => {\n                     return u;\n                 }\n                 None => {\n                     let t_norm = ty_fold::super_fold_ty(self, t);\n-                    self.tcx().normalized_cache.insert(t, t_norm);\n+                    let mut normalized_cache = self.tcx()\n+                                                   .normalized_cache\n+                                                   .borrow_mut();\n+                    normalized_cache.get().insert(t, t_norm);\n                     return t_norm;\n                 }\n             }\n@@ -4395,14 +4461,16 @@ pub fn count_traits_and_supertraits(tcx: ctxt,\n \n pub fn get_tydesc_ty(tcx: ctxt) -> Result<t, ~str> {\n     tcx.lang_items.require(TyDescStructLangItem).map(|tydesc_lang_item| {\n-        tcx.intrinsic_defs.find_copy(&tydesc_lang_item)\n+        let intrinsic_defs = tcx.intrinsic_defs.borrow();\n+        intrinsic_defs.get().find_copy(&tydesc_lang_item)\n             .expect(\"Failed to resolve TyDesc\")\n     })\n }\n \n pub fn get_opaque_ty(tcx: ctxt) -> Result<t, ~str> {\n     tcx.lang_items.require(OpaqueStructLangItem).map(|opaque_lang_item| {\n-        tcx.intrinsic_defs.find_copy(&opaque_lang_item)\n+        let intrinsic_defs = tcx.intrinsic_defs.borrow();\n+        intrinsic_defs.get().find_copy(&opaque_lang_item)\n             .expect(\"Failed to resolve Opaque\")\n     })\n }\n@@ -4429,8 +4497,9 @@ pub fn visitor_object_ty(tcx: ctxt,\n }\n \n pub fn item_variances(tcx: ctxt, item_id: ast::DefId) -> @ItemVariances {\n+    let mut item_variance_map = tcx.item_variance_map.borrow_mut();\n     lookup_locally_or_in_crate_store(\n-        \"item_variance_map\", item_id, tcx.item_variance_map,\n+        \"item_variance_map\", item_id, item_variance_map.get(),\n         || @csearch::get_item_variances(tcx.cstore, item_id))\n }\n \n@@ -4439,17 +4508,19 @@ fn record_trait_implementation(tcx: ctxt,\n                                trait_def_id: DefId,\n                                implementation: @Impl) {\n     let implementation_list;\n-    match tcx.trait_impls.find(&trait_def_id) {\n+    let mut trait_impls = tcx.trait_impls.borrow_mut();\n+    match trait_impls.get().find(&trait_def_id) {\n         None => {\n-            implementation_list = @mut ~[];\n-            tcx.trait_impls.insert(trait_def_id, implementation_list);\n+            implementation_list = @RefCell::new(~[]);\n+            trait_impls.get().insert(trait_def_id, implementation_list);\n         }\n         Some(&existing_implementation_list) => {\n             implementation_list = existing_implementation_list\n         }\n     }\n \n-    implementation_list.push(implementation);\n+    let mut implementation_list = implementation_list.borrow_mut();\n+    implementation_list.get().push(implementation);\n }\n \n /// Populates the type context with all the implementations for the given type\n@@ -4459,8 +4530,11 @@ pub fn populate_implementations_for_type_if_necessary(tcx: ctxt,\n     if type_id.crate == LOCAL_CRATE {\n         return\n     }\n-    if tcx.populated_external_types.contains(&type_id) {\n-        return\n+    {\n+        let populated_external_types = tcx.populated_external_types.borrow();\n+        if populated_external_types.get().contains(&type_id) {\n+            return\n+        }\n     }\n \n     csearch::each_implementation_for_type(tcx.sess.cstore, type_id,\n@@ -4480,30 +4554,40 @@ pub fn populate_implementations_for_type_if_necessary(tcx: ctxt,\n         // the map. This is a bit unfortunate.\n         for method in implementation.methods.iter() {\n             for source in method.provided_source.iter() {\n-                tcx.provided_method_sources.insert(method.def_id, *source);\n+                let mut provided_method_sources =\n+                    tcx.provided_method_sources.borrow_mut();\n+                provided_method_sources.get().insert(method.def_id, *source);\n             }\n         }\n \n         // If this is an inherent implementation, record it.\n         if associated_traits.is_none() {\n             let implementation_list;\n-            match tcx.inherent_impls.find(&type_id) {\n+            let mut inherent_impls = tcx.inherent_impls.borrow_mut();\n+            match inherent_impls.get().find(&type_id) {\n                 None => {\n-                    implementation_list = @mut ~[];\n-                    tcx.inherent_impls.insert(type_id, implementation_list);\n+                    implementation_list = @RefCell::new(~[]);\n+                    inherent_impls.get().insert(type_id, implementation_list);\n                 }\n                 Some(&existing_implementation_list) => {\n                     implementation_list = existing_implementation_list;\n                 }\n             }\n-            implementation_list.push(implementation);\n+            {\n+                let mut implementation_list =\n+                    implementation_list.borrow_mut();\n+                implementation_list.get().push(implementation);\n+            }\n         }\n \n         // Store the implementation info.\n-        tcx.impls.insert(implementation_def_id, implementation);\n+        let mut impls = tcx.impls.borrow_mut();\n+        impls.get().insert(implementation_def_id, implementation);\n     });\n \n-    tcx.populated_external_types.insert(type_id);\n+    let mut populated_external_types = tcx.populated_external_types\n+                                          .borrow_mut();\n+    populated_external_types.get().insert(type_id);\n }\n \n /// Populates the type context with all the implementations for the given\n@@ -4514,8 +4598,12 @@ pub fn populate_implementations_for_trait_if_necessary(\n     if trait_id.crate == LOCAL_CRATE {\n         return\n     }\n-    if tcx.populated_external_traits.contains(&trait_id) {\n-        return\n+    {\n+        let populated_external_traits = tcx.populated_external_traits\n+                                           .borrow();\n+        if populated_external_traits.get().contains(&trait_id) {\n+            return\n+        }\n     }\n \n     csearch::each_implementation_for_trait(tcx.sess.cstore, trait_id,\n@@ -4529,15 +4617,20 @@ pub fn populate_implementations_for_trait_if_necessary(\n         // the map. This is a bit unfortunate.\n         for method in implementation.methods.iter() {\n             for source in method.provided_source.iter() {\n-                tcx.provided_method_sources.insert(method.def_id, *source);\n+                let mut provided_method_sources =\n+                    tcx.provided_method_sources.borrow_mut();\n+                provided_method_sources.get().insert(method.def_id, *source);\n             }\n         }\n \n         // Store the implementation info.\n-        tcx.impls.insert(implementation_def_id, implementation);\n+        let mut impls = tcx.impls.borrow_mut();\n+        impls.get().insert(implementation_def_id, implementation);\n     });\n \n-    tcx.populated_external_traits.insert(trait_id);\n+    let mut populated_external_traits = tcx.populated_external_traits\n+                                           .borrow_mut();\n+    populated_external_traits.get().insert(trait_id);\n }\n \n /// Given the def_id of an impl, return the def_id of the trait it implements.\n@@ -4569,7 +4662,12 @@ pub fn trait_of_method(tcx: ctxt, def_id: ast::DefId)\n     if def_id.crate != LOCAL_CRATE {\n         return csearch::get_trait_of_method(tcx.cstore, def_id, tcx);\n     }\n-    match tcx.methods.find(&def_id) {\n+    let method;\n+    {\n+        let methods = tcx.methods.borrow();\n+        method = methods.get().find(&def_id).map(|method| *method);\n+    }\n+    match method {\n         Some(method) => {\n             match method.container {\n                 TraitContainer(def_id) => Some(def_id),\n@@ -4588,10 +4686,15 @@ pub fn trait_of_method(tcx: ctxt, def_id: ast::DefId)\n /// Otherwise, return `None`.\n pub fn trait_method_of_method(tcx: ctxt,\n                               def_id: ast::DefId) -> Option<ast::DefId> {\n-    let name = match tcx.methods.find(&def_id) {\n-        Some(method) => method.ident.name,\n-        None => return None\n-    };\n+    let method;\n+    {\n+        let methods = tcx.methods.borrow();\n+        match methods.get().find(&def_id) {\n+            Some(m) => method = *m,\n+            None => return None,\n+        }\n+    }\n+    let name = method.ident.name;\n     match trait_of_method(tcx, def_id) {\n         Some(trait_did) => {\n             let trait_methods = ty::trait_methods(tcx, trait_did);"}, {"sha": "0da9db5d5c2e3454b7ead9094e916c8df3a26619", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -76,12 +76,10 @@ pub trait AstConv {\n     fn ty_infer(&self, span: Span) -> ty::t;\n }\n \n-pub fn ast_region_to_region(\n-    tcx: ty::ctxt,\n-    lifetime: &ast::Lifetime)\n-    -> ty::Region\n-{\n-    let r = match tcx.named_region_map.find(&lifetime.id) {\n+pub fn ast_region_to_region(tcx: ty::ctxt, lifetime: &ast::Lifetime)\n+                            -> ty::Region {\n+    let named_region_map = tcx.named_region_map.borrow();\n+    let r = match named_region_map.get().find(&lifetime.id) {\n         None => {\n             // should have been recorded by the `resolve_lifetime` pass\n             tcx.sess.span_bug(lifetime.span, \"unresolved lifetime\");\n@@ -321,7 +319,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 // Note that the \"bounds must be empty if path is not a trait\"\n                 // restriction is enforced in the below case for ty_path, which\n                 // will run after this as long as the path isn't a trait.\n-                match tcx.def_map.find(&id) {\n+                let def_map = tcx.def_map.borrow();\n+                match def_map.get().find(&id) {\n                     Some(&ast::DefPrimTy(ast::ty_str)) if a_seq_ty.mutbl == ast::MutImmutable => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                         return ty::mk_estr(tcx, vst);\n@@ -383,16 +382,22 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n \n     let tcx = this.tcx();\n \n-    match tcx.ast_ty_to_ty_cache.find(&ast_ty.id) {\n-      Some(&ty::atttce_resolved(ty)) => return ty,\n-      Some(&ty::atttce_unresolved) => {\n-        tcx.sess.span_fatal(ast_ty.span, \"illegal recursive type; \\\n-                                          insert an enum in the cycle, if this is desired\");\n-      }\n-      None => { /* go on */ }\n+    {\n+        let mut ast_ty_to_ty_cache = tcx.ast_ty_to_ty_cache.borrow_mut();\n+        match ast_ty_to_ty_cache.get().find(&ast_ty.id) {\n+            Some(&ty::atttce_resolved(ty)) => return ty,\n+            Some(&ty::atttce_unresolved) => {\n+                tcx.sess.span_fatal(ast_ty.span,\n+                                    \"illegal recursive type; insert an enum \\\n+                                     or struct in the cycle, if this is \\\n+                                     desired\");\n+            }\n+            None => { /* go on */ }\n+        }\n+        ast_ty_to_ty_cache.get().insert(ast_ty.id, ty::atttce_unresolved);\n     }\n \n-    tcx.ast_ty_to_ty_cache.insert(ast_ty.id, ty::atttce_unresolved);\n+\n     let typ = match ast_ty.node {\n       ast::ty_nil => ty::mk_nil(),\n       ast::ty_bot => ty::mk_bot(),\n@@ -457,7 +462,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n           ty::mk_closure(tcx, fn_decl)\n       }\n       ast::ty_path(ref path, ref bounds, id) => {\n-        let a_def = match tcx.def_map.find(&id) {\n+        let def_map = tcx.def_map.borrow();\n+        let a_def = match def_map.get().find(&id) {\n           None => tcx.sess.span_fatal(\n               ast_ty.span, format!(\"unbound path {}\",\n                                 path_to_str(path, tcx.sess.intr()))),\n@@ -576,7 +582,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n       }\n     };\n \n-    tcx.ast_ty_to_ty_cache.insert(ast_ty.id, ty::atttce_resolved(typ));\n+    let mut ast_ty_to_ty_cache = tcx.ast_ty_to_ty_cache.borrow_mut();\n+    ast_ty_to_ty_cache.get().insert(ast_ty.id, ty::atttce_resolved(typ));\n     return typ;\n }\n "}, {"sha": "739437d278d97474838b470cc32bfc758619cda4", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -25,7 +25,7 @@ use syntax::parse::token;\n use syntax::codemap::Span;\n use syntax::print::pprust;\n \n-pub fn check_match(fcx: @mut FnCtxt,\n+pub fn check_match(fcx: @FnCtxt,\n                    expr: @ast::Expr,\n                    discrim: @ast::Expr,\n                    arms: &[ast::Arm]) {\n@@ -102,7 +102,7 @@ pub fn check_match(fcx: @mut FnCtxt,\n }\n \n pub struct pat_ctxt {\n-    fcx: @mut FnCtxt,\n+    fcx: @FnCtxt,\n     map: PatIdMap,\n }\n \n@@ -357,7 +357,8 @@ pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::NodeId, span: Span,\n     let class_fields = ty::lookup_struct_fields(tcx, struct_id);\n \n     // Check to ensure that the struct is the one specified.\n-    match tcx.def_map.find(&pat_id) {\n+    let def_map = tcx.def_map.borrow();\n+    match def_map.get().find(&pat_id) {\n         Some(&ast::DefStruct(supplied_def_id))\n                 if supplied_def_id == struct_id => {\n             // OK.\n@@ -391,7 +392,8 @@ pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n     let tcx = pcx.fcx.ccx.tcx;\n \n     // Find the variant that was specified.\n-    match tcx.def_map.find(&pat_id) {\n+    let def_map = tcx.def_map.borrow();\n+    match def_map.get().find(&pat_id) {\n         Some(&ast::DefVariant(found_enum_id, variant_id, _))\n                 if found_enum_id == enum_id => {\n             // Get the struct fields from this struct-like enum variant.\n@@ -461,7 +463,9 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n       }\n       ast::PatEnum(..) |\n       ast::PatIdent(..) if pat_is_const(tcx.def_map, pat) => {\n-        let const_did = ast_util::def_id_of_def(tcx.def_map.get_copy(&pat.id));\n+        let def_map = tcx.def_map.borrow();\n+        let const_did = ast_util::def_id_of_def(def_map.get()\n+                                                       .get_copy(&pat.id));\n         let const_tpt = ty::lookup_item_type(tcx, const_did);\n         demand::suptype(fcx, pat.span, expected, const_tpt.ty);\n         fcx.write_ty(pat.id, const_tpt.ty);\n@@ -524,14 +528,15 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n             }\n             _ => {\n                // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n-               fcx.infcx().type_error_message_str_with_expected(pat.span,\n+                fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                                 |expected, actual| {\n                             expected.map_default(~\"\", |e| {\n                                     format!(\"mismatched types: expected `{}` but found {}\",\n                                          e, actual)})},\n                                          Some(expected), ~\"a structure pattern\",\n                                          None);\n-                match tcx.def_map.find(&pat.id) {\n+                let def_map = tcx.def_map.borrow();\n+                match def_map.get().find(&pat.id) {\n                     Some(&ast::DefStruct(supplied_def_id)) => {\n                          check_struct_pat(pcx, pat.id, pat.span, ty::mk_err(), path, *fields, etc,\n                          supplied_def_id,"}, {"sha": "64b08d481e19618d1c248da9538853c04d577d6e", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -20,17 +20,17 @@ use syntax::codemap::Span;\n \n // Requires that the two types unify, and prints an error message if they\n // don't.\n-pub fn suptype(fcx: @mut FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n+pub fn suptype(fcx: @FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n     suptype_with_fn(fcx, sp, false, expected, actual,\n         |sp, e, a, s| { fcx.report_mismatched_types(sp, e, a, s) })\n }\n \n-pub fn subtype(fcx: @mut FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n+pub fn subtype(fcx: @FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n     suptype_with_fn(fcx, sp, true, actual, expected,\n         |sp, a, e, s| { fcx.report_mismatched_types(sp, e, a, s) })\n }\n \n-pub fn suptype_with_fn(fcx: @mut FnCtxt,\n+pub fn suptype_with_fn(fcx: @FnCtxt,\n                        sp: Span,\n                        b_is_expected: bool,\n                        ty_a: ty::t,\n@@ -46,7 +46,7 @@ pub fn suptype_with_fn(fcx: @mut FnCtxt,\n     }\n }\n \n-pub fn eqtype(fcx: @mut FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n+pub fn eqtype(fcx: @FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n     match infer::mk_eqty(fcx.infcx(), false, infer::Misc(sp), actual, expected) {\n         Ok(()) => { /* ok */ }\n         Err(ref err) => {\n@@ -56,10 +56,7 @@ pub fn eqtype(fcx: @mut FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n }\n \n // Checks that the type `actual` can be coerced to `expected`.\n-pub fn coerce(fcx: @mut FnCtxt,\n-              sp: Span,\n-              expected: ty::t,\n-              expr: @ast::Expr) {\n+pub fn coerce(fcx: @FnCtxt, sp: Span, expected: ty::t, expr: @ast::Expr) {\n     let expr_ty = fcx.expr_ty(expr);\n     match fcx.mk_assignty(expr, expr_ty, expected) {\n       result::Ok(()) => { /* ok */ }"}, {"sha": "7fc2798c7aa6c99b5ae9124cafc61a5f06bc6b56", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 52, "deletions": 31, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -95,6 +95,7 @@ use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n use util::common::indenter;\n use util::ppaux::Repr;\n \n+use std::cell::RefCell;\n use std::hashmap::HashSet;\n use std::result;\n use std::vec;\n@@ -118,7 +119,7 @@ pub enum AutoderefReceiverFlag {\n }\n \n pub fn lookup(\n-        fcx: @mut FnCtxt,\n+        fcx: @FnCtxt,\n \n         // In a call `a.b::<X, Y, ...>(...)`:\n         expr: @ast::Expr,                   // The expression `a.b(...)`.\n@@ -132,7 +133,7 @@ pub fn lookup(\n         check_traits: CheckTraitsFlag,      // Whether we check traits only.\n         autoderef_receiver: AutoderefReceiverFlag)\n      -> Option<method_map_entry> {\n-    let impl_dups = @mut HashSet::new();\n+    let impl_dups = @RefCell::new(HashSet::new());\n     let lcx = LookupContext {\n         fcx: fcx,\n         expr: expr,\n@@ -141,8 +142,8 @@ pub fn lookup(\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n         impl_dups: impl_dups,\n-        inherent_candidates: @mut ~[],\n-        extension_candidates: @mut ~[],\n+        inherent_candidates: @RefCell::new(~[]),\n+        extension_candidates: @RefCell::new(~[]),\n         deref_args: deref_args,\n         check_traits: check_traits,\n         autoderef_receiver: autoderef_receiver,\n@@ -168,15 +169,15 @@ pub fn lookup(\n }\n \n pub struct LookupContext<'a> {\n-    fcx: @mut FnCtxt,\n+    fcx: @FnCtxt,\n     expr: @ast::Expr,\n     self_expr: @ast::Expr,\n     callee_id: NodeId,\n     m_name: ast::Name,\n     supplied_tps: &'a [ty::t],\n-    impl_dups: @mut HashSet<DefId>,\n-    inherent_candidates: @mut ~[Candidate],\n-    extension_candidates: @mut ~[Candidate],\n+    impl_dups: @RefCell<HashSet<DefId>>,\n+    inherent_candidates: @RefCell<~[Candidate]>,\n+    extension_candidates: @RefCell<~[Candidate]>,\n     deref_args: check::DerefArgs,\n     check_traits: CheckTraitsFlag,\n     autoderef_receiver: AutoderefReceiverFlag,\n@@ -278,8 +279,8 @@ impl<'a> LookupContext<'a> {\n     // Candidate collection (see comment at start of file)\n \n     fn reset_candidates(&self) {\n-        *self.inherent_candidates = ~[];\n-        *self.extension_candidates = ~[];\n+        self.inherent_candidates.set(~[]);\n+        self.extension_candidates.set(~[]);\n     }\n \n     fn push_inherent_candidates(&self, self_ty: ty::t) {\n@@ -343,20 +344,25 @@ impl<'a> LookupContext<'a> {\n         // If the method being called is associated with a trait, then\n         // find all the impls of that trait.  Each of those are\n         // candidates.\n-        let trait_map: &mut resolve::TraitMap = &mut self.fcx.ccx.trait_map;\n+        let trait_map: &resolve::TraitMap = &self.fcx.ccx.trait_map;\n         let opt_applicable_traits = trait_map.find(&self.expr.id);\n         for applicable_traits in opt_applicable_traits.iter() {\n-            for trait_did in applicable_traits.iter() {\n+            let applicable_traits = applicable_traits.borrow();\n+            for trait_did in applicable_traits.get().iter() {\n                 ty::populate_implementations_for_trait_if_necessary(\n                     self.tcx(),\n                     *trait_did);\n \n                 // Look for explicit implementations.\n-                let opt_impl_infos = self.tcx().trait_impls.find(trait_did);\n+                let trait_impls = self.tcx().trait_impls.borrow();\n+                let opt_impl_infos = trait_impls.get().find(trait_did);\n                 for impl_infos in opt_impl_infos.iter() {\n-                    for impl_info in impl_infos.iter() {\n+                    let impl_infos = impl_infos.borrow();\n+                    for impl_info in impl_infos.get().iter() {\n+                        let mut extension_candidates =\n+                            self.extension_candidates.borrow_mut();\n                         self.push_candidates_from_impl(\n-                            self.extension_candidates, *impl_info);\n+                            extension_candidates.get(), *impl_info);\n \n                     }\n                 }\n@@ -508,7 +514,9 @@ impl<'a> LookupContext<'a> {\n                                        pos, this_bound_idx);\n \n                     debug!(\"pushing inherent candidate for param: {:?}\", cand);\n-                    self.inherent_candidates.push(cand);\n+                    let mut inherent_candidates = self.inherent_candidates\n+                                                      .borrow_mut();\n+                    inherent_candidates.get().push(cand);\n                 }\n                 None => {\n                     debug!(\"trait doesn't contain method: {:?}\",\n@@ -526,20 +534,27 @@ impl<'a> LookupContext<'a> {\n         // metadata if necessary.\n         ty::populate_implementations_for_type_if_necessary(self.tcx(), did);\n \n-        let opt_impl_infos = self.tcx().inherent_impls.find(&did);\n+        let inherent_impls = self.tcx().inherent_impls.borrow();\n+        let opt_impl_infos = inherent_impls.get().find(&did);\n         for impl_infos in opt_impl_infos.iter() {\n-            for impl_info in impl_infos.iter() {\n-                self.push_candidates_from_impl(\n-                    self.inherent_candidates, *impl_info);\n+            let impl_infos = impl_infos.borrow();\n+            for impl_info in impl_infos.get().iter() {\n+                let mut inherent_candidates = self.inherent_candidates\n+                                                  .borrow_mut();\n+                self.push_candidates_from_impl(inherent_candidates.get(),\n+                                               *impl_info);\n             }\n         }\n     }\n \n     fn push_candidates_from_impl(&self,\n                                      candidates: &mut ~[Candidate],\n                                      impl_info: &ty::Impl) {\n-        if !self.impl_dups.insert(impl_info.did) {\n-            return; // already visited\n+        {\n+            let mut impl_dups = self.impl_dups.borrow_mut();\n+            if !impl_dups.get().insert(impl_info.did) {\n+                return; // already visited\n+            }\n         }\n         debug!(\"push_candidates_from_impl: {} {} {}\",\n                token::interner_get(self.m_name),\n@@ -821,15 +836,17 @@ impl<'a> LookupContext<'a> {\n         // existing code.\n \n         debug!(\"searching inherent candidates\");\n-        match self.consider_candidates(rcvr_ty, self.inherent_candidates) {\n+        let mut inherent_candidates = self.inherent_candidates.borrow_mut();\n+        match self.consider_candidates(rcvr_ty, inherent_candidates.get()) {\n             None => {}\n             Some(mme) => {\n                 return Some(mme);\n             }\n         }\n \n         debug!(\"searching extension candidates\");\n-        match self.consider_candidates(rcvr_ty, self.extension_candidates) {\n+        let mut extension_candidates = self.extension_candidates.borrow_mut();\n+        match self.consider_candidates(rcvr_ty, extension_candidates.get()) {\n             None => {\n                 return None;\n             }\n@@ -840,9 +857,9 @@ impl<'a> LookupContext<'a> {\n     }\n \n     fn consider_candidates(&self,\n-                               rcvr_ty: ty::t,\n-                               candidates: &mut ~[Candidate])\n-                               -> Option<method_map_entry> {\n+                           rcvr_ty: ty::t,\n+                           candidates: &mut ~[Candidate])\n+                           -> Option<method_map_entry> {\n         // XXX(pcwalton): Do we need to clone here?\n         let relevant_candidates: ~[Candidate] =\n             candidates.iter().map(|c| (*c).clone()).\n@@ -1151,13 +1168,17 @@ impl<'a> LookupContext<'a> {\n         let bad;\n         match candidate.origin {\n             method_static(method_id) => {\n-                bad = self.tcx().destructors.contains(&method_id);\n+                let destructors = self.tcx().destructors.borrow();\n+                bad = destructors.get().contains(&method_id);\n             }\n             // XXX: does this properly enforce this on everything now\n             // that self has been merged in? -sully\n             method_param(method_param { trait_id: trait_id, .. }) |\n             method_object(method_object { trait_id: trait_id, .. }) => {\n-                bad = self.tcx().destructor_for_type.contains_key(&trait_id);\n+                let destructor_for_type = self.tcx()\n+                                              .destructor_for_type\n+                                              .borrow();\n+                bad = destructor_for_type.get().contains_key(&trait_id);\n             }\n         }\n \n@@ -1245,7 +1266,7 @@ impl<'a> LookupContext<'a> {\n             }\n         }\n \n-        fn rcvr_matches_ty(fcx: @mut FnCtxt,\n+        fn rcvr_matches_ty(fcx: @FnCtxt,\n                            rcvr_ty: ty::t,\n                            candidate: &Candidate) -> bool {\n             match candidate.rcvr_match_condition {\n@@ -1320,7 +1341,7 @@ impl<'a> LookupContext<'a> {\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    fn infcx(&self) -> @mut infer::InferCtxt {\n+    fn infcx(&self) -> @infer::InferCtxt {\n         self.fcx.inh.infcx\n     }\n "}, {"sha": "74575ba3517fe6ac671a23be5a2c64d0d2e0c4c3", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 167, "deletions": 131, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -110,6 +110,7 @@ use util::common::{block_query, indenter, loop_query};\n use util::ppaux::UserString;\n use util::ppaux;\n \n+use std::cell::{Cell, RefCell};\n use std::hashmap::HashMap;\n use std::result;\n use std::util::replace;\n@@ -156,14 +157,14 @@ pub struct SelfInfo {\n /// `bar()` will each have their own `FnCtxt`, but they will\n /// share the inherited fields.\n pub struct Inherited {\n-    infcx: @mut infer::InferCtxt,\n-    locals: @mut HashMap<ast::NodeId, ty::t>,\n+    infcx: @infer::InferCtxt,\n+    locals: @RefCell<HashMap<ast::NodeId, ty::t>>,\n     param_env: ty::ParameterEnvironment,\n \n     // Temporary tables:\n-    node_types: @mut HashMap<ast::NodeId, ty::t>,\n-    node_type_substs: @mut HashMap<ast::NodeId, ty::substs>,\n-    adjustments: @mut HashMap<ast::NodeId, @ty::AutoAdjustment>,\n+    node_types: RefCell<HashMap<ast::NodeId, ty::t>>,\n+    node_type_substs: RefCell<HashMap<ast::NodeId, ty::substs>>,\n+    adjustments: RefCell<HashMap<ast::NodeId, @ty::AutoAdjustment>>,\n     method_map: method_map,\n     vtable_map: vtable_map,\n }\n@@ -226,7 +227,7 @@ pub struct FnCtxt {\n     err_count_on_creation: uint,\n \n     ret_ty: ty::t,\n-    ps: PurityState,\n+    ps: RefCell<PurityState>,\n \n     // Sometimes we generate region pointers where the precise region\n     // to use is not known. For example, an expression like `&x.f`\n@@ -241,7 +242,7 @@ pub struct FnCtxt {\n     // inference selects the ultimate value.  Finally, borrowck is\n     // charged with guaranteeing that the value whose address was taken\n     // can actually be made to live as long as it needs to live.\n-    region_lb: ast::NodeId,\n+    region_lb: Cell<ast::NodeId>,\n \n     // Says whether we're inside a for loop, in a do block\n     // or neither. Helps with error messages involving the\n@@ -250,7 +251,7 @@ pub struct FnCtxt {\n \n     inh: @Inherited,\n \n-    ccx: @mut CrateCtxt,\n+    ccx: @CrateCtxt,\n }\n \n impl Inherited {\n@@ -259,32 +260,32 @@ impl Inherited {\n            -> Inherited {\n         Inherited {\n             infcx: infer::new_infer_ctxt(tcx),\n-            locals: @mut HashMap::new(),\n+            locals: @RefCell::new(HashMap::new()),\n             param_env: param_env,\n-            node_types: @mut HashMap::new(),\n-            node_type_substs: @mut HashMap::new(),\n-            adjustments: @mut HashMap::new(),\n-            method_map: @mut HashMap::new(),\n-            vtable_map: @mut HashMap::new(),\n+            node_types: RefCell::new(HashMap::new()),\n+            node_type_substs: RefCell::new(HashMap::new()),\n+            adjustments: RefCell::new(HashMap::new()),\n+            method_map: @RefCell::new(HashMap::new()),\n+            vtable_map: @RefCell::new(HashMap::new()),\n         }\n     }\n }\n \n // Used by check_const and check_enum_variants\n-pub fn blank_fn_ctxt(ccx: @mut CrateCtxt,\n+pub fn blank_fn_ctxt(ccx: @CrateCtxt,\n                      rty: ty::t,\n                      region_bnd: ast::NodeId)\n-                     -> @mut FnCtxt {\n+                     -> @FnCtxt {\n     // It's kind of a kludge to manufacture a fake function context\n     // and statement context, but we might as well do write the code only once\n     let param_env = ty::ParameterEnvironment { free_substs: substs::empty(),\n                                                self_param_bound: None,\n                                                type_param_bounds: ~[] };\n-    @mut FnCtxt {\n+    @FnCtxt {\n         err_count_on_creation: ccx.tcx.sess.err_count(),\n         ret_ty: rty,\n-        ps: PurityState::function(ast::impure_fn, 0),\n-        region_lb: region_bnd,\n+        ps: RefCell::new(PurityState::function(ast::impure_fn, 0)),\n+        region_lb: Cell::new(region_bnd),\n         fn_kind: Vanilla,\n         inh: @Inherited::new(ccx.tcx, param_env),\n         ccx: ccx\n@@ -301,7 +302,7 @@ impl ExprTyProvider for FnCtxt {\n     }\n }\n \n-struct CheckItemTypesVisitor { ccx: @mut CrateCtxt }\n+struct CheckItemTypesVisitor { ccx: @CrateCtxt }\n \n impl Visitor<()> for CheckItemTypesVisitor {\n     fn visit_item(&mut self, i:@ast::item, _:()) {\n@@ -310,12 +311,12 @@ impl Visitor<()> for CheckItemTypesVisitor {\n     }\n }\n \n-pub fn check_item_types(ccx: @mut CrateCtxt, crate: &ast::Crate) {\n+pub fn check_item_types(ccx: @CrateCtxt, crate: &ast::Crate) {\n     let mut visit = CheckItemTypesVisitor { ccx: ccx };\n     visit::walk_crate(&mut visit, crate, ());\n }\n \n-pub fn check_bare_fn(ccx: @mut CrateCtxt,\n+pub fn check_bare_fn(ccx: @CrateCtxt,\n                      decl: &ast::fn_decl,\n                      body: ast::P<ast::Block>,\n                      id: ast::NodeId,\n@@ -339,7 +340,7 @@ pub fn check_bare_fn(ccx: @mut CrateCtxt,\n }\n \n struct GatherLocalsVisitor {\n-                     fcx: @mut FnCtxt,\n+                     fcx: @FnCtxt,\n                      tcx: ty::ctxt,\n }\n \n@@ -350,11 +351,13 @@ impl GatherLocalsVisitor {\n                     // infer the variable's type\n                     let var_id = self.fcx.infcx().next_ty_var_id();\n                     let var_ty = ty::mk_var(self.fcx.tcx(), var_id);\n-                    self.fcx.inh.locals.insert(nid, var_ty);\n+                    let mut locals = self.fcx.inh.locals.borrow_mut();\n+                    locals.get().insert(nid, var_ty);\n                 }\n                 Some(typ) => {\n                     // take type that the user specified\n-                    self.fcx.inh.locals.insert(nid, typ);\n+                    let mut locals = self.fcx.inh.locals.borrow_mut();\n+                    locals.get().insert(nid, typ);\n                 }\n             }\n     }\n@@ -368,10 +371,13 @@ impl Visitor<()> for GatherLocalsVisitor {\n               _ => Some(self.fcx.to_ty(local.ty))\n             };\n             self.assign(local.id, o_ty);\n-            debug!(\"Local variable {} is assigned type {}\",\n-                   self.fcx.pat_to_str(local.pat),\n-                   self.fcx.infcx().ty_to_str(\n-                       self.fcx.inh.locals.get_copy(&local.id)));\n+            {\n+                let locals = self.fcx.inh.locals.borrow();\n+                debug!(\"Local variable {} is assigned type {}\",\n+                       self.fcx.pat_to_str(local.pat),\n+                       self.fcx.infcx().ty_to_str(\n+                           locals.get().get_copy(&local.id)));\n+            }\n             visit::walk_local(self, local, ());\n \n     }\n@@ -381,10 +387,13 @@ impl Visitor<()> for GatherLocalsVisitor {\n               ast::PatIdent(_, ref path, _)\n                   if pat_util::pat_is_binding(self.fcx.ccx.tcx.def_map, p) => {\n                 self.assign(p.id, None);\n-                debug!(\"Pattern binding {} is assigned to {}\",\n-                       self.tcx.sess.str_of(path.segments[0].identifier),\n-                       self.fcx.infcx().ty_to_str(\n-                           self.fcx.inh.locals.get_copy(&p.id)));\n+                {\n+                    let locals = self.fcx.inh.locals.borrow();\n+                    debug!(\"Pattern binding {} is assigned to {}\",\n+                           self.tcx.sess.str_of(path.segments[0].identifier),\n+                           self.fcx.infcx().ty_to_str(\n+                               locals.get().get_copy(&p.id)));\n+                }\n               }\n               _ => {}\n             }\n@@ -406,15 +415,15 @@ impl Visitor<()> for GatherLocalsVisitor {\n \n }\n \n-pub fn check_fn(ccx: @mut CrateCtxt,\n+pub fn check_fn(ccx: @CrateCtxt,\n                 opt_self_info: Option<SelfInfo>,\n                 purity: ast::purity,\n                 fn_sig: &ty::FnSig,\n                 decl: &ast::fn_decl,\n                 id: ast::NodeId,\n                 body: ast::P<ast::Block>,\n                 fn_kind: FnKind,\n-                inherited: @Inherited) -> @mut FnCtxt\n+                inherited: @Inherited) -> @FnCtxt\n {\n     /*!\n      * Helper used by check_bare_fn and check_expr_fn.  Does the\n@@ -457,12 +466,12 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n \n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n-    let fcx: @mut FnCtxt = {\n-        @mut FnCtxt {\n+    let fcx: @FnCtxt = {\n+        @FnCtxt {\n             err_count_on_creation: err_count_on_creation,\n             ret_ty: ret_ty,\n-            ps: PurityState::function(purity, id),\n-            region_lb: body.id,\n+            ps: RefCell::new(PurityState::function(purity, id)),\n+            region_lb: Cell::new(body.id),\n             fn_kind: fn_kind,\n             inh: inherited,\n             ccx: ccx\n@@ -496,7 +505,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n \n     return fcx;\n \n-    fn gather_locals(fcx: @mut FnCtxt,\n+    fn gather_locals(fcx: @FnCtxt,\n                      decl: &ast::fn_decl,\n                      body: ast::P<ast::Block>,\n                      arg_tys: &[ty::t],\n@@ -508,9 +517,10 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         // Add the self parameter\n         for self_info in opt_self_info.iter() {\n             visit.assign(self_info.self_id, Some(self_info.self_ty));\n+            let locals = fcx.inh.locals.borrow();\n             debug!(\"self is assigned to {}\",\n                    fcx.infcx().ty_to_str(\n-                       fcx.inh.locals.get_copy(&self_info.self_id)));\n+                       locals.get().get_copy(&self_info.self_id)));\n         }\n \n         // Add formal parameters.\n@@ -555,7 +565,7 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n     }\n }\n \n-pub fn check_struct(ccx: @mut CrateCtxt, id: ast::NodeId, span: Span) {\n+pub fn check_struct(ccx: @CrateCtxt, id: ast::NodeId, span: Span) {\n     let tcx = ccx.tcx;\n \n     // Check that the class is instantiable\n@@ -566,7 +576,7 @@ pub fn check_struct(ccx: @mut CrateCtxt, id: ast::NodeId, span: Span) {\n     }\n }\n \n-pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n+pub fn check_item(ccx: @CrateCtxt, it: @ast::item) {\n     debug!(\"check_item(it.id={}, it.ident={})\",\n            it.id,\n            ty::item_path_str(ccx.tcx, local_def(it.id)));\n@@ -669,7 +679,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n     }\n }\n \n-fn check_method_body(ccx: @mut CrateCtxt,\n+fn check_method_body(ccx: @CrateCtxt,\n                      item_generics: &ty::Generics,\n                      self_bound: Option<@ty::TraitRef>,\n                      method: @ast::method) {\n@@ -721,7 +731,7 @@ fn check_method_body(ccx: @mut CrateCtxt,\n         param_env);\n }\n \n-fn check_impl_methods_against_trait(ccx: @mut CrateCtxt,\n+fn check_impl_methods_against_trait(ccx: @CrateCtxt,\n                                     impl_span: Span,\n                                     impl_generics: &ty::Generics,\n                                     ast_trait_ref: &ast::trait_ref,\n@@ -1044,7 +1054,7 @@ impl AstConv for FnCtxt {\n }\n \n impl FnCtxt {\n-    pub fn infcx(&self) -> @mut infer::InferCtxt {\n+    pub fn infcx(&self) -> @infer::InferCtxt {\n         self.inh.infcx\n     }\n \n@@ -1060,7 +1070,7 @@ impl FnCtxt {\n     }\n }\n \n-impl RegionScope for @mut infer::InferCtxt {\n+impl RegionScope for @infer::InferCtxt {\n     fn anon_regions(&self,\n                     span: Span,\n                     count: uint) -> Result<~[ty::Region], ()> {\n@@ -1078,7 +1088,8 @@ impl FnCtxt {\n     }\n \n     pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> ty::t {\n-        match self.inh.locals.find(&nid) {\n+        let locals = self.inh.locals.borrow();\n+        match locals.get().find(&nid) {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.span_bug(\n@@ -1089,14 +1100,15 @@ impl FnCtxt {\n     }\n \n     pub fn block_region(&self) -> ty::Region {\n-        ty::ReScope(self.region_lb)\n+        ty::ReScope(self.region_lb.get())\n     }\n \n     #[inline]\n     pub fn write_ty(&self, node_id: ast::NodeId, ty: ty::t) {\n         debug!(\"write_ty({}, {}) in fcx {}\",\n                node_id, ppaux::ty_to_str(self.tcx(), ty), self.tag());\n-        self.inh.node_types.insert(node_id, ty);\n+        let mut node_types = self.inh.node_types.borrow_mut();\n+        node_types.get().insert(node_id, ty);\n     }\n \n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::substs) {\n@@ -1105,7 +1117,9 @@ impl FnCtxt {\n                    node_id,\n                    ty::substs_to_str(self.tcx(), &substs),\n                    self.tag());\n-            self.inh.node_type_substs.insert(node_id, substs);\n+\n+            let mut node_type_substs = self.inh.node_type_substs.borrow_mut();\n+            node_type_substs.get().insert(node_id, substs);\n         }\n     }\n \n@@ -1134,7 +1148,8 @@ impl FnCtxt {\n                             node_id: ast::NodeId,\n                             adj: @ty::AutoAdjustment) {\n         debug!(\"write_adjustment(node_id={:?}, adj={:?})\", node_id, adj);\n-        self.inh.adjustments.insert(node_id, adj);\n+        let mut adjustments = self.inh.adjustments.borrow_mut();\n+        adjustments.get().insert(node_id, adj);\n     }\n \n     pub fn write_nil(&self, node_id: ast::NodeId) {\n@@ -1143,7 +1158,7 @@ impl FnCtxt {\n     pub fn write_bot(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, ty::mk_bot());\n     }\n-    pub fn write_error(@mut self, node_id: ast::NodeId) {\n+    pub fn write_error(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, ty::mk_err());\n     }\n \n@@ -1156,7 +1171,8 @@ impl FnCtxt {\n     }\n \n     pub fn expr_ty(&self, ex: &ast::Expr) -> ty::t {\n-        match self.inh.node_types.find(&ex.id) {\n+        let node_types = self.inh.node_types.borrow();\n+        match node_types.get().find(&ex.id) {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(format!(\"no type for expr in fcx {}\",\n@@ -1166,7 +1182,8 @@ impl FnCtxt {\n     }\n \n     pub fn node_ty(&self, id: ast::NodeId) -> ty::t {\n-        match self.inh.node_types.find(&id) {\n+        let node_types = self.inh.node_types.borrow();\n+        match node_types.get().find(&id) {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(\n@@ -1180,7 +1197,8 @@ impl FnCtxt {\n     }\n \n     pub fn node_ty_substs(&self, id: ast::NodeId) -> ty::substs {\n-        match self.inh.node_type_substs.find(&id) {\n+        let mut node_type_substs = self.inh.node_type_substs.borrow_mut();\n+        match node_type_substs.get().find(&id) {\n             Some(ts) => (*ts).clone(),\n             None => {\n                 self.tcx().sess.bug(\n@@ -1196,7 +1214,8 @@ impl FnCtxt {\n                               id: ast::NodeId,\n                               f: |&ty::substs| -> bool)\n                               -> bool {\n-        match self.inh.node_type_substs.find(&id) {\n+        let node_type_substs = self.inh.node_type_substs.borrow();\n+        match node_type_substs.get().find(&id) {\n             Some(s) => f(s),\n             None => true\n         }\n@@ -1257,11 +1276,11 @@ impl FnCtxt {\n         infer::mk_subr(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n-    pub fn with_region_lb<R>(@mut self, lb: ast::NodeId, f: || -> R) -> R {\n-        let old_region_lb = self.region_lb;\n-        self.region_lb = lb;\n+    pub fn with_region_lb<R>(&self, lb: ast::NodeId, f: || -> R) -> R {\n+        let old_region_lb = self.region_lb.get();\n+        self.region_lb.set(lb);\n         let v = f();\n-        self.region_lb = old_region_lb;\n+        self.region_lb.set(old_region_lb);\n         v\n     }\n \n@@ -1294,7 +1313,7 @@ impl FnCtxt {\n     }\n }\n \n-pub fn do_autoderef(fcx: @mut FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n+pub fn do_autoderef(fcx: @FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n     /*!\n      *\n      * Autoderefs the type `t` as many times as possible, returning\n@@ -1351,7 +1370,7 @@ pub fn do_autoderef(fcx: @mut FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n }\n \n // AST fragment checking\n-pub fn check_lit(fcx: @mut FnCtxt, lit: @ast::lit) -> ty::t {\n+pub fn check_lit(fcx: @FnCtxt, lit: @ast::lit) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n@@ -1379,7 +1398,7 @@ pub fn check_lit(fcx: @mut FnCtxt, lit: @ast::lit) -> ty::t {\n     }\n }\n \n-pub fn valid_range_bounds(ccx: @mut CrateCtxt,\n+pub fn valid_range_bounds(ccx: @CrateCtxt,\n                           from: @ast::Expr,\n                           to: @ast::Expr)\n                        -> Option<bool> {\n@@ -1390,34 +1409,34 @@ pub fn valid_range_bounds(ccx: @mut CrateCtxt,\n }\n \n pub fn check_expr_has_type(\n-    fcx: @mut FnCtxt, expr: @ast::Expr,\n+    fcx: @FnCtxt, expr: @ast::Expr,\n     expected: ty::t) {\n     check_expr_with_unifier(fcx, expr, Some(expected), || {\n         demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr));\n     });\n }\n \n pub fn check_expr_coercable_to_type(\n-    fcx: @mut FnCtxt, expr: @ast::Expr,\n+    fcx: @FnCtxt, expr: @ast::Expr,\n     expected: ty::t) {\n     check_expr_with_unifier(fcx, expr, Some(expected), || {\n         demand::coerce(fcx, expr.span, expected, expr)\n     });\n }\n \n pub fn check_expr_with_hint(\n-    fcx: @mut FnCtxt, expr: @ast::Expr,\n+    fcx: @FnCtxt, expr: @ast::Expr,\n     expected: ty::t) {\n     check_expr_with_unifier(fcx, expr, Some(expected), || ())\n }\n \n pub fn check_expr_with_opt_hint(\n-    fcx: @mut FnCtxt, expr: @ast::Expr,\n+    fcx: @FnCtxt, expr: @ast::Expr,\n     expected: Option<ty::t>)  {\n     check_expr_with_unifier(fcx, expr, expected, || ())\n }\n \n-pub fn check_expr(fcx: @mut FnCtxt, expr: @ast::Expr)  {\n+pub fn check_expr(fcx: @FnCtxt, expr: @ast::Expr)  {\n     check_expr_with_unifier(fcx, expr, None, || ())\n }\n \n@@ -1489,7 +1508,7 @@ fn generics_of_static_method_container(type_context: ty::ctxt,\n \n // Verifies that type parameters supplied in paths are in the right\n // locations.\n-fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n+fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n                                           path: &ast::Path,\n                                           def: ast::Def) {\n     // We only care about checking the case in which the path has two or\n@@ -1623,14 +1642,14 @@ fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n /// Note that inspecting a type's structure *directly* may expose the fact\n /// that there are actually multiple representations for both `ty_err` and\n /// `ty_bot`, so avoid that when err and bot need to be handled differently.\n-pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n+pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                                expr: @ast::Expr,\n                                expected: Option<ty::t>,\n                                unifier: ||) {\n     debug!(\">> typechecking\");\n \n     fn check_method_argument_types(\n-        fcx: @mut FnCtxt,\n+        fcx: @FnCtxt,\n         sp: Span,\n         method_fn_ty: ty::t,\n         callee_expr: @ast::Expr,\n@@ -1659,7 +1678,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n     }\n \n-    fn check_argument_types(fcx: @mut FnCtxt,\n+    fn check_argument_types(fcx: @FnCtxt,\n                             sp: Span,\n                             fn_inputs: &[ty::t],\n                             callee_expr: @ast::Expr,\n@@ -1809,7 +1828,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     // A generic function for checking assignment expressions\n-    fn check_assignment(fcx: @mut FnCtxt,\n+    fn check_assignment(fcx: @FnCtxt,\n                         lhs: @ast::Expr,\n                         rhs: @ast::Expr,\n                         id: ast::NodeId) {\n@@ -1820,7 +1839,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // The callee checks for bot / err, we don't need to\n     }\n \n-    fn write_call(fcx: @mut FnCtxt,\n+    fn write_call(fcx: @FnCtxt,\n                   call_expr: @ast::Expr,\n                   output: ty::t,\n                   sugar: ast::CallSugar) {\n@@ -1841,7 +1860,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     // A generic function for doing all of the checking for call expressions\n-    fn check_call(fcx: @mut FnCtxt,\n+    fn check_call(fcx: @FnCtxt,\n                   callee_id: ast::NodeId,\n                   call_expr: @ast::Expr,\n                   f: @ast::Expr,\n@@ -1903,7 +1922,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     // Checks a method call.\n-    fn check_method_call(fcx: @mut FnCtxt,\n+    fn check_method_call(fcx: @FnCtxt,\n                          callee_id: ast::NodeId,\n                          expr: @ast::Expr,\n                          rcvr: @ast::Expr,\n@@ -1931,7 +1950,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                              AutoderefReceiver) {\n             Some(ref entry) => {\n                 let method_map = fcx.inh.method_map;\n-                method_map.insert(expr.id, (*entry));\n+                let mut method_map = method_map.borrow_mut();\n+                method_map.get().insert(expr.id, (*entry));\n             }\n             None => {\n                 debug!(\"(checking method call) failing expr is {}\", expr.id);\n@@ -1963,7 +1983,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n     // A generic function for checking the then and else in an if\n     // or if-check\n-    fn check_then_else(fcx: @mut FnCtxt,\n+    fn check_then_else(fcx: @FnCtxt,\n                        cond_expr: @ast::Expr,\n                        then_blk: &ast::Block,\n                        opt_else_expr: Option<@ast::Expr>,\n@@ -2002,7 +2022,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_ty(id, if_ty);\n     }\n \n-    fn lookup_op_method(fcx: @mut FnCtxt,\n+    fn lookup_op_method(fcx: @FnCtxt,\n                         callee_id: ast::NodeId,\n                         op_ex: @ast::Expr,\n                         self_ex: @ast::Expr,\n@@ -2021,7 +2041,10 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             Some(ref origin) => {\n                 let method_ty = fcx.node_ty(callee_id);\n                 let method_map = fcx.inh.method_map;\n-                method_map.insert(op_ex.id, *origin);\n+                {\n+                    let mut method_map = method_map.borrow_mut();\n+                    method_map.get().insert(op_ex.id, *origin);\n+                }\n                 check_method_argument_types(fcx, op_ex.span,\n                                             method_ty, op_ex, args,\n                                             ast::NoSugar, deref_args)\n@@ -2040,7 +2063,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     // could be either a expr_binop or an expr_assign_binop\n-    fn check_binop(fcx: @mut FnCtxt,\n+    fn check_binop(fcx: @FnCtxt,\n                    callee_id: ast::NodeId,\n                    expr: @ast::Expr,\n                    op: ast::BinOp,\n@@ -2128,7 +2151,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n     }\n \n-    fn check_user_binop(fcx: @mut FnCtxt,\n+    fn check_user_binop(fcx: @FnCtxt,\n                         callee_id: ast::NodeId,\n                         ex: @ast::Expr,\n                         lhs_expr: @ast::Expr,\n@@ -2170,7 +2193,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         ty::mk_err()\n     }\n \n-    fn check_user_unop(fcx: @mut FnCtxt,\n+    fn check_user_unop(fcx: @FnCtxt,\n                        callee_id: ast::NodeId,\n                        op_str: &str,\n                        mname: &str,\n@@ -2196,7 +2219,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     // resolution is not possible (e.g., no constraints yet present), just\n     // returns `none`.\n     fn unpack_expected<O>(\n-                       fcx: @mut FnCtxt,\n+                       fcx: @FnCtxt,\n                        expected: Option<ty::t>,\n                        unpack: |&ty::sty| -> Option<O>)\n                        -> Option<O> {\n@@ -2211,7 +2234,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n     }\n \n-    fn check_expr_fn(fcx: @mut FnCtxt,\n+    fn check_expr_fn(fcx: @FnCtxt,\n                      expr: @ast::Expr,\n                      ast_sigil_opt: Option<ast::Sigil>,\n                      decl: &ast::fn_decl,\n@@ -2306,7 +2329,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_ty(expr.id, fty);\n \n         let (inherited_purity, id) =\n-            ty::determine_inherited_purity((fcx.ps.purity, fcx.ps.def),\n+            ty::determine_inherited_purity((fcx.ps.get().purity,\n+                                            fcx.ps.get().def),\n                                            (purity, expr.id),\n                                            sigil);\n \n@@ -2316,7 +2340,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n \n     // Check field access expressions\n-    fn check_field(fcx: @mut FnCtxt,\n+    fn check_field(fcx: @FnCtxt,\n                    expr: @ast::Expr,\n                    base: @ast::Expr,\n                    field: ast::Name,\n@@ -2387,7 +2411,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_error(expr.id);\n     }\n \n-    fn check_struct_or_variant_fields(fcx: @mut FnCtxt,\n+    fn check_struct_or_variant_fields(fcx: @FnCtxt,\n                                       struct_ty: ty::t,\n                                       span: Span,\n                                       class_id: ast::DefId,\n@@ -2480,7 +2504,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n     }\n \n-    fn check_struct_constructor(fcx: @mut FnCtxt,\n+    fn check_struct_constructor(fcx: @FnCtxt,\n                                 id: ast::NodeId,\n                                 span: codemap::Span,\n                                 class_id: ast::DefId,\n@@ -2538,7 +2562,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_ty(id, struct_type);\n     }\n \n-    fn check_struct_enum_variant(fcx: @mut FnCtxt,\n+    fn check_struct_enum_variant(fcx: @FnCtxt,\n                                  id: ast::NodeId,\n                                  span: codemap::Span,\n                                  enum_id: ast::DefId,\n@@ -3069,7 +3093,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                 _ => false\n                             }\n                         }\n-                        fn types_compatible(fcx: @mut FnCtxt, sp: Span,\n+                        fn types_compatible(fcx: @FnCtxt, sp: Span,\n                                             t1: ty::t, t2: ty::t) -> bool {\n                             if !is_vec(t1) {\n                                 false\n@@ -3176,7 +3200,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n       }\n       ast::ExprStruct(ref path, ref fields, base_expr) => {\n         // Resolve the path.\n-        match tcx.def_map.find(&id) {\n+        let def_map = tcx.def_map.borrow();\n+        match def_map.get().find(&id) {\n             Some(&ast::DefStruct(type_def_id)) => {\n                 check_struct_constructor(fcx, id, expr.span, type_def_id,\n                                          *fields, base_expr);\n@@ -3257,7 +3282,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     unifier();\n }\n \n-pub fn require_integral(fcx: @mut FnCtxt, sp: Span, t: ty::t) {\n+pub fn require_integral(fcx: @FnCtxt, sp: Span, t: ty::t) {\n     if !type_is_integral(fcx, sp, t) {\n         fcx.type_error_message(sp, |actual| {\n             format!(\"mismatched types: expected integral type but found `{}`\",\n@@ -3266,15 +3291,15 @@ pub fn require_integral(fcx: @mut FnCtxt, sp: Span, t: ty::t) {\n     }\n }\n \n-pub fn check_decl_initializer(fcx: @mut FnCtxt,\n+pub fn check_decl_initializer(fcx: @FnCtxt,\n                               nid: ast::NodeId,\n                               init: @ast::Expr)\n                             {\n     let local_ty = fcx.local_ty(init.span, nid);\n     check_expr_coercable_to_type(fcx, init, local_ty)\n }\n \n-pub fn check_decl_local(fcx: @mut FnCtxt, local: @ast::Local)  {\n+pub fn check_decl_local(fcx: @FnCtxt, local: @ast::Local)  {\n     let tcx = fcx.ccx.tcx;\n \n     let t = fcx.local_ty(local.span, local.id);\n@@ -3302,7 +3327,7 @@ pub fn check_decl_local(fcx: @mut FnCtxt, local: @ast::Local)  {\n     }\n }\n \n-pub fn check_stmt(fcx: @mut FnCtxt, stmt: @ast::Stmt)  {\n+pub fn check_stmt(fcx: @FnCtxt, stmt: @ast::Stmt)  {\n     let node_id;\n     let mut saw_bot = false;\n     let mut saw_err = false;\n@@ -3347,7 +3372,7 @@ pub fn check_stmt(fcx: @mut FnCtxt, stmt: @ast::Stmt)  {\n     }\n }\n \n-pub fn check_block_no_value(fcx: @mut FnCtxt, blk: &ast::Block)  {\n+pub fn check_block_no_value(fcx: @FnCtxt, blk: &ast::Block)  {\n     check_block_with_expected(fcx, blk, Some(ty::mk_nil()));\n     let blkty = fcx.node_ty(blk.id);\n     if ty::type_is_error(blkty) {\n@@ -3362,15 +3387,18 @@ pub fn check_block_no_value(fcx: @mut FnCtxt, blk: &ast::Block)  {\n     }\n }\n \n-pub fn check_block(fcx0: @mut FnCtxt, blk: &ast::Block)  {\n+pub fn check_block(fcx0: @FnCtxt, blk: &ast::Block)  {\n     check_block_with_expected(fcx0, blk, None)\n }\n \n-pub fn check_block_with_expected(fcx: @mut FnCtxt,\n+pub fn check_block_with_expected(fcx: @FnCtxt,\n                                  blk: &ast::Block,\n                                  expected: Option<ty::t>) {\n-    let purity_state = fcx.ps.recurse(blk);\n-    let prev = replace(&mut fcx.ps, purity_state);\n+    let prev = {\n+        let mut fcx_ps = fcx.ps.borrow_mut();\n+        let purity_state = fcx_ps.get().recurse(blk);\n+        replace(fcx_ps.get(), purity_state)\n+    };\n \n     fcx.with_region_lb(blk.id, || {\n         let mut warned = false;\n@@ -3427,20 +3455,23 @@ pub fn check_block_with_expected(fcx: @mut FnCtxt,\n         };\n     });\n \n-    fcx.ps = prev;\n+    fcx.ps.set(prev);\n }\n \n-pub fn check_const(ccx: @mut CrateCtxt,\n+pub fn check_const(ccx: @CrateCtxt,\n                    sp: Span,\n                    e: @ast::Expr,\n                    id: ast::NodeId) {\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx = blank_fn_ctxt(ccx, rty, e.id);\n-    let declty = fcx.ccx.tcx.tcache.get(&local_def(id)).ty;\n+    let declty = {\n+        let tcache = fcx.ccx.tcx.tcache.borrow();\n+        tcache.get().get(&local_def(id)).ty\n+    };\n     check_const_with_ty(fcx, sp, e, declty);\n }\n \n-pub fn check_const_with_ty(fcx: @mut FnCtxt,\n+pub fn check_const_with_ty(fcx: @FnCtxt,\n                            _: Span,\n                            e: @ast::Expr,\n                            declty: ty::t) {\n@@ -3503,15 +3534,15 @@ pub fn check_simd(tcx: ty::ctxt, sp: Span, id: ast::NodeId) {\n     }\n }\n \n-pub fn check_enum_variants(ccx: @mut CrateCtxt,\n+pub fn check_enum_variants(ccx: @CrateCtxt,\n                            sp: Span,\n                            vs: &[ast::P<ast::variant>],\n                            id: ast::NodeId) {\n \n-    fn disr_in_range(ccx: @mut CrateCtxt,\n+    fn disr_in_range(ccx: @CrateCtxt,\n                      ty: attr::IntType,\n                      disr: ty::Disr) -> bool {\n-        fn uint_in_range(ccx: @mut CrateCtxt, ty: ast::uint_ty, disr: ty::Disr) -> bool {\n+        fn uint_in_range(ccx: @CrateCtxt, ty: ast::uint_ty, disr: ty::Disr) -> bool {\n             match ty {\n                 ast::ty_u8 => disr as u8 as Disr == disr,\n                 ast::ty_u16 => disr as u16 as Disr == disr,\n@@ -3520,7 +3551,7 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                 ast::ty_u => uint_in_range(ccx, ccx.tcx.sess.targ_cfg.uint_type, disr)\n             }\n         }\n-        fn int_in_range(ccx: @mut CrateCtxt, ty: ast::int_ty, disr: ty::Disr) -> bool {\n+        fn int_in_range(ccx: @CrateCtxt, ty: ast::int_ty, disr: ty::Disr) -> bool {\n             match ty {\n                 ast::ty_i8 => disr as i8 as Disr == disr,\n                 ast::ty_i16 => disr as i16 as Disr == disr,\n@@ -3535,7 +3566,7 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n         }\n     }\n \n-    fn do_check(ccx: @mut CrateCtxt,\n+    fn do_check(ccx: @CrateCtxt,\n                 vs: &[ast::P<ast::variant>],\n                 id: ast::NodeId,\n                 hint: attr::ReprAttr)\n@@ -3616,7 +3647,10 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n     let variants = do_check(ccx, vs, id, hint);\n \n     // cache so that ty::enum_variants won't repeat this work\n-    ccx.tcx.enum_var_cache.insert(local_def(id), @variants);\n+    {\n+        let mut enum_var_cache = ccx.tcx.enum_var_cache.borrow_mut();\n+        enum_var_cache.get().insert(local_def(id), @variants);\n+    }\n \n     // Check that it is possible to represent this enum:\n     let mut outer = true;\n@@ -3642,12 +3676,12 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n     check_instantiable(ccx.tcx, sp, id);\n }\n \n-pub fn lookup_def(fcx: @mut FnCtxt, sp: Span, id: ast::NodeId) -> ast::Def {\n+pub fn lookup_def(fcx: @FnCtxt, sp: Span, id: ast::NodeId) -> ast::Def {\n     lookup_def_ccx(fcx.ccx, sp, id)\n }\n \n // Returns the type parameter count and the type for the given definition.\n-pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n+pub fn ty_param_bounds_and_ty_for_def(fcx: @FnCtxt,\n                                       sp: Span,\n                                       defn: ast::Def)\n                                    -> ty_param_bounds_and_ty {\n@@ -3697,7 +3731,7 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n \n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n-pub fn instantiate_path(fcx: @mut FnCtxt,\n+pub fn instantiate_path(fcx: @FnCtxt,\n                         pth: &ast::Path,\n                         tpt: ty_param_bounds_and_ty,\n                         def: ast::Def,\n@@ -3812,7 +3846,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n \n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n // resolution is possible, then an error is reported.\n-pub fn structurally_resolved_type(fcx: @mut FnCtxt, sp: Span, tp: ty::t)\n+pub fn structurally_resolved_type(fcx: @FnCtxt, sp: Span, tp: ty::t)\n                                -> ty::t {\n     match infer::resolve_type(fcx.infcx(), tp, force_tvar) {\n         Ok(t_s) if !ty::type_is_ty_var(t_s) => t_s,\n@@ -3827,47 +3861,47 @@ pub fn structurally_resolved_type(fcx: @mut FnCtxt, sp: Span, tp: ty::t)\n }\n \n // Returns the one-level-deep structure of the given type.\n-pub fn structure_of<'a>(fcx: @mut FnCtxt, sp: Span, typ: ty::t)\n+pub fn structure_of<'a>(fcx: @FnCtxt, sp: Span, typ: ty::t)\n                         -> &'a ty::sty {\n     &ty::get(structurally_resolved_type(fcx, sp, typ)).sty\n }\n \n-pub fn type_is_integral(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_integral(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_integral(typ_s);\n }\n \n-pub fn type_is_scalar(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_scalar(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_scalar(typ_s);\n }\n \n-pub fn type_is_char(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_char(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_char(typ_s);\n }\n \n-pub fn type_is_bare_fn(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_bare_fn(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_bare_fn(typ_s);\n }\n \n-pub fn type_is_unsafe_ptr(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_unsafe_ptr(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_unsafe_ptr(typ_s);\n }\n \n-pub fn type_is_region_ptr(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_region_ptr(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_region_ptr(typ_s);\n }\n \n-pub fn type_is_c_like_enum(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_c_like_enum(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_c_like_enum(fcx.ccx.tcx, typ_s);\n }\n \n-pub fn ast_expr_vstore_to_vstore(fcx: @mut FnCtxt,\n+pub fn ast_expr_vstore_to_vstore(fcx: @FnCtxt,\n                                  e: @ast::Expr,\n                                  v: ast::ExprVstore)\n                               -> ty::vstore {\n@@ -3895,16 +3929,18 @@ pub fn may_break(cx: ty::ctxt, id: ast::NodeId, b: ast::P<ast::Block>) -> bool {\n    // <id> nested anywhere inside the loop?\n     (block_query(b, |e| {\n         match e.node {\n-            ast::ExprBreak(Some(_)) =>\n-                match cx.def_map.find(&e.id) {\n+            ast::ExprBreak(Some(_)) => {\n+                let def_map = cx.def_map.borrow();\n+                match def_map.get().find(&e.id) {\n                     Some(&ast::DefLabel(loop_id)) if id == loop_id => true,\n                     _ => false,\n-                },\n+                }\n+            }\n             _ => false\n         }}))\n }\n \n-pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n+pub fn check_bounds_are_used(ccx: @CrateCtxt,\n                              span: Span,\n                              tps: &OptVec<ast::TyParam>,\n                              ty: ty::t) {\n@@ -3934,8 +3970,8 @@ pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n     }\n }\n \n-pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n-    fn param(ccx: @mut CrateCtxt, n: uint) -> ty::t {\n+pub fn check_intrinsic_type(ccx: @CrateCtxt, it: @ast::foreign_item) {\n+    fn param(ccx: @CrateCtxt, n: uint) -> ty::t {\n         ty::mk_param(ccx.tcx, n, local_def(0))\n     }\n "}, {"sha": "87947a91ccd5cc584916cf4326757a8a4719bbab", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -47,14 +47,14 @@ use syntax::visit;\n use syntax::visit::Visitor;\n \n pub struct Rcx {\n-    fcx: @mut FnCtxt,\n+    fcx: @FnCtxt,\n     errors_reported: uint,\n \n     // id of innermost fn or loop\n     repeating_scope: ast::NodeId,\n }\n \n-fn encl_region_of_def(fcx: @mut FnCtxt, def: ast::Def) -> ty::Region {\n+fn encl_region_of_def(fcx: @FnCtxt, def: ast::Def) -> ty::Region {\n     let tcx = fcx.tcx();\n     match def {\n         DefLocal(node_id, _) | DefArg(node_id, _) |\n@@ -134,14 +134,16 @@ impl Rcx {\n             ty_unadjusted\n         } else {\n             let tcx = self.fcx.tcx();\n-            let adjustments = self.fcx.inh.adjustments;\n-            ty::adjust_ty(tcx, expr.span, ty_unadjusted,\n-                          adjustments.find_copy(&expr.id))\n+            let adjustment = {\n+                let adjustments = self.fcx.inh.adjustments.borrow();\n+                adjustments.get().find_copy(&expr.id)\n+            };\n+            ty::adjust_ty(tcx, expr.span, ty_unadjusted, adjustment)\n         }\n     }\n }\n \n-pub fn regionck_expr(fcx: @mut FnCtxt, e: @ast::Expr) {\n+pub fn regionck_expr(fcx: @FnCtxt, e: @ast::Expr) {\n     let mut rcx = Rcx { fcx: fcx, errors_reported: 0,\n                          repeating_scope: e.id };\n     let rcx = &mut rcx;\n@@ -152,7 +154,7 @@ pub fn regionck_expr(fcx: @mut FnCtxt, e: @ast::Expr) {\n     fcx.infcx().resolve_regions();\n }\n \n-pub fn regionck_fn(fcx: @mut FnCtxt, blk: ast::P<ast::Block>) {\n+pub fn regionck_fn(fcx: @FnCtxt, blk: ast::P<ast::Block>) {\n     let mut rcx = Rcx { fcx: fcx, errors_reported: 0,\n                          repeating_scope: blk.id };\n     let rcx = &mut rcx;\n@@ -247,7 +249,10 @@ fn visit_expr(rcx: &mut Rcx, expr: @ast::Expr) {\n     debug!(\"regionck::visit_expr(e={}, repeating_scope={:?})\",\n            expr.repr(rcx.fcx.tcx()), rcx.repeating_scope);\n \n-    let has_method_map = rcx.fcx.inh.method_map.contains_key(&expr.id);\n+    let has_method_map = {\n+        let method_map = rcx.fcx.inh.method_map;\n+        method_map.get().contains_key(&expr.id)\n+    };\n \n     // Record cleanup scopes, which are used by borrowck to decide the\n     // maximum lifetime of a temporary rvalue.  These were derived by\n@@ -300,7 +305,8 @@ fn visit_expr(rcx: &mut Rcx, expr: @ast::Expr) {\n \n     // Check any autoderefs or autorefs that appear.\n     {\n-        let r = rcx.fcx.inh.adjustments.find(&expr.id);\n+        let adjustments = rcx.fcx.inh.adjustments.borrow();\n+        let r = adjustments.get().find(&expr.id);\n         for &adjustment in r.iter() {\n             debug!(\"adjustment={:?}\", adjustment);\n             match *adjustment {\n@@ -699,7 +705,10 @@ fn constrain_regions_in_type_of_node(\n     // is going to fail anyway, so just stop here and let typeck\n     // report errors later on in the writeback phase.\n     let ty0 = rcx.resolve_node_type(id);\n-    let adjustment = rcx.fcx.inh.adjustments.find_copy(&id);\n+    let adjustment = {\n+        let adjustments = rcx.fcx.inh.adjustments.borrow();\n+        adjustments.get().find_copy(&id)\n+    };\n     let ty = ty::adjust_ty(tcx, origin.span(), ty0, adjustment);\n     debug!(\"constrain_regions_in_type_of_node(\\\n             ty={}, ty0={}, id={}, minimum_lifetime={:?}, adjustment={:?})\",\n@@ -1055,7 +1064,8 @@ pub mod guarantor {\n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n         debug!(\"before adjustments, cat={:?}\", expr_ct.cat);\n \n-        match rcx.fcx.inh.adjustments.find(&expr.id) {\n+        let adjustments = rcx.fcx.inh.adjustments.borrow();\n+        match adjustments.get().find(&expr.id) {\n             Some(&@ty::AutoAddEnv(..)) => {\n                 // This is basically an rvalue, not a pointer, no regions\n                 // involved.\n@@ -1106,7 +1116,8 @@ pub mod guarantor {\n         debug!(\"categorize_unadjusted()\");\n \n         let guarantor = {\n-            if rcx.fcx.inh.method_map.contains_key(&expr.id) {\n+            let method_map = rcx.fcx.inh.method_map.borrow();\n+            if method_map.get().contains_key(&expr.id) {\n                 None\n             } else {\n                 guarantor(rcx, expr)"}, {"sha": "f2899cb634002925008429e6990155f90bf395e7", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -24,6 +24,7 @@ use middle::subst::Subst;\n use util::common::indenter;\n use util::ppaux;\n \n+use std::cell::RefCell;\n use std::hashmap::HashSet;\n use std::result;\n use syntax::ast;\n@@ -70,7 +71,7 @@ pub struct LocationInfo {\n /// A vtable context includes an inference context, a crate context, and a\n /// callback function to call in case of type error.\n pub struct VtableContext<'a> {\n-    infcx: @mut infer::InferCtxt,\n+    infcx: @infer::InferCtxt,\n     param_env: &'a ty::ParameterEnvironment,\n }\n \n@@ -329,9 +330,15 @@ fn search_for_vtable(vcx: &VtableContext,\n \n     // XXX: this is a bad way to do this, since we do\n     // pointless allocations.\n-    let impls = tcx.trait_impls.find(&trait_ref.def_id).map_default(@mut ~[], |x| *x);\n+    let impls = {\n+        let trait_impls = tcx.trait_impls.borrow();\n+        trait_impls.get()\n+                   .find(&trait_ref.def_id)\n+                   .map_default(@RefCell::new(~[]), |x| *x)\n+    };\n     // impls is the list of all impls in scope for trait_ref.\n-    for im in impls.iter() {\n+    let impls = impls.borrow();\n+    for im in impls.get().iter() {\n         // im is one specific impl of trait_ref.\n \n         // First, ensure we haven't processed this impl yet.\n@@ -528,12 +535,13 @@ fn connect_trait_tps(vcx: &VtableContext,\n     relate_trait_refs(vcx, location_info, impl_trait_ref, trait_ref);\n }\n \n-fn insert_vtables(fcx: @mut FnCtxt,\n+fn insert_vtables(fcx: @FnCtxt,\n                   callee_id: ast::NodeId,\n                   vtables: vtable_res) {\n     debug!(\"insert_vtables(callee_id={}, vtables={:?})\",\n            callee_id, vtables.repr(fcx.tcx()));\n-    fcx.inh.vtable_map.insert(callee_id, vtables);\n+    let mut vtable_map = fcx.inh.vtable_map.borrow_mut();\n+    vtable_map.get().insert(callee_id, vtables);\n }\n \n pub fn location_info_for_expr(expr: @ast::Expr) -> LocationInfo {\n@@ -550,7 +558,7 @@ pub fn location_info_for_item(item: @ast::item) -> LocationInfo {\n }\n \n pub fn early_resolve_expr(ex: @ast::Expr,\n-                          fcx: @mut FnCtxt,\n+                          fcx: @FnCtxt,\n                           is_early: bool) {\n     debug!(\"vtable: early_resolve_expr() ex with id {:?} (early: {}): {}\",\n            ex.id, is_early, expr_to_str(ex, fcx.tcx().sess.intr()));\n@@ -562,7 +570,8 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n         fcx.opt_node_ty_substs(ex.id, |substs| {\n             debug!(\"vtable resolution on parameter bounds for expr {}\",\n                    ex.repr(fcx.tcx()));\n-            let def = cx.tcx.def_map.get_copy(&ex.id);\n+            let def_map = cx.tcx.def_map.borrow();\n+            let def = def_map.get().get_copy(&ex.id);\n             let did = ast_util::def_id_of_def(def);\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n             debug!(\"early resolve expr: def {:?} {:?}, {:?}, {}\", ex.id, did, def,\n@@ -715,14 +724,14 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n     }\n }\n \n-fn resolve_expr(fcx: @mut FnCtxt,\n+fn resolve_expr(fcx: @FnCtxt,\n                 ex: @ast::Expr) {\n     let mut fcx = fcx;\n     early_resolve_expr(ex, fcx, false);\n     visit::walk_expr(&mut fcx, ex, ());\n }\n \n-pub fn resolve_impl(ccx: @mut CrateCtxt,\n+pub fn resolve_impl(ccx: @CrateCtxt,\n                     impl_item: @ast::item,\n                     impl_generics: &ty::Generics,\n                     impl_trait_ref: &ty::TraitRef) {\n@@ -773,10 +782,12 @@ pub fn resolve_impl(ccx: @mut CrateCtxt,\n         self_vtables: self_vtable_res\n     };\n     let impl_def_id = ast_util::local_def(impl_item.id);\n-    ccx.tcx.impl_vtables.insert(impl_def_id, res);\n+\n+    let mut impl_vtables = ccx.tcx.impl_vtables.borrow_mut();\n+    impl_vtables.get().insert(impl_def_id, res);\n }\n \n-impl visit::Visitor<()> for @mut FnCtxt {\n+impl visit::Visitor<()> for @FnCtxt {\n     fn visit_expr(&mut self, ex:@ast::Expr, _:()) {\n         resolve_expr(*self, ex);\n     }\n@@ -787,7 +798,7 @@ impl visit::Visitor<()> for @mut FnCtxt {\n \n // Detect points where a trait-bounded type parameter is\n // instantiated, resolve the impls for the parameters.\n-pub fn resolve_in_block(fcx: @mut FnCtxt, bl: ast::P<ast::Block>) {\n+pub fn resolve_in_block(fcx: @FnCtxt, bl: ast::P<ast::Block>) {\n     let mut fcx = fcx;\n     visit::walk_block(&mut fcx, bl, ());\n }"}, {"sha": "3f371253e0553ca1eb2f4bbff58cdd77c0ad1d7e", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 47, "deletions": 26, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -32,7 +32,7 @@ use syntax::print::pprust::pat_to_str;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n-fn resolve_type_vars_in_type(fcx: @mut FnCtxt, sp: Span, typ: ty::t)\n+fn resolve_type_vars_in_type(fcx: @FnCtxt, sp: Span, typ: ty::t)\n                           -> Option<ty::t> {\n     if !ty::type_needs_infer(typ) { return Some(typ); }\n     match resolve_type(fcx.infcx(), typ, resolve_all | force_all) {\n@@ -50,7 +50,7 @@ fn resolve_type_vars_in_type(fcx: @mut FnCtxt, sp: Span, typ: ty::t)\n     }\n }\n \n-fn resolve_type_vars_in_types(fcx: @mut FnCtxt, sp: Span, tys: &[ty::t])\n+fn resolve_type_vars_in_types(fcx: @FnCtxt, sp: Span, tys: &[ty::t])\n                           -> ~[ty::t] {\n     tys.map(|t| {\n         match resolve_type_vars_in_type(fcx, sp, *t) {\n@@ -60,45 +60,56 @@ fn resolve_type_vars_in_types(fcx: @mut FnCtxt, sp: Span, tys: &[ty::t])\n     })\n }\n \n-fn resolve_method_map_entry(fcx: @mut FnCtxt, sp: Span, id: ast::NodeId) {\n+fn resolve_method_map_entry(fcx: @FnCtxt, sp: Span, id: ast::NodeId) {\n     // Resolve any method map entry\n-    match fcx.inh.method_map.find(&id) {\n+    let method_map_entry_opt = {\n+        let method_map = fcx.inh.method_map.borrow();\n+        method_map.get().find_copy(&id)\n+    };\n+    match method_map_entry_opt {\n         None => {}\n         Some(mme) => {\n             {\n                 let r = resolve_type_vars_in_type(fcx, sp, mme.self_ty);\n                 for t in r.iter() {\n                     let method_map = fcx.ccx.method_map;\n-                    let new_entry = method_map_entry { self_ty: *t, ..*mme };\n+                    let new_entry = method_map_entry { self_ty: *t, ..mme };\n                     debug!(\"writeback::resolve_method_map_entry(id={:?}, \\\n                             new_entry={:?})\",\n                            id, new_entry);\n-                    method_map.insert(id, new_entry);\n+                    let mut method_map = method_map.borrow_mut();\n+                    method_map.get().insert(id, new_entry);\n                 }\n             }\n         }\n     }\n }\n \n-fn resolve_vtable_map_entry(fcx: @mut FnCtxt, sp: Span, id: ast::NodeId) {\n+fn resolve_vtable_map_entry(fcx: @FnCtxt, sp: Span, id: ast::NodeId) {\n     // Resolve any method map entry\n-    match fcx.inh.vtable_map.find(&id) {\n-        None => {}\n-        Some(origins) => {\n-            let r_origins = resolve_origins(fcx, sp, *origins);\n-            let vtable_map = fcx.ccx.vtable_map;\n-            vtable_map.insert(id, r_origins);\n-            debug!(\"writeback::resolve_vtable_map_entry(id={}, vtables={:?})\",\n-                   id, r_origins.repr(fcx.tcx()));\n+    {\n+        let origins_opt = {\n+            let vtable_map = fcx.inh.vtable_map.borrow();\n+            vtable_map.get().find_copy(&id)\n+        };\n+        match origins_opt {\n+            None => {}\n+            Some(origins) => {\n+                let r_origins = resolve_origins(fcx, sp, origins);\n+                let mut vtable_map = fcx.ccx.vtable_map.borrow_mut();\n+                vtable_map.get().insert(id, r_origins);\n+                debug!(\"writeback::resolve_vtable_map_entry(id={}, vtables={:?})\",\n+                       id, r_origins.repr(fcx.tcx()));\n+            }\n         }\n     }\n \n-    fn resolve_origins(fcx: @mut FnCtxt, sp: Span,\n+    fn resolve_origins(fcx: @FnCtxt, sp: Span,\n                        vtbls: vtable_res) -> vtable_res {\n         @vtbls.map(|os| @os.map(|o| resolve_origin(fcx, sp, o)))\n     }\n \n-    fn resolve_origin(fcx: @mut FnCtxt,\n+    fn resolve_origin(fcx: @FnCtxt,\n                       sp: Span,\n                       origin: &vtable_origin) -> vtable_origin {\n         match origin {\n@@ -120,10 +131,14 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n     let tcx = fcx.ccx.tcx;\n \n     // Resolve any borrowings for the node with id `id`\n-    match fcx.inh.adjustments.find(&id) {\n+    let adjustment = {\n+        let adjustments = fcx.inh.adjustments.borrow();\n+        adjustments.get().find_copy(&id)\n+    };\n+    match adjustment {\n         None => (),\n \n-        Some(&@ty::AutoAddEnv(r, s)) => {\n+        Some(@ty::AutoAddEnv(r, s)) => {\n             match resolve_region(fcx.infcx(), r, resolve_all | force_all) {\n                 Err(e) => {\n                     // This should not, I think, happen:\n@@ -134,12 +149,13 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                 Ok(r1) => {\n                     let resolved_adj = @ty::AutoAddEnv(r1, s);\n                     debug!(\"Adjustments for node {}: {:?}\", id, resolved_adj);\n-                    fcx.tcx().adjustments.insert(id, resolved_adj);\n+                    let mut adjustments = fcx.tcx().adjustments.borrow_mut();\n+                    adjustments.get().insert(id, resolved_adj);\n                 }\n             }\n         }\n \n-        Some(&@ty::AutoDerefRef(adj)) => {\n+        Some(@ty::AutoDerefRef(adj)) => {\n             let fixup_region = |r| {\n                 match resolve_region(fcx.infcx(), r, resolve_all | force_all) {\n                     Ok(r1) => r1,\n@@ -163,7 +179,8 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                 autoref: resolved_autoref,\n             });\n             debug!(\"Adjustments for node {}: {:?}\", id, resolved_adj);\n-            fcx.tcx().adjustments.insert(id, resolved_adj);\n+            let mut adjustments = fcx.tcx().adjustments.borrow_mut();\n+            adjustments.get().insert(id, resolved_adj);\n         }\n     }\n \n@@ -200,15 +217,19 @@ fn maybe_resolve_type_vars_for_node(wbcx: &mut WbCtxt,\n                                     sp: Span,\n                                     id: ast::NodeId)\n                                  -> Option<ty::t> {\n-    if wbcx.fcx.inh.node_types.contains_key(&id) {\n+    let contained = {\n+        let node_types = wbcx.fcx.inh.node_types.borrow();\n+        node_types.get().contains_key(&id)\n+    };\n+    if contained {\n         resolve_type_vars_for_node(wbcx, sp, id)\n     } else {\n         None\n     }\n }\n \n struct WbCtxt {\n-    fcx: @mut FnCtxt,\n+    fcx: @FnCtxt,\n \n     // As soon as we hit an error we have to stop resolving\n     // the entire function.\n@@ -329,14 +350,14 @@ impl Visitor<()> for WbCtxt {\n     fn visit_ty(&mut self, _t: &ast::Ty, _:()) {}\n }\n \n-pub fn resolve_type_vars_in_expr(fcx: @mut FnCtxt, e: @ast::Expr) -> bool {\n+pub fn resolve_type_vars_in_expr(fcx: @FnCtxt, e: @ast::Expr) -> bool {\n     let mut wbcx = WbCtxt { fcx: fcx, success: true };\n     let wbcx = &mut wbcx;\n     wbcx.visit_expr(e, ());\n     return wbcx.success;\n }\n \n-pub fn resolve_type_vars_in_fn(fcx: @mut FnCtxt,\n+pub fn resolve_type_vars_in_fn(fcx: @FnCtxt,\n                                decl: &ast::fn_decl,\n                                blk: ast::P<ast::Block>,\n                                self_info: Option<SelfInfo>) -> bool {"}, {"sha": "376af7e9d3dfab8ae97d198a7bda1c405b78c603", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 60, "deletions": 33, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -45,6 +45,7 @@ use syntax::codemap::Span;\n use syntax::opt_vec;\n use syntax::visit;\n \n+use std::cell::RefCell;\n use std::hashmap::HashSet;\n use std::result::Ok;\n use std::vec;\n@@ -55,7 +56,7 @@ pub struct UniversalQuantificationResult {\n     type_param_defs: @~[ty::TypeParameterDef]\n }\n \n-pub fn get_base_type(inference_context: @mut InferCtxt,\n+pub fn get_base_type(inference_context: @InferCtxt,\n                      span: Span,\n                      original_type: t)\n                   -> Option<t> {\n@@ -118,7 +119,7 @@ pub fn type_is_defined_in_local_crate(original_type: t) -> bool {\n }\n \n // Returns the def ID of the base type, if there is one.\n-pub fn get_base_type_def_id(inference_context: @mut InferCtxt,\n+pub fn get_base_type_def_id(inference_context: @InferCtxt,\n                             span: Span,\n                             original_type: t)\n                          -> Option<DefId> {\n@@ -142,16 +143,16 @@ pub fn get_base_type_def_id(inference_context: @mut InferCtxt,\n     }\n }\n \n-pub fn CoherenceChecker(crate_context: @mut CrateCtxt) -> CoherenceChecker {\n+pub fn CoherenceChecker(crate_context: @CrateCtxt) -> CoherenceChecker {\n     CoherenceChecker {\n         crate_context: crate_context,\n         inference_context: new_infer_ctxt(crate_context.tcx),\n     }\n }\n \n pub struct CoherenceChecker {\n-    crate_context: @mut CrateCtxt,\n-    inference_context: @mut InferCtxt,\n+    crate_context: @CrateCtxt,\n+    inference_context: @InferCtxt,\n }\n \n struct CoherenceCheckVisitor { cc: CoherenceChecker }\n@@ -313,7 +314,8 @@ impl CoherenceChecker {\n             }\n         }\n \n-        tcx.impls.insert(implementation.did, implementation);\n+        let mut impls = tcx.impls.borrow_mut();\n+        impls.get().insert(implementation.did, implementation);\n     }\n \n     // Creates default method IDs and performs type substitutions for an impl\n@@ -365,13 +367,20 @@ impl CoherenceChecker {\n             };\n             debug!(\"new_polytype={}\", new_polytype.repr(tcx));\n \n-            tcx.tcache.insert(new_did, new_polytype);\n-            tcx.methods.insert(new_did, new_method_ty);\n+            {\n+                let mut tcache = tcx.tcache.borrow_mut();\n+                tcache.get().insert(new_did, new_polytype);\n+            }\n+\n+            let mut methods = tcx.methods.borrow_mut();\n+            methods.get().insert(new_did, new_method_ty);\n \n             // Pair the new synthesized ID up with the\n             // ID of the method.\n-            self.crate_context.tcx.provided_method_sources\n-                .insert(new_did, trait_method.def_id);\n+            let mut provided_method_sources =\n+                self.crate_context.tcx.provided_method_sources.borrow_mut();\n+            provided_method_sources.get().insert(new_did,\n+                                                 trait_method.def_id);\n         }\n     }\n \n@@ -380,39 +389,44 @@ impl CoherenceChecker {\n                              implementation: @Impl) {\n         let tcx = self.crate_context.tcx;\n         let implementation_list;\n-        match tcx.inherent_impls.find(&base_def_id) {\n+        let mut inherent_impls = tcx.inherent_impls.borrow_mut();\n+        match inherent_impls.get().find(&base_def_id) {\n             None => {\n-                implementation_list = @mut ~[];\n-                tcx.inherent_impls.insert(base_def_id, implementation_list);\n+                implementation_list = @RefCell::new(~[]);\n+                inherent_impls.get().insert(base_def_id, implementation_list);\n             }\n             Some(&existing_implementation_list) => {\n                 implementation_list = existing_implementation_list;\n             }\n         }\n \n-        implementation_list.push(implementation);\n+        let mut implementation_list = implementation_list.borrow_mut();\n+        implementation_list.get().push(implementation);\n     }\n \n     pub fn add_trait_impl(&self,\n                           base_def_id: DefId,\n                           implementation: @Impl) {\n         let tcx = self.crate_context.tcx;\n         let implementation_list;\n-        match tcx.trait_impls.find(&base_def_id) {\n+        let mut trait_impls = tcx.trait_impls.borrow_mut();\n+        match trait_impls.get().find(&base_def_id) {\n             None => {\n-                implementation_list = @mut ~[];\n-                tcx.trait_impls.insert(base_def_id, implementation_list);\n+                implementation_list = @RefCell::new(~[]);\n+                trait_impls.get().insert(base_def_id, implementation_list);\n             }\n             Some(&existing_implementation_list) => {\n                 implementation_list = existing_implementation_list;\n             }\n         }\n \n-        implementation_list.push(implementation);\n+        let mut implementation_list = implementation_list.borrow_mut();\n+        implementation_list.get().push(implementation);\n     }\n \n     pub fn check_implementation_coherence(&self) {\n-        self.crate_context.tcx.trait_impls.each_key(|&trait_id| {\n+        let trait_impls = self.crate_context.tcx.trait_impls.borrow();\n+        trait_impls.get().each_key(|&trait_id| {\n             self.check_implementation_coherence_of(trait_id);\n             true\n         });\n@@ -451,9 +465,11 @@ impl CoherenceChecker {\n     }\n \n     pub fn iter_impls_of_trait(&self, trait_def_id: DefId, f: |@Impl|) {\n-        match self.crate_context.tcx.trait_impls.find(&trait_def_id) {\n+        let trait_impls = self.crate_context.tcx.trait_impls.borrow();\n+        match trait_impls.get().find(&trait_def_id) {\n             Some(impls) => {\n-                for &im in impls.iter() {\n+                let impls = impls.borrow();\n+                for &im in impls.get().iter() {\n                     f(im);\n                 }\n             }\n@@ -519,7 +535,8 @@ impl CoherenceChecker {\n \n     pub fn get_self_type_for_implementation(&self, implementation: @Impl)\n                                             -> ty_param_bounds_and_ty {\n-        return self.crate_context.tcx.tcache.get_copy(&implementation.did);\n+        let tcache = self.crate_context.tcx.tcache.borrow();\n+        return tcache.get().get_copy(&implementation.did);\n     }\n \n     // Privileged scope checking\n@@ -530,7 +547,8 @@ impl CoherenceChecker {\n \n     pub fn trait_ref_to_trait_def_id(&self, trait_ref: &trait_ref) -> DefId {\n         let def_map = self.crate_context.tcx.def_map;\n-        let trait_def = def_map.get_copy(&trait_ref.ref_id);\n+        let def_map = def_map.borrow();\n+        let trait_def = def_map.get().get_copy(&trait_ref.ref_id);\n         let trait_id = def_id_of_def(trait_def);\n         return trait_id;\n     }\n@@ -542,7 +560,8 @@ impl CoherenceChecker {\n                                               -> bool {\n         match original_type.node {\n             ty_path(_, _, path_id) => {\n-                match self.crate_context.tcx.def_map.get_copy(&path_id) {\n+                let def_map = self.crate_context.tcx.def_map.borrow();\n+                match def_map.get().get_copy(&path_id) {\n                     DefTy(def_id) | DefStruct(def_id) => {\n                         if def_id.crate != LOCAL_CRATE {\n                             return false;\n@@ -651,11 +670,14 @@ impl CoherenceChecker {\n         // the map. This is a bit unfortunate.\n         for method in implementation.methods.iter() {\n             for source in method.provided_source.iter() {\n-                tcx.provided_method_sources.insert(method.def_id, *source);\n+                let mut provided_method_sources = tcx.provided_method_sources\n+                                                     .borrow_mut();\n+                provided_method_sources.get().insert(method.def_id, *source);\n             }\n         }\n \n-        tcx.impls.insert(implementation.did, implementation);\n+        let mut impls = tcx.impls.borrow_mut();\n+        impls.get().insert(implementation.did, implementation);\n     }\n \n     // Adds implementations and traits from external crates to the coherence\n@@ -681,15 +703,17 @@ impl CoherenceChecker {\n         let drop_trait = match tcx.lang_items.drop_trait() {\n             Some(id) => id, None => { return }\n         };\n-        let impls_opt = tcx.trait_impls.find(&drop_trait);\n \n+        let trait_impls = tcx.trait_impls.borrow();\n+        let impls_opt = trait_impls.get().find(&drop_trait);\n         let impls;\n         match impls_opt {\n-            None => return, // No types with (new-style) destructors present.\n+            None => return, // No types with (new-style) dtors present.\n             Some(found_impls) => impls = found_impls\n         }\n \n-        for impl_info in impls.iter() {\n+        let impls = impls.borrow();\n+        for impl_info in impls.get().iter() {\n             if impl_info.methods.len() < 1 {\n                 // We'll error out later. For now, just don't ICE.\n                 continue;\n@@ -699,9 +723,12 @@ impl CoherenceChecker {\n             let self_type = self.get_self_type_for_implementation(*impl_info);\n             match ty::get(self_type.ty).sty {\n                 ty::ty_struct(type_def_id, _) => {\n-                    tcx.destructor_for_type.insert(type_def_id,\n-                                                   method_def_id);\n-                    tcx.destructors.insert(method_def_id);\n+                    let mut destructor_for_type = tcx.destructor_for_type\n+                                                     .borrow_mut();\n+                    destructor_for_type.get().insert(type_def_id,\n+                                                     method_def_id);\n+                    let mut destructors = tcx.destructors.borrow_mut();\n+                    destructors.get().insert(method_def_id);\n                 }\n                 _ => {\n                     // Destructors only work on nominal types.\n@@ -805,7 +832,7 @@ fn subst_receiver_types_in_method_ty(tcx: ty::ctxt,\n     )\n }\n \n-pub fn check_coherence(crate_context: @mut CrateCtxt, crate: &Crate) {\n+pub fn check_coherence(crate_context: @CrateCtxt, crate: &Crate) {\n     let coherence_checker = CoherenceChecker(crate_context);\n     coherence_checker.check_coherence(crate);\n }"}, {"sha": "3dfcf15e0240bb5119ceee077fc37ae58e3579f3", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 133, "deletions": 59, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -57,7 +57,7 @@ use syntax::opt_vec::OptVec;\n use syntax::parse::token::special_idents;\n \n struct CollectItemTypesVisitor {\n-    ccx: @mut CrateCtxt\n+    ccx: @CrateCtxt\n }\n \n impl visit::Visitor<()> for CollectItemTypesVisitor {\n@@ -71,12 +71,13 @@ impl visit::Visitor<()> for CollectItemTypesVisitor {\n     }\n }\n \n-pub fn collect_item_types(ccx: @mut CrateCtxt, crate: &ast::Crate) {\n+pub fn collect_item_types(ccx: @CrateCtxt, crate: &ast::Crate) {\n     fn collect_intrinsic_type(ccx: &CrateCtxt,\n                               lang_item: ast::DefId) {\n         let ty::ty_param_bounds_and_ty { ty: ty, .. } =\n             ccx.get_item_ty(lang_item);\n-        ccx.tcx.intrinsic_defs.insert(lang_item, ty);\n+        let mut intrinsic_defs = ccx.tcx.intrinsic_defs.borrow_mut();\n+        intrinsic_defs.get().insert(lang_item, ty);\n     }\n \n     match ccx.tcx.lang_items.ty_desc() {\n@@ -172,7 +173,12 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n             generics: ty_generics(ccx, generics, 0),\n             ty: result_ty\n         };\n-        tcx.tcache.insert(local_def(variant.node.id), tpt);\n+\n+        {\n+            let mut tcache = tcx.tcache.borrow_mut();\n+            tcache.get().insert(local_def(variant.node.id), tpt);\n+        }\n+\n         write_ty_to_tcx(tcx, variant.node.id, result_ty);\n     }\n }\n@@ -213,7 +219,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                                           &trait_ty_generics);\n                 }\n \n-                tcx.methods.insert(ty_method.def_id, ty_method);\n+                let mut methods = tcx.methods.borrow_mut();\n+                methods.get().insert(ty_method.def_id, ty_method);\n             }\n \n             // Add an entry mapping\n@@ -225,7 +232,9 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n             });\n \n             let trait_def_id = local_def(trait_id);\n-            tcx.trait_method_def_ids.insert(trait_def_id, method_def_ids);\n+            let mut trait_method_def_ids = tcx.trait_method_def_ids\n+                                              .borrow_mut();\n+            trait_method_def_ids.get().insert(trait_def_id, method_def_ids);\n         }\n         _ => { /* Ignore things that aren't traits */ }\n     }\n@@ -346,7 +355,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                ty.repr(tcx),\n                substs.repr(tcx));\n \n-        tcx.tcache.insert(m.def_id,\n+        let mut tcache = tcx.tcache.borrow_mut();\n+        tcache.get().insert(m.def_id,\n                           ty_param_bounds_and_ty {\n                               generics: ty::Generics {\n                                   type_param_defs: @new_type_param_defs,\n@@ -397,7 +407,10 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n \n     // Called only the first time trait_def_of_item is called.\n     // Supertraits are ensured at the same time.\n-    assert!(!tcx.supertraits.contains_key(&local_def(id)));\n+    {\n+        let supertraits = tcx.supertraits.borrow();\n+        assert!(!supertraits.get().contains_key(&local_def(id)));\n+    }\n \n     let self_ty = ty::mk_self(ccx.tcx, local_def(id));\n     let mut ty_trait_refs: ~[@ty::TraitRef] = ~[];\n@@ -421,7 +434,9 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n             }\n         }\n     }\n-    tcx.supertraits.insert(local_def(id), @ty_trait_refs);\n+\n+    let mut supertraits = tcx.supertraits.borrow_mut();\n+    supertraits.get().insert(local_def(id), @ty_trait_refs);\n     bounds\n }\n \n@@ -431,7 +446,8 @@ pub fn convert_field(ccx: &CrateCtxt,\n     let tt = ccx.to_ty(&ExplicitRscope, v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n-    ccx.tcx.tcache.insert(local_def(v.node.id),\n+    let mut tcache = ccx.tcx.tcache.borrow_mut();\n+    tcache.get().insert(local_def(v.node.id),\n                           ty::ty_param_bounds_and_ty {\n                               generics: struct_generics.clone(),\n                               ty: tt\n@@ -461,22 +477,29 @@ fn convert_methods(ccx: &CrateCtxt,\n                 m.ident.repr(ccx.tcx),\n                 m.id,\n                 fty.repr(ccx.tcx));\n-        tcx.tcache.insert(\n-            local_def(m.id),\n+        {\n+            let mut tcache = tcx.tcache.borrow_mut();\n+            tcache.get().insert(\n+                local_def(m.id),\n+\n+                // n.b.: the type of a method is parameterized by both\n+                // the parameters on the receiver and those on the method\n+                // itself\n+                ty_param_bounds_and_ty {\n+                    generics: ty::Generics {\n+                        type_param_defs: @vec::append(\n+                            (*rcvr_ty_generics.type_param_defs).clone(),\n+                            *m_ty_generics.type_param_defs),\n+                        region_param_defs: rcvr_ty_generics.region_param_defs,\n+                    },\n+                    ty: fty\n+                });\n+        }\n \n-            // n.b.: the type of a method is parameterized by both\n-            // the parameters on the receiver and those on the method itself\n-            ty_param_bounds_and_ty {\n-                generics: ty::Generics {\n-                    type_param_defs: @vec::append(\n-                        (*rcvr_ty_generics.type_param_defs).clone(),\n-                        *m_ty_generics.type_param_defs),\n-                    region_param_defs: rcvr_ty_generics.region_param_defs,\n-                },\n-                ty: fty\n-            });\n         write_ty_to_tcx(tcx, m.id, fty);\n-        tcx.methods.insert(mty.def_id, mty);\n+\n+        let mut methods = tcx.methods.borrow_mut();\n+        methods.get().insert(mty.def_id, mty);\n     }\n \n     fn ty_of_method(ccx: &CrateCtxt,\n@@ -546,10 +569,14 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n         let i_ty_generics = ty_generics(ccx, generics, 0);\n         let selfty = ccx.to_ty(&ExplicitRscope, selfty);\n         write_ty_to_tcx(tcx, it.id, selfty);\n-        tcx.tcache.insert(local_def(it.id),\n-                          ty_param_bounds_and_ty {\n-                              generics: i_ty_generics,\n-                              ty: selfty});\n+\n+        {\n+            let mut tcache = tcx.tcache.borrow_mut();\n+            tcache.get().insert(local_def(it.id),\n+                              ty_param_bounds_and_ty {\n+                                  generics: i_ty_generics,\n+                                  ty: selfty});\n+        }\n \n         // If there is a trait reference, treat the methods as always public.\n         // This is to work around some incorrect behavior in privacy checking:\n@@ -607,7 +634,11 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n         // Write the class type\n         let tpt = ty_of_item(ccx, it);\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n-        tcx.tcache.insert(local_def(it.id), tpt);\n+\n+        {\n+            let mut tcache = tcx.tcache.borrow_mut();\n+            tcache.get().insert(local_def(it.id), tpt);\n+        }\n \n         convert_struct(ccx, struct_def, tpt, it.id);\n       }\n@@ -647,19 +678,29 @@ pub fn convert_struct(ccx: &CrateCtxt,\n             if struct_def.fields.len() == 0 {\n                 // Enum-like.\n                 write_ty_to_tcx(tcx, ctor_id, selfty);\n-                tcx.tcache.insert(local_def(ctor_id), tpt);\n+\n+                {\n+                    let mut tcache = tcx.tcache.borrow_mut();\n+                    tcache.get().insert(local_def(ctor_id), tpt);\n+                }\n             } else if struct_def.fields[0].node.kind == ast::unnamed_field {\n                 // Tuple-like.\n-                let inputs =\n+                let inputs = {\n+                    let tcache = tcx.tcache.borrow();\n                     struct_def.fields.map(\n-                        |field| ccx.tcx.tcache.get(\n-                            &local_def(field.node.id)).ty);\n+                        |field| tcache.get().get(\n+                            &local_def(field.node.id)).ty)\n+                };\n                 let ctor_fn_ty = ty::mk_ctor_fn(tcx, ctor_id, inputs, selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n-                tcx.tcache.insert(local_def(ctor_id), ty_param_bounds_and_ty {\n-                    generics: tpt.generics,\n-                    ty: ctor_fn_ty\n-                });\n+                {\n+                    let mut tcache = tcx.tcache.borrow_mut();\n+                    tcache.get().insert(local_def(ctor_id),\n+                                      ty_param_bounds_and_ty {\n+                        generics: tpt.generics,\n+                        ty: ctor_fn_ty\n+                    });\n+                }\n             }\n         }\n     }\n@@ -684,7 +725,9 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::foreign_item) {\n \n     let tpt = ty_of_foreign_item(ccx, i, abis);\n     write_ty_to_tcx(ccx.tcx, i.id, tpt.ty);\n-    ccx.tcx.tcache.insert(local_def(i.id), tpt);\n+\n+    let mut tcache = ccx.tcx.tcache.borrow_mut();\n+    tcache.get().insert(local_def(i.id), tpt);\n }\n \n pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n@@ -705,8 +748,9 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n             let trait_ref =\n                 astconv::ast_path_to_trait_ref(\n                     ccx, &rscope, trait_did, Some(self_ty), &ast_trait_ref.path);\n-            ccx.tcx.trait_refs.insert(\n-                ast_trait_ref.ref_id, trait_ref);\n+\n+            let mut trait_refs = ccx.tcx.trait_refs.borrow_mut();\n+            trait_refs.get().insert(ast_trait_ref.ref_id, trait_ref);\n             return trait_ref;\n         }\n         _ => {\n@@ -734,10 +778,14 @@ fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> @ty::TraitDef {\n pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::item) -> @ty::TraitDef {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n-    match tcx.trait_defs.find(&def_id) {\n-      Some(&def) => return def,\n-      _ => {}\n+    {\n+        let trait_defs = tcx.trait_defs.borrow();\n+        match trait_defs.get().find(&def_id) {\n+          Some(&def) => return def,\n+          _ => {}\n+        }\n     }\n+\n     match it.node {\n         ast::item_trait(ref generics, ref supertraits, _) => {\n             let self_ty = ty::mk_self(tcx, def_id);\n@@ -749,7 +797,8 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::item) -> @ty::TraitDef {\n             let trait_def = @ty::TraitDef {generics: ty_generics,\n                                            bounds: bounds,\n                                            trait_ref: trait_ref};\n-            tcx.trait_defs.insert(def_id, trait_def);\n+            let mut trait_defs = tcx.trait_defs.borrow_mut();\n+            trait_defs.get().insert(def_id, trait_def);\n             return trait_def;\n         }\n         ref s => {\n@@ -764,15 +813,20 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n                   -> ty::ty_param_bounds_and_ty {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n-    match tcx.tcache.find(&def_id) {\n-        Some(&tpt) => return tpt,\n-        _ => {}\n+    {\n+        let tcache = tcx.tcache.borrow();\n+        match tcache.get().find(&def_id) {\n+            Some(&tpt) => return tpt,\n+            _ => {}\n+        }\n     }\n     match it.node {\n         ast::item_static(t, _, _) => {\n             let typ = ccx.to_ty(&ExplicitRscope, t);\n             let tpt = no_params(typ);\n-            tcx.tcache.insert(local_def(it.id), tpt);\n+\n+            let mut tcache = tcx.tcache.borrow_mut();\n+            tcache.get().insert(local_def(it.id), tpt);\n             return tpt;\n         }\n         ast::item_fn(decl, purity, abi, ref generics, _) => {\n@@ -793,13 +847,18 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n                     tcx.sess.str_of(it.ident),\n                     it.id,\n                     ppaux::ty_to_str(tcx, tpt.ty));\n-            ccx.tcx.tcache.insert(local_def(it.id), tpt);\n+\n+            let mut tcache = ccx.tcx.tcache.borrow_mut();\n+            tcache.get().insert(local_def(it.id), tpt);\n             return tpt;\n         }\n         ast::item_ty(t, ref generics) => {\n-            match tcx.tcache.find(&local_def(it.id)) {\n-                Some(&tpt) => return tpt,\n-                None => { }\n+            {\n+                let mut tcache = tcx.tcache.borrow_mut();\n+                match tcache.get().find(&local_def(it.id)) {\n+                    Some(&tpt) => return tpt,\n+                    None => { }\n+                }\n             }\n \n             let tpt = {\n@@ -810,7 +869,8 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n                 }\n             };\n \n-            tcx.tcache.insert(local_def(it.id), tpt);\n+            let mut tcache = tcx.tcache.borrow_mut();\n+            tcache.get().insert(local_def(it.id), tpt);\n             return tpt;\n         }\n         ast::item_enum(_, ref generics) => {\n@@ -822,7 +882,9 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n                 generics: ty_generics,\n                 ty: t\n             };\n-            tcx.tcache.insert(local_def(it.id), tpt);\n+\n+            let mut tcache = tcx.tcache.borrow_mut();\n+            tcache.get().insert(local_def(it.id), tpt);\n             return tpt;\n         }\n         ast::item_trait(..) => {\n@@ -838,7 +900,9 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n                 generics: ty_generics,\n                 ty: t\n             };\n-            tcx.tcache.insert(local_def(it.id), tpt);\n+\n+            let mut tcache = tcx.tcache.borrow_mut();\n+            tcache.get().insert(local_def(it.id), tpt);\n             return tpt;\n         }\n         ast::item_impl(..) | ast::item_mod(_) |\n@@ -880,8 +944,12 @@ pub fn ty_generics(ccx: &CrateCtxt,\n                                          def_id: local_def(l.id) }\n             }).collect(),\n         type_param_defs: @generics.ty_params.mapi_to_vec(|offset, param| {\n-            match ccx.tcx.ty_param_defs.find(&param.id) {\n-                Some(&def) => def,\n+            let existing_def_opt = {\n+                let ty_param_defs = ccx.tcx.ty_param_defs.borrow();\n+                ty_param_defs.get().find(&param.id).map(|def| *def)\n+            };\n+            match existing_def_opt {\n+                Some(def) => def,\n                 None => {\n                     let param_ty = ty::param_ty {idx: base_index + offset,\n                                                  def_id: local_def(param.id)};\n@@ -892,7 +960,11 @@ pub fn ty_generics(ccx: &CrateCtxt,\n                         bounds: bounds\n                     };\n                     debug!(\"def for param: {}\", def.repr(ccx.tcx));\n-                    ccx.tcx.ty_param_defs.insert(param.id, def);\n+\n+                    let mut ty_param_defs = ccx.tcx\n+                                               .ty_param_defs\n+                                               .borrow_mut();\n+                    ty_param_defs.get().insert(param.id, def);\n                     def\n                 }\n             }\n@@ -965,7 +1037,9 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n         generics: ty_generics,\n         ty: t_fn\n     };\n-    ccx.tcx.tcache.insert(def_id, tpt);\n+\n+    let mut tcache = ccx.tcx.tcache.borrow_mut();\n+    tcache.get().insert(def_id, tpt);\n     return tpt;\n }\n "}, {"sha": "c35852d37c97e1a8c2ee3d3fb50f0778ee2abd33", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -67,7 +67,7 @@ use syntax::opt_vec;\n use syntax::abi::AbiSet;\n \n pub trait Combine {\n-    fn infcx(&self) -> @mut InferCtxt;\n+    fn infcx(&self) -> @InferCtxt;\n     fn tag(&self) -> ~str;\n     fn a_is_expected(&self) -> bool;\n     fn trace(&self) -> TypeTrace;\n@@ -328,7 +328,7 @@ pub trait Combine {\n }\n \n pub struct CombineFields {\n-    infcx: @mut InferCtxt,\n+    infcx: @InferCtxt,\n     a_is_expected: bool,\n     trace: TypeTrace,\n }"}, {"sha": "1744c1176156cea557da23f6d9e9a17007b99ce3", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -77,33 +77,33 @@ use util::ppaux::bound_region_to_str;\n use util::ppaux::note_and_explain_region;\n \n pub trait ErrorReporting {\n-    fn report_region_errors(@mut self,\n+    fn report_region_errors(@self,\n                             errors: &OptVec<RegionResolutionError>);\n \n-    fn report_and_explain_type_error(@mut self,\n+    fn report_and_explain_type_error(@self,\n                                      trace: TypeTrace,\n                                      terr: &ty::type_err);\n \n-    fn values_str(@mut self, values: &ValuePairs) -> Option<~str>;\n+    fn values_str(@self, values: &ValuePairs) -> Option<~str>;\n \n     fn expected_found_str<T:UserString+Resolvable>(\n-        @mut self,\n+        @self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<~str>;\n \n-    fn report_concrete_failure(@mut self,\n+    fn report_concrete_failure(@self,\n                                origin: SubregionOrigin,\n                                sub: Region,\n                                sup: Region);\n \n-    fn report_sub_sup_conflict(@mut self,\n+    fn report_sub_sup_conflict(@self,\n                                var_origin: RegionVariableOrigin,\n                                sub_origin: SubregionOrigin,\n                                sub_region: Region,\n                                sup_origin: SubregionOrigin,\n                                sup_region: Region);\n \n-    fn report_sup_sup_conflict(@mut self,\n+    fn report_sup_sup_conflict(@self,\n                                var_origin: RegionVariableOrigin,\n                                origin1: SubregionOrigin,\n                                region1: Region,\n@@ -112,15 +112,15 @@ pub trait ErrorReporting {\n }\n \n trait ErrorReportingHelpers {\n-    fn report_inference_failure(@mut self,\n+    fn report_inference_failure(@self,\n                                 var_origin: RegionVariableOrigin);\n \n-    fn note_region_origin(@mut self,\n+    fn note_region_origin(@self,\n                           origin: SubregionOrigin);\n }\n \n impl ErrorReporting for InferCtxt {\n-    fn report_region_errors(@mut self,\n+    fn report_region_errors(@self,\n                             errors: &OptVec<RegionResolutionError>) {\n         for error in errors.iter() {\n             match *error {\n@@ -147,7 +147,7 @@ impl ErrorReporting for InferCtxt {\n         }\n     }\n \n-    fn report_and_explain_type_error(@mut self,\n+    fn report_and_explain_type_error(@self,\n                                      trace: TypeTrace,\n                                      terr: &ty::type_err) {\n         let tcx = self.tcx;\n@@ -179,7 +179,7 @@ impl ErrorReporting for InferCtxt {\n         ty::note_and_explain_type_err(self.tcx, terr);\n     }\n \n-    fn values_str(@mut self, values: &ValuePairs) -> Option<~str> {\n+    fn values_str(@self, values: &ValuePairs) -> Option<~str> {\n         /*!\n          * Returns a string of the form \"expected `{}` but found `{}`\",\n          * or None if this is a derived error.\n@@ -195,7 +195,7 @@ impl ErrorReporting for InferCtxt {\n     }\n \n     fn expected_found_str<T:UserString+Resolvable>(\n-        @mut self,\n+        @self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<~str>\n     {\n@@ -214,7 +214,7 @@ impl ErrorReporting for InferCtxt {\n                   found.user_string(self.tcx)))\n     }\n \n-    fn report_concrete_failure(@mut self,\n+    fn report_concrete_failure(@self,\n                                origin: SubregionOrigin,\n                                sub: Region,\n                                sup: Region) {\n@@ -400,7 +400,7 @@ impl ErrorReporting for InferCtxt {\n         }\n     }\n \n-    fn report_sub_sup_conflict(@mut self,\n+    fn report_sub_sup_conflict(@self,\n                                var_origin: RegionVariableOrigin,\n                                sub_origin: SubregionOrigin,\n                                sub_region: Region,\n@@ -425,7 +425,7 @@ impl ErrorReporting for InferCtxt {\n         self.note_region_origin(sub_origin);\n     }\n \n-    fn report_sup_sup_conflict(@mut self,\n+    fn report_sup_sup_conflict(@self,\n                                var_origin: RegionVariableOrigin,\n                                origin1: SubregionOrigin,\n                                region1: Region,\n@@ -452,7 +452,7 @@ impl ErrorReporting for InferCtxt {\n }\n \n impl ErrorReportingHelpers for InferCtxt {\n-    fn report_inference_failure(@mut self,\n+    fn report_inference_failure(@self,\n                                 var_origin: RegionVariableOrigin) {\n         let var_description = match var_origin {\n             infer::MiscVariable(_) => ~\"\",\n@@ -484,8 +484,7 @@ impl ErrorReportingHelpers for InferCtxt {\n                     var_description));\n     }\n \n-    fn note_region_origin(@mut self,\n-                          origin: SubregionOrigin) {\n+    fn note_region_origin(@self, origin: SubregionOrigin) {\n         match origin {\n             infer::Subtype(ref trace) => {\n                 let desc = match trace.origin {\n@@ -612,12 +611,12 @@ impl ErrorReportingHelpers for InferCtxt {\n }\n \n trait Resolvable {\n-    fn resolve(&self, infcx: @mut InferCtxt) -> Self;\n+    fn resolve(&self, infcx: @InferCtxt) -> Self;\n     fn contains_error(&self) -> bool;\n }\n \n impl Resolvable for ty::t {\n-    fn resolve(&self, infcx: @mut InferCtxt) -> ty::t {\n+    fn resolve(&self, infcx: @InferCtxt) -> ty::t {\n         infcx.resolve_type_vars_if_possible(*self)\n     }\n     fn contains_error(&self) -> bool {\n@@ -626,7 +625,7 @@ impl Resolvable for ty::t {\n }\n \n impl Resolvable for @ty::TraitRef {\n-    fn resolve(&self, infcx: @mut InferCtxt) -> @ty::TraitRef {\n+    fn resolve(&self, infcx: @InferCtxt) -> @ty::TraitRef {\n         @infcx.resolve_type_vars_in_trait_ref_if_possible(*self)\n     }\n     fn contains_error(&self) -> bool {"}, {"sha": "a9aaa5df2ca99c446eb6b11b90fcea0be9574999", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -30,7 +30,7 @@ use util::ppaux::mt_to_str;\n pub struct Glb(CombineFields);  // \"greatest lower bound\" (common subtype)\n \n impl Combine for Glb {\n-    fn infcx(&self) -> @mut InferCtxt { self.infcx }\n+    fn infcx(&self) -> @InferCtxt { self.infcx }\n     fn tag(&self) -> ~str { ~\"glb\" }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n     fn trace(&self) -> TypeTrace { self.trace }"}, {"sha": "5af8c5571957d1a35d6d28527fdd7652cf6913e6", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -36,7 +36,7 @@ impl Lub {\n }\n \n impl Combine for Lub {\n-    fn infcx(&self) -> @mut InferCtxt { self.infcx }\n+    fn infcx(&self) -> @InferCtxt { self.infcx }\n     fn tag(&self) -> ~str { ~\"lub\" }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n     fn trace(&self) -> TypeTrace { self.trace }"}, {"sha": "8a95f9d1bff3fdd72f6a0686e44f44317b2ed669", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 91, "deletions": 79, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -35,6 +35,7 @@ use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::{ValsAndBindings, Root};\n use middle::typeck::infer::error_reporting::ErrorReporting;\n+use std::cell::{Cell, RefCell};\n use std::hashmap::HashMap;\n use std::result;\n use std::vec;\n@@ -43,8 +44,8 @@ use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::Span;\n use util::common::indent;\n-use util::ppaux::{bound_region_to_str, ty_to_str, trait_ref_to_str, Repr,\n-                  UserString};\n+use util::ppaux::{bound_region_to_str, ty_to_str, trait_ref_to_str, Repr};\n+use util::ppaux::{UserString};\n \n pub mod doc;\n pub mod macros;\n@@ -79,16 +80,18 @@ pub struct InferCtxt {\n     // We instantiate ValsAndBindings with bounds<ty::t> because the\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n-    ty_var_bindings: ValsAndBindings<ty::TyVid, Bounds<ty::t>>,\n-    ty_var_counter: uint,\n+    ty_var_bindings: RefCell<ValsAndBindings<ty::TyVid, Bounds<ty::t>>>,\n+    ty_var_counter: Cell<uint>,\n \n     // Map from integral variable to the kind of integer it represents\n-    int_var_bindings: ValsAndBindings<ty::IntVid, Option<IntVarValue>>,\n-    int_var_counter: uint,\n+    int_var_bindings: RefCell<ValsAndBindings<ty::IntVid,\n+                                              Option<IntVarValue>>>,\n+    int_var_counter: Cell<uint>,\n \n     // Map from floating variable to the kind of float it represents\n-    float_var_bindings: ValsAndBindings<ty::FloatVid, Option<ast::float_ty>>,\n-    float_var_counter: uint,\n+    float_var_bindings: RefCell<ValsAndBindings<ty::FloatVid,\n+                                                Option<ast::float_ty>>>,\n+    float_var_counter: Cell<uint>,\n \n     // For region variables.\n     region_vars: RegionVarBindings,\n@@ -255,24 +258,24 @@ fn new_ValsAndBindings<V:Clone,T:Clone>() -> ValsAndBindings<V, T> {\n     }\n }\n \n-pub fn new_infer_ctxt(tcx: ty::ctxt) -> @mut InferCtxt {\n-    @mut InferCtxt {\n+pub fn new_infer_ctxt(tcx: ty::ctxt) -> @InferCtxt {\n+    @InferCtxt {\n         tcx: tcx,\n \n-        ty_var_bindings: new_ValsAndBindings(),\n-        ty_var_counter: 0,\n+        ty_var_bindings: RefCell::new(new_ValsAndBindings()),\n+        ty_var_counter: Cell::new(0),\n \n-        int_var_bindings: new_ValsAndBindings(),\n-        int_var_counter: 0,\n+        int_var_bindings: RefCell::new(new_ValsAndBindings()),\n+        int_var_counter: Cell::new(0),\n \n-        float_var_bindings: new_ValsAndBindings(),\n-        float_var_counter: 0,\n+        float_var_bindings: RefCell::new(new_ValsAndBindings()),\n+        float_var_counter: Cell::new(0),\n \n         region_vars: RegionVarBindings(tcx),\n     }\n }\n \n-pub fn common_supertype(cx: @mut InferCtxt,\n+pub fn common_supertype(cx: @InferCtxt,\n                         origin: TypeOrigin,\n                         a_is_expected: bool,\n                         a: ty::t,\n@@ -300,7 +303,7 @@ pub fn common_supertype(cx: @mut InferCtxt,\n     }\n }\n \n-pub fn mk_subty(cx: @mut InferCtxt,\n+pub fn mk_subty(cx: @InferCtxt,\n                 a_is_expected: bool,\n                 origin: TypeOrigin,\n                 a: ty::t,\n@@ -318,7 +321,7 @@ pub fn mk_subty(cx: @mut InferCtxt,\n     }).to_ures()\n }\n \n-pub fn can_mk_subty(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n+pub fn can_mk_subty(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_subty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n     indent(|| {\n         cx.probe(|| {\n@@ -331,7 +334,7 @@ pub fn can_mk_subty(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n     }).to_ures()\n }\n \n-pub fn mk_subr(cx: @mut InferCtxt,\n+pub fn mk_subr(cx: @InferCtxt,\n                _a_is_expected: bool,\n                origin: SubregionOrigin,\n                a: ty::Region,\n@@ -342,7 +345,7 @@ pub fn mk_subr(cx: @mut InferCtxt,\n     cx.region_vars.commit();\n }\n \n-pub fn mk_eqty(cx: @mut InferCtxt,\n+pub fn mk_eqty(cx: @InferCtxt,\n                a_is_expected: bool,\n                origin: TypeOrigin,\n                a: ty::t,\n@@ -361,7 +364,7 @@ pub fn mk_eqty(cx: @mut InferCtxt,\n     }).to_ures()\n }\n \n-pub fn mk_sub_trait_refs(cx: @mut InferCtxt,\n+pub fn mk_sub_trait_refs(cx: @InferCtxt,\n                          a_is_expected: bool,\n                          origin: TypeOrigin,\n                          a: @ty::TraitRef,\n@@ -392,7 +395,7 @@ fn expected_found<T>(a_is_expected: bool,\n     }\n }\n \n-pub fn mk_coercety(cx: @mut InferCtxt,\n+pub fn mk_coercety(cx: @InferCtxt,\n                    a_is_expected: bool,\n                    origin: TypeOrigin,\n                    a: ty::t,\n@@ -410,7 +413,7 @@ pub fn mk_coercety(cx: @mut InferCtxt,\n     })\n }\n \n-pub fn can_mk_coercety(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n+pub fn can_mk_coercety(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_coercety({} -> {})\", a.inf_str(cx), b.inf_str(cx));\n     indent(|| {\n         cx.probe(|| {\n@@ -424,15 +427,15 @@ pub fn can_mk_coercety(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n }\n \n // See comment on the type `resolve_state` below\n-pub fn resolve_type(cx: @mut InferCtxt,\n+pub fn resolve_type(cx: @InferCtxt,\n                     a: ty::t,\n                     modes: uint)\n                  -> fres<ty::t> {\n     let mut resolver = resolver(cx, modes);\n     resolver.resolve_type_chk(a)\n }\n \n-pub fn resolve_region(cx: @mut InferCtxt, r: ty::Region, modes: uint)\n+pub fn resolve_region(cx: @InferCtxt, r: ty::Region, modes: uint)\n                    -> fres<ty::Region> {\n     let mut resolver = resolver(cx, modes);\n     resolver.resolve_region_chk(r)\n@@ -499,69 +502,69 @@ struct Snapshot {\n }\n \n impl InferCtxt {\n-    pub fn combine_fields(@mut self,\n-                          a_is_expected: bool,\n-                          trace: TypeTrace)\n+    pub fn combine_fields(@self, a_is_expected: bool, trace: TypeTrace)\n                           -> CombineFields {\n         CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n                        trace: trace}\n     }\n \n-    pub fn sub(@mut self, a_is_expected: bool, trace: TypeTrace) -> Sub {\n+    pub fn sub(@self, a_is_expected: bool, trace: TypeTrace) -> Sub {\n         Sub(self.combine_fields(a_is_expected, trace))\n     }\n \n-    pub fn lub(@mut self, a_is_expected: bool, trace: TypeTrace) -> Lub {\n+    pub fn lub(@self, a_is_expected: bool, trace: TypeTrace) -> Lub {\n         Lub(self.combine_fields(a_is_expected, trace))\n     }\n \n     pub fn in_snapshot(&self) -> bool {\n         self.region_vars.in_snapshot()\n     }\n \n-    pub fn start_snapshot(&mut self) -> Snapshot {\n+    pub fn start_snapshot(&self) -> Snapshot {\n+        let ty_var_bindings = self.ty_var_bindings.borrow();\n+        let int_var_bindings = self.int_var_bindings.borrow();\n+        let float_var_bindings = self.float_var_bindings.borrow();\n         Snapshot {\n-            ty_var_bindings_len:\n-                self.ty_var_bindings.bindings.len(),\n-            int_var_bindings_len:\n-                self.int_var_bindings.bindings.len(),\n-            float_var_bindings_len:\n-                self.float_var_bindings.bindings.len(),\n-            region_vars_snapshot:\n-                self.region_vars.start_snapshot(),\n+            ty_var_bindings_len: ty_var_bindings.get().bindings.len(),\n+            int_var_bindings_len: int_var_bindings.get().bindings.len(),\n+            float_var_bindings_len: float_var_bindings.get().bindings.len(),\n+            region_vars_snapshot: self.region_vars.start_snapshot(),\n         }\n     }\n \n-    pub fn rollback_to(&mut self, snapshot: &Snapshot) {\n+    pub fn rollback_to(&self, snapshot: &Snapshot) {\n         debug!(\"rollback!\");\n-        rollback_to(&mut self.ty_var_bindings, snapshot.ty_var_bindings_len);\n-\n-        rollback_to(&mut self.int_var_bindings,\n-                    snapshot.int_var_bindings_len);\n-        rollback_to(&mut self.float_var_bindings,\n+        let mut ty_var_bindings = self.ty_var_bindings.borrow_mut();\n+        let mut int_var_bindings = self.int_var_bindings.borrow_mut();\n+        let mut float_var_bindings = self.float_var_bindings.borrow_mut();\n+        rollback_to(ty_var_bindings.get(), snapshot.ty_var_bindings_len);\n+        rollback_to(int_var_bindings.get(), snapshot.int_var_bindings_len);\n+        rollback_to(float_var_bindings.get(),\n                     snapshot.float_var_bindings_len);\n \n         self.region_vars.rollback_to(snapshot.region_vars_snapshot);\n     }\n \n     /// Execute `f` and commit the bindings if successful\n-    pub fn commit<T,E>(@mut self, f: || -> Result<T,E>) -> Result<T,E> {\n+    pub fn commit<T,E>(@self, f: || -> Result<T,E>) -> Result<T,E> {\n         assert!(!self.in_snapshot());\n \n         debug!(\"commit()\");\n         indent(|| {\n             let r = self.try(|| f());\n \n-            self.ty_var_bindings.bindings.truncate(0);\n-            self.int_var_bindings.bindings.truncate(0);\n+            let mut ty_var_bindings = self.ty_var_bindings.borrow_mut();\n+            let mut int_var_bindings = self.int_var_bindings.borrow_mut();\n+            ty_var_bindings.get().bindings.truncate(0);\n+            int_var_bindings.get().bindings.truncate(0);\n             self.region_vars.commit();\n             r\n         })\n     }\n \n     /// Execute `f`, unroll bindings on failure\n-    pub fn try<T,E>(@mut self, f: || -> Result<T,E>) -> Result<T,E> {\n+    pub fn try<T,E>(@self, f: || -> Result<T,E>) -> Result<T,E> {\n         debug!(\"try()\");\n         let snapshot = self.start_snapshot();\n         let r = f();\n@@ -576,7 +579,7 @@ impl InferCtxt {\n     }\n \n     /// Execute `f` then unroll any bindings it creates\n-    pub fn probe<T,E>(@mut self, f: || -> Result<T,E>) -> Result<T,E> {\n+    pub fn probe<T,E>(@self, f: || -> Result<T,E>) -> Result<T,E> {\n         debug!(\"probe()\");\n         indent(|| {\n             let snapshot = self.start_snapshot();\n@@ -598,85 +601,94 @@ fn next_simple_var<V:Clone,T:Clone>(counter: &mut uint,\n }\n \n impl InferCtxt {\n-    pub fn next_ty_var_id(&mut self) -> TyVid {\n-        let id = self.ty_var_counter;\n-        self.ty_var_counter += 1;\n+    pub fn next_ty_var_id(&self) -> TyVid {\n+        let id = self.ty_var_counter.get();\n+        self.ty_var_counter.set(id + 1);\n         {\n-            let vals = &mut self.ty_var_bindings.vals;\n+            let mut ty_var_bindings = self.ty_var_bindings.borrow_mut();\n+            let vals = &mut ty_var_bindings.get().vals;\n             vals.insert(id, Root(Bounds { lb: None, ub: None }, 0u));\n         }\n         return TyVid(id);\n     }\n \n-    pub fn next_ty_var(&mut self) -> ty::t {\n+    pub fn next_ty_var(&self) -> ty::t {\n         ty::mk_var(self.tcx, self.next_ty_var_id())\n     }\n \n-    pub fn next_ty_vars(&mut self, n: uint) -> ~[ty::t] {\n+    pub fn next_ty_vars(&self, n: uint) -> ~[ty::t] {\n         vec::from_fn(n, |_i| self.next_ty_var())\n     }\n \n-    pub fn next_int_var_id(&mut self) -> IntVid {\n-        IntVid(next_simple_var(&mut self.int_var_counter,\n-                               &mut self.int_var_bindings))\n+    pub fn next_int_var_id(&self) -> IntVid {\n+        let mut int_var_counter = self.int_var_counter.get();\n+        let mut int_var_bindings = self.int_var_bindings.borrow_mut();\n+        let result = IntVid(next_simple_var(&mut int_var_counter,\n+                                            int_var_bindings.get()));\n+        self.int_var_counter.set(int_var_counter);\n+        result\n     }\n \n-    pub fn next_int_var(&mut self) -> ty::t {\n+    pub fn next_int_var(&self) -> ty::t {\n         ty::mk_int_var(self.tcx, self.next_int_var_id())\n     }\n \n-    pub fn next_float_var_id(&mut self) -> FloatVid {\n-        FloatVid(next_simple_var(&mut self.float_var_counter,\n-                                 &mut self.float_var_bindings))\n+    pub fn next_float_var_id(&self) -> FloatVid {\n+        let mut float_var_counter = self.float_var_counter.get();\n+        let mut float_var_bindings = self.float_var_bindings.borrow_mut();\n+        let result = FloatVid(next_simple_var(&mut float_var_counter,\n+                                              float_var_bindings.get()));\n+        self.float_var_counter.set(float_var_counter);\n+        result\n     }\n \n-    pub fn next_float_var(&mut self) -> ty::t {\n+    pub fn next_float_var(&self) -> ty::t {\n         ty::mk_float_var(self.tcx, self.next_float_var_id())\n     }\n \n-    pub fn next_region_var(&mut self, origin: RegionVariableOrigin) -> ty::Region {\n+    pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region {\n         ty::ReInfer(ty::ReVar(self.region_vars.new_region_var(origin)))\n     }\n \n-    pub fn next_region_vars(&mut self,\n+    pub fn next_region_vars(&self,\n                             origin: RegionVariableOrigin,\n                             count: uint)\n                             -> ~[ty::Region] {\n         vec::from_fn(count, |_| self.next_region_var(origin))\n     }\n \n-    pub fn fresh_bound_region(&mut self, binder_id: ast::NodeId) -> ty::Region {\n+    pub fn fresh_bound_region(&self, binder_id: ast::NodeId) -> ty::Region {\n         self.region_vars.new_bound(binder_id)\n     }\n \n-    pub fn resolve_regions(@mut self) {\n+    pub fn resolve_regions(@self) {\n         let errors = self.region_vars.resolve_regions();\n         self.report_region_errors(&errors); // see error_reporting.rs\n     }\n \n-    pub fn ty_to_str(@mut self, t: ty::t) -> ~str {\n+    pub fn ty_to_str(@self, t: ty::t) -> ~str {\n         ty_to_str(self.tcx,\n                   self.resolve_type_vars_if_possible(t))\n     }\n \n-    pub fn tys_to_str(@mut self, ts: &[ty::t]) -> ~str {\n+    pub fn tys_to_str(@self, ts: &[ty::t]) -> ~str {\n         let tstrs = ts.map(|t| self.ty_to_str(*t));\n         format!(\"({})\", tstrs.connect(\", \"))\n     }\n \n-    pub fn trait_ref_to_str(@mut self, t: &ty::TraitRef) -> ~str {\n+    pub fn trait_ref_to_str(@self, t: &ty::TraitRef) -> ~str {\n         let t = self.resolve_type_vars_in_trait_ref_if_possible(t);\n         trait_ref_to_str(self.tcx, &t)\n     }\n \n-    pub fn resolve_type_vars_if_possible(@mut self, typ: ty::t) -> ty::t {\n+    pub fn resolve_type_vars_if_possible(@self, typ: ty::t) -> ty::t {\n         match resolve_type(self, typ, resolve_nested_tvar | resolve_ivar) {\n           result::Ok(new_type) => new_type,\n           result::Err(_) => typ\n         }\n     }\n \n-    pub fn resolve_type_vars_in_trait_ref_if_possible(@mut self,\n+    pub fn resolve_type_vars_in_trait_ref_if_possible(@self,\n                                                       trait_ref:\n                                                       &ty::TraitRef)\n                                                       -> ty::TraitRef {\n@@ -716,15 +728,15 @@ impl InferCtxt {\n     // in this case. The typechecker should only ever report type errors involving mismatched\n     // types using one of these four methods, and should not call span_err directly for such\n     // errors.\n-    pub fn type_error_message_str(@mut self,\n+    pub fn type_error_message_str(@self,\n                                   sp: Span,\n                                   mk_msg: |Option<~str>, ~str| -> ~str,\n                                   actual_ty: ~str,\n                                   err: Option<&ty::type_err>) {\n         self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n     }\n \n-    pub fn type_error_message_str_with_expected(@mut self,\n+    pub fn type_error_message_str_with_expected(@self,\n                                                 sp: Span,\n                                                 mk_msg: |Option<~str>,\n                                                          ~str|\n@@ -755,7 +767,7 @@ impl InferCtxt {\n         }\n     }\n \n-    pub fn type_error_message(@mut self,\n+    pub fn type_error_message(@self,\n                               sp: Span,\n                               mk_msg: |~str| -> ~str,\n                               actual_ty: ty::t,\n@@ -770,7 +782,7 @@ impl InferCtxt {\n         self.type_error_message_str(sp, |_e, a| { mk_msg(a) }, self.ty_to_str(actual_ty), err);\n     }\n \n-    pub fn report_mismatched_types(@mut self,\n+    pub fn report_mismatched_types(@self,\n                                    sp: Span,\n                                    e: ty::t,\n                                    a: ty::t,\n@@ -791,7 +803,7 @@ impl InferCtxt {\n         self.type_error_message(sp, mk_msg, a, Some(err));\n     }\n \n-    pub fn replace_bound_regions_with_fresh_regions(&mut self,\n+    pub fn replace_bound_regions_with_fresh_regions(&self,\n                                                     trace: TypeTrace,\n                                                     fsig: &ty::FnSig)\n                                                     -> (ty::FnSig,"}, {"sha": "8d8524e0f512f6179318584bb1ede785c53fb82d", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 174, "deletions": 114, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -24,6 +24,7 @@ use middle::graph::{Direction, NodeIndex};\n use util::common::indenter;\n use util::ppaux::{Repr};\n \n+use std::cell::{Cell, RefCell};\n use std::hashmap::{HashMap, HashSet};\n use std::uint;\n use std::vec;\n@@ -87,12 +88,12 @@ type CombineMap = HashMap<TwoRegions, RegionVid>;\n \n pub struct RegionVarBindings {\n     tcx: ty::ctxt,\n-    var_origins: ~[RegionVariableOrigin],\n-    constraints: HashMap<Constraint, SubregionOrigin>,\n-    lubs: CombineMap,\n-    glbs: CombineMap,\n-    skolemization_count: uint,\n-    bound_count: uint,\n+    var_origins: RefCell<~[RegionVariableOrigin]>,\n+    constraints: RefCell<HashMap<Constraint, SubregionOrigin>>,\n+    lubs: RefCell<CombineMap>,\n+    glbs: RefCell<CombineMap>,\n+    skolemization_count: Cell<uint>,\n+    bound_count: Cell<uint>,\n \n     // The undo log records actions that might later be undone.\n     //\n@@ -102,96 +103,114 @@ pub struct RegionVarBindings {\n     // actively snapshotting.  The reason for this is that otherwise\n     // we end up adding entries for things like the lower bound on\n     // a variable and so forth, which can never be rolled back.\n-    undo_log: ~[UndoLogEntry],\n+    undo_log: RefCell<~[UndoLogEntry]>,\n \n     // This contains the results of inference.  It begins as an empty\n     // option and only acquires a value after inference is complete.\n-    values: Option<~[VarValue]>,\n+    values: RefCell<Option<~[VarValue]>>,\n }\n \n pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n     RegionVarBindings {\n         tcx: tcx,\n-        var_origins: ~[],\n-        values: None,\n-        constraints: HashMap::new(),\n-        lubs: HashMap::new(),\n-        glbs: HashMap::new(),\n-        skolemization_count: 0,\n-        bound_count: 0,\n-        undo_log: ~[]\n+        var_origins: RefCell::new(~[]),\n+        values: RefCell::new(None),\n+        constraints: RefCell::new(HashMap::new()),\n+        lubs: RefCell::new(HashMap::new()),\n+        glbs: RefCell::new(HashMap::new()),\n+        skolemization_count: Cell::new(0),\n+        bound_count: Cell::new(0),\n+        undo_log: RefCell::new(~[])\n     }\n }\n \n impl RegionVarBindings {\n     pub fn in_snapshot(&self) -> bool {\n-        self.undo_log.len() > 0\n+        let undo_log = self.undo_log.borrow();\n+        undo_log.get().len() > 0\n     }\n \n-    pub fn start_snapshot(&mut self) -> uint {\n-        debug!(\"RegionVarBindings: snapshot()={}\", self.undo_log.len());\n+    pub fn start_snapshot(&self) -> uint {\n+        debug!(\"RegionVarBindings: start_snapshot()\");\n         if self.in_snapshot() {\n-            self.undo_log.len()\n+            {\n+                let undo_log = self.undo_log.borrow();\n+                undo_log.get().len()\n+            }\n         } else {\n-            self.undo_log.push(Snapshot);\n-            0\n+            {\n+                let mut undo_log = self.undo_log.borrow_mut();\n+                undo_log.get().push(Snapshot);\n+                0\n+            }\n         }\n     }\n \n-    pub fn commit(&mut self) {\n+    pub fn commit(&self) {\n         debug!(\"RegionVarBindings: commit()\");\n-        while self.undo_log.len() > 0 {\n-            self.undo_log.pop();\n+        let mut undo_log = self.undo_log.borrow_mut();\n+        while undo_log.get().len() > 0 {\n+            undo_log.get().pop();\n         }\n     }\n \n-    pub fn rollback_to(&mut self, snapshot: uint) {\n+    pub fn rollback_to(&self, snapshot: uint) {\n         debug!(\"RegionVarBindings: rollback_to({})\", snapshot);\n-        while self.undo_log.len() > snapshot {\n-            let undo_item = self.undo_log.pop();\n+        let mut undo_log = self.undo_log.borrow_mut();\n+        while undo_log.get().len() > snapshot {\n+            let undo_item = undo_log.get().pop();\n             debug!(\"undo_item={:?}\", undo_item);\n             match undo_item {\n               Snapshot => {}\n               AddVar(vid) => {\n-                assert_eq!(self.var_origins.len(), vid.to_uint() + 1);\n-                self.var_origins.pop();\n+                let mut var_origins = self.var_origins.borrow_mut();\n+                assert_eq!(var_origins.get().len(), vid.to_uint() + 1);\n+                var_origins.get().pop();\n               }\n               AddConstraint(ref constraint) => {\n-                self.constraints.remove(constraint);\n+                let mut constraints = self.constraints.borrow_mut();\n+                constraints.get().remove(constraint);\n               }\n               AddCombination(Glb, ref regions) => {\n-                self.glbs.remove(regions);\n+                let mut glbs = self.glbs.borrow_mut();\n+                glbs.get().remove(regions);\n               }\n               AddCombination(Lub, ref regions) => {\n-                self.lubs.remove(regions);\n+                let mut lubs = self.lubs.borrow_mut();\n+                lubs.get().remove(regions);\n               }\n             }\n         }\n     }\n \n     pub fn num_vars(&self) -> uint {\n-        self.var_origins.len()\n+        let var_origins = self.var_origins.borrow();\n+        var_origins.get().len()\n     }\n \n-    pub fn new_region_var(&mut self, origin: RegionVariableOrigin) -> RegionVid {\n+    pub fn new_region_var(&self, origin: RegionVariableOrigin) -> RegionVid {\n         let id = self.num_vars();\n-        self.var_origins.push(origin);\n+        let mut var_origins = self.var_origins.borrow_mut();\n+        var_origins.get().push(origin);\n         let vid = RegionVid { id: id };\n         if self.in_snapshot() {\n-            self.undo_log.push(AddVar(vid));\n+            {\n+                let mut undo_log = self.undo_log.borrow_mut();\n+                undo_log.get().push(AddVar(vid));\n+            }\n         }\n         debug!(\"created new region variable {:?} with origin {:?}\",\n                vid, origin.repr(self.tcx));\n         return vid;\n     }\n \n-    pub fn new_skolemized(&mut self, br: ty::BoundRegion) -> Region {\n-        let sc = self.skolemization_count;\n-        self.skolemization_count += 1;\n+    pub fn new_skolemized(&self, br: ty::BoundRegion) -> Region {\n+        let sc = self.skolemization_count.get();\n+        self.skolemization_count.set(sc + 1);\n         ReInfer(ReSkolemized(sc, br))\n     }\n \n-    pub fn new_bound(&mut self, binder_id: ast::NodeId) -> Region {\n+    pub fn new_bound(&self, binder_id: ast::NodeId) -> Region {\n         // Creates a fresh bound variable for use in GLB computations.\n         // See discussion of GLB computation in the large comment at\n         // the top of this file for more details.\n@@ -210,37 +229,46 @@ impl RegionVarBindings {\n         // changing the representation of bound regions in a fn\n         // declaration\n \n-        let sc = self.bound_count;\n-        self.bound_count += 1;\n+        let sc = self.bound_count.get();\n+        self.bound_count.set(sc + 1);\n \n-        if sc >= self.bound_count {\n+        if sc >= self.bound_count.get() {\n             self.tcx.sess.bug(\"Rollover in RegionInference new_bound()\");\n         }\n \n         ReLateBound(binder_id, BrFresh(sc))\n     }\n \n-    pub fn add_constraint(&mut self,\n+    fn values_are_none(&self) -> bool {\n+        let values = self.values.borrow();\n+        values.get().is_none()\n+    }\n+\n+    pub fn add_constraint(&self,\n                           constraint: Constraint,\n                           origin: SubregionOrigin) {\n         // cannot add constraints once regions are resolved\n-        assert!(self.values.is_none());\n+        assert!(self.values_are_none());\n \n         debug!(\"RegionVarBindings: add_constraint({:?})\", constraint);\n \n-        if self.constraints.insert(constraint, origin) {\n+        let mut constraints = self.constraints.borrow_mut();\n+        if constraints.get().insert(constraint, origin) {\n             if self.in_snapshot() {\n-                self.undo_log.push(AddConstraint(constraint));\n+                {\n+                    let mut undo_log = self.undo_log.borrow_mut();\n+                    undo_log.get().push(AddConstraint(constraint));\n+                }\n             }\n         }\n     }\n \n-    pub fn make_subregion(&mut self,\n+    pub fn make_subregion(&self,\n                           origin: SubregionOrigin,\n                           sub: Region,\n                           sup: Region) {\n         // cannot add constraints once regions are resolved\n-        assert!(self.values.is_none());\n+        assert!(self.values_are_none());\n \n         debug!(\"RegionVarBindings: make_subregion({:?}, {:?})\", sub, sup);\n         match (sub, sup) {\n@@ -269,13 +297,13 @@ impl RegionVarBindings {\n         }\n     }\n \n-    pub fn lub_regions(&mut self,\n+    pub fn lub_regions(&self,\n                        origin: SubregionOrigin,\n                        a: Region,\n                        b: Region)\n                        -> Region {\n         // cannot add constraints once regions are resolved\n-        assert!(self.values.is_none());\n+        assert!(self.values_are_none());\n \n         debug!(\"RegionVarBindings: lub_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n@@ -292,13 +320,13 @@ impl RegionVarBindings {\n         }\n     }\n \n-    pub fn glb_regions(&mut self,\n+    pub fn glb_regions(&self,\n                        origin: SubregionOrigin,\n                        a: Region,\n                        b: Region)\n                        -> Region {\n         // cannot add constraints once regions are resolved\n-        assert!(self.values.is_none());\n+        assert!(self.values_are_none());\n \n         debug!(\"RegionVarBindings: glb_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n@@ -316,12 +344,16 @@ impl RegionVarBindings {\n         }\n     }\n \n-    pub fn resolve_var(&mut self, rid: RegionVid) -> ty::Region {\n-        let v = match self.values {\n-            None => self.tcx.sess.span_bug(\n-                self.var_origins[rid.to_uint()].span(),\n-                format!(\"Attempt to resolve region variable before values have \\\n-                      been computed!\")),\n+    pub fn resolve_var(&self, rid: RegionVid) -> ty::Region {\n+        let values = self.values.borrow();\n+        let v = match *values.get() {\n+            None => {\n+                let var_origins = self.var_origins.borrow();\n+                self.tcx.sess.span_bug(\n+                    var_origins.get()[rid.to_uint()].span(),\n+                    format!(\"Attempt to resolve region variable before \\\n+                             values have been computed!\"))\n+            }\n             Some(ref values) => values[rid.to_uint()]\n         };\n \n@@ -342,54 +374,62 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn combine_map<'a>(&'a mut self,\n-                       t: CombineMapType)\n-                       -> &'a mut CombineMap\n-    {\n+    fn combine_map<'a>(&'a self, t: CombineMapType)\n+                   -> &'a RefCell<CombineMap> {\n         match t {\n-            Glb => &mut self.glbs,\n-            Lub => &mut self.lubs,\n+            Glb => &self.glbs,\n+            Lub => &self.lubs,\n         }\n     }\n \n-    pub fn combine_vars(&mut self,\n+    pub fn combine_vars(&self,\n                         t: CombineMapType,\n                         a: Region,\n                         b: Region,\n                         origin: SubregionOrigin,\n-                        relate: |this: &mut RegionVarBindings,\n+                        relate: |this: &RegionVarBindings,\n                                  old_r: Region,\n                                  new_r: Region|)\n                         -> Region {\n         let vars = TwoRegions { a: a, b: b };\n-        match self.combine_map(t).find(&vars) {\n-            Some(&c) => {\n-                return ReInfer(ReVar(c));\n+        {\n+            let map = self.combine_map(t).borrow();\n+            match map.get().find(&vars) {\n+                Some(&c) => {\n+                    return ReInfer(ReVar(c));\n+                }\n+                None => {}\n             }\n-            None => {}\n         }\n         let c = self.new_region_var(infer::MiscVariable(origin.span()));\n-        self.combine_map(t).insert(vars, c);\n+        {\n+            let mut map = self.combine_map(t).borrow_mut();\n+            map.get().insert(vars, c);\n+        }\n         if self.in_snapshot() {\n-            self.undo_log.push(AddCombination(t, vars));\n+            {\n+                let mut undo_log = self.undo_log.borrow_mut();\n+                undo_log.get().push(AddCombination(t, vars));\n+            }\n         }\n         relate(self, a, ReInfer(ReVar(c)));\n         relate(self, b, ReInfer(ReVar(c)));\n         debug!(\"combine_vars() c={:?}\", c);\n         ReInfer(ReVar(c))\n     }\n \n-    pub fn vars_created_since_snapshot(&mut self, snapshot: uint)\n+    pub fn vars_created_since_snapshot(&self, snapshot: uint)\n                                        -> ~[RegionVid] {\n-        self.undo_log.slice_from(snapshot).iter()\n+        let undo_log = self.undo_log.borrow();\n+        undo_log.get().slice_from(snapshot).iter()\n             .filter_map(|&elt| match elt {\n                 AddVar(vid) => Some(vid),\n                 _ => None\n             })\n             .collect()\n     }\n \n-    pub fn tainted(&mut self, snapshot: uint, r0: Region) -> ~[Region] {\n+    pub fn tainted(&self, snapshot: uint, r0: Region) -> ~[Region] {\n         /*!\n          * Computes all regions that have been related to `r0` in any\n          * way since the snapshot `snapshot` was taken---`r0` itself\n@@ -401,7 +441,10 @@ impl RegionVarBindings {\n         debug!(\"tainted(snapshot={}, r0={:?})\", snapshot, r0);\n         let _indenter = indenter();\n \n-        let undo_len = self.undo_log.len();\n+        let undo_len = {\n+            let undo_log = self.undo_log.borrow();\n+            undo_log.get().len()\n+        };\n \n         // `result_set` acts as a worklist: we explore all outgoing\n         // edges and add any new regions we find to result_set.  This\n@@ -417,22 +460,25 @@ impl RegionVarBindings {\n             let mut undo_index = snapshot;\n             while undo_index < undo_len {\n                 // nb: can't use uint::range() here as we move result_set\n-                let regs = match self.undo_log[undo_index] {\n-                    AddConstraint(ConstrainVarSubVar(ref a, ref b)) => {\n-                        Some((ReInfer(ReVar(*a)),\n-                              ReInfer(ReVar(*b))))\n-                    }\n-                    AddConstraint(ConstrainRegSubVar(ref a, ref b)) => {\n-                        Some((*a, ReInfer(ReVar(*b))))\n-                    }\n-                    AddConstraint(ConstrainVarSubReg(ref a, ref b)) => {\n-                        Some((ReInfer(ReVar(*a)), *b))\n-                    }\n-                    AddConstraint(ConstrainRegSubReg(a, b)) => {\n-                        Some((a, b))\n-                    }\n-                    _ => {\n-                        None\n+                let regs = {\n+                    let undo_log = self.undo_log.borrow();\n+                    match undo_log.get()[undo_index] {\n+                        AddConstraint(ConstrainVarSubVar(ref a, ref b)) => {\n+                            Some((ReInfer(ReVar(*a)),\n+                                  ReInfer(ReVar(*b))))\n+                        }\n+                        AddConstraint(ConstrainRegSubVar(ref a, ref b)) => {\n+                            Some((*a, ReInfer(ReVar(*b))))\n+                        }\n+                        AddConstraint(ConstrainVarSubReg(ref a, ref b)) => {\n+                            Some((ReInfer(ReVar(*a)), *b))\n+                        }\n+                        AddConstraint(ConstrainRegSubReg(a, b)) => {\n+                            Some((a, b))\n+                        }\n+                        _ => {\n+                            None\n+                        }\n                     }\n                 };\n \n@@ -476,11 +522,12 @@ impl RegionVarBindings {\n     constraints, assuming such values can be found; if they cannot,\n     errors are reported.\n     */\n-    pub fn resolve_regions(&mut self) -> OptVec<RegionResolutionError> {\n+    pub fn resolve_regions(&self) -> OptVec<RegionResolutionError> {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n         let mut errors = opt_vec::Empty;\n         let v = self.infer_variable_values(&mut errors);\n-        self.values = Some(v);\n+        let mut values = self.values.borrow_mut();\n+        *values.get() = Some(v);\n         errors\n     }\n }\n@@ -512,8 +559,9 @@ impl RegionVarBindings {\n           }\n \n           (ReInfer(ReVar(v_id)), _) | (_, ReInfer(ReVar(v_id))) => {\n+            let var_origins = self.var_origins.borrow();\n             self.tcx.sess.span_bug(\n-                self.var_origins[v_id.to_uint()].span(),\n+                var_origins.get()[v_id.to_uint()].span(),\n                 format!(\"lub_concrete_regions invoked with \\\n                       non-concrete regions: {:?}, {:?}\", a, b));\n           }\n@@ -619,8 +667,9 @@ impl RegionVarBindings {\n \n             (ReInfer(ReVar(v_id)), _) |\n             (_, ReInfer(ReVar(v_id))) => {\n+                let var_origins = self.var_origins.borrow();\n                 self.tcx.sess.span_bug(\n-                    self.var_origins[v_id.to_uint()].span(),\n+                    var_origins.get()[v_id.to_uint()].span(),\n                     format!(\"glb_concrete_regions invoked with \\\n                           non-concrete regions: {:?}, {:?}\", a, b));\n             }\n@@ -925,7 +974,8 @@ impl RegionVarBindings {\n         &self,\n         errors: &mut OptVec<RegionResolutionError>)\n     {\n-        for (constraint, _) in self.constraints.iter() {\n+        let constraints = self.constraints.borrow();\n+        for (constraint, _) in constraints.get().iter() {\n             let (sub, sup) = match *constraint {\n                 ConstrainVarSubVar(..) |\n                 ConstrainRegSubVar(..) |\n@@ -943,7 +993,7 @@ impl RegionVarBindings {\n \n             debug!(\"ConcreteFailure: !(sub <= sup): sub={:?}, sup={:?}\",\n                    sub, sup);\n-            let origin = self.constraints.get_copy(constraint);\n+            let origin = constraints.get().get_copy(constraint);\n             errors.push(ConcreteFailure(origin, sub, sup));\n         }\n     }\n@@ -1031,7 +1081,9 @@ impl RegionVarBindings {\n \n     fn construct_graph(&self) -> RegionGraph {\n         let num_vars = self.num_vars();\n-        let num_edges = self.constraints.len();\n+\n+        let constraints = self.constraints.borrow();\n+        let num_edges = constraints.get().len();\n \n         let mut graph = graph::Graph::with_capacity(num_vars + 1,\n                                                     num_edges);\n@@ -1041,7 +1093,7 @@ impl RegionVarBindings {\n         }\n         let dummy_idx = graph.add_node(());\n \n-        for (constraint, _) in self.constraints.iter() {\n+        for (constraint, _) in constraints.get().iter() {\n             match *constraint {\n                 ConstrainVarSubVar(a_id, b_id) => {\n                     graph.add_edge(NodeIndex(a_id.to_uint()),\n@@ -1093,19 +1145,23 @@ impl RegionVarBindings {\n             for upper_bound in upper_bounds.iter() {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n-                    errors.push(SubSupConflict(\n-                        self.var_origins[node_idx.to_uint()],\n-                        lower_bound.origin,\n-                        lower_bound.region,\n-                        upper_bound.origin,\n-                        upper_bound.region));\n-                    return;\n+                    {\n+                        let var_origins = self.var_origins.borrow();\n+                        errors.push(SubSupConflict(\n+                            var_origins.get()[node_idx.to_uint()],\n+                            lower_bound.origin,\n+                            lower_bound.region,\n+                            upper_bound.origin,\n+                            upper_bound.region));\n+                        return;\n+                    }\n                 }\n             }\n         }\n \n+        let var_origins = self.var_origins.borrow();\n         self.tcx.sess.span_bug(\n-            self.var_origins[node_idx.to_uint()].span(),\n+            var_origins.get()[node_idx.to_uint()].span(),\n             format!(\"collect_error_for_expanding_node() could not find error \\\n                   for var {:?}, lower_bounds={}, upper_bounds={}\",\n                  node_idx,\n@@ -1137,8 +1193,9 @@ impl RegionVarBindings {\n                                                 upper_bound_2.region) {\n                   Ok(_) => {}\n                   Err(_) => {\n+                    let var_origins = self.var_origins.borrow();\n                     errors.push(SupSupConflict(\n-                        self.var_origins[node_idx.to_uint()],\n+                        var_origins.get()[node_idx.to_uint()],\n                         upper_bound_1.origin,\n                         upper_bound_1.region,\n                         upper_bound_2.origin,\n@@ -1149,8 +1206,9 @@ impl RegionVarBindings {\n             }\n         }\n \n+        let var_origins = self.var_origins.borrow();\n         self.tcx.sess.span_bug(\n-            self.var_origins[node_idx.to_uint()].span(),\n+            var_origins.get()[node_idx.to_uint()].span(),\n             format!(\"collect_error_for_contracting_node() could not find error \\\n                   for var {:?}, upper_bounds={}\",\n                  node_idx,\n@@ -1230,9 +1288,10 @@ impl RegionVarBindings {\n \n                     ConstrainRegSubVar(region, _) |\n                     ConstrainVarSubReg(_, region) => {\n+                        let constraints = this.constraints.borrow();\n                         state.result.push(RegionAndOrigin {\n                             region: region,\n-                            origin: this.constraints.get_copy(&edge.data)\n+                            origin: constraints.get().get_copy(&edge.data)\n                         });\n                     }\n \n@@ -1252,7 +1311,8 @@ impl RegionVarBindings {\n             changed = false;\n             iteration += 1;\n             debug!(\"---- {} Iteration \\\\#{}\", tag, iteration);\n-            for (constraint, _) in self.constraints.iter() {\n+            let constraints = self.constraints.borrow();\n+            for (constraint, _) in constraints.get().iter() {\n                 let edge_changed = body(constraint);\n                 if edge_changed {\n                     debug!(\"Updated due to constraint {}\","}, {"sha": "93ac3d8c2544534b412ee674770b5aea3d926bfa", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -80,14 +80,14 @@ pub static resolve_and_force_all_but_regions: uint =\n     (resolve_all | force_all) & not_regions;\n \n pub struct ResolveState {\n-    infcx: @mut InferCtxt,\n+    infcx: @InferCtxt,\n     modes: uint,\n     err: Option<fixup_err>,\n     v_seen: ~[TyVid],\n     type_depth: uint\n }\n \n-pub fn resolver(infcx: @mut InferCtxt, modes: uint) -> ResolveState {\n+pub fn resolver(infcx: @InferCtxt, modes: uint) -> ResolveState {\n     ResolveState {\n         infcx: infcx,\n         modes: modes,"}, {"sha": "68fa625f08c40937c9b1b8a4234ffb1952789af6", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -29,7 +29,7 @@ use syntax::ast::{Onceness, purity};\n pub struct Sub(CombineFields);  // \"subtype\", \"subregion\" etc\n \n impl Combine for Sub {\n-    fn infcx(&self) -> @mut InferCtxt { self.infcx }\n+    fn infcx(&self) -> @InferCtxt { self.infcx }\n     fn tag(&self) -> ~str { ~\"sub\" }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n     fn trace(&self) -> TypeTrace { self.trace }"}, {"sha": "1ec9b49ba4b32d94e89a58dafbf09769e9d3aa84", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -16,6 +16,7 @@ use middle::ty;\n use middle::typeck::infer::{Bounds, uok, ures};\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::to_str::InferStr;\n+use std::cell::RefCell;\n use syntax::ast;\n \n #[deriving(Clone)]\n@@ -36,24 +37,24 @@ pub struct Node<V, T> {\n }\n \n pub trait UnifyVid<T> {\n-    fn appropriate_vals_and_bindings<'v>(infcx: &'v mut InferCtxt)\n-                                      -> &'v mut ValsAndBindings<Self, T>;\n+    fn appropriate_vals_and_bindings<'v>(infcx: &'v InferCtxt)\n+                                     -> &'v RefCell<ValsAndBindings<Self, T>>;\n }\n \n pub trait UnifyInferCtxtMethods {\n     fn get<T:Clone,\n            V:Clone + Eq + Vid + UnifyVid<T>>(\n-           &mut self,\n+           &self,\n            vid: V)\n            -> Node<V, T>;\n     fn set<T:Clone + InferStr,\n            V:Clone + Vid + ToStr + UnifyVid<T>>(\n-           &mut self,\n+           &self,\n            vid: V,\n            new_v: VarValue<V, T>);\n     fn unify<T:Clone + InferStr,\n              V:Clone + Vid + ToStr + UnifyVid<T>>(\n-             &mut self,\n+             &self,\n              node_a: &Node<V, T>,\n              node_b: &Node<V, T>)\n              -> (V, uint);\n@@ -62,7 +63,7 @@ pub trait UnifyInferCtxtMethods {\n impl UnifyInferCtxtMethods for InferCtxt {\n     fn get<T:Clone,\n            V:Clone + Eq + Vid + UnifyVid<T>>(\n-           &mut self,\n+           &self,\n            vid: V)\n            -> Node<V, T> {\n         /*!\n@@ -74,7 +75,8 @@ impl UnifyInferCtxtMethods for InferCtxt {\n \n         let tcx = self.tcx;\n         let vb = UnifyVid::appropriate_vals_and_bindings(self);\n-        return helper(tcx, vb, vid);\n+        let mut vb = vb.borrow_mut();\n+        return helper(tcx, vb.get(), vid);\n \n         fn helper<T:Clone, V:Clone+Eq+Vid>(\n             tcx: ty::ctxt,\n@@ -108,7 +110,7 @@ impl UnifyInferCtxtMethods for InferCtxt {\n \n     fn set<T:Clone + InferStr,\n            V:Clone + Vid + ToStr + UnifyVid<T>>(\n-           &mut self,\n+           &self,\n            vid: V,\n            new_v: VarValue<V, T>) {\n         /*!\n@@ -120,14 +122,15 @@ impl UnifyInferCtxtMethods for InferCtxt {\n                vid.to_str(), new_v.inf_str(self));\n \n         let vb = UnifyVid::appropriate_vals_and_bindings(self);\n-        let old_v = (*vb.vals.get(&vid.to_uint())).clone();\n-        vb.bindings.push((vid.clone(), old_v));\n-        vb.vals.insert(vid.to_uint(), new_v);\n+        let mut vb = vb.borrow_mut();\n+        let old_v = (*vb.get().vals.get(&vid.to_uint())).clone();\n+        vb.get().bindings.push((vid.clone(), old_v));\n+        vb.get().vals.insert(vid.to_uint(), new_v);\n     }\n \n     fn unify<T:Clone + InferStr,\n              V:Clone + Vid + ToStr + UnifyVid<T>>(\n-             &mut self,\n+             &self,\n              node_a: &Node<V, T>,\n              node_b: &Node<V, T>)\n              -> (V, uint) {\n@@ -182,14 +185,14 @@ pub fn mk_err<T:SimplyUnifiable>(a_is_expected: bool,\n pub trait InferCtxtMethods {\n     fn simple_vars<T:Clone + Eq + InferStr + SimplyUnifiable,\n                    V:Clone + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n-                   &mut self,\n+                   &self,\n                    a_is_expected: bool,\n                    a_id: V,\n                    b_id: V)\n                    -> ures;\n     fn simple_var_t<T:Clone + Eq + InferStr + SimplyUnifiable,\n                     V:Clone + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n-                    &mut self,\n+                    &self,\n                     a_is_expected: bool,\n                     a_id: V,\n                     b: T)\n@@ -199,7 +202,7 @@ pub trait InferCtxtMethods {\n impl InferCtxtMethods for InferCtxt {\n     fn simple_vars<T:Clone + Eq + InferStr + SimplyUnifiable,\n                    V:Clone + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n-                   &mut self,\n+                   &self,\n                    a_is_expected: bool,\n                    a_id: V,\n                    b_id: V)\n@@ -239,7 +242,7 @@ impl InferCtxtMethods for InferCtxt {\n \n     fn simple_var_t<T:Clone + Eq + InferStr + SimplyUnifiable,\n                     V:Clone + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n-                    &mut self,\n+                    &self,\n                     a_is_expected: bool,\n                     a_id: V,\n                     b: T)\n@@ -274,16 +277,16 @@ impl InferCtxtMethods for InferCtxt {\n // ______________________________________________________________________\n \n impl UnifyVid<Bounds<ty::t>> for ty::TyVid {\n-    fn appropriate_vals_and_bindings<'v>(infcx: &'v mut InferCtxt)\n-        -> &'v mut ValsAndBindings<ty::TyVid, Bounds<ty::t>> {\n-        return &mut infcx.ty_var_bindings;\n+    fn appropriate_vals_and_bindings<'v>(infcx: &'v InferCtxt)\n+        -> &'v RefCell<ValsAndBindings<ty::TyVid, Bounds<ty::t>>> {\n+        return &infcx.ty_var_bindings;\n     }\n }\n \n impl UnifyVid<Option<IntVarValue>> for ty::IntVid {\n-    fn appropriate_vals_and_bindings<'v>(infcx: &'v mut InferCtxt)\n-        -> &'v mut ValsAndBindings<ty::IntVid, Option<IntVarValue>> {\n-        return &mut infcx.int_var_bindings;\n+    fn appropriate_vals_and_bindings<'v>(infcx: &'v InferCtxt)\n+        -> &'v RefCell<ValsAndBindings<ty::IntVid, Option<IntVarValue>>> {\n+        return &infcx.int_var_bindings;\n     }\n }\n \n@@ -294,9 +297,10 @@ impl SimplyUnifiable for IntVarValue {\n }\n \n impl UnifyVid<Option<ast::float_ty>> for ty::FloatVid {\n-    fn appropriate_vals_and_bindings<'v>(infcx: &'v mut InferCtxt)\n-        -> &'v mut ValsAndBindings<ty::FloatVid, Option<ast::float_ty>> {\n-        return &mut infcx.float_var_bindings;\n+    fn appropriate_vals_and_bindings<'v>(infcx: &'v InferCtxt)\n+        -> &'v RefCell<ValsAndBindings<ty::FloatVid,\n+                                           Option<ast::float_ty>>> {\n+        return &infcx.float_var_bindings;\n     }\n }\n "}, {"sha": "835c739c0852b099cd4e9686fd8bd3cd320b3269", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -68,6 +68,7 @@ use util::common::time;\n use util::ppaux::Repr;\n use util::ppaux;\n \n+use std::cell::RefCell;\n use std::hashmap::HashMap;\n use std::result;\n use extra::list::List;\n@@ -159,7 +160,7 @@ pub struct method_map_entry {\n \n // maps from an expression id that corresponds to a method call to the details\n // of the method to be invoked\n-pub type method_map = @mut HashMap<ast::NodeId, method_map_entry>;\n+pub type method_map = @RefCell<HashMap<ast::NodeId, method_map_entry>>;\n \n pub type vtable_param_res = @~[vtable_origin];\n // Resolutions for bounds of all parameters, left to right, for a given path.\n@@ -203,7 +204,7 @@ impl Repr for vtable_origin {\n     }\n }\n \n-pub type vtable_map = @mut HashMap<ast::NodeId, vtable_res>;\n+pub type vtable_map = @RefCell<HashMap<ast::NodeId, vtable_res>>;\n \n \n // Information about the vtable resolutions for for a trait impl.\n@@ -225,7 +226,7 @@ impl Repr for impl_res {\n     }\n }\n \n-pub type impl_vtable_map = @mut HashMap<ast::DefId, impl_res>;\n+pub type impl_vtable_map = RefCell<HashMap<ast::DefId, impl_res>>;\n \n pub struct CrateCtxt {\n     // A mapping from method call sites to traits that have that method.\n@@ -239,7 +240,8 @@ pub struct CrateCtxt {\n pub fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::NodeId, ty: ty::t) {\n     debug!(\"write_ty_to_tcx({}, {})\", node_id, ppaux::ty_to_str(tcx, ty));\n     assert!(!ty::type_needs_infer(ty));\n-    tcx.node_types.insert(node_id as uint, ty);\n+    let mut node_types = tcx.node_types.borrow_mut();\n+    node_types.get().insert(node_id as uint, ty);\n }\n pub fn write_substs_to_tcx(tcx: ty::ctxt,\n                            node_id: ast::NodeId,\n@@ -248,7 +250,9 @@ pub fn write_substs_to_tcx(tcx: ty::ctxt,\n         debug!(\"write_substs_to_tcx({}, {:?})\", node_id,\n                substs.map(|t| ppaux::ty_to_str(tcx, *t)));\n         assert!(substs.iter().all(|t| !ty::type_needs_infer(*t)));\n-        tcx.node_type_substs.insert(node_id, substs);\n+\n+        let mut node_type_substs = tcx.node_type_substs.borrow_mut();\n+        node_type_substs.get().insert(node_id, substs);\n     }\n }\n pub fn write_tpt_to_tcx(tcx: ty::ctxt,\n@@ -261,7 +265,8 @@ pub fn write_tpt_to_tcx(tcx: ty::ctxt,\n }\n \n pub fn lookup_def_tcx(tcx: ty::ctxt, sp: Span, id: ast::NodeId) -> ast::Def {\n-    match tcx.def_map.find(&id) {\n+    let def_map = tcx.def_map.borrow();\n+    match def_map.get().find(&id) {\n       Some(&x) => x,\n       _ => {\n         tcx.sess.span_fatal(sp, \"internal error looking up a definition\")\n@@ -283,7 +288,7 @@ pub fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n }\n \n pub fn require_same_types(tcx: ty::ctxt,\n-                          maybe_infcx: Option<@mut infer::InferCtxt>,\n+                          maybe_infcx: Option<@infer::InferCtxt>,\n                           t1_is_expected: bool,\n                           span: Span,\n                           t1: ty::t,\n@@ -434,9 +439,9 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n \n fn check_for_entry_fn(ccx: &CrateCtxt) {\n     let tcx = ccx.tcx;\n-    if !*tcx.sess.building_library {\n-        match *tcx.sess.entry_fn {\n-          Some((id, sp)) => match *tcx.sess.entry_type {\n+    if !tcx.sess.building_library.get() {\n+        match tcx.sess.entry_fn.get() {\n+          Some((id, sp)) => match tcx.sess.entry_type.get() {\n               Some(session::EntryMain) => check_main_fn_ty(ccx, id, sp),\n               Some(session::EntryStart) => check_start_fn_ty(ccx, id, sp),\n               Some(session::EntryNone) => {}\n@@ -452,10 +457,10 @@ pub fn check_crate(tcx: ty::ctxt,\n                    crate: &ast::Crate)\n                 -> (method_map, vtable_map) {\n     let time_passes = tcx.sess.time_passes();\n-    let ccx = @mut CrateCtxt {\n+    let ccx = @CrateCtxt {\n         trait_map: trait_map,\n-        method_map: @mut HashMap::new(),\n-        vtable_map: @mut HashMap::new(),\n+        method_map: @RefCell::new(HashMap::new()),\n+        vtable_map: @RefCell::new(HashMap::new()),\n         tcx: tcx\n     };\n "}, {"sha": "4eb1ad9ab9a43b982bef298a6a9a70b4406d2239", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -11,6 +11,7 @@\n \n use middle::ty;\n \n+use std::cell::Cell;\n use std::vec;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -49,14 +50,14 @@ impl RegionScope for ExplicitRscope {\n /// omitted regions. This occurs in function signatures.\n pub struct BindingRscope {\n     binder_id: ast::NodeId,\n-    anon_bindings: @mut uint\n+    anon_bindings: Cell<uint>,\n }\n \n impl BindingRscope {\n     pub fn new(binder_id: ast::NodeId) -> BindingRscope {\n         BindingRscope {\n             binder_id: binder_id,\n-            anon_bindings: @mut 0\n+            anon_bindings: Cell::new(0),\n         }\n     }\n }\n@@ -66,8 +67,8 @@ impl RegionScope for BindingRscope {\n                     _: Span,\n                     count: uint)\n                     -> Result<~[ty::Region], ()> {\n-        let idx = *self.anon_bindings;\n-        *self.anon_bindings += count;\n+        let idx = self.anon_bindings.get();\n+        self.anon_bindings.set(idx + count);\n         Ok(vec::from_fn(count, |i| ty::ReLateBound(self.binder_id,\n                                                    ty::BrAnon(idx + i))))\n     }"}, {"sha": "3ae43d606617cf19ed685d6a31c0fea9822ddea2", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -363,7 +363,10 @@ impl<'a> Visitor<()> for TermsContext<'a> {\n                 // \"invalid item id\" from \"item id with no\n                 // parameters\".\n                 if self.num_inferred() == inferreds_on_entry {\n-                    let newly_added = self.tcx.item_variance_map.insert(\n+                    let mut item_variance_map = self.tcx\n+                                                    .item_variance_map\n+                                                    .borrow_mut();\n+                    let newly_added = item_variance_map.get().insert(\n                         ast_util::local_def(item.id),\n                         self.empty_variances);\n                     assert!(newly_added);\n@@ -876,7 +879,6 @@ impl<'a> SolveContext<'a> {\n         // item id).\n \n         let tcx = self.terms_cx.tcx;\n-        let item_variance_map = tcx.item_variance_map;\n         let solutions = &self.solutions;\n         let inferred_infos = &self.terms_cx.inferred_infos;\n         let mut index = 0;\n@@ -919,8 +921,9 @@ impl<'a> SolveContext<'a> {\n                 tcx.sess.span_err(ast_map::node_span(tcx.items, item_id), found);\n             }\n \n-            let newly_added = item_variance_map.insert(item_def_id,\n-                                                       @item_variances);\n+            let mut item_variance_map = tcx.item_variance_map.borrow_mut();\n+            let newly_added = item_variance_map.get().insert(item_def_id,\n+                                                             @item_variances);\n             assert!(newly_added);\n         }\n     }"}, {"sha": "f3933c5623b26eaf0cf98d669fd55b6dc85507c2", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -14,7 +14,6 @@ use syntax::codemap::{Span};\n use syntax::visit;\n use syntax::visit::Visitor;\n \n-use std::hashmap::HashSet;\n use std::local_data;\n use extra;\n \n@@ -132,5 +131,3 @@ pub fn pluralize(n: uint, s: ~str) -> ~str {\n     else { format!(\"{}s\", s) }\n }\n \n-// A set of node IDs (used to keep track of which node IDs are for statements)\n-pub type stmt_set = @mut HashSet<ast::NodeId>;"}, {"sha": "ac88018a3c41f8e46234629610bce2f9c3f23f23", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -472,11 +472,10 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_infer(infer_ty) => infer_ty.to_str(),\n       ty_err => ~\"[type error]\",\n       ty_param(param_ty {idx: id, def_id: did}) => {\n-          let param_def = cx.ty_param_defs.find(&did.node);\n+          let ty_param_defs = cx.ty_param_defs.borrow();\n+          let param_def = ty_param_defs.get().find(&did.node);\n           let ident = match param_def {\n-              Some(def) => {\n-                  cx.sess.str_of(def.ident).to_owned()\n-              }\n+              Some(def) => cx.sess.str_of(def.ident).to_owned(),\n               None => {\n                   // This should not happen...\n                   format!(\"BUG[{:?}]\", id)"}, {"sha": "7d80cea23c160b9a6e6d5d783a989f52376edb1c", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -1153,7 +1153,8 @@ fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n         None => return Bool\n     };\n     debug!(\"searching for {:?} in defmap\", id);\n-    let d = match tycx.def_map.find(&id) {\n+    let def_map = tycx.def_map.borrow();\n+    let d = match def_map.get().find(&id) {\n         Some(k) => k,\n         None => {\n             debug!(\"could not find {:?} in defmap (`{}`)\", id,\n@@ -1210,7 +1211,8 @@ fn resolve_def(id: ast::NodeId) -> Option<ast::DefId> {\n     let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n     match cx.tycx {\n         Some(tcx) => {\n-            tcx.def_map.find(&id).map(|&d| ast_util::def_id_of_def(d))\n+            let def_map = tcx.def_map.borrow();\n+            def_map.get().find(&id).map(|&d| ast_util::def_id_of_def(d))\n         }\n         None => None\n     }"}, {"sha": "18891d38d38ecfbf205710dbfc4b2667b6e8a219", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -17,6 +17,7 @@ use syntax::diagnostic;\n use syntax::parse;\n use syntax;\n \n+use std::cell::RefCell;\n use std::os;\n use std::local_data;\n use std::hashmap::{HashSet};\n@@ -50,7 +51,7 @@ fn get_ast_and_resolve(cpath: &Path,\n     let sessopts = @driver::session::options {\n         binary: @\"rustdoc\",\n         maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n-        addl_lib_search_paths: @mut libs,\n+        addl_lib_search_paths: @RefCell::new(libs),\n         outputs: ~[driver::session::OutputDylib],\n         .. (*rustc::driver::session::basic_options()).clone()\n     };"}, {"sha": "7450abf34158befea7393a605c7629435a30b690", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::cell::RefCell;\n use std::hashmap::HashSet;\n use std::local_data;\n use std::os;\n@@ -34,7 +35,7 @@ pub fn run(input: &str, matches: &getopts::Matches) -> int {\n     let parsesess = parse::new_parse_sess(None);\n     let input = driver::file_input(Path::new(input));\n     let libs = matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice()));\n-    let libs = @mut libs.move_iter().collect();\n+    let libs = @RefCell::new(libs.move_iter().collect());\n \n     let sessopts = @session::options {\n         binary: @\"rustdoc\",\n@@ -99,7 +100,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>) {\n     let sessopts = @session::options {\n         binary: @\"rustdoctest\",\n         maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n-        addl_lib_search_paths: @mut libs,\n+        addl_lib_search_paths: @RefCell::new(libs),\n         outputs: ~[session::OutputExecutable],\n         debugging_opts: session::prefer_dynamic,\n         .. (*session::basic_options()).clone()\n@@ -159,7 +160,7 @@ fn maketest(s: &str, cratename: &str) -> @str {\n pub struct Collector {\n     priv tests: ~[test::TestDescAndFn],\n     priv names: ~[~str],\n-    priv libs: @mut HashSet<Path>,\n+    priv libs: @RefCell<HashSet<Path>>,\n     priv cnt: uint,\n     priv cratename: ~str,\n }\n@@ -169,7 +170,8 @@ impl Collector {\n         let test = test.to_owned();\n         let name = format!(\"{}_{}\", self.names.connect(\"::\"), self.cnt);\n         self.cnt += 1;\n-        let libs = (*self.libs).clone();\n+        let libs = self.libs.borrow();\n+        let libs = (*libs.get()).clone();\n         let cratename = self.cratename.to_owned();\n         self.tests.push(test::TestDescAndFn {\n             desc: test::TestDesc {"}, {"sha": "eb7dbe4e4a8a73fb6c5f595c538dba78734d6c44", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -10,6 +10,7 @@\n \n #[allow(dead_code)];\n \n+use std::cell::RefCell;\n use std::libc;\n use std::os;\n use std::io;\n@@ -244,7 +245,8 @@ pub fn compile_input(context: &BuildContext,\n         optimize: opt,\n         test: what == Test || what == Bench,\n         maybe_sysroot: Some(sysroot_to_use),\n-        addl_lib_search_paths: @mut context.additional_library_paths(),\n+        addl_lib_search_paths:\n+            @RefCell::new(context.additional_library_paths()),\n         output_type: output_type,\n         .. (*driver::build_session_options(binary,\n                                            &matches,\n@@ -254,15 +256,20 @@ pub fn compile_input(context: &BuildContext,\n \n     debug!(\"Created options...\");\n \n-    let addl_lib_search_paths = @mut options.addl_lib_search_paths;\n+    let addl_lib_search_paths = @RefCell::new(options.addl_lib_search_paths);\n     // Make sure all the library directories actually exist, since the linker will complain\n     // otherwise\n-    for p in addl_lib_search_paths.iter() {\n-        if p.exists() {\n-            assert!(p.is_dir())\n-        }\n-        else {\n-            fs::mkdir_recursive(p, io::UserRWX);\n+    {\n+        let mut addl_lib_search_paths = addl_lib_search_paths.borrow_mut();\n+        let addl_lib_search_paths = addl_lib_search_paths.get();\n+        let mut addl_lib_search_paths = addl_lib_search_paths.borrow_mut();\n+        for p in addl_lib_search_paths.get().iter() {\n+            if p.exists() {\n+                assert!(p.is_dir())\n+            }\n+            else {\n+                fs::mkdir_recursive(p, io::UserRWX);\n+            }\n         }\n     }\n \n@@ -285,9 +292,15 @@ pub fn compile_input(context: &BuildContext,\n     find_and_install_dependencies(context, pkg_id, in_file, sess, exec, &crate, deps,\n                                   |p| {\n                                       debug!(\"a dependency: {}\", p.display());\n+                                      let mut addl_lib_search_paths =\n+                                        addl_lib_search_paths.borrow_mut();\n+                                      let addl_lib_search_paths =\n+                                        addl_lib_search_paths.get();\n+                                      let mut addl_lib_search_paths =\n+                                        addl_lib_search_paths.borrow_mut();\n                                       // Pass the directory containing a dependency\n                                       // as an additional lib search path\n-                                      addl_lib_search_paths.insert(p);\n+                                      addl_lib_search_paths.get().insert(p);\n                                   });\n \n     // Inject the pkgid attribute so we get the right package name and version\n@@ -376,8 +389,11 @@ pub fn compile_crate_from_input(input: &Path,\n            outputs.obj_filename.display(),\n            sess.opts.output_type);\n     debug!(\"additional libraries:\");\n-    for lib in sess.opts.addl_lib_search_paths.iter() {\n-        debug!(\"an additional library: {}\", lib.display());\n+    {\n+        let addl_lib_search_paths = sess.opts.addl_lib_search_paths.borrow();\n+        for lib in addl_lib_search_paths.get().iter() {\n+            debug!(\"an additional library: {}\", lib.display());\n+        }\n     }\n     let analysis = driver::phase_3_run_analysis_passes(sess, &crate);\n     if driver::stop_after_phase_3(sess) { return None; }"}, {"sha": "c5fdddfec7625ec01c72a053fcaab89d34187e8c", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -21,6 +21,33 @@ pub struct Cell<T> {\n     priv value: T,\n }\n \n+#[cfg(stage0)]\n+impl<T> Cell<T> {\n+    /// Creates a new `Cell` containing the given value.\n+    pub fn new(value: T) -> Cell<T> {\n+        Cell {\n+            value: value,\n+        }\n+    }\n+\n+    /// Returns a copy of the contained value.\n+    #[inline]\n+    pub fn get(&self) -> T {\n+        unsafe {\n+            ::cast::transmute_copy(&self.value)\n+        }\n+    }\n+\n+    /// Sets the contained value.\n+    #[inline]\n+    pub fn set(&self, value: T) {\n+        unsafe {\n+            *cast::transmute_mut(&self.value) = value\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n impl<T: ::kinds::Pod> Cell<T> {\n     /// Creates a new `Cell` containing the given value.\n     pub fn new(value: T) -> Cell<T> {"}]}