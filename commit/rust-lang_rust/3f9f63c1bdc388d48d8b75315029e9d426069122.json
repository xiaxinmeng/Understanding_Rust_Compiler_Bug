{"sha": "3f9f63c1bdc388d48d8b75315029e9d426069122", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmOWY2M2MxYmRjMzg4ZDQ4ZDhiNzUzMTUwMjllOWQ0MjYwNjkxMjI=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-26T00:36:33Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-26T00:36:33Z"}, "message": "Improve expand_macro", "tree": {"sha": "ebaab3821c76b3d8c233c55aa59a25af8bc00e6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebaab3821c76b3d8c233c55aa59a25af8bc00e6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f9f63c1bdc388d48d8b75315029e9d426069122", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f9f63c1bdc388d48d8b75315029e9d426069122", "html_url": "https://github.com/rust-lang/rust/commit/3f9f63c1bdc388d48d8b75315029e9d426069122", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f9f63c1bdc388d48d8b75315029e9d426069122/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce4670f299d72a0f23f347b5df9790aca72da617", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce4670f299d72a0f23f347b5df9790aca72da617", "html_url": "https://github.com/rust-lang/rust/commit/ce4670f299d72a0f23f347b5df9790aca72da617"}], "stats": {"total": 99, "additions": 63, "deletions": 36}, "files": [{"sha": "9f543b79b56d3f05875783429a40daeadabb47cb", "filename": "crates/hir_def/src/item_scope.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f9f63c1bdc388d48d8b75315029e9d426069122/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f9f63c1bdc388d48d8b75315029e9d426069122/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs?ref=3f9f63c1bdc388d48d8b75315029e9d426069122", "patch": "@@ -8,6 +8,7 @@ use hir_expand::{name::Name, AstId, MacroCallId, MacroDefKind};\n use once_cell::sync::Lazy;\n use profile::Count;\n use rustc_hash::{FxHashMap, FxHashSet};\n+use smallvec::SmallVec;\n use stdx::format_to;\n use syntax::ast;\n \n@@ -61,7 +62,7 @@ pub struct ItemScope {\n     // be all resolved to the last one defined if shadowing happens.\n     legacy_macros: FxHashMap<Name, MacroDefId>,\n     attr_macros: FxHashMap<AstId<ast::Item>, MacroCallId>,\n-    derive_macros: FxHashMap<AstId<ast::Item>, (AttrId, MacroCallId)>,\n+    derive_macros: FxHashMap<AstId<ast::Item>, SmallVec<[(AttrId, MacroCallId); 1]>>,\n }\n \n pub(crate) static BUILTIN_SCOPE: Lazy<FxHashMap<Name, PerNs>> = Lazy::new(|| {\n@@ -189,13 +190,13 @@ impl ItemScope {\n         call: MacroCallId,\n         attr_id: AttrId,\n     ) {\n-        self.derive_macros.insert(item, (attr_id, call));\n+        self.derive_macros.entry(item).or_default().push((attr_id, call));\n     }\n \n     pub(crate) fn derive_macro_invocs(\n         &self,\n     ) -> impl Iterator<Item = (AstId<ast::Item>, (AttrId, MacroCallId))> + '_ {\n-        self.derive_macros.iter().map(|(k, v)| (*k, *v))\n+        self.derive_macros.iter().flat_map(|(k, v)| v.iter().map(move |v| (*k, *v)))\n     }\n \n     pub(crate) fn unnamed_trait_vis(&self, tr: TraitId) -> Option<Visibility> {"}, {"sha": "889b3748adc8fc41e1e819954332fb04f97a33b4", "filename": "crates/ide/src/expand_macro.rs", "status": "modified", "additions": 59, "deletions": 33, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/3f9f63c1bdc388d48d8b75315029e9d426069122/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f9f63c1bdc388d48d8b75315029e9d426069122/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fexpand_macro.rs?ref=3f9f63c1bdc388d48d8b75315029e9d426069122", "patch": "@@ -3,7 +3,7 @@ use std::iter;\n use hir::Semantics;\n use ide_db::{helpers::pick_best_token, RootDatabase};\n use itertools::Itertools;\n-use syntax::{ast, ted, AstNode, NodeOrToken, SyntaxKind, SyntaxKind::*, SyntaxNode, WalkEvent, T};\n+use syntax::{ast, ted, AstNode, NodeOrToken, SyntaxKind, SyntaxNode, WalkEvent, T};\n \n use crate::FilePosition;\n \n@@ -31,29 +31,29 @@ pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<\n         SyntaxKind::IDENT => 1,\n         _ => 0,\n     })?;\n+    let descended = sema.descend_into_macros(tok.clone());\n+    if let Some(attr) = descended.ancestors().find_map(ast::Attr::cast) {\n+        if let Some((path, tt)) = attr.as_simple_call() {\n+            if path == \"derive\" {\n+                let mut tt = tt.syntax().children_with_tokens().skip(1).join(\"\");\n+                tt.pop();\n+                return sema\n+                    .expand_derive_macro(&attr)\n+                    .map(insert_whitespaces)\n+                    .map(|expansion| ExpandedMacro { name: tt, expansion });\n+            }\n+        }\n+    }\n     let mut expanded = None;\n     let mut name = None;\n     for node in tok.ancestors() {\n-        if let Some(attr) = ast::Attr::cast(node.clone()) {\n-            if let Some((path, tt)) = attr.as_simple_call() {\n-                if path == \"derive\" {\n-                    let mut tt = tt.syntax().children_with_tokens().skip(1).join(\"\");\n-                    tt.pop();\n-                    name = Some(tt);\n-                    expanded = sema.expand_derive_macro(&attr);\n-                    break;\n-                }\n-            }\n-        }\n-\n         if let Some(item) = ast::Item::cast(node.clone()) {\n             if let Some(def) = sema.resolve_attr_macro_call(&item) {\n                 name = def.name(db).map(|name| name.to_string());\n                 expanded = expand_attr_macro_recur(&sema, &item);\n                 break;\n             }\n         }\n-\n         if let Some(mac) = ast::MacroCall::cast(node) {\n             name = Some(mac.path()?.segment()?.name_ref()?.to_string());\n             expanded = expand_macro_recur(&sema, &mac);\n@@ -107,24 +107,26 @@ fn expand<T: AstNode>(\n // FIXME: It would also be cool to share logic here and in the mbe tests,\n // which are pretty unreadable at the moment.\n fn insert_whitespaces(syn: SyntaxNode) -> String {\n+    use SyntaxKind::*;\n     let mut res = String::new();\n-    let mut token_iter = syn\n-        .preorder_with_tokens()\n-        .filter_map(|event| {\n-            if let WalkEvent::Enter(NodeOrToken::Token(token)) = event {\n-                Some(token)\n-            } else {\n-                None\n-            }\n-        })\n-        .peekable();\n \n     let mut indent = 0;\n     let mut last: Option<SyntaxKind> = None;\n \n-    while let Some(token) = token_iter.next() {\n-        let mut is_next = |f: fn(SyntaxKind) -> bool, default| -> bool {\n-            token_iter.peek().map(|it| f(it.kind())).unwrap_or(default)\n+    for event in syn.preorder_with_tokens() {\n+        let token = match event {\n+            WalkEvent::Enter(NodeOrToken::Token(token)) => token,\n+            WalkEvent::Leave(NodeOrToken::Node(node))\n+                if matches!(node.kind(), ATTR | MATCH_ARM | STRUCT | ENUM | UNION | FN | IMPL) =>\n+            {\n+                res.push('\\n');\n+                res.extend(iter::repeat(\" \").take(2 * indent));\n+                continue;\n+            }\n+            _ => continue,\n+        };\n+        let is_next = |f: fn(SyntaxKind) -> bool, default| -> bool {\n+            token.next_token().map(|it| f(it.kind())).unwrap_or(default)\n         };\n         let is_last =\n             |f: fn(SyntaxKind) -> bool, default| -> bool { last.map(f).unwrap_or(default) };\n@@ -182,6 +184,7 @@ mod tests {\n \n     use crate::fixture;\n \n+    #[track_caller]\n     fn check(ra_fixture: &str, expect: Expect) {\n         let (analysis, pos) = fixture::position(ra_fixture);\n         let expansion = analysis.expand_macro(pos).unwrap().unwrap();\n@@ -207,6 +210,7 @@ f$0oo!();\n             expect![[r#\"\n                 foo\n                 fn b(){}\n+\n             \"#]],\n         );\n     }\n@@ -226,11 +230,12 @@ macro_rules! foo {\n f$0oo!();\n         \"#,\n             expect![[r#\"\n-            foo\n-            fn some_thing() -> u32 {\n-              let a = 0;\n-              a+10\n-            }\"#]],\n+                foo\n+                fn some_thing() -> u32 {\n+                  let a = 0;\n+                  a+10\n+                }\n+            \"#]],\n         );\n     }\n \n@@ -343,7 +348,6 @@ fn main() {\n     fn macro_expand_derive() {\n         check(\n             r#\"\n-\n #[rustc_builtin_macro]\n pub macro Clone {}\n \n@@ -353,6 +357,28 @@ struct Foo {}\n             expect![[r#\"\n                 Clone\n                 impl< >crate::clone::Clone for Foo< >{}\n+\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn macro_expand_derive2() {\n+        check(\n+            r#\"\n+#[rustc_builtin_macro]\n+pub macro Clone {}\n+#[rustc_builtin_macro]\n+pub macro Copy {}\n+\n+#[derive(Cop$0y)]\n+#[derive(Clone)]\n+struct Foo {}\n+\"#,\n+            expect![[r#\"\n+                Copy\n+                impl< >crate::marker::Copy for Foo< >{}\n+\n             \"#]],\n         );\n     }"}]}