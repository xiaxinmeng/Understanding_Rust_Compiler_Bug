{"sha": "8a09420ac48658cad726e0a6997687ceac4151e3", "node_id": "C_kwDOAAsO6NoAKDhhMDk0MjBhYzQ4NjU4Y2FkNzI2ZTBhNjk5NzY4N2NlYWM0MTUxZTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-28T13:20:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-28T13:20:33Z"}, "message": "Auto merge of #105008 - Dylan-DPC:rollup-wcd19yu, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #104360 (Stabilize native library modifier `verbatim`)\n - #104732 (Refactor `ty::ClosureKind` related stuff)\n - #104795 (Change multiline span ASCII art visual order)\n - #104890 (small method code cleanup)\n - #104907 (Remove `SelectionContext::infcx()` in favor of field access)\n - #104927 (Simplify some binder shifting logic)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "89b587231315c230598887ffa9a3bd142b368631", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89b587231315c230598887ffa9a3bd142b368631"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a09420ac48658cad726e0a6997687ceac4151e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a09420ac48658cad726e0a6997687ceac4151e3", "html_url": "https://github.com/rust-lang/rust/commit/8a09420ac48658cad726e0a6997687ceac4151e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a09420ac48658cad726e0a6997687ceac4151e3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69df0f2c2f665d7f4e38a3579a81d4efc0d81034", "url": "https://api.github.com/repos/rust-lang/rust/commits/69df0f2c2f665d7f4e38a3579a81d4efc0d81034", "html_url": "https://github.com/rust-lang/rust/commit/69df0f2c2f665d7f4e38a3579a81d4efc0d81034"}, {"sha": "d5de2a8e641b1526473aaf903a25b16e174bafe8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5de2a8e641b1526473aaf903a25b16e174bafe8", "html_url": "https://github.com/rust-lang/rust/commit/d5de2a8e641b1526473aaf903a25b16e174bafe8"}], "stats": {"total": 843, "additions": 373, "deletions": 470}, "files": [{"sha": "7cb4f5503a101f1da94d1b78ed4020154c83317b", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -377,12 +377,8 @@ fn link_rlib<'a>(\n                 find_native_static_library(name.as_str(), lib.verbatim, &lib_search_paths, sess);\n             if sess.opts.unstable_opts.packed_bundled_libs && flavor == RlibFlavor::Normal {\n                 let filename = lib.filename.unwrap();\n-                let lib_path = find_native_static_library(\n-                    filename.as_str(),\n-                    Some(true),\n-                    &lib_search_paths,\n-                    sess,\n-                );\n+                let lib_path =\n+                    find_native_static_library(filename.as_str(), true, &lib_search_paths, sess);\n                 let src = read(lib_path)\n                     .map_err(|e| sess.emit_fatal(errors::ReadFileError { message: e }))?;\n                 let (data, _) = create_wrapper_file(sess, b\".bundled_lib\".to_vec(), &src);\n@@ -465,7 +461,7 @@ fn collate_raw_dylibs<'a, 'b>(\n \n     for lib in used_libraries {\n         if lib.kind == NativeLibKind::RawDylib {\n-            let ext = if matches!(lib.verbatim, Some(true)) { \"\" } else { \".dll\" };\n+            let ext = if lib.verbatim { \"\" } else { \".dll\" };\n             let name = format!(\"{}{}\", lib.name.expect(\"unnamed raw-dylib library\"), ext);\n             let imports = dylib_table.entry(name.clone()).or_default();\n             for import in &lib.dll_imports {\n@@ -1335,7 +1331,7 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n                 NativeLibKind::Static { bundle: Some(false), .. }\n                 | NativeLibKind::Dylib { .. }\n                 | NativeLibKind::Unspecified => {\n-                    let verbatim = lib.verbatim.unwrap_or(false);\n+                    let verbatim = lib.verbatim;\n                     if sess.target.is_like_msvc {\n                         Some(format!(\"{}{}\", name, if verbatim { \"\" } else { \".lib\" }))\n                     } else if sess.target.linker_flavor.is_gnu() {\n@@ -2306,7 +2302,7 @@ fn add_native_libs_from_crate(\n         _ => &codegen_results.crate_info.native_libraries[&cnum],\n     };\n \n-    let mut last = (None, NativeLibKind::Unspecified, None);\n+    let mut last = (None, NativeLibKind::Unspecified, false);\n     for lib in native_libs {\n         let Some(name) = lib.name else {\n             continue;\n@@ -2323,7 +2319,7 @@ fn add_native_libs_from_crate(\n         };\n \n         let name = name.as_str();\n-        let verbatim = lib.verbatim.unwrap_or(false);\n+        let verbatim = lib.verbatim;\n         match lib.kind {\n             NativeLibKind::Static { bundle, whole_archive } => {\n                 if link_static {"}, {"sha": "f087d903e5568f835476c6a43d8dd8c4f7dda6ce", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -515,7 +515,7 @@ impl<'a> Linker for GccLinker<'a> {\n             // -force_load is the macOS equivalent of --whole-archive, but it\n             // involves passing the full path to the library to link.\n             self.linker_arg(\"-force_load\");\n-            let lib = find_native_static_library(lib, Some(verbatim), search_path, &self.sess);\n+            let lib = find_native_static_library(lib, verbatim, search_path, &self.sess);\n             self.linker_arg(&lib);\n         }\n     }"}, {"sha": "def6390f6a36bcbd15d9610ceaa412eef883eeda", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -116,7 +116,7 @@ pub struct NativeLib {\n     pub name: Option<Symbol>,\n     pub filename: Option<Symbol>,\n     pub cfg: Option<ast::MetaItem>,\n-    pub verbatim: Option<bool>,\n+    pub verbatim: bool,\n     pub dll_imports: Vec<cstore::DllImport>,\n }\n \n@@ -127,7 +127,7 @@ impl From<&cstore::NativeLib> for NativeLib {\n             filename: lib.filename,\n             name: lib.name,\n             cfg: lib.cfg.clone(),\n-            verbatim: lib.verbatim,\n+            verbatim: lib.verbatim.unwrap_or(false),\n             dll_imports: lib.dll_imports.clone(),\n         }\n     }"}, {"sha": "1fabe15ff83ba4563a5618988f9242640fa67835", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -2282,7 +2282,7 @@ impl FileWithAnnotatedLines {\n         }\n \n         // Find overlapping multiline annotations, put them at different depths\n-        multiline_annotations.sort_by_key(|&(_, ref ml)| (ml.line_start, ml.line_end));\n+        multiline_annotations.sort_by_key(|&(_, ref ml)| (ml.line_start, usize::MAX - ml.line_end));\n         for (_, ann) in multiline_annotations.clone() {\n             for (_, a) in multiline_annotations.iter_mut() {\n                 // Move all other multiline annotations overlapping with this one\n@@ -2300,8 +2300,14 @@ impl FileWithAnnotatedLines {\n         }\n \n         let mut max_depth = 0; // max overlapping multiline spans\n-        for (file, ann) in multiline_annotations {\n+        for (_, ann) in &multiline_annotations {\n             max_depth = max(max_depth, ann.depth);\n+        }\n+        // Change order of multispan depth to minimize the number of overlaps in the ASCII art.\n+        for (_, a) in multiline_annotations.iter_mut() {\n+            a.depth = max_depth - a.depth + 1;\n+        }\n+        for (file, ann) in multiline_annotations {\n             let mut end_ann = ann.as_end();\n             if !ann.overlaps_exactly {\n                 // avoid output like"}, {"sha": "539b04535a0d028f8f45f2cbabfe8828e97802ce", "filename": "compiler/rustc_expand/src/tests.rs", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ftests.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -272,13 +272,13 @@ error: foo\n  --> test.rs:3:3\n   |\n 3 |      X0 Y0\n-  |  ____^__-\n-  | | ___|\n+  |   ___^__-\n+  |  |___|\n   | ||\n 4 | ||   X1 Y1\n 5 | ||   X2 Y2\n   | ||____^__- `Y` is a good letter too\n-  |  |____|\n+  | |_____|\n   |       `X` is a good letter\n \n \"#,\n@@ -311,12 +311,12 @@ error: foo\n  --> test.rs:3:3\n   |\n 3 |      X0 Y0\n-  |  ____^__-\n-  | | ___|\n+  |   ___^__-\n+  |  |___|\n   | ||\n 4 | ||   Y1 X1\n   | ||____-__^ `X` is a good letter\n-  | |_____|\n+  |  |____|\n   |       `Y` is a good letter too\n \n \"#,\n@@ -351,13 +351,13 @@ error: foo\n  --> test.rs:3:6\n   |\n 3 |      X0 Y0 Z0\n-  |   ______^\n-4 |  |   X1 Y1 Z1\n-  |  |_________-\n+  |  _______^\n+4 | |    X1 Y1 Z1\n+  | | _________-\n 5 | ||   X2 Y2 Z2\n   | ||____^ `X` is a good letter\n-6 | |    X3 Y3 Z3\n-  | |_____- `Y` is a good letter too\n+6 |  |   X3 Y3 Z3\n+  |  |____- `Y` is a good letter too\n \n \"#,\n     );\n@@ -395,15 +395,15 @@ error: foo\n  --> test.rs:3:3\n   |\n 3 |       X0 Y0 Z0\n-  |  _____^__-__-\n-  | | ____|__|\n-  | || ___|\n+  |    ___^__-__-\n+  |   |___|__|\n+  |  ||___|\n   | |||\n 4 | |||   X1 Y1 Z1\n 5 | |||   X2 Y2 Z2\n   | |||____^__-__- `Z` label\n-  |  ||____|__|\n-  |   |____|  `Y` is a good letter too\n+  | ||_____|__|\n+  | |______|  `Y` is a good letter too\n   |        `X` is a good letter\n \n \"#,\n@@ -487,17 +487,17 @@ error: foo\n  --> test.rs:3:6\n   |\n 3 |      X0 Y0 Z0\n-  |   ______^\n-4 |  |   X1 Y1 Z1\n-  |  |____^_-\n+  |  _______^\n+4 | |    X1 Y1 Z1\n+  | | ____^_-\n   | ||____|\n-  | |     `X` is a good letter\n-5 | |    X2 Y2 Z2\n-  | |____-______- `Y` is a good letter too\n-  |  ____|\n-  | |\n-6 | |    X3 Y3 Z3\n-  | |________- `Z`\n+  |  |    `X` is a good letter\n+5 |  |   X2 Y2 Z2\n+  |  |___-______- `Y` is a good letter too\n+  |   ___|\n+  |  |\n+6 |  |   X3 Y3 Z3\n+  |  |_______- `Z`\n \n \"#,\n     );\n@@ -570,14 +570,14 @@ error: foo\n  --> test.rs:3:6\n   |\n 3 |      X0 Y0 Z0\n-  |   ______^\n-4 |  |   X1 Y1 Z1\n-  |  |____^____-\n+  |  _______^\n+4 | |    X1 Y1 Z1\n+  | | ____^____-\n   | ||____|\n-  | |     `X` is a good letter\n-5 | |    X2 Y2 Z2\n-6 | |    X3 Y3 Z3\n-  | |___________- `Y` is a good letter too\n+  |  |    `X` is a good letter\n+5 |  |   X2 Y2 Z2\n+6 |  |   X3 Y3 Z3\n+  |  |__________- `Y` is a good letter too\n \n \"#,\n     );\n@@ -941,18 +941,18 @@ error: foo\n   --> test.rs:3:6\n    |\n 3  |      X0 Y0 Z0\n-   |   ______^\n-4  |  |   X1 Y1 Z1\n-   |  |____^____-\n+   |  _______^\n+4  | |    X1 Y1 Z1\n+   | | ____^____-\n    | ||____|\n-   | |     `X` is a good letter\n-5  | |  1\n-6  | |  2\n-7  | |  3\n-...  |\n-15 | |    X2 Y2 Z2\n-16 | |    X3 Y3 Z3\n-   | |___________- `Y` is a good letter too\n+   |  |    `X` is a good letter\n+5  |  | 1\n+6  |  | 2\n+7  |  | 3\n+...   |\n+15 |  |   X2 Y2 Z2\n+16 |  |   X3 Y3 Z3\n+   |  |__________- `Y` is a good letter too\n \n \"#,\n     );\n@@ -996,21 +996,21 @@ error: foo\n   --> test.rs:3:6\n    |\n 3  |      X0 Y0 Z0\n-   |   ______^\n-4  |  | 1\n-5  |  | 2\n-6  |  | 3\n-7  |  |   X1 Y1 Z1\n-   |  |_________-\n+   |  _______^\n+4  | |  1\n+5  | |  2\n+6  | |  3\n+7  | |    X1 Y1 Z1\n+   | | _________-\n 8  | || 4\n 9  | || 5\n 10 | || 6\n 11 | ||   X2 Y2 Z2\n    | ||__________- `Z` is a good letter too\n-...   |\n-15 |  | 10\n-16 |  |   X3 Y3 Z3\n-   |  |_______^ `Y` is a good letter\n+...  |\n+15 | |  10\n+16 | |    X3 Y3 Z3\n+   | |________^ `Y` is a good letter\n \n \"#,\n     );"}, {"sha": "7678ce323dfbc04fb0f254e47e214ca9ed833e68", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -237,6 +237,8 @@ declare_features! (\n     (accepted, native_link_modifiers, \"1.61.0\", Some(81490), None),\n     /// Allows specifying the bundle link modifier\n     (accepted, native_link_modifiers_bundle, \"1.63.0\", Some(81490), None),\n+    /// Allows specifying the verbatim link modifier\n+    (accepted, native_link_modifiers_verbatim, \"CURRENT_RUSTC_VERSION\", Some(81490), None),\n     /// Allows specifying the whole-archive link modifier\n     (accepted, native_link_modifiers_whole_archive, \"1.61.0\", Some(81490), None),\n     /// Allows using non lexical lifetimes (RFC 2094)."}, {"sha": "69c5297bf6b82564395b902052c9ce01ec38e3fa", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -455,8 +455,6 @@ declare_features! (\n     (active, naked_functions, \"1.9.0\", Some(32408), None),\n     /// Allows specifying the as-needed link modifier\n     (active, native_link_modifiers_as_needed, \"1.53.0\", Some(81490), None),\n-    /// Allows specifying the verbatim link modifier\n-    (active, native_link_modifiers_verbatim, \"1.53.0\", Some(81490), None),\n     /// Allow negative trait implementations.\n     (active, negative_impls, \"1.44.0\", Some(68318), None),\n     /// Allows the `!` type. Does not imply 'exhaustive_patterns' (below) any more."}, {"sha": "e50d249849fa8483265966c4b6a32403360025db", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -179,12 +179,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Hack: we know that there are traits implementing Fn for &F\n             // where F:Fn and so forth. In the particular case of types\n-            // like `x: &mut FnMut()`, if there is a call `x()`, we would\n-            // normally translate to `FnMut::call_mut(&mut x, ())`, but\n-            // that winds up requiring `mut x: &mut FnMut()`. A little\n-            // over the top. The simplest fix by far is to just ignore\n-            // this case and deref again, so we wind up with\n-            // `FnMut::call_mut(&mut *x, ())`.\n+            // like `f: &mut FnMut()`, if there is a call `f()`, we would\n+            // normally translate to `FnMut::call_mut(&mut f, ())`, but\n+            // that winds up potentially requiring the user to mark their\n+            // variable as `mut` which feels unnecessary and unexpected.\n+            //\n+            //     fn foo(f: &mut impl FnMut()) { f() }\n+            //            ^ without this hack `f` would have to be declared as mutable\n+            //\n+            // The simplest fix by far is to just ignore this case and deref again,\n+            // so we wind up with `FnMut::call_mut(&mut *f, ())`.\n             ty::Ref(..) if autoderef.step_count() == 0 => {\n                 return None;\n             }"}, {"sha": "732b4bec58ed5cbd03a8a3df0c665a00fddd26c3", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -46,7 +46,6 @@ use rustc_span::def_id::{DefId, LOCAL_CRATE};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n-use rustc_trait_selection::traits::error_reporting::report_object_safety_error;\n \n /// Reifies a cast check to be checked once we have full type information for\n /// a function context.\n@@ -727,9 +726,6 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     debug!(\" -> CoercionCast\");\n                     fcx.typeck_results.borrow_mut().set_coercion_cast(self.expr.hir_id.local_id);\n                 }\n-                Err(ty::error::TypeError::ObjectUnsafeCoercion(did)) => {\n-                    self.report_object_unsafe_cast(&fcx, did);\n-                }\n                 Err(_) => {\n                     match self.do_check(fcx) {\n                         Ok(k) => {\n@@ -741,14 +737,6 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             };\n         }\n     }\n-\n-    fn report_object_unsafe_cast(&self, fcx: &FnCtxt<'a, 'tcx>, did: DefId) {\n-        let violations = fcx.tcx.object_safety_violations(did);\n-        let mut err = report_object_safety_error(fcx.tcx, self.cast_span, did, violations);\n-        err.note(&format!(\"required by cast to type '{}'\", fcx.ty_to_string(self.cast_ty)));\n-        err.emit();\n-    }\n-\n     /// Checks a cast, and report an error if one exists. In some cases, this\n     /// can return Ok and create type errors in the fcx rather than returning\n     /// directly. coercion-cast is handled in check instead of here."}, {"sha": "e584d413c4190688fe8559af7bd28987f6e478ba", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -178,7 +178,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 });\n                 let kind = object_type\n                     .principal_def_id()\n-                    .and_then(|did| self.tcx.fn_trait_kind_from_lang_item(did));\n+                    .and_then(|did| self.tcx.fn_trait_kind_from_def_id(did));\n                 (sig, kind)\n             }\n             ty::Infer(ty::TyVar(vid)) => self.deduce_signature_from_predicates(\n@@ -235,7 +235,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 _ => None,\n             };\n             if let Some(closure_kind) =\n-                trait_def_id.and_then(|def_id| self.tcx.fn_trait_kind_from_lang_item(def_id))\n+                trait_def_id.and_then(|def_id| self.tcx.fn_trait_kind_from_def_id(def_id))\n             {\n                 expected_kind = Some(\n                     expected_kind\n@@ -263,7 +263,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let trait_def_id = projection.trait_def_id(tcx);\n \n-        let is_fn = tcx.fn_trait_kind_from_lang_item(trait_def_id).is_some();\n+        let is_fn = tcx.is_fn_trait(trait_def_id);\n         let gen_trait = tcx.require_lang_item(LangItem::Generator, cause_span);\n         let is_gen = gen_trait == trait_def_id;\n         if !is_fn && !is_gen {"}, {"sha": "b2d9d70fbd2acb4608f5dd878adb04aa0db22ca1", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 6, "deletions": 29, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -195,10 +195,6 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 debug!(\"coerce: unsize successful\");\n                 return unsize;\n             }\n-            Err(TypeError::ObjectUnsafeCoercion(did)) => {\n-                debug!(\"coerce: unsize not object safe\");\n-                return Err(TypeError::ObjectUnsafeCoercion(did));\n-            }\n             Err(error) => {\n                 debug!(?error, \"coerce: unsize failed\");\n             }\n@@ -498,27 +494,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         target = self.shallow_resolve(target);\n         debug!(?source, ?target);\n \n-        // These 'if' statements require some explanation.\n-        // The `CoerceUnsized` trait is special - it is only\n-        // possible to write `impl CoerceUnsized<B> for A` where\n-        // A and B have 'matching' fields. This rules out the following\n-        // two types of blanket impls:\n-        //\n-        // `impl<T> CoerceUnsized<T> for SomeType`\n-        // `impl<T> CoerceUnsized<SomeType> for T`\n-        //\n-        // Both of these trigger a special `CoerceUnsized`-related error (E0376)\n-        //\n-        // We can take advantage of this fact to avoid performing unnecessary work.\n-        // If either `source` or `target` is a type variable, then any applicable impl\n-        // would need to be generic over the self-type (`impl<T> CoerceUnsized<SomeType> for T`)\n-        // or generic over the `CoerceUnsized` type parameter (`impl<T> CoerceUnsized<T> for\n-        // SomeType`).\n-        //\n-        // However, these are exactly the kinds of impls which are forbidden by\n-        // the compiler! Therefore, we can be sure that coercion will always fail\n-        // when either the source or target type is a type variable. This allows us\n-        // to skip performing any trait selection, and immediately bail out.\n+        // We don't apply any coercions incase either the source or target\n+        // aren't sufficiently well known but tend to instead just equate\n+        // them both.\n         if source.is_ty_var() {\n             debug!(\"coerce_unsized: source is a TyVar, bailing out\");\n             return Err(TypeError::Mismatch);\n@@ -1101,15 +1079,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Special-case that coercion alone cannot handle:\n         // Function items or non-capturing closures of differing IDs or InternalSubsts.\n         let (a_sig, b_sig) = {\n-            #[allow(rustc::usage_of_ty_tykind)]\n-            let is_capturing_closure = |ty: &ty::TyKind<'tcx>| {\n-                if let &ty::Closure(closure_def_id, _substs) = ty {\n+            let is_capturing_closure = |ty: Ty<'tcx>| {\n+                if let &ty::Closure(closure_def_id, _substs) = ty.kind() {\n                     self.tcx.upvars_mentioned(closure_def_id.expect_local()).is_some()\n                 } else {\n                     false\n                 }\n             };\n-            if is_capturing_closure(prev_ty.kind()) || is_capturing_closure(new_ty.kind()) {\n+            if is_capturing_closure(prev_ty) || is_capturing_closure(new_ty) {\n                 (None, None)\n             } else {\n                 match (prev_ty.kind(), new_ty.kind()) {"}, {"sha": "86384c7b93e717692b04087fe27038904e501673", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -2089,7 +2089,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             && let maybe_trait_item_def_id = assoc_item.trait_item_def_id.unwrap_or(def_id)\n             && let maybe_trait_def_id = self.tcx.parent(maybe_trait_item_def_id)\n             // Just an easy way to check \"trait_def_id == Fn/FnMut/FnOnce\"\n-            && let Some(call_kind) = ty::ClosureKind::from_def_id(self.tcx, maybe_trait_def_id)\n+            && let Some(call_kind) = self.tcx.fn_trait_kind_from_def_id(maybe_trait_def_id)\n             && let Some(callee_ty) = callee_ty\n         {\n             let callee_ty = callee_ty.peel_refs();\n@@ -2115,7 +2115,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         {\n                             if let ty::PredicateKind::Clause(ty::Clause::Trait(pred)) = predicate.kind().skip_binder()\n                                 && pred.self_ty().peel_refs() == callee_ty\n-                                && ty::ClosureKind::from_def_id(self.tcx, pred.def_id()).is_some()\n+                                && self.tcx.is_fn_trait(pred.def_id())\n                             {\n                                 err.span_note(span, \"callable defined here\");\n                                 return;"}, {"sha": "4380e66a0d248221be4b3d7b896270c259ec2b94", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -343,10 +343,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             &mut orig_values,\n         );\n \n-        let steps = if mode == Mode::MethodCall {\n-            self.tcx.method_autoderef_steps(param_env_and_self_ty)\n-        } else {\n-            self.probe(|_| {\n+        let steps = match mode {\n+            Mode::MethodCall => self.tcx.method_autoderef_steps(param_env_and_self_ty),\n+            Mode::Path => self.probe(|_| {\n                 // Mode::Path - the deref steps is \"trivial\". This turns\n                 // our CanonicalQuery into a \"trivial\" QueryResponse. This\n                 // is a bit inefficient, but I don't think that writing\n@@ -375,7 +374,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     opt_bad_ty: None,\n                     reached_recursion_limit: false,\n                 }\n-            })\n+            }),\n         };\n \n         // If our autoderef loop had reached the recursion limit,"}, {"sha": "e2be8fb12d0d0d976c877a73a1cde0b18bfdc07c", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 26, "deletions": 36, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -1672,40 +1672,34 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             }\n         };\n \n-        match terr {\n-            // Ignore msg for object safe coercion\n-            // since E0038 message will be printed\n-            TypeError::ObjectUnsafeCoercion(_) => {}\n-            _ => {\n-                let mut label_or_note = |span: Span, msg: &str| {\n-                    if (prefer_label && is_simple_error) || &[span] == diag.span.primary_spans() {\n-                        diag.span_label(span, msg);\n-                    } else {\n-                        diag.span_note(span, msg);\n-                    }\n-                };\n-                if let Some((sp, msg)) = secondary_span {\n-                    if swap_secondary_and_primary {\n-                        let terr = if let Some(infer::ValuePairs::Terms(infer::ExpectedFound {\n-                            expected,\n-                            ..\n-                        })) = values\n-                        {\n-                            format!(\"expected this to be `{}`\", expected)\n-                        } else {\n-                            terr.to_string()\n-                        };\n-                        label_or_note(sp, &terr);\n-                        label_or_note(span, &msg);\n-                    } else {\n-                        label_or_note(span, &terr.to_string());\n-                        label_or_note(sp, &msg);\n-                    }\n-                } else {\n-                    label_or_note(span, &terr.to_string());\n-                }\n+        let mut label_or_note = |span: Span, msg: &str| {\n+            if (prefer_label && is_simple_error) || &[span] == diag.span.primary_spans() {\n+                diag.span_label(span, msg);\n+            } else {\n+                diag.span_note(span, msg);\n             }\n         };\n+        if let Some((sp, msg)) = secondary_span {\n+            if swap_secondary_and_primary {\n+                let terr = if let Some(infer::ValuePairs::Terms(infer::ExpectedFound {\n+                    expected,\n+                    ..\n+                })) = values\n+                {\n+                    format!(\"expected this to be `{}`\", expected)\n+                } else {\n+                    terr.to_string()\n+                };\n+                label_or_note(sp, &terr);\n+                label_or_note(span, &msg);\n+            } else {\n+                label_or_note(span, &terr.to_string());\n+                label_or_note(sp, &msg);\n+            }\n+        } else {\n+            label_or_note(span, &terr.to_string());\n+        }\n+\n         if let Some((expected, found)) = expected_found {\n             let (expected_label, found_label, exp_found) = match exp_found {\n                 Mismatch::Variable(ef) => (\n@@ -1875,9 +1869,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                         );\n                     }\n                 }\n-                TypeError::ObjectUnsafeCoercion(_) => {\n-                    diag.note_unsuccessful_coercion(found, expected);\n-                }\n                 _ => {\n                     debug!(\n                         \"note_type_err: exp_found={:?}, expected={:?} found={:?}\",\n@@ -3122,7 +3113,6 @@ impl<'tcx> ObligationCauseExt<'tcx> for ObligationCause<'tcx> {\n                 TypeError::IntrinsicCast => {\n                     Error0308(\"cannot coerce intrinsics to function pointers\")\n                 }\n-                TypeError::ObjectUnsafeCoercion(did) => Error0038(did),\n                 _ => Error0308(\"mismatched types\"),\n             },\n         }"}, {"sha": "1f554c81eff8e1941453d2f0a544ec245cd16d51", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -399,10 +399,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                 self_ty.highlight.maybe_highlighting_region(vid, actual_has_vid);\n \n                 if self_ty.value.is_closure()\n-                    && self\n-                        .tcx()\n-                        .fn_trait_kind_from_lang_item(expected_trait_ref.value.def_id)\n-                        .is_some()\n+                    && self.tcx().is_fn_trait(expected_trait_ref.value.def_id)\n                 {\n                     let closure_sig = self_ty.map(|closure| {\n                         if let ty::Closure(_, substs) = closure.kind() {"}, {"sha": "1fd35adf1bd2cc4c4ac7f865e10d55d0d1a04b82", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -29,11 +29,11 @@ use std::path::PathBuf;\n \n pub fn find_native_static_library(\n     name: &str,\n-    verbatim: Option<bool>,\n+    verbatim: bool,\n     search_paths: &[PathBuf],\n     sess: &Session,\n ) -> PathBuf {\n-    let formats = if verbatim.unwrap_or(false) {\n+    let formats = if verbatim {\n         vec![(\"\".into(), \"\".into())]\n     } else {\n         let os = (sess.target.staticlib_prefix.clone(), sess.target.staticlib_suffix.clone());\n@@ -52,7 +52,7 @@ pub fn find_native_static_library(\n         }\n     }\n \n-    sess.emit_fatal(MissingNativeLibrary::new(name, verbatim.unwrap_or(false)));\n+    sess.emit_fatal(MissingNativeLibrary::new(name, verbatim));\n }\n \n fn find_bundled_library(\n@@ -66,7 +66,7 @@ fn find_bundled_library(\n             let NativeLibKind::Static { bundle: Some(true) | None, .. } = kind {\n         find_native_static_library(\n             name.unwrap().as_str(),\n-            verbatim,\n+            verbatim.unwrap_or(false),\n             &sess.target_filesearch(PathKind::Native).search_path_dirs(),\n             sess,\n         ).file_name().and_then(|s| s.to_str()).map(Symbol::intern)\n@@ -311,10 +311,7 @@ impl<'tcx> Collector<'tcx> {\n                             sess.emit_err(BundleNeedsStatic { span });\n                         }\n \n-                        (\"verbatim\", _) => {\n-                            report_unstable_modifier!(native_link_modifiers_verbatim);\n-                            assign_modifier(&mut verbatim)\n-                        }\n+                        (\"verbatim\", _) => assign_modifier(&mut verbatim),\n \n                         (\"whole-archive\", Some(NativeLibKind::Static { whole_archive, .. })) => {\n                             assign_modifier(whole_archive)"}, {"sha": "343ea1f00f58bc7c4b982485e284593cb13e8c5f", "filename": "compiler/rustc_middle/src/middle/lang_items.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flang_items.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -27,7 +27,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    pub fn fn_trait_kind_from_lang_item(self, id: DefId) -> Option<ty::ClosureKind> {\n+    /// Given a [`DefId`] of a [`Fn`], [`FnMut`] or [`FnOnce`] traits,\n+    /// returns a corresponding [`ty::ClosureKind`].\n+    /// For any other [`DefId`] return `None`.\n+    pub fn fn_trait_kind_from_def_id(self, id: DefId) -> Option<ty::ClosureKind> {\n         let items = self.lang_items();\n         match Some(id) {\n             x if x == items.fn_trait() => Some(ty::ClosureKind::Fn),\n@@ -36,6 +39,11 @@ impl<'tcx> TyCtxt<'tcx> {\n             _ => None,\n         }\n     }\n+\n+    /// Returns `true` if `id` is a `DefId` of [`Fn`], [`FnMut`] or [`FnOnce`] traits.\n+    pub fn is_fn_trait(self, id: DefId) -> bool {\n+        self.fn_trait_kind_from_def_id(id).is_some()\n+    }\n }\n \n /// Returns `true` if the specified `lang_item` must be present for this"}, {"sha": "d00553cbad131753dda62ca19b9bfa69cb1191c4", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 14, "deletions": 31, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -97,39 +97,12 @@ impl<'tcx> ClosureKind {\n     /// Returns `true` if a type that impls this closure kind\n     /// must also implement `other`.\n     pub fn extends(self, other: ty::ClosureKind) -> bool {\n-        matches!(\n-            (self, other),\n-            (ClosureKind::Fn, ClosureKind::Fn)\n-                | (ClosureKind::Fn, ClosureKind::FnMut)\n-                | (ClosureKind::Fn, ClosureKind::FnOnce)\n-                | (ClosureKind::FnMut, ClosureKind::FnMut)\n-                | (ClosureKind::FnMut, ClosureKind::FnOnce)\n-                | (ClosureKind::FnOnce, ClosureKind::FnOnce)\n-        )\n-    }\n-\n-    /// Returns the representative scalar type for this closure kind.\n-    /// See `Ty::to_opt_closure_kind` for more details.\n-    pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n-        match self {\n-            ClosureKind::Fn => tcx.types.i8,\n-            ClosureKind::FnMut => tcx.types.i16,\n-            ClosureKind::FnOnce => tcx.types.i32,\n-        }\n-    }\n-\n-    pub fn from_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ClosureKind> {\n-        if Some(def_id) == tcx.lang_items().fn_once_trait() {\n-            Some(ClosureKind::FnOnce)\n-        } else if Some(def_id) == tcx.lang_items().fn_mut_trait() {\n-            Some(ClosureKind::FnMut)\n-        } else if Some(def_id) == tcx.lang_items().fn_trait() {\n-            Some(ClosureKind::Fn)\n-        } else {\n-            None\n-        }\n+        self <= other\n     }\n \n+    /// Converts `self` to a [`DefId`] of the corresponding trait.\n+    ///\n+    /// Note: the inverse of this function is [`TyCtxt::fn_trait_kind_from_def_id`].\n     pub fn to_def_id(&self, tcx: TyCtxt<'_>) -> DefId {\n         tcx.require_lang_item(\n             match self {\n@@ -140,6 +113,16 @@ impl<'tcx> ClosureKind {\n             None,\n         )\n     }\n+\n+    /// Returns the representative scalar type for this closure kind.\n+    /// See `Ty::to_opt_closure_kind` for more details.\n+    pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+        match self {\n+            ClosureKind::Fn => tcx.types.i8,\n+            ClosureKind::FnMut => tcx.types.i16,\n+            ClosureKind::FnOnce => tcx.types.i32,\n+        }\n+    }\n }\n \n /// A composite describing a `Place` that is captured by a closure."}, {"sha": "d83e17574a09423c249b54034a35339c6f9f1b04", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -70,7 +70,6 @@ pub enum TypeError<'tcx> {\n     CyclicConst(ty::Const<'tcx>),\n     ProjectionMismatched(ExpectedFound<DefId>),\n     ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>>),\n-    ObjectUnsafeCoercion(DefId),\n     ConstMismatch(ExpectedFound<ty::Const<'tcx>>),\n \n     IntrinsicCast,\n@@ -222,7 +221,6 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                 f,\n                 \"cannot coerce functions with `#[target_feature]` to safe function pointers\"\n             ),\n-            ObjectUnsafeCoercion(_) => write!(f, \"coercion to object-unsafe trait object\"),\n         }\n     }\n }\n@@ -249,8 +247,7 @@ impl<'tcx> TypeError<'tcx> {\n             | ProjectionMismatched(_)\n             | ExistentialMismatch(_)\n             | ConstMismatch(_)\n-            | IntrinsicCast\n-            | ObjectUnsafeCoercion(_) => true,\n+            | IntrinsicCast => true,\n         }\n     }\n }"}, {"sha": "d431d008ddf06ed96489dcea92e5a542aa74e537", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -407,6 +407,7 @@ where\n         match *t.kind() {\n             ty::Bound(debruijn, bound_ty) if debruijn == self.current_index => {\n                 let ty = self.delegate.replace_ty(bound_ty);\n+                debug_assert!(!ty.has_vars_bound_above(ty::INNERMOST));\n                 ty::fold::shift_vars(self.tcx, ty, self.current_index.as_u32())\n             }\n             _ if t.has_vars_bound_at_or_above(self.current_index) => t.super_fold_with(self),\n@@ -437,6 +438,7 @@ where\n         match ct.kind() {\n             ty::ConstKind::Bound(debruijn, bound_const) if debruijn == self.current_index => {\n                 let ct = self.delegate.replace_const(bound_const, ct.ty());\n+                debug_assert!(!ct.has_vars_bound_above(ty::INNERMOST));\n                 ty::fold::shift_vars(self.tcx, ct, self.current_index.as_u32())\n             }\n             _ => ct.super_fold_with(self),\n@@ -697,46 +699,41 @@ impl<'tcx> TypeFolder<'tcx> for Shifter<'tcx> {\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n-            ty::ReLateBound(debruijn, br) => {\n-                if self.amount == 0 || debruijn < self.current_index {\n-                    r\n-                } else {\n-                    let debruijn = debruijn.shifted_in(self.amount);\n-                    let shifted = ty::ReLateBound(debruijn, br);\n-                    self.tcx.mk_region(shifted)\n-                }\n+            ty::ReLateBound(debruijn, br) if debruijn >= self.current_index => {\n+                let debruijn = debruijn.shifted_in(self.amount);\n+                let shifted = ty::ReLateBound(debruijn, br);\n+                self.tcx.mk_region(shifted)\n             }\n             _ => r,\n         }\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         match *ty.kind() {\n-            ty::Bound(debruijn, bound_ty) => {\n-                if self.amount == 0 || debruijn < self.current_index {\n-                    ty\n-                } else {\n-                    let debruijn = debruijn.shifted_in(self.amount);\n-                    self.tcx.mk_ty(ty::Bound(debruijn, bound_ty))\n-                }\n+            ty::Bound(debruijn, bound_ty) if debruijn >= self.current_index => {\n+                let debruijn = debruijn.shifted_in(self.amount);\n+                self.tcx.mk_ty(ty::Bound(debruijn, bound_ty))\n             }\n \n-            _ => ty.super_fold_with(self),\n+            _ if ty.has_vars_bound_at_or_above(self.current_index) => ty.super_fold_with(self),\n+            _ => ty,\n         }\n     }\n \n     fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n-        if let ty::ConstKind::Bound(debruijn, bound_ct) = ct.kind() {\n-            if self.amount == 0 || debruijn < self.current_index {\n-                ct\n-            } else {\n-                let debruijn = debruijn.shifted_in(self.amount);\n-                self.tcx.mk_const(ty::ConstKind::Bound(debruijn, bound_ct), ct.ty())\n-            }\n+        if let ty::ConstKind::Bound(debruijn, bound_ct) = ct.kind()\n+            && debruijn >= self.current_index\n+        {\n+            let debruijn = debruijn.shifted_in(self.amount);\n+            self.tcx.mk_const(ty::ConstKind::Bound(debruijn, bound_ct), ct.ty())\n         } else {\n             ct.super_fold_with(self)\n         }\n     }\n+\n+    fn fold_predicate(&mut self, p: ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n+        if p.has_vars_bound_at_or_above(self.current_index) { p.super_fold_with(self) } else { p }\n+    }\n }\n \n pub fn shift_region<'tcx>(\n@@ -758,5 +755,9 @@ where\n {\n     debug!(\"shift_vars(value={:?}, amount={})\", value, amount);\n \n+    if amount == 0 || !value.has_escaping_bound_vars() {\n+        return value;\n+    }\n+\n     value.fold_with(&mut Shifter::new(tcx, amount))\n }"}, {"sha": "bd17f7d34ad9ccdb74b7586e93e45559ac7f39fe", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -1080,7 +1080,7 @@ pub trait PrettyPrinter<'tcx>:\n                 let mut resugared = false;\n \n                 // Special-case `Fn(...) -> ...` and re-sugar it.\n-                let fn_trait_kind = cx.tcx().fn_trait_kind_from_lang_item(principal.def_id);\n+                let fn_trait_kind = cx.tcx().fn_trait_kind_from_def_id(principal.def_id);\n                 if !cx.should_print_verbose() && fn_trait_kind.is_some() {\n                     if let ty::Tuple(tys) = principal.substs.type_at(0).kind() {\n                         let mut projections = predicates.projection_bounds();"}, {"sha": "5984686044b7340dfb5a3f57eaba07990613384c", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -2116,8 +2116,7 @@ impl<'tcx> Ty<'tcx> {\n     /// parameter. This is kind of a phantom type, except that the\n     /// most convenient thing for us to are the integral types. This\n     /// function converts such a special type into the closure\n-    /// kind. To go the other way, use\n-    /// `tcx.closure_kind_ty(closure_kind)`.\n+    /// kind. To go the other way, use `closure_kind.to_ty(tcx)`.\n     ///\n     /// Note that during type checking, we use an inference variable\n     /// to represent the closure kind, because it has not yet been"}, {"sha": "a115bb2831a4b2c1c1ec7dc04d4015495200a30e", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -37,7 +37,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n         }\n         ty::InstanceDef::FnPtrShim(def_id, ty) => {\n             let trait_ = tcx.trait_of_item(def_id).unwrap();\n-            let adjustment = match tcx.fn_trait_kind_from_lang_item(trait_) {\n+            let adjustment = match tcx.fn_trait_kind_from_def_id(trait_) {\n                 Some(ty::ClosureKind::FnOnce) => Adjustment::Identity,\n                 Some(ty::ClosureKind::FnMut | ty::ClosureKind::Fn) => Adjustment::Deref,\n                 None => bug!(\"fn pointer {:?} is not an fn\", ty),"}, {"sha": "927810351e958c1f73e7879bb8df49cbf75922f4", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -2029,10 +2029,7 @@ fn parse_native_lib_modifiers(\n                 \"linking modifier `bundle` is only compatible with `static` linking kind\",\n             ),\n \n-            (\"verbatim\", _) => {\n-                report_unstable_modifier();\n-                assign_modifier(&mut verbatim)\n-            }\n+            (\"verbatim\", _) => assign_modifier(&mut verbatim),\n \n             (\"whole-archive\", NativeLibKind::Static { whole_archive, .. }) => {\n                 assign_modifier(whole_archive)"}, {"sha": "88a13f75c7eb1865290a70a72957c09e7ddbe16e", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -599,17 +599,17 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n         computed_preds: &mut FxIndexSet<ty::Predicate<'tcx>>,\n         fresh_preds: &mut FxHashSet<ty::Predicate<'tcx>>,\n         predicates: &mut VecDeque<ty::PolyTraitPredicate<'tcx>>,\n-        select: &mut SelectionContext<'_, 'tcx>,\n+        selcx: &mut SelectionContext<'_, 'tcx>,\n         only_projections: bool,\n     ) -> bool {\n         let dummy_cause = ObligationCause::dummy();\n \n         for obligation in nested {\n             let is_new_pred =\n-                fresh_preds.insert(self.clean_pred(select.infcx(), obligation.predicate));\n+                fresh_preds.insert(self.clean_pred(selcx.infcx, obligation.predicate));\n \n             // Resolve any inference variables that we can, to help selection succeed\n-            let predicate = select.infcx().resolve_vars_if_possible(obligation.predicate);\n+            let predicate = selcx.infcx.resolve_vars_if_possible(obligation.predicate);\n \n             // We only add a predicate as a user-displayable bound if\n             // it involves a generic parameter, and doesn't contain\n@@ -717,10 +717,8 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                     // and turn them into an explicit negative impl for our type.\n                     debug!(\"Projecting and unifying projection predicate {:?}\", predicate);\n \n-                    match project::poly_project_and_unify_type(\n-                        select,\n-                        &obligation.with(self.tcx, p),\n-                    ) {\n+                    match project::poly_project_and_unify_type(selcx, &obligation.with(self.tcx, p))\n+                    {\n                         ProjectAndUnifyResult::MismatchedProjectionTypes(e) => {\n                             debug!(\n                                 \"evaluate_nested_obligations: Unable to unify predicate \\\n@@ -745,7 +743,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                                     computed_preds,\n                                     fresh_preds,\n                                     predicates,\n-                                    select,\n+                                    selcx,\n                                     only_projections,\n                                 ) {\n                                     return false;\n@@ -768,7 +766,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 }\n                 ty::PredicateKind::Clause(ty::Clause::RegionOutlives(binder)) => {\n                     let binder = bound_predicate.rebind(binder);\n-                    select.infcx().region_outlives_predicate(&dummy_cause, binder)\n+                    selcx.infcx.region_outlives_predicate(&dummy_cause, binder)\n                 }\n                 ty::PredicateKind::Clause(ty::Clause::TypeOutlives(binder)) => {\n                     let binder = bound_predicate.rebind(binder);\n@@ -777,14 +775,14 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                         binder.map_bound_ref(|pred| pred.0).no_bound_vars(),\n                     ) {\n                         (None, Some(t_a)) => {\n-                            select.infcx().register_region_obligation_with_cause(\n+                            selcx.infcx.register_region_obligation_with_cause(\n                                 t_a,\n-                                select.infcx().tcx.lifetimes.re_static,\n+                                selcx.infcx.tcx.lifetimes.re_static,\n                                 &dummy_cause,\n                             );\n                         }\n                         (Some(ty::OutlivesPredicate(t_a, r_b)), _) => {\n-                            select.infcx().register_region_obligation_with_cause(\n+                            selcx.infcx.register_region_obligation_with_cause(\n                                 t_a,\n                                 r_b,\n                                 &dummy_cause,\n@@ -796,13 +794,13 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 ty::PredicateKind::ConstEquate(c1, c2) => {\n                     let evaluate = |c: ty::Const<'tcx>| {\n                         if let ty::ConstKind::Unevaluated(unevaluated) = c.kind() {\n-                            match select.infcx().const_eval_resolve(\n+                            match selcx.infcx.const_eval_resolve(\n                                 obligation.param_env,\n                                 unevaluated,\n                                 Some(obligation.cause.span),\n                             ) {\n                                 Ok(Some(valtree)) => {\n-                                    Ok(ty::Const::from_value(select.tcx(), valtree, c.ty()))\n+                                    Ok(ty::Const::from_value(selcx.tcx(), valtree, c.ty()))\n                                 }\n                                 Ok(None) => {\n                                     let tcx = self.tcx;\n@@ -823,10 +821,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n \n                     match (evaluate(c1), evaluate(c2)) {\n                         (Ok(c1), Ok(c2)) => {\n-                            match select\n-                                .infcx()\n-                                .at(&obligation.cause, obligation.param_env)\n-                                .eq(c1, c2)\n+                            match selcx.infcx.at(&obligation.cause, obligation.param_env).eq(c1, c2)\n                             {\n                                 Ok(_) => (),\n                                 Err(_) => return false,"}, {"sha": "99724fb28db1104ab90a8c7c04a6f54865d9377c", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -119,7 +119,7 @@ fn with_fresh_ty_vars<'cx, 'tcx>(\n     impl_def_id: DefId,\n ) -> ty::ImplHeader<'tcx> {\n     let tcx = selcx.tcx();\n-    let impl_substs = selcx.infcx().fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+    let impl_substs = selcx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n \n     let header = ty::ImplHeader {\n         impl_def_id,\n@@ -149,7 +149,7 @@ fn overlap<'cx, 'tcx>(\n         impl1_def_id, impl2_def_id, overlap_mode\n     );\n \n-    selcx.infcx().probe_maybe_skip_leak_check(skip_leak_check.is_yes(), |snapshot| {\n+    selcx.infcx.probe_maybe_skip_leak_check(skip_leak_check.is_yes(), |snapshot| {\n         overlap_within_probe(selcx, impl1_def_id, impl2_def_id, overlap_mode, snapshot)\n     })\n }\n@@ -161,7 +161,7 @@ fn overlap_within_probe<'cx, 'tcx>(\n     overlap_mode: OverlapMode,\n     snapshot: &CombinedSnapshot<'tcx>,\n ) -> Option<OverlapResult<'tcx>> {\n-    let infcx = selcx.infcx();\n+    let infcx = selcx.infcx;\n \n     if overlap_mode.use_negative_impl() {\n         if negative_impl(infcx.tcx, impl1_def_id, impl2_def_id)\n@@ -200,9 +200,9 @@ fn overlap_within_probe<'cx, 'tcx>(\n     debug!(\"overlap: intercrate_ambiguity_causes={:#?}\", intercrate_ambiguity_causes);\n \n     let involves_placeholder =\n-        matches!(selcx.infcx().region_constraints_added_in_snapshot(snapshot), Some(true));\n+        matches!(selcx.infcx.region_constraints_added_in_snapshot(snapshot), Some(true));\n \n-    let impl_header = selcx.infcx().resolve_vars_if_possible(impl1_header);\n+    let impl_header = selcx.infcx.resolve_vars_if_possible(impl1_header);\n     Some(OverlapResult { impl_header, intercrate_ambiguity_causes, involves_placeholder })\n }\n \n@@ -214,7 +214,7 @@ fn equate_impl_headers<'cx, 'tcx>(\n     // Do `a` and `b` unify? If not, no overlap.\n     debug!(\"equate_impl_headers(impl1_header={:?}, impl2_header={:?}\", impl1_header, impl2_header);\n     selcx\n-        .infcx()\n+        .infcx\n         .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n         .eq_impl_headers(impl1_header, impl2_header)\n         .map(|infer_ok| infer_ok.obligations)\n@@ -255,7 +255,7 @@ fn implicit_negative<'cx, 'tcx>(\n         \"implicit_negative(impl1_header={:?}, impl2_header={:?}, obligations={:?})\",\n         impl1_header, impl2_header, obligations\n     );\n-    let infcx = selcx.infcx();\n+    let infcx = selcx.infcx;\n     let opt_failing_obligation = impl1_header\n         .predicates\n         .iter()"}, {"sha": "e96b9b64e78749c0b16184d53682699986b1380d", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -357,7 +357,8 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n                 ocx.register_obligation(obligation);\n                 if ocx.select_all_or_error().is_empty() {\n                     return Ok((\n-                        ty::ClosureKind::from_def_id(self.tcx, trait_def_id)\n+                        self.tcx\n+                            .fn_trait_kind_from_def_id(trait_def_id)\n                             .expect(\"expected to map DefId to ClosureKind\"),\n                         ty.rebind(self.resolve_vars_if_possible(var)),\n                     ));\n@@ -686,7 +687,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 }\n                                 ObligationCauseCode::BindingObligation(def_id, _)\n                                 | ObligationCauseCode::ItemObligation(def_id)\n-                                    if ty::ClosureKind::from_def_id(tcx, *def_id).is_some() =>\n+                                    if tcx.is_fn_trait(*def_id) =>\n                                 {\n                                     err.code(rustc_errors::error_code!(E0059));\n                                     err.set_primary_message(format!(\n@@ -846,8 +847,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             );\n                         }\n \n-                        let is_fn_trait =\n-                            ty::ClosureKind::from_def_id(tcx, trait_ref.def_id()).is_some();\n+                        let is_fn_trait = tcx.is_fn_trait(trait_ref.def_id());\n                         let is_target_feature_fn = if let ty::FnDef(def_id, _) =\n                             *trait_ref.skip_binder().self_ty().kind()\n                         {\n@@ -877,7 +877,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             // Note if the `FnMut` or `FnOnce` is less general than the trait we're trying\n                             // to implement.\n                             let selected_kind =\n-                                ty::ClosureKind::from_def_id(self.tcx, trait_ref.def_id())\n+                                self.tcx.fn_trait_kind_from_def_id(trait_ref.def_id())\n                                     .expect(\"expected to map DefId to ClosureKind\");\n                             if !implemented_kind.extends(selected_kind) {\n                                 err.note(\n@@ -2155,7 +2155,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     if generics.params.iter().any(|p| p.name != kw::SelfUpper)\n                         && !snippet.ends_with('>')\n                         && !generics.has_impl_trait()\n-                        && !self.tcx.fn_trait_kind_from_lang_item(def_id).is_some()\n+                        && !self.tcx.is_fn_trait(def_id)\n                     {\n                         // FIXME: To avoid spurious suggestions in functions where type arguments\n                         // where already supplied, we check the snippet to make sure it doesn't"}, {"sha": "992ea1755163fbad6b039e64ae8b520461b993de", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -1679,9 +1679,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         ) -> Ty<'tcx> {\n             let inputs = trait_ref.skip_binder().substs.type_at(1);\n             let sig = match inputs.kind() {\n-                ty::Tuple(inputs)\n-                    if infcx.tcx.fn_trait_kind_from_lang_item(trait_ref.def_id()).is_some() =>\n-                {\n+                ty::Tuple(inputs) if infcx.tcx.is_fn_trait(trait_ref.def_id()) => {\n                     infcx.tcx.mk_fn_sig(\n                         inputs.iter(),\n                         infcx.next_ty_var(TypeVariableOrigin {\n@@ -1752,7 +1750,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             && let predicates = self.tcx.predicates_of(def_id).instantiate_identity(self.tcx)\n             && let Some(pred) = predicates.predicates.get(*idx)\n             && let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = pred.kind().skip_binder()\n-            && ty::ClosureKind::from_def_id(self.tcx, trait_pred.def_id()).is_some()\n+            && self.tcx.is_fn_trait(trait_pred.def_id())\n         {\n             let expected_self =\n                 self.tcx.anonymize_late_bound_regions(pred.kind().rebind(trait_pred.self_ty()));\n@@ -1766,8 +1764,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 .enumerate()\n                 .find(|(other_idx, (pred, _))| match pred.kind().skip_binder() {\n                     ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred))\n-                        if ty::ClosureKind::from_def_id(self.tcx, trait_pred.def_id())\n-                            .is_some()\n+                        if self.tcx.is_fn_trait(trait_pred.def_id())\n                             && other_idx != idx\n                             // Make sure that the self type matches\n                             // (i.e. constraining this closure)"}, {"sha": "76a755ed9e09d4a1da7070064fba845301c5d12a", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -199,7 +199,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n             // code is so hot. 1 and 0 dominate; 2+ is fairly rare.\n             1 => {\n                 let infer_var = pending_obligation.stalled_on[0];\n-                self.selcx.infcx().ty_or_const_infer_var_changed(infer_var)\n+                self.selcx.infcx.ty_or_const_infer_var_changed(infer_var)\n             }\n             0 => {\n                 // In this case we haven't changed, but wish to make a change.\n@@ -210,7 +210,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 // form was a perf win. See #64545 for details.\n                 (|| {\n                     for &infer_var in &pending_obligation.stalled_on {\n-                        if self.selcx.infcx().ty_or_const_infer_var_changed(infer_var) {\n+                        if self.selcx.infcx.ty_or_const_infer_var_changed(infer_var) {\n                             return true;\n                         }\n                     }\n@@ -240,13 +240,12 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n         debug!(?obligation, \"pre-resolve\");\n \n         if obligation.predicate.has_non_region_infer() {\n-            obligation.predicate =\n-                self.selcx.infcx().resolve_vars_if_possible(obligation.predicate);\n+            obligation.predicate = self.selcx.infcx.resolve_vars_if_possible(obligation.predicate);\n         }\n \n         let obligation = &pending_obligation.obligation;\n \n-        let infcx = self.selcx.infcx();\n+        let infcx = self.selcx.infcx;\n \n         if obligation.predicate.has_projections() {\n             let mut obligations = Vec::new();\n@@ -353,7 +352,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 }\n \n                 ty::PredicateKind::ClosureKind(_, closure_substs, kind) => {\n-                    match self.selcx.infcx().closure_kind(closure_substs) {\n+                    match self.selcx.infcx.closure_kind(closure_substs) {\n                         Some(closure_kind) => {\n                             if closure_kind.extends(kind) {\n                                 ProcessResult::Changed(vec![])\n@@ -367,7 +366,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n \n                 ty::PredicateKind::WellFormed(arg) => {\n                     match wf::obligations(\n-                        self.selcx.infcx(),\n+                        self.selcx.infcx,\n                         obligation.param_env,\n                         obligation.cause.body_id,\n                         obligation.recursion_depth + 1,\n@@ -384,7 +383,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 }\n \n                 ty::PredicateKind::Subtype(subtype) => {\n-                    match self.selcx.infcx().subtype_predicate(\n+                    match self.selcx.infcx.subtype_predicate(\n                         &obligation.cause,\n                         obligation.param_env,\n                         Binder::dummy(subtype),\n@@ -408,7 +407,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 }\n \n                 ty::PredicateKind::Coerce(coerce) => {\n-                    match self.selcx.infcx().coerce_predicate(\n+                    match self.selcx.infcx.coerce_predicate(\n                         &obligation.cause,\n                         obligation.param_env,\n                         Binder::dummy(coerce),\n@@ -432,7 +431,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n \n                 ty::PredicateKind::ConstEvaluatable(uv) => {\n                     match const_evaluatable::is_const_evaluatable(\n-                        self.selcx.infcx(),\n+                        self.selcx.infcx,\n                         uv,\n                         obligation.param_env,\n                         obligation.cause.span,\n@@ -503,7 +502,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n \n                     let mut evaluate = |c: Const<'tcx>| {\n                         if let ty::ConstKind::Unevaluated(unevaluated) = c.kind() {\n-                            match self.selcx.infcx().try_const_eval_resolve(\n+                            match self.selcx.infcx.try_const_eval_resolve(\n                                 obligation.param_env,\n                                 unevaluated,\n                                 c.ty(),\n@@ -531,7 +530,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                         (Ok(c1), Ok(c2)) => {\n                             match self\n                                 .selcx\n-                                .infcx()\n+                                .infcx\n                                 .at(&obligation.cause, obligation.param_env)\n                                 .eq(c1, c2)\n                             {\n@@ -601,7 +600,7 @@ impl<'a, 'tcx> FulfillProcessor<'a, 'tcx> {\n         trait_obligation: TraitObligation<'tcx>,\n         stalled_on: &mut Vec<TyOrConstInferVar<'tcx>>,\n     ) -> ProcessResult<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>> {\n-        let infcx = self.selcx.infcx();\n+        let infcx = self.selcx.infcx;\n         if obligation.predicate.is_global() {\n             // no type variables present, can use evaluation for better caching.\n             // FIXME: consider caching errors too.\n@@ -659,7 +658,7 @@ impl<'a, 'tcx> FulfillProcessor<'a, 'tcx> {\n         if obligation.predicate.is_global() {\n             // no type variables present, can use evaluation for better caching.\n             // FIXME: consider caching errors too.\n-            if self.selcx.infcx().predicate_must_hold_considering_regions(obligation) {\n+            if self.selcx.infcx.predicate_must_hold_considering_regions(obligation) {\n                 if let Some(key) = ProjectionCacheKey::from_poly_projection_predicate(\n                     &mut self.selcx,\n                     project_obligation.predicate,\n@@ -668,7 +667,7 @@ impl<'a, 'tcx> FulfillProcessor<'a, 'tcx> {\n                     // evaluated all sub-obligations. We can therefore mark the 'root'\n                     // obligation as complete, and skip evaluating sub-obligations.\n                     self.selcx\n-                        .infcx()\n+                        .infcx\n                         .inner\n                         .borrow_mut()\n                         .projection_cache()\n@@ -707,7 +706,7 @@ fn substs_infer_vars<'a, 'tcx>(\n     substs: ty::Binder<'tcx, SubstsRef<'tcx>>,\n ) -> impl Iterator<Item = TyOrConstInferVar<'tcx>> {\n     selcx\n-        .infcx()\n+        .infcx\n         .resolve_vars_if_possible(substs)\n         .skip_binder() // ok because this check doesn't care about regions\n         .iter()"}, {"sha": "18f4379d8f890f6cf01423698459b5b55b1bedea", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -194,7 +194,7 @@ pub(super) fn poly_project_and_unify_type<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &PolyProjectionObligation<'tcx>,\n ) -> ProjectAndUnifyResult<'tcx> {\n-    let infcx = selcx.infcx();\n+    let infcx = selcx.infcx;\n     let r = infcx.commit_if_ok(|_snapshot| {\n         let old_universe = infcx.universe();\n         let placeholder_predicate =\n@@ -250,7 +250,7 @@ fn project_and_unify_type<'cx, 'tcx>(\n ) -> ProjectAndUnifyResult<'tcx> {\n     let mut obligations = vec![];\n \n-    let infcx = selcx.infcx();\n+    let infcx = selcx.infcx;\n     let normalized = match opt_normalize_projection_type(\n         selcx,\n         obligation.param_env,\n@@ -269,7 +269,7 @@ fn project_and_unify_type<'cx, 'tcx>(\n     // This allows users to omit re-mentioning all bounds on an associated type and just use an\n     // `impl Trait` for the assoc type to add more bounds.\n     let InferOk { value: actual, obligations: new } =\n-        selcx.infcx().replace_opaque_types_with_inference_vars(\n+        selcx.infcx.replace_opaque_types_with_inference_vars(\n             actual,\n             obligation.cause.body_id,\n             obligation.cause.span,\n@@ -445,7 +445,7 @@ impl<'a, 'b, 'tcx> AssocTypeNormalizer<'a, 'b, 'tcx> {\n     }\n \n     fn fold<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n-        let value = self.selcx.infcx().resolve_vars_if_possible(value);\n+        let value = self.selcx.infcx.resolve_vars_if_possible(value);\n         debug!(?value);\n \n         assert!(\n@@ -524,7 +524,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                                 self.param_env,\n                                 ty,\n                             );\n-                            self.selcx.infcx().err_ctxt().report_overflow_error(&obligation, true);\n+                            self.selcx.infcx.err_ctxt().report_overflow_error(&obligation, true);\n                         }\n \n                         let substs = substs.fold_with(self);\n@@ -590,7 +590,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 // want to figure out how to register obligations with escaping vars\n                 // or handle this some other way.\n \n-                let infcx = self.selcx.infcx();\n+                let infcx = self.selcx.infcx;\n                 let (data, mapped_regions, mapped_types, mapped_consts) =\n                     BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, data);\n                 let data = data.fold_with(self);\n@@ -640,7 +640,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n             let constant = constant.super_fold_with(self);\n             debug!(?constant, ?self.param_env);\n             with_replaced_escaping_bound_vars(\n-                self.selcx.infcx(),\n+                self.selcx.infcx,\n                 &mut self.universes,\n                 constant,\n                 |constant| constant.eval(tcx, self.param_env),\n@@ -992,10 +992,7 @@ pub fn normalize_projection_type<'a, 'b, 'tcx>(\n         // and a deferred predicate to resolve this when more type\n         // information is available.\n \n-        selcx\n-            .infcx()\n-            .infer_projection(param_env, projection_ty, cause, depth + 1, obligations)\n-            .into()\n+        selcx.infcx.infer_projection(param_env, projection_ty, cause, depth + 1, obligations).into()\n     })\n }\n \n@@ -1018,7 +1015,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n     depth: usize,\n     obligations: &mut Vec<PredicateObligation<'tcx>>,\n ) -> Result<Option<Term<'tcx>>, InProgress> {\n-    let infcx = selcx.infcx();\n+    let infcx = selcx.infcx;\n     // Don't use the projection cache in intercrate mode -\n     // the `infcx` may be re-used between intercrate in non-intercrate\n     // mode, which could lead to using incorrect cache results.\n@@ -1110,7 +1107,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // an impl, where-clause etc) and hence we must\n             // re-normalize it\n \n-            let projected_term = selcx.infcx().resolve_vars_if_possible(projected_term);\n+            let projected_term = selcx.infcx.resolve_vars_if_possible(projected_term);\n \n             let mut result = if projected_term.has_projections() {\n                 let mut normalizer = AssocTypeNormalizer::new(\n@@ -1206,9 +1203,9 @@ fn normalize_to_error<'a, 'tcx>(\n         param_env,\n         predicate: trait_ref.without_const().to_predicate(selcx.tcx()),\n     };\n-    let tcx = selcx.infcx().tcx;\n+    let tcx = selcx.infcx.tcx;\n     let def_id = projection_ty.item_def_id;\n-    let new_value = selcx.infcx().next_ty_var(TypeVariableOrigin {\n+    let new_value = selcx.infcx.next_ty_var(TypeVariableOrigin {\n         kind: TypeVariableOriginKind::NormalizeProjectionType,\n         span: tcx.def_span(def_id),\n     });\n@@ -1330,7 +1327,7 @@ fn assemble_candidate_for_impl_trait_in_trait<'cx, 'tcx>(\n         let trait_predicate =\n             ty::Binder::dummy(ty::TraitRef { def_id: trait_def_id, substs: trait_substs });\n \n-        let _ = selcx.infcx().commit_if_ok(|_| {\n+        let _ = selcx.infcx.commit_if_ok(|_| {\n             match selcx.select(&obligation.with(tcx, trait_predicate)) {\n                 Ok(Some(super::ImplSource::UserDefined(data))) => {\n                     candidate_set.push_candidate(ProjectionCandidate::ImplTraitInTrait(\n@@ -1435,7 +1432,7 @@ fn assemble_candidates_from_object_ty<'cx, 'tcx>(\n     let tcx = selcx.tcx();\n \n     let self_ty = obligation.predicate.self_ty();\n-    let object_ty = selcx.infcx().shallow_resolve(self_ty);\n+    let object_ty = selcx.infcx.shallow_resolve(self_ty);\n     let data = match object_ty.kind() {\n         ty::Dynamic(data, ..) => data,\n         ty::Infer(ty::TyVar(_)) => {\n@@ -1473,7 +1470,7 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     env_predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n     potentially_unnormalized_candidates: bool,\n ) {\n-    let infcx = selcx.infcx();\n+    let infcx = selcx.infcx;\n     for predicate in env_predicates {\n         let bound_predicate = predicate.kind();\n         if let ty::PredicateKind::Clause(ty::Clause::Projection(data)) =\n@@ -1529,7 +1526,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n     // start out by selecting the predicate `T as TraitRef<...>`:\n     let poly_trait_ref = ty::Binder::dummy(obligation.predicate.trait_ref(selcx.tcx()));\n     let trait_obligation = obligation.with(selcx.tcx(), poly_trait_ref);\n-    let _ = selcx.infcx().commit_if_ok(|_| {\n+    let _ = selcx.infcx.commit_if_ok(|_| {\n         let impl_source = match selcx.select(&trait_obligation) {\n             Ok(Some(impl_source)) => impl_source,\n             Ok(None) => {\n@@ -1587,7 +1584,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                     if obligation.param_env.reveal() == Reveal::All {\n                         // NOTE(eddyb) inference variables can resolve to parameters, so\n                         // assume `poly_trait_ref` isn't monomorphic, if it contains any.\n-                        let poly_trait_ref = selcx.infcx().resolve_vars_if_possible(poly_trait_ref);\n+                        let poly_trait_ref = selcx.infcx.resolve_vars_if_possible(poly_trait_ref);\n                         !poly_trait_ref.still_further_specializable()\n                     } else {\n                         debug!(\n@@ -1603,7 +1600,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // While a builtin impl may be known to exist, the associated type may not yet\n                 // be known. Any type with multiple potential associated types is therefore\n                 // not eligible.\n-                let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n+                let self_ty = selcx.infcx.shallow_resolve(obligation.predicate.self_ty());\n \n                 let lang_items = selcx.tcx().lang_items();\n                 if lang_items.discriminant_kind_trait() == Some(poly_trait_ref.def_id()) {\n@@ -1690,7 +1687,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                         // type parameters, opaques, and unnormalized projections have pointer\n                         // metadata if they're known (e.g. by the param_env) to be sized\n                         ty::Param(_) | ty::Projection(..) | ty::Opaque(..)\n-                            if selcx.infcx().predicate_must_hold_modulo_regions(\n+                            if selcx.infcx.predicate_must_hold_modulo_regions(\n                                 &obligation.with(\n                                     selcx.tcx(),\n                                     ty::Binder::dummy(\n@@ -1818,8 +1815,7 @@ fn confirm_candidate<'cx, 'tcx>(\n     // when possible for this to work. See `auto-trait-projection-recursion.rs`\n     // for a case where this matters.\n     if progress.term.has_infer_regions() {\n-        progress.term =\n-            progress.term.fold_with(&mut OpportunisticRegionResolver::new(selcx.infcx()));\n+        progress.term = progress.term.fold_with(&mut OpportunisticRegionResolver::new(selcx.infcx));\n     }\n     progress\n }\n@@ -2000,7 +1996,7 @@ fn confirm_fn_pointer_candidate<'cx, 'tcx>(\n     obligation: &ProjectionTyObligation<'tcx>,\n     fn_pointer_impl_source: ImplSourceFnPointerData<'tcx, PredicateObligation<'tcx>>,\n ) -> Progress<'tcx> {\n-    let fn_type = selcx.infcx().shallow_resolve(fn_pointer_impl_source.fn_ty);\n+    let fn_type = selcx.infcx.shallow_resolve(fn_pointer_impl_source.fn_ty);\n     let sig = fn_type.fn_sig(selcx.tcx());\n     let Normalized { value: sig, obligations } = normalize_with_depth(\n         selcx,\n@@ -2073,7 +2069,7 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n     poly_cache_entry: ty::PolyProjectionPredicate<'tcx>,\n     potentially_unnormalized_candidate: bool,\n ) -> Progress<'tcx> {\n-    let infcx = selcx.infcx();\n+    let infcx = selcx.infcx;\n     let cause = &obligation.cause;\n     let param_env = obligation.param_env;\n \n@@ -2168,7 +2164,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     // * `substs` ends up as `[u32, S]`\n     let substs = obligation.predicate.substs.rebase_onto(tcx, trait_def_id, substs);\n     let substs =\n-        translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.defining_node);\n+        translate_substs(selcx.infcx, param_env, impl_def_id, substs, assoc_ty.defining_node);\n     let ty = tcx.bound_type_of(assoc_ty.item.def_id);\n     let is_const = matches!(tcx.def_kind(assoc_ty.item.def_id), DefKind::AssocConst);\n     let term: ty::EarlyBinder<ty::Term<'tcx>> = if is_const {\n@@ -2264,7 +2260,7 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n     let impl_fn_substs =\n         obligation.predicate.substs.rebase_onto(tcx, tcx.parent(trait_fn_def_id), data.substs);\n     let impl_fn_substs = translate_substs(\n-        selcx.infcx(),\n+        selcx.infcx,\n         obligation.param_env,\n         data.impl_def_id,\n         impl_fn_substs,\n@@ -2424,7 +2420,7 @@ impl<'cx, 'tcx> ProjectionCacheKeyExt<'cx, 'tcx> for ProjectionCacheKey<'tcx> {\n         selcx: &mut SelectionContext<'cx, 'tcx>,\n         predicate: ty::PolyProjectionPredicate<'tcx>,\n     ) -> Option<Self> {\n-        let infcx = selcx.infcx();\n+        let infcx = selcx.infcx;\n         // We don't do cross-snapshot caching of obligations with escaping regions,\n         // so there's no cache key to use\n         predicate.no_bound_vars().map(|predicate| {"}, {"sha": "10854ede652b5870785c564dac6d6ffb5bfafe86", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -238,7 +238,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             param_env: obligation.param_env,\n             cause: obligation.cause.clone(),\n             recursion_depth: obligation.recursion_depth,\n-            predicate: self.infcx().resolve_vars_if_possible(obligation.predicate),\n+            predicate: self.infcx.resolve_vars_if_possible(obligation.predicate),\n         };\n \n         if obligation.predicate.skip_binder().self_ty().is_ty_var() {\n@@ -451,7 +451,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) {\n-        let Some(kind) = self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()) else {\n+        let Some(kind) = self.tcx().fn_trait_kind_from_def_id(obligation.predicate.def_id()) else {\n             return;\n         };\n \n@@ -489,7 +489,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) {\n         // We provide impl of all fn traits for fn pointers.\n-        if self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()).is_none() {\n+        if !self.tcx().is_fn_trait(obligation.predicate.def_id()) {\n             return;\n         }\n \n@@ -689,9 +689,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             debug!(?poly_trait_ref, \"assemble_candidates_from_object_ty\");\n \n-            let poly_trait_predicate = self.infcx().resolve_vars_if_possible(obligation.predicate);\n+            let poly_trait_predicate = self.infcx.resolve_vars_if_possible(obligation.predicate);\n             let placeholder_trait_predicate =\n-                self.infcx().replace_bound_vars_with_placeholders(poly_trait_predicate);\n+                self.infcx.replace_bound_vars_with_placeholders(poly_trait_predicate);\n \n             // Count only those upcast versions that match the trait-ref\n             // we are looking for. Specifically, do not only check for the\n@@ -940,7 +940,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return;\n         }\n \n-        let self_ty = self.infcx().shallow_resolve(obligation.self_ty());\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n         match self_ty.skip_binder().kind() {\n             ty::Opaque(..)\n             | ty::Dynamic(..)\n@@ -1007,7 +1007,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) {\n-        let self_ty = self.infcx().shallow_resolve(obligation.self_ty().skip_binder());\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n         match self_ty.kind() {\n             ty::Tuple(_) => {\n                 candidates.vec.push(BuiltinCandidate { has_nested: false });"}, {"sha": "22cd700dcb5f4747705c2c31185cace511e59529", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -147,7 +147,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let trait_predicate = self.infcx.shallow_resolve(obligation.predicate);\n         let placeholder_trait_predicate =\n-            self.infcx().replace_bound_vars_with_placeholders(trait_predicate).trait_ref;\n+            self.infcx.replace_bound_vars_with_placeholders(trait_predicate).trait_ref;\n         let placeholder_self_ty = placeholder_trait_predicate.self_ty();\n         let placeholder_trait_predicate = ty::Binder::dummy(placeholder_trait_predicate);\n         let (def_id, substs) = match *placeholder_self_ty.kind() {\n@@ -639,7 +639,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(?obligation, \"confirm_trait_alias_candidate\");\n \n         let alias_def_id = obligation.predicate.def_id();\n-        let predicate = self.infcx().replace_bound_vars_with_placeholders(obligation.predicate);\n+        let predicate = self.infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n         let trait_ref = predicate.trait_ref;\n         let trait_def_id = trait_ref.def_id;\n         let substs = trait_ref.substs;\n@@ -735,7 +735,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Result<ImplSourceClosureData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         let kind = self\n             .tcx()\n-            .fn_trait_kind_from_lang_item(obligation.predicate.def_id())\n+            .fn_trait_kind_from_def_id(obligation.predicate.def_id())\n             .unwrap_or_else(|| bug!(\"closure candidate for non-fn trait {:?}\", obligation));\n \n         // Okay to skip binder because the substs on closure types never"}, {"sha": "a2d2d44fbc28f8c4c57355beb4b7b64042e21700", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -101,7 +101,7 @@ impl IntercrateAmbiguityCause {\n }\n \n pub struct SelectionContext<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'tcx>,\n+    pub infcx: &'cx InferCtxt<'tcx>,\n \n     /// Freshener used specifically for entries on the obligation\n     /// stack. This ensures that all entries on the stack at one time\n@@ -237,10 +237,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.intercrate_ambiguity_causes.take().unwrap_or_default()\n     }\n \n-    pub fn infcx(&self) -> &'cx InferCtxt<'tcx> {\n-        self.infcx\n-    }\n-\n     pub fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n@@ -734,10 +730,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                     match (evaluate(c1), evaluate(c2)) {\n                         (Ok(c1), Ok(c2)) => {\n-                            match self\n-                                .infcx()\n-                                .at(&obligation.cause, obligation.param_env)\n-                                .eq(c1, c2)\n+                            match self.infcx.at(&obligation.cause, obligation.param_env).eq(c1, c2)\n                             {\n                                 Ok(inf_ok) => self.evaluate_predicates_recursively(\n                                     previous_stack,\n@@ -1256,7 +1249,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         let obligation = &stack.obligation;\n-        let predicate = self.infcx().resolve_vars_if_possible(obligation.predicate);\n+        let predicate = self.infcx.resolve_vars_if_possible(obligation.predicate);\n \n         // Okay to skip binder because of the nature of the\n         // trait-ref-is-knowable check, which does not care about\n@@ -1393,9 +1386,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> smallvec::SmallVec<[(usize, ty::BoundConstness); 2]> {\n-        let poly_trait_predicate = self.infcx().resolve_vars_if_possible(obligation.predicate);\n+        let poly_trait_predicate = self.infcx.resolve_vars_if_possible(obligation.predicate);\n         let placeholder_trait_predicate =\n-            self.infcx().replace_bound_vars_with_placeholders(poly_trait_predicate);\n+            self.infcx.replace_bound_vars_with_placeholders(poly_trait_predicate);\n         debug!(?placeholder_trait_predicate);\n \n         let tcx = self.infcx.tcx;\n@@ -2175,7 +2168,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n     ) -> Result<Normalized<'tcx, SubstsRef<'tcx>>, ()> {\n         let placeholder_obligation =\n-            self.infcx().replace_bound_vars_with_placeholders(obligation.predicate);\n+            self.infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n         let placeholder_obligation_trait_ref = placeholder_obligation.trait_ref;\n \n         let impl_substs = self.infcx.fresh_substs_for_item(obligation.cause.span, impl_def_id);"}, {"sha": "a06db4c274831fdf76f01069852c93adadc6e08d", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -203,13 +203,13 @@ pub fn impl_subject_and_oblig<'a, 'tcx>(\n     let subject = selcx.tcx().bound_impl_subject(impl_def_id);\n     let subject = subject.subst(selcx.tcx(), impl_substs);\n     let InferOk { value: subject, obligations: normalization_obligations1 } = selcx\n-        .infcx()\n+        .infcx\n         .partially_normalize_associated_types_in(ObligationCause::dummy(), param_env, subject);\n \n     let predicates = selcx.tcx().predicates_of(impl_def_id);\n     let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n     let InferOk { value: predicates, obligations: normalization_obligations2 } = selcx\n-        .infcx()\n+        .infcx\n         .partially_normalize_associated_types_in(ObligationCause::dummy(), param_env, predicates);\n     let impl_obligations =\n         super::predicates_for_generics(|_, _| ObligationCause::dummy(), param_env, predicates);"}, {"sha": "c6f2b16ca210226db5b9482d7233e87676418292", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -209,7 +209,7 @@ fn resolve_associated_item<'tcx>(\n             substs: future_data.substs,\n         }),\n         traits::ImplSource::Closure(closure_data) => {\n-            let trait_closure_kind = tcx.fn_trait_kind_from_lang_item(trait_id).unwrap();\n+            let trait_closure_kind = tcx.fn_trait_kind_from_def_id(trait_id).unwrap();\n             Instance::resolve_closure(\n                 tcx,\n                 closure_data.closure_def_id,"}, {"sha": "ef6eee75f1ce6c2cdc4d0ed83e43144e60bb68de", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -104,6 +104,33 @@ This modifier has no effect when building other targets like executables or dyna\n \n The default for this modifier is `+bundle`.\n \n+### Linking modifiers: `verbatim`\n+\n+This modifier is compatible with all linking kinds.\n+\n+`+verbatim` means that rustc itself won't add any target-specified library prefixes or suffixes\n+(like `lib` or `.a`) to the library name, and will try its best to ask for the same thing from the\n+linker.\n+\n+For `ld`-like linkers supporting GNU extensions rustc will use the `-l:filename` syntax (note the\n+colon) when passing the library, so the linker won't add any prefixes or suffixes to it.\n+See [`-l namespec`](https://sourceware.org/binutils/docs/ld/Options.html) in ld documentation for\n+more details. \\\n+For linkers not supporting any verbatim modifiers (e.g. `link.exe` or `ld64`) the library name will\n+be passed as is. So the most reliable cross-platform use scenarios for this option are when no\n+linker is involved, for example bundling native libraries into rlibs.\n+\n+`-verbatim` means that rustc will either add a target-specific prefix and suffix to the library\n+name before passing it to linker, or won't prevent linker from implicitly adding it. \\\n+In case of `raw-dylib` kind in particular `.dll` will be added to the library name on Windows.\n+\n+The default for this modifier is `-verbatim`.\n+\n+NOTE: Even with `+verbatim` and `-l:filename` syntax `ld`-like linkers do not typically support\n+passing absolute paths to libraries. Usually such paths need to be passed as input files without\n+using any options like `-l`, e.g. `ld /my/absolute/path`. \\\n+`-Clink-arg=/my/absolute/path` can be used for doing this from stable `rustc`.\n+\n <a id=\"option-crate-type\"></a>\n ## `--crate-type`: a list of types of crates for the compiler to emit\n "}, {"sha": "02bd87e50956d4ee83acec6e389a63e83513e4a2", "filename": "src/doc/unstable-book/src/language-features/native-link-modifiers-verbatim.md", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnative-link-modifiers-verbatim.md", "raw_url": "https://github.com/rust-lang/rust/raw/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnative-link-modifiers-verbatim.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnative-link-modifiers-verbatim.md?ref=69df0f2c2f665d7f4e38a3579a81d4efc0d81034", "patch": "@@ -1,20 +0,0 @@\n-# `native_link_modifiers_verbatim`\n-\n-The tracking issue for this feature is: [#81490]\n-\n-[#81490]: https://github.com/rust-lang/rust/issues/81490\n-\n-------------------------\n-\n-The `native_link_modifiers_verbatim` feature allows you to use the `verbatim` modifier.\n-\n-`+verbatim` means that rustc itself won't add any target-specified library prefixes or suffixes (like `lib` or `.a`) to the library name, and will try its best to ask for the same thing from the linker.\n-\n-For `ld`-like linkers rustc will use the `-l:filename` syntax (note the colon) when passing the library, so the linker won't add any prefixes or suffixes as well.\n-See [`-l namespec`](https://sourceware.org/binutils/docs/ld/Options.html) in ld documentation for more details.\n-For linkers not supporting any verbatim modifiers (e.g. `link.exe` or `ld64`) the library name will be passed as is.\n-\n-The default for this modifier is `-verbatim`.\n-\n-This RFC changes the behavior of `raw-dylib` linking kind specified by [RFC 2627](https://github.com/rust-lang/rfcs/pull/2627). The `.dll` suffix (or other target-specified suffixes for other targets) is now added automatically.\n-If your DLL doesn't have the `.dll` suffix, it can be specified with `+verbatim`."}, {"sha": "246560bad291ffcc173fd72610030f1138951f75", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -106,7 +106,7 @@ fn external_generic_args<'tcx>(\n ) -> GenericArgs {\n     let args = substs_to_args(cx, substs, has_self);\n \n-    if cx.tcx.fn_trait_kind_from_lang_item(did).is_some() {\n+    if cx.tcx.fn_trait_kind_from_def_id(did).is_some() {\n         let inputs =\n             // The trait's first substitution is the one after self, if there is one.\n             match substs.iter().nth(if has_self { 1 } else { 0 }).unwrap().expect_ty().kind() {"}, {"sha": "666e4084ce295d4cc16b80d61b2b6bacecd53006", "filename": "src/test/run-make/native-link-modifier-verbatim-linker/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Frun-make%2Fnative-link-modifier-verbatim-linker%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Frun-make%2Fnative-link-modifier-verbatim-linker%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fnative-link-modifier-verbatim-linker%2FMakefile?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -6,10 +6,10 @@ include ../../run-make-fulldeps/tools.mk\n all:\n \t# Verbatim allows specify precise name.\n \t$(RUSTC) local_native_dep.rs --crate-type=staticlib -o $(TMPDIR)/local_some_strange_name.ext\n-\t$(RUSTC) main.rs -Zunstable-options -l static:+verbatim=local_some_strange_name.ext\n+\t$(RUSTC) main.rs -l static:+verbatim=local_some_strange_name.ext\n \n \t# With verbatim any other name cannot be used (local).\n \t$(RUSTC) local_native_dep.rs --crate-type=staticlib -o $(TMPDIR)/liblocal_native_dep.a\n \t$(RUSTC) local_native_dep.rs --crate-type=staticlib -o $(TMPDIR)/local_native_dep.a\n \t$(RUSTC) local_native_dep.rs --crate-type=staticlib -o $(TMPDIR)/local_native_dep.lib\n-\t$(RUSTC) main.rs -Zunstable-options -l static:+verbatim=local_native_dep 2>&1 | $(CGREP) \"local_native_dep\"\n+\t$(RUSTC) main.rs -l static:+verbatim=local_native_dep 2>&1 | $(CGREP) \"local_native_dep\""}, {"sha": "6f01f37804a2ac5e2dd0f738e95a5dc21bdd3cea", "filename": "src/test/run-make/native-link-modifier-verbatim-rustc/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Frun-make%2Fnative-link-modifier-verbatim-rustc%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Frun-make%2Fnative-link-modifier-verbatim-rustc%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fnative-link-modifier-verbatim-rustc%2FMakefile?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -3,10 +3,10 @@ include ../../run-make-fulldeps/tools.mk\n all:\n \t# Verbatim allows specify precise name.\n \t$(RUSTC) upstream_native_dep.rs --crate-type=staticlib -o $(TMPDIR)/upstream_some_strange_name.ext\n-\t$(RUSTC) rust_dep.rs -Zunstable-options -l static:+verbatim=upstream_some_strange_name.ext --crate-type rlib\n+\t$(RUSTC) rust_dep.rs -l static:+verbatim=upstream_some_strange_name.ext --crate-type rlib\n \n \t# With verbatim any other name cannot be used (upstream).\n \t$(RUSTC) upstream_native_dep.rs --crate-type=staticlib -o $(TMPDIR)/libupstream_native_dep.a\n \t$(RUSTC) upstream_native_dep.rs --crate-type=staticlib -o $(TMPDIR)/upstream_native_dep.a\n \t$(RUSTC) upstream_native_dep.rs --crate-type=staticlib -o $(TMPDIR)/upstream_native_dep.lib\n-\t$(RUSTC) rust_dep.rs -Zunstable-options -l static:+verbatim=upstream_native_dep --crate-type rlib 2>&1 | $(CGREP) \"upstream_native_dep\"\n+\t$(RUSTC) rust_dep.rs -l static:+verbatim=upstream_native_dep --crate-type rlib 2>&1 | $(CGREP) \"upstream_native_dep\""}, {"sha": "5fb1204037c933e3168b844231cb006f971f658f", "filename": "src/test/run-make/raw-dylib-c/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Frun-make%2Fraw-dylib-c%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Frun-make%2Fraw-dylib-c%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fraw-dylib-c%2Flib.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -1,4 +1,4 @@\n-#![feature(raw_dylib, native_link_modifiers_verbatim)]\n+#![feature(raw_dylib)]\n \n #[link(name = \"extern_1.dll\", kind = \"raw-dylib\", modifiers = \"+verbatim\")]\n extern {"}, {"sha": "77e41e237d42a2f2cfaa0abc7e0b8af27df94eea", "filename": "src/test/run-make/rlib-format-packed-bundled-libs-2/rust_dep.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Frun-make%2Frlib-format-packed-bundled-libs-2%2Frust_dep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Frun-make%2Frlib-format-packed-bundled-libs-2%2Frust_dep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frlib-format-packed-bundled-libs-2%2Frust_dep.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -1,4 +1,3 @@\n-#![feature(native_link_modifiers_verbatim)]\n #[link(name = \"native_dep.ext\", kind = \"static\", modifiers = \"+verbatim\")]\n extern \"C\" {\n     fn native_f1() -> i32;"}, {"sha": "dd3665f22ac7880503376a2d726fbc8072c03aa7", "filename": "src/test/ui/alloc-error/alloc-error-handler-bad-signature-1.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-1.stderr?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -4,8 +4,8 @@ error[E0308]: mismatched types\n LL |    #[alloc_error_handler]\n    |    ---------------------- in this procedural macro expansion\n LL |    fn oom(\n-   |   _^\n-   |  |_|\n+   |  __^\n+   | | _|\n    | ||\n LL | ||     info: &Layout,\n LL | || ) -> ()\n@@ -30,8 +30,8 @@ error[E0308]: mismatched types\n LL |    #[alloc_error_handler]\n    |    ---------------------- in this procedural macro expansion\n LL |    fn oom(\n-   |   _^\n-   |  |_|\n+   |  __^\n+   | | _|\n    | ||\n LL | ||     info: &Layout,\n LL | || ) -> ()"}, {"sha": "adb652fe61659bcf94a699b7dc6b427980a81cd8", "filename": "src/test/ui/alloc-error/alloc-error-handler-bad-signature-2.stderr", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-2.stderr?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -4,14 +4,12 @@ error[E0308]: mismatched types\n LL |    #[alloc_error_handler]\n    |    ---------------------- in this procedural macro expansion\n LL |    fn oom(\n-   |   _^\n-   |  |_|\n+   |  __^\n+   | | _|\n    | ||\n LL | ||     info: Layout,\n LL | || ) {\n-   | || -\n-   | ||_|\n-   | |  arguments to this function are incorrect\n+   | ||_- arguments to this function are incorrect\n LL | |      loop {}\n LL | |  }\n    | |__^ expected struct `Layout`, found struct `core::alloc::Layout`\n@@ -42,14 +40,12 @@ error[E0308]: mismatched types\n LL |    #[alloc_error_handler]\n    |    ---------------------- in this procedural macro expansion\n LL |    fn oom(\n-   |   _^\n-   |  |_|\n+   |  __^\n+   | | _|\n    | ||\n LL | ||     info: Layout,\n LL | || ) {\n-   | || ^\n-   | ||_|\n-   | |  expected `!`, found `()`\n+   | ||_^ expected `!`, found `()`\n LL | |      loop {}\n LL | |  }\n    | |__- expected `!` because of return type"}, {"sha": "7b09195dc3fb0c4a4c56b21d67ece79bb8dd2c00", "filename": "src/test/ui/feature-gates/feature-gate-native_link_modifiers_verbatim.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-native_link_modifiers_verbatim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-native_link_modifiers_verbatim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-native_link_modifiers_verbatim.rs?ref=69df0f2c2f665d7f4e38a3579a81d4efc0d81034", "patch": "@@ -1,5 +0,0 @@\n-#[link(name = \"foo\", modifiers = \"+verbatim\")]\n-//~^ ERROR: linking modifier `verbatim` is unstable\n-extern \"C\" {}\n-\n-fn main() {}"}, {"sha": "3bfbeb8db35fe3d4ba6b51f9f52366fa079244a3", "filename": "src/test/ui/feature-gates/feature-gate-native_link_modifiers_verbatim.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-native_link_modifiers_verbatim.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-native_link_modifiers_verbatim.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-native_link_modifiers_verbatim.stderr?ref=69df0f2c2f665d7f4e38a3579a81d4efc0d81034", "patch": "@@ -1,12 +0,0 @@\n-error[E0658]: linking modifier `verbatim` is unstable\n-  --> $DIR/feature-gate-native_link_modifiers_verbatim.rs:1:34\n-   |\n-LL | #[link(name = \"foo\", modifiers = \"+verbatim\")]\n-   |                                  ^^^^^^^^^^^\n-   |\n-   = note: see issue #81490 <https://github.com/rust-lang/rust/issues/81490> for more information\n-   = help: add `#![feature(native_link_modifiers_verbatim)]` to the crate attributes to enable\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "034005697b4343b239e27871028732a1f068c5aa", "filename": "src/test/ui/inference/deref-suggestion.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Fui%2Finference%2Fderef-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Fui%2Finference%2Fderef-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fderef-suggestion.stderr?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -157,19 +157,19 @@ error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/deref-suggestion.rs:69:12\n    |\n LL |        let val = if true {\n-   |   _______________-\n-LL |  |         *a\n-   |  |         -- expected because of this\n-LL |  |     } else if true {\n-   |  |____________^\n+   |  ________________-\n+LL | |          *a\n+   | |          -- expected because of this\n+LL | |      } else if true {\n+   | | ____________^\n LL | ||\n LL | ||         b\n LL | ||     } else {\n LL | ||         &0\n LL | ||     };\n    | ||     ^\n    | ||_____|\n-   | |______`if` and `else` have incompatible types\n+   |  |_____`if` and `else` have incompatible types\n    |        expected `i32`, found `&{integer}`\n \n error: aborting due to 13 previous errors"}, {"sha": "3abeadf9e4bbeb12ebb3b27bbd94ecc749fe03eb", "filename": "src/test/ui/issues/issue-13497-2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Fui%2Fissues%2Fissue-13497-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Fui%2Fissues%2Fissue-13497-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13497-2.stderr?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -2,12 +2,12 @@ error[E0515]: cannot return value referencing local variable `rawLines`\n   --> $DIR/issue-13497-2.rs:3:5\n    |\n LL |        rawLines\n-   |   _____^\n-   |  |_____|\n+   |  ______^\n+   | | _____|\n    | ||\n LL | ||         .iter().map(|l| l.trim()).collect()\n    | ||_______________-___________________________^ returns a value referencing data owned by the current function\n-   | |________________|\n+   |  |_______________|\n    |                  `rawLines` is borrowed here\n \n error: aborting due to previous error"}, {"sha": "34f720dd2d3c588e1847c73ba6938417e71050f2", "filename": "src/test/ui/linkage-attr/link-attr-validation-late.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Fui%2Flinkage-attr%2Flink-attr-validation-late.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Fui%2Flinkage-attr%2Flink-attr-validation-late.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flinkage-attr%2Flink-attr-validation-late.rs?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -1,4 +1,3 @@\n-#![feature(native_link_modifiers_verbatim)]\n #![feature(link_cfg)]\n \n // Top-level ill-formed"}, {"sha": "1ad5fbaf7de8066f2f34d8a4828ada45e9b4b833", "filename": "src/test/ui/linkage-attr/link-attr-validation-late.stderr", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Fui%2Flinkage-attr%2Flink-attr-validation-late.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Fui%2Flinkage-attr%2Flink-attr-validation-late.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flinkage-attr%2Flink-attr-validation-late.stderr?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -1,143 +1,143 @@\n error: unexpected `#[link]` argument, expected one of: name, kind, modifiers, cfg, wasm_import_module, import_name_type\n-  --> $DIR/link-attr-validation-late.rs:5:22\n+  --> $DIR/link-attr-validation-late.rs:4:22\n    |\n LL | #[link(name = \"...\", \"literal\")]\n    |                      ^^^^^^^^^\n \n error: unexpected `#[link]` argument, expected one of: name, kind, modifiers, cfg, wasm_import_module, import_name_type\n-  --> $DIR/link-attr-validation-late.rs:6:22\n+  --> $DIR/link-attr-validation-late.rs:5:22\n    |\n LL | #[link(name = \"...\", unknown)]\n    |                      ^^^^^^^\n \n error: multiple `name` arguments in a single `#[link]` attribute\n-  --> $DIR/link-attr-validation-late.rs:10:22\n+  --> $DIR/link-attr-validation-late.rs:9:22\n    |\n LL | #[link(name = \"foo\", name = \"bar\")]\n    |                      ^^^^^^^^^^^^\n \n error: multiple `kind` arguments in a single `#[link]` attribute\n-  --> $DIR/link-attr-validation-late.rs:11:38\n+  --> $DIR/link-attr-validation-late.rs:10:38\n    |\n LL | #[link(name = \"...\", kind = \"dylib\", kind = \"bar\")]\n    |                                      ^^^^^^^^^^^^\n \n error: multiple `modifiers` arguments in a single `#[link]` attribute\n-  --> $DIR/link-attr-validation-late.rs:12:47\n+  --> $DIR/link-attr-validation-late.rs:11:47\n    |\n LL | #[link(name = \"...\", modifiers = \"+verbatim\", modifiers = \"bar\")]\n    |                                               ^^^^^^^^^^^^^^^^^\n \n error: multiple `cfg` arguments in a single `#[link]` attribute\n-  --> $DIR/link-attr-validation-late.rs:13:34\n+  --> $DIR/link-attr-validation-late.rs:12:34\n    |\n LL | #[link(name = \"...\", cfg(FALSE), cfg(FALSE))]\n    |                                  ^^^^^^^^^^\n \n error: multiple `wasm_import_module` arguments in a single `#[link]` attribute\n-  --> $DIR/link-attr-validation-late.rs:14:36\n+  --> $DIR/link-attr-validation-late.rs:13:36\n    |\n LL | #[link(wasm_import_module = \"foo\", wasm_import_module = \"bar\")]\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: link name must be of the form `name = \"string\"`\n-  --> $DIR/link-attr-validation-late.rs:18:8\n+  --> $DIR/link-attr-validation-late.rs:17:8\n    |\n LL | #[link(name)]\n    |        ^^^^\n \n error[E0459]: `#[link]` attribute requires a `name = \"string\"` argument\n-  --> $DIR/link-attr-validation-late.rs:18:1\n+  --> $DIR/link-attr-validation-late.rs:17:1\n    |\n LL | #[link(name)]\n    | ^^^^^^^^^^^^^ missing `name` argument\n \n error: link name must be of the form `name = \"string\"`\n-  --> $DIR/link-attr-validation-late.rs:20:8\n+  --> $DIR/link-attr-validation-late.rs:19:8\n    |\n LL | #[link(name())]\n    |        ^^^^^^\n \n error[E0459]: `#[link]` attribute requires a `name = \"string\"` argument\n-  --> $DIR/link-attr-validation-late.rs:20:1\n+  --> $DIR/link-attr-validation-late.rs:19:1\n    |\n LL | #[link(name())]\n    | ^^^^^^^^^^^^^^^ missing `name` argument\n \n error: link kind must be of the form `kind = \"string\"`\n-  --> $DIR/link-attr-validation-late.rs:22:22\n+  --> $DIR/link-attr-validation-late.rs:21:22\n    |\n LL | #[link(name = \"...\", kind)]\n    |                      ^^^^\n \n error: link kind must be of the form `kind = \"string\"`\n-  --> $DIR/link-attr-validation-late.rs:23:22\n+  --> $DIR/link-attr-validation-late.rs:22:22\n    |\n LL | #[link(name = \"...\", kind())]\n    |                      ^^^^^^\n \n error: link modifiers must be of the form `modifiers = \"string\"`\n-  --> $DIR/link-attr-validation-late.rs:24:22\n+  --> $DIR/link-attr-validation-late.rs:23:22\n    |\n LL | #[link(name = \"...\", modifiers)]\n    |                      ^^^^^^^^^\n \n error: link modifiers must be of the form `modifiers = \"string\"`\n-  --> $DIR/link-attr-validation-late.rs:25:22\n+  --> $DIR/link-attr-validation-late.rs:24:22\n    |\n LL | #[link(name = \"...\", modifiers())]\n    |                      ^^^^^^^^^^^\n \n error: link cfg must be of the form `cfg(/* predicate */)`\n-  --> $DIR/link-attr-validation-late.rs:26:22\n+  --> $DIR/link-attr-validation-late.rs:25:22\n    |\n LL | #[link(name = \"...\", cfg)]\n    |                      ^^^\n \n error: link cfg must be of the form `cfg(/* predicate */)`\n-  --> $DIR/link-attr-validation-late.rs:27:22\n+  --> $DIR/link-attr-validation-late.rs:26:22\n    |\n LL | #[link(name = \"...\", cfg = \"literal\")]\n    |                      ^^^^^^^^^^^^^^^\n \n error: link cfg must have a single predicate argument\n-  --> $DIR/link-attr-validation-late.rs:28:22\n+  --> $DIR/link-attr-validation-late.rs:27:22\n    |\n LL | #[link(name = \"...\", cfg(\"literal\"))]\n    |                      ^^^^^^^^^^^^^^\n \n error: wasm import module must be of the form `wasm_import_module = \"string\"`\n-  --> $DIR/link-attr-validation-late.rs:29:22\n+  --> $DIR/link-attr-validation-late.rs:28:22\n    |\n LL | #[link(name = \"...\", wasm_import_module)]\n    |                      ^^^^^^^^^^^^^^^^^^\n \n error: wasm import module must be of the form `wasm_import_module = \"string\"`\n-  --> $DIR/link-attr-validation-late.rs:30:22\n+  --> $DIR/link-attr-validation-late.rs:29:22\n    |\n LL | #[link(name = \"...\", wasm_import_module())]\n    |                      ^^^^^^^^^^^^^^^^^^^^\n \n error: invalid linking modifier syntax, expected '+' or '-' prefix before one of: bundle, verbatim, whole-archive, as-needed\n-  --> $DIR/link-attr-validation-late.rs:34:34\n+  --> $DIR/link-attr-validation-late.rs:33:34\n    |\n LL | #[link(name = \"...\", modifiers = \"\")]\n    |                                  ^^\n \n error: invalid linking modifier syntax, expected '+' or '-' prefix before one of: bundle, verbatim, whole-archive, as-needed\n-  --> $DIR/link-attr-validation-late.rs:35:34\n+  --> $DIR/link-attr-validation-late.rs:34:34\n    |\n LL | #[link(name = \"...\", modifiers = \"no-plus-minus\")]\n    |                                  ^^^^^^^^^^^^^^^\n \n error: unknown linking modifier `unknown`, expected one of: bundle, verbatim, whole-archive, as-needed\n-  --> $DIR/link-attr-validation-late.rs:36:34\n+  --> $DIR/link-attr-validation-late.rs:35:34\n    |\n LL | #[link(name = \"...\", modifiers = \"+unknown\")]\n    |                                  ^^^^^^^^^^\n \n error: multiple `verbatim` modifiers in a single `modifiers` argument\n-  --> $DIR/link-attr-validation-late.rs:37:34\n+  --> $DIR/link-attr-validation-late.rs:36:34\n    |\n LL | #[link(name = \"...\", modifiers = \"+verbatim,+verbatim\")]\n    |                                  ^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "4caee777a131bb830da6ba797b298b03da760e3f", "filename": "src/test/ui/lint/suggestions.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Fui%2Flint%2Fsuggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Fui%2Flint%2Fsuggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fsuggestions.stderr?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -41,12 +41,12 @@ warning: variable does not need to be mutable\n   --> $DIR/suggestions.rs:54:13\n    |\n LL |            let mut\n-   |   _____________^\n-   |  |_____________|\n+   |  ______________^\n+   | | _____________|\n    | ||\n LL | ||             b = 1;\n    | ||____________-^\n-   |  |____________|\n+   | |_____________|\n    |               help: remove this `mut`\n \n error: const items should never be `#[no_mangle]`"}, {"sha": "4f938670e5e2c88ab76a8ad53c3e3d59f4327a17", "filename": "src/test/ui/return/issue-86188-return-not-in-fn-body.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Fui%2Freturn%2Fissue-86188-return-not-in-fn-body.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Fui%2Freturn%2Fissue-86188-return-not-in-fn-body.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freturn%2Fissue-86188-return-not-in-fn-body.stderr?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -35,17 +35,17 @@ LL | |     }\n error[E0572]: return statement outside of function body\n   --> $DIR/issue-86188-return-not-in-fn-body.rs:36:10\n    |\n-LL |  / fn main() {\n-LL |  |\n-LL |  |     [(); return || {\n-   |  |__________^\n+LL | /  fn main() {\n+LL | |\n+LL | |      [(); return || {\n+   | | __________^\n LL | ||\n LL | ||\n LL | ||         let tx;\n LL | ||     }];\n    | ||_____^ the return is part of this body...\n-LL |  | }\n-   |  |_- ...not the enclosing function body\n+LL | |  }\n+   | |__- ...not the enclosing function body\n \n error: aborting due to 4 previous errors\n "}, {"sha": "260df85653b156890153e712d62d14032886c4be", "filename": "src/test/ui/suggestions/issue-99240-2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Fui%2Fsuggestions%2Fissue-99240-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Fui%2Fsuggestions%2Fissue-99240-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-99240-2.stderr?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -5,12 +5,12 @@ LL |        Unit,\n    |        ---- enum variant `Alias::Unit` defined here\n ...\n LL |        Alias::\n-   |   _____^\n-   |  |_____|\n+   |  ______^\n+   | | _____|\n    | ||\n LL | ||     Unit();\n    | ||________^_- call expression requires function\n-   | |_________|\n+   |  |________|\n    | \n    |\n help: `Alias::Unit` is a unit enum variant, and does not take parentheses to be constructed"}, {"sha": "31cca323d0e4226e578b79216ce8637a7bc36fa1", "filename": "src/test/ui/suggestions/suggest-remove-refs-3.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-remove-refs-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-remove-refs-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-remove-refs-3.stderr?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -2,8 +2,8 @@ error[E0277]: `&&&&&Enumerate<std::slice::Iter<'_, {integer}>>` is not an iterat\n   --> $DIR/suggest-remove-refs-3.rs:6:19\n    |\n LL |        for (i, _) in & & &\n-   |   ___________________^\n-   |  |___________________|\n+   |  ____________________^\n+   | | ___________________|\n    | ||\n LL | ||         & &v\n    | ||___________- help: consider removing 5 leading `&`-references"}, {"sha": "92ba3592967803c41235fd84b4a418528a3bf376", "filename": "src/tools/clippy/tests/ui/async_yields_async.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fasync_yields_async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fasync_yields_async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fasync_yields_async.stderr?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -2,14 +2,14 @@ error: an async construct yields a type which is itself awaitable\n   --> $DIR/async_yields_async.rs:39:9\n    |\n LL |        let _h = async {\n-   |   ____________________-\n-LL |  |         async {\n-   |  |_________^\n+   |  _____________________-\n+LL | |          async {\n+   | | _________^\n LL | ||             3\n LL | ||         }\n    | ||_________^ awaitable value not awaited\n-LL |  |     };\n-   |  |_____- outer async construct\n+LL | |      };\n+   | |______- outer async construct\n    |\n    = note: `-D clippy::async-yields-async` implied by `-D warnings`\n help: consider awaiting this value\n@@ -36,14 +36,14 @@ error: an async construct yields a type which is itself awaitable\n   --> $DIR/async_yields_async.rs:50:9\n    |\n LL |        let _j = async || {\n-   |   _______________________-\n-LL |  |         async {\n-   |  |_________^\n+   |  ________________________-\n+LL | |          async {\n+   | | _________^\n LL | ||             3\n LL | ||         }\n    | ||_________^ awaitable value not awaited\n-LL |  |     };\n-   |  |_____- outer async construct\n+LL | |      };\n+   | |______- outer async construct\n    |\n help: consider awaiting this value\n    |"}, {"sha": "2e1eb8eb18066796e2eb95c7aa1671ddda5a0e89", "filename": "src/tools/clippy/tests/ui/result_map_unit_fn_unfixable.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fresult_map_unit_fn_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a09420ac48658cad726e0a6997687ceac4151e3/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fresult_map_unit_fn_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fresult_map_unit_fn_unfixable.stderr?ref=8a09420ac48658cad726e0a6997687ceac4151e3", "patch": "@@ -20,14 +20,14 @@ error: called `map(f)` on an `Result` value where `f` is a closure that returns\n   --> $DIR/result_map_unit_fn_unfixable.rs:29:5\n    |\n LL |        x.field.map(|value| {\n-   |   _____^\n-   |  |_____|\n+   |  ______^\n+   | | _____|\n    | ||\n LL | ||         do_nothing(value);\n LL | ||         do_nothing(value)\n LL | ||     });\n    | ||______^- help: try this: `if let Ok(value) = x.field { ... }`\n-   | |_______|\n+   |  |______|\n    | \n \n error: called `map(f)` on an `Result` value where `f` is a closure that returns the unit type `()`"}]}