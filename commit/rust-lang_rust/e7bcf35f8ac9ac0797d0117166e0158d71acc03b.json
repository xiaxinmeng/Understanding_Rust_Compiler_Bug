{"sha": "e7bcf35f8ac9ac0797d0117166e0158d71acc03b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3YmNmMzVmOGFjOWFjMDc5N2QwMTE3MTY2ZTAxNThkNzFhY2MwM2I=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-10-21T09:17:53Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-10-21T09:17:53Z"}, "message": "Simplify PrimValKind and remove a horrible hack.\n\nThis takes the `AllocId` out of PrimValKind, replacing it with a\n`relocation` field on `PrimVal`, which is closer to an earlier design\nfor `PrimVal` I discussed with @eddyb.\n\nThis commit prepares the code for removing the `PrimValKind` from\n`PrimVal` and making them more pure bitbags. The only code dealing with\n`PrimValKind` will be code making decisions like \"what kind of operation\ndo I need to do on these bits\", like operators and casting. Transmutes\nof `PrimVal`s will become true no-ops, not even adjusting a `kind`\nfield.\n\nThis commit also removes my horrible `value_to_primval` hack that made\nan allocation for every `ByVal` passed in, so it could use `read_value`\nto get a `PrimVal` with the right kind. Now I just compute the\n`PrimValKind` from the `Ty` and re-tag the `PrimVal`.\n\nThe code got slightly messier in some areas here, but I think a _lot_ of\ncode will simplify in obvious ways once I remove the `kind` field from\n`PrimVal`.\n\nGosh, if my commit messages aren't turning into essays these days.", "tree": {"sha": "04938849be0895443e384538f9986f52896b6880", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04938849be0895443e384538f9986f52896b6880"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7bcf35f8ac9ac0797d0117166e0158d71acc03b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7bcf35f8ac9ac0797d0117166e0158d71acc03b", "html_url": "https://github.com/rust-lang/rust/commit/e7bcf35f8ac9ac0797d0117166e0158d71acc03b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7bcf35f8ac9ac0797d0117166e0158d71acc03b/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "330be7766f6d89e127a63ae81ee1a2f032c53910", "url": "https://api.github.com/repos/rust-lang/rust/commits/330be7766f6d89e127a63ae81ee1a2f032c53910", "html_url": "https://github.com/rust-lang/rust/commit/330be7766f6d89e127a63ae81ee1a2f032c53910"}], "stats": {"total": 364, "additions": 214, "deletions": 150}, "files": [{"sha": "70b39fc882ec5bfc25927f3e1872f9a124fe5b4c", "filename": "src/interpreter/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7bcf35f8ac9ac0797d0117166e0158d71acc03b/src%2Finterpreter%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bcf35f8ac9ac0797d0117166e0158d71acc03b/src%2Finterpreter%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fcast.rs?ref=e7bcf35f8ac9ac0797d0117166e0158d71acc03b", "patch": "@@ -21,8 +21,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Bool | Char | U8 | U16 | U32 | U64 => self.cast_int(val.bits, ty, false),\n \n-            FnPtr(alloc) | Ptr(alloc) => {\n-                let ptr = Pointer::new(alloc, val.bits as usize);\n+            FnPtr | Ptr => {\n+                let ptr = val.expect_ptr(\"FnPtr- or Ptr-tagged PrimVal had no relocation\");\n                 self.cast_ptr(ptr, ty)\n             }\n         }"}, {"sha": "1e37d3ec75376899a6807e3d2498a1ca445a526a", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 87, "deletions": 37, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/e7bcf35f8ac9ac0797d0117166e0158d71acc03b/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bcf35f8ac9ac0797d0117166e0158d71acc03b/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=e7bcf35f8ac9ac0797d0117166e0158d71acc03b", "patch": "@@ -972,7 +972,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Deref => {\n-                use primval::PrimValKind::*;\n                 use interpreter::value::Value::*;\n \n                 let val = match self.eval_and_read_lvalue(&proj.base)? {\n@@ -981,22 +980,21 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n \n                 match val {\n-                    ByValPair(\n-                        PrimVal { kind: Ptr(ptr_alloc), bits: ptr_offset },\n-                        PrimVal { kind: Ptr(vtable_alloc), bits: vtable_offset },\n-                    ) => {\n-                        let ptr = Pointer::new(ptr_alloc, ptr_offset as usize);\n-                        let vtable = Pointer::new(vtable_alloc, vtable_offset as usize);\n+                    ByValPair(ptr, vtable)\n+                        if ptr.try_as_ptr().is_some() && vtable.try_as_ptr().is_some()\n+                    => {\n+                        let ptr = ptr.try_as_ptr().unwrap();\n+                        let vtable = vtable.try_as_ptr().unwrap();\n                         (ptr, LvalueExtra::Vtable(vtable))\n                     }\n \n-                    ByValPair(PrimVal { kind: Ptr(alloc), bits: offset }, n) => {\n-                        let ptr = Pointer::new(alloc, offset as usize);\n+                    ByValPair(ptr, n) if ptr.try_as_ptr().is_some() => {\n+                        let ptr = ptr.try_as_ptr().unwrap();\n                         (ptr, LvalueExtra::Length(n.expect_uint(\"slice length\")))\n                     }\n \n-                    ByVal(PrimVal { kind: Ptr(alloc), bits: offset }) => {\n-                        let ptr = Pointer::new(alloc, offset as usize);\n+                    ByVal(ptr) if ptr.try_as_ptr().is_some() => {\n+                        let ptr = ptr.try_as_ptr().unwrap();\n                         (ptr, LvalueExtra::None)\n                     }\n \n@@ -1122,39 +1120,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 Value::ByValPair(..) => bug!(\"value_to_primval can't work with fat pointers\"),\n             },\n \n-            // FIXME(solson): This unnecessarily allocates to work around a new issue my `Value`\n-            // locals refactoring introduced. There is code that calls this function and expects to\n-            // get a PrimVal reflecting the specific type that it asked for, e.g. `PrimVal::Bool`\n-            // when it was asking for `TyBool`. This used to always work because it would go\n-            // through `read_value` which does the right thing.\n-            //\n-            // This is the comment and implementation from before my refactor:\n-            //\n-            //     TODO(solson): Sanity-check the primval type against the input type.\n-            //     Value::ByVal(primval) => Ok(primval),\n-            //\n-            // Turns out sanity-checking isn't enough now, and we need conversion.\n-            //\n-            // Now that we can possibly be reading a `ByVal` straight out of the locals vec, if the\n-            // user did something tricky like transmuting a `u8` to a `bool`, then we'll have a\n-            // `PrimVal::U8` and need to convert to `PrimVal::Bool`.\n-            //\n-            // I want to avoid handling the full set of conversions between `PrimVal`s, so for now\n-            // I will use this hack. I have a plan to change the representation of `PrimVal` to be\n-            // more like a small piece of memory tagged with a `PrimValKind`, which should make the\n-            // conversion easy and make the problem solveable using code already in `Memory`.\n             Value::ByVal(primval) => {\n-                let ptr = self.alloc_ptr(ty)?;\n-                self.memory.write_primval(ptr, primval)?;\n-                let primval = self.value_to_primval(Value::ByRef(ptr), ty)?;\n-                self.memory.deallocate(ptr)?;\n-                Ok(primval)\n+                let new_primval = self.transmute_primval(primval, ty)?;\n+                self.ensure_valid_value(new_primval, ty)?;\n+                Ok(new_primval)\n             }\n \n             Value::ByValPair(..) => bug!(\"value_to_primval can't work with fat pointers\"),\n         }\n     }\n \n+    fn transmute_primval(&self, val: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+        Ok(PrimVal { kind: self.ty_to_primval_kind(ty)?, ..val })\n+    }\n+\n     fn write_primval(\n         &mut self,\n         dest: Lvalue,\n@@ -1252,6 +1231,77 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n+    fn ty_to_primval_kind(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimValKind> {\n+        use syntax::ast::FloatTy;\n+\n+        let kind = match ty.sty {\n+            ty::TyBool => PrimValKind::Bool,\n+            ty::TyChar => PrimValKind::Char,\n+\n+            ty::TyInt(int_ty) => {\n+                use syntax::ast::IntTy::*;\n+                let size = match int_ty {\n+                    I8 => 1,\n+                    I16 => 2,\n+                    I32 => 4,\n+                    I64 => 8,\n+                    Is => self.memory.pointer_size(),\n+                };\n+                PrimValKind::from_int_size(size)\n+            }\n+\n+            ty::TyUint(uint_ty) => {\n+                use syntax::ast::UintTy::*;\n+                let size = match uint_ty {\n+                    U8 => 1,\n+                    U16 => 2,\n+                    U32 => 4,\n+                    U64 => 8,\n+                    Us => self.memory.pointer_size(),\n+                };\n+                PrimValKind::from_uint_size(size)\n+            }\n+\n+            ty::TyFloat(FloatTy::F32) => PrimValKind::F32,\n+            ty::TyFloat(FloatTy::F64) => PrimValKind::F64,\n+\n+            ty::TyFnPtr(_) => PrimValKind::FnPtr,\n+\n+            ty::TyBox(ty) |\n+            ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n+            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) if self.type_is_sized(ty) => PrimValKind::Ptr,\n+\n+            ty::TyAdt(..) => {\n+                use rustc::ty::layout::Layout::*;\n+                if let CEnum { discr, signed, .. } = *self.type_layout(ty) {\n+                    let size = discr.size().bytes() as usize;\n+                    if signed {\n+                        PrimValKind::from_int_size(size)\n+                    } else {\n+                        PrimValKind::from_uint_size(size)\n+                    }\n+                } else {\n+                    bug!(\"primitive read of non-clike enum: {:?}\", ty);\n+                }\n+            },\n+\n+            _ => bug!(\"primitive read of non-primitive type: {:?}\", ty),\n+        };\n+\n+        Ok(kind)\n+    }\n+\n+    fn ensure_valid_value(&self, val: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n+        match ty.sty {\n+            ty::TyBool if val.bits > 1 => Err(EvalError::InvalidBool),\n+\n+            ty::TyChar if ::std::char::from_u32(val.bits as u32).is_none()\n+                => Err(EvalError::InvalidChar(val.bits as u32 as u64)),\n+\n+            _ => Ok(()),\n+        }\n+    }\n+\n     fn read_value(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         use syntax::ast::FloatTy;\n "}, {"sha": "bb88e3864ee6fcb2defab45a6c88403510753599", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "modified", "additions": 35, "deletions": 31, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e7bcf35f8ac9ac0797d0117166e0158d71acc03b/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bcf35f8ac9ac0797d0117166e0158d71acc03b/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=e7bcf35f8ac9ac0797d0117166e0158d71acc03b", "patch": "@@ -19,10 +19,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         dest_ty: Ty<'tcx>,\n         dest_layout: &'tcx Layout,\n     ) -> EvalResult<'tcx, ()> {\n-        let args_ptrs: EvalResult<Vec<Value>> = args.iter()\n+        let arg_vals: EvalResult<Vec<Value>> = args.iter()\n             .map(|arg| self.eval_operand(arg))\n             .collect();\n-        let args_ptrs = args_ptrs?;\n+        let arg_vals = arg_vals?;\n         let i32 = self.tcx.types.i32;\n         let isize = self.tcx.types.isize;\n         let usize = self.tcx.types.usize;\n@@ -42,32 +42,31 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n \n             \"arith_offset\" => {\n-                let ptr = args_ptrs[0].read_ptr(&self.memory)?;\n-                let offset = self.value_to_primval(args_ptrs[1], isize)?\n+                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n+                let offset = self.value_to_primval(arg_vals[1], isize)?\n                     .expect_int(\"arith_offset second arg not isize\");\n                 let new_ptr = ptr.offset(offset as isize);\n                 self.write_primval(dest, PrimVal::from_ptr(new_ptr))?;\n             }\n \n             \"assume\" => {\n                 let bool = self.tcx.types.bool;\n-                let cond = self.value_to_primval(args_ptrs[0], bool)?\n-                    .expect_bool(\"assume arg not bool\");\n+                let cond = self.value_to_primval(arg_vals[0], bool)?.try_as_bool()?;\n                 if !cond { return Err(EvalError::AssumptionNotHeld); }\n             }\n \n             \"atomic_load\" |\n             \"volatile_load\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = args_ptrs[0].read_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 self.write_value(Value::ByRef(ptr), dest, ty)?;\n             }\n \n             \"atomic_store\" |\n             \"volatile_store\" => {\n                 let ty = substs.type_at(0);\n-                let dest = args_ptrs[0].read_ptr(&self.memory)?;\n-                self.write_value_to_ptr(args_ptrs[1], dest, ty)?;\n+                let dest = arg_vals[0].read_ptr(&self.memory)?;\n+                self.write_value_to_ptr(arg_vals[1], dest, ty)?;\n             }\n \n             \"breakpoint\" => unimplemented!(), // halt miri\n@@ -78,9 +77,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let elem_ty = substs.type_at(0);\n                 let elem_size = self.type_size(elem_ty);\n                 let elem_align = self.type_align(elem_ty);\n-                let src = args_ptrs[0].read_ptr(&self.memory)?;\n-                let dest = args_ptrs[1].read_ptr(&self.memory)?;\n-                let count = self.value_to_primval(args_ptrs[2], usize)?\n+                let src = arg_vals[0].read_ptr(&self.memory)?;\n+                let dest = arg_vals[1].read_ptr(&self.memory)?;\n+                let count = self.value_to_primval(arg_vals[2], usize)?\n                     .expect_uint(\"arith_offset second arg not isize\");\n                 self.memory.copy(src, dest, count as usize * elem_size, elem_align)?;\n             }\n@@ -90,34 +89,34 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"ctlz\" |\n             \"bswap\" => {\n                 let elem_ty = substs.type_at(0);\n-                let num = self.value_to_primval(args_ptrs[0], elem_ty)?;\n+                let num = self.value_to_primval(arg_vals[0], elem_ty)?;\n                 let num = numeric_intrinsic(intrinsic_name, num);\n                 self.write_primval(dest, num)?;\n             }\n \n             \"discriminant_value\" => {\n                 let ty = substs.type_at(0);\n-                let adt_ptr = args_ptrs[0].read_ptr(&self.memory)?;\n+                let adt_ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n                 self.write_primval(dest, PrimVal::new(discr_val, PrimValKind::U64))?;\n             }\n \n             \"fabsf32\" => {\n-                let f = self.value_to_primval(args_ptrs[2], f32)?\n+                let f = self.value_to_primval(arg_vals[2], f32)?\n                     .expect_f32(\"fabsf32 read non f32\");\n                 self.write_primval(dest, PrimVal::from_f32(f.abs()))?;\n             }\n \n             \"fabsf64\" => {\n-                let f = self.value_to_primval(args_ptrs[2], f64)?\n+                let f = self.value_to_primval(arg_vals[2], f64)?\n                     .expect_f64(\"fabsf64 read non f64\");\n                 self.write_primval(dest, PrimVal::from_f64(f.abs()))?;\n             }\n \n             \"fadd_fast\" => {\n                 let ty = substs.type_at(0);\n-                let a = self.value_to_primval(args_ptrs[0], ty)?;\n-                let b = self.value_to_primval(args_ptrs[0], ty)?;\n+                let a = self.value_to_primval(arg_vals[0], ty)?;\n+                let b = self.value_to_primval(arg_vals[0], ty)?;\n                 let result = primval::binary_op(mir::BinOp::Add, a, b)?;\n                 self.write_primval(dest, result.0)?;\n             }\n@@ -151,8 +150,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"move_val_init\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = args_ptrs[0].read_ptr(&self.memory)?;\n-                self.write_value_to_ptr(args_ptrs[1], ptr, ty)?;\n+                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n+                self.write_value_to_ptr(arg_vals[1], ptr, ty)?;\n             }\n \n             \"needs_drop\" => {\n@@ -165,10 +164,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"offset\" => {\n                 let pointee_ty = substs.type_at(0);\n                 let pointee_size = self.type_size(pointee_ty) as isize;\n-                let offset = self.value_to_primval(args_ptrs[1], isize)?\n+                let offset = self.value_to_primval(arg_vals[1], isize)?\n                     .expect_int(\"offset second arg not isize\");\n \n-                let ptr = args_ptrs[0].read_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let result_ptr = ptr.offset(offset as isize * pointee_size);\n                 self.write_primval(dest, PrimVal::from_ptr(result_ptr))?;\n             }\n@@ -186,29 +185,29 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"powif32\" => {\n-                let f = self.value_to_primval(args_ptrs[0], f32)?\n+                let f = self.value_to_primval(arg_vals[0], f32)?\n                     .expect_f32(\"powif32 first arg not f32\");\n-                let i = self.value_to_primval(args_ptrs[1], i32)?\n+                let i = self.value_to_primval(arg_vals[1], i32)?\n                     .expect_int(\"powif32 second arg not i32\");\n                 self.write_primval(dest, PrimVal::from_f32(f.powi(i as i32)))?;\n             }\n \n             \"powif64\" => {\n-                let f = self.value_to_primval(args_ptrs[0], f64)?\n+                let f = self.value_to_primval(arg_vals[0], f64)?\n                     .expect_f64(\"powif64 first arg not f64\");\n-                let i = self.value_to_primval(args_ptrs[1], i32)?\n+                let i = self.value_to_primval(arg_vals[1], i32)?\n                     .expect_int(\"powif64 second arg not i32\");\n                 self.write_primval(dest, PrimVal::from_f64(f.powi(i as i32)))?;\n             }\n \n             \"sqrtf32\" => {\n-                let f = self.value_to_primval(args_ptrs[0], f32)?\n+                let f = self.value_to_primval(arg_vals[0], f32)?\n                     .expect_f32(\"sqrtf32 first arg not f32\");\n                 self.write_primval(dest, PrimVal::from_f32(f.sqrt()))?;\n             }\n \n             \"sqrtf64\" => {\n-                let f = self.value_to_primval(args_ptrs[0], f64)?\n+                let f = self.value_to_primval(arg_vals[0], f64)?\n                     .expect_f64(\"sqrtf64 first arg not f64\");\n                 self.write_primval(dest, PrimVal::from_f64(f.sqrt()))?;\n             }\n@@ -222,7 +221,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"size_of_val\" => {\n                 let ty = substs.type_at(0);\n-                let (size, _) = self.size_and_align_of_dst(ty, args_ptrs[0])?;\n+                let (size, _) = self.size_and_align_of_dst(ty, arg_vals[0])?;\n                 let size_val = self.usize_primval(size);\n                 self.write_primval(dest, size_val)?;\n             }\n@@ -239,8 +238,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"transmute\" => {\n-                let ty = substs.type_at(0);\n-                self.write_value(args_ptrs[0], dest, ty)?;\n+                let dest_ty = substs.type_at(1);\n+                let val = match arg_vals[0] {\n+                    Value::ByVal(primval) =>\n+                        Value::ByVal(self.transmute_primval(primval, dest_ty)?),\n+                    v => v,\n+                };\n+                self.write_value(val, dest, dest_ty)?;\n             }\n \n             \"uninit\" => {"}, {"sha": "1a7f985d20a787deff343a21c2d5d3268fc37168", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7bcf35f8ac9ac0797d0117166e0158d71acc03b/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bcf35f8ac9ac0797d0117166e0158d71acc03b/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=e7bcf35f8ac9ac0797d0117166e0158d71acc03b", "patch": "@@ -35,8 +35,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Goto { target } => self.goto_block(target),\n \n             If { ref cond, targets: (then_target, else_target) } => {\n-                let cond_val = self.eval_operand_to_primval(cond)?\n-                    .expect_bool(\"TerminatorKind::If condition constant was not a bool\");\n+                let cond_val = self.eval_operand_to_primval(cond)?.try_as_bool()?;\n                 self.goto_block(if cond_val { then_target } else { else_target });\n             }\n \n@@ -116,8 +115,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Assert { ref cond, expected, ref msg, target, .. } => {\n-                let cond_val = self.eval_operand_to_primval(cond)?\n-                    .expect_bool(\"TerminatorKind::Assert condition constant was not a bool\");\n+                let cond_val = self.eval_operand_to_primval(cond)?.try_as_bool()?;\n                 if expected == cond_val {\n                     self.goto_block(target);\n                 } else {"}, {"sha": "22698f978184b467422077718c4e9970ec37e595", "filename": "src/interpreter/value.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e7bcf35f8ac9ac0797d0117166e0158d71acc03b/src%2Finterpreter%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bcf35f8ac9ac0797d0117166e0158d71acc03b/src%2Finterpreter%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fvalue.rs?ref=e7bcf35f8ac9ac0797d0117166e0158d71acc03b", "patch": "@@ -1,6 +1,6 @@\n use error::EvalResult;\n use memory::{Memory, Pointer};\n-use primval::{PrimVal, PrimValKind};\n+use primval::PrimVal;\n \n /// A `Value` represents a single self-contained Rust value.\n ///\n@@ -23,10 +23,8 @@ impl<'a, 'tcx: 'a> Value {\n         match *self {\n             ByRef(ptr) => mem.read_ptr(ptr),\n \n-            ByVal(PrimVal { kind: PrimValKind::Ptr(alloc), bits: offset }) |\n-            ByVal(PrimVal { kind: PrimValKind::FnPtr(alloc), bits: offset }) => {\n-                let ptr = Pointer::new(alloc, offset as usize);\n-                Ok(ptr)\n+            ByVal(ptr) if ptr.try_as_ptr().is_some() => {\n+                Ok(ptr.try_as_ptr().unwrap())\n             }\n \n             ByValPair(..) => unimplemented!(),\n@@ -46,12 +44,11 @@ impl<'a, 'tcx: 'a> Value {\n                 Ok((ptr, vtable))\n             }\n \n-            ByValPair(\n-                PrimVal { kind: PrimValKind::Ptr(ptr_alloc), bits: ptr_offset },\n-                PrimVal { kind: PrimValKind::Ptr(vtable_alloc), bits: vtable_offset },\n-            ) => {\n-                let ptr = Pointer::new(ptr_alloc, ptr_offset as usize);\n-                let vtable = Pointer::new(vtable_alloc, vtable_offset as usize);\n+            ByValPair(ptr, vtable)\n+                if ptr.try_as_ptr().is_some() && vtable.try_as_ptr().is_some()\n+            => {\n+                let ptr = ptr.try_as_ptr().unwrap();\n+                let vtable = vtable.try_as_ptr().unwrap();\n                 Ok((ptr, vtable))\n             }\n "}, {"sha": "73770ee403f444236e75f5326b111dca7d88159c", "filename": "src/memory.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e7bcf35f8ac9ac0797d0117166e0158d71acc03b/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bcf35f8ac9ac0797d0117166e0158d71acc03b/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=e7bcf35f8ac9ac0797d0117166e0158d71acc03b", "patch": "@@ -532,25 +532,21 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn write_primval(&mut self, ptr: Pointer, val: PrimVal) -> EvalResult<'tcx, ()> {\n-        use primval::PrimValKind::*;\n-        match val.kind {\n-            FnPtr(alloc_id) | Ptr(alloc_id) => {\n-                let p = Pointer::new(alloc_id, val.bits as usize);\n-                return self.write_ptr(ptr, p);\n-            }\n-            _ => {}\n+    pub fn write_primval(&mut self, dest: Pointer, val: PrimVal) -> EvalResult<'tcx, ()> {\n+        if let Some(ptr) = val.try_as_ptr() {\n+            return self.write_ptr(dest, ptr);\n         }\n \n+        use primval::PrimValKind::*;\n         let (size, bits) = match val.kind {\n             I8 | U8 | Bool         => (1, val.bits as u8  as u64),\n             I16 | U16              => (2, val.bits as u16 as u64),\n             I32 | U32 | F32 | Char => (4, val.bits as u32 as u64),\n             I64 | U64 | F64        => (8, val.bits),\n-            FnPtr(_) | Ptr(_)      => bug!(\"handled above\"),\n+            FnPtr | Ptr            => bug!(\"handled above\"),\n         };\n \n-        self.write_uint(ptr, bits, size)\n+        self.write_uint(dest, bits, size)\n     }\n \n     pub fn read_bool(&self, ptr: Pointer) -> EvalResult<'tcx, bool> {"}, {"sha": "597bee6b402decd6f04faea2e52d7ac134a72837", "filename": "src/primval.rs", "status": "modified", "additions": 74, "deletions": 55, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/e7bcf35f8ac9ac0797d0117166e0158d71acc03b/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bcf35f8ac9ac0797d0117166e0158d71acc03b/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=e7bcf35f8ac9ac0797d0117166e0158d71acc03b", "patch": "@@ -33,6 +33,15 @@ fn bits_to_bool(n: u64) -> bool {\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub struct PrimVal {\n     pub bits: u64,\n+\n+    /// This field is initialized when the `PrimVal` represents a pointer into an `Allocation`. An\n+    /// `Allocation` in the `memory` module has a list of relocations, but a `PrimVal` is only\n+    /// large enough to contain one, hence the `Option`.\n+    pub relocation: Option<AllocId>,\n+\n+    // FIXME(solson): I think we can make this field unnecessary, or at least move it outside of\n+    // this struct. We can either match over `Ty`s or generate simple `PrimVal`s from `Ty`s and\n+    // match over those to decide which operations to perform on `PrimVal`s.\n     pub kind: PrimValKind,\n }\n \n@@ -43,8 +52,8 @@ pub enum PrimValKind {\n     F32, F64,\n     Bool,\n     Char,\n-    Ptr(AllocId),\n-    FnPtr(AllocId),\n+    Ptr,\n+    FnPtr,\n }\n \n impl PrimValKind {\n@@ -55,19 +64,43 @@ impl PrimValKind {\n             _ => false,\n         }\n     }\n+\n+    pub fn from_uint_size(size: usize) -> Self {\n+        match size {\n+            1 => PrimValKind::U8,\n+            2 => PrimValKind::U16,\n+            4 => PrimValKind::U32,\n+            8 => PrimValKind::U64,\n+            _ => bug!(\"can't make uint with size {}\", size),\n+        }\n+    }\n+\n+    pub fn from_int_size(size: usize) -> Self {\n+        match size {\n+            1 => PrimValKind::I8,\n+            2 => PrimValKind::I16,\n+            4 => PrimValKind::I32,\n+            8 => PrimValKind::I64,\n+            _ => bug!(\"can't make int with size {}\", size),\n+        }\n+    }\n }\n \n impl PrimVal {\n     pub fn new(bits: u64, kind: PrimValKind) -> Self {\n-        PrimVal { bits: bits, kind: kind }\n+        PrimVal { bits: bits, relocation: None, kind: kind }\n+    }\n+\n+    pub fn new_with_relocation(bits: u64, kind: PrimValKind, alloc_id: AllocId) -> Self {\n+        PrimVal { bits: bits, relocation: Some(alloc_id), kind: kind }\n     }\n \n     pub fn from_ptr(ptr: Pointer) -> Self {\n-        PrimVal::new(ptr.offset as u64, PrimValKind::Ptr(ptr.alloc_id))\n+        PrimVal::new_with_relocation(ptr.offset as u64, PrimValKind::Ptr, ptr.alloc_id)\n     }\n \n     pub fn from_fn_ptr(ptr: Pointer) -> Self {\n-        PrimVal::new(ptr.offset as u64, PrimValKind::FnPtr(ptr.alloc_id))\n+        PrimVal::new_with_relocation(ptr.offset as u64, PrimValKind::FnPtr, ptr.alloc_id)\n     }\n \n     pub fn from_bool(b: bool) -> Self {\n@@ -87,64 +120,58 @@ impl PrimVal {\n     }\n \n     pub fn from_uint_with_size(n: u64, size: usize) -> Self {\n-        let kind = match size {\n-            1 => PrimValKind::U8,\n-            2 => PrimValKind::U16,\n-            4 => PrimValKind::U32,\n-            8 => PrimValKind::U64,\n-            _ => bug!(\"can't make uint ({}) with size {}\", n, size),\n-        };\n-        PrimVal::new(n, kind)\n+        PrimVal::new(n, PrimValKind::from_uint_size(size))\n     }\n \n     pub fn from_int_with_size(n: i64, size: usize) -> Self {\n-        let kind = match size {\n-            1 => PrimValKind::I8,\n-            2 => PrimValKind::I16,\n-            4 => PrimValKind::I32,\n-            8 => PrimValKind::I64,\n-            _ => bug!(\"can't make int ({}) with size {}\", n, size),\n-        };\n-        PrimVal::new(n as u64, kind)\n+        PrimVal::new(n as u64, PrimValKind::from_int_size(size))\n     }\n \n     pub fn to_f32(self) -> f32 {\n+        assert!(self.relocation.is_none());\n         bits_to_f32(self.bits)\n     }\n \n     pub fn to_f64(self) -> f64 {\n+        assert!(self.relocation.is_none());\n         bits_to_f64(self.bits)\n     }\n \n+    pub fn try_as_ptr(self) -> Option<Pointer> {\n+        self.relocation.map(|alloc_id| {\n+            Pointer::new(alloc_id, self.bits as usize)\n+        })\n+    }\n+\n     pub fn expect_uint(self, error_msg: &str) -> u64 {\n+        if let Some(ptr) = self.try_as_ptr() {\n+            return ptr.to_int().expect(\"non abstract ptr\") as u64\n+        }\n+\n         use self::PrimValKind::*;\n         match self.kind {\n             U8 | U16 | U32 | U64 => self.bits,\n-            Ptr(alloc_id) => {\n-                let ptr = Pointer::new(alloc_id, self.bits as usize);\n-                ptr.to_int().expect(\"non abstract ptr\") as u64\n-            }\n             _ => bug!(\"{}\", error_msg),\n         }\n     }\n \n     pub fn expect_int(self, error_msg: &str) -> i64 {\n+        if let Some(ptr) = self.try_as_ptr() {\n+            return ptr.to_int().expect(\"non abstract ptr\") as i64\n+        }\n+\n         use self::PrimValKind::*;\n         match self.kind {\n             I8 | I16 | I32 | I64 => self.bits as i64,\n-            Ptr(alloc_id) => {\n-                let ptr = Pointer::new(alloc_id, self.bits as usize);\n-                ptr.to_int().expect(\"non abstract ptr\") as i64\n-            }\n             _ => bug!(\"{}\", error_msg),\n         }\n     }\n \n-    pub fn expect_bool(self, error_msg: &str) -> bool {\n-        match (self.kind, self.bits) {\n-            (PrimValKind::Bool, 0) => false,\n-            (PrimValKind::Bool, 1) => true,\n-            _ => bug!(\"{}\", error_msg),\n+    pub fn try_as_bool<'tcx>(self) -> EvalResult<'tcx, bool> {\n+        match self.bits {\n+            0 => Ok(false),\n+            1 => Ok(true),\n+            _ => Err(EvalError::InvalidBool),\n         }\n     }\n \n@@ -163,17 +190,12 @@ impl PrimVal {\n     }\n \n     pub fn expect_ptr(self, error_msg: &str) -> Pointer {\n-        match self.kind {\n-            PrimValKind::Ptr(alloc_id) => Pointer::new(alloc_id, self.bits as usize),\n-            _ => bug!(\"{}\", error_msg),\n-        }\n+        self.try_as_ptr().expect(error_msg)\n     }\n \n+    /// FIXME(solson): Refactored into a duplicate of `expect_ptr`. Investigate removal.\n     pub fn expect_fn_ptr(self, error_msg: &str) -> Pointer {\n-        match self.kind {\n-            PrimValKind::FnPtr(alloc_id) => Pointer::new(alloc_id, self.bits as usize),\n-            _ => bug!(\"{}\", error_msg),\n-        }\n+        self.try_as_ptr().expect(error_msg)\n     }\n }\n \n@@ -255,22 +277,19 @@ pub fn binary_op<'tcx>(\n     use rustc::mir::repr::BinOp::*;\n     use self::PrimValKind::*;\n \n-    match (left.kind, right.kind) {\n-        (FnPtr(_), Ptr(_)) |\n-        (Ptr(_), FnPtr(_)) => return Ok((unrelated_ptr_ops(bin_op)?, false)),\n-\n-        (Ptr(l_alloc), Ptr(r_alloc)) if l_alloc != r_alloc\n-            => return Ok((unrelated_ptr_ops(bin_op)?, false)),\n-\n-        (FnPtr(l_alloc), FnPtr(r_alloc)) => {\n-            match bin_op {\n-                Eq => return Ok((PrimVal::from_bool(l_alloc == r_alloc), false)),\n-                Ne => return Ok((PrimVal::from_bool(l_alloc != r_alloc), false)),\n-                _ => {}\n+    match (left.try_as_ptr(), right.try_as_ptr()) {\n+        (Some(left_ptr), Some(right_ptr)) => {\n+            if left_ptr.alloc_id != right_ptr.alloc_id {\n+                return Ok((unrelated_ptr_ops(bin_op)?, false));\n             }\n+\n+            // If the pointers are into the same allocation, fall through to the more general match\n+            // later, which will do comparisons on the `bits` fields, which are the pointer offsets\n+            // in this case.\n         }\n \n-        _ => {}\n+        (None, None) => {}\n+        _ => unimplemented!(),\n     }\n \n     let (l, r) = (left.bits, right.bits);"}]}