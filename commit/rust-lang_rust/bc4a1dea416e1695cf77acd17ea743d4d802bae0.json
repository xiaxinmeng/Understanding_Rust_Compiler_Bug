{"sha": "bc4a1dea416e1695cf77acd17ea743d4d802bae0", "node_id": "C_kwDOAAsO6NoAKGJjNGExZGVhNDE2ZTE2OTVjZjc3YWNkMTdlYTc0M2Q0ZDgwMmJhZTA", "commit": {"author": {"name": "Jack Wrenn", "email": "jack@wrenn.fyi", "date": "2021-07-03T16:18:13Z"}, "committer": {"name": "Jack Wrenn", "email": "jack@wrenn.fyi", "date": "2022-07-27T17:33:56Z"}, "message": "Initial (incomplete) implementation of transmutability trait.\n\nThis initial implementation handles transmutations between types with specified layouts, except when references are involved.\n\nCo-authored-by: Igor null <m1el.2027@gmail.com>", "tree": {"sha": "f53690a1600de8fa7923dd3da10daf919978c492", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f53690a1600de8fa7923dd3da10daf919978c492"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc4a1dea416e1695cf77acd17ea743d4d802bae0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc4a1dea416e1695cf77acd17ea743d4d802bae0", "html_url": "https://github.com/rust-lang/rust/commit/bc4a1dea416e1695cf77acd17ea743d4d802bae0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc4a1dea416e1695cf77acd17ea743d4d802bae0/comments", "author": {"login": "jswrenn", "id": 3820879, "node_id": "MDQ6VXNlcjM4MjA4Nzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3820879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jswrenn", "html_url": "https://github.com/jswrenn", "followers_url": "https://api.github.com/users/jswrenn/followers", "following_url": "https://api.github.com/users/jswrenn/following{/other_user}", "gists_url": "https://api.github.com/users/jswrenn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jswrenn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jswrenn/subscriptions", "organizations_url": "https://api.github.com/users/jswrenn/orgs", "repos_url": "https://api.github.com/users/jswrenn/repos", "events_url": "https://api.github.com/users/jswrenn/events{/privacy}", "received_events_url": "https://api.github.com/users/jswrenn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jswrenn", "id": 3820879, "node_id": "MDQ6VXNlcjM4MjA4Nzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3820879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jswrenn", "html_url": "https://github.com/jswrenn", "followers_url": "https://api.github.com/users/jswrenn/followers", "following_url": "https://api.github.com/users/jswrenn/following{/other_user}", "gists_url": "https://api.github.com/users/jswrenn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jswrenn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jswrenn/subscriptions", "organizations_url": "https://api.github.com/users/jswrenn/orgs", "repos_url": "https://api.github.com/users/jswrenn/repos", "events_url": "https://api.github.com/users/jswrenn/events{/privacy}", "received_events_url": "https://api.github.com/users/jswrenn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a220937c283803bfd5d1155e4a81e6287089504", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a220937c283803bfd5d1155e4a81e6287089504", "html_url": "https://github.com/rust-lang/rust/commit/2a220937c283803bfd5d1155e4a81e6287089504"}], "stats": {"total": 5693, "additions": 5691, "deletions": 2}, "files": [{"sha": "16b67526cffa0730cdf930145fe495a2a83a19a3", "filename": "Cargo.lock", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -4553,6 +4553,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_transmute\",\n  \"smallvec\",\n  \"tracing\",\n ]\n@@ -4577,6 +4578,20 @@ dependencies = [\n  \"tracing\",\n ]\n \n+[[package]]\n+name = \"rustc_transmute\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"itertools\",\n+ \"rustc_data_structures\",\n+ \"rustc_infer\",\n+ \"rustc_macros\",\n+ \"rustc_middle\",\n+ \"rustc_span\",\n+ \"rustc_target\",\n+ \"tracing\",\n+]\n+\n [[package]]\n name = \"rustc_ty_utils\"\n version = \"0.0.0\""}, {"sha": "c337be12ae4929416e36901c49c3f09b7e7b33ce", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -191,6 +191,9 @@ language_item_table! {\n     CoerceUnsized,           sym::coerce_unsized,      coerce_unsized_trait,       Target::Trait,          GenericRequirement::Minimum(1);\n     DispatchFromDyn,         sym::dispatch_from_dyn,   dispatch_from_dyn_trait,    Target::Trait,          GenericRequirement::Minimum(1);\n \n+    // language items relating to transmutability\n+    TransmuteTrait,          sym::transmute_trait,     transmute_trait,            Target::Trait,          GenericRequirement::Exact(6);\n+\n     Add(Op),                 sym::add,                 add_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n     Sub(Op),                 sym::sub,                 sub_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n     Mul(Op),                 sym::mul,                 mul_trait,                  Target::Trait,          GenericRequirement::Exact(1);"}, {"sha": "e836ba47eed7a31fab3bbbe1eae5bf7fd92869a1", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -109,6 +109,10 @@ pub enum SelectionCandidate<'tcx> {\n         /// `false` if there are no *further* obligations.\n         has_nested: bool,\n     },\n+\n+    /// Implementation of transmutability trait.\n+    TransmutabilityCandidate,\n+\n     ParamCandidate(ty::PolyTraitPredicate<'tcx>),\n     ImplCandidate(DefId),\n     AutoImplCandidate(DefId),"}, {"sha": "5fda1e6538e91e7234c55e44d1e02ef7dffa9054", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -48,7 +48,7 @@ pub use subst::*;\n pub use vtable::*;\n \n use std::fmt::Debug;\n-use std::hash::Hash;\n+use std::hash::{Hash, Hasher};\n use std::ops::ControlFlow;\n use std::{fmt, str};\n \n@@ -1724,6 +1724,26 @@ impl VariantDef {\n     }\n }\n \n+/// There should be only one VariantDef for each `def_id`, therefore\n+/// it is fine to implement `PartialEq` only based on `def_id`.\n+impl PartialEq for VariantDef {\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.def_id == other.def_id\n+    }\n+}\n+\n+impl Eq for VariantDef {}\n+\n+/// There should be only one VariantDef for each `def_id`, therefore\n+/// it is fine to implement `Hash` only based on `def_id`.\n+impl Hash for VariantDef {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        self.def_id.hash(s)\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub enum VariantDiscr {\n     /// Explicit value for this variant, i.e., `X = 123`.\n@@ -1744,6 +1764,26 @@ pub struct FieldDef {\n     pub vis: Visibility,\n }\n \n+/// There should be only one FieldDef for each `did`, therefore\n+/// it is fine to implement `PartialEq` only based on `did`.\n+impl PartialEq for FieldDef {\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.did == other.did\n+    }\n+}\n+\n+impl Eq for FieldDef {}\n+\n+/// There should be only one FieldDef for each `did`, therefore\n+/// it is fine to implement `Hash` only based on `did`.\n+impl Hash for FieldDef {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        self.did.hash(s)\n+    }\n+}\n+\n bitflags! {\n     #[derive(TyEncodable, TyDecodable, Default, HashStable)]\n     pub struct ReprFlags: u8 {"}, {"sha": "632d2c13d74ef5ef76448679dfeaf0e33c3fa1df", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -1462,6 +1462,7 @@ symbols! {\n         trait_alias,\n         trait_upcasting,\n         transmute,\n+        transmute_trait,\n         transparent,\n         transparent_enums,\n         transparent_unions,"}, {"sha": "0758bf7c7cb07b5fe6ddd65a870cce2b77a956f3", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -508,6 +508,7 @@ impl fmt::Debug for Align {\n \n impl Align {\n     pub const ONE: Align = Align { pow2: 0 };\n+    pub const MAX: Align = Align { pow2: 29 };\n \n     #[inline]\n     pub fn from_bits(bits: u64) -> Result<Align, String> {\n@@ -540,7 +541,7 @@ impl Align {\n         if bytes != 1 {\n             return Err(not_power_of_2(align));\n         }\n-        if pow2 > 29 {\n+        if pow2 > Self::MAX.pow2 {\n             return Err(too_large(align));\n         }\n "}, {"sha": "566f236f26a8c7061587937dcc40780f49dcb592", "filename": "compiler/rustc_trait_selection/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_trait_selection%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_trait_selection%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2FCargo.toml?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -23,4 +23,5 @@ rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n+rustc_transmute = { path = \"../rustc_transmute\", features = [\"rustc\"] }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "a18b835e70ce1681a22c875446931b54f2ca3417", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -305,6 +305,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n             } else if lang_items.destruct_trait() == Some(def_id) {\n                 self.assemble_const_destruct_candidates(obligation, &mut candidates);\n+            } else if lang_items.transmute_trait() == Some(def_id) {\n+                // User-defined transmutability impls are permitted.\n+                self.assemble_candidates_from_impls(obligation, &mut candidates);\n+                self.assemble_candidates_for_transmutability(obligation, &mut candidates);\n             } else {\n                 if lang_items.clone_trait() == Some(def_id) {\n                     // Same builtin conditions as `Copy`, i.e., every type which has builtin support\n@@ -873,6 +877,25 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self, obligation, candidates))]\n+    fn assemble_candidates_for_transmutability(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) {\n+        if obligation.has_param_types_or_consts() {\n+            candidates.ambiguous = false;\n+            return;\n+        }\n+\n+        if obligation.has_infer_types_or_consts() {\n+            candidates.ambiguous = true;\n+            return;\n+        }\n+\n+        candidates.vec.push(TransmutabilityCandidate);\n+    }\n+\n     #[tracing::instrument(level = \"debug\", skip(self, obligation, candidates))]\n     fn assemble_candidates_for_trait_alias(\n         &mut self,"}, {"sha": "a609fb2b17266552925201237cada8b90d9ab68d", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -48,6 +48,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ImplSource::Builtin(data)\n             }\n \n+            TransmutabilityCandidate => {\n+                let data = self.confirm_transmutability_candidate(obligation)?;\n+                ImplSource::Builtin(data)\n+            }\n+\n             ParamCandidate(param) => {\n                 let obligations =\n                     self.confirm_param_candidate(obligation, param.map_bound(|t| t.trait_ref));\n@@ -267,6 +272,53 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         ImplSourceBuiltinData { nested: obligations }\n     }\n \n+    fn confirm_transmutability_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+    ) -> Result<ImplSourceBuiltinData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+        debug!(?obligation, \"confirm_transmutability_candidate\");\n+\n+        let predicate = obligation.predicate;\n+\n+        let type_at = |i| predicate.map_bound(|p| p.trait_ref.substs.type_at(i));\n+        let bool_at = |i| {\n+            predicate\n+                .skip_binder()\n+                .trait_ref\n+                .substs\n+                .const_at(i)\n+                .try_eval_bool(self.tcx(), obligation.param_env)\n+                .unwrap()\n+        };\n+\n+        let src_and_dst = predicate.map_bound(|p| rustc_transmute::Types {\n+            src: p.trait_ref.substs.type_at(1),\n+            dst: p.trait_ref.substs.type_at(0),\n+        });\n+\n+        let scope = type_at(2).skip_binder();\n+\n+        let assume = rustc_transmute::Assume {\n+            alignment: bool_at(3),\n+            lifetimes: bool_at(4),\n+            validity: bool_at(5),\n+            visibility: bool_at(6),\n+        };\n+\n+        let cause = obligation.cause.clone();\n+\n+        let mut transmute_env = rustc_transmute::TransmuteTypeEnv::new(self.infcx);\n+\n+        let maybe_transmutable = transmute_env.is_transmutable(cause, src_and_dst, scope, assume);\n+\n+        use rustc_transmute::Answer;\n+\n+        match maybe_transmutable {\n+            Answer::Yes => Ok(ImplSourceBuiltinData { nested: vec![] }),\n+            _ => Err(Unimplemented),\n+        }\n+    }\n+\n     /// This handles the case where an `auto trait Foo` impl is being used.\n     /// The idea is that the impl applies to `X : Foo` if the following conditions are met:\n     ///"}, {"sha": "9ca23228b98793c2fb9f40983f49c3f466281681", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -1630,6 +1630,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 );\n             }\n \n+            // FIXME(@jswrenn): this should probably be more sophisticated\n+            (TransmutabilityCandidate, _) | (_, TransmutabilityCandidate) => false,\n+\n             // (*)\n             (\n                 BuiltinCandidate { has_nested: false }"}, {"sha": "9dc96e08a8e27a271ed93681221d8259ca2df0b2", "filename": "compiler/rustc_transmute/Cargo.toml", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_transmute%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_transmute%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2FCargo.toml?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,28 @@\n+[package]\n+name = \"rustc_transmute\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+tracing = \"0.1\"\n+rustc_data_structures = { path = \"../rustc_data_structures\", optional = true}\n+rustc_infer = { path = \"../rustc_infer\", optional = true}\n+rustc_macros = { path = \"../rustc_macros\", optional = true}\n+rustc_middle = { path = \"../rustc_middle\", optional = true}\n+rustc_span = { path = \"../rustc_span\", optional = true}\n+rustc_target = { path = \"../rustc_target\", optional = true}\n+\n+[features]\n+rustc = [\n+    \"rustc_middle\",\n+    \"rustc_data_structures\",\n+    \"rustc_infer\",\n+    \"rustc_macros\",\n+    \"rustc_span\",\n+    \"rustc_target\",\n+]\n+\n+[dev-dependencies]\n+itertools = \"0.10.1\"\n\\ No newline at end of file"}, {"sha": "cdd3195712d269ed816d16dc00422abf522fa1bc", "filename": "compiler/rustc_transmute/src/layout/dfa.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Fdfa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Fdfa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Fdfa.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,184 @@\n+use super::{nfa, Byte, Nfa, Ref};\n+use crate::Map;\n+use std::fmt;\n+use std::sync::atomic::{AtomicU64, Ordering};\n+\n+#[derive(PartialEq, Clone, Debug)]\n+pub(crate) struct Dfa<R>\n+where\n+    R: Ref,\n+{\n+    pub(crate) transitions: Map<State, Transitions<R>>,\n+    pub(crate) start: State,\n+    pub(crate) accepting: State,\n+}\n+\n+#[derive(PartialEq, Clone, Debug)]\n+pub(crate) struct Transitions<R>\n+where\n+    R: Ref,\n+{\n+    byte_transitions: Map<Byte, State>,\n+    ref_transitions: Map<R, State>,\n+}\n+\n+impl<R> Default for Transitions<R>\n+where\n+    R: Ref,\n+{\n+    fn default() -> Self {\n+        Self { byte_transitions: Map::default(), ref_transitions: Map::default() }\n+    }\n+}\n+\n+impl<R> Transitions<R>\n+where\n+    R: Ref,\n+{\n+    fn insert(&mut self, transition: Transition<R>, state: State) {\n+        match transition {\n+            Transition::Byte(b) => {\n+                self.byte_transitions.insert(b, state);\n+            }\n+            Transition::Ref(r) => {\n+                self.ref_transitions.insert(r, state);\n+            }\n+        }\n+    }\n+}\n+\n+/// The states in a `Nfa` represent byte offsets.\n+#[derive(Hash, Eq, PartialEq, PartialOrd, Ord, Copy, Clone)]\n+pub(crate) struct State(u64);\n+\n+#[derive(Hash, Eq, PartialEq, Clone, Copy)]\n+pub(crate) enum Transition<R>\n+where\n+    R: Ref,\n+{\n+    Byte(Byte),\n+    Ref(R),\n+}\n+\n+impl fmt::Debug for State {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"S_{}\", self.0)\n+    }\n+}\n+\n+impl<R> fmt::Debug for Transition<R>\n+where\n+    R: Ref,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match &self {\n+            Self::Byte(b) => b.fmt(f),\n+            Self::Ref(r) => r.fmt(f),\n+        }\n+    }\n+}\n+\n+impl<R> Dfa<R>\n+where\n+    R: Ref,\n+{\n+    pub(crate) fn unit() -> Self {\n+        let transitions: Map<State, Transitions<R>> = Map::default();\n+        let start = State::new();\n+        let accepting = start;\n+\n+        Self { transitions, start, accepting }\n+    }\n+\n+    #[cfg(test)]\n+    pub(crate) fn bool() -> Self {\n+        let mut transitions: Map<State, Transitions<R>> = Map::default();\n+        let start = State::new();\n+        let accepting = State::new();\n+\n+        transitions.entry(start).or_default().insert(Transition::Byte(Byte::Init(0x00)), accepting);\n+\n+        transitions.entry(start).or_default().insert(Transition::Byte(Byte::Init(0x01)), accepting);\n+\n+        Self { transitions, start, accepting }\n+    }\n+\n+    #[tracing::instrument]\n+    #[cfg_attr(feature = \"rustc\", allow(rustc::potential_query_instability))]\n+    pub(crate) fn from_nfa(nfa: Nfa<R>) -> Self {\n+        let Nfa { transitions: nfa_transitions, start: nfa_start, accepting: nfa_accepting } = nfa;\n+\n+        let mut dfa_transitions: Map<State, Transitions<R>> = Map::default();\n+        let mut nfa_to_dfa: Map<nfa::State, State> = Map::default();\n+        let dfa_start = State::new();\n+        nfa_to_dfa.insert(nfa_start, dfa_start);\n+\n+        let mut queue = vec![(nfa_start, dfa_start)];\n+\n+        while let Some((nfa_state, dfa_state)) = queue.pop() {\n+            if nfa_state == nfa_accepting {\n+                continue;\n+            }\n+\n+            for (nfa_transition, next_nfa_states) in nfa_transitions[&nfa_state].iter() {\n+                let dfa_transitions =\n+                    dfa_transitions.entry(dfa_state).or_insert_with(Default::default);\n+\n+                let mapped_state = next_nfa_states.iter().find_map(|x| nfa_to_dfa.get(x).copied());\n+\n+                let next_dfa_state = match nfa_transition {\n+                    &nfa::Transition::Byte(b) => *dfa_transitions\n+                        .byte_transitions\n+                        .entry(b)\n+                        .or_insert_with(|| mapped_state.unwrap_or_else(State::new)),\n+                    &nfa::Transition::Ref(r) => *dfa_transitions\n+                        .ref_transitions\n+                        .entry(r)\n+                        .or_insert_with(|| mapped_state.unwrap_or_else(State::new)),\n+                };\n+\n+                for &next_nfa_state in next_nfa_states {\n+                    nfa_to_dfa.entry(next_nfa_state).or_insert_with(|| {\n+                        queue.push((next_nfa_state, next_dfa_state));\n+                        next_dfa_state\n+                    });\n+                }\n+            }\n+        }\n+\n+        let dfa_accepting = nfa_to_dfa[&nfa_accepting];\n+\n+        Self { transitions: dfa_transitions, start: dfa_start, accepting: dfa_accepting }\n+    }\n+\n+    pub(crate) fn bytes_from(&self, start: State) -> Option<&Map<Byte, State>> {\n+        Some(&self.transitions.get(&start)?.byte_transitions)\n+    }\n+\n+    pub(crate) fn byte_from(&self, start: State, byte: Byte) -> Option<State> {\n+        self.transitions.get(&start)?.byte_transitions.get(&byte).copied()\n+    }\n+\n+    pub(crate) fn refs_from(&self, start: State) -> Option<&Map<R, State>> {\n+        Some(&self.transitions.get(&start)?.ref_transitions)\n+    }\n+}\n+\n+impl State {\n+    pub(crate) fn new() -> Self {\n+        static COUNTER: AtomicU64 = AtomicU64::new(0);\n+        Self(COUNTER.fetch_add(1, Ordering::SeqCst))\n+    }\n+}\n+\n+impl<R> From<nfa::Transition<R>> for Transition<R>\n+where\n+    R: Ref,\n+{\n+    fn from(nfa_transition: nfa::Transition<R>) -> Self {\n+        match nfa_transition {\n+            nfa::Transition::Byte(byte) => Transition::Byte(byte),\n+            nfa::Transition::Ref(r) => Transition::Ref(r),\n+        }\n+    }\n+}"}, {"sha": "cbf92bdacd6f00e43c419cfccd974d148219500e", "filename": "compiler/rustc_transmute/src/layout/mod.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Fmod.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,71 @@\n+use std::fmt::{self, Debug};\n+use std::hash::Hash;\n+\n+pub(crate) mod tree;\n+pub(crate) use tree::Tree;\n+\n+pub(crate) mod nfa;\n+pub(crate) use nfa::Nfa;\n+\n+pub(crate) mod dfa;\n+pub(crate) use dfa::Dfa;\n+\n+#[derive(Debug)]\n+pub(crate) struct Uninhabited;\n+\n+/// An instance of a byte is either initialized to a particular value, or uninitialized.\n+#[derive(Hash, Eq, PartialEq, Clone, Copy)]\n+pub(crate) enum Byte {\n+    Uninit,\n+    Init(u8),\n+}\n+\n+impl fmt::Debug for Byte {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match &self {\n+            Self::Uninit => f.write_str(\"??u8\"),\n+            Self::Init(b) => write!(f, \"{:#04x}u8\", b),\n+        }\n+    }\n+}\n+\n+pub(crate) trait Def: Debug + Hash + Eq + PartialEq + Copy + Clone {}\n+pub trait Ref: Debug + Hash + Eq + PartialEq + Copy + Clone {}\n+\n+impl Def for ! {}\n+impl Ref for ! {}\n+\n+#[cfg(feature = \"rustc\")]\n+pub(crate) mod rustc {\n+    use rustc_middle::mir::Mutability;\n+    use rustc_middle::ty;\n+    use rustc_middle::ty::Region;\n+    use rustc_middle::ty::Ty;\n+\n+    /// A reference in the layout [`Nfa`].\n+    #[derive(Debug, Hash, Eq, PartialEq, PartialOrd, Ord, Clone, Copy)]\n+    pub struct Ref<'tcx> {\n+        lifetime: Region<'tcx>,\n+        ty: Ty<'tcx>,\n+        mutability: Mutability,\n+    }\n+\n+    impl<'tcx> super::Ref for Ref<'tcx> {}\n+\n+    impl<'tcx> Ref<'tcx> {\n+        pub fn min_align(&self) -> usize {\n+            todo!()\n+        }\n+    }\n+\n+    /// A visibility node in the layout [`Nfa`].\n+    #[derive(Debug, Hash, Eq, PartialEq, Clone, Copy)]\n+    pub enum Def<'tcx> {\n+        Adt(ty::AdtDef<'tcx>),\n+        Variant(&'tcx ty::VariantDef),\n+        Field(&'tcx ty::FieldDef),\n+        Primitive,\n+    }\n+\n+    impl<'tcx> super::Def for Def<'tcx> {}\n+}"}, {"sha": "817e426ba274e305f3cc4269e85ab02069619d6a", "filename": "compiler/rustc_transmute/src/layout/nfa.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Fnfa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Fnfa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Fnfa.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,179 @@\n+use super::{Byte, Ref, Tree, Uninhabited};\n+use crate::{Map, Set};\n+use std::fmt;\n+use std::sync::atomic::{AtomicU64, Ordering};\n+\n+/// A non-deterministic finite automaton (NFA) that represents the layout of a type.\n+/// The transmutability of two given types is computed by comparing their `Nfa`s.\n+#[derive(PartialEq, Debug)]\n+pub(crate) struct Nfa<R>\n+where\n+    R: Ref,\n+{\n+    pub(crate) transitions: Map<State, Map<Transition<R>, Set<State>>>,\n+    pub(crate) start: State,\n+    pub(crate) accepting: State,\n+}\n+\n+/// The states in a `Nfa` represent byte offsets.\n+#[derive(Hash, Eq, PartialEq, PartialOrd, Ord, Copy, Clone)]\n+pub(crate) struct State(u64);\n+\n+/// The transitions between states in a `Nfa` reflect bit validity.\n+#[derive(Hash, Eq, PartialEq, Clone, Copy)]\n+pub(crate) enum Transition<R>\n+where\n+    R: Ref,\n+{\n+    Byte(Byte),\n+    Ref(R),\n+}\n+\n+impl fmt::Debug for State {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"S_{}\", self.0)\n+    }\n+}\n+\n+impl<R> fmt::Debug for Transition<R>\n+where\n+    R: Ref,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match &self {\n+            Self::Byte(b) => b.fmt(f),\n+            Self::Ref(r) => r.fmt(f),\n+        }\n+    }\n+}\n+\n+impl<R> Nfa<R>\n+where\n+    R: Ref,\n+{\n+    pub(crate) fn unit() -> Self {\n+        let transitions: Map<State, Map<Transition<R>, Set<State>>> = Map::default();\n+        let start = State::new();\n+        let accepting = start;\n+\n+        Nfa { transitions, start, accepting }\n+    }\n+\n+    pub(crate) fn from_byte(byte: Byte) -> Self {\n+        let mut transitions: Map<State, Map<Transition<R>, Set<State>>> = Map::default();\n+        let start = State::new();\n+        let accepting = State::new();\n+\n+        let source = transitions.entry(start).or_default();\n+        let edge = source.entry(Transition::Byte(byte)).or_default();\n+        edge.insert(accepting);\n+\n+        Nfa { transitions, start, accepting }\n+    }\n+\n+    pub(crate) fn from_ref(r: R) -> Self {\n+        let mut transitions: Map<State, Map<Transition<R>, Set<State>>> = Map::default();\n+        let start = State::new();\n+        let accepting = State::new();\n+\n+        let source = transitions.entry(start).or_default();\n+        let edge = source.entry(Transition::Ref(r)).or_default();\n+        edge.insert(accepting);\n+\n+        Nfa { transitions, start, accepting }\n+    }\n+\n+    pub(crate) fn from_tree(tree: Tree<!, R>) -> Result<Self, Uninhabited> {\n+        Ok(match tree {\n+            Tree::Byte(b) => Self::from_byte(b),\n+            Tree::Def(..) => unreachable!(),\n+            Tree::Ref(r) => Self::from_ref(r),\n+            Tree::Alt(alts) => {\n+                let mut alts = alts.into_iter().map(Self::from_tree);\n+                let mut nfa = alts.next().ok_or(Uninhabited)??;\n+                for alt in alts {\n+                    nfa = nfa.union(&alt?);\n+                }\n+                nfa\n+            }\n+            Tree::Seq(elts) => {\n+                let mut nfa = Self::unit();\n+                for elt in elts.into_iter().map(Self::from_tree) {\n+                    nfa = nfa.concat(elt?);\n+                }\n+                nfa\n+            }\n+        })\n+    }\n+\n+    /// Concatenate two `Nfa`s.\n+    pub(crate) fn concat(self, other: Self) -> Self {\n+        if self.start == self.accepting {\n+            return other;\n+        } else if other.start == other.accepting {\n+            return self;\n+        }\n+\n+        let start = self.start;\n+        let accepting = other.accepting;\n+\n+        let mut transitions: Map<State, Map<Transition<R>, Set<State>>> = self.transitions;\n+\n+        // the iteration order doesn't matter\n+        #[cfg_attr(feature = \"rustc\", allow(rustc::potential_query_instability))]\n+        for (source, transition) in other.transitions {\n+            let fix_state = |state| if state == other.start { self.accepting } else { state };\n+            let entry = transitions.entry(fix_state(source)).or_default();\n+            for (edge, destinations) in transition {\n+                let entry = entry.entry(edge.clone()).or_default();\n+                for destination in destinations {\n+                    entry.insert(fix_state(destination));\n+                }\n+            }\n+        }\n+\n+        Self { transitions, start, accepting }\n+    }\n+\n+    /// Compute the union of two `Nfa`s.\n+    pub(crate) fn union(&self, other: &Self) -> Self {\n+        let start = self.start;\n+        let accepting = self.accepting;\n+\n+        let mut transitions: Map<State, Map<Transition<R>, Set<State>>> = self.transitions.clone();\n+\n+        // the iteration order doesn't matter\n+        #[cfg_attr(feature = \"rustc\", allow(rustc::potential_query_instability))]\n+        for (&(mut source), transition) in other.transitions.iter() {\n+            // if source is starting state of `other`, replace with starting state of `self`\n+            if source == other.start {\n+                source = self.start;\n+            }\n+            let entry = transitions.entry(source).or_default();\n+            for (edge, destinations) in transition {\n+                let entry = entry.entry(edge.clone()).or_default();\n+                // the iteration order doesn't matter\n+                #[cfg_attr(feature = \"rustc\", allow(rustc::potential_query_instability))]\n+                for &(mut destination) in destinations {\n+                    // if dest is accepting state of `other`, replace with accepting state of `self`\n+                    if destination == other.accepting {\n+                        destination = self.accepting;\n+                    }\n+                    entry.insert(destination);\n+                }\n+            }\n+        }\n+        Self { transitions, start, accepting }\n+    }\n+\n+    pub(crate) fn edges_from(&self, start: State) -> Option<&Map<Transition<R>, Set<State>>> {\n+        self.transitions.get(&start)\n+    }\n+}\n+\n+impl State {\n+    pub(crate) fn new() -> Self {\n+        static COUNTER: AtomicU64 = AtomicU64::new(0);\n+        Self(COUNTER.fetch_add(1, Ordering::SeqCst))\n+    }\n+}"}, {"sha": "67b401855d4be570abe460412081e83e5ee5e99b", "filename": "compiler/rustc_transmute/src/layout/tree.rs", "status": "added", "additions": 479, "deletions": 0, "changes": 479, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,479 @@\n+use super::{Byte, Def, Ref};\n+\n+#[cfg(test)]\n+mod tests;\n+\n+/// A tree-based representation of a type layout.\n+///\n+/// Invariants:\n+/// 1. All paths through the layout have the same length (in bytes).\n+///\n+/// Nice-to-haves:\n+/// 1. An `Alt` is never directly nested beneath another `Alt`.\n+/// 2. A `Seq` is never directly nested beneath another `Seq`.\n+/// 3. `Seq`s and `Alt`s with a single member do not exist.\n+#[derive(Clone, Debug, Hash, PartialEq, Eq)]\n+pub(crate) enum Tree<D, R>\n+where\n+    D: Def,\n+    R: Ref,\n+{\n+    /// A sequence of successive layouts.\n+    Seq(Vec<Self>),\n+    /// A choice between alternative layouts.\n+    Alt(Vec<Self>),\n+    /// A definition node.\n+    Def(D),\n+    /// A reference node.\n+    Ref(R),\n+    /// A byte node.\n+    Byte(Byte),\n+}\n+\n+impl<D, R> Tree<D, R>\n+where\n+    D: Def,\n+    R: Ref,\n+{\n+    /// A `Tree` consisting only of a definition node.\n+    pub(crate) fn def(def: D) -> Self {\n+        Self::Def(def)\n+    }\n+\n+    /// A `Tree` representing an uninhabited type.\n+    pub(crate) fn uninhabited() -> Self {\n+        Self::Alt(vec![])\n+    }\n+\n+    /// A `Tree` representing a zero-sized type.\n+    pub(crate) fn unit() -> Self {\n+        Self::Seq(Vec::new())\n+    }\n+\n+    /// A `Tree` containing a single, uninitialized byte.\n+    pub(crate) fn uninit() -> Self {\n+        Self::Byte(Byte::Uninit)\n+    }\n+\n+    /// A `Tree` representing the layout of `bool`.\n+    pub(crate) fn bool() -> Self {\n+        Self::from_bits(0x00).or(Self::from_bits(0x01))\n+    }\n+\n+    /// A `Tree` whose layout matches that of a `u8`.\n+    pub(crate) fn u8() -> Self {\n+        Self::Alt((0u8..=255).map(Self::from_bits).collect())\n+    }\n+\n+    /// A `Tree` whose layout accepts exactly the given bit pattern.\n+    pub(crate) fn from_bits(bits: u8) -> Self {\n+        Self::Byte(Byte::Init(bits))\n+    }\n+\n+    /// A `Tree` whose layout is a number of the given width.\n+    pub(crate) fn number(width_in_bytes: usize) -> Self {\n+        Self::Seq(vec![Self::u8(); width_in_bytes])\n+    }\n+\n+    /// A `Tree` whose layout is entirely padding of the given width.\n+    #[tracing::instrument]\n+    pub(crate) fn padding(width_in_bytes: usize) -> Self {\n+        Self::Seq(vec![Self::uninit(); width_in_bytes])\n+    }\n+\n+    /// Remove all `Def` nodes, and all branches of the layout for which `f` produces false.\n+    pub(crate) fn prune<F>(self, f: &F) -> Tree<!, R>\n+    where\n+        F: Fn(D) -> bool,\n+    {\n+        match self {\n+            Self::Seq(elts) => elts\n+                .into_iter()\n+                .map(|elt| elt.prune(f))\n+                .try_fold(Tree::unit(), |elts, elt| {\n+                    if elt == Tree::uninhabited() {\n+                        Err(Tree::uninhabited())\n+                    } else {\n+                        Ok(elts.then(elt))\n+                    }\n+                })\n+                .into_ok_or_err(),\n+            Self::Alt(alts) => alts\n+                .into_iter()\n+                .map(|alt| alt.prune(f))\n+                .fold(Tree::uninhabited(), |alts, alt| alts.or(alt)),\n+            Self::Byte(b) => Tree::Byte(b),\n+            Self::Ref(r) => Tree::Ref(r),\n+            Self::Def(d) => {\n+                if !f(d) {\n+                    Tree::uninhabited()\n+                } else {\n+                    Tree::unit()\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Produces `true` if `Tree` is an inhabited type; otherwise false.\n+    pub(crate) fn is_inhabited(&self) -> bool {\n+        match self {\n+            Self::Seq(elts) => elts.into_iter().all(|elt| elt.is_inhabited()),\n+            Self::Alt(alts) => alts.into_iter().any(|alt| alt.is_inhabited()),\n+            Self::Byte(..) | Self::Ref(..) | Self::Def(..) => true,\n+        }\n+    }\n+}\n+\n+impl<D, R> Tree<D, R>\n+where\n+    D: Def,\n+    R: Ref,\n+{\n+    /// Produces a new `Tree` where `other` is sequenced after `self`.\n+    pub(crate) fn then(self, other: Self) -> Self {\n+        match (self, other) {\n+            (Self::Seq(elts), other) | (other, Self::Seq(elts)) if elts.len() == 0 => other,\n+            (Self::Seq(mut lhs), Self::Seq(mut rhs)) => {\n+                lhs.append(&mut rhs);\n+                Self::Seq(lhs)\n+            }\n+            (Self::Seq(mut lhs), rhs) => {\n+                lhs.push(rhs);\n+                Self::Seq(lhs)\n+            }\n+            (lhs, Self::Seq(mut rhs)) => {\n+                rhs.insert(0, lhs);\n+                Self::Seq(rhs)\n+            }\n+            (lhs, rhs) => Self::Seq(vec![lhs, rhs]),\n+        }\n+    }\n+\n+    /// Produces a new `Tree` accepting either `self` or `other` as alternative layouts.\n+    pub(crate) fn or(self, other: Self) -> Self {\n+        match (self, other) {\n+            (Self::Alt(alts), other) | (other, Self::Alt(alts)) if alts.len() == 0 => other,\n+            (Self::Alt(mut lhs), Self::Alt(rhs)) => {\n+                lhs.extend(rhs);\n+                Self::Alt(lhs)\n+            }\n+            (Self::Alt(mut alts), alt) | (alt, Self::Alt(mut alts)) => {\n+                alts.push(alt);\n+                Self::Alt(alts)\n+            }\n+            (lhs, rhs) => Self::Alt(vec![lhs, rhs]),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone)]\n+pub(crate) enum Err {\n+    /// The layout of the type is unspecified.\n+    Unspecified,\n+    /// This error will be surfaced elsewhere by rustc, so don't surface it.\n+    Unknown,\n+}\n+\n+#[cfg(feature = \"rustc\")]\n+pub(crate) mod rustc {\n+    use super::{Err, Tree};\n+    use crate::layout::rustc::{Def, Ref};\n+\n+    use rustc_middle::ty;\n+    use rustc_middle::ty::layout::LayoutError;\n+    use rustc_middle::ty::util::Discr;\n+    use rustc_middle::ty::AdtDef;\n+    use rustc_middle::ty::ParamEnv;\n+    use rustc_middle::ty::SubstsRef;\n+    use rustc_middle::ty::Ty;\n+    use rustc_middle::ty::TyCtxt;\n+    use rustc_middle::ty::VariantDef;\n+    use rustc_target::abi::Align;\n+    use std::alloc;\n+\n+    impl<'tcx> From<LayoutError<'tcx>> for Err {\n+        fn from(err: LayoutError<'tcx>) -> Self {\n+            match err {\n+                LayoutError::Unknown(..) => Self::Unknown,\n+                err @ _ => unimplemented!(\"{:?}\", err),\n+            }\n+        }\n+    }\n+\n+    trait LayoutExt {\n+        fn clamp_align(&self, min_align: Align, max_align: Align) -> Self;\n+    }\n+\n+    impl LayoutExt for alloc::Layout {\n+        fn clamp_align(&self, min_align: Align, max_align: Align) -> Self {\n+            let min_align = min_align.bytes().try_into().unwrap();\n+            let max_align = max_align.bytes().try_into().unwrap();\n+            Self::from_size_align(self.size(), self.align().clamp(min_align, max_align)).unwrap()\n+        }\n+    }\n+\n+    struct LayoutSummary {\n+        total_align: Align,\n+        total_size: usize,\n+        discriminant_size: usize,\n+        discriminant_align: Align,\n+    }\n+\n+    impl LayoutSummary {\n+        fn from_ty<'tcx>(ty: Ty<'tcx>, ctx: TyCtxt<'tcx>) -> Result<Self, LayoutError<'tcx>> {\n+            use rustc_middle::ty::ParamEnvAnd;\n+            use rustc_target::abi::{TyAndLayout, Variants};\n+\n+            let param_env = ParamEnv::reveal_all();\n+            let param_env_and_type = ParamEnvAnd { param_env, value: ty };\n+            let TyAndLayout { layout, .. } = ctx.layout_of(param_env_and_type)?;\n+\n+            let total_size: usize = layout.size().bytes_usize();\n+            let total_align: Align = layout.align().abi;\n+            let discriminant_align: Align;\n+            let discriminant_size: usize;\n+\n+            if let Variants::Multiple { tag, .. } = layout.variants() {\n+                discriminant_align = tag.align(&ctx).abi;\n+                discriminant_size = tag.size(&ctx).bytes_usize();\n+            } else {\n+                discriminant_align = Align::ONE;\n+                discriminant_size = 0;\n+            };\n+\n+            Ok(Self { total_align, total_size, discriminant_align, discriminant_size })\n+        }\n+\n+        fn into(&self) -> alloc::Layout {\n+            alloc::Layout::from_size_align(\n+                self.total_size,\n+                self.total_align.bytes().try_into().unwrap(),\n+            )\n+            .unwrap()\n+        }\n+    }\n+\n+    impl<'tcx> Tree<Def<'tcx>, Ref<'tcx>> {\n+        pub fn from_ty(ty: Ty<'tcx>, tcx: TyCtxt<'tcx>) -> Result<Self, Err> {\n+            use rustc_middle::ty::FloatTy::*;\n+            use rustc_middle::ty::IntTy::*;\n+            use rustc_middle::ty::UintTy::*;\n+            use rustc_target::abi::HasDataLayout;\n+\n+            let target = tcx.data_layout();\n+\n+            match ty.kind() {\n+                ty::Bool => Ok(Self::bool()),\n+\n+                ty::Int(I8) | ty::Uint(U8) => Ok(Self::u8()),\n+                ty::Int(I16) | ty::Uint(U16) => Ok(Self::number(2)),\n+                ty::Int(I32) | ty::Uint(U32) | ty::Float(F32) => Ok(Self::number(4)),\n+                ty::Int(I64) | ty::Uint(U64) | ty::Float(F64) => Ok(Self::number(8)),\n+                ty::Int(I128) | ty::Uint(U128) => Ok(Self::number(16)),\n+                ty::Int(Isize) | ty::Uint(Usize) => {\n+                    Ok(Self::number(target.pointer_size.bytes_usize()))\n+                }\n+\n+                ty::Tuple(members) => {\n+                    if members.len() == 0 {\n+                        Ok(Tree::unit())\n+                    } else {\n+                        Err(Err::Unspecified)\n+                    }\n+                }\n+\n+                ty::Array(ty, len) => {\n+                    let len = len.try_eval_usize(tcx, ParamEnv::reveal_all()).unwrap();\n+                    let elt = Tree::from_ty(*ty, tcx)?;\n+                    Ok(std::iter::repeat(elt)\n+                        .take(len as usize)\n+                        .fold(Tree::unit(), |tree, elt| tree.then(elt)))\n+                }\n+\n+                ty::Adt(adt_def, substs_ref) => {\n+                    use rustc_middle::ty::AdtKind;\n+\n+                    // If the layout is ill-specified, halt.\n+                    if !(adt_def.repr().c() || adt_def.repr().int.is_some()) {\n+                        return Err(Err::Unspecified);\n+                    }\n+\n+                    // Compute a summary of the type's layout.\n+                    let layout_summary = LayoutSummary::from_ty(ty, tcx)?;\n+\n+                    // The layout begins with this adt's visibility.\n+                    let vis = Self::def(Def::Adt(*adt_def));\n+\n+                    // And is followed the layout(s) of its variants\n+                    Ok(vis.then(match adt_def.adt_kind() {\n+                        AdtKind::Struct => Self::from_repr_c_variant(\n+                            ty,\n+                            *adt_def,\n+                            substs_ref,\n+                            &layout_summary,\n+                            None,\n+                            adt_def.non_enum_variant(),\n+                            tcx,\n+                        )?,\n+                        AdtKind::Enum => {\n+                            tracing::trace!(\n+                                adt_def = ?adt_def,\n+                                \"treeifying enum\"\n+                            );\n+                            let mut tree = Tree::uninhabited();\n+\n+                            for (idx, discr) in adt_def.discriminants(tcx) {\n+                                tree = tree.or(Self::from_repr_c_variant(\n+                                    ty,\n+                                    *adt_def,\n+                                    substs_ref,\n+                                    &layout_summary,\n+                                    Some(discr),\n+                                    adt_def.variant(idx),\n+                                    tcx,\n+                                )?);\n+                            }\n+\n+                            tree\n+                        }\n+                        AdtKind::Union => {\n+                            // is the layout well-defined?\n+                            if !adt_def.repr().c() {\n+                                return Err(Err::Unspecified);\n+                            }\n+\n+                            let ty_layout = layout_of(tcx, ty)?;\n+\n+                            let mut tree = Tree::uninhabited();\n+\n+                            for field in adt_def.all_fields() {\n+                                let variant_ty = field.ty(tcx, substs_ref);\n+                                let variant_layout = layout_of(tcx, variant_ty)?;\n+                                let padding_needed = ty_layout.size() - variant_layout.size();\n+                                let variant = Self::def(Def::Field(field))\n+                                    .then(Self::from_ty(variant_ty, tcx)?)\n+                                    .then(Self::padding(padding_needed));\n+\n+                                tree = tree.or(variant);\n+                            }\n+\n+                            tree\n+                        }\n+                    }))\n+                }\n+                _ => Err(Err::Unspecified),\n+            }\n+        }\n+\n+        fn from_repr_c_variant(\n+            ty: Ty<'tcx>,\n+            adt_def: AdtDef<'tcx>,\n+            substs_ref: SubstsRef<'tcx>,\n+            layout_summary: &LayoutSummary,\n+            discr: Option<Discr<'tcx>>,\n+            variant_def: &'tcx VariantDef,\n+            tcx: TyCtxt<'tcx>,\n+        ) -> Result<Self, Err> {\n+            let mut tree = Tree::unit();\n+\n+            let repr = adt_def.repr();\n+            let min_align = repr.align.unwrap_or(Align::ONE);\n+            let max_align = repr.pack.unwrap_or(Align::MAX);\n+\n+            let clamp =\n+                |align: Align| align.clamp(min_align, max_align).bytes().try_into().unwrap();\n+\n+            let variant_span = tracing::trace_span!(\n+                \"treeifying variant\",\n+                min_align = ?min_align,\n+                max_align = ?max_align,\n+            )\n+            .entered();\n+\n+            let mut variant_layout = alloc::Layout::from_size_align(\n+                0,\n+                layout_summary.total_align.bytes().try_into().unwrap(),\n+            )\n+            .unwrap();\n+\n+            // The layout of the variant is prefixed by the discriminant, if any.\n+            if let Some(discr) = discr {\n+                tracing::trace!(discr = ?discr, \"treeifying discriminant\");\n+                let discr_layout = alloc::Layout::from_size_align(\n+                    layout_summary.discriminant_size,\n+                    clamp(layout_summary.discriminant_align),\n+                )\n+                .unwrap();\n+                tracing::trace!(discr_layout = ?discr_layout, \"computed discriminant layout\");\n+                variant_layout = variant_layout.extend(discr_layout).unwrap().0;\n+                tree = tree.then(Self::from_disr(discr, tcx, layout_summary.discriminant_size));\n+            }\n+\n+            // Next come fields.\n+            let fields_span = tracing::trace_span!(\"treeifying fields\").entered();\n+            for field_def in variant_def.fields.iter() {\n+                let field_ty = field_def.ty(tcx, substs_ref);\n+                let _span = tracing::trace_span!(\"treeifying field\", field = ?field_ty).entered();\n+\n+                // begin with the field's visibility\n+                tree = tree.then(Self::def(Def::Field(field_def)));\n+\n+                // compute the field's layout charactaristics\n+                let field_layout = layout_of(tcx, field_ty)?.clamp_align(min_align, max_align);\n+\n+                // next comes the field's padding\n+                let padding_needed = variant_layout.padding_needed_for(field_layout.align());\n+                if padding_needed > 0 {\n+                    tree = tree.then(Self::padding(padding_needed));\n+                }\n+\n+                // finally, the field's layout\n+                tree = tree.then(Self::from_ty(field_ty, tcx)?);\n+\n+                // extend the variant layout with the field layout\n+                variant_layout = variant_layout.extend(field_layout).unwrap().0;\n+            }\n+            drop(fields_span);\n+\n+            // finally: padding\n+            let padding_span = tracing::trace_span!(\"adding trailing padding\").entered();\n+            let padding_needed = layout_summary.total_size - variant_layout.size();\n+            if padding_needed > 0 {\n+                tree = tree.then(Self::padding(padding_needed));\n+            };\n+            drop(padding_span);\n+            drop(variant_span);\n+            Ok(tree)\n+        }\n+\n+        pub fn from_disr(discr: Discr<'tcx>, tcx: TyCtxt<'tcx>, size: usize) -> Self {\n+            // FIXME(@jswrenn): I'm certain this is missing needed endian nuance.\n+            let bytes = discr.val.to_ne_bytes();\n+            let bytes = &bytes[..size];\n+            Self::Seq(bytes.into_iter().copied().map(|b| Self::from_bits(b)).collect())\n+        }\n+    }\n+\n+    fn layout_of<'tcx>(\n+        ctx: TyCtxt<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> Result<alloc::Layout, LayoutError<'tcx>> {\n+        use rustc_middle::ty::ParamEnvAnd;\n+        use rustc_target::abi::TyAndLayout;\n+\n+        let param_env = ParamEnv::reveal_all();\n+        let param_env_and_type = ParamEnvAnd { param_env, value: ty };\n+        let TyAndLayout { layout, .. } = ctx.layout_of(param_env_and_type)?;\n+        let layout = alloc::Layout::from_size_align(\n+            layout.size().bytes_usize(),\n+            layout.align().abi.bytes().try_into().unwrap(),\n+        )\n+        .unwrap();\n+        tracing::trace!(\n+            ty = ?ty,\n+            layout = ?layout,\n+            \"computed layout for type\"\n+        );\n+        Ok(layout)\n+    }\n+}"}, {"sha": "90515e92f7aef58724bcecc0acbc2a8ac6edda21", "filename": "compiler/rustc_transmute/src/layout/tree/tests.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree%2Ftests.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,80 @@\n+use super::Tree;\n+\n+#[derive(Debug, Hash, Eq, PartialEq, Clone, Copy)]\n+pub enum Def {\n+    Visible,\n+    Invisible,\n+}\n+\n+impl super::Def for Def {}\n+\n+mod prune {\n+    use super::*;\n+\n+    mod should_simplify {\n+        use super::*;\n+\n+        #[test]\n+        fn seq_1() {\n+            let layout: Tree<Def, !> = Tree::def(Def::Visible).then(Tree::from_bits(0x00));\n+            assert_eq!(layout.prune(&|d| matches!(d, Def::Visible)), Tree::from_bits(0x00));\n+        }\n+\n+        #[test]\n+        fn seq_2() {\n+            let layout: Tree<Def, !> =\n+                Tree::from_bits(0x00).then(Tree::def(Def::Visible)).then(Tree::from_bits(0x01));\n+\n+            assert_eq!(\n+                layout.prune(&|d| matches!(d, Def::Visible)),\n+                Tree::from_bits(0x00).then(Tree::from_bits(0x01))\n+            );\n+        }\n+    }\n+\n+    mod should_reject {\n+        use super::*;\n+\n+        #[test]\n+        fn invisible_def() {\n+            let layout: Tree<Def, !> = Tree::def(Def::Invisible);\n+            assert_eq!(layout.prune(&|d| matches!(d, Def::Visible)), Tree::uninhabited());\n+        }\n+\n+        #[test]\n+        fn invisible_def_in_seq_len_2() {\n+            let layout: Tree<Def, !> = Tree::def(Def::Visible).then(Tree::def(Def::Invisible));\n+            assert_eq!(layout.prune(&|d| matches!(d, Def::Visible)), Tree::uninhabited());\n+        }\n+\n+        #[test]\n+        fn invisible_def_in_seq_len_3() {\n+            let layout: Tree<Def, !> =\n+                Tree::def(Def::Visible).then(Tree::from_bits(0x00)).then(Tree::def(Def::Invisible));\n+            assert_eq!(layout.prune(&|d| matches!(d, Def::Visible)), Tree::uninhabited());\n+        }\n+    }\n+\n+    mod should_accept {\n+        use super::*;\n+\n+        #[test]\n+        fn visible_def() {\n+            let layout: Tree<Def, !> = Tree::def(Def::Visible);\n+            assert_eq!(layout.prune(&|d| matches!(d, Def::Visible)), Tree::unit());\n+        }\n+\n+        #[test]\n+        fn visible_def_in_seq_len_2() {\n+            let layout: Tree<Def, !> = Tree::def(Def::Visible).then(Tree::def(Def::Visible));\n+            assert_eq!(layout.prune(&|d| matches!(d, Def::Visible)), Tree::unit());\n+        }\n+\n+        #[test]\n+        fn visible_def_in_seq_len_3() {\n+            let layout: Tree<Def, !> =\n+                Tree::def(Def::Visible).then(Tree::from_bits(0x00)).then(Tree::def(Def::Visible));\n+            assert_eq!(layout.prune(&|d| matches!(d, Def::Visible)), Tree::from_bits(0x00));\n+        }\n+    }\n+}"}, {"sha": "9f7508fdd716abbea3e4b4df690d9dfcfad5a2f6", "filename": "compiler/rustc_transmute/src/lib.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flib.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,114 @@\n+#![feature(\n+    alloc_layout_extra,\n+    control_flow_enum,\n+    decl_macro,\n+    iterator_try_reduce,\n+    never_type,\n+    result_into_ok_or_err\n+)]\n+#![allow(dead_code, unused_variables)]\n+\n+#[cfg(feature = \"rustc\")]\n+pub(crate) use rustc_data_structures::fx::{FxHashMap as Map, FxHashSet as Set};\n+\n+#[cfg(not(feature = \"rustc\"))]\n+pub(crate) use std::collections::{HashMap as Map, HashSet as Set};\n+\n+pub(crate) mod layout;\n+pub(crate) mod maybe_transmutable;\n+\n+#[derive(Default)]\n+pub struct Assume {\n+    pub alignment: bool,\n+    pub lifetimes: bool,\n+    pub validity: bool,\n+    pub visibility: bool,\n+}\n+\n+/// The type encodes answers to the question: \"Are these types transmutable?\"\n+#[derive(Debug, Hash, Eq, PartialEq, PartialOrd, Ord, Clone)]\n+pub enum Answer<R>\n+where\n+    R: layout::Ref,\n+{\n+    /// `Src` is transmutable into `Dst`.\n+    Yes,\n+\n+    /// `Src` is NOT transmutable into `Dst`.\n+    No(Reason),\n+\n+    /// `Src` is transmutable into `Dst`, if `src` is transmutable into `dst`.\n+    IfTransmutable { src: R, dst: R },\n+\n+    /// `Src` is transmutable into `Dst`, if all of the enclosed requirements are met.\n+    IfAll(Vec<Answer<R>>),\n+\n+    /// `Src` is transmutable into `Dst` if any of the enclosed requirements are met.\n+    IfAny(Vec<Answer<R>>),\n+}\n+\n+/// Answers: Why wasn't the source type transmutable into the destination type?\n+#[derive(Debug, Hash, Eq, PartialEq, PartialOrd, Ord, Clone)]\n+pub enum Reason {\n+    /// The layout of the source type is unspecified.\n+    SrcIsUnspecified,\n+    /// The layout of the destination type is unspecified.\n+    DstIsUnspecified,\n+    /// The layout of the destination type is bit-incompatible with the source type.\n+    DstIsBitIncompatible,\n+    /// There aren't any public constructors for `Dst`.\n+    DstIsPrivate,\n+    /// `Dst` is larger than `Src`, and the excess bytes were not exclusively uninitialized.\n+    DstIsTooBig,\n+}\n+\n+#[cfg(feature = \"rustc\")]\n+mod rustc {\n+    use rustc_infer::infer::InferCtxt;\n+    use rustc_macros::{TypeFoldable, TypeVisitable};\n+    use rustc_middle::traits::ObligationCause;\n+    use rustc_middle::ty::Binder;\n+    use rustc_middle::ty::Ty;\n+\n+    /// The source and destination types of a transmutation.\n+    #[derive(TypeFoldable, TypeVisitable, Debug, Clone, Copy)]\n+    pub struct Types<'tcx> {\n+        /// The source type.\n+        pub src: Ty<'tcx>,\n+        /// The destination type.\n+        pub dst: Ty<'tcx>,\n+    }\n+\n+    pub struct TransmuteTypeEnv<'cx, 'tcx> {\n+        infcx: &'cx InferCtxt<'cx, 'tcx>,\n+    }\n+\n+    impl<'cx, 'tcx> TransmuteTypeEnv<'cx, 'tcx> {\n+        pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>) -> Self {\n+            Self { infcx }\n+        }\n+\n+        #[allow(unused)]\n+        pub fn is_transmutable(\n+            &mut self,\n+            cause: ObligationCause<'tcx>,\n+            src_and_dst: Binder<'tcx, Types<'tcx>>,\n+            scope: Ty<'tcx>,\n+            assume: crate::Assume,\n+        ) -> crate::Answer<crate::layout::rustc::Ref<'tcx>> {\n+            let src = src_and_dst.map_bound(|types| types.src).skip_binder();\n+            let dst = src_and_dst.map_bound(|types| types.dst).skip_binder();\n+            crate::maybe_transmutable::MaybeTransmutableQuery::new(\n+                src,\n+                dst,\n+                scope,\n+                assume,\n+                self.infcx.tcx,\n+            )\n+            .answer()\n+        }\n+    }\n+}\n+\n+#[cfg(feature = \"rustc\")]\n+pub use rustc::*;"}, {"sha": "ef3852001a806b0001dadf20cac17ddf22b1f4f4", "filename": "compiler/rustc_transmute/src/maybe_transmutable/mod.rs", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fmod.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,320 @@\n+use crate::Map;\n+use crate::{Answer, Reason};\n+\n+#[cfg(test)]\n+mod tests;\n+\n+mod query_context;\n+use query_context::QueryContext;\n+\n+use crate::layout::{self, dfa, Byte, Dfa, Nfa, Tree, Uninhabited};\n+pub(crate) struct MaybeTransmutableQuery<L, C>\n+where\n+    C: QueryContext,\n+{\n+    src: L,\n+    dst: L,\n+    scope: <C as QueryContext>::Scope,\n+    assume: crate::Assume,\n+    context: C,\n+}\n+\n+impl<L, C> MaybeTransmutableQuery<L, C>\n+where\n+    C: QueryContext,\n+{\n+    pub(crate) fn new(\n+        src: L,\n+        dst: L,\n+        scope: <C as QueryContext>::Scope,\n+        assume: crate::Assume,\n+        context: C,\n+    ) -> Self {\n+        Self { src, dst, scope, assume, context }\n+    }\n+\n+    pub(crate) fn map_layouts<F, M>(\n+        self,\n+        f: F,\n+    ) -> Result<MaybeTransmutableQuery<M, C>, Answer<<C as QueryContext>::Ref>>\n+    where\n+        F: FnOnce(\n+            L,\n+            L,\n+            <C as QueryContext>::Scope,\n+            &C,\n+        ) -> Result<(M, M), Answer<<C as QueryContext>::Ref>>,\n+    {\n+        let Self { src, dst, scope, assume, context } = self;\n+\n+        let (src, dst) = f(src, dst, scope, &context)?;\n+\n+        Ok(MaybeTransmutableQuery { src, dst, scope, assume, context })\n+    }\n+}\n+\n+#[cfg(feature = \"rustc\")]\n+mod rustc {\n+    use super::*;\n+    use crate::layout::tree::Err;\n+\n+    use rustc_middle::ty::Ty;\n+    use rustc_middle::ty::TyCtxt;\n+\n+    impl<'tcx> MaybeTransmutableQuery<Ty<'tcx>, TyCtxt<'tcx>> {\n+        /// This method begins by converting `src` and `dst` from `Ty`s to `Tree`s,\n+        /// then computes an answer using those trees.\n+        #[tracing::instrument(skip(self), fields(src = ?self.src, dst = ?self.dst))]\n+        pub fn answer(self) -> Answer<<TyCtxt<'tcx> as QueryContext>::Ref> {\n+            let query_or_answer = self.map_layouts(|src, dst, scope, &context| {\n+                // Convert `src` and `dst` from their rustc representations, to `Tree`-based\n+                // representations. If these conversions fail, conclude that the transmutation is\n+                // unacceptable; the layouts of both the source and destination types must be\n+                // well-defined.\n+                let src = Tree::from_ty(src, context).map_err(|err| match err {\n+                    // Answer `Yes` here, because \"Unknown Type\" will already be reported by\n+                    // rustc. No need to spam the user with more errors.\n+                    Err::Unknown => Answer::Yes,\n+                    Err::Unspecified => Answer::No(Reason::SrcIsUnspecified),\n+                })?;\n+\n+                let dst = Tree::from_ty(dst, context).map_err(|err| match err {\n+                    Err::Unknown => Answer::Yes,\n+                    Err::Unspecified => Answer::No(Reason::DstIsUnspecified),\n+                })?;\n+\n+                Ok((src, dst))\n+            });\n+\n+            match query_or_answer {\n+                Ok(query) => query.answer(),\n+                Err(answer) => answer,\n+            }\n+        }\n+    }\n+}\n+\n+impl<C> MaybeTransmutableQuery<Tree<<C as QueryContext>::Def, <C as QueryContext>::Ref>, C>\n+where\n+    C: QueryContext,\n+{\n+    /// Answers whether a `Tree` is transmutable into another `Tree`.\n+    ///\n+    /// This method begins by de-def'ing `src` and `dst`, and prunes private paths from `dst`,\n+    /// then converts `src` and `dst` to `Nfa`s, and computes an answer using those NFAs.\n+    #[inline(always)]\n+    #[tracing::instrument(skip(self), fields(src = ?self.src, dst = ?self.dst))]\n+    pub(crate) fn answer(self) -> Answer<<C as QueryContext>::Ref> {\n+        let assume_visibility = self.assume.visibility;\n+        let query_or_answer = self.map_layouts(|src, dst, scope, context| {\n+            // Remove all `Def` nodes from `src`, without checking their visibility.\n+            let src = src.prune(&|def| true);\n+\n+            tracing::trace!(src = ?src, \"pruned src\");\n+\n+            // Remove all `Def` nodes from `dst`, additionally...\n+            let dst = if assume_visibility {\n+                // ...if visibility is assumed, don't check their visibility.\n+                dst.prune(&|def| true)\n+            } else {\n+                // ...otherwise, prune away all unreachable paths through the `Dst` layout.\n+                dst.prune(&|def| context.is_accessible_from(def, scope))\n+            };\n+\n+            tracing::trace!(dst = ?dst, \"pruned dst\");\n+\n+            // Convert `src` from a tree-based representation to an NFA-based representation.\n+            // If the conversion fails because `src` is uninhabited, conclude that the transmutation\n+            // is acceptable, because instances of the `src` type do not exist.\n+            let src = Nfa::from_tree(src).map_err(|Uninhabited| Answer::Yes)?;\n+\n+            // Convert `dst` from a tree-based representation to an NFA-based representation.\n+            // If the conversion fails because `src` is uninhabited, conclude that the transmutation\n+            // is unacceptable, because instances of the `dst` type do not exist.\n+            let dst =\n+                Nfa::from_tree(dst).map_err(|Uninhabited| Answer::No(Reason::DstIsPrivate))?;\n+\n+            Ok((src, dst))\n+        });\n+\n+        match query_or_answer {\n+            Ok(query) => query.answer(),\n+            Err(answer) => answer,\n+        }\n+    }\n+}\n+\n+impl<C> MaybeTransmutableQuery<Nfa<<C as QueryContext>::Ref>, C>\n+where\n+    C: QueryContext,\n+{\n+    /// Answers whether a `Nfa` is transmutable into another `Nfa`.\n+    ///\n+    /// This method converts `src` and `dst` to DFAs, then computes an answer using those DFAs.\n+    #[inline(always)]\n+    #[tracing::instrument(skip(self), fields(src = ?self.src, dst = ?self.dst))]\n+    pub(crate) fn answer(self) -> Answer<<C as QueryContext>::Ref> {\n+        let query_or_answer = self\n+            .map_layouts(|src, dst, scope, context| Ok((Dfa::from_nfa(src), Dfa::from_nfa(dst))));\n+\n+        match query_or_answer {\n+            Ok(query) => query.answer(),\n+            Err(answer) => answer,\n+        }\n+    }\n+}\n+\n+impl<C> MaybeTransmutableQuery<Dfa<<C as QueryContext>::Ref>, C>\n+where\n+    C: QueryContext,\n+{\n+    /// Answers whether a `Nfa` is transmutable into another `Nfa`.\n+    ///\n+    /// This method converts `src` and `dst` to DFAs, then computes an answer using those DFAs.\n+    pub(crate) fn answer(self) -> Answer<<C as QueryContext>::Ref> {\n+        MaybeTransmutableQuery {\n+            src: &self.src,\n+            dst: &self.dst,\n+            scope: self.scope,\n+            assume: self.assume,\n+            context: self.context,\n+        }\n+        .answer()\n+    }\n+}\n+\n+impl<'l, C> MaybeTransmutableQuery<&'l Dfa<<C as QueryContext>::Ref>, C>\n+where\n+    C: QueryContext,\n+{\n+    pub(crate) fn answer(&mut self) -> Answer<<C as QueryContext>::Ref> {\n+        self.answer_memo(&mut Map::default(), self.src.start, self.dst.start)\n+    }\n+\n+    #[inline(always)]\n+    #[tracing::instrument(skip(self))]\n+    fn answer_memo(\n+        &self,\n+        cache: &mut Map<(dfa::State, dfa::State), Answer<<C as QueryContext>::Ref>>,\n+        src_state: dfa::State,\n+        dst_state: dfa::State,\n+    ) -> Answer<<C as QueryContext>::Ref> {\n+        if let Some(answer) = cache.get(&(src_state, dst_state)) {\n+            answer.clone()\n+        } else {\n+            let answer = if dst_state == self.dst.accepting {\n+                // truncation: `size_of(Src) >= size_of(Dst)`\n+                Answer::Yes\n+            } else if src_state == self.src.accepting {\n+                // extension: `size_of(Src) >= size_of(Dst)`\n+                if let Some(dst_state_prime) = self.dst.byte_from(dst_state, Byte::Uninit) {\n+                    self.answer_memo(cache, src_state, dst_state_prime)\n+                } else {\n+                    Answer::No(Reason::DstIsTooBig)\n+                }\n+            } else {\n+                let src_quantification = if self.assume.validity {\n+                    // if the compiler may assume that the programmer is doing additional validity checks,\n+                    // (e.g.: that `src != 3u8` when the destination type is `bool`)\n+                    // then there must exist at least one transition out of `src_state` such that the transmute is viable...\n+                    there_exists\n+                } else {\n+                    // if the compiler cannot assume that the programmer is doing additional validity checks,\n+                    // then for all transitions out of `src_state`, such that the transmute is viable...\n+                    // then there must exist at least one transition out of `src_state` such that the transmute is viable...\n+                    for_all\n+                };\n+\n+                src_quantification(\n+                    self.src.bytes_from(src_state).unwrap_or(&Map::default()),\n+                    |(&src_validity, &src_state_prime)| {\n+                        if let Some(dst_state_prime) = self.dst.byte_from(dst_state, src_validity) {\n+                            self.answer_memo(cache, src_state_prime, dst_state_prime)\n+                        } else if let Some(dst_state_prime) =\n+                            self.dst.byte_from(dst_state, Byte::Uninit)\n+                        {\n+                            self.answer_memo(cache, src_state_prime, dst_state_prime)\n+                        } else {\n+                            Answer::No(Reason::DstIsBitIncompatible)\n+                        }\n+                    },\n+                )\n+            };\n+            cache.insert((src_state, dst_state), answer.clone());\n+            answer\n+        }\n+    }\n+}\n+\n+impl<R> Answer<R>\n+where\n+    R: layout::Ref,\n+{\n+    pub(crate) fn and(self, rhs: Self) -> Self {\n+        match (self, rhs) {\n+            (Self::No(reason), _) | (_, Self::No(reason)) => Self::No(reason),\n+            (Self::Yes, Self::Yes) => Self::Yes,\n+            (Self::IfAll(mut lhs), Self::IfAll(ref mut rhs)) => {\n+                lhs.append(rhs);\n+                Self::IfAll(lhs)\n+            }\n+            (constraint, Self::IfAll(mut constraints))\n+            | (Self::IfAll(mut constraints), constraint) => {\n+                constraints.push(constraint);\n+                Self::IfAll(constraints)\n+            }\n+            (lhs, rhs) => Self::IfAll(vec![lhs, rhs]),\n+        }\n+    }\n+\n+    pub(crate) fn or(self, rhs: Self) -> Self {\n+        match (self, rhs) {\n+            (Self::Yes, _) | (_, Self::Yes) => Self::Yes,\n+            (Self::No(lhr), Self::No(rhr)) => Self::No(lhr),\n+            (Self::IfAny(mut lhs), Self::IfAny(ref mut rhs)) => {\n+                lhs.append(rhs);\n+                Self::IfAny(lhs)\n+            }\n+            (constraint, Self::IfAny(mut constraints))\n+            | (Self::IfAny(mut constraints), constraint) => {\n+                constraints.push(constraint);\n+                Self::IfAny(constraints)\n+            }\n+            (lhs, rhs) => Self::IfAny(vec![lhs, rhs]),\n+        }\n+    }\n+}\n+\n+pub fn for_all<R, I, F>(iter: I, f: F) -> Answer<R>\n+where\n+    R: layout::Ref,\n+    I: IntoIterator,\n+    F: FnMut(<I as IntoIterator>::Item) -> Answer<R>,\n+{\n+    use std::ops::ControlFlow::{Break, Continue};\n+    let (Continue(result) | Break(result)) =\n+        iter.into_iter().map(f).try_fold(Answer::Yes, |constraints, constraint| {\n+            match constraint.and(constraints) {\n+                Answer::No(reason) => Break(Answer::No(reason)),\n+                maybe => Continue(maybe),\n+            }\n+        });\n+    result\n+}\n+\n+pub fn there_exists<R, I, F>(iter: I, f: F) -> Answer<R>\n+where\n+    R: layout::Ref,\n+    I: IntoIterator,\n+    F: FnMut(<I as IntoIterator>::Item) -> Answer<R>,\n+{\n+    use std::ops::ControlFlow::{Break, Continue};\n+    let (Continue(result) | Break(result)) = iter.into_iter().map(f).try_fold(\n+        Answer::No(Reason::DstIsBitIncompatible),\n+        |constraints, constraint| match constraint.or(constraints) {\n+            Answer::Yes => Break(Answer::Yes),\n+            maybe => Continue(maybe),\n+        },\n+    );\n+    result\n+}"}, {"sha": "ab9bcd232f0d0d2fb418e9b88ecea9c47101cdeb", "filename": "compiler/rustc_transmute/src/maybe_transmutable/query_context.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fquery_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fquery_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fquery_context.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,93 @@\n+use crate::layout;\n+\n+/// Context necessary to answer the question \"Are these types transmutable?\".\n+pub(crate) trait QueryContext {\n+    type Def: layout::Def;\n+    type Ref: layout::Ref;\n+    type Scope: Copy;\n+\n+    /// Is `def` accessible from the defining module of `scope`?\n+    fn is_accessible_from(&self, def: Self::Def, scope: Self::Scope) -> bool;\n+\n+    fn min_align(&self, reference: Self::Ref) -> usize;\n+}\n+\n+#[cfg(test)]\n+pub(crate) mod test {\n+    use super::QueryContext;\n+\n+    pub(crate) struct UltraMinimal;\n+\n+    #[derive(Debug, Hash, Eq, PartialEq, Clone, Copy)]\n+    pub(crate) enum Def {\n+        Visible,\n+        Invisible,\n+    }\n+\n+    impl crate::layout::Def for Def {}\n+\n+    impl QueryContext for UltraMinimal {\n+        type Def = Def;\n+        type Ref = !;\n+        type Scope = ();\n+\n+        fn is_accessible_from(&self, def: Def, scope: ()) -> bool {\n+            matches!(Def::Visible, def)\n+        }\n+\n+        fn min_align(&self, reference: !) -> usize {\n+            unimplemented!()\n+        }\n+    }\n+}\n+\n+#[cfg(feature = \"rustc\")]\n+mod rustc {\n+    use super::*;\n+    use rustc_middle::ty::{Ty, TyCtxt};\n+\n+    impl<'tcx> super::QueryContext for TyCtxt<'tcx> {\n+        type Def = layout::rustc::Def<'tcx>;\n+        type Ref = layout::rustc::Ref<'tcx>;\n+\n+        type Scope = Ty<'tcx>;\n+\n+        #[tracing::instrument(skip(self))]\n+        fn is_accessible_from(&self, def: Self::Def, scope: Self::Scope) -> bool {\n+            use layout::rustc::Def;\n+            use rustc_middle::ty;\n+\n+            let parent = if let ty::Adt(adt_def, ..) = scope.kind() {\n+                use rustc_middle::ty::DefIdTree;\n+                let parent = self.parent(adt_def.did());\n+                parent\n+            } else {\n+                // Is this always how we want to handle a non-ADT scope?\n+                return false;\n+            };\n+\n+            let def_id = match def {\n+                Def::Adt(adt_def) => adt_def.did(),\n+                Def::Variant(variant_def) => variant_def.def_id,\n+                Def::Field(field_def) => field_def.did,\n+                Def::Primitive => {\n+                    // primitives do not have a def_id, but they're always accessible\n+                    return true;\n+                }\n+            };\n+\n+            let ret = if self.visibility(def_id).is_accessible_from(parent, *self) {\n+                true\n+            } else {\n+                false\n+            };\n+\n+            tracing::trace!(ret = ?ret, \"ret\");\n+            ret\n+        }\n+\n+        fn min_align(&self, reference: Self::Ref) -> usize {\n+            unimplemented!()\n+        }\n+    }\n+}"}, {"sha": "d9d125687f6566921a0d86dca9d0954e10b8c2e6", "filename": "compiler/rustc_transmute/src/maybe_transmutable/tests.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Ftests.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,115 @@\n+use super::query_context::test::{Def, UltraMinimal};\n+use crate::maybe_transmutable::MaybeTransmutableQuery;\n+use crate::{layout, Answer, Reason, Set};\n+use itertools::Itertools;\n+\n+mod bool {\n+    use super::*;\n+\n+    #[test]\n+    fn should_permit_identity_transmutation_tree() {\n+        println!(\"{:?}\", layout::Tree::<!, !>::bool());\n+        let answer = crate::maybe_transmutable::MaybeTransmutableQuery::new(\n+            layout::Tree::<Def, !>::bool(),\n+            layout::Tree::<Def, !>::bool(),\n+            (),\n+            crate::Assume { alignment: false, lifetimes: false, validity: true, visibility: false },\n+            UltraMinimal,\n+        )\n+        .answer();\n+        assert_eq!(answer, Answer::Yes);\n+    }\n+\n+    #[test]\n+    fn should_permit_identity_transmutation_dfa() {\n+        let answer = crate::maybe_transmutable::MaybeTransmutableQuery::new(\n+            layout::Dfa::<!>::bool(),\n+            layout::Dfa::<!>::bool(),\n+            (),\n+            crate::Assume { alignment: false, lifetimes: false, validity: true, visibility: false },\n+            UltraMinimal,\n+        )\n+        .answer();\n+        assert_eq!(answer, Answer::Yes);\n+    }\n+\n+    #[test]\n+    fn should_permit_validity_expansion_and_reject_contraction() {\n+        let un = layout::Tree::<Def, !>::uninhabited();\n+        let b0 = layout::Tree::<Def, !>::from_bits(0);\n+        let b1 = layout::Tree::<Def, !>::from_bits(1);\n+        let b2 = layout::Tree::<Def, !>::from_bits(2);\n+\n+        let alts = [b0, b1, b2];\n+\n+        let into_layout = |alts: Vec<_>| {\n+            alts.into_iter().fold(layout::Tree::<Def, !>::uninhabited(), layout::Tree::<Def, !>::or)\n+        };\n+\n+        let into_set = |alts: Vec<_>| {\n+            #[cfg(feature = \"rustc\")]\n+            let mut set = Set::default();\n+            #[cfg(not(feature = \"rustc\"))]\n+            let mut set = Set::new();\n+            set.extend(alts);\n+            set\n+        };\n+\n+        for src_alts in alts.clone().into_iter().powerset() {\n+            let src_layout = into_layout(src_alts.clone());\n+            let src_set = into_set(src_alts.clone());\n+\n+            for dst_alts in alts.clone().into_iter().powerset().filter(|alts| !alts.is_empty()) {\n+                let dst_layout = into_layout(dst_alts.clone());\n+                let dst_set = into_set(dst_alts.clone());\n+\n+                if src_set.is_subset(&dst_set) {\n+                    assert_eq!(\n+                        Answer::Yes,\n+                        MaybeTransmutableQuery::new(\n+                            src_layout.clone(),\n+                            dst_layout.clone(),\n+                            (),\n+                            crate::Assume { validity: false, ..crate::Assume::default() },\n+                            UltraMinimal,\n+                        )\n+                        .answer(),\n+                        \"{:?} SHOULD be transmutable into {:?}\",\n+                        src_layout,\n+                        dst_layout\n+                    );\n+                } else if !src_set.is_disjoint(&dst_set) {\n+                    assert_eq!(\n+                        Answer::Yes,\n+                        MaybeTransmutableQuery::new(\n+                            src_layout.clone(),\n+                            dst_layout.clone(),\n+                            (),\n+                            crate::Assume { validity: true, ..crate::Assume::default() },\n+                            UltraMinimal,\n+                        )\n+                        .answer(),\n+                        \"{:?} SHOULD be transmutable (assuming validity) into {:?}\",\n+                        src_layout,\n+                        dst_layout\n+                    );\n+                } else {\n+                    assert_eq!(\n+                        Answer::No(Reason::DstIsBitIncompatible),\n+                        MaybeTransmutableQuery::new(\n+                            src_layout.clone(),\n+                            dst_layout.clone(),\n+                            (),\n+                            crate::Assume { validity: false, ..crate::Assume::default() },\n+                            UltraMinimal,\n+                        )\n+                        .answer(),\n+                        \"{:?} should NOT be transmutable into {:?}\",\n+                        src_layout,\n+                        dst_layout\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "add65a3be5042407d5889afe04d8bee3a437ebb8", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -27,6 +27,10 @@ mod valid_align;\n // alignment as a parameter, such as `Layout::padding_needed_for`.\n pub(crate) use valid_align::ValidAlign;\n \n+mod transmutability;\n+#[unstable(feature = \"transmutability\", issue = \"none\")]\n+pub use transmutability::{Assume, BikeshedIntrinsicFrom};\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(inline)]\n pub use crate::intrinsics::transmute;"}, {"sha": "52342f8a0ecd603190761b601bdbd5e3fce0250b", "filename": "library/core/src/mem/transmutability.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/library%2Fcore%2Fsrc%2Fmem%2Ftransmutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/library%2Fcore%2Fsrc%2Fmem%2Ftransmutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Ftransmutability.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,39 @@\n+/// Are values of a type transmutable into values of another type?\n+///\n+/// This trait is implemented on-the-fly by the compiler for types `Src` and `Self` when the bits of\n+/// any value of type `Self` are safely transmutable into a value of type `Dst`, in a given `Context`,\n+/// notwithstanding whatever safety checks you have asked the compiler to [`Assume`] are satisfied.\n+#[unstable(feature = \"transmutability\", issue = \"none\")]\n+#[cfg_attr(not(bootstrap), lang = \"transmute_trait\")]\n+pub unsafe trait BikeshedIntrinsicFrom<\n+    Src,\n+    Context,\n+    const ASSUME_ALIGNMENT: bool,\n+    const ASSUME_LIFETIMES: bool,\n+    const ASSUME_VALIDITY: bool,\n+    const ASSUME_VISIBILITY: bool,\n+> where\n+    Src: ?Sized,\n+{\n+}\n+\n+/// What transmutation safety conditions shall the compiler assume that *you* are checking?\n+#[unstable(feature = \"transmutability\", issue = \"none\")]\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct Assume {\n+    /// When `true`, the compiler assumes that *you* are ensuring (either dynamically or statically) that\n+    /// destination referents do not have stricter alignment requirements than source referents.\n+    pub alignment: bool,\n+\n+    /// When `true`, the compiler assume that *you* are ensuring that lifetimes are not extended in a manner\n+    /// that violates Rust's memory model.\n+    pub lifetimes: bool,\n+\n+    /// When `true`, the compiler assumes that *you* are ensuring that the source type is actually a valid\n+    /// instance of the destination type.\n+    pub validity: bool,\n+\n+    /// When `true`, the compiler assumes that *you* have ensured that it is safe for you to violate the\n+    /// type and field privacy of the destination type (and sometimes of the source type, too).\n+    pub visibility: bool,\n+}"}, {"sha": "94c38bb28f7e20cadce116eda3014ddf33d0f66e", "filename": "src/test/ui/transmutability/abstraction/const_generic_fn.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fabstraction%2Fconst_generic_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fabstraction%2Fconst_generic_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fabstraction%2Fconst_generic_fn.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,41 @@\n+// check-pass\n+//! An array must have the correct length.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code, incomplete_features, non_camel_case_types)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn array_like<T, E, const N: usize>()\n+    where\n+        T: BikeshedIntrinsicFrom<[E; N], Context, false, false, false, true>,\n+        [E; N]: BikeshedIntrinsicFrom<T, Context, false, false, false, true>\n+    {}\n+}\n+\n+fn len_0() {\n+    type Array = [u8; 0];\n+    #[repr(C)] struct Struct();\n+    assert::array_like::<Struct, u8, 0>();\n+}\n+\n+fn len_1() {\n+    type Array = [u8; 1];\n+    #[repr(C)] struct Struct(u8);\n+    assert::array_like::<Struct, u8, 1>();\n+}\n+\n+fn len_2() {\n+    type Array = [u8; 2];\n+    #[repr(C)] struct Struct(u8, u8);\n+    assert::array_like::<Struct, u8, 2>();\n+}\n+\n+fn len_3() {\n+    type Array = [u8; 3];\n+    #[repr(C)] struct Struct(u8, u8, u8);\n+    assert::array_like::<Struct, u8, 3>();\n+}"}, {"sha": "bfe6d830a1be77864dca587ccb86213fdc7ad7c3", "filename": "src/test/ui/transmutability/arrays/should_have_correct_length.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Farrays%2Fshould_have_correct_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Farrays%2Fshould_have_correct_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Farrays%2Fshould_have_correct_length.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,44 @@\n+// check-pass\n+//! An array must have the correct length.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code, incomplete_features, non_camel_case_types)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+    {}\n+}\n+\n+fn should_have_len_0() {\n+    type Array = [u8; 0];\n+    #[repr(C)] struct Struct();\n+    assert::is_maybe_transmutable::<Array, Struct>();\n+    assert::is_maybe_transmutable::<Struct, Array>();\n+}\n+\n+fn should_have_len_1() {\n+    type Array = [u8; 1];\n+    #[repr(C)] struct Struct(u8);\n+    assert::is_maybe_transmutable::<Array, Struct>();\n+    assert::is_maybe_transmutable::<Struct, Array>();\n+}\n+\n+fn should_have_len_2() {\n+    type Array = [u8; 2];\n+    #[repr(C)] struct Struct(u8, u8);\n+    assert::is_maybe_transmutable::<Array, Struct>();\n+    assert::is_maybe_transmutable::<Struct, Array>();\n+}\n+\n+fn should_have_len_3() {\n+    type Array = [u8; 3];\n+    #[repr(C)] struct Struct(u8, u8, u8);\n+    assert::is_maybe_transmutable::<Array, Struct>();\n+    assert::is_maybe_transmutable::<Struct, Array>();\n+}"}, {"sha": "fcb1765ea6bb46206c2b35d650748027d1275243", "filename": "src/test/ui/transmutability/arrays/should_inherit_alignment.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Farrays%2Fshould_inherit_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Farrays%2Fshould_inherit_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Farrays%2Fshould_inherit_alignment.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,55 @@\n+// check-pass\n+//! An array must inherit the alignment of its inner type.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code, incomplete_features, non_camel_case_types)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+    {}\n+}\n+\n+#[derive(Clone, Copy)] #[repr(u8)] enum Ox00 { V = 0x00 }\n+#[derive(Clone, Copy)] #[repr(u8)] enum Ox01 { V = 0x01 }\n+#[derive(Clone, Copy)] #[repr(u8)] enum OxFF { V = 0xFF }\n+\n+#[repr(C)]\n+union Uninit {\n+    a: (),\n+    b: OxFF,\n+}\n+\n+#[repr(C, align(2))] struct align_2(Ox00);\n+\n+fn len_0() {\n+    #[repr(C)] struct ImplicitlyPadded([align_2; 0], Ox01);\n+    #[repr(C)] struct ExplicitlyPadded(Ox01, Uninit);\n+\n+    #[repr(C)] struct Struct();\n+    assert::is_maybe_transmutable::<ImplicitlyPadded, ExplicitlyPadded>();\n+    assert::is_maybe_transmutable::<ExplicitlyPadded, ImplicitlyPadded>();\n+}\n+\n+fn len_1() {\n+    #[repr(C)] struct ImplicitlyPadded([align_2; 1], Ox01);\n+    #[repr(C)] struct ExplicitlyPadded(Ox00, Uninit, Ox01, Uninit);\n+\n+    #[repr(C)] struct Struct();\n+    assert::is_maybe_transmutable::<ImplicitlyPadded, ExplicitlyPadded>();\n+    assert::is_maybe_transmutable::<ExplicitlyPadded, ImplicitlyPadded>();\n+}\n+\n+fn len_2() {\n+    #[repr(C)] struct ImplicitlyPadded([align_2; 2], Ox01);\n+    #[repr(C)] struct ExplicitlyPadded(Ox00, Uninit, Ox00, Uninit, Ox01, Uninit);\n+\n+    #[repr(C)] struct Struct();\n+    assert::is_maybe_transmutable::<ImplicitlyPadded, ExplicitlyPadded>();\n+    assert::is_maybe_transmutable::<ExplicitlyPadded, ImplicitlyPadded>();\n+}"}, {"sha": "36f9ceb0da7a6ba6fe3a38103268d4c2cd9361d2", "filename": "src/test/ui/transmutability/arrays/should_require_well_defined_layout.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Farrays%2Fshould_require_well_defined_layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Farrays%2Fshould_require_well_defined_layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Farrays%2Fshould_require_well_defined_layout.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,61 @@\n+//! An array must have a well-defined layout to participate in a transmutation.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code, incomplete_features, non_camel_case_types)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+    {}\n+}\n+\n+fn should_reject_repr_rust()\n+{\n+    fn unit() {\n+        type repr_rust = [String; 0];\n+        assert::is_maybe_transmutable::<repr_rust, ()>(); //~ ERROR not satisfied\n+        assert::is_maybe_transmutable::<u128, repr_rust>(); //~ ERROR not satisfied\n+    }\n+\n+    fn singleton() {\n+        type repr_rust = [String; 1];\n+        assert::is_maybe_transmutable::<repr_rust, ()>(); //~ ERROR not satisfied\n+        assert::is_maybe_transmutable::<u128, repr_rust>(); //~ ERROR not satisfied\n+    }\n+\n+    fn duplex() {\n+        type repr_rust = [String; 2];\n+        assert::is_maybe_transmutable::<repr_rust, ()>(); //~ ERROR not satisfied\n+        assert::is_maybe_transmutable::<u128, repr_rust>(); //~ ERROR not satisfied\n+    }\n+}\n+\n+fn should_accept_repr_C()\n+{\n+    fn unit() {\n+        #[repr(C)] struct repr_c(u8, u16, u8);\n+        type array = [repr_c; 0];\n+        assert::is_maybe_transmutable::<array, ()>();\n+        assert::is_maybe_transmutable::<i128, array>();\n+    }\n+\n+    fn singleton() {\n+        #[repr(C)] struct repr_c(u8, u16, u8);\n+        type array = [repr_c; 1];\n+        assert::is_maybe_transmutable::<array, repr_c>();\n+        assert::is_maybe_transmutable::<repr_c, array>();\n+    }\n+\n+    fn duplex() {\n+        #[repr(C)] struct repr_c(u8, u16, u8);\n+        #[repr(C)] struct duplex(repr_c, repr_c);\n+        type array = [repr_c; 2];\n+        assert::is_maybe_transmutable::<array, duplex>();\n+        assert::is_maybe_transmutable::<duplex, array>();\n+    }\n+}"}, {"sha": "109e58c4093cb4c28e1d3839546e008b22e5a8e9", "filename": "src/test/ui/transmutability/arrays/should_require_well_defined_layout.stderr", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Farrays%2Fshould_require_well_defined_layout.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Farrays%2Fshould_require_well_defined_layout.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Farrays%2Fshould_require_well_defined_layout.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,93 @@\n+error[E0277]: the trait bound `(): BikeshedIntrinsicFrom<[String; 0], assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:21:52\n+   |\n+LL |         assert::is_maybe_transmutable::<repr_rust, ()>();\n+   |                                                    ^^ the trait `BikeshedIntrinsicFrom<[String; 0], assert::Context, true, true, true, true>` is not implemented for `()`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `[String; 0]: BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:22:47\n+   |\n+LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n+   |                                               ^^^^^^^^^ the trait `BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not implemented for `[String; 0]`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `(): BikeshedIntrinsicFrom<[String; 1], assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:27:52\n+   |\n+LL |         assert::is_maybe_transmutable::<repr_rust, ()>();\n+   |                                                    ^^ the trait `BikeshedIntrinsicFrom<[String; 1], assert::Context, true, true, true, true>` is not implemented for `()`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `[String; 1]: BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:28:47\n+   |\n+LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n+   |                                               ^^^^^^^^^ the trait `BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not implemented for `[String; 1]`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `(): BikeshedIntrinsicFrom<[String; 2], assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:33:52\n+   |\n+LL |         assert::is_maybe_transmutable::<repr_rust, ()>();\n+   |                                                    ^^ the trait `BikeshedIntrinsicFrom<[String; 2], assert::Context, true, true, true, true>` is not implemented for `()`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `[String; 2]: BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:34:47\n+   |\n+LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n+   |                                               ^^^^^^^^^ the trait `BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not implemented for `[String; 2]`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "cd411a4b838e070fc4681f771088c927d7bc2ea2", "filename": "src/test/ui/transmutability/enums/repr/primitive_reprs_should_have_correct_length.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Frepr%2Fprimitive_reprs_should_have_correct_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Frepr%2Fprimitive_reprs_should_have_correct_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Frepr%2Fprimitive_reprs_should_have_correct_length.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,149 @@\n+//! An enum with a primitive repr should have exactly the size of that primitive.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+\n+    pub fn is_transmutable<Src, Dst, Context>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+    {}\n+}\n+\n+#[repr(C)]\n+struct Zst;\n+\n+#[derive(Clone, Copy)]\n+#[repr(i8)] enum V0i8 { V }\n+#[repr(u8)] enum V0u8 { V }\n+#[repr(i16)] enum V0i16 { V }\n+#[repr(u16)] enum V0u16 { V }\n+#[repr(i32)] enum V0i32 { V }\n+#[repr(u32)] enum V0u32 { V }\n+#[repr(i64)] enum V0i64 { V }\n+#[repr(u64)] enum V0u64 { V }\n+#[repr(isize)] enum V0isize { V }\n+#[repr(usize)] enum V0usize { V }\n+\n+fn n8() {\n+    struct Context;\n+\n+    type Smaller = Zst;\n+    type Analog = u8;\n+    type Larger = u16;\n+\n+    fn i_should_have_correct_length() {\n+        type Current = V0i8;\n+\n+        assert::is_transmutable::<Smaller, Current, Context>(); //~ ERROR not satisfied\n+        assert::is_transmutable::<Current, Analog, Context>();\n+        assert::is_transmutable::<Current, Larger, Context>(); //~ ERROR not satisfied\n+    }\n+\n+    fn u_should_have_correct_length() {\n+        type Current = V0u8;\n+\n+        assert::is_transmutable::<Smaller, Current, Context>(); //~ ERROR not satisfied\n+        assert::is_transmutable::<Current, Analog, Context>();\n+        assert::is_transmutable::<Current, Larger, Context>(); //~ ERROR not satisfied\n+    }\n+}\n+\n+fn n16() {\n+    struct Context;\n+\n+    type Smaller = u8;\n+    type Analog = u16;\n+    type Larger = u32;\n+\n+    fn i_should_have_correct_length() {\n+        type Current = V0i16;\n+\n+        assert::is_transmutable::<Smaller, Current, Context>(); //~ ERROR not satisfied\n+        assert::is_transmutable::<Current, Analog, Context>();\n+        assert::is_transmutable::<Current, Larger, Context>(); //~ ERROR not satisfied\n+    }\n+\n+    fn u_should_have_correct_length() {\n+        type Current = V0u16;\n+\n+        assert::is_transmutable::<Smaller, Current, Context>(); //~ ERROR not satisfied\n+        assert::is_transmutable::<Current, Analog, Context>();\n+        assert::is_transmutable::<Current, Larger, Context>(); //~ ERROR not satisfied\n+    }\n+}\n+\n+fn n32() {\n+    struct Context;\n+\n+    type Smaller = u16;\n+    type Analog = u32;\n+    type Larger = u64;\n+\n+    fn i_should_have_correct_length() {\n+        type Current = V0i32;\n+\n+        assert::is_transmutable::<Smaller, Current, Context>(); //~ ERROR not satisfied\n+        assert::is_transmutable::<Current, Analog, Context>();\n+        assert::is_transmutable::<Current, Larger, Context>(); //~ ERROR not satisfied\n+    }\n+\n+    fn u_should_have_correct_length() {\n+        type Current = V0u32;\n+\n+        assert::is_transmutable::<Smaller, Current, Context>(); //~ ERROR not satisfied\n+        assert::is_transmutable::<Current, Analog, Context>();\n+        assert::is_transmutable::<Current, Larger, Context>(); //~ ERROR not satisfied\n+    }\n+}\n+\n+fn n64() {\n+    struct Context;\n+\n+    type Smaller = u32;\n+    type Analog = u64;\n+    type Larger = u128;\n+\n+    fn i_should_have_correct_length() {\n+        type Current = V0i64;\n+\n+        assert::is_transmutable::<Smaller, Current, Context>(); //~ ERROR not satisfied\n+        assert::is_transmutable::<Current, Analog, Context>();\n+        assert::is_transmutable::<Current, Larger, Context>(); //~ ERROR not satisfied\n+    }\n+\n+    fn u_should_have_correct_length() {\n+        type Current = V0u64;\n+\n+        assert::is_transmutable::<Smaller, Current, Context>(); //~ ERROR not satisfied\n+        assert::is_transmutable::<Current, Analog, Context>();\n+        assert::is_transmutable::<Current, Larger, Context>(); //~ ERROR not satisfied\n+    }\n+}\n+\n+fn nsize() {\n+    struct Context;\n+\n+    type Smaller = u8;\n+    type Analog = usize;\n+    type Larger = [usize; 2];\n+\n+    fn i_should_have_correct_length() {\n+        type Current = V0isize;\n+\n+        assert::is_transmutable::<Smaller, Current, Context>(); //~ ERROR not satisfied\n+        assert::is_transmutable::<Current, Analog, Context>();\n+        assert::is_transmutable::<Current, Larger, Context>(); //~ ERROR not satisfied\n+    }\n+\n+    fn u_should_have_correct_length() {\n+        type Current = V0usize;\n+\n+        assert::is_transmutable::<Smaller, Current, Context>(); //~ ERROR not satisfied\n+        assert::is_transmutable::<Current, Analog, Context>();\n+        assert::is_transmutable::<Current, Larger, Context>(); //~ ERROR not satisfied\n+    }\n+}"}, {"sha": "da24c6a021efef01015a3c93f493ab0d9455250c", "filename": "src/test/ui/transmutability/enums/repr/primitive_reprs_should_have_correct_length.stderr", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Frepr%2Fprimitive_reprs_should_have_correct_length.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Frepr%2Fprimitive_reprs_should_have_correct_length.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Frepr%2Fprimitive_reprs_should_have_correct_length.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,303 @@\n+error[E0277]: the trait bound `V0i8: BikeshedIntrinsicFrom<Zst, n8::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:41:44\n+   |\n+LL |         assert::is_transmutable::<Smaller, Current, Context>();\n+   |                                            ^^^^^^^ the trait `BikeshedIntrinsicFrom<Zst, n8::Context, true, true, true, true>` is not implemented for `V0i8`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u16: BikeshedIntrinsicFrom<V0i8, n8::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:43:44\n+   |\n+LL |         assert::is_transmutable::<Current, Larger, Context>();\n+   |                                            ^^^^^^ the trait `BikeshedIntrinsicFrom<V0i8, n8::Context, true, true, true, true>` is not implemented for `u16`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `V0u8: BikeshedIntrinsicFrom<Zst, n8::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:49:44\n+   |\n+LL |         assert::is_transmutable::<Smaller, Current, Context>();\n+   |                                            ^^^^^^^ the trait `BikeshedIntrinsicFrom<Zst, n8::Context, true, true, true, true>` is not implemented for `V0u8`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u16: BikeshedIntrinsicFrom<V0u8, n8::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:51:44\n+   |\n+LL |         assert::is_transmutable::<Current, Larger, Context>();\n+   |                                            ^^^^^^ the trait `BikeshedIntrinsicFrom<V0u8, n8::Context, true, true, true, true>` is not implemented for `u16`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `V0i16: BikeshedIntrinsicFrom<u8, n16::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:65:44\n+   |\n+LL |         assert::is_transmutable::<Smaller, Current, Context>();\n+   |                                            ^^^^^^^ the trait `BikeshedIntrinsicFrom<u8, n16::Context, true, true, true, true>` is not implemented for `V0i16`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u32: BikeshedIntrinsicFrom<V0i16, n16::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:67:44\n+   |\n+LL |         assert::is_transmutable::<Current, Larger, Context>();\n+   |                                            ^^^^^^ the trait `BikeshedIntrinsicFrom<V0i16, n16::Context, true, true, true, true>` is not implemented for `u32`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `V0u16: BikeshedIntrinsicFrom<u8, n16::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:73:44\n+   |\n+LL |         assert::is_transmutable::<Smaller, Current, Context>();\n+   |                                            ^^^^^^^ the trait `BikeshedIntrinsicFrom<u8, n16::Context, true, true, true, true>` is not implemented for `V0u16`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u32: BikeshedIntrinsicFrom<V0u16, n16::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:75:44\n+   |\n+LL |         assert::is_transmutable::<Current, Larger, Context>();\n+   |                                            ^^^^^^ the trait `BikeshedIntrinsicFrom<V0u16, n16::Context, true, true, true, true>` is not implemented for `u32`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `V0i32: BikeshedIntrinsicFrom<u16, n32::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:89:44\n+   |\n+LL |         assert::is_transmutable::<Smaller, Current, Context>();\n+   |                                            ^^^^^^^ the trait `BikeshedIntrinsicFrom<u16, n32::Context, true, true, true, true>` is not implemented for `V0i32`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u64: BikeshedIntrinsicFrom<V0i32, n32::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:91:44\n+   |\n+LL |         assert::is_transmutable::<Current, Larger, Context>();\n+   |                                            ^^^^^^ the trait `BikeshedIntrinsicFrom<V0i32, n32::Context, true, true, true, true>` is not implemented for `u64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `V0u32: BikeshedIntrinsicFrom<u16, n32::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:97:44\n+   |\n+LL |         assert::is_transmutable::<Smaller, Current, Context>();\n+   |                                            ^^^^^^^ the trait `BikeshedIntrinsicFrom<u16, n32::Context, true, true, true, true>` is not implemented for `V0u32`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u64: BikeshedIntrinsicFrom<V0u32, n32::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:99:44\n+   |\n+LL |         assert::is_transmutable::<Current, Larger, Context>();\n+   |                                            ^^^^^^ the trait `BikeshedIntrinsicFrom<V0u32, n32::Context, true, true, true, true>` is not implemented for `u64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `V0i64: BikeshedIntrinsicFrom<u32, n64::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:113:44\n+   |\n+LL |         assert::is_transmutable::<Smaller, Current, Context>();\n+   |                                            ^^^^^^^ the trait `BikeshedIntrinsicFrom<u32, n64::Context, true, true, true, true>` is not implemented for `V0i64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u128: BikeshedIntrinsicFrom<V0i64, n64::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:115:44\n+   |\n+LL |         assert::is_transmutable::<Current, Larger, Context>();\n+   |                                            ^^^^^^ the trait `BikeshedIntrinsicFrom<V0i64, n64::Context, true, true, true, true>` is not implemented for `u128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `V0u64: BikeshedIntrinsicFrom<u32, n64::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:121:44\n+   |\n+LL |         assert::is_transmutable::<Smaller, Current, Context>();\n+   |                                            ^^^^^^^ the trait `BikeshedIntrinsicFrom<u32, n64::Context, true, true, true, true>` is not implemented for `V0u64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u128: BikeshedIntrinsicFrom<V0u64, n64::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:123:44\n+   |\n+LL |         assert::is_transmutable::<Current, Larger, Context>();\n+   |                                            ^^^^^^ the trait `BikeshedIntrinsicFrom<V0u64, n64::Context, true, true, true, true>` is not implemented for `u128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `V0isize: BikeshedIntrinsicFrom<u8, nsize::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:137:44\n+   |\n+LL |         assert::is_transmutable::<Smaller, Current, Context>();\n+   |                                            ^^^^^^^ the trait `BikeshedIntrinsicFrom<u8, nsize::Context, true, true, true, true>` is not implemented for `V0isize`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `[usize; 2]: BikeshedIntrinsicFrom<V0isize, nsize::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:139:44\n+   |\n+LL |         assert::is_transmutable::<Current, Larger, Context>();\n+   |                                            ^^^^^^ the trait `BikeshedIntrinsicFrom<V0isize, nsize::Context, true, true, true, true>` is not implemented for `[usize; 2]`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `V0usize: BikeshedIntrinsicFrom<u8, nsize::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:145:44\n+   |\n+LL |         assert::is_transmutable::<Smaller, Current, Context>();\n+   |                                            ^^^^^^^ the trait `BikeshedIntrinsicFrom<u8, nsize::Context, true, true, true, true>` is not implemented for `V0usize`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `[usize; 2]: BikeshedIntrinsicFrom<V0usize, nsize::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:147:44\n+   |\n+LL |         assert::is_transmutable::<Current, Larger, Context>();\n+   |                                            ^^^^^^ the trait `BikeshedIntrinsicFrom<V0usize, nsize::Context, true, true, true, true>` is not implemented for `[usize; 2]`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error: aborting due to 20 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "24a88d6ac95cc9e45a9aadc255f550308bc1f1fb", "filename": "src/test/ui/transmutability/enums/repr/should_require_well_defined_layout.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Frepr%2Fshould_require_well_defined_layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Frepr%2Fshould_require_well_defined_layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Frepr%2Fshould_require_well_defined_layout.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,117 @@\n+//! An enum must have a well-defined layout to participate in a transmutation.\n+\n+#![crate_type = \"lib\"]\n+#![feature(repr128)]\n+#![feature(transmutability)]\n+#![allow(dead_code, incomplete_features, non_camel_case_types)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+    {}\n+}\n+\n+fn should_reject_repr_rust() {\n+    fn void() {\n+        enum repr_rust {}\n+        assert::is_maybe_transmutable::<repr_rust, ()>(); //~ ERROR not satisfied\n+        assert::is_maybe_transmutable::<u128, repr_rust>(); //~ ERROR not satisfied\n+    }\n+\n+    fn singleton() {\n+        enum repr_rust { V }\n+        assert::is_maybe_transmutable::<repr_rust, ()>(); //~ ERROR not satisfied\n+        assert::is_maybe_transmutable::<u128, repr_rust>(); //~ ERROR not satisfied\n+    }\n+\n+    fn duplex() {\n+        enum repr_rust { A, B }\n+        assert::is_maybe_transmutable::<repr_rust, ()>(); //~ ERROR not satisfied\n+        assert::is_maybe_transmutable::<u128, repr_rust>(); //~ ERROR not satisfied\n+    }\n+}\n+\n+fn should_accept_primitive_reprs()\n+{\n+    fn should_accept_repr_i8() {\n+        #[repr(i8)] enum repr_i8 { V }\n+        assert::is_maybe_transmutable::<repr_i8, ()>();\n+        assert::is_maybe_transmutable::<i8, repr_i8>();\n+    }\n+\n+    fn should_accept_repr_u8() {\n+        #[repr(u8)] enum repr_u8 { V }\n+        assert::is_maybe_transmutable::<repr_u8, ()>();\n+        assert::is_maybe_transmutable::<u8, repr_u8>();\n+    }\n+\n+    fn should_accept_repr_i16() {\n+        #[repr(i16)] enum repr_i16 { V }\n+        assert::is_maybe_transmutable::<repr_i16, ()>();\n+        assert::is_maybe_transmutable::<i16, repr_i16>();\n+    }\n+\n+    fn should_accept_repr_u16() {\n+        #[repr(u16)] enum repr_u16 { V }\n+        assert::is_maybe_transmutable::<repr_u16, ()>();\n+        assert::is_maybe_transmutable::<u16, repr_u16>();\n+    }\n+\n+    fn should_accept_repr_i32() {\n+        #[repr(i32)] enum repr_i32 { V }\n+        assert::is_maybe_transmutable::<repr_i32, ()>();\n+        assert::is_maybe_transmutable::<i32, repr_i32>();\n+    }\n+\n+    fn should_accept_repr_u32() {\n+        #[repr(u32)] enum repr_u32 { V }\n+        assert::is_maybe_transmutable::<repr_u32, ()>();\n+        assert::is_maybe_transmutable::<u32, repr_u32>();\n+    }\n+\n+    fn should_accept_repr_i64() {\n+        #[repr(i64)] enum repr_i64 { V }\n+        assert::is_maybe_transmutable::<repr_i64, ()>();\n+        assert::is_maybe_transmutable::<i64, repr_i64>();\n+    }\n+\n+    fn should_accept_repr_u64() {\n+        #[repr(u64)] enum repr_u64 { V }\n+        assert::is_maybe_transmutable::<repr_u64, ()>();\n+        assert::is_maybe_transmutable::<u64, repr_u64>();\n+    }\n+\n+    fn should_accept_repr_i128() {\n+        #[repr(i128)] enum repr_i128 { V }\n+        assert::is_maybe_transmutable::<repr_i128, ()>();\n+        assert::is_maybe_transmutable::<i128, repr_i128>();\n+    }\n+\n+    fn should_accept_repr_u128() {\n+        #[repr(u128)] enum repr_u128 { V }\n+        assert::is_maybe_transmutable::<repr_u128, ()>();\n+        assert::is_maybe_transmutable::<u128, repr_u128>();\n+    }\n+\n+    fn should_accept_repr_isize() {\n+        #[repr(isize)] enum repr_isize { V }\n+        assert::is_maybe_transmutable::<repr_isize, ()>();\n+        assert::is_maybe_transmutable::<isize, repr_isize>();\n+    }\n+\n+    fn should_accept_repr_usize() {\n+        #[repr(usize)] enum repr_usize { V }\n+        assert::is_maybe_transmutable::<repr_usize, ()>();\n+        assert::is_maybe_transmutable::<usize, repr_usize>();\n+    }\n+}\n+\n+fn should_accept_repr_C() {\n+    #[repr(C)] enum repr_c { V }\n+    assert::is_maybe_transmutable::<repr_c, ()>();\n+    assert::is_maybe_transmutable::<i128, repr_c>();\n+}"}, {"sha": "1bfbff68f06cb9fe643ff58f2938b76b8d671c20", "filename": "src/test/ui/transmutability/enums/repr/should_require_well_defined_layout.stderr", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Frepr%2Fshould_require_well_defined_layout.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Frepr%2Fshould_require_well_defined_layout.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Frepr%2Fshould_require_well_defined_layout.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,93 @@\n+error[E0277]: the trait bound `(): BikeshedIntrinsicFrom<void::repr_rust, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:21:52\n+   |\n+LL |         assert::is_maybe_transmutable::<repr_rust, ()>();\n+   |                                                    ^^ the trait `BikeshedIntrinsicFrom<void::repr_rust, assert::Context, true, true, true, true>` is not implemented for `()`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:14:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `void::repr_rust: BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:22:47\n+   |\n+LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n+   |                                               ^^^^^^^^^ the trait `BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not implemented for `void::repr_rust`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:14:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `(): BikeshedIntrinsicFrom<singleton::repr_rust, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:27:52\n+   |\n+LL |         assert::is_maybe_transmutable::<repr_rust, ()>();\n+   |                                                    ^^ the trait `BikeshedIntrinsicFrom<singleton::repr_rust, assert::Context, true, true, true, true>` is not implemented for `()`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:14:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `singleton::repr_rust: BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:28:47\n+   |\n+LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n+   |                                               ^^^^^^^^^ the trait `BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not implemented for `singleton::repr_rust`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:14:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `(): BikeshedIntrinsicFrom<duplex::repr_rust, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:33:52\n+   |\n+LL |         assert::is_maybe_transmutable::<repr_rust, ()>();\n+   |                                                    ^^ the trait `BikeshedIntrinsicFrom<duplex::repr_rust, assert::Context, true, true, true, true>` is not implemented for `()`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:14:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `duplex::repr_rust: BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:34:47\n+   |\n+LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n+   |                                               ^^^^^^^^^ the trait `BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not implemented for `duplex::repr_rust`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:14:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "6558d2658ee455fc2ff7ce5e8838543116273db7", "filename": "src/test/ui/transmutability/enums/should_order_correctly.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Fshould_order_correctly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Fshould_order_correctly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Fshould_order_correctly.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,32 @@\n+// check-pass\n+//! The payloads of an enum variant should be ordered after its tag.\n+\n+#![crate_type = \"lib\"]\n+#![feature(arbitrary_enum_discriminant)]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+    {}\n+}\n+\n+#[repr(u8)] enum V0 { V = 0 }\n+#[repr(u8)] enum V1 { V = 1 }\n+#[repr(u8)] enum V2 { V = 2 }\n+\n+#[repr(u8)] enum E01 { V0(V1) = 0u8 }\n+#[repr(u8)] enum E012 { V0(V1, V2) = 0u8 }\n+\n+fn should_order_tag_and_fields_correctly() {\n+    // An implementation that (incorrectly) arranges E01 as [0x01, 0x00] will,\n+    // in principle, reject this transmutation.\n+    assert::is_transmutable::<E01, V0>();\n+    // Again, but with one more field.\n+    assert::is_transmutable::<E012, E01>();\n+}"}, {"sha": "87951586523deab29e26d6ea1972bd6beccc6d1d", "filename": "src/test/ui/transmutability/enums/should_pad_variants.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Fshould_pad_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Fshould_pad_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Fshould_pad_variants.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,40 @@\n+//! The variants of an enum must be padded with uninit bytes such that they have\n+//! the same length (in bytes).\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+\n+    pub fn is_transmutable<Src, Dst, Context>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+    {}\n+}\n+\n+#[derive(Clone, Copy)]\n+#[repr(C)] struct Zst;\n+\n+#[derive(Clone, Copy)]\n+#[repr(u8)] enum V0 { V = 0 }\n+\n+#[derive(Clone, Copy)]\n+#[repr(u8)] enum V2 { V = 2 }\n+\n+#[repr(C, u8)]\n+enum Lopsided {\n+    Smol(Zst),\n+    Lorg(V0),\n+}\n+\n+#[repr(C)] struct Src(V0, Zst, V2);\n+#[repr(C)] struct Dst(Lopsided, V2);\n+\n+fn should_pad_variants() {\n+    struct Context;\n+    // If the implementation (incorrectly) fails to pad `Lopsided::Smol` with\n+    // an uninitialized byte, this transmutation might be (wrongly) accepted:\n+    assert::is_transmutable::<Src, Dst, Context>(); //~ ERROR not satisfied\n+}"}, {"sha": "b940ca077d4ad93c265c81d09c6ad1596508caf4", "filename": "src/test/ui/transmutability/enums/should_pad_variants.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Fshould_pad_variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Fshould_pad_variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Fshould_pad_variants.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: the trait bound `Dst: BikeshedIntrinsicFrom<Src, should_pad_variants::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_pad_variants.rs:39:36\n+   |\n+LL |     assert::is_transmutable::<Src, Dst, Context>();\n+   |                                    ^^^ the trait `BikeshedIntrinsicFrom<Src, should_pad_variants::Context, true, true, true, true>` is not implemented for `Dst`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/should_pad_variants.rs:13:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "9bab44e1d914fc8196cf397c399e26469db4b6f4", "filename": "src/test/ui/transmutability/enums/should_respect_endianness.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Fshould_respect_endianness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Fshould_respect_endianness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Fshould_respect_endianness.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,33 @@\n+//! The target endianness should be a consideration in computing the layout of\n+//! an enum with a multi-byte tag.\n+\n+#![crate_type = \"lib\"]\n+#![feature(arbitrary_enum_discriminant)]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+    {}\n+}\n+\n+#[repr(u16)] enum Src { V = 0xCAFE }\n+\n+#[repr(u8)] enum OxCA { V = 0xCA }\n+#[repr(u8)] enum OxFE { V = 0xFE }\n+\n+#[cfg(target_endian = \"big\")] #[repr(C)] struct Expected(OxCA, OxFE);\n+#[cfg(target_endian = \"big\")] #[repr(C)] struct Unexpected(OxFE, OxCA);\n+\n+#[cfg(target_endian = \"little\")] #[repr(C)] struct Expected(OxFE, OxCA);\n+#[cfg(target_endian = \"little\")] #[repr(C)] struct Unexpected(OxCA, OxFE);\n+\n+fn should_respect_endianness() {\n+    assert::is_transmutable::<Src, Expected>();\n+    assert::is_transmutable::<Src, Unexpected>(); //~ ERROR not satisfied\n+}"}, {"sha": "3f3335d4a1b8fba1c9268876481fa22d94cdb868", "filename": "src/test/ui/transmutability/enums/should_respect_endianness.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Fshould_respect_endianness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Fshould_respect_endianness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fenums%2Fshould_respect_endianness.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: the trait bound `Unexpected: BikeshedIntrinsicFrom<Src, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_respect_endianness.rs:32:36\n+   |\n+LL |     assert::is_transmutable::<Src, Unexpected>();\n+   |                                    ^^^^^^^^^^ the trait `BikeshedIntrinsicFrom<Src, assert::Context, true, true, true, true>` is not implemented for `Unexpected`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/should_respect_endianness.rs:15:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "e13462d390b0302b4da240b27623ab79ab672dc4", "filename": "src/test/ui/transmutability/malformed-program-gracefulness/unknown_dst.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_dst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_dst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_dst.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,21 @@\n+// An unknown destination type should be gracefully handled.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code, incomplete_features, non_camel_case_types)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_transmutable<Src, Dst, Context>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+    {}\n+}\n+\n+fn should_gracefully_handle_unknown_dst() {\n+    struct Context;\n+    struct Src;\n+    assert::is_transmutable::<Src, Dst, Context>(); //~ cannot find type\n+}"}, {"sha": "85087282d3a6e5b86cf318a396484f3b27516925", "filename": "src/test/ui/transmutability/malformed-program-gracefulness/unknown_dst.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_dst.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_dst.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_dst.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,12 @@\n+error[E0412]: cannot find type `Dst` in this scope\n+  --> $DIR/unknown_dst.rs:20:36\n+   |\n+LL | fn should_gracefully_handle_unknown_dst() {\n+   |                                        - help: you might be missing a type parameter: `<Dst>`\n+...\n+LL |     assert::is_transmutable::<Src, Dst, Context>();\n+   |                                    ^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "dc51e2a8f4d2b65c58106c7ce90a970d3378958f", "filename": "src/test/ui/transmutability/malformed-program-gracefulness/unknown_src.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,21 @@\n+// An unknown source type should be gracefully handled.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code, incomplete_features, non_camel_case_types)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_transmutable<Src, Dst, Context>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+    {}\n+}\n+\n+fn should_gracefully_handle_unknown_src() {\n+    struct Context;\n+    #[repr(C)] struct Dst;\n+    assert::is_transmutable::<Src, Dst, Context>(); //~ cannot find type\n+}"}, {"sha": "9bedbe87c3f7fc50befd8a207e01fcc6150c25e7", "filename": "src/test/ui/transmutability/malformed-program-gracefulness/unknown_src.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,12 @@\n+error[E0412]: cannot find type `Src` in this scope\n+  --> $DIR/unknown_src.rs:20:31\n+   |\n+LL | fn should_gracefully_handle_unknown_src() {\n+   |                                        - help: you might be missing a type parameter: `<Src>`\n+...\n+LL |     assert::is_transmutable::<Src, Dst, Context>();\n+   |                               ^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "86fc8bd6b28568230b434e28f8dc890bc15c04fa", "filename": "src/test/ui/transmutability/malformed-program-gracefulness/unknown_src_field.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src_field.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,22 @@\n+// An unknown destination type should be gracefully handled.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code, incomplete_features, non_camel_case_types)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_transmutable<Src, Dst, Context>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+    {}\n+}\n+\n+fn should_gracefully_handle_unknown_dst_field() {\n+    struct Context;\n+    #[repr(C)] struct Src;\n+    #[repr(C)] struct Dst(Missing); //~ cannot find type\n+    assert::is_transmutable::<Src, Dst, Context>();\n+}"}, {"sha": "475e6f429f3c995c5cf909c9b95f9e54a7029018", "filename": "src/test/ui/transmutability/malformed-program-gracefulness/unknown_src_field.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src_field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src_field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src_field.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,9 @@\n+error[E0412]: cannot find type `Missing` in this scope\n+  --> $DIR/unknown_src_field.rs:20:27\n+   |\n+LL |     #[repr(C)] struct Dst(Missing);\n+   |                           ^^^^^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "13cecd1d8b7ea0904009237cab9ecbe2920f8199", "filename": "src/test/ui/transmutability/primitives/bool.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fprimitives%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fprimitives%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fprimitives%2Fbool.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,25 @@\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+#![allow(incomplete_features)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, true>\n+    {}\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, true, true>\n+    {}\n+}\n+\n+fn contrast_with_u8() {\n+    assert::is_transmutable::<u8, bool>(); //~ ERROR not satisfied\n+    assert::is_maybe_transmutable::<u8, bool>();\n+    assert::is_transmutable::<bool, u8>();\n+}"}, {"sha": "f05bb433ec84474fb0d4e9ab487123840c09bd0f", "filename": "src/test/ui/transmutability/primitives/bool.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fprimitives%2Fbool.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fprimitives%2Fbool.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fprimitives%2Fbool.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: the trait bound `bool: BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, true>` is not satisfied\n+  --> $DIR/bool.rs:22:35\n+   |\n+LL |     assert::is_transmutable::<u8, bool>();\n+   |                                   ^^^^ the trait `BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, true>` is not implemented for `bool`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/bool.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "3dbdfab9686a8958b1e9d9db0d767e899ef0db19", "filename": "src/test/ui/transmutability/primitives/numbers.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fprimitives%2Fnumbers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fprimitives%2Fnumbers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fprimitives%2Fnumbers.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,128 @@\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+#![allow(incomplete_features)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    struct Context;\n+\n+    pub fn is_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+    {}\n+}\n+\n+fn should_accept_identity() {\n+    assert::is_transmutable::<   i8,    i8>();\n+    assert::is_transmutable::<   u8,    u8>();\n+    assert::is_transmutable::<  i16,   i16>();\n+    assert::is_transmutable::<  u16,   u16>();\n+    assert::is_transmutable::<  i32,   i32>();\n+    assert::is_transmutable::<  f32,   f32>();\n+    assert::is_transmutable::<  u32,   u32>();\n+    assert::is_transmutable::<  i64,   i64>();\n+    assert::is_transmutable::<  f64,   f64>();\n+    assert::is_transmutable::<  u64,   u64>();\n+    assert::is_transmutable::< i128,  i128>();\n+    assert::is_transmutable::< u128,  u128>();\n+    assert::is_transmutable::<isize, isize>();\n+    assert::is_transmutable::<usize, usize>();\n+}\n+\n+fn should_be_bitransmutable() {\n+    assert::is_transmutable::<   i8,    u8>();\n+    assert::is_transmutable::<   u8,    i8>();\n+\n+    assert::is_transmutable::<  i16,   u16>();\n+    assert::is_transmutable::<  u16,   i16>();\n+\n+    assert::is_transmutable::<  i32,   f32>();\n+    assert::is_transmutable::<  i32,   u32>();\n+    assert::is_transmutable::<  f32,   i32>();\n+    assert::is_transmutable::<  f32,   u32>();\n+    assert::is_transmutable::<  u32,   i32>();\n+    assert::is_transmutable::<  u32,   f32>();\n+\n+    assert::is_transmutable::<  u64,   i64>();\n+    assert::is_transmutable::<  u64,   f64>();\n+    assert::is_transmutable::<  i64,   u64>();\n+    assert::is_transmutable::<  i64,   f64>();\n+    assert::is_transmutable::<  f64,   u64>();\n+    assert::is_transmutable::<  f64,   i64>();\n+\n+    assert::is_transmutable::< u128,  i128>();\n+    assert::is_transmutable::< i128,  u128>();\n+\n+    assert::is_transmutable::<isize, usize>();\n+    assert::is_transmutable::<usize, isize>();\n+}\n+\n+fn should_reject_extension() {\n+    assert::is_transmutable::<   i8,   i16>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<   i8,   u16>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<   i8,   i32>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<   i8,   f32>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<   i8,   u32>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<   i8,   u64>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<   i8,   i64>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<   i8,   f64>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<   i8,  u128>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<   i8,  i128>(); //~ ERROR not satisfied\n+\n+    assert::is_transmutable::<   u8,   i16>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<   u8,   u16>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<   u8,   i32>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<   u8,   f32>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<   u8,   u32>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<   u8,   u64>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<   u8,   i64>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<   u8,   f64>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<   u8,  u128>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<   u8,  i128>(); //~ ERROR not satisfied\n+\n+    assert::is_transmutable::<  i16,   i32>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  i16,   f32>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  i16,   u32>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  i16,   u64>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  i16,   i64>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  i16,   f64>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  i16,  u128>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  i16,  i128>(); //~ ERROR not satisfied\n+\n+    assert::is_transmutable::<  u16,   i32>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  u16,   f32>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  u16,   u32>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  u16,   u64>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  u16,   i64>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  u16,   f64>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  u16,  u128>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  u16,  i128>(); //~ ERROR not satisfied\n+\n+    assert::is_transmutable::<  i32,   u64>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  i32,   i64>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  i32,   f64>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  i32,  u128>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  i32,  i128>(); //~ ERROR not satisfied\n+\n+    assert::is_transmutable::<  f32,   u64>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  f32,   i64>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  f32,   f64>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  f32,  u128>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  f32,  i128>(); //~ ERROR not satisfied\n+\n+    assert::is_transmutable::<  u32,   u64>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  u32,   i64>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  u32,   f64>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  u32,  u128>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  u32,  i128>(); //~ ERROR not satisfied\n+\n+    assert::is_transmutable::<  u64,  u128>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  u64,  i128>(); //~ ERROR not satisfied\n+\n+    assert::is_transmutable::<  i64,  u128>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  i64,  i128>(); //~ ERROR not satisfied\n+\n+    assert::is_transmutable::<  f64,  u128>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<  f64,  i128>(); //~ ERROR not satisfied\n+}"}, {"sha": "6bd3379dfd1a4141835bade2863120d44004fb1e", "filename": "src/test/ui/transmutability/primitives/numbers.stderr", "status": "added", "additions": 858, "deletions": 0, "changes": 858, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fprimitives%2Fnumbers.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fprimitives%2Fnumbers.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fprimitives%2Fnumbers.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,858 @@\n+error[E0277]: the trait bound `i16: BikeshedIntrinsicFrom<i8, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:62:40\n+   |\n+LL |     assert::is_transmutable::<   i8,   i16>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<i8, assert::Context, false, false, false, false>` is not implemented for `i16`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u16: BikeshedIntrinsicFrom<i8, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:63:40\n+   |\n+LL |     assert::is_transmutable::<   i8,   u16>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<i8, assert::Context, false, false, false, false>` is not implemented for `u16`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i32: BikeshedIntrinsicFrom<i8, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:64:40\n+   |\n+LL |     assert::is_transmutable::<   i8,   i32>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<i8, assert::Context, false, false, false, false>` is not implemented for `i32`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `f32: BikeshedIntrinsicFrom<i8, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:65:40\n+   |\n+LL |     assert::is_transmutable::<   i8,   f32>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<i8, assert::Context, false, false, false, false>` is not implemented for `f32`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u32: BikeshedIntrinsicFrom<i8, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:66:40\n+   |\n+LL |     assert::is_transmutable::<   i8,   u32>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<i8, assert::Context, false, false, false, false>` is not implemented for `u32`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u64: BikeshedIntrinsicFrom<i8, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:67:40\n+   |\n+LL |     assert::is_transmutable::<   i8,   u64>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<i8, assert::Context, false, false, false, false>` is not implemented for `u64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i64: BikeshedIntrinsicFrom<i8, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:68:40\n+   |\n+LL |     assert::is_transmutable::<   i8,   i64>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<i8, assert::Context, false, false, false, false>` is not implemented for `i64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `f64: BikeshedIntrinsicFrom<i8, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:69:40\n+   |\n+LL |     assert::is_transmutable::<   i8,   f64>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<i8, assert::Context, false, false, false, false>` is not implemented for `f64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u128: BikeshedIntrinsicFrom<i8, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:70:39\n+   |\n+LL |     assert::is_transmutable::<   i8,  u128>();\n+   |                                       ^^^^ the trait `BikeshedIntrinsicFrom<i8, assert::Context, false, false, false, false>` is not implemented for `u128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i128: BikeshedIntrinsicFrom<i8, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:71:39\n+   |\n+LL |     assert::is_transmutable::<   i8,  i128>();\n+   |                                       ^^^^ the trait `BikeshedIntrinsicFrom<i8, assert::Context, false, false, false, false>` is not implemented for `i128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i16: BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:73:40\n+   |\n+LL |     assert::is_transmutable::<   u8,   i16>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, false>` is not implemented for `i16`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u16: BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:74:40\n+   |\n+LL |     assert::is_transmutable::<   u8,   u16>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, false>` is not implemented for `u16`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i32: BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:75:40\n+   |\n+LL |     assert::is_transmutable::<   u8,   i32>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, false>` is not implemented for `i32`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `f32: BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:76:40\n+   |\n+LL |     assert::is_transmutable::<   u8,   f32>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, false>` is not implemented for `f32`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u32: BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:77:40\n+   |\n+LL |     assert::is_transmutable::<   u8,   u32>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, false>` is not implemented for `u32`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u64: BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:78:40\n+   |\n+LL |     assert::is_transmutable::<   u8,   u64>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, false>` is not implemented for `u64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i64: BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:79:40\n+   |\n+LL |     assert::is_transmutable::<   u8,   i64>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, false>` is not implemented for `i64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `f64: BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:80:40\n+   |\n+LL |     assert::is_transmutable::<   u8,   f64>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, false>` is not implemented for `f64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u128: BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:81:39\n+   |\n+LL |     assert::is_transmutable::<   u8,  u128>();\n+   |                                       ^^^^ the trait `BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, false>` is not implemented for `u128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i128: BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:82:39\n+   |\n+LL |     assert::is_transmutable::<   u8,  i128>();\n+   |                                       ^^^^ the trait `BikeshedIntrinsicFrom<u8, assert::Context, false, false, false, false>` is not implemented for `i128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i32: BikeshedIntrinsicFrom<i16, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:84:40\n+   |\n+LL |     assert::is_transmutable::<  i16,   i32>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<i16, assert::Context, false, false, false, false>` is not implemented for `i32`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `f32: BikeshedIntrinsicFrom<i16, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:85:40\n+   |\n+LL |     assert::is_transmutable::<  i16,   f32>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<i16, assert::Context, false, false, false, false>` is not implemented for `f32`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u32: BikeshedIntrinsicFrom<i16, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:86:40\n+   |\n+LL |     assert::is_transmutable::<  i16,   u32>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<i16, assert::Context, false, false, false, false>` is not implemented for `u32`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u64: BikeshedIntrinsicFrom<i16, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:87:40\n+   |\n+LL |     assert::is_transmutable::<  i16,   u64>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<i16, assert::Context, false, false, false, false>` is not implemented for `u64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i64: BikeshedIntrinsicFrom<i16, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:88:40\n+   |\n+LL |     assert::is_transmutable::<  i16,   i64>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<i16, assert::Context, false, false, false, false>` is not implemented for `i64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `f64: BikeshedIntrinsicFrom<i16, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:89:40\n+   |\n+LL |     assert::is_transmutable::<  i16,   f64>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<i16, assert::Context, false, false, false, false>` is not implemented for `f64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u128: BikeshedIntrinsicFrom<i16, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:90:39\n+   |\n+LL |     assert::is_transmutable::<  i16,  u128>();\n+   |                                       ^^^^ the trait `BikeshedIntrinsicFrom<i16, assert::Context, false, false, false, false>` is not implemented for `u128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i128: BikeshedIntrinsicFrom<i16, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:91:39\n+   |\n+LL |     assert::is_transmutable::<  i16,  i128>();\n+   |                                       ^^^^ the trait `BikeshedIntrinsicFrom<i16, assert::Context, false, false, false, false>` is not implemented for `i128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i32: BikeshedIntrinsicFrom<u16, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:93:40\n+   |\n+LL |     assert::is_transmutable::<  u16,   i32>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<u16, assert::Context, false, false, false, false>` is not implemented for `i32`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `f32: BikeshedIntrinsicFrom<u16, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:94:40\n+   |\n+LL |     assert::is_transmutable::<  u16,   f32>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<u16, assert::Context, false, false, false, false>` is not implemented for `f32`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u32: BikeshedIntrinsicFrom<u16, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:95:40\n+   |\n+LL |     assert::is_transmutable::<  u16,   u32>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<u16, assert::Context, false, false, false, false>` is not implemented for `u32`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u64: BikeshedIntrinsicFrom<u16, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:96:40\n+   |\n+LL |     assert::is_transmutable::<  u16,   u64>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<u16, assert::Context, false, false, false, false>` is not implemented for `u64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i64: BikeshedIntrinsicFrom<u16, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:97:40\n+   |\n+LL |     assert::is_transmutable::<  u16,   i64>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<u16, assert::Context, false, false, false, false>` is not implemented for `i64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `f64: BikeshedIntrinsicFrom<u16, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:98:40\n+   |\n+LL |     assert::is_transmutable::<  u16,   f64>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<u16, assert::Context, false, false, false, false>` is not implemented for `f64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u128: BikeshedIntrinsicFrom<u16, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:99:39\n+   |\n+LL |     assert::is_transmutable::<  u16,  u128>();\n+   |                                       ^^^^ the trait `BikeshedIntrinsicFrom<u16, assert::Context, false, false, false, false>` is not implemented for `u128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i128: BikeshedIntrinsicFrom<u16, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:100:39\n+   |\n+LL |     assert::is_transmutable::<  u16,  i128>();\n+   |                                       ^^^^ the trait `BikeshedIntrinsicFrom<u16, assert::Context, false, false, false, false>` is not implemented for `i128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u64: BikeshedIntrinsicFrom<i32, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:102:40\n+   |\n+LL |     assert::is_transmutable::<  i32,   u64>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<i32, assert::Context, false, false, false, false>` is not implemented for `u64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i64: BikeshedIntrinsicFrom<i32, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:103:40\n+   |\n+LL |     assert::is_transmutable::<  i32,   i64>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<i32, assert::Context, false, false, false, false>` is not implemented for `i64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `f64: BikeshedIntrinsicFrom<i32, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:104:40\n+   |\n+LL |     assert::is_transmutable::<  i32,   f64>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<i32, assert::Context, false, false, false, false>` is not implemented for `f64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u128: BikeshedIntrinsicFrom<i32, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:105:39\n+   |\n+LL |     assert::is_transmutable::<  i32,  u128>();\n+   |                                       ^^^^ the trait `BikeshedIntrinsicFrom<i32, assert::Context, false, false, false, false>` is not implemented for `u128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i128: BikeshedIntrinsicFrom<i32, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:106:39\n+   |\n+LL |     assert::is_transmutable::<  i32,  i128>();\n+   |                                       ^^^^ the trait `BikeshedIntrinsicFrom<i32, assert::Context, false, false, false, false>` is not implemented for `i128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u64: BikeshedIntrinsicFrom<f32, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:108:40\n+   |\n+LL |     assert::is_transmutable::<  f32,   u64>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<f32, assert::Context, false, false, false, false>` is not implemented for `u64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i64: BikeshedIntrinsicFrom<f32, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:109:40\n+   |\n+LL |     assert::is_transmutable::<  f32,   i64>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<f32, assert::Context, false, false, false, false>` is not implemented for `i64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `f64: BikeshedIntrinsicFrom<f32, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:110:40\n+   |\n+LL |     assert::is_transmutable::<  f32,   f64>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<f32, assert::Context, false, false, false, false>` is not implemented for `f64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u128: BikeshedIntrinsicFrom<f32, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:111:39\n+   |\n+LL |     assert::is_transmutable::<  f32,  u128>();\n+   |                                       ^^^^ the trait `BikeshedIntrinsicFrom<f32, assert::Context, false, false, false, false>` is not implemented for `u128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i128: BikeshedIntrinsicFrom<f32, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:112:39\n+   |\n+LL |     assert::is_transmutable::<  f32,  i128>();\n+   |                                       ^^^^ the trait `BikeshedIntrinsicFrom<f32, assert::Context, false, false, false, false>` is not implemented for `i128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u64: BikeshedIntrinsicFrom<u32, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:114:40\n+   |\n+LL |     assert::is_transmutable::<  u32,   u64>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<u32, assert::Context, false, false, false, false>` is not implemented for `u64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i64: BikeshedIntrinsicFrom<u32, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:115:40\n+   |\n+LL |     assert::is_transmutable::<  u32,   i64>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<u32, assert::Context, false, false, false, false>` is not implemented for `i64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `f64: BikeshedIntrinsicFrom<u32, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:116:40\n+   |\n+LL |     assert::is_transmutable::<  u32,   f64>();\n+   |                                        ^^^ the trait `BikeshedIntrinsicFrom<u32, assert::Context, false, false, false, false>` is not implemented for `f64`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u128: BikeshedIntrinsicFrom<u32, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:117:39\n+   |\n+LL |     assert::is_transmutable::<  u32,  u128>();\n+   |                                       ^^^^ the trait `BikeshedIntrinsicFrom<u32, assert::Context, false, false, false, false>` is not implemented for `u128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i128: BikeshedIntrinsicFrom<u32, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:118:39\n+   |\n+LL |     assert::is_transmutable::<  u32,  i128>();\n+   |                                       ^^^^ the trait `BikeshedIntrinsicFrom<u32, assert::Context, false, false, false, false>` is not implemented for `i128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u128: BikeshedIntrinsicFrom<u64, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:120:39\n+   |\n+LL |     assert::is_transmutable::<  u64,  u128>();\n+   |                                       ^^^^ the trait `BikeshedIntrinsicFrom<u64, assert::Context, false, false, false, false>` is not implemented for `u128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i128: BikeshedIntrinsicFrom<u64, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:121:39\n+   |\n+LL |     assert::is_transmutable::<  u64,  i128>();\n+   |                                       ^^^^ the trait `BikeshedIntrinsicFrom<u64, assert::Context, false, false, false, false>` is not implemented for `i128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u128: BikeshedIntrinsicFrom<i64, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:123:39\n+   |\n+LL |     assert::is_transmutable::<  i64,  u128>();\n+   |                                       ^^^^ the trait `BikeshedIntrinsicFrom<i64, assert::Context, false, false, false, false>` is not implemented for `u128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i128: BikeshedIntrinsicFrom<i64, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:124:39\n+   |\n+LL |     assert::is_transmutable::<  i64,  i128>();\n+   |                                       ^^^^ the trait `BikeshedIntrinsicFrom<i64, assert::Context, false, false, false, false>` is not implemented for `i128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `u128: BikeshedIntrinsicFrom<f64, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:126:39\n+   |\n+LL |     assert::is_transmutable::<  f64,  u128>();\n+   |                                       ^^^^ the trait `BikeshedIntrinsicFrom<f64, assert::Context, false, false, false, false>` is not implemented for `u128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `i128: BikeshedIntrinsicFrom<f64, assert::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/numbers.rs:127:39\n+   |\n+LL |     assert::is_transmutable::<  f64,  i128>();\n+   |                                       ^^^^ the trait `BikeshedIntrinsicFrom<f64, assert::Context, false, false, false, false>` is not implemented for `i128`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/numbers.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error: aborting due to 57 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "a9c618188bf419cb31da5b75900d0cbaee408728", "filename": "src/test/ui/transmutability/primitives/unit.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fprimitives%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fprimitives%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fprimitives%2Funit.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,24 @@\n+//! The unit type, `()`, should be one byte.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+\n+    pub fn is_transmutable<Src, Dst, Context>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+    {}\n+}\n+\n+#[repr(C)]\n+struct Zst;\n+\n+fn should_have_correct_size() {\n+    struct Context;\n+    assert::is_transmutable::<(), Zst, Context>();\n+    assert::is_transmutable::<Zst, (), Context>();\n+    assert::is_transmutable::<(), u8, Context>(); //~ ERROR not satisfied\n+}"}, {"sha": "f602612feea9307adc079bc02b49e0552bc5fe17", "filename": "src/test/ui/transmutability/primitives/unit.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fprimitives%2Funit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fprimitives%2Funit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fprimitives%2Funit.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: the trait bound `u8: BikeshedIntrinsicFrom<(), should_have_correct_size::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/unit.rs:23:35\n+   |\n+LL |     assert::is_transmutable::<(), u8, Context>();\n+   |                                   ^^ the trait `BikeshedIntrinsicFrom<(), should_have_correct_size::Context, true, true, true, true>` is not implemented for `u8`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/unit.rs:12:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "c7d24aaf1caa8f58637660c8acec4b3cdc1c6bf8", "filename": "src/test/ui/transmutability/references.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Freferences.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,20 @@\n+//! Transmutations involving references are not yet supported.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code, incomplete_features, non_camel_case_types)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+    {}\n+}\n+\n+fn not_yet_implemented() {\n+    #[repr(C)] struct Unit;\n+    assert::is_maybe_transmutable::<&'static Unit, &'static Unit>(); //~ ERROR not satisfied\n+}"}, {"sha": "7199e169e29770e9a43828ca330335f8cc6ab265", "filename": "src/test/ui/transmutability/references.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Freferences.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Freferences.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Freferences.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: the trait bound `&'static Unit: BikeshedIntrinsicFrom<&'static Unit, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/references.rs:19:52\n+   |\n+LL |     assert::is_maybe_transmutable::<&'static Unit, &'static Unit>();\n+   |                                                    ^^^^^^^^^^^^^ the trait `BikeshedIntrinsicFrom<&'static Unit, assert::Context, true, true, true, true>` is not implemented for `&'static Unit`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/references.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "71720165ab06327fdfcf1fa3b41db44716f1082c", "filename": "src/test/ui/transmutability/structs/repr/should_handle_align.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fstructs%2Frepr%2Fshould_handle_align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fstructs%2Frepr%2Fshould_handle_align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fstructs%2Frepr%2Fshould_handle_align.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,36 @@\n+// check-pass\n+//! The presence of an `align(X)` annotation must be accounted for.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code, incomplete_features, non_camel_case_types)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+    {}\n+}\n+\n+fn should_pad_explicitly_aligned_field() {\n+    #[derive(Clone, Copy)] #[repr(u8)] enum V0u8 { V = 0 }\n+\n+    #[repr(C)]\n+    pub union Uninit {\n+        a: (),\n+        b: V0u8,\n+    }\n+\n+    #[repr(C, align(2))] struct align_2(V0u8);\n+\n+    #[repr(C)] struct ImplicitlyPadded(align_2, V0u8);\n+    #[repr(C)] struct ExplicitlyPadded(V0u8, Uninit, V0u8);\n+\n+    // An implementation that (incorrectly) does not place a padding byte after\n+    // `align_2` will, incorrectly, reject the following transmutations.\n+    assert::is_maybe_transmutable::<ImplicitlyPadded, ExplicitlyPadded>();\n+    assert::is_maybe_transmutable::<ExplicitlyPadded, ImplicitlyPadded>();\n+}"}, {"sha": "ae8acf50418976cb2705ddd8a6f5683d90e1b5a7", "filename": "src/test/ui/transmutability/structs/repr/should_handle_packed.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fstructs%2Frepr%2Fshould_handle_packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fstructs%2Frepr%2Fshould_handle_packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fstructs%2Frepr%2Fshould_handle_packed.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,35 @@\n+// check-pass\n+//! The presence of an `align(X)` annotation must be accounted for.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code, incomplete_features, non_camel_case_types)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+    {}\n+}\n+\n+fn should_pad_explicitly_packed_field() {\n+    #[derive(Clone, Copy)] #[repr(u8)] enum V0u8 { V = 0 }\n+    #[derive(Clone, Copy)] #[repr(u32)] enum V0u32 { V = 0 }\n+\n+    #[repr(C)]\n+    pub union Uninit {\n+        a: (),\n+        b: V0u8,\n+    }\n+\n+    #[repr(C, packed(2))] struct ImplicitlyPadded(V0u8, V0u32);\n+    #[repr(C)] struct ExplicitlyPadded(V0u8, Uninit, V0u8, V0u8, V0u8, V0u8);\n+\n+    // An implementation that (incorrectly) does not place a padding byte after\n+    // `align_2` will, incorrectly, reject the following transmutations.\n+    assert::is_maybe_transmutable::<ImplicitlyPadded, ExplicitlyPadded>();\n+    assert::is_maybe_transmutable::<ExplicitlyPadded, ImplicitlyPadded>();\n+}"}, {"sha": "63419aceb6ce9390a594370c90fcf49df50a1fec", "filename": "src/test/ui/transmutability/structs/repr/should_require_well_defined_layout.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fstructs%2Frepr%2Fshould_require_well_defined_layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fstructs%2Frepr%2Fshould_require_well_defined_layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fstructs%2Frepr%2Fshould_require_well_defined_layout.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,76 @@\n+//! A struct must have a well-defined layout to participate in a transmutation.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code, incomplete_features, non_camel_case_types)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+    {}\n+}\n+\n+fn should_reject_repr_rust()\n+{\n+    fn unit() {\n+        struct repr_rust;\n+        assert::is_maybe_transmutable::<repr_rust, ()>(); //~ ERROR not satisfied\n+        assert::is_maybe_transmutable::<u128, repr_rust>(); //~ ERROR not satisfied\n+    }\n+\n+    fn tuple() {\n+        struct repr_rust();\n+        assert::is_maybe_transmutable::<repr_rust, ()>(); //~ ERROR not satisfied\n+        assert::is_maybe_transmutable::<u128, repr_rust>(); //~ ERROR not satisfied\n+    }\n+\n+    fn braces() {\n+        struct repr_rust{}\n+        assert::is_maybe_transmutable::<repr_rust, ()>(); //~ ERROR not satisfied\n+        assert::is_maybe_transmutable::<u128, repr_rust>(); //~ ERROR not satisfied\n+    }\n+\n+    fn aligned() {\n+        #[repr(align(1))] struct repr_rust{}\n+        assert::is_maybe_transmutable::<repr_rust, ()>(); //~ ERROR not satisfied\n+        assert::is_maybe_transmutable::<u128, repr_rust>(); //~ ERROR not satisfied\n+    }\n+\n+    fn packed() {\n+        #[repr(packed)] struct repr_rust{}\n+        assert::is_maybe_transmutable::<repr_rust, ()>(); //~ ERROR not satisfied\n+        assert::is_maybe_transmutable::<u128, repr_rust>(); //~ ERROR not satisfied\n+    }\n+\n+    fn nested() {\n+        struct repr_rust;\n+        #[repr(C)] struct repr_c(repr_rust);\n+        assert::is_maybe_transmutable::<repr_c, ()>(); //~ ERROR not satisfied\n+        assert::is_maybe_transmutable::<u128, repr_c>(); //~ ERROR not satisfied\n+    }\n+}\n+\n+fn should_accept_repr_C()\n+{\n+    fn unit() {\n+        #[repr(C)] struct repr_c;\n+        assert::is_maybe_transmutable::<repr_c, ()>();\n+        assert::is_maybe_transmutable::<i128, repr_c>();\n+    }\n+\n+    fn tuple() {\n+        #[repr(C)] struct repr_c();\n+        assert::is_maybe_transmutable::<repr_c, ()>();\n+        assert::is_maybe_transmutable::<i128, repr_c>();\n+    }\n+\n+    fn braces() {\n+        #[repr(C)] struct repr_c{}\n+        assert::is_maybe_transmutable::<repr_c, ()>();\n+        assert::is_maybe_transmutable::<i128, repr_c>();\n+    }\n+}"}, {"sha": "ab582dd668807bbbf82df7b7c265c004c956c22b", "filename": "src/test/ui/transmutability/structs/repr/should_require_well_defined_layout.stderr", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fstructs%2Frepr%2Fshould_require_well_defined_layout.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fstructs%2Frepr%2Fshould_require_well_defined_layout.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fstructs%2Frepr%2Fshould_require_well_defined_layout.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,183 @@\n+error[E0277]: the trait bound `(): BikeshedIntrinsicFrom<should_reject_repr_rust::unit::repr_rust, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:21:52\n+   |\n+LL |         assert::is_maybe_transmutable::<repr_rust, ()>();\n+   |                                                    ^^ the trait `BikeshedIntrinsicFrom<should_reject_repr_rust::unit::repr_rust, assert::Context, true, true, true, true>` is not implemented for `()`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `should_reject_repr_rust::unit::repr_rust: BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:22:47\n+   |\n+LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n+   |                                               ^^^^^^^^^ the trait `BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not implemented for `should_reject_repr_rust::unit::repr_rust`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `(): BikeshedIntrinsicFrom<should_reject_repr_rust::tuple::repr_rust, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:27:52\n+   |\n+LL |         assert::is_maybe_transmutable::<repr_rust, ()>();\n+   |                                                    ^^ the trait `BikeshedIntrinsicFrom<should_reject_repr_rust::tuple::repr_rust, assert::Context, true, true, true, true>` is not implemented for `()`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `should_reject_repr_rust::tuple::repr_rust: BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:28:47\n+   |\n+LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n+   |                                               ^^^^^^^^^ the trait `BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not implemented for `should_reject_repr_rust::tuple::repr_rust`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `(): BikeshedIntrinsicFrom<should_reject_repr_rust::braces::repr_rust, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:33:52\n+   |\n+LL |         assert::is_maybe_transmutable::<repr_rust, ()>();\n+   |                                                    ^^ the trait `BikeshedIntrinsicFrom<should_reject_repr_rust::braces::repr_rust, assert::Context, true, true, true, true>` is not implemented for `()`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `should_reject_repr_rust::braces::repr_rust: BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:34:47\n+   |\n+LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n+   |                                               ^^^^^^^^^ the trait `BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not implemented for `should_reject_repr_rust::braces::repr_rust`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `(): BikeshedIntrinsicFrom<aligned::repr_rust, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:39:52\n+   |\n+LL |         assert::is_maybe_transmutable::<repr_rust, ()>();\n+   |                                                    ^^ the trait `BikeshedIntrinsicFrom<aligned::repr_rust, assert::Context, true, true, true, true>` is not implemented for `()`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `aligned::repr_rust: BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:40:47\n+   |\n+LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n+   |                                               ^^^^^^^^^ the trait `BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not implemented for `aligned::repr_rust`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `(): BikeshedIntrinsicFrom<packed::repr_rust, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:45:52\n+   |\n+LL |         assert::is_maybe_transmutable::<repr_rust, ()>();\n+   |                                                    ^^ the trait `BikeshedIntrinsicFrom<packed::repr_rust, assert::Context, true, true, true, true>` is not implemented for `()`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `packed::repr_rust: BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:46:47\n+   |\n+LL |         assert::is_maybe_transmutable::<u128, repr_rust>();\n+   |                                               ^^^^^^^^^ the trait `BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not implemented for `packed::repr_rust`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `(): BikeshedIntrinsicFrom<nested::repr_c, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:52:49\n+   |\n+LL |         assert::is_maybe_transmutable::<repr_c, ()>();\n+   |                                                 ^^ the trait `BikeshedIntrinsicFrom<nested::repr_c, assert::Context, true, true, true, true>` is not implemented for `()`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `nested::repr_c: BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:53:47\n+   |\n+LL |         assert::is_maybe_transmutable::<u128, repr_c>();\n+   |                                               ^^^^^^ the trait `BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not implemented for `nested::repr_c`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error: aborting due to 12 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "db49b914fe06535cf76941a142dcbead611fc4b8", "filename": "src/test/ui/transmutability/structs/should_order_fields_correctly.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fstructs%2Fshould_order_fields_correctly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fstructs%2Fshould_order_fields_correctly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fstructs%2Fshould_order_fields_correctly.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,31 @@\n+// check-pass\n+//! The fields of a struct should be laid out in lexical order.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+    {}\n+}\n+\n+#[repr(u8)] enum V0 { V = 0 }\n+#[repr(u8)] enum V1 { V = 1 }\n+#[repr(u8)] enum V2 { V = 2 }\n+\n+#[repr(C)] struct S01(V0, V1);\n+#[repr(C)] struct S012(V0, V1, V2);\n+\n+fn should_order_tag_and_fields_correctly() {\n+    // An implementation that (incorrectly) arranges S01 as [0x01, 0x00] will,\n+    // in principle, reject this transmutation.\n+    assert::is_transmutable::<S01, V0>();\n+    // Again, but with one more field.\n+    assert::is_transmutable::<S012, S01>();\n+}"}, {"sha": "975118b99b7baf9edcda44b7cf367f76a6364764", "filename": "src/test/ui/transmutability/unions/boolish.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fboolish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fboolish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fboolish.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,31 @@\n+// check-pass\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![feature(marker_trait_attr)]\n+#![allow(dead_code)]\n+#![allow(incomplete_features)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, true>\n+    {}\n+}\n+\n+fn should_match_bool() {\n+    #[derive(Copy, Clone)] #[repr(u8)] pub enum False { V = 0 }\n+    #[derive(Copy, Clone)] #[repr(u8)] pub enum True { V = 1 }\n+\n+    #[repr(C)]\n+    pub union Bool {\n+        pub f: False,\n+        pub t: True,\n+    }\n+\n+    assert::is_transmutable::<Bool, bool>();\n+    assert::is_transmutable::<bool, Bool>();\n+}"}, {"sha": "e215799a232407d0c6c94972e97b40fc531b5c24", "filename": "src/test/ui/transmutability/unions/repr/should_handle_align.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Frepr%2Fshould_handle_align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Frepr%2Fshould_handle_align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Frepr%2Fshould_handle_align.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,40 @@\n+// check-pass\n+//! The presence of an `align(X)` annotation must be accounted for.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code, incomplete_features, non_camel_case_types)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+    {}\n+}\n+\n+fn should_pad_explicitly_aligned_field() {\n+    #[derive(Clone, Copy)] #[repr(u8)] enum V0u8 { V = 0 }\n+    #[derive(Clone, Copy)] #[repr(u8)] enum V1u8 { V = 1 }\n+\n+    #[repr(C)]\n+    pub union Uninit {\n+        a: (),\n+        b: V1u8,\n+    }\n+\n+    #[repr(C, align(2))]\n+    pub union align_2 {\n+        a: V0u8,\n+    }\n+\n+    #[repr(C)] struct ImplicitlyPadded(align_2, V0u8);\n+    #[repr(C)] struct ExplicitlyPadded(V0u8, Uninit, V0u8);\n+\n+    // An implementation that (incorrectly) does not place a padding byte after\n+    // `align_2` will, incorrectly, reject the following transmutations.\n+    assert::is_maybe_transmutable::<ImplicitlyPadded, ExplicitlyPadded>();\n+    assert::is_maybe_transmutable::<ExplicitlyPadded, ImplicitlyPadded>();\n+}"}, {"sha": "34a53c7a80c42a5101196fe179fd285b4e69aa3d", "filename": "src/test/ui/transmutability/unions/repr/should_handle_packed.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Frepr%2Fshould_handle_packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Frepr%2Fshould_handle_packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Frepr%2Fshould_handle_packed.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,41 @@\n+// check-pass\n+//! The presence of an `align(X)` annotation must be accounted for.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code, incomplete_features, non_camel_case_types)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+    {}\n+}\n+\n+fn should_pad_explicitly_packed_field() {\n+    #[derive(Clone, Copy)] #[repr(u8)] enum V0u8 { V = 0 }\n+    #[derive(Clone, Copy)] #[repr(u8)] enum V1u8 { V = 1 }\n+    #[derive(Clone, Copy)] #[repr(u8)] enum V2u8 { V = 2 }\n+    #[derive(Clone, Copy)] #[repr(u32)] enum V3u32 { V = 3 }\n+\n+    #[repr(C)]\n+    pub union Uninit {\n+        a: (),\n+        b: V1u8,\n+    }\n+\n+    #[repr(C, packed(2))]\n+    pub union Packed {\n+        a: [V3u32; 0],\n+        b: V0u8,\n+    }\n+\n+    #[repr(C)] struct ImplicitlyPadded(Packed, V2u8);\n+    #[repr(C)] struct ExplicitlyPadded(V0u8, Uninit, V2u8);\n+\n+    assert::is_maybe_transmutable::<ImplicitlyPadded, ExplicitlyPadded>();\n+    assert::is_maybe_transmutable::<ExplicitlyPadded, ImplicitlyPadded>();\n+}"}, {"sha": "d6e28d7f0db3f2ed44ba411be9ef458da7947228", "filename": "src/test/ui/transmutability/unions/repr/should_require_well_defined_layout.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Frepr%2Fshould_require_well_defined_layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Frepr%2Fshould_require_well_defined_layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Frepr%2Fshould_require_well_defined_layout.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,37 @@\n+//! A struct must have a well-defined layout to participate in a transmutation.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code, incomplete_features, non_camel_case_types)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+    {}\n+}\n+\n+fn should_reject_repr_rust()\n+{\n+    union repr_rust {\n+        a: u8\n+    }\n+\n+    assert::is_maybe_transmutable::<repr_rust, ()>(); //~ ERROR not satisfied\n+    assert::is_maybe_transmutable::<u128, repr_rust>(); //~ ERROR not satisfied\n+}\n+\n+fn should_accept_repr_C()\n+{\n+    #[repr(C)]\n+    union repr_c {\n+        a: u8\n+    }\n+\n+    struct repr_rust;\n+    assert::is_maybe_transmutable::<repr_c, ()>();\n+    assert::is_maybe_transmutable::<u128, repr_c>();\n+}"}, {"sha": "c24193f9a6d77aed8b4d7921ddaec6374e563d5a", "filename": "src/test/ui/transmutability/unions/repr/should_require_well_defined_layout.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Frepr%2Fshould_require_well_defined_layout.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Frepr%2Fshould_require_well_defined_layout.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Frepr%2Fshould_require_well_defined_layout.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,33 @@\n+error[E0277]: the trait bound `(): BikeshedIntrinsicFrom<should_reject_repr_rust::repr_rust, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:23:48\n+   |\n+LL |     assert::is_maybe_transmutable::<repr_rust, ()>();\n+   |                                                ^^ the trait `BikeshedIntrinsicFrom<should_reject_repr_rust::repr_rust, assert::Context, true, true, true, true>` is not implemented for `()`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `should_reject_repr_rust::repr_rust: BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_require_well_defined_layout.rs:24:43\n+   |\n+LL |     assert::is_maybe_transmutable::<u128, repr_rust>();\n+   |                                           ^^^^^^^^^ the trait `BikeshedIntrinsicFrom<u128, assert::Context, true, true, true, true>` is not implemented for `should_reject_repr_rust::repr_rust`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_require_well_defined_layout.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "d4126693f92842983fae08075f07148776b0f5a1", "filename": "src/test/ui/transmutability/unions/should_pad_variants.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_pad_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_pad_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_pad_variants.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,40 @@\n+//! The variants of a union must be padded with uninit bytes such that they have\n+//! the same length (in bytes).\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+\n+    pub fn is_transmutable<Src, Dst, Context>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+    {}\n+}\n+\n+#[derive(Clone, Copy)]\n+#[repr(C)] struct Zst;\n+\n+#[derive(Clone, Copy)]\n+#[repr(u8)] enum V0 { V = 0 }\n+\n+#[derive(Clone, Copy)]\n+#[repr(u8)] enum V2 { V = 2 }\n+\n+#[repr(C)]\n+union Lopsided {\n+    smol: Zst,\n+    lorg: V0,\n+}\n+\n+#[repr(C)] struct Src(V0, Zst, V2);\n+#[repr(C)] struct Dst(V0, Lopsided, V2);\n+\n+fn should_pad_variants() {\n+    struct Context;\n+    // If the implementation (incorrectly) fails to pad `Lopsided::smol` with\n+    // an uninitialized byte, this transmutation might be (wrongly) accepted:\n+    assert::is_transmutable::<Src, Dst, Context>(); //~ ERROR not satisfied\n+}"}, {"sha": "b940ca077d4ad93c265c81d09c6ad1596508caf4", "filename": "src/test/ui/transmutability/unions/should_pad_variants.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_pad_variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_pad_variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_pad_variants.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: the trait bound `Dst: BikeshedIntrinsicFrom<Src, should_pad_variants::Context, true, true, true, true>` is not satisfied\n+  --> $DIR/should_pad_variants.rs:39:36\n+   |\n+LL |     assert::is_transmutable::<Src, Dst, Context>();\n+   |                                    ^^^ the trait `BikeshedIntrinsicFrom<Src, should_pad_variants::Context, true, true, true, true>` is not implemented for `Dst`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/should_pad_variants.rs:13:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, true, true, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "2493d71554ad3d4dc03bc139da910d36eb37ad10", "filename": "src/test/ui/transmutability/unions/should_permit_intersecting_if_validity_is_assumed.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_permit_intersecting_if_validity_is_assumed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_permit_intersecting_if_validity_is_assumed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_permit_intersecting_if_validity_is_assumed.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,39 @@\n+// check-pass\n+//! If validity is assumed, there need only be one matching bit-pattern between\n+//! the source and destination types.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code, incomplete_features, non_camel_case_types)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, true, true>\n+        // validity IS assumed --------------------------------^^^^\n+    {}\n+}\n+\n+#[derive(Clone, Copy)] #[repr(u8)] enum Ox00 { V = 0x00 }\n+#[derive(Clone, Copy)] #[repr(u8)] enum Ox7F { V = 0x7F }\n+#[derive(Clone, Copy)] #[repr(u8)] enum OxFF { V = 0xFF }\n+\n+fn test() {\n+    #[repr(C)]\n+    union A {\n+        a: Ox00,\n+        b: Ox7F,\n+    }\n+\n+    #[repr(C)]\n+    union B {\n+        a: Ox7F,\n+        b: OxFF,\n+    }\n+\n+    assert::is_maybe_transmutable::<A, B>();\n+    assert::is_maybe_transmutable::<B, A>();\n+}"}, {"sha": "34b31595193dd05d1290163a79f0dc6c152ed138", "filename": "src/test/ui/transmutability/unions/should_reject_contraction.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_reject_contraction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_reject_contraction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_reject_contraction.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,36 @@\n+//! Validity may not be contracted, unless validity is assumed.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code, incomplete_features, non_camel_case_types)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, true>\n+    {}\n+}\n+\n+#[derive(Clone, Copy)] #[repr(u8)] enum Ox00 { V = 0x00 }\n+#[derive(Clone, Copy)] #[repr(u8)] enum Ox01 { V = 0x01 }\n+#[derive(Clone, Copy)] #[repr(u8)] enum OxFF { V = 0xFF }\n+\n+fn test() {\n+    #[repr(C)]\n+    union Subset {\n+        a: Ox00,\n+        b: OxFF,\n+    }\n+\n+    #[repr(C)]\n+    union Superset {\n+        a: Ox00,\n+        b: OxFF,\n+        c: Ox01,\n+    }\n+\n+    assert::is_transmutable::<Superset, Subset>(); //~ ERROR not satisfied\n+}"}, {"sha": "1465c3df228377f150ab3d3655338ce3333ddb3d", "filename": "src/test/ui/transmutability/unions/should_reject_contraction.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_reject_contraction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_reject_contraction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_reject_contraction.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: the trait bound `Subset: BikeshedIntrinsicFrom<Superset, assert::Context, false, false, false, true>` is not satisfied\n+  --> $DIR/should_reject_contraction.rs:35:41\n+   |\n+LL |     assert::is_transmutable::<Superset, Subset>();\n+   |                                         ^^^^^^ the trait `BikeshedIntrinsicFrom<Superset, assert::Context, false, false, false, true>` is not implemented for `Subset`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/should_reject_contraction.rs:13:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "b4b06c571315e98e178afb2c6401090553974c7b", "filename": "src/test/ui/transmutability/unions/should_reject_disjoint.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_reject_disjoint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_reject_disjoint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_reject_disjoint.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,36 @@\n+//! Validity must be satisfiable, even if validity is assumed.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code, incomplete_features, non_camel_case_types)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, true, true>\n+        // validity IS assumed --------------------------------^^^^\n+    {}\n+}\n+\n+#[derive(Clone, Copy)] #[repr(u8)] enum Ox00 { V = 0x00 }\n+#[derive(Clone, Copy)] #[repr(u8)] enum Ox01 { V = 0x01 }\n+#[derive(Clone, Copy)] #[repr(u8)] enum OxFF { V = 0xFF }\n+\n+fn test() {\n+    #[repr(C)]\n+    union A {\n+        a: Ox00,\n+        b: OxFF,\n+    }\n+\n+    #[repr(C)]\n+    union B {\n+        c: Ox01,\n+    }\n+\n+    assert::is_maybe_transmutable::<A, B>(); //~ ERROR not satisfied\n+    assert::is_maybe_transmutable::<B, A>(); //~ ERROR not satisfied\n+}"}, {"sha": "a140f0c506b3bea18042fd85a07a0c554c66e37d", "filename": "src/test/ui/transmutability/unions/should_reject_disjoint.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_reject_disjoint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_reject_disjoint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_reject_disjoint.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,33 @@\n+error[E0277]: the trait bound `B: BikeshedIntrinsicFrom<A, assert::Context, false, false, true, true>` is not satisfied\n+  --> $DIR/should_reject_disjoint.rs:34:40\n+   |\n+LL |     assert::is_maybe_transmutable::<A, B>();\n+   |                                        ^ the trait `BikeshedIntrinsicFrom<A, assert::Context, false, false, true, true>` is not implemented for `B`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_reject_disjoint.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error[E0277]: the trait bound `A: BikeshedIntrinsicFrom<B, assert::Context, false, false, true, true>` is not satisfied\n+  --> $DIR/should_reject_disjoint.rs:35:40\n+   |\n+LL |     assert::is_maybe_transmutable::<B, A>();\n+   |                                        ^ the trait `BikeshedIntrinsicFrom<B, assert::Context, false, false, true, true>` is not implemented for `A`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/should_reject_disjoint.rs:13:14\n+   |\n+LL |     pub fn is_maybe_transmutable<Src, Dst>()\n+   |            --------------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, true, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_maybe_transmutable`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "1ed7d2a0bd9a049468f435d81774f280491d8c1b", "filename": "src/test/ui/transmutability/unions/should_reject_intersecting.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_reject_intersecting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_reject_intersecting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_reject_intersecting.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,38 @@\n+//! ALL valid bit patterns of the source must be valid bit patterns of the\n+//! destination type, unless validity is assumed.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code, incomplete_features, non_camel_case_types)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+    pub struct Context;\n+\n+    pub fn is_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, true>\n+        // validity is NOT assumed ----------------------------^^^^^\n+    {}\n+}\n+\n+#[derive(Clone, Copy)] #[repr(u8)] enum Ox00 { V = 0x00 }\n+#[derive(Clone, Copy)] #[repr(u8)] enum Ox7F { V = 0x7F }\n+#[derive(Clone, Copy)] #[repr(u8)] enum OxFF { V = 0xFF }\n+\n+fn test() {\n+    #[repr(C)]\n+    union A {\n+        a: Ox00,\n+        b: Ox7F,\n+    }\n+\n+    #[repr(C)]\n+    union B {\n+        a: Ox7F,\n+        b: OxFF,\n+    }\n+\n+    assert::is_transmutable::<A, B>(); //~ ERROR not satisfied\n+    assert::is_transmutable::<B, A>(); //~ ERROR not satisfied\n+}"}, {"sha": "43e642b5691521d8d1672472501d612f68d4c4ea", "filename": "src/test/ui/transmutability/unions/should_reject_intersecting.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_reject_intersecting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_reject_intersecting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Funions%2Fshould_reject_intersecting.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,33 @@\n+error[E0277]: the trait bound `B: BikeshedIntrinsicFrom<A, assert::Context, false, false, false, true>` is not satisfied\n+  --> $DIR/should_reject_intersecting.rs:36:34\n+   |\n+LL |     assert::is_transmutable::<A, B>();\n+   |                                  ^ the trait `BikeshedIntrinsicFrom<A, assert::Context, false, false, false, true>` is not implemented for `B`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/should_reject_intersecting.rs:14:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error[E0277]: the trait bound `A: BikeshedIntrinsicFrom<B, assert::Context, false, false, false, true>` is not satisfied\n+  --> $DIR/should_reject_intersecting.rs:37:34\n+   |\n+LL |     assert::is_transmutable::<B, A>();\n+   |                                  ^ the trait `BikeshedIntrinsicFrom<B, assert::Context, false, false, false, true>` is not implemented for `A`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/should_reject_intersecting.rs:14:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, true>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "5a8c810494c58b77a16468d8544f1600beebb77e", "filename": "src/test/ui/transmutability/visibility/assume/should_accept_if_dst_has_private_field.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fassume%2Fshould_accept_if_dst_has_private_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fassume%2Fshould_accept_if_dst_has_private_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fassume%2Fshould_accept_if_dst_has_private_field.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,38 @@\n+// check-pass\n+//! If visibility is assumed, a transmutation should be accepted even if the\n+//! destination type contains a private field.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+\n+    pub fn is_transmutable<Src, Dst, Context>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, true>\n+        // visibility IS assumed -------------------------------------^^^^\n+    {}\n+}\n+\n+mod src {\n+    #[repr(C)] pub(self) struct Zst;\n+\n+    #[repr(C)] pub(in super) struct Src {\n+        pub(self) field: Zst,\n+    }\n+}\n+\n+mod dst {\n+    #[repr(C)] pub(in super) struct Zst;\n+\n+    #[repr(C)] pub(in super) struct Dst {\n+        pub(self) field: Zst, // <- private field\n+    }\n+}\n+\n+fn test() {\n+    struct Context;\n+    assert::is_transmutable::<src::Src, dst::Dst, Context>();\n+}"}, {"sha": "77ab4fa6bff4b8ab8a595f46e4873db9cbf7a951", "filename": "src/test/ui/transmutability/visibility/assume/should_accept_if_dst_has_private_variant.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fassume%2Fshould_accept_if_dst_has_private_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fassume%2Fshould_accept_if_dst_has_private_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fassume%2Fshould_accept_if_dst_has_private_variant.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,39 @@\n+// check-pass\n+//! If visibility is assumed, a transmutation should be accepted even if the\n+//! destination type contains a private variant.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+\n+    pub fn is_transmutable<Src, Dst, Context>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, true>\n+        // visibility IS assumed -------------------------------------^^^^\n+    {}\n+}\n+\n+mod src {\n+    #[repr(C)] pub(self) struct Zst;\n+\n+    #[repr(C)] pub(in super) struct Src {\n+        pub(self) field: Zst,\n+    }\n+}\n+\n+mod dst {\n+    #[derive(Copy, Clone)]\n+    #[repr(C)] pub(in super) struct Zst;\n+\n+    #[repr(C)] pub(in super) union Dst {\n+        pub(self) field: Zst, // <- private variant\n+    }\n+}\n+\n+fn test() {\n+    struct Context;\n+    assert::is_transmutable::<src::Src, dst::Dst, Context>();\n+}"}, {"sha": "2421b24cbf07f472593fefd8cf148c5199ce2ab0", "filename": "src/test/ui/transmutability/visibility/assume/should_accept_if_dst_has_tricky_unreachable_field.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fassume%2Fshould_accept_if_dst_has_tricky_unreachable_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fassume%2Fshould_accept_if_dst_has_tricky_unreachable_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fassume%2Fshould_accept_if_dst_has_tricky_unreachable_field.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,46 @@\n+// check-pass\n+//! Unless visibility is assumed, a transmutation should be rejected if the\n+//! destination type contains an unreachable field (e.g., a public field with a\n+//! private type). (This rule is distinct from type privacy, which still may\n+//! forbid naming such types.)\n+//!\n+//! This test exercises a tricky-to-implement instance of this principle: the\n+//! \"pub-in-priv trick\". In the below example, the type `dst::private::Zst` is\n+//! unreachable from `Context`.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+\n+    pub fn is_transmutable<Src, Dst, Context>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, true>\n+        // visibility IS assumed -------------------------------------^^^^\n+    {}\n+}\n+\n+mod src {\n+    #[repr(C)] pub(in super) struct Zst;\n+\n+    #[repr(C)] pub(in super) struct Src {\n+        pub(in super) field: Zst,\n+    }\n+}\n+\n+mod dst {\n+    mod private {\n+        #[repr(C)] pub struct Zst; // <- unreachable type\n+    }\n+\n+    #[repr(C)] pub(in super) struct Dst {\n+        pub(in super) field: private::Zst,\n+    }\n+}\n+\n+fn test() {\n+    struct Context;\n+    assert::is_transmutable::<src::Src, dst::Dst, Context>();\n+}"}, {"sha": "80b454fda560ff61bf1484de993f4314e0345282", "filename": "src/test/ui/transmutability/visibility/assume/should_accept_if_dst_has_unreachable_field.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fassume%2Fshould_accept_if_dst_has_unreachable_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fassume%2Fshould_accept_if_dst_has_unreachable_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fassume%2Fshould_accept_if_dst_has_unreachable_field.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,39 @@\n+//! If visibility is assumed, a transmutation should be accepted even if the\n+//! destination type contains an unreachable field (e.g., a public field with a\n+//! private type). (This rule is distinct from type privacy, which still may\n+//! forbid naming such types.)\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+\n+    pub fn is_transmutable<Src, Dst, Context>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, true>\n+        // visibility IS assumed -------------------------------------^^^^\n+    {}\n+}\n+\n+mod src {\n+    #[repr(C)] pub(self) struct Zst;\n+\n+    #[repr(C)] pub(in super) struct Src {\n+        pub(self) field: Zst,\n+    }\n+}\n+\n+mod dst {\n+    #[repr(C)] pub(self) struct Zst; // <- unreachable type\n+\n+    #[repr(C)] pub(in super) struct Dst {\n+        pub(in super) field: Zst, //~ ERROR private type\n+    }\n+}\n+\n+fn test() {\n+    struct Context;\n+    assert::is_transmutable::<src::Src, dst::Dst, Context>();\n+}"}, {"sha": "be83b7ce33f2404dbe6c76b3a4d5c320a16f8c22", "filename": "src/test/ui/transmutability/visibility/assume/should_accept_if_dst_has_unreachable_field.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fassume%2Fshould_accept_if_dst_has_unreachable_field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fassume%2Fshould_accept_if_dst_has_unreachable_field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fassume%2Fshould_accept_if_dst_has_unreachable_field.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,12 @@\n+error[E0446]: private type `dst::Zst` in public interface\n+  --> $DIR/should_accept_if_dst_has_unreachable_field.rs:32:9\n+   |\n+LL |     #[repr(C)] pub(self) struct Zst; // <- unreachable type\n+   |                -------------------- `dst::Zst` declared as private\n+...\n+LL |         pub(in super) field: Zst,\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0446`."}, {"sha": "7c53c91e4eda7b0457a215884f7b6ca1ab72bc11", "filename": "src/test/ui/transmutability/visibility/assume/should_accept_if_dst_has_unreachable_ty.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fassume%2Fshould_accept_if_dst_has_unreachable_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fassume%2Fshould_accept_if_dst_has_unreachable_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fassume%2Fshould_accept_if_dst_has_unreachable_ty.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,40 @@\n+//! If visibility is assumed, a transmutation should be accepted even if the\n+//! destination type contains an unreachable field (e.g., a public field with a\n+//! private type). (This rule is distinct from type privacy, which still may\n+//! forbid naming such types.)\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+\n+    pub fn is_transmutable<Src, Dst, Context>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, true>\n+        // visibility IS assumed -------------------------------------^^^^\n+    {}\n+}\n+\n+mod src {\n+    #[repr(C)] pub(self) struct Zst;\n+\n+    #[repr(C)] pub(in super) struct Src {\n+        pub(self) field: Zst,\n+    }\n+}\n+\n+mod dst {\n+    #[repr(C)] pub(in super) struct Zst;\n+\n+    // unreachable type\n+    #[repr(C)] pub(self) struct Dst {\n+        pub(in super) field: Zst,\n+    }\n+}\n+\n+fn test() {\n+    struct Context;\n+    assert::is_transmutable::<src::Src, dst::Dst, Context>(); //~ ERROR `Dst` is private\n+}"}, {"sha": "827df05decb8fba817f084fdf91fa624f37fdc59", "filename": "src/test/ui/transmutability/visibility/assume/should_accept_if_dst_has_unreachable_ty.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fassume%2Fshould_accept_if_dst_has_unreachable_ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fassume%2Fshould_accept_if_dst_has_unreachable_ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fassume%2Fshould_accept_if_dst_has_unreachable_ty.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,15 @@\n+error[E0603]: struct `Dst` is private\n+  --> $DIR/should_accept_if_dst_has_unreachable_ty.rs:39:46\n+   |\n+LL |     assert::is_transmutable::<src::Src, dst::Dst, Context>();\n+   |                                              ^^^ private struct\n+   |\n+note: the struct `Dst` is defined here\n+  --> $DIR/should_accept_if_dst_has_unreachable_ty.rs:32:16\n+   |\n+LL |     #[repr(C)] pub(self) struct Dst {\n+   |                ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0603`."}, {"sha": "c3f298f01632568d95f5180cf9ab5d45a23445e5", "filename": "src/test/ui/transmutability/visibility/should_accept_if_src_has_private_field.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_accept_if_src_has_private_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_accept_if_src_has_private_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_accept_if_src_has_private_field.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,38 @@\n+// check-pass\n+//! The presence of a private field in the source type does not affect\n+//! transmutability.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+\n+    pub fn is_transmutable<Src, Dst, Context>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+        // visibility is NOT assumed ---------------------------------^^^^^\n+    {}\n+}\n+\n+mod src {\n+    #[repr(C)] pub(in super) struct Zst;\n+\n+    #[repr(C)] pub(in super) struct Src {\n+        pub(self) field: Zst, // <- private field\n+    }\n+}\n+\n+mod dst {\n+    #[repr(C)] pub(in super) struct Zst;\n+\n+    #[repr(C)] pub(in super) struct Dst {\n+        pub(in super) field: Zst,\n+    }\n+}\n+\n+fn test() {\n+    struct Context;\n+    assert::is_transmutable::<src::Src, dst::Dst, Context>();\n+}"}, {"sha": "73f6aece51eb539698eecf09d28ac515f35573ea", "filename": "src/test/ui/transmutability/visibility/should_accept_if_src_has_private_variant.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_accept_if_src_has_private_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_accept_if_src_has_private_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_accept_if_src_has_private_variant.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,39 @@\n+// check-pass\n+//! The presence of a private variant in the source type does not affect\n+//! transmutability.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+\n+    pub fn is_transmutable<Src, Dst, Context>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+        // visibility is NOT assumed ---------------------------------^^^^^\n+    {}\n+}\n+\n+mod src {\n+    #[derive(Copy, Clone)]\n+    #[repr(C)] pub(in super) struct Zst;\n+\n+    #[repr(C)] pub(in super) union Src {\n+        pub(self) field: Zst, // <- private variant\n+    }\n+}\n+\n+mod dst {\n+    #[repr(C)] pub(in super) struct Zst;\n+\n+    #[repr(C)] pub(in super) struct Dst {\n+        pub(in super) field: Zst,\n+    }\n+}\n+\n+fn test() {\n+    struct Context;\n+    assert::is_transmutable::<src::Src, dst::Dst, Context>();\n+}"}, {"sha": "6d602601e96abc2e5e2ecaf73dd65fea80f8883e", "filename": "src/test/ui/transmutability/visibility/should_accept_if_src_has_unreachable_field.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_accept_if_src_has_unreachable_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_accept_if_src_has_unreachable_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_accept_if_src_has_unreachable_field.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,38 @@\n+//! The presence of an unreachable field in the source type (e.g., a public\n+//! field with a private type does not affect transmutability. (This rule is\n+//! distinct from type privacy, which still may forbid naming such types.)\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+\n+    pub fn is_transmutable<Src, Dst, Context>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+        // visibility is NOT assumed ---------------------------------^^^^^\n+    {}\n+}\n+\n+mod src {\n+    #[repr(C)] pub(self) struct Zst; // <- unreachable type\n+\n+    #[repr(C)] pub(in super) struct Src {\n+        pub(in super) field: Zst, //~ ERROR private type\n+    }\n+}\n+\n+mod dst {\n+    #[repr(C)] pub(in super) struct Zst;\n+\n+    #[repr(C)] pub(in super) struct Dst {\n+        pub(in super) field: Zst,\n+    }\n+}\n+\n+fn test() {\n+    struct Context;\n+    assert::is_transmutable::<src::Src, dst::Dst, Context>();\n+}"}, {"sha": "3f7d08d0ae24857138a7b3ba8dda9121f5057c3a", "filename": "src/test/ui/transmutability/visibility/should_accept_if_src_has_unreachable_field.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_accept_if_src_has_unreachable_field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_accept_if_src_has_unreachable_field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_accept_if_src_has_unreachable_field.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,12 @@\n+error[E0446]: private type `src::Zst` in public interface\n+  --> $DIR/should_accept_if_src_has_unreachable_field.rs:23:9\n+   |\n+LL |     #[repr(C)] pub(self) struct Zst; // <- unreachable type\n+   |                -------------------- `src::Zst` declared as private\n+...\n+LL |         pub(in super) field: Zst,\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0446`."}, {"sha": "1943fb8716a111596039cedf638cc834282a66ac", "filename": "src/test/ui/transmutability/visibility/should_accept_if_src_has_unreachable_ty.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_accept_if_src_has_unreachable_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_accept_if_src_has_unreachable_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_accept_if_src_has_unreachable_ty.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,39 @@\n+//! The presence of an unreachable source type (i.e., the source type is\n+//! private) does not affect transmutability. (This rule is distinct from type\n+//! privacy, which still may forbid naming such types.)\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+\n+    pub fn is_transmutable<Src, Dst, Context>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+        // visibility is NOT assumed ---------------------------------^^^^^\n+    {}\n+}\n+\n+mod src {\n+    #[repr(C)] pub(in super) struct Zst;\n+\n+    // unreachable type\n+    #[repr(C)] pub(self) struct Src {\n+        pub(in super) field: Zst,\n+    }\n+}\n+\n+mod dst {\n+    #[repr(C)] pub(in super) struct Zst;\n+\n+    #[repr(C)] pub(in super) struct Dst {\n+        pub(in super) field: Zst,\n+    }\n+}\n+\n+fn test() {\n+    struct Context;\n+    assert::is_transmutable::<src::Src, dst::Dst, Context>(); //~ ERROR `Src` is private\n+}"}, {"sha": "e961984e189322ec4026609ed46276507682695c", "filename": "src/test/ui/transmutability/visibility/should_accept_if_src_has_unreachable_ty.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_accept_if_src_has_unreachable_ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_accept_if_src_has_unreachable_ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_accept_if_src_has_unreachable_ty.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,15 @@\n+error[E0603]: struct `Src` is private\n+  --> $DIR/should_accept_if_src_has_unreachable_ty.rs:38:36\n+   |\n+LL |     assert::is_transmutable::<src::Src, dst::Dst, Context>();\n+   |                                    ^^^ private struct\n+   |\n+note: the struct `Src` is defined here\n+  --> $DIR/should_accept_if_src_has_unreachable_ty.rs:23:16\n+   |\n+LL |     #[repr(C)] pub(self) struct Src {\n+   |                ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0603`."}, {"sha": "04cb6885887f41e58af1323138947a5d503009d2", "filename": "src/test/ui/transmutability/visibility/should_reject_if_dst_has_private_field.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_private_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_private_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_private_field.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,37 @@\n+//! Unless visibility is assumed, a transmutation should be rejected if the\n+//! destination type contains a private field.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+\n+    pub fn is_transmutable<Src, Dst, Context>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+        // visibility is NOT assumed ---------------------------------^^^^^\n+    {}\n+}\n+\n+mod src {\n+    #[repr(C)] pub(in super) struct Zst;\n+\n+    #[repr(C)] pub(in super) struct Src {\n+        pub(in super) field: Zst,\n+    }\n+}\n+\n+mod dst {\n+    #[repr(C)] pub(in super) struct Zst;\n+\n+    #[repr(C)] pub(in super) struct Dst {\n+        pub(self) field: Zst, // <- private field\n+    }\n+}\n+\n+fn test() {\n+    struct Context;\n+    assert::is_transmutable::<src::Src, dst::Dst, Context>(); //~ ERROR not satisfied\n+}"}, {"sha": "4dfbfaeafb64839cf1a4f1c07bb2a3adb1c05aa2", "filename": "src/test/ui/transmutability/visibility/should_reject_if_dst_has_private_field.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_private_field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_private_field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_private_field.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: the trait bound `Dst: BikeshedIntrinsicFrom<Src, test::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/should_reject_if_dst_has_private_field.rs:36:41\n+   |\n+LL |     assert::is_transmutable::<src::Src, dst::Dst, Context>();\n+   |                                         ^^^^^^^^ the trait `BikeshedIntrinsicFrom<Src, test::Context, false, false, false, false>` is not implemented for `Dst`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/should_reject_if_dst_has_private_field.rs:13:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "768e7bc559efeb459a58bc27c1d291496d779713", "filename": "src/test/ui/transmutability/visibility/should_reject_if_dst_has_private_variant.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_private_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_private_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_private_variant.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,38 @@\n+//! Unless visibility is assumed, a transmutation should be rejected if the\n+//! destination type contains a private variant.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+\n+    pub fn is_transmutable<Src, Dst, Context>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+        // visibility is NOT assumed ---------------------------------^^^^^\n+    {}\n+}\n+\n+mod src {\n+    #[repr(C)] pub(in super) struct Zst;\n+\n+    #[repr(C)] pub(in super) struct Src {\n+        pub(in super) field: Zst,\n+    }\n+}\n+\n+mod dst {\n+    #[derive(Copy, Clone)]\n+    #[repr(C)] pub(in super) struct Zst;\n+\n+    #[repr(C)] pub(in super) union Dst {\n+        pub(self) field: Zst, // <- private variant\n+    }\n+}\n+\n+fn test() {\n+    struct Context;\n+    assert::is_transmutable::<src::Src, dst::Dst, Context>(); //~ ERROR not satisfied\n+}"}, {"sha": "ed834a1bd258705cf2e5ea9c3857fc02ee49e654", "filename": "src/test/ui/transmutability/visibility/should_reject_if_dst_has_private_variant.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_private_variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_private_variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_private_variant.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: the trait bound `Dst: BikeshedIntrinsicFrom<Src, test::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/should_reject_if_dst_has_private_variant.rs:37:41\n+   |\n+LL |     assert::is_transmutable::<src::Src, dst::Dst, Context>();\n+   |                                         ^^^^^^^^ the trait `BikeshedIntrinsicFrom<Src, test::Context, false, false, false, false>` is not implemented for `Dst`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/should_reject_if_dst_has_private_variant.rs:13:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "c44fed4cce3925f1c76edc4ad019e9a065fbf3ee", "filename": "src/test/ui/transmutability/visibility/should_reject_if_dst_has_tricky_unreachable_field.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_tricky_unreachable_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_tricky_unreachable_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_tricky_unreachable_field.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,52 @@\n+// check-pass\n+//! NOTE: This test documents a known-bug in the implementation of the\n+//! transmutability trait. Once fixed, the above \"check-pass\" header should be\n+//! removed, and an \"ERROR not satisfied\" annotation should be added at the end\n+//! of the line starting with `assert::is_transmutable`.\n+//!\n+//! Unless visibility is assumed, a transmutation should be rejected if the\n+//! destination type contains an unreachable field (e.g., a public field with a\n+//! private type). (This rule is distinct from type privacy, which still may\n+//! forbid naming such types.)\n+//!\n+//! This test exercises a tricky-to-implement instance of this principle: the\n+//! \"pub-in-priv trick\". In the below example, the type `dst::private::Zst` is\n+//! unreachable from `Context`. Consequently, the transmute from `Src` to `Dst`\n+//! SHOULD be rejected.\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+\n+    pub fn is_transmutable<Src, Dst, Context>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+        // visibility is NOT assumed ---------------------------------^^^^^\n+    {}\n+}\n+\n+mod src {\n+    #[repr(C)] pub(in super) struct Zst;\n+\n+    #[repr(C)] pub(in super) struct Src {\n+        pub(in super) field: Zst,\n+    }\n+}\n+\n+mod dst {\n+    mod private {\n+        #[repr(C)] pub struct Zst; // <- unreachable type\n+    }\n+\n+    #[repr(C)] pub(in super) struct Dst {\n+        pub(in super) field: private::Zst,\n+    }\n+}\n+\n+fn test() {\n+    struct Context;\n+    assert::is_transmutable::<src::Src, dst::Dst, Context>();\n+}"}, {"sha": "dbef149bacc996b0f92ab3401983c51749cd9d8f", "filename": "src/test/ui/transmutability/visibility/should_reject_if_dst_has_unreachable_field.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_unreachable_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_unreachable_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_unreachable_field.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,39 @@\n+//! Unless visibility is assumed, a transmutation should be rejected if the\n+//! destination type contains an unreachable field (e.g., a public field with a\n+//! private type). (This rule is distinct from type privacy, which still may\n+//! forbid naming such types.)\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+\n+    pub fn is_transmutable<Src, Dst, Context>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+        // visibility is NOT assumed ---------------------------------^^^^^\n+    {}\n+}\n+\n+mod src {\n+    #[repr(C)] pub(in super) struct Zst;\n+\n+    #[repr(C)] pub(in super) struct Src {\n+        pub(in super) field: Zst,\n+    }\n+}\n+\n+mod dst {\n+    #[repr(C)] pub(self) struct Zst; // <- unreachable type\n+\n+    #[repr(C)] pub(in super) struct Dst {\n+        pub(in super) field: Zst,\n+    }\n+}\n+\n+fn test() {\n+    struct Context;\n+    assert::is_transmutable::<src::Src, dst::Dst, Context>(); //~ ERROR not satisfied\n+}"}, {"sha": "3029d6ab8eeee5cfae5b13a0eaecda22b03aec63", "filename": "src/test/ui/transmutability/visibility/should_reject_if_dst_has_unreachable_field.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_unreachable_field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_unreachable_field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_unreachable_field.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: the trait bound `Dst: BikeshedIntrinsicFrom<Src, test::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/should_reject_if_dst_has_unreachable_field.rs:38:41\n+   |\n+LL |     assert::is_transmutable::<src::Src, dst::Dst, Context>();\n+   |                                         ^^^^^^^^ the trait `BikeshedIntrinsicFrom<Src, test::Context, false, false, false, false>` is not implemented for `Dst`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/should_reject_if_dst_has_unreachable_field.rs:15:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "c5947eceb656ec206f1d239f9bcfedcf8131a4c3", "filename": "src/test/ui/transmutability/visibility/should_reject_if_dst_has_unreachable_ty.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_unreachable_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_unreachable_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_unreachable_ty.rs?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,42 @@\n+//! Unless visibility is assumed, a transmutation should be rejected if the\n+//! destination type contains an unreachable field (e.g., a public field with a\n+//! private type). (This rule is distinct from type privacy, which still may\n+//! forbid naming such types.)\n+\n+#![crate_type = \"lib\"]\n+#![feature(transmutability)]\n+#![allow(dead_code)]\n+\n+mod assert {\n+    use std::mem::BikeshedIntrinsicFrom;\n+\n+    pub fn is_transmutable<Src, Dst, Context>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+        // visibility is NOT assumed ---------------------------------^^^^^\n+    {}\n+}\n+\n+mod src {\n+    #[repr(C)] pub(in super) struct Zst;\n+\n+    #[repr(C)] pub(in super) struct Src {\n+        pub(in super) field: Zst,\n+    }\n+}\n+\n+mod dst {\n+    #[repr(C)] pub(in super) struct Zst;\n+\n+    // unreachable type\n+    #[repr(C)] pub(self) struct Dst {\n+        pub(in super) field: Zst,\n+    }\n+}\n+\n+fn test() {\n+    struct Context;\n+    assert::is_transmutable::<src::Src, dst::Dst, Context>();\n+    //~^ ERROR `Dst` is private\n+    //~| ERROR not satisfied\n+}"}, {"sha": "2fd3889032149ec8d99d7e7b0f1f29d828cba74e", "filename": "src/test/ui/transmutability/visibility/should_reject_if_dst_has_unreachable_ty.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_unreachable_ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4a1dea416e1695cf77acd17ea743d4d802bae0/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_unreachable_ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Fvisibility%2Fshould_reject_if_dst_has_unreachable_ty.stderr?ref=bc4a1dea416e1695cf77acd17ea743d4d802bae0", "patch": "@@ -0,0 +1,31 @@\n+error[E0603]: struct `Dst` is private\n+  --> $DIR/should_reject_if_dst_has_unreachable_ty.rs:39:46\n+   |\n+LL |     assert::is_transmutable::<src::Src, dst::Dst, Context>();\n+   |                                              ^^^ private struct\n+   |\n+note: the struct `Dst` is defined here\n+  --> $DIR/should_reject_if_dst_has_unreachable_ty.rs:32:16\n+   |\n+LL |     #[repr(C)] pub(self) struct Dst {\n+   |                ^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: the trait bound `Dst: BikeshedIntrinsicFrom<Src, test::Context, false, false, false, false>` is not satisfied\n+  --> $DIR/should_reject_if_dst_has_unreachable_ty.rs:39:41\n+   |\n+LL |     assert::is_transmutable::<src::Src, dst::Dst, Context>();\n+   |                                         ^^^^^^^^ the trait `BikeshedIntrinsicFrom<Src, test::Context, false, false, false, false>` is not implemented for `Dst`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/should_reject_if_dst_has_unreachable_ty.rs:15:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, false, false, false, false>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0277, E0603.\n+For more information about an error, try `rustc --explain E0277`."}]}