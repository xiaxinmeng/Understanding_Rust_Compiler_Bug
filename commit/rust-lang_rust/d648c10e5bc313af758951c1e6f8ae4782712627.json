{"sha": "d648c10e5bc313af758951c1e6f8ae4782712627", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2NDhjMTBlNWJjMzEzYWY3NTg5NTFjMWU2ZjhhZTQ3ODI3MTI2Mjc=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-04-13T19:37:05Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-04-17T18:25:35Z"}, "message": "libsyntax/parse: improve associated item error reporting\n\nFixes #41161.\nFixes #41239.", "tree": {"sha": "7a2ff60df5153e90f07e9494bd6aa1991a2027cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a2ff60df5153e90f07e9494bd6aa1991a2027cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d648c10e5bc313af758951c1e6f8ae4782712627", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d648c10e5bc313af758951c1e6f8ae4782712627", "html_url": "https://github.com/rust-lang/rust/commit/d648c10e5bc313af758951c1e6f8ae4782712627", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d648c10e5bc313af758951c1e6f8ae4782712627/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c58c928e658d2e45f816fd05796a964aa83759da", "url": "https://api.github.com/repos/rust-lang/rust/commits/c58c928e658d2e45f816fd05796a964aa83759da", "html_url": "https://github.com/rust-lang/rust/commit/c58c928e658d2e45f816fd05796a964aa83759da"}], "stats": {"total": 272, "additions": 191, "deletions": 81}, "files": [{"sha": "20a858b80df4769e37ef2376584d8cd8cb725230", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d648c10e5bc313af758951c1e6f8ae4782712627/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d648c10e5bc313af758951c1e6f8ae4782712627/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d648c10e5bc313af758951c1e6f8ae4782712627", "patch": "@@ -617,14 +617,14 @@ impl<'a> Parser<'a> {\n             ExpansionKind::TraitItems => {\n                 let mut items = SmallVector::new();\n                 while self.token != token::Eof {\n-                    items.push(self.parse_trait_item()?);\n+                    items.push(self.parse_trait_item(&mut false)?);\n                 }\n                 Expansion::TraitItems(items)\n             }\n             ExpansionKind::ImplItems => {\n                 let mut items = SmallVector::new();\n                 while self.token != token::Eof {\n-                    items.push(self.parse_impl_item()?);\n+                    items.push(self.parse_impl_item(&mut false)?);\n                 }\n                 Expansion::ImplItems(items)\n             }"}, {"sha": "dfb82d40d568da50d161d76f72fa0792abba1773", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 99, "deletions": 68, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/d648c10e5bc313af758951c1e6f8ae4782712627/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d648c10e5bc313af758951c1e6f8ae4782712627/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d648c10e5bc313af758951c1e6f8ae4782712627", "patch": "@@ -85,12 +85,18 @@ pub enum PathStyle {\n     Expr,\n }\n \n-#[derive(Clone, Copy, PartialEq)]\n+#[derive(Clone, Copy, Debug, PartialEq)]\n pub enum SemiColonMode {\n     Break,\n     Ignore,\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq)]\n+pub enum BlockMode {\n+    Break,\n+    Ignore,\n+}\n+\n /// Possibly accept an `token::Interpolated` expression (a pre-parsed expression\n /// dropped into the token stream, which happens while parsing the result of\n /// macro expansion). Placement of these is not as complex as I feared it would\n@@ -1204,7 +1210,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse the items in a trait declaration\n-    pub fn parse_trait_item(&mut self) -> PResult<'a, TraitItem> {\n+    pub fn parse_trait_item(&mut self, at_end: &mut bool) -> PResult<'a, TraitItem> {\n         maybe_whole!(self, NtTraitItem, |x| x);\n         let mut attrs = self.parse_outer_attributes()?;\n         let lo = self.span;\n@@ -1214,7 +1220,7 @@ impl<'a> Parser<'a> {\n             self.expect(&token::Semi)?;\n             (ident, TraitItemKind::Type(bounds, default))\n         } else if self.is_const_item() {\n-                self.expect_keyword(keywords::Const)?;\n+            self.expect_keyword(keywords::Const)?;\n             let ident = self.parse_ident()?;\n             self.expect(&token::Colon)?;\n             let ty = self.parse_ty()?;\n@@ -1231,9 +1237,17 @@ impl<'a> Parser<'a> {\n         } else if self.token.is_path_start() {\n             // trait item macro.\n             // code copied from parse_macro_use_or_failure... abstraction!\n+            let prev_span = self.prev_span;\n             let lo = self.span;\n             let pth = self.parse_path(PathStyle::Mod)?;\n-            self.expect(&token::Not)?;\n+\n+            if pth.segments.len() == 1 {\n+                if !self.eat(&token::Not) {\n+                    return Err(self.missing_assoc_item_kind_err(\"trait\", prev_span));\n+                }\n+            } else {\n+                self.expect(&token::Not)?;\n+            }\n \n             // eat a matched-delimiter token tree:\n             let (delim, tts) = self.expect_delimited_token_tree()?;\n@@ -1246,25 +1260,7 @@ impl<'a> Parser<'a> {\n         } else {\n             let (constness, unsafety, abi) = match self.parse_fn_front_matter() {\n                 Ok(cua) => cua,\n-                Err(e) => {\n-                    loop {\n-                        match self.token {\n-                            token::Eof => break,\n-                            token::CloseDelim(token::Brace) |\n-                            token::Semi => {\n-                                self.bump();\n-                                break;\n-                            }\n-                            token::OpenDelim(token::Brace) => {\n-                                self.parse_token_tree();\n-                                break;\n-                            }\n-                            _ => self.bump(),\n-                        }\n-                    }\n-\n-                    return Err(e);\n-                }\n+                Err(e) => return Err(e),\n             };\n \n             let ident = self.parse_ident()?;\n@@ -1289,11 +1285,13 @@ impl<'a> Parser<'a> {\n             let body = match self.token {\n                 token::Semi => {\n                     self.bump();\n+                    *at_end = true;\n                     debug!(\"parse_trait_methods(): parsing required method\");\n                     None\n                 }\n                 token::OpenDelim(token::Brace) => {\n                     debug!(\"parse_trait_methods(): parsing provided method\");\n+                    *at_end = true;\n                     let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n                     attrs.extend(inner_attrs.iter().cloned());\n                     Some(body)\n@@ -1315,18 +1313,6 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-\n-    /// Parse the items in a trait declaration\n-    pub fn parse_trait_items(&mut self) -> PResult<'a,  Vec<TraitItem>> {\n-        self.parse_unspanned_seq(\n-            &token::OpenDelim(token::Brace),\n-            &token::CloseDelim(token::Brace),\n-            SeqSep::none(),\n-            |p| -> PResult<'a, TraitItem> {\n-                p.parse_trait_item()\n-            })\n-    }\n-\n     /// Parse optional return type [ -> TY ] in function decl\n     pub fn parse_ret_ty(&mut self) -> PResult<'a, FunctionRetTy> {\n         if self.eat(&token::RArrow) {\n@@ -3641,22 +3627,33 @@ impl<'a> Parser<'a> {\n     //\n     // We terminate when we find an unmatched `}` (without consuming it).\n     fn recover_stmt(&mut self) {\n-        self.recover_stmt_(SemiColonMode::Ignore)\n+        self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore)\n     }\n+\n     // If `break_on_semi` is `Break`, then we will stop consuming tokens after\n     // finding (and consuming) a `;` outside of `{}` or `[]` (note that this is\n     // approximate - it can mean we break too early due to macros, but that\n     // shoud only lead to sub-optimal recovery, not inaccurate parsing).\n-    fn recover_stmt_(&mut self, break_on_semi: SemiColonMode) {\n+    //\n+    // If `break_on_block` is `Break`, then we will stop consuming tokens\n+    // after finding (and consuming) a brace-delimited block.\n+    fn recover_stmt_(&mut self, break_on_semi: SemiColonMode, break_on_block: BlockMode) {\n         let mut brace_depth = 0;\n         let mut bracket_depth = 0;\n-        debug!(\"recover_stmt_ enter loop\");\n+        let mut in_block = false;\n+        debug!(\"recover_stmt_ enter loop (semi={:?}, block={:?})\",\n+               break_on_semi, break_on_block);\n         loop {\n             debug!(\"recover_stmt_ loop {:?}\", self.token);\n             match self.token {\n                 token::OpenDelim(token::DelimToken::Brace) => {\n                     brace_depth += 1;\n                     self.bump();\n+                    if break_on_block == BlockMode::Break &&\n+                       brace_depth == 1 &&\n+                       bracket_depth == 0 {\n+                        in_block = true;\n+                    }\n                 }\n                 token::OpenDelim(token::DelimToken::Bracket) => {\n                     bracket_depth += 1;\n@@ -3669,6 +3666,10 @@ impl<'a> Parser<'a> {\n                     }\n                     brace_depth -= 1;\n                     self.bump();\n+                    if in_block && bracket_depth == 0 && brace_depth == 0 {\n+                        debug!(\"recover_stmt_ return - block end {:?}\", self.token);\n+                        return;\n+                    }\n                 }\n                 token::CloseDelim(token::DelimToken::Bracket) => {\n                     bracket_depth -= 1;\n@@ -3700,7 +3701,7 @@ impl<'a> Parser<'a> {\n     fn parse_stmt_(&mut self, macro_legacy_warnings: bool) -> Option<Stmt> {\n         self.parse_stmt_without_recovery(macro_legacy_warnings).unwrap_or_else(|mut e| {\n             e.emit();\n-            self.recover_stmt_(SemiColonMode::Break);\n+            self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n             None\n         })\n     }\n@@ -3974,7 +3975,7 @@ impl<'a> Parser<'a> {\n                     e.span_suggestion(stmt_span, \"try placing this code inside a block\", sugg);\n                 }\n                 Err(mut e) => {\n-                    self.recover_stmt_(SemiColonMode::Break);\n+                    self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n                     self.cancel(&mut e);\n                 }\n                 _ => ()\n@@ -4663,7 +4664,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an impl item.\n-    pub fn parse_impl_item(&mut self) -> PResult<'a, ImplItem> {\n+    pub fn parse_impl_item(&mut self, at_end: &mut bool) -> PResult<'a, ImplItem> {\n         maybe_whole!(self, NtImplItem, |x| x);\n \n         let mut attrs = self.parse_outer_attributes()?;\n@@ -4686,7 +4687,7 @@ impl<'a> Parser<'a> {\n             self.expect(&token::Semi)?;\n             (name, ast::ImplItemKind::Const(typ, expr))\n         } else {\n-            let (name, inner_attrs, node) = self.parse_impl_method(&vis)?;\n+            let (name, inner_attrs, node) = self.parse_impl_method(&vis, at_end)?;\n             attrs.extend(inner_attrs);\n             (name, node)\n         };\n@@ -4731,43 +4732,50 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    fn missing_assoc_item_kind_err(&mut self, item_type: &str, prev_span: Span)\n+                                   -> DiagnosticBuilder<'a>\n+    {\n+        // Given this code `path(`, it seems like this is not\n+        // setting the visibility of a macro invocation, but rather\n+        // a mistyped method declaration.\n+        // Create a diagnostic pointing out that `fn` is missing.\n+        //\n+        // x |     pub path(&self) {\n+        //   |        ^ missing `fn`, `type`, or `const`\n+        //     pub  path(\n+        //        ^^ `sp` below will point to this\n+        let sp = prev_span.between(self.prev_span);\n+        let mut err = self.diagnostic().struct_span_err(\n+            sp,\n+            &format!(\"missing `fn`, `type`, or `const` for {}-item declaration\",\n+                     item_type));\n+        err.span_label(sp, &\"missing `fn`, `type`, or `const`\");\n+        err\n+    }\n+\n     /// Parse a method or a macro invocation in a trait impl.\n-    fn parse_impl_method(&mut self, vis: &Visibility)\n+    fn parse_impl_method(&mut self, vis: &Visibility, at_end: &mut bool)\n                          -> PResult<'a, (Ident, Vec<ast::Attribute>, ast::ImplItemKind)> {\n         // code copied from parse_macro_use_or_failure... abstraction!\n         if self.token.is_path_start() {\n             // Method macro.\n \n             let prev_span = self.prev_span;\n-            // Before complaining about trying to set a macro as `pub`,\n-            // check if `!` comes after the path.\n-            let err = self.complain_if_pub_macro_diag(&vis, prev_span);\n \n             let lo = self.span;\n             let pth = self.parse_path(PathStyle::Mod)?;\n-            let bang_err = self.expect(&token::Not);\n-            if let Err(mut err) = err {\n-                if let Err(mut bang_err) = bang_err {\n-                    // Given this code `pub path(`, it seems like this is not setting the\n-                    // visibility of a macro invocation, but rather a mistyped method declaration.\n-                    // Create a diagnostic pointing out that `fn` is missing.\n-                    //\n-                    // x |     pub path(&self) {\n-                    //   |        ^ missing `fn` for method declaration\n-\n-                    err.cancel();\n-                    bang_err.cancel();\n-                    //     pub  path(\n-                    //        ^^ `sp` below will point to this\n-                    let sp = prev_span.between(self.prev_span);\n-                    err = self.diagnostic()\n-                        .struct_span_err(sp, \"missing `fn` for method declaration\");\n-                    err.span_label(sp, &\"missing `fn`\");\n+            if pth.segments.len() == 1 {\n+                if !self.eat(&token::Not) {\n+                    return Err(self.missing_assoc_item_kind_err(\"impl\", prev_span));\n                 }\n-                return Err(err);\n+            } else {\n+                self.expect(&token::Not)?;\n             }\n \n+            self.complain_if_pub_macro(&vis, prev_span);\n+\n             // eat a matched-delimiter token tree:\n+            *at_end = true;\n             let (delim, tts) = self.expect_delimited_token_tree()?;\n             if delim != token::Brace {\n                 self.expect(&token::Semi)?\n@@ -4781,6 +4789,7 @@ impl<'a> Parser<'a> {\n             let mut generics = self.parse_generics()?;\n             let decl = self.parse_fn_decl_with_self(|p| p.parse_arg())?;\n             generics.where_clause = self.parse_where_clause()?;\n+            *at_end = true;\n             let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n             Ok((ident, inner_attrs, ast::ImplItemKind::Method(ast::MethodSig {\n                 generics: generics,\n@@ -4806,8 +4815,21 @@ impl<'a> Parser<'a> {\n \n         tps.where_clause = self.parse_where_clause()?;\n \n-        let meths = self.parse_trait_items()?;\n-        Ok((ident, ItemKind::Trait(unsafety, tps, bounds, meths), None))\n+        self.expect(&token::OpenDelim(token::Brace))?;\n+        let mut trait_items = vec![];\n+        while !self.eat(&token::CloseDelim(token::Brace)) {\n+            let mut at_end = false;\n+            match self.parse_trait_item(&mut at_end) {\n+                Ok(item) => trait_items.push(item),\n+                Err(mut e) => {\n+                    e.emit();\n+                    if !at_end {\n+                        self.recover_stmt_(SemiColonMode::Break, BlockMode::Break);\n+                    }\n+                }\n+            }\n+        }\n+        Ok((ident, ItemKind::Trait(unsafety, tps, bounds, trait_items), None))\n     }\n \n     /// Parses items implementations variants\n@@ -4882,7 +4904,16 @@ impl<'a> Parser<'a> {\n \n             let mut impl_items = vec![];\n             while !self.eat(&token::CloseDelim(token::Brace)) {\n-                impl_items.push(self.parse_impl_item()?);\n+                let mut at_end = false;\n+                match self.parse_impl_item(&mut at_end) {\n+                    Ok(item) => impl_items.push(item),\n+                    Err(mut e) => {\n+                        e.emit();\n+                        if !at_end {\n+                            self.recover_stmt_(SemiColonMode::Break, BlockMode::Break);\n+                        }\n+                    }\n+                }\n             }\n \n             Ok((keywords::Invalid.ident(),"}, {"sha": "b6d95ffb911caba717e9ef07f1302227aefcb3ad", "filename": "src/test/parse-fail/issue-21153.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d648c10e5bc313af758951c1e6f8ae4782712627/src%2Ftest%2Fparse-fail%2Fissue-21153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d648c10e5bc313af758951c1e6f8ae4782712627/src%2Ftest%2Fparse-fail%2Fissue-21153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-21153.rs?ref=d648c10e5bc313af758951c1e6f8ae4782712627", "patch": "@@ -10,7 +10,6 @@\n \n // compile-flags: -Z parse-only\n \n-trait MyTrait<T>: Iterator {\n-    Item = T; //~ ERROR expected one of `!` or `::`, found `=`\n-              //~| ERROR expected item, found `=`\n+trait MyTrait<T>: Iterator { //~ ERROR missing `fn`, `type`, or `const`\n+    Item = T;\n }"}, {"sha": "6bc24e2081d19c9400f7eda02d0a273580debf1d", "filename": "src/test/parse-fail/trait-pub-assoc-const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d648c10e5bc313af758951c1e6f8ae4782712627/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d648c10e5bc313af758951c1e6f8ae4782712627/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-const.rs?ref=d648c10e5bc313af758951c1e6f8ae4782712627", "patch": "@@ -10,7 +10,7 @@\n \n trait Foo {\n     pub const Foo: u32;\n-     //~^ ERROR expected one of `const`, `extern`, `fn`, `type`, or `unsafe`, found `pub`\n+    //~^ ERROR expected one of `const`, `extern`, `fn`, `type`, `unsafe`, or `}`, found `pub`\n }\n \n fn main() {}"}, {"sha": "493ff087eaf9ec009c9eddaa9ff385707c0b3795", "filename": "src/test/parse-fail/trait-pub-assoc-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d648c10e5bc313af758951c1e6f8ae4782712627/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d648c10e5bc313af758951c1e6f8ae4782712627/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-ty.rs?ref=d648c10e5bc313af758951c1e6f8ae4782712627", "patch": "@@ -10,7 +10,7 @@\n \n trait Foo {\n     pub type Foo;\n-    //~^ ERROR expected one of `const`, `extern`, `fn`, `type`, or `unsafe`, found `pub`\n+    //~^ ERROR expected one of `const`, `extern`, `fn`, `type`, `unsafe`, or `}`, found `pub`\n }\n \n fn main() {}"}, {"sha": "c2ee3c31d885b87091affe6ee199bcb3f200b971", "filename": "src/test/parse-fail/trait-pub-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d648c10e5bc313af758951c1e6f8ae4782712627/src%2Ftest%2Fparse-fail%2Ftrait-pub-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d648c10e5bc313af758951c1e6f8ae4782712627/src%2Ftest%2Fparse-fail%2Ftrait-pub-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-pub-method.rs?ref=d648c10e5bc313af758951c1e6f8ae4782712627", "patch": "@@ -10,7 +10,7 @@\n \n trait Foo {\n     pub fn foo();\n-    //~^ ERROR expected one of `const`, `extern`, `fn`, `type`, or `unsafe`, found `pub`\n+    //~^ ERROR expected one of `const`, `extern`, `fn`, `type`, `unsafe`, or `}`, found `pub`\n }\n \n fn main() {}"}, {"sha": "d68c25faa8a847699043b5f7c48fcf77f3fe84fa", "filename": "src/test/ui/did_you_mean/issue-40006.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d648c10e5bc313af758951c1e6f8ae4782712627/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d648c10e5bc313af758951c1e6f8ae4782712627/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.rs?ref=d648c10e5bc313af758951c1e6f8ae4782712627", "patch": "@@ -8,8 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+impl X {\n+    Y\n+}\n+\n struct S;\n \n+trait X {\n+    X() {}\n+    fn xxx() { ### }\n+    L = M;\n+    Z = { 2 + 3 };\n+    ::Y ();\n+}\n+\n impl S {\n     pub hello_method(&self) {\n         println!(\"Hello\");"}, {"sha": "29ff0cee3af5c1d82dfb74756dc9ced2803faaa4", "filename": "src/test/ui/did_you_mean/issue-40006.stderr", "status": "modified", "additions": 64, "deletions": 4, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d648c10e5bc313af758951c1e6f8ae4782712627/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d648c10e5bc313af758951c1e6f8ae4782712627/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr?ref=d648c10e5bc313af758951c1e6f8ae4782712627", "patch": "@@ -1,8 +1,68 @@\n-error: missing `fn` for method declaration\n-  --> $DIR/issue-40006.rs:14:8\n+error: missing `fn`, `type`, or `const` for impl-item declaration\n+  --> $DIR/issue-40006.rs:11:9\n    |\n-14 |     pub hello_method(&self) {\n-   |        ^ missing `fn`\n+11 |   impl X {\n+   |  _________^ starting here...\n+12 | |     Y\n+   | |____^ ...ending here: missing `fn`, `type`, or `const`\n+\n+error: missing `fn`, `type`, or `const` for trait-item declaration\n+  --> $DIR/issue-40006.rs:17:10\n+   |\n+17 |   trait X {\n+   |  __________^ starting here...\n+18 | |     X() {}\n+   | |____^ ...ending here: missing `fn`, `type`, or `const`\n+\n+error: expected `[`, found `#`\n+  --> $DIR/issue-40006.rs:19:17\n+   |\n+19 |     fn xxx() { ### }\n+   |                 ^\n+\n+error: missing `fn`, `type`, or `const` for trait-item declaration\n+  --> $DIR/issue-40006.rs:19:21\n+   |\n+19 |       fn xxx() { ### }\n+   |  _____________________^ starting here...\n+20 | |     L = M;\n+   | |____^ ...ending here: missing `fn`, `type`, or `const`\n+\n+error: missing `fn`, `type`, or `const` for trait-item declaration\n+  --> $DIR/issue-40006.rs:20:11\n+   |\n+20 |       L = M;\n+   |  ___________^ starting here...\n+21 | |     Z = { 2 + 3 };\n+   | |____^ ...ending here: missing `fn`, `type`, or `const`\n+\n+error: expected one of `const`, `extern`, `fn`, `type`, `unsafe`, or `}`, found `;`\n+  --> $DIR/issue-40006.rs:21:18\n+   |\n+21 |     Z = { 2 + 3 };\n+   |                  ^ expected one of `const`, `extern`, `fn`, `type`, `unsafe`, or `}` here\n+\n+error: expected one of `!` or `::`, found `(`\n+  --> $DIR/issue-40006.rs:22:9\n+   |\n+22 |     ::Y ();\n+   |        -^ unexpected token\n+   |        |\n+   |        expected one of `!` or `::` here\n+\n+error: missing `fn`, `type`, or `const` for impl-item declaration\n+  --> $DIR/issue-40006.rs:26:8\n+   |\n+26 |     pub hello_method(&self) {\n+   |        ^ missing `fn`, `type`, or `const`\n+\n+error[E0038]: the trait `X` cannot be made into an object\n+  --> $DIR/issue-40006.rs:11:6\n+   |\n+11 | impl X {\n+   |      ^ the trait `X` cannot be made into an object\n+   |\n+   = note: method `xxx` has no receiver\n \n error: aborting due to previous error\n "}, {"sha": "a6ad1206b14d06cfe19311025cef40c60d080f5a", "filename": "src/test/ui/token/issue-41155.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d648c10e5bc313af758951c1e6f8ae4782712627/src%2Ftest%2Fui%2Ftoken%2Fissue-41155.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d648c10e5bc313af758951c1e6f8ae4782712627/src%2Ftest%2Fui%2Ftoken%2Fissue-41155.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftoken%2Fissue-41155.stderr?ref=d648c10e5bc313af758951c1e6f8ae4782712627", "patch": "@@ -6,5 +6,13 @@ error: expected one of `(`, `const`, `default`, `extern`, `fn`, `type`, or `unsa\n 13 | }\n    | ^ unexpected token\n \n-error: aborting due to previous error\n+error[E0412]: cannot find type `S` in this scope\n+  --> $DIR/issue-41155.rs:11:6\n+   |\n+11 | impl S {\n+   |      ^ not found in this scope\n+\n+error: main function not found\n+\n+error: aborting due to 3 previous errors\n "}]}