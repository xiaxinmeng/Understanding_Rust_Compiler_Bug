{"sha": "eeeb2cc0dffc016582f020c0a9e6d9f9fc751397", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlZWIyY2MwZGZmYzAxNjU4MmYwMjBjMGE5ZTZkOWY5ZmM3NTEzOTc=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2015-05-15T13:20:42Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2015-05-15T13:30:22Z"}, "message": "Allow for better optimizations of iterators for zero-sized types\n\nUsing regular pointer arithmetic to iterate collections of zero-sized types\ndoesn't work, because we'd get the same pointer all the time. Our\ncurrent solution is to convert the pointer to an integer, add an offset\nand then convert back, but this inhibits certain optimizations.\n\nWhat we should do instead is to convert the pointer to one that points\nto an i8*, and then use a LLVM GEP instructions without the inbounds\nflag to perform the pointer arithmetic. This allows to generate pointers\nthat point outside allocated objects without causing UB (as long as you\ndon't dereference them), and it wraps around using two's complement,\ni.e. it behaves exactly like the wrapping_* operations we're currently\nusing, with the added benefit of LLVM being able to better optimize the\nresulting IR.", "tree": {"sha": "0218029e9937bf8ad03f8a8071ae2b6dcb1c6d2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0218029e9937bf8ad03f8a8071ae2b6dcb1c6d2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eeeb2cc0dffc016582f020c0a9e6d9f9fc751397", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eeeb2cc0dffc016582f020c0a9e6d9f9fc751397", "html_url": "https://github.com/rust-lang/rust/commit/eeeb2cc0dffc016582f020c0a9e6d9f9fc751397", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eeeb2cc0dffc016582f020c0a9e6d9f9fc751397/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "579e31929feff51dcaf8d444648eff8de735f91a", "url": "https://api.github.com/repos/rust-lang/rust/commits/579e31929feff51dcaf8d444648eff8de735f91a", "html_url": "https://github.com/rust-lang/rust/commit/579e31929feff51dcaf8d444648eff8de735f91a"}], "stats": {"total": 265, "additions": 219, "deletions": 46}, "files": [{"sha": "4f3c3b0826342f676a1d219fc874ccd36614fc38", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/eeeb2cc0dffc016582f020c0a9e6d9f9fc751397/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeeb2cc0dffc016582f020c0a9e6d9f9fc751397/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=eeeb2cc0dffc016582f020c0a9e6d9f9fc751397", "patch": "@@ -19,6 +19,8 @@ pub use self::TraversalItem::*;\n use core::prelude::*;\n \n use core::cmp::Ordering::{Greater, Less, Equal};\n+#[cfg(not(stage0))]\n+use core::intrinsics::arith_offset;\n use core::iter::Zip;\n use core::marker::PhantomData;\n use core::ops::{Deref, DerefMut, Index, IndexMut};\n@@ -205,6 +207,7 @@ impl<T> RawItems<T> {\n         RawItems::from_parts(slice.as_ptr(), slice.len())\n     }\n \n+    #[cfg(stage0)]\n     unsafe fn from_parts(ptr: *const T, len: usize) -> RawItems<T> {\n         if mem::size_of::<T>() == 0 {\n             RawItems {\n@@ -219,6 +222,22 @@ impl<T> RawItems<T> {\n         }\n     }\n \n+    #[cfg(not(stage0))]\n+    unsafe fn from_parts(ptr: *const T, len: usize) -> RawItems<T> {\n+        if mem::size_of::<T>() == 0 {\n+            RawItems {\n+                head: ptr,\n+                tail: arith_offset(ptr as *const i8, len as isize) as *const T,\n+            }\n+        } else {\n+            RawItems {\n+                head: ptr,\n+                tail: ptr.offset(len as isize),\n+            }\n+        }\n+    }\n+\n+    #[cfg(stage0)]\n     unsafe fn push(&mut self, val: T) {\n         ptr::write(self.tail as *mut T, val);\n \n@@ -228,11 +247,23 @@ impl<T> RawItems<T> {\n             self.tail = self.tail.offset(1);\n         }\n     }\n+\n+    #[cfg(not(stage0))]\n+    unsafe fn push(&mut self, val: T) {\n+        ptr::write(self.tail as *mut T, val);\n+\n+        if mem::size_of::<T>() == 0 {\n+            self.tail = arith_offset(self.tail as *const i8, 1) as *const T;\n+        } else {\n+            self.tail = self.tail.offset(1);\n+        }\n+    }\n }\n \n impl<T> Iterator for RawItems<T> {\n     type Item = T;\n \n+    #[cfg(stage0)]\n     fn next(&mut self) -> Option<T> {\n         if self.head == self.tail {\n             None\n@@ -250,9 +281,29 @@ impl<T> Iterator for RawItems<T> {\n             }\n         }\n     }\n+\n+    #[cfg(not(stage0))]\n+    fn next(&mut self) -> Option<T> {\n+        if self.head == self.tail {\n+            None\n+        } else {\n+            unsafe {\n+                let ret = Some(ptr::read(self.head));\n+\n+                if mem::size_of::<T>() == 0 {\n+                    self.head = arith_offset(self.head as *const i8, 1) as *const T;\n+                } else {\n+                    self.head = self.head.offset(1);\n+                }\n+\n+                ret\n+            }\n+        }\n+    }\n }\n \n impl<T> DoubleEndedIterator for RawItems<T> {\n+    #[cfg(stage0)]\n     fn next_back(&mut self) -> Option<T> {\n         if self.head == self.tail {\n             None\n@@ -268,6 +319,23 @@ impl<T> DoubleEndedIterator for RawItems<T> {\n             }\n         }\n     }\n+\n+    #[cfg(not(stage0))]\n+    fn next_back(&mut self) -> Option<T> {\n+        if self.head == self.tail {\n+            None\n+        } else {\n+            unsafe {\n+                if mem::size_of::<T>() == 0 {\n+                    self.tail = arith_offset(self.tail as *const i8, -1) as *const T;\n+                } else {\n+                    self.tail = self.tail.offset(-1);\n+                }\n+\n+                Some(ptr::read(self.tail))\n+            }\n+        }\n+    }\n }\n \n impl<T> Drop for RawItems<T> {"}, {"sha": "d3315758df04baa639a0606a62b846fc9b1575d6", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/eeeb2cc0dffc016582f020c0a9e6d9f9fc751397/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeeb2cc0dffc016582f020c0a9e6d9f9fc751397/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=eeeb2cc0dffc016582f020c0a9e6d9f9fc751397", "patch": "@@ -66,6 +66,8 @@ use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{self, Hash};\n use core::intrinsics::assume;\n+#[cfg(not(stage0))]\n+use core::intrinsics::arith_offset;\n use core::iter::{repeat, FromIterator};\n use core::marker::PhantomData;\n use core::mem;\n@@ -1527,6 +1529,7 @@ impl<T> IntoIterator for Vec<T> {\n     /// }\n     /// ```\n     #[inline]\n+    #[cfg(stage0)]\n     fn into_iter(self) -> IntoIter<T> {\n         unsafe {\n             let ptr = *self.ptr;\n@@ -1542,6 +1545,24 @@ impl<T> IntoIterator for Vec<T> {\n             IntoIter { allocation: ptr, cap: cap, ptr: begin, end: end }\n         }\n     }\n+\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn into_iter(self) -> IntoIter<T> {\n+        unsafe {\n+            let ptr = *self.ptr;\n+            assume(!ptr.is_null());\n+            let cap = self.cap;\n+            let begin = ptr as *const T;\n+            let end = if mem::size_of::<T>() == 0 {\n+                arith_offset(ptr as *const i8, self.len() as isize) as *const T\n+            } else {\n+                ptr.offset(self.len() as isize) as *const T\n+            };\n+            mem::forget(self);\n+            IntoIter { allocation: ptr, cap: cap, ptr: begin, end: end }\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1746,6 +1767,7 @@ impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n     #[inline]\n+    #[cfg(stage0)]\n     fn next(&mut self) -> Option<T> {\n         unsafe {\n             if self.ptr == self.end {\n@@ -1769,6 +1791,31 @@ impl<T> Iterator for IntoIter<T> {\n         }\n     }\n \n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn next(&mut self) -> Option<T> {\n+        unsafe {\n+            if self.ptr == self.end {\n+                None\n+            } else {\n+                if mem::size_of::<T>() == 0 {\n+                    // purposefully don't use 'ptr.offset' because for\n+                    // vectors with 0-size elements this would return the\n+                    // same pointer.\n+                    self.ptr = arith_offset(self.ptr as *const i8, 1) as *const T;\n+\n+                    // Use a non-null pointer value\n+                    Some(ptr::read(EMPTY as *mut T))\n+                } else {\n+                    let old = self.ptr;\n+                    self.ptr = self.ptr.offset(1);\n+\n+                    Some(ptr::read(old))\n+                }\n+            }\n+        }\n+    }\n+\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let diff = (self.end as usize) - (self.ptr as usize);\n@@ -1786,6 +1833,7 @@ impl<T> Iterator for IntoIter<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n+    #[cfg(stage0)]\n     fn next_back(&mut self) -> Option<T> {\n         unsafe {\n             if self.end == self.ptr {\n@@ -1805,6 +1853,28 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n             }\n         }\n     }\n+\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn next_back(&mut self) -> Option<T> {\n+        unsafe {\n+            if self.end == self.ptr {\n+                None\n+            } else {\n+                if mem::size_of::<T>() == 0 {\n+                    // See above for why 'ptr.offset' isn't used\n+                    self.end = arith_offset(self.end as *const i8, -1) as *const T;\n+\n+                    // Use a non-null pointer value\n+                    Some(ptr::read(EMPTY as *mut T))\n+                } else {\n+                    self.end = self.end.offset(-1);\n+\n+                    Some(ptr::read(mem::transmute(self.end)))\n+                }\n+            }\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "fa432e311eb74fafc0ce6f48fa6a3e547d5f0e1b", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eeeb2cc0dffc016582f020c0a9e6d9f9fc751397/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeeb2cc0dffc016582f020c0a9e6d9f9fc751397/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=eeeb2cc0dffc016582f020c0a9e6d9f9fc751397", "patch": "@@ -283,6 +283,20 @@ extern \"rust-intrinsic\" {\n     /// returned value will result in undefined behavior.\n     pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n \n+    /// Calculates the offset from a pointer, potentially wrapping.\n+    ///\n+    /// This is implemented as an intrinsic to avoid converting to and from an\n+    /// integer, since the conversion inhibits certain optimizations.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Unlike the `offset` intrinsic, this intrinsic does not restrict the\n+    /// resulting pointer to point into or one byte past the end of an allocated\n+    /// object, and it wraps with two's complement arithmetic. The resulting\n+    /// value is not necessarily valid to be used to actually access memory.\n+    #[cfg(not(stage0))]\n+    pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n+\n     /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n     /// and destination may *not* overlap.\n     ///"}, {"sha": "346afdc963d62f66ddbca22bf3a9b4a620618fc6", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 61, "deletions": 45, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/eeeb2cc0dffc016582f020c0a9e6d9f9fc751397/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeeb2cc0dffc016582f020c0a9e6d9f9fc751397/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=eeeb2cc0dffc016582f020c0a9e6d9f9fc751397", "patch": "@@ -124,6 +124,43 @@ pub trait SliceExt {\n     fn clone_from_slice(&mut self, &[Self::Item]) -> usize where Self::Item: Clone;\n }\n \n+// Use macros to be generic over const/mut\n+#[cfg(stage0)]\n+macro_rules! slice_offset {\n+    ($ptr:expr, $by:expr) => {{\n+        let ptr = $ptr;\n+        if size_from_ptr(ptr) == 0 {\n+            transmute((ptr as isize).wrapping_add($by))\n+        } else {\n+            ptr.offset($by)\n+        }\n+    }};\n+}\n+\n+#[cfg(not(stage0))]\n+macro_rules! slice_offset {\n+    ($ptr:expr, $by:expr) => {{\n+        let ptr = $ptr;\n+        if size_from_ptr(ptr) == 0 {\n+            ::intrinsics::arith_offset(ptr as *mut i8, $by) as *mut _\n+        } else {\n+            ptr.offset($by)\n+        }\n+    }};\n+}\n+\n+macro_rules! slice_ref {\n+    ($ptr:expr) => {{\n+        let ptr = $ptr;\n+        if size_from_ptr(ptr) == 0 {\n+            // Use a non-null pointer value\n+            &mut *(1 as *mut _)\n+        } else {\n+            transmute(ptr)\n+        }\n+    }};\n+}\n+\n #[unstable(feature = \"core\")]\n impl<T> SliceExt for [T] {\n     type Item = T;\n@@ -136,16 +173,18 @@ impl<T> SliceExt for [T] {\n     #[inline]\n     fn iter<'a>(&'a self) -> Iter<'a, T> {\n         unsafe {\n-            let p = self.as_ptr();\n-            assume(!p.is_null());\n-            if mem::size_of::<T>() == 0 {\n-                Iter {ptr: p,\n-                      end: ((p as usize).wrapping_add(self.len())) as *const T,\n-                      _marker: marker::PhantomData}\n+            let p = if mem::size_of::<T>() == 0 {\n+                1 as *const _\n             } else {\n-                Iter {ptr: p,\n-                      end: p.offset(self.len() as isize),\n-                      _marker: marker::PhantomData}\n+                let p = self.as_ptr();\n+                assume(!p.is_null());\n+                p\n+            };\n+\n+            Iter {\n+                ptr: p,\n+                end: slice_offset!(p, self.len() as isize),\n+                _marker: marker::PhantomData\n             }\n         }\n     }\n@@ -273,16 +312,18 @@ impl<T> SliceExt for [T] {\n     #[inline]\n     fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n         unsafe {\n-            let p = self.as_mut_ptr();\n-            assume(!p.is_null());\n-            if mem::size_of::<T>() == 0 {\n-                IterMut {ptr: p,\n-                         end: ((p as usize).wrapping_add(self.len())) as *mut T,\n-                         _marker: marker::PhantomData}\n+            let p = if mem::size_of::<T>() == 0 {\n+                1 as *mut _\n             } else {\n-                IterMut {ptr: p,\n-                         end: p.offset(self.len() as isize),\n-                         _marker: marker::PhantomData}\n+                let p = self.as_mut_ptr();\n+                assume(!p.is_null());\n+                p\n+            };\n+\n+            IterMut {\n+                ptr: p,\n+                end: slice_offset!(p, self.len() as isize),\n+                _marker: marker::PhantomData\n             }\n         }\n     }\n@@ -630,31 +671,6 @@ fn size_from_ptr<T>(_: *const T) -> usize {\n     mem::size_of::<T>()\n }\n \n-\n-// Use macros to be generic over const/mut\n-macro_rules! slice_offset {\n-    ($ptr:expr, $by:expr) => {{\n-        let ptr = $ptr;\n-        if size_from_ptr(ptr) == 0 {\n-            transmute((ptr as isize).wrapping_add($by))\n-        } else {\n-            ptr.offset($by)\n-        }\n-    }};\n-}\n-\n-macro_rules! slice_ref {\n-    ($ptr:expr) => {{\n-        let ptr = $ptr;\n-        if size_from_ptr(ptr) == 0 {\n-            // Use a non-null pointer value\n-            &mut *(1 as *mut _)\n-        } else {\n-            transmute(ptr)\n-        }\n-    }};\n-}\n-\n // The shared definition of the `Iter` and `IterMut` iterators\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n@@ -781,7 +797,7 @@ impl<'a, T> Iter<'a, T> {\n         match self.as_slice().get(n) {\n             Some(elem_ref) => unsafe {\n                 self.ptr = slice_offset!(self.ptr, (n as isize).wrapping_add(1));\n-                Some(slice_ref!(elem_ref))\n+                Some(elem_ref)\n             },\n             None => {\n                 self.ptr = self.end;\n@@ -849,7 +865,7 @@ impl<'a, T> IterMut<'a, T> {\n         match make_mut_slice!(self.ptr, self.end).get_mut(n) {\n             Some(elem_ref) => unsafe {\n                 self.ptr = slice_offset!(self.ptr, (n as isize).wrapping_add(1));\n-                Some(slice_ref!(elem_ref))\n+                Some(elem_ref)\n             },\n             None => {\n                 self.ptr = self.end;"}, {"sha": "4608918ec59bd8696f2859cdac1bb0db558f6f0c", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eeeb2cc0dffc016582f020c0a9e6d9f9fc751397/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeeb2cc0dffc016582f020c0a9e6d9f9fc751397/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=eeeb2cc0dffc016582f020c0a9e6d9f9fc751397", "patch": "@@ -418,6 +418,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             let offset = llargs[1];\n             InBoundsGEP(bcx, ptr, &[offset])\n         }\n+        (_, \"arith_offset\") => {\n+            let ptr = llargs[0];\n+            let offset = llargs[1];\n+            GEP(bcx, ptr, &[offset])\n+        }\n \n         (_, \"copy_nonoverlapping\") => {\n             copy_intrinsic(bcx,"}, {"sha": "f13305bba343eab0ef7aea151675a13b4fa5b88f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeeb2cc0dffc016582f020c0a9e6d9f9fc751397/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeeb2cc0dffc016582f020c0a9e6d9f9fc751397/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=eeeb2cc0dffc016582f020c0a9e6d9f9fc751397", "patch": "@@ -5009,7 +5009,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"type_name\" => (1, Vec::new(), ty::mk_str_slice(tcx, tcx.mk_region(ty::ReStatic),\n                                                              ast::MutImmutable)),\n             \"type_id\" => (1, Vec::new(), ccx.tcx.types.u64),\n-            \"offset\" => {\n+            \"offset\" | \"arith_offset\" => {\n               (1,\n                vec!(\n                   ty::mk_ptr(tcx, ty::mt {"}]}