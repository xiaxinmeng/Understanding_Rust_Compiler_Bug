{"sha": "3fd8c8b3306ae33bdc85811aa410ba01967922bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmZDhjOGIzMzA2YWUzM2JkYzg1ODExYWE0MTBiYTAxOTY3OTIyYmM=", "commit": {"author": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2014-01-15T03:32:24Z"}, "committer": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2014-01-18T06:15:15Z"}, "message": "Rename iterators for consistency\n\nRename existing iterators to get rid of the Iterator suffix and to\ngive them names that better describe the things being iterated over.", "tree": {"sha": "36818b3c2f6f3c6ba8e145f4a1098dcb87f5bb44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36818b3c2f6f3c6ba8e145f4a1098dcb87f5bb44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fd8c8b3306ae33bdc85811aa410ba01967922bc", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fd8c8b3306ae33bdc85811aa410ba01967922bc", "html_url": "https://github.com/rust-lang/rust/commit/3fd8c8b3306ae33bdc85811aa410ba01967922bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fd8c8b3306ae33bdc85811aa410ba01967922bc/comments", "author": null, "committer": null, "parents": [{"sha": "c58d2bacb78ed0d2b9c0c0909e56f390b525aabd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c58d2bacb78ed0d2b9c0c0909e56f390b525aabd", "html_url": "https://github.com/rust-lang/rust/commit/c58d2bacb78ed0d2b9c0c0909e56f390b525aabd"}], "stats": {"total": 953, "additions": 476, "deletions": 477}, "files": [{"sha": "5fd1bb9d59922c82a0f2b45832dea4bc89cfcdfe", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -414,12 +414,12 @@ impl Bitv {\n     }\n \n     #[inline]\n-    pub fn iter<'a>(&'a self) -> BitvIterator<'a> {\n-        BitvIterator {bitv: self, next_idx: 0, end_idx: self.nbits}\n+    pub fn iter<'a>(&'a self) -> Bits<'a> {\n+        Bits {bitv: self, next_idx: 0, end_idx: self.nbits}\n     }\n \n     #[inline]\n-    pub fn rev_iter<'a>(&'a self) -> Invert<BitvIterator<'a>> {\n+    pub fn rev_iter<'a>(&'a self) -> Invert<Bits<'a>> {\n         self.iter().invert()\n     }\n \n@@ -578,13 +578,13 @@ fn iterate_bits(base: uint, bits: uint, f: |uint| -> bool) -> bool {\n }\n \n /// An iterator for `Bitv`.\n-pub struct BitvIterator<'a> {\n+pub struct Bits<'a> {\n     priv bitv: &'a Bitv,\n     priv next_idx: uint,\n     priv end_idx: uint,\n }\n \n-impl<'a> Iterator<bool> for BitvIterator<'a> {\n+impl<'a> Iterator<bool> for Bits<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<bool> {\n         if self.next_idx != self.end_idx {\n@@ -602,7 +602,7 @@ impl<'a> Iterator<bool> for BitvIterator<'a> {\n     }\n }\n \n-impl<'a> DoubleEndedIterator<bool> for BitvIterator<'a> {\n+impl<'a> DoubleEndedIterator<bool> for Bits<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<bool> {\n         if self.next_idx != self.end_idx {\n@@ -614,9 +614,9 @@ impl<'a> DoubleEndedIterator<bool> for BitvIterator<'a> {\n     }\n }\n \n-impl<'a> ExactSize<bool> for BitvIterator<'a> {}\n+impl<'a> ExactSize<bool> for Bits<'a> {}\n \n-impl<'a> RandomAccessIterator<bool> for BitvIterator<'a> {\n+impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         self.end_idx - self.next_idx\n@@ -724,8 +724,8 @@ impl BitvSet {\n         self.other_op(other, |w1, w2| w1 ^ w2);\n     }\n \n-    pub fn iter<'a>(&'a self) -> BitvSetIterator<'a> {\n-        BitvSetIterator {set: self, next_idx: 0}\n+    pub fn iter<'a>(&'a self) -> BitPositions<'a> {\n+        BitPositions {set: self, next_idx: 0}\n     }\n \n     pub fn difference(&self, other: &BitvSet, f: |&uint| -> bool) -> bool {\n@@ -871,7 +871,7 @@ impl BitvSet {\n     /// and w1/w2 are the words coming from the two vectors self, other.\n     fn commons<'a>(&'a self, other: &'a BitvSet)\n         -> Map<'static, ((uint, &'a uint), &'a ~[uint]), (uint, uint, uint),\n-               Zip<Enumerate<vec::VecIterator<'a, uint>>, Repeat<&'a ~[uint]>>> {\n+               Zip<Enumerate<vec::Items<'a, uint>>, Repeat<&'a ~[uint]>>> {\n         let min = num::min(self.bitv.storage.len(), other.bitv.storage.len());\n         self.bitv.storage.slice(0, min).iter().enumerate()\n             .zip(Repeat::new(&other.bitv.storage))\n@@ -887,7 +887,7 @@ impl BitvSet {\n     /// `other`.\n     fn outliers<'a>(&'a self, other: &'a BitvSet)\n         -> Map<'static, ((uint, &'a uint), uint), (bool, uint, uint),\n-               Zip<Enumerate<vec::VecIterator<'a, uint>>, Repeat<uint>>> {\n+               Zip<Enumerate<vec::Items<'a, uint>>, Repeat<uint>>> {\n         let slen = self.bitv.storage.len();\n         let olen = other.bitv.storage.len();\n \n@@ -903,12 +903,12 @@ impl BitvSet {\n     }\n }\n \n-pub struct BitvSetIterator<'a> {\n+pub struct BitPositions<'a> {\n     priv set: &'a BitvSet,\n     priv next_idx: uint\n }\n \n-impl<'a> Iterator<uint> for BitvSetIterator<'a> {\n+impl<'a> Iterator<uint> for BitPositions<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<uint> {\n         while self.next_idx < self.set.capacity() {"}, {"sha": "28a6c69ba1b6df499e308693b6e63d5ddfeef658", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -48,14 +48,14 @@ struct Node<T> {\n \n /// Double-ended DList iterator\n #[deriving(Clone)]\n-pub struct DListIterator<'a, T> {\n+pub struct Items<'a, T> {\n     priv head: &'a Link<T>,\n     priv tail: Rawlink<Node<T>>,\n     priv nelem: uint,\n }\n \n /// Double-ended mutable DList iterator\n-pub struct MutDListIterator<'a, T> {\n+pub struct MutItems<'a, T> {\n     priv list: &'a mut DList<T>,\n     priv head: Rawlink<Node<T>>,\n     priv tail: Rawlink<Node<T>>,\n@@ -64,7 +64,7 @@ pub struct MutDListIterator<'a, T> {\n \n /// DList consuming iterator\n #[deriving(Clone)]\n-pub struct MoveIterator<T> {\n+pub struct MoveItems<T> {\n     priv list: DList<T>\n }\n \n@@ -362,24 +362,24 @@ impl<T> DList<T> {\n \n     /// Provide a forward iterator\n     #[inline]\n-    pub fn iter<'a>(&'a self) -> DListIterator<'a, T> {\n-        DListIterator{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n+    pub fn iter<'a>(&'a self) -> Items<'a, T> {\n+        Items{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n     }\n \n     /// Provide a reverse iterator\n     #[inline]\n-    pub fn rev_iter<'a>(&'a self) -> Invert<DListIterator<'a, T>> {\n+    pub fn rev_iter<'a>(&'a self) -> Invert<Items<'a, T>> {\n         self.iter().invert()\n     }\n \n     /// Provide a forward iterator with mutable references\n     #[inline]\n-    pub fn mut_iter<'a>(&'a mut self) -> MutDListIterator<'a, T> {\n+    pub fn mut_iter<'a>(&'a mut self) -> MutItems<'a, T> {\n         let head_raw = match self.list_head {\n             Some(ref mut h) => Rawlink::some(*h),\n             None => Rawlink::none(),\n         };\n-        MutDListIterator{\n+        MutItems{\n             nelem: self.len(),\n             head: head_raw,\n             tail: self.list_tail,\n@@ -388,20 +388,20 @@ impl<T> DList<T> {\n     }\n     /// Provide a reverse iterator with mutable references\n     #[inline]\n-    pub fn mut_rev_iter<'a>(&'a mut self) -> Invert<MutDListIterator<'a, T>> {\n+    pub fn mut_rev_iter<'a>(&'a mut self) -> Invert<MutItems<'a, T>> {\n         self.mut_iter().invert()\n     }\n \n \n     /// Consume the list into an iterator yielding elements by value\n     #[inline]\n-    pub fn move_iter(self) -> MoveIterator<T> {\n-        MoveIterator{list: self}\n+    pub fn move_iter(self) -> MoveItems<T> {\n+        MoveItems{list: self}\n     }\n \n     /// Consume the list into an iterator yielding elements by value, in reverse\n     #[inline]\n-    pub fn move_rev_iter(self) -> Invert<MoveIterator<T>> {\n+    pub fn move_rev_iter(self) -> Invert<MoveItems<T>> {\n         self.move_iter().invert()\n     }\n }\n@@ -439,7 +439,7 @@ impl<T> Drop for DList<T> {\n }\n \n \n-impl<'a, A> Iterator<&'a A> for DListIterator<'a, A> {\n+impl<'a, A> Iterator<&'a A> for Items<'a, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a A> {\n         if self.nelem == 0 {\n@@ -458,7 +458,7 @@ impl<'a, A> Iterator<&'a A> for DListIterator<'a, A> {\n     }\n }\n \n-impl<'a, A> DoubleEndedIterator<&'a A> for DListIterator<'a, A> {\n+impl<'a, A> DoubleEndedIterator<&'a A> for Items<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a A> {\n         if self.nelem == 0 {\n@@ -473,9 +473,9 @@ impl<'a, A> DoubleEndedIterator<&'a A> for DListIterator<'a, A> {\n     }\n }\n \n-impl<'a, A> ExactSize<&'a A> for DListIterator<'a, A> {}\n+impl<'a, A> ExactSize<&'a A> for Items<'a, A> {}\n \n-impl<'a, A> Iterator<&'a mut A> for MutDListIterator<'a, A> {\n+impl<'a, A> Iterator<&'a mut A> for MutItems<'a, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut A> {\n         if self.nelem == 0 {\n@@ -497,7 +497,7 @@ impl<'a, A> Iterator<&'a mut A> for MutDListIterator<'a, A> {\n     }\n }\n \n-impl<'a, A> DoubleEndedIterator<&'a mut A> for MutDListIterator<'a, A> {\n+impl<'a, A> DoubleEndedIterator<&'a mut A> for MutItems<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut A> {\n         if self.nelem == 0 {\n@@ -511,7 +511,7 @@ impl<'a, A> DoubleEndedIterator<&'a mut A> for MutDListIterator<'a, A> {\n     }\n }\n \n-impl<'a, A> ExactSize<&'a mut A> for MutDListIterator<'a, A> {}\n+impl<'a, A> ExactSize<&'a mut A> for MutItems<'a, A> {}\n \n /// Allow mutating the DList while iterating\n pub trait ListInsertion<A> {\n@@ -524,8 +524,8 @@ pub trait ListInsertion<A> {\n     fn peek_next<'a>(&'a mut self) -> Option<&'a mut A>;\n }\n \n-// private methods for MutDListIterator\n-impl<'a, A> MutDListIterator<'a, A> {\n+// private methods for MutItems\n+impl<'a, A> MutItems<'a, A> {\n     fn insert_next_node(&mut self, mut ins_node: ~Node<A>) {\n         // Insert before `self.head` so that it is between the\n         // previously yielded element and self.head.\n@@ -547,7 +547,7 @@ impl<'a, A> MutDListIterator<'a, A> {\n     }\n }\n \n-impl<'a, A> ListInsertion<A> for MutDListIterator<'a, A> {\n+impl<'a, A> ListInsertion<A> for MutItems<'a, A> {\n     #[inline]\n     fn insert_next(&mut self, elt: A) {\n         self.insert_next_node(~Node::new(elt))\n@@ -562,7 +562,7 @@ impl<'a, A> ListInsertion<A> for MutDListIterator<'a, A> {\n     }\n }\n \n-impl<A> Iterator<A> for MoveIterator<A> {\n+impl<A> Iterator<A> for MoveItems<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.list.pop_front() }\n \n@@ -572,7 +572,7 @@ impl<A> Iterator<A> for MoveIterator<A> {\n     }\n }\n \n-impl<A> DoubleEndedIterator<A> for MoveIterator<A> {\n+impl<A> DoubleEndedIterator<A> for MoveItems<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.list.pop_back() }\n }"}, {"sha": "f12da3080aa809c8968530afd2f507c656b66497", "filename": "src/libextra/enum_set.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibextra%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibextra%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fenum_set.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -77,8 +77,8 @@ impl<E:CLike> EnumSet<E> {\n     }\n \n     /// Returns an iterator over an EnumSet\n-    pub fn iter(&self) -> EnumSetIterator<E> {\n-        EnumSetIterator::new(self.bits)\n+    pub fn iter(&self) -> Items<E> {\n+        Items::new(self.bits)\n     }\n }\n \n@@ -101,18 +101,18 @@ impl<E:CLike> BitAnd<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n }\n \n /// An iterator over an EnumSet\n-pub struct EnumSetIterator<E> {\n+pub struct Items<E> {\n     priv index: uint,\n     priv bits: uint,\n }\n \n-impl<E:CLike> EnumSetIterator<E> {\n-    fn new(bits: uint) -> EnumSetIterator<E> {\n-        EnumSetIterator { index: 0, bits: bits }\n+impl<E:CLike> Items<E> {\n+    fn new(bits: uint) -> Items<E> {\n+        Items { index: 0, bits: bits }\n     }\n }\n \n-impl<E:CLike> Iterator<E> for EnumSetIterator<E> {\n+impl<E:CLike> Iterator<E> for Items<E> {\n     fn next(&mut self) -> Option<E> {\n         if (self.bits == 0) {\n             return None;"}, {"sha": "d4d0a7b89f040141d74096848e4831dcdf71ae5f", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -11,7 +11,7 @@\n /*!\n  * Support for matching file paths against Unix shell style patterns.\n  *\n- * The `glob` and `glob_with` functions, in concert with the `GlobIterator`\n+ * The `glob` and `glob_with` functions, in concert with the `Paths`\n  * type, allow querying the filesystem for all files that match a particular\n  * pattern - just like the libc `glob` function (for an example see the `glob`\n  * documentation). The methods on the `Pattern` type provide functionality\n@@ -32,7 +32,7 @@ use std::path::is_sep;\n  * An iterator that yields Paths from the filesystem that match a particular\n  * pattern - see the `glob` function for more details.\n  */\n-pub struct GlobIterator {\n+pub struct Paths {\n     priv root: Path,\n     priv dir_patterns: ~[Pattern],\n     priv options: MatchOptions,\n@@ -67,7 +67,7 @@ pub struct GlobIterator {\n /// /media/pictures/puppies.jpg\n /// ```\n ///\n-pub fn glob(pattern: &str) -> GlobIterator {\n+pub fn glob(pattern: &str) -> Paths {\n     glob_with(pattern, MatchOptions::new())\n }\n \n@@ -82,7 +82,7 @@ pub fn glob(pattern: &str) -> GlobIterator {\n  *\n  * Paths are yielded in alphabetical order, as absolute paths.\n  */\n-pub fn glob_with(pattern: &str, options: MatchOptions) -> GlobIterator {\n+pub fn glob_with(pattern: &str, options: MatchOptions) -> Paths {\n     #[cfg(windows)]\n     fn check_windows_verbatim(p: &Path) -> bool { path::windows::is_verbatim(p) }\n     #[cfg(not(windows))]\n@@ -95,7 +95,7 @@ pub fn glob_with(pattern: &str, options: MatchOptions) -> GlobIterator {\n         if check_windows_verbatim(pat_root.get_ref()) {\n             // XXX: How do we want to handle verbatim paths? I'm inclined to return nothing,\n             // since we can't very well find all UNC shares with a 1-letter server name.\n-            return GlobIterator { root: root, dir_patterns: ~[], options: options, todo: ~[] };\n+            return Paths { root: root, dir_patterns: ~[], options: options, todo: ~[] };\n         }\n         root.push(pat_root.get_ref());\n     }\n@@ -106,15 +106,15 @@ pub fn glob_with(pattern: &str, options: MatchOptions) -> GlobIterator {\n \n     let todo = list_dir_sorted(&root).move_iter().map(|x|(x,0u)).to_owned_vec();\n \n-    GlobIterator {\n+    Paths {\n         root: root,\n         dir_patterns: dir_patterns,\n         options: options,\n         todo: todo,\n     }\n }\n \n-impl Iterator<Path> for GlobIterator {\n+impl Iterator<Path> for Paths {\n \n     fn next(&mut self) -> Option<Path> {\n         loop {"}, {"sha": "cf3c265e3fbe0d69fe0507f2e1d571e9d70a70d5", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -36,8 +36,8 @@ impl<T:Ord> Mutable for PriorityQueue<T> {\n impl<T:Ord> PriorityQueue<T> {\n     /// An iterator visiting all values in underlying vector, in\n     /// arbitrary order.\n-    pub fn iter<'a>(&'a self) -> PriorityQueueIterator<'a, T> {\n-        PriorityQueueIterator { iter: self.data.iter() }\n+    pub fn iter<'a>(&'a self) -> Items<'a, T> {\n+        Items { iter: self.data.iter() }\n     }\n \n     /// Returns the greatest item in the queue - fails if empty\n@@ -177,11 +177,11 @@ impl<T:Ord> PriorityQueue<T> {\n }\n \n /// PriorityQueue iterator\n-pub struct PriorityQueueIterator <'a, T> {\n-    priv iter: vec::VecIterator<'a, T>,\n+pub struct Items <'a, T> {\n+    priv iter: vec::Items<'a, T>,\n }\n \n-impl<'a, T> Iterator<&'a T> for PriorityQueueIterator<'a, T> {\n+impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<(&'a T)> { self.iter.next() }\n "}, {"sha": "c5c8f69dc6541e05217d51a6c430afb26d802cd3", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -187,17 +187,17 @@ impl<T> RingBuf<T> {\n     }\n \n     /// Front-to-back iterator.\n-    pub fn iter<'a>(&'a self) -> RingBufIterator<'a, T> {\n-        RingBufIterator{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts}\n+    pub fn iter<'a>(&'a self) -> Items<'a, T> {\n+        Items{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts}\n     }\n \n     /// Back-to-front iterator.\n-    pub fn rev_iter<'a>(&'a self) -> Invert<RingBufIterator<'a, T>> {\n+    pub fn rev_iter<'a>(&'a self) -> Invert<Items<'a, T>> {\n         self.iter().invert()\n     }\n \n     /// Front-to-back iterator which returns mutable values.\n-    pub fn mut_iter<'a>(&'a mut self) -> RingBufMutIterator<'a, T> {\n+    pub fn mut_iter<'a>(&'a mut self) -> MutItems<'a, T> {\n         let start_index = raw_index(self.lo, self.elts.len(), 0);\n         let end_index = raw_index(self.lo, self.elts.len(), self.nelts);\n \n@@ -209,34 +209,34 @@ impl<T> RingBuf<T> {\n             //    0 to end_index\n             let (temp, remaining1) = self.elts.mut_split_at(start_index);\n             let (remaining2, _) = temp.mut_split_at(end_index);\n-            RingBufMutIterator { remaining1: remaining1,\n+            MutItems { remaining1: remaining1,\n                                  remaining2: remaining2,\n                                  nelts: self.nelts }\n         } else {\n             // Items to iterate goes from start_index to end_index:\n             let (empty, elts) = self.elts.mut_split_at(0);\n             let remaining1 = elts.mut_slice(start_index, end_index);\n-            RingBufMutIterator { remaining1: remaining1,\n+            MutItems { remaining1: remaining1,\n                                  remaining2: empty,\n                                  nelts: self.nelts }\n         }\n     }\n \n     /// Back-to-front iterator which returns mutable values.\n-    pub fn mut_rev_iter<'a>(&'a mut self) -> Invert<RingBufMutIterator<'a, T>> {\n+    pub fn mut_rev_iter<'a>(&'a mut self) -> Invert<MutItems<'a, T>> {\n         self.mut_iter().invert()\n     }\n }\n \n /// RingBuf iterator\n-pub struct RingBufIterator<'a, T> {\n+pub struct Items<'a, T> {\n     priv lo: uint,\n     priv index: uint,\n     priv rindex: uint,\n     priv elts: &'a [Option<T>],\n }\n \n-impl<'a, T> Iterator<&'a T> for RingBufIterator<'a, T> {\n+impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> {\n         if self.index == self.rindex {\n@@ -254,7 +254,7 @@ impl<'a, T> Iterator<&'a T> for RingBufIterator<'a, T> {\n     }\n }\n \n-impl<'a, T> DoubleEndedIterator<&'a T> for RingBufIterator<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> {\n         if self.index == self.rindex {\n@@ -266,9 +266,9 @@ impl<'a, T> DoubleEndedIterator<&'a T> for RingBufIterator<'a, T> {\n     }\n }\n \n-impl<'a, T> ExactSize<&'a T> for RingBufIterator<'a, T> {}\n+impl<'a, T> ExactSize<&'a T> for Items<'a, T> {}\n \n-impl<'a, T> RandomAccessIterator<&'a T> for RingBufIterator<'a, T> {\n+impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint { self.rindex - self.index }\n \n@@ -284,13 +284,13 @@ impl<'a, T> RandomAccessIterator<&'a T> for RingBufIterator<'a, T> {\n }\n \n /// RingBuf mutable iterator\n-pub struct RingBufMutIterator<'a, T> {\n+pub struct MutItems<'a, T> {\n     priv remaining1: &'a mut [Option<T>],\n     priv remaining2: &'a mut [Option<T>],\n     priv nelts: uint,\n }\n \n-impl<'a, T> Iterator<&'a mut T> for RingBufMutIterator<'a, T> {\n+impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut T> {\n         if self.nelts == 0 {\n@@ -312,7 +312,7 @@ impl<'a, T> Iterator<&'a mut T> for RingBufMutIterator<'a, T> {\n     }\n }\n \n-impl<'a, T> DoubleEndedIterator<&'a mut T> for RingBufMutIterator<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a mut T> for MutItems<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> {\n         if self.nelts == 0 {\n@@ -329,7 +329,7 @@ impl<'a, T> DoubleEndedIterator<&'a mut T> for RingBufMutIterator<'a, T> {\n     }\n }\n \n-impl<'a, T> ExactSize<&'a mut T> for RingBufMutIterator<'a, T> {}\n+impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}\n \n /// Grow is only called on full elts, so nelts is also len(elts), unlike\n /// elsewhere."}, {"sha": "93d138a9d460f490e4856939f384e073f68a69d7", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -17,7 +17,6 @@\n \n use std::iter::{Enumerate, FilterMap, Invert};\n use std::util::replace;\n-use std::vec::{VecIterator, VecMutIterator};\n use std::vec;\n \n #[allow(missing_doc)]\n@@ -119,8 +118,8 @@ impl<V> SmallIntMap<V> {\n \n     /// An iterator visiting all key-value pairs in ascending order by the keys.\n     /// Iterator element type is (uint, &'r V)\n-    pub fn iter<'r>(&'r self) -> SmallIntMapIterator<'r, V> {\n-        SmallIntMapIterator {\n+    pub fn iter<'r>(&'r self) -> Entries<'r, V> {\n+        Entries {\n             front: 0,\n             back: self.v.len(),\n             iter: self.v.iter()\n@@ -130,8 +129,8 @@ impl<V> SmallIntMap<V> {\n     /// An iterator visiting all key-value pairs in ascending order by the keys,\n     /// with mutable references to the values\n     /// Iterator element type is (uint, &'r mut V)\n-    pub fn mut_iter<'r>(&'r mut self) -> SmallIntMapMutIterator<'r, V> {\n-        SmallIntMapMutIterator {\n+    pub fn mut_iter<'r>(&'r mut self) -> MutEntries<'r, V> {\n+        MutEntries {\n             front: 0,\n             back: self.v.len(),\n             iter: self.v.mut_iter()\n@@ -140,21 +139,21 @@ impl<V> SmallIntMap<V> {\n \n     /// An iterator visiting all key-value pairs in descending order by the keys.\n     /// Iterator element type is (uint, &'r V)\n-    pub fn rev_iter<'r>(&'r self) -> SmallIntMapRevIterator<'r, V> {\n+    pub fn rev_iter<'r>(&'r self) -> RevEntries<'r, V> {\n         self.iter().invert()\n     }\n \n     /// An iterator visiting all key-value pairs in descending order by the keys,\n     /// with mutable references to the values\n     /// Iterator element type is (uint, &'r mut V)\n-    pub fn mut_rev_iter<'r>(&'r mut self) -> SmallIntMapMutRevIterator <'r, V> {\n+    pub fn mut_rev_iter<'r>(&'r mut self) -> RevMutEntries <'r, V> {\n         self.mut_iter().invert()\n     }\n \n     /// Empties the hash map, moving all values into the specified closure\n     pub fn move_iter(&mut self)\n         -> FilterMap<(uint, Option<V>), (uint, V),\n-                Enumerate<vec::MoveIterator<Option<V>>>>\n+                Enumerate<vec::MoveItems<Option<V>>>>\n     {\n         let values = replace(&mut self.v, ~[]);\n         values.move_iter().enumerate().filter_map(|(i, v)| {\n@@ -234,25 +233,25 @@ macro_rules! double_ended_iterator {\n     }\n }\n \n-pub struct SmallIntMapIterator<'a, T> {\n+pub struct Entries<'a, T> {\n     priv front: uint,\n     priv back: uint,\n-    priv iter: VecIterator<'a, Option<T>>\n+    priv iter: vec::Items<'a, Option<T>>\n }\n \n-iterator!(impl SmallIntMapIterator -> (uint, &'a T), get_ref)\n-double_ended_iterator!(impl SmallIntMapIterator -> (uint, &'a T), get_ref)\n-pub type SmallIntMapRevIterator<'a, T> = Invert<SmallIntMapIterator<'a, T>>;\n+iterator!(impl Entries -> (uint, &'a T), get_ref)\n+double_ended_iterator!(impl Entries -> (uint, &'a T), get_ref)\n+pub type RevEntries<'a, T> = Invert<Entries<'a, T>>;\n \n-pub struct SmallIntMapMutIterator<'a, T> {\n+pub struct MutEntries<'a, T> {\n     priv front: uint,\n     priv back: uint,\n-    priv iter: VecMutIterator<'a, Option<T>>\n+    priv iter: vec::MutItems<'a, Option<T>>\n }\n \n-iterator!(impl SmallIntMapMutIterator -> (uint, &'a mut T), get_mut_ref)\n-double_ended_iterator!(impl SmallIntMapMutIterator -> (uint, &'a mut T), get_mut_ref)\n-pub type SmallIntMapMutRevIterator<'a, T> = Invert<SmallIntMapMutIterator<'a, T>>;\n+iterator!(impl MutEntries -> (uint, &'a mut T), get_mut_ref)\n+double_ended_iterator!(impl MutEntries -> (uint, &'a mut T), get_mut_ref)\n+pub type RevMutEntries<'a, T> = Invert<MutEntries<'a, T>>;\n \n #[cfg(test)]\n mod test_map {"}, {"sha": "7b8258ec5ae2763731fc803a38742558da8b393e", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 71, "deletions": 71, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -137,8 +137,8 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n \n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n-    pub fn iter<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n-        TreeMapIterator {\n+    pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n+        Entries {\n             stack: ~[],\n             node: deref(&self.root),\n             remaining_min: self.length,\n@@ -148,14 +148,14 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n \n     /// Get a lazy reverse iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n-    pub fn rev_iter<'a>(&'a self) -> TreeMapRevIterator<'a, K, V> {\n-        TreeMapRevIterator{iter: self.iter()}\n+    pub fn rev_iter<'a>(&'a self) -> RevEntries<'a, K, V> {\n+        RevEntries{iter: self.iter()}\n     }\n \n     /// Get a lazy forward iterator over the key-value pairs in the\n     /// map, with the values being mutable.\n-    pub fn mut_iter<'a>(&'a mut self) -> TreeMapMutIterator<'a, K, V> {\n-        TreeMapMutIterator {\n+    pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n+        MutEntries {\n             stack: ~[],\n             node: mut_deref(&mut self.root),\n             remaining_min: self.length,\n@@ -164,19 +164,19 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     }\n     /// Get a lazy reverse iterator over the key-value pairs in the\n     /// map, with the values being mutable.\n-    pub fn mut_rev_iter<'a>(&'a mut self) -> TreeMapMutRevIterator<'a, K, V> {\n-        TreeMapMutRevIterator{iter: self.mut_iter()}\n+    pub fn mut_rev_iter<'a>(&'a mut self) -> RevMutEntries<'a, K, V> {\n+        RevMutEntries{iter: self.mut_iter()}\n     }\n \n \n     /// Get a lazy iterator that consumes the treemap.\n-    pub fn move_iter(self) -> TreeMapMoveIterator<K, V> {\n+    pub fn move_iter(self) -> MoveEntries<K, V> {\n         let TreeMap { root: root, length: length } = self;\n         let stk = match root {\n             None => ~[],\n             Some(~tn) => ~[tn]\n         };\n-        TreeMapMoveIterator {\n+        MoveEntries {\n             stack: stk,\n             remaining: length\n         }\n@@ -220,8 +220,8 @@ macro_rules! bound_setup {\n impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Get a lazy iterator that should be initialized using\n     /// `traverse_left`/`traverse_right`/`traverse_complete`.\n-    fn iter_for_traversal<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n-        TreeMapIterator {\n+    fn iter_for_traversal<'a>(&'a self) -> Entries<'a, K, V> {\n+        Entries {\n             stack: ~[],\n             node: deref(&self.root),\n             remaining_min: 0,\n@@ -231,20 +231,20 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n \n     /// Return a lazy iterator to the first key-value pair whose key is not less than `k`\n     /// If all keys in map are less than `k` an empty iterator is returned.\n-    pub fn lower_bound<'a>(&'a self, k: &K) -> TreeMapIterator<'a, K, V> {\n+    pub fn lower_bound<'a>(&'a self, k: &K) -> Entries<'a, K, V> {\n         bound_setup!(self.iter_for_traversal(), true)\n     }\n \n     /// Return a lazy iterator to the first key-value pair whose key is greater than `k`\n     /// If all keys in map are not greater than `k` an empty iterator is returned.\n-    pub fn upper_bound<'a>(&'a self, k: &K) -> TreeMapIterator<'a, K, V> {\n+    pub fn upper_bound<'a>(&'a self, k: &K) -> Entries<'a, K, V> {\n         bound_setup!(self.iter_for_traversal(), false)\n     }\n \n     /// Get a lazy iterator that should be initialized using\n     /// `traverse_left`/`traverse_right`/`traverse_complete`.\n-    fn mut_iter_for_traversal<'a>(&'a mut self) -> TreeMapMutIterator<'a, K, V> {\n-        TreeMapMutIterator {\n+    fn mut_iter_for_traversal<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n+        MutEntries {\n             stack: ~[],\n             node: mut_deref(&mut self.root),\n             remaining_min: 0,\n@@ -257,7 +257,7 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     ///\n     /// If all keys in map are less than `k` an empty iterator is\n     /// returned.\n-    pub fn mut_lower_bound<'a>(&'a mut self, k: &K) -> TreeMapMutIterator<'a, K, V> {\n+    pub fn mut_lower_bound<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> {\n         bound_setup!(self.mut_iter_for_traversal(), true)\n     }\n \n@@ -266,15 +266,15 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     ///\n     /// If all keys in map are not greater than `k` an empty iterator\n     /// is returned.\n-    pub fn mut_upper_bound<'a>(&'a mut self, k: &K) -> TreeMapMutIterator<'a, K, V> {\n+    pub fn mut_upper_bound<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> {\n         bound_setup!(self.mut_iter_for_traversal(), false)\n     }\n }\n \n /// Lazy forward iterator over a map\n-pub struct TreeMapIterator<'a, K, V> {\n+pub struct Entries<'a, K, V> {\n     priv stack: ~[&'a TreeNode<K, V>],\n-    // See the comment on TreeMapMutIterator; this is just to allow\n+    // See the comment on MutEntries; this is just to allow\n     // code-sharing (for this immutable-values iterator it *could* very\n     // well be Option<&'a TreeNode<K,V>>).\n     priv node: *TreeNode<K, V>,\n@@ -283,13 +283,13 @@ pub struct TreeMapIterator<'a, K, V> {\n }\n \n /// Lazy backward iterator over a map\n-pub struct TreeMapRevIterator<'a, K, V> {\n-    priv iter: TreeMapIterator<'a, K, V>,\n+pub struct RevEntries<'a, K, V> {\n+    priv iter: Entries<'a, K, V>,\n }\n \n /// Lazy forward iterator over a map that allows for the mutation of\n /// the values.\n-pub struct TreeMapMutIterator<'a, K, V> {\n+pub struct MutEntries<'a, K, V> {\n     priv stack: ~[&'a mut TreeNode<K, V>],\n     // Unfortunately, we require some unsafe-ness to get around the\n     // fact that we would be storing a reference *into* one of the\n@@ -316,8 +316,8 @@ pub struct TreeMapMutIterator<'a, K, V> {\n }\n \n /// Lazy backward iterator over a map\n-pub struct TreeMapMutRevIterator<'a, K, V> {\n-    priv iter: TreeMapMutIterator<'a, K, V>,\n+pub struct RevMutEntries<'a, K, V> {\n+    priv iter: MutEntries<'a, K, V>,\n }\n \n \n@@ -377,13 +377,13 @@ macro_rules! define_iterator {\n             }\n \n             /// traverse_left, traverse_right and traverse_complete are\n-            /// used to initialize TreeMapIterator/TreeMapMutIterator\n+            /// used to initialize Entries/MutEntries\n             /// pointing to element inside tree structure.\n             ///\n             /// They should be used in following manner:\n             ///   - create iterator using TreeMap::[mut_]iter_for_traversal\n             ///   - find required node using `traverse_left`/`traverse_right`\n-            ///     (current node is `TreeMapIterator::node` field)\n+            ///     (current node is `Entries::node` field)\n             ///   - complete initialization with `traverse_complete`\n             ///\n             /// After this, iteration will start from `self.node`.  If\n@@ -443,16 +443,16 @@ macro_rules! define_iterator {\n } // end of define_iterator\n \n define_iterator! {\n-    TreeMapIterator,\n-    TreeMapRevIterator,\n+    Entries,\n+    RevEntries,\n     deref = deref,\n \n     // immutable, so no mut\n     addr_mut =\n }\n define_iterator! {\n-    TreeMapMutIterator,\n-    TreeMapMutRevIterator,\n+    MutEntries,\n+    RevMutEntries,\n     deref = mut_deref,\n \n     addr_mut = mut\n@@ -481,12 +481,12 @@ fn mut_deref<K, V>(x: &mut Option<~TreeNode<K, V>>) -> *mut TreeNode<K, V> {\n \n \n /// Lazy forward iterator over a map that consumes the map while iterating\n-pub struct TreeMapMoveIterator<K, V> {\n+pub struct MoveEntries<K, V> {\n     priv stack: ~[TreeNode<K, V>],\n     priv remaining: uint\n }\n \n-impl<K, V> Iterator<(K, V)> for TreeMapMoveIterator<K,V> {\n+impl<K, V> Iterator<(K, V)> for MoveEntries<K,V> {\n     #[inline]\n     fn next(&mut self) -> Option<(K, V)> {\n         while !self.stack.is_empty() {\n@@ -530,15 +530,15 @@ impl<K, V> Iterator<(K, V)> for TreeMapMoveIterator<K,V> {\n \n }\n \n-impl<'a, T> Iterator<&'a T> for TreeSetIterator<'a, T> {\n+impl<'a, T> Iterator<&'a T> for SetItems<'a, T> {\n     /// Advance the iterator to the next node (in order). If there are no more nodes, return `None`.\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> {\n         self.iter.next().map(|(value, _)| value)\n     }\n }\n \n-impl<'a, T> Iterator<&'a T> for TreeSetRevIterator<'a, T> {\n+impl<'a, T> Iterator<&'a T> for RevSetItems<'a, T> {\n     /// Advance the iterator to the next node (in order). If there are no more nodes, return `None`.\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> {\n@@ -653,86 +653,86 @@ impl<T: TotalOrd> TreeSet<T> {\n     /// Get a lazy iterator over the values in the set.\n     /// Requires that it be frozen (immutable).\n     #[inline]\n-    pub fn iter<'a>(&'a self) -> TreeSetIterator<'a, T> {\n-        TreeSetIterator{iter: self.map.iter()}\n+    pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n+        SetItems{iter: self.map.iter()}\n     }\n \n     /// Get a lazy iterator over the values in the set.\n     /// Requires that it be frozen (immutable).\n     #[inline]\n-    pub fn rev_iter<'a>(&'a self) -> TreeSetRevIterator<'a, T> {\n-        TreeSetRevIterator{iter: self.map.rev_iter()}\n+    pub fn rev_iter<'a>(&'a self) -> RevSetItems<'a, T> {\n+        RevSetItems{iter: self.map.rev_iter()}\n     }\n \n     /// Get a lazy iterator pointing to the first value not less than `v` (greater or equal).\n     /// If all elements in the set are less than `v` empty iterator is returned.\n     #[inline]\n-    pub fn lower_bound<'a>(&'a self, v: &T) -> TreeSetIterator<'a, T> {\n-        TreeSetIterator{iter: self.map.lower_bound(v)}\n+    pub fn lower_bound<'a>(&'a self, v: &T) -> SetItems<'a, T> {\n+        SetItems{iter: self.map.lower_bound(v)}\n     }\n \n     /// Get a lazy iterator pointing to the first value greater than `v`.\n     /// If all elements in the set are not greater than `v` empty iterator is returned.\n     #[inline]\n-    pub fn upper_bound<'a>(&'a self, v: &T) -> TreeSetIterator<'a, T> {\n-        TreeSetIterator{iter: self.map.upper_bound(v)}\n+    pub fn upper_bound<'a>(&'a self, v: &T) -> SetItems<'a, T> {\n+        SetItems{iter: self.map.upper_bound(v)}\n     }\n \n     /// Visit the values (in-order) representing the difference\n-    pub fn difference<'a>(&'a self, other: &'a TreeSet<T>) -> Difference<'a, T> {\n-        Difference{a: self.iter().peekable(), b: other.iter().peekable()}\n+    pub fn difference<'a>(&'a self, other: &'a TreeSet<T>) -> DifferenceItems<'a, T> {\n+        DifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visit the values (in-order) representing the symmetric difference\n     pub fn symmetric_difference<'a>(&'a self, other: &'a TreeSet<T>)\n-        -> SymDifference<'a, T> {\n-        SymDifference{a: self.iter().peekable(), b: other.iter().peekable()}\n+        -> SymDifferenceItems<'a, T> {\n+        SymDifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visit the values (in-order) representing the intersection\n     pub fn intersection<'a>(&'a self, other: &'a TreeSet<T>)\n-        -> Intersection<'a, T> {\n-        Intersection{a: self.iter().peekable(), b: other.iter().peekable()}\n+        -> IntersectionItems<'a, T> {\n+        IntersectionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visit the values (in-order) representing the union\n-    pub fn union<'a>(&'a self, other: &'a TreeSet<T>) -> Union<'a, T> {\n-        Union{a: self.iter().peekable(), b: other.iter().peekable()}\n+    pub fn union<'a>(&'a self, other: &'a TreeSet<T>) -> UnionItems<'a, T> {\n+        UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n }\n \n /// Lazy forward iterator over a set\n-pub struct TreeSetIterator<'a, T> {\n-    priv iter: TreeMapIterator<'a, T, ()>\n+pub struct SetItems<'a, T> {\n+    priv iter: Entries<'a, T, ()>\n }\n \n /// Lazy backward iterator over a set\n-pub struct TreeSetRevIterator<'a, T> {\n-    priv iter: TreeMapRevIterator<'a, T, ()>\n+pub struct RevSetItems<'a, T> {\n+    priv iter: RevEntries<'a, T, ()>\n }\n \n /// Lazy iterator producing elements in the set difference (in-order)\n-pub struct Difference<'a, T> {\n-    priv a: Peekable<&'a T, TreeSetIterator<'a, T>>,\n-    priv b: Peekable<&'a T, TreeSetIterator<'a, T>>,\n+pub struct DifferenceItems<'a, T> {\n+    priv a: Peekable<&'a T, SetItems<'a, T>>,\n+    priv b: Peekable<&'a T, SetItems<'a, T>>,\n }\n \n /// Lazy iterator producing elements in the set symmetric difference (in-order)\n-pub struct SymDifference<'a, T> {\n-    priv a: Peekable<&'a T, TreeSetIterator<'a, T>>,\n-    priv b: Peekable<&'a T, TreeSetIterator<'a, T>>,\n+pub struct SymDifferenceItems<'a, T> {\n+    priv a: Peekable<&'a T, SetItems<'a, T>>,\n+    priv b: Peekable<&'a T, SetItems<'a, T>>,\n }\n \n /// Lazy iterator producing elements in the set intersection (in-order)\n-pub struct Intersection<'a, T> {\n-    priv a: Peekable<&'a T, TreeSetIterator<'a, T>>,\n-    priv b: Peekable<&'a T, TreeSetIterator<'a, T>>,\n+pub struct IntersectionItems<'a, T> {\n+    priv a: Peekable<&'a T, SetItems<'a, T>>,\n+    priv b: Peekable<&'a T, SetItems<'a, T>>,\n }\n \n /// Lazy iterator producing elements in the set intersection (in-order)\n-pub struct Union<'a, T> {\n-    priv a: Peekable<&'a T, TreeSetIterator<'a, T>>,\n-    priv b: Peekable<&'a T, TreeSetIterator<'a, T>>,\n+pub struct UnionItems<'a, T> {\n+    priv a: Peekable<&'a T, SetItems<'a, T>>,\n+    priv b: Peekable<&'a T, SetItems<'a, T>>,\n }\n \n /// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n@@ -745,7 +745,7 @@ fn cmp_opt<T: TotalOrd>(x: Option<&T>, y: Option<&T>,\n     }\n }\n \n-impl<'a, T: TotalOrd> Iterator<&'a T> for Difference<'a, T> {\n+impl<'a, T: TotalOrd> Iterator<&'a T> for DifferenceItems<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n@@ -757,7 +757,7 @@ impl<'a, T: TotalOrd> Iterator<&'a T> for Difference<'a, T> {\n     }\n }\n \n-impl<'a, T: TotalOrd> Iterator<&'a T> for SymDifference<'a, T> {\n+impl<'a, T: TotalOrd> Iterator<&'a T> for SymDifferenceItems<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n@@ -769,7 +769,7 @@ impl<'a, T: TotalOrd> Iterator<&'a T> for SymDifference<'a, T> {\n     }\n }\n \n-impl<'a, T: TotalOrd> Iterator<&'a T> for Intersection<'a, T> {\n+impl<'a, T: TotalOrd> Iterator<&'a T> for IntersectionItems<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             let o_cmp = match (self.a.peek(), self.b.peek()) {\n@@ -787,7 +787,7 @@ impl<'a, T: TotalOrd> Iterator<&'a T> for Intersection<'a, T> {\n     }\n }\n \n-impl<'a, T: TotalOrd> Iterator<&'a T> for Union<'a, T> {\n+impl<'a, T: TotalOrd> Iterator<&'a T> for UnionItems<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {"}, {"sha": "ae395cbb9bc15aa70938c69334498632f5c7b0b2", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -56,7 +56,7 @@ impl LanguageItems {\n         }\n     }\n \n-    pub fn items<'a>(&'a self) -> Enumerate<vec::VecIterator<'a, Option<ast::DefId>>> {\n+    pub fn items<'a>(&'a self) -> Enumerate<vec::Items<'a, Option<ast::DefId>>> {\n         self.items.iter().enumerate()\n     }\n "}, {"sha": "074c9f4fec515d80e621231c16b4ebb8280f8cfa", "filename": "src/librustc/middle/trans/basic_block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbasic_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbasic_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbasic_block.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n use lib::llvm::{llvm, BasicBlockRef};\n-use middle::trans::value::{UserIterator, Value};\n+use middle::trans::value::{Users, Value};\n use std::iter::{Filter, Map};\n \n pub struct BasicBlock(BasicBlockRef);\n \n-pub type PredIterator<'a> = Map<'a, Value, BasicBlock, Filter<'a, Value, UserIterator>>;\n+pub type Preds<'a> = Map<'a, Value, BasicBlock, Filter<'a, Value, Users>>;\n \n /**\n  * Wrapper for LLVM BasicBlockRef\n@@ -30,7 +30,7 @@ impl BasicBlock {\n         }\n     }\n \n-    pub fn pred_iter(self) -> PredIterator {\n+    pub fn pred_iter(self) -> Preds {\n         self.as_value().user_iter()\n             .filter(|user| user.is_a_terminator_inst())\n             .map(|user| user.get_parent().unwrap())"}, {"sha": "1930b4fa8b916993250c178f6c89a2b085ea1d46", "filename": "src/librustc/middle/trans/value.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -99,8 +99,8 @@ impl Value {\n     }\n \n     /// Returns an iterator for the users of this value\n-    pub fn user_iter(self) -> UserIterator {\n-        UserIterator {\n+    pub fn user_iter(self) -> Users {\n+        Users {\n             next: self.get_first_use()\n         }\n     }\n@@ -151,11 +151,11 @@ impl Use {\n }\n \n /// Iterator for the users of a value\n-pub struct UserIterator {\n+pub struct Users {\n     priv next: Option<Use>\n }\n \n-impl Iterator<Value> for UserIterator {\n+impl Iterator<Value> for Users {\n     fn next(&mut self) -> Option<Value> {\n         let current = self.next;\n "}, {"sha": "301df329f49eea81c37bf6ff8ef5bd058471fe8a", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -171,8 +171,8 @@ impl CString {\n     }\n \n     /// Return a CString iterator.\n-    pub fn iter<'a>(&'a self) -> CStringIterator<'a> {\n-        CStringIterator {\n+    pub fn iter<'a>(&'a self) -> CChars<'a> {\n+        CChars {\n             ptr: self.buf,\n             lifetime: unsafe { cast::transmute(self.buf) },\n         }\n@@ -330,12 +330,12 @@ fn check_for_null(v: &[u8], buf: *mut libc::c_char) {\n /// External iterator for a CString's bytes.\n ///\n /// Use with the `std::iter` module.\n-pub struct CStringIterator<'a> {\n+pub struct CChars<'a> {\n     priv ptr: *libc::c_char,\n     priv lifetime: &'a libc::c_char, // FIXME: #5922\n }\n \n-impl<'a> Iterator<libc::c_char> for CStringIterator<'a> {\n+impl<'a> Iterator<libc::c_char> for CChars<'a> {\n     fn next(&mut self) -> Option<libc::c_char> {\n         let ch = unsafe { *self.ptr };\n         if ch == 0 {"}, {"sha": "26d67daf7c147337e3ae247ac25e023dac42a705", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -305,7 +305,7 @@ pub struct Port<T> {\n /// An iterator over messages received on a port, this iterator will block\n /// whenever `next` is called, waiting for a new message, and `None` will be\n /// returned when the corresponding channel has hung up.\n-pub struct PortIterator<'a, T> {\n+pub struct Messages<'a, T> {\n     priv port: &'a Port<T>\n }\n \n@@ -899,12 +899,12 @@ impl<T: Send> Port<T> {\n \n     /// Returns an iterator which will block waiting for messages, but never\n     /// `fail!`. It will return `None` when the channel has hung up.\n-    pub fn iter<'a>(&'a self) -> PortIterator<'a, T> {\n-        PortIterator { port: self }\n+    pub fn iter<'a>(&'a self) -> Messages<'a, T> {\n+        Messages { port: self }\n     }\n }\n \n-impl<'a, T: Send> Iterator<T> for PortIterator<'a, T> {\n+impl<'a, T: Send> Iterator<T> for Messages<'a, T> {\n     fn next(&mut self) -> Option<T> { self.port.recv_opt() }\n }\n "}, {"sha": "6a10ac56a4ef446b4a9d0cbaaedcdfc468beee38", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -94,7 +94,7 @@ pub struct Handle<'port, T> {\n     priv port: &'port mut Port<T>,\n }\n \n-struct PacketIterator { priv cur: *mut Packet }\n+struct Packets { priv cur: *mut Packet }\n \n impl Select {\n     /// Creates a new selection structure. This set is initially empty and\n@@ -267,7 +267,7 @@ impl Select {\n         (*packet).selection_id = 0;\n     }\n \n-    fn iter(&self) -> PacketIterator { PacketIterator { cur: self.head } }\n+    fn iter(&self) -> Packets { Packets { cur: self.head } }\n }\n \n impl<'port, T: Send> Handle<'port, T> {\n@@ -300,7 +300,7 @@ impl<'port, T: Send> Drop for Handle<'port, T> {\n     }\n }\n \n-impl Iterator<*mut Packet> for PacketIterator {\n+impl Iterator<*mut Packet> for Packets {\n     fn next(&mut self) -> Option<*mut Packet> {\n         if self.cur.is_null() {\n             None"}, {"sha": "8a945d09bfcffa4cede9334749fb5620c05261de", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -497,7 +497,7 @@ pub struct Formatter<'a> {\n \n     /// Output buffer.\n     buf: &'a mut io::Writer,\n-    priv curarg: vec::VecIterator<'a, Argument<'a>>,\n+    priv curarg: vec::Items<'a, Argument<'a>>,\n     priv args: &'a [Argument<'a>],\n }\n "}, {"sha": "6c08eae7474a378778534c628dd4d9a7dd48e300", "filename": "src/libstd/fmt/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -168,7 +168,7 @@ pub struct SelectArm<'a> {\n /// necessary there's probably lots of room for improvement performance-wise.\n pub struct Parser<'a> {\n     priv input: &'a str,\n-    priv cur: str::CharOffsetIterator<'a>,\n+    priv cur: str::CharOffsets<'a>,\n     priv depth: uint,\n }\n "}, {"sha": "7f19105cdc881e881c25144530b0c0d794a61d4a", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -528,34 +528,34 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n \n     /// An iterator visiting all keys in arbitrary order.\n     /// Iterator element type is &'a K.\n-    pub fn keys<'a>(&'a self) -> HashMapKeyIterator<'a, K, V> {\n+    pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         self.iter().map(|(k, _v)| k)\n     }\n \n     /// An iterator visiting all values in arbitrary order.\n     /// Iterator element type is &'a V.\n-    pub fn values<'a>(&'a self) -> HashMapValueIterator<'a, K, V> {\n+    pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         self.iter().map(|(_k, v)| v)\n     }\n \n     /// An iterator visiting all key-value pairs in arbitrary order.\n     /// Iterator element type is (&'a K, &'a V).\n-    pub fn iter<'a>(&'a self) -> HashMapIterator<'a, K, V> {\n-        HashMapIterator { iter: self.buckets.iter() }\n+    pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n+        Entries { iter: self.buckets.iter() }\n     }\n \n     /// An iterator visiting all key-value pairs in arbitrary order,\n     /// with mutable references to the values.\n     /// Iterator element type is (&'a K, &'a mut V).\n-    pub fn mut_iter<'a>(&'a mut self) -> HashMapMutIterator<'a, K, V> {\n-        HashMapMutIterator { iter: self.buckets.mut_iter() }\n+    pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n+        MutEntries { iter: self.buckets.mut_iter() }\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each key-value\n     /// pair out of the map in arbitrary order. The map cannot be used after\n     /// calling this.\n-    pub fn move_iter(self) -> HashMapMoveIterator<K, V> {\n-        HashMapMoveIterator {iter: self.buckets.move_iter()}\n+    pub fn move_iter(self) -> MoveEntries<K, V> {\n+        MoveEntries {iter: self.buckets.move_iter()}\n     }\n }\n \n@@ -598,40 +598,40 @@ impl<K:Hash + Eq + Clone,V:Clone> Clone for HashMap<K,V> {\n \n /// HashMap iterator\n #[deriving(Clone)]\n-pub struct HashMapIterator<'a, K, V> {\n-    priv iter: vec::VecIterator<'a, Option<Bucket<K, V>>>,\n+pub struct Entries<'a, K, V> {\n+    priv iter: vec::Items<'a, Option<Bucket<K, V>>>,\n }\n \n /// HashMap mutable values iterator\n-pub struct HashMapMutIterator<'a, K, V> {\n-    priv iter: vec::VecMutIterator<'a, Option<Bucket<K, V>>>,\n+pub struct MutEntries<'a, K, V> {\n+    priv iter: vec::MutItems<'a, Option<Bucket<K, V>>>,\n }\n \n /// HashMap move iterator\n-pub struct HashMapMoveIterator<K, V> {\n-    priv iter: vec::MoveIterator<Option<Bucket<K, V>>>,\n+pub struct MoveEntries<K, V> {\n+    priv iter: vec::MoveItems<Option<Bucket<K, V>>>,\n }\n \n /// HashMap keys iterator\n-pub type HashMapKeyIterator<'a, K, V> =\n-    iter::Map<'static, (&'a K, &'a V), &'a K, HashMapIterator<'a, K, V>>;\n+pub type Keys<'a, K, V> =\n+    iter::Map<'static, (&'a K, &'a V), &'a K, Entries<'a, K, V>>;\n \n /// HashMap values iterator\n-pub type HashMapValueIterator<'a, K, V> =\n-    iter::Map<'static, (&'a K, &'a V), &'a V, HashMapIterator<'a, K, V>>;\n+pub type Values<'a, K, V> =\n+    iter::Map<'static, (&'a K, &'a V), &'a V, Entries<'a, K, V>>;\n \n /// HashSet iterator\n #[deriving(Clone)]\n-pub struct HashSetIterator<'a, K> {\n-    priv iter: vec::VecIterator<'a, Option<Bucket<K, ()>>>,\n+pub struct SetItems<'a, K> {\n+    priv iter: vec::Items<'a, Option<Bucket<K, ()>>>,\n }\n \n /// HashSet move iterator\n-pub struct HashSetMoveIterator<K> {\n-    priv iter: vec::MoveIterator<Option<Bucket<K, ()>>>,\n+pub struct SetMoveItems<K> {\n+    priv iter: vec::MoveItems<Option<Bucket<K, ()>>>,\n }\n \n-impl<'a, K, V> Iterator<(&'a K, &'a V)> for HashMapIterator<'a, K, V> {\n+impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n     #[inline]\n     fn next(&mut self) -> Option<(&'a K, &'a V)> {\n         for elt in self.iter {\n@@ -644,7 +644,7 @@ impl<'a, K, V> Iterator<(&'a K, &'a V)> for HashMapIterator<'a, K, V> {\n     }\n }\n \n-impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for HashMapMutIterator<'a, K, V> {\n+impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n     #[inline]\n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n         for elt in self.iter {\n@@ -657,7 +657,7 @@ impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for HashMapMutIterator<'a, K, V> {\n     }\n }\n \n-impl<K, V> Iterator<(K, V)> for HashMapMoveIterator<K, V> {\n+impl<K, V> Iterator<(K, V)> for MoveEntries<K, V> {\n     #[inline]\n     fn next(&mut self) -> Option<(K, V)> {\n         for elt in self.iter {\n@@ -670,7 +670,7 @@ impl<K, V> Iterator<(K, V)> for HashMapMoveIterator<K, V> {\n     }\n }\n \n-impl<'a, K> Iterator<&'a K> for HashSetIterator<'a, K> {\n+impl<'a, K> Iterator<&'a K> for SetItems<'a, K> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a K> {\n         for elt in self.iter {\n@@ -683,7 +683,7 @@ impl<'a, K> Iterator<&'a K> for HashSetIterator<'a, K> {\n     }\n }\n \n-impl<K> Iterator<K> for HashSetMoveIterator<K> {\n+impl<K> Iterator<K> for SetMoveItems<K> {\n     #[inline]\n     fn next(&mut self) -> Option<K> {\n         for elt in self.iter {\n@@ -806,19 +806,19 @@ impl<T:Hash + Eq> HashSet<T> {\n \n     /// An iterator visiting all elements in arbitrary order.\n     /// Iterator element type is &'a T.\n-    pub fn iter<'a>(&'a self) -> HashSetIterator<'a, T> {\n-        HashSetIterator { iter: self.map.buckets.iter() }\n+    pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n+        SetItems { iter: self.map.buckets.iter() }\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each value out\n     /// of the set in arbitrary order. The set cannot be used after calling\n     /// this.\n-    pub fn move_iter(self) -> HashSetMoveIterator<T> {\n-        HashSetMoveIterator {iter: self.map.buckets.move_iter()}\n+    pub fn move_iter(self) -> SetMoveItems<T> {\n+        SetMoveItems {iter: self.map.buckets.move_iter()}\n     }\n \n     /// Visit the values representing the difference\n-    pub fn difference<'a>(&'a self, other: &'a HashSet<T>) -> SetAlgebraIter<'a, T> {\n+    pub fn difference<'a>(&'a self, other: &'a HashSet<T>) -> SetAlgebraItems<'a, T> {\n         Repeat::new(other)\n             .zip(self.iter())\n             .filter_map(|(other, elt)| {\n@@ -828,13 +828,13 @@ impl<T:Hash + Eq> HashSet<T> {\n \n     /// Visit the values representing the symmetric difference\n     pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T>)\n-        -> Chain<SetAlgebraIter<'a, T>, SetAlgebraIter<'a, T>> {\n+        -> Chain<SetAlgebraItems<'a, T>, SetAlgebraItems<'a, T>> {\n         self.difference(other).chain(other.difference(self))\n     }\n \n     /// Visit the values representing the intersection\n     pub fn intersection<'a>(&'a self, other: &'a HashSet<T>)\n-        -> SetAlgebraIter<'a, T> {\n+        -> SetAlgebraItems<'a, T> {\n         Repeat::new(other)\n             .zip(self.iter())\n             .filter_map(|(other, elt)| {\n@@ -844,7 +844,7 @@ impl<T:Hash + Eq> HashSet<T> {\n \n     /// Visit the values representing the union\n     pub fn union<'a>(&'a self, other: &'a HashSet<T>)\n-        -> Chain<HashSetIterator<'a, T>, SetAlgebraIter<'a, T>> {\n+        -> Chain<SetItems<'a, T>, SetAlgebraItems<'a, T>> {\n         self.iter().chain(other.difference(self))\n     }\n \n@@ -882,9 +882,9 @@ impl<K: Eq + Hash> Default for HashSet<K> {\n // `Repeat` is used to feed the filter closure an explicit capture\n // of a reference to the other set\n /// Set operations iterator\n-pub type SetAlgebraIter<'a, T> =\n+pub type SetAlgebraItems<'a, T> =\n     FilterMap<'static,(&'a HashSet<T>, &'a T), &'a T,\n-              Zip<Repeat<&'a HashSet<T>>,HashSetIterator<'a,T>>>;\n+              Zip<Repeat<&'a HashSet<T>>,SetItems<'a,T>>>;\n \n \n #[cfg(test)]"}, {"sha": "511462f89f83db0ff69d5aed761eaba51395364f", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -24,7 +24,7 @@ use vec::{OwnedVector, ImmutableVector};\n ///\n /// # Notes about the Iteration Protocol\n ///\n-/// The `ByteIterator` may yield `None` and thus terminate\n+/// The `Bytes` may yield `None` and thus terminate\n /// an iteration, but continue to yield elements if iteration\n /// is attempted again.\n ///\n@@ -33,17 +33,17 @@ use vec::{OwnedVector, ImmutableVector};\n /// Raises the same conditions as the `read` method, for\n /// each call to its `.next()` method.\n /// Yields `None` if the condition is handled.\n-pub struct ByteIterator<'r, T> {\n+pub struct Bytes<'r, T> {\n     priv reader: &'r mut T,\n }\n \n-impl<'r, R: Reader> ByteIterator<'r, R> {\n-    pub fn new(r: &'r mut R) -> ByteIterator<'r, R> {\n-        ByteIterator { reader: r }\n+impl<'r, R: Reader> Bytes<'r, R> {\n+    pub fn new(r: &'r mut R) -> Bytes<'r, R> {\n+        Bytes { reader: r }\n     }\n }\n \n-impl<'r, R: Reader> Iterator<u8> for ByteIterator<'r, R> {\n+impl<'r, R: Reader> Iterator<u8> for Bytes<'r, R> {\n     #[inline]\n     fn next(&mut self) -> Option<u8> {\n         self.reader.read_byte()"}, {"sha": "aac565f2c45e970ef4baee77a68065d5a88ecc80", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -508,16 +508,16 @@ pub fn readdir(path: &Path) -> ~[Path] {\n /// Returns an iterator which will recursively walk the directory structure\n /// rooted at `path`. The path given will not be iterated over, and this will\n /// perform iteration in a top-down order.\n-pub fn walk_dir(path: &Path) -> WalkIterator {\n-    WalkIterator { stack: readdir(path) }\n+pub fn walk_dir(path: &Path) -> Directories {\n+    Directories { stack: readdir(path) }\n }\n \n /// An iterator which walks over a directory\n-pub struct WalkIterator {\n+pub struct Directories {\n     priv stack: ~[Path],\n }\n \n-impl Iterator<Path> for WalkIterator {\n+impl Iterator<Path> for Directories {\n     fn next(&mut self) -> Option<Path> {\n         match self.stack.shift_opt() {\n             Some(path) => {"}, {"sha": "871809805418d5c17ef113b8c2f139d4ed311be5", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -624,8 +624,8 @@ pub trait Reader {\n     /// Raises the same conditions as the `read` method, for\n     /// each call to its `.next()` method.\n     /// Ends the iteration if the condition is handled.\n-    fn bytes<'r>(&'r mut self) -> extensions::ByteIterator<'r, Self> {\n-        extensions::ByteIterator::new(self)\n+    fn bytes<'r>(&'r mut self) -> extensions::Bytes<'r, Self> {\n+        extensions::Bytes::new(self)\n     }\n \n     // Byte conversion helpers\n@@ -1053,7 +1053,7 @@ impl<T: Reader + Writer> Stream for T {}\n ///\n /// # Notes about the Iteration Protocol\n ///\n-/// The `LineIterator` may yield `None` and thus terminate\n+/// The `Lines` may yield `None` and thus terminate\n /// an iteration, but continue to yield elements if iteration\n /// is attempted again.\n ///\n@@ -1062,11 +1062,11 @@ impl<T: Reader + Writer> Stream for T {}\n /// Raises the same conditions as the `read` method except for `EndOfFile`\n /// which is swallowed.\n /// Iteration yields `None` if the condition is handled.\n-pub struct LineIterator<'r, T> {\n+pub struct Lines<'r, T> {\n     priv buffer: &'r mut T,\n }\n \n-impl<'r, T: Buffer> Iterator<~str> for LineIterator<'r, T> {\n+impl<'r, T: Buffer> Iterator<~str> for Lines<'r, T> {\n     fn next(&mut self) -> Option<~str> {\n         self.buffer.read_line()\n     }\n@@ -1126,8 +1126,8 @@ pub trait Buffer: Reader {\n     ///\n     /// Iterator raises the same conditions as the `read` method\n     /// except for `EndOfFile`.\n-    fn lines<'r>(&'r mut self) -> LineIterator<'r, Self> {\n-        LineIterator {\n+    fn lines<'r>(&'r mut self) -> Lines<'r, Self> {\n+        Lines {\n             buffer: self,\n         }\n     }\n@@ -1256,8 +1256,8 @@ pub trait Acceptor<T> {\n     fn accept(&mut self) -> Option<T>;\n \n     /// Create an iterator over incoming connection attempts\n-    fn incoming<'r>(&'r mut self) -> IncomingIterator<'r, Self> {\n-        IncomingIterator { inc: self }\n+    fn incoming<'r>(&'r mut self) -> IncomingConnections<'r, Self> {\n+        IncomingConnections { inc: self }\n     }\n }\n \n@@ -1268,11 +1268,11 @@ pub trait Acceptor<T> {\n /// The Some contains another Option representing whether the connection attempt was succesful.\n /// A successful connection will be wrapped in Some.\n /// A failed connection is represented as a None and raises a condition.\n-struct IncomingIterator<'a, A> {\n+struct IncomingConnections<'a, A> {\n     priv inc: &'a mut A,\n }\n \n-impl<'a, T, A: Acceptor<T>> Iterator<Option<T>> for IncomingIterator<'a, A> {\n+impl<'a, T, A: Acceptor<T>> Iterator<Option<T>> for IncomingConnections<'a, A> {\n     fn next(&mut self) -> Option<Option<T>> {\n         Some(self.inc.accept())\n     }"}, {"sha": "621b1a3d1e2d7684d445bd3d2c3904101678e91b", "filename": "src/libstd/option.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -214,26 +214,26 @@ impl<T> Option<T> {\n \n     /// Return an iterator over the possibly contained value\n     #[inline]\n-    pub fn iter<'r>(&'r self) -> OptionIterator<&'r T> {\n+    pub fn iter<'r>(&'r self) -> Item<&'r T> {\n         match *self {\n-            Some(ref x) => OptionIterator{opt: Some(x)},\n-            None => OptionIterator{opt: None}\n+            Some(ref x) => Item{opt: Some(x)},\n+            None => Item{opt: None}\n         }\n     }\n \n     /// Return a mutable iterator over the possibly contained value\n     #[inline]\n-    pub fn mut_iter<'r>(&'r mut self) -> OptionIterator<&'r mut T> {\n+    pub fn mut_iter<'r>(&'r mut self) -> Item<&'r mut T> {\n         match *self {\n-            Some(ref mut x) => OptionIterator{opt: Some(x)},\n-            None => OptionIterator{opt: None}\n+            Some(ref mut x) => Item{opt: Some(x)},\n+            None => Item{opt: None}\n         }\n     }\n \n     /// Return a consuming iterator over the possibly contained value\n     #[inline]\n-    pub fn move_iter(self) -> OptionIterator<T> {\n-        OptionIterator{opt: self}\n+    pub fn move_iter(self) -> Item<T> {\n+        Item{opt: self}\n     }\n \n     /////////////////////////////////////////////////////////////////////////\n@@ -401,11 +401,11 @@ impl<T> Default for Option<T> {\n \n /// An iterator that yields either one or zero elements\n #[deriving(Clone, DeepClone)]\n-pub struct OptionIterator<A> {\n+pub struct Item<A> {\n     priv opt: Option<A>\n }\n \n-impl<A> Iterator<A> for OptionIterator<A> {\n+impl<A> Iterator<A> for Item<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         self.opt.take()\n@@ -420,14 +420,14 @@ impl<A> Iterator<A> for OptionIterator<A> {\n     }\n }\n \n-impl<A> DoubleEndedIterator<A> for OptionIterator<A> {\n+impl<A> DoubleEndedIterator<A> for Item<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         self.opt.take()\n     }\n }\n \n-impl<A> ExactSize<A> for OptionIterator<A> {}\n+impl<A> ExactSize<A> for Item<A> {}\n \n /////////////////////////////////////////////////////////////////////////////\n // Free functions"}, {"sha": "56e86afaaef12a45f3cef2ba98a8423073b9fa91", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -93,29 +93,29 @@ pub use Path = self::windows::Path;\n \n /// Typedef for the platform-native component iterator\n #[cfg(unix)]\n-pub use ComponentIter = self::posix::ComponentIter;\n+pub use Components = self::posix::Components;\n /// Typedef for the platform-native reverse component iterator\n #[cfg(unix)]\n-pub use RevComponentIter = self::posix::RevComponentIter;\n+pub use RevComponents = self::posix::RevComponents;\n /// Typedef for the platform-native component iterator\n #[cfg(windows)]\n-pub use ComponentIter = self::windows::ComponentIter;\n+pub use Components = self::windows::Components;\n /// Typedef for the platform-native reverse component iterator\n #[cfg(windows)]\n-pub use RevComponentIter = self::windows::RevComponentIter;\n+pub use RevComponents = self::windows::RevComponents;\n \n /// Typedef for the platform-native str component iterator\n #[cfg(unix)]\n-pub use StrComponentIter = self::posix::StrComponentIter;\n+pub use StrComponents = self::posix::StrComponents;\n /// Typedef for the platform-native reverse str component iterator\n #[cfg(unix)]\n-pub use RevStrComponentIter = self::posix::RevStrComponentIter;\n+pub use RevStrComponents = self::posix::RevStrComponents;\n /// Typedef for the platform-native str component iterator\n #[cfg(windows)]\n-pub use StrComponentIter = self::windows::StrComponentIter;\n+pub use StrComponents = self::windows::StrComponents;\n /// Typedef for the platform-native reverse str component iterator\n #[cfg(windows)]\n-pub use RevStrComponentIter = self::windows::RevStrComponentIter;\n+pub use RevStrComponents = self::windows::RevStrComponents;\n \n /// Typedef for the platform-native separator char func\n #[cfg(unix)]"}, {"sha": "0a93f385a06328f59883cac5d3f1d0fd003d5e12", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -21,21 +21,21 @@ use str;\n use str::Str;\n use to_bytes::IterBytes;\n use vec;\n-use vec::{CopyableVector, RSplitIterator, SplitIterator, Vector, VectorVector,\n+use vec::{CopyableVector, RevSplits, Splits, Vector, VectorVector,\n           ImmutableEqVector, OwnedVector, ImmutableVector, OwnedCopyableVector};\n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n \n /// Iterator that yields successive components of a Path as &[u8]\n-pub type ComponentIter<'a> = SplitIterator<'a, u8>;\n+pub type Components<'a> = Splits<'a, u8>;\n /// Iterator that yields components of a Path in reverse as &[u8]\n-pub type RevComponentIter<'a> = RSplitIterator<'a, u8>;\n+pub type RevComponents<'a> = RevSplits<'a, u8>;\n \n /// Iterator that yields successive components of a Path as Option<&str>\n-pub type StrComponentIter<'a> = Map<'a, &'a [u8], Option<&'a str>,\n-                                       ComponentIter<'a>>;\n+pub type StrComponents<'a> = Map<'a, &'a [u8], Option<&'a str>,\n+                                       Components<'a>>;\n /// Iterator that yields components of a Path in reverse as Option<&str>\n-pub type RevStrComponentIter<'a> = Map<'a, &'a [u8], Option<&'a str>,\n-                                          RevComponentIter<'a>>;\n+pub type RevStrComponents<'a> = Map<'a, &'a [u8], Option<&'a str>,\n+                                          RevComponents<'a>>;\n \n /// Represents a POSIX file path\n #[deriving(Clone, DeepClone)]\n@@ -371,7 +371,7 @@ impl Path {\n     /// Does not distinguish between absolute and relative paths, e.g.\n     /// /a/b/c and a/b/c yield the same set of components.\n     /// A path of \"/\" yields no components. A path of \".\" yields one component.\n-    pub fn components<'a>(&'a self) -> ComponentIter<'a> {\n+    pub fn components<'a>(&'a self) -> Components<'a> {\n         let v = if self.repr[0] == sep_byte {\n             self.repr.slice_from(1)\n         } else { self.repr.as_slice() };\n@@ -385,7 +385,7 @@ impl Path {\n \n     /// Returns an iterator that yields each component of the path in reverse.\n     /// See components() for details.\n-    pub fn rev_components<'a>(&'a self) -> RevComponentIter<'a> {\n+    pub fn rev_components<'a>(&'a self) -> RevComponents<'a> {\n         let v = if self.repr[0] == sep_byte {\n             self.repr.slice_from(1)\n         } else { self.repr.as_slice() };\n@@ -399,13 +399,13 @@ impl Path {\n \n     /// Returns an iterator that yields each component of the path as Option<&str>.\n     /// See components() for details.\n-    pub fn str_components<'a>(&'a self) -> StrComponentIter<'a> {\n+    pub fn str_components<'a>(&'a self) -> StrComponents<'a> {\n         self.components().map(str::from_utf8_opt)\n     }\n \n     /// Returns an iterator that yields each component of the path in reverse as Option<&str>.\n     /// See components() for details.\n-    pub fn rev_str_components<'a>(&'a self) -> RevStrComponentIter<'a> {\n+    pub fn rev_str_components<'a>(&'a self) -> RevStrComponents<'a> {\n         self.rev_components().map(str::from_utf8_opt)\n     }\n }"}, {"sha": "9b0169bf22dd404e7928585621cd5a92b294353a", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -20,7 +20,7 @@ use from_str::FromStr;\n use iter::{AdditiveIterator, DoubleEndedIterator, Extendable, Invert, Iterator, Map};\n use option::{Option, Some, None};\n use str;\n-use str::{CharSplitIterator, OwnedStr, Str, StrVector, StrSlice};\n+use str::{CharSplits, OwnedStr, Str, StrVector, StrSlice};\n use to_bytes::IterBytes;\n use vec::{Vector, OwnedVector, ImmutableVector};\n use super::{contains_nul, BytesContainer, GenericPath, GenericPathUnsafe};\n@@ -29,21 +29,21 @@ use super::{contains_nul, BytesContainer, GenericPath, GenericPathUnsafe};\n ///\n /// Each component is yielded as Option<&str> for compatibility with PosixPath, but\n /// every component in WindowsPath is guaranteed to be Some.\n-pub type StrComponentIter<'a> = Map<'a, &'a str, Option<&'a str>,\n-                                       CharSplitIterator<'a, char>>;\n+pub type StrComponents<'a> = Map<'a, &'a str, Option<&'a str>,\n+                                       CharSplits<'a, char>>;\n /// Iterator that yields components of a Path in reverse as &str\n ///\n /// Each component is yielded as Option<&str> for compatibility with PosixPath, but\n /// every component in WindowsPath is guaranteed to be Some.\n-pub type RevStrComponentIter<'a> = Invert<Map<'a, &'a str, Option<&'a str>,\n-                                                 CharSplitIterator<'a, char>>>;\n+pub type RevStrComponents<'a> = Invert<Map<'a, &'a str, Option<&'a str>,\n+                                                 CharSplits<'a, char>>>;\n \n /// Iterator that yields successive components of a Path as &[u8]\n-pub type ComponentIter<'a> = Map<'a, Option<&'a str>, &'a [u8],\n-                                    StrComponentIter<'a>>;\n+pub type Components<'a> = Map<'a, Option<&'a str>, &'a [u8],\n+                                    StrComponents<'a>>;\n /// Iterator that yields components of a Path in reverse as &[u8]\n-pub type RevComponentIter<'a> = Map<'a, Option<&'a str>, &'a [u8],\n-                                       RevStrComponentIter<'a>>;\n+pub type RevComponents<'a> = Map<'a, Option<&'a str>, &'a [u8],\n+                                       RevStrComponents<'a>>;\n \n /// Represents a Windows path\n // Notes for Windows path impl:\n@@ -615,7 +615,7 @@ impl Path {\n     /// \\a\\b\\c and a\\b\\c.\n     /// Does not distinguish between absolute and cwd-relative paths, e.g.\n     /// C:\\foo and C:foo.\n-    pub fn str_components<'a>(&'a self) -> StrComponentIter<'a> {\n+    pub fn str_components<'a>(&'a self) -> StrComponents<'a> {\n         let s = match self.prefix {\n             Some(_) => {\n                 let plen = self.prefix_len();\n@@ -632,13 +632,13 @@ impl Path {\n \n     /// Returns an iterator that yields each component of the path in reverse as an Option<&str>\n     /// See str_components() for details.\n-    pub fn rev_str_components<'a>(&'a self) -> RevStrComponentIter<'a> {\n+    pub fn rev_str_components<'a>(&'a self) -> RevStrComponents<'a> {\n         self.str_components().invert()\n     }\n \n     /// Returns an iterator that yields each component of the path in turn as a &[u8].\n     /// See str_components() for details.\n-    pub fn components<'a>(&'a self) -> ComponentIter<'a> {\n+    pub fn components<'a>(&'a self) -> Components<'a> {\n         fn convert<'a>(x: Option<&'a str>) -> &'a [u8] {\n             #[inline];\n             x.unwrap().as_bytes()\n@@ -648,7 +648,7 @@ impl Path {\n \n     /// Returns an iterator that yields each component of the path in reverse as a &[u8].\n     /// See str_components() for details.\n-    pub fn rev_components<'a>(&'a self) -> RevComponentIter<'a> {\n+    pub fn rev_components<'a>(&'a self) -> RevComponents<'a> {\n         fn convert<'a>(x: Option<&'a str>) -> &'a [u8] {\n             #[inline];\n             x.unwrap().as_bytes()"}, {"sha": "5041c4b6165688e972d977efa5fa29d4bfc740ed", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -79,7 +79,7 @@ pub struct Death {\n     on_exit: Option<proc(TaskResult)>,\n }\n \n-pub struct BlockedTaskIterator {\n+pub struct BlockedTasks {\n     priv inner: UnsafeArc<AtomicUint>,\n }\n \n@@ -300,7 +300,7 @@ impl Drop for Task {\n     }\n }\n \n-impl Iterator<BlockedTask> for BlockedTaskIterator {\n+impl Iterator<BlockedTask> for BlockedTasks {\n     fn next(&mut self) -> Option<BlockedTask> {\n         Some(Shared(self.inner.clone()))\n     }\n@@ -331,7 +331,7 @@ impl BlockedTask {\n     }\n \n     /// Converts one blocked task handle to a list of many handles to the same.\n-    pub fn make_selectable(self, num_handles: uint) -> Take<BlockedTaskIterator>\n+    pub fn make_selectable(self, num_handles: uint) -> Take<BlockedTasks>\n     {\n         let arc = match self {\n             Owned(task) => {\n@@ -340,7 +340,7 @@ impl BlockedTask {\n             }\n             Shared(arc) => arc.clone(),\n         };\n-        BlockedTaskIterator{ inner: arc }.take(num_handles)\n+        BlockedTasks{ inner: arc }.take(num_handles)\n     }\n \n     /// Convert to an unsafe uint value. Useful for storing in a pipe's state"}, {"sha": "fdc9c11d93a3ae7fea6a27c08be5f150083f810d", "filename": "src/libstd/str.rs", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -331,12 +331,12 @@ Section: Iterators\n /// External iterator for a string's characters.\n /// Use with the `std::iter` module.\n #[deriving(Clone)]\n-pub struct CharIterator<'a> {\n+pub struct Chars<'a> {\n     /// The slice remaining to be iterated\n     priv string: &'a str,\n }\n \n-impl<'a> Iterator<char> for CharIterator<'a> {\n+impl<'a> Iterator<char> for Chars<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n         // Decode the next codepoint, then update\n@@ -358,7 +358,7 @@ impl<'a> Iterator<char> for CharIterator<'a> {\n     }\n }\n \n-impl<'a> DoubleEndedIterator<char> for CharIterator<'a> {\n+impl<'a> DoubleEndedIterator<char> for Chars<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {\n         if self.string.len() != 0 {\n@@ -376,13 +376,13 @@ impl<'a> DoubleEndedIterator<char> for CharIterator<'a> {\n /// External iterator for a string's characters and their byte offsets.\n /// Use with the `std::iter` module.\n #[deriving(Clone)]\n-pub struct CharOffsetIterator<'a> {\n+pub struct CharOffsets<'a> {\n     /// The original string to be iterated\n     priv string: &'a str,\n-    priv iter: CharIterator<'a>,\n+    priv iter: Chars<'a>,\n }\n \n-impl<'a> Iterator<(uint, char)> for CharOffsetIterator<'a> {\n+impl<'a> Iterator<(uint, char)> for CharOffsets<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<(uint, char)> {\n         // Compute the byte offset by using the pointer offset between\n@@ -397,7 +397,7 @@ impl<'a> Iterator<(uint, char)> for CharOffsetIterator<'a> {\n     }\n }\n \n-impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsetIterator<'a> {\n+impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsets<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, char)> {\n         self.iter.next_back().map(|ch| {\n@@ -410,24 +410,24 @@ impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsetIterator<'a> {\n \n /// External iterator for a string's characters in reverse order.\n /// Use with the `std::iter` module.\n-pub type CharRevIterator<'a> = Invert<CharIterator<'a>>;\n+pub type RevChars<'a> = Invert<Chars<'a>>;\n \n /// External iterator for a string's characters and their byte offsets in reverse order.\n /// Use with the `std::iter` module.\n-pub type CharOffsetRevIterator<'a> = Invert<CharOffsetIterator<'a>>;\n+pub type RevCharOffsets<'a> = Invert<CharOffsets<'a>>;\n \n /// External iterator for a string's bytes.\n /// Use with the `std::iter` module.\n-pub type ByteIterator<'a> =\n-    Map<'a, &'a u8, u8, vec::VecIterator<'a, u8>>;\n+pub type Bytes<'a> =\n+    Map<'a, &'a u8, u8, vec::Items<'a, u8>>;\n \n /// External iterator for a string's bytes in reverse order.\n /// Use with the `std::iter` module.\n-pub type ByteRevIterator<'a> = Invert<ByteIterator<'a>>;\n+pub type RevBytes<'a> = Invert<Bytes<'a>>;\n \n /// An iterator over the substrings of a string, separated by `sep`.\n #[deriving(Clone)]\n-pub struct CharSplitIterator<'a, Sep> {\n+pub struct CharSplits<'a, Sep> {\n     /// The slice remaining to be iterated\n     priv string: &'a str,\n     priv sep: Sep,\n@@ -439,27 +439,27 @@ pub struct CharSplitIterator<'a, Sep> {\n \n /// An iterator over the substrings of a string, separated by `sep`,\n /// starting from the back of the string.\n-pub type CharRSplitIterator<'a, Sep> = Invert<CharSplitIterator<'a, Sep>>;\n+pub type RevCharSplits<'a, Sep> = Invert<CharSplits<'a, Sep>>;\n \n /// An iterator over the substrings of a string, separated by `sep`,\n /// splitting at most `count` times.\n #[deriving(Clone)]\n-pub struct CharSplitNIterator<'a, Sep> {\n-    priv iter: CharSplitIterator<'a, Sep>,\n+pub struct CharSplitsN<'a, Sep> {\n+    priv iter: CharSplits<'a, Sep>,\n     /// The number of splits remaining\n     priv count: uint,\n     priv invert: bool,\n }\n \n /// An iterator over the words of a string, separated by an sequence of whitespace\n-pub type WordIterator<'a> =\n-    Filter<'a, &'a str, CharSplitIterator<'a, extern \"Rust\" fn(char) -> bool>>;\n+pub type Words<'a> =\n+    Filter<'a, &'a str, CharSplits<'a, extern \"Rust\" fn(char) -> bool>>;\n \n /// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n-pub type AnyLineIterator<'a> =\n-    Map<'a, &'a str, &'a str, CharSplitIterator<'a, char>>;\n+pub type AnyLines<'a> =\n+    Map<'a, &'a str, &'a str, CharSplits<'a, char>>;\n \n-impl<'a, Sep> CharSplitIterator<'a, Sep> {\n+impl<'a, Sep> CharSplits<'a, Sep> {\n     #[inline]\n     fn get_end(&mut self) -> Option<&'a str> {\n         if !self.finished && (self.allow_trailing_empty || self.string.len() > 0) {\n@@ -471,7 +471,7 @@ impl<'a, Sep> CharSplitIterator<'a, Sep> {\n     }\n }\n \n-impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplitIterator<'a, Sep> {\n+impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplits<'a, Sep> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n         if self.finished { return None }\n@@ -504,7 +504,7 @@ impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplitIterator<'a, Sep> {\n }\n \n impl<'a, Sep: CharEq> DoubleEndedIterator<&'a str>\n-for CharSplitIterator<'a, Sep> {\n+for CharSplits<'a, Sep> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> {\n         if self.finished { return None }\n@@ -545,7 +545,7 @@ for CharSplitIterator<'a, Sep> {\n     }\n }\n \n-impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplitNIterator<'a, Sep> {\n+impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplitsN<'a, Sep> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n         if self.count != 0 {\n@@ -560,7 +560,7 @@ impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplitNIterator<'a, Sep> {\n /// An iterator over the start and end indices of the matches of a\n /// substring within a larger string\n #[deriving(Clone)]\n-pub struct MatchesIndexIterator<'a> {\n+pub struct MatchIndices<'a> {\n     priv haystack: &'a str,\n     priv needle: &'a str,\n     priv position: uint,\n@@ -569,13 +569,13 @@ pub struct MatchesIndexIterator<'a> {\n /// An iterator over the substrings of a string separated by a given\n /// search string\n #[deriving(Clone)]\n-pub struct StrSplitIterator<'a> {\n-    priv it: MatchesIndexIterator<'a>,\n+pub struct StrSplits<'a> {\n+    priv it: MatchIndices<'a>,\n     priv last_end: uint,\n     priv finished: bool\n }\n \n-impl<'a> Iterator<(uint, uint)> for MatchesIndexIterator<'a> {\n+impl<'a> Iterator<(uint, uint)> for MatchIndices<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<(uint, uint)> {\n         // See Issue #1932 for why this is a naive search\n@@ -606,7 +606,7 @@ impl<'a> Iterator<(uint, uint)> for MatchesIndexIterator<'a> {\n     }\n }\n \n-impl<'a> Iterator<&'a str> for StrSplitIterator<'a> {\n+impl<'a> Iterator<&'a str> for StrSplits<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n         if self.finished { return None; }\n@@ -654,14 +654,14 @@ enum NormalizationForm {\n /// External iterator for a string's normalization's characters.\n /// Use with the `std::iter` module.\n #[deriving(Clone)]\n-struct NormalizationIterator<'a> {\n+struct Normalizations<'a> {\n     priv kind: NormalizationForm,\n-    priv iter: CharIterator<'a>,\n+    priv iter: Chars<'a>,\n     priv buffer: ~[(char, u8)],\n     priv sorted: bool\n }\n \n-impl<'a> Iterator<char> for NormalizationIterator<'a> {\n+impl<'a> Iterator<char> for Normalizations<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n         use unicode::decompose::canonical_combining_class;\n@@ -1347,23 +1347,23 @@ pub trait StrSlice<'a> {\n     /// let v: ~[char] = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n     /// assert_eq!(v, ~['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n     /// ```\n-    fn chars(&self) -> CharIterator<'a>;\n+    fn chars(&self) -> Chars<'a>;\n \n     /// An iterator over the characters of `self`, in reverse order.\n-    fn chars_rev(&self) -> CharRevIterator<'a>;\n+    fn chars_rev(&self) -> RevChars<'a>;\n \n     /// An iterator over the bytes of `self`\n-    fn bytes(&self) -> ByteIterator<'a>;\n+    fn bytes(&self) -> Bytes<'a>;\n \n     /// An iterator over the bytes of `self`, in reverse order\n-    fn bytes_rev(&self) -> ByteRevIterator<'a>;\n+    fn bytes_rev(&self) -> RevBytes<'a>;\n \n     /// An iterator over the characters of `self` and their byte offsets.\n-    fn char_indices(&self) -> CharOffsetIterator<'a>;\n+    fn char_indices(&self) -> CharOffsets<'a>;\n \n     /// An iterator over the characters of `self` and their byte offsets,\n     /// in reverse order.\n-    fn char_indices_rev(&self) -> CharOffsetRevIterator<'a>;\n+    fn char_indices_rev(&self) -> RevCharOffsets<'a>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`.\n@@ -1380,7 +1380,7 @@ pub trait StrSlice<'a> {\n     /// let v: ~[&str] = \"lionXXtigerXleopard\".split('X').collect();\n     /// assert_eq!(v, ~[\"lion\", \"\", \"tiger\", \"leopard\"]);\n     /// ```\n-    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'a, Sep>;\n+    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`, restricted to splitting at most `count`\n@@ -1398,7 +1398,7 @@ pub trait StrSlice<'a> {\n     /// let v: ~[&str] = \"lionXXtigerXleopard\".splitn('X', 2).collect();\n     /// assert_eq!(v, ~[\"lion\", \"\", \"tigerXleopard\"]);\n     /// ```\n-    fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitNIterator<'a, Sep>;\n+    fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`.\n@@ -1415,7 +1415,7 @@ pub trait StrSlice<'a> {\n     /// let v: ~[&str] = \"A..B..\".split_terminator('.').collect();\n     /// assert_eq!(v, ~[\"A\", \"\", \"B\", \"\"]);\n     /// ```\n-    fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'a, Sep>;\n+    fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`, in reverse order.\n@@ -1432,7 +1432,7 @@ pub trait StrSlice<'a> {\n     /// let v: ~[&str] = \"lionXXtigerXleopard\".rsplit('X').collect();\n     /// assert_eq!(v, ~[\"leopard\", \"tiger\", \"\", \"lion\"]);\n     /// ```\n-    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> CharRSplitIterator<'a, Sep>;\n+    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> RevCharSplits<'a, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`, starting from the end of the string.\n@@ -1450,7 +1450,7 @@ pub trait StrSlice<'a> {\n     /// let v: ~[&str] = \"lionXXtigerXleopard\".rsplitn('X', 2).collect();\n     /// assert_eq!(v, ~[\"leopard\", \"tiger\", \"lionX\"]);\n     /// ```\n-    fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitNIterator<'a, Sep>;\n+    fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;\n \n     /// An iterator over the start and end indices of the disjoint\n     /// matches of `sep` within `self`.\n@@ -1472,7 +1472,7 @@ pub trait StrSlice<'a> {\n     /// let v: ~[(uint, uint)] = \"ababa\".match_indices(\"aba\").collect();\n     /// assert_eq!(v, ~[(0, 3)]); // only the first `aba`\n     /// ```\n-    fn match_indices(&self, sep: &'a str) -> MatchesIndexIterator<'a>;\n+    fn match_indices(&self, sep: &'a str) -> MatchIndices<'a>;\n \n     /// An iterator over the substrings of `self` separated by `sep`.\n     ///\n@@ -1485,7 +1485,7 @@ pub trait StrSlice<'a> {\n     /// let v: ~[&str] = \"1abcabc2\".split_str(\"abc\").collect();\n     /// assert_eq!(v, ~[\"1\", \"\", \"2\"]);\n     /// ```\n-    fn split_str(&self, &'a str) -> StrSplitIterator<'a>;\n+    fn split_str(&self, &'a str) -> StrSplits<'a>;\n \n     /// An iterator over the lines of a string (subsequences separated\n     /// by `\\n`). This does not include the empty string after a\n@@ -1498,7 +1498,7 @@ pub trait StrSlice<'a> {\n     /// let v: ~[&str] = four_lines.lines().collect();\n     /// assert_eq!(v, ~[\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n-    fn lines(&self) -> CharSplitIterator<'a, char>;\n+    fn lines(&self) -> CharSplits<'a, char>;\n \n     /// An iterator over the lines of a string, separated by either\n     /// `\\n` or `\\r\\n`. As with `.lines()`, this does not include an\n@@ -1511,7 +1511,7 @@ pub trait StrSlice<'a> {\n     /// let v: ~[&str] = four_lines.lines_any().collect();\n     /// assert_eq!(v, ~[\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n-    fn lines_any(&self) -> AnyLineIterator<'a>;\n+    fn lines_any(&self) -> AnyLines<'a>;\n \n     /// An iterator over the words of a string (subsequences separated\n     /// by any sequence of whitespace). Sequences of whitespace are\n@@ -1524,15 +1524,15 @@ pub trait StrSlice<'a> {\n     /// let v: ~[&str] = some_words.words().collect();\n     /// assert_eq!(v, ~[\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     /// ```\n-    fn words(&self) -> WordIterator<'a>;\n+    fn words(&self) -> Words<'a>;\n \n     /// An Iterator over the string in Unicode Normalization Form D\n     /// (canonical decomposition).\n-    fn nfd_chars(&self) -> NormalizationIterator<'a>;\n+    fn nfd_chars(&self) -> Normalizations<'a>;\n \n     /// An Iterator over the string in Unicode Normalization Form KD\n     /// (compatibility decomposition).\n-    fn nfkd_chars(&self) -> NormalizationIterator<'a>;\n+    fn nfkd_chars(&self) -> Normalizations<'a>;\n \n     /// Returns true if the string contains only whitespace.\n     ///\n@@ -2008,38 +2008,38 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn chars(&self) -> CharIterator<'a> {\n-        CharIterator{string: *self}\n+    fn chars(&self) -> Chars<'a> {\n+        Chars{string: *self}\n     }\n \n     #[inline]\n-    fn chars_rev(&self) -> CharRevIterator<'a> {\n+    fn chars_rev(&self) -> RevChars<'a> {\n         self.chars().invert()\n     }\n \n     #[inline]\n-    fn bytes(&self) -> ByteIterator<'a> {\n+    fn bytes(&self) -> Bytes<'a> {\n         self.as_bytes().iter().map(|&b| b)\n     }\n \n     #[inline]\n-    fn bytes_rev(&self) -> ByteRevIterator<'a> {\n+    fn bytes_rev(&self) -> RevBytes<'a> {\n         self.bytes().invert()\n     }\n \n     #[inline]\n-    fn char_indices(&self) -> CharOffsetIterator<'a> {\n-        CharOffsetIterator{string: *self, iter: self.chars()}\n+    fn char_indices(&self) -> CharOffsets<'a> {\n+        CharOffsets{string: *self, iter: self.chars()}\n     }\n \n     #[inline]\n-    fn char_indices_rev(&self) -> CharOffsetRevIterator<'a> {\n+    fn char_indices_rev(&self) -> RevCharOffsets<'a> {\n         self.char_indices().invert()\n     }\n \n     #[inline]\n-    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'a, Sep> {\n-        CharSplitIterator {\n+    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep> {\n+        CharSplits {\n             string: *self,\n             only_ascii: sep.only_ascii(),\n             sep: sep,\n@@ -2050,8 +2050,8 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint)\n-        -> CharSplitNIterator<'a, Sep> {\n-        CharSplitNIterator {\n+        -> CharSplitsN<'a, Sep> {\n+        CharSplitsN {\n             iter: self.split(sep),\n             count: count,\n             invert: false,\n@@ -2060,53 +2060,53 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn split_terminator<Sep: CharEq>(&self, sep: Sep)\n-        -> CharSplitIterator<'a, Sep> {\n-        CharSplitIterator {\n+        -> CharSplits<'a, Sep> {\n+        CharSplits {\n             allow_trailing_empty: false,\n             ..self.split(sep)\n         }\n     }\n \n     #[inline]\n-    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> CharRSplitIterator<'a, Sep> {\n+    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> RevCharSplits<'a, Sep> {\n         self.split(sep).invert()\n     }\n \n     #[inline]\n     fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint)\n-        -> CharSplitNIterator<'a, Sep> {\n-        CharSplitNIterator {\n+        -> CharSplitsN<'a, Sep> {\n+        CharSplitsN {\n             iter: self.split(sep),\n             count: count,\n             invert: true,\n         }\n     }\n \n     #[inline]\n-    fn match_indices(&self, sep: &'a str) -> MatchesIndexIterator<'a> {\n+    fn match_indices(&self, sep: &'a str) -> MatchIndices<'a> {\n         assert!(!sep.is_empty())\n-        MatchesIndexIterator {\n+        MatchIndices {\n             haystack: *self,\n             needle: sep,\n             position: 0\n         }\n     }\n \n     #[inline]\n-    fn split_str(&self, sep: &'a str) -> StrSplitIterator<'a> {\n-        StrSplitIterator {\n+    fn split_str(&self, sep: &'a str) -> StrSplits<'a> {\n+        StrSplits {\n             it: self.match_indices(sep),\n             last_end: 0,\n             finished: false\n         }\n     }\n \n     #[inline]\n-    fn lines(&self) -> CharSplitIterator<'a, char> {\n+    fn lines(&self) -> CharSplits<'a, char> {\n         self.split_terminator('\\n')\n     }\n \n-    fn lines_any(&self) -> AnyLineIterator<'a> {\n+    fn lines_any(&self) -> AnyLines<'a> {\n         self.lines().map(|line| {\n             let l = line.len();\n             if l > 0 && line[l - 1] == '\\r' as u8 { line.slice(0, l - 1) }\n@@ -2115,13 +2115,13 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn words(&self) -> WordIterator<'a> {\n+    fn words(&self) -> Words<'a> {\n         self.split(char::is_whitespace).filter(|s| !s.is_empty())\n     }\n \n     #[inline]\n-    fn nfd_chars(&self) -> NormalizationIterator<'a> {\n-        NormalizationIterator {\n+    fn nfd_chars(&self) -> Normalizations<'a> {\n+        Normalizations {\n             iter: self.chars(),\n             buffer: ~[],\n             sorted: false,\n@@ -2130,8 +2130,8 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn nfkd_chars(&self) -> NormalizationIterator<'a> {\n-        NormalizationIterator {\n+    fn nfkd_chars(&self) -> Normalizations<'a> {\n+        Normalizations {\n             iter: self.chars(),\n             buffer: ~[],\n             sorted: false,"}, {"sha": "2c3fd18e587de7aa96d59dae410de3df80c2243f", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -115,8 +115,8 @@ impl<T> TrieMap<T> {\n     }\n \n     /// Get an iterator over the key-value pairs in the map\n-    pub fn iter<'a>(&'a self) -> TrieMapIterator<'a, T> {\n-        let mut iter = unsafe {TrieMapIterator::new()};\n+    pub fn iter<'a>(&'a self) -> Entries<'a, T> {\n+        let mut iter = unsafe {Entries::new()};\n         iter.stack[0] = self.root.children.iter();\n         iter.length = 1;\n         iter.remaining_min = self.length;\n@@ -127,8 +127,8 @@ impl<T> TrieMap<T> {\n \n     /// Get an iterator over the key-value pairs in the map, with the\n     /// ability to mutate the values.\n-    pub fn mut_iter<'a>(&'a mut self) -> TrieMapMutIterator<'a, T> {\n-        let mut iter = unsafe {TrieMapMutIterator::new()};\n+    pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, T> {\n+        let mut iter = unsafe {MutEntries::new()};\n         iter.stack[0] = self.root.children.mut_iter();\n         iter.length = 1;\n         iter.remaining_min = self.length;\n@@ -221,42 +221,42 @@ macro_rules! bound {\n impl<T> TrieMap<T> {\n     // If `upper` is true then returns upper_bound else returns lower_bound.\n     #[inline]\n-    fn bound<'a>(&'a self, key: uint, upper: bool) -> TrieMapIterator<'a, T> {\n-        bound!(TrieMapIterator, self = self,\n+    fn bound<'a>(&'a self, key: uint, upper: bool) -> Entries<'a, T> {\n+        bound!(Entries, self = self,\n                key = key, is_upper = upper,\n                slice_from = slice_from, iter = iter,\n                mutability = )\n     }\n \n     /// Get an iterator pointing to the first key-value pair whose key is not less than `key`.\n     /// If all keys in the map are less than `key` an empty iterator is returned.\n-    pub fn lower_bound<'a>(&'a self, key: uint) -> TrieMapIterator<'a, T> {\n+    pub fn lower_bound<'a>(&'a self, key: uint) -> Entries<'a, T> {\n         self.bound(key, false)\n     }\n \n     /// Get an iterator pointing to the first key-value pair whose key is greater than `key`.\n     /// If all keys in the map are not greater than `key` an empty iterator is returned.\n-    pub fn upper_bound<'a>(&'a self, key: uint) -> TrieMapIterator<'a, T> {\n+    pub fn upper_bound<'a>(&'a self, key: uint) -> Entries<'a, T> {\n         self.bound(key, true)\n     }\n     // If `upper` is true then returns upper_bound else returns lower_bound.\n     #[inline]\n-    fn mut_bound<'a>(&'a mut self, key: uint, upper: bool) -> TrieMapMutIterator<'a, T> {\n-        bound!(TrieMapMutIterator, self = self,\n+    fn mut_bound<'a>(&'a mut self, key: uint, upper: bool) -> MutEntries<'a, T> {\n+        bound!(MutEntries, self = self,\n                key = key, is_upper = upper,\n                slice_from = mut_slice_from, iter = mut_iter,\n                mutability = mut)\n     }\n \n     /// Get an iterator pointing to the first key-value pair whose key is not less than `key`.\n     /// If all keys in the map are less than `key` an empty iterator is returned.\n-    pub fn mut_lower_bound<'a>(&'a mut self, key: uint) -> TrieMapMutIterator<'a, T> {\n+    pub fn mut_lower_bound<'a>(&'a mut self, key: uint) -> MutEntries<'a, T> {\n         self.mut_bound(key, false)\n     }\n \n     /// Get an iterator pointing to the first key-value pair whose key is greater than `key`.\n     /// If all keys in the map are not greater than `key` an empty iterator is returned.\n-    pub fn mut_upper_bound<'a>(&'a mut self, key: uint) -> TrieMapMutIterator<'a, T> {\n+    pub fn mut_upper_bound<'a>(&'a mut self, key: uint) -> MutEntries<'a, T> {\n         self.mut_bound(key, true)\n     }\n }\n@@ -329,20 +329,20 @@ impl TrieSet {\n \n     /// Get an iterator over the values in the set\n     #[inline]\n-    pub fn iter<'a>(&'a self) -> TrieSetIterator<'a> {\n-        TrieSetIterator{iter: self.map.iter()}\n+    pub fn iter<'a>(&'a self) -> SetItems<'a> {\n+        SetItems{iter: self.map.iter()}\n     }\n \n     /// Get an iterator pointing to the first value that is not less than `val`.\n     /// If all values in the set are less than `val` an empty iterator is returned.\n-    pub fn lower_bound<'a>(&'a self, val: uint) -> TrieSetIterator<'a> {\n-        TrieSetIterator{iter: self.map.lower_bound(val)}\n+    pub fn lower_bound<'a>(&'a self, val: uint) -> SetItems<'a> {\n+        SetItems{iter: self.map.lower_bound(val)}\n     }\n \n     /// Get an iterator pointing to the first value that key is greater than `val`.\n     /// If all values in the set are not greater than `val` an empty iterator is returned.\n-    pub fn upper_bound<'a>(&'a self, val: uint) -> TrieSetIterator<'a> {\n-        TrieSetIterator{iter: self.map.upper_bound(val)}\n+    pub fn upper_bound<'a>(&'a self, val: uint) -> SetItems<'a> {\n+        SetItems{iter: self.map.upper_bound(val)}\n     }\n }\n \n@@ -474,17 +474,17 @@ fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n }\n \n /// Forward iterator over a map\n-pub struct TrieMapIterator<'a, T> {\n-    priv stack: [vec::VecIterator<'a, Child<T>>, .. NUM_CHUNKS],\n+pub struct Entries<'a, T> {\n+    priv stack: [vec::Items<'a, Child<T>>, .. NUM_CHUNKS],\n     priv length: uint,\n     priv remaining_min: uint,\n     priv remaining_max: uint\n }\n \n /// Forward iterator over the key-value pairs of a map, with the\n /// values being mutable.\n-pub struct TrieMapMutIterator<'a, T> {\n-    priv stack: [vec::VecMutIterator<'a, Child<T>>, .. NUM_CHUNKS],\n+pub struct MutEntries<'a, T> {\n+    priv stack: [vec::MutItems<'a, Child<T>>, .. NUM_CHUNKS],\n     priv length: uint,\n     priv remaining_min: uint,\n     priv remaining_max: uint\n@@ -601,15 +601,15 @@ macro_rules! iterator_impl {\n     }\n }\n \n-iterator_impl! { TrieMapIterator, iter = iter, mutability = }\n-iterator_impl! { TrieMapMutIterator, iter = mut_iter, mutability = mut }\n+iterator_impl! { Entries, iter = iter, mutability = }\n+iterator_impl! { MutEntries, iter = mut_iter, mutability = mut }\n \n /// Forward iterator over a set\n-pub struct TrieSetIterator<'a> {\n-    priv iter: TrieMapIterator<'a, ()>\n+pub struct SetItems<'a> {\n+    priv iter: Entries<'a, ()>\n }\n \n-impl<'a> Iterator<uint> for TrieSetIterator<'a> {\n+impl<'a> Iterator<uint> for SetItems<'a> {\n     fn next(&mut self) -> Option<uint> {\n         self.iter.next().map(|(key, _)| key)\n     }"}, {"sha": "d85e679c6a36140602df45795a4a75cecdf521ce", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 71, "deletions": 71, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -25,7 +25,7 @@ This is a big module, but for a high-level overview:\n \n ## Structs\n \n-Several structs that are useful for vectors, such as `VecIterator`, which\n+Several structs that are useful for vectors, such as `Items`, which\n represents iteration over a vector.\n \n ## Traits\n@@ -230,14 +230,14 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n \n /// An iterator over the slices of a vector separated by elements that\n /// match a predicate function.\n-pub struct SplitIterator<'a, T> {\n+pub struct Splits<'a, T> {\n     priv v: &'a [T],\n     priv n: uint,\n     priv pred: 'a |t: &T| -> bool,\n     priv finished: bool\n }\n \n-impl<'a, T> Iterator<&'a [T]> for SplitIterator<'a, T> {\n+impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n@@ -279,14 +279,14 @@ impl<'a, T> Iterator<&'a [T]> for SplitIterator<'a, T> {\n \n /// An iterator over the slices of a vector separated by elements that\n /// match a predicate function, from back to front.\n-pub struct RSplitIterator<'a, T> {\n+pub struct RevSplits<'a, T> {\n     priv v: &'a [T],\n     priv n: uint,\n     priv pred: 'a |t: &T| -> bool,\n     priv finished: bool\n }\n \n-impl<'a, T> Iterator<&'a [T]> for RSplitIterator<'a, T> {\n+impl<'a, T> Iterator<&'a [T]> for RevSplits<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n@@ -514,12 +514,12 @@ impl<T: Clone> Iterator<~[T]> for Permutations<T> {\n /// An iterator over the (overlapping) slices of length `size` within\n /// a vector.\n #[deriving(Clone)]\n-pub struct WindowIter<'a, T> {\n+pub struct Windows<'a, T> {\n     priv v: &'a [T],\n     priv size: uint\n }\n \n-impl<'a, T> Iterator<&'a [T]> for WindowIter<'a, T> {\n+impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n         if self.size > self.v.len() {\n@@ -548,12 +548,12 @@ impl<'a, T> Iterator<&'a [T]> for WindowIter<'a, T> {\n /// When the vector len is not evenly divided by the chunk size,\n /// the last slice of the iteration will be the remainder.\n #[deriving(Clone)]\n-pub struct ChunkIter<'a, T> {\n+pub struct Chunks<'a, T> {\n     priv v: &'a [T],\n     priv size: uint\n }\n \n-impl<'a, T> Iterator<&'a [T]> for ChunkIter<'a, T> {\n+impl<'a, T> Iterator<&'a [T]> for Chunks<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n         if self.v.len() == 0 {\n@@ -579,7 +579,7 @@ impl<'a, T> Iterator<&'a [T]> for ChunkIter<'a, T> {\n     }\n }\n \n-impl<'a, T> DoubleEndedIterator<&'a [T]> for ChunkIter<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a [T]> for Chunks<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n         if self.v.len() == 0 {\n@@ -595,7 +595,7 @@ impl<'a, T> DoubleEndedIterator<&'a [T]> for ChunkIter<'a, T> {\n     }\n }\n \n-impl<'a, T> RandomAccessIterator<&'a [T]> for ChunkIter<'a, T> {\n+impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         self.v.len()/self.size + if self.v.len() % self.size != 0 { 1 } else { 0 }\n@@ -866,29 +866,29 @@ pub trait ImmutableVector<'a, T> {\n      */\n     fn slice_to(&self, end: uint) -> &'a [T];\n     /// Returns an iterator over the vector\n-    fn iter(self) -> VecIterator<'a, T>;\n+    fn iter(self) -> Items<'a, T>;\n     /// Returns a reversed iterator over a vector\n-    fn rev_iter(self) -> RevIterator<'a, T>;\n+    fn rev_iter(self) -> RevItems<'a, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`.  The matched element\n     /// is not contained in the subslices.\n-    fn split(self, pred: 'a |&T| -> bool) -> SplitIterator<'a, T>;\n+    fn split(self, pred: 'a |&T| -> bool) -> Splits<'a, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`, limited to splitting\n     /// at most `n` times.  The matched element is not contained in\n     /// the subslices.\n-    fn splitn(self, n: uint, pred: 'a |&T| -> bool) -> SplitIterator<'a, T>;\n+    fn splitn(self, n: uint, pred: 'a |&T| -> bool) -> Splits<'a, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`. This starts at the\n     /// end of the vector and works backwards.  The matched element is\n     /// not contained in the subslices.\n-    fn rsplit(self, pred: 'a |&T| -> bool) -> RSplitIterator<'a, T>;\n+    fn rsplit(self, pred: 'a |&T| -> bool) -> RevSplits<'a, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred` limited to splitting\n     /// at most `n` times. This starts at the end of the vector and\n     /// works backwards.  The matched element is not contained in the\n     /// subslices.\n-    fn rsplitn(self,  n: uint, pred: 'a |&T| -> bool) -> RSplitIterator<'a, T>;\n+    fn rsplitn(self,  n: uint, pred: 'a |&T| -> bool) -> RevSplits<'a, T>;\n \n     /**\n      * Returns an iterator over all contiguous windows of length\n@@ -912,7 +912,7 @@ pub trait ImmutableVector<'a, T> {\n      * ```\n      *\n      */\n-    fn windows(self, size: uint) -> WindowIter<'a, T>;\n+    fn windows(self, size: uint) -> Windows<'a, T>;\n     /**\n      *\n      * Returns an iterator over `size` elements of the vector at a\n@@ -937,7 +937,7 @@ pub trait ImmutableVector<'a, T> {\n      * ```\n      *\n      */\n-    fn chunks(self, size: uint) -> ChunkIter<'a, T>;\n+    fn chunks(self, size: uint) -> Chunks<'a, T>;\n \n     /// Returns the element of a vector at the given index, or `None` if the\n     /// index is out of bounds\n@@ -1055,34 +1055,34 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn iter(self) -> VecIterator<'a, T> {\n+    fn iter(self) -> Items<'a, T> {\n         unsafe {\n             let p = self.as_ptr();\n             if mem::size_of::<T>() == 0 {\n-                VecIterator{ptr: p,\n+                Items{ptr: p,\n                             end: (p as uint + self.len()) as *T,\n                             lifetime: None}\n             } else {\n-                VecIterator{ptr: p,\n+                Items{ptr: p,\n                             end: p.offset(self.len() as int),\n                             lifetime: None}\n             }\n         }\n     }\n \n     #[inline]\n-    fn rev_iter(self) -> RevIterator<'a, T> {\n+    fn rev_iter(self) -> RevItems<'a, T> {\n         self.iter().invert()\n     }\n \n     #[inline]\n-    fn split(self, pred: 'a |&T| -> bool) -> SplitIterator<'a, T> {\n+    fn split(self, pred: 'a |&T| -> bool) -> Splits<'a, T> {\n         self.splitn(uint::max_value, pred)\n     }\n \n     #[inline]\n-    fn splitn(self, n: uint, pred: 'a |&T| -> bool) -> SplitIterator<'a, T> {\n-        SplitIterator {\n+    fn splitn(self, n: uint, pred: 'a |&T| -> bool) -> Splits<'a, T> {\n+        Splits {\n             v: self,\n             n: n,\n             pred: pred,\n@@ -1091,13 +1091,13 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn rsplit(self, pred: 'a |&T| -> bool) -> RSplitIterator<'a, T> {\n+    fn rsplit(self, pred: 'a |&T| -> bool) -> RevSplits<'a, T> {\n         self.rsplitn(uint::max_value, pred)\n     }\n \n     #[inline]\n-    fn rsplitn(self, n: uint, pred: 'a |&T| -> bool) -> RSplitIterator<'a, T> {\n-        RSplitIterator {\n+    fn rsplitn(self, n: uint, pred: 'a |&T| -> bool) -> RevSplits<'a, T> {\n+        RevSplits {\n             v: self,\n             n: n,\n             pred: pred,\n@@ -1106,15 +1106,15 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn windows(self, size: uint) -> WindowIter<'a, T> {\n+    fn windows(self, size: uint) -> Windows<'a, T> {\n         assert!(size != 0);\n-        WindowIter { v: self, size: size }\n+        Windows { v: self, size: size }\n     }\n \n     #[inline]\n-    fn chunks(self, size: uint) -> ChunkIter<'a, T> {\n+    fn chunks(self, size: uint) -> Chunks<'a, T> {\n         assert!(size != 0);\n-        ChunkIter { v: self, size: size }\n+        Chunks { v: self, size: size }\n     }\n \n     #[inline]\n@@ -1331,10 +1331,10 @@ pub trait OwnedVector<T> {\n     ///   println!(\"{}\", s);\n     /// }\n     /// ```\n-    fn move_iter(self) -> MoveIterator<T>;\n+    fn move_iter(self) -> MoveItems<T>;\n     /// Creates a consuming iterator that moves out of the vector in\n     /// reverse order.\n-    fn move_rev_iter(self) -> MoveRevIterator<T>;\n+    fn move_rev_iter(self) -> RevMoveItems<T>;\n \n     /**\n      * Reserves capacity for exactly `n` elements in the given vector.\n@@ -1479,16 +1479,16 @@ pub trait OwnedVector<T> {\n \n impl<T> OwnedVector<T> for ~[T] {\n     #[inline]\n-    fn move_iter(self) -> MoveIterator<T> {\n+    fn move_iter(self) -> MoveItems<T> {\n         unsafe {\n             let iter = cast::transmute(self.iter());\n             let ptr = cast::transmute(self);\n-            MoveIterator { allocation: ptr, iter: iter }\n+            MoveItems { allocation: ptr, iter: iter }\n         }\n     }\n \n     #[inline]\n-    fn move_rev_iter(self) -> MoveRevIterator<T> {\n+    fn move_rev_iter(self) -> RevMoveItems<T> {\n         self.move_iter().invert()\n     }\n \n@@ -2065,18 +2065,18 @@ pub trait MutableVector<'a, T> {\n     fn mut_slice_to(self, end: uint) -> &'a mut [T];\n \n     /// Returns an iterator that allows modifying each value\n-    fn mut_iter(self) -> VecMutIterator<'a, T>;\n+    fn mut_iter(self) -> MutItems<'a, T>;\n \n     /// Returns a mutable pointer to the last item in the vector.\n     fn mut_last(self) -> &'a mut T;\n \n     /// Returns a reversed iterator that allows modifying each value\n-    fn mut_rev_iter(self) -> MutRevIterator<'a, T>;\n+    fn mut_rev_iter(self) -> RevMutItems<'a, T>;\n \n     /// Returns an iterator over the mutable subslices of the vector\n     /// which are separated by elements that match `pred`.  The\n     /// matched element is not contained in the subslices.\n-    fn mut_split(self, pred: 'a |&T| -> bool) -> MutSplitIterator<'a, T>;\n+    fn mut_split(self, pred: 'a |&T| -> bool) -> MutSplits<'a, T>;\n \n     /**\n      * Returns an iterator over `size` elements of the vector at a time.\n@@ -2088,7 +2088,7 @@ pub trait MutableVector<'a, T> {\n      *\n      * Fails if `size` is 0.\n      */\n-    fn mut_chunks(self, chunk_size: uint) -> MutChunkIter<'a, T>;\n+    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T>;\n \n     /**\n      * Returns a mutable reference to the first element in this slice\n@@ -2317,15 +2317,15 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n     }\n \n     #[inline]\n-    fn mut_iter(self) -> VecMutIterator<'a, T> {\n+    fn mut_iter(self) -> MutItems<'a, T> {\n         unsafe {\n             let p = self.as_mut_ptr();\n             if mem::size_of::<T>() == 0 {\n-                VecMutIterator{ptr: p,\n+                MutItems{ptr: p,\n                                end: (p as uint + self.len()) as *mut T,\n                                lifetime: None}\n             } else {\n-                VecMutIterator{ptr: p,\n+                MutItems{ptr: p,\n                                end: p.offset(self.len() as int),\n                                lifetime: None}\n             }\n@@ -2340,19 +2340,19 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n     }\n \n     #[inline]\n-    fn mut_rev_iter(self) -> MutRevIterator<'a, T> {\n+    fn mut_rev_iter(self) -> RevMutItems<'a, T> {\n         self.mut_iter().invert()\n     }\n \n     #[inline]\n-    fn mut_split(self, pred: 'a |&T| -> bool) -> MutSplitIterator<'a, T> {\n-        MutSplitIterator { v: self, pred: pred, finished: false }\n+    fn mut_split(self, pred: 'a |&T| -> bool) -> MutSplits<'a, T> {\n+        MutSplits { v: self, pred: pred, finished: false }\n     }\n \n     #[inline]\n-    fn mut_chunks(self, chunk_size: uint) -> MutChunkIter<'a, T> {\n+    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T> {\n         assert!(chunk_size > 0);\n-        MutChunkIter { v: self, chunk_size: chunk_size }\n+        MutChunks { v: self, chunk_size: chunk_size }\n     }\n \n     fn mut_shift_ref(&mut self) -> &'a mut T {\n@@ -2735,7 +2735,7 @@ macro_rules! iterator {\n     }\n }\n \n-impl<'a, T> RandomAccessIterator<&'a T> for VecIterator<'a, T> {\n+impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         let (exact, _) = self.size_hint();\n@@ -2754,28 +2754,28 @@ impl<'a, T> RandomAccessIterator<&'a T> for VecIterator<'a, T> {\n     }\n }\n \n-iterator!{struct VecIterator -> *T, &'a T}\n-pub type RevIterator<'a, T> = Invert<VecIterator<'a, T>>;\n+iterator!{struct Items -> *T, &'a T}\n+pub type RevItems<'a, T> = Invert<Items<'a, T>>;\n \n-impl<'a, T> ExactSize<&'a T> for VecIterator<'a, T> {}\n-impl<'a, T> ExactSize<&'a mut T> for VecMutIterator<'a, T> {}\n+impl<'a, T> ExactSize<&'a T> for Items<'a, T> {}\n+impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}\n \n-impl<'a, T> Clone for VecIterator<'a, T> {\n-    fn clone(&self) -> VecIterator<'a, T> { *self }\n+impl<'a, T> Clone for Items<'a, T> {\n+    fn clone(&self) -> Items<'a, T> { *self }\n }\n \n-iterator!{struct VecMutIterator -> *mut T, &'a mut T}\n-pub type MutRevIterator<'a, T> = Invert<VecMutIterator<'a, T>>;\n+iterator!{struct MutItems -> *mut T, &'a mut T}\n+pub type RevMutItems<'a, T> = Invert<MutItems<'a, T>>;\n \n /// An iterator over the subslices of the vector which are separated\n /// by elements that match `pred`.\n-pub struct MutSplitIterator<'a, T> {\n+pub struct MutSplits<'a, T> {\n     priv v: &'a mut [T],\n     priv pred: 'a |t: &T| -> bool,\n     priv finished: bool\n }\n \n-impl<'a, T> Iterator<&'a mut [T]> for MutSplitIterator<'a, T> {\n+impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n         if self.finished { return None; }\n@@ -2810,7 +2810,7 @@ impl<'a, T> Iterator<&'a mut [T]> for MutSplitIterator<'a, T> {\n     }\n }\n \n-impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplitIterator<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n         if self.finished { return None; }\n@@ -2834,12 +2834,12 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplitIterator<'a, T> {\n /// An iterator over a vector in (non-overlapping) mutable chunks (`size`  elements at a time). When\n /// the vector len is not evenly divided by the chunk size, the last slice of the iteration will be\n /// the remainder.\n-pub struct MutChunkIter<'a, T> {\n+pub struct MutChunks<'a, T> {\n     priv v: &'a mut [T],\n     priv chunk_size: uint\n }\n \n-impl<'a, T> Iterator<&'a mut [T]> for MutChunkIter<'a, T> {\n+impl<'a, T> Iterator<&'a mut [T]> for MutChunks<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n         if self.v.len() == 0 {\n@@ -2865,7 +2865,7 @@ impl<'a, T> Iterator<&'a mut [T]> for MutChunkIter<'a, T> {\n     }\n }\n \n-impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunkIter<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n         if self.v.len() == 0 {\n@@ -2883,12 +2883,12 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunkIter<'a, T> {\n }\n \n /// An iterator that moves out of a vector.\n-pub struct MoveIterator<T> {\n+pub struct MoveItems<T> {\n     priv allocation: *mut u8, // the block of memory allocated for the vector\n-    priv iter: VecIterator<'static, T>\n+    priv iter: Items<'static, T>\n }\n \n-impl<T> Iterator<T> for MoveIterator<T> {\n+impl<T> Iterator<T> for MoveItems<T> {\n     #[inline]\n     fn next(&mut self) -> Option<T> {\n         unsafe {\n@@ -2902,7 +2902,7 @@ impl<T> Iterator<T> for MoveIterator<T> {\n     }\n }\n \n-impl<T> DoubleEndedIterator<T> for MoveIterator<T> {\n+impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         unsafe {\n@@ -2912,7 +2912,7 @@ impl<T> DoubleEndedIterator<T> for MoveIterator<T> {\n }\n \n #[unsafe_destructor]\n-impl<T> Drop for MoveIterator<T> {\n+impl<T> Drop for MoveItems<T> {\n     fn drop(&mut self) {\n         // destroy the remaining elements\n         for _x in *self {}\n@@ -2923,7 +2923,7 @@ impl<T> Drop for MoveIterator<T> {\n }\n \n /// An iterator that moves out of a vector in reverse order.\n-pub type MoveRevIterator<T> = Invert<MoveIterator<T>>;\n+pub type RevMoveItems<T> = Invert<MoveItems<T>>;\n \n impl<A> FromIterator<A> for ~[A] {\n     fn from_iterator<T: Iterator<A>>(iterator: &mut T) -> ~[A] {"}, {"sha": "3cca81180168b555eafae1a01eb64d1eaf90d54a", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -15,7 +15,7 @@\n  * other useful things like `push()` and `len()`.\n  */\n \n-use std::vec::{VecIterator};\n+use std::vec;\n \n #[deriving(Clone, Encodable, Decodable, IterBytes)]\n pub enum OptVec<T> {\n@@ -112,10 +112,10 @@ impl<T> OptVec<T> {\n     }\n \n     #[inline]\n-    pub fn iter<'r>(&'r self) -> OptVecIterator<'r, T> {\n+    pub fn iter<'r>(&'r self) -> Items<'r, T> {\n         match *self {\n-            Empty => OptVecIterator{iter: None},\n-            Vec(ref v) => OptVecIterator{iter: Some(v.iter())}\n+            Empty => Items{iter: None},\n+            Vec(ref v) => Items{iter: Some(v.iter())}\n         }\n     }\n \n@@ -173,11 +173,11 @@ impl<T> Default for OptVec<T> {\n     fn default() -> OptVec<T> { Empty }\n }\n \n-pub struct OptVecIterator<'a, T> {\n-    priv iter: Option<VecIterator<'a, T>>\n+pub struct Items<'a, T> {\n+    priv iter: Option<vec::Items<'a, T>>\n }\n \n-impl<'a, T> Iterator<&'a T> for OptVecIterator<'a, T> {\n+impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> {\n         match self.iter {\n@@ -195,7 +195,7 @@ impl<'a, T> Iterator<&'a T> for OptVecIterator<'a, T> {\n     }\n }\n \n-impl<'a, T> DoubleEndedIterator<&'a T> for OptVecIterator<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> {\n         match self.iter {"}, {"sha": "6803bb1eaf940b4f526e6d6f1fe6030204eef5d5", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd8c8b3306ae33bdc85811aa410ba01967922bc/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=3fd8c8b3306ae33bdc85811aa410ba01967922bc", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-use std::vec::MoveIterator;\n+use std::vec;\n use std::util;\n \n /// A vector type optimized for cases where the size is almost always 0 or 1\n@@ -80,7 +80,7 @@ impl<T> SmallVector<T> {\n         }\n     }\n \n-    pub fn move_iter(self) -> SmallVectorMoveIterator<T> {\n+    pub fn move_iter(self) -> MoveItems<T> {\n         match self {\n             Zero => ZeroIterator,\n             One(v) => OneIterator(v),\n@@ -89,13 +89,13 @@ impl<T> SmallVector<T> {\n     }\n }\n \n-pub enum SmallVectorMoveIterator<T> {\n+pub enum MoveItems<T> {\n     priv ZeroIterator,\n     priv OneIterator(T),\n-    priv ManyIterator(MoveIterator<T>),\n+    priv ManyIterator(vec::MoveItems<T>),\n }\n \n-impl<T> Iterator<T> for SmallVectorMoveIterator<T> {\n+impl<T> Iterator<T> for MoveItems<T> {\n     fn next(&mut self) -> Option<T> {\n         match *self {\n             ZeroIterator => None,"}]}