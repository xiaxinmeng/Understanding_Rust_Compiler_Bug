{"sha": "d56e8920852adec249c9d8159348a94dcafbd31c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1NmU4OTIwODUyYWRlYzI0OWM5ZDgxNTkzNDhhOTRkY2FmYmQzMWM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-09-08T19:14:55Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-22T02:12:59Z"}, "message": "rustc_target: rename abi::Align to AbiAndPrefAlign.", "tree": {"sha": "d3779af2daa531693ef0aee3eb5ef82ad4c70524", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3779af2daa531693ef0aee3eb5ef82ad4c70524"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d56e8920852adec249c9d8159348a94dcafbd31c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d56e8920852adec249c9d8159348a94dcafbd31c", "html_url": "https://github.com/rust-lang/rust/commit/d56e8920852adec249c9d8159348a94dcafbd31c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d56e8920852adec249c9d8159348a94dcafbd31c/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "780658a464603fa755d94b27f72a375bd81d07ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/780658a464603fa755d94b27f72a375bd81d07ea", "html_url": "https://github.com/rust-lang/rust/commit/780658a464603fa755d94b27f72a375bd81d07ea"}], "stats": {"total": 438, "additions": 220, "deletions": 218}, "files": [{"sha": "eb44c3c8c5f7b99deea2f19fced077a61d91f2b0", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -12,7 +12,7 @@\n \n use super::{Pointer, EvalResult, AllocId};\n \n-use ty::layout::{Size, Align};\n+use ty::layout::{Size, AbiAndPrefAlign};\n use syntax::ast::Mutability;\n use std::iter;\n use mir;\n@@ -40,7 +40,7 @@ pub struct Allocation<Tag=(),Extra=()> {\n     /// Denotes undefined memory. Reading from undefined memory is forbidden in miri\n     pub undef_mask: UndefMask,\n     /// The alignment of the allocation to detect unaligned reads.\n-    pub align: Align,\n+    pub align: AbiAndPrefAlign,\n     /// Whether the allocation is mutable.\n     /// Also used by codegen to determine if a static should be put into mutable memory,\n     /// which happens for `static mut` and `static` with interior mutability.\n@@ -90,7 +90,7 @@ impl AllocationExtra<()> for () {}\n \n impl<Tag, Extra: Default> Allocation<Tag, Extra> {\n     /// Creates a read-only allocation initialized by the given bytes\n-    pub fn from_bytes(slice: &[u8], align: Align) -> Self {\n+    pub fn from_bytes(slice: &[u8], align: AbiAndPrefAlign) -> Self {\n         let mut undef_mask = UndefMask::new(Size::ZERO);\n         undef_mask.grow(Size::from_bytes(slice.len() as u64), true);\n         Self {\n@@ -104,10 +104,10 @@ impl<Tag, Extra: Default> Allocation<Tag, Extra> {\n     }\n \n     pub fn from_byte_aligned_bytes(slice: &[u8]) -> Self {\n-        Allocation::from_bytes(slice, Align::from_bytes(1, 1).unwrap())\n+        Allocation::from_bytes(slice, AbiAndPrefAlign::from_bytes(1, 1).unwrap())\n     }\n \n-    pub fn undef(size: Size, align: Align) -> Self {\n+    pub fn undef(size: Size, align: AbiAndPrefAlign) -> Self {\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n         Allocation {\n             bytes: vec![0; size.bytes() as usize],"}, {"sha": "bae53a9216a4d3b538b1299ef1424fe753171b9c", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -13,7 +13,7 @@ use std::{fmt, env};\n use hir::map::definitions::DefPathData;\n use mir;\n use ty::{self, Ty, layout};\n-use ty::layout::{Size, Align, LayoutError};\n+use ty::layout::{Size, AbiAndPrefAlign, LayoutError};\n use rustc_target::spec::abi::Abi;\n \n use super::{RawConst, Pointer, InboundsCheck, ScalarMaybeUndef};\n@@ -301,8 +301,8 @@ pub enum EvalErrorKind<'tcx, O> {\n     TlsOutOfBounds,\n     AbiViolation(String),\n     AlignmentCheckFailed {\n-        required: Align,\n-        has: Align,\n+        required: AbiAndPrefAlign,\n+        has: AbiAndPrefAlign,\n     },\n     ValidationFailure(String),\n     CalledClosureAsFunction,\n@@ -315,7 +315,7 @@ pub enum EvalErrorKind<'tcx, O> {\n     DeallocatedWrongMemoryKind(String, String),\n     ReallocateNonBasePtr,\n     DeallocateNonBasePtr,\n-    IncorrectAllocationInformation(Size, Size, Align, Align),\n+    IncorrectAllocationInformation(Size, Size, AbiAndPrefAlign, AbiAndPrefAlign),\n     Layout(layout::LayoutError<'tcx>),\n     HeapAllocZeroBytes,\n     HeapAllocNonPowerOfTwoAlignment(u64),"}, {"sha": "34a89ccf7a2103f467b7ba8d57b38dc62081b87d", "filename": "src/librustc/session/code_stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc%2Fsession%2Fcode_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc%2Fsession%2Fcode_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fcode_stats.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_target::abi::{Align, Size};\n+use rustc_target::abi::{AbiAndPrefAlign, Size};\n use rustc_data_structures::fx::{FxHashSet};\n use std::cmp::{self, Ordering};\n \n@@ -63,7 +63,7 @@ impl CodeStats {\n     pub fn record_type_size<S: ToString>(&mut self,\n                                          kind: DataTypeKind,\n                                          type_desc: S,\n-                                         align: Align,\n+                                         align: AbiAndPrefAlign,\n                                          overall_size: Size,\n                                          packed: bool,\n                                          opt_discr_size: Option<Size>,"}, {"sha": "76c3c467febbd21b7994a2ec8f58442e907c04f2", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -248,7 +248,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             /// A univariant, the last field of which may be coerced to unsized.\n             MaybeUnsized,\n             /// A univariant, but with a prefix of an arbitrary size & alignment (e.g. enum tag).\n-            Prefixed(Size, Align),\n+            Prefixed(Size, AbiAndPrefAlign),\n         }\n \n         let univariant_uninterned = |fields: &[TyLayout<'_>], repr: &ReprOptions, kind| {\n@@ -259,7 +259,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n             let pack = {\n                 let pack = repr.pack as u64;\n-                Align::from_bytes(pack, pack).unwrap()\n+                AbiAndPrefAlign::from_bytes(pack, pack).unwrap()\n             };\n \n             let mut align = if packed {\n@@ -352,7 +352,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n             if repr.align > 0 {\n                 let repr_align = repr.align as u64;\n-                align = align.max(Align::from_bytes(repr_align, repr_align).unwrap());\n+                align = align.max(AbiAndPrefAlign::from_bytes(repr_align, repr_align).unwrap());\n                 debug!(\"univariant repr_align: {:?}\", repr_align);\n             }\n \n@@ -682,7 +682,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n                     let pack = {\n                         let pack = def.repr.pack as u64;\n-                        Align::from_bytes(pack, pack).unwrap()\n+                        AbiAndPrefAlign::from_bytes(pack, pack).unwrap()\n                     };\n \n                     let mut align = if packed {\n@@ -694,7 +694,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     if def.repr.align > 0 {\n                         let repr_align = def.repr.align as u64;\n                         align = align.max(\n-                            Align::from_bytes(repr_align, repr_align).unwrap());\n+                            AbiAndPrefAlign::from_bytes(repr_align, repr_align).unwrap());\n                     }\n \n                     let optimize = !def.repr.inhibit_union_abi_opt();\n@@ -964,7 +964,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 let mut size = Size::ZERO;\n \n                 // We're interested in the smallest alignment, so start large.\n-                let mut start_align = Align::from_bytes(256, 256).unwrap();\n+                let mut start_align = AbiAndPrefAlign::from_bytes(256, 256).unwrap();\n                 assert_eq!(Integer::for_abi_align(dl, start_align), None);\n \n                 // repr(C) on an enum tells us to make a (tag, union) layout,\n@@ -1994,7 +1994,7 @@ impl_stable_hash_for!(enum ::ty::layout::Primitive {\n     Pointer\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for Align {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for AbiAndPrefAlign {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {"}, {"sha": "38400946a914f332db7bd869696103232aee0c9e", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -19,7 +19,7 @@ use type_of::LayoutLlvmExt;\n use value::Value;\n use libc::{c_uint, c_char};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{self, Align, Size, TyLayout};\n+use rustc::ty::layout::{self, AbiAndPrefAlign, Size, TyLayout};\n use rustc::session::config;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_codegen_ssa::traits::*;\n@@ -457,15 +457,15 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn alloca(&mut self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n+    fn alloca(&mut self, ty: &'ll Type, name: &str, align: AbiAndPrefAlign) -> &'ll Value {\n         let mut bx = Builder::with_cx(self.cx);\n         bx.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });\n         bx.dynamic_alloca(ty, name, align)\n     }\n \n-    fn dynamic_alloca(&mut self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n+    fn dynamic_alloca(&mut self, ty: &'ll Type, name: &str, align: AbiAndPrefAlign) -> &'ll Value {\n         self.count_insn(\"alloca\");\n         unsafe {\n             let alloca = if name.is_empty() {\n@@ -484,7 +484,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                         ty: &'ll Type,\n                         len: &'ll Value,\n                         name: &str,\n-                        align: Align) -> &'ll Value {\n+                        align: AbiAndPrefAlign) -> &'ll Value {\n         self.count_insn(\"alloca\");\n         unsafe {\n             let alloca = if name.is_empty() {\n@@ -499,7 +499,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn load(&mut self, ptr: &'ll Value, align: Align) -> &'ll Value {\n+    fn load(&mut self, ptr: &'ll Value, align: AbiAndPrefAlign) -> &'ll Value {\n         self.count_insn(\"load\");\n         unsafe {\n             let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n@@ -639,15 +639,15 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn store(&mut self, val: &'ll Value, ptr: &'ll Value, align: Align) -> &'ll Value {\n+    fn store(&mut self, val: &'ll Value, ptr: &'ll Value, align: AbiAndPrefAlign) -> &'ll Value {\n         self.store_with_flags(val, ptr, align, MemFlags::empty())\n     }\n \n     fn store_with_flags(\n         &mut self,\n         val: &'ll Value,\n         ptr: &'ll Value,\n-        align: Align,\n+        align: AbiAndPrefAlign,\n         flags: MemFlags,\n     ) -> &'ll Value {\n         debug!(\"Store {:?} -> {:?} ({:?})\", val, ptr, flags);\n@@ -878,8 +878,8 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn memcpy(&mut self, dst: &'ll Value, dst_align: Align,\n-                  src: &'ll Value, src_align: Align,\n+    fn memcpy(&mut self, dst: &'ll Value, dst_align: AbiAndPrefAlign,\n+                  src: &'ll Value, src_align: AbiAndPrefAlign,\n                   size: &'ll Value, flags: MemFlags) {\n         if flags.contains(MemFlags::NONTEMPORAL) {\n             // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n@@ -898,8 +898,8 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn memmove(&mut self, dst: &'ll Value, dst_align: Align,\n-                  src: &'ll Value, src_align: Align,\n+    fn memmove(&mut self, dst: &'ll Value, dst_align: AbiAndPrefAlign,\n+                  src: &'ll Value, src_align: AbiAndPrefAlign,\n                   size: &'ll Value, flags: MemFlags) {\n         if flags.contains(MemFlags::NONTEMPORAL) {\n             // HACK(nox): This is inefficient but there is no nontemporal memmove.\n@@ -923,7 +923,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         ptr: &'ll Value,\n         fill_byte: &'ll Value,\n         size: &'ll Value,\n-        align: Align,\n+        align: AbiAndPrefAlign,\n         flags: MemFlags,\n     ) {\n         let ptr_width = &self.cx().sess().target.target.target_pointer_width;"}, {"sha": "158bc6eb9c10679b2238e4455eeddb53aad2dfcd", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -28,7 +28,7 @@ use value::Value;\n use rustc::ty::{self, Ty};\n use rustc_codegen_ssa::traits::*;\n \n-use rustc::ty::layout::{self, Size, Align, LayoutOf};\n+use rustc::ty::layout::{self, Size, AbiAndPrefAlign, LayoutOf};\n \n use rustc::hir::{self, CodegenFnAttrs, CodegenFnAttrFlags};\n \n@@ -89,12 +89,12 @@ pub fn codegen_static_initializer(\n \n fn set_global_alignment(cx: &CodegenCx<'ll, '_>,\n                         gv: &'ll Value,\n-                        mut align: Align) {\n+                        mut align: AbiAndPrefAlign) {\n     // The target may require greater alignment for globals than the type does.\n     // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,\n     // which can force it to be smaller.  Rust doesn't support this yet.\n     if let Some(min) = cx.sess().target.target.options.min_global_align {\n-        match ty::layout::Align::from_bits(min, min) {\n+        match ty::layout::AbiAndPrefAlign::from_bits(min, min) {\n             Ok(min) => align = align.max(min),\n             Err(err) => {\n                 cx.sess().err(&format!(\"invalid minimum global alignment: {}\", err));\n@@ -186,7 +186,7 @@ impl StaticMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn static_addr_of_mut(\n         &self,\n         cv: &'ll Value,\n-        align: Align,\n+        align: AbiAndPrefAlign,\n         kind: Option<&str>,\n     ) -> &'ll Value {\n         unsafe {\n@@ -212,7 +212,7 @@ impl StaticMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn static_addr_of(\n         &self,\n         cv: &'ll Value,\n-        align: Align,\n+        align: AbiAndPrefAlign,\n         kind: Option<&str>,\n     ) -> &'ll Value {\n         if let Some(&gv) = self.const_globals.borrow().get(&cv) {"}, {"sha": "42b48b728fd05ee1260c3d5e058279509c760c2b", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -35,7 +35,7 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use rustc::ty::Instance;\n use common::CodegenCx;\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n-use rustc::ty::layout::{self, Align, HasDataLayout, Integer, IntegerExt, LayoutOf,\n+use rustc::ty::layout::{self, AbiAndPrefAlign, HasDataLayout, Integer, IntegerExt, LayoutOf,\n                         PrimitiveExt, Size, TyLayout};\n use rustc::session::config;\n use rustc::util::nodemap::FxHashMap;\n@@ -923,7 +923,7 @@ struct MemberDescription<'ll> {\n     type_metadata: &'ll DIType,\n     offset: Size,\n     size: Size,\n-    align: Align,\n+    align: AbiAndPrefAlign,\n     flags: DIFlags,\n     discriminant: Option<u64>,\n }\n@@ -985,13 +985,12 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n                 f.ident.to_string()\n             };\n             let field = layout.field(cx, i);\n-            let (size, align) = field.size_and_align();\n             MemberDescription {\n                 name,\n                 type_metadata: type_metadata(cx, field.ty, self.span),\n                 offset: layout.fields.offset(i),\n-                size,\n-                align,\n+                size: field.size,\n+                align: field.align,\n                 flags: DIFlags::FlagZero,\n                 discriminant: None,\n             }\n@@ -1109,13 +1108,12 @@ impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n                                   -> Vec<MemberDescription<'ll>> {\n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n             let field = self.layout.field(cx, i);\n-            let (size, align) = field.size_and_align();\n             MemberDescription {\n                 name: f.ident.to_string(),\n                 type_metadata: type_metadata(cx, field.ty, self.span),\n                 offset: Size::ZERO,\n-                size,\n-                align,\n+                size: field.size,\n+                align: field.align,\n                 flags: DIFlags::FlagZero,\n                 discriminant: None,\n             }\n@@ -1587,8 +1585,6 @@ fn prepare_enum_metadata(\n         _ => {}\n     }\n \n-    let (enum_type_size, enum_type_align) = layout.size_and_align();\n-\n     let enum_name = SmallCStr::new(&enum_name);\n     let unique_type_id_str = SmallCStr::new(\n         debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id)\n@@ -1610,8 +1606,8 @@ fn prepare_enum_metadata(\n                 enum_name.as_ptr(),\n                 file_metadata,\n                 UNKNOWN_LINE_NUMBER,\n-                enum_type_size.bits(),\n-                enum_type_align.abi_bits() as u32,\n+                layout.size.bits(),\n+                layout.align.abi_bits() as u32,\n                 DIFlags::FlagZero,\n                 None,\n                 0, // RuntimeLang\n@@ -1695,8 +1691,8 @@ fn prepare_enum_metadata(\n             ptr::null_mut(),\n             file_metadata,\n             UNKNOWN_LINE_NUMBER,\n-            enum_type_size.bits(),\n-            enum_type_align.abi_bits() as u32,\n+            layout.size.bits(),\n+            layout.align.abi_bits() as u32,\n             DIFlags::FlagZero,\n             discriminator_metadata,\n             empty_array,\n@@ -1712,8 +1708,8 @@ fn prepare_enum_metadata(\n             enum_name.as_ptr(),\n             file_metadata,\n             UNKNOWN_LINE_NUMBER,\n-            enum_type_size.bits(),\n-            enum_type_align.abi_bits() as u32,\n+            layout.size.bits(),\n+            layout.align.abi_bits() as u32,\n             DIFlags::FlagZero,\n             None,\n             type_array,"}, {"sha": "a07fa94489195f0753ff68f8ab933b6f007517ac", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -12,7 +12,7 @@ use abi::{FnType, FnTypeExt};\n use common::*;\n use rustc::hir;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n+use rustc::ty::layout::{self, AbiAndPrefAlign, LayoutOf, Size, TyLayout};\n use rustc_target::abi::FloatTy;\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n use type_::Type;\n@@ -80,7 +80,7 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n     match layout.fields {\n         layout::FieldPlacement::Union(_) => {\n-            let fill = cx.type_padding_filler( layout.size, layout.align);\n+            let fill = cx.type_padding_filler(layout.size, layout.align);\n             let packed = false;\n             match name {\n                 None => {\n@@ -165,16 +165,17 @@ fn struct_llfields<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n-    pub fn align_of(&self, ty: Ty<'tcx>) -> Align {\n+    pub fn align_of(&self, ty: Ty<'tcx>) -> AbiAndPrefAlign {\n         self.layout_of(ty).align\n     }\n \n     pub fn size_of(&self, ty: Ty<'tcx>) -> Size {\n         self.layout_of(ty).size\n     }\n \n-    pub fn size_and_align_of(&self, ty: Ty<'tcx>) -> (Size, Align) {\n-        self.layout_of(ty).size_and_align()\n+    pub fn size_and_align_of(&self, ty: Ty<'tcx>) -> (Size, AbiAndPrefAlign) {\n+        let layout = self.layout_of(ty);\n+        (layout.size, layout.align)\n     }\n }\n \n@@ -196,7 +197,7 @@ pub enum PointerKind {\n #[derive(Copy, Clone)]\n pub struct PointeeInfo {\n     pub size: Size,\n-    pub align: Align,\n+    pub align: AbiAndPrefAlign,\n     pub safe: Option<PointerKind>,\n }\n "}, {"sha": "e80ff8b658019ea9152ed93861883b757ae25139", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -31,7 +31,7 @@ use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::weak_lang_items;\n use rustc::mir::mono::{Stats, CodegenUnitNameBuilder};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n+use rustc::ty::layout::{self, AbiAndPrefAlign, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n use rustc::ty::query::Providers;\n use rustc::middle::cstore::{self, LinkagePreference};\n use rustc::util::common::{time, print_time_passes_entry};\n@@ -410,9 +410,9 @@ pub fn to_immediate_scalar<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n pub fn memcpy_ty<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     dst: Bx::Value,\n-    dst_align: Align,\n+    dst_align: AbiAndPrefAlign,\n     src: Bx::Value,\n-    src_align: Align,\n+    src_align: AbiAndPrefAlign,\n     layout: TyLayout<'tcx>,\n     flags: MemFlags,\n ) {"}, {"sha": "bf4c53f228e39260a995d212b0b612ad7f3192c5", "filename": "src/librustc_codegen_ssa/glue.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_ssa%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_ssa%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fglue.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -25,14 +25,12 @@ pub fn size_and_align_of_dst<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     t: Ty<'tcx>,\n     info: Option<Bx::Value>\n ) -> (Bx::Value, Bx::Value) {\n-    debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n-           t, info);\n-    if bx.cx().type_is_sized(t) {\n-        let (size, align) = bx.cx().layout_of(t).size_and_align();\n-        debug!(\"size_and_align_of_dst t={} info={:?} size: {:?} align: {:?}\",\n-               t, info, size, align);\n-        let size = bx.cx().const_usize(size.bytes());\n-        let align = bx.cx().const_usize(align.abi());\n+    let layout = bx.cx().layout_of(t);\n+    debug!(\"size_and_align_of_dst(ty={}, info={:?}): layout: {:?}\",\n+           t, info, layout);\n+    if !layout.is_unsized() {\n+        let size = bx.cx().const_usize(layout.size.bytes());\n+        let align = bx.cx().const_usize(layout.align.abi());\n         return (size, align);\n     }\n     match t.sty {\n@@ -42,19 +40,17 @@ pub fn size_and_align_of_dst<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             (meth::SIZE.get_usize(bx, vtable), meth::ALIGN.get_usize(bx, vtable))\n         }\n         ty::Slice(_) | ty::Str => {\n-            let unit = t.sequence_element_type(bx.tcx());\n+            let unit = layout.field(bx.cx(), 0);\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n-            let (size, align) = bx.cx().layout_of(unit).size_and_align();\n-            (bx.mul(info.unwrap(), bx.cx().const_usize(size.bytes())),\n-             bx.cx().const_usize(align.abi()))\n+            (bx.mul(info.unwrap(), bx.cx().const_usize(unit.size.bytes())),\n+             bx.cx().const_usize(unit.align.abi()))\n         }\n         _ => {\n             // First get the size of all statically known fields.\n             // Don't use size_of because it also rounds up to alignment, which we\n             // want to avoid, as the unsized field's alignment could be smaller.\n             assert!(!t.is_simd());\n-            let layout = bx.cx().layout_of(t);\n             debug!(\"DST {} layout: {:?}\", t, layout);\n \n             let i = layout.fields.count() - 1;"}, {"sha": "d0b8c166b121d40f3fd8d2bd6ef96a071c2984ea", "filename": "src/librustc_codegen_ssa/meth.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmeth.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -100,15 +100,15 @@ pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n         })\n     });\n \n-    let (size, align) = cx.layout_of(ty).size_and_align();\n+    let layout = cx.layout_of(ty);\n     // /////////////////////////////////////////////////////////////////////////////////////////////\n     // If you touch this code, be sure to also make the corresponding changes to\n     // `get_vtable` in rust_mir/interpret/traits.rs\n     // /////////////////////////////////////////////////////////////////////////////////////////////\n     let components: Vec<_> = [\n         cx.get_fn(monomorphize::resolve_drop_in_place(cx.tcx(), ty)),\n-        cx.const_usize(size.bytes()),\n-        cx.const_usize(align.abi())\n+        cx.const_usize(layout.size.bytes()),\n+        cx.const_usize(layout.align.abi())\n     ].iter().cloned().chain(methods).collect();\n \n     let vtable_const = cx.const_struct(&components, false);"}, {"sha": "4c92ab7eda5be9f98b8ba6e94de733a666daa927", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -11,7 +11,7 @@\n use rustc::mir::interpret::{ConstValue, ErrorHandled};\n use rustc::mir;\n use rustc::ty;\n-use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n+use rustc::ty::layout::{self, AbiAndPrefAlign, LayoutOf, TyLayout};\n \n use base;\n use MemFlags;\n@@ -33,7 +33,7 @@ pub enum OperandValue<V> {\n     /// to be valid for the operand's lifetime.\n     /// The second value, if any, is the extra data (vtable or length)\n     /// which indicates that it refers to an unsized rvalue.\n-    Ref(V, Option<V>, Align),\n+    Ref(V, Option<V>, AbiAndPrefAlign),\n     /// A single LLVM value.\n     Immediate(V),\n     /// A pair of immediate LLVM values. Used by fat pointers too.\n@@ -348,8 +348,8 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandValue<V> {\n             };\n \n         // FIXME: choose an appropriate alignment, or use dynamic align somehow\n-        let max_align = Align::from_bits(128, 128).unwrap();\n-        let min_align = Align::from_bits(8, 8).unwrap();\n+        let max_align = AbiAndPrefAlign::from_bits(128, 128).unwrap();\n+        let min_align = AbiAndPrefAlign::from_bits(8, 8).unwrap();\n \n         // Allocate an appropriate region on the stack, and copy the value into it\n         let (llsize, _) = glue::size_and_align_of_dst(bx, unsized_ty, Some(llextra));"}, {"sha": "e6216c8724f50cdd3f6efe4fd961d7e666f1091d", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n+use rustc::ty::layout::{self, AbiAndPrefAlign, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n use rustc::mir;\n use rustc::mir::tcx::PlaceTy;\n use MemFlags;\n@@ -33,14 +33,14 @@ pub struct PlaceRef<'tcx, V> {\n     pub layout: TyLayout<'tcx>,\n \n     /// What alignment we know for this place\n-    pub align: Align,\n+    pub align: AbiAndPrefAlign,\n }\n \n impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n     pub fn new_sized(\n         llval: V,\n         layout: TyLayout<'tcx>,\n-        align: Align,\n+        align: AbiAndPrefAlign,\n     ) -> PlaceRef<'tcx, V> {\n         assert!(!layout.is_unsized());\n         PlaceRef {\n@@ -308,9 +308,8 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n                         // Issue #34427: As workaround for LLVM bug on ARM,\n                         // use memset of 0 before assigning niche value.\n                         let fill_byte = bx.cx().const_u8(0);\n-                        let (size, align) = self.layout.size_and_align();\n-                        let size = bx.cx().const_usize(size.bytes());\n-                        bx.memset(self.llval, fill_byte, size, align, MemFlags::empty());\n+                        let size = bx.cx().const_usize(self.layout.size.bytes());\n+                        bx.memset(self.llval, fill_byte, size, self.align, MemFlags::empty());\n                     }\n \n                     let niche = self.project_field(bx, 0);"}, {"sha": "167a143ec31eb5588eb935f9da480e9f7b0621e3", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -496,10 +496,10 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::NullaryOp(mir::NullOp::Box, content_ty) => {\n-                let content_ty: Ty<'tcx> = self.monomorphize(&content_ty);\n-                let (size, align) = bx.cx().layout_of(content_ty).size_and_align();\n-                let llsize = bx.cx().const_usize(size.bytes());\n-                let llalign = bx.cx().const_usize(align.abi());\n+                let content_ty = self.monomorphize(&content_ty);\n+                let content_layout = bx.cx().layout_of(content_ty);\n+                let llsize = bx.cx().const_usize(content_layout.size.bytes());\n+                let llalign = bx.cx().const_usize(content_layout.align.abi());\n                 let box_layout = bx.cx().layout_of(bx.tcx().mk_box(content_ty));\n                 let llty_ptr = bx.cx().backend_type(box_layout);\n "}, {"sha": "02be098599b3d04e227bc6a36c05eb7ba3649141", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -15,10 +15,10 @@ use super::intrinsic::IntrinsicCallMethods;\n use super::type_::ArgTypeMethods;\n use super::HasCodegen;\n use common::{AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate, SynchronizationScope};\n-use std::ffi::CStr;\n use mir::operand::OperandRef;\n use mir::place::PlaceRef;\n-use rustc::ty::layout::{Align, Size};\n+use rustc::ty::layout::{AbiAndPrefAlign, Size};\n+use std::ffi::CStr;\n use MemFlags;\n \n use std::borrow::Cow;\n@@ -97,17 +97,18 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n     fn fneg(&mut self, v: Self::Value) -> Self::Value;\n     fn not(&mut self, v: Self::Value) -> Self::Value;\n \n-    fn alloca(&mut self, ty: Self::Type, name: &str, align: Align) -> Self::Value;\n-    fn dynamic_alloca(&mut self, ty: Self::Type, name: &str, align: Align) -> Self::Value;\n+    fn alloca(&mut self, ty: Self::Type, name: &str, align: AbiAndPrefAlign) -> Self::Value;\n+    fn dynamic_alloca(&mut self, ty: Self::Type, name: &str, align: AbiAndPrefAlign)\n+        -> Self::Value;\n     fn array_alloca(\n         &mut self,\n         ty: Self::Type,\n         len: Self::Value,\n         name: &str,\n-        align: Align,\n+        align: AbiAndPrefAlign,\n     ) -> Self::Value;\n \n-    fn load(&mut self, ptr: Self::Value, align: Align) -> Self::Value;\n+    fn load(&mut self, ptr: Self::Value, align: AbiAndPrefAlign) -> Self::Value;\n     fn volatile_load(&mut self, ptr: Self::Value) -> Self::Value;\n     fn atomic_load(&mut self, ptr: Self::Value, order: AtomicOrdering, size: Size) -> Self::Value;\n     fn load_operand(&mut self, place: PlaceRef<'tcx, Self::Value>)\n@@ -116,12 +117,12 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n     fn range_metadata(&mut self, load: Self::Value, range: Range<u128>);\n     fn nonnull_metadata(&mut self, load: Self::Value);\n \n-    fn store(&mut self, val: Self::Value, ptr: Self::Value, align: Align) -> Self::Value;\n+    fn store(&mut self, val: Self::Value, ptr: Self::Value, align: AbiAndPrefAlign) -> Self::Value;\n     fn store_with_flags(\n         &mut self,\n         val: Self::Value,\n         ptr: Self::Value,\n-        align: Align,\n+        align: AbiAndPrefAlign,\n         flags: MemFlags,\n     ) -> Self::Value;\n     fn atomic_store(\n@@ -174,18 +175,18 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n     fn memcpy(\n         &mut self,\n         dst: Self::Value,\n-        dst_align: Align,\n+        dst_align: AbiAndPrefAlign,\n         src: Self::Value,\n-        src_align: Align,\n+        src_align: AbiAndPrefAlign,\n         size: Self::Value,\n         flags: MemFlags,\n     );\n     fn memmove(\n         &mut self,\n         dst: Self::Value,\n-        dst_align: Align,\n+        dst_align: AbiAndPrefAlign,\n         src: Self::Value,\n-        src_align: Align,\n+        src_align: AbiAndPrefAlign,\n         size: Self::Value,\n         flags: MemFlags,\n     );\n@@ -194,7 +195,7 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n         ptr: Self::Value,\n         fill_byte: Self::Value,\n         size: Self::Value,\n-        align: Align,\n+        align: AbiAndPrefAlign,\n         flags: MemFlags,\n     );\n "}, {"sha": "b66f4378c35f6560e4eadaf622e86a987409e950", "filename": "src/librustc_codegen_ssa/traits/statics.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -10,13 +10,23 @@\n \n use super::Backend;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::layout::Align;\n+use rustc::ty::layout::AbiAndPrefAlign;\n \n pub trait StaticMethods<'tcx>: Backend<'tcx> {\n     fn static_ptrcast(&self, val: Self::Value, ty: Self::Type) -> Self::Value;\n     fn static_bitcast(&self, val: Self::Value, ty: Self::Type) -> Self::Value;\n-    fn static_addr_of_mut(&self, cv: Self::Value, align: Align, kind: Option<&str>) -> Self::Value;\n-    fn static_addr_of(&self, cv: Self::Value, align: Align, kind: Option<&str>) -> Self::Value;\n+    fn static_addr_of_mut(\n+        &self,\n+        cv: Self::Value,\n+        align: AbiAndPrefAlign,\n+        kind: Option<&str>,\n+    ) -> Self::Value;\n+    fn static_addr_of(\n+        &self,\n+        cv: Self::Value,\n+        align: AbiAndPrefAlign,\n+        kind: Option<&str>,\n+    ) -> Self::Value;\n     fn get_static(&self, def_id: DefId) -> Self::Value;\n     fn codegen_static(&self, def_id: DefId, is_mutable: bool);\n     unsafe fn static_replace_all_uses(&self, old_g: Self::Value, new_g: Self::Value);"}, {"sha": "275f378495d9b1aab4e0eb84f43d5bb24d3c732a", "filename": "src/librustc_codegen_ssa/traits/type_.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -13,7 +13,7 @@ use super::Backend;\n use super::HasCodegen;\n use common::{self, TypeKind};\n use mir::place::PlaceRef;\n-use rustc::ty::layout::{self, Align, Size, TyLayout};\n+use rustc::ty::layout::{self, AbiAndPrefAlign, Size, TyLayout};\n use rustc::ty::{self, Ty};\n use rustc::util::nodemap::FxHashMap;\n use rustc_target::abi::call::{ArgType, CastTarget, FnType, Reg};\n@@ -120,15 +120,15 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n         }\n     }\n \n-    fn type_pointee_for_abi_align(&self, align: Align) -> Self::Type {\n+    fn type_pointee_for_abi_align(&self, align: AbiAndPrefAlign) -> Self::Type {\n         // FIXME(eddyb) We could find a better approximation if ity.align < align.\n         let ity = layout::Integer::approximate_abi_align(self, align);\n         self.type_from_integer(ity)\n     }\n \n     /// Return a LLVM type that has at most the required alignment,\n     /// and exactly the required size, as a best-effort padding array.\n-    fn type_padding_filler(&self, size: Size, align: Align) -> Self::Type {\n+    fn type_padding_filler(&self, size: Size, align: AbiAndPrefAlign) -> Self::Type {\n         let unit = layout::Integer::approximate_abi_align(self, align);\n         let size = size.bytes();\n         let unit_size = unit.size().bytes();"}, {"sha": "69db638270a5e267250a4c4ddd371b05c2b6ea77", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -16,7 +16,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::def::Def;\n use rustc::mir;\n use rustc::ty::layout::{\n-    self, Size, Align, HasDataLayout, LayoutOf, TyLayout\n+    self, Size, AbiAndPrefAlign, HasDataLayout, LayoutOf, TyLayout\n };\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -314,9 +314,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         &self,\n         metadata: Option<Scalar<M::PointerTag>>,\n         layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(Size, Align)>> {\n+    ) -> EvalResult<'tcx, Option<(Size, AbiAndPrefAlign)>> {\n         if !layout.is_unsized() {\n-            return Ok(Some(layout.size_and_align()));\n+            return Ok(Some((layout.size, layout.align)));\n         }\n         match layout.ty.sty {\n             ty::Adt(..) | ty::Tuple(..) => {\n@@ -391,8 +391,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n \n             ty::Slice(_) | ty::Str => {\n                 let len = metadata.expect(\"slice fat ptr must have vtable\").to_usize(self)?;\n-                let (elem_size, align) = layout.field(self, 0)?.size_and_align();\n-                Ok(Some((elem_size * len, align)))\n+                let elem = layout.field(self, 0)?;\n+                Ok(Some((elem.size * len, elem.align)))\n             }\n \n             ty::Foreign(_) => {\n@@ -406,7 +406,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n     pub fn size_and_align_of_mplace(\n         &self,\n         mplace: MPlaceTy<'tcx, M::PointerTag>\n-    ) -> EvalResult<'tcx, Option<(Size, Align)>> {\n+    ) -> EvalResult<'tcx, Option<(Size, AbiAndPrefAlign)>> {\n         self.size_and_align_of(mplace.meta, mplace.layout)\n     }\n "}, {"sha": "dbb0e52287484a0ad1e725513f142fdafa23cde6", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -21,7 +21,7 @@ use std::ptr;\n use std::borrow::Cow;\n \n use rustc::ty::{self, Instance, ParamEnv, query::TyCtxtAt};\n-use rustc::ty::layout::{self, Align, TargetDataLayout, Size, HasDataLayout};\n+use rustc::ty::layout::{self, AbiAndPrefAlign, TargetDataLayout, Size, HasDataLayout};\n pub use rustc::mir::interpret::{truncate, write_target_uint, read_target_uint};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n@@ -71,7 +71,7 @@ pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n     /// To be able to compare pointers with NULL, and to check alignment for accesses\n     /// to ZSTs (where pointers may dangle), we keep track of the size even for allocations\n     /// that do not exist any more.\n-    dead_alloc_map: FxHashMap<AllocId, (Size, Align)>,\n+    dead_alloc_map: FxHashMap<AllocId, (Size, AbiAndPrefAlign)>,\n \n     /// Lets us implement `HasDataLayout`, which is awfully convenient.\n     pub(super) tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n@@ -130,7 +130,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn allocate(\n         &mut self,\n         size: Size,\n-        align: Align,\n+        align: AbiAndPrefAlign,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx, Pointer> {\n         Ok(Pointer::from(self.allocate_with(Allocation::undef(size, align), kind)?))\n@@ -140,9 +140,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         &mut self,\n         ptr: Pointer<M::PointerTag>,\n         old_size: Size,\n-        old_align: Align,\n+        old_align: AbiAndPrefAlign,\n         new_size: Size,\n-        new_align: Align,\n+        new_align: AbiAndPrefAlign,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx, Pointer> {\n         if ptr.offset.bytes() != 0 {\n@@ -179,7 +179,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn deallocate(\n         &mut self,\n         ptr: Pointer<M::PointerTag>,\n-        size_and_align: Option<(Size, Align)>,\n+        size_and_align: Option<(Size, AbiAndPrefAlign)>,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx> {\n         trace!(\"deallocating: {}\", ptr.alloc_id);\n@@ -244,7 +244,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn check_align(\n         &self,\n         ptr: Scalar<M::PointerTag>,\n-        required_align: Align\n+        required_align: AbiAndPrefAlign\n     ) -> EvalResult<'tcx> {\n         // Check non-NULL/Undef, extract offset\n         let (offset, alloc_align) = match ptr {\n@@ -279,7 +279,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         } else {\n             let has = offset % required_align.abi();\n             err!(AlignmentCheckFailed {\n-                has: Align::from_bytes(has, has).unwrap(),\n+                has: AbiAndPrefAlign::from_bytes(has, has).unwrap(),\n                 required: required_align,\n             })\n         }\n@@ -443,13 +443,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn get_size_and_align(&self, id: AllocId) -> (Size, Align) {\n+    pub fn get_size_and_align(&self, id: AllocId) -> (Size, AbiAndPrefAlign) {\n         if let Ok(alloc) = self.get(id) {\n             return (Size::from_bytes(alloc.bytes.len() as u64), alloc.align);\n         }\n         // Could also be a fn ptr or extern static\n         match self.tcx.alloc_map.lock().get(id) {\n-            Some(AllocType::Function(..)) => (Size::ZERO, Align::from_bytes(1, 1).unwrap()),\n+            Some(AllocType::Function(..)) => {\n+                (Size::ZERO, AbiAndPrefAlign::from_bytes(1, 1).unwrap())\n+            }\n             Some(AllocType::Static(did)) => {\n                 // The only way `get` couldn't have worked here is if this is an extern static\n                 assert!(self.tcx.is_foreign_item(did));\n@@ -622,7 +624,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         &self,\n         ptr: Pointer<M::PointerTag>,\n         size: Size,\n-        align: Align,\n+        align: AbiAndPrefAlign,\n         check_defined_and_ptr: bool,\n     ) -> EvalResult<'tcx, &[u8]> {\n         assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n@@ -651,7 +653,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         &self,\n         ptr: Pointer<M::PointerTag>,\n         size: Size,\n-        align: Align\n+        align: AbiAndPrefAlign\n     ) -> EvalResult<'tcx, &[u8]> {\n         self.get_bytes_internal(ptr, size, align, true)\n     }\n@@ -663,7 +665,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         &self,\n         ptr: Pointer<M::PointerTag>,\n         size: Size,\n-        align: Align\n+        align: AbiAndPrefAlign\n     ) -> EvalResult<'tcx, &[u8]> {\n         self.get_bytes_internal(ptr, size, align, false)\n     }\n@@ -674,7 +676,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         &mut self,\n         ptr: Pointer<M::PointerTag>,\n         size: Size,\n-        align: Align,\n+        align: AbiAndPrefAlign,\n     ) -> EvalResult<'tcx, &mut [u8]> {\n         assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n         self.check_align(ptr.into(), align)?;\n@@ -747,9 +749,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn copy(\n         &mut self,\n         src: Scalar<M::PointerTag>,\n-        src_align: Align,\n+        src_align: AbiAndPrefAlign,\n         dest: Scalar<M::PointerTag>,\n-        dest_align: Align,\n+        dest_align: AbiAndPrefAlign,\n         size: Size,\n         nonoverlapping: bool,\n     ) -> EvalResult<'tcx> {\n@@ -759,9 +761,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn copy_repeatedly(\n         &mut self,\n         src: Scalar<M::PointerTag>,\n-        src_align: Align,\n+        src_align: AbiAndPrefAlign,\n         dest: Scalar<M::PointerTag>,\n-        dest_align: Align,\n+        dest_align: AbiAndPrefAlign,\n         size: Size,\n         length: u64,\n         nonoverlapping: bool,\n@@ -863,7 +865,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         allow_ptr_and_undef: bool,\n     ) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-        let align = Align::from_bytes(1, 1).unwrap();\n+        let align = AbiAndPrefAlign::from_bytes(1, 1).unwrap();\n         if size.bytes() == 0 {\n             self.check_align(ptr, align)?;\n             return Ok(());\n@@ -881,7 +883,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn read_bytes(&self, ptr: Scalar<M::PointerTag>, size: Size) -> EvalResult<'tcx, &[u8]> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-        let align = Align::from_bytes(1, 1).unwrap();\n+        let align = AbiAndPrefAlign::from_bytes(1, 1).unwrap();\n         if size.bytes() == 0 {\n             self.check_align(ptr, align)?;\n             return Ok(&[]);\n@@ -891,7 +893,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn write_bytes(&mut self, ptr: Scalar<M::PointerTag>, src: &[u8]) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-        let align = Align::from_bytes(1, 1).unwrap();\n+        let align = AbiAndPrefAlign::from_bytes(1, 1).unwrap();\n         if src.is_empty() {\n             self.check_align(ptr, align)?;\n             return Ok(());\n@@ -908,7 +910,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         count: Size\n     ) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-        let align = Align::from_bytes(1, 1).unwrap();\n+        let align = AbiAndPrefAlign::from_bytes(1, 1).unwrap();\n         if count.bytes() == 0 {\n             self.check_align(ptr, align)?;\n             return Ok(());\n@@ -924,7 +926,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn read_scalar(\n         &self,\n         ptr: Pointer<M::PointerTag>,\n-        ptr_align: Align,\n+        ptr_align: AbiAndPrefAlign,\n         size: Size\n     ) -> EvalResult<'tcx, ScalarMaybeUndef<M::PointerTag>> {\n         // get_bytes_unchecked tests alignment and relocation edges\n@@ -961,7 +963,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn read_ptr_sized(\n         &self,\n         ptr: Pointer<M::PointerTag>,\n-        ptr_align: Align\n+        ptr_align: AbiAndPrefAlign\n     ) -> EvalResult<'tcx, ScalarMaybeUndef<M::PointerTag>> {\n         self.read_scalar(ptr, ptr_align, self.pointer_size())\n     }\n@@ -970,7 +972,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn write_scalar(\n         &mut self,\n         ptr: Pointer<M::PointerTag>,\n-        ptr_align: Align,\n+        ptr_align: AbiAndPrefAlign,\n         val: ScalarMaybeUndef<M::PointerTag>,\n         type_size: Size,\n     ) -> EvalResult<'tcx> {\n@@ -1017,14 +1019,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn write_ptr_sized(\n         &mut self,\n         ptr: Pointer<M::PointerTag>,\n-        ptr_align: Align,\n+        ptr_align: AbiAndPrefAlign,\n         val: ScalarMaybeUndef<M::PointerTag>\n     ) -> EvalResult<'tcx> {\n         let ptr_size = self.pointer_size();\n         self.write_scalar(ptr.into(), ptr_align, val, ptr_size)\n     }\n \n-    fn int_align(&self, size: Size) -> Align {\n+    fn int_align(&self, size: Size) -> AbiAndPrefAlign {\n         // We assume pointer-sized integers have the same alignment as pointers.\n         // We also assume signed and unsigned integers of the same size have the same alignment.\n         let ity = match size.bytes() {"}, {"sha": "bd713d4462d0e8ce4095f051d3202d70af79306b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -18,7 +18,7 @@ use std::hash::Hash;\n use rustc::hir;\n use rustc::mir;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout, VariantIdx};\n+use rustc::ty::layout::{self, Size, AbiAndPrefAlign, LayoutOf, TyLayout, HasDataLayout, VariantIdx};\n \n use super::{\n     GlobalId, AllocId, Allocation, Scalar, EvalResult, Pointer, PointerArithmetic,\n@@ -32,7 +32,7 @@ pub struct MemPlace<Tag=(), Id=AllocId> {\n     /// be turned back into a reference before ever being dereferenced.\n     /// However, it may never be undef.\n     pub ptr: Scalar<Tag, Id>,\n-    pub align: Align,\n+    pub align: AbiAndPrefAlign,\n     /// Metadata for unsized places.  Interpretation is up to the type.\n     /// Must not be present for sized types, but can be missing for unsized types\n     /// (e.g. `extern type`).\n@@ -116,7 +116,7 @@ impl<Tag> MemPlace<Tag> {\n     }\n \n     #[inline(always)]\n-    pub fn from_scalar_ptr(ptr: Scalar<Tag>, align: Align) -> Self {\n+    pub fn from_scalar_ptr(ptr: Scalar<Tag>, align: AbiAndPrefAlign) -> Self {\n         MemPlace {\n             ptr,\n             align,\n@@ -127,16 +127,16 @@ impl<Tag> MemPlace<Tag> {\n     /// Produces a Place that will error if attempted to be read from or written to\n     #[inline(always)]\n     pub fn null(cx: &impl HasDataLayout) -> Self {\n-        Self::from_scalar_ptr(Scalar::ptr_null(cx), Align::from_bytes(1, 1).unwrap())\n+        Self::from_scalar_ptr(Scalar::ptr_null(cx), AbiAndPrefAlign::from_bytes(1, 1).unwrap())\n     }\n \n     #[inline(always)]\n-    pub fn from_ptr(ptr: Pointer<Tag>, align: Align) -> Self {\n+    pub fn from_ptr(ptr: Pointer<Tag>, align: AbiAndPrefAlign) -> Self {\n         Self::from_scalar_ptr(ptr.into(), align)\n     }\n \n     #[inline(always)]\n-    pub fn to_scalar_ptr_align(self) -> (Scalar<Tag>, Align) {\n+    pub fn to_scalar_ptr_align(self) -> (Scalar<Tag>, AbiAndPrefAlign) {\n         assert!(self.meta.is_none());\n         (self.ptr, self.align)\n     }\n@@ -230,12 +230,12 @@ impl<'tcx, Tag: ::std::fmt::Debug> Place<Tag> {\n     }\n \n     #[inline(always)]\n-    pub fn from_scalar_ptr(ptr: Scalar<Tag>, align: Align) -> Self {\n+    pub fn from_scalar_ptr(ptr: Scalar<Tag>, align: AbiAndPrefAlign) -> Self {\n         Place::Ptr(MemPlace::from_scalar_ptr(ptr, align))\n     }\n \n     #[inline(always)]\n-    pub fn from_ptr(ptr: Pointer<Tag>, align: Align) -> Self {\n+    pub fn from_ptr(ptr: Pointer<Tag>, align: AbiAndPrefAlign) -> Self {\n         Place::Ptr(MemPlace::from_ptr(ptr, align))\n     }\n \n@@ -249,7 +249,7 @@ impl<'tcx, Tag: ::std::fmt::Debug> Place<Tag> {\n     }\n \n     #[inline]\n-    pub fn to_scalar_ptr_align(self) -> (Scalar<Tag>, Align) {\n+    pub fn to_scalar_ptr_align(self) -> (Scalar<Tag>, AbiAndPrefAlign) {\n         self.to_mem_place().to_scalar_ptr_align()\n     }\n "}, {"sha": "56475dffae42c6fa486a48a5048a7e0317888c4a", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -16,7 +16,7 @@ use rustc::mir::interpret::{\n };\n \n use rustc::ty::{self, TyCtxt};\n-use rustc::ty::layout::Align;\n+use rustc::ty::layout::AbiAndPrefAlign;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -276,7 +276,7 @@ struct AllocationSnapshot<'a> {\n     bytes: &'a [u8],\n     relocations: Relocations<(), AllocIdSnapshot<'a>>,\n     undef_mask: &'a UndefMask,\n-    align: &'a Align,\n+    align: &'a AbiAndPrefAlign,\n     mutability: &'a Mutability,\n }\n "}, {"sha": "f1bedd181e9e7c05626edfa3044ca948aa1b2ecf", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{Size, Align, LayoutOf};\n+use rustc::ty::layout::{Size, AbiAndPrefAlign, LayoutOf};\n use rustc::mir::interpret::{Scalar, Pointer, EvalResult, PointerArithmetic};\n \n use super::{EvalContext, Machine, MemoryKind};\n@@ -101,7 +101,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     pub fn read_size_and_align_from_vtable(\n         &self,\n         vtable: Pointer<M::PointerTag>,\n-    ) -> EvalResult<'tcx, (Size, Align)> {\n+    ) -> EvalResult<'tcx, (Size, AbiAndPrefAlign)> {\n         let pointer_size = self.pointer_size();\n         let pointer_align = self.tcx.data_layout.pointer_align;\n         let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?,pointer_align)?\n@@ -110,6 +110,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             vtable.offset(pointer_size * 2, self)?,\n             pointer_align\n         )?.to_bits(pointer_size)? as u64;\n-        Ok((Size::from_bytes(size), Align::from_bytes(align, align).unwrap()))\n+        Ok((Size::from_bytes(size), AbiAndPrefAlign::from_bytes(align, align).unwrap()))\n     }\n }"}, {"sha": "41358fe0d84851af7fd5bc88ad54ec5608c7a421", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -13,7 +13,7 @@ use std::hash::Hash;\n use std::ops::RangeInclusive;\n \n use syntax_pos::symbol::Symbol;\n-use rustc::ty::layout::{self, Size, Align, TyLayout, LayoutOf, VariantIdx};\n+use rustc::ty::layout::{self, Size, AbiAndPrefAlign, TyLayout, LayoutOf, VariantIdx};\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n@@ -355,7 +355,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     // for the purpose of validity, consider foreign types to have\n                     // alignment and size determined by the layout (size will be 0,\n                     // alignment should take attributes into account).\n-                    .unwrap_or_else(|| layout.size_and_align());\n+                    .unwrap_or_else(|| (layout.size, layout.align));\n                 match self.ecx.memory.check_align(ptr, align) {\n                     Ok(_) => {},\n                     Err(err) => {\n@@ -463,7 +463,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     // for function pointers.\n                     let non_null =\n                         self.ecx.memory.check_align(\n-                            Scalar::Ptr(ptr), Align::from_bytes(1, 1).unwrap()\n+                            Scalar::Ptr(ptr), AbiAndPrefAlign::from_bytes(1, 1).unwrap()\n                         ).is_ok() ||\n                         self.ecx.memory.get_fn(ptr).is_ok();\n                     if !non_null {"}, {"sha": "289a76eae8f5f77770f2ad1eb2f5832893bec9c1", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{self, Abi, Align, FieldPlacement, Size};\n+use abi::{self, Abi, AbiAndPrefAlign, FieldPlacement, Size};\n use abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n use spec::HasTargetSpec;\n \n@@ -80,7 +80,7 @@ mod attr_impl {\n pub struct ArgAttributes {\n     pub regular: ArgAttribute,\n     pub pointee_size: Size,\n-    pub pointee_align: Option<Align>\n+    pub pointee_align: Option<AbiAndPrefAlign>\n }\n \n impl ArgAttributes {\n@@ -137,7 +137,7 @@ impl Reg {\n }\n \n impl Reg {\n-    pub fn align<C: HasDataLayout>(&self, cx: &C) -> Align {\n+    pub fn align<C: HasDataLayout>(&self, cx: &C) -> AbiAndPrefAlign {\n         let dl = cx.data_layout();\n         match self.kind {\n             RegKind::Integer => {\n@@ -188,7 +188,7 @@ impl From<Reg> for Uniform {\n }\n \n impl Uniform {\n-    pub fn align<C: HasDataLayout>(&self, cx: &C) -> Align {\n+    pub fn align<C: HasDataLayout>(&self, cx: &C) -> AbiAndPrefAlign {\n         self.unit.align(cx)\n     }\n }\n@@ -230,7 +230,7 @@ impl CastTarget {\n              .abi_align(self.rest.align(cx)) + self.rest.total\n     }\n \n-    pub fn align<C: HasDataLayout>(&self, cx: &C) -> Align {\n+    pub fn align<C: HasDataLayout>(&self, cx: &C) -> AbiAndPrefAlign {\n         self.prefix.iter()\n             .filter_map(|x| x.map(|kind| Reg { kind, size: self.prefix_chunk }.align(cx)))\n             .fold(cx.data_layout().aggregate_align.max(self.rest.align(cx)),"}, {"sha": "93b8f79ccdc05669114025c522db7a1409b4f9b0", "filename": "src/librustc_target/abi/call/powerpc64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -13,7 +13,7 @@\n // need to be fixed when PowerPC vector support is added.\n \n use abi::call::{FnType, ArgType, Reg, RegKind, Uniform};\n-use abi::{Align, Endian, HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use abi::{AbiAndPrefAlign, Endian, HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n use spec::HasTargetSpec;\n \n #[derive(Debug, Clone, Copy, PartialEq)]\n@@ -120,7 +120,7 @@ fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>, abi: ABI)\n     } else {\n         // Aggregates larger than a doubleword should be padded\n         // at the tail to fill out a whole number of doublewords.\n-        let align = Align::from_bits(64, 64).unwrap();\n+        let align = AbiAndPrefAlign::from_bits(64, 64).unwrap();\n         (Reg::i64(), size.abi_align(align))\n     };\n "}, {"sha": "7b0b34e207cece454ce60e696e3bf8c9c110fbeb", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 49, "deletions": 52, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d56e8920852adec249c9d8159348a94dcafbd31c/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=d56e8920852adec249c9d8159348a94dcafbd31c", "patch": "@@ -24,20 +24,21 @@ pub mod call;\n /// for a target, which contains everything needed to compute layouts.\n pub struct TargetDataLayout {\n     pub endian: Endian,\n-    pub i1_align: Align,\n-    pub i8_align: Align,\n-    pub i16_align: Align,\n-    pub i32_align: Align,\n-    pub i64_align: Align,\n-    pub i128_align: Align,\n-    pub f32_align: Align,\n-    pub f64_align: Align,\n+    pub i1_align: AbiAndPrefAlign,\n+    pub i8_align: AbiAndPrefAlign,\n+    pub i16_align: AbiAndPrefAlign,\n+    pub i32_align: AbiAndPrefAlign,\n+    pub i64_align: AbiAndPrefAlign,\n+    pub i128_align: AbiAndPrefAlign,\n+    pub f32_align: AbiAndPrefAlign,\n+    pub f64_align: AbiAndPrefAlign,\n     pub pointer_size: Size,\n-    pub pointer_align: Align,\n-    pub aggregate_align: Align,\n+    pub pointer_align: AbiAndPrefAlign,\n+    pub aggregate_align: AbiAndPrefAlign,\n \n     /// Alignments for vector types.\n-    pub vector_align: Vec<(Size, Align)>,\n+    pub vector_align: Vec<(Size, AbiAndPrefAlign)>,\n+\n     pub instruction_address_space: u32,\n }\n \n@@ -46,20 +47,20 @@ impl Default for TargetDataLayout {\n     fn default() -> TargetDataLayout {\n         TargetDataLayout {\n             endian: Endian::Big,\n-            i1_align: Align::from_bits(8, 8).unwrap(),\n-            i8_align: Align::from_bits(8, 8).unwrap(),\n-            i16_align: Align::from_bits(16, 16).unwrap(),\n-            i32_align: Align::from_bits(32, 32).unwrap(),\n-            i64_align: Align::from_bits(32, 64).unwrap(),\n-            i128_align: Align::from_bits(32, 64).unwrap(),\n-            f32_align: Align::from_bits(32, 32).unwrap(),\n-            f64_align: Align::from_bits(64, 64).unwrap(),\n+            i1_align: AbiAndPrefAlign::from_bits(8, 8).unwrap(),\n+            i8_align: AbiAndPrefAlign::from_bits(8, 8).unwrap(),\n+            i16_align: AbiAndPrefAlign::from_bits(16, 16).unwrap(),\n+            i32_align: AbiAndPrefAlign::from_bits(32, 32).unwrap(),\n+            i64_align: AbiAndPrefAlign::from_bits(32, 64).unwrap(),\n+            i128_align: AbiAndPrefAlign::from_bits(32, 64).unwrap(),\n+            f32_align: AbiAndPrefAlign::from_bits(32, 32).unwrap(),\n+            f64_align: AbiAndPrefAlign::from_bits(64, 64).unwrap(),\n             pointer_size: Size::from_bits(64),\n-            pointer_align: Align::from_bits(64, 64).unwrap(),\n-            aggregate_align: Align::from_bits(0, 64).unwrap(),\n+            pointer_align: AbiAndPrefAlign::from_bits(64, 64).unwrap(),\n+            aggregate_align: AbiAndPrefAlign::from_bits(0, 64).unwrap(),\n             vector_align: vec![\n-                (Size::from_bits(64), Align::from_bits(64, 64).unwrap()),\n-                (Size::from_bits(128), Align::from_bits(128, 128).unwrap())\n+                (Size::from_bits(64), AbiAndPrefAlign::from_bits(64, 64).unwrap()),\n+                (Size::from_bits(128), AbiAndPrefAlign::from_bits(128, 128).unwrap())\n             ],\n             instruction_address_space: 0,\n         }\n@@ -96,7 +97,7 @@ impl TargetDataLayout {\n             }\n             let abi = parse_bits(s[0], \"alignment\", cause)?;\n             let pref = s.get(1).map_or(Ok(abi), |pref| parse_bits(pref, \"alignment\", cause))?;\n-            Align::from_bits(abi, pref).map_err(|err| {\n+            AbiAndPrefAlign::from_bits(abi, pref).map_err(|err| {\n                 format!(\"invalid alignment for `{}` in \\\"data-layout\\\": {}\",\n                         cause, err)\n             })\n@@ -205,7 +206,7 @@ impl TargetDataLayout {\n         }\n     }\n \n-    pub fn vector_align(&self, vec_size: Size) -> Align {\n+    pub fn vector_align(&self, vec_size: Size) -> AbiAndPrefAlign {\n         for &(size, align) in &self.vector_align {\n             if size == vec_size {\n                 return align;\n@@ -214,7 +215,7 @@ impl TargetDataLayout {\n         // Default to natural alignment, which is what LLVM does.\n         // That is, use the size, rounded up to a power of 2.\n         let align = vec_size.bytes().next_power_of_two();\n-        Align::from_bytes(align, align).unwrap()\n+        AbiAndPrefAlign::from_bytes(align, align).unwrap()\n     }\n }\n \n@@ -270,13 +271,13 @@ impl Size {\n     }\n \n     #[inline]\n-    pub fn abi_align(self, align: Align) -> Size {\n+    pub fn abi_align(self, align: AbiAndPrefAlign) -> Size {\n         let mask = align.abi() - 1;\n         Size::from_bytes((self.bytes() + mask) & !mask)\n     }\n \n     #[inline]\n-    pub fn is_abi_aligned(self, align: Align) -> bool {\n+    pub fn is_abi_aligned(self, align: AbiAndPrefAlign) -> bool {\n         let mask = align.abi() - 1;\n         self.bytes() & mask == 0\n     }\n@@ -358,23 +359,23 @@ impl AddAssign for Size {\n     }\n }\n \n-/// Alignment of a type in bytes, both ABI-mandated and preferred.\n+/// Alignments of a type in bytes, both ABI-mandated and preferred.\n /// Each field is a power of two, giving the alignment a maximum value\n /// of 2<sup>(2<sup>8</sup> - 1)</sup>, which is limited by LLVM to a\n /// maximum capacity of 2<sup>29</sup> or 536870912.\n #[derive(Copy, Clone, PartialEq, Eq, Ord, PartialOrd, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct Align {\n+pub struct AbiAndPrefAlign {\n     abi_pow2: u8,\n     pref_pow2: u8,\n }\n \n-impl Align {\n-    pub fn from_bits(abi: u64, pref: u64) -> Result<Align, String> {\n-        Align::from_bytes(Size::from_bits(abi).bytes(),\n+impl AbiAndPrefAlign {\n+    pub fn from_bits(abi: u64, pref: u64) -> Result<AbiAndPrefAlign, String> {\n+        AbiAndPrefAlign::from_bytes(Size::from_bits(abi).bytes(),\n                           Size::from_bits(pref).bytes())\n     }\n \n-    pub fn from_bytes(abi: u64, pref: u64) -> Result<Align, String> {\n+    pub fn from_bytes(abi: u64, pref: u64) -> Result<AbiAndPrefAlign, String> {\n         let log2 = |align: u64| {\n             // Treat an alignment of 0 bytes like 1-byte alignment.\n             if align == 0 {\n@@ -396,7 +397,7 @@ impl Align {\n             }\n         };\n \n-        Ok(Align {\n+        Ok(AbiAndPrefAlign {\n             abi_pow2: log2(abi)?,\n             pref_pow2: log2(pref)?,\n         })\n@@ -418,15 +419,15 @@ impl Align {\n         self.pref() * 8\n     }\n \n-    pub fn min(self, other: Align) -> Align {\n-        Align {\n+    pub fn min(self, other: AbiAndPrefAlign) -> AbiAndPrefAlign {\n+        AbiAndPrefAlign {\n             abi_pow2: cmp::min(self.abi_pow2, other.abi_pow2),\n             pref_pow2: cmp::min(self.pref_pow2, other.pref_pow2),\n         }\n     }\n \n-    pub fn max(self, other: Align) -> Align {\n-        Align {\n+    pub fn max(self, other: AbiAndPrefAlign) -> AbiAndPrefAlign {\n+        AbiAndPrefAlign {\n             abi_pow2: cmp::max(self.abi_pow2, other.abi_pow2),\n             pref_pow2: cmp::max(self.pref_pow2, other.pref_pow2),\n         }\n@@ -436,18 +437,18 @@ impl Align {\n     /// (the largest power of two that the offset is a multiple of).\n     ///\n     /// NB: for an offset of `0`, this happens to return `2^64`.\n-    pub fn max_for_offset(offset: Size) -> Align {\n+    pub fn max_for_offset(offset: Size) -> AbiAndPrefAlign {\n         let pow2 = offset.bytes().trailing_zeros() as u8;\n-        Align {\n+        AbiAndPrefAlign {\n             abi_pow2: pow2,\n             pref_pow2: pow2,\n         }\n     }\n \n     /// Lower the alignment, if necessary, such that the given offset\n     /// is aligned to it (the offset is a multiple of the alignment).\n-    pub fn restrict_for_offset(self, offset: Size) -> Align {\n-        self.min(Align::max_for_offset(offset))\n+    pub fn restrict_for_offset(self, offset: Size) -> AbiAndPrefAlign {\n+        self.min(AbiAndPrefAlign::max_for_offset(offset))\n     }\n }\n \n@@ -472,7 +473,7 @@ impl Integer {\n         }\n     }\n \n-    pub fn align<C: HasDataLayout>(self, cx: &C) -> Align {\n+    pub fn align<C: HasDataLayout>(self, cx: &C) -> AbiAndPrefAlign {\n         let dl = cx.data_layout();\n \n         match self {\n@@ -507,7 +508,7 @@ impl Integer {\n     }\n \n     /// Find the smallest integer with the given alignment.\n-    pub fn for_abi_align<C: HasDataLayout>(cx: &C, align: Align) -> Option<Integer> {\n+    pub fn for_abi_align<C: HasDataLayout>(cx: &C, align: AbiAndPrefAlign) -> Option<Integer> {\n         let dl = cx.data_layout();\n \n         let wanted = align.abi();\n@@ -520,7 +521,7 @@ impl Integer {\n     }\n \n     /// Find the largest integer with the given alignment or less.\n-    pub fn approximate_abi_align<C: HasDataLayout>(cx: &C, align: Align) -> Integer {\n+    pub fn approximate_abi_align<C: HasDataLayout>(cx: &C, align: AbiAndPrefAlign) -> Integer {\n         let dl = cx.data_layout();\n \n         let wanted = align.abi();\n@@ -597,7 +598,7 @@ impl<'a, 'tcx> Primitive {\n         }\n     }\n \n-    pub fn align<C: HasDataLayout>(self, cx: &C) -> Align {\n+    pub fn align<C: HasDataLayout>(self, cx: &C) -> AbiAndPrefAlign {\n         let dl = cx.data_layout();\n \n         match self {\n@@ -868,7 +869,7 @@ pub struct LayoutDetails {\n     pub variants: Variants,\n     pub fields: FieldPlacement,\n     pub abi: Abi,\n-    pub align: Align,\n+    pub align: AbiAndPrefAlign,\n     pub size: Size\n }\n \n@@ -949,8 +950,4 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n             Abi::Aggregate { sized } => sized && self.size.bytes() == 0\n         }\n     }\n-\n-    pub fn size_and_align(&self) -> (Size, Align) {\n-        (self.size, self.align)\n-    }\n }"}]}