{"sha": "68369a041cea809a87e5bd80701da90e0e0a4799", "node_id": "C_kwDOAAsO6NoAKDY4MzY5YTA0MWNlYTgwOWE4N2U1YmQ4MDcwMWRhOTBlMGUwYTQ3OTk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-22T14:41:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-22T14:41:26Z"}, "message": "Auto merge of #94254 - matthiaskrgr:rollup-7llbjhd, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #94169 (Fix several asm! related issues)\n - #94178 (tidy: fire less \"ignoring file length unneccessarily\" warnings)\n - #94179 (solarish current_exe using libc call directly)\n - #94196 (compiletest: Print process output info with less whitespace)\n - #94208 (Add the let else tests found missing in the stabilization report)\n - #94237 (Do not suggest wrapping an item if it has ambiguous un-imported methods)\n - #94246 (ScalarMaybeUninit is explicitly hexadecimal in its formatting)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e2fc6c0b85a95aad96ea76703966f126fdf3d907", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2fc6c0b85a95aad96ea76703966f126fdf3d907"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68369a041cea809a87e5bd80701da90e0e0a4799", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68369a041cea809a87e5bd80701da90e0e0a4799", "html_url": "https://github.com/rust-lang/rust/commit/68369a041cea809a87e5bd80701da90e0e0a4799", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68369a041cea809a87e5bd80701da90e0e0a4799/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ecd75b831f744b9bdfb5ec4d435fa20c65e074e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ecd75b831f744b9bdfb5ec4d435fa20c65e074e", "html_url": "https://github.com/rust-lang/rust/commit/9ecd75b831f744b9bdfb5ec4d435fa20c65e074e"}, {"sha": "e3814629c4aaff5813ad35b2e52f00cfa006eef5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3814629c4aaff5813ad35b2e52f00cfa006eef5", "html_url": "https://github.com/rust-lang/rust/commit/e3814629c4aaff5813ad35b2e52f00cfa006eef5"}], "stats": {"total": 795, "additions": 488, "deletions": 307}, "files": [{"sha": "171cc60dfd77c28b79dca802aa4c81d31b7543ea", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -64,12 +64,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut clobber_abis = FxHashMap::default();\n         if let Some(asm_arch) = asm_arch {\n             for (abi_name, abi_span) in &asm.clobber_abis {\n-                match asm::InlineAsmClobberAbi::parse(\n-                    asm_arch,\n-                    &self.sess.target_features,\n-                    &self.sess.target,\n-                    *abi_name,\n-                ) {\n+                match asm::InlineAsmClobberAbi::parse(asm_arch, &self.sess.target, *abi_name) {\n                     Ok(abi) => {\n                         // If the abi was already in the list, emit an error\n                         match clobber_abis.get(&abi) {\n@@ -129,17 +124,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .operands\n             .iter()\n             .map(|(op, op_sp)| {\n-                let lower_reg = |reg, is_clobber| match reg {\n+                let lower_reg = |reg| match reg {\n                     InlineAsmRegOrRegClass::Reg(s) => {\n                         asm::InlineAsmRegOrRegClass::Reg(if let Some(asm_arch) = asm_arch {\n-                            asm::InlineAsmReg::parse(\n-                                asm_arch,\n-                                &sess.target_features,\n-                                &sess.target,\n-                                is_clobber,\n-                                s,\n-                            )\n-                            .unwrap_or_else(|e| {\n+                            asm::InlineAsmReg::parse(asm_arch, s).unwrap_or_else(|e| {\n                                 let msg = format!(\"invalid register `{}`: {}\", s.as_str(), e);\n                                 sess.struct_span_err(*op_sp, &msg).emit();\n                                 asm::InlineAsmReg::Err\n@@ -163,24 +151,24 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                 let op = match *op {\n                     InlineAsmOperand::In { reg, ref expr } => hir::InlineAsmOperand::In {\n-                        reg: lower_reg(reg, false),\n+                        reg: lower_reg(reg),\n                         expr: self.lower_expr_mut(expr),\n                     },\n                     InlineAsmOperand::Out { reg, late, ref expr } => hir::InlineAsmOperand::Out {\n-                        reg: lower_reg(reg, expr.is_none()),\n+                        reg: lower_reg(reg),\n                         late,\n                         expr: expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n                     },\n                     InlineAsmOperand::InOut { reg, late, ref expr } => {\n                         hir::InlineAsmOperand::InOut {\n-                            reg: lower_reg(reg, false),\n+                            reg: lower_reg(reg),\n                             late,\n                             expr: self.lower_expr_mut(expr),\n                         }\n                     }\n                     InlineAsmOperand::SplitInOut { reg, late, ref in_expr, ref out_expr } => {\n                         hir::InlineAsmOperand::SplitInOut {\n-                            reg: lower_reg(reg, false),\n+                            reg: lower_reg(reg),\n                             late,\n                             in_expr: self.lower_expr_mut(in_expr),\n                             out_expr: out_expr.as_ref().map(|expr| self.lower_expr_mut(expr)),"}, {"sha": "deac5dfd3ec1adc43b8e2380446dba99a493eb6e", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -106,6 +106,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     let mut asm_gen = InlineAssemblyGenerator {\n         tcx: fx.tcx,\n         arch: fx.tcx.sess.asm_arch.unwrap(),\n+        enclosing_def_id: fx.instance.def_id(),\n         template,\n         operands,\n         options,\n@@ -169,6 +170,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n struct InlineAssemblyGenerator<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     arch: InlineAsmArch,\n+    enclosing_def_id: DefId,\n     template: &'a [InlineAsmTemplatePiece],\n     operands: &'a [InlineAsmOperand<'tcx>],\n     options: InlineAsmOptions,\n@@ -182,7 +184,12 @@ struct InlineAssemblyGenerator<'a, 'tcx> {\n impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n     fn allocate_registers(&mut self) {\n         let sess = self.tcx.sess;\n-        let map = allocatable_registers(self.arch, &sess.target_features, &sess.target);\n+        let map = allocatable_registers(\n+            self.arch,\n+            sess.relocation_model(),\n+            self.tcx.asm_target_features(self.enclosing_def_id),\n+            &sess.target,\n+        );\n         let mut allocated = FxHashMap::<_, (bool, bool)>::default();\n         let mut regs = vec![None; self.operands.len()];\n \n@@ -313,14 +320,9 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         let mut new_slot = |x| new_slot_fn(&mut slot_size, x);\n \n         // Allocate stack slots for saving clobbered registers\n-        let abi_clobber = InlineAsmClobberAbi::parse(\n-            self.arch,\n-            &self.tcx.sess.target_features,\n-            &self.tcx.sess.target,\n-            sym::C,\n-        )\n-        .unwrap()\n-        .clobbered_regs();\n+        let abi_clobber = InlineAsmClobberAbi::parse(self.arch, &self.tcx.sess.target, sym::C)\n+            .unwrap()\n+            .clobbered_regs();\n         for (i, reg) in self.registers.iter().enumerate().filter_map(|(i, r)| r.map(|r| (i, r))) {\n             let mut need_save = true;\n             // If the register overlaps with a register clobbered by function call, then"}, {"sha": "77166c89735e43b9f77c7facf88b24144398452f", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -36,7 +36,6 @@ const ARM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     // #[target_feature].\n     (\"thumb-mode\", Some(sym::arm_target_feature)),\n     (\"thumb2\", Some(sym::arm_target_feature)),\n-    (\"reserve-r9\", Some(sym::arm_target_feature)),\n ];\n \n const AARCH64_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &["}, {"sha": "bc4dca4c146f6e2257ab5e1b61084c4860a8ad62", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -142,11 +142,11 @@ impl<Tag: Provenance> std::fmt::Display for ImmTy<'_, Tag> {\n                         p(cx, s, ty)?;\n                         return Ok(());\n                     }\n-                    write!(f, \"{}: {}\", s, self.layout.ty)\n+                    write!(f, \"{:x}: {}\", s, self.layout.ty)\n                 }\n                 Immediate::ScalarPair(a, b) => {\n                     // FIXME(oli-obk): at least print tuples and slices nicely\n-                    write!(f, \"({}, {}): {}\", a, b, self.layout.ty,)\n+                    write!(f, \"({:x}, {:x}): {}\", a, b, self.layout.ty,)\n                 }\n             }\n         })"}, {"sha": "54e29299e6c97652fbba7fd431941a6364d45ee7", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -503,7 +503,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     value.to_bool(),\n                     self.path,\n                     err_ub!(InvalidBool(..)) | err_ub!(InvalidUninitBytes(None)) =>\n-                        { \"{}\", value } expected { \"a boolean\" },\n+                        { \"{:x}\", value } expected { \"a boolean\" },\n                 );\n                 Ok(true)\n             }\n@@ -513,7 +513,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     value.to_char(),\n                     self.path,\n                     err_ub!(InvalidChar(..)) | err_ub!(InvalidUninitBytes(None)) =>\n-                        { \"{}\", value } expected { \"a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\" },\n+                        { \"{:x}\", value } expected { \"a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\" },\n                 );\n                 Ok(true)\n             }\n@@ -526,7 +526,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     let is_bits = value.check_init().map_or(false, |v| v.try_to_int().is_ok());\n                     if !is_bits {\n                         throw_validation_failure!(self.path,\n-                            { \"{}\", value } expected { \"initialized plain (non-pointer) bytes\" }\n+                            { \"{:x}\", value } expected { \"initialized plain (non-pointer) bytes\" }\n                         )\n                     }\n                 }\n@@ -580,7 +580,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     err_ub!(DanglingIntPointer(..)) |\n                     err_ub!(InvalidFunctionPointer(..)) |\n                     err_ub!(InvalidUninitBytes(None)) =>\n-                        { \"{}\", value } expected { \"a function pointer\" },\n+                        { \"{:x}\", value } expected { \"a function pointer\" },\n                 );\n                 // FIXME: Check if the signature matches\n                 Ok(true)\n@@ -632,7 +632,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         let value = try_validation!(\n             value.check_init(),\n             self.path,\n-            err_ub!(InvalidUninitBytes(None)) => { \"{}\", value }\n+            err_ub!(InvalidUninitBytes(None)) => { \"{:x}\", value }\n                 expected { \"something {}\", wrapping_range_format(valid_range, max_value) },\n         );\n         let bits = match value.try_to_int() {"}, {"sha": "c8ddc4edc8adae51efb0b50e5858c7ad696ba8c5", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -498,7 +498,7 @@ impl<Tag: Provenance> fmt::Debug for ScalarMaybeUninit<Tag> {\n     }\n }\n \n-impl<Tag: Provenance> fmt::Display for ScalarMaybeUninit<Tag> {\n+impl<Tag: Provenance> fmt::LowerHex for ScalarMaybeUninit<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             ScalarMaybeUninit::Uninit => write!(f, \"uninitialized bytes\"),"}, {"sha": "069dac969c66e0cdce9bafabbec4e02c9fe86203", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -1046,6 +1046,10 @@ rustc_queries! {\n         cache_on_disk_if { true }\n     }\n \n+    query asm_target_features(def_id: DefId) -> &'tcx FxHashSet<Symbol> {\n+        desc { |tcx| \"computing target features for inline asm of `{}`\", tcx.def_path_str(def_id) }\n+    }\n+\n     query fn_arg_names(def_id: DefId) -> &'tcx [rustc_span::symbol::Ident] {\n         desc { |tcx| \"looking up function parameter names for `{}`\", tcx.def_path_str(def_id) }\n         separate_provide_extern"}, {"sha": "d7dde157864a499049360dae548cf53b2df1628a", "filename": "compiler/rustc_passes/src/intrinsicck.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -1,4 +1,5 @@\n use rustc_ast::InlineAsmTemplatePiece;\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -138,7 +139,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n         template: &[InlineAsmTemplatePiece],\n         is_input: bool,\n         tied_input: Option<(&hir::Expr<'tcx>, Option<InlineAsmType>)>,\n-        target_features: &[Symbol],\n+        target_features: &FxHashSet<Symbol>,\n     ) -> Option<InlineAsmType> {\n         // Check the type against the allowed types for inline asm.\n         let ty = self.typeck_results.expr_ty_adjusted(expr);\n@@ -285,9 +286,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n         // (!). In that case we still need the earlier check to verify that the\n         // register class is usable at all.\n         if let Some(feature) = feature {\n-            if !self.tcx.sess.target_features.contains(&feature)\n-                && !target_features.contains(&feature)\n-            {\n+            if !target_features.contains(&feature) {\n                 let msg = &format!(\"`{}` target feature is not enabled\", feature);\n                 let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n                 err.note(&format!(\n@@ -347,7 +346,8 @@ impl<'tcx> ExprVisitor<'tcx> {\n         let hir = self.tcx.hir();\n         let enclosing_id = hir.enclosing_body_owner(hir_id);\n         let enclosing_def_id = hir.local_def_id(enclosing_id).to_def_id();\n-        let attrs = self.tcx.codegen_fn_attrs(enclosing_def_id);\n+        let target_features = self.tcx.asm_target_features(enclosing_def_id);\n+        let asm_arch = self.tcx.sess.asm_arch.unwrap();\n         for (idx, (op, op_sp)) in asm.operands.iter().enumerate() {\n             // Validate register classes against currently enabled target\n             // features. We check that at least one type is available for\n@@ -360,16 +360,29 @@ impl<'tcx> ExprVisitor<'tcx> {\n             // Note that this is only possible for explicit register\n             // operands, which cannot be used in the asm string.\n             if let Some(reg) = op.reg() {\n+                // Some explicit registers cannot be used depending on the\n+                // target. Reject those here.\n+                if let InlineAsmRegOrRegClass::Reg(reg) = reg {\n+                    if let Err(msg) = reg.validate(\n+                        asm_arch,\n+                        self.tcx.sess.relocation_model(),\n+                        &target_features,\n+                        &self.tcx.sess.target,\n+                        op.is_clobber(),\n+                    ) {\n+                        let msg = format!(\"cannot use register `{}`: {}\", reg.name(), msg);\n+                        self.tcx.sess.struct_span_err(*op_sp, &msg).emit();\n+                        continue;\n+                    }\n+                }\n+\n                 if !op.is_clobber() {\n                     let mut missing_required_features = vec![];\n                     let reg_class = reg.reg_class();\n-                    for &(_, feature) in reg_class.supported_types(self.tcx.sess.asm_arch.unwrap())\n-                    {\n+                    for &(_, feature) in reg_class.supported_types(asm_arch) {\n                         match feature {\n                             Some(feature) => {\n-                                if self.tcx.sess.target_features.contains(&feature)\n-                                    || attrs.target_features.contains(&feature)\n-                                {\n+                                if target_features.contains(&feature) {\n                                     missing_required_features.clear();\n                                     break;\n                                 } else {\n@@ -425,7 +438,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n                         asm.template,\n                         true,\n                         None,\n-                        &attrs.target_features,\n+                        &target_features,\n                     );\n                 }\n                 hir::InlineAsmOperand::Out { reg, late: _, ref expr } => {\n@@ -437,7 +450,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n                             asm.template,\n                             false,\n                             None,\n-                            &attrs.target_features,\n+                            &target_features,\n                         );\n                     }\n                 }\n@@ -449,7 +462,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n                         asm.template,\n                         false,\n                         None,\n-                        &attrs.target_features,\n+                        &target_features,\n                     );\n                 }\n                 hir::InlineAsmOperand::SplitInOut { reg, late: _, ref in_expr, ref out_expr } => {\n@@ -460,7 +473,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n                         asm.template,\n                         true,\n                         None,\n-                        &attrs.target_features,\n+                        &target_features,\n                     );\n                     if let Some(out_expr) = out_expr {\n                         self.check_asm_operand_type(\n@@ -470,7 +483,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n                             asm.template,\n                             false,\n                             Some((in_expr, in_ty)),\n-                            &attrs.target_features,\n+                            &target_features,\n                         );\n                     }\n                 }"}, {"sha": "6767593bbc51a8ce455cd8daec8e5d5cbb57db0e", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -1122,7 +1122,6 @@ symbols! {\n         repr_packed,\n         repr_simd,\n         repr_transparent,\n-        reserved_r9: \"reserved-r9\",\n         residual,\n         result,\n         rhs,"}, {"sha": "7fb4dbdf2b181086d3e29a4d2e0efd19a920c95f", "filename": "compiler/rustc_target/src/asm/aarch64.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -1,5 +1,5 @@\n use super::{InlineAsmArch, InlineAsmType};\n-use crate::spec::Target;\n+use crate::spec::{RelocModel, Target};\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::Symbol;\n@@ -73,17 +73,18 @@ impl AArch64InlineAsmRegClass {\n     }\n }\n \n-pub fn reserved_x18(\n+pub fn target_reserves_x18(target: &Target) -> bool {\n+    target.os == \"android\" || target.is_like_fuchsia || target.is_like_osx || target.is_like_windows\n+}\n+\n+fn reserved_x18(\n     _arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     _target_features: &FxHashSet<Symbol>,\n     target: &Target,\n     _is_clobber: bool,\n ) -> Result<(), &'static str> {\n-    if target.os == \"android\"\n-        || target.is_like_fuchsia\n-        || target.is_like_osx\n-        || target.is_like_windows\n-    {\n+    if target_reserves_x18(target) {\n         Err(\"x18 is a reserved register on this target\")\n     } else {\n         Ok(())"}, {"sha": "88f2d3f80d2c38d352d19fdcb7b2a18c99d1b122", "filename": "compiler/rustc_target/src/asm/arm.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -1,5 +1,5 @@\n use super::{InlineAsmArch, InlineAsmType};\n-use crate::spec::Target;\n+use crate::spec::{RelocModel, Target};\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::{sym, Symbol};\n@@ -67,11 +67,12 @@ fn frame_pointer_is_r7(target_features: &FxHashSet<Symbol>, target: &Target) ->\n \n fn frame_pointer_r11(\n     arch: InlineAsmArch,\n+    reloc_model: RelocModel,\n     target_features: &FxHashSet<Symbol>,\n     target: &Target,\n     is_clobber: bool,\n ) -> Result<(), &'static str> {\n-    not_thumb1(arch, target_features, target, is_clobber)?;\n+    not_thumb1(arch, reloc_model, target_features, target, is_clobber)?;\n \n     if !frame_pointer_is_r7(target_features, target) {\n         Err(\"the frame pointer (r11) cannot be used as an operand for inline asm\")\n@@ -82,6 +83,7 @@ fn frame_pointer_r11(\n \n fn frame_pointer_r7(\n     _arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     target_features: &FxHashSet<Symbol>,\n     target: &Target,\n     _is_clobber: bool,\n@@ -95,6 +97,7 @@ fn frame_pointer_r7(\n \n fn not_thumb1(\n     _arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n     is_clobber: bool,\n@@ -111,18 +114,18 @@ fn not_thumb1(\n \n fn reserved_r9(\n     arch: InlineAsmArch,\n+    reloc_model: RelocModel,\n     target_features: &FxHashSet<Symbol>,\n     target: &Target,\n     is_clobber: bool,\n ) -> Result<(), &'static str> {\n-    not_thumb1(arch, target_features, target, is_clobber)?;\n+    not_thumb1(arch, reloc_model, target_features, target, is_clobber)?;\n \n-    // We detect this using the reserved-r9 feature instead of using the target\n-    // because the relocation model can be changed with compiler options.\n-    if target_features.contains(&sym::reserved_r9) {\n-        Err(\"the RWPI static base register (r9) cannot be used as an operand for inline asm\")\n-    } else {\n-        Ok(())\n+    match reloc_model {\n+        RelocModel::Rwpi | RelocModel::RopiRwpi => {\n+            Err(\"the RWPI static base register (r9) cannot be used as an operand for inline asm\")\n+        }\n+        _ => Ok(()),\n     }\n }\n "}, {"sha": "3b03766a089b22f12406b083cae5cd2e84d716d2", "filename": "compiler/rustc_target/src/asm/bpf.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_target%2Fsrc%2Fasm%2Fbpf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_target%2Fsrc%2Fasm%2Fbpf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fbpf.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -1,7 +1,6 @@\n-use super::{InlineAsmArch, InlineAsmType, Target};\n-use rustc_data_structures::stable_set::FxHashSet;\n+use super::{InlineAsmArch, InlineAsmType};\n use rustc_macros::HashStable_Generic;\n-use rustc_span::{sym, Symbol};\n+use rustc_span::Symbol;\n use std::fmt;\n \n def_reg_class! {\n@@ -43,19 +42,6 @@ impl BpfInlineAsmRegClass {\n     }\n }\n \n-fn only_alu32(\n-    _arch: InlineAsmArch,\n-    target_features: &FxHashSet<Symbol>,\n-    _target: &Target,\n-    _is_clobber: bool,\n-) -> Result<(), &'static str> {\n-    if !target_features.contains(&sym::alu32) {\n-        Err(\"register can't be used without the `alu32` target feature\")\n-    } else {\n-        Ok(())\n-    }\n-}\n-\n def_regs! {\n     Bpf BpfInlineAsmReg BpfInlineAsmRegClass {\n         r0: reg = [\"r0\"],\n@@ -68,16 +54,16 @@ def_regs! {\n         r7: reg = [\"r7\"],\n         r8: reg = [\"r8\"],\n         r9: reg = [\"r9\"],\n-        w0: wreg = [\"w0\"] % only_alu32,\n-        w1: wreg = [\"w1\"] % only_alu32,\n-        w2: wreg = [\"w2\"] % only_alu32,\n-        w3: wreg = [\"w3\"] % only_alu32,\n-        w4: wreg = [\"w4\"] % only_alu32,\n-        w5: wreg = [\"w5\"] % only_alu32,\n-        w6: wreg = [\"w6\"] % only_alu32,\n-        w7: wreg = [\"w7\"] % only_alu32,\n-        w8: wreg = [\"w8\"] % only_alu32,\n-        w9: wreg = [\"w9\"] % only_alu32,\n+        w0: wreg = [\"w0\"],\n+        w1: wreg = [\"w1\"],\n+        w2: wreg = [\"w2\"],\n+        w3: wreg = [\"w3\"],\n+        w4: wreg = [\"w4\"],\n+        w5: wreg = [\"w5\"],\n+        w6: wreg = [\"w6\"],\n+        w7: wreg = [\"w7\"],\n+        w8: wreg = [\"w8\"],\n+        w9: wreg = [\"w9\"],\n \n         #error = [\"r10\", \"w10\"] =>\n             \"the stack pointer cannot be used as an operand for inline asm\","}, {"sha": "5bc4b566daf67f86a241082c544ba75b90a6444d", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 106, "deletions": 127, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -1,5 +1,5 @@\n-use crate::abi::Size;\n use crate::spec::Target;\n+use crate::{abi::Size, spec::RelocModel};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_macros::HashStable_Generic;\n use rustc_span::Symbol;\n@@ -25,7 +25,7 @@ macro_rules! def_reg_class {\n                 }\n             }\n \n-            pub fn parse(_arch: super::InlineAsmArch, name: rustc_span::Symbol) -> Result<Self, &'static str> {\n+            pub fn parse(name: rustc_span::Symbol) -> Result<Self, &'static str> {\n                 match name {\n                     $(\n                         rustc_span::sym::$class => Ok(Self::$class),\n@@ -79,30 +79,45 @@ macro_rules! def_regs {\n                 }\n             }\n \n-            pub fn parse(\n-                _arch: super::InlineAsmArch,\n-                _target_features: &rustc_data_structures::fx::FxHashSet<Symbol>,\n-                _target: &crate::spec::Target,\n-                _is_clobber: bool,\n-                name: &str,\n-            ) -> Result<Self, &'static str> {\n+            pub fn parse(name: &str) -> Result<Self, &'static str> {\n                 match name {\n                     $(\n-                        $($alias)|* | $reg_name => {\n-                            $($filter(_arch, _target_features, _target, _is_clobber)?;)?\n-                            Ok(Self::$reg)\n-                        }\n+                        $($alias)|* | $reg_name => Ok(Self::$reg),\n                     )*\n                     $(\n                         $($bad_reg)|* => Err($error),\n                     )*\n                     _ => Err(\"unknown register\"),\n                 }\n             }\n+\n+            pub fn validate(self,\n+                _arch: super::InlineAsmArch,\n+                _reloc_model: crate::spec::RelocModel,\n+                _target_features: &rustc_data_structures::fx::FxHashSet<Symbol>,\n+                _target: &crate::spec::Target,\n+                _is_clobber: bool,\n+            ) -> Result<(), &'static str> {\n+                match self {\n+                    $(\n+                        Self::$reg => {\n+                            $($filter(\n+                                _arch,\n+                                _reloc_model,\n+                                _target_features,\n+                                _target,\n+                                _is_clobber\n+                            )?;)?\n+                            Ok(())\n+                        }\n+                    )*\n+                }\n+            }\n         }\n \n         pub(super) fn fill_reg_map(\n             _arch: super::InlineAsmArch,\n+            _reloc_model: crate::spec::RelocModel,\n             _target_features: &rustc_data_structures::fx::FxHashSet<Symbol>,\n             _target: &crate::spec::Target,\n             _map: &mut rustc_data_structures::fx::FxHashMap<\n@@ -113,7 +128,7 @@ macro_rules! def_regs {\n             #[allow(unused_imports)]\n             use super::{InlineAsmReg, InlineAsmRegClass};\n             $(\n-                if $($filter(_arch, _target_features, _target, false).is_ok() &&)? true {\n+                if $($filter(_arch, _reloc_model, _target_features, _target, false).is_ok() &&)? true {\n                     if let Some(set) = _map.get_mut(&InlineAsmRegClass::$arch($arch_regclass::$class)) {\n                         set.insert(InlineAsmReg::$arch($arch_reg::$reg));\n                     }\n@@ -295,94 +310,60 @@ impl InlineAsmReg {\n         }\n     }\n \n-    pub fn parse(\n-        arch: InlineAsmArch,\n-        target_features: &FxHashSet<Symbol>,\n-        target: &Target,\n-        is_clobber: bool,\n-        name: Symbol,\n-    ) -> Result<Self, &'static str> {\n+    pub fn parse(arch: InlineAsmArch, name: Symbol) -> Result<Self, &'static str> {\n         // FIXME: use direct symbol comparison for register names\n         // Use `Symbol::as_str` instead of `Symbol::with` here because `has_feature` may access `Symbol`.\n         let name = name.as_str();\n         Ok(match arch {\n-            InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n-                Self::X86(X86InlineAsmReg::parse(arch, target_features, target, is_clobber, name)?)\n+            InlineAsmArch::X86 | InlineAsmArch::X86_64 => Self::X86(X86InlineAsmReg::parse(name)?),\n+            InlineAsmArch::Arm => Self::Arm(ArmInlineAsmReg::parse(name)?),\n+            InlineAsmArch::AArch64 => Self::AArch64(AArch64InlineAsmReg::parse(name)?),\n+            InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n+                Self::RiscV(RiscVInlineAsmReg::parse(name)?)\n             }\n-            InlineAsmArch::Arm => {\n-                Self::Arm(ArmInlineAsmReg::parse(arch, target_features, target, is_clobber, name)?)\n+            InlineAsmArch::Nvptx64 => Self::Nvptx(NvptxInlineAsmReg::parse(name)?),\n+            InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => {\n+                Self::PowerPC(PowerPCInlineAsmReg::parse(name)?)\n             }\n-            InlineAsmArch::AArch64 => Self::AArch64(AArch64InlineAsmReg::parse(\n-                arch,\n-                target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n-            InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => Self::RiscV(\n-                RiscVInlineAsmReg::parse(arch, target_features, target, is_clobber, name)?,\n-            ),\n-            InlineAsmArch::Nvptx64 => Self::Nvptx(NvptxInlineAsmReg::parse(\n-                arch,\n-                target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n-            InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => Self::PowerPC(\n-                PowerPCInlineAsmReg::parse(arch, target_features, target, is_clobber, name)?,\n-            ),\n-            InlineAsmArch::Hexagon => Self::Hexagon(HexagonInlineAsmReg::parse(\n-                arch,\n-                target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n-            InlineAsmArch::Mips | InlineAsmArch::Mips64 => Self::Mips(MipsInlineAsmReg::parse(\n-                arch,\n-                target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n-            InlineAsmArch::S390x => Self::S390x(S390xInlineAsmReg::parse(\n-                arch,\n-                target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n-            InlineAsmArch::SpirV => Self::SpirV(SpirVInlineAsmReg::parse(\n-                arch,\n-                target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n-            InlineAsmArch::Wasm32 | InlineAsmArch::Wasm64 => Self::Wasm(WasmInlineAsmReg::parse(\n-                arch,\n-                target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n-            InlineAsmArch::Bpf => {\n-                Self::Bpf(BpfInlineAsmReg::parse(arch, target_features, target, is_clobber, name)?)\n+            InlineAsmArch::Hexagon => Self::Hexagon(HexagonInlineAsmReg::parse(name)?),\n+            InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n+                Self::Mips(MipsInlineAsmReg::parse(name)?)\n             }\n-            InlineAsmArch::Avr => {\n-                Self::Avr(AvrInlineAsmReg::parse(arch, target_features, target, is_clobber, name)?)\n+            InlineAsmArch::S390x => Self::S390x(S390xInlineAsmReg::parse(name)?),\n+            InlineAsmArch::SpirV => Self::SpirV(SpirVInlineAsmReg::parse(name)?),\n+            InlineAsmArch::Wasm32 | InlineAsmArch::Wasm64 => {\n+                Self::Wasm(WasmInlineAsmReg::parse(name)?)\n             }\n-            InlineAsmArch::Msp430 => Self::Msp430(Msp430InlineAsmReg::parse(\n-                arch,\n-                target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n+            InlineAsmArch::Bpf => Self::Bpf(BpfInlineAsmReg::parse(name)?),\n+            InlineAsmArch::Avr => Self::Avr(AvrInlineAsmReg::parse(name)?),\n+            InlineAsmArch::Msp430 => Self::Msp430(Msp430InlineAsmReg::parse(name)?),\n         })\n     }\n \n+    pub fn validate(\n+        self,\n+        arch: InlineAsmArch,\n+        reloc_model: RelocModel,\n+        target_features: &FxHashSet<Symbol>,\n+        target: &Target,\n+        is_clobber: bool,\n+    ) -> Result<(), &'static str> {\n+        match self {\n+            Self::X86(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::Arm(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::AArch64(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::RiscV(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::PowerPC(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::Hexagon(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::Mips(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::S390x(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::Bpf(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::Avr(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::Msp430(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::Err => unreachable!(),\n+        }\n+    }\n+\n     // NOTE: This function isn't used at the moment, but is needed to support\n     // falling back to an external assembler.\n     pub fn emit(\n@@ -584,29 +565,29 @@ impl InlineAsmRegClass {\n     pub fn parse(arch: InlineAsmArch, name: Symbol) -> Result<Self, &'static str> {\n         Ok(match arch {\n             InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n-                Self::X86(X86InlineAsmRegClass::parse(arch, name)?)\n+                Self::X86(X86InlineAsmRegClass::parse(name)?)\n             }\n-            InlineAsmArch::Arm => Self::Arm(ArmInlineAsmRegClass::parse(arch, name)?),\n-            InlineAsmArch::AArch64 => Self::AArch64(AArch64InlineAsmRegClass::parse(arch, name)?),\n+            InlineAsmArch::Arm => Self::Arm(ArmInlineAsmRegClass::parse(name)?),\n+            InlineAsmArch::AArch64 => Self::AArch64(AArch64InlineAsmRegClass::parse(name)?),\n             InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n-                Self::RiscV(RiscVInlineAsmRegClass::parse(arch, name)?)\n+                Self::RiscV(RiscVInlineAsmRegClass::parse(name)?)\n             }\n-            InlineAsmArch::Nvptx64 => Self::Nvptx(NvptxInlineAsmRegClass::parse(arch, name)?),\n+            InlineAsmArch::Nvptx64 => Self::Nvptx(NvptxInlineAsmRegClass::parse(name)?),\n             InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => {\n-                Self::PowerPC(PowerPCInlineAsmRegClass::parse(arch, name)?)\n+                Self::PowerPC(PowerPCInlineAsmRegClass::parse(name)?)\n             }\n-            InlineAsmArch::Hexagon => Self::Hexagon(HexagonInlineAsmRegClass::parse(arch, name)?),\n+            InlineAsmArch::Hexagon => Self::Hexagon(HexagonInlineAsmRegClass::parse(name)?),\n             InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n-                Self::Mips(MipsInlineAsmRegClass::parse(arch, name)?)\n+                Self::Mips(MipsInlineAsmRegClass::parse(name)?)\n             }\n-            InlineAsmArch::S390x => Self::S390x(S390xInlineAsmRegClass::parse(arch, name)?),\n-            InlineAsmArch::SpirV => Self::SpirV(SpirVInlineAsmRegClass::parse(arch, name)?),\n+            InlineAsmArch::S390x => Self::S390x(S390xInlineAsmRegClass::parse(name)?),\n+            InlineAsmArch::SpirV => Self::SpirV(SpirVInlineAsmRegClass::parse(name)?),\n             InlineAsmArch::Wasm32 | InlineAsmArch::Wasm64 => {\n-                Self::Wasm(WasmInlineAsmRegClass::parse(arch, name)?)\n+                Self::Wasm(WasmInlineAsmRegClass::parse(name)?)\n             }\n-            InlineAsmArch::Bpf => Self::Bpf(BpfInlineAsmRegClass::parse(arch, name)?),\n-            InlineAsmArch::Avr => Self::Avr(AvrInlineAsmRegClass::parse(arch, name)?),\n-            InlineAsmArch::Msp430 => Self::Msp430(Msp430InlineAsmRegClass::parse(arch, name)?),\n+            InlineAsmArch::Bpf => Self::Bpf(BpfInlineAsmRegClass::parse(name)?),\n+            InlineAsmArch::Avr => Self::Avr(AvrInlineAsmRegClass::parse(name)?),\n+            InlineAsmArch::Msp430 => Self::Msp430(Msp430InlineAsmRegClass::parse(name)?),\n         })\n     }\n \n@@ -749,78 +730,79 @@ impl fmt::Display for InlineAsmType {\n // falling back to an external assembler.\n pub fn allocatable_registers(\n     arch: InlineAsmArch,\n+    reloc_model: RelocModel,\n     target_features: &FxHashSet<Symbol>,\n     target: &crate::spec::Target,\n ) -> FxHashMap<InlineAsmRegClass, FxHashSet<InlineAsmReg>> {\n     match arch {\n         InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n             let mut map = x86::regclass_map();\n-            x86::fill_reg_map(arch, target_features, target, &mut map);\n+            x86::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Arm => {\n             let mut map = arm::regclass_map();\n-            arm::fill_reg_map(arch, target_features, target, &mut map);\n+            arm::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::AArch64 => {\n             let mut map = aarch64::regclass_map();\n-            aarch64::fill_reg_map(arch, target_features, target, &mut map);\n+            aarch64::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n             let mut map = riscv::regclass_map();\n-            riscv::fill_reg_map(arch, target_features, target, &mut map);\n+            riscv::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Nvptx64 => {\n             let mut map = nvptx::regclass_map();\n-            nvptx::fill_reg_map(arch, target_features, target, &mut map);\n+            nvptx::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => {\n             let mut map = powerpc::regclass_map();\n-            powerpc::fill_reg_map(arch, target_features, target, &mut map);\n+            powerpc::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Hexagon => {\n             let mut map = hexagon::regclass_map();\n-            hexagon::fill_reg_map(arch, target_features, target, &mut map);\n+            hexagon::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n             let mut map = mips::regclass_map();\n-            mips::fill_reg_map(arch, target_features, target, &mut map);\n+            mips::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::S390x => {\n             let mut map = s390x::regclass_map();\n-            s390x::fill_reg_map(arch, target_features, target, &mut map);\n+            s390x::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::SpirV => {\n             let mut map = spirv::regclass_map();\n-            spirv::fill_reg_map(arch, target_features, target, &mut map);\n+            spirv::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Wasm32 | InlineAsmArch::Wasm64 => {\n             let mut map = wasm::regclass_map();\n-            wasm::fill_reg_map(arch, target_features, target, &mut map);\n+            wasm::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Bpf => {\n             let mut map = bpf::regclass_map();\n-            bpf::fill_reg_map(arch, target_features, target, &mut map);\n+            bpf::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Avr => {\n             let mut map = avr::regclass_map();\n-            avr::fill_reg_map(arch, target_features, target, &mut map);\n+            avr::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Msp430 => {\n             let mut map = msp430::regclass_map();\n-            msp430::fill_reg_map(arch, target_features, target, &mut map);\n+            msp430::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n     }\n@@ -853,7 +835,6 @@ impl InlineAsmClobberAbi {\n     /// clobber ABIs for the target.\n     pub fn parse(\n         arch: InlineAsmArch,\n-        target_features: &FxHashSet<Symbol>,\n         target: &Target,\n         name: Symbol,\n     ) -> Result<Self, &'static [&'static str]> {\n@@ -877,13 +858,11 @@ impl InlineAsmClobberAbi {\n                 _ => Err(&[\"C\", \"system\", \"efiapi\", \"aapcs\"]),\n             },\n             InlineAsmArch::AArch64 => match name {\n-                \"C\" | \"system\" | \"efiapi\" => {\n-                    Ok(if aarch64::reserved_x18(arch, target_features, target, true).is_err() {\n-                        InlineAsmClobberAbi::AArch64NoX18\n-                    } else {\n-                        InlineAsmClobberAbi::AArch64\n-                    })\n-                }\n+                \"C\" | \"system\" | \"efiapi\" => Ok(if aarch64::target_reserves_x18(target) {\n+                    InlineAsmClobberAbi::AArch64NoX18\n+                } else {\n+                    InlineAsmClobberAbi::AArch64\n+                }),\n                 _ => Err(&[\"C\", \"system\", \"efiapi\"]),\n             },\n             InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => match name {"}, {"sha": "987bf9705293338c6a28c3d0f195a3158347ca6a", "filename": "compiler/rustc_target/src/asm/riscv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_target%2Fsrc%2Fasm%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_target%2Fsrc%2Fasm%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Friscv.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -1,5 +1,5 @@\n use super::{InlineAsmArch, InlineAsmType};\n-use crate::spec::Target;\n+use crate::spec::{RelocModel, Target};\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::{sym, Symbol};\n@@ -54,6 +54,7 @@ impl RiscVInlineAsmRegClass {\n \n fn not_e(\n     _arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n     _is_clobber: bool,"}, {"sha": "7c136a475486b63eb835a2e3bdac065f6204f54a", "filename": "compiler/rustc_target/src/asm/x86.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -1,5 +1,5 @@\n use super::{InlineAsmArch, InlineAsmType};\n-use crate::spec::Target;\n+use crate::spec::{RelocModel, Target};\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::Symbol;\n@@ -139,6 +139,7 @@ impl X86InlineAsmRegClass {\n \n fn x86_64_only(\n     arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     _target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n     _is_clobber: bool,\n@@ -152,6 +153,7 @@ fn x86_64_only(\n \n fn high_byte(\n     arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     _target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n     _is_clobber: bool,\n@@ -164,6 +166,7 @@ fn high_byte(\n \n fn rbx_reserved(\n     arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     _target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n     _is_clobber: bool,\n@@ -179,6 +182,7 @@ fn rbx_reserved(\n \n fn esi_reserved(\n     arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     _target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n     _is_clobber: bool,"}, {"sha": "3213148f6a3dcd72f6308c8674f24ea295a62f09", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -1485,27 +1485,38 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (self.tcx.mk_mut_ref(self.tcx.lifetimes.re_erased, rcvr_ty), \"&mut \"),\n                 (self.tcx.mk_imm_ref(self.tcx.lifetimes.re_erased, rcvr_ty), \"&\"),\n             ] {\n-                if let Ok(pick) = self.lookup_probe(\n+                match self.lookup_probe(\n                     span,\n                     item_name,\n                     *rcvr_ty,\n                     rcvr,\n                     crate::check::method::probe::ProbeScope::AllTraits,\n                 ) {\n-                    // If the method is defined for the receiver we have, it likely wasn't `use`d.\n-                    // We point at the method, but we just skip the rest of the check for arbitrary\n-                    // self types and rely on the suggestion to `use` the trait from\n-                    // `suggest_valid_traits`.\n-                    let did = Some(pick.item.container.id());\n-                    let skip = skippable.contains(&did);\n-                    if pick.autoderefs == 0 && !skip {\n-                        err.span_label(\n-                            pick.item.ident(self.tcx).span,\n-                            &format!(\"the method is available for `{}` here\", rcvr_ty),\n-                        );\n+                    Ok(pick) => {\n+                        // If the method is defined for the receiver we have, it likely wasn't `use`d.\n+                        // We point at the method, but we just skip the rest of the check for arbitrary\n+                        // self types and rely on the suggestion to `use` the trait from\n+                        // `suggest_valid_traits`.\n+                        let did = Some(pick.item.container.id());\n+                        let skip = skippable.contains(&did);\n+                        if pick.autoderefs == 0 && !skip {\n+                            err.span_label(\n+                                pick.item.ident(self.tcx).span,\n+                                &format!(\"the method is available for `{}` here\", rcvr_ty),\n+                            );\n+                        }\n+                        break;\n                     }\n-                    break;\n+                    Err(MethodError::Ambiguity(_)) => {\n+                        // If the method is defined (but ambiguous) for the receiver we have, it is also\n+                        // likely we haven't `use`d it. It may be possible that if we `Box`/`Pin`/etc.\n+                        // the receiver, then it might disambiguate this method, but I think these\n+                        // suggestions are generally misleading (see #94218).\n+                        break;\n+                    }\n+                    _ => {}\n                 }\n+\n                 for (rcvr_ty, pre) in &[\n                     (self.tcx.mk_lang_item(*rcvr_ty, LangItem::OwnedBox), \"Box::new\"),\n                     (self.tcx.mk_lang_item(*rcvr_ty, LangItem::Pin), \"Pin::new\"),"}, {"sha": "392144ca7639c81799e6a9d5b53b0ef7d29fad3e", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-filelength\n //! \"Collection\" is the process of determining the type and other external\n //! details of each item in Rust. Collection is specifically concerned\n //! with *inter-procedural* things -- for example, for a function\n@@ -87,6 +88,7 @@ pub fn provide(providers: &mut Providers) {\n         static_mutability,\n         generator_kind,\n         codegen_fn_attrs,\n+        asm_target_features,\n         collect_mod_item_types,\n         should_inherit_track_caller,\n         ..*providers\n@@ -3255,6 +3257,24 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     codegen_fn_attrs\n }\n \n+/// Computes the set of target features used in a function for the purposes of\n+/// inline assembly.\n+fn asm_target_features<'tcx>(tcx: TyCtxt<'tcx>, id: DefId) -> &'tcx FxHashSet<Symbol> {\n+    let mut target_features = tcx.sess.target_features.clone();\n+    let attrs = tcx.codegen_fn_attrs(id);\n+    target_features.extend(&attrs.target_features);\n+    match attrs.instruction_set {\n+        None => {}\n+        Some(InstructionSetAttr::ArmA32) => {\n+            target_features.remove(&sym::thumb_mode);\n+        }\n+        Some(InstructionSetAttr::ArmT32) => {\n+            target_features.insert(sym::thumb_mode);\n+        }\n+    }\n+    tcx.arena.alloc(target_features)\n+}\n+\n /// Checks if the provided DefId is a method in a trait impl for a trait which has track_caller\n /// applied to the method prototype.\n fn should_inherit_track_caller(tcx: TyCtxt<'_>, def_id: DefId) -> bool {"}, {"sha": "0b6cdb923bd6a11d367d048bbb4d7db7d4a66e76", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -384,11 +384,8 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     if let Ok(path) = crate::fs::read_link(\"/proc/self/path/a.out\") {\n         Ok(path)\n     } else {\n-        extern \"C\" {\n-            fn getexecname() -> *const c_char;\n-        }\n         unsafe {\n-            let path = getexecname();\n+            let path = libc::getexecname();\n             if path.is_null() {\n                 Err(io::Error::last_os_error())\n             } else {"}, {"sha": "e64f5e8af52384a2de783a8d0d848a1d804ddd04", "filename": "src/test/ui/asm/issue-85247.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Fasm%2Fissue-85247.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Fasm%2Fissue-85247.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fissue-85247.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -0,0 +1,26 @@\n+// revisions: ropi rwpi\n+\n+// [ropi] compile-flags: --target armv7-unknown-linux-gnueabihf -C relocation-model=ropi\n+// [rwpi] compile-flags: --target armv7-unknown-linux-gnueabihf -C relocation-model=rwpi\n+// [ropi] needs-llvm-components: arm\n+// [rwpi] needs-llvm-components: arm\n+// [ropi] build-pass\n+\n+#![feature(no_core, lang_items, rustc_attrs)]\n+#![no_core]\n+#![crate_type = \"rlib\"]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[lang = \"sized\"]\n+trait Sized {}\n+\n+// R9 is reserved as the RWPI base register\n+fn main() {\n+    unsafe {\n+        asm!(\"\", out(\"r9\") _);\n+        //[rwpi]~^ cannot use register `r9`\n+    }\n+}"}, {"sha": "996b0933a34122bfeca371fc039977b33c29bb9c", "filename": "src/test/ui/asm/issue-85247.rwpi.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Fasm%2Fissue-85247.rwpi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Fasm%2Fissue-85247.rwpi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fissue-85247.rwpi.stderr?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -0,0 +1,8 @@\n+error: cannot use register `r9`: the RWPI static base register (r9) cannot be used as an operand for inline asm\n+  --> $DIR/issue-85247.rs:23:18\n+   |\n+LL |         asm!(\"\", out(\"r9\") _);\n+   |                  ^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "d595e88ff80c5d6536641408aaa3eb6946983adc", "filename": "src/test/ui/asm/issue-92378.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Fasm%2Fissue-92378.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Fasm%2Fissue-92378.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fissue-92378.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -0,0 +1,30 @@\n+// compile-flags: --target armv5te-unknown-linux-gnueabi\n+// needs-llvm-components: arm\n+// build-pass\n+\n+#![feature(no_core, lang_items, rustc_attrs, isa_attribute)]\n+#![no_core]\n+#![crate_type = \"rlib\"]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[lang = \"sized\"]\n+trait Sized {}\n+\n+// ARM uses R11 for the frame pointer, make sure R7 is usable.\n+#[instruction_set(arm::a32)]\n+pub fn arm() {\n+    unsafe {\n+        asm!(\"\", out(\"r7\") _);\n+    }\n+}\n+\n+// Thumb uses R7 for the frame pointer, make sure R11 is usable.\n+#[instruction_set(arm::t32)]\n+pub fn thumb() {\n+    unsafe {\n+        asm!(\"\", out(\"r11\") _);\n+    }\n+}"}, {"sha": "4c4ce8b5e9e493ecd6f22fcc9bd70a9d036b4038", "filename": "src/test/ui/asm/x86_64/bad-reg.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -31,8 +31,6 @@ fn main() {\n         //~^ ERROR invalid register `ip`: the instruction pointer cannot be used as an operand\n         asm!(\"\", in(\"k0\") foo);\n         //~^ ERROR invalid register `k0`: the k0 AVX mask register cannot be used as an operand\n-        asm!(\"\", in(\"ah\") foo);\n-        //~^ ERROR invalid register `ah`: high byte registers cannot be used as an operand\n \n         asm!(\"\", in(\"st(2)\") foo);\n         //~^ ERROR register class `x87_reg` can only be used as a clobber, not as an input or output"}, {"sha": "f8b024e1acd62c3b7d8891d4cc80ce558a312f63", "filename": "src/test/ui/asm/x86_64/bad-reg.stderr", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.stderr?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -70,91 +70,85 @@ error: invalid register `k0`: the k0 AVX mask register cannot be used as an oper\n LL |         asm!(\"\", in(\"k0\") foo);\n    |                  ^^^^^^^^^^^^\n \n-error: invalid register `ah`: high byte registers cannot be used as an operand on x86_64\n-  --> $DIR/bad-reg.rs:34:18\n-   |\n-LL |         asm!(\"\", in(\"ah\") foo);\n-   |                  ^^^^^^^^^^^^\n-\n error: register class `x87_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:37:18\n+  --> $DIR/bad-reg.rs:35:18\n    |\n LL |         asm!(\"\", in(\"st(2)\") foo);\n    |                  ^^^^^^^^^^^^^^^\n \n error: register class `mmx_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:39:18\n+  --> $DIR/bad-reg.rs:37:18\n    |\n LL |         asm!(\"\", in(\"mm0\") foo);\n    |                  ^^^^^^^^^^^^^\n \n error: register class `x87_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:43:20\n+  --> $DIR/bad-reg.rs:41:20\n    |\n LL |         asm!(\"{}\", in(x87_reg) foo);\n    |                    ^^^^^^^^^^^^^^^\n \n error: register class `mmx_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:45:20\n+  --> $DIR/bad-reg.rs:43:20\n    |\n LL |         asm!(\"{}\", in(mmx_reg) foo);\n    |                    ^^^^^^^^^^^^^^^\n \n error: register class `x87_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:47:20\n+  --> $DIR/bad-reg.rs:45:20\n    |\n LL |         asm!(\"{}\", out(x87_reg) _);\n    |                    ^^^^^^^^^^^^^^\n \n error: register class `mmx_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:49:20\n+  --> $DIR/bad-reg.rs:47:20\n    |\n LL |         asm!(\"{}\", out(mmx_reg) _);\n    |                    ^^^^^^^^^^^^^^\n \n error: register `al` conflicts with register `ax`\n-  --> $DIR/bad-reg.rs:55:33\n+  --> $DIR/bad-reg.rs:53:33\n    |\n LL |         asm!(\"\", in(\"eax\") foo, in(\"al\") bar);\n    |                  -------------  ^^^^^^^^^^^^ register `al`\n    |                  |\n    |                  register `ax`\n \n error: register `ax` conflicts with register `ax`\n-  --> $DIR/bad-reg.rs:57:33\n+  --> $DIR/bad-reg.rs:55:33\n    |\n LL |         asm!(\"\", in(\"rax\") foo, out(\"rax\") bar);\n    |                  -------------  ^^^^^^^^^^^^^^ register `ax`\n    |                  |\n    |                  register `ax`\n    |\n help: use `lateout` instead of `out` to avoid conflict\n-  --> $DIR/bad-reg.rs:57:18\n+  --> $DIR/bad-reg.rs:55:18\n    |\n LL |         asm!(\"\", in(\"rax\") foo, out(\"rax\") bar);\n    |                  ^^^^^^^^^^^^^\n \n error: register `ymm0` conflicts with register `xmm0`\n-  --> $DIR/bad-reg.rs:60:34\n+  --> $DIR/bad-reg.rs:58:34\n    |\n LL |         asm!(\"\", in(\"xmm0\") foo, in(\"ymm0\") bar);\n    |                  --------------  ^^^^^^^^^^^^^^ register `ymm0`\n    |                  |\n    |                  register `xmm0`\n \n error: register `ymm0` conflicts with register `xmm0`\n-  --> $DIR/bad-reg.rs:62:34\n+  --> $DIR/bad-reg.rs:60:34\n    |\n LL |         asm!(\"\", in(\"xmm0\") foo, out(\"ymm0\") bar);\n    |                  --------------  ^^^^^^^^^^^^^^^ register `ymm0`\n    |                  |\n    |                  register `xmm0`\n    |\n help: use `lateout` instead of `out` to avoid conflict\n-  --> $DIR/bad-reg.rs:62:18\n+  --> $DIR/bad-reg.rs:60:18\n    |\n LL |         asm!(\"\", in(\"xmm0\") foo, out(\"ymm0\") bar);\n    |                  ^^^^^^^^^^^^^^\n \n-error: aborting due to 21 previous errors\n+error: aborting due to 20 previous errors\n "}, {"sha": "39f4c9060fea539e82a3b6bbdbbc2a1af9481c7d", "filename": "src/test/ui/let-else/let-else-allow-in-expr.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Flet-else%2Flet-else-allow-in-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Flet-else%2Flet-else-allow-in-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-allow-in-expr.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -0,0 +1,30 @@\n+#![feature(let_else)]\n+\n+#![deny(unused_variables)]\n+\n+fn main() {\n+    let Some(_): Option<u32> = ({\n+        let x = 1; //~ ERROR unused variable: `x`\n+        Some(1)\n+    }) else {\n+        return;\n+    };\n+\n+    #[allow(unused_variables)]\n+    let Some(_): Option<u32> = ({\n+        let x = 1;\n+        Some(1)\n+    }) else {\n+        return;\n+    };\n+\n+    let Some(_): Option<u32> = ({\n+        #[allow(unused_variables)]\n+        let x = 1;\n+        Some(1)\n+    }) else {\n+        return;\n+    };\n+\n+    let x = 1; //~ ERROR unused variable: `x`\n+}"}, {"sha": "e86bcbc850029ee1c1d404401778aa41331c3413", "filename": "src/test/ui/let-else/let-else-allow-in-expr.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Flet-else%2Flet-else-allow-in-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Flet-else%2Flet-else-allow-in-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-allow-in-expr.stderr?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -0,0 +1,20 @@\n+error: unused variable: `x`\n+  --> $DIR/let-else-allow-in-expr.rs:7:13\n+   |\n+LL |         let x = 1;\n+   |             ^ help: if this is intentional, prefix it with an underscore: `_x`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/let-else-allow-in-expr.rs:3:9\n+   |\n+LL | #![deny(unused_variables)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: unused variable: `x`\n+  --> $DIR/let-else-allow-in-expr.rs:29:9\n+   |\n+LL |     let x = 1;\n+   |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "86ebacfa7b7d1e0660fb58c68414eebb2a4ba156", "filename": "src/test/ui/let-else/let-else-allow-unused.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Flet-else%2Flet-else-allow-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Flet-else%2Flet-else-allow-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-allow-unused.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -1,4 +1,3 @@\n-// check-pass\n // issue #89807\n \n #![feature(let_else)]\n@@ -10,5 +9,7 @@ fn main() {\n     #[allow(unused)]\n     let banana = 1;\n     #[allow(unused)]\n-    let Some(chaenomeles) = value else { return }; // OK\n+    let Some(chaenomeles) = value.clone() else { return }; // OK\n+\n+    let Some(chaenomeles) = value else { return }; //~ ERROR unused variable: `chaenomeles`\n }"}, {"sha": "05b8a9169fb70633b2ae9f8211285ef1a997a0ac", "filename": "src/test/ui/let-else/let-else-allow-unused.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Flet-else%2Flet-else-allow-unused.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Flet-else%2Flet-else-allow-unused.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-allow-unused.stderr?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -0,0 +1,14 @@\n+error: unused variable: `chaenomeles`\n+  --> $DIR/let-else-allow-unused.rs:14:14\n+   |\n+LL |     let Some(chaenomeles) = value else { return };\n+   |              ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_chaenomeles`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/let-else-allow-unused.rs:5:8\n+   |\n+LL | #[deny(unused_variables)]\n+   |        ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "9e32cbef742a2fefdb9c5d4a9d582ef1393dfb30", "filename": "src/test/ui/let-else/let-else-check.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Flet-else%2Flet-else-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Flet-else%2Flet-else-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-check.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -10,5 +10,10 @@ fn main() {\n         return;\n     };\n \n+    let Some(_): Option<u32> = Some(Default::default()) else {\n+        let x = 1; //~ ERROR unused variable: `x`\n+        return;\n+    };\n+\n     let x = 1; //~ ERROR unused variable: `x`\n }"}, {"sha": "b3da412ec280eb46ec11672af0317bede1dd21b8", "filename": "src/test/ui/let-else/let-else-check.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Flet-else%2Flet-else-check.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Flet-else%2Flet-else-check.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-check.stderr?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -1,5 +1,5 @@\n error: unused variable: `x`\n-  --> $DIR/let-else-check.rs:13:9\n+  --> $DIR/let-else-check.rs:18:9\n    |\n LL |     let x = 1;\n    |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n@@ -10,5 +10,11 @@ note: the lint level is defined here\n LL | #![deny(unused_variables)]\n    |         ^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: unused variable: `x`\n+  --> $DIR/let-else-check.rs:14:13\n+   |\n+LL |         let x = 1;\n+   |             ^ help: if this is intentional, prefix it with an underscore: `_x`\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "4022656a8f53dbcebfc64ab715fb1cd39ada538c", "filename": "src/test/ui/let-else/let-else-slicing-error.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Flet-else%2Flet-else-slicing-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Flet-else%2Flet-else-slicing-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-slicing-error.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -0,0 +1,9 @@\n+// issue #92069\n+#![feature(let_else)]\n+\n+fn main() {\n+    let nums = vec![5, 4, 3, 2, 1];\n+    let [x, y] = nums else { //~ ERROR expected an array or slice\n+        return;\n+    };\n+}"}, {"sha": "064025e0345b7c8ebb13a73680cd78403d16a91b", "filename": "src/test/ui/let-else/let-else-slicing-error.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Flet-else%2Flet-else-slicing-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Flet-else%2Flet-else-slicing-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-slicing-error.stderr?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -0,0 +1,11 @@\n+error[E0529]: expected an array or slice, found `Vec<{integer}>`\n+  --> $DIR/let-else-slicing-error.rs:6:9\n+   |\n+LL |     let [x, y] = nums else {\n+   |         ^^^^^^   ---- help: consider slicing here: `nums[..]`\n+   |         |\n+   |         pattern cannot match with input type `Vec<{integer}>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0529`."}, {"sha": "3d21b735aea0a175ac2983370cc844705cbce133", "filename": "src/test/ui/rust-2021/future-prelude-collision-shadow.stderr", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-shadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-shadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-shadow.stderr?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -4,34 +4,8 @@ error[E0599]: no method named `try_into` found for type `u8` in the current scop\n LL |         let _: u32 = 3u8.try_into().unwrap();\n    |                          ^^^^^^^^ method not found in `u8`\n    |\n-  ::: $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-   |\n-LL |     fn try_into(self) -> Result<T, Self::Error>;\n-   |        --------\n-   |        |\n-   |        the method is available for `Box<u8>` here\n-   |        the method is available for `Pin<u8>` here\n-   |        the method is available for `Arc<u8>` here\n-   |        the method is available for `Rc<u8>` here\n-   |\n    = help: items from traits can only be used if the trait is in scope\n    = note: 'std::convert::TryInto' is included in the prelude starting in Edition 2021\n-help: consider wrapping the receiver expression with the appropriate type\n-   |\n-LL |         let _: u32 = Box::new(3u8).try_into().unwrap();\n-   |                      +++++++++   +\n-help: consider wrapping the receiver expression with the appropriate type\n-   |\n-LL |         let _: u32 = Pin::new(3u8).try_into().unwrap();\n-   |                      +++++++++   +\n-help: consider wrapping the receiver expression with the appropriate type\n-   |\n-LL |         let _: u32 = Arc::new(3u8).try_into().unwrap();\n-   |                      +++++++++   +\n-help: consider wrapping the receiver expression with the appropriate type\n-   |\n-LL |         let _: u32 = Rc::new(3u8).try_into().unwrap();\n-   |                      ++++++++   +\n help: the following traits are implemented but not in scope; perhaps add a `use` for one of them:\n    |\n LL |     use crate::m::TryIntoU32;"}, {"sha": "baa2128eb8e36730954872d63dbeb59af1ef63fa", "filename": "src/test/ui/suggestions/dont-wrap-ambiguous-receivers.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Fsuggestions%2Fdont-wrap-ambiguous-receivers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Fsuggestions%2Fdont-wrap-ambiguous-receivers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-wrap-ambiguous-receivers.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -0,0 +1,21 @@\n+mod banana {\n+    //~^ HELP the following traits are implemented but not in scope\n+    pub struct Chaenomeles;\n+\n+    pub trait Apple {\n+        fn pick(&self) {}\n+    }\n+    impl Apple for Chaenomeles {}\n+\n+    pub trait Peach {\n+        fn pick(&self, a: &mut ()) {}\n+    }\n+    impl<Mango: Peach> Peach for Box<Mango> {}\n+    impl Peach for Chaenomeles {}\n+}\n+\n+fn main() {\n+    banana::Chaenomeles.pick()\n+    //~^ ERROR no method named\n+    //~| HELP items from traits can only be used if the trait is in scope\n+}"}, {"sha": "8fcadbf4c75f4455fc7d0bf3cac001a5fac61477", "filename": "src/test/ui/suggestions/dont-wrap-ambiguous-receivers.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Fsuggestions%2Fdont-wrap-ambiguous-receivers.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftest%2Fui%2Fsuggestions%2Fdont-wrap-ambiguous-receivers.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-wrap-ambiguous-receivers.stderr?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -0,0 +1,20 @@\n+error[E0599]: no method named `pick` found for struct `Chaenomeles` in the current scope\n+  --> $DIR/dont-wrap-ambiguous-receivers.rs:18:25\n+   |\n+LL |     pub struct Chaenomeles;\n+   |     ----------------------- method `pick` not found for this\n+...\n+LL |     banana::Chaenomeles.pick()\n+   |                         ^^^^ method not found in `Chaenomeles`\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+help: the following traits are implemented but not in scope; perhaps add a `use` for one of them:\n+   |\n+LL | use banana::Apple;\n+   |\n+LL | use banana::Peach;\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "3f67a64971b678193185769eee00d9eeab0f96e8", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -3753,23 +3753,27 @@ pub struct ProcRes {\n \n impl ProcRes {\n     pub fn print_info(&self) {\n-        print!(\n-            \"\\\n-             status: {}\\n\\\n-             command: {}\\n\\\n-             stdout:\\n\\\n-             ------------------------------------------\\n\\\n-             {}\\n\\\n-             ------------------------------------------\\n\\\n-             stderr:\\n\\\n-             ------------------------------------------\\n\\\n-             {}\\n\\\n-             ------------------------------------------\\n\\\n-             \\n\",\n+        fn render(name: &str, contents: &str) -> String {\n+            let contents = json::extract_rendered(contents);\n+            let contents = contents.trim();\n+            if contents.is_empty() {\n+                format!(\"{name}: none\")\n+            } else {\n+                format!(\n+                    \"\\\n+                     --- {name} -------------------------------\\n\\\n+                     {contents}\\n\\\n+                     ------------------------------------------\",\n+                )\n+            }\n+        }\n+\n+        println!(\n+            \"status: {}\\ncommand: {}\\n{}\\n{}\\n\",\n             self.status,\n             self.cmdline,\n-            json::extract_rendered(&self.stdout),\n-            json::extract_rendered(&self.stderr),\n+            render(\"stdout\", &self.stdout),\n+            render(\"stderr\", &self.stderr),\n         );\n     }\n "}, {"sha": "c197acd4828a143ee57fcd2b38e0578155abcb48", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68369a041cea809a87e5bd80701da90e0e0a4799/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=68369a041cea809a87e5bd80701da90e0e0a4799", "patch": "@@ -395,6 +395,9 @@ pub fn check(path: &Path, bad: &mut bool) {\n                 );\n             };\n             suppressible_tidy_err!(err, skip_file_length, \"\");\n+        } else if lines > (LINES * 7) / 10 {\n+            // Just set it to something that doesn't trigger the \"unneccessarily ignored\" warning.\n+            skip_file_length = Directive::Ignore(true);\n         }\n \n         if let Directive::Ignore(false) = skip_cr {"}]}