{"sha": "0ae1a77a2e336118ceb63121e45014ac0ca3c853", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhZTFhNzdhMmUzMzYxMThjZWI2MzEyMWU0NTAxNGFjMGNhM2M4NTM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-30T08:21:13Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-30T08:21:13Z"}, "message": "Do some additional cleanup around `InternedString` and `Symbol`", "tree": {"sha": "fdae33e099588712ffe0f2b9a5d00b7b4527b5d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdae33e099588712ffe0f2b9a5d00b7b4527b5d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ae1a77a2e336118ceb63121e45014ac0ca3c853", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ae1a77a2e336118ceb63121e45014ac0ca3c853", "html_url": "https://github.com/rust-lang/rust/commit/0ae1a77a2e336118ceb63121e45014ac0ca3c853", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ae1a77a2e336118ceb63121e45014ac0ca3c853/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "html_url": "https://github.com/rust-lang/rust/commit/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd"}], "stats": {"total": 101, "additions": 50, "deletions": 51}, "files": [{"sha": "7093e18454f55ad5d9075426f5378c61332cb963", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=0ae1a77a2e336118ceb63121e45014ac0ca3c853", "patch": "@@ -77,10 +77,10 @@ fn check_lit(cx: &LateContext, lit: &Lit, e: &Expr) {\n }\n \n fn check_known_consts(cx: &LateContext, e: &Expr, s: &symbol::Symbol, module: &str) {\n-    let s = &*s.as_str();\n+    let s = s.as_str();\n     if s.parse::<f64>().is_ok() {\n         for &(constant, name, min_digits) in KNOWN_CONSTS {\n-            if is_approx_const(constant, s, min_digits) {\n+            if is_approx_const(constant, &s, min_digits) {\n                 span_lint(cx,\n                           APPROX_CONSTANT,\n                           e.span,"}, {"sha": "646bcdad5ffb05240d68079b2b8447063f383c3d", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=0ae1a77a2e336118ceb63121e45014ac0ca3c853", "patch": "@@ -237,7 +237,7 @@ fn check_attrs(cx: &LateContext, span: Span, name: &Name, attrs: &[Attribute]) {\n \n fn check_semver(cx: &LateContext, span: Span, lit: &Lit) {\n     if let LitKind::Str(ref is, _) = lit.node {\n-        if Version::parse(&*is.as_str()).is_ok() {\n+        if Version::parse(&is.as_str()).is_ok() {\n             return;\n         }\n     }"}, {"sha": "3713aa0a2051cdbb6df95307521e32a39c295819", "filename": "clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=0ae1a77a2e336118ceb63121e45014ac0ca3c853", "patch": "@@ -40,7 +40,7 @@ impl LintPass for BlackListedName {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlackListedName {\n     fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n         if let PatKind::Binding(_, _, ref ident, _) = pat.node {\n-            if self.blacklist.iter().any(|s| *s == *ident.node.as_str()) {\n+            if self.blacklist.iter().any(|s| ident.node == *s) {\n                 span_lint(cx,\n                           BLACKLISTED_NAME,\n                           pat.span,"}, {"sha": "b869948c324a2861db269370d456c9b9f26a7413", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=0ae1a77a2e336118ceb63121e45014ac0ca3c853", "patch": "@@ -90,7 +90,7 @@ pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [a\n     for attr in attrs {\n         if attr.is_sugared_doc {\n             if let Some(ref doc) = attr.value_str() {\n-                let doc = (*doc.as_str()).to_owned();\n+                let doc = doc.to_string();\n                 docs.extend_from_slice(&strip_doc_comment_decoration((doc, attr.span)));\n             }\n         }"}, {"sha": "860003587bc3f1138375e953e935fa9777fdf20e", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=0ae1a77a2e336118ceb63121e45014ac0ca3c853", "patch": "@@ -85,7 +85,7 @@ fn check_cond<'a, 'tcx, 'b>(\n     if_let_chain! {[\n         let ExprMethodCall(ref name, _, ref params) = check.node,\n         params.len() >= 2,\n-        name.node.as_str() == \"contains_key\",\n+        name.node == \"contains_key\",\n         let ExprAddrOf(_, ref key) = params[1].node\n     ], {\n         let map = &params[0];\n@@ -119,7 +119,7 @@ impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n         if_let_chain! {[\n             let ExprMethodCall(ref name, _, ref params) = expr.node,\n             params.len() == 3,\n-            name.node.as_str() == \"insert\",\n+            name.node == \"insert\",\n             get_item_name(self.cx, self.map) == get_item_name(self.cx, &params[0]),\n             SpanlessEq::new(self.cx).eq_expr(self.key, &params[1])\n         ], {"}, {"sha": "32e02e30b7912a28e83dea47a5a085acd7d7906f", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=0ae1a77a2e336118ceb63121e45014ac0ca3c853", "patch": "@@ -79,7 +79,7 @@ pub fn get_argument_fmtstr_parts<'a, 'b>(cx: &LateContext<'a, 'b>, expr: &'a Exp\n         let StmtDecl(ref decl, _) = block.stmts[0].node,\n         let DeclItem(ref decl) = decl.node,\n         let Some(NodeItem(decl)) = cx.tcx.hir.find(decl.id),\n-        decl.name.as_str() == \"__STATIC_FMTSTR\",\n+        decl.name == \"__STATIC_FMTSTR\",\n         let ItemStatic(_, _, ref expr) = decl.node,\n         let ExprAddrOf(_, ref expr) = cx.tcx.hir.body(*expr).value.node, // &[\"\u2026\", \"\u2026\", \u2026]\n         let ExprArray(ref exprs) = expr.node,"}, {"sha": "3c7b139cbd7a0ce225651e3dce5c4f8fc7724340", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=0ae1a77a2e336118ceb63121e45014ac0ca3c853", "patch": "@@ -89,7 +89,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n \n fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[TraitItemRef]) {\n     fn is_named_self(cx: &LateContext, item: &TraitItemRef, name: &str) -> bool {\n-        *item.name.as_str() == *name &&\n+        item.name == name &&\n         if let AssociatedItemKind::Method { has_self } = item.kind {\n             has_self &&\n             {\n@@ -116,7 +116,7 @@ fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[TraitItemRef]\n \n fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n     fn is_named_self(cx: &LateContext, item: &ImplItemRef, name: &str) -> bool {\n-        *item.name.as_str() == *name &&\n+        item.name == name &&\n         if let AssociatedItemKind::Method { has_self } = item.kind {\n             has_self &&\n             {\n@@ -155,22 +155,22 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str) {\n     // check if we are in an is_empty() method\n     if let Some(name) = get_item_name(cx, left) {\n-        if name.as_str() == \"is_empty\" {\n+        if name == \"is_empty\" {\n             return;\n         }\n     }\n     match (&left.node, &right.node) {\n         (&ExprLit(ref lit), &ExprMethodCall(ref method, _, ref args)) |\n         (&ExprMethodCall(ref method, _, ref args), &ExprLit(ref lit)) => {\n-            check_len_zero(cx, span, &method.node, args, lit, op)\n+            check_len_zero(cx, span, method.node, args, lit, op)\n         },\n         _ => (),\n     }\n }\n \n-fn check_len_zero(cx: &LateContext, span: Span, name: &Name, args: &[Expr], lit: &Lit, op: &str) {\n+fn check_len_zero(cx: &LateContext, span: Span, name: Name, args: &[Expr], lit: &Lit, op: &str) {\n     if let Spanned { node: LitKind::Int(0, _), .. } = *lit {\n-        if name.as_str() == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n+        if name == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n             span_lint_and_then(cx, LEN_ZERO, span, \"length comparison to zero\", |db| {\n                 db.span_suggestion(span,\n                                    \"consider using `is_empty`\",\n@@ -185,7 +185,7 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n     /// Get an `AssociatedItem` and return true if it matches `is_empty(self)`.\n     fn is_is_empty(cx: &LateContext, item: &ty::AssociatedItem) -> bool {\n         if let ty::AssociatedKind::Method = item.kind {\n-            if item.name.as_str() == \"is_empty\" {\n+            if item.name == \"is_empty\" {\n                 let sig = cx.tcx.item_type(item.def_id).fn_sig();\n                 let ty = sig.skip_binder();\n                 ty.inputs().len() == 1"}, {"sha": "1de7e9e47f766f8205fd9c637257b2f07d0f57a2", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=0ae1a77a2e336118ceb63121e45014ac0ca3c853", "patch": "@@ -199,7 +199,7 @@ fn allowed_lts_from(named_lts: &[LifetimeDef]) -> HashSet<RefLt> {\n \n fn lts_from_bounds<'a, T: Iterator<Item = &'a Lifetime>>(mut vec: Vec<RefLt>, bounds_lts: T) -> Vec<RefLt> {\n     for lt in bounds_lts {\n-        if lt.name.as_str() != \"'static\" {\n+        if lt.name != \"'static\" {\n             vec.push(RefLt::Named(lt.name));\n         }\n     }\n@@ -228,7 +228,7 @@ impl<'v, 't> RefVisitor<'v, 't> {\n \n     fn record(&mut self, lifetime: &Option<Lifetime>) {\n         if let Some(ref lt) = *lifetime {\n-            if lt.name.as_str() == \"'static\" {\n+            if lt.name == \"'static\" {\n                 self.lts.push(RefLt::Static);\n             } else if lt.is_elided() {\n                 self.lts.push(RefLt::Unnamed);"}, {"sha": "ff57afb732499f0c67aeec27f2c046db5ce19cef", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=0ae1a77a2e336118ceb63121e45014ac0ca3c853", "patch": "@@ -389,8 +389,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     &ExprMethodCall(method_name, _, ref method_args)) = (pat, &match_expr.node) {\n                 let iter_expr = &method_args[0];\n                 let lhs_constructor = last_path_segment(qpath);\n-                if method_name.node.as_str() == \"next\" && match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n-                   lhs_constructor.name.as_str() == \"Some\" && !is_refutable(cx, &pat_args[0]) &&\n+                if method_name.node == \"next\" && match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n+                   lhs_constructor.name == \"Some\" && !is_refutable(cx, &pat_args[0]) &&\n                    !is_iterator_used_after_while_let(cx, iter_expr) {\n                     let iterator = snippet(cx, method_args[0].span, \"_\");\n                     let loop_var = snippet(cx, pat_args[0].span, \"_\");\n@@ -409,7 +409,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if let ExprMethodCall(ref method, _, ref args) = expr.node {\n-                if args.len() == 1 && method.node.as_str() == \"collect\" &&\n+                if args.len() == 1 && method.node == \"collect\" &&\n                    match_trait_method(cx, expr, &paths::ITERATOR) {\n                     span_lint(cx,\n                               UNUSED_COLLECT,\n@@ -579,7 +579,7 @@ fn is_len_call(expr: &Expr, var: &Name) -> bool {\n     if_let_chain! {[\n         let ExprMethodCall(method, _, ref len_args) = expr.node,\n         len_args.len() == 1,\n-        method.node.as_str() == \"len\",\n+        method.node == \"len\",\n         let ExprPath(QPath::Resolved(_, ref path)) = len_args[0].node,\n         path.segments.len() == 1,\n         path.segments[0].name == *var\n@@ -664,11 +664,11 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n     if let ExprMethodCall(ref method, _, ref args) = arg.node {\n         // just the receiver, no arguments\n         if args.len() == 1 {\n-            let method_name = &*method.node.as_str();\n+            let method_name = method.node.as_str();\n             // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n             if method_name == \"iter\" || method_name == \"iter_mut\" {\n                 if is_ref_iterable_type(cx, &args[0]) {\n-                    lint_iter_method(cx, args, arg, method_name);\n+                    lint_iter_method(cx, args, arg, &method_name);\n                 }\n             } else if method_name == \"into_iter\" && match_trait_method(cx, arg, &paths::INTO_ITERATOR) {\n                 let method_call = ty::MethodCall::expr(arg.id);\n@@ -680,7 +680,7 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n                 let fn_arg_tys = fn_ty.fn_args();\n                 assert_eq!(fn_arg_tys.skip_binder().len(), 1);\n                 if fn_arg_tys.skip_binder()[0].is_region_ptr() {\n-                    lint_iter_method(cx, args, arg, method_name);\n+                    lint_iter_method(cx, args, arg, &method_name);\n                 } else {\n                     let object = snippet(cx, args[0].span, \"_\");\n                     span_lint_and_sugg(cx,"}, {"sha": "f6138a4870eb7abc6a10c4b40d5781ae210288ae", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=0ae1a77a2e336118ceb63121e45014ac0ca3c853", "patch": "@@ -28,7 +28,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // call to .map()\n         if let ExprMethodCall(name, _, ref args) = expr.node {\n-            if name.node.as_str() == \"map\" && args.len() == 2 {\n+            if name.node == \"map\" && args.len() == 2 {\n                 match args[1].node {\n                     ExprClosure(_, ref decl, closure_eid, _) => {\n                         let body = cx.tcx.hir.body(closure_eid);\n@@ -53,7 +53,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                             }\n                             // explicit clone() calls ( .map(|x| x.clone()) )\n                             else if let ExprMethodCall(clone_call, _, ref clone_args) = closure_expr.node {\n-                                if clone_call.node.as_str() == \"clone\" &&\n+                                if clone_call.node == \"clone\" &&\n                                     clone_args.len() == 1 &&\n                                     match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) &&\n                                     expr_eq_name(&clone_args[0], arg_ident)"}, {"sha": "b6f7e2fca1c15b6e5d726f7e3d2e9e34da00e238", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=0ae1a77a2e336118ceb63121e45014ac0ca3c853", "patch": "@@ -607,14 +607,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 lint_or_fun_call(cx, expr, &name.node.as_str(), args);\n \n                 let self_ty = cx.tables.expr_ty_adjusted(&args[0]);\n-                if args.len() == 1 && name.node.as_str() == \"clone\" {\n+                if args.len() == 1 && name.node == \"clone\" {\n                     lint_clone_on_copy(cx, expr, &args[0], self_ty);\n                 }\n \n                 match self_ty.sty {\n                     ty::TyRef(_, ty) if ty.ty.sty == ty::TyStr => {\n                         for &(method, pos) in &PATTERN_METHODS {\n-                            if *name.node.as_str() == *method && args.len() > pos {\n+                            if name.node == method && args.len() > pos {\n                                 lint_single_char_pattern(cx, expr, &args[pos]);\n                             }\n                         }\n@@ -646,7 +646,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         ], {\n             // check missing trait implementations\n             for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n-                if *name.as_str() == *method_name &&\n+                if name == method_name &&\n                    sig.decl.inputs.len() == n_args &&\n                    out_type.matches(&sig.decl.output) &&\n                    self_kind.matches(&first_arg_ty, &first_arg, &self_ty, false) {\n@@ -683,7 +683,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             }\n \n             let ret_ty = return_ty(cx, implitem.id);\n-            if name.as_str() == \"new\" &&\n+            if name == \"new\" &&\n                !ret_ty.walk().any(|t| same_tys(cx, t, ty, implitem.id)) {\n                 span_lint(cx,\n                           NEW_RET_NO_SELF,\n@@ -712,7 +712,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n \n         if name == \"unwrap_or\" {\n             if let hir::ExprPath(ref qpath) = fun.node {\n-                let path: &str = &*last_path_segment(qpath).name.as_str();\n+                let path = &*last_path_segment(qpath).name.as_str();\n \n                 if [\"default\", \"new\"].contains(&path) {\n                     let arg_ty = cx.tables.expr_ty(arg);\n@@ -991,7 +991,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: ty::Ty) -> Option<sug\n     }\n \n     if let hir::ExprMethodCall(name, _, ref args) = expr.node {\n-        if name.node.as_str() == \"iter\" && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n+        if name.node == \"iter\" && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n             sugg::Sugg::hir_opt(cx, &args[0]).map(|sugg| sugg.addr())\n         } else {\n             None\n@@ -1209,7 +1209,7 @@ fn lint_chars_next(cx: &LateContext, expr: &hir::Expr, chain: &hir::Expr, other:\n         arg_char.len() == 1,\n         let hir::ExprPath(ref qpath) = fun.node,\n         let Some(segment) = single_segment_path(qpath),\n-        segment.name.as_str() == \"Some\"\n+        segment.name == \"Some\"\n     ], {\n         let self_ty = walk_ptrs_ty(cx.tables.expr_ty_adjusted(&args[0][0]));\n "}, {"sha": "a029a9c4ddaabe026ba9ca61167fa0927939a9c1", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=0ae1a77a2e336118ceb63121e45014ac0ca3c853", "patch": "@@ -305,7 +305,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                         return;\n                     }\n                     if let Some(name) = get_item_name(cx, expr) {\n-                        let name = &*name.as_str();\n+                        let name = name.as_str();\n                         if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") ||\n                            name.ends_with(\"_eq\") {\n                             return;\n@@ -378,7 +378,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n fn check_nan(cx: &LateContext, path: &Path, expr: &Expr) {\n     if !in_constant(cx, expr.id) {\n-        path.segments.last().map(|seg| if seg.name.as_str() == \"NAN\" {\n+        path.segments.last().map(|seg| if seg.name == \"NAN\" {\n             span_lint(cx,\n                       CMP_NAN,\n                       expr.span,\n@@ -425,7 +425,7 @@ fn is_float(cx: &LateContext, expr: &Expr) -> bool {\n fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: Span) {\n     let (arg_ty, snip) = match expr.node {\n         ExprMethodCall(Spanned { node: ref name, .. }, _, ref args) if args.len() == 1 => {\n-            let name = &*name.as_str();\n+            let name = name.as_str();\n             if name == \"to_string\" || name == \"to_owned\" && is_str_arg(cx, args) {\n                 (cx.tables.expr_ty(&args[0]), snippet(cx, args[0].span, \"..\"))\n             } else {"}, {"sha": "ed495e7e56733d6bdb965a2e8920553a87d06895", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=0ae1a77a2e336118ceb63121e45014ac0ca3c853", "patch": "@@ -65,7 +65,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                     if_let_chain!{[\n                         a.meta_item_list().is_some(),\n                         let Some(name) = a.name(),\n-                        name.as_str() == \"proc_macro_derive\",\n+                        name == \"proc_macro_derive\",\n                     ], {\n                         return;\n                     }}\n@@ -141,7 +141,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                         match_type(cx, ty, &paths::VEC),\n                         let TyPath(QPath::Resolved(_, ref path)) = input.node,\n                         let Some(elem_ty) = path.segments.iter()\n-                            .find(|seg| seg.name.as_str() == \"Vec\")\n+                            .find(|seg| seg.name == \"Vec\")\n                             .map(|ps| ps.parameters.types()[0]),\n                     ], {\n                         let slice_ty = format!(\"&[{}]\", snippet(cx, elem_ty.span, \"_\"));"}, {"sha": "2040bd7167dfcdd3238562a62a2870d535e3c2f4", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=0ae1a77a2e336118ceb63121e45014ac0ca3c853", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                 // can't be implemented by default\n                 return;\n             }\n-            if decl.inputs.is_empty() && name.as_str() == \"new\" && cx.access_levels.is_reachable(id) {\n+            if decl.inputs.is_empty() && name == \"new\" && cx.access_levels.is_reachable(id) {\n                 let self_ty = cx.tcx\n                     .item_type(cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(id)));\n                 if_let_chain!{["}, {"sha": "b59c32005a345e874e28b38a72461e20bf4c1b3c", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=0ae1a77a2e336118ceb63121e45014ac0ca3c853", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSensical {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprMethodCall(ref name, _, ref arguments) = e.node {\n             let (obj_ty, _) = walk_ptrs_ty_depth(cx.tables.expr_ty(&arguments[0]));\n-            if name.node.as_str() == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n+            if name.node == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n                 get_open_options(cx, &arguments[0], &mut options);\n                 check_open_options(cx, &options, e.span);"}, {"sha": "6989eb79f8e77485d489d47e4ffe05dc0819c2f5", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=0ae1a77a2e336118ceb63121e45014ac0ca3c853", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             trait_ref.path.def.def_id() == cx.tcx.lang_items.eq_trait().unwrap(),\n         ], {\n             for impl_item in impl_items {\n-                if impl_item.name.as_str() == \"ne\" {\n+                if impl_item.name == \"ne\" {\n                     span_lint(cx,\n                               PARTIALEQ_NE_IMPL,\n                               impl_item.span,"}, {"sha": "aa190402f298eb8463a1c392597ab2aa284fca3c", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=0ae1a77a2e336118ceb63121e45014ac0ca3c853", "patch": "@@ -49,7 +49,7 @@ impl LintPass for StepByZero {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StepByZero {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprMethodCall(Spanned { node: ref name, .. }, _, ref args) = expr.node {\n-            let name = &*name.as_str();\n+            let name = name.as_str();\n \n             // Range with step_by(0).\n             if name == \"step_by\" && args.len() == 2 && has_step_by(cx, &args[0]) && is_integer_literal(&args[1], 0) {\n@@ -63,14 +63,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StepByZero {\n                 let zip_arg = &args[1];\n                 if_let_chain! {[\n                     // .iter() call\n-                    let ExprMethodCall( Spanned { node: ref iter_name, .. }, _, ref iter_args ) = *iter,\n-                    iter_name.as_str() == \"iter\",\n+                    let ExprMethodCall( Spanned { node: iter_name, .. }, _, ref iter_args ) = *iter,\n+                    iter_name == \"iter\",\n                     // range expression in .zip() call: 0..x.len()\n                     let Some(higher::Range { start: Some(ref start), end: Some(ref end), .. }) = higher::range(zip_arg),\n                     is_integer_literal(start, 0),\n                     // .len() call\n-                    let ExprMethodCall(Spanned { node: ref len_name, .. }, _, ref len_args) = end.node,\n-                    len_name.as_str() == \"len\" && len_args.len() == 1,\n+                    let ExprMethodCall(Spanned { node: len_name, .. }, _, ref len_args) = end.node,\n+                    len_name == \"len\" && len_args.len() == 1,\n                     // .iter() and .len() called on same Path\n                     let ExprPath(QPath::Resolved(_, ref iter_path)) = iter_args[0].node,\n                     let ExprPath(QPath::Resolved(_, ref len_path)) = len_args[0].node,"}, {"sha": "2808dfd35465a010c69b38a0627e415881200160", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=0ae1a77a2e336118ceb63121e45014ac0ca3c853", "patch": "@@ -203,7 +203,7 @@ fn check_regex(cx: &LateContext, expr: &Expr, utf8: bool) {\n \n     if let ExprLit(ref lit) = expr.node {\n         if let LitKind::Str(ref r, _) = lit.node {\n-            let r = &*r.as_str();\n+            let r = &r.as_str();\n             match builder.parse(r) {\n                 Ok(r) => {\n                     if let Some(repl) = is_trivial_regex(&r) {"}, {"sha": "0e4bf017f3f60190d335b17a05d1fdd0d08fbe81", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=0ae1a77a2e336118ceb63121e45014ac0ca3c853", "patch": "@@ -143,7 +143,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n         use utils::{snippet, in_macro};\n \n         if let ExprMethodCall(ref name, _, ref args) = e.node {\n-            if name.node.as_str() == \"as_bytes\" {\n+            if name.node == \"as_bytes\" {\n                 if let ExprLit(ref lit) = args[0].node {\n                     if let LitKind::Str(ref lit_content, _) = lit.node {\n                         if lit_content.as_str().chars().all(|c| c.is_ascii()) && !in_macro(cx, args[0].span) {"}, {"sha": "c8ceb6be0cc061a412098d323666c57fb030c3db", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=0ae1a77a2e336118ceb63121e45014ac0ca3c853", "patch": "@@ -56,8 +56,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n             },\n \n             hir::ExprMethodCall(ref symbol, _, ref args) => {\n-                let symbol = &*symbol.node.as_str();\n-                match symbol {\n+                match &*symbol.node.as_str() {\n                     \"expect\" | \"unwrap\" | \"unwrap_or\" | \"unwrap_or_else\" => {\n                         check_method_call(cx, &args[0], expr);\n                     },"}, {"sha": "1eed85c9fe0429bf2f6236d9ecebd3ae34a87acc", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae1a77a2e336118ceb63121e45014ac0ca3c853/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=0ae1a77a2e336118ceb63121e45014ac0ca3c853", "patch": "@@ -680,7 +680,7 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n         }\n         if let Some(ref value) = attr.value_str() {\n             if attr.name().map_or(false, |n| n == name) {\n-                if let Ok(value) = FromStr::from_str(&*value.as_str()) {\n+                if let Ok(value) = FromStr::from_str(&value.as_str()) {\n                     attr::mark_used(attr);\n                     f(value)\n                 } else {"}]}