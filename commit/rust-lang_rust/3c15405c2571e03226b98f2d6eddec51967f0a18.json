{"sha": "3c15405c2571e03226b98f2d6eddec51967f0a18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjMTU0MDVjMjU3MWUwMzIyNmI5OGYyZDZlZGRlYzUxOTY3ZjBhMTg=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-01-26T22:16:43Z"}, "committer": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-01-30T18:42:51Z"}, "message": "Add feature gate + tests", "tree": {"sha": "544446df2609b2afcaa16ec39e6d6cd8b369c464", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/544446df2609b2afcaa16ec39e6d6cd8b369c464"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c15405c2571e03226b98f2d6eddec51967f0a18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c15405c2571e03226b98f2d6eddec51967f0a18", "html_url": "https://github.com/rust-lang/rust/commit/3c15405c2571e03226b98f2d6eddec51967f0a18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c15405c2571e03226b98f2d6eddec51967f0a18/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4897a05ebf862f694f8b276e6c540ba30af4326a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4897a05ebf862f694f8b276e6c540ba30af4326a", "html_url": "https://github.com/rust-lang/rust/commit/4897a05ebf862f694f8b276e6c540ba30af4326a"}], "stats": {"total": 116, "additions": 106, "deletions": 10}, "files": [{"sha": "5254c751e6b621b500e1620f320aebda91eb7020", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c15405c2571e03226b98f2d6eddec51967f0a18/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c15405c2571e03226b98f2d6eddec51967f0a18/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=3c15405c2571e03226b98f2d6eddec51967f0a18", "patch": "@@ -237,7 +237,8 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n             s.iter().map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        let tt = quoted::parse(tt.clone().into(), true, sess).pop().unwrap();\n+                        let tt = quoted::parse(tt.clone().into(), true, sess, features, &def.attrs)\n+                            .pop().unwrap();\n                         valid &= check_lhs_nt_follows(sess, features, &def.attrs, &tt);\n                         return tt;\n                     }\n@@ -253,7 +254,8 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n             s.iter().map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        return quoted::parse(tt.clone().into(), false, sess).pop().unwrap();\n+                        return quoted::parse(tt.clone().into(), false, sess, features, &def.attrs)\n+                            .pop().unwrap();\n                     }\n                 }\n                 sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")"}, {"sha": "8e05a6ccc470411db1ec64d494431b4b933c86a2", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 64, "deletions": 8, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3c15405c2571e03226b98f2d6eddec51967f0a18/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c15405c2571e03226b98f2d6eddec51967f0a18/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=3c15405c2571e03226b98f2d6eddec51967f0a18", "patch": "@@ -8,14 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast;\n+use {ast, attr};\n use ext::tt::macro_parser;\n+use feature_gate::{self, emit_feature_err, Features, GateIssue};\n use parse::{token, ParseSess};\n use print::pprust;\n use symbol::keywords;\n use syntax_pos::{BytePos, Span, DUMMY_SP};\n use tokenstream;\n \n+use std::cell::RefCell;\n use std::iter::Peekable;\n use std::rc::Rc;\n \n@@ -179,6 +181,8 @@ pub fn parse(\n     input: tokenstream::TokenStream,\n     expect_matchers: bool,\n     sess: &ParseSess,\n+    features: &RefCell<Features>,\n+    attrs: &[ast::Attribute],\n ) -> Vec<TokenTree> {\n     // Will contain the final collection of `self::TokenTree`\n     let mut result = Vec::new();\n@@ -187,10 +191,9 @@ pub fn parse(\n     // additional trees if need be.\n     let mut trees = input.trees().peekable();\n     while let Some(tree) = trees.next() {\n-        let tree = parse_tree(tree, &mut trees, expect_matchers, sess);\n-\n         // Given the parsed tree, if there is a metavar and we are expecting matchers, actually\n         // parse out the matcher (i.e. in `$id:ident` this would parse the `:` and `ident`).\n+        let tree = parse_tree(tree, &mut trees, expect_matchers, sess, features, attrs);\n         match tree {\n             TokenTree::MetaVar(start_sp, ident) if expect_matchers => {\n                 let span = match trees.next() {\n@@ -244,6 +247,8 @@ fn parse_tree<I>(\n     trees: &mut Peekable<I>,\n     expect_matchers: bool,\n     sess: &ParseSess,\n+    features: &RefCell<Features>,\n+    attrs: &[ast::Attribute],\n ) -> TokenTree\n where\n     I: Iterator<Item = tokenstream::TokenTree>,\n@@ -262,9 +267,9 @@ where\n                     sess.span_diagnostic.span_err(span, &msg);\n                 }\n                 // Parse the contents of the sequence itself\n-                let sequence = parse(delimited.tts.into(), expect_matchers, sess);\n+                let sequence = parse(delimited.tts.into(), expect_matchers, sess, features, attrs);\n                 // Get the Kleene operator and optional separator\n-                let (separator, op) = parse_sep_and_kleene_op(trees, span, sess);\n+                let (separator, op) = parse_sep_and_kleene_op(trees, span, sess, features, attrs);\n                 // Count the number of captured \"names\" (i.e. named metavars)\n                 let name_captures = macro_parser::count_names(&sequence);\n                 TokenTree::Sequence(\n@@ -317,7 +322,7 @@ where\n             span,\n             Rc::new(Delimited {\n                 delim: delimited.delim,\n-                tts: parse(delimited.tts.into(), expect_matchers, sess),\n+                tts: parse(delimited.tts.into(), expect_matchers, sess, features, attrs),\n             }),\n         ),\n     }\n@@ -373,6 +378,8 @@ fn parse_sep_and_kleene_op<I>(\n     input: &mut Peekable<I>,\n     span: Span,\n     sess: &ParseSess,\n+    features: &RefCell<Features>,\n+    attrs: &[ast::Attribute],\n ) -> (Option<token::Token>, KleeneOp)\n where\n     I: Iterator<Item = tokenstream::TokenTree>,\n@@ -401,6 +408,21 @@ where\n                 // (N.B. We need to advance the input iterator.)\n                 match parse_kleene_op(input, span) {\n                     // #2 is a KleeneOp (this is the only valid option) :)\n+                    Ok(Ok(op)) if op == KleeneOp::ZeroOrOne => {\n+                        if !features.borrow().macro_at_most_once_rep\n+                            && !attr::contains_name(attrs, \"allow_internal_unstable\")\n+                        {\n+                            let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n+                            emit_feature_err(\n+                                sess,\n+                                \"macro_at_most_once_rep\",\n+                                span,\n+                                GateIssue::Language,\n+                                explain,\n+                            );\n+                        }\n+                        return (Some(token::Question), op);\n+                    }\n                     Ok(Ok(op)) => return (Some(token::Question), op),\n \n                     // #2 is a random token (this is an error) :(\n@@ -410,6 +432,19 @@ where\n                     Err(span) => span,\n                 }\n             } else {\n+                if !features.borrow().macro_at_most_once_rep\n+                    && !attr::contains_name(attrs, \"allow_internal_unstable\")\n+                {\n+                    let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n+                    emit_feature_err(\n+                        sess,\n+                        \"macro_at_most_once_rep\",\n+                        span,\n+                        GateIssue::Language,\n+                        explain,\n+                    );\n+                }\n+\n                 // #2 is a random tree and #1 is KleeneOp::ZeroOrOne\n                 return (None, op);\n             }\n@@ -418,6 +453,21 @@ where\n         // #1 is a separator followed by #2, a KleeneOp\n         Ok(Err((tok, span))) => match parse_kleene_op(input, span) {\n             // #2 is a KleeneOp :D\n+            Ok(Ok(op)) if op == KleeneOp::ZeroOrOne => {\n+                if !features.borrow().macro_at_most_once_rep\n+                    && !attr::contains_name(attrs, \"allow_internal_unstable\")\n+                {\n+                    let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n+                    emit_feature_err(\n+                        sess,\n+                        \"macro_at_most_once_rep\",\n+                        span,\n+                        GateIssue::Language,\n+                        explain,\n+                    );\n+                }\n+                return (Some(tok), op);\n+            }\n             Ok(Ok(op)) => return (Some(tok), op),\n \n             // #2 is a random token :(\n@@ -431,7 +481,13 @@ where\n         Err(span) => span,\n     };\n \n-    sess.span_diagnostic\n-        .span_err(span, \"expected one of: `*`, `+`, or `?`\");\n+    if !features.borrow().macro_at_most_once_rep\n+        && !attr::contains_name(attrs, \"allow_internal_unstable\")\n+    {\n+        sess.span_diagnostic\n+            .span_err(span, \"expected one of: `*`, `+`, or `?`\");\n+    } else {\n+        sess.span_diagnostic.span_err(span, \"expected `*` or `+`\");\n+    }\n     (None, KleeneOp::ZeroOrMore)\n }"}, {"sha": "9358511018a93778ca50f9ec3fc6bad10238e4d2", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c15405c2571e03226b98f2d6eddec51967f0a18/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c15405c2571e03226b98f2d6eddec51967f0a18/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=3c15405c2571e03226b98f2d6eddec51967f0a18", "patch": "@@ -452,6 +452,11 @@ declare_features! (\n \n     // Allows `#[repr(transparent)]` attribute on newtype structs\n     (active, repr_transparent, \"1.25.0\", Some(43036)),\n+\n+    // Use `?` as the Kleene \"at most one\" operator\n+    // FIXME(mark-i-m): make sure we use the correct issue number when there is\n+    //   a tracking issue...\n+    (active, macro_at_most_once_rep, \"1.25.0\", None),\n );\n \n declare_features! (\n@@ -1250,6 +1255,9 @@ pub const EXPLAIN_PLACEMENT_IN: &'static str =\n pub const EXPLAIN_UNSIZED_TUPLE_COERCION: &'static str =\n     \"Unsized tuple coercion is not stable enough for use and is subject to change\";\n \n+pub const EXPLAIN_MACRO_AT_MOST_ONCE_REP: &'static str =\n+    \"Using the `?` macro Kleene operator for \\\"at most one\\\" repetition is unstable\";\n+\n struct PostExpansionVisitor<'a> {\n     context: &'a Context<'a>,\n }"}, {"sha": "13b2a8e217a42ad1968a7ebc486f39010df0607d", "filename": "src/test/ui/feature-gate-macro_at_most_once_rep.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3c15405c2571e03226b98f2d6eddec51967f0a18/src%2Ftest%2Fui%2Ffeature-gate-macro_at_most_once_rep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c15405c2571e03226b98f2d6eddec51967f0a18/src%2Ftest%2Fui%2Ffeature-gate-macro_at_most_once_rep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-macro_at_most_once_rep.rs?ref=3c15405c2571e03226b98f2d6eddec51967f0a18", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the MSP430 interrupt ABI cannot be used when msp430_interrupt\n+// feature gate is not used.\n+\n+macro_rules! m { ($(a)?) => {} }\n+//~^ ERROR Using the `?` macro Kleene operator for \"at most one\" repetition is unstable\n+\n+fn main() {\n+    m!();\n+}"}, {"sha": "f470399ffefa5b819c5b5a90e795ee1f736bb32f", "filename": "src/test/ui/feature-gate-macro_at_most_once_rep.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3c15405c2571e03226b98f2d6eddec51967f0a18/src%2Ftest%2Fui%2Ffeature-gate-macro_at_most_once_rep.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c15405c2571e03226b98f2d6eddec51967f0a18/src%2Ftest%2Fui%2Ffeature-gate-macro_at_most_once_rep.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-macro_at_most_once_rep.stderr?ref=3c15405c2571e03226b98f2d6eddec51967f0a18", "patch": "@@ -0,0 +1,11 @@\n+error[E0658]: Using the `?` macro Kleene operator for \"at most one\" repetition is unstable\n+  --> $DIR/feature-gate-macro_at_most_once_rep.rs:14:19\n+   |\n+14 | macro_rules! m { ($(a)?) => {} }\n+   |                   ^^^^^\n+   |\n+   = help: add #![feature(macro_at_most_once_rep)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+"}]}