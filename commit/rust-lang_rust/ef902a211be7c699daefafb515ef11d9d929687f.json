{"sha": "ef902a211be7c699daefafb515ef11d9d929687f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmOTAyYTIxMWJlN2M2OTlkYWVmYWZiNTE1ZWYxMWQ5ZDkyOTY4N2Y=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-04-06T18:49:50Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-18T14:11:35Z"}, "message": "when encoding, push MetaData(foo) task on stack\n\nThis lets us determine what was used to construct the metadata.\n\nConflicts:\n\tsrc/librustc_metadata/encoder.rs", "tree": {"sha": "aadc46cf5183f5c495231ac9f35d2d8f888839fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aadc46cf5183f5c495231ac9f35d2d8f888839fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef902a211be7c699daefafb515ef11d9d929687f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef902a211be7c699daefafb515ef11d9d929687f", "html_url": "https://github.com/rust-lang/rust/commit/ef902a211be7c699daefafb515ef11d9d929687f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef902a211be7c699daefafb515ef11d9d929687f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bcdf4c1928bb07beaea0c3b143f8ff2a1b73922", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bcdf4c1928bb07beaea0c3b143f8ff2a1b73922", "html_url": "https://github.com/rust-lang/rust/commit/5bcdf4c1928bb07beaea0c3b143f8ff2a1b73922"}], "stats": {"total": 125, "additions": 71, "deletions": 54}, "files": [{"sha": "9c1bc3324dbbf2d21ce1583e4bf6ebd7f6f87f33", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef902a211be7c699daefafb515ef11d9d929687f/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef902a211be7c699daefafb515ef11d9d929687f/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=ef902a211be7c699daefafb515ef11d9d929687f", "patch": "@@ -22,3 +22,4 @@ pub use self::dep_node::DepNode;\n pub use self::graph::DepGraph;\n pub use self::query::DepGraphQuery;\n pub use self::visit::visit_all_items_in_krate;\n+pub use self::raii::DepTask;"}, {"sha": "54e078a16f0a1269dcacd8cf544cc7dfe2421945", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef902a211be7c699daefafb515ef11d9d929687f/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef902a211be7c699daefafb515ef11d9d929687f/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=ef902a211be7c699daefafb515ef11d9d929687f", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::closure_kind(&cdata, def_id.index)\n     }\n \n-    fn closure_ty(&self, tcx: &TyCtxt<'tcx>, def_id: DefId) -> ty::ClosureTy<'tcx> {\n+    fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::ClosureTy<'tcx> {\n         assert!(!def_id.is_local());\n         self.dep_graph.read(DepNode::MetaData(def_id));\n         let cdata = self.get_crate_data(def_id.krate);"}, {"sha": "8a16a4b4a634f379ab44974a69c4699c4013e44f", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 68, "deletions": 52, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/ef902a211be7c699daefafb515ef11d9d929687f/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef902a211be7c699daefafb515ef11d9d929687f/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=ef902a211be7c699daefafb515ef11d9d929687f", "patch": "@@ -25,6 +25,7 @@ use middle::cstore::{LOCAL_CRATE, InlinedItemRef, LinkMeta, tls};\n use rustc::hir::def;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::dependency_format::Linkage;\n+use rustc::dep_graph::{DepGraph, DepNode, DepTask};\n use rustc::ty::subst;\n use rustc::traits::specialization_graph;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -76,15 +77,23 @@ impl<'a, 'tcx> EncodeContext<'a,'tcx> {\n #[derive(PartialEq, Eq, Hash)]\n pub enum XRef<'tcx> { Predicate(ty::Predicate<'tcx>) }\n \n-struct CrateIndex<'tcx> {\n+struct CrateIndex<'a, 'tcx> {\n+    dep_graph: &'a DepGraph,\n     items: IndexData,\n     xrefs: FnvHashMap<XRef<'tcx>, u32>, // sequentially-assigned\n }\n \n-impl<'tcx> CrateIndex<'tcx> {\n-    fn record(&mut self, id: DefId, rbml_w: &mut Encoder) {\n+impl<'a, 'tcx> CrateIndex<'a, 'tcx> {\n+    /// Records that `id` is being emitted at the current offset.\n+    /// This data is later used to construct the item index in the\n+    /// metadata so we can quickly find the data for a given item.\n+    ///\n+    /// Returns a dep-graph task that you should keep live as long as\n+    /// the data for this item is being emitted.\n+    fn record(&mut self, id: DefId, rbml_w: &mut Encoder) -> DepTask<'a> {\n         let position = rbml_w.mark_stable_position();\n         self.items.record(id, position);\n+        self.dep_graph.in_task(DepNode::MetaData(id))\n     }\n \n     fn add_xref(&mut self, xref: XRef<'tcx>) -> u32 {\n@@ -154,7 +163,7 @@ fn encode_item_variances(rbml_w: &mut Encoder,\n \n fn encode_bounds_and_type_for_item<'a, 'tcx>(rbml_w: &mut Encoder,\n                                              ecx: &EncodeContext<'a, 'tcx>,\n-                                             index: &mut CrateIndex<'tcx>,\n+                                             index: &mut CrateIndex<'a, 'tcx>,\n                                              id: NodeId) {\n     encode_bounds_and_type(rbml_w,\n                            ecx,\n@@ -165,7 +174,7 @@ fn encode_bounds_and_type_for_item<'a, 'tcx>(rbml_w: &mut Encoder,\n \n fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n                                     ecx: &EncodeContext<'a, 'tcx>,\n-                                    index: &mut CrateIndex<'tcx>,\n+                                    index: &mut CrateIndex<'a, 'tcx>,\n                                     scheme: &ty::TypeScheme<'tcx>,\n                                     predicates: &ty::GenericPredicates<'tcx>) {\n     encode_generics(rbml_w, ecx, index,\n@@ -248,7 +257,7 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                       rbml_w: &mut Encoder,\n                                       did: DefId,\n                                       vis: &hir::Visibility,\n-                                      index: &mut CrateIndex<'tcx>) {\n+                                      index: &mut CrateIndex<'a, 'tcx>) {\n     debug!(\"encode_enum_variant_info(did={:?})\", did);\n     let repr_hints = ecx.tcx.lookup_repr_hints(did);\n     let repr_type = ecx.tcx.enum_repr_type(repr_hints.get(0));\n@@ -266,7 +275,7 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             }\n         }\n \n-        index.record(vid, rbml_w);\n+        let _task = index.record(vid, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, vid);\n         encode_family(rbml_w, match variant.kind() {\n@@ -471,11 +480,11 @@ fn encode_item_sort(rbml_w: &mut Encoder, sort: char) {\n fn encode_field<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                           rbml_w: &mut Encoder,\n                           field: ty::FieldDef<'tcx>,\n-                          index: &mut CrateIndex<'tcx>) {\n+                          index: &mut CrateIndex<'a, 'tcx>) {\n     let nm = field.name;\n     let id = ecx.local_id(field.did);\n \n-    index.record(field.did, rbml_w);\n+    let _task = index.record(field.did, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n     debug!(\"encode_field: encoding {} {}\", nm, id);\n     encode_struct_field_family(rbml_w, field.vis);\n@@ -495,12 +504,12 @@ fn encode_info_for_struct_ctor<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                          rbml_w: &mut Encoder,\n                                          name: Name,\n                                          struct_def: &hir::VariantData,\n-                                         index: &mut CrateIndex<'tcx>,\n+                                         index: &mut CrateIndex<'a, 'tcx>,\n                                          struct_id: NodeId) {\n     let ctor_id = struct_def.id();\n     let ctor_def_id = ecx.tcx.map.local_def_id(ctor_id);\n \n-    index.record(ctor_def_id, rbml_w);\n+    let _task = index.record(ctor_def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id_and_key(ecx, rbml_w, ctor_def_id);\n     encode_family(rbml_w, match *struct_def {\n@@ -531,7 +540,7 @@ fn encode_info_for_struct_ctor<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n                              ecx: &EncodeContext<'a, 'tcx>,\n-                             index: &mut CrateIndex<'tcx>,\n+                             index: &mut CrateIndex<'a, 'tcx>,\n                              generics: &ty::Generics<'tcx>,\n                              predicates: &ty::GenericPredicates<'tcx>,\n                              tag: usize)\n@@ -576,7 +585,7 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n \n fn encode_predicates_in_current_doc<'a,'tcx>(rbml_w: &mut Encoder,\n                                              _ecx: &EncodeContext<'a,'tcx>,\n-                                             index: &mut CrateIndex<'tcx>,\n+                                             index: &mut CrateIndex<'a, 'tcx>,\n                                              predicates: &ty::GenericPredicates<'tcx>)\n {\n     for (space, _, predicate) in predicates.predicates.iter_enumerated() {\n@@ -593,7 +602,7 @@ fn encode_predicates_in_current_doc<'a,'tcx>(rbml_w: &mut Encoder,\n \n fn encode_predicates<'a,'tcx>(rbml_w: &mut Encoder,\n                               ecx: &EncodeContext<'a,'tcx>,\n-                              index: &mut CrateIndex<'tcx>,\n+                              index: &mut CrateIndex<'a, 'tcx>,\n                               predicates: &ty::GenericPredicates<'tcx>,\n                               tag: usize)\n {\n@@ -604,7 +613,7 @@ fn encode_predicates<'a,'tcx>(rbml_w: &mut Encoder,\n \n fn encode_method_ty_fields<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                      rbml_w: &mut Encoder,\n-                                     index: &mut CrateIndex<'tcx>,\n+                                     index: &mut CrateIndex<'a, 'tcx>,\n                                      method_ty: &ty::Method<'tcx>) {\n     encode_def_id_and_key(ecx, rbml_w, method_ty.def_id);\n     encode_name(rbml_w, method_ty.name);\n@@ -623,15 +632,15 @@ fn encode_method_ty_fields<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n fn encode_info_for_associated_const<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                               rbml_w: &mut Encoder,\n-                                              index: &mut CrateIndex<'tcx>,\n+                                              index: &mut CrateIndex<'a, 'tcx>,\n                                               associated_const: &ty::AssociatedConst,\n                                               parent_id: NodeId,\n                                               impl_item_opt: Option<&hir::ImplItem>) {\n     debug!(\"encode_info_for_associated_const({:?},{:?})\",\n            associated_const.def_id,\n            associated_const.name);\n \n-    index.record(associated_const.def_id, rbml_w);\n+    let _task = index.record(associated_const.def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n \n     encode_def_id_and_key(ecx, rbml_w, associated_const.def_id);\n@@ -665,15 +674,15 @@ fn encode_info_for_associated_const<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                     rbml_w: &mut Encoder,\n-                                    index: &mut CrateIndex<'tcx>,\n+                                    index: &mut CrateIndex<'a, 'tcx>,\n                                     m: &ty::Method<'tcx>,\n                                     is_default_impl: bool,\n                                     parent_id: NodeId,\n                                     impl_item_opt: Option<&hir::ImplItem>) {\n \n     debug!(\"encode_info_for_method: {:?} {:?}\", m.def_id,\n            m.name);\n-    index.record(m.def_id, rbml_w);\n+    let _task = index.record(m.def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n \n     encode_method_ty_fields(ecx, rbml_w, index, m);\n@@ -717,15 +726,15 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                              rbml_w: &mut Encoder,\n-                                             index: &mut CrateIndex<'tcx>,\n+                                             index: &mut CrateIndex<'a, 'tcx>,\n                                              associated_type: &ty::AssociatedType<'tcx>,\n                                              parent_id: NodeId,\n                                              impl_item_opt: Option<&hir::ImplItem>) {\n     debug!(\"encode_info_for_associated_type({:?},{:?})\",\n            associated_type.def_id,\n            associated_type.name);\n \n-    index.record(associated_type.def_id, rbml_w);\n+    let _task = index.record(associated_type.def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n \n     encode_def_id_and_key(ecx, rbml_w, associated_type.def_id);\n@@ -863,20 +872,23 @@ fn encode_xrefs<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                   rbml_w: &mut Encoder,\n                                   item: &hir::Item,\n-                                  index: &mut CrateIndex<'tcx>) {\n+                                  index: &mut CrateIndex<'a, 'tcx>) {\n     let tcx = ecx.tcx;\n \n     debug!(\"encoding info for item at {}\",\n            tcx.sess.codemap().span_to_string(item.span));\n \n     let vis = &item.vis;\n     let def_id = ecx.tcx.map.local_def_id(item.id);\n-    let stab = tcx.lookup_stability(ecx.tcx.map.local_def_id(item.id));\n-    let depr = tcx.lookup_deprecation(ecx.tcx.map.local_def_id(item.id));\n+\n+    let (stab, depr) = tcx.dep_graph.with_task(DepNode::MetaData(def_id), || {\n+        (tcx.lookup_stability(ecx.tcx.map.local_def_id(item.id)),\n+         tcx.lookup_deprecation(ecx.tcx.map.local_def_id(item.id)))\n+    });\n \n     match item.node {\n       hir::ItemStatic(_, m, _) => {\n-        index.record(def_id, rbml_w);\n+        let _task = index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n         if m == hir::MutMutable {\n@@ -894,7 +906,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         rbml_w.end_tag();\n       }\n       hir::ItemConst(_, _) => {\n-        index.record(def_id, rbml_w);\n+        let _task = index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'C');\n@@ -909,7 +921,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         rbml_w.end_tag();\n       }\n       hir::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n-        index.record(def_id, rbml_w);\n+        let _task = index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, FN_FAMILY);\n@@ -933,7 +945,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         rbml_w.end_tag();\n       }\n       hir::ItemMod(ref m) => {\n-        index.record(def_id, rbml_w);\n+        let _task = index.record(def_id, rbml_w);\n         encode_info_for_mod(ecx,\n                             rbml_w,\n                             m,\n@@ -943,7 +955,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                             &item.vis);\n       }\n       hir::ItemForeignMod(ref fm) => {\n-        index.record(def_id, rbml_w);\n+        let _task = index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'n');\n@@ -960,7 +972,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         rbml_w.end_tag();\n       }\n       hir::ItemTy(..) => {\n-        index.record(def_id, rbml_w);\n+        let _task = index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'y');\n@@ -972,7 +984,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         rbml_w.end_tag();\n       }\n       hir::ItemEnum(ref enum_definition, _) => {\n-        index.record(def_id, rbml_w);\n+        let _task = index.record(def_id, rbml_w);\n \n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n@@ -1003,12 +1015,12 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                  index);\n       }\n       hir::ItemStruct(ref struct_def, _) => {\n+        /* Index the class*/\n+        let _task = index.record(def_id, rbml_w);\n+\n         let def = ecx.tcx.lookup_adt_def(def_id);\n         let variant = def.struct_variant();\n \n-        /* Index the class*/\n-        index.record(def_id, rbml_w);\n-\n         /* Now, make an item for the class itself */\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n@@ -1056,7 +1068,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         }\n       }\n       hir::ItemDefaultImpl(unsafety, _) => {\n-          index.record(def_id, rbml_w);\n+          let _task = index.record(def_id, rbml_w);\n           rbml_w.start_tag(tag_items_data_item);\n           encode_def_id_and_key(ecx, rbml_w, def_id);\n           encode_family(rbml_w, 'd');\n@@ -1068,12 +1080,13 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n           rbml_w.end_tag();\n       }\n       hir::ItemImpl(unsafety, polarity, _, _, _, ref ast_items) => {\n+        let _task = index.record(def_id, rbml_w);\n+\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n         let impl_items = tcx.impl_items.borrow();\n         let items = impl_items.get(&def_id).unwrap();\n \n-        index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'i');\n@@ -1170,7 +1183,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         }\n       }\n       hir::ItemTrait(_, _, _, ref ms) => {\n-        index.record(def_id, rbml_w);\n+        let _task = index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'I');\n@@ -1225,7 +1238,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         for (i, &item_def_id) in r.iter().enumerate() {\n             assert_eq!(item_def_id.def_id().krate, LOCAL_CRATE);\n \n-            index.record(item_def_id.def_id(), rbml_w);\n+            let _task = index.record(item_def_id.def_id(), rbml_w);\n             rbml_w.start_tag(tag_items_data_item);\n \n             encode_parent_item(rbml_w, def_id);\n@@ -1336,12 +1349,12 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                           rbml_w: &mut Encoder,\n                                           nitem: &hir::ForeignItem,\n-                                          index: &mut CrateIndex<'tcx>) {\n+                                          index: &mut CrateIndex<'a, 'tcx>) {\n     debug!(\"writing foreign item {}\", ecx.tcx.node_path_str(nitem.id));\n     let def_id = ecx.tcx.map.local_def_id(nitem.id);\n     let abi = ecx.tcx.map.get_foreign_abi(nitem.id);\n \n-    index.record(def_id, rbml_w);\n+    let _task = index.record(def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id_and_key(ecx, rbml_w, def_id);\n     encode_visibility(rbml_w, &nitem.vis);\n@@ -1390,7 +1403,7 @@ fn my_visit_expr(expr: &hir::Expr,\n         hir::ExprClosure(..) => {\n             let def_id = ecx.tcx.map.local_def_id(expr.id);\n \n-            index.record(def_id, rbml_w);\n+            let _task = index.record(def_id, rbml_w);\n \n             rbml_w.start_tag(tag_items_data_item);\n             encode_def_id_and_key(ecx, rbml_w, def_id);\n@@ -1414,8 +1427,8 @@ fn my_visit_expr(expr: &hir::Expr,\n \n struct EncodeVisitor<'a, 'b:'a, 'c:'a, 'tcx:'c> {\n     rbml_w_for_visit_item: &'a mut Encoder<'b>,\n-    ecx: &'a EncodeContext<'c,'tcx>,\n-    index: &'a mut CrateIndex<'tcx>,\n+    ecx: &'a EncodeContext<'c, 'tcx>,\n+    index: &'a mut CrateIndex<'c, 'tcx>,\n }\n \n impl<'a, 'b, 'c, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n@@ -1435,23 +1448,26 @@ impl<'a, 'b, 'c, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n \n fn encode_info_for_items<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                    rbml_w: &mut Encoder)\n-                                   -> CrateIndex<'tcx> {\n+                                   -> CrateIndex<'a, 'tcx> {\n     let krate = ecx.tcx.map.krate();\n \n     let mut index = CrateIndex {\n+        dep_graph: &ecx.tcx.dep_graph,\n         items: IndexData::new(ecx.tcx.map.num_local_def_ids()),\n         xrefs: FnvHashMap()\n     };\n     rbml_w.start_tag(tag_items_data);\n \n-    index.record(DefId::local(CRATE_DEF_INDEX), rbml_w);\n-    encode_info_for_mod(ecx,\n-                        rbml_w,\n-                        &krate.module,\n-                        &[],\n-                        CRATE_NODE_ID,\n-                        syntax::parse::token::intern(&ecx.link_meta.crate_name),\n-                        &hir::Public);\n+    {\n+        let _task = index.record(DefId::local(CRATE_DEF_INDEX), rbml_w);\n+        encode_info_for_mod(ecx,\n+                            rbml_w,\n+                            &krate.module,\n+                            &[],\n+                            CRATE_NODE_ID,\n+                            syntax::parse::token::intern(&ecx.link_meta.crate_name),\n+                            &hir::Public);\n+    }\n \n     krate.visit_all_items(&mut EncodeVisitor {\n         index: &mut index,"}, {"sha": "b850073462f5a87a2e666825897d236dce6ded35", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef902a211be7c699daefafb515ef11d9d929687f/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef902a211be7c699daefafb515ef11d9d929687f/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=ef902a211be7c699daefafb515ef11d9d929687f", "patch": "@@ -75,7 +75,7 @@ impl IndexData {\n \n     pub fn record(&mut self, def_id: DefId, position: u64) {\n         assert!(def_id.is_local());\n-        self.record_index(def_id.index, position)\n+        self.record_index(def_id.index, position);\n     }\n \n     pub fn record_index(&mut self, item: DefIndex, position: u64) {"}]}