{"sha": "d022013eb74df8a6b915cd144c983ac533589a28", "node_id": "C_kwDOAAsO6NoAKGQwMjIwMTNlYjc0ZGY4YTZiOTE1Y2QxNDRjOTgzYWM1MzM1ODlhMjg", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-22T10:43:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-22T10:43:05Z"}, "message": "Rollup merge of #107102 - compiler-errors:new-solver-new-candidats-4, r=lcnr\n\nImplement some more predicates in the new solver\n\nImplement a few more goals. The subtype goal specifically is important, since it's required for this code to compile:\n\n```\nfn main() {\n  let mut x = vec![];\n  x.push(1i32);\n}\n```\n\n(I think we emit a subtype goal here because of coercion).\n\nDrive-by: Also implements `--compare-mode=next-solver` -- I've been using this locally a lot to find out what works and what doesn't. I'm also happy to split this out into another PR.\n\nr? `@lcnr`", "tree": {"sha": "42990e2d533c75b245e4b3d9f1e89eac6f9d7ba5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42990e2d533c75b245e4b3d9f1e89eac6f9d7ba5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d022013eb74df8a6b915cd144c983ac533589a28", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjzRM5CRBK7hj4Ov3rIwAAFwwIAFuMS0pZ1Sq5jvISlP+h9nwR\nR5792rjNfCEITtuePRki/zFgP7D8PwIRlHN7Z26OvqM8Iigz+GFiAyuiRP11XbwZ\n8kuzphrigRt8juRK9C/sQGGh8fsRvxJ0/5ihp4buwm+plvG+3ciATr15TJwlf9qL\nZi3ku8Mk873Oa5kK9nQUflEvFADBKC/k4F13NPYbW2EgBh8/Kff+P0TbydfNB56e\nrV0RlXBznMpenEGZpE/5ouhmk7ERTETWpBcHogIs6xu8eHmhotmCuzZKcUcFAaxS\n3FTOqM7IlPKIv3+os/x0cwPdkFwRBtYOeAyhnMGIafWAd57GBto54/x5aN42QiA=\n=+w9E\n-----END PGP SIGNATURE-----\n", "payload": "tree 42990e2d533c75b245e4b3d9f1e89eac6f9d7ba5\nparent 940d00f2f64a0d1e11a546c13bd02ae58d699417\nparent 444cbcd729e4b55602fedcaef7fe902316d8ab49\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1674384185 +0100\ncommitter GitHub <noreply@github.com> 1674384185 +0100\n\nRollup merge of #107102 - compiler-errors:new-solver-new-candidats-4, r=lcnr\n\nImplement some more predicates in the new solver\n\nImplement a few more goals. The subtype goal specifically is important, since it's required for this code to compile:\n\n```\nfn main() {\n  let mut x = vec![];\n  x.push(1i32);\n}\n```\n\n(I think we emit a subtype goal here because of coercion).\n\nDrive-by: Also implements `--compare-mode=next-solver` -- I've been using this locally a lot to find out what works and what doesn't. I'm also happy to split this out into another PR.\n\nr? `@lcnr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d022013eb74df8a6b915cd144c983ac533589a28", "html_url": "https://github.com/rust-lang/rust/commit/d022013eb74df8a6b915cd144c983ac533589a28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d022013eb74df8a6b915cd144c983ac533589a28/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "940d00f2f64a0d1e11a546c13bd02ae58d699417", "url": "https://api.github.com/repos/rust-lang/rust/commits/940d00f2f64a0d1e11a546c13bd02ae58d699417", "html_url": "https://github.com/rust-lang/rust/commit/940d00f2f64a0d1e11a546c13bd02ae58d699417"}, {"sha": "444cbcd729e4b55602fedcaef7fe902316d8ab49", "url": "https://api.github.com/repos/rust-lang/rust/commits/444cbcd729e4b55602fedcaef7fe902316d8ab49", "html_url": "https://github.com/rust-lang/rust/commit/444cbcd729e4b55602fedcaef7fe902316d8ab49"}], "stats": {"total": 109, "additions": 91, "deletions": 18}, "files": [{"sha": "cdb72d49834f0101f401660171e102675bfa9e3b", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d022013eb74df8a6b915cd144c983ac533589a28/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d022013eb74df8a6b915cd144c983ac533589a28/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=d022013eb74df8a6b915cd144c983ac533589a28", "patch": "@@ -1,7 +1,7 @@\n //! Code shared by trait and projection goals for candidate assembly.\n \n use super::infcx_ext::InferCtxtExt;\n-use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n+use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::elaborate_predicates;\n@@ -148,9 +148,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         if goal.predicate.self_ty().is_ty_var() {\n             return vec![Candidate {\n                 source: CandidateSource::BuiltinImpl,\n-                result: self\n-                    .make_canonical_response(Certainty::Maybe(MaybeCause::Ambiguity))\n-                    .unwrap(),\n+                result: self.make_canonical_response(Certainty::AMBIGUOUS).unwrap(),\n             }];\n         }\n "}, {"sha": "da2a1a19957e128f491b8a1bbc3b3384da637581", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 76, "deletions": 7, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/d022013eb74df8a6b915cd144c983ac533589a28/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d022013eb74df8a6b915cd144c983ac533589a28/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=d022013eb74df8a6b915cd144c983ac533589a28", "patch": "@@ -19,14 +19,17 @@\n \n use std::mem;\n \n+use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, CanonicalVarKind, CanonicalVarValues};\n use rustc_infer::infer::canonical::{OriginalQueryValues, QueryRegionConstraints, QueryResponse};\n use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::Obligation;\n use rustc_middle::infer::canonical::Certainty as OldCertainty;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_middle::ty::{RegionOutlivesPredicate, ToPredicate, TypeOutlivesPredicate};\n+use rustc_middle::ty::{\n+    CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, ToPredicate, TypeOutlivesPredicate,\n+};\n use rustc_span::DUMMY_SP;\n \n use crate::traits::ObligationCause;\n@@ -87,6 +90,8 @@ pub enum Certainty {\n }\n \n impl Certainty {\n+    pub const AMBIGUOUS: Certainty = Certainty::Maybe(MaybeCause::Ambiguity);\n+\n     /// When proving multiple goals using **AND**, e.g. nested obligations for an impl,\n     /// use this function to unify the certainty of these goals\n     pub fn unify_and(self, other: Certainty) -> Certainty {\n@@ -243,16 +248,28 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => {\n                     self.compute_region_outlives_goal(Goal { param_env, predicate })\n                 }\n+                ty::PredicateKind::Subtype(predicate) => {\n+                    self.compute_subtype_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Coerce(predicate) => {\n+                    self.compute_coerce_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::ClosureKind(def_id, substs, kind) => self\n+                    .compute_closure_kind_goal(Goal {\n+                        param_env,\n+                        predicate: (def_id, substs, kind),\n+                    }),\n+                ty::PredicateKind::Ambiguous => self.make_canonical_response(Certainty::AMBIGUOUS),\n                 // FIXME: implement these predicates :)\n                 ty::PredicateKind::WellFormed(_)\n                 | ty::PredicateKind::ObjectSafe(_)\n-                | ty::PredicateKind::ClosureKind(_, _, _)\n-                | ty::PredicateKind::Subtype(_)\n-                | ty::PredicateKind::Coerce(_)\n                 | ty::PredicateKind::ConstEvaluatable(_)\n-                | ty::PredicateKind::ConstEquate(_, _)\n-                | ty::PredicateKind::TypeWellFormedFromEnv(_)\n-                | ty::PredicateKind::Ambiguous => self.make_canonical_response(Certainty::Yes),\n+                | ty::PredicateKind::ConstEquate(_, _) => {\n+                    self.make_canonical_response(Certainty::Yes)\n+                }\n+                ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n+                    bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n+                }\n             }\n         } else {\n             let kind = self.infcx.replace_bound_vars_with_placeholders(kind);\n@@ -275,6 +292,58 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n     ) -> QueryResult<'tcx> {\n         self.make_canonical_response(Certainty::Yes)\n     }\n+\n+    fn compute_coerce_goal(\n+        &mut self,\n+        goal: Goal<'tcx, CoercePredicate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        self.compute_subtype_goal(Goal {\n+            param_env: goal.param_env,\n+            predicate: SubtypePredicate {\n+                a_is_expected: false,\n+                a: goal.predicate.a,\n+                b: goal.predicate.b,\n+            },\n+        })\n+    }\n+\n+    fn compute_subtype_goal(\n+        &mut self,\n+        goal: Goal<'tcx, SubtypePredicate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        if goal.predicate.a.is_ty_var() && goal.predicate.b.is_ty_var() {\n+            // FIXME: Do we want to register a subtype relation between these vars?\n+            // That won't actually reflect in the query response, so it seems moot.\n+            self.make_canonical_response(Certainty::AMBIGUOUS)\n+        } else {\n+            self.infcx.probe(|_| {\n+                let InferOk { value: (), obligations } = self\n+                    .infcx\n+                    .at(&ObligationCause::dummy(), goal.param_env)\n+                    .sub(goal.predicate.a, goal.predicate.b)?;\n+                self.evaluate_all_and_make_canonical_response(\n+                    obligations.into_iter().map(|pred| pred.into()).collect(),\n+                )\n+            })\n+        }\n+    }\n+\n+    fn compute_closure_kind_goal(\n+        &mut self,\n+        goal: Goal<'tcx, (DefId, ty::SubstsRef<'tcx>, ty::ClosureKind)>,\n+    ) -> QueryResult<'tcx> {\n+        let (_, substs, expected_kind) = goal.predicate;\n+        let found_kind = substs.as_closure().kind_ty().to_opt_closure_kind();\n+\n+        let Some(found_kind) = found_kind else {\n+            return self.make_canonical_response(Certainty::AMBIGUOUS);\n+        };\n+        if found_kind.extends(expected_kind) {\n+            self.make_canonical_response(Certainty::Yes)\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {"}, {"sha": "32e15f03998b3598431b58e417d87938e5cab02d", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d022013eb74df8a6b915cd144c983ac533589a28/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d022013eb74df8a6b915cd144c983ac533589a28/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=d022013eb74df8a6b915cd144c983ac533589a28", "patch": "@@ -3,7 +3,7 @@ use crate::traits::{specialization_graph, translate_substs};\n use super::assembly::{self, Candidate, CandidateSource};\n use super::infcx_ext::InferCtxtExt;\n use super::trait_goals::structural_traits;\n-use super::{Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n+use super::{Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n@@ -229,8 +229,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 goal.predicate.def_id(),\n                 impl_def_id\n             )? else {\n-                let certainty = Certainty::Maybe(MaybeCause::Ambiguity);\n-                return ecx.make_canonical_response(trait_ref_certainty.unify_and(certainty));\n+                return ecx.make_canonical_response(trait_ref_certainty.unify_and(Certainty::AMBIGUOUS));\n             };\n \n             if !assoc_def.item.defaultness(tcx).has_value() {\n@@ -382,7 +381,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 .to_predicate(ecx.tcx());\n             Self::consider_assumption(ecx, goal, pred)\n         } else {\n-            ecx.make_canonical_response(Certainty::Maybe(MaybeCause::Ambiguity))\n+            ecx.make_canonical_response(Certainty::AMBIGUOUS)\n         }\n     }\n "}, {"sha": "4b6d673c999c96fd7dab198e99a3aec327ceba70", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d022013eb74df8a6b915cd144c983ac533589a28/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d022013eb74df8a6b915cd144c983ac533589a28/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=d022013eb74df8a6b915cd144c983ac533589a28", "patch": "@@ -4,7 +4,7 @@ use std::iter;\n \n use super::assembly::{self, Candidate, CandidateSource};\n use super::infcx_ext::InferCtxtExt;\n-use super::{Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n+use super::{Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n@@ -133,7 +133,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         if goal.predicate.self_ty().has_non_region_infer() {\n-            return ecx.make_canonical_response(Certainty::Maybe(MaybeCause::Ambiguity));\n+            return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n         }\n \n         let tcx = ecx.tcx();\n@@ -171,7 +171,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                 .to_predicate(ecx.tcx());\n             Self::consider_assumption(ecx, goal, pred)\n         } else {\n-            ecx.make_canonical_response(Certainty::Maybe(MaybeCause::Ambiguity))\n+            ecx.make_canonical_response(Certainty::AMBIGUOUS)\n         }\n     }\n "}, {"sha": "3676f69b100db0136b8701413a1e15513a634399", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d022013eb74df8a6b915cd144c983ac533589a28/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d022013eb74df8a6b915cd144c983ac533589a28/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=d022013eb74df8a6b915cd144c983ac533589a28", "patch": "@@ -123,6 +123,7 @@ pub enum FailMode {\n pub enum CompareMode {\n     Polonius,\n     Chalk,\n+    NextSolver,\n     SplitDwarf,\n     SplitDwarfSingle,\n }\n@@ -132,6 +133,7 @@ impl CompareMode {\n         match *self {\n             CompareMode::Polonius => \"polonius\",\n             CompareMode::Chalk => \"chalk\",\n+            CompareMode::NextSolver => \"next-solver\",\n             CompareMode::SplitDwarf => \"split-dwarf\",\n             CompareMode::SplitDwarfSingle => \"split-dwarf-single\",\n         }\n@@ -141,6 +143,7 @@ impl CompareMode {\n         match s.as_str() {\n             \"polonius\" => CompareMode::Polonius,\n             \"chalk\" => CompareMode::Chalk,\n+            \"next-solver\" => CompareMode::NextSolver,\n             \"split-dwarf\" => CompareMode::SplitDwarf,\n             \"split-dwarf-single\" => CompareMode::SplitDwarfSingle,\n             x => panic!(\"unknown --compare-mode option: {}\", x),"}, {"sha": "dc30e4bb1bef793171358affe8acb3d156dd0c43", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d022013eb74df8a6b915cd144c983ac533589a28/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d022013eb74df8a6b915cd144c983ac533589a28/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=d022013eb74df8a6b915cd144c983ac533589a28", "patch": "@@ -710,6 +710,7 @@ impl Config {\n             match self.compare_mode {\n                 Some(CompareMode::Polonius) => name == \"compare-mode-polonius\",\n                 Some(CompareMode::Chalk) => name == \"compare-mode-chalk\",\n+                Some(CompareMode::NextSolver) => name == \"compare-mode-next-solver\",\n                 Some(CompareMode::SplitDwarf) => name == \"compare-mode-split-dwarf\",\n                 Some(CompareMode::SplitDwarfSingle) => name == \"compare-mode-split-dwarf-single\",\n                 None => false,"}, {"sha": "51c9a27c83d51cfbb0e7dac0541d66e5ea4b1977", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d022013eb74df8a6b915cd144c983ac533589a28/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d022013eb74df8a6b915cd144c983ac533589a28/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=d022013eb74df8a6b915cd144c983ac533589a28", "patch": "@@ -2030,6 +2030,9 @@ impl<'test> TestCx<'test> {\n             Some(CompareMode::Chalk) => {\n                 rustc.args(&[\"-Ztrait-solver=chalk\"]);\n             }\n+            Some(CompareMode::NextSolver) => {\n+                rustc.args(&[\"-Ztrait-solver=next\"]);\n+            }\n             Some(CompareMode::SplitDwarf) if self.config.target.contains(\"windows\") => {\n                 rustc.args(&[\"-Csplit-debuginfo=unpacked\", \"-Zunstable-options\"]);\n             }"}]}