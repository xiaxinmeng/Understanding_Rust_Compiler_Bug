{"sha": "64bd8c1dc427c8bcd69bed7c240b1f1f38bedbd3", "node_id": "C_kwDOAAsO6NoAKDY0YmQ4YzFkYzQyN2M4YmNkNjliZWQ3YzI0MGIxZjFmMzhiZWRiZDM", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-08-17T19:02:55Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-08-17T19:02:55Z"}, "message": "Make same_type_modulo_infer a proper TypeRelation", "tree": {"sha": "2167162a6159200487f5376637abffdb7b6b9adc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2167162a6159200487f5376637abffdb7b6b9adc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64bd8c1dc427c8bcd69bed7c240b1f1f38bedbd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64bd8c1dc427c8bcd69bed7c240b1f1f38bedbd3", "html_url": "https://github.com/rust-lang/rust/commit/64bd8c1dc427c8bcd69bed7c240b1f1f38bedbd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64bd8c1dc427c8bcd69bed7c240b1f1f38bedbd3/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86c6ebee8fa0a5ad1e18e375113b06bd2849b634", "url": "https://api.github.com/repos/rust-lang/rust/commits/86c6ebee8fa0a5ad1e18e375113b06bd2849b634", "html_url": "https://github.com/rust-lang/rust/commit/86c6ebee8fa0a5ad1e18e375113b06bd2849b634"}], "stats": {"total": 203, "additions": 150, "deletions": 53}, "files": [{"sha": "d55708acc9a9b8b8c4307ad0a3a08bc99d9f4dc6", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 79, "deletions": 53, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/64bd8c1dc427c8bcd69bed7c240b1f1f38bedbd3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bd8c1dc427c8bcd69bed7c240b1f1f38bedbd3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=64bd8c1dc427c8bcd69bed7c240b1f1f38bedbd3", "patch": "@@ -66,6 +66,7 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::Node;\n use rustc_middle::dep_graph::DepContext;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n+use rustc_middle::ty::relate::{self, RelateResult, TypeRelation};\n use rustc_middle::ty::{\n     self, error::TypeError, Binder, List, Region, Subst, Ty, TyCtxt, TypeFoldable,\n     TypeSuperVisitable, TypeVisitable,\n@@ -2660,67 +2661,92 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Float types, respectively). When comparing two ADTs, these rules apply recursively.\n     pub fn same_type_modulo_infer(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         let (a, b) = self.resolve_vars_if_possible((a, b));\n-        match (a.kind(), b.kind()) {\n-            (&ty::Adt(def_a, substs_a), &ty::Adt(def_b, substs_b)) => {\n-                if def_a != def_b {\n-                    return false;\n-                }\n+        SameTypeModuloInfer(self).relate(a, b).is_ok()\n+    }\n+}\n \n-                substs_a\n-                    .types()\n-                    .zip(substs_b.types())\n-                    .all(|(a, b)| self.same_type_modulo_infer(a, b))\n-            }\n-            (&ty::FnDef(did_a, substs_a), &ty::FnDef(did_b, substs_b)) => {\n-                if did_a != did_b {\n-                    return false;\n-                }\n+struct SameTypeModuloInfer<'a, 'tcx>(&'a InferCtxt<'a, 'tcx>);\n \n-                substs_a\n-                    .types()\n-                    .zip(substs_b.types())\n-                    .all(|(a, b)| self.same_type_modulo_infer(a, b))\n-            }\n-            (&ty::Int(_) | &ty::Uint(_), &ty::Infer(ty::InferTy::IntVar(_)))\n+impl<'tcx> TypeRelation<'tcx> for SameTypeModuloInfer<'_, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.0.tcx\n+    }\n+\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        // Unused, only for consts which we treat as always equal\n+        ty::ParamEnv::empty()\n+    }\n+\n+    fn tag(&self) -> &'static str {\n+        \"SameTypeModuloInfer\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    }\n+\n+    fn relate_with_variance<T: relate::Relate<'tcx>>(\n+        &mut self,\n+        _variance: ty::Variance,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n+        a: T,\n+        b: T,\n+    ) -> relate::RelateResult<'tcx, T> {\n+        self.relate(a, b)\n+    }\n+\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        match (a.kind(), b.kind()) {\n+            (ty::Int(_) | ty::Uint(_), ty::Infer(ty::InferTy::IntVar(_)))\n             | (\n-                &ty::Infer(ty::InferTy::IntVar(_)),\n-                &ty::Int(_) | &ty::Uint(_) | &ty::Infer(ty::InferTy::IntVar(_)),\n+                ty::Infer(ty::InferTy::IntVar(_)),\n+                ty::Int(_) | ty::Uint(_) | ty::Infer(ty::InferTy::IntVar(_)),\n             )\n-            | (&ty::Float(_), &ty::Infer(ty::InferTy::FloatVar(_)))\n+            | (ty::Float(_), ty::Infer(ty::InferTy::FloatVar(_)))\n             | (\n-                &ty::Infer(ty::InferTy::FloatVar(_)),\n-                &ty::Float(_) | &ty::Infer(ty::InferTy::FloatVar(_)),\n+                ty::Infer(ty::InferTy::FloatVar(_)),\n+                ty::Float(_) | ty::Infer(ty::InferTy::FloatVar(_)),\n             )\n-            | (&ty::Infer(ty::InferTy::TyVar(_)), _)\n-            | (_, &ty::Infer(ty::InferTy::TyVar(_))) => true,\n-            (&ty::Ref(_, ty_a, mut_a), &ty::Ref(_, ty_b, mut_b)) => {\n-                mut_a == mut_b && self.same_type_modulo_infer(ty_a, ty_b)\n-            }\n-            (&ty::RawPtr(a), &ty::RawPtr(b)) => {\n-                a.mutbl == b.mutbl && self.same_type_modulo_infer(a.ty, b.ty)\n-            }\n-            (&ty::Slice(a), &ty::Slice(b)) => self.same_type_modulo_infer(a, b),\n-            (&ty::Array(a_ty, a_ct), &ty::Array(b_ty, b_ct)) => {\n-                self.same_type_modulo_infer(a_ty, b_ty) && a_ct == b_ct\n-            }\n-            (&ty::Tuple(a), &ty::Tuple(b)) => {\n-                if a.len() != b.len() {\n-                    return false;\n-                }\n-                std::iter::zip(a.iter(), b.iter()).all(|(a, b)| self.same_type_modulo_infer(a, b))\n-            }\n-            (&ty::FnPtr(a), &ty::FnPtr(b)) => {\n-                let a = a.skip_binder().inputs_and_output;\n-                let b = b.skip_binder().inputs_and_output;\n-                if a.len() != b.len() {\n-                    return false;\n-                }\n-                std::iter::zip(a.iter(), b.iter()).all(|(a, b)| self.same_type_modulo_infer(a, b))\n-            }\n-            // FIXME(compiler-errors): This needs to be generalized more\n-            _ => a == b,\n+            | (ty::Infer(ty::InferTy::TyVar(_)), _)\n+            | (_, ty::Infer(ty::InferTy::TyVar(_))) => Ok(a),\n+            (ty::Infer(_), _) | (_, ty::Infer(_)) => Err(TypeError::Mismatch),\n+            _ => relate::super_relate_tys(self, a, b),\n         }\n     }\n+\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        if (a.is_var() && b.is_free_or_static()) || (b.is_var() && a.is_free_or_static()) || a == b\n+        {\n+            Ok(a)\n+        } else {\n+            Err(TypeError::Mismatch)\n+        }\n+    }\n+\n+    fn binders<T>(\n+        &mut self,\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> relate::RelateResult<'tcx, ty::Binder<'tcx, T>>\n+    where\n+        T: relate::Relate<'tcx>,\n+    {\n+        Ok(ty::Binder::dummy(self.relate(a.skip_binder(), b.skip_binder())?))\n+    }\n+\n+    fn consts(\n+        &mut self,\n+        a: ty::Const<'tcx>,\n+        _b: ty::Const<'tcx>,\n+    ) -> relate::RelateResult<'tcx, ty::Const<'tcx>> {\n+        // FIXME(compiler-errors): This could at least do some first-order\n+        // relation\n+        Ok(a)\n+    }\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {"}, {"sha": "0070575f2136ac8e6c4a36ef4ff4fdaaf04806b3", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64bd8c1dc427c8bcd69bed7c240b1f1f38bedbd3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bd8c1dc427c8bcd69bed7c240b1f1f38bedbd3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=64bd8c1dc427c8bcd69bed7c240b1f1f38bedbd3", "patch": "@@ -1617,6 +1617,10 @@ impl<'tcx> Region<'tcx> {\n             _ => self.is_free(),\n         }\n     }\n+\n+    pub fn is_var(self) -> bool {\n+        matches!(self.kind(), ty::ReVar(_))\n+    }\n }\n \n /// Type utilities"}, {"sha": "5599cd410baadd8e734d6d0e48120b4ea0b48b27", "filename": "src/test/ui/implied-bounds/issue-100690.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/64bd8c1dc427c8bcd69bed7c240b1f1f38bedbd3/src%2Ftest%2Fui%2Fimplied-bounds%2Fissue-100690.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bd8c1dc427c8bcd69bed7c240b1f1f38bedbd3/src%2Ftest%2Fui%2Fimplied-bounds%2Fissue-100690.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimplied-bounds%2Fissue-100690.rs?ref=64bd8c1dc427c8bcd69bed7c240b1f1f38bedbd3", "patch": "@@ -0,0 +1,45 @@\n+// This code (probably) _should_ compile, but it currently does not because we\n+// are not smart enough about implied bounds.\n+\n+use std::io;\n+\n+fn real_dispatch<T, F>(f: F) -> Result<(), io::Error>\n+//~^ NOTE required by a bound in this\n+where\n+    F: FnOnce(&mut UIView<T>) -> Result<(), io::Error> + Send + 'static,\n+    //~^ NOTE required by this bound in `real_dispatch`\n+    //~| NOTE required by a bound in `real_dispatch`\n+{\n+    todo!()\n+}\n+\n+#[derive(Debug)]\n+struct UIView<'a, T: 'a> {\n+    _phantom: std::marker::PhantomData<&'a mut T>,\n+}\n+\n+trait Handle<'a, T: 'a, V, R> {\n+    fn dispatch<F>(&self, f: F) -> Result<(), io::Error>\n+    where\n+        F: FnOnce(&mut V) -> R + Send + 'static;\n+}\n+\n+#[derive(Debug, Clone)]\n+struct TUIHandle<T> {\n+    _phantom: std::marker::PhantomData<T>,\n+}\n+\n+impl<'a, T: 'a> Handle<'a, T, UIView<'a, T>, Result<(), io::Error>> for TUIHandle<T> {\n+    fn dispatch<F>(&self, f: F) -> Result<(), io::Error>\n+    where\n+        F: FnOnce(&mut UIView<'a, T>) -> Result<(), io::Error> + Send + 'static,\n+    {\n+        real_dispatch(f)\n+        //~^ ERROR expected a `FnOnce<(&mut UIView<'_, T>,)>` closure, found `F`\n+        //~| NOTE expected an `FnOnce<(&mut UIView<'_, T>,)>` closure, found `F`\n+        //~| NOTE expected a closure with arguments\n+        //~| NOTE required by a bound introduced by this call\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "3f6af70d8ed932fce4fe851280ec6b46ddc90469", "filename": "src/test/ui/implied-bounds/issue-100690.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/64bd8c1dc427c8bcd69bed7c240b1f1f38bedbd3/src%2Ftest%2Fui%2Fimplied-bounds%2Fissue-100690.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64bd8c1dc427c8bcd69bed7c240b1f1f38bedbd3/src%2Ftest%2Fui%2Fimplied-bounds%2Fissue-100690.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimplied-bounds%2Fissue-100690.stderr?ref=64bd8c1dc427c8bcd69bed7c240b1f1f38bedbd3", "patch": "@@ -0,0 +1,22 @@\n+error[E0277]: expected a `FnOnce<(&mut UIView<'_, T>,)>` closure, found `F`\n+  --> $DIR/issue-100690.rs:37:23\n+   |\n+LL |         real_dispatch(f)\n+   |         ------------- ^ expected an `FnOnce<(&mut UIView<'_, T>,)>` closure, found `F`\n+   |         |\n+   |         required by a bound introduced by this call\n+   |\n+   = note: expected a closure with arguments `(&mut UIView<'a, T>,)`\n+              found a closure with arguments `(&mut UIView<'_, T>,)`\n+note: required by a bound in `real_dispatch`\n+  --> $DIR/issue-100690.rs:9:8\n+   |\n+LL | fn real_dispatch<T, F>(f: F) -> Result<(), io::Error>\n+   |    ------------- required by a bound in this\n+...\n+LL |     F: FnOnce(&mut UIView<T>) -> Result<(), io::Error> + Send + 'static,\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `real_dispatch`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}