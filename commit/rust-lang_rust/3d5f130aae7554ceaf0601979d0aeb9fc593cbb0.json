{"sha": "3d5f130aae7554ceaf0601979d0aeb9fc593cbb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkNWYxMzBhYWU3NTU0Y2VhZjA2MDE5NzlkMGFlYjlmYzU5M2NiYjA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-21T19:10:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-21T19:10:40Z"}, "message": "Rollup merge of #72347 - xliiv:72340-impl-for-default, r=GuillaumeGomez\n\nMake intra-link resolve links for both trait and impl items\n\nCloses #72340", "tree": {"sha": "bc556752e24e0e6a7e91dab5266f70b755db3900", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc556752e24e0e6a7e91dab5266f70b755db3900"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d5f130aae7554ceaf0601979d0aeb9fc593cbb0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJextIwCRBK7hj4Ov3rIwAAdHIIAFGc5rYV0v26719wwzrJQQGj\nN1h+uL7LzQq4h+ElXdCpiou0LzFr+hWDFz7QQ1psJK6XmrH0XRQUH/D1uP2k0nwd\nek9C3O9Tsq7Bl5jvY0Xd8qSlZI66VIAyiR8dt0V+plAquxNhADQpCToi+/2EgADJ\ns3m8/jCz/GahYyArRdRJtjqdZwtADUVsJPtCw+il6W41uBOQWKswzMSNH6FIjBxj\niaUdi67mwdjS7cvM7d1H1WTfmCHApb8xFq5Ta80lIt0Ws+DaVq6PNBgYOGz2Cw+6\nlRQH9l+ZVXG5ohHMElHRQLGz1/qGCmI5YP9qlBhyaXrjKUwCJFwbxlpnnEcKzDM=\n=N/Pq\n-----END PGP SIGNATURE-----\n", "payload": "tree bc556752e24e0e6a7e91dab5266f70b755db3900\nparent dc65fd4f6a56f9c88d60bae036e69fa9126cf0e0\nparent fc4c9a6c7f27dc4cc68d8b2afe77e88a29ff8a31\nauthor Ralf Jung <post@ralfj.de> 1590088240 +0200\ncommitter GitHub <noreply@github.com> 1590088240 +0200\n\nRollup merge of #72347 - xliiv:72340-impl-for-default, r=GuillaumeGomez\n\nMake intra-link resolve links for both trait and impl items\n\nCloses #72340\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d5f130aae7554ceaf0601979d0aeb9fc593cbb0", "html_url": "https://github.com/rust-lang/rust/commit/3d5f130aae7554ceaf0601979d0aeb9fc593cbb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d5f130aae7554ceaf0601979d0aeb9fc593cbb0/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc65fd4f6a56f9c88d60bae036e69fa9126cf0e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc65fd4f6a56f9c88d60bae036e69fa9126cf0e0", "html_url": "https://github.com/rust-lang/rust/commit/dc65fd4f6a56f9c88d60bae036e69fa9126cf0e0"}, {"sha": "fc4c9a6c7f27dc4cc68d8b2afe77e88a29ff8a31", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc4c9a6c7f27dc4cc68d8b2afe77e88a29ff8a31", "html_url": "https://github.com/rust-lang/rust/commit/fc4c9a6c7f27dc4cc68d8b2afe77e88a29ff8a31"}], "stats": {"total": 80, "additions": 54, "deletions": 26}, "files": [{"sha": "05f3b598ecdf4d1d672b0f4bc3641c4f0024b839", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3d5f130aae7554ceaf0601979d0aeb9fc593cbb0/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5f130aae7554ceaf0601979d0aeb9fc593cbb0/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=3d5f130aae7554ceaf0601979d0aeb9fc593cbb0", "patch": "@@ -232,37 +232,46 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     DefKind::Struct | DefKind::Union | DefKind::Enum | DefKind::TyAlias,\n                     did,\n                 ) => {\n-                    // We need item's parent to know if it's\n-                    // trait impl or struct/enum/etc impl\n-                    let item_parent = item_opt\n+                    // Checks if item_name belongs to `impl SomeItem`\n+                    let impl_item = cx\n+                        .tcx\n+                        .inherent_impls(did)\n+                        .iter()\n+                        .flat_map(|imp| cx.tcx.associated_items(*imp).in_definition_order())\n+                        .find(|item| item.ident.name == item_name);\n+                    let trait_item = item_opt\n                         .and_then(|item| self.cx.as_local_hir_id(item.def_id))\n                         .and_then(|item_hir| {\n+                            // Checks if item_name belongs to `impl SomeTrait for SomeItem`\n                             let parent_hir = self.cx.tcx.hir().get_parent_item(item_hir);\n-                            self.cx.tcx.hir().find(parent_hir)\n+                            let item_parent = self.cx.tcx.hir().find(parent_hir);\n+                            match item_parent {\n+                                Some(hir::Node::Item(hir::Item {\n+                                    kind: hir::ItemKind::Impl { of_trait: Some(_), self_ty, .. },\n+                                    ..\n+                                })) => cx\n+                                    .tcx\n+                                    .associated_item_def_ids(self_ty.hir_id.owner)\n+                                    .iter()\n+                                    .map(|child| {\n+                                        let associated_item = cx.tcx.associated_item(*child);\n+                                        associated_item\n+                                    })\n+                                    .find(|child| child.ident.name == item_name),\n+                                _ => None,\n+                            }\n                         });\n-                    let item = match item_parent {\n-                        Some(hir::Node::Item(hir::Item {\n-                            kind: hir::ItemKind::Impl { of_trait: Some(_), self_ty, .. },\n-                            ..\n-                        })) => {\n-                            // trait impl\n-                            cx.tcx\n-                                .associated_item_def_ids(self_ty.hir_id.owner)\n-                                .iter()\n-                                .map(|child| {\n-                                    let associated_item = cx.tcx.associated_item(*child);\n-                                    associated_item\n-                                })\n-                                .find(|child| child.ident.name == item_name)\n-                        }\n-                        _ => {\n-                            // struct/enum/etc. impl\n-                            cx.tcx\n-                                .inherent_impls(did)\n-                                .iter()\n-                                .flat_map(|imp| cx.tcx.associated_items(*imp).in_definition_order())\n-                                .find(|item| item.ident.name == item_name)\n+                    let item = match (impl_item, trait_item) {\n+                        (Some(from_impl), Some(_)) => {\n+                            // Although it's ambiguous, return impl version for compat. sake.\n+                            // To handle that properly resolve() would have to support\n+                            // something like\n+                            // [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n+                            Some(from_impl)\n                         }\n+                        (None, Some(from_trait)) => Some(from_trait),\n+                        (Some(from_impl), None) => Some(from_impl),\n+                        _ => None,\n                     };\n \n                     if let Some(item) = item {"}, {"sha": "6ed3bfbe3e54bdcd64f54c9d89bdb4ebe39f43bc", "filename": "src/test/rustdoc/issue-72340.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3d5f130aae7554ceaf0601979d0aeb9fc593cbb0/src%2Ftest%2Frustdoc%2Fissue-72340.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5f130aae7554ceaf0601979d0aeb9fc593cbb0/src%2Ftest%2Frustdoc%2Fissue-72340.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-72340.rs?ref=3d5f130aae7554ceaf0601979d0aeb9fc593cbb0", "patch": "@@ -0,0 +1,19 @@\n+#![crate_name = \"foo\"]\n+\n+pub struct Body;\n+\n+impl Body {\n+    pub fn empty() -> Self {\n+        Body\n+    }\n+\n+}\n+\n+impl Default for Body {\n+    // @has foo/struct.Body.html '//a/@href' '../foo/struct.Body.html#method.empty'\n+\n+    /// Returns [`Body::empty()`](Body::empty).\n+    fn default() -> Body {\n+        Body::empty()\n+    }\n+}"}]}