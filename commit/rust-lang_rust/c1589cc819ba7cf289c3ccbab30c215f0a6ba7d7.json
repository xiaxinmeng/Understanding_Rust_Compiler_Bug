{"sha": "c1589cc819ba7cf289c3ccbab30c215f0a6ba7d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNTg5Y2M4MTliYTdjZjI4OWMzY2NiYWIzMGMyMTVmMGE2YmE3ZDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-15T07:42:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-15T07:42:13Z"}, "message": "Auto merge of #76684 - jyn514:refactor-intra-links, r=manishearth\n\nRefactor intra doc link code\n\nI got tired of `fold_item` being 500 lines long.\nThis is best reviewed one commit at a time with whitespace changes hidden.\nThere are no logic changes other than the last commit making a parameter checked by the caller instead of the callee.\n\nr? `@Manishearth`", "tree": {"sha": "ffdeed3b3cc3dfc4b388eb4a4b60ec91578f5ab1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffdeed3b3cc3dfc4b388eb4a4b60ec91578f5ab1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1589cc819ba7cf289c3ccbab30c215f0a6ba7d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1589cc819ba7cf289c3ccbab30c215f0a6ba7d7", "html_url": "https://github.com/rust-lang/rust/commit/c1589cc819ba7cf289c3ccbab30c215f0a6ba7d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1589cc819ba7cf289c3ccbab30c215f0a6ba7d7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cae28165f0450fd3f100374b26841e458b8cfef", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cae28165f0450fd3f100374b26841e458b8cfef", "html_url": "https://github.com/rust-lang/rust/commit/6cae28165f0450fd3f100374b26841e458b8cfef"}, {"sha": "8a13fc494d4365e57d8f343219f0201458b68591", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a13fc494d4365e57d8f343219f0201458b68591", "html_url": "https://github.com/rust-lang/rust/commit/8a13fc494d4365e57d8f343219f0201458b68591"}], "stats": {"total": 1290, "additions": 659, "deletions": 631}, "files": [{"sha": "5a9eeec4dfec334566f2fa407431dad8f77e7667", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 659, "deletions": 631, "changes": 1290, "blob_url": "https://github.com/rust-lang/rust/blob/c1589cc819ba7cf289c3ccbab30c215f0a6ba7d7/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1589cc819ba7cf289c3ccbab30c215f0a6ba7d7/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=c1589cc819ba7cf289c3ccbab30c215f0a6ba7d7", "patch": "@@ -217,7 +217,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 let kind = if let Some(intermediate) = self.check_full_res(\n                     TypeNS,\n                     &intermediate_path,\n-                    Some(module_id),\n+                    module_id,\n                     current_item,\n                     extra_fragment,\n                 ) {\n@@ -235,7 +235,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn macro_resolve(\n         &self,\n         path_str: &'a str,\n-        parent_id: Option<DefId>,\n+        module_id: DefId,\n     ) -> Result<Res, ResolutionFailure<'a>> {\n         let cx = self.cx;\n         let path = ast::Path::from_ident(Ident::from_str(path_str));\n@@ -254,28 +254,23 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             if let Some(res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n                 return Some(Ok(res.map_id(|_| panic!(\"unexpected id\"))));\n             }\n-            if let Some(module_id) = parent_id {\n-                debug!(\"resolving {} as a macro in the module {:?}\", path_str, module_id);\n-                if let Ok((_, res)) =\n-                    resolver.resolve_str_path_error(DUMMY_SP, path_str, MacroNS, module_id)\n-                {\n-                    // don't resolve builtins like `#[derive]`\n-                    if let Res::Def(..) = res {\n-                        let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n-                        return Some(Ok(res));\n-                    }\n+            debug!(\"resolving {} as a macro in the module {:?}\", path_str, module_id);\n+            if let Ok((_, res)) =\n+                resolver.resolve_str_path_error(DUMMY_SP, path_str, MacroNS, module_id)\n+            {\n+                // don't resolve builtins like `#[derive]`\n+                if let Res::Def(..) = res {\n+                    let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n+                    return Some(Ok(res));\n                 }\n-            } else {\n-                debug!(\"attempting to resolve item without parent module: {}\", path_str);\n-                return Some(Err(ResolutionFailure::NoParentItem));\n             }\n             None\n         })\n         // This weird control flow is so we don't borrow the resolver more than once at a time\n         .unwrap_or_else(|| {\n             let mut split = path_str.rsplitn(2, \"::\");\n             if let Some((parent, base)) = split.next().and_then(|x| Some((split.next()?, x))) {\n-                if let Some(res) = self.check_full_res(TypeNS, parent, parent_id, &None, &None) {\n+                if let Some(res) = self.check_full_res(TypeNS, parent, module_id, &None, &None) {\n                     return Err(if matches!(res, Res::PrimTy(_)) {\n                         ResolutionFailure::NoPrimitiveAssocItem {\n                             res,\n@@ -287,306 +282,282 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     });\n                 }\n             }\n-            Err(ResolutionFailure::NotInScope {\n-                module_id: parent_id.expect(\"already saw `Some` when resolving as a macro\"),\n-                name: path_str.into(),\n-            })\n+            Err(ResolutionFailure::NotInScope { module_id, name: path_str.into() })\n         })\n     }\n+\n     /// Resolves a string as a path within a particular namespace. Also returns an optional\n     /// URL fragment in the case of variants and methods.\n     fn resolve<'path>(\n         &self,\n         path_str: &'path str,\n         ns: Namespace,\n         current_item: &Option<String>,\n-        parent_id: Option<DefId>,\n+        module_id: DefId,\n         extra_fragment: &Option<String>,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n         let cx = self.cx;\n \n-        // In case we're in a module, try to resolve the relative path.\n-        if let Some(module_id) = parent_id {\n-            let result = cx.enter_resolver(|resolver| {\n-                resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n-            });\n-            debug!(\"{} resolved to {:?} in namespace {:?}\", path_str, result, ns);\n-            let result = match result {\n-                Ok((_, Res::Err)) => Err(()),\n-                x => x,\n-            };\n+        let result = cx.enter_resolver(|resolver| {\n+            resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n+        });\n+        debug!(\"{} resolved to {:?} in namespace {:?}\", path_str, result, ns);\n+        let result = match result {\n+            Ok((_, Res::Err)) => Err(()),\n+            x => x,\n+        };\n \n-            if let Ok((_, res)) = result {\n-                let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n-                // In case this is a trait item, skip the\n-                // early return and try looking for the trait.\n-                let value = match res {\n-                    Res::Def(DefKind::AssocFn | DefKind::AssocConst, _) => true,\n-                    Res::Def(DefKind::AssocTy, _) => false,\n-                    Res::Def(DefKind::Variant, _) => {\n-                        return handle_variant(cx, res, extra_fragment);\n-                    }\n-                    // Not a trait item; just return what we found.\n-                    Res::PrimTy(..) => {\n-                        if extra_fragment.is_some() {\n-                            return Err(ErrorKind::AnchorFailure(\n-                                AnchorFailure::RustdocAnchorConflict(res),\n-                            ));\n-                        }\n-                        return Ok((res, Some(path_str.to_owned())));\n-                    }\n-                    Res::Def(DefKind::Mod, _) => {\n-                        return Ok((res, extra_fragment.clone()));\n-                    }\n-                    _ => {\n-                        return Ok((res, extra_fragment.clone()));\n+        if let Ok((_, res)) = result {\n+            let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n+            // In case this is a trait item, skip the\n+            // early return and try looking for the trait.\n+            let value = match res {\n+                Res::Def(DefKind::AssocFn | DefKind::AssocConst, _) => true,\n+                Res::Def(DefKind::AssocTy, _) => false,\n+                Res::Def(DefKind::Variant, _) => {\n+                    return handle_variant(cx, res, extra_fragment);\n+                }\n+                // Not a trait item; just return what we found.\n+                Res::PrimTy(..) => {\n+                    if extra_fragment.is_some() {\n+                        return Err(ErrorKind::AnchorFailure(\n+                            AnchorFailure::RustdocAnchorConflict(res),\n+                        ));\n                     }\n-                };\n-\n-                if value != (ns == ValueNS) {\n-                    return Err(ResolutionFailure::WrongNamespace(res, ns).into());\n+                    return Ok((res, Some(path_str.to_owned())));\n+                }\n+                Res::Def(DefKind::Mod, _) => {\n+                    return Ok((res, extra_fragment.clone()));\n                 }\n-            } else if let Some((path, prim)) = is_primitive(path_str, ns) {\n-                if extra_fragment.is_some() {\n-                    return Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(\n-                        prim,\n-                    )));\n+                _ => {\n+                    return Ok((res, extra_fragment.clone()));\n                 }\n-                return Ok((prim, Some(path.to_owned())));\n+            };\n+\n+            if value != (ns == ValueNS) {\n+                return Err(ResolutionFailure::WrongNamespace(res, ns).into());\n             }\n+        } else if let Some((path, prim)) = is_primitive(path_str, ns) {\n+            if extra_fragment.is_some() {\n+                return Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(prim)));\n+            }\n+            return Ok((prim, Some(path.to_owned())));\n+        }\n \n-            // Try looking for methods and associated items.\n-            let mut split = path_str.rsplitn(2, \"::\");\n-            // this can be an `unwrap()` because we ensure the link is never empty\n-            let item_name = Symbol::intern(split.next().unwrap());\n-            let path_root = split\n-                .next()\n-                .map(|f| {\n-                    if f == \"self\" || f == \"Self\" {\n-                        if let Some(name) = current_item.as_ref() {\n-                            return name.clone();\n-                        }\n-                    }\n-                    f.to_owned()\n-                })\n-                // If there's no `::`, it's not an associated item.\n-                // So we can be sure that `rustc_resolve` was accurate when it said it wasn't resolved.\n-                .ok_or_else(|| {\n-                    debug!(\"found no `::`, assumming {} was correctly not in scope\", item_name);\n-                    ResolutionFailure::NotInScope { module_id, name: item_name.to_string().into() }\n-                })?;\n-\n-            if let Some((path, prim)) = is_primitive(&path_root, TypeNS) {\n-                let impls = primitive_impl(cx, &path)\n-                    .ok_or_else(|| ResolutionFailure::NoPrimitiveImpl(prim, path_root.into()))?;\n-                for &impl_ in impls {\n-                    let link = cx\n-                        .tcx\n-                        .associated_items(impl_)\n-                        .find_by_name_and_namespace(\n-                            cx.tcx,\n-                            Ident::with_dummy_span(item_name),\n-                            ns,\n-                            impl_,\n-                        )\n-                        .map(|item| match item.kind {\n-                            ty::AssocKind::Fn => \"method\",\n-                            ty::AssocKind::Const => \"associatedconstant\",\n-                            ty::AssocKind::Type => \"associatedtype\",\n-                        })\n-                        .map(|out| (prim, Some(format!(\"{}#{}.{}\", path, out, item_name))));\n-                    if let Some(link) = link {\n-                        return Ok(link);\n+        // Try looking for methods and associated items.\n+        let mut split = path_str.rsplitn(2, \"::\");\n+        // this can be an `unwrap()` because we ensure the link is never empty\n+        let item_name = Symbol::intern(split.next().unwrap());\n+        let path_root = split\n+            .next()\n+            .map(|f| {\n+                if f == \"self\" || f == \"Self\" {\n+                    if let Some(name) = current_item.as_ref() {\n+                        return name.clone();\n                     }\n                 }\n-                debug!(\n-                    \"returning primitive error for {}::{} in {} namespace\",\n-                    path,\n-                    item_name,\n-                    ns.descr()\n-                );\n-                return Err(ResolutionFailure::NoPrimitiveAssocItem {\n-                    res: prim,\n-                    prim_name: path,\n-                    assoc_item: item_name,\n+                f.to_owned()\n+            })\n+            // If there's no `::`, it's not an associated item.\n+            // So we can be sure that `rustc_resolve` was accurate when it said it wasn't resolved.\n+            .ok_or_else(|| {\n+                debug!(\"found no `::`, assumming {} was correctly not in scope\", item_name);\n+                ResolutionFailure::NotInScope { module_id, name: item_name.to_string().into() }\n+            })?;\n+\n+        if let Some((path, prim)) = is_primitive(&path_root, TypeNS) {\n+            let impls = primitive_impl(cx, &path)\n+                .ok_or_else(|| ResolutionFailure::NoPrimitiveImpl(prim, path_root.into()))?;\n+            for &impl_ in impls {\n+                let link = cx\n+                    .tcx\n+                    .associated_items(impl_)\n+                    .find_by_name_and_namespace(\n+                        cx.tcx,\n+                        Ident::with_dummy_span(item_name),\n+                        ns,\n+                        impl_,\n+                    )\n+                    .map(|item| match item.kind {\n+                        ty::AssocKind::Fn => \"method\",\n+                        ty::AssocKind::Const => \"associatedconstant\",\n+                        ty::AssocKind::Type => \"associatedtype\",\n+                    })\n+                    .map(|out| (prim, Some(format!(\"{}#{}.{}\", path, out, item_name))));\n+                if let Some(link) = link {\n+                    return Ok(link);\n                 }\n-                .into());\n             }\n+            debug!(\n+                \"returning primitive error for {}::{} in {} namespace\",\n+                path,\n+                item_name,\n+                ns.descr()\n+            );\n+            return Err(ResolutionFailure::NoPrimitiveAssocItem {\n+                res: prim,\n+                prim_name: path,\n+                assoc_item: item_name,\n+            }\n+            .into());\n+        }\n \n-            let ty_res = cx\n-                .enter_resolver(|resolver| {\n-                    // only types can have associated items\n-                    resolver.resolve_str_path_error(DUMMY_SP, &path_root, TypeNS, module_id)\n-                })\n-                .map(|(_, res)| res);\n-            let ty_res = match ty_res {\n-                Err(()) | Ok(Res::Err) => {\n-                    return if ns == Namespace::ValueNS {\n-                        self.variant_field(path_str, current_item, module_id, extra_fragment)\n-                    } else {\n-                        // See if it only broke because of the namespace.\n-                        let kind = cx.enter_resolver(|resolver| {\n-                            // NOTE: this doesn't use `check_full_res` because we explicitly want to ignore `TypeNS` (we already checked it)\n-                            for &ns in &[MacroNS, ValueNS] {\n-                                match resolver\n-                                    .resolve_str_path_error(DUMMY_SP, &path_root, ns, module_id)\n-                                {\n-                                    Ok((_, Res::Err)) | Err(()) => {}\n-                                    Ok((_, res)) => {\n-                                        let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n-                                        return ResolutionFailure::CannotHaveAssociatedItems(\n-                                            res, ns,\n-                                        );\n-                                    }\n+        let ty_res = cx\n+            .enter_resolver(|resolver| {\n+                // only types can have associated items\n+                resolver.resolve_str_path_error(DUMMY_SP, &path_root, TypeNS, module_id)\n+            })\n+            .map(|(_, res)| res);\n+        let ty_res = match ty_res {\n+            Err(()) | Ok(Res::Err) => {\n+                return if ns == Namespace::ValueNS {\n+                    self.variant_field(path_str, current_item, module_id, extra_fragment)\n+                } else {\n+                    // See if it only broke because of the namespace.\n+                    let kind = cx.enter_resolver(|resolver| {\n+                        // NOTE: this doesn't use `check_full_res` because we explicitly want to ignore `TypeNS` (we already checked it)\n+                        for &ns in &[MacroNS, ValueNS] {\n+                            match resolver\n+                                .resolve_str_path_error(DUMMY_SP, &path_root, ns, module_id)\n+                            {\n+                                Ok((_, Res::Err)) | Err(()) => {}\n+                                Ok((_, res)) => {\n+                                    let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n+                                    return ResolutionFailure::CannotHaveAssociatedItems(res, ns);\n                                 }\n                             }\n-                            ResolutionFailure::NotInScope { module_id, name: path_root.into() }\n-                        });\n-                        Err(kind.into())\n-                    };\n-                }\n-                Ok(res) => res,\n-            };\n-            let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n-            let res = match ty_res {\n-                Res::Def(\n-                    DefKind::Struct | DefKind::Union | DefKind::Enum | DefKind::TyAlias,\n-                    did,\n-                ) => {\n-                    debug!(\"looking for associated item named {} for item {:?}\", item_name, did);\n-                    // Checks if item_name belongs to `impl SomeItem`\n-                    let assoc_item = cx\n-                        .tcx\n-                        .inherent_impls(did)\n-                        .iter()\n-                        .flat_map(|&imp| {\n-                            cx.tcx.associated_items(imp).find_by_name_and_namespace(\n-                                cx.tcx,\n-                                Ident::with_dummy_span(item_name),\n-                                ns,\n-                                imp,\n-                            )\n-                        })\n-                        .map(|item| (item.kind, item.def_id))\n-                        // There should only ever be one associated item that matches from any inherent impl\n-                        .next()\n-                        // Check if item_name belongs to `impl SomeTrait for SomeItem`\n-                        // This gives precedence to `impl SomeItem`:\n-                        // Although having both would be ambiguous, use impl version for compat. sake.\n-                        // To handle that properly resolve() would have to support\n-                        // something like [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n-                        .or_else(|| {\n-                            let kind = resolve_associated_trait_item(\n-                                did, module_id, item_name, ns, &self.cx,\n-                            );\n-                            debug!(\"got associated item kind {:?}\", kind);\n-                            kind\n-                        });\n-\n-                    if let Some((kind, id)) = assoc_item {\n-                        let out = match kind {\n-                            ty::AssocKind::Fn => \"method\",\n-                            ty::AssocKind::Const => \"associatedconstant\",\n-                            ty::AssocKind::Type => \"associatedtype\",\n-                        };\n-                        Some(if extra_fragment.is_some() {\n-                            Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(\n-                                ty_res,\n-                            )))\n-                        } else {\n-                            // HACK(jynelson): `clean` expects the type, not the associated item.\n-                            // but the disambiguator logic expects the associated item.\n-                            // Store the kind in a side channel so that only the disambiguator logic looks at it.\n-                            self.kind_side_channel.set(Some((kind.as_def_kind(), id)));\n-                            Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n-                        })\n-                    } else if ns == Namespace::ValueNS {\n-                        debug!(\"looking for variants or fields named {} for {:?}\", item_name, did);\n-                        match cx.tcx.type_of(did).kind() {\n-                            ty::Adt(def, _) => {\n-                                let field = if def.is_enum() {\n-                                    def.all_fields().find(|item| item.ident.name == item_name)\n-                                } else {\n-                                    def.non_enum_variant()\n-                                        .fields\n-                                        .iter()\n-                                        .find(|item| item.ident.name == item_name)\n-                                };\n-                                field.map(|item| {\n-                                    if extra_fragment.is_some() {\n-                                        let res = Res::Def(\n-                                            if def.is_enum() {\n-                                                DefKind::Variant\n-                                            } else {\n-                                                DefKind::Field\n-                                            },\n-                                            item.did,\n-                                        );\n-                                        Err(ErrorKind::AnchorFailure(\n-                                            AnchorFailure::RustdocAnchorConflict(res),\n-                                        ))\n-                                    } else {\n-                                        Ok((\n-                                            ty_res,\n-                                            Some(format!(\n-                                                \"{}.{}\",\n-                                                if def.is_enum() {\n-                                                    \"variant\"\n-                                                } else {\n-                                                    \"structfield\"\n-                                                },\n-                                                item.ident\n-                                            )),\n-                                        ))\n-                                    }\n-                                })\n-                            }\n-                            _ => None,\n                         }\n-                    } else {\n-                        // We already know this isn't in ValueNS, so no need to check variant_field\n-                        return Err(ResolutionFailure::NoAssocItem(ty_res, item_name).into());\n-                    }\n-                }\n-                Res::Def(DefKind::Trait, did) => cx\n+                        ResolutionFailure::NotInScope { module_id, name: path_root.into() }\n+                    });\n+                    Err(kind.into())\n+                };\n+            }\n+            Ok(res) => res,\n+        };\n+        let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n+        let res = match ty_res {\n+            Res::Def(DefKind::Struct | DefKind::Union | DefKind::Enum | DefKind::TyAlias, did) => {\n+                debug!(\"looking for associated item named {} for item {:?}\", item_name, did);\n+                // Checks if item_name belongs to `impl SomeItem`\n+                let assoc_item = cx\n                     .tcx\n-                    .associated_items(did)\n-                    .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, did)\n-                    .map(|item| {\n-                        let kind = match item.kind {\n-                            ty::AssocKind::Const => \"associatedconstant\",\n-                            ty::AssocKind::Type => \"associatedtype\",\n-                            ty::AssocKind::Fn => {\n-                                if item.defaultness.has_value() {\n-                                    \"method\"\n+                    .inherent_impls(did)\n+                    .iter()\n+                    .flat_map(|&imp| {\n+                        cx.tcx.associated_items(imp).find_by_name_and_namespace(\n+                            cx.tcx,\n+                            Ident::with_dummy_span(item_name),\n+                            ns,\n+                            imp,\n+                        )\n+                    })\n+                    .map(|item| (item.kind, item.def_id))\n+                    // There should only ever be one associated item that matches from any inherent impl\n+                    .next()\n+                    // Check if item_name belongs to `impl SomeTrait for SomeItem`\n+                    // This gives precedence to `impl SomeItem`:\n+                    // Although having both would be ambiguous, use impl version for compat. sake.\n+                    // To handle that properly resolve() would have to support\n+                    // something like [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n+                    .or_else(|| {\n+                        let kind =\n+                            resolve_associated_trait_item(did, module_id, item_name, ns, &self.cx);\n+                        debug!(\"got associated item kind {:?}\", kind);\n+                        kind\n+                    });\n+\n+                if let Some((kind, id)) = assoc_item {\n+                    let out = match kind {\n+                        ty::AssocKind::Fn => \"method\",\n+                        ty::AssocKind::Const => \"associatedconstant\",\n+                        ty::AssocKind::Type => \"associatedtype\",\n+                    };\n+                    Some(if extra_fragment.is_some() {\n+                        Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(ty_res)))\n+                    } else {\n+                        // HACK(jynelson): `clean` expects the type, not the associated item.\n+                        // but the disambiguator logic expects the associated item.\n+                        // Store the kind in a side channel so that only the disambiguator logic looks at it.\n+                        self.kind_side_channel.set(Some((kind.as_def_kind(), id)));\n+                        Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n+                    })\n+                } else if ns == Namespace::ValueNS {\n+                    debug!(\"looking for variants or fields named {} for {:?}\", item_name, did);\n+                    match cx.tcx.type_of(did).kind() {\n+                        ty::Adt(def, _) => {\n+                            let field = if def.is_enum() {\n+                                def.all_fields().find(|item| item.ident.name == item_name)\n+                            } else {\n+                                def.non_enum_variant()\n+                                    .fields\n+                                    .iter()\n+                                    .find(|item| item.ident.name == item_name)\n+                            };\n+                            field.map(|item| {\n+                                if extra_fragment.is_some() {\n+                                    let res = Res::Def(\n+                                        if def.is_enum() {\n+                                            DefKind::Variant\n+                                        } else {\n+                                            DefKind::Field\n+                                        },\n+                                        item.did,\n+                                    );\n+                                    Err(ErrorKind::AnchorFailure(\n+                                        AnchorFailure::RustdocAnchorConflict(res),\n+                                    ))\n                                 } else {\n-                                    \"tymethod\"\n+                                    Ok((\n+                                        ty_res,\n+                                        Some(format!(\n+                                            \"{}.{}\",\n+                                            if def.is_enum() { \"variant\" } else { \"structfield\" },\n+                                            item.ident\n+                                        )),\n+                                    ))\n                                 }\n-                            }\n-                        };\n-\n-                        if extra_fragment.is_some() {\n-                            Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(\n-                                ty_res,\n-                            )))\n-                        } else {\n-                            let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n-                            Ok((res, Some(format!(\"{}.{}\", kind, item_name))))\n+                            })\n                         }\n-                    }),\n-                _ => None,\n-            };\n-            res.unwrap_or_else(|| {\n-                if ns == Namespace::ValueNS {\n-                    self.variant_field(path_str, current_item, module_id, extra_fragment)\n+                        _ => None,\n+                    }\n                 } else {\n-                    Err(ResolutionFailure::NoAssocItem(ty_res, item_name).into())\n+                    // We already know this isn't in ValueNS, so no need to check variant_field\n+                    return Err(ResolutionFailure::NoAssocItem(ty_res, item_name).into());\n                 }\n-            })\n-        } else {\n-            debug!(\"attempting to resolve item without parent module: {}\", path_str);\n-            Err(ResolutionFailure::NoParentItem.into())\n-        }\n+            }\n+            Res::Def(DefKind::Trait, did) => cx\n+                .tcx\n+                .associated_items(did)\n+                .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, did)\n+                .map(|item| {\n+                    let kind = match item.kind {\n+                        ty::AssocKind::Const => \"associatedconstant\",\n+                        ty::AssocKind::Type => \"associatedtype\",\n+                        ty::AssocKind::Fn => {\n+                            if item.defaultness.has_value() {\n+                                \"method\"\n+                            } else {\n+                                \"tymethod\"\n+                            }\n+                        }\n+                    };\n+\n+                    if extra_fragment.is_some() {\n+                        Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(ty_res)))\n+                    } else {\n+                        let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n+                        Ok((res, Some(format!(\"{}.{}\", kind, item_name))))\n+                    }\n+                }),\n+            _ => None,\n+        };\n+        res.unwrap_or_else(|| {\n+            if ns == Namespace::ValueNS {\n+                self.variant_field(path_str, current_item, module_id, extra_fragment)\n+            } else {\n+                Err(ResolutionFailure::NoAssocItem(ty_res, item_name).into())\n+            }\n+        })\n     }\n \n     /// Used for reporting better errors.\n@@ -599,7 +570,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         &self,\n         ns: Namespace,\n         path_str: &str,\n-        base_node: Option<DefId>,\n+        module_id: DefId,\n         current_item: &Option<String>,\n         extra_fragment: &Option<String>,\n     ) -> Option<Res> {\n@@ -616,11 +587,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         };\n         // cannot be used for macro namespace\n         let check_full_res = |this: &Self, ns| {\n-            let result = this.resolve(path_str, ns, current_item, base_node, extra_fragment);\n+            let result = this.resolve(path_str, ns, current_item, module_id, extra_fragment);\n             check_full_res_inner(this, result.map(|(res, _)| res))\n         };\n         let check_full_res_macro = |this: &Self| {\n-            let result = this.macro_resolve(path_str, base_node);\n+            let result = this.macro_resolve(path_str, module_id);\n             check_full_res_inner(this, result.map_err(ErrorKind::from))\n         };\n         match ns {\n@@ -843,7 +814,6 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             self.mod_ids.push(item.def_id);\n         }\n \n-        let cx = self.cx;\n         let dox = item.attrs.collapsed_doc_value().unwrap_or_else(String::new);\n         trace!(\"got documentation '{}'\", dox);\n \n@@ -885,377 +855,439 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         });\n \n         for (ori_link, link_range) in markdown_links(&dox) {\n-            trace!(\"considering link '{}'\", ori_link);\n+            self.resolve_link(\n+                &mut item,\n+                &dox,\n+                &current_item,\n+                parent_node,\n+                &parent_name,\n+                ori_link,\n+                link_range,\n+            );\n+        }\n+\n+        if item.is_mod() && !item.attrs.inner_docs {\n+            self.mod_ids.push(item.def_id);\n+        }\n+\n+        if item.is_mod() {\n+            let ret = self.fold_item_recur(item);\n+\n+            self.mod_ids.pop();\n \n-            // Bail early for real links.\n-            if ori_link.contains('/') {\n-                continue;\n+            ret\n+        } else {\n+            self.fold_item_recur(item)\n+        }\n+    }\n+}\n+\n+impl LinkCollector<'_, '_> {\n+    fn resolve_link(\n+        &self,\n+        item: &mut Item,\n+        dox: &str,\n+        current_item: &Option<String>,\n+        parent_node: Option<DefId>,\n+        parent_name: &Option<String>,\n+        ori_link: String,\n+        link_range: Option<Range<usize>>,\n+    ) {\n+        trace!(\"considering link '{}'\", ori_link);\n+\n+        // Bail early for real links.\n+        if ori_link.contains('/') {\n+            return;\n+        }\n+\n+        // [] is mostly likely not supposed to be a link\n+        if ori_link.is_empty() {\n+            return;\n+        }\n+\n+        let cx = self.cx;\n+        let link = ori_link.replace(\"`\", \"\");\n+        let parts = link.split('#').collect::<Vec<_>>();\n+        let (link, extra_fragment) = if parts.len() > 2 {\n+            anchor_failure(cx, &item, &link, dox, link_range, AnchorFailure::MultipleAnchors);\n+            return;\n+        } else if parts.len() == 2 {\n+            if parts[0].trim().is_empty() {\n+                // This is an anchor to an element of the current page, nothing to do in here!\n+                return;\n             }\n+            (parts[0], Some(parts[1].to_owned()))\n+        } else {\n+            (parts[0], None)\n+        };\n+        let resolved_self;\n+        let link_text;\n+        let mut path_str;\n+        let disambiguator;\n+        let (mut res, mut fragment) = {\n+            path_str = if let Ok((d, path)) = Disambiguator::from_str(&link) {\n+                disambiguator = Some(d);\n+                path\n+            } else {\n+                disambiguator = None;\n+                &link\n+            }\n+            .trim();\n \n-            // [] is mostly likely not supposed to be a link\n-            if ori_link.is_empty() {\n-                continue;\n+            if path_str.contains(|ch: char| !(ch.is_alphanumeric() || ch == ':' || ch == '_')) {\n+                return;\n             }\n \n-            let link = ori_link.replace(\"`\", \"\");\n-            let parts = link.split('#').collect::<Vec<_>>();\n-            let (link, extra_fragment) = if parts.len() > 2 {\n-                anchor_failure(cx, &item, &link, &dox, link_range, AnchorFailure::MultipleAnchors);\n-                continue;\n-            } else if parts.len() == 2 {\n-                if parts[0].trim().is_empty() {\n-                    // This is an anchor to an element of the current page, nothing to do in here!\n-                    continue;\n-                }\n-                (parts[0], Some(parts[1].to_owned()))\n+            // We stripped `()` and `!` when parsing the disambiguator.\n+            // Add them back to be displayed, but not prefix disambiguators.\n+            link_text = disambiguator\n+                .map(|d| d.display_for(path_str))\n+                .unwrap_or_else(|| path_str.to_owned());\n+\n+            // In order to correctly resolve intra-doc-links we need to\n+            // pick a base AST node to work from.  If the documentation for\n+            // this module came from an inner comment (//!) then we anchor\n+            // our name resolution *inside* the module.  If, on the other\n+            // hand it was an outer comment (///) then we anchor the name\n+            // resolution in the parent module on the basis that the names\n+            // used are more likely to be intended to be parent names.  For\n+            // this, we set base_node to None for inner comments since\n+            // we've already pushed this node onto the resolution stack but\n+            // for outer comments we explicitly try and resolve against the\n+            // parent_node first.\n+            let base_node = if item.is_mod() && item.attrs.inner_docs {\n+                self.mod_ids.last().copied()\n             } else {\n-                (parts[0], None)\n+                parent_node\n             };\n-            let resolved_self;\n-            let link_text;\n-            let mut path_str;\n-            let disambiguator;\n-            let (mut res, mut fragment) = {\n-                path_str = if let Ok((d, path)) = Disambiguator::from_str(&link) {\n-                    disambiguator = Some(d);\n-                    path\n-                } else {\n-                    disambiguator = None;\n-                    &link\n-                }\n-                .trim();\n \n-                if path_str.contains(|ch: char| !(ch.is_alphanumeric() || ch == ':' || ch == '_')) {\n-                    continue;\n+            let module_id = if let Some(id) = base_node {\n+                id\n+            } else {\n+                debug!(\"attempting to resolve item without parent module: {}\", path_str);\n+                let err_kind = ResolutionFailure::NoParentItem.into();\n+                resolution_failure(\n+                    self,\n+                    &item,\n+                    path_str,\n+                    disambiguator,\n+                    dox,\n+                    link_range,\n+                    smallvec![err_kind],\n+                );\n+                return;\n+            };\n+\n+            // replace `Self` with suitable item's parent name\n+            if path_str.starts_with(\"Self::\") {\n+                if let Some(ref name) = parent_name {\n+                    resolved_self = format!(\"{}::{}\", name, &path_str[6..]);\n+                    path_str = &resolved_self;\n                 }\n+            }\n \n-                // We stripped `()` and `!` when parsing the disambiguator.\n-                // Add them back to be displayed, but not prefix disambiguators.\n-                link_text = disambiguator\n-                    .map(|d| d.display_for(path_str))\n-                    .unwrap_or_else(|| path_str.to_owned());\n-\n-                // In order to correctly resolve intra-doc-links we need to\n-                // pick a base AST node to work from.  If the documentation for\n-                // this module came from an inner comment (//!) then we anchor\n-                // our name resolution *inside* the module.  If, on the other\n-                // hand it was an outer comment (///) then we anchor the name\n-                // resolution in the parent module on the basis that the names\n-                // used are more likely to be intended to be parent names.  For\n-                // this, we set base_node to None for inner comments since\n-                // we've already pushed this node onto the resolution stack but\n-                // for outer comments we explicitly try and resolve against the\n-                // parent_node first.\n-                let base_node = if item.is_mod() && item.attrs.inner_docs {\n-                    self.mod_ids.last().copied()\n-                } else {\n-                    parent_node\n-                };\n+            match self.resolve_with_disambiguator(\n+                disambiguator,\n+                item,\n+                dox,\n+                path_str,\n+                current_item,\n+                module_id,\n+                extra_fragment,\n+                &ori_link,\n+                link_range.clone(),\n+            ) {\n+                Some(x) => x,\n+                None => return,\n+            }\n+        };\n \n-                // replace `Self` with suitable item's parent name\n-                if path_str.starts_with(\"Self::\") {\n-                    if let Some(ref name) = parent_name {\n-                        resolved_self = format!(\"{}::{}\", name, &path_str[6..]);\n-                        path_str = &resolved_self;\n+        // Check for a primitive which might conflict with a module\n+        // Report the ambiguity and require that the user specify which one they meant.\n+        // FIXME: could there ever be a primitive not in the type namespace?\n+        if matches!(\n+            disambiguator,\n+            None | Some(Disambiguator::Namespace(Namespace::TypeNS) | Disambiguator::Primitive)\n+        ) && !matches!(res, Res::PrimTy(_))\n+        {\n+            if let Some((path, prim)) = is_primitive(path_str, TypeNS) {\n+                // `prim@char`\n+                if matches!(disambiguator, Some(Disambiguator::Primitive)) {\n+                    if fragment.is_some() {\n+                        anchor_failure(\n+                            cx,\n+                            &item,\n+                            path_str,\n+                            dox,\n+                            link_range,\n+                            AnchorFailure::RustdocAnchorConflict(prim),\n+                        );\n+                        return;\n                     }\n+                    res = prim;\n+                    fragment = Some(path.to_owned());\n+                } else {\n+                    // `[char]` when a `char` module is in scope\n+                    let candidates = vec![res, prim];\n+                    ambiguity_error(cx, &item, path_str, dox, link_range, candidates);\n+                    return;\n                 }\n+            }\n+        }\n \n-                match disambiguator.map(Disambiguator::ns) {\n-                    Some(ns @ (ValueNS | TypeNS)) => {\n-                        match self.resolve(path_str, ns, &current_item, base_node, &extra_fragment)\n-                        {\n-                            Ok(res) => res,\n-                            Err(ErrorKind::Resolve(box mut kind)) => {\n-                                // We only looked in one namespace. Try to give a better error if possible.\n-                                if kind.full_res().is_none() {\n-                                    let other_ns = if ns == ValueNS { TypeNS } else { ValueNS };\n-                                    for &new_ns in &[other_ns, MacroNS] {\n-                                        if let Some(res) = self.check_full_res(\n-                                            new_ns,\n-                                            path_str,\n-                                            base_node,\n-                                            &current_item,\n-                                            &extra_fragment,\n-                                        ) {\n-                                            kind = ResolutionFailure::WrongNamespace(res, ns);\n-                                            break;\n-                                        }\n-                                    }\n-                                }\n-                                resolution_failure(\n-                                    self,\n-                                    &item,\n-                                    path_str,\n-                                    disambiguator,\n-                                    &dox,\n-                                    link_range,\n-                                    smallvec![kind],\n-                                );\n-                                // This could just be a normal link or a broken link\n-                                // we could potentially check if something is\n-                                // \"intra-doc-link-like\" and warn in that case.\n-                                continue;\n-                            }\n-                            Err(ErrorKind::AnchorFailure(msg)) => {\n-                                anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n-                                continue;\n-                            }\n-                        }\n+        let report_mismatch = |specified: Disambiguator, resolved: Disambiguator| {\n+            // The resolved item did not match the disambiguator; give a better error than 'not found'\n+            let msg = format!(\"incompatible link kind for `{}`\", path_str);\n+            report_diagnostic(cx, &msg, &item, dox, &link_range, |diag, sp| {\n+                let note = format!(\n+                    \"this link resolved to {} {}, which is not {} {}\",\n+                    resolved.article(),\n+                    resolved.descr(),\n+                    specified.article(),\n+                    specified.descr()\n+                );\n+                diag.note(&note);\n+                suggest_disambiguator(resolved, diag, path_str, dox, sp, &link_range);\n+            });\n+        };\n+        if let Res::PrimTy(_) = res {\n+            match disambiguator {\n+                Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {\n+                    item.attrs.links.push(ItemLink {\n+                        link: ori_link,\n+                        link_text: path_str.to_owned(),\n+                        did: None,\n+                        fragment,\n+                    });\n+                }\n+                Some(other) => {\n+                    report_mismatch(other, Disambiguator::Primitive);\n+                    return;\n+                }\n+            }\n+        } else {\n+            debug!(\"intra-doc link to {} resolved to {:?}\", path_str, res);\n+\n+            // Disallow e.g. linking to enums with `struct@`\n+            if let Res::Def(kind, _) = res {\n+                debug!(\"saw kind {:?} with disambiguator {:?}\", kind, disambiguator);\n+                match (self.kind_side_channel.take().map(|(kind, _)| kind).unwrap_or(kind), disambiguator) {\n+                    | (DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst, Some(Disambiguator::Kind(DefKind::Const)))\n+                    // NOTE: this allows 'method' to mean both normal functions and associated functions\n+                    // This can't cause ambiguity because both are in the same namespace.\n+                    | (DefKind::Fn | DefKind::AssocFn, Some(Disambiguator::Kind(DefKind::Fn)))\n+                    // These are namespaces; allow anything in the namespace to match\n+                    | (_, Some(Disambiguator::Namespace(_)))\n+                    // If no disambiguator given, allow anything\n+                    | (_, None)\n+                    // All of these are valid, so do nothing\n+                    => {}\n+                    (actual, Some(Disambiguator::Kind(expected))) if actual == expected => {}\n+                    (_, Some(specified @ Disambiguator::Kind(_) | specified @ Disambiguator::Primitive)) => {\n+                        report_mismatch(specified, Disambiguator::Kind(kind));\n+                        return;\n                     }\n-                    None => {\n-                        // Try everything!\n-                        let mut candidates = PerNS {\n-                            macro_ns: self\n-                                .macro_resolve(path_str, base_node)\n-                                .map(|res| (res, extra_fragment.clone())),\n-                            type_ns: match self.resolve(\n-                                path_str,\n-                                TypeNS,\n-                                &current_item,\n-                                base_node,\n-                                &extra_fragment,\n-                            ) {\n-                                Ok(res) => {\n-                                    debug!(\"got res in TypeNS: {:?}\", res);\n-                                    Ok(res)\n-                                }\n-                                Err(ErrorKind::AnchorFailure(msg)) => {\n-                                    anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n-                                    continue;\n-                                }\n-                                Err(ErrorKind::Resolve(box kind)) => Err(kind),\n-                            },\n-                            value_ns: match self.resolve(\n-                                path_str,\n-                                ValueNS,\n-                                &current_item,\n-                                base_node,\n-                                &extra_fragment,\n-                            ) {\n-                                Ok(res) => Ok(res),\n-                                Err(ErrorKind::AnchorFailure(msg)) => {\n-                                    anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n-                                    continue;\n-                                }\n-                                Err(ErrorKind::Resolve(box kind)) => Err(kind),\n-                            }\n-                            .and_then(|(res, fragment)| {\n-                                // Constructors are picked up in the type namespace.\n-                                match res {\n-                                    Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) => {\n-                                        Err(ResolutionFailure::WrongNamespace(res, TypeNS))\n-                                    }\n-                                    _ => match (fragment, extra_fragment) {\n-                                        (Some(fragment), Some(_)) => {\n-                                            // Shouldn't happen but who knows?\n-                                            Ok((res, Some(fragment)))\n-                                        }\n-                                        (fragment, None) | (None, fragment) => Ok((res, fragment)),\n-                                    },\n-                                }\n-                            }),\n-                        };\n+                }\n+            }\n \n-                        let len = candidates.iter().filter(|res| res.is_ok()).count();\n+            // item can be non-local e.g. when using #[doc(primitive = \"pointer\")]\n+            if let Some((src_id, dst_id)) = res\n+                .opt_def_id()\n+                .and_then(|def_id| def_id.as_local())\n+                .and_then(|dst_id| item.def_id.as_local().map(|src_id| (src_id, dst_id)))\n+            {\n+                use rustc_hir::def_id::LOCAL_CRATE;\n \n-                        if len == 0 {\n-                            resolution_failure(\n-                                self,\n-                                &item,\n-                                path_str,\n-                                disambiguator,\n-                                &dox,\n-                                link_range,\n-                                candidates.into_iter().filter_map(|res| res.err()).collect(),\n-                            );\n-                            // this could just be a normal link\n-                            continue;\n-                        }\n+                let hir_src = self.cx.tcx.hir().local_def_id_to_hir_id(src_id);\n+                let hir_dst = self.cx.tcx.hir().local_def_id_to_hir_id(dst_id);\n \n-                        if len == 1 {\n-                            candidates.into_iter().filter_map(|res| res.ok()).next().unwrap()\n-                        } else if len == 2 && is_derive_trait_collision(&candidates) {\n-                            candidates.type_ns.unwrap()\n-                        } else {\n-                            if is_derive_trait_collision(&candidates) {\n-                                candidates.macro_ns = Err(ResolutionFailure::Dummy);\n-                            }\n-                            // If we're reporting an ambiguity, don't mention the namespaces that failed\n-                            let candidates =\n-                                candidates.map(|candidate| candidate.ok().map(|(res, _)| res));\n-                            ambiguity_error(\n-                                cx,\n-                                &item,\n-                                path_str,\n-                                &dox,\n-                                link_range,\n-                                candidates.present_items().collect(),\n-                            );\n-                            continue;\n-                        }\n-                    }\n-                    Some(MacroNS) => {\n-                        match self.macro_resolve(path_str, base_node) {\n-                            Ok(res) => (res, extra_fragment),\n-                            Err(mut kind) => {\n-                                // `macro_resolve` only looks in the macro namespace. Try to give a better error if possible.\n-                                for &ns in &[TypeNS, ValueNS] {\n-                                    if let Some(res) = self.check_full_res(\n-                                        ns,\n-                                        path_str,\n-                                        base_node,\n-                                        &current_item,\n-                                        &extra_fragment,\n-                                    ) {\n-                                        kind = ResolutionFailure::WrongNamespace(res, MacroNS);\n-                                        break;\n-                                    }\n-                                }\n-                                resolution_failure(\n-                                    self,\n-                                    &item,\n+                if self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_src)\n+                    && !self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_dst)\n+                {\n+                    privacy_error(cx, &item, &path_str, dox, link_range);\n+                    return;\n+                }\n+            }\n+            let id = register_res(cx, res);\n+            item.attrs.links.push(ItemLink { link: ori_link, link_text, did: Some(id), fragment });\n+        }\n+    }\n+\n+    fn resolve_with_disambiguator(\n+        &self,\n+        disambiguator: Option<Disambiguator>,\n+        item: &mut Item,\n+        dox: &str,\n+        path_str: &str,\n+        current_item: &Option<String>,\n+        base_node: DefId,\n+        extra_fragment: Option<String>,\n+        ori_link: &str,\n+        link_range: Option<Range<usize>>,\n+    ) -> Option<(Res, Option<String>)> {\n+        match disambiguator.map(Disambiguator::ns) {\n+            Some(ns @ (ValueNS | TypeNS)) => {\n+                match self.resolve(path_str, ns, &current_item, base_node, &extra_fragment) {\n+                    Ok(res) => Some(res),\n+                    Err(ErrorKind::Resolve(box mut kind)) => {\n+                        // We only looked in one namespace. Try to give a better error if possible.\n+                        if kind.full_res().is_none() {\n+                            let other_ns = if ns == ValueNS { TypeNS } else { ValueNS };\n+                            for &new_ns in &[other_ns, MacroNS] {\n+                                if let Some(res) = self.check_full_res(\n+                                    new_ns,\n                                     path_str,\n-                                    disambiguator,\n-                                    &dox,\n-                                    link_range,\n-                                    smallvec![kind],\n-                                );\n-                                continue;\n+                                    base_node,\n+                                    &current_item,\n+                                    &extra_fragment,\n+                                ) {\n+                                    kind = ResolutionFailure::WrongNamespace(res, ns);\n+                                    break;\n+                                }\n                             }\n                         }\n+                        resolution_failure(\n+                            self,\n+                            &item,\n+                            path_str,\n+                            disambiguator,\n+                            dox,\n+                            link_range,\n+                            smallvec![kind],\n+                        );\n+                        // This could just be a normal link or a broken link\n+                        // we could potentially check if something is\n+                        // \"intra-doc-link-like\" and warn in that case.\n+                        return None;\n                     }\n-                }\n-            };\n-\n-            // Check for a primitive which might conflict with a module\n-            // Report the ambiguity and require that the user specify which one they meant.\n-            // FIXME: could there ever be a primitive not in the type namespace?\n-            if matches!(\n-                disambiguator,\n-                None | Some(Disambiguator::Namespace(Namespace::TypeNS) | Disambiguator::Primitive)\n-            ) && !matches!(res, Res::PrimTy(_))\n-            {\n-                if let Some((path, prim)) = is_primitive(path_str, TypeNS) {\n-                    // `prim@char`\n-                    if matches!(disambiguator, Some(Disambiguator::Primitive)) {\n-                        if fragment.is_some() {\n-                            anchor_failure(\n-                                cx,\n-                                &item,\n-                                path_str,\n-                                &dox,\n-                                link_range,\n-                                AnchorFailure::RustdocAnchorConflict(prim),\n-                            );\n-                            continue;\n-                        }\n-                        res = prim;\n-                        fragment = Some(path.to_owned());\n-                    } else {\n-                        // `[char]` when a `char` module is in scope\n-                        let candidates = vec![res, prim];\n-                        ambiguity_error(cx, &item, path_str, &dox, link_range, candidates);\n-                        continue;\n+                    Err(ErrorKind::AnchorFailure(msg)) => {\n+                        anchor_failure(self.cx, &item, &ori_link, dox, link_range, msg);\n+                        return None;\n                     }\n                 }\n             }\n+            None => {\n+                // Try everything!\n+                let mut candidates = PerNS {\n+                    macro_ns: self\n+                        .macro_resolve(path_str, base_node)\n+                        .map(|res| (res, extra_fragment.clone())),\n+                    type_ns: match self.resolve(\n+                        path_str,\n+                        TypeNS,\n+                        &current_item,\n+                        base_node,\n+                        &extra_fragment,\n+                    ) {\n+                        Ok(res) => {\n+                            debug!(\"got res in TypeNS: {:?}\", res);\n+                            Ok(res)\n+                        }\n+                        Err(ErrorKind::AnchorFailure(msg)) => {\n+                            anchor_failure(self.cx, &item, ori_link, dox, link_range, msg);\n+                            return None;\n+                        }\n+                        Err(ErrorKind::Resolve(box kind)) => Err(kind),\n+                    },\n+                    value_ns: match self.resolve(\n+                        path_str,\n+                        ValueNS,\n+                        &current_item,\n+                        base_node,\n+                        &extra_fragment,\n+                    ) {\n+                        Ok(res) => Ok(res),\n+                        Err(ErrorKind::AnchorFailure(msg)) => {\n+                            anchor_failure(self.cx, &item, ori_link, dox, link_range, msg);\n+                            return None;\n+                        }\n+                        Err(ErrorKind::Resolve(box kind)) => Err(kind),\n+                    }\n+                    .and_then(|(res, fragment)| {\n+                        // Constructors are picked up in the type namespace.\n+                        match res {\n+                            Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) => {\n+                                Err(ResolutionFailure::WrongNamespace(res, TypeNS))\n+                            }\n+                            _ => match (fragment, extra_fragment) {\n+                                (Some(fragment), Some(_)) => {\n+                                    // Shouldn't happen but who knows?\n+                                    Ok((res, Some(fragment)))\n+                                }\n+                                (fragment, None) | (None, fragment) => Ok((res, fragment)),\n+                            },\n+                        }\n+                    }),\n+                };\n \n-            let report_mismatch = |specified: Disambiguator, resolved: Disambiguator| {\n-                // The resolved item did not match the disambiguator; give a better error than 'not found'\n-                let msg = format!(\"incompatible link kind for `{}`\", path_str);\n-                report_diagnostic(cx, &msg, &item, &dox, &link_range, |diag, sp| {\n-                    let note = format!(\n-                        \"this link resolved to {} {}, which is not {} {}\",\n-                        resolved.article(),\n-                        resolved.descr(),\n-                        specified.article(),\n-                        specified.descr()\n+                let len = candidates.iter().filter(|res| res.is_ok()).count();\n+\n+                if len == 0 {\n+                    resolution_failure(\n+                        self,\n+                        &item,\n+                        path_str,\n+                        disambiguator,\n+                        dox,\n+                        link_range,\n+                        candidates.into_iter().filter_map(|res| res.err()).collect(),\n                     );\n-                    diag.note(&note);\n-                    suggest_disambiguator(resolved, diag, path_str, &dox, sp, &link_range);\n-                });\n-            };\n-            if let Res::PrimTy(_) = res {\n-                match disambiguator {\n-                    Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {\n-                        item.attrs.links.push(ItemLink {\n-                            link: ori_link,\n-                            link_text: path_str.to_owned(),\n-                            did: None,\n-                            fragment,\n-                        });\n-                    }\n-                    Some(other) => {\n-                        report_mismatch(other, Disambiguator::Primitive);\n-                        continue;\n-                    }\n+                    // this could just be a normal link\n+                    return None;\n                 }\n-            } else {\n-                debug!(\"intra-doc link to {} resolved to {:?}\", path_str, res);\n-\n-                // Disallow e.g. linking to enums with `struct@`\n-                if let Res::Def(kind, _) = res {\n-                    debug!(\"saw kind {:?} with disambiguator {:?}\", kind, disambiguator);\n-                    match (self.kind_side_channel.take().map(|(kind, _)| kind).unwrap_or(kind), disambiguator) {\n-                        | (DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst, Some(Disambiguator::Kind(DefKind::Const)))\n-                        // NOTE: this allows 'method' to mean both normal functions and associated functions\n-                        // This can't cause ambiguity because both are in the same namespace.\n-                        | (DefKind::Fn | DefKind::AssocFn, Some(Disambiguator::Kind(DefKind::Fn)))\n-                        // These are namespaces; allow anything in the namespace to match\n-                        | (_, Some(Disambiguator::Namespace(_)))\n-                        // If no disambiguator given, allow anything\n-                        | (_, None)\n-                        // All of these are valid, so do nothing\n-                        => {}\n-                        (actual, Some(Disambiguator::Kind(expected))) if actual == expected => {}\n-                        (_, Some(specified @ Disambiguator::Kind(_) | specified @ Disambiguator::Primitive)) => {\n-                            report_mismatch(specified, Disambiguator::Kind(kind));\n-                            continue;\n-                        }\n+\n+                if len == 1 {\n+                    Some(candidates.into_iter().filter_map(|res| res.ok()).next().unwrap())\n+                } else if len == 2 && is_derive_trait_collision(&candidates) {\n+                    Some(candidates.type_ns.unwrap())\n+                } else {\n+                    if is_derive_trait_collision(&candidates) {\n+                        candidates.macro_ns = Err(ResolutionFailure::Dummy);\n                     }\n+                    // If we're reporting an ambiguity, don't mention the namespaces that failed\n+                    let candidates = candidates.map(|candidate| candidate.ok().map(|(res, _)| res));\n+                    ambiguity_error(\n+                        self.cx,\n+                        &item,\n+                        path_str,\n+                        dox,\n+                        link_range,\n+                        candidates.present_items().collect(),\n+                    );\n+                    return None;\n                 }\n-\n-                // item can be non-local e.g. when using #[doc(primitive = \"pointer\")]\n-                if let Some((src_id, dst_id)) = res\n-                    .opt_def_id()\n-                    .and_then(|def_id| def_id.as_local())\n-                    .and_then(|dst_id| item.def_id.as_local().map(|src_id| (src_id, dst_id)))\n-                {\n-                    use rustc_hir::def_id::LOCAL_CRATE;\n-\n-                    let hir_src = self.cx.tcx.hir().local_def_id_to_hir_id(src_id);\n-                    let hir_dst = self.cx.tcx.hir().local_def_id_to_hir_id(dst_id);\n-\n-                    if self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_src)\n-                        && !self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_dst)\n-                    {\n-                        privacy_error(cx, &item, &path_str, &dox, link_range);\n-                        continue;\n+            }\n+            Some(MacroNS) => {\n+                match self.macro_resolve(path_str, base_node) {\n+                    Ok(res) => Some((res, extra_fragment)),\n+                    Err(mut kind) => {\n+                        // `macro_resolve` only looks in the macro namespace. Try to give a better error if possible.\n+                        for &ns in &[TypeNS, ValueNS] {\n+                            if let Some(res) = self.check_full_res(\n+                                ns,\n+                                path_str,\n+                                base_node,\n+                                &current_item,\n+                                &extra_fragment,\n+                            ) {\n+                                kind = ResolutionFailure::WrongNamespace(res, MacroNS);\n+                                break;\n+                            }\n+                        }\n+                        resolution_failure(\n+                            self,\n+                            &item,\n+                            path_str,\n+                            disambiguator,\n+                            dox,\n+                            link_range,\n+                            smallvec![kind],\n+                        );\n+                        return None;\n                     }\n                 }\n-                let id = register_res(cx, res);\n-                item.attrs.links.push(ItemLink {\n-                    link: ori_link,\n-                    link_text,\n-                    did: Some(id),\n-                    fragment,\n-                });\n             }\n         }\n-\n-        if item.is_mod() && !item.attrs.inner_docs {\n-            self.mod_ids.push(item.def_id);\n-        }\n-\n-        if item.is_mod() {\n-            let ret = self.fold_item_recur(item);\n-\n-            self.mod_ids.pop();\n-\n-            ret\n-        } else {\n-            self.fold_item_recur(item)\n-        }\n     }\n }\n \n@@ -1536,13 +1568,9 @@ fn resolution_failure(\n                                 break;\n                             }\n                         };\n-                        if let Some(res) = collector.check_full_res(\n-                            TypeNS,\n-                            &current,\n-                            Some(*module_id),\n-                            &None,\n-                            &None,\n-                        ) {\n+                        if let Some(res) =\n+                            collector.check_full_res(TypeNS, &current, *module_id, &None, &None)\n+                        {\n                             failure = ResolutionFailure::NoAssocItem(res, Symbol::intern(current));\n                             break;\n                         }"}]}