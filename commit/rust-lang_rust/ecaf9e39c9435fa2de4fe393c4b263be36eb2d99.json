{"sha": "ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjYWY5ZTM5Yzk0MzVmYTJkZTRmZTM5M2M0YjI2M2JlMzZlYjJkOTk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-06T19:34:08Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-06T22:36:30Z"}, "message": "Convert alt to match. Stop parsing alt", "tree": {"sha": "775f69be65adff65551d96173dd797e32e2c3157", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/775f69be65adff65551d96173dd797e32e2c3157"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "html_url": "https://github.com/rust-lang/rust/commit/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3a9bb1bd4a1d510bbaca2ab1121e4c85a239247", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3a9bb1bd4a1d510bbaca2ab1121e4c85a239247", "html_url": "https://github.com/rust-lang/rust/commit/d3a9bb1bd4a1d510bbaca2ab1121e4c85a239247"}], "stats": {"total": 5853, "additions": 2938, "deletions": 2915}, "files": [{"sha": "9342bcb0ca87a8d8a8bbb7eac0ffa205cf152b70", "filename": "doc/rust.md", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -209,15 +209,15 @@ import export use mod\n The keywords in [source files](#source-files) are the following strings:\n \n ~~~~~~~~ {.keyword}\n-alt again assert\n+again assert\n break\n check class const copy\n drop\n else enum export extern\n fail false fn for\n if impl import\n let log loop\n-mod mut\n+match mod mut\n pure\n return\n true trait type\n@@ -956,7 +956,7 @@ An example of a predicate that uses an unchecked block:\n # import std::list::*;\n \n fn pure_foldl<T, U: copy>(ls: list<T>, u: U, f: fn(&&T, &&U) -> U) -> U {\n-    alt ls {\n+    match ls {\n       nil => u,\n       cons(hd, tl) => f(hd, pure_foldl(*tl, f(hd, u), f))\n     }\n@@ -1156,7 +1156,7 @@ class file_descriptor {\n       let mut name: option<~str>;\n     }\n     fn get_name() -> ~str {\n-      alt self.name {\n+      match self.name {\n          none    => fail ~\"File has no name!\",\n          some(n) => n\n       }\n@@ -2171,21 +2171,21 @@ evaluated. If all `if` and `else if` conditions evaluate to `false`\n then any `else` block is executed.\n \n \n-### Alternative expressions\n+### Match expressions\n \n ~~~~~~~~{.ebnf .gram}\n-alt_expr : \"alt\" expr '{' alt_arm [ '|' alt_arm ] * '}' ;\n+match_expr : \"match\" expr '{' match_arm [ '|' match_arm ] * '}' ;\n \n-alt_arm : alt_pat '=>' expr_or_blockish ;\n+match_arm : match_pat '=>' expr_or_blockish ;\n \n-alt_pat : pat [ \"to\" pat ] ? [ \"if\" expr ] ;\n+match_pat : pat [ \"to\" pat ] ? [ \"if\" expr ] ;\n ~~~~~~~~\n \n \n-An `alt` expression branches on a *pattern*. The exact form of matching that\n+A `match` expression branches on a *pattern*. The exact form of matching that\n occurs depends on the pattern. Patterns consist of some combination of\n literals, destructured enum constructors, records and tuples, variable binding\n-specifications, wildcards (`*`), and placeholders (`_`). An `alt` expression has a *head\n+specifications, wildcards (`*`), and placeholders (`_`). A `match` expression has a *head\n expression*, which is the value to compare to the patterns. The type of the\n patterns must equal the type of the head expression.\n \n@@ -2198,7 +2198,7 @@ enum list<X> { nil, cons(X, @list<X>) }\n \n let x: list<int> = cons(10, @cons(11, @nil));\n \n-alt x {\n+match x {\n     cons(_, @nil) => fail ~\"singleton list\",\n     cons(*)       => return,\n     nil           => fail ~\"empty list\"\n@@ -2210,13 +2210,13 @@ tail value of `@nil`. The second pattern matches `any` list constructed with `co\n ignoring the values of its arguments. The difference between `_` and `*` is that the pattern `C(_)` is only type-correct if\n `C` has exactly one argument, while the pattern `C(*)` is type-correct for any enum variant `C`, regardless of how many arguments `C` has.\n \n-To execute an `alt` expression, first the head expression is evaluated, then\n+To execute an `match` expression, first the head expression is evaluated, then\n its value is sequentially compared to the patterns in the arms until a match\n is found. The first arm with a matching pattern is chosen as the branch target\n-of the `alt`, any variables bound by the pattern are assigned to local\n+of the `match`, any variables bound by the pattern are assigned to local\n variables in the arm's block, and control enters the block.\n \n-An example of an `alt` expression:\n+An example of an `match` expression:\n \n \n ~~~~\n@@ -2227,7 +2227,7 @@ enum list<X> { nil, cons(X, @list<X>) }\n \n let x: list<int> = cons(10, @cons(11, @nil));\n \n-alt x {\n+match x {\n     cons(a, @cons(b, _)) => {\n         process_pair(a,b);\n     }\n@@ -2264,7 +2264,7 @@ fn main() {\n         }\n     };\n \n-    alt r {\n+    match r {\n       {options: {choose: true, _}, _} => {\n         choose_player(r)\n       }\n@@ -2278,20 +2278,20 @@ fn main() {\n }\n ~~~~\n \n-Multiple alternative patterns may be joined with the `|` operator.  A\n+Multiple match patterns may be joined with the `|` operator.  A\n range of values may be specified with `to`. For example:\n \n ~~~~\n # let x = 2;\n \n-let message = alt x {\n+let message = match x {\n   0 | 1  => ~\"not many\",\n   2 to 9 => ~\"a few\",\n   _      => ~\"lots\"\n };\n ~~~~\n \n-Finally, alt patterns can accept *pattern guards* to further refine the\n+Finally, match patterns can accept *pattern guards* to further refine the\n criteria for matching a case. Pattern guards appear after the pattern and\n consist of a bool-typed expression following the `if` keyword. A pattern\n guard may refer to the variables bound within the pattern they follow.\n@@ -2301,7 +2301,7 @@ guard may refer to the variables bound within the pattern they follow.\n # fn process_digit(i: int) { }\n # fn process_other(i: int) { }\n \n-let message = alt maybe_digit {\n+let message = match maybe_digit {\n   some(x) if x < 10 => process_digit(x),\n   some(x) => process_other(x),\n   none => fail"}, {"sha": "ebdb2303dcc209433f16f8f744d84521ac76d2c4", "filename": "doc/tutorial.md", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -116,7 +116,7 @@ fn main() {\n         let pick = || (~[rock, paper, scissors])[rng.gen_uint() % 3];\n \n         // Pick two gestures and decide the result\n-        alt (pick(), pick()) {\n+        match (pick(), pick()) {\n             (rock, scissors) | (paper, rock) | (scissors, paper) => copy player1,\n             (scissors, rock) | (rock, paper) | (paper, scissors) => copy player2,\n             _ => ~\"tie\"\n@@ -707,14 +707,14 @@ have type `int`, because control doesn't reach the end of that arm\n \n ## Pattern matching\n \n-Rust's `alt` construct is a generalized, cleaned-up version of C's\n+Rust's `match` construct is a generalized, cleaned-up version of C's\n `switch` construct. You provide it with a value and a number of arms,\n each labelled with a pattern, and it will execute the arm that matches\n the value.\n \n ~~~~\n # let my_number = 1;\n-alt my_number {\n+match my_number {\n   0       => io::println(~\"zero\"),\n   1 | 2   => io::println(~\"one or two\"),\n   3 to 10 => io::println(~\"three to ten\"),\n@@ -732,14 +732,14 @@ valid patterns, and will match only their own value. The pipe operator\n of numeric literal patterns can be expressed with `to`. The underscore\n (`_`) is a wildcard pattern that matches everything.\n \n-The patterns in an alt arm are followed by a fat arrow, `=>`, then an\n+The patterns in an match arm are followed by a fat arrow, `=>`, then an\n expression to evaluate. Each case is separated by commas. It's often\n convenient to use a block expression for a case, in which case the\n commas are optional.\n \n ~~~\n # let my_number = 1;\n-alt my_number {\n+match my_number {\n   0 => {\n     io::println(~\"zero\")\n   }\n@@ -750,9 +750,9 @@ alt my_number {\n ~~~\n \n If the arm with the wildcard pattern was left off in the above\n-example, the typechecker would reject it at compile time. `alt`\n+example, the typechecker would reject it at compile time. `match`\n constructs must be exhaustive: they must have an arm covering every\n-possible case. (You may use the `alt check` construct to write a\n+possible case. (You may use the `match check` construct to write a\n non-exhaustive match, but it's highly undesirable to do so. You may\n reason that the missing cases will never occur, but the typechecker\n provides you with no assurance that your reasoning is correct.)\n@@ -763,7 +763,7 @@ that `(float, float)` is a tuple of two floats:\n \n ~~~~\n fn angle(vec: (float, float)) -> float {\n-    alt vec {\n+    match vec {\n       (0f, y) if y < 0f => 1.5 * float::consts::pi,\n       (0f, y) => 0.5 * float::consts::pi,\n       (x, y) => float::atan(y / x)\n@@ -777,7 +777,7 @@ y)` matches any tuple whose first element is zero, and binds `y` to\n the second element. `(x, y)` matches any tuple, and binds both\n elements to a variable.\n \n-Any `alt` arm can have a guard clause (written `if EXPR`), which is\n+Any `match` arm can have a guard clause (written `if EXPR`), which is\n an expression of type `bool` that determines, after the pattern is\n found to match, whether the arm is taken or not. The variables bound\n by the pattern are available in this guard expression.\n@@ -851,7 +851,7 @@ task failure:\n \n * Accessing an out-of-bounds element of a vector.\n \n-* Having no clauses match when evaluating an `alt check` expression.\n+* Having no clauses match when evaluating an `match check` expression.\n \n * An assertion failure.\n \n@@ -1044,14 +1044,14 @@ not an actual new type.)\n \n ## Record patterns\n \n-Records can be destructured in `alt` patterns. The basic syntax is\n+Records can be destructured in `match` patterns. The basic syntax is\n `{fieldname: pattern, ...}`, but the pattern for a field can be\n omitted as a shorthand for simply binding the variable with the same\n name as the field.\n \n ~~~~\n # let mypoint = {x: 0f, y: 0f};\n-alt mypoint {\n+match mypoint {\n     {x: 0f, y: y_name} => { /* Provide sub-patterns for fields */ }\n     {x, y}             => { /* Simply bind the fields */ }\n }\n@@ -1157,7 +1157,7 @@ patterns, as in this definition of `area`:\n # type point = {x: float, y: float};\n # enum shape { circle(point, float), rectangle(point, point) }\n fn area(sh: shape) -> float {\n-    alt sh {\n+    match sh {\n         circle(_, size) => float::consts::pi * size * size,\n         rectangle({x, y}, {x: x2, y: y2}) => (x2 - x) * (y2 - y)\n     }\n@@ -1170,7 +1170,7 @@ Another example, matching nullary enum variants:\n # type point = {x: float, y: float};\n # enum direction { north, east, south, west }\n fn point_from_direction(dir: direction) -> point {\n-    alt dir {\n+    match dir {\n         north => {x:  0f, y:  1f},\n         east  => {x:  1f, y:  0f},\n         south => {x:  0f, y: -1f},\n@@ -1188,7 +1188,7 @@ nil, `()`, as the empty tuple if you like).\n \n ~~~~\n let mytup: (int, int, float) = (10, 20, 30.0);\n-alt mytup {\n+match mytup {\n   (a, b, c) => log(info, a + b + (c as int))\n }\n ~~~~\n@@ -1922,15 +1922,15 @@ gets access to them.\n ## Other uses of safe references\n \n Safe references are not only used for argument passing. When you\n-destructure on a value in an `alt` expression, or loop over a vector\n+destructure on a value in a `match` expression, or loop over a vector\n with `for`, variables bound to the inside of the given data structure\n will use safe references, not copies. This means such references are\n very cheap, but you'll occasionally have to copy them to ensure\n safety.\n \n ~~~~\n let mut my_rec = {a: 4, b: ~[1, 2, 3]};\n-alt my_rec {\n+match my_rec {\n   {a, b} => {\n     log(info, b); // This is okay\n     my_rec = {a: a + 1, b: b + ~[a]};"}, {"sha": "2f162db325cd06f858021de744bb445ad7ad62ba", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -128,7 +128,7 @@ fn is_uuid(id: ~str) -> bool {\n                 return false;\n             }\n \n-            alt i {\n+            match i {\n                 0u => {\n                     if str::len(part) == 8u {\n                         correct += 1u;\n@@ -192,7 +192,7 @@ fn is_archive_url(u: ~str) -> bool {\n     // FIXME (#2661): this requires the protocol bit - if we had proper\n     // url parsing, we wouldn't need it\n \n-    alt str::find_str(u, ~\"://\") {\n+    match str::find_str(u, ~\"://\") {\n         option::some(i) => has_archive_extension(u),\n         _ => false\n     }\n@@ -223,9 +223,9 @@ fn load_link(mis: ~[@ast::meta_item]) -> (option<~str>,\n     let mut vers = none;\n     let mut uuid = none;\n     for mis.each |a| {\n-        alt a.node {\n+        match a.node {\n             ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) => {\n-                alt *v {\n+                match *v {\n                     ~\"name\" => name = some(*s),\n                     ~\"vers\" => vers = some(*s),\n                     ~\"uuid\" => uuid = some(*s),\n@@ -250,9 +250,9 @@ fn load_crate(filename: ~str) -> option<crate> {\n     let mut crate_type = none;\n \n     for c.node.attrs.each |a| {\n-        alt a.node.value.node {\n+        match a.node.value.node {\n             ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) => {\n-                alt *v {\n+                match *v {\n                     ~\"desc\" => desc = some(*v),\n                     ~\"sigs\" => sigs = some(*v),\n                     ~\"crate_type\" => crate_type = some(*v),\n@@ -279,7 +279,7 @@ fn load_crate(filename: ~str) -> option<crate> {\n     };\n \n     fn goto_view_item(e: env, i: @ast::view_item) {\n-        alt i.node {\n+        match i.node {\n             ast::view_item_use(ident, metas, id) => {\n                 let name_items =\n                     attr::find_meta_items_by_name(metas, ~\"name\");\n@@ -293,11 +293,11 @@ fn load_crate(filename: ~str) -> option<crate> {\n                 let mut attr_from = ~\"\";\n \n               for m.each |item| {\n-                    alt attr::get_meta_item_value_str(item) {\n+                    match attr::get_meta_item_value_str(item) {\n                         some(value) => {\n                             let name = attr::get_meta_item_name(item);\n \n-                            alt *name {\n+                            match *name {\n                                 ~\"vers\" => attr_vers = *value,\n                                 ~\"from\" => attr_from = *value,\n                                 _ => ()\n@@ -315,7 +315,7 @@ fn load_crate(filename: ~str) -> option<crate> {\n                     } else { *attr_name }\n                 };\n \n-                alt *attr_name {\n+                match *attr_name {\n                     ~\"std\" | ~\"core\" => (),\n                     _ => vec::push(e.deps, query)\n                 }\n@@ -339,7 +339,7 @@ fn load_crate(filename: ~str) -> option<crate> {\n \n     let deps = copy e.deps;\n \n-    alt (name, vers, uuid) {\n+    match (name, vers, uuid) {\n         (some(name0), some(vers0), some(uuid0)) => {\n             some({\n                 name: name0,\n@@ -390,21 +390,21 @@ fn parse_source(name: ~str, j: json::json) -> source {\n         fail fmt!{\"'%s' is an invalid source name\", name};\n     }\n \n-    alt j {\n+    match j {\n         json::dict(j) => {\n-            let mut url = alt j.find(~\"url\") {\n+            let mut url = match j.find(~\"url\") {\n                 some(json::string(u)) => *u,\n                 _ => fail ~\"needed 'url' field in source\"\n             };\n-            let method = alt j.find(~\"method\") {\n+            let method = match j.find(~\"method\") {\n                 some(json::string(u)) => *u,\n                 _ => assume_source_method(url)\n             };\n-            let key = alt j.find(~\"key\") {\n+            let key = match j.find(~\"key\") {\n                 some(json::string(u)) => some(*u),\n                 _ => none\n             };\n-            let keyfp = alt j.find(~\"keyfp\") {\n+            let keyfp = match j.find(~\"keyfp\") {\n                 some(json::string(u)) => some(*u),\n                 _ => none\n             };\n@@ -426,7 +426,7 @@ fn parse_source(name: ~str, j: json::json) -> source {\n fn try_parse_sources(filename: ~str, sources: map::hashmap<~str, source>) {\n     if !os::path_exists(filename)  { return; }\n     let c = io::read_whole_file_str(filename);\n-    alt json::from_str(result::get(c)) {\n+    match json::from_str(result::get(c)) {\n         ok(json::dict(j)) => {\n           for j.each |k, v| {\n                 sources.insert(k, parse_source(k, v));\n@@ -439,7 +439,7 @@ fn try_parse_sources(filename: ~str, sources: map::hashmap<~str, source>) {\n }\n \n fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n-    let name = alt p.find(~\"name\") {\n+    let name = match p.find(~\"name\") {\n         some(json::string(n)) => {\n             if !valid_pkg_name(*n) {\n                 warn(~\"malformed source json: \"\n@@ -456,7 +456,7 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n         }\n     };\n \n-    let uuid = alt p.find(~\"uuid\") {\n+    let uuid = match p.find(~\"uuid\") {\n         some(json::string(n)) => {\n             if !is_uuid(*n) {\n                 warn(~\"malformed source json: \"\n@@ -472,15 +472,15 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n         }\n     };\n \n-    let url = alt p.find(~\"url\") {\n+    let url = match p.find(~\"url\") {\n         some(json::string(n)) => *n,\n         _ => {\n             warn(~\"malformed source json: \" + src.name + ~\" (missing url)\");\n             return;\n         }\n     };\n \n-    let method = alt p.find(~\"method\") {\n+    let method = match p.find(~\"method\") {\n         some(json::string(n)) => *n,\n         _ => {\n             warn(~\"malformed source json: \"\n@@ -489,16 +489,16 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n         }\n     };\n \n-    let reference = alt p.find(~\"ref\") {\n+    let reference = match p.find(~\"ref\") {\n         some(json::string(n)) => some(*n),\n         _ => none\n     };\n \n     let mut tags = ~[];\n-    alt p.find(~\"tags\") {\n+    match p.find(~\"tags\") {\n         some(json::list(js)) => {\n           for (*js).each |j| {\n-                alt j {\n+                match j {\n                     json::string(j) => vec::grow(tags, 1u, *j),\n                     _ => ()\n                 }\n@@ -507,7 +507,7 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n         _ => ()\n     }\n \n-    let description = alt p.find(~\"description\") {\n+    let description = match p.find(~\"description\") {\n         some(json::string(n)) => *n,\n         _ => {\n             warn(~\"malformed source json: \" + src.name\n@@ -527,7 +527,7 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n         versions: ~[]\n     };\n \n-    alt vec::position(src.packages, |pkg| pkg.uuid == uuid) {\n+    match vec::position(src.packages, |pkg| pkg.uuid == uuid) {\n       some(idx) => {\n         src.packages[idx] = newpkg;\n         log(debug, ~\"  updated package: \" + src.name + ~\"/\" + name);\n@@ -545,7 +545,7 @@ fn load_source_info(c: cargo, src: source) {\n     let srcfile = path::connect(dir, ~\"source.json\");\n     if !os::path_exists(srcfile) { return; }\n     let srcstr = io::read_whole_file_str(srcfile);\n-    alt json::from_str(result::get(srcstr)) {\n+    match json::from_str(result::get(srcstr)) {\n         ok(json::dict(s)) => {\n             let o = parse_source(src.name, json::dict(s));\n \n@@ -567,10 +567,10 @@ fn load_source_packages(c: cargo, src: source) {\n     let pkgfile = path::connect(dir, ~\"packages.json\");\n     if !os::path_exists(pkgfile) { return; }\n     let pkgstr = io::read_whole_file_str(pkgfile);\n-    alt json::from_str(result::get(pkgstr)) {\n+    match json::from_str(result::get(pkgstr)) {\n         ok(json::list(js)) => {\n           for (*js).each |j| {\n-                alt j {\n+                match j {\n                     json::dict(p) => {\n                         load_one_source_package(src, p);\n                     }\n@@ -592,7 +592,7 @@ fn load_source_packages(c: cargo, src: source) {\n }\n \n fn build_cargo_options(argv: ~[~str]) -> options {\n-    let matches = alt getopts::getopts(argv, opts()) {\n+    let matches = match getopts::getopts(argv, opts()) {\n         result::ok(m) => m,\n         result::err(f) => {\n             fail fmt!{\"%s\", getopts::fail_str(f)};\n@@ -623,12 +623,12 @@ fn build_cargo_options(argv: ~[~str]) -> options {\n }\n \n fn configure(opts: options) -> cargo {\n-    let home = alt get_cargo_root() {\n+    let home = match get_cargo_root() {\n         ok(home) => home,\n         err(_err) => result::get(get_cargo_sysroot())\n     };\n \n-    let get_cargo_dir = alt opts.mode {\n+    let get_cargo_dir = match opts.mode {\n         system_mode => get_cargo_sysroot,\n         user_mode => get_cargo_root,\n         local_mode => get_cargo_root_nearest\n@@ -716,7 +716,7 @@ fn run_in_buildpath(what: ~str, path: ~str, subdir: ~str, cf: ~str,\n }\n \n fn test_one_crate(_c: cargo, path: ~str, cf: ~str) {\n-  let buildpath = alt run_in_buildpath(~\"testing\", path, ~\"/test\", cf,\n+  let buildpath = match run_in_buildpath(~\"testing\", path, ~\"/test\", cf,\n                                        ~[ ~\"--test\"]) {\n       none => return,\n       some(bp) => bp\n@@ -725,7 +725,7 @@ fn test_one_crate(_c: cargo, path: ~str, cf: ~str) {\n }\n \n fn install_one_crate(c: cargo, path: ~str, cf: ~str) {\n-    let buildpath = alt run_in_buildpath(~\"installing\", path,\n+    let buildpath = match run_in_buildpath(~\"installing\", path,\n                                          ~\"/build\", cf, ~[]) {\n       none => return,\n       some(bp) => bp\n@@ -752,7 +752,7 @@ fn install_one_crate(c: cargo, path: ~str, cf: ~str) {\n \n \n fn rustc_sysroot() -> ~str {\n-    alt os::self_exe_path() {\n+    match os::self_exe_path() {\n         some(path) => {\n             let path = ~[path, ~\"..\", ~\"bin\", ~\"rustc\"];\n             let rustc = path::normalize(path::connect_many(path));\n@@ -779,7 +779,7 @@ fn install_source(c: cargo, path: ~str) {\n     }\n \n     for cratefiles.each |cf| {\n-        alt load_crate(cf) {\n+        match load_crate(cf) {\n             none => again,\n             some(crate) => {\n               for crate.deps.each |query| {\n@@ -788,7 +788,7 @@ fn install_source(c: cargo, path: ~str) {\n                     // condition\")\n \n                     let wd_base = c.workdir + path::path_sep();\n-                    let wd = alt tempfile::mkdtemp(wd_base, ~\"\") {\n+                    let wd = match tempfile::mkdtemp(wd_base, ~\"\") {\n                         some(wd) => wd,\n                         none => fail fmt!{\"needed temp dir: %s\", wd_base}\n                     };\n@@ -838,15 +838,15 @@ fn install_file(c: cargo, wd: ~str, path: ~str) {\n \n fn install_package(c: cargo, src: ~str, wd: ~str, pkg: package) {\n     let url = copy pkg.url;\n-    let method = alt pkg.method {\n+    let method = match pkg.method {\n         ~\"git\" => ~\"git\",\n         ~\"file\" => ~\"file\",\n         _ => ~\"curl\"\n     };\n \n     info(fmt!{\"installing %s/%s via %s...\", src, pkg.name, method});\n \n-    alt method {\n+    match method {\n         ~\"git\" => install_git(c, wd, url, copy pkg.reference),\n         ~\"file\" => install_file(c, wd, url),\n         ~\"curl\" => install_curl(c, wd, copy url),\n@@ -913,7 +913,7 @@ fn install_named(c: cargo, wd: ~str, name: ~str) {\n }\n \n fn install_uuid_specific(c: cargo, wd: ~str, src: ~str, uuid: ~str) {\n-    alt c.sources.find(src) {\n+    match c.sources.find(src) {\n       some(s) => {\n         let packages = copy s.packages;\n         if vec::any(packages, |p| {\n@@ -929,7 +929,7 @@ fn install_uuid_specific(c: cargo, wd: ~str, src: ~str, uuid: ~str) {\n }\n \n fn install_named_specific(c: cargo, wd: ~str, src: ~str, name: ~str) {\n-    alt c.sources.find(src) {\n+    match c.sources.find(src) {\n         some(s) => {\n           let packages = copy s.packages;\n           if vec::any(packages, |p| {\n@@ -960,7 +960,7 @@ fn cmd_uninstall(c: cargo) {\n     // name only)\n     if is_uuid(target) {\n         for os::list_dir(lib).each |file| {\n-            alt str::find_str(file, ~\"-\" + target + ~\"-\") {\n+            match str::find_str(file, ~\"-\" + target + ~\"-\") {\n                 some(idx) => {\n                     let full = path::normalize(path::connect(lib, file));\n                     if os::remove_file(full) {\n@@ -977,7 +977,7 @@ fn cmd_uninstall(c: cargo) {\n         error(~\"can't find package with uuid: \" + target);\n     } else {\n         for os::list_dir(lib).each |file| {\n-            alt str::find_str(file, ~\"lib\" + target + ~\"-\") {\n+            match str::find_str(file, ~\"lib\" + target + ~\"-\") {\n                 some(idx) => {\n                     let full = path::normalize(path::connect(lib,\n                                file));\n@@ -992,7 +992,7 @@ fn cmd_uninstall(c: cargo) {\n             }\n         }\n         for os::list_dir(bin).each |file| {\n-            alt str::find_str(file, target) {\n+            match str::find_str(file, target) {\n                 some(idx) => {\n                     let full = path::normalize(path::connect(bin, file));\n                     if os::remove_file(full) {\n@@ -1011,7 +1011,7 @@ fn cmd_uninstall(c: cargo) {\n }\n \n fn install_query(c: cargo, wd: ~str, target: ~str) {\n-    alt c.dep_cache.find(target) {\n+    match c.dep_cache.find(target) {\n         some(inst) => {\n             if inst {\n                 return;\n@@ -1038,7 +1038,7 @@ fn install_query(c: cargo, wd: ~str, target: ~str) {\n     } else {\n         let mut ps = copy target;\n \n-        alt str::find_char(ps, '/') {\n+        match str::find_char(ps, '/') {\n             option::some(idx) => {\n                 let source = str::slice(ps, 0u, idx);\n                 ps = str::slice(ps, idx + 1u, str::len(ps));\n@@ -1072,7 +1072,7 @@ fn install_query(c: cargo, wd: ~str, target: ~str) {\n \n fn cmd_install(c: cargo) unsafe {\n     let wd_base = c.workdir + path::path_sep();\n-    let wd = alt tempfile::mkdtemp(wd_base, ~\"\") {\n+    let wd = match tempfile::mkdtemp(wd_base, ~\"\") {\n         some(wd) => wd,\n         none => fail fmt!{\"needed temp dir: %s\", wd_base}\n     };\n@@ -1129,7 +1129,7 @@ fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n     os::copy_file(path::connect(url, ~\"source.json.sig\"), srcsigfile);\n     os::copy_file(path::connect(url, ~\"packages.json.sig\"), sigfile);\n \n-    alt copy src.key {\n+    match copy src.key {\n         some(u) => {\n             let p = run::program_output(~\"curl\",\n                                         ~[~\"-f\", ~\"-s\", ~\"-o\", keyfile, u]);\n@@ -1141,7 +1141,7 @@ fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n         }\n         _ => ()\n     }\n-    alt (src.key, src.keyfp) {\n+    match (src.key, src.keyfp) {\n         (some(_), some(f)) => {\n             let r = pgp::verify(c.root, pkgfile, sigfile, f);\n \n@@ -1238,7 +1238,7 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n \n     let has_src_file = os::path_exists(srcfile);\n \n-    alt copy src.key {\n+    match copy src.key {\n         some(u) => {\n             let p = run::program_output(~\"curl\",\n                                         ~[~\"-f\", ~\"-s\", ~\"-o\", keyfile, u]);\n@@ -1251,7 +1251,7 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n         }\n         _ => ()\n     }\n-    alt (src.key, src.keyfp) {\n+    match (src.key, src.keyfp) {\n         (some(_), some(f)) => {\n             let r = pgp::verify(c.root, pkgfile, sigfile, f);\n \n@@ -1318,7 +1318,7 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n         }\n     }\n \n-    alt copy src.key {\n+    match copy src.key {\n         some(u) => {\n             let p = run::program_output(~\"curl\",\n                                         ~[~\"-f\", ~\"-s\", ~\"-o\", keyfile, u]);\n@@ -1330,7 +1330,7 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n         }\n         _ => ()\n     }\n-    alt (src.key, src.keyfp) {\n+    match (src.key, src.keyfp) {\n         (some(_), some(f)) => {\n             if smart {\n                 url = src.url + ~\"/packages.json.sig\";\n@@ -1403,7 +1403,7 @@ fn sync_one(c: cargo, src: source) {\n \n     need_dir(dir);\n \n-    let result = alt src.method {\n+    let result = match src.method {\n         ~\"git\" => sync_one_git(c, dir, src),\n         ~\"file\" => sync_one_file(c, dir, src),\n         _ => sync_one_curl(c, dir, src)\n@@ -1490,7 +1490,7 @@ fn cmd_list(c: cargo) {\n             if !valid_pkg_name(name) {\n                 error(fmt!{\"'%s' is an invalid source name\", name});\n             } else {\n-                alt c.sources.find(name) {\n+                match c.sources.find(name) {\n                     some(source) => {\n                         print_source(source);\n                     }\n@@ -1562,7 +1562,7 @@ fn dump_sources(c: cargo) {\n         copy_warn(out, path::connect(c.root, ~\"sources.json.old\"));\n     }\n \n-    alt io::buffered_file_writer(out) {\n+    match io::buffered_file_writer(out) {\n         result::ok(writer) => {\n             let hash = map::str_hash();\n             let root = json::dict(hash);\n@@ -1574,13 +1574,13 @@ fn dump_sources(c: cargo) {\n                 chash.insert(~\"url\", json::string(@v.url));\n                 chash.insert(~\"method\", json::string(@v.method));\n \n-                alt copy v.key {\n+                match copy v.key {\n                     some(key) => {\n                         chash.insert(~\"key\", json::string(@key));\n                     }\n                     _ => ()\n                 }\n-                alt copy v.keyfp {\n+                match copy v.keyfp {\n                     some(keyfp) => {\n                         chash.insert(~\"keyfp\", json::string(@keyfp));\n                     }\n@@ -1615,7 +1615,7 @@ fn cmd_sources(c: cargo) {\n \n     let action = c.opts.free[2u];\n \n-    alt action {\n+    match action {\n         ~\"clear\" => {\n           for c.sources.each_key |k| {\n                 c.sources.remove(k);\n@@ -1637,7 +1637,7 @@ fn cmd_sources(c: cargo) {\n                 return;\n             }\n \n-            alt c.sources.find(name) {\n+            match c.sources.find(name) {\n                 some(source) => {\n                     error(fmt!{\"source already exists: %s\", name});\n                 }\n@@ -1667,7 +1667,7 @@ fn cmd_sources(c: cargo) {\n                 return;\n             }\n \n-            alt c.sources.find(name) {\n+            match c.sources.find(name) {\n                 some(source) => {\n                     c.sources.remove(name);\n                     info(fmt!{\"removed source: %s\", name});\n@@ -1691,7 +1691,7 @@ fn cmd_sources(c: cargo) {\n                 return;\n             }\n \n-            alt c.sources.find(name) {\n+            match c.sources.find(name) {\n                 some(source) => {\n                     let old = copy source.url;\n                     let method = assume_source_method(url);\n@@ -1722,11 +1722,11 @@ fn cmd_sources(c: cargo) {\n                 return;\n             }\n \n-            alt c.sources.find(name) {\n+            match c.sources.find(name) {\n                 some(source) => {\n                     let old = copy source.method;\n \n-                    source.method = alt method {\n+                    source.method = match method {\n                         ~\"git\" => ~\"git\",\n                         ~\"file\" => ~\"file\",\n                         _ => ~\"curl\"\n@@ -1760,7 +1760,7 @@ fn cmd_sources(c: cargo) {\n                 return;\n             }\n \n-            alt c.sources.find(name) {\n+            match c.sources.find(name) {\n                 some(source) => {\n                     c.sources.remove(name);\n                     c.sources.insert(newn, source);\n@@ -1874,7 +1874,7 @@ fn main(argv: ~[~str]) {\n         return;\n     }\n     if o.help {\n-        alt o.free[1] {\n+        match o.free[1] {\n             ~\"init\" => cmd_usage_init(),\n             ~\"install\" => cmd_usage_install(),\n             ~\"uninstall\" => cmd_usage_uninstall(),\n@@ -1901,7 +1901,7 @@ fn main(argv: ~[~str]) {\n         c = configure(o);\n     }\n \n-    alt o.free[1] {\n+    match o.free[1] {\n         ~\"init\" => cmd_init(c),\n         ~\"install\" => cmd_install(c),\n         ~\"uninstall\" => cmd_uninstall(c),"}, {"sha": "fd9a12aa1f7b66d2ed5c41106cbaeaa644a7093b", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -37,7 +37,7 @@ fn parse_config(args: ~[~str]) -> config {\n     assert (vec::is_not_empty(args));\n     let args_ = vec::tail(args);\n     let matches =\n-        alt getopts::getopts(args_, opts) {\n+        match getopts::getopts(args_, opts) {\n           ok(m) => m,\n           err(f) => fail getopts::fail_str(f)\n         };\n@@ -80,15 +80,15 @@ fn log_config(config: config) {\n }\n \n fn opt_str(maybestr: option<~str>) -> ~str {\n-    alt maybestr { option::some(s) => s, option::none => ~\"(none)\" }\n+    match maybestr { option::some(s) => s, option::none => ~\"(none)\" }\n }\n \n fn str_opt(maybestr: ~str) -> option<~str> {\n     if maybestr != ~\"(none)\" { option::some(maybestr) } else { option::none }\n }\n \n fn str_mode(s: ~str) -> mode {\n-    alt s {\n+    match s {\n       ~\"compile-fail\" => mode_compile_fail,\n       ~\"run-fail\" => mode_run_fail,\n       ~\"run-pass\" => mode_run_pass,\n@@ -98,7 +98,7 @@ fn str_mode(s: ~str) -> mode {\n }\n \n fn mode_str(mode: mode) -> ~str {\n-    alt mode {\n+    match mode {\n       mode_compile_fail => ~\"compile-fail\",\n       mode_run_fail => ~\"run-fail\",\n       mode_run_pass => ~\"run-pass\",\n@@ -115,13 +115,13 @@ fn run_tests(config: config) {\n \n fn test_opts(config: config) -> test::test_opts {\n     {filter:\n-         alt config.filter {\n+         match config.filter {\n            option::some(s) => option::some(s),\n            option::none => option::none\n          },\n      run_ignored: config.run_ignored,\n      logfile:\n-         alt config.logfile {\n+         match config.logfile {\n            option::some(s) => option::some(s),\n            option::none => option::none\n          }\n@@ -144,7 +144,7 @@ fn make_tests(config: config) -> ~[test::test_desc] {\n fn is_test(config: config, testfile: ~str) -> bool {\n     // Pretty-printer does not work with .rc files yet\n     let valid_extensions =\n-        alt config.mode {\n+        match config.mode {\n           mode_pretty => ~[~\".rs\"],\n           _ => ~[~\".rc\", ~\".rs\"]\n         };"}, {"sha": "53599a9ad0e453b6350deb01b290338729f91868", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -23,7 +23,7 @@ fn load_errors(testfile: ~str) -> ~[expected_error] {\n fn parse_expected(line_num: uint, line: ~str) -> ~[expected_error] unsafe {\n     let error_tag = ~\"//~\";\n     let mut idx;\n-    alt str::find_str(line, error_tag) {\n+    match str::find_str(line, error_tag) {\n       option::none => return ~[],\n       option::some(nn) => { idx = (nn as uint) + str::len(error_tag); }\n     }"}, {"sha": "bf58e809692592fe5b28331d9d41b0f7645a3b50", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -30,7 +30,7 @@ fn load_props(testfile: ~str) -> test_props {\n     let mut compile_flags = option::none;\n     let mut pp_exact = option::none;\n     for iter_header(testfile) |ln| {\n-        alt parse_error_pattern(ln) {\n+        match parse_error_pattern(ln) {\n           option::some(ep) => vec::push(error_patterns, ep),\n           option::none => ()\n         };\n@@ -107,7 +107,7 @@ fn parse_exec_env(line: ~str) -> option<(~str, ~str)> {\n     do parse_name_value_directive(line, ~\"exec-env\").map |nv| {\n         // nv is either FOO or FOO=BAR\n         let strs = str::splitn_char(nv, '=', 1u);\n-        alt strs.len() {\n+        match strs.len() {\n           1u => (strs[0], ~\"\"),\n           2u => (strs[0], strs[1]),\n           n => fail fmt!{\"Expected 1 or 2 strings, not %u\", n}\n@@ -116,7 +116,7 @@ fn parse_exec_env(line: ~str) -> option<(~str, ~str)> {\n }\n \n fn parse_pp_exact(line: ~str, testfile: ~str) -> option<~str> {\n-    alt parse_name_value_directive(line, ~\"pp-exact\") {\n+    match parse_name_value_directive(line, ~\"pp-exact\") {\n       option::some(s) => option::some(s),\n       option::none => {\n         if parse_name_directive(line, ~\"pp-exact\") {\n@@ -135,7 +135,7 @@ fn parse_name_directive(line: ~str, directive: ~str) -> bool {\n fn parse_name_value_directive(line: ~str,\n                               directive: ~str) -> option<~str> unsafe {\n     let keycolon = directive + ~\":\";\n-    alt str::find_str(line, keycolon) {\n+    match str::find_str(line, keycolon) {\n         option::some(colon) => {\n             let value = str::slice(line, colon + str::len(keycolon),\n                                    str::len(line));"}, {"sha": "ba4249999a471750a66d70ee7bb4ab1d371fb7fd", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -76,7 +76,7 @@ fn run(lib_path: ~str,\n     let mut outs = ~\"\";\n     let mut count = 2;\n     while count > 0 {\n-        alt p.recv() {\n+        match p.recv() {\n           (1, s) => {\n             outs = s;\n           }"}, {"sha": "7a2d3456ed685abfeaf8d6376d121b893f1929a9", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -18,7 +18,7 @@ fn run(config: config, testfile: ~str) {\n     }\n     debug!{\"running %s\", testfile};\n     let props = load_props(testfile);\n-    alt config.mode {\n+    match config.mode {\n       mode_compile_fail => run_cfail_test(config, props, testfile),\n       mode_run_fail => run_rfail_test(config, props, testfile),\n       mode_run_pass => run_rpass_test(config, props, testfile),\n@@ -90,7 +90,7 @@ fn run_pretty_test(config: config, props: test_props, testfile: ~str) {\n     } else { logv(config, ~\"testing for converging pretty-printing\"); }\n \n     let rounds =\n-        alt props.pp_exact { option::some(_) => 1, option::none => 2 };\n+        match props.pp_exact { option::some(_) => 1, option::none => 2 };\n \n     let mut srcs = ~[result::get(io::read_whole_file_str(testfile))];\n \n@@ -109,7 +109,7 @@ fn run_pretty_test(config: config, props: test_props, testfile: ~str) {\n     }\n \n     let mut expected =\n-        alt props.pp_exact {\n+        match props.pp_exact {\n           option::some(file) => {\n             let filepath = path::connect(path::dirname(testfile), file);\n             result::get(io::read_whole_file_str(filepath))\n@@ -383,7 +383,7 @@ fn make_run_args(config: config, _props: test_props, testfile: ~str) ->\n             // If we've got another tool to run under (valgrind),\n             // then split apart its command\n             let runtool =\n-                alt config.runtool {\n+                match config.runtool {\n                   option::some(s) => option::some(s),\n                   option::none => option::none\n                 };\n@@ -402,7 +402,7 @@ fn split_maybe_args(argstr: option<~str>) -> ~[~str] {\n         vec::filter_map(v, flt)\n     }\n \n-    alt argstr {\n+    match argstr {\n       option::some(s) => rm_whitespace(str::split_char(s, ' ')),\n       option::none => ~[]\n     }"}, {"sha": "0c7a0235bee92c22127387d548d1abf59b74214a", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -7,7 +7,7 @@ fn make_new_path(path: ~str) -> ~str {\n \n     // Windows just uses PATH as the library search path, so we have to\n     // maintain the current value while adding our own\n-    alt getenv(lib_path_env_var()) {\n+    match getenv(lib_path_env_var()) {\n       option::some(curr) => {\n         fmt!{\"%s%s%s\", path, path_div(), curr}\n       }"}, {"sha": "230ef3d981f6a4246930428b7f51916dfb694513", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -62,9 +62,9 @@ pure fn safe_to_steal_expr(e: @ast::expr, tm: test_mode) -> bool {\n }\n \n pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n-    alt tm {\n+    match tm {\n       tm_converge => {\n-        alt e.node {\n+        match e.node {\n           // If the fuzzer moves a block-ending-in-semicolon into callee\n           // position, the pretty-printer can't preserve this even by\n           // parenthesizing!!  See email to marijn.\n@@ -139,7 +139,7 @@ fn steal(crate: ast::crate, tm: test_mode) -> stolen_stuff {\n \n \n fn safe_to_replace_expr(e: ast::expr_, _tm: test_mode) -> bool {\n-    alt e {\n+    match e {\n       // https://github.com/mozilla/rust/issues/652\n       ast::expr_if(*) => { false }\n       ast::expr_block(_) => { false }\n@@ -152,7 +152,7 @@ fn safe_to_replace_expr(e: ast::expr_, _tm: test_mode) -> bool {\n }\n \n fn safe_to_replace_ty(t: ast::ty_, _tm: test_mode) -> bool {\n-    alt t {\n+    match t {\n       ast::ty_infer => { false } // always implicit, always top level\n       ast::ty_bot => { false }   // in source, can only appear\n                               // as the out type of a function\n@@ -272,7 +272,7 @@ fn check_variants_T<T: copy>(\n                         io::str_reader(~\"\"), a,\n                         pprust::no_ann(),\n                         false));\n-                alt cx.mode {\n+                match cx.mode {\n                   tm_converge => {\n                     check_roundtrip_convergence(str3, 1u);\n                   }\n@@ -314,12 +314,12 @@ fn check_whole_compiler(code: ~str, suggested_filename_prefix: ~str,\n \n     let compile_result = check_compiling(filename);\n \n-    let run_result = alt (compile_result, allow_running) {\n+    let run_result = match (compile_result, allow_running) {\n       (passed, true) => { check_running(suggested_filename_prefix) }\n       (h, _) => { h }\n     };\n \n-    alt run_result {\n+    match run_result {\n       passed | cleanly_rejected(_) | known_bug(_) => {\n         removeIfExists(suggested_filename_prefix);\n         removeIfExists(suggested_filename_prefix + ~\".rs\");\n@@ -364,7 +364,7 @@ fn check_running(exe_filename: ~str) -> happiness {\n     } else if contains(comb, ~\"malloc\") {\n         failed(~\"Mentioned malloc\")\n     } else {\n-        alt p.status {\n+        match p.status {\n             0         => { passed }\n             100       => { cleanly_rejected(~\"running: explicit fail\") }\n             101 | 247 => { cleanly_rejected(~\"running: timed out\") }\n@@ -441,7 +441,7 @@ fn parse_and_print(code: @~str) -> ~str {\n fn has_raw_pointers(c: ast::crate) -> bool {\n     let has_rp = @mut false;\n     fn visit_ty(flag: @mut bool, t: @ast::ty) {\n-        alt t.node {\n+        match t.node {\n           ast::ty_ptr(_) => { *flag = true; }\n           _ => { }\n         }"}, {"sha": "f8eb96996d0760b663068e07e75bce2505951200", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -39,7 +39,7 @@ pure fn is_false(v: bool) -> bool { !v }\n \n /// Parse logic value from `s`\n pure fn from_str(s: ~str) -> option<bool> {\n-    alt check s {\n+    match check s {\n       ~\"true\" => some(true),\n       ~\"false\" => some(false),\n       _ => none"}, {"sha": "98aeddcf27322bfe00cc774b6d5b2a6a879d7c6f", "filename": "src/libcore/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -113,7 +113,7 @@ pure fn is_digit(c: char) -> bool {\n  * refer to a digit in the given radix.\n  */\n pure fn to_digit(c: char, radix: uint) -> option<uint> {\n-    let val = alt c {\n+    let val = match c {\n       '0' to '9' => c as uint - ('0' as uint),\n       'a' to 'z' => c as uint + 10u - ('a' as uint),\n       'A' to 'Z' => c as uint + 10u - ('A' as uint),\n@@ -158,7 +158,7 @@ fn escape_unicode(c: char) -> ~str {\n  *   - Any other chars are given hex unicode escapes; see `escape_unicode`.\n  */\n fn escape_default(c: char) -> ~str {\n-    alt c {\n+    match c {\n       '\\t' => ~\"\\\\t\",\n       '\\r' => ~\"\\\\r\",\n       '\\n' => ~\"\\\\n\","}, {"sha": "794bdc90885891c0182f8d237d58d3b045957ffd", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -409,7 +409,7 @@ fn test_select2_stress() {\n     let mut as = 0;\n     let mut bs = 0;\n     for iter::repeat(msgs * times * 2u) {\n-        alt check select2(po_a, po_b) {\n+        match check select2(po_a, po_b) {\n           either::left(~\"a\") => as += 1,\n           either::right(~\"b\") => bs += 1\n         }"}, {"sha": "9d410c03d6ae9d4e7fa15e97e5cb16b5503848ea", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -26,17 +26,17 @@ enum dlist<T> = @{\n \n impl private_methods<T> for dlist_node<T> {\n     pure fn assert_links() {\n-        alt self.next {\n-            some(neighbour) => alt neighbour.prev {\n+        match self.next {\n+            some(neighbour) => match neighbour.prev {\n               some(me) => if !box::ptr_eq(*self, *me) {\n                   fail ~\"Asymmetric next-link in dlist node.\"\n               }\n               none => fail ~\"One-way next-link in dlist node.\"\n             }\n             none => ()\n         }\n-        alt self.prev {\n-            some(neighbour) => alt neighbour.next {\n+        match self.prev {\n+            some(neighbour) => match neighbour.next {\n               some(me) => if !box::ptr_eq(*me, *self) {\n                   fail ~\"Asymmetric prev-link in dlist node.\"\n               }\n@@ -55,7 +55,7 @@ impl extensions<T> for dlist_node<T> {\n     }\n     /// Get the next node in the list, failing if there isn't one.\n     pure fn next_node() -> dlist_node<T> {\n-        alt self.next_link() {\n+        match self.next_link() {\n             some(nobe) => nobe,\n             none       => fail ~\"This dlist node has no next neighbour.\"\n         }\n@@ -67,7 +67,7 @@ impl extensions<T> for dlist_node<T> {\n     }\n     /// Get the previous node in the list, failing if there isn't one.\n     pure fn prev_node() -> dlist_node<T> {\n-        alt self.prev_link() {\n+        match self.prev_link() {\n             some(nobe) => nobe,\n             none       => fail ~\"This dlist node has no previous neighbour.\"\n         }\n@@ -138,11 +138,11 @@ impl private_methods<T> for dlist<T> {\n     // the head and/or tail pointers appropriately.\n     #[inline(always)]\n     fn link(+before: dlist_link<T>, +after: dlist_link<T>) {\n-        alt before {\n+        match before {\n             some(neighbour) => neighbour.next = after,\n             none            => self.hd        = after\n         }\n-        alt after {\n+        match after {\n             some(neighbour) => neighbour.prev = before,\n             none            => self.tl        = before\n         }\n@@ -286,14 +286,14 @@ impl extensions<T> for dlist<T> {\n \n     /// Get the node at the list's head, failing if empty. O(1).\n     pure fn head_n() -> dlist_node<T> {\n-        alt self.hd {\n+        match self.hd {\n             some(nobe) => nobe,\n             none       => fail ~\"Attempted to get the head of an empty dlist.\"\n         }\n     }\n     /// Get the node at the list's tail, failing if empty. O(1).\n     pure fn tail_n() -> dlist_node<T> {\n-        alt self.tl {\n+        match self.tl {\n             some(nobe) => nobe,\n             none       => fail ~\"Attempted to get the tail of an empty dlist.\"\n         }"}, {"sha": "a05df4e608ae212037f4baeaf923995bf5ae8887", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -222,7 +222,7 @@ impl extensions<A:copy> for dvec<A> {\n      */\n     fn append_iter<A, I:iter::base_iter<A>>(ts: I) {\n         do self.swap |v| {\n-           let mut v = alt ts.size_hint() {\n+           let mut v = match ts.size_hint() {\n              none { v }\n              some(h) {\n                let len = v.len() + h;"}, {"sha": "06999513889326d42354b35cefb6970062eb311c", "filename": "src/libcore/either.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -18,7 +18,7 @@ fn either<T, U, V>(f_left: fn(T) -> V,\n      * result is returned.\n      */\n \n-    alt value {\n+    match value {\n       left(l) => f_left(l),\n       right(r) => f_right(r)\n     }\n@@ -29,7 +29,7 @@ fn lefts<T: copy, U>(eithers: ~[either<T, U>]) -> ~[T] {\n \n     let mut result: ~[T] = ~[];\n     for vec::each(eithers) |elt| {\n-        alt elt {\n+        match elt {\n           left(l) => vec::push(result, l),\n           _ => { /* fallthrough */ }\n         }\n@@ -42,7 +42,7 @@ fn rights<T, U: copy>(eithers: ~[either<T, U>]) -> ~[U] {\n \n     let mut result: ~[U] = ~[];\n     for vec::each(eithers) |elt| {\n-        alt elt {\n+        match elt {\n           right(r) => vec::push(result, r),\n           _ => { /* fallthrough */ }\n         }\n@@ -62,7 +62,7 @@ fn partition<T: copy, U: copy>(eithers: ~[either<T, U>])\n     let mut lefts: ~[T] = ~[];\n     let mut rights: ~[U] = ~[];\n     for vec::each(eithers) |elt| {\n-        alt elt {\n+        match elt {\n           left(l) => vec::push(lefts, l),\n           right(r) => vec::push(rights, r)\n         }\n@@ -73,7 +73,7 @@ fn partition<T: copy, U: copy>(eithers: ~[either<T, U>])\n pure fn flip<T: copy, U: copy>(eith: either<T, U>) -> either<U, T> {\n     //! Flips between left and right of a given either\n \n-    alt eith {\n+    match eith {\n       right(r) => left(r),\n       left(l) => right(l)\n     }\n@@ -88,7 +88,7 @@ pure fn to_result<T: copy, U: copy>(\n      * an ok result, and the \"left\" choice a fail\n      */\n \n-    alt eith {\n+    match eith {\n       right(r) => result::ok(r),\n       left(l) => result::err(l)\n     }\n@@ -97,13 +97,13 @@ pure fn to_result<T: copy, U: copy>(\n pure fn is_left<T, U>(eith: either<T, U>) -> bool {\n     //! Checks whether the given value is a left\n \n-    alt eith { left(_) => true, _ => false }\n+    match eith { left(_) => true, _ => false }\n }\n \n pure fn is_right<T, U>(eith: either<T, U>) -> bool {\n     //! Checks whether the given value is a right\n \n-    alt eith { right(_) => true, _ => false }\n+    match eith { right(_) => true, _ => false }\n }\n \n #[test]"}, {"sha": "fba8968103c392d39f0aed54090d80e8d55cc761", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -122,7 +122,7 @@ mod ct {\n         let c = s[i];\n         if !('0' as u8 <= c && c <= '9' as u8) { return option::none; }\n         let n = (c - ('0' as u8)) as uint;\n-        return alt peek_num(s, i + 1u, lim) {\n+        return match peek_num(s, i + 1u, lim) {\n               none => some({num: n, next: i + 1u}),\n               some(next) => {\n                 let m = next.num;\n@@ -150,7 +150,7 @@ mod ct {\n        {param: option<int>, next: uint} {\n         if i >= lim { return {param: none, next: i}; }\n         let num = peek_num(s, i, lim);\n-        return alt num {\n+        return match num {\n               none => {param: none, next: i},\n               some(t) => {\n                 let n = t.num;\n@@ -195,13 +195,13 @@ mod ct {\n             } else if s[i] == '*' as u8 {\n                 let param = parse_parameter(s, i + 1u, lim);\n                 let j = param.next;\n-                alt param.param {\n+                match param.param {\n                   none => {count: count_is_next_param, next: j},\n                   some(n) => {count: count_is_param(n), next: j}\n                 }\n             } else {\n                 let num = peek_num(s, i, lim);\n-                alt num {\n+                match num {\n                   none => {count: count_implied, next: i},\n                   some(num) => {\n                     count: count_is(num.num as int),\n@@ -220,7 +220,7 @@ mod ct {\n \n                 // If there were no digits specified, i.e. the precision\n                 // was \".\", then the precision is 0\n-                alt count.count {\n+                match count.count {\n                   count_implied => {count: count_is(0), next: count.next},\n                   _ => count\n                 }\n@@ -294,7 +294,7 @@ mod rt {\n     pure fn conv_uint(cv: conv, u: uint) -> ~str {\n         let prec = get_int_precision(cv);\n         let mut rs =\n-            alt cv.ty {\n+            match cv.ty {\n               ty_default => uint_to_str_prec(u, 10u, prec),\n               ty_hex_lower => uint_to_str_prec(u, 16u, prec),\n               ty_hex_upper => str::to_upper(uint_to_str_prec(u, 16u, prec)),\n@@ -316,7 +316,7 @@ mod rt {\n     pure fn conv_str(cv: conv, s: &str) -> ~str {\n         // For strings, precision is the maximum characters\n         // displayed\n-        let mut unpadded = alt cv.precision {\n+        let mut unpadded = match cv.precision {\n           count_implied => s.to_unique(),\n           count_is(max) => if max as uint < str::char_len(s) {\n             str::substr(s, 0u, max as uint)\n@@ -327,7 +327,7 @@ mod rt {\n         return unchecked { pad(cv, unpadded, pad_nozero) };\n     }\n     pure fn conv_float(cv: conv, f: float) -> ~str {\n-        let (to_str, digits) = alt cv.precision {\n+        let (to_str, digits) = match cv.precision {\n               count_is(c) => (float::to_str_exact, c as uint),\n               count_implied => (float::to_str, 6u)\n         };\n@@ -371,14 +371,14 @@ mod rt {\n             };\n     }\n     pure fn get_int_precision(cv: conv) -> uint {\n-        return alt cv.precision {\n+        return match cv.precision {\n               count_is(c) => c as uint,\n               count_implied => 1u\n             };\n     }\n     enum pad_mode { pad_signed, pad_unsigned, pad_nozero, pad_float }\n     fn pad(cv: conv, &s: ~str, mode: pad_mode) -> ~str {\n-        let uwidth : uint = alt cv.width {\n+        let uwidth : uint = match cv.width {\n           count_implied => return s,\n           count_is(width) => {\n               // FIXME: width should probably be uint (see Issue #1996)\n@@ -393,14 +393,14 @@ mod rt {\n             let padstr = str::from_chars(vec::from_elem(diff, padchar));\n             return s + padstr;\n         }\n-        let {might_zero_pad, signed} = alt mode {\n+        let {might_zero_pad, signed} = match mode {\n           pad_nozero => {might_zero_pad:false, signed:false},\n           pad_signed => {might_zero_pad:true,  signed:true },\n           pad_float => {might_zero_pad:true,  signed:true},\n           pad_unsigned => {might_zero_pad:true,  signed:false}\n         };\n         pure fn have_precision(cv: conv) -> bool {\n-            return alt cv.precision { count_implied => false, _ => true };\n+            return match cv.precision { count_implied => false, _ => true };\n         }\n         let zero_padding = {\n             if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&"}, {"sha": "4269ef41f4db696f419382fa406dc6693d8638da", "filename": "src/libcore/float.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -256,14 +256,14 @@ fn from_str(num: ~str) -> option<float> {\n    let mut c     = 'z';            //Latest char.\n \n    //The string must start with one of the following characters.\n-   alt str::char_at(num, 0u) {\n+   match str::char_at(num, 0u) {\n       '-' | '+' | '0' to '9' | '.' => (),\n       _ => return none\n    }\n \n    //Determine if first char is '-'/'+'. Set [pos] and [neg] accordingly.\n    let mut neg = false;               //Sign of the result\n-   alt str::char_at(num, 0u) {\n+   match str::char_at(num, 0u) {\n       '-' => {\n           neg = true;\n           pos = 1u;\n@@ -279,7 +279,7 @@ fn from_str(num: ~str) -> option<float> {\n        let char_range = str::char_range_at(num, pos);\n        c   = char_range.ch;\n        pos = char_range.next;\n-       alt c {\n+       match c {\n          '0' to '9' => {\n            total = total * 10f;\n            total += ((c as int) - ('0' as int)) as float;\n@@ -295,7 +295,7 @@ fn from_str(num: ~str) -> option<float> {\n          let char_range = str::char_range_at(num, pos);\n          c = char_range.ch;\n          pos = char_range.next;\n-         alt c {\n+         match c {\n             '0' | '1' | '2' | '3' | '4' | '5' | '6'| '7' | '8' | '9'  => {\n                  decimal /= 10f;\n                  total += (((c as int) - ('0' as int)) as float)*decimal;\n@@ -312,7 +312,7 @@ fn from_str(num: ~str) -> option<float> {\n       if(pos < len) {\n           let char_range = str::char_range_at(num, pos);\n           c   = char_range.ch;\n-          alt c  {\n+          match c  {\n              '+' => {\n                 pos = char_range.next;\n              }\n@@ -325,7 +325,7 @@ fn from_str(num: ~str) -> option<float> {\n           while(pos < len) {\n              let char_range = str::char_range_at(num, pos);\n              c = char_range.ch;\n-             alt c {\n+             match c {\n                  '0' | '1' | '2' | '3' | '4' | '5' | '6'| '7' | '8' | '9' => {\n                      exponent *= 10u;\n                      exponent += ((c as uint) - ('0' as uint));\n@@ -447,7 +447,7 @@ fn test_from_str() {\n    assert from_str(~\"inf\") == some(infinity);\n    assert from_str(~\"-inf\") == some(neg_infinity);\n    // note: NaN != NaN, hence this slightly complex test\n-   alt from_str(~\"NaN\") {\n+   match from_str(~\"NaN\") {\n        some(f) => assert is_NaN(f),\n        none => fail\n    }"}, {"sha": "8b7b51eef58dc7b378e0e50353d82a934b17ca1d", "filename": "src/libcore/future.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -77,7 +77,7 @@ fn from_port<A:send>(-port: future_pipe::client::waiting<A>) -> future<A> {\n         let mut port_ = none;\n         port_ <-> *port;\n         let port = option::unwrap(port_);\n-        alt recv(port) {\n+        match recv(port) {\n           future_pipe::completed(data) => move_it!{data}\n         }\n     }\n@@ -119,7 +119,7 @@ fn get<A:copy>(future: future<A>) -> A {\n fn with<A,B>(future: future<A>, blk: fn(A) -> B) -> B {\n     //! Work with the value without copying it\n \n-    let v = alt copy future.v {\n+    let v = match copy future.v {\n       either::left(v) => v,\n       either::right(f) => {\n         let v = @f();"}, {"sha": "897f4030a47fa88785f31b2ccc2a0b295efb3f4a", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -144,7 +144,7 @@ fn parse_buf(buf: ~[u8], radix: uint) -> option<T> {\n     }\n     let mut n = 0 as T;\n     loop {\n-        alt char::to_digit(buf[i] as char, radix) {\n+        match char::to_digit(buf[i] as char, radix) {\n           some(d) => n += (d as T) * power,\n           none => return none\n         }"}, {"sha": "2946700f83265facd2ff781121c1afe5980546a5", "filename": "src/libcore/io.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -196,7 +196,7 @@ impl reader_util for reader {\n // Reader implementations\n \n fn convert_whence(whence: seek_style) -> i32 {\n-    return alt whence {\n+    return match whence {\n       seek_set => 0i32,\n       seek_cur => 1i32,\n       seek_end => 2i32\n@@ -440,7 +440,7 @@ fn mk_file_writer(path: ~str, flags: ~[fileflag])\n \n     let mut fflags: c_int = wb();\n     for vec::each(flags) |f| {\n-        alt f {\n+        match f {\n           append => fflags |= O_APPEND as c_int,\n           create => fflags |= O_CREAT as c_int,\n           truncate => fflags |= O_TRUNC as c_int,\n@@ -460,7 +460,7 @@ fn mk_file_writer(path: ~str, flags: ~[fileflag])\n \n fn u64_to_le_bytes<T>(n: u64, size: uint, f: fn(v: &[u8]) -> T) -> T {\n     assert size <= 8u;\n-    alt size {\n+    match size {\n       1u => f(&[n as u8]),\n       2u => f(&[n as u8,\n               (n >> 8) as u8]),\n@@ -491,7 +491,7 @@ fn u64_to_le_bytes<T>(n: u64, size: uint, f: fn(v: &[u8]) -> T) -> T {\n \n fn u64_to_be_bytes<T>(n: u64, size: uint, f: fn(v: &[u8]) -> T) -> T {\n     assert size <= 8u;\n-    alt size {\n+    match size {\n       1u => f(&[n as u8]),\n       2u => f(&[(n >> 8) as u8,\n               n as u8]),\n@@ -717,7 +717,7 @@ fn seek_in_buf(offset: int, pos: uint, len: uint, whence: seek_style) ->\n    uint {\n     let mut bpos = pos as int;\n     let blen = len as int;\n-    alt whence {\n+    match whence {\n       seek_set => bpos = offset,\n       seek_cur => bpos += offset,\n       seek_end => bpos = blen + offset\n@@ -767,7 +767,7 @@ mod fsync {\n         let arg: arg<t>;\n         new(-arg: arg<t>) { self.arg <- arg; }\n         drop {\n-          alt self.arg.opt_level {\n+          match self.arg.opt_level {\n             option::none => (),\n             option::some(level) => {\n               // fail hard if not succesful\n@@ -891,7 +891,7 @@ mod tests {\n \n     #[test]\n     fn file_reader_not_exist() {\n-        alt io::file_reader(~\"not a file\") {\n+        match io::file_reader(~\"not a file\") {\n           result::err(e) => {\n             assert e == ~\"error opening not a file\";\n           }\n@@ -901,7 +901,7 @@ mod tests {\n \n     #[test]\n     fn file_writer_bad_name() {\n-        alt io::file_writer(~\"?/?\", ~[]) {\n+        match io::file_writer(~\"?/?\", ~[]) {\n           result::err(e) => {\n             assert str::starts_with(e, ~\"error opening ?/?\");\n           }\n@@ -911,7 +911,7 @@ mod tests {\n \n     #[test]\n     fn buffered_file_writer_bad_name() {\n-        alt io::buffered_file_writer(~\"?/?\") {\n+        match io::buffered_file_writer(~\"?/?\") {\n           result::err(e) => {\n             assert e == ~\"error opening ?/?\";\n           }"}, {"sha": "2bcb7bba56ef9a3bdb0dcc6868d8e7df3758df07", "filename": "src/libcore/iter-trait/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fiter-trait%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fiter-trait%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Foption.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -1,14 +1,14 @@\n type IMPL_T<A> = option<A>;\n \n pure fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n-    alt self {\n+    match self {\n       none => (),\n       some(a) => { f(a); }\n     }\n }\n \n fn SIZE_HINT<A>(self: IMPL_T<A>) -> option<uint> {\n-    alt self {\n+    match self {\n       none => some(0u),\n       some(_) => some(1u)\n     }"}, {"sha": "2cb3369dbc7c99ccf36242e26a7823d0865ddef4", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -134,8 +134,8 @@ fn repeat(times: uint, blk: fn() -> bool) {\n }\n \n fn min<A:copy,IA:base_iter<A>>(self: IA) -> A {\n-    alt do foldl::<A,option<A>,IA>(self, none) |a, b| {\n-        alt a {\n+    match do foldl::<A,option<A>,IA>(self, none) |a, b| {\n+        match a {\n           some(a_) if a_ < b => {\n             // FIXME (#2005): Not sure if this is successfully optimized to\n             // a move\n@@ -150,8 +150,8 @@ fn min<A:copy,IA:base_iter<A>>(self: IA) -> A {\n }\n \n fn max<A:copy,IA:base_iter<A>>(self: IA) -> A {\n-    alt do foldl::<A,option<A>,IA>(self, none) |a, b| {\n-        alt a {\n+    match do foldl::<A,option<A>,IA>(self, none) |a, b| {\n+        match a {\n           some(a_) if a_ > b => {\n             // FIXME (#2005): Not sure if this is successfully optimized to\n             // a move."}, {"sha": "d64b89c2f04a19f0c2731bdafb2ac097007fb298", "filename": "src/libcore/option.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -23,7 +23,7 @@ pure fn get<T: copy>(opt: option<T>) -> T {\n      * Fails if the value equals `none`\n      */\n \n-    alt opt {\n+    match opt {\n       some(x) => return x,\n       none => fail ~\"option::get none\"\n     }\n@@ -37,13 +37,13 @@ pure fn expect<T: copy>(opt: option<T>, reason: ~str) -> T {\n \n     Fails if the value equals `none`\n     \"];\n-    alt opt { some(x) => x, none => fail reason }\n+    match opt { some(x) => x, none => fail reason }\n }\n \n pure fn map<T, U>(opt: option<T>, f: fn(T) -> U) -> option<U> {\n     //! Maps a `some` value from one type to another\n \n-    alt opt { some(x) => some(f(x)), none => none }\n+    match opt { some(x) => some(f(x)), none => none }\n }\n \n pure fn map_consume<T, U>(-opt: option<T>, f: fn(-T) -> U) -> option<U> {\n@@ -60,7 +60,7 @@ pure fn chain<T, U>(opt: option<T>, f: fn(T) -> option<U>) -> option<U> {\n      * function that returns an option.\n      */\n \n-    alt opt { some(x) => f(x), none => none }\n+    match opt { some(x) => f(x), none => none }\n }\n \n #[inline(always)]\n@@ -76,7 +76,7 @@ pure fn while_some<T>(+x: option<T>, blk: fn(+T) -> option<T>) {\n pure fn is_none<T>(opt: option<T>) -> bool {\n     //! Returns true if the option equals `none`\n \n-    alt opt { none => true, some(_) => false }\n+    match opt { none => true, some(_) => false }\n }\n \n pure fn is_some<T>(opt: option<T>) -> bool {\n@@ -88,19 +88,19 @@ pure fn is_some<T>(opt: option<T>) -> bool {\n pure fn get_default<T: copy>(opt: option<T>, def: T) -> T {\n     //! Returns the contained value or a default\n \n-    alt opt { some(x) => x, none => def }\n+    match opt { some(x) => x, none => def }\n }\n \n pure fn map_default<T, U>(opt: option<T>, +def: U, f: fn(T) -> U) -> U {\n     //! Applies a function to the contained value or returns a default\n \n-    alt opt { none => def, some(t) => f(t) }\n+    match opt { none => def, some(t) => f(t) }\n }\n \n pure fn iter<T>(opt: option<T>, f: fn(T)) {\n     //! Performs an operation on the contained value or does nothing\n \n-    alt opt { none => (), some(t) => f(t) }\n+    match opt { none => (), some(t) => f(t) }\n }\n \n #[inline(always)]\n@@ -113,7 +113,7 @@ pure fn unwrap<T>(-opt: option<T>) -> T {\n      */\n \n     unsafe {\n-        let addr = alt opt {\n+        let addr = match opt {\n           some(x) => ptr::addr_of(x),\n           none => fail ~\"option::unwrap none\"\n         };"}, {"sha": "07bbff42b94209b31b7627529d3ae55b031e2ce7", "filename": "src/libcore/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -178,7 +178,7 @@ mod global_env {\n         unsafe {\n             do priv::weaken_task |weak_po| {\n                 loop {\n-                    alt comm::select2(msg_po, weak_po) {\n+                    match comm::select2(msg_po, weak_po) {\n                       either::left(msg_getenv(n, resp_ch)) => {\n                         comm::send(resp_ch, impl::getenv(n))\n                       }\n@@ -282,7 +282,7 @@ fn fsync_fd(fd: c_int, _level: io::fsync::level) -> c_int {\n #[cfg(target_os = \"linux\")]\n fn fsync_fd(fd: c_int, level: io::fsync::level) -> c_int {\n     import libc::funcs::posix01::unistd::*;\n-    alt level {\n+    match level {\n       io::fsync::fsync\n       | io::fsync::fullfsync => return fsync(fd),\n       io::fsync::fdatasync => return fdatasync(fd)\n@@ -294,7 +294,7 @@ fn fsync_fd(fd: c_int, level: io::fsync::level) -> c_int {\n     import libc::consts::os::extra::*;\n     import libc::funcs::posix88::fcntl::*;\n     import libc::funcs::posix01::unistd::*;\n-    alt level {\n+    match level {\n       io::fsync::fsync => return fsync(fd),\n       _ => {\n         // According to man fnctl, the ok retval is only specified to be !=-1\n@@ -440,7 +440,7 @@ fn self_exe_path() -> option<path> {\n  * Otherwise, homedir returns option::none.\n  */\n fn homedir() -> option<path> {\n-    return alt getenv(~\"HOME\") {\n+    return match getenv(~\"HOME\") {\n         some(p) => if !str::is_empty(p) {\n           some(p)\n         } else {"}, {"sha": "1f239605131d05cb632bfc0a3c2ce85bec3b5c43", "filename": "src/libcore/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -61,7 +61,7 @@ fn path_is_absolute(p: ~str) -> bool {\n fn path_sep() -> ~str { return str::from_char(consts::path_sep); }\n \n fn split_dirname_basename (pp: path) -> {dirname: ~str, basename: ~str} {\n-    alt str::rfind(pp, |ch|\n+    match str::rfind(pp, |ch|\n         ch == consts::path_sep || ch == consts::alt_path_sep\n     ) {\n       some(i) => {"}, {"sha": "33ee3cc52fb858410e235c79a759e81d80a4c728", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -136,7 +136,7 @@ struct packet_header {\n     unsafe fn unblock() {\n         let old_task = swap_task(self.blocked_task, ptr::null());\n         if !old_task.is_null() { rustrt::rust_task_deref(old_task) }\n-        alt swap_state_acq(self.state, empty) {\n+        match swap_state_acq(self.state, empty) {\n           empty | blocked => (),\n           terminated => self.state = terminated,\n           full => self.state = full\n@@ -345,7 +345,7 @@ fn send<T: send, Tbuffer: send>(-p: send_packet_buffered<T, Tbuffer>,\n     assert p.payload == none;\n     p.payload <- some(payload);\n     let old_state = swap_state_rel(p.header.state, full);\n-    alt old_state {\n+    match old_state {\n       empty => {\n         // Yay, fastpath.\n \n@@ -403,7 +403,7 @@ fn try_recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>)\n         rustrt::task_clear_event_reject(this);\n         let old_state = swap_state_acq(p.header.state,\n                                        blocked);\n-        alt old_state {\n+        match old_state {\n           empty => {\n             debug!{\"no data available on %?, going to sleep.\", p_};\n             if count == 0 {\n@@ -451,7 +451,7 @@ fn try_recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>)\n \n /// Returns true if messages are available.\n pure fn peek<T: send, Tb: send>(p: recv_packet_buffered<T, Tb>) -> bool {\n-    alt unsafe {(*p.header()).state} {\n+    match unsafe {(*p.header()).state} {\n       empty => false,\n       blocked => fail ~\"peeking on blocked packet\",\n       full | terminated => true\n@@ -467,7 +467,7 @@ impl peek<T: send, Tb: send> for recv_packet_buffered<T, Tb> {\n #[doc(hidden)]\n fn sender_terminate<T: send>(p: *packet<T>) {\n     let p = unsafe { &*p };\n-    alt swap_state_rel(p.header.state, terminated) {\n+    match swap_state_rel(p.header.state, terminated) {\n       empty => {\n         assert p.header.blocked_task.is_null();\n         // The receiver will eventually clean up.\n@@ -500,7 +500,7 @@ fn sender_terminate<T: send>(p: *packet<T>) {\n fn receiver_terminate<T: send>(p: *packet<T>) {\n     let p = unsafe { &*p };\n     assert p.header.blocked_task.is_null();\n-    alt swap_state_rel(p.header.state, terminated) {\n+    match swap_state_rel(p.header.state, terminated) {\n       empty => {\n         // the sender will clean up\n         //unsafe { forget(p) }\n@@ -534,7 +534,7 @@ fn wait_many(pkts: &[*packet_header]) -> uint {\n     for pkts.eachi |i, p| unsafe {\n         let p = unsafe { &*p };\n         let old = p.mark_blocked(this);\n-        alt old {\n+        match old {\n           full | terminated => {\n             data_avail = true;\n             ready_packet = i;\n@@ -551,7 +551,7 @@ fn wait_many(pkts: &[*packet_header]) -> uint {\n         let event = wait_event(this) as *packet_header;\n         let pos = vec::position(pkts, |p| p == event);\n \n-        alt pos {\n+        match pos {\n           some(i) => {\n             ready_packet = i;\n             data_avail = true;\n@@ -611,7 +611,7 @@ fn select2<A: send, Ab: send, B: send, Bb: send>(\n     let i = wait_many([a.header(), b.header()]/_);\n \n     unsafe {\n-        alt i {\n+        match i {\n           0 => left((try_recv(a), b)),\n           1 => right((a, try_recv(b))),\n           _ => fail ~\"select2 return an invalid packet\"\n@@ -631,7 +631,7 @@ fn selecti<T: selectable>(endpoints: &[T]) -> uint {\n \n /// Returns 0 or 1 depending on which endpoint is ready to receive\n fn select2i<A: selectable, B: selectable>(a: A, b: B) -> either<(), ()> {\n-    alt wait_many([a.header(), b.header()]/_) {\n+    match wait_many([a.header(), b.header()]/_) {\n       0 => left(()),\n       1 => right(()),\n       _ => fail ~\"wait returned unexpected index\"\n@@ -704,7 +704,7 @@ struct send_packet_buffered<T: send, Tbuffer: send> {\n     }\n \n     pure fn header() -> *packet_header {\n-        alt self.p {\n+        match self.p {\n           some(packet) => unsafe {\n             let packet = &*packet;\n             let header = ptr::addr_of(packet.header);\n@@ -765,7 +765,7 @@ struct recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n     }\n \n     pure fn header() -> *packet_header {\n-        alt self.p {\n+        match self.p {\n           some(packet) => unsafe {\n             let packet = &*packet;\n             let header = ptr::addr_of(packet.header);\n@@ -924,7 +924,7 @@ impl port<T: send> of recv<T> for port<T> {\n     fn try_recv() -> option<T> {\n         let mut endp = none;\n         endp <-> self.endp;\n-        alt move pipes::try_recv(unwrap(endp)) {\n+        match move pipes::try_recv(unwrap(endp)) {\n           some(streamp::data(x, endp)) => {\n             self.endp = some(move_it!{endp});\n             some(move_it!{x})\n@@ -936,7 +936,7 @@ impl port<T: send> of recv<T> for port<T> {\n     pure fn peek() -> bool unchecked {\n         let mut endp = none;\n         endp <-> self.endp;\n-        let peek = alt endp {\n+        let peek = match endp {\n           some(endp) => pipes::peek(endp),\n           none => fail ~\"peeking empty stream\"\n         };\n@@ -969,7 +969,7 @@ struct port_set<T: send> : recv<T> {\n         ports <-> self.ports;\n         while result == none && ports.len() > 0 {\n             let i = wait_many(ports.map(|p| p.header()));\n-            alt move ports[i].try_recv() {\n+            match move ports[i].try_recv() {\n                 some(copy m) => {\n                     result = some(move m);\n                 }\n@@ -1007,7 +1007,7 @@ struct port_set<T: send> : recv<T> {\n \n impl<T: send> of selectable for port<T> {\n     pure fn header() -> *packet_header unchecked {\n-        alt self.endp {\n+        match self.endp {\n           some(endp) => endp.header(),\n           none => fail ~\"peeking empty stream\"\n         }\n@@ -1045,17 +1045,17 @@ impl<T: send, U: send, Left: selectable recv<T>, Right: selectable recv<U>>\n     of select2<T, U> for (Left, Right) {\n \n     fn select() -> either<T, U> {\n-        alt self {\n-          (lp, rp) => alt select2i(lp, rp) {\n+        match self {\n+          (lp, rp) => match select2i(lp, rp) {\n             left(()) => left (lp.recv()),\n             right(()) => right(rp.recv())\n           }\n         }\n     }\n \n     fn try_select() -> either<option<T>, option<U>> {\n-        alt self {\n-          (lp, rp) => alt select2i(lp, rp) {\n+        match self {\n+          (lp, rp) => match select2i(lp, rp) {\n             left(()) => left (lp.try_recv()),\n             right(()) => right(rp.try_recv())\n           }\n@@ -1072,7 +1072,7 @@ mod test {\n \n         c1.send(~\"abc\");\n \n-        alt (p1, p2).select() {\n+        match (p1, p2).select() {\n           right(_) => fail,\n           _ => ()\n         }"}, {"sha": "ac286da79f63f24aaea3f0a1cf2ba517013e3f56", "filename": "src/libcore/priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fpriv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fpriv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpriv.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -49,7 +49,7 @@ unsafe fn chan_from_global_ptr<T: send>(\n \n             // Wait to hear if we are the official instance of\n             // this global task\n-            alt comm::recv::<msg>(setup_po) {\n+            match comm::recv::<msg>(setup_po) {\n               proceed => f(po),\n               abort => ()\n             }"}, {"sha": "417841f33230caadd1e1adce2b51a03acedf0a97", "filename": "src/libcore/result.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -18,7 +18,7 @@ enum result<T, U> {\n  * If the result is an error\n  */\n pure fn get<T: copy, U>(res: result<T, U>) -> T {\n-    alt res {\n+    match res {\n       ok(t) => t,\n       err(the_err) => unchecked {\n         fail fmt!{\"get called on error result: %?\", the_err}\n@@ -34,15 +34,15 @@ pure fn get<T: copy, U>(res: result<T, U>) -> T {\n  * If the result is not an error\n  */\n pure fn get_err<T, U: copy>(res: result<T, U>) -> U {\n-    alt res {\n+    match res {\n       err(u) => u,\n       ok(_) => fail ~\"get_error called on ok result\"\n     }\n }\n \n /// Returns true if the result is `ok`\n pure fn is_ok<T, U>(res: result<T, U>) -> bool {\n-    alt res {\n+    match res {\n       ok(_) => true,\n       err(_) => false\n     }\n@@ -60,7 +60,7 @@ pure fn is_err<T, U>(res: result<T, U>) -> bool {\n  * result variants are converted to `either::left`.\n  */\n pure fn to_either<T: copy, U: copy>(res: result<U, T>) -> either<T, U> {\n-    alt res {\n+    match res {\n       ok(res) => either::right(res),\n       err(fail_) => either::left(fail_)\n     }\n@@ -82,7 +82,7 @@ pure fn to_either<T: copy, U: copy>(res: result<U, T>) -> either<T, U> {\n  */\n fn chain<T, U: copy, V: copy>(res: result<T, V>, op: fn(T) -> result<U, V>)\n     -> result<U, V> {\n-    alt res {\n+    match res {\n       ok(t) => op(t),\n       err(e) => err(e)\n     }\n@@ -100,7 +100,7 @@ fn chain_err<T: copy, U: copy, V: copy>(\n     res: result<T, V>,\n     op: fn(V) -> result<T, U>)\n     -> result<T, U> {\n-    alt res {\n+    match res {\n       ok(t) => ok(t),\n       err(v) => op(v)\n     }\n@@ -121,7 +121,7 @@ fn chain_err<T: copy, U: copy, V: copy>(\n  *     }\n  */\n fn iter<T, E>(res: result<T, E>, f: fn(T)) {\n-    alt res {\n+    match res {\n       ok(t) => f(t),\n       err(_) => ()\n     }\n@@ -136,7 +136,7 @@ fn iter<T, E>(res: result<T, E>, f: fn(T)) {\n  * handling an error.\n  */\n fn iter_err<T, E>(res: result<T, E>, f: fn(E)) {\n-    alt res {\n+    match res {\n       ok(_) => (),\n       err(e) => f(e)\n     }\n@@ -158,7 +158,7 @@ fn iter_err<T, E>(res: result<T, E>, f: fn(E)) {\n  */\n fn map<T, E: copy, U: copy>(res: result<T, E>, op: fn(T) -> U)\n   -> result<U, E> {\n-    alt res {\n+    match res {\n       ok(t) => ok(op(t)),\n       err(e) => err(e)\n     }\n@@ -174,7 +174,7 @@ fn map<T, E: copy, U: copy>(res: result<T, E>, op: fn(T) -> U)\n  */\n fn map_err<T: copy, E, F: copy>(res: result<T, E>, op: fn(E) -> F)\n   -> result<T, F> {\n-    alt res {\n+    match res {\n       ok(t) => ok(t),\n       err(e) => err(op(e))\n     }\n@@ -186,14 +186,14 @@ impl extensions<T, E> for result<T, E> {\n     fn is_err() -> bool { is_err(self) }\n \n     fn iter(f: fn(T)) {\n-        alt self {\n+        match self {\n           ok(t) => f(t),\n           err(_) => ()\n         }\n     }\n \n     fn iter_err(f: fn(E)) {\n-        alt self {\n+        match self {\n           ok(_) => (),\n           err(e) => f(e)\n         }\n@@ -204,7 +204,7 @@ impl extensions<T:copy, E> for result<T, E> {\n     fn get() -> T { get(self) }\n \n     fn map_err<F:copy>(op: fn(E) -> F) -> result<T,F> {\n-        alt self {\n+        match self {\n           ok(t) => ok(t),\n           err(e) => err(op(e))\n         }\n@@ -215,7 +215,7 @@ impl extensions<T, E:copy> for result<T, E> {\n     fn get_err() -> E { get_err(self) }\n \n     fn map<U:copy>(op: fn(T) -> U) -> result<U,E> {\n-        alt self {\n+        match self {\n           ok(t) => ok(op(t)),\n           err(e) => err(e)\n         }\n@@ -255,7 +255,7 @@ fn map_vec<T,U:copy,V:copy>(\n     let mut vs: ~[V] = ~[];\n     vec::reserve(vs, vec::len(ts));\n     for vec::each(ts) |t| {\n-        alt op(t) {\n+        match op(t) {\n           ok(v) => vec::push(vs, v),\n           err(u) => return err(u)\n         }\n@@ -266,9 +266,9 @@ fn map_vec<T,U:copy,V:copy>(\n fn map_opt<T,U:copy,V:copy>(\n     o_t: option<T>, op: fn(T) -> result<V,U>) -> result<option<V>,U> {\n \n-    alt o_t {\n+    match o_t {\n       none => ok(none),\n-      some(t) => alt op(t) {\n+      some(t) => match op(t) {\n         ok(v) => ok(some(v)),\n         err(e) => err(e)\n       }\n@@ -293,7 +293,7 @@ fn map_vec2<S,T,U:copy,V:copy>(ss: ~[S], ts: ~[T],\n     vec::reserve(vs, n);\n     let mut i = 0u;\n     while i < n {\n-        alt op(ss[i],ts[i]) {\n+        match op(ss[i],ts[i]) {\n           ok(v) => vec::push(vs, v),\n           err(u) => return err(u)\n         }\n@@ -314,7 +314,7 @@ fn iter_vec2<S,T,U:copy>(ss: ~[S], ts: ~[T],\n     let n = vec::len(ts);\n     let mut i = 0u;\n     while i < n {\n-        alt op(ss[i],ts[i]) {\n+        match op(ss[i],ts[i]) {\n           ok(()) => (),\n           err(u) => return err(u)\n         }\n@@ -326,7 +326,7 @@ fn iter_vec2<S,T,U:copy>(ss: ~[S], ts: ~[T],\n /// Unwraps a result, assuming it is an `ok(T)`\n fn unwrap<T, U>(-res: result<T, U>) -> T {\n     unsafe {\n-        let addr = alt res {\n+        let addr = match res {\n           ok(x) => ptr::addr_of(x),\n           err(_) => fail ~\"error result\"\n         };"}, {"sha": "92e89d8a7c8e7758b6b2bf6bc674c7a0cf7216be", "filename": "src/libcore/run.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -96,7 +96,7 @@ fn with_envp<T>(env: option<~[(~str,~str)]>,\n                 cb: fn(*c_void) -> T) -> T {\n     // On posixy systems we can pass a char** for envp, which is\n     // a null-terminated array of \"k=v\\n\" strings.\n-    alt env {\n+    match env {\n       some(es) if !vec::is_empty(es) => {\n         let mut tmps = ~[];\n         let mut ptrs = ~[];\n@@ -123,7 +123,7 @@ fn with_envp<T>(env: option<~[(~str,~str)]>,\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate.\n     unsafe {\n-        alt env {\n+        match env {\n           some(es) if !vec::is_empty(es) => {\n             let mut blk : ~[u8] = ~[];\n             for vec::each(es) |e| {\n@@ -143,7 +143,7 @@ fn with_envp<T>(env: option<~[(~str,~str)]>,\n \n fn with_dirp<T>(d: option<~str>,\n                 cb: fn(*libc::c_char) -> T) -> T {\n-    alt d {\n+    match d {\n       some(dir) => str::as_c_str(dir, cb),\n       none => cb(ptr::null())\n     }\n@@ -309,7 +309,7 @@ fn program_output(prog: ~str, args: ~[~str]) ->\n     let mut count = 2;\n     while count > 0 {\n         let stream = comm::recv(p);\n-        alt check stream {\n+        match check stream {\n             (1, s) => {\n                 outs = s;\n             }"}, {"sha": "04dc25a2c114ea761e59f1a4de10bce6d886d765", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -115,7 +115,7 @@ mod linear {\n             k: &K) -> search_result {\n \n             let _ = for self.bucket_sequence(hash) |i| {\n-                alt buckets[i] {\n+                match buckets[i] {\n                   some(bkt) => if bkt.hash == hash && self.eqfn(k, &bkt.key) {\n                     return found_entry(i);\n                   }\n@@ -155,7 +155,7 @@ mod linear {\n         /// Assumes that there will be a bucket.\n         /// True if there was no previous entry with that key\n         fn insert_internal(hash: uint, +k: K, +v: V) -> bool {\n-            alt self.bucket_for_key_with_hash(self.buckets, hash,\n+            match self.bucket_for_key_with_hash(self.buckets, hash,\n                                               unsafe{borrow(k)}) {\n               table_full => {fail ~\"Internal logic error\";}\n               found_hole(idx) => {\n@@ -207,7 +207,7 @@ mod linear {\n             // I found this explanation elucidating:\n             // http://www.maths.lse.ac.uk/Courses/MA407/del-hash.pdf\n \n-            let mut idx = alt self.bucket_for_key(self.buckets, k) {\n+            let mut idx = match self.bucket_for_key(self.buckets, k) {\n               table_full | found_hole(_) => {\n                 return false;\n               }\n@@ -246,7 +246,7 @@ mod linear {\n         }\n \n         fn contains_key(k: &K) -> bool {\n-            alt self.bucket_for_key(self.buckets, k) {\n+            match self.bucket_for_key(self.buckets, k) {\n               found_entry(_) => {true}\n               table_full | found_hole(_) => {false}\n             }\n@@ -255,9 +255,9 @@ mod linear {\n \n     impl public_methods<K,V: copy> for &const linear_map<K,V> {\n         fn find(k: &K) -> option<V> {\n-            alt self.bucket_for_key(self.buckets, k) {\n+            match self.bucket_for_key(self.buckets, k) {\n               found_entry(idx) => {\n-                alt check self.buckets[idx] {\n+                match check self.buckets[idx] {\n                   some(bkt) => {some(copy bkt.value)}\n                 }\n               }"}, {"sha": "4a13c1d93542a6356e69e22ad751f458882d878f", "filename": "src/libcore/str.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -341,15 +341,15 @@ fn unshift_char(&s: ~str, ch: char) { s = from_char(ch) + s; }\n \n /// Returns a string with leading whitespace removed\n pure fn trim_left(s: &str) -> ~str {\n-    alt find(s, |c| !char::is_whitespace(c)) {\n+    match find(s, |c| !char::is_whitespace(c)) {\n       none => ~\"\",\n       some(first) => unsafe { unsafe::slice_bytes(s, first, len(s)) }\n     }\n }\n \n /// Returns a string with trailing whitespace removed\n pure fn trim_right(s: &str) -> ~str {\n-    alt rfind(s, |c| !char::is_whitespace(c)) {\n+    match rfind(s, |c| !char::is_whitespace(c)) {\n       none => ~\"\",\n       some(last) => {\n         let {next, _} = char_range_at(s, last);\n@@ -2776,7 +2776,7 @@ mod tests {\n     fn test_chars_iter() {\n         let mut i = 0;\n         do chars_iter(~\"x\\u03c0y\") |ch| {\n-            alt check i {\n+            match check i {\n               0 => assert ch == 'x',\n               1 => assert ch == '\\u03c0',\n               2 => assert ch == 'y'\n@@ -2792,7 +2792,7 @@ mod tests {\n         let mut i = 0;\n \n         do bytes_iter(~\"xyz\") |bb| {\n-            alt check i {\n+            match check i {\n               0 => assert bb == 'x' as u8,\n               1 => assert bb == 'y' as u8,\n               2 => assert bb == 'z' as u8\n@@ -2810,7 +2810,7 @@ mod tests {\n         let mut ii = 0;\n \n         do split_char_iter(data, ' ') |xx| {\n-            alt ii {\n+            match ii {\n               0 => assert ~\"\\nMary\" == xx,\n               1 => assert ~\"had\"    == xx,\n               2 => assert ~\"a\"      == xx,\n@@ -2828,7 +2828,7 @@ mod tests {\n         let mut ii = 0;\n \n         do splitn_char_iter(data, ' ', 2u) |xx| {\n-            alt ii {\n+            match ii {\n               0 => assert ~\"\\nMary\" == xx,\n               1 => assert ~\"had\"    == xx,\n               2 => assert ~\"a little lamb\\nLittle lamb\\n\" == xx,\n@@ -2845,7 +2845,7 @@ mod tests {\n         let mut ii = 0;\n \n         do words_iter(data) |ww| {\n-            alt ii {\n+            match ii {\n               0 => assert ~\"Mary\"   == ww,\n               1 => assert ~\"had\"    == ww,\n               2 => assert ~\"a\"      == ww,\n@@ -2865,7 +2865,7 @@ mod tests {\n         let mut ii = 0;\n \n         do lines_iter(lf) |x| {\n-            alt ii {\n+            match ii {\n                 0 => assert ~\"\" == x,\n                 1 => assert ~\"Mary had a little lamb\" == x,\n                 2 => assert ~\"Little lamb\" == x,"}, {"sha": "422d62862eaa533528547acf65d00ac8eb27c390", "filename": "src/libcore/task.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -279,7 +279,7 @@ impl task_builder for task_builder {\n         let ch = comm::chan(po);\n \n         blk(do future::from_fn {\n-            alt comm::recv(po) {\n+            match comm::recv(po) {\n               exit(_, result) => result\n             }\n         });\n@@ -502,7 +502,7 @@ fn try<T:send>(+f: fn~() -> T) -> result<T,()> {\n     do task().unlinked().future_result(|-r| { result = some(r); }).spawn {\n         comm::send(ch, f());\n     }\n-    alt future::get(option::unwrap(result)) {\n+    match future::get(option::unwrap(result)) {\n       success => result::ok(comm::recv(po)),\n       failure => result::err(())\n     }\n@@ -991,7 +991,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n     /*######################################################################*\n      * Step 1. Get spawner's taskgroup info.\n      *######################################################################*/\n-    let spawner_group = alt unsafe { local_get(spawner, taskgroup_key()) } {\n+    let spawner_group = match unsafe { local_get(spawner, taskgroup_key()) } {\n         none => {\n             // Main task, doing first spawn ever. Lazily initialise here.\n             let mut members = new_taskset();\n@@ -1028,7 +1028,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n             // assertion, but initialising it requires locking a mutex. Hence\n             // it should be enabled only in debug builds.\n             let new_generation =\n-                alt *old_ancestors {\n+                match *old_ancestors {\n                     some(arc) => access_ancestors(arc, |a| a.generation+1),\n                     none      => 0 // the actual value doesn't really matter.\n                 };\n@@ -1047,7 +1047,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n \n     fn share_ancestors(ancestors: &mut ancestor_list) -> ancestor_list {\n         // Appease the borrow-checker. Really this wants to be written as:\n-        // alt ancestors\n+        // match ancestors\n         //    some(ancestor_arc) { ancestor_list(some(ancestor_arc.clone())) }\n         //    none               { ancestor_list(none) }\n         let tmp = util::replace(&mut **ancestors, none);\n@@ -1073,7 +1073,7 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n             let (child_tg, ancestors, f) = option::swap_unwrap(child_data);\n             // Create child task.\n-            let new_task = alt opts.sched {\n+            let new_task = match opts.sched {\n               none             => rustrt::new_task(),\n               some(sched_opts) => new_task_in_new_sched(sched_opts)\n             };\n@@ -1162,7 +1162,7 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n             fail ~\"foreign_stack_size scheduler option unimplemented\";\n         }\n \n-        let num_threads = alt opts.mode {\n+        let num_threads = match opts.mode {\n           single_threaded => 1u,\n           thread_per_core => {\n             fail ~\"thread_per_core scheduling mode unimplemented\"\n@@ -1273,7 +1273,7 @@ unsafe fn local_data_lookup<T: owned>(\n \n     let key_value = key_to_key_value(key);\n     let map_pos = (*map).position(|entry|\n-        alt entry {\n+        match entry {\n             some((k,_,_)) => k == key_value,\n             none => false\n         }\n@@ -1336,15 +1336,15 @@ unsafe fn local_set<T: owned>(\n     // Construct new entry to store in the map.\n     let new_entry = some((keyval, data_ptr, data_box));\n     // Find a place to put it.\n-    alt local_data_lookup(map, key) {\n+    match local_data_lookup(map, key) {\n         some((index, _old_data_ptr)) => {\n             // Key already had a value set, _old_data_ptr, whose reference\n             // will get dropped when the local_data box is overwritten.\n             (*map).set_elt(index, new_entry);\n         }\n         none => {\n             // Find an empty slot. If not, grow the vector.\n-            alt (*map).position(|x| x == none) {\n+            match (*map).position(|x| x == none) {\n                 some(empty_index) => (*map).set_elt(empty_index, new_entry),\n                 none => (*map).push(new_entry)\n             }\n@@ -1694,7 +1694,7 @@ fn test_spawn_listiner_bidi() {\n \n #[test]\n fn test_try_success() {\n-    alt do try {\n+    match do try {\n         ~\"Success!\"\n     } {\n         result::ok(~\"Success!\") => (),\n@@ -1705,7 +1705,7 @@ fn test_try_success() {\n #[test]\n #[ignore(cfg(windows))]\n fn test_try_fail() {\n-    alt do try {\n+    match do try {\n         fail\n     } {\n         result::err(()) => (),\n@@ -2052,13 +2052,13 @@ fn test_tls_pop() unsafe {\n fn test_tls_modify() unsafe {\n     fn my_key(+_x: @~str) { }\n     local_data_modify(my_key, |data| {\n-        alt data {\n+        match data {\n             some(@val) => fail ~\"unwelcome value: \" + val,\n             none       => some(@~\"first data\")\n         }\n     });\n     local_data_modify(my_key, |data| {\n-        alt data {\n+        match data {\n             some(@~\"first data\") => some(@~\"next data\"),\n             some(@val)           => fail ~\"wrong value: \" + val,\n             none                 => fail ~\"missing value\""}, {"sha": "a0feaf3ed9d20747954c282e7538a941bfe11800", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -127,7 +127,7 @@ fn parse_buf(buf: ~[u8], radix: uint) -> option<T> {\n     let mut power = 1u as T;\n     let mut n = 0u as T;\n     loop {\n-        alt char::to_digit(buf[i] as char, radix) {\n+        match char::to_digit(buf[i] as char, radix) {\n           some(d) => n += d as T * power,\n           none => return none\n         }\n@@ -146,7 +146,7 @@ fn from_str_radix(buf: ~str, radix: u64) -> option<u64> {\n     let mut i = str::len(buf) - 1u;\n     let mut power = 1u64, n = 0u64;\n     loop {\n-        alt char::to_digit(buf[i] as char, radix as uint) {\n+        match char::to_digit(buf[i] as char, radix as uint) {\n           some(d) => n += d as u64 * power,\n           none => return none\n         }"}, {"sha": "c7f0c9bfa17914c63cb8001f0af44db5f3a61635", "filename": "src/libcore/unicode.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -1,14 +1,14 @@\n mod general_category {\n     pure fn Cc(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\x00' to '\\x1f'\n             | '\\x7f' to '\\x9f' => true,\n             _ => false\n         };\n     }\n \n     pure fn Cf(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\xad'\n             | '\\u0600' to '\\u0603'\n             | '\\u06dd'\n@@ -27,21 +27,21 @@ mod general_category {\n     }\n \n     pure fn Co(c: char) -> bool {\n-        return alt c {\n+        return match c {\n           '\\ue000' to '\\uf8ff' => true,\n           _ => false\n         };\n     }\n \n     pure fn Cs(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\ud800' to '\\udfff' => true,\n             _ => false\n         };\n     }\n \n     pure fn Ll(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\x61' to '\\x7a'\n             | '\\xaa'\n             | '\\xb5'\n@@ -646,7 +646,7 @@ mod general_category {\n     }\n \n     pure fn Lm(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\u02b0' to '\\u02c1'\n             | '\\u02c6' to '\\u02d1'\n             | '\\u02e0' to '\\u02e4'\n@@ -702,7 +702,7 @@ mod general_category {\n     }\n \n     pure fn Lo(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\u01bb'\n             | '\\u01c0' to '\\u01c3'\n             | '\\u0294'\n@@ -888,7 +888,7 @@ mod general_category {\n     }\n \n     pure fn Lt(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\u01c5'\n             | '\\u01c8'\n             | '\\u01cb'\n@@ -905,7 +905,7 @@ mod general_category {\n     }\n \n     pure fn Lu(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\x41' to '\\x5a'\n             | '\\xc0' to '\\xd6'\n             | '\\xd8' to '\\xde'\n@@ -1497,7 +1497,7 @@ mod general_category {\n     }\n \n     pure fn Mc(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\u0903'\n             | '\\u093b'\n             | '\\u093e' to '\\u0940'\n@@ -1608,7 +1608,7 @@ mod general_category {\n     }\n \n     pure fn Me(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\u0488' to '\\u0489'\n             | '\\u20dd' to '\\u20e0'\n             | '\\u20e2' to '\\u20e4'\n@@ -1619,7 +1619,7 @@ mod general_category {\n     }\n \n     pure fn Mn(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\u0300' to '\\u036f'\n             | '\\u0483' to '\\u0487'\n             | '\\u0591' to '\\u05bd'\n@@ -1812,7 +1812,7 @@ mod general_category {\n     }\n \n     pure fn Nd(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\x30' to '\\x39'\n             | '\\u0660' to '\\u0669'\n             | '\\u06f0' to '\\u06f9'\n@@ -1856,7 +1856,7 @@ mod general_category {\n     }\n \n     pure fn Nl(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\u16ee' to '\\u16f0'\n             | '\\u2160' to '\\u2182'\n             | '\\u2185' to '\\u2188'\n@@ -1875,7 +1875,7 @@ mod general_category {\n     }\n \n     pure fn No(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\xb2' to '\\xb3'\n             | '\\xb9'\n             | '\\xbc' to '\\xbe'\n@@ -1923,7 +1923,7 @@ mod general_category {\n     }\n \n     pure fn Pc(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\x5f'\n             | '\\u203f' to '\\u2040'\n             | '\\u2054'\n@@ -1936,7 +1936,7 @@ mod general_category {\n     }\n \n     pure fn Pd(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\x2d'\n             | '\\u058a'\n             | '\\u05be'\n@@ -1958,7 +1958,7 @@ mod general_category {\n     }\n \n     pure fn Pe(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\x29'\n             | '\\x5d'\n             | '\\x7d'\n@@ -2035,7 +2035,7 @@ mod general_category {\n     }\n \n     pure fn Pf(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\xbb'\n             | '\\u2019'\n             | '\\u201d'\n@@ -2052,7 +2052,7 @@ mod general_category {\n     }\n \n     pure fn Pi(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\xab'\n             | '\\u2018'\n             | '\\u201b' to '\\u201c'\n@@ -2070,7 +2070,7 @@ mod general_category {\n     }\n \n     pure fn Po(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\x21' to '\\x23'\n             | '\\x25' to '\\x27'\n             | '\\x2a'\n@@ -2203,7 +2203,7 @@ mod general_category {\n     }\n \n     pure fn Ps(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\x28'\n             | '\\x5b'\n             | '\\x7b'\n@@ -2282,7 +2282,7 @@ mod general_category {\n     }\n \n     pure fn Sc(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\x24'\n             | '\\xa2' to '\\xa5'\n             | '\\u060b'\n@@ -2305,7 +2305,7 @@ mod general_category {\n     }\n \n     pure fn Sk(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\x5e'\n             | '\\x60'\n             | '\\xa8'\n@@ -2339,7 +2339,7 @@ mod general_category {\n     }\n \n     pure fn Sm(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\x2b'\n             | '\\x3c' to '\\x3e'\n             | '\\x7c'\n@@ -2410,7 +2410,7 @@ mod general_category {\n     }\n \n     pure fn So(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\xa6' to '\\xa7'\n             | '\\xa9'\n             | '\\xae'\n@@ -2529,21 +2529,21 @@ mod general_category {\n     }\n \n     pure fn Zl(c: char) -> bool {\n-        return alt c {\n+        return match c {\n           '\\u2028' => true,\n           _ => false\n         };\n     }\n \n     pure fn Zp(c: char) -> bool {\n-        return alt c {\n+        return match c {\n           '\\u2029' => true,\n           _ => false\n         };\n     }\n \n     pure fn Zs(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\x20'\n             | '\\xa0'\n             | '\\u1680'\n@@ -2561,7 +2561,7 @@ mod general_category {\n mod derived_property {\n     /// Check if a character has the alphabetic unicode property\n     pure fn Alphabetic(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\x41' to '\\x5a'\n             | '\\x61' to '\\x7a'\n             | '\\xaa'\n@@ -3299,7 +3299,7 @@ mod derived_property {\n     }\n \n     pure fn XID_Continue(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\x30' to '\\x39'\n             | '\\x41' to '\\x5a'\n             | '\\x5f'\n@@ -4170,7 +4170,7 @@ mod derived_property {\n     }\n \n     pure fn XID_Start(c: char) -> bool {\n-        return alt c {\n+        return match c {\n               '\\x41' to '\\x5a'\n             | '\\x61' to '\\x7a'\n             | '\\xaa'"}, {"sha": "fcfbb3ea13537bb24832543bfb438fe903e471ea", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -356,7 +356,7 @@ fn split<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n     let mut start = 0u;\n     let mut result = ~[];\n     while start < ln {\n-        alt position_between(v, start, ln, f) {\n+        match position_between(v, start, ln, f) {\n           none => break,\n           some(i) => {\n             push(result, slice(v, start, i));\n@@ -380,7 +380,7 @@ fn splitn<T: copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n     let mut count = n;\n     let mut result = ~[];\n     while start < ln && count > 0u {\n-        alt position_between(v, start, ln, f) {\n+        match position_between(v, start, ln, f) {\n           none => break,\n           some(i) => {\n             push(result, slice(v, start, i));\n@@ -405,7 +405,7 @@ fn rsplit<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n     let mut end = ln;\n     let mut result = ~[];\n     while end > 0u {\n-        alt rposition_between(v, 0u, end, f) {\n+        match rposition_between(v, 0u, end, f) {\n           none => break,\n           some(i) => {\n             push(result, slice(v, i + 1u, end));\n@@ -429,7 +429,7 @@ fn rsplitn<T: copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n     let mut count = n;\n     let mut result = ~[];\n     while end > 0u && count > 0u {\n-        alt rposition_between(v, 0u, end, f) {\n+        match rposition_between(v, 0u, end, f) {\n           none => break,\n           some(i) => {\n             push(result, slice(v, i + 1u, end));\n@@ -713,7 +713,7 @@ pure fn filter_map<T, U: copy>(v: &[T], f: fn(T) -> option<U>)\n     -> ~[U] {\n     let mut result = ~[];\n     for each(v) |elem| {\n-        alt f(elem) {\n+        match f(elem) {\n           none => {/* no-op */ }\n           some(result_elem) => unsafe { push(result, result_elem); }\n         }"}, {"sha": "a51ac7658a626c2eb2303ecc9dd15544dffa5892", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -30,7 +30,7 @@ impl of to_base64 for ~[u8] {\n             i += 3u;\n         }\n \n-        alt check len % 3u {\n+        match check len % 3u {\n           0u => (),\n           1u => {\n             let n = (self[i] as uint) << 16u;\n@@ -96,7 +96,7 @@ impl of from_base64 for ~[u8] {\n                 } else if ch == '/' {\n                     n |= 0x3Fu;\n                 } else if ch == '=' {\n-                    alt len - i {\n+                    match len - i {\n                       1u => {\n                         vec::push(r, ((n >> 16u) & 0xFFu) as u8);\n                         vec::push(r, ((n >> 8u ) & 0xFFu) as u8);"}, {"sha": "4b1fa4bfac9db04409b2e3b9e356aee4b5a145ac", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -179,19 +179,19 @@ class bitv {\n             if self.nbits != other.nbits {\n                 self.die();\n             }\n-            alt self.rep {\n-              small(s) => alt other.rep {\n-                small(s1) => alt op {\n+            match self.rep {\n+              small(s) => match other.rep {\n+                small(s1) => match op {\n                   union      => s.union(s1),\n                   intersect  => s.intersect(s1),\n                   assign     => s.become(s1),\n                   difference => s.difference(s1)\n                 }\n                 big(s1) => self.die()\n               }\n-              big(s) => alt other.rep {\n+              big(s) => match other.rep {\n                 small(_) => self.die(),\n-                big(s1) => alt op {\n+                big(s1) => match op {\n                   union      => s.union(s1),\n                   intersect  => s.intersect(s1),\n                   assign     => s.become(s1),\n@@ -232,7 +232,7 @@ class bitv {\n     /// Makes a copy of a bitvector\n     #[inline(always)]\n     fn clone() -> ~bitv {\n-        ~alt self.rep {\n+        ~match self.rep {\n           small(b) => {\n             bitv{nbits: self.nbits, rep: small(~small_bitv{bits: b.bits})}\n           }\n@@ -249,7 +249,7 @@ class bitv {\n     #[inline(always)]\n     pure fn get(i: uint) -> bool {\n        assert (i < self.nbits);\n-       alt self.rep {\n+       match self.rep {\n          big(b)   => b.get(i),\n          small(s) => s.get(i)\n        }\n@@ -263,7 +263,7 @@ class bitv {\n     #[inline(always)]\n     fn set(i: uint, x: bool) {\n       assert (i < self.nbits);\n-      alt self.rep {\n+      match self.rep {\n         big(b)   => b.set(i, x),\n         small(s) => s.set(i, x)\n       }\n@@ -278,12 +278,12 @@ class bitv {\n     #[inline(always)]\n     fn equal(v1: bitv) -> bool {\n       if self.nbits != v1.nbits { return false; }\n-      alt self.rep {\n-        small(b) => alt v1.rep {\n+      match self.rep {\n+        small(b) => match v1.rep {\n           small(b1) => b.equals(b1),\n           _ => false\n         }\n-        big(s) => alt v1.rep {\n+        big(s) => match v1.rep {\n           big(s1) => s.equals(s1),\n           small(_) => return false\n         }\n@@ -293,7 +293,7 @@ class bitv {\n     /// Set all bits to 0\n     #[inline(always)]\n     fn clear() {\n-        alt self.rep {\n+        match self.rep {\n           small(b) => b.clear(),\n           big(s) => for s.each_storage() |w| { w = 0u }\n         }\n@@ -302,15 +302,15 @@ class bitv {\n     /// Set all bits to 1\n     #[inline(always)]\n     fn set_all() {\n-      alt self.rep {\n+      match self.rep {\n         small(b) => b.set_all(),\n         big(s) => for s.each_storage() |w| { w = !0u } }\n     }\n \n     /// Invert all bits\n     #[inline(always)]\n     fn invert() {\n-      alt self.rep {\n+      match self.rep {\n         small(b) => b.invert(),\n         big(s) => for s.each_storage() |w| { w = !w } }\n     }\n@@ -329,7 +329,7 @@ class bitv {\n         /// Returns true if all bits are 1\n     #[inline(always)]\n     fn is_true() -> bool {\n-      alt self.rep {\n+      match self.rep {\n         small(b) => b.is_true(),\n         _ => {\n           for self.each() |i| { if !i { return false; } }\n@@ -350,7 +350,7 @@ class bitv {\n     /// Returns true if all bits are 0\n \n     fn is_false() -> bool {\n-      alt self.rep {\n+      match self.rep {\n         small(b) => b.is_false(),\n         big(_) => {\n           for self.each() |i| { if i { return false; } }"}, {"sha": "8b5a5e551134e2132b85f589b0d92c8ff3ebf80e", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -46,7 +46,7 @@ class dtor_res {\n   let dtor: option<fn@()>;\n   new(dtor: option<fn@()>) { self.dtor = dtor; }\n   drop {\n-    alt self.dtor {\n+    match self.dtor {\n       option::none => (),\n       option::some(f) => f()\n     }"}, {"sha": "8293e4f215c6a2c632c6dd15d79cba6ba3959095", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -41,7 +41,7 @@ fn create<T: copy>() -> t<T> {\n         return rv;\n     }\n     fn get<T: copy>(elts: dvec<cell<T>>, i: uint) -> T {\n-        alt elts.get_elt(i) { some(t) => t, _ => fail }\n+        match elts.get_elt(i) { some(t) => t, _ => fail }\n     }\n \n     type repr<T> = {mut nelts: uint,\n@@ -238,32 +238,32 @@ mod tests {\n         fn inteq(&&a: int, &&b: int) -> bool { return a == b; }\n         fn intboxeq(&&a: @int, &&b: @int) -> bool { return a == b; }\n         fn taggyeq(a: taggy, b: taggy) -> bool {\n-            alt a {\n-              one(a1) => alt b {\n+            match a {\n+              one(a1) => match b {\n                 one(b1) => return a1 == b1,\n                 _ => return false\n               }\n-              two(a1, a2) => alt b {\n+              two(a1, a2) => match b {\n                 two(b1, b2) => return a1 == b1 && a2 == b2,\n                 _ => return false\n               }\n-              three(a1, a2, a3) => alt b {\n+              three(a1, a2, a3) => match b {\n                 three(b1, b2, b3) => return a1 == b1 && a2 == b2 && a3 == b3,\n                 _ => return false\n               }\n             }\n         }\n         fn taggypareq<T>(a: taggypar<T>, b: taggypar<T>) -> bool {\n-            alt a {\n-              onepar::<T>(a1) => alt b {\n+            match a {\n+              onepar::<T>(a1) => match b {\n                 onepar::<T>(b1) => return a1 == b1,\n                 _ => return false\n               }\n-              twopar::<T>(a1, a2) => alt b {\n+              twopar::<T>(a1, a2) => match b {\n                 twopar::<T>(b1, b2) => return a1 == b1 && a2 == b2,\n                 _ => return false\n               }\n-              threepar::<T>(a1, a2, a3) => alt b {\n+              threepar::<T>(a1, a2, a3) => match b {\n                 threepar::<T>(b1, b2, b3) => {\n                     return a1 == b1 && a2 == b2 && a3 == b3\n                 }"}, {"sha": "f5396395b93cadf2a691909ce179a5dbba54f41f", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -113,7 +113,7 @@ fn maybe_get_doc(d: doc, tg: uint) -> option<doc> {\n }\n \n fn get_doc(d: doc, tg: uint) -> doc {\n-    alt maybe_get_doc(d, tg) {\n+    match maybe_get_doc(d, tg) {\n       some(d) => return d,\n       none => {\n         error!{\"failed to find block with tag %u\", tg};\n@@ -189,7 +189,7 @@ enum writer {\n }\n \n fn write_sized_vuint(w: io::writer, n: uint, size: uint) {\n-    alt size {\n+    match size {\n       1u => w.write(&[0x80u8 | (n as u8)]),\n       2u => w.write(&[0x40u8 | ((n >> 8_u) as u8), n as u8]),\n       3u => w.write(&[0x20u8 | ((n >> 16_u) as u8), (n >> 8_u) as u8,\n@@ -593,7 +593,7 @@ fn test_option_int() {\n \n     fn serialize_0<S: serialization::serializer>(s: S, v: option<int>) {\n         do s.emit_enum(~\"core::option::t\") {\n-            alt v {\n+            match v {\n               none => s.emit_enum_variant(\n                   ~\"core::option::none\", 0u, 0u, || { } ),\n               some(v0) => {\n@@ -612,7 +612,7 @@ fn test_option_int() {\n     fn deserialize_0<S: serialization::deserializer>(s: S) -> option<int> {\n         do s.read_enum(~\"core::option::t\") {\n             do s.read_enum_variant |i| {\n-                alt check i {\n+                match check i {\n                   0u => none,\n                   1u => {\n                     let v0 = do s.read_enum_variant_arg(0u) {"}, {"sha": "786af20940e53aac04041b4d5f11e7df4876a179", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -30,7 +30,7 @@ fn init<K, V>() -> treemap<K, V> { @empty }\n \n /// Insert a value into the map\n fn insert<K: copy, V: copy>(m: treemap<K, V>, k: K, v: V) -> treemap<K, V> {\n-    @alt m {\n+    @match m {\n        @empty => node(@k, @v, @empty, @empty),\n        @node(@kk, vv, left, right) => {\n          if k < kk {\n@@ -44,7 +44,7 @@ fn insert<K: copy, V: copy>(m: treemap<K, V>, k: K, v: V) -> treemap<K, V> {\n \n /// Find a value based on the key\n fn find<K, V: copy>(m: treemap<K, V>, k: K) -> option<V> {\n-    alt *m {\n+    match *m {\n       empty => none,\n       node(@kk, @v, left, right) => {\n         if k == kk {\n@@ -56,7 +56,7 @@ fn find<K, V: copy>(m: treemap<K, V>, k: K) -> option<V> {\n \n /// Visit all pairs in the map in order.\n fn traverse<K, V: copy>(m: treemap<K, V>, f: fn(K, V)) {\n-    alt *m {\n+    match *m {\n       empty => (),\n       /*\n         Previously, this had what looked like redundant"}, {"sha": "04a0469107715faa8ee1c0d3d0572412907ace23", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 54, "deletions": 52, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -43,7 +43,7 @@\n  *             optflag(\"h\"),\n  *             optflag(\"help\")\n  *         ];\n- *         let matches = alt getopts(vec::tail(args), opts) {\n+ *         let matches = match getopts(vec::tail(args), opts) {\n  *             result::ok(m) { m }\n  *             result::err(f) { fail fail_str(f) }\n  *         };\n@@ -140,7 +140,7 @@ fn is_arg(arg: ~str) -> bool {\n }\n \n fn name_str(nm: name) -> ~str {\n-    return alt nm {\n+    return match nm {\n       short(ch) => str::from_char(ch),\n       long(s) => s\n     };\n@@ -164,7 +164,7 @@ enum fail_ {\n \n /// Convert a `fail_` enum into an error string\n fn fail_str(f: fail_) -> ~str {\n-    return alt f {\n+    return match f {\n       argument_missing(nm) => ~\"Argument to option '\" + nm + ~\"' missing.\",\n       unrecognized_option(nm) => ~\"Unrecognized option: '\" + nm + ~\"'.\",\n       option_missing(nm) => ~\"Required option '\" + nm + ~\"' missing.\",\n@@ -233,12 +233,14 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n                        correctly\n                     */\n \n-                    alt find_opt(opts, opt) {\n+                    match find_opt(opts, opt) {\n                       some(id) => last_valid_opt_id = option::some(id),\n                       none => {\n                         let arg_follows =\n                             option::is_some(last_valid_opt_id) &&\n-                            alt opts[option::get(last_valid_opt_id)].hasarg {\n+                            match opts[option::get(last_valid_opt_id)]\n+                              .hasarg {\n+\n                               yes | maybe => true,\n                               no => false\n                             };\n@@ -257,11 +259,11 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n             let mut name_pos = 0u;\n             for vec::each(names) |nm| {\n                 name_pos += 1u;\n-                let optid = alt find_opt(opts, nm) {\n+                let optid = match find_opt(opts, nm) {\n                   some(id) => id,\n                   none => return err(unrecognized_option(name_str(nm)))\n                 };\n-                alt opts[optid].hasarg {\n+                match opts[optid].hasarg {\n                   no => {\n                     if !option::is_none::<~str>(i_arg) {\n                         return err(unexpected_argument(name_str(nm)));\n@@ -309,7 +311,7 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n }\n \n fn opt_vals(m: matches, nm: ~str) -> ~[optval] {\n-    return alt find_opt(m.opts, mkname(nm)) {\n+    return match find_opt(m.opts, mkname(nm)) {\n       some(id) => m.vals[id],\n       none => {\n         error!{\"No option '%s' defined\", nm};\n@@ -328,7 +330,7 @@ fn opt_present(m: matches, nm: ~str) -> bool {\n /// Returns true if any of several options were matched\n fn opts_present(m: matches, names: ~[~str]) -> bool {\n     for vec::each(names) |nm| {\n-        alt find_opt(m.opts, mkname(nm)) {\n+        match find_opt(m.opts, mkname(nm)) {\n           some(_) => return true,\n           _ => ()\n         }\n@@ -344,7 +346,7 @@ fn opts_present(m: matches, names: ~[~str]) -> bool {\n  * argument\n  */\n fn opt_str(m: matches, nm: ~str) -> ~str {\n-    return alt opt_val(m, nm) { val(s) => s, _ => fail };\n+    return match opt_val(m, nm) { val(s) => s, _ => fail };\n }\n \n /**\n@@ -355,7 +357,7 @@ fn opt_str(m: matches, nm: ~str) -> ~str {\n  */\n fn opts_str(m: matches, names: ~[~str]) -> ~str {\n     for vec::each(names) |nm| {\n-        alt opt_val(m, nm) {\n+        match opt_val(m, nm) {\n           val(s) => return s,\n           _ => ()\n         }\n@@ -373,7 +375,7 @@ fn opts_str(m: matches, names: ~[~str]) -> ~str {\n fn opt_strs(m: matches, nm: ~str) -> ~[~str] {\n     let mut acc: ~[~str] = ~[];\n     for vec::each(opt_vals(m, nm)) |v| {\n-        alt v { val(s) => vec::push(acc, s), _ => () }\n+        match v { val(s) => vec::push(acc, s), _ => () }\n     }\n     return acc;\n }\n@@ -382,7 +384,7 @@ fn opt_strs(m: matches, nm: ~str) -> ~[~str] {\n fn opt_maybe_str(m: matches, nm: ~str) -> option<~str> {\n     let vals = opt_vals(m, nm);\n     if vec::len::<optval>(vals) == 0u { return none::<~str>; }\n-    return alt vals[0] { val(s) => some::<~str>(s), _ => none::<~str> };\n+    return match vals[0] { val(s) => some::<~str>(s), _ => none::<~str> };\n }\n \n \n@@ -396,7 +398,7 @@ fn opt_maybe_str(m: matches, nm: ~str) -> option<~str> {\n fn opt_default(m: matches, nm: ~str, def: ~str) -> option<~str> {\n     let vals = opt_vals(m, nm);\n     if vec::len::<optval>(vals) == 0u { return none::<~str>; }\n-    return alt vals[0] { val(s) => some::<~str>(s), _ => some::<~str>(def) }\n+    return match vals[0] { val(s) => some::<~str>(s), _ => some::<~str>(def) }\n }\n \n #[cfg(test)]\n@@ -413,7 +415,7 @@ mod tests {\n     }\n \n     fn check_fail_type(f: fail_, ft: fail_type) {\n-        alt f {\n+        match f {\n           argument_missing(_) => assert ft == argument_missing_,\n           unrecognized_option(_) => assert ft == unrecognized_option_,\n           option_missing(_) => assert ft == option_missing_,\n@@ -429,7 +431,7 @@ mod tests {\n         let args = ~[~\"--test=20\"];\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n-        alt check rs {\n+        match check rs {\n           ok(m) => {\n             assert (opt_present(m, ~\"test\"));\n             assert (opt_str(m, ~\"test\") == ~\"20\");\n@@ -442,7 +444,7 @@ mod tests {\n         let args = ~[~\"blah\"];\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           err(f) => check_fail_type(f, option_missing_),\n           _ => fail\n         }\n@@ -453,7 +455,7 @@ mod tests {\n         let args = ~[~\"--test\"];\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           err(f) => check_fail_type(f, argument_missing_),\n           _ => fail\n         }\n@@ -464,7 +466,7 @@ mod tests {\n         let args = ~[~\"--test=20\", ~\"--test=30\"];\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           err(f) => check_fail_type(f, option_duplicated_),\n           _ => fail\n         }\n@@ -475,7 +477,7 @@ mod tests {\n         let args = ~[~\"-t\", ~\"20\"];\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           ok(m) => {\n             assert (opt_present(m, ~\"t\"));\n             assert (opt_str(m, ~\"t\") == ~\"20\");\n@@ -489,7 +491,7 @@ mod tests {\n         let args = ~[~\"blah\"];\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           err(f) => check_fail_type(f, option_missing_),\n           _ => fail\n         }\n@@ -500,7 +502,7 @@ mod tests {\n         let args = ~[~\"-t\"];\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           err(f) => check_fail_type(f, argument_missing_),\n           _ => fail\n         }\n@@ -511,7 +513,7 @@ mod tests {\n         let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           err(f) => check_fail_type(f, option_duplicated_),\n           _ => fail\n         }\n@@ -524,7 +526,7 @@ mod tests {\n         let args = ~[~\"--test=20\"];\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           ok(m) => {\n             assert (opt_present(m, ~\"test\"));\n             assert (opt_str(m, ~\"test\") == ~\"20\");\n@@ -538,7 +540,7 @@ mod tests {\n         let args = ~[~\"blah\"];\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           ok(m) => assert (!opt_present(m, ~\"test\")),\n           _ => fail\n         }\n@@ -549,7 +551,7 @@ mod tests {\n         let args = ~[~\"--test\"];\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           err(f) => check_fail_type(f, argument_missing_),\n           _ => fail\n         }\n@@ -560,7 +562,7 @@ mod tests {\n         let args = ~[~\"--test=20\", ~\"--test=30\"];\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           err(f) => check_fail_type(f, option_duplicated_),\n           _ => fail\n         }\n@@ -571,7 +573,7 @@ mod tests {\n         let args = ~[~\"-t\", ~\"20\"];\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           ok(m) => {\n             assert (opt_present(m, ~\"t\"));\n             assert (opt_str(m, ~\"t\") == ~\"20\");\n@@ -585,7 +587,7 @@ mod tests {\n         let args = ~[~\"blah\"];\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           ok(m) => assert (!opt_present(m, ~\"t\")),\n           _ => fail\n         }\n@@ -596,7 +598,7 @@ mod tests {\n         let args = ~[~\"-t\"];\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           err(f) => check_fail_type(f, argument_missing_),\n           _ => fail\n         }\n@@ -607,7 +609,7 @@ mod tests {\n         let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           err(f) => check_fail_type(f, option_duplicated_),\n           _ => fail\n         }\n@@ -620,7 +622,7 @@ mod tests {\n         let args = ~[~\"--test\"];\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           ok(m) => assert (opt_present(m, ~\"test\")),\n           _ => fail\n         }\n@@ -631,7 +633,7 @@ mod tests {\n         let args = ~[~\"blah\"];\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           ok(m) => assert (!opt_present(m, ~\"test\")),\n           _ => fail\n         }\n@@ -642,7 +644,7 @@ mod tests {\n         let args = ~[~\"--test=20\"];\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           err(f) => {\n             log(error, fail_str(f));\n             check_fail_type(f, unexpected_argument_);\n@@ -656,7 +658,7 @@ mod tests {\n         let args = ~[~\"--test\", ~\"--test\"];\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           err(f) => check_fail_type(f, option_duplicated_),\n           _ => fail\n         }\n@@ -667,7 +669,7 @@ mod tests {\n         let args = ~[~\"-t\"];\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           ok(m) => assert (opt_present(m, ~\"t\")),\n           _ => fail\n         }\n@@ -678,7 +680,7 @@ mod tests {\n         let args = ~[~\"blah\"];\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           ok(m) => assert (!opt_present(m, ~\"t\")),\n           _ => fail\n         }\n@@ -689,7 +691,7 @@ mod tests {\n         let args = ~[~\"-t\", ~\"20\"];\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           ok(m) => {\n             // The next variable after the flag is just a free argument\n \n@@ -704,7 +706,7 @@ mod tests {\n         let args = ~[~\"-t\", ~\"-t\"];\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           err(f) => check_fail_type(f, option_duplicated_),\n           _ => fail\n         }\n@@ -717,7 +719,7 @@ mod tests {\n         let args = ~[~\"--test=20\"];\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           ok(m) => {\n             assert (opt_present(m, ~\"test\"));\n             assert (opt_str(m, ~\"test\") == ~\"20\");\n@@ -731,7 +733,7 @@ mod tests {\n         let args = ~[~\"blah\"];\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           ok(m) => assert (!opt_present(m, ~\"test\")),\n           _ => fail\n         }\n@@ -742,7 +744,7 @@ mod tests {\n         let args = ~[~\"--test\"];\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           err(f) => check_fail_type(f, argument_missing_),\n           _ => fail\n         }\n@@ -753,7 +755,7 @@ mod tests {\n         let args = ~[~\"--test=20\", ~\"--test=30\"];\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           ok(m) => {\n             assert (opt_present(m, ~\"test\"));\n             assert (opt_str(m, ~\"test\") == ~\"20\");\n@@ -769,7 +771,7 @@ mod tests {\n         let args = ~[~\"-t\", ~\"20\"];\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           ok(m) => {\n             assert (opt_present(m, ~\"t\"));\n             assert (opt_str(m, ~\"t\") == ~\"20\");\n@@ -783,7 +785,7 @@ mod tests {\n         let args = ~[~\"blah\"];\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           ok(m) => assert (!opt_present(m, ~\"t\")),\n           _ => fail\n         }\n@@ -794,7 +796,7 @@ mod tests {\n         let args = ~[~\"-t\"];\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           err(f) => check_fail_type(f, argument_missing_),\n           _ => fail\n         }\n@@ -805,7 +807,7 @@ mod tests {\n         let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           ok(m) => {\n             assert (opt_present(m, ~\"t\"));\n             assert (opt_str(m, ~\"t\") == ~\"20\");\n@@ -821,7 +823,7 @@ mod tests {\n         let args = ~[~\"--untest\"];\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           err(f) => check_fail_type(f, unrecognized_option_),\n           _ => fail\n         }\n@@ -832,7 +834,7 @@ mod tests {\n         let args = ~[~\"-t\"];\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           err(f) => check_fail_type(f, unrecognized_option_),\n           _ => fail\n         }\n@@ -849,7 +851,7 @@ mod tests {\n              optflag(~\"f\"), optmulti(~\"m\"), optmulti(~\"n\"),\n              optopt(~\"notpresent\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        match rs {\n           ok(m) => {\n             assert (m.free[0] == ~\"prog\");\n             assert (m.free[1] == ~\"free1\");\n@@ -872,7 +874,7 @@ mod tests {\n     fn test_multi() {\n         let args = ~[~\"-e\", ~\"foo\", ~\"--encrypt\", ~\"foo\"];\n         let opts = ~[optopt(~\"e\"), optopt(~\"encrypt\")];\n-        let matches = alt getopts(args, opts) {\n+        let matches = match getopts(args, opts) {\n           result::ok(m) => m,\n           result::err(f) => fail\n         };\n@@ -893,7 +895,7 @@ mod tests {\n     fn test_nospace() {\n         let args = ~[~\"-Lfoo\"];\n         let opts = ~[optmulti(~\"L\")];\n-        let matches = alt getopts(args, opts) {\n+        let matches = match getopts(args, opts) {\n           result::ok(m) => m,\n           result::err(f) => fail\n         };"}, {"sha": "f3ca79be02b4ae1c952727b7a80499fd81fb6306", "filename": "src/libstd/json.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -45,7 +45,7 @@ type error = {\n \n /// Serializes a json value into a io::writer\n fn to_writer(wr: io::writer, j: json) {\n-    alt j {\n+    match j {\n       num(n) => wr.write_str(float::to_str(n, 6u)),\n       string(s) => wr.write_str(escape_str(*s)),\n       boolean(b) => wr.write_str(if b { ~\"true\" } else { ~\"false\" }),\n@@ -87,7 +87,7 @@ fn to_writer(wr: io::writer, j: json) {\n fn escape_str(s: ~str) -> ~str {\n     let mut escaped = ~\"\\\"\";\n     do str::chars_iter(s) |c| {\n-        alt c {\n+        match c {\n           '\"' => escaped += ~\"\\\\\\\"\",\n           '\\\\' => escaped += ~\"\\\\\\\\\",\n           '\\x08' => escaped += ~\"\\\\b\",\n@@ -144,7 +144,7 @@ impl parser for parser {\n     }\n \n     fn parse() -> result<json, error> {\n-        alt self.parse_value() {\n+        match self.parse_value() {\n           ok(value) => {\n             // Skip trailing whitespaces.\n             self.parse_whitespace();\n@@ -164,12 +164,12 @@ impl parser for parser {\n \n         if self.eof() { return self.error(~\"EOF while parsing value\"); }\n \n-        alt self.ch {\n+        match self.ch {\n           'n' => self.parse_ident(~\"ull\", null),\n           't' => self.parse_ident(~\"rue\", boolean(true)),\n           'f' => self.parse_ident(~\"alse\", boolean(false)),\n           '0' to '9' | '-' => self.parse_number(),\n-          '\"' => alt self.parse_str() {\n+          '\"' => match self.parse_str() {\n             ok(s) => ok(string(s)),\n             err(e) => err(e)\n           }\n@@ -200,20 +200,20 @@ impl parser for parser {\n             neg = -1f;\n         }\n \n-        let mut res = alt self.parse_integer() {\n+        let mut res = match self.parse_integer() {\n           ok(res) => res,\n           err(e) => return err(e)\n         };\n \n         if self.ch == '.' {\n-            alt self.parse_decimal(res) {\n+            match self.parse_decimal(res) {\n               ok(r) => res = r,\n               err(e) => return err(e)\n             }\n         }\n \n         if self.ch == 'e' || self.ch == 'E' {\n-            alt self.parse_exponent(res) {\n+            match self.parse_exponent(res) {\n               ok(r) => res = r,\n               err(e) => return err(e)\n             }\n@@ -225,19 +225,19 @@ impl parser for parser {\n     fn parse_integer() -> result<float, error> {\n         let mut res = 0f;\n \n-        alt self.ch {\n+        match self.ch {\n           '0' => {\n             self.bump();\n \n             // There can be only one leading '0'.\n-            alt self.ch {\n+            match self.ch {\n               '0' to '9' => return self.error(~\"invalid number\"),\n               _ => ()\n             }\n           }\n           '1' to '9' => {\n             while !self.eof() {\n-                alt self.ch {\n+                match self.ch {\n                   '0' to '9' => {\n                     res *= 10f;\n                     res += ((self.ch as int) - ('0' as int)) as float;\n@@ -258,15 +258,15 @@ impl parser for parser {\n         self.bump();\n \n         // Make sure a digit follows the decimal place.\n-        alt self.ch {\n+        match self.ch {\n           '0' to '9' => (),\n           _ => return self.error(~\"invalid number\")\n         }\n \n         let mut res = res;\n         let mut dec = 1f;\n         while !self.eof() {\n-            alt self.ch {\n+            match self.ch {\n               '0' to '9' => {\n                 dec /= 10f;\n                 res += (((self.ch as int) - ('0' as int)) as float) * dec;\n@@ -287,20 +287,20 @@ impl parser for parser {\n         let mut exp = 0u;\n         let mut neg_exp = false;\n \n-        alt self.ch {\n+        match self.ch {\n           '+' => self.bump(),\n           '-' => { self.bump(); neg_exp = true; }\n           _ => ()\n         }\n \n         // Make sure a digit follows the exponent place.\n-        alt self.ch {\n+        match self.ch {\n           '0' to '9' => (),\n           _ => return self.error(~\"invalid number\")\n         }\n \n         while !self.eof() {\n-            alt self.ch {\n+            match self.ch {\n               '0' to '9' => {\n                 exp *= 10u;\n                 exp += (self.ch as uint) - ('0' as uint);\n@@ -329,7 +329,7 @@ impl parser for parser {\n             self.bump();\n \n             if (escape) {\n-                alt self.ch {\n+                match self.ch {\n                   '\"' => str::push_char(res, '\"'),\n                   '\\\\' => str::push_char(res, '\\\\'),\n                   '/' => str::push_char(res, '/'),\n@@ -343,7 +343,7 @@ impl parser for parser {\n                       let mut i = 0u;\n                       let mut n = 0u;\n                       while i < 4u {\n-                          alt self.next_char() {\n+                          match self.next_char() {\n                             '0' to '9' => {\n                               n = n * 10u +\n                                   (self.ch as uint) - ('0' as uint);\n@@ -389,7 +389,7 @@ impl parser for parser {\n         }\n \n         loop {\n-            alt self.parse_value() {\n+            match self.parse_value() {\n               ok(v) => vec::push(values, v),\n               e => return e\n             }\n@@ -399,7 +399,7 @@ impl parser for parser {\n                 return self.error(~\"EOF while parsing list\");\n             }\n \n-            alt self.ch {\n+            match self.ch {\n               ',' => self.bump(),\n               ']' => { self.bump(); return ok(list(@values)); }\n               _ => return self.error(~\"expected `,` or `]`\")\n@@ -425,7 +425,7 @@ impl parser for parser {\n                 return self.error(~\"key must be a string\");\n             }\n \n-            let key = alt self.parse_str() {\n+            let key = match self.parse_str() {\n               ok(key) => key,\n               err(e) => return err(e)\n             };\n@@ -438,13 +438,13 @@ impl parser for parser {\n             }\n             self.bump();\n \n-            alt self.parse_value() {\n+            match self.parse_value() {\n               ok(value) => { values.insert(copy *key, value); }\n               e => return e\n             }\n             self.parse_whitespace();\n \n-            alt self.ch {\n+            match self.ch {\n               ',' => self.bump(),\n               '}' => { self.bump(); return ok(dict(values)); }\n               _ => {\n@@ -477,7 +477,7 @@ fn from_str(s: ~str) -> result<json, error> {\n \n /// Test if two json values are equal\n fn eq(value0: json, value1: json) -> bool {\n-    alt (value0, value1) {\n+    match (value0, value1) {\n       (num(f0), num(f1)) => f0 == f1,\n       (string(s0), string(s1)) => s0 == s1,\n       (boolean(b0), boolean(b1)) => b0 == b1,\n@@ -486,7 +486,7 @@ fn eq(value0: json, value1: json) -> bool {\n           if d0.size() == d1.size() {\n               let mut equal = true;\n               for d0.each |k, v0| {\n-                  alt d1.find(k) {\n+                  match d1.find(k) {\n                     some(v1) => if !eq(v0, v1) { equal = false },\n                     none => equal = false\n                   }\n@@ -581,7 +581,7 @@ impl of to_json for @~str {\n \n impl <A: to_json, B: to_json> of to_json for (A, B) {\n     fn to_json() -> json {\n-        alt self {\n+        match self {\n           (a, b) => {\n             list(@~[a.to_json(), b.to_json()])\n           }\n@@ -592,7 +592,7 @@ impl <A: to_json, B: to_json> of to_json for (A, B) {\n impl <A: to_json, B: to_json, C: to_json>\n   of to_json for (A, B, C) {\n     fn to_json() -> json {\n-        alt self {\n+        match self {\n           (a, b, c) => {\n             list(@~[a.to_json(), b.to_json(), c.to_json()])\n           }\n@@ -616,7 +616,7 @@ impl <A: to_json copy> of to_json for hashmap<~str, A> {\n \n impl <A: to_json> of to_json for option<A> {\n     fn to_json() -> json {\n-        alt self {\n+        match self {\n           none => null,\n           some(value) => value.to_json()\n         }"}, {"sha": "4b8b75d3d666aab43ae5195b30a0dd0b5d8ca952", "filename": "src/libstd/list.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -43,7 +43,7 @@ fn foldl<T: copy, U>(z: T, ls: @list<U>, f: fn(T, U) -> T) -> T {\n fn find<T: copy>(ls: @list<T>, f: fn(T) -> bool) -> option<T> {\n     let mut ls = ls;\n     loop {\n-        ls = alt *ls {\n+        ls = match *ls {\n           cons(hd, tl) => {\n             if f(hd) { return some(hd); }\n             tl\n@@ -63,7 +63,7 @@ fn has<T: copy>(ls: @list<T>, elt: T) -> bool {\n \n /// Returns true if the list is empty\n pure fn is_empty<T: copy>(ls: @list<T>) -> bool {\n-    alt *ls {\n+    match *ls {\n         nil => true,\n         _ => false\n     }\n@@ -83,20 +83,20 @@ fn len<T>(ls: @list<T>) -> uint {\n \n /// Returns all but the first element of a list\n pure fn tail<T: copy>(ls: @list<T>) -> @list<T> {\n-    alt *ls {\n+    match *ls {\n         cons(_, tl) => return tl,\n         nil => fail ~\"list empty\"\n     }\n }\n \n /// Returns the first element of a list\n pure fn head<T: copy>(ls: @list<T>) -> T {\n-    alt check *ls { cons(hd, _) => hd }\n+    match check *ls { cons(hd, _) => hd }\n }\n \n /// Appends one list to another\n pure fn append<T: copy>(l: @list<T>, m: @list<T>) -> @list<T> {\n-    alt *l {\n+    match *l {\n       nil => return m,\n       cons(x, xs) => {\n         let rest = append(xs, m);\n@@ -114,7 +114,7 @@ fn push<T: copy>(&l: list<T>, v: T) {\n fn iter<T>(l: @list<T>, f: fn(T)) {\n     let mut cur = l;\n     loop {\n-        cur = alt *cur {\n+        cur = match *cur {\n           cons(hd, tl) => {\n             f(hd);\n             tl\n@@ -128,7 +128,7 @@ fn iter<T>(l: @list<T>, f: fn(T)) {\n fn each<T>(l: @list<T>, f: fn(T) -> bool) {\n     let mut cur = l;\n     loop {\n-        cur = alt *cur {\n+        cur = match *cur {\n           cons(hd, tl) => {\n             if !f(hd) { return; }\n             tl"}, {"sha": "695f40fc3877d3218b29e1dc5b7d11f2362db3f1", "filename": "src/libstd/map.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -133,7 +133,7 @@ mod chained {\n             let mut e0 = e_root;\n             let mut comp = 1u;   // for logging\n             loop {\n-                alt copy e0.next {\n+                match copy e0.next {\n                   none => {\n                     debug!{\"search_tbl: absent, comp %u, hash %u, idx %u\",\n                            comp, h, idx};\n@@ -156,7 +156,7 @@ mod chained {\n \n         fn search_tbl(k: &K, h: uint) -> search_result<K,V> {\n             let idx = h % vec::len(self.chains);\n-            alt copy self.chains[idx] {\n+            match copy self.chains[idx] {\n               none => {\n                 debug!{\"search_tbl: none, comp %u, hash %u, idx %u\",\n                        0u, h, idx};\n@@ -193,7 +193,7 @@ mod chained {\n             while i < n {\n                 let mut chain = self.chains[i];\n                 loop {\n-                    chain = alt chain {\n+                    chain = match chain {\n                       none => break,\n                       some(entry) => {\n                         let next = entry.next;\n@@ -216,15 +216,15 @@ mod chained {\n \n         fn contains_key_ref(k: &K) -> bool {\n             let hash = self.hasher(k);\n-            alt self.search_tbl(k, hash) {\n+            match self.search_tbl(k, hash) {\n               not_found => false,\n               found_first(*) | found_after(*) => true\n             }\n         }\n \n         fn insert(+k: K, +v: V) -> bool {\n             let hash = self.hasher(&k);\n-            alt self.search_tbl(&k, hash) {\n+            match self.search_tbl(&k, hash) {\n               not_found => {\n                 self.count += 1u;\n                 let idx = hash % vec::len(self.chains);\n@@ -265,7 +265,7 @@ mod chained {\n         }\n \n         fn find(+k: K) -> option<V> {\n-            alt self.search_tbl(&k, self.hasher(&k)) {\n+            match self.search_tbl(&k, self.hasher(&k)) {\n               not_found => none,\n               found_first(_, entry) => some(entry.value),\n               found_after(_, entry) => some(entry.value)\n@@ -281,7 +281,7 @@ mod chained {\n         }\n \n         fn remove(+k: K) -> option<V> {\n-            alt self.search_tbl(&k, self.hasher(&k)) {\n+            match self.search_tbl(&k, self.hasher(&k)) {\n               not_found => none,\n               found_first(idx, entry) => {\n                 self.count -= 1u;\n@@ -638,7 +638,7 @@ mod tests {\n         i = 0u;\n         while i < num_to_insert {\n             let v = hm.remove(i);\n-            alt v {\n+            match v {\n               option::some(u) => assert (u == i * i),\n               option::none => fail\n             }"}, {"sha": "d0b08212952989a6892ebff64a40270511071887", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -47,7 +47,7 @@ type parse_addr_err = {\n  * * ip - a `std::net::ip::ip_addr`\n  */\n fn format_addr(ip: ip_addr) -> ~str {\n-    alt ip {\n+    match ip {\n       ipv4(addr) =>  unsafe {\n         let result = uv_ip4_name(&addr);\n         if result == ~\"\" {\n@@ -103,7 +103,7 @@ fn get_addr(++node: ~str, iotask: iotask)\n                     node_ptr,\n                     ptr::null(),\n                     ptr::null());\n-                alt result {\n+                match result {\n                   0i32 => {\n                     set_data_for_req(handle_ptr, handle_data_ptr);\n                   }\n@@ -134,7 +134,7 @@ mod v4 {\n      * * an `ip_addr` of the `ipv4` variant\n      */\n     fn parse_addr(ip: ~str) -> ip_addr {\n-        alt try_parse_addr(ip) {\n+        match try_parse_addr(ip) {\n           result::ok(addr) => copy(addr),\n           result::err(err_data) => fail err_data.err_msg\n         }\n@@ -155,7 +155,7 @@ mod v4 {\n     }\n     fn parse_to_ipv4_rep(ip: ~str) -> result::result<ipv4_rep, ~str> {\n         let parts = vec::map(str::split_char(ip, '.'), |s| {\n-            alt uint::from_str(s) {\n+            match uint::from_str(s) {\n               some(n) if n <= 255u => n,\n               _ => 256u\n             }\n@@ -220,7 +220,7 @@ mod v6 {\n      * * an `ip_addr` of the `ipv6` variant\n      */\n     fn parse_addr(ip: ~str) -> ip_addr {\n-        alt try_parse_addr(ip) {\n+        match try_parse_addr(ip) {\n           result::ok(addr) => copy(addr),\n           result::err(err_data) => fail err_data.err_msg\n         }\n@@ -326,7 +326,7 @@ mod test {\n     }\n     #[test]\n     fn test_ip_ipv4_bad_parse() {\n-        alt v4::try_parse_addr(~\"b4df00d\") {\n+        match v4::try_parse_addr(~\"b4df00d\") {\n           result::err(err_info) => {\n             log(debug, fmt!{\"got error as expected %?\", err_info});\n             assert true;\n@@ -339,7 +339,7 @@ mod test {\n     #[test]\n     #[ignore(target_os=\"win32\")]\n     fn test_ip_ipv6_bad_parse() {\n-        alt v6::try_parse_addr(~\"::,~2234k;\") {\n+        match v6::try_parse_addr(~\"::,~2234k;\") {\n           result::err(err_info) => {\n             log(debug, fmt!{\"got error as expected %?\", err_info});\n             assert true;\n@@ -364,7 +364,7 @@ mod test {\n         log(debug, fmt!{\"test_get_addr: Number of results for %s: %?\",\n                         localhost_name, vec::len(results)});\n         for vec::each(results) |r| {\n-            let ipv_prefix = alt r {\n+            let ipv_prefix = match r {\n               ipv4(_) => ~\"IPv4\",\n               ipv6(_) => ~\"IPv6\"\n             };"}, {"sha": "4e25a42985a1689ba8ef738d5fc7aab9c0465f17", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -151,16 +151,16 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n         log(debug, ~\"in interact cb for tcp client connect..\");\n         log(debug, fmt!{\"stream_handle_ptr in interact %?\",\n             stream_handle_ptr});\n-        alt uv::ll::tcp_init( loop_ptr, stream_handle_ptr) {\n+        match uv::ll::tcp_init( loop_ptr, stream_handle_ptr) {\n           0i32 => {\n             log(debug, ~\"tcp_init successful\");\n-            alt input_ip {\n+            match input_ip {\n               ipv4 => {\n                 log(debug, ~\"dealing w/ ipv4 connection..\");\n                 let connect_req_ptr =\n                     ptr::addr_of((*socket_data_ptr).connect_req);\n                 let addr_str = ip::format_addr(input_ip);\n-                let connect_result = alt input_ip {\n+                let connect_result = match input_ip {\n                   ip::ipv4(addr) => {\n                     // have to \"recreate\" the sockaddr_in/6\n                     // since the ip_addr discards the port\n@@ -185,7 +185,7 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n                         tcp_connect_on_connect_cb)\n                   }\n                 };\n-                alt connect_result {\n+                match connect_result {\n                   0i32 => {\n                     log(debug, ~\"tcp_connect successful\");\n                     // reusable data that we'll have for the\n@@ -223,7 +223,7 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n           }\n         }\n     };\n-    alt comm::recv(result_po) {\n+    match comm::recv(result_po) {\n       conn_success => {\n         log(debug, ~\"tcp::connect - received success on result_po\");\n         result::ok(tcp_socket(socket_data))\n@@ -234,7 +234,7 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n         // still have to free the malloc'd stream handle..\n         rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n                                            as *libc::c_void);\n-        let tcp_conn_err = alt err_data.err_name {\n+        let tcp_conn_err = match err_data.err_name {\n           ~\"ECONNREFUSED\" => connection_refused,\n           _ => generic_connect_err(err_data.err_name, err_data.err_msg)\n         };\n@@ -445,7 +445,7 @@ fn read_future(sock: tcp_socket, timeout_msecs: uint)\n  *             // do work here\n  *         }\n  *     };\n- *     alt comm::recv(cont_po) {\n+ *     match comm::recv(cont_po) {\n  *       // shut down listen()\n  *       some(err_data) { comm::send(kill_chan, some(err_data)) }\n  *       // wait for next connection\n@@ -469,7 +469,7 @@ fn read_future(sock: tcp_socket, timeout_msecs: uint)\n fn accept(new_conn: tcp_new_connection)\n     -> result::result<tcp_socket, tcp_err_data> unsafe {\n \n-    alt new_conn{\n+    match new_conn{\n       new_tcp_conn(server_handle_ptr) => {\n         let server_data_ptr = uv::ll::get_data_for_uv_handle(\n             server_handle_ptr) as *tcp_listen_fc_data;\n@@ -501,10 +501,10 @@ fn accept(new_conn: tcp_new_connection)\n         log(debug, ~\"in interact cb for tcp::accept\");\n         let loop_ptr = uv::ll::get_loop_for_uv_handle(\n             server_handle_ptr);\n-        alt uv::ll::tcp_init(loop_ptr, client_stream_handle_ptr) {\n+        match uv::ll::tcp_init(loop_ptr, client_stream_handle_ptr) {\n           0i32 => {\n             log(debug, ~\"uv_tcp_init successful for client stream\");\n-            alt uv::ll::accept(\n+            match uv::ll::accept(\n                 server_handle_ptr as *libc::c_void,\n                 client_stream_handle_ptr as *libc::c_void) {\n               0i32 => {\n@@ -528,7 +528,7 @@ fn accept(new_conn: tcp_new_connection)\n           }\n         }\n         // UNSAFE LIBUV INTERACTION END\n-        alt comm::recv(result_po) {\n+        match comm::recv(result_po) {\n           some(err_data) => result::err(err_data),\n           none => result::ok(tcp_socket(client_socket_data))\n         }\n@@ -610,13 +610,13 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n         // nested within a comm::listen block)\n         let loc_ip = copy(host_ip);\n         do iotask::interact(iotask) |loop_ptr| {\n-            alt uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n+            match uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n               0i32 => {\n                 uv::ll::set_data_for_uv_handle(\n                     server_stream_ptr,\n                     server_data_ptr);\n                 let addr_str = ip::format_addr(loc_ip);\n-                let bind_result = alt loc_ip {\n+                let bind_result = match loc_ip {\n                   ip::ipv4(addr) => {\n                     log(debug, fmt!{\"addr: %?\", addr});\n                     let in_addr = uv::ll::ip4_addr(addr_str, port as int);\n@@ -630,9 +630,9 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n                                      ptr::addr_of(in_addr))\n                   }\n                 };\n-                alt bind_result {\n+                match bind_result {\n                   0i32 => {\n-                    alt uv::ll::listen(server_stream_ptr,\n+                    match uv::ll::listen(server_stream_ptr,\n                                        backlog as libc::c_int,\n                                        tcp_lfc_on_connection_cb) {\n                       0i32 => comm::send(setup_ch, none),\n@@ -659,7 +659,7 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n         };\n         setup_ch.recv()\n     };\n-    alt setup_result {\n+    match setup_result {\n       some(err_data) => {\n         do iotask::interact(iotask) |loop_ptr| {\n             log(debug, fmt!{\"tcp::listen post-kill recv hl interact %?\",\n@@ -668,7 +668,7 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n             uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n         };\n         stream_closed_po.recv();\n-        alt err_data.err_name {\n+        match err_data.err_name {\n           ~\"EACCES\" => {\n             log(debug, ~\"Got EACCES error\");\n             result::err(access_denied)\n@@ -695,7 +695,7 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n             uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n         };\n         stream_closed_po.recv();\n-        alt kill_result {\n+        match kill_result {\n           // some failure post bind/listen\n           some(err_data) => result::err(generic_listen_err(err_data.err_name,\n                                                            err_data.err_msg)),\n@@ -878,7 +878,7 @@ fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n             some(comm::recv(result::get(rs_result)))\n         };\n         log(debug, ~\"tcp::read after recv_timeout\");\n-        alt read_result {\n+        match read_result {\n           none => {\n             log(debug, ~\"tcp::read: timed out..\");\n             let err_data = {\n@@ -905,7 +905,7 @@ fn read_stop_common_impl(socket_data: *tcp_socket_data) ->\n     let stop_ch = comm::chan(stop_po);\n     do iotask::interact((*socket_data).iotask) |loop_ptr| {\n         log(debug, ~\"in interact cb for tcp::read_stop\");\n-        alt uv::ll::read_stop(stream_handle_ptr as *uv::ll::uv_stream_t) {\n+        match uv::ll::read_stop(stream_handle_ptr as *uv::ll::uv_stream_t) {\n           0i32 => {\n             log(debug, ~\"successfully called uv_read_stop\");\n             comm::send(stop_ch, none);\n@@ -917,7 +917,7 @@ fn read_stop_common_impl(socket_data: *tcp_socket_data) ->\n           }\n         }\n     };\n-    alt comm::recv(stop_po) {\n+    match comm::recv(stop_po) {\n       some(err_data) => result::err(err_data.to_tcp_err()),\n       none => result::ok(())\n     }\n@@ -933,7 +933,7 @@ fn read_start_common_impl(socket_data: *tcp_socket_data)\n     log(debug, ~\"in tcp::read_start before interact loop\");\n     do iotask::interact((*socket_data).iotask) |loop_ptr| {\n         log(debug, fmt!{\"in tcp::read_start interact cb %?\", loop_ptr});\n-        alt uv::ll::read_start(stream_handle_ptr as *uv::ll::uv_stream_t,\n+        match uv::ll::read_start(stream_handle_ptr as *uv::ll::uv_stream_t,\n                                on_alloc_cb,\n                                on_tcp_read_cb) {\n           0i32 => {\n@@ -947,7 +947,7 @@ fn read_start_common_impl(socket_data: *tcp_socket_data)\n           }\n         }\n     };\n-    alt comm::recv(start_po) {\n+    match comm::recv(start_po) {\n       some(err_data) => result::err(err_data.to_tcp_err()),\n       none => result::ok((*socket_data).reader_po)\n     }\n@@ -973,7 +973,7 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n     let write_data_ptr = ptr::addr_of(write_data);\n     do iotask::interact((*socket_data_ptr).iotask) |loop_ptr| {\n         log(debug, fmt!{\"in interact cb for tcp::write %?\", loop_ptr});\n-        alt uv::ll::write(write_req_ptr,\n+        match uv::ll::write(write_req_ptr,\n                           stream_handle_ptr,\n                           write_buf_vec_ptr,\n                           tcp_write_complete_cb) {\n@@ -993,7 +993,7 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n     // and waiting here for the write to complete, we should transfer\n     // ownership of everything to the I/O task and let it deal with the\n     // aftermath, so we don't have to sit here blocking.\n-    alt comm::recv(result_po) {\n+    match comm::recv(result_po) {\n       tcp_write_success => result::ok(()),\n       tcp_write_error(err_data) => result::err(err_data.to_tcp_err())\n     }\n@@ -1024,7 +1024,7 @@ extern fn tcp_lfc_on_connection_cb(handle: *uv::ll::uv_tcp_t,\n         as *tcp_listen_fc_data;\n     let kill_ch = (*server_data_ptr).kill_ch;\n     if (*server_data_ptr).active {\n-        alt status {\n+        match status {\n           0i32 => (*server_data_ptr).on_connect_cb(handle),\n           _ => {\n             let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n@@ -1081,7 +1081,7 @@ extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n     let loop_ptr = uv::ll::get_loop_for_uv_handle(stream);\n     let socket_data_ptr = uv::ll::get_data_for_uv_handle(stream)\n         as *tcp_socket_data;\n-    alt nread as int {\n+    match nread as int {\n       // incoming err.. probably eof\n       -1 => {\n         let err_data = uv::ll::get_last_err_data(loop_ptr).to_tcp_err();\n@@ -1175,7 +1175,7 @@ extern fn tcp_connect_on_connect_cb(connect_req_ptr: *uv::ll::uv_connect_t,\n     log(debug, fmt!{\"tcp_connect result_ch %?\", result_ch});\n     let tcp_stream_ptr =\n         uv::ll::get_stream_handle_from_connect_req(connect_req_ptr);\n-    alt status {\n+    match status {\n       0i32 => {\n         log(debug, ~\"successful tcp connection!\");\n         comm::send(result_ch, conn_success);\n@@ -1336,7 +1336,7 @@ mod test {\n                 client_ch,\n                 hl_loop)\n         };\n-        alt actual_resp_result.get_err() {\n+        match actual_resp_result.get_err() {\n           connection_refused => (),\n           _ => fail ~\"unknown error.. expected connection_refused\"\n         }\n@@ -1382,7 +1382,7 @@ mod test {\n                 client_ch,\n                 hl_loop)\n         };\n-        alt listen_err {\n+        match listen_err {\n           address_in_use => {\n             assert true;\n           }\n@@ -1401,7 +1401,7 @@ mod test {\n                             server_ip,\n                             server_port,\n                             hl_loop);\n-        alt listen_err {\n+        match listen_err {\n           access_denied => {\n             assert true;\n           }\n@@ -1515,7 +1515,7 @@ mod test {\n                         log(debug, ~\"SERVER: successfully accepted\"+\n                             ~\"connection!\");\n                         let received_req_bytes = read(sock, 0u);\n-                        alt received_req_bytes {\n+                        match received_req_bytes {\n                           result::ok(data) => {\n                             log(debug, ~\"SERVER: got REQ str::from_bytes..\");\n                             log(debug, fmt!{\"SERVER: REQ data len: %?\",\n@@ -1544,7 +1544,7 @@ mod test {\n         });\n         // err check on listen_result\n         if result::is_err(listen_result) {\n-            alt result::get_err(listen_result) {\n+            match result::get_err(listen_result) {\n               generic_listen_err(name, msg) => {\n                 fail fmt!{\"SERVER: exited abnormally name %s msg %s\",\n                                 name, msg};"}, {"sha": "215d5b4f5e15148b79149341f269d4601c03d735", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -133,10 +133,10 @@ fn prepend_str(rope: rope, str: @~str) -> rope {\n \n /// Concatenate two ropes\n fn append_rope(left: rope, right: rope) -> rope {\n-   alt(left) {\n+   match (left) {\n      node::empty => return right,\n      node::content(left_content) => {\n-       alt(right) {\n+       match (right) {\n          node::empty => return left,\n          node::content(right_content) => {\n            return node::content(node::concat2(left_content, right_content));\n@@ -197,9 +197,9 @@ Section: Keeping ropes healthy\n  * to rebalance your rope at some point, before using it for other purposes.\n  */\n fn bal(rope:rope) -> rope {\n-    alt(rope) {\n+    match (rope) {\n       node::empty => return rope,\n-      node::content(x) => alt(node::bal(x)) {\n+      node::content(x) => match (node::bal(x)) {\n         option::none    => rope,\n         option::some(y) => node::content(y)\n       }\n@@ -226,7 +226,7 @@ Section: Transforming ropes\n  */\n fn sub_chars(rope: rope, char_offset: uint, char_len: uint) -> rope {\n     if char_len == 0u { return node::empty; }\n-    alt(rope) {\n+    match (rope) {\n       node::empty => fail,\n       node::content(node) => if char_len > node::char_len(node) {\n         fail\n@@ -251,7 +251,7 @@ fn sub_chars(rope: rope, char_offset: uint, char_len: uint) -> rope {\n  */\n fn sub_bytes(rope: rope, byte_offset: uint, byte_len: uint) -> rope {\n     if byte_len == 0u { return node::empty; }\n-    alt(rope) {\n+    match (rope) {\n       node::empty => fail,\n       node::content(node) =>if byte_len > node::byte_len(node) {\n         fail\n@@ -276,7 +276,7 @@ Section: Comparing ropes\n  * value if `left > right`\n  */\n fn cmp(left: rope, right: rope) -> int {\n-    alt((left, right)) {\n+    match ((left, right)) {\n       (node::empty, node::empty) => return 0,\n       (node::empty, _)     => return -1,\n       (_, node::empty)     => return  1,\n@@ -379,7 +379,7 @@ Section: Iterating\n  * that is if `it` returned `false` at any point.\n  */\n fn loop_chars(rope: rope, it: fn(char) -> bool) -> bool {\n-   alt(rope) {\n+   match (rope) {\n       node::empty => return true,\n       node::content(x) => return node::loop_chars(x, it)\n    }\n@@ -422,7 +422,7 @@ fn iter_chars(rope: rope, it: fn(char)) {\n  * that is if `it` returned `false` at any point.\n  */\n fn loop_leaves(rope: rope, it: fn(node::leaf) -> bool) -> bool{\n-   alt(rope) {\n+   match (rope) {\n       node::empty => return true,\n       node::content(x) => return node::loop_leaves(x, it)\n    }\n@@ -431,7 +431,7 @@ fn loop_leaves(rope: rope, it: fn(node::leaf) -> bool) -> bool{\n mod iterator {\n     mod leaf {\n         fn start(rope: rope) -> node::leaf_iterator::t {\n-            alt(rope) {\n+            match (rope) {\n               node::empty      => return node::leaf_iterator::empty(),\n               node::content(x) => return node::leaf_iterator::start(x)\n             }\n@@ -442,7 +442,7 @@ mod iterator {\n     }\n     mod char {\n         fn start(rope: rope) -> node::char_iterator::t {\n-            alt(rope) {\n+            match (rope) {\n               node::empty      => return node::char_iterator::empty(),\n               node::content(x) => return node::char_iterator::start(x)\n             }\n@@ -469,7 +469,7 @@ mod iterator {\n  * Constant time.\n  */\n fn height(rope: rope) -> uint {\n-   alt(rope) {\n+   match (rope) {\n       node::empty      => return 0u,\n       node::content(x) => return node::height(x)\n    }\n@@ -485,7 +485,7 @@ fn height(rope: rope) -> uint {\n  * Constant time.\n  */\n pure fn char_len(rope: rope) -> uint {\n-   alt(rope) {\n+   match (rope) {\n      node::empty            => return 0u,\n      node::content(x)       => return node::char_len(x)\n    }\n@@ -499,7 +499,7 @@ pure fn char_len(rope: rope) -> uint {\n  * Constant time.\n  */\n pure fn byte_len(rope: rope) -> uint {\n-   alt(rope) {\n+   match (rope) {\n      node::empty            => return 0u,\n      node::content(x)       => return node::byte_len(x)\n    }\n@@ -522,7 +522,7 @@ pure fn byte_len(rope: rope) -> uint {\n  * rope + the (bounded) length of the largest leaf.\n  */\n fn char_at(rope: rope, pos: uint) -> char {\n-   alt(rope) {\n+   match (rope) {\n       node::empty => fail,\n       node::content(x) => return node::char_at(x, pos)\n    }\n@@ -730,14 +730,14 @@ mod node {\n \n     pure fn byte_len(node: @node) -> uint {\n         //FIXME (#2744): Could we do this without the pattern-matching?\n-        alt(*node) {\n+        match (*node) {\n           leaf(y)   => return y.byte_len,\n           concat(y) => return y.byte_len\n         }\n     }\n \n     pure fn char_len(node: @node) -> uint {\n-        alt(*node) {\n+        match (*node) {\n           leaf(y)   => return y.char_len,\n           concat(y) => return y.char_len\n         }\n@@ -800,7 +800,7 @@ mod node {\n         let mut offset = 0u;//Current position in the buffer\n         let it = leaf_iterator::start(node);\n         loop {\n-            alt(leaf_iterator::next(it)) {\n+            match (leaf_iterator::next(it)) {\n               option::none => break,\n               option::some(x) => {\n                 //FIXME (#2744): Replace with memcpy or something similar\n@@ -827,7 +827,7 @@ mod node {\n      * This function executes in linear time.\n      */\n     fn flatten(node: @node) -> @node unsafe {\n-        alt(*node) {\n+        match (*node) {\n           leaf(_) => return node,\n           concat(x) => {\n             return @leaf({\n@@ -861,7 +861,7 @@ mod node {\n         let mut forest = ~[mut];\n         let it = leaf_iterator::start(node);\n         loop {\n-            alt (leaf_iterator::next(it)) {\n+            match (leaf_iterator::next(it)) {\n               option::none    => break,\n               option::some(x) => vec::push(forest, @leaf(x))\n             }\n@@ -898,7 +898,7 @@ mod node {\n             if byte_offset == 0u && byte_len == node::byte_len(node) {\n                 return node;\n             }\n-            alt(*node) {\n+            match (*node) {\n               node::leaf(x) => {\n                 let char_len =\n                     str::count_chars(*x.content, byte_offset, byte_len);\n@@ -956,7 +956,7 @@ mod node {\n         let mut node        = node;\n         let mut char_offset = char_offset;\n         loop {\n-            alt(*node) {\n+            match (*node) {\n               node::leaf(x) => {\n                 if char_offset == 0u && char_len == x.char_len {\n                     return node;\n@@ -1007,7 +1007,7 @@ mod node {\n     }\n \n     fn height(node: @node) -> uint {\n-        alt(*node) {\n+        match (*node) {\n           leaf(_)   => return 0u,\n           concat(x) => return x.height\n         }\n@@ -1018,7 +1018,7 @@ mod node {\n         let itb = char_iterator::start(b);\n         let mut result = 0;\n         while result == 0 {\n-            alt((char_iterator::next(ita), char_iterator::next(itb))) {\n+            match ((char_iterator::next(ita), char_iterator::next(itb))) {\n               (option::none, option::none) => break,\n               (option::some(chara), option::some(charb)) => {\n                 result = char::cmp(chara, charb);\n@@ -1059,7 +1059,7 @@ mod node {\n     fn loop_leaves(node: @node, it: fn(leaf) -> bool) -> bool{\n         let mut current = node;\n         loop {\n-            alt(*current) {\n+            match (*current) {\n               leaf(x) => return it(x),\n               concat(x) => if loop_leaves(x.left, it) { //non tail call\n                 current = x.right;       //tail call\n@@ -1091,7 +1091,7 @@ mod node {\n         let mut node    = node;\n         let mut pos     = pos;\n         loop {\n-            alt *node {\n+            match *node {\n               leaf(x) => return str::char_at(*x.content, pos),\n               concat({left, right, _}) => {\n                 let left_len = char_len(left);\n@@ -1126,7 +1126,7 @@ mod node {\n             loop {\n                 let current = it.stack[it.stackpos];\n                 it.stackpos -= 1;\n-                alt(*current) {\n+                match (*current) {\n                   concat(x) => {\n                     it.stackpos += 1;\n                     it.stack[it.stackpos] = x.right;\n@@ -1164,11 +1164,11 @@ mod node {\n \n         fn next(it: t) -> option<char> {\n             loop {\n-                alt(get_current_or_next_leaf(it)) {\n+                match (get_current_or_next_leaf(it)) {\n                   option::none => return option::none,\n                   option::some(_) => {\n                     let next_char = get_next_char_in_leaf(it);\n-                    alt(next_char) {\n+                    match (next_char) {\n                       option::none => again,\n                       option::some(_) => return next_char\n                     }\n@@ -1178,11 +1178,11 @@ mod node {\n         }\n \n         fn get_current_or_next_leaf(it: t) -> option<leaf> {\n-            alt(it.leaf) {\n+            match (it.leaf) {\n               option::some(_) => return it.leaf,\n               option::none => {\n                 let next = leaf_iterator::next(it.leaf_iterator);\n-                alt(next) {\n+                match (next) {\n                   option::none => return option::none,\n                   option::some(_) => {\n                     it.leaf          = next;\n@@ -1195,7 +1195,7 @@ mod node {\n         }\n \n         fn get_next_char_in_leaf(it: t) -> option<char> {\n-            alt copy it.leaf {\n+            match copy it.leaf {\n               option::none => return option::none,\n               option::some(aleaf) => {\n                 if it.leaf_byte_pos >= aleaf.byte_len {\n@@ -1220,12 +1220,12 @@ mod tests {\n \n     //Utility function, used for sanity check\n     fn rope_to_string(r: rope) -> ~str {\n-        alt(r) {\n+        match (r) {\n           node::empty => return ~\"\",\n           node::content(x) => {\n             let str = @mut ~\"\";\n             fn aux(str: @mut ~str, node: @node::node) unsafe {\n-                alt(*node) {\n+                match (*node) {\n                   node::leaf(x) => {\n                     *str += str::slice(\n                         *x.content, x.byte_offset,\n@@ -1274,7 +1274,7 @@ mod tests {\n         let rope_iter   = iterator::char::start(r);\n         let mut equal   = true;\n         while equal {\n-            alt(node::char_iterator::next(rope_iter)) {\n+            match (node::char_iterator::next(rope_iter)) {\n               option::none => {\n                 if string_iter < string_len {\n                     equal = false;\n@@ -1301,7 +1301,7 @@ mod tests {\n         let mut len = 0u;\n         let it  = iterator::char::start(r);\n         loop {\n-            alt(node::char_iterator::next(it)) {\n+            match (node::char_iterator::next(it)) {\n               option::none => break,\n               option::some(_) => len += 1u\n             }"}, {"sha": "86421ea3e74740632946afeeaac84c4fbd92ab62", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -243,7 +243,7 @@ fn deserialize_bool<D: deserializer>(d: D) -> bool {\n \n fn serialize_option<S: serializer,T>(s: S, v: option<T>, st: fn(T)) {\n     do s.emit_enum(~\"option\") {\n-        alt v {\n+        match v {\n           none => do s.emit_enum_variant(~\"none\", 0u, 0u) {\n           }\n \n@@ -260,7 +260,7 @@ fn deserialize_option<D: deserializer,T: copy>(d: D, st: fn() -> T)\n     -> option<T> {\n     do d.read_enum(~\"option\") {\n         do d.read_enum_variant |i| {\n-            alt check i {\n+            match check i {\n               0u => none,\n               1u => some(d.read_enum_variant_arg(0u, || st() ))\n             }"}, {"sha": "6ed2a397b3f6f90abd830327ae5ab80c040fe126", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -48,7 +48,7 @@ pure fn find<T: copy>(self: smallintmap<T>, key: uint) -> option<T> {\n  * If the key does not exist in the map\n  */\n pure fn get<T: copy>(self: smallintmap<T>, key: uint) -> T {\n-    alt find(self, key) {\n+    match find(self, key) {\n       none => {\n         error!{\"smallintmap::get(): key not present\"};\n         fail;\n@@ -67,7 +67,7 @@ impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n     fn size() -> uint {\n         let mut sz = 0u;\n         for self.v.each |item| {\n-            alt item {\n+            match item {\n               some(_) => sz += 1u,\n               _ => ()\n             }\n@@ -103,7 +103,7 @@ impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n     fn each(it: fn(+key: uint, +value: V) -> bool) {\n         let mut idx = 0u, l = self.v.len();\n         while idx < l {\n-            alt self.v.get_elt(idx) {\n+            match self.v.get_elt(idx) {\n               some(elt) => if !it(idx, elt) { break }\n               none => ()\n             }\n@@ -119,7 +119,7 @@ impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n     fn each_ref(it: fn(key: &uint, value: &V) -> bool) {\n         let mut idx = 0u, l = self.v.len();\n         while idx < l {\n-            alt self.v.get_elt(idx) {\n+            match self.v.get_elt(idx) {\n               some(elt) => if !it(&idx, &elt) { break }\n               none => ()\n             }"}, {"sha": "1ebfe6955193e0c74d3d379664c261f027b6cb58", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -21,7 +21,7 @@ fn mkdtemp(prefix: ~str, suffix: ~str) -> option<~str> {\n #[test]\n fn test_mkdtemp() {\n     let r = mkdtemp(~\"./\", ~\"foobar\");\n-    alt r {\n+    match r {\n         some(p) => {\n             os::remove_dir(p);\n             assert(str::ends_with(p, ~\"foobar\"));"}, {"sha": "0d3112238476819c1c6db863d617ff0546384093", "filename": "src/libstd/term.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -35,7 +35,7 @@ fn reset(writer: io::writer) {\n fn color_supported() -> bool {\n     let supported_terms = ~[~\"xterm-color\", ~\"xterm\",\n                            ~\"screen-bce\", ~\"xterm-256color\"];\n-    return alt os::getenv(~\"TERM\") {\n+    return match os::getenv(~\"TERM\") {\n           option::some(env) => {\n             for vec::each(supported_terms) |term| {\n                 if term == env { return true; }"}, {"sha": "a4b52c5168594d9e48f31ecc18721dd9e02ad6ea", "filename": "src/libstd/test.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -52,7 +52,7 @@ type test_desc = {\n // arguments and a vector of test_descs (generated at compile time).\n fn test_main(args: ~[~str], tests: ~[test_desc]) {\n     let opts =\n-        alt parse_opts(args) {\n+        match parse_opts(args) {\n           either::left(o) => o,\n           either::right(m) => fail m\n         };\n@@ -69,7 +69,7 @@ fn parse_opts(args: ~[~str]) -> opt_res {\n     let args_ = vec::tail(args);\n     let opts = ~[getopts::optflag(~\"ignored\"), getopts::optopt(~\"logfile\")];\n     let matches =\n-        alt getopts::getopts(args_, opts) {\n+        match getopts::getopts(args_, opts) {\n           ok(m) => m,\n           err(f) => return either::right(getopts::fail_str(f))\n         };\n@@ -105,19 +105,19 @@ fn run_tests_console(opts: test_opts,\n                      tests: ~[test_desc]) -> bool {\n \n     fn callback(event: testevent, st: console_test_state) {\n-        alt event {\n+        match event {\n           te_filtered(filtered_tests) => {\n             st.total = vec::len(filtered_tests);\n             let noun = if st.total != 1u { ~\"tests\" } else { ~\"test\" };\n             st.out.write_line(fmt!{\"\\nrunning %u %s\", st.total, noun});\n           }\n           te_wait(test) => st.out.write_str(fmt!{\"test %s ... \", test.name}),\n           te_result(test, result) => {\n-            alt st.log_out {\n+            match st.log_out {\n                 some(f) => write_log(f, result, test),\n                 none => ()\n             }\n-            alt result {\n+            match result {\n               tr_ok => {\n                 st.passed += 1u;\n                 write_ok(st.out, st.use_color);\n@@ -139,8 +139,9 @@ fn run_tests_console(opts: test_opts,\n         }\n     }\n \n-    let log_out = alt opts.logfile {\n-        some(path) => alt io::file_writer(path, ~[io::create, io::truncate]) {\n+    let log_out = match opts.logfile {\n+        some(path) => match io::file_writer(path,\n+                                            ~[io::create, io::truncate]) {\n           result::ok(w) => some(w),\n           result::err(s) => {\n               fail(fmt!{\"can't open output file: %s\", s})\n@@ -180,7 +181,7 @@ fn run_tests_console(opts: test_opts,\n \n     fn write_log(out: io::writer, result: test_result, test: test_desc) {\n         out.write_line(fmt!{\"%s %s\",\n-                    alt result {\n+                    match result {\n                         tr_ok => ~\"ok\",\n                         tr_failed => ~\"failed\",\n                         tr_ignored => ~\"ignored\"\n@@ -334,7 +335,7 @@ fn filter_tests(opts: test_opts,\n         filtered\n     } else {\n         let filter_str =\n-            alt opts.filter {\n+            match opts.filter {\n           option::some(f) => f,\n           option::none => ~\"\"\n         };\n@@ -479,7 +480,7 @@ mod tests {\n     #[test]\n     fn first_free_arg_should_be_a_filter() {\n         let args = ~[~\"progname\", ~\"filter\"];\n-        let opts = alt parse_opts(args) {\n+        let opts = match parse_opts(args) {\n           either::left(o) => o,\n           _ => fail ~\"Malformed arg in first_free_arg_should_be_a_filter\"\n         };\n@@ -489,7 +490,7 @@ mod tests {\n     #[test]\n     fn parse_ignored_flag() {\n         let args = ~[~\"progname\", ~\"filter\", ~\"--ignored\"];\n-        let opts = alt parse_opts(args) {\n+        let opts = match parse_opts(args) {\n           either::left(o) => o,\n           _ => fail ~\"Malformed arg in parse_ignored_flag\"\n         };"}, {"sha": "3a4b5f3ccd927d61d3db798951232d383970f525", "filename": "src/libstd/time.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -181,7 +181,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n             let {ch, next} = str::char_range_at(s, pos);\n             pos = next;\n \n-            alt ch {\n+            match ch {\n               '0' to '9' => {\n                 value = value * 10_i32 + (ch as i32 - '0' as i32);\n               }\n@@ -208,8 +208,8 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n \n     fn parse_type(s: ~str, pos: uint, ch: char, tm: tm_mut)\n       -> result<uint, ~str> {\n-        alt ch {\n-          'A' => alt match_strs(s, pos, ~[\n+        match ch {\n+          'A' => match match_strs(s, pos, ~[\n               (~\"Sunday\", 0_i32),\n               (~\"Monday\", 1_i32),\n               (~\"Tuesday\", 2_i32),\n@@ -221,7 +221,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n             some(item) => { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n             none => err(~\"Invalid day\")\n           }\n-          'a' => alt match_strs(s, pos, ~[\n+          'a' => match match_strs(s, pos, ~[\n               (~\"Sun\", 0_i32),\n               (~\"Mon\", 1_i32),\n               (~\"Tue\", 2_i32),\n@@ -233,7 +233,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n             some(item) => { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n             none => err(~\"Invalid day\")\n           }\n-          'B' => alt match_strs(s, pos, ~[\n+          'B' => match match_strs(s, pos, ~[\n               (~\"January\", 0_i32),\n               (~\"February\", 1_i32),\n               (~\"March\", 2_i32),\n@@ -250,7 +250,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n             some(item) => { let (v, pos) = item; tm.tm_mon = v; ok(pos) }\n             none => err(~\"Invalid month\")\n           }\n-          'b' | 'h' => alt match_strs(s, pos, ~[\n+          'b' | 'h' => match match_strs(s, pos, ~[\n               (~\"Jan\", 0_i32),\n               (~\"Feb\", 1_i32),\n               (~\"Mar\", 2_i32),\n@@ -267,7 +267,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n             some(item) => { let (v, pos) = item; tm.tm_mon = v; ok(pos) }\n             none => err(~\"Invalid month\")\n           }\n-          'C' => alt match_digits(s, pos, 2u, false) {\n+          'C' => match match_digits(s, pos, 2u, false) {\n             some(item) => {\n                 let (v, pos) = item;\n                   tm.tm_year += (v * 100_i32) - 1900_i32;\n@@ -293,11 +293,11 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n                 .chain(|pos| parse_char(s, pos, '/'))\n                 .chain(|pos| parse_type(s, pos, 'y', tm))\n           }\n-          'd' => alt match_digits(s, pos, 2u, false) {\n+          'd' => match match_digits(s, pos, 2u, false) {\n             some(item) => { let (v, pos) = item; tm.tm_mday = v; ok(pos) }\n             none => err(~\"Invalid day of the month\")\n           }\n-          'e' => alt match_digits(s, pos, 2u, true) {\n+          'e' => match match_digits(s, pos, 2u, true) {\n             some(item) => { let (v, pos) = item; tm.tm_mday = v; ok(pos) }\n             none => err(~\"Invalid day of the month\")\n           }\n@@ -310,14 +310,14 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n           }\n           'H' => {\n             // FIXME (#2350): range check.\n-            alt match_digits(s, pos, 2u, false) {\n+            match match_digits(s, pos, 2u, false) {\n               some(item) => { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n               none => err(~\"Invalid hour\")\n             }\n           }\n           'I' => {\n             // FIXME (#2350): range check.\n-            alt match_digits(s, pos, 2u, false) {\n+            match match_digits(s, pos, 2u, false) {\n               some(item) => {\n                   let (v, pos) = item;\n                   tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n@@ -328,7 +328,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n           }\n           'j' => {\n             // FIXME (#2350): range check.\n-            alt match_digits(s, pos, 3u, false) {\n+            match match_digits(s, pos, 3u, false) {\n               some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_yday = v - 1_i32;\n@@ -339,14 +339,14 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n           }\n           'k' => {\n             // FIXME (#2350): range check.\n-            alt match_digits(s, pos, 2u, true) {\n+            match match_digits(s, pos, 2u, true) {\n               some(item) => { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n               none => err(~\"Invalid hour\")\n             }\n           }\n           'l' => {\n             // FIXME (#2350): range check.\n-            alt match_digits(s, pos, 2u, true) {\n+            match match_digits(s, pos, 2u, true) {\n               some(item) => {\n                   let (v, pos) = item;\n                   tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n@@ -357,14 +357,14 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n           }\n           'M' => {\n             // FIXME (#2350): range check.\n-            alt match_digits(s, pos, 2u, false) {\n+            match match_digits(s, pos, 2u, false) {\n               some(item) => { let (v, pos) = item; tm.tm_min = v; ok(pos) }\n               none => err(~\"Invalid minute\")\n             }\n           }\n           'm' => {\n             // FIXME (#2350): range check.\n-            alt match_digits(s, pos, 2u, false) {\n+            match match_digits(s, pos, 2u, false) {\n               some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_mon = v - 1_i32;\n@@ -374,11 +374,15 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n             }\n           }\n           'n' => parse_char(s, pos, '\\n'),\n-          'P' => alt match_strs(s, pos, ~[(~\"am\", 0_i32), (~\"pm\", 12_i32)]) {\n+          'P' => match match_strs(s, pos,\n+                                  ~[(~\"am\", 0_i32), (~\"pm\", 12_i32)]) {\n+\n             some(item) => { let (v, pos) = item; tm.tm_hour += v; ok(pos) }\n             none => err(~\"Invalid hour\")\n           }\n-          'p' => alt match_strs(s, pos, ~[(~\"AM\", 0_i32), (~\"PM\", 12_i32)]) {\n+          'p' => match match_strs(s, pos,\n+                                  ~[(~\"AM\", 0_i32), (~\"PM\", 12_i32)]) {\n+\n             some(item) => { let (v, pos) = item; tm.tm_hour += v; ok(pos) }\n             none => err(~\"Invalid hour\")\n           }\n@@ -398,7 +402,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n           }\n           'S' => {\n             // FIXME (#2350): range check.\n-            alt match_digits(s, pos, 2u, false) {\n+            match match_digits(s, pos, 2u, false) {\n               some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_sec = v;\n@@ -418,7 +422,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n           't' => parse_char(s, pos, '\\t'),\n           'u' => {\n             // FIXME (#2350): range check.\n-            alt match_digits(s, pos, 1u, false) {\n+            match match_digits(s, pos, 1u, false) {\n               some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_wday = v;\n@@ -437,7 +441,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n           //'W' {}\n           'w' => {\n             // FIXME (#2350): range check.\n-            alt match_digits(s, pos, 1u, false) {\n+            match match_digits(s, pos, 1u, false) {\n               some(item) => { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n               none => err(~\"Invalid weekday\")\n             }\n@@ -446,7 +450,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n           //'x' {}\n           'Y' => {\n             // FIXME (#2350): range check.\n-            alt match_digits(s, pos, 4u, false) {\n+            match match_digits(s, pos, 4u, false) {\n               some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_year = v - 1900_i32;\n@@ -457,7 +461,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n           }\n           'y' => {\n             // FIXME (#2350): range check.\n-            alt match_digits(s, pos, 2u, false) {\n+            match match_digits(s, pos, 2u, false) {\n               some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_year = v - 1900_i32;\n@@ -489,7 +493,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n             let {ch, next} = str::char_range_at(s, pos);\n \n             if ch == '+' || ch == '-' {\n-                alt match_digits(s, next, 4u, false) {\n+                match match_digits(s, next, 4u, false) {\n                   some(item) => {\n                     let (v, pos) = item;\n                     if v == 0_i32 {\n@@ -534,8 +538,8 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n         while !rdr.eof() && pos < len {\n             let {ch, next} = str::char_range_at(s, pos);\n \n-            alt rdr.read_char() {\n-              '%' => alt parse_type(s, pos, rdr.read_char(), tm) {\n+            match rdr.read_char() {\n+              '%' => match parse_type(s, pos, rdr.read_char(), tm) {\n                 ok(next) => pos = next,\n                   err(e) => { result = err(e); break; }\n               }\n@@ -568,8 +572,8 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n fn strftime(format: ~str, tm: tm) -> ~str {\n     fn parse_type(ch: char, tm: tm) -> ~str {\n         //FIXME (#2350): Implement missing types.\n-        alt check ch {\n-          'A' => alt check tm.tm_wday as int {\n+        match check ch {\n+          'A' => match check tm.tm_wday as int {\n             0 => ~\"Sunday\",\n             1 => ~\"Monday\",\n             2 => ~\"Tuesday\",\n@@ -578,7 +582,7 @@ fn strftime(format: ~str, tm: tm) -> ~str {\n             5 => ~\"Friday\",\n             6 => ~\"Saturday\"\n           }\n-          'a' => alt check tm.tm_wday as int {\n+          'a' => match check tm.tm_wday as int {\n             0 => ~\"Sun\",\n             1 => ~\"Mon\",\n             2 => ~\"Tue\",\n@@ -587,7 +591,7 @@ fn strftime(format: ~str, tm: tm) -> ~str {\n             5 => ~\"Fri\",\n             6 => ~\"Sat\"\n           }\n-          'B' => alt check tm.tm_mon as int {\n+          'B' => match check tm.tm_mon as int {\n             0 => ~\"January\",\n             1 => ~\"February\",\n             2 => ~\"March\",\n@@ -601,7 +605,7 @@ fn strftime(format: ~str, tm: tm) -> ~str {\n             10 => ~\"November\",\n             11 => ~\"December\"\n           }\n-          'b' | 'h' => alt check tm.tm_mon as int {\n+          'b' | 'h' => match check tm.tm_mon as int {\n             0 => ~\"Jan\",\n             1 => ~\"Feb\",\n             2 => ~\"Mar\",\n@@ -716,7 +720,7 @@ fn strftime(format: ~str, tm: tm) -> ~str {\n \n     do io::with_str_reader(format) |rdr| {\n         while !rdr.eof() {\n-            alt rdr.read_char() {\n+            match rdr.read_char() {\n                 '%' => buf += parse_type(rdr.read_char(), tm),\n                 ch => str::push_char(buf, ch)\n             }\n@@ -932,7 +936,7 @@ mod tests {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n-        alt strptime(~\"\", ~\"\") {\n+        match strptime(~\"\", ~\"\") {\n           ok(tm) => {\n             assert tm.tm_sec == 0_i32;\n             assert tm.tm_min == 0_i32;\n@@ -954,7 +958,7 @@ mod tests {\n         assert strptime(~\"Fri Feb 13 15:31:30\", format)\n             == err(~\"Invalid time\");\n \n-        alt strptime(~\"Fri Feb 13 15:31:30 2009\", format) {\n+        match strptime(~\"Fri Feb 13 15:31:30 2009\", format) {\n           err(e) => fail e,\n           ok(tm) => {\n             assert tm.tm_sec == 30_i32;\n@@ -973,7 +977,7 @@ mod tests {\n         }\n \n         fn test(s: ~str, format: ~str) -> bool {\n-            alt strptime(s, format) {\n+            match strptime(s, format) {\n               ok(tm) => tm.strftime(format) == s,\n               err(e) => fail e\n             }"}, {"sha": "d19d7a1adccc473603b85bc93828e5d083054695", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -215,7 +215,7 @@ mod test {\n                 delayed_send(hl_loop, 1u, test_ch, expected);\n             };\n \n-            alt recv_timeout(hl_loop, 10u, test_po) {\n+            match recv_timeout(hl_loop, 10u, test_po) {\n               some(val) => {\n                 assert val == expected;\n                 successes += 1;\n@@ -243,7 +243,7 @@ mod test {\n                 delayed_send(hl_loop, 1000u, test_ch, expected);\n             };\n \n-            alt recv_timeout(hl_loop, 1u, test_po) {\n+            match recv_timeout(hl_loop, 1u, test_po) {\n               none => successes += 1,\n               _ => failures += 1\n             };"}, {"sha": "65dbadb4a53e0b53e04e1ce3fdcbf922998de6ea", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -30,7 +30,7 @@ fn treemap<K, V>() -> treemap<K, V> { @mut none }\n \n /// Insert a value into the map\n fn insert<K: copy, V: copy>(m: &mut tree_edge<K, V>, k: K, v: V) {\n-    alt copy *m {\n+    match copy *m {\n       none => {\n         *m = some(@tree_node({key: k,\n                               mut value: v,\n@@ -52,7 +52,7 @@ fn insert<K: copy, V: copy>(m: &mut tree_edge<K, V>, k: K, v: V) {\n \n /// Find a value based on the key\n fn find<K: copy, V: copy>(m: &const tree_edge<K, V>, k: K) -> option<V> {\n-    alt copy *m {\n+    match copy *m {\n       none => none,\n \n       // FIXME (#2808): was that an optimization?\n@@ -70,7 +70,7 @@ fn find<K: copy, V: copy>(m: &const tree_edge<K, V>, k: K) -> option<V> {\n \n /// Visit all pairs in the map in order.\n fn traverse<K, V: copy>(m: &const tree_edge<K, V>, f: fn(K, V)) {\n-    alt copy *m {\n+    match copy *m {\n       none => (),\n       some(node) => {\n         traverse(&const node.left, f);"}, {"sha": "b2ae1de6e4ac4efbd5c3e338a138bf16b15db3df", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -56,7 +56,7 @@ fn get_monitor_task_gl() -> iotask unsafe {\n             let hl_loop = spawn_loop();\n             loop {\n                 debug!{\"in outer_loop...\"};\n-                alt select2(weak_exit_po, msg_po) {\n+                match select2(weak_exit_po, msg_po) {\n                   left(weak_exit) => {\n                     // all normal tasks have ended, tell the\n                     // libuv loop to tear_down, then exit"}, {"sha": "80d1053570ea3e6b5b5cac0be97494e648cfd037", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -144,7 +144,7 @@ extern fn wake_up_cb(async_handle: *ll::uv_async_t,\n     let msg_po = (*data).msg_po;\n \n     while msg_po.peek() {\n-        alt msg_po.recv() {\n+        match msg_po.recv() {\n           interaction(cb) => cb(loop_ptr),\n           teardown_loop => begin_teardown(data)\n         }"}, {"sha": "26b95a9a37b93a48f53051a3c0253589b4be3841", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -848,7 +848,7 @@ unsafe fn ip6_name(src: &sockaddr_in6) -> ~str {\n                         src_unsafe_ptr, src});\n         let result = rustrt::rust_uv_ip6_name(src_unsafe_ptr,\n                                               dst_buf, size as libc::size_t);\n-        alt result {\n+        match result {\n           0i32 => str::unsafe::from_buf(dst_buf),\n           _ => ~\"\"\n         }"}, {"sha": "f10ec1423285aa36e804beb3fff4ab4f17d121fc", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -193,7 +193,7 @@ enum vstore {\n }\n \n pure fn is_blockish(p: ast::proto) -> bool {\n-    alt p {\n+    match p {\n       proto_block => true,\n       proto_bare | proto_uniq | proto_box => false\n     }"}, {"sha": "2c774abff579e8940469e57a54bcd1abf6da2fdb", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -12,7 +12,7 @@ type path = ~[path_elt];\n /* FIXMEs that say \"bad\" are as per #2543 */\n fn path_to_str_with_sep(p: path, sep: ~str) -> ~str {\n     let strs = do vec::map(p) |e| {\n-        alt e {\n+        match e {\n           path_mod(s) => /* FIXME (#2543) */ copy *s,\n           path_name(s) => /* FIXME (#2543) */ copy *s\n         }\n@@ -104,7 +104,7 @@ fn map_decoded_item(diag: span_handler,\n     // methods get added to the AST map when their impl is visited.  Since we\n     // don't decode and instantiate the impl, but just the method, we have to\n     // add it to the table now:\n-    alt ii {\n+    match ii {\n       ii_item(*) | ii_ctor(*) | ii_dtor(*) => { /* fallthrough */ }\n       ii_foreign(i) => {\n         cx.map.insert(i.id, node_foreign_item(i, foreign_abi_rust_intrinsic,\n@@ -127,7 +127,7 @@ fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n                           copy a, cx.local_id));\n         cx.local_id += 1u;\n     }\n-    alt fk {\n+    match fk {\n       visit::fk_ctor(nm, attrs, tps, self_id, parent_id) => {\n           let ct = @{node: {id: id,\n                             attrs: attrs,\n@@ -159,7 +159,7 @@ fn map_block(b: blk, cx: ctx, v: vt) {\n \n fn number_pat(cx: ctx, pat: @pat) {\n     do ast_util::walk_pat(pat) |p| {\n-        alt p.node {\n+        match p.node {\n           pat_ident(*) => {\n             cx.map.insert(p.id, node_local(cx.local_id));\n             cx.local_id += 1u;\n@@ -189,7 +189,7 @@ fn map_method(impl_did: def_id, impl_path: @path,\n fn map_item(i: @item, cx: ctx, v: vt) {\n     let item_path = @/* FIXME (#2543) */ copy cx.path;\n     cx.map.insert(i.id, node_item(i, item_path));\n-    alt i.node {\n+    match i.node {\n       item_impl(_, opt_ir, _, ms) => {\n         let impl_did = ast_util::local_def(i.id);\n         for ms.each |m| {\n@@ -205,7 +205,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n         }\n       }\n       item_foreign_mod(nm) => {\n-        let abi = alt attr::foreign_abi(i.attrs) {\n+        let abi = match attr::foreign_abi(i.attrs) {\n           either::left(msg) => cx.diag.span_fatal(i.span, msg),\n           either::right(abi) => abi\n         };\n@@ -248,7 +248,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n       }\n       _ => ()\n     }\n-    alt i.node {\n+    match i.node {\n       item_mod(_) | item_foreign_mod(_) => {\n         vec::push(cx.path, path_mod(i.ident));\n       }\n@@ -259,9 +259,9 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n }\n \n fn map_view_item(vi: @view_item, cx: ctx, _v: vt) {\n-    alt vi.node {\n+    match vi.node {\n       view_item_export(vps) => for vps.each |vp| {\n-        let (id, name) = alt vp.node {\n+        let (id, name) = match vp.node {\n           view_path_simple(nm, _, id) => {\n             (id, /* FIXME (#2543) */ copy nm)\n           }\n@@ -281,7 +281,7 @@ fn map_expr(ex: @expr, cx: ctx, v: vt) {\n }\n \n fn node_id_to_str(map: map, id: node_id) -> ~str {\n-    alt map.find(id) {\n+    match map.find(id) {\n       none => {\n         fmt!{\"unknown node (id=%d)\", id}\n       }"}, {"sha": "4f261afa3def5d974b20e7fe3dabef178b4b3734", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -35,15 +35,15 @@ pure fn local_def(id: node_id) -> def_id { {crate: local_crate, node: id} }\n pure fn is_local(did: ast::def_id) -> bool { did.crate == local_crate }\n \n pure fn stmt_id(s: stmt) -> node_id {\n-    alt s.node {\n+    match s.node {\n       stmt_decl(_, id) => id,\n       stmt_expr(_, id) => id,\n       stmt_semi(_, id) => id\n     }\n }\n \n fn variant_def_ids(d: def) -> {enm: def_id, var: def_id} {\n-    alt d {\n+    match d {\n       def_variant(enum_id, var_id) => {\n         return {enm: enum_id, var: var_id}\n       }\n@@ -52,7 +52,7 @@ fn variant_def_ids(d: def) -> {enm: def_id, var: def_id} {\n }\n \n pure fn def_id_of_def(d: def) -> def_id {\n-    alt d {\n+    match d {\n       def_fn(id, _) | def_mod(id) |\n       def_foreign_mod(id) | def_const(id) |\n       def_variant(_, id) | def_ty(id) | def_ty_param(id, _) |\n@@ -70,7 +70,7 @@ pure fn def_id_of_def(d: def) -> def_id {\n }\n \n pure fn binop_to_str(op: binop) -> ~str {\n-    alt op {\n+    match op {\n       add => return ~\"+\",\n       subtract => return ~\"-\",\n       mul => return ~\"*\",\n@@ -93,7 +93,7 @@ pure fn binop_to_str(op: binop) -> ~str {\n }\n \n pure fn binop_to_method_name(op: binop) -> option<~str> {\n-    alt op {\n+    match op {\n       add => return some(~\"add\"),\n       subtract => return some(~\"sub\"),\n       mul => return some(~\"mul\"),\n@@ -109,23 +109,23 @@ pure fn binop_to_method_name(op: binop) -> option<~str> {\n }\n \n pure fn lazy_binop(b: binop) -> bool {\n-    alt b {\n+    match b {\n       and => true,\n       or => true,\n       _ => false\n     }\n }\n \n pure fn is_shift_binop(b: binop) -> bool {\n-    alt b {\n+    match b {\n       shl => true,\n       shr => true,\n       _ => false\n     }\n }\n \n pure fn unop_to_str(op: unop) -> ~str {\n-    alt op {\n+    match op {\n       box(mt) => if mt == m_mutbl { ~\"@mut \" } else { ~\"@\" },\n       uniq(mt) => if mt == m_mutbl { ~\"~mut \" } else { ~\"~\" },\n       deref => ~\"*\",\n@@ -135,11 +135,11 @@ pure fn unop_to_str(op: unop) -> ~str {\n }\n \n pure fn is_path(e: @expr) -> bool {\n-    return alt e.node { expr_path(_) => true, _ => false };\n+    return match e.node { expr_path(_) => true, _ => false };\n }\n \n pure fn int_ty_to_str(t: int_ty) -> ~str {\n-    alt t {\n+    match t {\n       ty_char => ~\"u8\", // ???\n       ty_i => ~\"\",\n       ty_i8 => ~\"i8\",\n@@ -150,7 +150,7 @@ pure fn int_ty_to_str(t: int_ty) -> ~str {\n }\n \n pure fn int_ty_max(t: int_ty) -> u64 {\n-    alt t {\n+    match t {\n       ty_i8 => 0x80u64,\n       ty_i16 => 0x8000u64,\n       ty_i | ty_char | ty_i32 => 0x80000000u64, // actually ni about ty_i\n@@ -159,7 +159,7 @@ pure fn int_ty_max(t: int_ty) -> u64 {\n }\n \n pure fn uint_ty_to_str(t: uint_ty) -> ~str {\n-    alt t {\n+    match t {\n       ty_u => ~\"u\",\n       ty_u8 => ~\"u8\",\n       ty_u16 => ~\"u16\",\n@@ -169,7 +169,7 @@ pure fn uint_ty_to_str(t: uint_ty) -> ~str {\n }\n \n pure fn uint_ty_max(t: uint_ty) -> u64 {\n-    alt t {\n+    match t {\n       ty_u8 => 0xffu64,\n       ty_u16 => 0xffffu64,\n       ty_u | ty_u32 => 0xffffffffu64, // actually ni about ty_u\n@@ -178,15 +178,15 @@ pure fn uint_ty_max(t: uint_ty) -> u64 {\n }\n \n pure fn float_ty_to_str(t: float_ty) -> ~str {\n-    alt t { ty_f => ~\"f\", ty_f32 => ~\"f32\", ty_f64 => ~\"f64\" }\n+    match t { ty_f => ~\"f\", ty_f32 => ~\"f32\", ty_f64 => ~\"f64\" }\n }\n \n fn is_exported(i: ident, m: _mod) -> bool {\n     let mut local = false;\n     let mut parent_enum : option<ident> = none;\n     for m.items.each |it| {\n         if it.ident == i { local = true; }\n-        alt it.node {\n+        match it.node {\n           item_enum(variants, _) => for variants.each |v| {\n             if v.node.name == i {\n                 local = true;\n@@ -199,14 +199,14 @@ fn is_exported(i: ident, m: _mod) -> bool {\n     }\n     let mut has_explicit_exports = false;\n     for m.view_items.each |vi| {\n-        alt vi.node {\n+        match vi.node {\n           view_item_export(vps) => {\n             has_explicit_exports = true;\n             for vps.each |vp| {\n-                alt vp.node {\n+                match vp.node {\n                   ast::view_path_simple(id, _, _) => {\n                     if id == i { return true; }\n-                    alt parent_enum {\n+                    match parent_enum {\n                       some(parent_enum_id) => {\n                         if id == parent_enum_id { return true; }\n                       }\n@@ -240,7 +240,7 @@ fn is_exported(i: ident, m: _mod) -> bool {\n }\n \n pure fn is_call_expr(e: @expr) -> bool {\n-    alt e.node { expr_call(_, _, _) => true, _ => false }\n+    match e.node { expr_call(_, _, _) => true, _ => false }\n }\n \n pure fn eq_ty(a: &@ty, b: &@ty) -> bool { box::ptr_eq(*a, *b) }\n@@ -284,7 +284,7 @@ fn ident_to_path(s: span, +i: ident) -> @path {\n }\n \n pure fn is_unguarded(&&a: arm) -> bool {\n-    alt a.guard {\n+    match a.guard {\n       none => true,\n       _    => false\n     }\n@@ -295,7 +295,7 @@ pure fn unguarded_pat(a: arm) -> option<~[@pat]> {\n }\n \n pure fn class_item_ident(ci: @class_member) -> ident {\n-    alt ci.node {\n+    match ci.node {\n       instance_var(i,_,_,_,_) => /* FIXME (#2543) */ copy i,\n       class_method(it) => /* FIXME (#2543) */ copy it.ident\n     }\n@@ -306,7 +306,7 @@ type ivar = {ident: ident, ty: @ty, cm: class_mutability,\n \n fn public_methods(ms: ~[@method]) -> ~[@method] {\n     vec::filter(ms,\n-                |m| alt m.vis {\n+                |m| match m.vis {\n                     public => true,\n                     _   => false\n                 })\n@@ -315,7 +315,7 @@ fn public_methods(ms: ~[@method]) -> ~[@method] {\n fn split_class_items(cs: ~[@class_member]) -> (~[ivar], ~[@method]) {\n     let mut vs = ~[], ms = ~[];\n     for cs.each |c| {\n-      alt c.node {\n+      match c.node {\n         instance_var(i, t, cm, id, vis) => {\n           vec::push(vs, {ident: /* FIXME (#2543) */ copy i,\n                          ty: t,\n@@ -332,7 +332,7 @@ fn split_class_items(cs: ~[@class_member]) -> (~[ivar], ~[@method]) {\n // extract a ty_method from a trait_method. if the trait_method is\n // a default, pull out the useful fields to make a ty_method\n fn trait_method_to_ty_method(method: trait_method) -> ty_method {\n-    alt method {\n+    match method {\n       required(m) => m,\n       provided(m) => {\n         {ident: m.ident, attrs: m.attrs,\n@@ -346,7 +346,7 @@ fn split_trait_methods(trait_methods: ~[trait_method])\n     -> (~[ty_method], ~[@method]) {\n     let mut reqd = ~[], provd = ~[];\n     for trait_methods.each |trt_method| {\n-        alt trt_method {\n+        match trt_method {\n           required(tm) => vec::push(reqd, tm),\n           provided(m) => vec::push(provd, m)\n         }\n@@ -355,7 +355,7 @@ fn split_trait_methods(trait_methods: ~[trait_method])\n }\n \n pure fn class_member_visibility(ci: @class_member) -> visibility {\n-  alt ci.node {\n+  match ci.node {\n      instance_var(_, _, _, _, vis) => vis,\n      class_method(m) => m.vis\n   }\n@@ -369,7 +369,7 @@ trait inlined_item_utils {\n \n impl inlined_item_methods of inlined_item_utils for inlined_item {\n     fn ident() -> ident {\n-        alt self {\n+        match self {\n           ii_item(i) => /* FIXME (#2543) */ copy i.ident,\n           ii_foreign(i) => /* FIXME (#2543) */ copy i.ident,\n           ii_method(_, m) => /* FIXME (#2543) */ copy m.ident,\n@@ -379,7 +379,7 @@ impl inlined_item_methods of inlined_item_utils for inlined_item {\n     }\n \n     fn id() -> ast::node_id {\n-        alt self {\n+        match self {\n           ii_item(i) => i.id,\n           ii_foreign(i) => i.id,\n           ii_method(_, m) => m.id,\n@@ -389,7 +389,7 @@ impl inlined_item_methods of inlined_item_utils for inlined_item {\n     }\n \n     fn accept<E>(e: E, v: visit::vt<E>) {\n-        alt self {\n+        match self {\n           ii_item(i) => v.visit_item(i, e, v),\n           ii_foreign(i) => v.visit_foreign_item(i, e, v),\n           ii_method(_, m) => visit::visit_method_helper(m, e, v),\n@@ -406,7 +406,7 @@ impl inlined_item_methods of inlined_item_utils for inlined_item {\n /* True if d is either a def_self, or a chain of def_upvars\n  referring to a def_self */\n fn is_self(d: ast::def) -> bool {\n-  alt d {\n+  match d {\n     def_self(_)        => true,\n     def_upvar(_, d, _) => is_self(*d),\n     _                  => false\n@@ -415,7 +415,7 @@ fn is_self(d: ast::def) -> bool {\n \n /// Maps a binary operator to its precedence\n fn operator_prec(op: ast::binop) -> uint {\n-  alt op {\n+  match op {\n       mul | div | rem   => 12u,\n       // 'as' sits between here with 11\n       add | subtract    => 10u,\n@@ -455,11 +455,11 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n         },\n \n         visit_view_item: fn@(vi: @view_item) {\n-            alt vi.node {\n+            match vi.node {\n               view_item_use(_, _, id) => vfn(id),\n               view_item_import(vps) | view_item_export(vps) => {\n                 do vec::iter(vps) |vp| {\n-                    alt vp.node {\n+                    match vp.node {\n                       view_path_simple(_, _, id) => vfn(id),\n                       view_path_glob(_, id) => vfn(id),\n                       view_path_list(_, _, id) => vfn(id)\n@@ -475,7 +475,7 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n \n         visit_item: fn@(i: @item) {\n             vfn(i.id);\n-            alt i.node {\n+            match i.node {\n               item_enum(vs, _) => for vs.each |v| { vfn(v.node.id); }\n               _ => ()\n             }\n@@ -511,7 +511,7 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n         },\n \n         visit_ty: fn@(t: @ty) {\n-            alt t.node {\n+            match t.node {\n               ty_path(_, id) => vfn(id),\n               _ => { /* fall through */ }\n             }\n@@ -525,7 +525,7 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n                       _b: ast::blk, _sp: span, id: ast::node_id) {\n             vfn(id);\n \n-            alt fk {\n+            match fk {\n               visit::fk_ctor(nm, _, tps, self_id, parent_id) => {\n                 vec::iter(tps, |tp| vfn(tp.id));\n                 vfn(id);\n@@ -565,7 +565,7 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n         },\n \n         visit_class_item: fn@(c: @class_member) {\n-            alt c.node {\n+            match c.node {\n               instance_var(_, _, _, id,_) => vfn(id),\n               class_method(_) => ()\n             }\n@@ -592,15 +592,15 @@ fn compute_id_range_for_inlined_item(item: inlined_item) -> id_range {\n }\n \n pure fn is_item_impl(item: @ast::item) -> bool {\n-    alt item.node {\n+    match item.node {\n        item_impl(*) => true,\n        _            => false\n     }\n }\n \n fn walk_pat(pat: @pat, it: fn(@pat)) {\n     it(pat);\n-    alt pat.node {\n+    match pat.node {\n       pat_ident(_, pth, some(p)) => walk_pat(p, it),\n       pat_rec(fields, _) => for fields.each |f| { walk_pat(f.pat, it) }\n       pat_enum(_, some(s)) | pat_tup(s) => for s.each |p| {\n@@ -613,7 +613,7 @@ fn walk_pat(pat: @pat, it: fn(@pat)) {\n }\n \n fn view_path_id(p: @view_path) -> node_id {\n-    alt p.node {\n+    match p.node {\n       view_path_simple(_, _, id) | view_path_glob(_, id) |\n       view_path_list(_, _, id) => id\n     }"}, {"sha": "0838a1a70d9ec285a6f94170b5857a000561385c", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -114,7 +114,7 @@ fn get_attr_name(attr: ast::attribute) -> ast::ident {\n \n // All \"bad\" FIXME copies are as per #2543\n fn get_meta_item_name(meta: @ast::meta_item) -> ast::ident {\n-    alt meta.node {\n+    match meta.node {\n       ast::meta_word(n) => /* FIXME (#2543) */ copy n,\n       ast::meta_name_value(n, _) => /* FIXME (#2543) */ copy n,\n       ast::meta_list(n, _) => /* FIXME (#2543) */ copy n\n@@ -126,8 +126,8 @@ fn get_meta_item_name(meta: @ast::meta_item) -> ast::ident {\n  * containing a string, otherwise none\n  */\n fn get_meta_item_value_str(meta: @ast::meta_item) -> option<@~str> {\n-    alt meta.node {\n-      ast::meta_name_value(_, v) => alt v.node {\n+    match meta.node {\n+      ast::meta_name_value(_, v) => match v.node {\n         ast::lit_str(s) => option::some(s),\n         _ => option::none\n       }\n@@ -137,7 +137,7 @@ fn get_meta_item_value_str(meta: @ast::meta_item) -> option<@~str> {\n \n /// Gets a list of inner meta items from a list meta_item type\n fn get_meta_item_list(meta: @ast::meta_item) -> option<~[@ast::meta_item]> {\n-    alt meta.node {\n+    match meta.node {\n       ast::meta_list(_, l) => option::some(/* FIXME (#2543) */ copy l),\n       _ => option::none\n     }\n@@ -150,7 +150,7 @@ fn get_meta_item_list(meta: @ast::meta_item) -> option<~[@ast::meta_item]> {\n fn get_name_value_str_pair(\n     item: @ast::meta_item\n ) -> option<(ast::ident, @~str)> {\n-    alt attr::get_meta_item_value_str(item) {\n+    match attr::get_meta_item_value_str(item) {\n       some(value) => {\n         let name = attr::get_meta_item_name(item);\n         some((name, value))\n@@ -203,12 +203,12 @@ fn contains(haystack: ~[@ast::meta_item], needle: @ast::meta_item) -> bool {\n }\n \n fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n-    return alt a.node {\n-          ast::meta_word(na) => alt b.node {\n+    return match a.node {\n+          ast::meta_word(na) => match b.node {\n             ast::meta_word(nb) => na == nb,\n             _ => false\n           }\n-          ast::meta_name_value(na, va) => alt b.node {\n+          ast::meta_name_value(na, va) => match b.node {\n             ast::meta_name_value(nb, vb) => na == nb && va.node == vb.node,\n             _ => false\n           }\n@@ -253,8 +253,8 @@ fn last_meta_item_value_str_by_name(\n     items: ~[@ast::meta_item],\n     +name: ~str\n ) -> option<@~str> {\n-    alt last_meta_item_by_name(items, name) {\n-      some(item) => alt attr::get_meta_item_value_str(item) {\n+    match last_meta_item_by_name(items, name) {\n+      some(item) => match attr::get_meta_item_value_str(item) {\n         some(value) => some(value),\n         none => none\n       }\n@@ -266,7 +266,7 @@ fn last_meta_item_list_by_name(\n     items: ~[@ast::meta_item],\n     +name: ~str\n ) -> option<~[@ast::meta_item]> {\n-    alt last_meta_item_by_name(items, name) {\n+    match last_meta_item_by_name(items, name) {\n       some(item) => attr::get_meta_item_list(item),\n       none => none\n     }\n@@ -280,7 +280,7 @@ fn last_meta_item_list_by_name(\n fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n     pure fn lteq(ma: &@ast::meta_item, mb: &@ast::meta_item) -> bool {\n         pure fn key(m: &ast::meta_item) -> ast::ident {\n-            alt m.node {\n+            match m.node {\n               ast::meta_word(name) => /* FIXME (#2543) */ copy name,\n               ast::meta_name_value(name, _) => /* FIXME (#2543) */ copy name,\n               ast::meta_list(name, _) => /* FIXME (#2543) */ copy name\n@@ -310,7 +310,7 @@ fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ast::ident) ->\n fn find_linkage_attrs(attrs: ~[ast::attribute]) -> ~[ast::attribute] {\n     let mut found = ~[];\n     for find_attrs_by_name(attrs, ~\"link\").each |attr| {\n-        alt attr.node.value.node {\n+        match attr.node.value.node {\n           ast::meta_list(_, _) => vec::push(found, attr),\n           _ => debug!{\"ignoring link attribute that has incorrect type\"}\n         }\n@@ -324,14 +324,14 @@ fn find_linkage_attrs(attrs: ~[ast::attribute]) -> ~[ast::attribute] {\n  */\n fn find_linkage_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n     do find_linkage_attrs(attrs).flat_map |attr| {\n-        alt check attr.node.value.node {\n+        match check attr.node.value.node {\n           ast::meta_list(_, items) => /* FIXME (#2543) */ copy items\n         }\n     }\n }\n \n fn foreign_abi(attrs: ~[ast::attribute]) -> either<~str, ast::foreign_abi> {\n-    return alt attr::first_attr_value_str_by_name(attrs, ~\"abi\") {\n+    return match attr::first_attr_value_str_by_name(attrs, ~\"abi\") {\n       option::none => {\n         either::right(ast::foreign_abi_cdecl)\n       }\n@@ -361,7 +361,7 @@ enum inline_attr {\n fn find_inline_attr(attrs: ~[ast::attribute]) -> inline_attr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline(always)]\n     do vec::foldl(ia_none, attrs) |ia,attr| {\n-        alt attr.node.value.node {\n+        match attr.node.value.node {\n           ast::meta_word(@~\"inline\") => ia_hint,\n           ast::meta_list(@~\"inline\", items) => {\n             if !vec::is_empty(find_meta_items_by_name(items, ~\"always\")) {"}, {"sha": "e725eaaa724657168eb53731834c89318e75147c", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -124,7 +124,7 @@ fn lookup_char_pos_adj(map: codemap, pos: uint)\n     -> {filename: ~str, line: uint, col: uint, file: option<filemap>}\n {\n     let loc = lookup_char_pos(map, pos);\n-    alt (loc.file.substr) {\n+    match (loc.file.substr) {\n       fss_none => {\n         {filename: /* FIXME (#2543) */ copy loc.file.name,\n          line: loc.line,\n@@ -146,7 +146,7 @@ fn lookup_char_pos_adj(map: codemap, pos: uint)\n fn adjust_span(map: codemap, sp: span) -> span {\n     pure fn lookup(pos: file_pos) -> uint { return pos.ch; }\n     let line = lookup_line(map, sp.lo, lookup);\n-    alt (line.fm.substr) {\n+    match (line.fm.substr) {\n       fss_none => sp,\n       fss_internal(s) => {\n         adjust_span(map, {lo: s.lo + (sp.lo - line.fm.start_pos.ch),\n@@ -196,7 +196,7 @@ fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n \n fn get_line(fm: filemap, line: int) -> ~str unsafe {\n     let begin: uint = fm.lines[line].byte - fm.start_pos.byte;\n-    let end = alt str::find_char_from(*fm.src, '\\n', begin) {\n+    let end = match str::find_char_from(*fm.src, '\\n', begin) {\n       some(e) => e,\n       none => str::len(*fm.src)\n     };"}, {"sha": "bd5b37ab6982687c8ffa71e757a38ed412c0d923", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -87,7 +87,7 @@ impl codemap_handler of handler for handler_t {\n     fn has_errors() -> bool { self.err_count > 0u }\n     fn abort_if_errors() {\n         let s;\n-        alt self.err_count {\n+        match self.err_count {\n           0u => return,\n           1u => s = ~\"aborting due to previous error\",\n           _  => {\n@@ -122,7 +122,7 @@ fn mk_span_handler(handler: handler, cm: codemap::codemap) -> span_handler {\n \n fn mk_handler(emitter: option<emitter>) -> handler {\n \n-    let emit = alt emitter {\n+    let emit = match emitter {\n       some(e) => e,\n       none => {\n         let f = fn@(cmsp: option<(codemap::codemap, span)>,\n@@ -147,7 +147,7 @@ enum level {\n }\n \n fn diagnosticstr(lvl: level) -> ~str {\n-    alt lvl {\n+    match lvl {\n       fatal => ~\"error\",\n       error => ~\"error\",\n       warning => ~\"warning\",\n@@ -156,7 +156,7 @@ fn diagnosticstr(lvl: level) -> ~str {\n }\n \n fn diagnosticcolor(lvl: level) -> u8 {\n-    alt lvl {\n+    match lvl {\n       fatal => term::color_bright_red,\n       error => term::color_bright_red,\n       warning => term::color_bright_yellow,\n@@ -182,7 +182,7 @@ fn print_diagnostic(topic: ~str, lvl: level, msg: ~str) {\n \n fn emit(cmsp: option<(codemap::codemap, span)>,\n         msg: ~str, lvl: level) {\n-    alt cmsp {\n+    match cmsp {\n       some((cm, sp)) => {\n         let sp = codemap::adjust_span(cm,sp);\n         let ss = codemap::span_to_str(sp, cm);\n@@ -266,7 +266,7 @@ fn print_macro_backtrace(cm: codemap::codemap, sp: span) {\n \n fn expect<T: copy>(diag: span_handler,\n                    opt: option<T>, msg: fn() -> ~str) -> T {\n-    alt opt {\n+    match opt {\n        some(t) => t,\n        none => diag.handler().bug(msg())\n     }"}, {"sha": "c87ea71fc47d6349675acc428413fe1d51efcc9a", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -101,7 +101,7 @@ fn expand(cx: ext_ctxt,\n     }\n \n     do vec::flat_map(in_items) |in_item| {\n-        alt in_item.node {\n+        match in_item.node {\n           ast::item_ty(ty, tps) => {\n             vec::append(~[filter_attrs(in_item)],\n                         ty_fns(cx, in_item.ident, ty, tps))\n@@ -375,7 +375,7 @@ fn ser_lambda(cx: ext_ctxt, tps: ser_tps_map, ty: @ast::ty,\n }\n \n fn is_vec_or_str(ty: @ast::ty) -> bool {\n-    alt ty.node {\n+    match ty.node {\n       ast::ty_vec(_) => true,\n       // This may be wrong if the user has shadowed (!) str\n       ast::ty_path(@{span: _, global: _, idents: ids,\n@@ -391,7 +391,7 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n \n     let ext_cx = cx; // required for #ast{}\n \n-    alt ty.node {\n+    match ty.node {\n       ast::ty_nil => {\n         ~[#ast[stmt]{$(s).emit_nil()}]\n       }\n@@ -447,7 +447,7 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n       ast::ty_tup(tys) => {\n         // Generate code like\n         //\n-        // alt v {\n+        // match v {\n         //    (v1, v2, v3) {\n         //       .. serialize v1, v2, v3 ..\n         //    }\n@@ -483,7 +483,7 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n             vec::is_empty(path.types) {\n             let ident = path.idents[0];\n \n-            alt tps.find(*ident) {\n+            match tps.find(*ident) {\n               some(f) => f(v),\n               none => ser_path(cx, tps, path, s, v)\n             }\n@@ -634,7 +634,7 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n \n     let ext_cx = cx; // required for #ast{}\n \n-    alt ty.node {\n+    match ty.node {\n       ast::ty_nil => {\n         #ast{ $(d).read_nil() }\n       }\n@@ -709,7 +709,7 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n             vec::is_empty(path.types) {\n             let ident = path.idents[0];\n \n-            alt tps.find(*ident) {\n+            match tps.find(*ident) {\n               some(f) => f(),\n               none => deser_path(cx, tps, path, d)\n             }"}, {"sha": "f2e1855c0f5b208e99f3bc8cc7810f6106e7e533", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -150,7 +150,7 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n         fn mod_pop() { vec::pop(self.mod_path); }\n         fn mod_path() -> ~[ast::ident] { return self.mod_path; }\n         fn bt_push(ei: codemap::expn_info_) {\n-            alt ei {\n+            match ei {\n               expanded_from({call_site: cs, callie: callie}) => {\n                 self.backtrace =\n                     some(@expanded_from({\n@@ -161,7 +161,7 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n             }\n         }\n         fn bt_pop() {\n-            alt self.backtrace {\n+            match self.backtrace {\n               some(@expanded_from({call_site: {expn_info: prev, _}, _})) => {\n                 self.backtrace = prev\n               }\n@@ -206,8 +206,8 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n }\n \n fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, error: ~str) -> ~str {\n-    alt expr.node {\n-      ast::expr_lit(l) => alt l.node {\n+    match expr.node {\n+      ast::expr_lit(l) => match l.node {\n         ast::lit_str(s) => return *s,\n         _ => cx.span_fatal(l.span, error)\n       }\n@@ -216,7 +216,7 @@ fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, error: ~str) -> ~str {\n }\n \n fn expr_to_ident(cx: ext_ctxt, expr: @ast::expr, error: ~str) -> ast::ident {\n-    alt expr.node {\n+    match expr.node {\n       ast::expr_path(p) => {\n         if vec::len(p.types) > 0u || vec::len(p.idents) != 1u {\n             cx.span_fatal(expr.span, error);\n@@ -233,11 +233,11 @@ fn get_mac_args_no_max(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n \n fn get_mac_args(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                 min: uint, max: option<uint>, name: ~str) -> ~[@ast::expr] {\n-    alt arg {\n-      some(expr) => alt expr.node {\n+    match arg {\n+      some(expr) => match expr.node {\n         ast::expr_vec(elts, _) => {\n             let elts_len = vec::len(elts);\n-              alt max {\n+              match max {\n                 some(max) if ! (min <= elts_len && elts_len <= max) => {\n                   cx.span_fatal(sp,\n                                 fmt!{\"#%s takes between %u and %u arguments.\",\n@@ -261,7 +261,7 @@ fn get_mac_args(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n fn get_mac_body(cx: ext_ctxt, sp: span, args: ast::mac_body)\n     -> ast::mac_body_\n {\n-    alt (args) {\n+    match (args) {\n       some(body) => body,\n       none => cx.span_fatal(sp, ~\"missing macro body\")\n     }\n@@ -289,10 +289,10 @@ fn tt_args_to_original_flavor(cx: ext_ctxt, sp: span, arg: ~[ast::token_tree])\n     let arg_reader = new_tt_reader(cx.parse_sess().span_diagnostic,\n                                    cx.parse_sess().interner, none, arg);\n     let args =\n-        alt parse_or_else(cx.parse_sess(), cx.cfg(), arg_reader as reader,\n+        match parse_or_else(cx.parse_sess(), cx.cfg(), arg_reader as reader,\n                           argument_gram).get(@~\"arg\") {\n           @matched_seq(s, _) => do s.map() |lf| {\n-            alt lf {\n+            match lf {\n               @matched_nonterminal(parse::token::nt_expr(arg)) => {\n                 arg /* whew! list of exprs, here we come! */\n               }"}, {"sha": "01030591da955f3f9fe10cb143d68f9bfc779d9d", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -16,7 +16,7 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n     // option<str> rather than just an maybe-empty string.\n \n     let var = expr_to_str(cx, args[0], ~\"#env requires a string\");\n-    alt os::getenv(var) {\n+    match os::getenv(var) {\n       option::none => return mk_uniq_str(cx, sp, ~\"\"),\n       option::some(s) => return mk_uniq_str(cx, sp, s)\n     }"}, {"sha": "9b50101683a7610eafdfc909725cefebebbb34a7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -15,18 +15,18 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n                orig: fn@(expr_, span, ast_fold) -> (expr_, span))\n     -> (expr_, span)\n {\n-    return alt e {\n+    return match e {\n       // expr_mac should really be expr_ext or something; it's the\n       // entry-point for all syntax extensions.\n           expr_mac(mac) => {\n \n             // Old-style macros, for compatibility, will erase this whole\n             // block once we've transitioned.\n-            alt mac.node {\n+            match mac.node {\n               mac_invoc(pth, args, body) => {\n                 assert (vec::len(pth.idents) > 0u);\n                 let extname = pth.idents[0];\n-                alt exts.find(*extname) {\n+                match exts.find(*extname) {\n                   none => {\n                     cx.span_fatal(pth.span,\n                                   fmt!{\"macro undefined: '%s'\", *extname})\n@@ -69,13 +69,13 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n               mac_invoc_tt(pth, tts) => {\n                 assert (vec::len(pth.idents) == 1u);\n                 let extname = pth.idents[0];\n-                alt exts.find(*extname) {\n+                match exts.find(*extname) {\n                   none => {\n                     cx.span_fatal(pth.span,\n                                   fmt!{\"macro undefined: '%s'\", *extname})\n                   }\n                   some(expr_tt({expander: exp, span: exp_sp})) => {\n-                    let expanded = alt exp(cx, mac.span, tts) {\n+                    let expanded = match exp(cx, mac.span, tts) {\n                       mr_expr(e) => e,\n                       _ => cx.span_fatal(\n                           pth.span, fmt!{\"non-expr macro in expr pos: %s\",\n@@ -141,12 +141,12 @@ fn expand_mod_items(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n     // the item into a new set of items.\n     let new_items = do vec::flat_map(module_.items) |item| {\n         do vec::foldr(item.attrs, ~[item]) |attr, items| {\n-            let mname = alt attr.node.value.node {\n+            let mname = match attr.node.value.node {\n               ast::meta_word(n) => n,\n               ast::meta_name_value(n, _) => n,\n               ast::meta_list(n, _) => n\n             };\n-            alt exts.find(*mname) {\n+            match exts.find(*mname) {\n               none | some(normal(_)) | some(macro_defining(_))\n               | some(expr_tt(_)) | some(item_tt(*)) => items,\n               some(item_decorator(dec_fn)) => {\n@@ -166,16 +166,16 @@ fn expand_item(exts: hashmap<~str, syntax_extension>,\n                orig: fn@(&&@ast::item, ast_fold) -> option<@ast::item>)\n     -> option<@ast::item>\n {\n-    let is_mod = alt it.node {\n+    let is_mod = match it.node {\n       ast::item_mod(_) | ast::item_foreign_mod(_) => true,\n       _ => false\n     };\n-    let maybe_it = alt it.node {\n+    let maybe_it = match it.node {\n       ast::item_mac(*) => expand_item_mac(exts, cx, it, fld),\n       _ => some(it)\n     };\n \n-    alt maybe_it {\n+    match maybe_it {\n       some(it) => {\n         if is_mod { cx.mod_push(it.ident); }\n         let ret_val = orig(it, fld);\n@@ -192,10 +192,10 @@ fn expand_item(exts: hashmap<~str, syntax_extension>,\n fn expand_item_mac(exts: hashmap<~str, syntax_extension>,\n                    cx: ext_ctxt, &&it: @ast::item,\n                    fld: ast_fold) -> option<@ast::item> {\n-    alt it.node {\n+    match it.node {\n       item_mac({node: mac_invoc_tt(pth, tts), span}) => {\n         let extname = pth.idents[0];\n-        alt exts.find(*extname) {\n+        match exts.find(*extname) {\n           none => {\n             cx.span_fatal(pth.span,\n                           fmt!{\"macro undefined: '%s'\", *extname})\n@@ -205,7 +205,7 @@ fn expand_item_mac(exts: hashmap<~str, syntax_extension>,\n             cx.bt_push(expanded_from({call_site: it.span,\n                                       callie: {name: *extname,\n                                                span: expand.span}}));\n-            let maybe_it = alt expanded {\n+            let maybe_it = match expanded {\n               mr_item(it) => fld.fold_item(it),\n               mr_expr(e) => cx.span_fatal(pth.span,\n                                          ~\"expr macro in item position: \" +"}, {"sha": "19b5fefc1cf0847a165f7abb193db108c9f27561", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -52,7 +52,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n         fn make_flags(cx: ext_ctxt, sp: span, flags: ~[flag]) -> @ast::expr {\n             let mut tmp_expr = make_rt_path_expr(cx, sp, @~\"flag_none\");\n             for flags.each |f| {\n-                let fstr = alt f {\n+                let fstr = match f {\n                   flag_left_justify => ~\"flag_left_justify\",\n                   flag_left_zero_pad => ~\"flag_left_zero_pad\",\n                   flag_space_for_sign => ~\"flag_space_for_sign\",\n@@ -65,7 +65,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n             return tmp_expr;\n         }\n         fn make_count(cx: ext_ctxt, sp: span, cnt: count) -> @ast::expr {\n-            alt cnt {\n+            match cnt {\n               count_implied => {\n                 return make_rt_path_expr(cx, sp, @~\"count_implied\");\n               }\n@@ -80,8 +80,8 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n         }\n         fn make_ty(cx: ext_ctxt, sp: span, t: ty) -> @ast::expr {\n             let mut rt_type;\n-            alt t {\n-              ty_hex(c) => alt c {\n+            match t {\n+              ty_hex(c) => match c {\n                 case_upper => rt_type = ~\"ty_hex_upper\",\n                 case_lower => rt_type = ~\"ty_hex_lower\"\n               }\n@@ -121,8 +121,8 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n         // FIXME: Move validation code into core::extfmt (Issue #2249)\n \n         fn is_signed_type(cnv: conv) -> bool {\n-            alt cnv.ty {\n-              ty_int(s) => alt s {\n+            match cnv.ty {\n+              ty_int(s) => match s {\n                 signed => return true,\n                 unsigned => return false\n               }\n@@ -131,12 +131,12 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n             }\n         }\n         let unsupported = ~\"conversion not supported in #fmt string\";\n-        alt cnv.param {\n+        match cnv.param {\n           option::none => (),\n           _ => cx.span_unimpl(sp, unsupported)\n         }\n         for cnv.flags.each |f| {\n-            alt f {\n+            match f {\n               flag_left_justify => (),\n               flag_sign_always => {\n                 if !is_signed_type(cnv) {\n@@ -156,19 +156,19 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n               _ => cx.span_unimpl(sp, unsupported)\n             }\n         }\n-        alt cnv.width {\n+        match cnv.width {\n           count_implied => (),\n           count_is(_) => (),\n           _ => cx.span_unimpl(sp, unsupported)\n         }\n-        alt cnv.precision {\n+        match cnv.precision {\n           count_implied => (),\n           count_is(_) => (),\n           _ => cx.span_unimpl(sp, unsupported)\n         }\n-        alt cnv.ty {\n+        match cnv.ty {\n           ty_str => return make_conv_call(cx, arg.span, ~\"str\", cnv, arg),\n-          ty_int(sign) => alt sign {\n+          ty_int(sign) => match sign {\n             signed => return make_conv_call(cx, arg.span, ~\"int\", cnv, arg),\n             unsigned => {\n                 return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg)\n@@ -188,45 +188,45 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n         }\n     }\n     fn log_conv(c: conv) {\n-        alt c.param {\n+        match c.param {\n           some(p) => { log(debug, ~\"param: \" + int::to_str(p, 10u)); }\n           _ => debug!{\"param: none\"}\n         }\n         for c.flags.each |f| {\n-            alt f {\n+            match f {\n               flag_left_justify => debug!{\"flag: left justify\"},\n               flag_left_zero_pad => debug!{\"flag: left zero pad\"},\n               flag_space_for_sign => debug!{\"flag: left space pad\"},\n               flag_sign_always => debug!{\"flag: sign always\"},\n               flag_alternate => debug!{\"flag: alternate\"}\n             }\n         }\n-        alt c.width {\n+        match c.width {\n           count_is(i) => log(\n               debug, ~\"width: count is \" + int::to_str(i, 10u)),\n           count_is_param(i) => log(\n               debug, ~\"width: count is param \" + int::to_str(i, 10u)),\n           count_is_next_param => debug!{\"width: count is next param\"},\n           count_implied => debug!{\"width: count is implied\"}\n         }\n-        alt c.precision {\n+        match c.precision {\n           count_is(i) => log(\n               debug, ~\"prec: count is \" + int::to_str(i, 10u)),\n           count_is_param(i) => log(\n               debug, ~\"prec: count is param \" + int::to_str(i, 10u)),\n           count_is_next_param => debug!{\"prec: count is next param\"},\n           count_implied => debug!{\"prec: count is implied\"}\n         }\n-        alt c.ty {\n+        match c.ty {\n           ty_bool => debug!{\"type: bool\"},\n           ty_str => debug!{\"type: str\"},\n           ty_char => debug!{\"type: char\"},\n-          ty_int(s) => alt s {\n+          ty_int(s) => match s {\n             signed => debug!{\"type: signed\"},\n             unsigned => debug!{\"type: unsigned\"}\n           }\n           ty_bits => debug!{\"type: bits\"},\n-          ty_hex(cs) => alt cs {\n+          ty_hex(cs) => match cs {\n             case_upper => debug!{\"type: uhex\"},\n             case_lower => debug!{\"type: lhex\"},\n           }\n@@ -240,7 +240,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n     let mut piece_exprs = ~[];\n     let nargs = args.len();\n     for pieces.each |pc| {\n-        alt pc {\n+        match pc {\n           piece_string(s) => {\n             vec::push(piece_exprs, mk_uniq_str(cx, fmt_sp, s))\n           }"}, {"sha": "8595a991e2480a2772852253ba5b538100fba234", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -44,7 +44,7 @@ impl proto_check of proto::visitor<(), (), ()>  for ext_ctxt {\n \n     fn visit_message(name: ident, _span: span, _tys: &[@ast::ty],\n                      this: state, next: next_state) {\n-        alt next {\n+        match next {\n           some({state: next, tys: next_tys}) => {\n             let proto = this.proto;\n             if !proto.has_state(next) {"}, {"sha": "aa553d8ae53ea64d6349b6b617981592a72d37e8", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -25,12 +25,12 @@ impl proto_parser of proto_parser for parser {\n     fn parse_state(proto: protocol) {\n         let id = self.parse_ident();\n         self.expect(token::COLON);\n-        let dir = alt copy self.token {\n+        let dir = match copy self.token {\n           token::IDENT(n, _) => self.get_str(n),\n           _ => fail\n         };\n         self.bump();\n-        let dir = alt dir {\n+        let dir = match dir {\n           @~\"send\" => send,\n           @~\"recv\" => recv,\n           _ => fail\n@@ -64,7 +64,7 @@ impl proto_parser of proto_parser for parser {\n \n         self.expect(token::RARROW);\n \n-        let next = alt copy self.token {\n+        let next = match copy self.token {\n           token::IDENT(_, _) => {\n             let name = self.parse_ident();\n             let ntys = if self.token == token::LT {"}, {"sha": "16ba6d3a0633bc3d82815c375ca18bf43a876d99", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -47,7 +47,7 @@ trait gen_init {\n impl compile of gen_send for message {\n     fn gen_send(cx: ext_ctxt) -> @ast::item {\n         debug!{\"pipec: gen_send\"};\n-        alt self {\n+        match self {\n           message(id, span, tys, this,\n                   some({state: next, tys: next_tys})) => {\n             debug!{\"pipec: next state exists\"};\n@@ -71,7 +71,7 @@ impl compile of gen_send for message {\n             let mut body = ~\"{\\n\";\n \n             if this.proto.is_bounded() {\n-                let (sp, rp) = alt (this.dir, next.dir) {\n+                let (sp, rp) = match (this.dir, next.dir) {\n                   (send, send) => (~\"c\", ~\"s\"),\n                   (send, recv) => (~\"s\", ~\"c\"),\n                   (recv, send) => (~\"s\", ~\"c\"),\n@@ -87,7 +87,7 @@ impl compile of gen_send for message {\n                              rp, *next.name};\n             }\n             else {\n-                let pat = alt (this.dir, next.dir) {\n+                let pat = match (this.dir, next.dir) {\n                   (send, send) => ~\"(c, s)\",\n                   (send, recv) => ~\"(s, c)\",\n                   (recv, send) => ~\"(s, c)\",\n@@ -181,12 +181,12 @@ impl compile of to_type_decls for state {\n         for self.messages.each |m| {\n             let message(name, _span, tys, this, next) = m;\n \n-            let tys = alt next {\n+            let tys = match next {\n               some({state: next, tys: next_tys}) => {\n                 let next = this.proto.get_state(next);\n                 let next_name = next.data_name();\n \n-                let dir = alt this.dir {\n+                let dir = match this.dir {\n                   send => @~\"server\",\n                   recv => @~\"client\"\n                 };\n@@ -208,7 +208,7 @@ impl compile of to_type_decls for state {\n \n     fn to_endpoint_decls(cx: ext_ctxt, dir: direction) -> ~[@ast::item] {\n         debug!{\"pipec: to_endpoint_decls\"};\n-        let dir = alt dir {\n+        let dir = match dir {\n           send => (*self).dir,\n           recv => (*self).dir.reverse()\n         };\n@@ -255,7 +255,7 @@ impl compile of gen_init for protocol {\n         let start_state = self.states[0];\n \n         let body = if !self.is_bounded() {\n-            alt start_state.dir {\n+            match start_state.dir {\n               send => #ast { pipes::entangle() },\n               recv => {\n                 #ast {{\n@@ -267,7 +267,7 @@ impl compile of gen_init for protocol {\n         }\n         else {\n             let body = self.gen_init_bounded(ext_cx);\n-            alt start_state.dir {\n+            match start_state.dir {\n               send => body,\n               recv => {\n                 #ast {{\n@@ -322,7 +322,7 @@ impl compile of gen_init for protocol {\n         let mut params: ~[ast::ty_param] = ~[];\n         for (copy self.states).each |s| {\n             for s.ty_params.each |tp| {\n-                alt params.find(|tpp| *tp.ident == *tpp.ident) {\n+                match params.find(|tpp| *tp.ident == *tpp.ident) {\n                   none => vec::push(params, tp),\n                   _ => ()\n                 }\n@@ -338,7 +338,7 @@ impl compile of gen_init for protocol {\n         let mut params: ~[ast::ty_param] = ~[];\n         let fields = do (copy self.states).map_to_vec |s| {\n             for s.ty_params.each |tp| {\n-                alt params.find(|tpp| *tp.ident == *tpp.ident) {\n+                match params.find(|tpp| *tp.ident == *tpp.ident) {\n                   none => vec::push(params, tp),\n                   _ => ()\n                 }\n@@ -439,7 +439,7 @@ impl parse_utils of ext_ctxt_parse_utils for ext_ctxt {\n             self.cfg(),\n             ~[],\n             self.parse_sess());\n-        alt res {\n+        match res {\n           some(ast) => ast,\n           none => {\n             error!{\"Parse error with ```\\n%s\\n```\", s};"}, {"sha": "5769125225e3e81a54f1ee762763078731a01b6e", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -11,7 +11,7 @@ enum direction {\n \n impl of to_str for direction {\n     fn to_str() -> ~str {\n-        alt self {\n+        match self {\n           send => ~\"send\",\n           recv => ~\"recv\"\n         }\n@@ -20,7 +20,7 @@ impl of to_str for direction {\n \n impl methods for direction {\n     fn reverse() -> direction {\n-        alt self {\n+        match self {\n           send => recv,\n           recv => send\n         }\n@@ -36,20 +36,20 @@ enum message {\n \n impl methods for message {\n     fn name() -> ident {\n-        alt self {\n+        match self {\n           message(id, _, _, _, _) => id\n         }\n     }\n \n     fn span() -> span {\n-        alt self {\n+        match self {\n           message(_, span, _, _, _) => span\n         }\n     }\n \n     /// Return the type parameters actually used by this message\n     fn get_params() -> ~[ast::ty_param] {\n-        alt self {\n+        match self {\n           message(_, _, _, this, _) => this.ty_params\n         }\n     }\n@@ -92,7 +92,7 @@ impl methods for state {\n     /// from this state.\n     fn reachable(f: fn(state) -> bool) {\n         for self.messages.each |m| {\n-            alt m {\n+            match m {\n               message(_, _, _, _, some({state: id, _})) => {\n                 let state = self.proto.get_state(id);\n                 if !f(state) { break }"}, {"sha": "491d6104c7bed3db65ae1b8ab88501a1bc26574e", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -48,7 +48,7 @@ impl of qq_helper for @ast::expr {\n     fn span() -> span {self.span}\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_expr(self, cx, v);}\n     fn extract_mac() -> option<ast::mac_> {\n-        alt (self.node) {\n+        match (self.node) {\n           ast::expr_mac({node: mac, _}) => some(mac),\n           _ => none\n         }\n@@ -63,7 +63,7 @@ impl of qq_helper for @ast::ty {\n     fn span() -> span {self.span}\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_ty(self, cx, v);}\n     fn extract_mac() -> option<ast::mac_> {\n-        alt (self.node) {\n+        match (self.node) {\n           ast::ty_mac({node: mac, _}) => some(mac),\n           _ => none\n         }\n@@ -124,7 +124,7 @@ fn gather_anti_quotes<N: qq_helper>(lo: uint, node: N) -> aq_ctxt\n \n fn visit_aq<T:qq_helper>(node: T, constr: ~str, &&cx: aq_ctxt, v: vt<aq_ctxt>)\n {\n-    alt (node.extract_mac()) {\n+    match (node.extract_mac()) {\n       some(mac_aq(sp, e)) => {\n         cx.gather.push(gather_item {\n             lo: sp.lo - cx.lo,\n@@ -147,7 +147,7 @@ fn expand_ast(ecx: ext_ctxt, _sp: span,\n     let mut what = ~\"expr\";\n     do option::iter(arg) |arg| {\n         let args: ~[@ast::expr] =\n-            alt arg.node {\n+            match arg.node {\n               ast::expr_vec(elts, _) => elts,\n               _ => {\n                 ecx.span_fatal\n@@ -157,15 +157,15 @@ fn expand_ast(ecx: ext_ctxt, _sp: span,\n         if vec::len::<@ast::expr>(args) != 1u {\n             ecx.span_fatal(_sp, ~\"#ast requires exactly one arg\");\n         }\n-        alt (args[0].node) {\n+        match (args[0].node) {\n           ast::expr_path(@{idents: id, _}) if vec::len(id) == 1u\n           => what = *id[0],\n           _ => ecx.span_fatal(args[0].span, ~\"expected an identifier\")\n         }\n     }\n     let body = get_mac_body(ecx,_sp,body);\n \n-    return alt what {\n+    return match what {\n       ~\"crate\" => finish(ecx, body, parse_crate),\n       ~\"expr\" => finish(ecx, body, parse_expr),\n       ~\"ty\" => finish(ecx, body, parse_ty),\n@@ -183,7 +183,7 @@ fn parse_expr(p: parser) -> @ast::expr { p.parse_expr() }\n fn parse_pat(p: parser) -> @ast::pat { p.parse_pat(true) }\n \n fn parse_item(p: parser) -> @ast::item {\n-    alt p.parse_item(~[]) {\n+    match p.parse_item(~[]) {\n       some(item) => item,\n       none       => fail ~\"parse_item: parsing an item failed\"\n     }\n@@ -225,7 +225,7 @@ fn finish<T: qq_helper>\n             state = skip(str::char_len(repl));\n             str2 += repl;\n         }\n-        alt copy state {\n+        match copy state {\n           active => str::push_char(str2, ch),\n           skip(1u) => state = blank,\n           skip(sk) => state = skip (sk-1u),\n@@ -308,8 +308,8 @@ fn replace_expr(repls: ~[fragment],\n                 orig: fn@(ast::expr_, span, ast_fold)->(ast::expr_, span))\n     -> (ast::expr_, span)\n {\n-    alt e {\n-      ast::expr_mac({node: mac_var(i), _}) => alt (repls[i]) {\n+    match e {\n+      ast::expr_mac({node: mac_var(i), _}) => match (repls[i]) {\n         from_expr(r) => (r.node, r.span),\n         _ => fail /* fixme error message */\n       }\n@@ -322,8 +322,8 @@ fn replace_ty(repls: ~[fragment],\n                 orig: fn@(ast::ty_, span, ast_fold)->(ast::ty_, span))\n     -> (ast::ty_, span)\n {\n-    alt e {\n-      ast::ty_mac({node: mac_var(i), _}) => alt (repls[i]) {\n+    match e {\n+      ast::ty_mac({node: mac_var(i), _}) => match (repls[i]) {\n         from_ty(r) => (r.node, r.span),\n         _ => fail /* fixme error message */\n       }"}, {"sha": "bdb0c663fc7e7cd10f6da710c4e53421e4ca2c16", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -36,7 +36,7 @@ enum matchable {\n \n /* for when given an incompatible bit of AST */\n fn match_error(cx: ext_ctxt, m: matchable, expected: ~str) -> ! {\n-    alt m {\n+    match m {\n       match_expr(x) => cx.span_fatal(\n           x.span, ~\"this argument is an expr, expected \" + expected),\n       match_path(x) => cx.span_fatal(\n@@ -65,8 +65,8 @@ fn elts_to_ell(cx: ext_ctxt, elts: ~[@expr]) ->\n     let mut idx: uint = 0u;\n     let mut res = none;\n     for elts.each |elt| {\n-        alt elt.node {\n-          expr_mac(m) => alt m.node {\n+        match elt.node {\n+          expr_mac(m) => match m.node {\n             ast::mac_ellipsis => {\n                 if res != none {\n                     cx.span_fatal(m.span, ~\"only one ellipsis allowed\");\n@@ -82,7 +82,7 @@ fn elts_to_ell(cx: ext_ctxt, elts: ~[@expr]) ->\n         }\n         idx += 1u;\n     }\n-    return alt res {\n+    return match res {\n           some(val) => val,\n           none => {pre: elts, rep: none, post: ~[]}\n     }\n@@ -92,7 +92,7 @@ fn option_flatten_map<T: copy, U: copy>(f: fn@(T) -> option<U>, v: ~[T]) ->\n    option<~[U]> {\n     let mut res = ~[];\n     for v.each |elem| {\n-        alt f(elem) {\n+        match f(elem) {\n           none => return none,\n           some(fv) => vec::push(res, fv)\n         }\n@@ -101,9 +101,9 @@ fn option_flatten_map<T: copy, U: copy>(f: fn@(T) -> option<U>, v: ~[T]) ->\n }\n \n fn a_d_map(ad: arb_depth<matchable>, f: selector) -> match_result {\n-    alt ad {\n+    match ad {\n       leaf(x) => return f(x),\n-      seq(ads, span) => alt option_flatten_map(|x| a_d_map(x, f), *ads) {\n+      seq(ads, span) => match option_flatten_map(|x| a_d_map(x, f), *ads) {\n         none => return none,\n         some(ts) => return some(seq(@ts, span))\n       }\n@@ -112,7 +112,7 @@ fn a_d_map(ad: arb_depth<matchable>, f: selector) -> match_result {\n \n fn compose_sels(s1: selector, s2: selector) -> selector {\n     fn scomp(s1: selector, s2: selector, m: matchable) -> match_result {\n-        return alt s1(m) {\n+        return match s1(m) {\n               none => none,\n               some(matches) => a_d_map(matches, s2)\n             }\n@@ -156,11 +156,11 @@ fn use_selectors_to_bind(b: binders, e: @expr) -> option<bindings> {\n     let res = box_str_hash::<arb_depth<matchable>>();\n     //need to do this first, to check vec lengths.\n     for b.literal_ast_matchers.each |sel| {\n-        alt sel(match_expr(e)) { none => return none, _ => () }\n+        match sel(match_expr(e)) { none => return none, _ => () }\n     }\n     let mut never_mind: bool = false;\n     for b.real_binders.each |key, val| {\n-        alt val(match_expr(e)) {\n+        match val(match_expr(e)) {\n           none => never_mind = true,\n           some(mtc) => { res.insert(key, mtc); }\n         }\n@@ -209,7 +209,7 @@ fn follow(m: arb_depth<matchable>, idx_path: @mut ~[uint]) ->\n    arb_depth<matchable> {\n     let mut res: arb_depth<matchable> = m;\n     for vec::each(*idx_path) |idx| {\n-        res = alt res {\n+        res = match res {\n           leaf(_) => return res,/* end of the line */\n           seq(new_ms, _) => new_ms[idx]\n         }\n@@ -219,10 +219,10 @@ fn follow(m: arb_depth<matchable>, idx_path: @mut ~[uint]) ->\n \n fn follow_for_trans(cx: ext_ctxt, mmaybe: option<arb_depth<matchable>>,\n                     idx_path: @mut ~[uint]) -> option<matchable> {\n-    alt mmaybe {\n+    match mmaybe {\n       none => return none,\n       some(m) => {\n-        return alt follow(m, idx_path) {\n+        return match follow(m, idx_path) {\n               seq(_, sp) => {\n                 cx.span_fatal(sp,\n                               ~\"syntax matched under ... but not \" +\n@@ -258,21 +258,21 @@ fn free_vars(b: bindings, e: @expr, it: fn(ident)) {\n fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                     recur: fn@(&&@expr) -> @expr,\n                     exprs: ~[@expr]) -> ~[@expr] {\n-    alt elts_to_ell(cx, exprs) {\n+    match elts_to_ell(cx, exprs) {\n       {pre: pre, rep: repeat_me_maybe, post: post} => {\n         let mut res = vec::map(pre, recur);\n-        alt repeat_me_maybe {\n+        match repeat_me_maybe {\n           none => (),\n           some(repeat_me) => {\n             let mut repeat: option<{rep_count: uint, name: ident}> = none;\n             /* we need to walk over all the free vars in lockstep, except for\n             the leaves, which are just duplicated */\n             do free_vars(b, repeat_me) |fv| {\n                 let cur_pos = follow(b.get(fv), idx_path);\n-                alt cur_pos {\n+                match cur_pos {\n                   leaf(_) => (),\n                   seq(ms, _) => {\n-                    alt repeat {\n+                    match repeat {\n                       none => {\n                         repeat = some({rep_count: vec::len(*ms), name: fv});\n                       }\n@@ -290,7 +290,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                   }\n                 }\n             };\n-            alt repeat {\n+            match repeat {\n               none => {\n                 cx.span_fatal(repeat_me.span,\n                               ~\"'...' surrounds an expression without any\" +\n@@ -320,7 +320,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n // substitute, in a position that's required to be an ident\n fn transcribe_ident(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                     &&i: ident, _fld: ast_fold) -> ident {\n-    return alt follow_for_trans(cx, b.find(i), idx_path) {\n+    return match follow_for_trans(cx, b.find(i), idx_path) {\n           some(match_ident(a_id)) => a_id.node,\n           some(m) => match_error(cx, m, ~\"an identifier\"),\n           none => i\n@@ -332,7 +332,7 @@ fn transcribe_path(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                    p: path, _fld: ast_fold) -> path {\n     // Don't substitute into qualified names.\n     if vec::len(p.types) > 0u || vec::len(p.idents) != 1u { return p; }\n-    alt follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n+    match follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n       some(match_ident(id)) => {\n         {span: id.span, global: false, idents: ~[id.node],\n          rp: none, types: ~[]}\n@@ -349,13 +349,13 @@ fn transcribe_expr(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                    orig: fn@(ast::expr_, span, ast_fold)->(ast::expr_, span))\n     -> (ast::expr_, span)\n {\n-    return alt e {\n+    return match e {\n           expr_path(p) => {\n             // Don't substitute into qualified names.\n             if vec::len(p.types) > 0u || vec::len(p.idents) != 1u {\n                 (e, s);\n             }\n-            alt follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n+            match follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n               some(match_ident(id)) => {\n                 (expr_path(@{span: id.span,\n                              global: false,\n@@ -378,11 +378,11 @@ fn transcribe_type(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                    orig: fn@(ast::ty_, span, ast_fold) -> (ast::ty_, span))\n     -> (ast::ty_, span)\n {\n-    return alt t {\n+    return match t {\n           ast::ty_path(pth, _) => {\n-            alt path_to_ident(pth) {\n+            match path_to_ident(pth) {\n               some(id) => {\n-                alt follow_for_trans(cx, b.find(id), idx_path) {\n+                match follow_for_trans(cx, b.find(id), idx_path) {\n                   some(match_ty(ty)) => (ty.node, ty.span),\n                   some(m) => match_error(cx, m, ~\"a type\"),\n                   none => orig(t, s, fld)\n@@ -404,9 +404,9 @@ fn transcribe_block(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                     orig: fn@(blk_, span, ast_fold) -> (blk_, span))\n     -> (blk_, span)\n {\n-    return alt block_to_ident(blk) {\n+    return match block_to_ident(blk) {\n           some(id) => {\n-            alt follow_for_trans(cx, b.find(id), idx_path) {\n+            match follow_for_trans(cx, b.find(id), idx_path) {\n               some(match_block(new_blk)) => (new_blk.node, new_blk.span),\n \n               // possibly allow promotion of ident/path/expr to blocks?\n@@ -424,12 +424,12 @@ argument. ps accumulates instructions on navigating the tree.*/\n fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n \n     //it might be possible to traverse only exprs, not matchables\n-    alt m {\n+    match m {\n       match_expr(e) => {\n-        alt e.node {\n+        match e.node {\n           expr_path(p_pth) => p_t_s_r_path(cx, p_pth, s, b),\n           expr_vec(p_elts, _) => {\n-            alt elts_to_ell(cx, p_elts) {\n+            match elts_to_ell(cx, p_elts) {\n               {pre: pre, rep: some(repeat_me), post: post} => {\n                 p_t_s_r_length(cx, vec::len(pre) + vec::len(post), true, s,\n                                b);\n@@ -459,7 +459,7 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n           _ => {\n             fn select(cx: ext_ctxt, m: matchable, pat: @expr) ->\n                match_result {\n-                return alt m {\n+                return match m {\n                       match_expr(e) => {\n                         if e == pat { some(leaf(match_exact)) } else { none }\n                       }\n@@ -477,11 +477,11 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n \n /* make a match more precise */\n fn specialize_match(m: matchable) -> matchable {\n-    return alt m {\n+    return match m {\n           match_expr(e) => {\n-            alt e.node {\n+            match e.node {\n               expr_path(pth) => {\n-                alt path_to_ident(pth) {\n+                match path_to_ident(pth) {\n                   some(id) => match_ident(respan(pth.span, id)),\n                   none => match_path(pth)\n                 }\n@@ -495,10 +495,10 @@ fn specialize_match(m: matchable) -> matchable {\n \n /* pattern_to_selectors helper functions */\n fn p_t_s_r_path(cx: ext_ctxt, p: @path, s: selector, b: binders) {\n-    alt path_to_ident(p) {\n+    match path_to_ident(p) {\n       some(p_id) => {\n         fn select(cx: ext_ctxt, m: matchable) -> match_result {\n-            return alt m {\n+            return match m {\n                   match_expr(e) => some(leaf(specialize_match(m))),\n                   _ => cx.bug(~\"broken traversal in p_t_s_r\")\n                 }\n@@ -514,8 +514,8 @@ fn p_t_s_r_path(cx: ext_ctxt, p: @path, s: selector, b: binders) {\n \n fn block_to_ident(blk: blk_) -> option<ident> {\n     if vec::len(blk.stmts) != 0u { return none; }\n-    return alt blk.expr {\n-          some(expr) => alt expr.node {\n+    return match blk.expr {\n+          some(expr) => match expr.node {\n             expr_path(pth) => path_to_ident(pth),\n             _ => none\n           }\n@@ -526,8 +526,8 @@ fn block_to_ident(blk: blk_) -> option<ident> {\n fn p_t_s_r_mac(cx: ext_ctxt, mac: ast::mac, _s: selector, _b: binders) {\n     fn select_pt_1(cx: ext_ctxt, m: matchable,\n                    fn_m: fn(ast::mac) -> match_result) -> match_result {\n-        return alt m {\n-              match_expr(e) => alt e.node {\n+        return match m {\n+              match_expr(e) => match e.node {\n                 expr_mac(mac) => fn_m(mac),\n                 _ => none\n               }\n@@ -537,7 +537,7 @@ fn p_t_s_r_mac(cx: ext_ctxt, mac: ast::mac, _s: selector, _b: binders) {\n     fn no_des(cx: ext_ctxt, sp: span, syn: ~str) -> ! {\n         cx.span_fatal(sp, ~\"destructuring \" + syn + ~\" is not yet supported\");\n     }\n-    alt mac.node {\n+    match mac.node {\n       ast::mac_ellipsis => cx.span_fatal(mac.span, ~\"misused `...`\"),\n       ast::mac_invoc(_, _, _) => no_des(cx, mac.span, ~\"macro calls\"),\n       ast::mac_invoc_tt(_, _) => no_des(cx, mac.span, ~\"macro calls\"),\n@@ -550,9 +550,9 @@ fn p_t_s_r_ellipses(cx: ext_ctxt, repeat_me: @expr, offset: uint, s: selector,\n                     b: binders) {\n     fn select(cx: ext_ctxt, repeat_me: @expr, offset: uint, m: matchable) ->\n        match_result {\n-        return alt m {\n+        return match m {\n               match_expr(e) => {\n-                alt e.node {\n+                match e.node {\n                   expr_vec(arg_elts, _) => {\n                     let mut elts = ~[];\n                     let mut idx = offset;\n@@ -580,9 +580,9 @@ fn p_t_s_r_length(cx: ext_ctxt, len: uint, at_least: bool, s: selector,\n                   b: binders) {\n     fn len_select(_cx: ext_ctxt, m: matchable, at_least: bool, len: uint) ->\n        match_result {\n-        return alt m {\n+        return match m {\n               match_expr(e) => {\n-                alt e.node {\n+                match e.node {\n                   expr_vec(arg_elts, _) => {\n                     let actual_len = vec::len(arg_elts);\n                     if at_least && actual_len >= len || actual_len == len {\n@@ -604,9 +604,9 @@ fn p_t_s_r_actual_vector(cx: ext_ctxt, elts: ~[@expr], _repeat_after: bool,\n     let mut idx: uint = 0u;\n     while idx < vec::len(elts) {\n         fn select(cx: ext_ctxt, m: matchable, idx: uint) -> match_result {\n-            return alt m {\n+            return match m {\n                   match_expr(e) => {\n-                    alt e.node {\n+                    match e.node {\n                       expr_vec(arg_elts, _) => {\n                         some(leaf(match_expr(arg_elts[idx])))\n                       }\n@@ -629,7 +629,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n     let mut macro_name: option<@~str> = none;\n     let mut clauses: ~[@clause] = ~[];\n     for args.each |arg| {\n-        alt arg.node {\n+        match arg.node {\n           expr_vec(elts, mutbl) => {\n             if vec::len(elts) != 2u {\n                 cx.span_fatal((*arg).span,\n@@ -638,12 +638,12 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n             }\n \n \n-            alt elts[0u].node {\n+            match elts[0u].node {\n               expr_mac(mac) => {\n-                alt mac.node {\n+                match mac.node {\n                   mac_invoc(pth, invoc_arg, body) => {\n-                    alt path_to_ident(pth) {\n-                      some(id) => alt macro_name {\n+                    match path_to_ident(pth) {\n+                      some(id) => match macro_name {\n                         none => macro_name = some(id),\n                         some(other_id) => if id != other_id {\n                             cx.span_fatal(pth.span,\n@@ -654,7 +654,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                       none => cx.span_fatal(pth.span,\n                                             ~\"macro name must not be a path\")\n                     }\n-                    let arg = alt invoc_arg {\n+                    let arg = match invoc_arg {\n                       some(arg) => arg,\n                       none => cx.span_fatal(mac.span,\n                                            ~\"macro must have arguments\")\n@@ -689,7 +689,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n     let ext = |a,b,c,d, move clauses| generic_extension(a,b,c,d,clauses);\n \n     return {ident:\n-             alt macro_name {\n+             match macro_name {\n                some(id) => id,\n                none => cx.span_fatal(sp, ~\"macro definition must have \" +\n                                      ~\"at least one clause\")\n@@ -699,12 +699,12 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n     fn generic_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                          _body: ast::mac_body,\n                          clauses: ~[@clause]) -> @expr {\n-        let arg = alt arg {\n+        let arg = match arg {\n           some(arg) => arg,\n           none => cx.span_fatal(sp, ~\"macro must have arguments\")\n         };\n         for clauses.each |c| {\n-            alt use_selectors_to_bind(c.params, arg) {\n+            match use_selectors_to_bind(c.params, arg) {\n               some(bindings) => return transcribe(cx, bindings, c.body),\n               none => again\n             }"}, {"sha": "3fdd5239e651538b68c49e928967b4f576e011b8", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -70,7 +70,7 @@ fn expand_include_str(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n     let file = expr_to_str(cx, args[0], ~\"#include_str requires a string\");\n \n     let res = io::read_whole_file_str(res_rel_file(cx, sp, file));\n-    alt res {\n+    match res {\n       result::ok(_) => { /* Continue. */ }\n       result::err(e) => {\n         cx.parse_sess().span_diagnostic.handler().fatal(e);\n@@ -86,7 +86,7 @@ fn expand_include_bin(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n \n     let file = expr_to_str(cx, args[0], ~\"#include_bin requires a string\");\n \n-    alt io::read_whole_file(res_rel_file(cx, sp, file)) {\n+    match io::read_whole_file(res_rel_file(cx, sp, file)) {\n       result::ok(src) => {\n         let u8_exprs = vec::map(src, |char: u8| {\n             mk_u8(cx, sp, char)"}, {"sha": "f1c7ebb7dadaf4acad958fa399245b36f7490e91", "filename": "src/libsyntax/ext/tt/earley_parser.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -31,7 +31,7 @@ enum matcher_pos_up { /* to break a circularity */\n }\n \n fn is_some(&&mpu: matcher_pos_up) -> bool {\n-    alt mpu {\n+    match mpu {\n       matcher_pos_up(none) => false,\n       _ => true\n     }\n@@ -48,15 +48,15 @@ type matcher_pos = ~{\n };\n \n fn copy_up(&& mpu: matcher_pos_up) -> matcher_pos {\n-    alt mpu {\n+    match mpu {\n       matcher_pos_up(some(mp)) => copy mp,\n       _ => fail\n     }\n }\n \n fn count_names(ms: &[matcher]) -> uint {\n     vec::foldl(0u, ms, |ct, m| {\n-        ct + alt m.node {\n+        ct + match m.node {\n           match_tok(_) => 0u,\n           match_seq(more_ms, _, _, _, _) => count_names(more_ms),\n           match_nonterminal(_,_,_) => 1u\n@@ -68,7 +68,7 @@ fn initial_matcher_pos(ms: ~[matcher], sep: option<token>, lo: uint)\n     -> matcher_pos {\n     let mut match_idx_hi = 0u;\n     for ms.each() |elt| {\n-        alt elt.node {\n+        match elt.node {\n           match_tok(_) => (),\n           match_seq(_,_,_,_,hi) => {\n             match_idx_hi = hi;       // it is monotonic...\n@@ -113,7 +113,7 @@ fn nameize(p_s: parse_sess, ms: ~[matcher], res: ~[@named_match])\n     -> hashmap<ident,@named_match> {\n     fn n_rec(p_s: parse_sess, m: matcher, res: ~[@named_match],\n              ret_val: hashmap<ident, @named_match>) {\n-        alt m {\n+        match m {\n           {node: match_tok(_), span: _} => (),\n           {node: match_seq(more_ms, _, _, _, _), span: _} => {\n             for more_ms.each() |next_m| { n_rec(p_s, next_m, res, ret_val) };\n@@ -139,7 +139,7 @@ enum parse_result {\n \n fn parse_or_else(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader,\n                  ms: ~[matcher]) -> hashmap<ident, @named_match> {\n-    alt parse(sess, cfg, rdr, ms) {\n+    match parse(sess, cfg, rdr, ms) {\n       success(m) => m,\n       failure(sp, str) => sess.span_diagnostic.span_fatal(sp, str)\n     }\n@@ -202,7 +202,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n                     // can we go around again?\n \n                     // the *_t vars are workarounds for the lack of unary move\n-                    alt copy ei.sep {\n+                    match copy ei.sep {\n                       some(t) if idx == len => { // we need a separator\n                         if tok == t { //pass the separator\n                             let ei_t <- ei;\n@@ -220,7 +220,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n                     vec::push(eof_eis, ei);\n                 }\n             } else {\n-                alt copy ei.elts[idx].node {\n+                match copy ei.elts[idx].node {\n                   /* need to descend into sequence */\n                   match_seq(matchers, sep, zero_ok,\n                             match_idx_lo, match_idx_hi) => {\n@@ -270,7 +270,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n             if (bb_eis.len() > 0u && next_eis.len() > 0u)\n                 || bb_eis.len() > 1u {\n                 let nts = str::connect(vec::map(bb_eis, |ei| {\n-                    alt ei.elts[ei.idx].node {\n+                    match ei.elts[ei.idx].node {\n                       match_nonterminal(bind,name,_) => {\n                         fmt!{\"%s ('%s')\", *name, *bind}\n                       }\n@@ -293,7 +293,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n                 let rust_parser = parser(sess, cfg, rdr.dup(), SOURCE_FILE);\n \n                 let ei = vec::pop(bb_eis);\n-                alt ei.elts[ei.idx].node {\n+                match ei.elts[ei.idx].node {\n                   match_nonterminal(_, name, idx) => {\n                     ei.matches[idx].push(@matched_nonterminal(\n                         parse_nt(rust_parser, *name)));\n@@ -318,8 +318,8 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n }\n \n fn parse_nt(p: parser, name: ~str) -> nonterminal {\n-    alt name {\n-      ~\"item\" => alt p.parse_item(~[]) {\n+    match name {\n+      ~\"item\" => match p.parse_item(~[]) {\n         some(i) => token::nt_item(i),\n         none => p.fatal(~\"expected an item keyword\")\n       }\n@@ -329,7 +329,7 @@ fn parse_nt(p: parser, name: ~str) -> nonterminal {\n       ~\"expr\" => token::nt_expr(p.parse_expr()),\n       ~\"ty\" => token::nt_ty(p.parse_ty(false /* no need to disambiguate*/)),\n       // this could be handled like a token, since it is one\n-      ~\"ident\" => alt copy p.token {\n+      ~\"ident\" => match copy p.token {\n         token::IDENT(sn,b) => { p.bump(); token::nt_ident(sn,b) }\n         _ => p.fatal(~\"expected ident, found \"\n                      + token::to_str(*p.reader.interner(), copy p.token))"}, {"sha": "a870928d50b992ef994ce42bb3516d1f67641814", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -37,11 +37,11 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                                      arg_reader as reader, argument_gram);\n \n     // Extract the arguments:\n-    let lhses:~[@named_match] = alt argument_map.get(@~\"lhs\") {\n+    let lhses:~[@named_match] = match argument_map.get(@~\"lhs\") {\n       @matched_seq(s, sp) => s,\n       _ => cx.span_bug(sp, ~\"wrong-structured lhs\")\n     };\n-    let rhses:~[@named_match] = alt argument_map.get(@~\"rhs\") {\n+    let rhses:~[@named_match] = match argument_map.get(@~\"rhs\") {\n       @matched_seq(s, sp) => s,\n       _ => cx.span_bug(sp, ~\"wrong-structured rhs\")\n     };\n@@ -58,13 +58,14 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n         let itr = cx.parse_sess().interner;\n \n         for lhses.eachi() |i, lhs| { // try each arm's matchers\n-            alt lhs {\n+            match lhs {\n               @matched_nonterminal(nt_matchers(mtcs)) => {\n                 // `none` is because we're not interpolating\n                 let arg_rdr = new_tt_reader(s_d, itr, none, arg) as reader;\n-                alt parse(cx.parse_sess(), cx.cfg(), arg_rdr, mtcs) {\n+                match parse(cx.parse_sess(), cx.cfg(), arg_rdr, mtcs) {\n                   success(named_matches) => {\n-                    let rhs = alt rhses[i] { // okay, what's your transcriber?\n+                    let rhs = match rhses[i] {\n+                        // okay, what's your transcriber?\n                       @matched_nonterminal(nt_tt(@tt)) => tt,\n                       _ => cx.span_bug(sp, ~\"bad thing in rhs\")\n                     };"}, {"sha": "693b538ec6d0ed8fe0326b03004f28482508ef8a", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -46,7 +46,7 @@ fn new_tt_reader(sp_diag: span_handler, itr: @interner<@~str>,\n     let r = @{sp_diag: sp_diag, interner: itr,\n               mut cur: @{readme: src, mut idx: 0u, dotdotdoted: false,\n                          sep: none, up: tt_frame_up(option::none)},\n-              interpolations: alt interp { /* just a convienience */\n+              interpolations: match interp { /* just a convienience */\n                 none => std::map::box_str_hash::<@named_match>(),\n                 some(x) => x\n               },\n@@ -61,7 +61,7 @@ fn new_tt_reader(sp_diag: span_handler, itr: @interner<@~str>,\n \n pure fn dup_tt_frame(&&f: tt_frame) -> tt_frame {\n     @{readme: f.readme, mut idx: f.idx, dotdotdoted: f.dotdotdoted,\n-      sep: f.sep, up: alt f.up {\n+      sep: f.sep, up: match f.up {\n         tt_frame_up(some(up_frame)) => {\n           tt_frame_up(some(dup_tt_frame(up_frame)))\n         }\n@@ -82,7 +82,7 @@ pure fn dup_tt_reader(&&r: tt_reader) -> tt_reader {\n pure fn lookup_cur_matched_by_matched(r: tt_reader,\n                                       start: @named_match) -> @named_match {\n     pure fn red(&&ad: @named_match, &&idx: uint) -> @named_match {\n-        alt *ad {\n+        match *ad {\n           matched_nonterminal(_) => {\n             // end of the line; duplicate henceforth\n             ad\n@@ -102,10 +102,10 @@ enum lis {\n \n fn lockstep_iter_size(&&t: token_tree, &&r: tt_reader) -> lis {\n     fn lis_merge(lhs: lis, rhs: lis) -> lis {\n-        alt lhs {\n+        match lhs {\n           lis_unconstrained => rhs,\n           lis_contradiction(_) => lhs,\n-          lis_constraint(l_len, l_id) => alt rhs {\n+          lis_constraint(l_len, l_id) => match rhs {\n             lis_unconstrained => lhs,\n             lis_contradiction(_) => rhs,\n             lis_constraint(r_len, _) if l_len == r_len => lhs,\n@@ -117,13 +117,13 @@ fn lockstep_iter_size(&&t: token_tree, &&r: tt_reader) -> lis {\n           }\n         }\n     }\n-    alt t {\n+    match t {\n       tt_delim(tts) | tt_seq(_, tts, _, _) => {\n         vec::foldl(lis_unconstrained, tts, {|lis, tt|\n             lis_merge(lis, lockstep_iter_size(tt, r)) })\n       }\n       tt_tok(*) => lis_unconstrained,\n-      tt_nonterminal(_, name) => alt *lookup_cur_matched(r, name) {\n+      tt_nonterminal(_, name) => match *lookup_cur_matched(r, name) {\n         matched_nonterminal(_) => lis_unconstrained,\n         matched_seq(ads, _) => lis_constraint(ads.len(), name)\n       }\n@@ -138,7 +138,7 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n         if ! r.cur.dotdotdoted\n             || r.repeat_idx.last() == r.repeat_len.last() - 1 {\n \n-            alt r.cur.up {\n+            match r.cur.up {\n               tt_frame_up(none) => {\n                 r.cur_tok = EOF;\n                 return ret_val;\n@@ -156,7 +156,7 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n         } else { /* repeat */\n             r.cur.idx = 0u;\n             r.repeat_idx[r.repeat_idx.len() - 1u] += 1u;\n-            alt r.cur.sep {\n+            match r.cur.sep {\n               some(tk) => {\n                 r.cur_tok = tk; /* repeat same span, I guess */\n                 return ret_val;\n@@ -167,7 +167,7 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n     }\n     loop { /* because it's easiest, this handles `tt_delim` not starting\n     with a `tt_tok`, even though it won't happen */\n-        alt r.cur.readme[r.cur.idx] {\n+        match r.cur.readme[r.cur.idx] {\n           tt_delim(tts) => {\n             r.cur = @{readme: tts, mut idx: 0u, dotdotdoted: false,\n                       sep: none, up: tt_frame_up(option::some(r.cur)) };\n@@ -179,7 +179,7 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n             return ret_val;\n           }\n           tt_seq(sp, tts, sep, zerok) => {\n-            alt lockstep_iter_size(tt_seq(sp, tts, sep, zerok), r) {\n+            match lockstep_iter_size(tt_seq(sp, tts, sep, zerok), r) {\n               lis_unconstrained => {\n                 r.sp_diag.span_fatal(\n                     sp, /* blame macro writer */\n@@ -212,7 +212,7 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n           }\n           // FIXME #2887: think about span stuff here\n           tt_nonterminal(sp, ident) => {\n-            alt *lookup_cur_matched(r, ident) {\n+            match *lookup_cur_matched(r, ident) {\n               /* sidestep the interpolation tricks for ident because\n               (a) idents can be in lots of places, so it'd be a pain\n               (b) we actually can, since it's a token. */"}, {"sha": "40c676f8b80cabf4324fd579a69f27b0ea8b9996", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -80,7 +80,7 @@ type ast_fold_precursor = @{\n //used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n     return @{node:\n-              alt mi.node {\n+              match mi.node {\n                 meta_word(id) => meta_word(fld.fold_ident(id)),\n                 meta_list(id, mis) => {\n                   let fold_meta_item = |x|fold_meta_item_(x, fld);\n@@ -112,7 +112,7 @@ fn fold_arg_(a: arg, fld: ast_fold) -> arg {\n //used in noop_fold_expr, and possibly elsewhere in the future\n fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n     return {node:\n-             alt m.node {\n+             match m.node {\n                mac_invoc(pth, arg, body) => {\n                  mac_invoc(fld.fold_path(pth),\n                            option::map(arg, |x| fld.fold_expr(x)), body)\n@@ -133,7 +133,7 @@ fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n }\n \n fn fold_ty_param_bound(tpb: ty_param_bound, fld: ast_fold) -> ty_param_bound {\n-    alt tpb {\n+    match tpb {\n       bound_copy | bound_send | bound_const | bound_owned => tpb,\n       bound_trait(ty) => bound_trait(fld.fold_ty(ty))\n     }\n@@ -163,7 +163,7 @@ fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n \n fn noop_fold_crate_directive(cd: crate_directive_, fld: ast_fold) ->\n    crate_directive_ {\n-    return alt cd {\n+    return match cd {\n           cdir_src_mod(id, attrs) => {\n             cdir_src_mod(fld.fold_ident(id), /* FIXME (#2543) */ copy attrs)\n           }\n@@ -190,7 +190,7 @@ fn noop_fold_foreign_item(&&ni: @foreign_item, fld: ast_fold)\n     return @{ident: fld.fold_ident(ni.ident),\n           attrs: vec::map(ni.attrs, fold_attribute),\n           node:\n-              alt ni.node {\n+              match ni.node {\n                 foreign_item_fn(fdec, typms) => {\n                   foreign_item_fn({inputs: vec::map(fdec.inputs, fold_arg),\n                                   output: fld.fold_ty(fdec.output),\n@@ -216,7 +216,7 @@ fn noop_fold_item(&&i: @item, fld: ast_fold) -> option<@item> {\n \n fn noop_fold_class_item(&&ci: @class_member, fld: ast_fold)\n     -> @class_member {\n-    @{node: alt ci.node {\n+    @{node: match ci.node {\n         instance_var(ident, t, cm, id, p) => {\n            instance_var(/* FIXME (#2543) */ copy ident,\n                         fld.fold_ty(t), cm, id, p)\n@@ -227,7 +227,7 @@ fn noop_fold_class_item(&&ci: @class_member, fld: ast_fold)\n }\n \n fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n-    return alt i {\n+    return match i {\n           item_const(t, e) => item_const(fld.fold_ty(t), fld.fold_expr(e)),\n           item_fn(decl, typms, body) => {\n               item_fn(fold_fn_decl(decl, fld),\n@@ -244,7 +244,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n           }\n           item_class(typms, traits, items, m_ctor, m_dtor) => {\n             let resulting_optional_constructor;\n-            alt m_ctor {\n+            match m_ctor {\n                 none => {\n                     resulting_optional_constructor = none;\n                 }\n@@ -319,7 +319,7 @@ fn noop_fold_block(b: blk_, fld: ast_fold) -> blk_ {\n }\n \n fn noop_fold_stmt(s: stmt_, fld: ast_fold) -> stmt_ {\n-    return alt s {\n+    return match s {\n       stmt_decl(d, nid) => stmt_decl(fld.fold_decl(d), fld.new_id(nid)),\n       stmt_expr(e, nid) => stmt_expr(fld.fold_expr(e), fld.new_id(nid)),\n       stmt_semi(e, nid) => stmt_semi(fld.fold_expr(e), fld.new_id(nid))\n@@ -333,7 +333,7 @@ fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n }\n \n fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n-    return alt p {\n+    return match p {\n           pat_wild => pat_wild,\n           pat_ident(binding_mode, pth, sub) => {\n             pat_ident(binding_mode,\n@@ -364,9 +364,9 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n }\n \n fn noop_fold_decl(d: decl_, fld: ast_fold) -> decl_ {\n-    alt d {\n+    match d {\n       decl_local(ls) => decl_local(vec::map(ls, |x| fld.fold_local(x))),\n-      decl_item(it) => alt fld.fold_item(it) {\n+      decl_item(it) => match fld.fold_item(it) {\n         some(it_folded) => decl_item(it_folded),\n         none => decl_local(~[])\n       }\n@@ -393,7 +393,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n \n     let fold_mac = |x| fold_mac_(x, fld);\n \n-    return alt e {\n+    return match e {\n           expr_vstore(e, v) => {\n             expr_vstore(fld.fold_expr(e), v)\n           }\n@@ -496,7 +496,7 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n                 mt: fold_mt(f.node.mt, fld)},\n          span: fld.new_span(f.span)}\n     }\n-    alt t {\n+    match t {\n       ty_nil | ty_bot | ty_infer => copy t,\n       ty_box(mt) => ty_box(fold_mt(mt, fld)),\n       ty_uniq(mt) => ty_uniq(fold_mt(mt, fld)),\n@@ -533,7 +533,7 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n     let fold_attribute = |x| fold_attribute_(x, fld);\n     let attrs = vec::map(v.attrs, fold_attribute);\n \n-    let de = alt v.disr_expr {\n+    let de = match v.disr_expr {\n       some(e) => some(fld.fold_expr(e)),\n       none => none\n     };\n@@ -560,7 +560,7 @@ fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {\n          ty: fld.fold_ty(l.ty),\n          pat: fld.fold_pat(l.pat),\n          init:\n-             alt l.init {\n+             match l.init {\n                option::none::<initializer> => l.init,\n                option::some::<initializer>(init) => {\n                  option::some::<initializer>({op: init.op,\n@@ -635,7 +635,7 @@ impl of ast_fold for ast_fold_precursor {\n         return self.fold_item(i, self as ast_fold);\n     }\n     fn fold_class_item(&&ci: @class_member) -> @class_member {\n-        @{node: alt ci.node {\n+        @{node: match ci.node {\n            instance_var(nm, t, mt, id, p) => {\n                instance_var(/* FIXME (#2543) */ copy nm,\n                             (self as ast_fold).fold_ty(t), mt, id, p)"}, {"sha": "0a6df808530dc2d7cfb3ddb62ac568fc06d4dd9d", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -189,7 +189,7 @@ fn new_parser_etc_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n                             +path: ~str, ftype: parser::file_type) ->\n    (parser, string_reader) {\n     let res = io::read_whole_file_str(path);\n-    alt res {\n+    match res {\n       result::ok(_) => { /* Continue. */ }\n       result::err(e) => sess.span_diagnostic.handler().fatal(e)\n     }"}, {"sha": "aefa7264bf6cded85a6acf17500865e820618889", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -29,7 +29,7 @@ impl parser_attr of parser_attr for parser {\n         -> attr_or_ext\n     {\n         let expect_item_next = vec::is_not_empty(first_item_attrs);\n-        alt self.token {\n+        match self.token {\n           token::POUND => {\n             let lo = self.span.lo;\n             if self.look_ahead(1u) == token::LBRACKET {\n@@ -57,7 +57,7 @@ impl parser_attr of parser_attr for parser {\n     fn parse_outer_attributes() -> ~[ast::attribute] {\n         let mut attrs: ~[ast::attribute] = ~[];\n         loop {\n-            alt copy self.token {\n+            match copy self.token {\n               token::POUND => {\n                 if self.look_ahead(1u) != token::LBRACKET {\n                     break;\n@@ -106,7 +106,7 @@ impl parser_attr of parser_attr for parser {\n         let mut inner_attrs: ~[ast::attribute] = ~[];\n         let mut next_outer_attrs: ~[ast::attribute] = ~[];\n         loop {\n-            alt copy self.token {\n+            match copy self.token {\n               token::POUND => {\n                 if self.look_ahead(1u) != token::LBRACKET {\n                     // This is an extension\n@@ -146,7 +146,7 @@ impl parser_attr of parser_attr for parser {\n     fn parse_meta_item() -> @ast::meta_item {\n         let lo = self.span.lo;\n         let ident = self.parse_ident();\n-        alt self.token {\n+        match self.token {\n           token::EQ => {\n             self.bump();\n             let lit = self.parse_lit();\n@@ -172,7 +172,7 @@ impl parser_attr of parser_attr for parser {\n     }\n \n     fn parse_optional_meta() -> ~[@ast::meta_item] {\n-        alt self.token {\n+        match self.token {\n           token::LPAREN => return self.parse_meta_seq(),\n           _ => return ~[]\n         }"}, {"sha": "38599907e6f887eb80cf6301a2d6350d9b02d9b4", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -5,7 +5,7 @@\n import ast_util::operator_prec;\n \n fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n-    alt e.node {\n+    match e.node {\n       ast::expr_if(_, _, _) | ast::expr_alt(_, _, _) | ast::expr_block(_)\n       | ast::expr_while(_, _) | ast::expr_loop(_)\n       | ast::expr_call(_, _, true) => false,\n@@ -14,9 +14,9 @@ fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n }\n \n fn stmt_ends_with_semi(stmt: ast::stmt) -> bool {\n-    alt stmt.node {\n+    match stmt.node {\n       ast::stmt_decl(d, _) => {\n-        return alt d.node {\n+        return match d.node {\n               ast::decl_local(_) => true,\n               ast::decl_item(_) => false\n             }\n@@ -31,7 +31,7 @@ fn stmt_ends_with_semi(stmt: ast::stmt) -> bool {\n }\n \n fn need_parens(expr: @ast::expr, outer_prec: uint) -> bool {\n-    alt expr.node {\n+    match expr.node {\n       ast::expr_binary(op, _, _) => operator_prec(op) < outer_prec,\n       ast::expr_cast(_, _) => parse::prec::as_prec < outer_prec,\n       // This may be too conservative in some cases\n@@ -47,8 +47,8 @@ fn need_parens(expr: @ast::expr, outer_prec: uint) -> bool {\n }\n \n fn ends_in_lit_int(ex: @ast::expr) -> bool {\n-    alt ex.node {\n-      ast::expr_lit(node) => alt node {\n+    match ex.node {\n+      ast::expr_lit(node) => match node {\n         @{node: ast::lit_int(_, ast::ty_i), _}\n         | @{node: ast::lit_int_unsuffixed(_), _} => true,\n         _ => false\n@@ -60,7 +60,7 @@ fn ends_in_lit_int(ex: @ast::expr) -> bool {\n       ast::expr_log(_, _, sub) | ast::expr_assert(sub) => {\n         ends_in_lit_int(sub)\n       }\n-      ast::expr_fail(osub) | ast::expr_ret(osub) => alt osub {\n+      ast::expr_fail(osub) | ast::expr_ret(osub) => match osub {\n         some(ex) => ends_in_lit_int(ex),\n         _ => false\n       }"}, {"sha": "445e4c20eede31ad15845435944f833d739d72e3", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -84,7 +84,7 @@ impl parser_common of parser_common for parser {\n     }\n \n     fn parse_ident() -> ast::ident {\n-        alt copy self.token {\n+        match copy self.token {\n           token::IDENT(i, _) => { self.bump(); return self.get_str(i); }\n           token::INTERPOLATED(token::nt_ident(*)) => { self.bug(\n               ~\"ident interpolation not converted to real token\"); }\n@@ -118,7 +118,7 @@ impl parser_common of parser_common for parser {\n     }\n \n     fn token_is_word(word: ~str, ++tok: token::token) -> bool {\n-        alt tok {\n+        match tok {\n           token::IDENT(sid, false) => { word == *self.get_str(sid) }\n           _ => { false }\n         }\n@@ -134,7 +134,7 @@ impl parser_common of parser_common for parser {\n     }\n \n     fn is_any_keyword(tok: token::token) -> bool {\n-        alt tok {\n+        match tok {\n           token::IDENT(sid, false) => {\n             self.keywords.contains_key_ref(self.get_str(sid))\n           }\n@@ -146,7 +146,7 @@ impl parser_common of parser_common for parser {\n         self.require_keyword(word);\n \n         let mut bump = false;\n-        let val = alt self.token {\n+        let val = match self.token {\n           token::IDENT(sid, false) => {\n             if word == *self.get_str(sid) {\n                 bump = true;\n@@ -173,7 +173,7 @@ impl parser_common of parser_common for parser {\n     }\n \n     fn check_restricted_keywords() {\n-        alt self.token {\n+        match self.token {\n           token::IDENT(_, false) => {\n             let w = token_to_str(self.reader, self.token);\n             self.check_restricted_keywords_(w);\n@@ -209,7 +209,7 @@ impl parser_common of parser_common for parser {\n         let mut v = ~[];\n         while self.token != token::GT\n             && self.token != token::BINOP(token::SHR) {\n-            alt sep {\n+            match sep {\n               some(t) => {\n                 if first { first = false; }\n                 else { self.expect(t); }\n@@ -253,7 +253,7 @@ impl parser_common of parser_common for parser {\n         let mut first: bool = true;\n         let mut v: ~[T] = ~[];\n         while self.token != ket {\n-            alt sep.sep {\n+            match sep.sep {\n               some(t) => {\n                 if first { first = false; }\n                 else { self.expect(t); }"}, {"sha": "6b0112922a5fb02063893a06ce439049aa68971c", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -47,7 +47,7 @@ fn parse_companion_mod(cx: ctx, prefix: ~str, suffix: option<~str>)\n     -> (~[@ast::view_item], ~[@ast::item], ~[ast::attribute]) {\n \n     fn companion_file(+prefix: ~str, suffix: option<~str>) -> ~str {\n-        return alt suffix {\n+        return match suffix {\n           option::some(s) => path::connect(prefix, s),\n           option::none => prefix\n         } + ~\".rs\";\n@@ -56,7 +56,7 @@ fn parse_companion_mod(cx: ctx, prefix: ~str, suffix: option<~str>)\n     fn file_exists(path: ~str) -> bool {\n         // Crude, but there's no lib function for this and I'm not\n         // up to writing it just now\n-        alt io::file_reader(path) {\n+        match io::file_reader(path) {\n           result::ok(_) => true,\n           result::err(_) => false\n         }\n@@ -79,7 +79,7 @@ fn parse_companion_mod(cx: ctx, prefix: ~str, suffix: option<~str>)\n }\n \n fn cdir_path_opt(id: ast::ident, attrs: ~[ast::attribute]) -> @~str {\n-    alt ::attr::first_attr_value_str_by_name(attrs, ~\"path\") {\n+    match ::attr::first_attr_value_str_by_name(attrs, ~\"path\") {\n       some(d) => return d,\n       none => return id\n     }\n@@ -88,7 +88,7 @@ fn cdir_path_opt(id: ast::ident, attrs: ~[ast::attribute]) -> @~str {\n fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: ~str,\n                         &view_items: ~[@ast::view_item],\n                         &items: ~[@ast::item]) {\n-    alt cdir.node {\n+    match cdir.node {\n       ast::cdir_src_mod(id, attrs) => {\n         let file_path = cdir_path_opt(@(*id + ~\".rs\"), attrs);\n         let full_path ="}, {"sha": "e9bfbc753f70d0e5ee5fe0d0358f871c14d39b49", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -206,7 +206,7 @@ fn consume_whitespace_and_comments(rdr: string_reader)\n fn consume_any_line_comment(rdr: string_reader)\n                                 -> option<{tok: token::token, sp: span}> {\n     if rdr.curr == '/' {\n-        alt nextch(rdr) {\n+        match nextch(rdr) {\n           '/' => {\n             bump(rdr);\n             bump(rdr);\n@@ -313,7 +313,7 @@ fn scan_digits(rdr: string_reader, radix: uint) -> ~str {\n     loop {\n         let c = rdr.curr;\n         if c == '_' { bump(rdr); again; }\n-        alt char::to_digit(c, radix) {\n+        match char::to_digit(c, radix) {\n           some(d) => {\n             str::push_char(rslt, c);\n             bump(rdr);\n@@ -371,7 +371,7 @@ fn scan_number(c: char, rdr: string_reader) -> token::token {\n             rdr.fatal(~\"no valid digits found for number\");\n         }\n         let parsed = option::get(u64::from_str_radix(num_str, base as u64));\n-        alt tp {\n+        match tp {\n           either::left(t) => return token::LIT_INT(parsed as i64, t),\n           either::right(t) => return token::LIT_UINT(parsed, t)\n         }\n@@ -383,7 +383,7 @@ fn scan_number(c: char, rdr: string_reader) -> token::token {\n         let dec_part = scan_digits(rdr, 10u);\n         num_str += ~\".\" + dec_part;\n     }\n-    alt scan_exponent(rdr) {\n+    match scan_exponent(rdr) {\n       some(s) => {\n         is_float = true;\n         num_str += s;\n@@ -472,7 +472,7 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n             return token::BINOPEQ(op);\n         } else { return token::BINOP(op); }\n     }\n-    alt c {\n+    match c {\n \n \n \n@@ -539,12 +539,12 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n       }\n       '<' => {\n         bump(rdr);\n-        alt rdr.curr {\n+        match rdr.curr {\n           '=' => { bump(rdr); return token::LE; }\n           '<' => { return binop(rdr, token::SHL); }\n           '-' => {\n             bump(rdr);\n-            alt rdr.curr {\n+            match rdr.curr {\n               '>' => { bump(rdr); return token::DARROW; }\n               _ => { return token::LARROW; }\n             }\n@@ -554,7 +554,7 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n       }\n       '>' => {\n         bump(rdr);\n-        alt rdr.curr {\n+        match rdr.curr {\n           '=' => { bump(rdr); return token::GE; }\n           '>' => { return binop(rdr, token::SHR); }\n           _ => { return token::GT; }\n@@ -567,7 +567,7 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n         if c2 == '\\\\' {\n             let escaped = rdr.curr;\n             bump(rdr);\n-            alt escaped {\n+            match escaped {\n               'n' => { c2 = '\\n'; }\n               'r' => { c2 = '\\r'; }\n               't' => { c2 = '\\t'; }\n@@ -599,11 +599,11 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n \n             let ch = rdr.curr;\n             bump(rdr);\n-            alt ch {\n+            match ch {\n               '\\\\' => {\n                 let escaped = rdr.curr;\n                 bump(rdr);\n-                alt escaped {\n+                match escaped {\n                   'n' => str::push_char(accum_str, '\\n'),\n                   'r' => str::push_char(accum_str, '\\r'),\n                   't' => str::push_char(accum_str, '\\t'),\n@@ -646,7 +646,7 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n         } else { return binop(rdr, token::AND); }\n       }\n       '|' => {\n-        alt nextch(rdr) {\n+        match nextch(rdr) {\n           '|' => { bump(rdr); bump(rdr); return token::OROR; }\n           _ => { return binop(rdr, token::OR); }\n         }"}, {"sha": "7684c66c3649c8bb8077a999b1c0ebeca3e135dc", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -107,7 +107,7 @@ type item_info = (ident, item_, option<~[attribute]>);\n The important thing is to make sure that lookahead doesn't balk\n at INTERPOLATED tokens */\n macro_rules! maybe_whole_expr {\n-    {$p:expr} => { alt copy $p.token {\n+    {$p:expr} => { match copy $p.token {\n       INTERPOLATED(token::nt_expr(e)) => {\n         $p.bump();\n         return pexpr(e);\n@@ -122,19 +122,19 @@ macro_rules! maybe_whole_expr {\n }\n \n macro_rules! maybe_whole {\n-    {$p:expr, $constructor:ident} => { alt copy $p.token {\n+    {$p:expr, $constructor:ident} => { match copy $p.token {\n       INTERPOLATED(token::$constructor(x)) => { $p.bump(); return x; }\n       _ => ()\n     }} ;\n-    {deref $p:expr, $constructor:ident} => { alt copy $p.token {\n+    {deref $p:expr, $constructor:ident} => { match copy $p.token {\n       INTERPOLATED(token::$constructor(x)) => { $p.bump(); return *x; }\n       _ => ()\n     }} ;\n-    {some $p:expr, $constructor:ident} => { alt copy $p.token {\n+    {some $p:expr, $constructor:ident} => { match copy $p.token {\n       INTERPOLATED(token::$constructor(x)) => { $p.bump(); return some(x); }\n       _ => ()\n     }} ;\n-    {pair_empty $p:expr, $constructor:ident} => { alt copy $p.token {\n+    {pair_empty $p:expr, $constructor:ident} => { match copy $p.token {\n       INTERPOLATED(token::$constructor(x)) => { $p.bump(); return (~[], x); }\n       _ => ()\n     }}\n@@ -284,7 +284,7 @@ class parser {\n             debug!{\"parse_trait_methods(): trait method signature ends in \\\n                     `%s`\",\n                    token_to_str(p.reader, p.token)};\n-            alt p.token {\n+            match p.token {\n               token::SEMI => {\n                 p.bump();\n                 debug!{\"parse_trait_methods(): parsing required method\"};\n@@ -356,7 +356,7 @@ class parser {\n     }\n \n     fn region_from_name(s: option<@~str>) -> @region {\n-        let r = alt s {\n+        let r = match s {\n           some (string) => re_named(string),\n           none => re_anon\n         };\n@@ -368,7 +368,7 @@ class parser {\n     fn parse_region() -> @region {\n         self.expect(token::BINOP(token::AND));\n \n-        alt copy self.token {\n+        match copy self.token {\n           token::IDENT(sid, _) => {\n             self.bump();\n             let n = self.get_str(sid);\n@@ -383,7 +383,7 @@ class parser {\n     // Parses something like \"&x/\" (note the trailing slash)\n     fn parse_region_with_sep() -> @region {\n         let name =\n-            alt copy self.token {\n+            match copy self.token {\n               token::IDENT(sid, _) => {\n                 if self.look_ahead(1u) == token::BINOP(token::SLASH) {\n                     self.bump(); self.bump();\n@@ -402,7 +402,7 @@ class parser {\n \n         let lo = self.span.lo;\n \n-        alt self.maybe_parse_dollar_mac() {\n+        match self.maybe_parse_dollar_mac() {\n           some(e) => {\n             return @{id: self.get_id(),\n                   node: ty_mac(spanned(lo, self.span.hi, e)),\n@@ -471,7 +471,7 @@ class parser {\n \n         let sp = mk_sp(lo, self.last_span.hi);\n         return @{id: self.get_id(),\n-              node: alt self.maybe_parse_fixed_vstore() {\n+              node: match self.maybe_parse_fixed_vstore() {\n                 // Consider a fixed vstore suffix (/N or /_)\n                 none => t,\n                 some(v) => {\n@@ -542,11 +542,11 @@ class parser {\n     }\n \n     fn maybe_parse_dollar_mac() -> option<mac_> {\n-        alt copy self.token {\n+        match copy self.token {\n           token::DOLLAR => {\n             let lo = self.span.lo;\n             self.bump();\n-            alt copy self.token {\n+            match copy self.token {\n               token::LIT_INT_UNSUFFIXED(num) => {\n                 self.bump();\n                 some(mac_var(num as uint))\n@@ -570,7 +570,7 @@ class parser {\n     fn maybe_parse_fixed_vstore() -> option<option<uint>> {\n         if self.token == token::BINOP(token::SLASH) {\n             self.bump();\n-            alt copy self.token {\n+            match copy self.token {\n               token::UNDERSCORE => {\n                 self.bump(); some(none)\n               }\n@@ -585,7 +585,7 @@ class parser {\n     }\n \n     fn lit_from_token(tok: token::token) -> lit_ {\n-        alt tok {\n+        match tok {\n           token::LIT_INT(i, it) => lit_int(i, it),\n           token::LIT_UINT(u, ut) => lit_uint(u, ut),\n           token::LIT_INT_UNSUFFIXED(i) => lit_int_unsuffixed(i),\n@@ -733,7 +733,7 @@ class parser {\n     }\n \n     fn to_expr(e: pexpr) -> @expr {\n-        alt e.node {\n+        match e.node {\n           expr_tup(es) if vec::len(es) == 1u => es[0u],\n           _ => *e\n         }\n@@ -746,7 +746,7 @@ class parser {\n \n         let mut ex: expr_;\n \n-        alt self.maybe_parse_dollar_mac() {\n+        match self.maybe_parse_dollar_mac() {\n           some(x) => return pexpr(self.mk_mac_expr(lo, self.span.hi, x)),\n           _ => ()\n         }\n@@ -794,11 +794,11 @@ class parser {\n             return pexpr(self.parse_while_expr());\n         } else if self.eat_keyword(~\"loop\") {\n             return pexpr(self.parse_loop_expr());\n-        } else if self.eat_keyword(~\"alt\") || self.eat_keyword(~\"match\") {\n+        } else if self.eat_keyword(~\"match\") {\n             return pexpr(self.parse_alt_expr());\n         } else if self.eat_keyword(~\"fn\") {\n             let proto = self.parse_fn_ty_proto();\n-            alt proto {\n+            match proto {\n               proto_bare => self.fatal(~\"fn expr are deprecated, use fn@\"),\n               _ => { /* fallthrough */ }\n             }\n@@ -893,7 +893,7 @@ class parser {\n             /* `!`, as an operator, is prefix, so we know this isn't that */\n             if self.token == token::NOT {\n                 self.bump();\n-                let tts = alt self.token {\n+                let tts = match self.token {\n                   token::LPAREN | token::LBRACE | token::LBRACKET => {\n                     let ket = token::flip_delimiter(self.token);\n                     self.parse_unspanned_seq(copy self.token, ket,\n@@ -948,9 +948,9 @@ class parser {\n \n         // Vstore is legal following expr_lit(lit_str(...)) and expr_vec(...)\n         // only.\n-        alt ex {\n+        match ex {\n           expr_lit(@{node: lit_str(_), span: _}) |\n-          expr_vec(_, _)  => alt self.maybe_parse_fixed_vstore() {\n+          expr_vec(_, _)  => match self.maybe_parse_fixed_vstore() {\n             none => (),\n             some(v) => {\n                 hi = self.span.hi;\n@@ -976,7 +976,7 @@ class parser {\n     }\n \n     fn parse_syntax_ext_naked(lo: uint) -> @expr {\n-        alt self.token {\n+        match self.token {\n           token::IDENT(_, _) => (),\n           _ => self.fatal(~\"expected a syntax expander name\")\n         }\n@@ -1003,7 +1003,7 @@ class parser {\n             let lo = self.span.lo;\n             let mut depth = 1u;\n             while (depth > 0u) {\n-                alt (self.token) {\n+                match (self.token) {\n                   token::LBRACE => depth += 1u,\n                   token::RBRACE => depth -= 1u,\n                   token::EOF => self.fatal(~\"unexpected EOF in macro body\"),\n@@ -1033,7 +1033,7 @@ class parser {\n         loop {\n             // expr.f\n             if self.eat(token::DOT) {\n-                alt copy self.token {\n+                match copy self.token {\n                   token::IDENT(i, _) => {\n                     hi = self.span.hi;\n                     self.bump();\n@@ -1051,7 +1051,7 @@ class parser {\n                 again;\n             }\n             if self.expr_is_complete(e) { break; }\n-            alt copy self.token {\n+            match copy self.token {\n               // expr(...)\n               token::LPAREN if self.permits_call() => {\n                 let es = self.parse_unspanned_seq(\n@@ -1103,7 +1103,7 @@ class parser {\n         maybe_whole!{deref self, nt_tt};\n \n         fn parse_tt_tok(p: parser, delim_ok: bool) -> token_tree {\n-            alt p.token {\n+            match p.token {\n               token::RPAREN | token::RBRACE | token::RBRACKET\n               if !delim_ok => {\n                 p.fatal(~\"incorrect close delimiter: `\"\n@@ -1134,7 +1134,7 @@ class parser {\n             return res;\n         }\n \n-        return alt self.token {\n+        return match self.token {\n           token::LPAREN | token::LBRACE | token::LBRACKET => {\n             let ket = token::flip_delimiter(self.token);\n             tt_delim(vec::append(\n@@ -1154,7 +1154,7 @@ class parser {\n         // the interpolation of matchers\n         maybe_whole!{self, nt_matchers};\n         let name_idx = @mut 0u;\n-        return alt self.token {\n+        return match self.token {\n           token::LBRACE | token::LPAREN | token::LBRACKET => {\n             self.parse_matcher_subseq(name_idx, copy self.token,\n                                       token::flip_delimiter(self.token))\n@@ -1222,7 +1222,7 @@ class parser {\n         let mut hi;\n \n         let mut ex;\n-        alt copy self.token {\n+        match copy self.token {\n           token::NOT => {\n             self.bump();\n             let e = self.to_expr(self.parse_prefix_expr());\n@@ -1231,7 +1231,7 @@ class parser {\n             ex = expr_unary(not, e);\n           }\n           token::BINOP(b) => {\n-            alt b {\n+            match b {\n               token::MINUS => {\n                 self.bump();\n                 let e = self.to_expr(self.parse_prefix_expr());\n@@ -1251,7 +1251,7 @@ class parser {\n                 let e = self.to_expr(self.parse_prefix_expr());\n                 hi = e.span.hi;\n                 // HACK: turn &[...] into a &-evec\n-                ex = alt e.node {\n+                ex = match e.node {\n                   expr_vec(*) | expr_lit(@{node: lit_str(_), span: _})\n                   if m == m_imm => {\n                     expr_vstore(e, vstore_slice(self.region_from_name(none)))\n@@ -1268,7 +1268,7 @@ class parser {\n             let e = self.to_expr(self.parse_prefix_expr());\n             hi = e.span.hi;\n             // HACK: turn @[...] into a @-evec\n-            ex = alt e.node {\n+            ex = match e.node {\n               expr_vec(*) | expr_lit(@{node: lit_str(_), span: _})\n               if m == m_imm => expr_vstore(e, vstore_box),\n               _ => expr_unary(box(m), e)\n@@ -1280,7 +1280,7 @@ class parser {\n             let e = self.to_expr(self.parse_prefix_expr());\n             hi = e.span.hi;\n             // HACK: turn ~[...] into a ~-evec\n-            ex = alt e.node {\n+            ex = match e.node {\n               expr_vec(*) | expr_lit(@{node: lit_str(_), span: _})\n               if m == m_imm => expr_vstore(e, vstore_uniq),\n               _ => expr_unary(uniq(m), e)\n@@ -1311,7 +1311,7 @@ class parser {\n             return lhs;\n         }\n         let cur_opt   = token_to_binop(peeked);\n-        alt cur_opt {\n+        match cur_opt {\n           some(cur_op) => {\n             let cur_prec = operator_prec(cur_op);\n             if cur_prec > min_prec {\n@@ -1338,7 +1338,7 @@ class parser {\n     fn parse_assign_expr() -> @expr {\n         let lo = self.span.lo;\n         let lhs = self.parse_binops();\n-        alt copy self.token {\n+        match copy self.token {\n           token::EQ => {\n             self.bump();\n             let rhs = self.parse_expr();\n@@ -1348,7 +1348,7 @@ class parser {\n             self.bump();\n             let rhs = self.parse_expr();\n             let mut aop;\n-            alt op {\n+            match op {\n               token::PLUS => aop = add,\n               token::MINUS => aop = subtract,\n               token::STAR => aop = mul,\n@@ -1412,7 +1412,7 @@ class parser {\n     fn parse_lambda_block_expr() -> @expr {\n         self.parse_lambda_expr_(\n             || {\n-                alt self.token {\n+                match self.token {\n                   token::BINOP(token::OR) | token::OROR => {\n                     self.parse_fn_block_decl()\n                   }\n@@ -1481,7 +1481,7 @@ class parser {\n         // Turn on the restriction to stop at | or || so we can parse\n         // them as the lambda arguments\n         let e = self.parse_expr_res(RESTRICT_NO_BAR_OR_DOUBLEBAR_OP);\n-        alt e.node {\n+        match e.node {\n           expr_call(f, args, false) => {\n             let block = self.parse_lambda_block_expr();\n             let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n@@ -1608,7 +1608,7 @@ class parser {\n     }\n \n     fn parse_initializer() -> option<initializer> {\n-        alt self.token {\n+        match self.token {\n           token::EQ => {\n             self.bump();\n             return some({op: init_assign, expr: self.parse_expr()});\n@@ -1645,14 +1645,14 @@ class parser {\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n         let mut pat;\n-        alt self.token {\n+        match self.token {\n           token::UNDERSCORE => { self.bump(); pat = pat_wild; }\n           token::AT => {\n             self.bump();\n             let sub = self.parse_pat(refutable);\n             hi = sub.span.hi;\n             // HACK: parse @\"...\" as a literal of a vstore @str\n-            pat = alt sub.node {\n+            pat = match sub.node {\n               pat_lit(e@@{\n                 node: expr_lit(@{node: lit_str(_), span: _}), _\n               }) => {\n@@ -1669,7 +1669,7 @@ class parser {\n             let sub = self.parse_pat(refutable);\n             hi = sub.span.hi;\n             // HACK: parse ~\"...\" as a literal of a vstore ~str\n-            pat = alt sub.node {\n+            pat = match sub.node {\n               pat_lit(e@@{\n                 node: expr_lit(@{node: lit_str(_), span: _}), _\n               }) => {\n@@ -1775,7 +1775,7 @@ class parser {\n                 }\n \n                 if is_plain_ident(self.token) &&\n-                    alt self.look_ahead(1) {\n+                    match self.look_ahead(1) {\n                       token::LPAREN | token::LBRACKET | token::LT => {\n                         false\n                       }\n@@ -1794,8 +1794,8 @@ class parser {\n                     hi = enum_path.span.hi;\n                     let mut args: ~[@pat] = ~[];\n                     let mut star_pat = false;\n-                    alt self.token {\n-                      token::LPAREN => alt self.look_ahead(1u) {\n+                    match self.token {\n+                      token::LPAREN => match self.look_ahead(1u) {\n                         token::BINOP(token::STAR) => {\n                             // This is a \"top constructor only\" pat\n                               self.bump(); self.bump();\n@@ -1890,7 +1890,7 @@ class parser {\n             return @spanned(lo, decl.span.hi, stmt_decl(decl, self.get_id()));\n         } else {\n             let mut item_attrs;\n-            alt self.parse_outer_attrs_or_ext(first_item_attrs) {\n+            match self.parse_outer_attrs_or_ext(first_item_attrs) {\n               none => item_attrs = ~[],\n               some(left(attrs)) => item_attrs = attrs,\n               some(right(ext)) => {\n@@ -1901,7 +1901,7 @@ class parser {\n \n             let item_attrs = vec::append(first_item_attrs, item_attrs);\n \n-            alt self.parse_item(item_attrs) {\n+            match self.parse_item(item_attrs) {\n               some(i) => {\n                 let mut hi = i.span.hi;\n                 let decl = @spanned(lo, hi, decl_item(i));\n@@ -1993,16 +1993,16 @@ class parser {\n         }\n \n         while self.token != token::RBRACE {\n-            alt self.token {\n+            match self.token {\n               token::SEMI => {\n                 self.bump(); // empty\n               }\n               _ => {\n                 let stmt = self.parse_stmt(initial_attrs);\n                 initial_attrs = ~[];\n-                alt stmt.node {\n+                match stmt.node {\n                   stmt_expr(e, stmt_id) => { // Expression without semicolon:\n-                    alt self.token {\n+                    match self.token {\n                       token::SEMI => {\n                         self.bump();\n                         push(stmts,\n@@ -2086,7 +2086,7 @@ class parser {\n     }\n \n     fn is_self_ident() -> bool {\n-        alt self.token {\n+        match self.token {\n             token::IDENT(sid, false) if ~\"self\" == *self.get_str(sid) => true,\n             _ => false\n         }\n@@ -2111,7 +2111,7 @@ class parser {\n         // backwards compatible.\n         let lo = self.span.lo;\n         let self_ty;\n-        alt copy self.token {\n+        match copy self.token {\n             token::BINOP(token::AND) => {\n                 // We need to make sure it isn't a mode.\n                 self.bump();\n@@ -2126,10 +2126,10 @@ class parser {\n \n                     // Parse an explicit region, if possible.\n                     let region_name;\n-                    alt copy self.token {\n+                    match copy self.token {\n                         token::BINOP(token::SLASH) => {\n                             self.bump();\n-                            alt copy self.token {\n+                            match copy self.token {\n                                 token::IDENT(sid, false) => {\n                                     self.bump();\n                                     region_name = some(self.get_str(sid));\n@@ -2174,7 +2174,7 @@ class parser {\n         // If we parsed a self type, expect a comma before the argument list.\n         let args_or_capture_items;\n         if self_ty != sty_by_ref {\n-            alt copy self.token {\n+            match copy self.token {\n                 token::COMMA => {\n                     self.bump();\n                     let sep = seq_sep_trailing_disallowed(token::COMMA);\n@@ -2265,7 +2265,7 @@ class parser {\n     }\n \n     fn parse_method_name() -> ident {\n-        alt copy self.token {\n+        match copy self.token {\n           token::BINOP(op) => { self.bump(); @token::binop_to_str(op) }\n           token::NOT => { self.bump(); @~\"!\" }\n           token::LBRACKET => {\n@@ -2387,7 +2387,7 @@ class parser {\n             } else {\n                 traits = ~[];\n             };\n-            ident = alt ident_old {\n+            ident = match ident_old {\n               some(name) => name,\n               none => { self.expect_keyword(~\"of\"); fail; }\n             };\n@@ -2445,7 +2445,7 @@ class parser {\n                                    codemap::span)> = none;\n         let mut the_dtor : option<(blk, ~[attribute], codemap::span)> = none;\n         while self.token != token::RBRACE {\n-            alt self.parse_class_item(class_path) {\n+            match self.parse_class_item(class_path) {\n               ctor_decl(a_fn_decl, attrs, blk, s) => {\n                 the_ctor = some((a_fn_decl, attrs, blk, s));\n               }\n@@ -2463,7 +2463,7 @@ class parser {\n                     body: d_body},\n              span: d_s}};\n         self.bump();\n-        alt the_ctor {\n+        match the_ctor {\n           some((ct_d, ct_attrs, ct_b, ct_s)) => {\n             (class_name,\n              item_class(ty_params, traits, ms, some({\n@@ -2487,7 +2487,7 @@ class parser {\n     }\n \n     fn token_is_pound_or_doc_comment(++tok: token::token) -> bool {\n-        alt tok {\n+        match tok {\n             token::POUND | token::DOC_COMMENT(_) => true,\n             _ => false\n         }\n@@ -2582,7 +2582,7 @@ class parser {\n                 first = false;\n             }\n             debug!{\"parse_mod_items: parse_item(attrs=%?)\", attrs};\n-            alt self.parse_item(attrs) {\n+            match self.parse_item(attrs) {\n               some(i) => vec::push(items, i),\n               _ => {\n                 self.fatal(~\"expected item but found `\" +\n@@ -2764,7 +2764,7 @@ class parser {\n     }\n \n     fn parse_fn_ty_proto() -> proto {\n-        alt self.token {\n+        match self.token {\n           token::AT => {\n             self.bump();\n             proto_box\n@@ -2784,7 +2784,7 @@ class parser {\n     }\n \n     fn fn_expr_lookahead(tok: token::token) -> bool {\n-        alt tok {\n+        match tok {\n           token::LPAREN | token::AT | token::TILDE | token::BINOP(_) => true,\n           _ => false\n         }\n@@ -2846,7 +2846,7 @@ class parser {\n             let pth = self.parse_path_without_tps();\n             self.expect(token::NOT);\n             let id = self.parse_ident();\n-            let tts = alt self.token {\n+            let tts = match self.token {\n               token::LPAREN | token::LBRACE | token::LBRACKET => {\n                 let ket = token::flip_delimiter(self.token);\n                 self.parse_unspanned_seq(copy self.token, ket,\n@@ -2863,7 +2863,7 @@ class parser {\n             (id, item_mac(m), none)\n         } else { return none; };\n         some(self.mk_item(lo, self.last_span.hi, ident, item_, visibility,\n-                          alt extra_attrs {\n+                          match extra_attrs {\n                               some(as) => vec::append(attrs, as),\n                               none => attrs\n                           }))\n@@ -2880,7 +2880,7 @@ class parser {\n         let first_ident = self.parse_ident();\n         let mut path = ~[first_ident];\n         debug!{\"parsed view_path: %s\", *first_ident};\n-        alt self.token {\n+        match self.token {\n           token::EQ => {\n             // x = foo::bar\n             self.bump();\n@@ -2901,7 +2901,7 @@ class parser {\n             while self.token == token::MOD_SEP {\n                 self.bump();\n \n-                alt copy self.token {\n+                match copy self.token {\n \n                   token::IDENT(i, _) => {\n                     self.bump();\n@@ -3004,7 +3004,7 @@ class parser {\n     }\n \n     fn parse_str() -> @~str {\n-        alt copy self.token {\n+        match copy self.token {\n           token::LIT_STR(s) => { self.bump(); self.get_str(s) }\n           _ => self.fatal(~\"expected string literal\")\n         }\n@@ -3035,7 +3035,7 @@ class parser {\n                 self.expect_keyword(~\"module\");\n             }\n             let id = self.parse_ident();\n-            alt self.token {\n+            match self.token {\n               // mod x = \"foo.rs\";\n               token::SEMI => {\n                 let mut hi = self.span.hi;"}, {"sha": "bd9ada9a3384370675e73cf6032171509d2d8cab", "filename": "src/libsyntax/parse/prec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fparse%2Fprec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fparse%2Fprec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fprec.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -20,7 +20,7 @@ const as_prec: uint = 11u;\n  * operator and its precedence\n  */\n fn token_to_binop(tok: token) -> option<ast::binop> {\n-  alt tok {\n+  match tok {\n       BINOP(STAR)    => some(mul),\n       BINOP(SLASH)   => some(div),\n       BINOP(PERCENT) => some(rem),"}, {"sha": "a99d071b6ef74055361847bc63c8182bb094d693", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -102,7 +102,7 @@ enum nonterminal {\n }\n \n fn binop_to_str(o: binop) -> ~str {\n-    alt o {\n+    match o {\n       PLUS => ~\"+\",\n       MINUS => ~\"-\",\n       STAR => ~\"*\",\n@@ -117,7 +117,7 @@ fn binop_to_str(o: binop) -> ~str {\n }\n \n fn to_str(in: interner<@~str>, t: token) -> ~str {\n-    alt t {\n+    match t {\n       EQ => ~\"=\",\n       LT => ~\"<\",\n       LE => ~\"<=\",\n@@ -186,7 +186,7 @@ fn to_str(in: interner<@~str>, t: token) -> ~str {\n       EOF => ~\"<eof>\",\n       INTERPOLATED(nt) => {\n         ~\"an interpolated \" +\n-            alt nt {\n+            match nt {\n               nt_item(*) => ~\"item\",\n               nt_block(*) => ~\"block\",\n               nt_stmt(*) => ~\"statement\",\n@@ -203,7 +203,7 @@ fn to_str(in: interner<@~str>, t: token) -> ~str {\n }\n \n pure fn can_begin_expr(t: token) -> bool {\n-    alt t {\n+    match t {\n       LPAREN => true,\n       LBRACE => true,\n       LBRACKET => true,\n@@ -234,7 +234,7 @@ pure fn can_begin_expr(t: token) -> bool {\n \n /// what's the opposite delimiter?\n fn flip_delimiter(&t: token::token) -> token::token {\n-    alt t {\n+    match t {\n       token::LPAREN => token::RPAREN,\n       token::LBRACE => token::RBRACE,\n       token::LBRACKET => token::RBRACKET,\n@@ -248,7 +248,7 @@ fn flip_delimiter(&t: token::token) -> token::token {\n \n \n fn is_lit(t: token) -> bool {\n-    alt t {\n+    match t {\n       LIT_INT(_, _) => true,\n       LIT_UINT(_, _) => true,\n       LIT_INT_UNSUFFIXED(_) => true,\n@@ -259,22 +259,22 @@ fn is_lit(t: token) -> bool {\n }\n \n pure fn is_ident(t: token) -> bool {\n-    alt t { IDENT(_, _) => true, _ => false }\n+    match t { IDENT(_, _) => true, _ => false }\n }\n \n pure fn is_ident_or_path(t: token) -> bool {\n-    alt t {\n+    match t {\n       IDENT(_, _) | INTERPOLATED(nt_path(*)) => true,\n       _ => false\n     }\n }\n \n pure fn is_plain_ident(t: token) -> bool {\n-    alt t { IDENT(_, false) => true, _ => false }\n+    match t { IDENT(_, false) => true, _ => false }\n }\n \n pure fn is_bar(t: token) -> bool {\n-    alt t { BINOP(OR) | OROR => true, _ => false }\n+    match t { BINOP(OR) | OROR => true, _ => false }\n }\n \n /**\n@@ -333,7 +333,7 @@ fn contextual_keyword_table() -> hashmap<~str, ()> {\n fn restricted_keyword_table() -> hashmap<~str, ()> {\n     let words = str_hash();\n     let keys = ~[\n-        ~\"alt\", ~\"again\", ~\"assert\",\n+        ~\"again\", ~\"assert\",\n         ~\"break\",\n         ~\"check\", ~\"class\", ~\"const\", ~\"copy\",\n         ~\"do\", ~\"drop\","}, {"sha": "a8f9cf756a816237a87090f129e6355a8771d907", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -62,7 +62,7 @@ type begin_t = {offset: int, breaks: breaks};\n enum token { STRING(@~str, int), BREAK(break_t), BEGIN(begin_t), END, EOF, }\n \n fn tok_str(++t: token) -> ~str {\n-    alt t {\n+    match t {\n       STRING(s, len) => return fmt!{\"STR(%s,%d)\", *s, len},\n       BREAK(_) => return ~\"BREAK\",\n       BEGIN(_) => return ~\"BEGIN\",\n@@ -238,7 +238,7 @@ impl printer for printer {\n     fn replace_last_token(t: token) { self.token[self.right] = t; }\n     fn pretty_print(t: token) {\n         debug!{\"pp ~[%u,%u]\", self.left, self.right};\n-        alt t {\n+        match t {\n           EOF => {\n             if !self.scan_stack_empty {\n                 self.check_stack(0);\n@@ -357,7 +357,7 @@ impl printer for printer {\n                self.left, L};\n         if L >= 0 {\n             self.print(x, L);\n-            alt x {\n+            match x {\n               BREAK(b) => self.left_total += b.blank_space,\n               STRING(_, len) => { assert (len == L); self.left_total += len; }\n               _ => ()\n@@ -373,7 +373,7 @@ impl printer for printer {\n     fn check_stack(k: int) {\n         if !self.scan_stack_empty {\n             let x = self.scan_top();\n-            alt copy self.token[x] {\n+            match copy self.token[x] {\n               BEGIN(b) => {\n                 if k > 0 {\n                     self.size[self.scan_pop()] = self.size[x] +\n@@ -422,7 +422,7 @@ impl printer for printer {\n         debug!{\"print %s %d (remaining line space=%d)\", tok_str(x), L,\n                self.space};\n         log(debug, buf_str(self.token, self.size, self.left, self.right, 6u));\n-        alt x {\n+        match x {\n           BEGIN(b) => {\n             if L > self.space {\n                 let col = self.margin - self.space + b.offset;\n@@ -442,7 +442,7 @@ impl printer for printer {\n           }\n           BREAK(b) => {\n             let top = self.get_top();\n-            alt top.pbreak {\n+            match top.pbreak {\n               fits => {\n                 debug!{\"print BREAK in fitting block\"};\n                 self.space -= b.blank_space;"}, {"sha": "e968fb92ad6498e636323a1a56e87edcc6fc0f48", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -222,11 +222,11 @@ fn bclose_(s: ps, span: codemap::span, indented: uint) {\n fn bclose(s: ps, span: codemap::span) { bclose_(s, span, indent_unit); }\n \n fn is_begin(s: ps) -> bool {\n-    alt s.s.last_token() { pp::BEGIN(_) => true, _ => false }\n+    match s.s.last_token() { pp::BEGIN(_) => true, _ => false }\n }\n \n fn is_end(s: ps) -> bool {\n-    alt s.s.last_token() { pp::END => true, _ => false }\n+    match s.s.last_token() { pp::END => true, _ => false }\n }\n \n fn is_bol(s: ps) -> bool {\n@@ -318,7 +318,7 @@ fn print_foreign_mod(s: ps, nmod: ast::foreign_mod,\n }\n \n fn print_region(s: ps, region: @ast::region) {\n-    alt region.node {\n+    match region.node {\n       ast::re_anon => word_space(s, ~\"&\"),\n       ast::re_named(name) => {\n         word(s.s, ~\"&\");\n@@ -334,14 +334,14 @@ fn print_type(s: ps, &&ty: @ast::ty) {\n fn print_type_ex(s: ps, &&ty: @ast::ty, print_colons: bool) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n-    alt ty.node {\n+    match ty.node {\n       ast::ty_nil => word(s.s, ~\"()\"),\n       ast::ty_bot => word(s.s, ~\"!\"),\n       ast::ty_box(mt) => { word(s.s, ~\"@\"); print_mt(s, mt); }\n       ast::ty_uniq(mt) => { word(s.s, ~\"~\"); print_mt(s, mt); }\n       ast::ty_vec(mt) => {\n         word(s.s, ~\"[\");\n-        alt mt.mutbl {\n+        match mt.mutbl {\n           ast::m_mutbl => word_space(s, ~\"mut\"),\n           ast::m_const => word_space(s, ~\"const\"),\n           ast::m_imm => ()\n@@ -351,7 +351,7 @@ fn print_type_ex(s: ps, &&ty: @ast::ty, print_colons: bool) {\n       }\n       ast::ty_ptr(mt) => { word(s.s, ~\"*\"); print_mt(s, mt); }\n       ast::ty_rptr(region, mt) => {\n-        alt region.node {\n+        match region.node {\n           ast::re_anon => word(s.s, ~\"&\"),\n           _ => { print_region(s, region); word(s.s, ~\"/\"); }\n         }\n@@ -400,7 +400,7 @@ fn print_foreign_item(s: ps, item: @ast::foreign_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n-    alt item.node {\n+    match item.node {\n       ast::foreign_item_fn(decl, typarams) => {\n         print_fn(s, decl, item.ident, typarams);\n         end(s); // end head-ibox\n@@ -416,7 +416,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n     print_outer_attributes(s, item.attrs);\n     let ann_node = node_item(s, item);\n     s.ann.pre(ann_node);\n-    alt item.node {\n+    match item.node {\n       ast::item_const(ty, expr) => {\n         head(s, ~\"const\");\n         word_space(s, *item.ident + ~\":\");\n@@ -538,18 +538,18 @@ fn print_item(s: ps, &&item: @ast::item) {\n              hardbreak_if_not_bol(s);\n              maybe_print_comment(s, ci.span.lo);\n              let pr = ast_util::class_member_visibility(ci);\n-             alt pr {\n+             match pr {\n                 ast::private => {\n                     head(s, ~\"priv\");\n                     bopen(s);\n                     hardbreak_if_not_bol(s);\n                 }\n                 _ => ()\n              }\n-             alt ci.node {\n+             match ci.node {\n                 ast::instance_var(nm, t, mt, _,_) => {\n                     word_nbsp(s, ~\"let\");\n-                    alt mt {\n+                    match mt {\n                       ast::class_mutable => word_nbsp(s, ~\"mut\"),\n                       _ => ()\n                     }\n@@ -562,7 +562,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n                     print_method(s, m);\n                 }\n              }\n-             alt pr {\n+             match pr {\n                  ast::private => bclose(s, ci.span),\n                  _ => ()\n              }\n@@ -625,10 +625,10 @@ fn print_item(s: ps, &&item: @ast::item) {\n /// and then pretty-print the resulting AST nodes (so, e.g., we print\n /// expression arguments as expressions). It can be done! I think.\n fn print_tt(s: ps, tt: ast::token_tree) {\n-    alt tt {\n+    match tt {\n       ast::tt_delim(tts) => for tts.each() |tt_elt| { print_tt(s, tt_elt); }\n       ast::tt_tok(_, tk) => {\n-        alt tk {\n+        match tk {\n           parse::token::IDENT(*) => { // don't let idents run together\n             if s.s.token_tree_last_was_ident { word(s.s, ~\" \") }\n             s.s.token_tree_last_was_ident = true;\n@@ -641,7 +641,7 @@ fn print_tt(s: ps, tt: ast::token_tree) {\n         word(s.s, ~\"$(\");\n         for tts.each() |tt_elt| { print_tt(s, tt_elt); }\n         word(s.s, ~\")\");\n-        alt sep {\n+        match sep {\n           some(tk) => word(s.s, parse::token::to_str(*s.intr, tk)),\n           none => ()\n         }\n@@ -665,7 +665,7 @@ fn print_variant(s: ps, v: ast::variant) {\n         commasep(s, consistent, v.node.args, print_variant_arg);\n         pclose(s);\n     }\n-    alt v.node.disr_expr {\n+    match v.node.disr_expr {\n       some(d) => {\n         space(s.s);\n         word_space(s, ~\"=\");\n@@ -684,7 +684,7 @@ fn print_ty_method(s: ps, m: ast::ty_method) {\n }\n \n fn print_trait_method(s: ps, m: ast::trait_method) {\n-    alt m {\n+    match m {\n       required(ty_m) => print_ty_method(s, ty_m),\n       provided(m)    => print_method(s, m)\n     }\n@@ -702,7 +702,7 @@ fn print_method(s: ps, meth: @ast::method) {\n fn print_outer_attributes(s: ps, attrs: ~[ast::attribute]) {\n     let mut count = 0;\n     for attrs.each |attr| {\n-        alt attr.node.style {\n+        match attr.node.style {\n           ast::attr_outer => { print_attribute(s, attr); count += 1; }\n           _ => {/* fallthrough */ }\n         }\n@@ -713,7 +713,7 @@ fn print_outer_attributes(s: ps, attrs: ~[ast::attribute]) {\n fn print_inner_attributes(s: ps, attrs: ~[ast::attribute]) {\n     let mut count = 0;\n     for attrs.each |attr| {\n-        alt attr.node.style {\n+        match attr.node.style {\n           ast::attr_inner => {\n             print_attribute(s, attr);\n             if !attr.node.is_sugared_doc {\n@@ -744,7 +744,7 @@ fn print_attribute(s: ps, attr: ast::attribute) {\n \n fn print_stmt(s: ps, st: ast::stmt) {\n     maybe_print_comment(s, st.span.lo);\n-    alt st.node {\n+    match st.node {\n       ast::stmt_decl(decl, _) => {\n         print_decl(s, decl);\n       }\n@@ -780,15 +780,15 @@ fn print_possibly_embedded_block(s: ps, blk: ast::blk, embedded: embed_type,\n \n fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n                                   indented: uint, attrs: ~[ast::attribute]) {\n-    alt blk.node.rules {\n+    match blk.node.rules {\n       ast::unchecked_blk => word(s.s, ~\"unchecked\"),\n       ast::unsafe_blk => word(s.s, ~\"unsafe\"),\n       ast::default_blk => ()\n     }\n     maybe_print_comment(s, blk.span.lo);\n     let ann_node = node_block(s, blk);\n     s.ann.pre(ann_node);\n-    alt embedded {\n+    match embedded {\n       block_block_fn => end(s),\n       block_normal => bopen(s)\n     }\n@@ -799,7 +799,7 @@ fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n     for blk.node.stmts.each |st| {\n         print_stmt(s, *st);\n     }\n-    alt blk.node.expr {\n+    match blk.node.expr {\n       some(expr) => {\n         space_if_not_bol(s);\n         print_expr(s, expr);\n@@ -814,7 +814,7 @@ fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n // return and fail, without arguments cannot appear is the discriminant of if,\n // alt, do, & while unambiguously without being parenthesized\n fn print_maybe_parens_discrim(s: ps, e: @ast::expr) {\n-    let disambig = alt e.node {\n+    let disambig = match e.node {\n       ast::expr_ret(none) | ast::expr_fail(none) => true,\n       _ => false\n     };\n@@ -831,9 +831,9 @@ fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n     space(s.s);\n     print_block(s, blk);\n     fn do_else(s: ps, els: option<@ast::expr>) {\n-        alt els {\n+        match els {\n           some(_else) => {\n-            alt _else.node {\n+            match _else.node {\n               // \"another else-if\"\n               ast::expr_if(i, t, e) => {\n                 cbox(s, indent_unit - 1u);\n@@ -864,11 +864,11 @@ fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n }\n \n fn print_mac(s: ps, m: ast::mac) {\n-    alt m.node {\n+    match m.node {\n       ast::mac_invoc(path, arg, body) => {\n         word(s.s, ~\"#\");\n         print_path(s, path, false);\n-        alt arg {\n+        match arg {\n           some(@{node: ast::expr_vec(_, _), _}) => (),\n           _ => word(s.s, ~\" \")\n         }\n@@ -888,12 +888,12 @@ fn print_mac(s: ps, m: ast::mac) {\n }\n \n fn print_vstore(s: ps, t: ast::vstore) {\n-    alt t {\n+    match t {\n       ast::vstore_fixed(some(i)) => word(s.s, fmt!{\"%u\", i}),\n       ast::vstore_fixed(none) => word(s.s, ~\"_\"),\n       ast::vstore_uniq => word(s.s, ~\"~\"),\n       ast::vstore_box => word(s.s, ~\"@\"),\n-      ast::vstore_slice(r) => alt r.node {\n+      ast::vstore_slice(r) => match r.node {\n         ast::re_anon => word(s.s, ~\"&\"),\n         ast::re_named(name) => {\n             word(s.s, ~\"&\");\n@@ -919,8 +919,8 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n     ibox(s, indent_unit);\n     let ann_node = node_expr(s, expr);\n     s.ann.pre(ann_node);\n-    alt expr.node {\n-      ast::expr_vstore(e, v) => alt v {\n+    match expr.node {\n+      ast::expr_vstore(e, v) => match v {\n         ast::vstore_fixed(_) => {\n             print_expr(s, e);\n               word(s.s, ~\"/\");\n@@ -961,7 +961,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       ast::expr_rec(fields, wth) => {\n         word(s.s, ~\"{\");\n         commasep_cmnt(s, consistent, fields, print_field, get_span);\n-        alt wth {\n+        match wth {\n           some(expr) => {\n             if vec::len(fields) > 0u { space(s.s); }\n             ibox(s, indent_unit);\n@@ -977,7 +977,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         print_path(s, path, true);\n         word(s.s, ~\"{\");\n         commasep_cmnt(s, consistent, fields, print_field, get_span);\n-        alt wth {\n+        match wth {\n             some(expr) => {\n                 if vec::len(fields) > 0u { space(s.s); }\n                 ibox(s, indent_unit);\n@@ -998,7 +998,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         let mut base_args = args;\n         let blk = if has_block {\n             let blk_arg = vec::pop(base_args);\n-            alt blk_arg.node {\n+            match blk_arg.node {\n               ast::expr_loop_body(_) => word_nbsp(s, ~\"for\"),\n               ast::expr_do_body(_) => word_nbsp(s, ~\"do\"),\n               _ => ()\n@@ -1056,7 +1056,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       ast::expr_alt(expr, arms, mode) => {\n         cbox(s, alt_indent_unit);\n         ibox(s, 4u);\n-        word_nbsp(s, ~\"alt\");\n+        word_nbsp(s, ~\"match\");\n         if mode == ast::alt_check { word_nbsp(s, ~\"check\"); }\n         print_maybe_parens_discrim(s, expr);\n         space(s.s);\n@@ -1074,7 +1074,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n                 print_pat(s, p);\n             }\n             space(s.s);\n-            alt arm.guard {\n+            match arm.guard {\n               some(e) => {\n                 word_space(s, ~\"if\");\n                 print_expr(s, e);\n@@ -1087,7 +1087,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n             assert arm.body.node.view_items.is_empty();\n             assert arm.body.node.stmts.is_empty();\n             assert arm.body.node.rules == ast::default_blk;\n-            alt arm.body.node.expr {\n+            match arm.body.node.expr {\n               some(expr) => {\n                 end(s); // close the ibox for the pattern\n                 print_expr(s, expr);\n@@ -1185,7 +1185,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       ast::expr_path(path) => print_path(s, path, true),\n       ast::expr_fail(maybe_fail_val) => {\n         word(s.s, ~\"fail\");\n-        alt maybe_fail_val {\n+        match maybe_fail_val {\n           some(expr) => { word(s.s, ~\" \"); print_expr(s, expr); }\n           _ => ()\n         }\n@@ -1194,13 +1194,13 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       ast::expr_again => word(s.s, ~\"again\"),\n       ast::expr_ret(result) => {\n         word(s.s, ~\"return\");\n-        alt result {\n+        match result {\n           some(expr) => { word(s.s, ~\" \"); print_expr(s, expr); }\n           _ => ()\n         }\n       }\n       ast::expr_log(lvl, lexp, expr) => {\n-        alt check lvl {\n+        match check lvl {\n           1 => { word_nbsp(s, ~\"log\"); print_expr(s, expr); }\n           0 => { word_nbsp(s, ~\"log_err\"); print_expr(s, expr); }\n           2 => {\n@@ -1225,7 +1225,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n }\n \n fn print_expr_parens_if_not_bot(s: ps, ex: @ast::expr) {\n-    let parens = alt ex.node {\n+    let parens = match ex.node {\n       ast::expr_fail(_) | ast::expr_ret(_) |\n       ast::expr_binary(_, _, _) | ast::expr_unary(_, _) |\n       ast::expr_move(_, _) | ast::expr_copy(_) |\n@@ -1243,15 +1243,15 @@ fn print_expr_parens_if_not_bot(s: ps, ex: @ast::expr) {\n \n fn print_local_decl(s: ps, loc: @ast::local) {\n     print_pat(s, loc.node.pat);\n-    alt loc.node.ty.node {\n+    match loc.node.ty.node {\n       ast::ty_infer => (),\n       _ => { word_space(s, ~\":\"); print_type(s, loc.node.ty); }\n     }\n }\n \n fn print_decl(s: ps, decl: @ast::decl) {\n     maybe_print_comment(s, decl.span.lo);\n-    alt decl.node {\n+    match decl.node {\n       ast::decl_local(locs) => {\n         space_if_not_bol(s);\n         ibox(s, indent_unit);\n@@ -1267,10 +1267,10 @@ fn print_decl(s: ps, decl: @ast::decl) {\n             ibox(s, indent_unit);\n             print_local_decl(s, loc);\n             end(s);\n-            alt loc.node.init {\n+            match loc.node.init {\n               some(init) => {\n                 nbsp(s);\n-                alt init.op {\n+                match init.op {\n                   ast::init_assign => word_space(s, ~\"=\"),\n                   ast::init_move => word_space(s, ~\"<-\")\n                 }\n@@ -1306,7 +1306,7 @@ fn print_path(s: ps, &&path: @ast::path, colons_before_params: bool) {\n     if path.rp.is_some() || !path.types.is_empty() {\n         if colons_before_params { word(s.s, ~\"::\"); }\n \n-        alt path.rp {\n+        match path.rp {\n           none => { /* ok */ }\n           some(r) => {\n             word(s.s, ~\"/\");\n@@ -1328,22 +1328,22 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n     s.ann.pre(ann_node);\n     /* Pat isn't normalized, but the beauty of it\n      is that it doesn't matter */\n-    alt pat.node {\n+    match pat.node {\n       ast::pat_wild => word(s.s, ~\"_\"),\n       ast::pat_ident(binding_mode, path, sub) => {\n-        alt binding_mode {\n+        match binding_mode {\n           ast::bind_by_ref => word_space(s, ~\"ref\"),\n           ast::bind_by_value => ()\n         }\n         print_path(s, path, true);\n-        alt sub {\n+        match sub {\n           some(p) => { word(s.s, ~\"@\"); print_pat(s, p); }\n           none => ()\n         }\n       }\n       ast::pat_enum(path, args_) => {\n         print_path(s, path, true);\n-        alt args_ {\n+        match args_ {\n           none => word(s.s, ~\"(*)\"),\n           some(args) => {\n             if vec::len(args) > 0u {\n@@ -1391,7 +1391,7 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n \n fn print_fn(s: ps, decl: ast::fn_decl, name: ast::ident,\n             typarams: ~[ast::ty_param]) {\n-    alt decl.purity {\n+    match decl.purity {\n       ast::impure_fn => head(s, ~\"fn\"),\n       _ => head(s, purity_to_str(decl.purity) + ~\" fn\")\n     }\n@@ -1442,7 +1442,7 @@ fn print_fn_block_args(s: ps, decl: ast::fn_decl,\n }\n \n fn mode_to_str(m: ast::mode) -> ~str {\n-    alt m {\n+    match m {\n       ast::expl(ast::by_mutbl_ref) => ~\"&\",\n       ast::expl(ast::by_move) => ~\"-\",\n       ast::expl(ast::by_ref) => ~\"&&\",\n@@ -1462,7 +1462,7 @@ fn print_bounds(s: ps, bounds: @~[ast::ty_param_bound]) {\n         word(s.s, ~\":\");\n         for vec::each(*bounds) |bound| {\n             nbsp(s);\n-            alt bound {\n+            match bound {\n               ast::bound_copy => word(s.s, ~\"copy\"),\n               ast::bound_send => word(s.s, ~\"send\"),\n               ast::bound_const => word(s.s, ~\"const\"),\n@@ -1487,7 +1487,7 @@ fn print_type_params(s: ps, &&params: ~[ast::ty_param]) {\n \n fn print_meta_item(s: ps, &&item: @ast::meta_item) {\n     ibox(s, indent_unit);\n-    alt item.node {\n+    match item.node {\n       ast::meta_word(name) => word(s.s, *name),\n       ast::meta_name_value(name, value) => {\n         word_space(s, *name);\n@@ -1505,7 +1505,7 @@ fn print_meta_item(s: ps, &&item: @ast::meta_item) {\n }\n \n fn print_view_path(s: ps, &&vp: @ast::view_path) {\n-    alt vp.node {\n+    match vp.node {\n       ast::view_path_simple(ident, path, _) => {\n         if path.idents[vec::len(path.idents)-1u] != ident {\n             word_space(s, *ident);\n@@ -1538,7 +1538,7 @@ fn print_view_item(s: ps, item: @ast::view_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n-    alt item.node {\n+    match item.node {\n       ast::view_item_use(id, mta, _) => {\n         head(s, ~\"use\");\n         word(s.s, *id);\n@@ -1572,7 +1572,7 @@ fn print_op_maybe_parens(s: ps, expr: @ast::expr, outer_prec: uint) {\n }\n \n fn print_mutability(s: ps, mutbl: ast::mutability) {\n-    alt mutbl {\n+    match mutbl {\n       ast::m_mutbl => word_nbsp(s, ~\"mut\"),\n       ast::m_const => word_nbsp(s, ~\"const\"),\n       ast::m_imm => {/* nothing */ }\n@@ -1587,7 +1587,7 @@ fn print_mt(s: ps, mt: ast::mt) {\n fn print_arg(s: ps, input: ast::arg) {\n     ibox(s, indent_unit);\n     print_arg_mode(s, input.mode);\n-    alt input.ty.node {\n+    match input.ty.node {\n       ast::ty_infer => word(s.s, *input.ident),\n       _ => {\n         if str::len(*input.ident) > 0u {\n@@ -1604,8 +1604,8 @@ fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n                tps: option<~[ast::ty_param]>) {\n     ibox(s, indent_unit);\n     word(s.s, opt_proto_to_str(opt_proto));\n-    alt id { some(id) => { word(s.s, ~\" \"); word(s.s, *id); } _ => () }\n-    alt tps { some(tps) => print_type_params(s, tps), _ => () }\n+    match id { some(id) => { word(s.s, ~\" \"); word(s.s, *id); } _ => () }\n+    match tps { some(tps) => print_type_params(s, tps), _ => () }\n     zerobreak(s.s);\n     popen(s);\n     commasep(s, inconsistent, decl.inputs, print_arg);\n@@ -1625,14 +1625,14 @@ fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n fn maybe_print_trailing_comment(s: ps, span: codemap::span,\n                                 next_pos: option<uint>) {\n     let mut cm;\n-    alt s.cm { some(ccm) => cm = ccm, _ => return }\n-    alt next_comment(s) {\n+    match s.cm { some(ccm) => cm = ccm, _ => return }\n+    match next_comment(s) {\n       some(cmnt) => {\n         if cmnt.style != comments::trailing { return; }\n         let span_line = codemap::lookup_char_pos(cm, span.hi);\n         let comment_line = codemap::lookup_char_pos(cm, cmnt.pos);\n         let mut next = cmnt.pos + 1u;\n-        alt next_pos { none => (), some(p) => next = p }\n+        match next_pos { none => (), some(p) => next = p }\n         if span.hi < cmnt.pos && cmnt.pos < next &&\n                span_line.line == comment_line.line {\n             print_comment(s, cmnt);\n@@ -1648,7 +1648,7 @@ fn print_remaining_comments(s: ps) {\n     // make sure there is a line break at the end.\n     if option::is_none(next_comment(s)) { hardbreak(s.s); }\n     loop {\n-        alt next_comment(s) {\n+        match next_comment(s) {\n           some(cmnt) => { print_comment(s, cmnt); s.cur_cmnt += 1u; }\n           _ => break\n         }\n@@ -1657,14 +1657,14 @@ fn print_remaining_comments(s: ps) {\n \n fn print_literal(s: ps, &&lit: @ast::lit) {\n     maybe_print_comment(s, lit.span.lo);\n-    alt next_lit(s, lit.span.lo) {\n+    match next_lit(s, lit.span.lo) {\n       some(ltrl) => {\n         word(s.s, ltrl.lit);\n         return;\n       }\n       _ => ()\n     }\n-    alt lit.node {\n+    match lit.node {\n       ast::lit_str(st) => print_string(s, *st),\n       ast::lit_int(ch, ast::ty_char) => {\n         word(s.s, ~\"'\" + char::escape_default(ch as char) + ~\"'\");\n@@ -1705,7 +1705,7 @@ fn print_literal(s: ps, &&lit: @ast::lit) {\n fn lit_to_str(l: @ast::lit) -> ~str { return to_str(l, print_literal); }\n \n fn next_lit(s: ps, pos: uint) -> option<comments::lit> {\n-    alt s.literals {\n+    match s.literals {\n       some(lits) => {\n         while s.cur_lit < vec::len(lits) {\n             let ltrl = lits[s.cur_lit];\n@@ -1721,7 +1721,7 @@ fn next_lit(s: ps, pos: uint) -> option<comments::lit> {\n \n fn maybe_print_comment(s: ps, pos: uint) {\n     loop {\n-        alt next_comment(s) {\n+        match next_comment(s) {\n           some(cmnt) => {\n             if cmnt.pos < pos {\n                 print_comment(s, cmnt);\n@@ -1734,7 +1734,7 @@ fn maybe_print_comment(s: ps, pos: uint) {\n }\n \n fn print_comment(s: ps, cmnt: comments::cmnt) {\n-    alt cmnt.style {\n+    match cmnt.style {\n       comments::mixed => {\n         assert (vec::len(cmnt.lines) == 1u);\n         zerobreak(s.s);\n@@ -1767,7 +1767,7 @@ fn print_comment(s: ps, cmnt: comments::cmnt) {\n       comments::blank_line => {\n         // We need to do at least one, possibly two hardbreaks.\n         let is_semi =\n-            alt s.s.last_token() {\n+            match s.s.last_token() {\n               pp::STRING(s, _) => *s == ~\";\",\n               _ => false\n             };\n@@ -1792,7 +1792,7 @@ fn to_str<T>(t: T, f: fn@(ps, T)) -> ~str {\n }\n \n fn next_comment(s: ps) -> option<comments::cmnt> {\n-    alt s.comments {\n+    match s.comments {\n       some(cmnts) => {\n         if s.cur_cmnt < vec::len(cmnts) {\n             return some(cmnts[s.cur_cmnt]);\n@@ -1803,14 +1803,14 @@ fn next_comment(s: ps) -> option<comments::cmnt> {\n }\n \n fn opt_proto_to_str(opt_p: option<ast::proto>) -> ~str {\n-    alt opt_p {\n+    match opt_p {\n       none => ~\"fn\",\n       some(p) => proto_to_str(p)\n     }\n }\n \n pure fn purity_to_str(p: ast::purity) -> ~str {\n-    alt p {\n+    match p {\n       ast::impure_fn => ~\"impure\",\n       ast::unsafe_fn => ~\"unsafe\",\n       ast::pure_fn => ~\"pure\",\n@@ -1819,14 +1819,14 @@ pure fn purity_to_str(p: ast::purity) -> ~str {\n }\n \n fn print_purity(s: ps, p: ast::purity) {\n-    alt p {\n+    match p {\n       ast::impure_fn => (),\n       _ => word_nbsp(s, purity_to_str(p))\n     }\n }\n \n fn proto_to_str(p: ast::proto) -> ~str {\n-    return alt p {\n+    return match p {\n       ast::proto_bare => ~\"extern fn\",\n       ast::proto_block => ~\"fn&\",\n       ast::proto_uniq => ~\"fn~\","}, {"sha": "ccc5302015572b6fb263df136481a90bf8878b89", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -27,7 +27,7 @@ trait interner<T: const copy> {\n \n impl <T: const copy> of interner<T> for hash_interner<T> {\n     fn intern(val: T) -> uint {\n-        alt self.map.find(val) {\n+        match self.map.find(val) {\n           some(idx) => return idx,\n           none => {\n             let new_idx = self.vect.len();"}, {"sha": "7df0fc739ad262a4c54892797b79874bda407585", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -25,7 +25,7 @@ enum fn_kind {\n }\n \n fn name_of_fn(fk: fn_kind) -> ident {\n-    alt fk {\n+    match fk {\n       fk_item_fn(name, _) | fk_method(name, _, _)\n           | fk_ctor(name, _, _, _, _) => /* FIXME (#2543) */ copy name,\n       fk_anon(*) | fk_fn_block(*) => @~\"anon\",\n@@ -34,7 +34,7 @@ fn name_of_fn(fk: fn_kind) -> ident {\n }\n \n fn tps_of_fn(fk: fn_kind) -> ~[ty_param] {\n-    alt fk {\n+    match fk {\n       fk_item_fn(_, tps) | fk_method(_, tps, _)\n           | fk_ctor(_, _, tps, _, _) | fk_dtor(tps, _, _, _) => {\n           /* FIXME (#2543) */ copy tps\n@@ -89,7 +89,7 @@ fn visit_crate<E>(c: crate, e: E, v: vt<E>) {\n }\n \n fn visit_crate_directive<E>(cd: @crate_directive, e: E, v: vt<E>) {\n-    alt cd.node {\n+    match cd.node {\n       cdir_src_mod(_, _) => (),\n       cdir_dir_mod(_, cdirs, _) => for cdirs.each |cdir| {\n         visit_crate_directive(cdir, e, v);\n@@ -109,14 +109,14 @@ fn visit_view_item<E>(_vi: @view_item, _e: E, _v: vt<E>) { }\n fn visit_local<E>(loc: @local, e: E, v: vt<E>) {\n     v.visit_pat(loc.node.pat, e, v);\n     v.visit_ty(loc.node.ty, e, v);\n-    alt loc.node.init {\n+    match loc.node.init {\n       none => (),\n       some(i) => v.visit_expr(i.expr, e, v)\n     }\n }\n \n fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n-    alt i.node {\n+    match i.node {\n       item_const(t, ex) => { v.visit_ty(t, e, v); v.visit_expr(ex, e, v); }\n       item_fn(decl, tp, body) => {\n         v.visit_fn(fk_item_fn(/* FIXME (#2543) */ copy i.ident,\n@@ -175,7 +175,7 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n }\n \n fn visit_class_item<E>(cm: @class_member, e:E, v:vt<E>) {\n-    alt cm.node {\n+    match cm.node {\n       instance_var(_, t, _, _, _) => v.visit_ty(t, e, v),\n       class_method(m) => visit_method_helper(m, e, v)\n     }\n@@ -184,7 +184,7 @@ fn visit_class_item<E>(cm: @class_member, e:E, v:vt<E>) {\n fn skip_ty<E>(_t: @ty, _e: E, _v: vt<E>) {}\n \n fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n-    alt t.node {\n+    match t.node {\n       ty_box(mt) | ty_uniq(mt) |\n       ty_vec(mt) | ty_ptr(mt) | ty_rptr(_, mt) => {\n         v.visit_ty(mt.ty, e, v);\n@@ -213,7 +213,7 @@ fn visit_path<E>(p: @path, e: E, v: vt<E>) {\n }\n \n fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n-    alt p.node {\n+    match p.node {\n       pat_enum(path, children) => {\n         visit_path(path, e, v);\n         do option::iter(children) |children| {\n@@ -237,7 +237,7 @@ fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n }\n \n fn visit_foreign_item<E>(ni: @foreign_item, e: E, v: vt<E>) {\n-    alt ni.node {\n+    match ni.node {\n       foreign_item_fn(fd, tps) => {\n         v.visit_ty_params(tps, e, v);\n         visit_fn_decl(fd, e, v);\n@@ -248,7 +248,7 @@ fn visit_foreign_item<E>(ni: @foreign_item, e: E, v: vt<E>) {\n fn visit_ty_params<E>(tps: ~[ty_param], e: E, v: vt<E>) {\n     for tps.each |tp| {\n         for vec::each(*tp.bounds) |bound| {\n-            alt bound {\n+            match bound {\n               bound_trait(t) => v.visit_ty(t, e, v),\n               bound_copy | bound_send | bound_const | bound_owned => ()\n             }\n@@ -304,7 +304,7 @@ fn visit_ty_method<E>(m: ty_method, e: E, v: vt<E>) {\n }\n \n fn visit_trait_method<E>(m: trait_method, e: E, v: vt<E>) {\n-    alt m {\n+    match m {\n       required(ty_m) => v.visit_ty_method(ty_m, e, v),\n       provided(m) => visit_method_helper(m, e, v)\n     }\n@@ -317,15 +317,15 @@ fn visit_block<E>(b: ast::blk, e: E, v: vt<E>) {\n }\n \n fn visit_stmt<E>(s: @stmt, e: E, v: vt<E>) {\n-    alt s.node {\n+    match s.node {\n       stmt_decl(d, _) => v.visit_decl(d, e, v),\n       stmt_expr(ex, _) => v.visit_expr(ex, e, v),\n       stmt_semi(ex, _) => v.visit_expr(ex, e, v)\n     }\n }\n \n fn visit_decl<E>(d: @decl, e: E, v: vt<E>) {\n-    alt d.node {\n+    match d.node {\n       decl_local(locs) => for locs.each |loc| {\n         v.visit_local(loc, e, v)\n       }\n@@ -334,15 +334,15 @@ fn visit_decl<E>(d: @decl, e: E, v: vt<E>) {\n }\n \n fn visit_expr_opt<E>(eo: option<@expr>, e: E, v: vt<E>) {\n-    alt eo { none => (), some(ex) => v.visit_expr(ex, e, v) }\n+    match eo { none => (), some(ex) => v.visit_expr(ex, e, v) }\n }\n \n fn visit_exprs<E>(exprs: ~[@expr], e: E, v: vt<E>) {\n     for exprs.each |ex| { v.visit_expr(ex, e, v); }\n }\n \n fn visit_mac<E>(m: mac, e: E, v: vt<E>) {\n-    alt m.node {\n+    match m.node {\n       ast::mac_invoc(pth, arg, body) => {\n         option::map(arg, |arg| v.visit_expr(arg, e, v)); }\n       ast::mac_invoc_tt(pth, tt) => { /* no user-serviceable parts inside */ }\n@@ -353,7 +353,7 @@ fn visit_mac<E>(m: mac, e: E, v: vt<E>) {\n }\n \n fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n-    alt ex.node {\n+    match ex.node {\n       expr_vstore(x, _) => v.visit_expr(x, e, v),\n       expr_vec(es, _) => visit_exprs(es, e, v),\n       expr_repeat(element, count, _) => {"}, {"sha": "e7fe5fa3e3df67f3dbc2ea77f23b53d7f36bf12f", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -61,7 +61,7 @@ mod write {\n     // and the extension to use.\n     fn mk_intermediate_name(output_path: ~str, extension: ~str) ->\n         ~str unsafe {\n-        let stem = alt str::find_char(output_path, '.') {\n+        let stem = match str::find_char(output_path, '.') {\n           some(dot_pos) => str::slice(output_path, 0u, dot_pos),\n           none => output_path\n         };\n@@ -82,7 +82,7 @@ mod write {\n         // specified.\n \n         if opts.save_temps {\n-            alt opts.output_type {\n+            match opts.output_type {\n               output_type_bitcode => {\n                 if opts.optimize != 0u {\n                     let filename = mk_intermediate_name(output, ~\"no-opt.bc\");\n@@ -146,7 +146,7 @@ mod write {\n             let LLVMOptDefault    = 2 as c_int; // -O2, -Os\n             let LLVMOptAggressive = 3 as c_int; // -O3\n \n-            let mut CodeGenOptLevel = alt check opts.optimize {\n+            let mut CodeGenOptLevel = match check opts.optimize {\n               0u => LLVMOptNone,\n               1u => LLVMOptLess,\n               2u => LLVMOptDefault,\n@@ -323,12 +323,12 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n         for linkage_metas.each |meta| {\n             if *attr::get_meta_item_name(meta) == ~\"name\" {\n-                alt attr::get_meta_item_value_str(meta) {\n+                match attr::get_meta_item_value_str(meta) {\n                   some(v) => { name = some(v); }\n                   none => vec::push(cmh_items, meta)\n                 }\n             } else if *attr::get_meta_item_name(meta) == ~\"vers\" {\n-                alt attr::get_meta_item_value_str(meta) {\n+                match attr::get_meta_item_value_str(meta) {\n                   some(v) => { vers = some(v); }\n                   none => vec::push(cmh_items, meta)\n                 }\n@@ -355,7 +355,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n         symbol_hasher.reset();\n         for cmh_items.each |m_| {\n             let m = m_;\n-            alt m.node {\n+            match m.node {\n               ast::meta_name_value(key, value) => {\n                 symbol_hasher.write_str(len_and_str(*key));\n                 symbol_hasher.write_str(len_and_str_lit(value));\n@@ -385,7 +385,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n \n     fn crate_meta_name(sess: session, _crate: ast::crate,\n                        output: ~str, metas: provided_metas) -> @~str {\n-        return alt metas.name {\n+        return match metas.name {\n               some(v) => v,\n               none => {\n                 let name =\n@@ -407,7 +407,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n \n     fn crate_meta_vers(sess: session, _crate: ast::crate,\n                        metas: provided_metas) -> @~str {\n-        return alt metas.vers {\n+        return match metas.vers {\n               some(v) => v,\n               none => {\n                 let vers = ~\"0.0\";\n@@ -451,7 +451,7 @@ fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &hash::State, t: ty::t,\n }\n \n fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> ~str {\n-    alt ccx.type_hashcodes.find(t) {\n+    match ccx.type_hashcodes.find(t) {\n       some(h) => return h,\n       none => {\n         let hash = symbol_hash(ccx.tcx, ccx.symbol_hasher, t, ccx.link_meta);\n@@ -467,7 +467,7 @@ fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> ~str {\n fn sanitize(s: ~str) -> ~str {\n     let mut result = ~\"\";\n     do str::chars_iter(s) |c| {\n-        alt c {\n+        match c {\n           '@' => result += ~\"_sbox_\",\n           '~' => result += ~\"_ubox_\",\n           '*' => result += ~\"_ptr_\",\n@@ -503,7 +503,7 @@ fn mangle(ss: path) -> ~str {\n     let mut n = ~\"_ZN\"; // Begin name-sequence.\n \n     for ss.each |s| {\n-        alt s { path_name(s) | path_mod(s) => {\n+        match s { path_name(s) | path_mod(s) => {\n           let sani = sanitize(*s);\n           n += fmt!{\"%u%s\", str::len(sani), sani};\n         } }\n@@ -566,7 +566,7 @@ fn link_binary(sess: session,\n             vec::pop(parts);\n             return str::connect(parts, ~\".\");\n         }\n-        return alt config.os {\n+        return match config.os {\n               session::os_macos => rmext(rmlib(filename)),\n               session::os_linux => rmext(rmlib(filename)),\n               session::os_freebsd => rmext(rmlib(filename)),"}, {"sha": "e06b0a2fe72e9e3458fd7e583bb2f145634285a5", "filename": "src/rustc/back/rpath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Frpath.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -7,7 +7,7 @@ import metadata::filesearch;\n export get_rpath_flags;\n \n pure fn not_win32(os: session::os) -> bool {\n-  alt os {\n+  match os {\n       session::os_win32 => false,\n       _ => true\n   }\n@@ -108,7 +108,7 @@ fn get_rpath_relative_to_output(os: session::os,\n     assert not_win32(os);\n \n     // Mac doesn't appear to support $ORIGIN\n-    let prefix = alt os {\n+    let prefix = match os {\n         session::os_linux => ~\"$ORIGIN\" + path::path_sep(),\n         session::os_freebsd => ~\"$ORIGIN\" + path::path_sep(),\n         session::os_macos => ~\"@executable_path\" + path::path_sep(),"}, {"sha": "78270f31e3731b71ed5088e3cd14f210a6bec39e", "filename": "src/rustc/back/x86.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fx86.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -8,7 +8,7 @@ fn get_target_strs(target_os: session::os) -> target_strs::t {\n \n         meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)),\n \n-        data_layout: alt target_os {\n+        data_layout: match target_os {\n           session::os_macos => {\n             ~\"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\" +\n                 ~\"-i32:32:32-i64:32:64\" +\n@@ -29,7 +29,7 @@ fn get_target_strs(target_os: session::os) -> target_strs::t {\n           }\n         },\n \n-        target_triple: alt target_os {\n+        target_triple: match target_os {\n           session::os_macos => ~\"i686-apple-darwin\",\n           session::os_win32 => ~\"i686-pc-mingw32\",\n           session::os_linux => ~\"i686-unknown-linux-gnu\","}, {"sha": "18c2232c0fc9b58a9e177f292294e20fc10668c4", "filename": "src/rustc/back/x86_64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fx86_64.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -8,7 +8,7 @@ fn get_target_strs(target_os: session::os) -> target_strs::t {\n \n         meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)),\n \n-        data_layout: alt target_os {\n+        data_layout: match target_os {\n           session::os_macos => {\n             ~\"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\"+\n                 ~\"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n@@ -35,7 +35,7 @@ fn get_target_strs(target_os: session::os) -> target_strs::t {\n           }\n         },\n \n-        target_triple: alt target_os {\n+        target_triple: match target_os {\n           session::os_macos => ~\"x86_64-apple-darwin\",\n           session::os_win32 => ~\"x86_64-pc-mingw32\",\n           session::os_linux => ~\"x86_64-unknown-linux-gnu\","}, {"sha": "2f6bd86592f4bd261d6420545402afb8651fc36d", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -26,15 +26,15 @@ enum pp_mode {ppm_normal, ppm_expanded, ppm_typed, ppm_identified,\n fn anon_src() -> ~str { ~\"<anon>\" }\n \n fn source_name(input: input) -> ~str {\n-    alt input {\n+    match input {\n       file_input(ifile) => ifile,\n       str_input(_) => anon_src()\n     }\n }\n \n fn default_configuration(sess: session, argv0: ~str, input: input) ->\n    ast::crate_cfg {\n-    let libc = alt sess.targ_cfg.os {\n+    let libc = match sess.targ_cfg.os {\n       session::os_win32 => ~\"msvcrt.dll\",\n       session::os_macos => ~\"libc.dylib\",\n       session::os_linux => ~\"libc.so.6\",\n@@ -44,7 +44,7 @@ fn default_configuration(sess: session, argv0: ~str, input: input) ->\n \n     let mk = attr::mk_name_value_item_str;\n \n-    let (arch,wordsz) = alt sess.targ_cfg.arch {\n+    let (arch,wordsz) = match sess.targ_cfg.arch {\n       session::arch_x86 => (~\"x86\",~\"32\"),\n       session::arch_x86_64 => (~\"x86_64\",~\"64\"),\n       session::arch_arm => (~\"arm\",~\"32\")\n@@ -99,7 +99,7 @@ enum input {\n \n fn parse_input(sess: session, cfg: ast::crate_cfg, input: input)\n     -> @ast::crate {\n-    alt input {\n+    match input {\n       file_input(file) => {\n         parse::parse_crate_from_file(file, cfg, sess.parse_sess)\n       }\n@@ -270,13 +270,13 @@ fn compile_input(sess: session, cfg: ast::crate_cfg, input: input,\n fn pretty_print_input(sess: session, cfg: ast::crate_cfg, input: input,\n                       ppm: pp_mode) {\n     fn ann_paren_for_expr(node: pprust::ann_node) {\n-        alt node {\n+        match node {\n           pprust::node_expr(s, expr) => pprust::popen(s),\n           _ => ()\n         }\n     }\n     fn ann_typed_post(tcx: ty::ctxt, node: pprust::ann_node) {\n-        alt node {\n+        match node {\n           pprust::node_expr(s, expr) => {\n             pp::space(s.s);\n             pp::word(s.s, ~\"as\");\n@@ -288,7 +288,7 @@ fn pretty_print_input(sess: session, cfg: ast::crate_cfg, input: input,\n         }\n     }\n     fn ann_identified_post(node: pprust::ann_node) {\n-        alt node {\n+        match node {\n           pprust::node_item(s, item) => {\n             pp::space(s.s);\n             pprust::synth_comment(s, int::to_str(item.id, 10u));\n@@ -314,14 +314,14 @@ fn pretty_print_input(sess: session, cfg: ast::crate_cfg, input: input,\n     // to collect comments and literals, and we need to support reading\n     // from stdin, we're going to just suck the source into a string\n     // so both the parser and pretty-printer can use it.\n-    let upto = alt ppm {\n+    let upto = match ppm {\n       ppm_expanded | ppm_expanded_identified => cu_expand,\n       ppm_typed => cu_typeck,\n       _ => cu_parse\n     };\n     let {crate, tcx} = compile_upto(sess, cfg, input, upto, none);\n \n-    let ann = alt ppm {\n+    let ann = match ppm {\n       ppm_typed => {\n         {pre: ann_paren_for_expr,\n          post: |a| ann_typed_post(option::get(tcx), a) }\n@@ -371,21 +371,21 @@ fn get_arch(triple: ~str) -> option<session::arch> {\n \n fn build_target_config(sopts: @session::options,\n                        demitter: diagnostic::emitter) -> @session::config {\n-    let os = alt get_os(sopts.target_triple) {\n+    let os = match get_os(sopts.target_triple) {\n       some(os) => os,\n       none => early_error(demitter, ~\"unknown operating system\")\n     };\n-    let arch = alt get_arch(sopts.target_triple) {\n+    let arch = match get_arch(sopts.target_triple) {\n       some(arch) => arch,\n       none => early_error(demitter,\n                           ~\"unknown architecture: \" + sopts.target_triple)\n     };\n-    let (int_type, uint_type, float_type) = alt arch {\n+    let (int_type, uint_type, float_type) = match arch {\n       session::arch_x86 => (ast::ty_i32, ast::ty_u32, ast::ty_f64),\n       session::arch_x86_64 => (ast::ty_i64, ast::ty_u64, ast::ty_f64),\n       session::arch_arm => (ast::ty_i32, ast::ty_u32, ast::ty_f64)\n     };\n-    let target_strs = alt arch {\n+    let target_strs = match arch {\n       session::arch_x86 => x86::get_target_strs(os),\n       session::arch_x86_64 => x86_64::get_target_strs(os),\n       session::arch_arm => x86::get_target_strs(os)\n@@ -438,7 +438,7 @@ fn build_session_options(matches: getopts::matches,\n                                 getopts::opt_strs(matches, level_name));\n         for flags.each |lint_name| {\n             let lint_name = str::replace(lint_name, ~\"-\", ~\"_\");\n-            alt lint_dict.find(lint_name) {\n+            match lint_dict.find(lint_name) {\n               none => {\n                 early_error(demitter, fmt!{\"unknown %s flag: %s\",\n                                            level_name, lint_name});\n@@ -486,7 +486,7 @@ fn build_session_options(matches: getopts::matches,\n     let sysroot_opt = getopts::opt_maybe_str(matches, ~\"sysroot\");\n     let target_opt = getopts::opt_maybe_str(matches, ~\"target\");\n     let save_temps = getopts::opt_present(matches, ~\"save-temps\");\n-    alt output_type {\n+    match output_type {\n       // unless we're emitting huamn-readable assembly, omit comments.\n       link::output_type_llvm_assembly | link::output_type_assembly => (),\n       _ => debugging_opts |= session::no_asm_comments\n@@ -498,7 +498,7 @@ fn build_session_options(matches: getopts::matches,\n             }\n             2u\n         } else if opt_present(matches, ~\"opt-level\") {\n-            alt getopts::opt_str(matches, ~\"opt-level\") {\n+            match getopts::opt_str(matches, ~\"opt-level\") {\n               ~\"0\" => 0u,\n               ~\"1\" => 1u,\n               ~\"2\" => 2u,\n@@ -510,7 +510,7 @@ fn build_session_options(matches: getopts::matches,\n             }\n         } else { 0u };\n     let target =\n-        alt target_opt {\n+        match target_opt {\n             none => host_triple(),\n             some(s) => s\n         };\n@@ -577,7 +577,7 @@ fn build_session_(sopts: @session::options,\n }\n \n fn parse_pretty(sess: session, &&name: ~str) -> pp_mode {\n-    alt name {\n+    match name {\n       ~\"normal\" => ppm_normal,\n       ~\"expanded\" => ppm_expanded,\n       ~\"typed\" => ppm_typed,\n@@ -628,7 +628,7 @@ fn build_output_filenames(input: input,\n \n \n     let obj_suffix =\n-        alt sopts.output_type {\n+        match sopts.output_type {\n           link::output_type_none => ~\"none\",\n           link::output_type_bitcode => ~\"bc\",\n           link::output_type_assembly => ~\"s\",\n@@ -637,20 +637,20 @@ fn build_output_filenames(input: input,\n           link::output_type_object | link::output_type_exe => ~\"o\"\n         };\n \n-    alt ofile {\n+    match ofile {\n       none => {\n         // \"-\" as input file will cause the parser to read from stdin so we\n         // have to make up a name\n         // We want to toss everything after the final '.'\n-        let dirname = alt odir {\n+        let dirname = match odir {\n           some(d) => d,\n-          none => alt input {\n+          none => match input {\n             str_input(_) => os::getcwd(),\n             file_input(ifile) => path::dirname(ifile)\n           }\n         };\n \n-        let base_filename = alt input {\n+        let base_filename = match input {\n           file_input(ifile) => {\n             let (path, _) = path::splitext(ifile);\n             path::basename(path)\n@@ -714,7 +714,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test() {\n         let matches =\n-            alt getopts::getopts(~[~\"--test\"], opts()) {\n+            match getopts::getopts(~[~\"--test\"], opts()) {\n               ok(m) => m,\n               err(f) => fail ~\"test_switch_implies_cfg_test: \" +\n                              getopts::fail_str(f)\n@@ -730,7 +730,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n-            alt getopts::getopts(~[~\"--test\", ~\"--cfg=test\"], opts()) {\n+            match getopts::getopts(~[~\"--test\", ~\"--cfg=test\"], opts()) {\n               ok(m) => m,\n               err(f) => {\n                 fail ~\"test_switch_implies_cfg_test_unless_cfg_test: \" +"}, {"sha": "dbbe48f84b20501feca993d22380d7757047a7ba", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -95,7 +95,7 @@ fn describe_warnings() {\n         let k = str::replace(k, ~\"_\", ~\"-\");\n         io::println(fmt!{\"    %s  %7.7s  %s\",\n                          padded(max_key, k),\n-                         alt v.default {\n+                         match v.default {\n                              lint::allow => ~\"allow\",\n                              lint::warn => ~\"warn\",\n                              lint::deny => ~\"deny\",\n@@ -124,7 +124,7 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n     if vec::len(args) == 0u { usage(binary); return; }\n \n     let matches =\n-        alt getopts::getopts(args, opts()) {\n+        match getopts::getopts(args, opts()) {\n           ok(m) => m,\n           err(f) => {\n             early_error(demitter, getopts::fail_str(f))\n@@ -152,7 +152,7 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n         version(binary);\n         return;\n     }\n-    let input = alt vec::len(matches.free) {\n+    let input = match vec::len(matches.free) {\n       0u => early_error(demitter, ~\"no input filename given\"),\n       1u => {\n         let ifile = matches.free[0];\n@@ -175,7 +175,7 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n         option::map(getopts::opt_default(matches, ~\"pretty\",\n                                          ~\"normal\"),\n                     |a| parse_pretty(sess, a) );\n-    alt pretty {\n+    match pretty {\n       some::<pp_mode>(ppm) => {\n         pretty_print_input(sess, cfg, input, ppm);\n         return;\n@@ -184,7 +184,7 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n     }\n     let ls = opt_present(matches, ~\"ls\");\n     if ls {\n-        alt input {\n+        match input {\n           file_input(ifile) => {\n             list_metadata(sess, ifile, io::stdout());\n           }\n@@ -219,7 +219,7 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n     let p = comm::port();\n     let ch = comm::chan(p);\n \n-    alt do task::try  {\n+    match do task::try  {\n \n         // The 'diagnostics emitter'. Every error, warning, etc. should\n         // go through this function."}, {"sha": "df9370afaea27d793a47f6a096f92fc4cd8d320a", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -152,7 +152,7 @@ impl session for session {\n     }\n     fn span_lint_level(level: lint::level,\n                        sp: span, msg: ~str) {\n-        alt level {\n+        match level {\n           lint::allow => { },\n           lint::warn => self.span_warn(sp, msg),\n           lint::deny | lint::forbid => {\n@@ -219,14 +219,14 @@ fn expect<T: copy>(sess: session, opt: option<T>, msg: fn() -> ~str) -> T {\n \n fn building_library(req_crate_type: crate_type, crate: @ast::crate,\n                     testing: bool) -> bool {\n-    alt req_crate_type {\n+    match req_crate_type {\n       bin_crate => false,\n       lib_crate => true,\n       unknown_crate => {\n         if testing {\n             false\n         } else {\n-            alt syntax::attr::first_attr_value_str_by_name(\n+            match syntax::attr::first_attr_value_str_by_name(\n                 crate.node.attrs,\n                 ~\"crate_type\") {\n               option::some(@~\"lib\") => true,\n@@ -240,7 +240,7 @@ fn building_library(req_crate_type: crate_type, crate: @ast::crate,\n fn sess_os_to_meta_os(os: os) -> metadata::loader::os {\n     import metadata::loader;\n \n-    alt os {\n+    match os {\n       os_win32 => loader::os_win32,\n       os_linux => loader::os_linux,\n       os_macos => loader::os_macos,"}, {"sha": "ee9000b80e0454f450f9537510bc5fdc97ea2f87", "filename": "src/rustc/front/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fconfig.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -82,9 +82,9 @@ fn fold_foreign_mod(cx: ctxt, nm: ast::foreign_mod,\n \n fn filter_stmt(cx: ctxt, &&stmt: @ast::stmt) ->\n    option<@ast::stmt> {\n-    alt stmt.node {\n+    match stmt.node {\n       ast::stmt_decl(decl, _) => {\n-        alt decl.node {\n+        match decl.node {\n           ast::decl_item(item) => {\n             if item_in_cfg(cx, item) {\n                 option::some(stmt)"}, {"sha": "85770b7b6dd43ef7ce3ce8607ab41335eb76f95a", "filename": "src/rustc/front/intrinsic_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fintrinsic_inject.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -15,7 +15,7 @@ fn inject_intrinsic(sess: session,\n                                                  ~[],\n                                                  sess.parse_sess);\n     let item =\n-        alt item {\n+        match item {\n           some(i) => i,\n           none => {\n             sess.fatal(~\"no item found in intrinsic module\");"}, {"sha": "9c54f6fa98161a9d105a1c8dd72a8450dfc80ff4", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -70,7 +70,7 @@ fn fold_mod(_cx: test_ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n     // FIXME (#2403): This is sloppy. Instead we should have some mechanism to\n     // indicate to the translation pass which function we want to be main.\n     fn nomain(&&item: @ast::item) -> option<@ast::item> {\n-        alt item.node {\n+        match item.node {\n           ast::item_fn(_, _, _) => {\n             if *item.ident == ~\"main\" {\n                 option::none\n@@ -102,7 +102,7 @@ fn fold_item(cx: test_ctxt, &&i: @ast::item, fld: fold::ast_fold) ->\n     debug!{\"current path: %s\", ast_util::path_name_i(cx.path)};\n \n     if is_test_fn(i) {\n-        alt i.node {\n+        match i.node {\n           ast::item_fn(decl, _, _) if decl.purity == ast::unsafe_fn => {\n             cx.sess.span_fatal(\n                 i.span,\n@@ -129,7 +129,7 @@ fn is_test_fn(i: @ast::item) -> bool {\n         vec::len(attr::find_attrs_by_name(i.attrs, ~\"test\")) > 0u;\n \n     fn has_test_signature(i: @ast::item) -> bool {\n-        alt i.node {\n+        match i.node {\n           ast::item_fn(decl, tps, _) => {\n             let input_cnt = vec::len(decl.inputs);\n             let no_output = decl.output.node == ast::ty_nil;\n@@ -246,7 +246,7 @@ fn mk_path(cx: test_ctxt, path: ~[ast::ident]) -> ~[ast::ident] {\n     // the paths with std::\n     let is_std = {\n         let items = attr::find_linkage_metas(cx.crate.node.attrs);\n-        alt attr::last_meta_item_value_str_by_name(items, ~\"name\") {\n+        match attr::last_meta_item_value_str_by_name(items, ~\"name\") {\n           some(@~\"std\") => true,\n           _ => false\n         }"}, {"sha": "2250d3d3086b7e56502ac1c81ea48168218c1e35", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -1015,7 +1015,7 @@ fn type_to_str(names: type_names, ty: TypeRef) -> ~str {\n \n fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n    ~str {\n-    alt type_has_name(names, ty) {\n+    match type_has_name(names, ty) {\n       option::some(n) => return n,\n       _ => {}\n     }\n@@ -1035,7 +1035,7 @@ fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n         return s;\n     }\n \n-    alt kind {\n+    match kind {\n       Void => return ~\"Void\",\n       Half => return ~\"Half\",\n       Float => return ~\"Float\",\n@@ -1103,7 +1103,7 @@ fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n }\n \n fn float_width(llt: TypeRef) -> uint {\n-    return alt llvm::LLVMGetTypeKind(llt) as int {\n+    return match llvm::LLVMGetTypeKind(llt) as int {\n           1 => 32u,\n           2 => 64u,\n           3 => 80u,"}, {"sha": "5b72a6caa6c98680a1cbd9a174da2e0f2a04f50c", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -100,7 +100,7 @@ type env = @{diag: span_handler,\n              mut next_crate_num: ast::crate_num};\n \n fn visit_view_item(e: env, i: @ast::view_item) {\n-    alt i.node {\n+    match i.node {\n       ast::view_item_use(ident, meta_items, id) => {\n         debug!{\"resolving use stmt. ident: %?, meta: %?\", ident, meta_items};\n         let cnum = resolve_crate(e, ident, meta_items, ~\"\", i.span);\n@@ -111,9 +111,9 @@ fn visit_view_item(e: env, i: @ast::view_item) {\n }\n \n fn visit_item(e: env, i: @ast::item) {\n-    alt i.node {\n+    match i.node {\n       ast::item_foreign_mod(m) => {\n-        alt attr::foreign_abi(i.attrs) {\n+        match attr::foreign_abi(i.attrs) {\n           either::right(abi) => {\n             if abi != ast::foreign_abi_cdecl &&\n                abi != ast::foreign_abi_stdcall { return; }\n@@ -123,7 +123,7 @@ fn visit_item(e: env, i: @ast::item) {\n \n         let cstore = e.cstore;\n         let foreign_name =\n-            alt attr::first_attr_value_str_by_name(i.attrs, ~\"link_name\") {\n+            match attr::first_attr_value_str_by_name(i.attrs, ~\"link_name\") {\n               some(nn) => {\n                 if *nn == ~\"\" {\n                     e.diag.span_fatal(\n@@ -144,7 +144,7 @@ fn visit_item(e: env, i: @ast::item) {\n                               ~\"' already added: can't specify link_args.\");\n         }\n         for link_args.each |a| {\n-            alt attr::get_meta_item_value_str(attr::attr_meta(a)) {\n+            match attr::get_meta_item_value_str(attr::attr_meta(a)) {\n               some(linkarg) => {\n                 cstore::add_used_link_args(cstore, *linkarg);\n               }\n@@ -187,7 +187,7 @@ fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n                  hash: ~str, span: span) -> ast::crate_num {\n     let metas = metas_with_ident(ident, metas);\n \n-    alt existing_match(e, metas, hash) {\n+    match existing_match(e, metas, hash) {\n       none => {\n         let load_ctxt: loader::ctxt = {\n             diag: e.diag,\n@@ -218,7 +218,7 @@ fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n         let cnum_map = resolve_crate_deps(e, cdata);\n \n         let cname =\n-            alt attr::last_meta_item_value_str_by_name(metas, ~\"name\") {\n+            match attr::last_meta_item_value_str_by_name(metas, ~\"name\") {\n               option::some(v) => v,\n               option::none => ident\n             };\n@@ -248,7 +248,7 @@ fn resolve_crate_deps(e: env, cdata: @~[u8]) -> cstore::cnum_map {\n         let cmetas = metas_with(dep.vers, @~\"vers\", ~[]);\n         debug!{\"resolving dep crate %s ver: %s hash: %s\",\n                *dep.name, *dep.vers, *dep.hash};\n-        alt existing_match(e, metas_with_ident(cname, cmetas), *dep.hash) {\n+        match existing_match(e, metas_with_ident(cname, cmetas), *dep.hash) {\n           some(local_cnum) => {\n             debug!{\"already have it\"};\n             // We've already seen this crate"}, {"sha": "627d7a326d006691c59c031fb2e30233e60a700b", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -57,7 +57,7 @@ fn lookup_defs(cstore: cstore::cstore, cnum: ast::crate_num,\n fn lookup_method_purity(cstore: cstore::cstore, did: ast::def_id)\n     -> ast::purity {\n     let cdata = cstore::get_crate_data(cstore, did.crate).data;\n-    alt check decoder::lookup_def(did.crate, cdata, did) {\n+    match check decoder::lookup_def(did.crate, cdata, did) {\n       ast::def_fn(_, p) => p\n     }\n }"}, {"sha": "75c7c8dd9fe4bcd63e5baa3b742d949063ba8fc9", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -64,7 +64,7 @@ type use_crate_map = map::hashmap<ast::node_id, ast::crate_num>;\n \n // Internal method to retrieve the data from the cstore\n pure fn p(cstore: cstore) -> cstore_private {\n-    alt cstore { private(p) => p }\n+    match cstore { private(p) => p }\n }\n \n fn mk_cstore() -> cstore {"}, {"sha": "2fae50785aff42ff882d984e802fc657cd1e9e71", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -99,7 +99,7 @@ fn find_item(item_id: int, items: ebml::doc) -> ebml::doc {\n // to the item data.\n fn lookup_item(item_id: int, data: @~[u8]) -> ebml::doc {\n     let items = ebml::get_doc(ebml::doc(data), tag_items);\n-    alt maybe_find_item(item_id, items) {\n+    match maybe_find_item(item_id, items) {\n        none => fail(fmt!{\"lookup_item: id not found: %d\", item_id}),\n        some(d) => d\n     }\n@@ -135,7 +135,7 @@ fn field_mutability(d: ebml::doc) -> ast::class_mutability {\n         ebml::maybe_get_doc(d, tag_class_mut),\n         ast::class_immutable,\n         |d| {\n-            alt ebml::doc_as_u8(d) as char {\n+            match ebml::doc_as_u8(d) as char {\n               'm' => ast::class_mutable,\n               _   => ast::class_immutable\n             }\n@@ -184,7 +184,7 @@ fn item_ty_param_bounds(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n }\n \n fn item_ty_region_param(item: ebml::doc) -> bool {\n-    alt ebml::maybe_get_doc(item, tag_region_param) {\n+    match ebml::maybe_get_doc(item, tag_region_param) {\n       some(_) => true,\n       none => false\n     }\n@@ -275,7 +275,7 @@ fn lookup_item_name(data: @~[u8], id: ast::node_id) -> ast::ident {\n fn item_to_def_like(item: ebml::doc, did: ast::def_id, cnum: ast::crate_num)\n         -> def_like {\n     let fam_ch = item_family(item);\n-    alt fam_ch {\n+    match fam_ch {\n       'c' => dl_def(ast::def_const(did)),\n       'C' => dl_def(ast::def_class(did, true)),\n       'S' => dl_def(ast::def_class(did, false)),\n@@ -349,7 +349,7 @@ fn get_class_method(cdata: cmd, id: ast::node_id,\n                     name: ast::ident) -> ast::def_id {\n     let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n     let mut found = none;\n-    let cls_items = alt maybe_find_item(id, items) {\n+    let cls_items = match maybe_find_item(id, items) {\n       some(it) => it,\n       none => fail (fmt!{\"get_class_method: class id not found \\\n                               when looking up method %s\", *name})\n@@ -360,7 +360,7 @@ fn get_class_method(cdata: cmd, id: ast::node_id,\n             found = some(m_did);\n         }\n     }\n-    alt found {\n+    match found {\n       some(found) => found,\n       none => fail (fmt!{\"get_class_method: no method named %s\", *name})\n     }\n@@ -369,7 +369,7 @@ fn get_class_method(cdata: cmd, id: ast::node_id,\n fn class_dtor(cdata: cmd, id: ast::node_id) -> option<ast::def_id> {\n     let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n     let mut found = none;\n-    let cls_items = alt maybe_find_item(id, items) {\n+    let cls_items = match maybe_find_item(id, items) {\n             some(it) => it,\n             none     => fail (fmt!{\"class_dtor: class id not found \\\n               when looking up dtor for %d\", id})\n@@ -394,7 +394,7 @@ enum def_like {\n }\n \n fn def_like_to_def(def_like: def_like) -> ast::def {\n-    alt def_like {\n+    match def_like {\n         dl_def(def) => return def,\n         dl_impl(*) => fail ~\"found impl in def_like_to_def\",\n         dl_field => fail ~\"found field in def_like_to_def\"\n@@ -467,7 +467,7 @@ fn each_path(cdata: cmd, f: fn(path_entry) -> bool) {\n             let def_id = class_member_id(path_doc, cdata);\n \n             // Get the item.\n-            alt maybe_find_item(def_id.node, items) {\n+            match maybe_find_item(def_id.node, items) {\n                 none => {\n                     debug!{\"(each_path) ignoring implicit item: %s\",\n                             *path};\n@@ -515,14 +515,14 @@ fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt,\n     debug!{\"Looking up item: %d\", id};\n     let item_doc = lookup_item(id, cdata.data);\n     let path = vec::init(item_path(item_doc));\n-    alt decode_inlined_item(cdata, tcx, path, item_doc) {\n+    match decode_inlined_item(cdata, tcx, path, item_doc) {\n       some(ii) => csearch::found(ii),\n       none => {\n-        alt item_parent_item(item_doc) {\n+        match item_parent_item(item_doc) {\n           some(did) => {\n             let did = translate_def_id(cdata, did);\n             let parent_item = lookup_item(did.node, cdata.data);\n-            alt decode_inlined_item(cdata, tcx, path,\n+            match decode_inlined_item(cdata, tcx, path,\n                                                parent_item) {\n               some(ii) => csearch::found_parent(did, ii),\n               none => csearch::not_found\n@@ -548,13 +548,13 @@ fn get_enum_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n                                 tcx, cdata);\n         let name = item_name(item);\n         let mut arg_tys: ~[ty::t] = ~[];\n-        alt ty::get(ctor_ty).struct {\n+        match ty::get(ctor_ty).struct {\n           ty::ty_fn(f) => {\n             for f.inputs.each |a| { vec::push(arg_tys, a.ty); }\n           }\n           _ => { /* Nullary enum variant. */ }\n         }\n-        alt variant_disr_val(item) {\n+        match variant_disr_val(item) {\n           some(val) => { disr_val = val; }\n           _         => { /* empty */ }\n         }\n@@ -577,7 +577,7 @@ type _impl = {did: ast::def_id, ident: ast::ident, methods: ~[@method_info]};\n \n fn get_self_ty(item: ebml::doc) -> ast::self_ty_ {\n     fn get_mutability(ch: u8) -> ast::mutability {\n-        alt ch as char {\n+        match ch as char {\n             'i' => { ast::m_imm }\n             'm' => { ast::m_mutbl }\n             'c' => { ast::m_const }\n@@ -591,7 +591,7 @@ fn get_self_ty(item: ebml::doc) -> ast::self_ty_ {\n     let string = ebml::doc_as_str(self_type_doc);\n \n     let self_ty_kind = string[0];\n-    alt self_ty_kind as char {\n+    match self_ty_kind as char {\n         'r' => { return ast::sty_by_ref; }\n         'v' => { return ast::sty_value; }\n         '@' => { return ast::sty_box(get_mutability(string[1])); }\n@@ -654,7 +654,7 @@ fn get_impls_for_mod(cdata: cmd,\n         let impl_data = impl_cdata.data;\n         let item = lookup_item(local_did.node, impl_data);\n         let nm = item_name(item);\n-        if alt name { some(n) => { n == nm } none => { true } } {\n+        if match name { some(n) => { n == nm } none => { true } } {\n            let base_tps = item_ty_param_count(item);\n            vec::push(result, @{\n                 did: local_did, ident: nm,\n@@ -675,7 +675,7 @@ fn get_trait_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n         let bounds = item_ty_param_bounds(mth, tcx, cdata);\n         let name = item_name(mth);\n         let ty = doc_type(mth, tcx, cdata);\n-        let fty = alt ty::get(ty).struct {\n+        let fty = match ty::get(ty).struct {\n           ty::ty_fn(f) => f,\n           _ => {\n             tcx.diag.handler().bug(\n@@ -684,7 +684,7 @@ fn get_trait_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n         let self_ty = get_self_ty(mth);\n         vec::push(result, {ident: name, tps: bounds, fty: fty,\n                     self_ty: self_ty,\n-                    purity: alt check item_family(mth) {\n+                    purity: match check item_family(mth) {\n                       'u' => ast::unsafe_fn,\n                       'f' => ast::impure_fn,\n                       'p' => ast::pure_fn\n@@ -742,7 +742,7 @@ fn get_class_members(cdata: cmd, id: ast::node_id,\n }\n \n pure fn family_to_visibility(family: char) -> ast::visibility {\n-    alt family {\n+    match family {\n       'g' => ast::public,\n       'j' => ast::private,\n       'N' => ast::inherited,\n@@ -756,7 +756,7 @@ fn get_class_fields(cdata: cmd, id: ast::node_id) -> ~[ty::field_ty] {\n }\n \n fn family_has_type_params(fam_ch: char) -> bool {\n-    alt check fam_ch {\n+    match check fam_ch {\n       'c' | 'T' | 'm' | 'n' | 'g' | 'h' | 'j' => false,\n       'f' | 'u' | 'p' | 'F' | 'U' | 'P' | 'y' | 't' | 'v' | 'i' | 'I' | 'C'\n           | 'a' | 'S'\n@@ -765,7 +765,7 @@ fn family_has_type_params(fam_ch: char) -> bool {\n }\n \n fn family_names_type(fam_ch: char) -> bool {\n-    alt fam_ch { 'y' | 't' | 'I' => true, _ => false }\n+    match fam_ch { 'y' | 't' | 'I' => true, _ => false }\n }\n \n fn read_path(d: ebml::doc) -> {path: ~str, pos: uint} {\n@@ -778,15 +778,15 @@ fn read_path(d: ebml::doc) -> {path: ~str, pos: uint} {\n \n fn describe_def(items: ebml::doc, id: ast::def_id) -> ~str {\n     if id.crate != ast::local_crate { return ~\"external\"; }\n-    let it = alt maybe_find_item(id.node, items) {\n+    let it = match maybe_find_item(id.node, items) {\n         some(it) => it,\n         none => fail (fmt!{\"describe_def: item not found %?\", id})\n     };\n     return item_family_to_str(item_family(it));\n }\n \n fn item_family_to_str(fam: char) -> ~str {\n-    alt check fam {\n+    match check fam {\n       'c' => return ~\"const\",\n       'f' => return ~\"fn\",\n       'u' => return ~\"unsafe fn\",\n@@ -837,7 +837,7 @@ fn get_meta_items(md: ebml::doc) -> ~[@ast::meta_item] {\n \n fn get_attributes(md: ebml::doc) -> ~[ast::attribute] {\n     let mut attrs: ~[ast::attribute] = ~[];\n-    alt ebml::maybe_get_doc(md, tag_attributes) {\n+    match ebml::maybe_get_doc(md, tag_attributes) {\n       option::some(attrs_d) => {\n         for ebml::tagged_docs(attrs_d, tag_attribute) |attr_doc| {\n             let meta_items = get_meta_items(attr_doc);\n@@ -916,7 +916,7 @@ fn get_crate_hash(data: @~[u8]) -> @~str {\n \n fn get_crate_vers(data: @~[u8]) -> @~str {\n     let attrs = decoder::get_crate_attributes(data);\n-    return alt attr::last_meta_item_value_str_by_name(\n+    return match attr::last_meta_item_value_str_by_name(\n         attr::find_linkage_metas(attrs), ~\"vers\") {\n       some(ver) => ver,\n       none => @~\"0.0\"\n@@ -997,7 +997,7 @@ fn translate_def_id(cdata: cmd, did: ast::def_id) -> ast::def_id {\n         return {crate: cdata.cnum, node: did.node};\n     }\n \n-    alt cdata.cnum_map.find(did.crate) {\n+    match cdata.cnum_map.find(did.crate) {\n       option::some(n) => return {crate: n, node: did.node},\n       option::none => fail ~\"didn't find a crate in the cnum_map\"\n     }"}, {"sha": "39057647b7fc83f856ad4ea64f7dd36f7a6b72e8", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -101,7 +101,7 @@ fn encode_named_def_id(ebml_w: ebml::writer, name: ident, id: def_id) {\n \n fn encode_mutability(ebml_w: ebml::writer, mt: class_mutability) {\n     do ebml_w.wr_tag(tag_class_mut) {\n-        let val = alt mt {\n+        let val = match mt {\n           class_immutable => 'i',\n           class_mutable => 'm'\n         };\n@@ -145,10 +145,10 @@ fn encode_foreign_module_item_paths(ebml_w: ebml::writer, nmod: foreign_mod,\n fn encode_class_item_paths(ebml_w: ebml::writer,\n      items: ~[@class_member], path: ~[ident], &index: ~[entry<~str>]) {\n     for items.each |it| {\n-     alt ast_util::class_member_visibility(it) {\n+     match ast_util::class_member_visibility(it) {\n           private => again,\n           public | inherited => {\n-              let (id, ident) = alt it.node {\n+              let (id, ident) = match it.node {\n                  instance_var(v, _, _, vid, _) => (vid, v),\n                  class_method(it) => (it.id, it.ident)\n               };\n@@ -168,7 +168,7 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n         if !ast_util::is_item_impl(it) {\n             add_to_index(ebml_w, path, index, it.ident);\n         }\n-        alt it.node {\n+        match it.node {\n           item_const(_, _) => {\n             encode_named_def_id(ebml_w, it.ident, local_def(it.id));\n           }\n@@ -205,7 +205,7 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                 // class and for its ctor\n                 add_to_index(ebml_w, path, index, it.ident);\n \n-                alt m_ctor {\n+                match m_ctor {\n                     none => {\n                         // Nothing to do.\n                     }\n@@ -317,7 +317,7 @@ fn encode_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n \n fn encode_symbol(ecx: @encode_ctxt, ebml_w: ebml::writer, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n-    let sym = alt ecx.item_symbols.find(id) {\n+    let sym = match ecx.item_symbols.find(id) {\n       some(x) => x,\n       none => {\n         ecx.diag.handler().bug(\n@@ -382,7 +382,7 @@ fn encode_path(ebml_w: ebml::writer,\n                path: ast_map::path,\n                name: ast_map::path_elt) {\n     fn encode_path_elt(ebml_w: ebml::writer, elt: ast_map::path_elt) {\n-        let (tag, name) = alt elt {\n+        let (tag, name) = match elt {\n           ast_map::path_mod(name) => (tag_path_elt_mod, name),\n           ast_map::path_name(name) => (tag_path_elt_name, name)\n         };\n@@ -416,7 +416,7 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n                ast_util::is_exported(ident, md)};\n \n         ebml_w.start_tag(tag_mod_impl);\n-        alt ecx.tcx.items.find(did.node) {\n+        match ecx.tcx.items.find(did.node) {\n           some(ast_map::node_item(it@@{node: cl@item_class(*),_},_)) => {\n         /* If did stands for a trait\n         ref, we need to map it to its parent class */\n@@ -436,15 +436,15 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n }\n \n fn encode_visibility(ebml_w: ebml::writer, visibility: visibility) {\n-    encode_family(ebml_w, alt visibility {\n+    encode_family(ebml_w, match visibility {\n         public => 'g',\n         private => 'j',\n         inherited => 'N'\n     });\n }\n \n fn encode_region(ebml_w: ebml::writer, region: region) {\n-    alt region.node {\n+    match region.node {\n         re_anon => {\n             ebml_w.wr_tagged_str(tag_item_trait_method_self_ty, ~\"\");\n         }\n@@ -459,7 +459,7 @@ fn encode_self_type(ebml_w: ebml::writer, self_type: ast::self_ty_) {\n \n     // Encode the base self type.\n     let ch;\n-    alt self_type {\n+    match self_type {\n         sty_by_ref =>       { ch = 'r' as u8; }\n         sty_value =>        { ch = 'v' as u8; }\n         sty_region(_, _) => { ch = '&' as u8; }\n@@ -469,7 +469,7 @@ fn encode_self_type(ebml_w: ebml::writer, self_type: ast::self_ty_) {\n     ebml_w.writer.write(&[ ch ]);\n \n     // Encode mutability.\n-    alt self_type {\n+    match self_type {\n         sty_by_ref | sty_value => { /* No-op. */ }\n         sty_region(_, m_imm) | sty_box(m_imm) | sty_uniq(m_imm) => {\n             ebml_w.writer.write(&[ 'i' as u8 ]);\n@@ -483,7 +483,7 @@ fn encode_self_type(ebml_w: ebml::writer, self_type: ast::self_ty_) {\n     }\n \n     // Encode the region.\n-    alt self_type {\n+    match self_type {\n         sty_region(region, _) => {\n             encode_region(ebml_w, *region);\n         }\n@@ -508,7 +508,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     for items.each |ci| {\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n-      alt ci.node {\n+      match ci.node {\n         instance_var(nm, _, mt, id, vis) => {\n           vec::push(*index, {val: id, pos: ebml_w.writer.tell()});\n           vec::push(*global_index, {val: id, pos: ebml_w.writer.tell()});\n@@ -523,7 +523,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n           ebml_w.end_tag();\n         }\n         class_method(m) => {\n-           alt m.vis {\n+           match m.vis {\n               public | inherited => {\n                 vec::push(*index, {val: m.id, pos: ebml_w.writer.tell()});\n                 vec::push(*global_index,\n@@ -557,7 +557,7 @@ fn encode_info_for_fn(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                util::ppaux::ty_to_str(ecx.tcx, its_ty), id};\n         encode_type(ecx, ebml_w, its_ty);\n         encode_path(ebml_w, path, ast_map::path_name(ident));\n-        alt item {\n+        match item {\n            some(it) => {\n              ecx.encode_inlined_item(ecx, ebml_w, path, it);\n            }\n@@ -592,7 +592,7 @@ fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: ebml::writer,\n }\n \n fn purity_fn_family(p: purity) -> char {\n-    alt p {\n+    match p {\n       unsafe_fn => 'u',\n       pure_fn => 'p',\n       impure_fn => 'f',\n@@ -602,7 +602,7 @@ fn purity_fn_family(p: purity) -> char {\n \n \n fn should_inline(attrs: ~[attribute]) -> bool {\n-    alt attr::find_inline_attr(attrs) {\n+    match attr::find_inline_attr(attrs) {\n         attr::ia_none | attr::ia_never  => false,\n         attr::ia_hint | attr::ia_always => true\n     }\n@@ -614,7 +614,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n \n     let tcx = ecx.tcx;\n     let must_write =\n-        alt item.node {\n+        match item.node {\n           item_enum(_, _) | item_impl(*)\n           | item_trait(*) | item_class(*) => true,\n           _ => false\n@@ -627,7 +627,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n     }\n     let add_to_index = |copy ebml_w| add_to_index_(item, ebml_w, index);\n \n-    alt item.node {\n+    match item.node {\n       item_const(_, _) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n@@ -719,7 +719,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n \n-        alt ctor {\n+        match ctor {\n             none => encode_family(ebml_w, 'S'),\n             some(_) => encode_family(ebml_w, 'C')\n         }\n@@ -752,7 +752,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n            ebml_w.end_tag();\n         }\n         for ms.each |m| {\n-           alt m.vis {\n+           match m.vis {\n               private => { /* do nothing */ }\n               public | inherited => {\n                 /* Write the info that's needed when viewing this class\n@@ -823,7 +823,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_attributes(ebml_w, item.attrs);\n         let mut i = 0u;\n         for vec::each(*ty::trait_methods(tcx, local_def(item.id))) |mty| {\n-            alt ms[i] {\n+            match ms[i] {\n               required(ty_m) => {\n                 ebml_w.start_tag(tag_item_trait_method);\n                 encode_name(ebml_w, mty.ident);\n@@ -859,7 +859,7 @@ fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     vec::push(*index, {val: nitem.id, pos: ebml_w.writer.tell()});\n \n     ebml_w.start_tag(tag_items_data_item);\n-    alt nitem.node {\n+    match nitem.node {\n       foreign_item_fn(fn_decl, tps) => {\n         encode_def_id(ebml_w, local_def(nitem.id));\n         encode_family(ebml_w, purity_fn_family(fn_decl.purity));\n@@ -888,11 +888,11 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         visit_expr: |_e, _cx, _v| { },\n         visit_item: |i, cx, v, copy ebml_w| {\n             visit::visit_item(i, cx, v);\n-            alt check ecx.tcx.items.get(i.id) {\n+            match check ecx.tcx.items.get(i.id) {\n               ast_map::node_item(_, pt) => {\n                 encode_info_for_item(ecx, ebml_w, i, index, *pt);\n                 /* encode ctor, then encode items */\n-                alt i.node {\n+                match i.node {\n                    item_class(tps, _, _, some(ctor), m_dtor) => {\n                        debug!{\"encoding info for ctor %s %d\", *i.ident,\n                               ctor.node.id};\n@@ -913,7 +913,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         },\n         visit_foreign_item: |ni, cx, v, copy ebml_w| {\n             visit::visit_foreign_item(ni, cx, v);\n-            alt check ecx.tcx.items.get(ni.id) {\n+            match check ecx.tcx.items.get(ni.id) {\n               ast_map::node_foreign_item(_, abi, pt) => {\n                 encode_info_for_foreign_item(ecx, ebml_w, ni,\n                                              index, *pt, abi);\n@@ -981,7 +981,7 @@ fn write_int(writer: io::writer, &&n: int) {\n }\n \n fn encode_meta_item(ebml_w: ebml::writer, mi: meta_item) {\n-    alt mi.node {\n+    match mi.node {\n       meta_word(name) => {\n         ebml_w.start_tag(tag_meta_item_word);\n         ebml_w.start_tag(tag_meta_item_name);\n@@ -990,7 +990,7 @@ fn encode_meta_item(ebml_w: ebml::writer, mi: meta_item) {\n         ebml_w.end_tag();\n       }\n       meta_name_value(name, value) => {\n-        alt value.node {\n+        match value.node {\n           lit_str(value) => {\n             ebml_w.start_tag(tag_meta_item_name_value);\n             ebml_w.start_tag(tag_meta_item_name);\n@@ -1064,7 +1064,7 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n             if *attr::get_attr_name(attr) != ~\"link\" {\n                 attr\n             } else {\n-                alt attr.node.value.node {\n+                match attr.node.value.node {\n                   meta_list(n, l) => {\n                     found_link_attr = true;;\n                     synthesize_link_attr(ecx, l)"}, {"sha": "54aef6e858f9c9c994d52eebaf9a3410e1cf8206", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -43,11 +43,11 @@ fn mk_filesearch(maybe_sysroot: option<path>,\n \n             vec::push(paths,\n                       make_target_lib_path(self.sysroot, self.target_triple));\n-            alt get_cargo_lib_path_nearest() {\n+            match get_cargo_lib_path_nearest() {\n               result::ok(p) => vec::push(paths, p),\n               result::err(p) => ()\n             }\n-            alt get_cargo_lib_path() {\n+            match get_cargo_lib_path() {\n               result::ok(p) => vec::push(paths, p),\n               result::err(p) => ()\n             }\n@@ -101,14 +101,14 @@ fn make_target_lib_path(sysroot: path,\n }\n \n fn get_default_sysroot() -> path {\n-    alt os::self_exe_path() {\n+    match os::self_exe_path() {\n       option::some(p) => path::normalize(path::connect(p, ~\"..\")),\n       option::none => fail ~\"can't determine value for sysroot\"\n     }\n }\n \n fn get_sysroot(maybe_sysroot: option<path>) -> path {\n-    alt maybe_sysroot {\n+    match maybe_sysroot {\n       option::some(sr) => sr,\n       option::none => get_default_sysroot()\n     }\n@@ -120,9 +120,9 @@ fn get_cargo_sysroot() -> result<path, ~str> {\n }\n \n fn get_cargo_root() -> result<path, ~str> {\n-    alt os::getenv(~\"CARGO_ROOT\") {\n+    match os::getenv(~\"CARGO_ROOT\") {\n         some(_p) => result::ok(_p),\n-        none => alt os::homedir() {\n+        none => match os::homedir() {\n           some(_q) => result::ok(path::connect(_q, ~\".cargo\")),\n           none => result::err(~\"no CARGO_ROOT or home directory\")\n         }"}, {"sha": "e5a2e0848e9225e3365c4261bf973a72ed6fcd22", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -37,7 +37,7 @@ type ctxt = {\n };\n \n fn load_library_crate(cx: ctxt) -> {ident: ~str, data: @~[u8]} {\n-    alt find_library_crate(cx) {\n+    match find_library_crate(cx) {\n       some(t) => return t,\n       none => {\n         cx.diag.span_fatal(\n@@ -53,7 +53,7 @@ fn find_library_crate(cx: ctxt) -> option<{ident: ~str, data: @~[u8]}> {\n \n fn libname(cx: ctxt) -> {prefix: ~str, suffix: ~str} {\n     if cx.static { return {prefix: ~\"lib\", suffix: ~\".rlib\"}; }\n-    alt cx.os {\n+    match cx.os {\n       os_win32 => return {prefix: ~\"\", suffix: ~\".dll\"},\n       os_macos => return {prefix: ~\"lib\", suffix: ~\".dylib\"},\n       os_linux => return {prefix: ~\"lib\", suffix: ~\".so\"},\n@@ -79,7 +79,7 @@ fn find_library_crate_aux(cx: ctxt,\n             option::none::<()>\n         } else {\n             debug!{\"%s is a candidate\", path};\n-            alt get_metadata_section(cx.os, path) {\n+            match get_metadata_section(cx.os, path) {\n               option::some(cvec) => {\n                 if !crate_matches(cvec, cx.metas, cx.hash) {\n                     debug!{\"skipping %s, metadata doesn't match\", path};\n@@ -118,9 +118,9 @@ fn find_library_crate_aux(cx: ctxt,\n \n fn crate_name_from_metas(metas: ~[@ast::meta_item]) -> @~str {\n     let name_items = attr::find_meta_items_by_name(metas, ~\"name\");\n-    alt vec::last_opt(name_items) {\n+    match vec::last_opt(name_items) {\n       some(i) => {\n-        alt attr::get_meta_item_value_str(i) {\n+        match attr::get_meta_item_value_str(i) {\n           some(n) => n,\n           // FIXME (#2406): Probably want a warning here since the user\n           // is using the wrong type of meta item.\n@@ -175,7 +175,7 @@ fn get_metadata_section(os: os,\n         llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n                                    });\n     if mb as int == 0 { return option::none::<@~[u8]>; }\n-    let of = alt mk_object_file(mb) {\n+    let of = match mk_object_file(mb) {\n         option::some(of) => of,\n         _ => return option::none::<@~[u8]>\n     };\n@@ -197,7 +197,7 @@ fn get_metadata_section(os: os,\n }\n \n fn meta_section_name(os: os) -> ~str {\n-    alt os {\n+    match os {\n       os_macos => ~\"__DATA,__note.rustc\",\n       os_win32 => ~\".note.rustc\",\n       os_linux => ~\".note.rustc\",\n@@ -207,7 +207,7 @@ fn meta_section_name(os: os) -> ~str {\n \n // A diagnostic function for dumping crate metadata to an output stream\n fn list_file_metadata(os: os, path: ~str, out: io::writer) {\n-    alt get_metadata_section(os, path) {\n+    match get_metadata_section(os, path) {\n       option::some(bytes) => decoder::list_crate_metadata(bytes, out),\n       option::none => {\n         out.write_str(~\"could not find metadata in \" + path + ~\".\\n\");"}, {"sha": "a834147af96103f98b911fee15913821916cc968", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -57,7 +57,7 @@ fn parse_ty_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n }\n \n fn parse_ret_ty(st: @pstate, conv: conv_did) -> (ast::ret_style, ty::t) {\n-    alt peek(st) {\n+    match peek(st) {\n       '!' => { next(st); (ast::noreturn, ty::mk_bot(st.tcx)) }\n       _ => (ast::return_val, parse_ty(st, conv))\n     }\n@@ -68,7 +68,7 @@ fn parse_path(st: @pstate) -> @ast::path {\n     fn is_last(c: char) -> bool { return c == '(' || c == ':'; }\n     vec::push(idents, parse_ident_(st, is_last));\n     loop {\n-        alt peek(st) {\n+        match peek(st) {\n           ':' => { next(st); next(st); }\n           c => {\n             if c == '(' {\n@@ -86,7 +86,7 @@ fn parse_ty_rust_fn(st: @pstate, conv: conv_did) -> ty::t {\n }\n \n fn parse_proto(c: char) -> ast::proto {\n-    alt c {\n+    match c {\n       '~' => ast::proto_uniq,\n       '@' => ast::proto_box,\n       '&' => ast::proto_block,\n@@ -105,7 +105,7 @@ fn parse_vstore(st: @pstate) -> ty::vstore {\n         return ty::vstore_fixed(n);\n     }\n \n-    alt check next(st) {\n+    match check next(st) {\n       '~' => ty::vstore_uniq,\n       '@' => ty::vstore_box,\n       '&' => ty::vstore_slice(parse_region(st))\n@@ -128,7 +128,7 @@ fn parse_substs(st: @pstate, conv: conv_did) -> ty::substs {\n }\n \n fn parse_bound_region(st: @pstate) -> ty::bound_region {\n-    alt check next(st) {\n+    match check next(st) {\n       's' => ty::br_self,\n       'a' => ty::br_anon,\n       '[' => ty::br_named(@parse_str(st, ']')),\n@@ -141,7 +141,7 @@ fn parse_bound_region(st: @pstate) -> ty::bound_region {\n }\n \n fn parse_region(st: @pstate) -> ty::region {\n-    alt check next(st) {\n+    match check next(st) {\n       'b' => {\n         ty::re_bound(parse_bound_region(st))\n       }\n@@ -165,7 +165,7 @@ fn parse_region(st: @pstate) -> ty::region {\n }\n \n fn parse_opt<T>(st: @pstate, f: fn() -> T) -> option<T> {\n-    alt check next(st) {\n+    match check next(st) {\n       'n' => none,\n       's' => some(f())\n     }\n@@ -181,15 +181,15 @@ fn parse_str(st: @pstate, term: char) -> ~str {\n }\n \n fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n-    alt check next(st) {\n+    match check next(st) {\n       'n' => return ty::mk_nil(st.tcx),\n       'z' => return ty::mk_bot(st.tcx),\n       'b' => return ty::mk_bool(st.tcx),\n       'i' => return ty::mk_int(st.tcx),\n       'u' => return ty::mk_uint(st.tcx),\n       'l' => return ty::mk_float(st.tcx),\n       'M' => {\n-        alt check next(st) {\n+        match check next(st) {\n           'b' => return ty::mk_mach_uint(st.tcx, ast::ty_u8),\n           'w' => return ty::mk_mach_uint(st.tcx, ast::ty_u16),\n           'l' => return ty::mk_mach_uint(st.tcx, ast::ty_u32),\n@@ -267,7 +267,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n       }\n       'Y' => return ty::mk_type(st.tcx),\n       'C' => {\n-        let ck = alt check next(st) {\n+        let ck = match check next(st) {\n           '&' => ty::ck_block,\n           '@' => ty::ck_box,\n           '~' => ty::ck_uniq\n@@ -279,7 +279,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         assert (next(st) == ':');\n         let len = parse_hex(st);\n         assert (next(st) == '#');\n-        alt st.tcx.rcache.find({cnum: st.crate, pos: pos, len: len}) {\n+        match st.tcx.rcache.find({cnum: st.crate, pos: pos, len: len}) {\n           some(tt) => return tt,\n           none => {\n             let ps = @{pos: pos with *st};\n@@ -311,7 +311,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n \n fn parse_mt(st: @pstate, conv: conv_did) -> ty::mt {\n     let mut m;\n-    alt peek(st) {\n+    match peek(st) {\n       'm' => { next(st); m = ast::m_mutbl; }\n       '?' => { next(st); m = ast::m_const; }\n       _ => { m = ast::m_imm; }\n@@ -351,7 +351,7 @@ fn parse_hex(st: @pstate) -> uint {\n }\n \n fn parse_purity(c: char) -> purity {\n-    alt check c {\n+    match check c {\n       'u' => unsafe_fn,\n       'p' => pure_fn,\n       'i' => impure_fn,\n@@ -365,7 +365,7 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::fn_ty {\n     assert (next(st) == '[');\n     let mut inputs: ~[ty::arg] = ~[];\n     while peek(st) != ']' {\n-        let mode = alt check peek(st) {\n+        let mode = match check peek(st) {\n           '&' => ast::by_mutbl_ref,\n           '-' => ast::by_move,\n           '+' => ast::by_copy,\n@@ -394,12 +394,12 @@ fn parse_def_id(buf: &[u8]) -> ast::def_id {\n     let crate_part = vec::slice(buf, 0u, colon_idx);\n     let def_part = vec::slice(buf, colon_idx + 1u, len);\n \n-    let crate_num = alt uint::parse_buf(crate_part, 10u) {\n+    let crate_num = match uint::parse_buf(crate_part, 10u) {\n        some(cn) => cn as int,\n        none => fail (fmt!{\"internal error: parse_def_id: crate number \\\n                                expected, but found %?\", crate_part})\n     };\n-    let def_num = alt uint::parse_buf(def_part, 10u) {\n+    let def_num = match uint::parse_buf(def_part, 10u) {\n        some(dn) => dn as int,\n        none => fail (fmt!{\"internal error: parse_def_id: id expected, but \\\n                                found %?\", def_part})\n@@ -417,7 +417,7 @@ fn parse_bounds_data(data: @~[u8], start: uint,\n fn parse_bounds(st: @pstate, conv: conv_did) -> @~[ty::param_bound] {\n     let mut bounds = ~[];\n     loop {\n-        vec::push(bounds, alt check next(st) {\n+        vec::push(bounds, match check next(st) {\n           'S' => ty::bound_send,\n           'C' => ty::bound_copy,\n           'K' => ty::bound_const,"}, {"sha": "458dc149802c60fbea01c52ba16704b6eb8625af", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -34,16 +34,16 @@ type ty_abbrev = {pos: uint, len: uint, s: @~str};\n enum abbrev_ctxt { ac_no_abbrevs, ac_use_abbrevs(hashmap<ty::t, ty_abbrev>), }\n \n fn cx_uses_abbrevs(cx: @ctxt) -> bool {\n-    alt cx.abbrevs {\n+    match cx.abbrevs {\n       ac_no_abbrevs => return false,\n       ac_use_abbrevs(_) => return true\n     }\n }\n \n fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n-    alt cx.abbrevs {\n+    match cx.abbrevs {\n       ac_no_abbrevs => {\n-        let result_str = alt cx.tcx.short_names_cache.find(t) {\n+        let result_str = match cx.tcx.short_names_cache.find(t) {\n           some(s) => *s,\n           none => {\n             let buf = io::mem_buffer();\n@@ -55,11 +55,11 @@ fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n         w.write_str(result_str);\n       }\n       ac_use_abbrevs(abbrevs) => {\n-        alt abbrevs.find(t) {\n+        match abbrevs.find(t) {\n           some(a) => { w.write_str(*a.s); return; }\n           none => {\n             let pos = w.tell();\n-            alt ty::type_def_id(t) {\n+            match ty::type_def_id(t) {\n               some(def_id) => {\n                 // Do not emit node ids that map to unexported names.  Those\n                 // are not helpful.\n@@ -96,7 +96,7 @@ fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n     }\n }\n fn enc_mt(w: io::writer, cx: @ctxt, mt: ty::mt) {\n-    alt mt.mutbl {\n+    match mt.mutbl {\n       m_imm => (),\n       m_mutbl => w.write_char('m'),\n       m_const => w.write_char('?')\n@@ -105,7 +105,7 @@ fn enc_mt(w: io::writer, cx: @ctxt, mt: ty::mt) {\n }\n \n fn enc_opt<T>(w: io::writer, t: option<T>, enc_f: fn(T)) {\n-    alt t {\n+    match t {\n       none => w.write_char('n'),\n       some(v) => {\n         w.write_char('s');\n@@ -123,7 +123,7 @@ fn enc_substs(w: io::writer, cx: @ctxt, substs: ty::substs) {\n }\n \n fn enc_region(w: io::writer, cx: @ctxt, r: ty::region) {\n-    alt r {\n+    match r {\n       ty::re_bound(br) => {\n         w.write_char('b');\n         enc_bound_region(w, br);\n@@ -152,7 +152,7 @@ fn enc_region(w: io::writer, cx: @ctxt, r: ty::region) {\n }\n \n fn enc_bound_region(w: io::writer, br: ty::bound_region) {\n-    alt br {\n+    match br {\n       ty::br_self => w.write_char('s'),\n       ty::br_anon => w.write_char('a'),\n       ty::br_named(s) => {\n@@ -171,7 +171,7 @@ fn enc_bound_region(w: io::writer, br: ty::bound_region) {\n \n fn enc_vstore(w: io::writer, cx: @ctxt, v: ty::vstore) {\n     w.write_char('/');\n-    alt v {\n+    match v {\n       ty::vstore_fixed(u) => {\n         w.write_uint(u);\n         w.write_char('|');\n@@ -190,12 +190,12 @@ fn enc_vstore(w: io::writer, cx: @ctxt, v: ty::vstore) {\n }\n \n fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n-    alt st {\n+    match st {\n       ty::ty_nil => w.write_char('n'),\n       ty::ty_bot => w.write_char('z'),\n       ty::ty_bool => w.write_char('b'),\n       ty::ty_int(t) => {\n-        alt t {\n+        match t {\n           ty_i => w.write_char('i'),\n           ty_char => w.write_char('c'),\n           ty_i8 => w.write_str(&\"MB\"),\n@@ -205,7 +205,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         }\n       }\n       ty::ty_uint(t) => {\n-        alt t {\n+        match t {\n           ty_u => w.write_char('u'),\n           ty_u8 => w.write_str(&\"Mb\"),\n           ty_u16 => w.write_str(&\"Mw\"),\n@@ -214,7 +214,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         }\n       }\n       ty::ty_float(t) => {\n-        alt t {\n+        match t {\n           ty_f => w.write_char('l'),\n           ty_f32 => w.write_str(&\"Mf\"),\n           ty_f64 => w.write_str(&\"MF\"),\n@@ -307,7 +307,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n     }\n }\n fn enc_proto(w: io::writer, proto: proto) {\n-    alt proto {\n+    match proto {\n       proto_uniq => w.write_str(&\"f~\"),\n       proto_box => w.write_str(&\"f@\"),\n       proto_block => w.write_str(~\"f&\"),\n@@ -316,7 +316,7 @@ fn enc_proto(w: io::writer, proto: proto) {\n }\n \n fn enc_mode(w: io::writer, cx: @ctxt, m: mode) {\n-    alt ty::resolved_mode(cx.tcx, m) {\n+    match ty::resolved_mode(cx.tcx, m) {\n       by_mutbl_ref => w.write_char('&'),\n       by_move => w.write_char('-'),\n       by_copy => w.write_char('+'),\n@@ -326,7 +326,7 @@ fn enc_mode(w: io::writer, cx: @ctxt, m: mode) {\n }\n \n fn enc_purity(w: io::writer, p: purity) {\n-    alt p {\n+    match p {\n       pure_fn => w.write_char('p'),\n       impure_fn => w.write_char('i'),\n       unsafe_fn => w.write_char('u'),\n@@ -343,15 +343,15 @@ fn enc_ty_fn(w: io::writer, cx: @ctxt, ft: ty::fn_ty) {\n         enc_ty(w, cx, arg.ty);\n     }\n     w.write_char(']');\n-    alt ft.ret_style {\n+    match ft.ret_style {\n       noreturn => w.write_char('!'),\n       _ => enc_ty(w, cx, ft.output)\n     }\n }\n \n fn enc_bounds(w: io::writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n     for vec::each(*bs) |bound| {\n-        alt bound {\n+        match bound {\n           ty::bound_send => w.write_char('S'),\n           ty::bound_copy => w.write_char('C'),\n           ty::bound_const => w.write_char('K'),"}, {"sha": "b1b548169983dedf1afdf6155f7b1e2377fe1286", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -111,7 +111,7 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n                        path: ast_map::path,\n                        par_doc: ebml::doc) -> option<ast::inlined_item> {\n     let dcx = @{cdata: cdata, tcx: tcx, maps: maps};\n-    alt par_doc.opt_child(c::tag_ast) {\n+    match par_doc.opt_child(c::tag_ast) {\n       none => none,\n       some(ast_doc) => {\n         debug!{\"> Decoding inlined fn: %s::?\", ast_map::path_to_str(path)};\n@@ -129,7 +129,7 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n         decode_side_tables(xcx, ast_doc);\n         debug!{\"< Decoded inlined fn: %s::%s\",\n                ast_map::path_to_str(path), *ii.ident()};\n-        alt ii {\n+        match ii {\n           ast::ii_item(i) => {\n             debug!{\">>> DECODED ITEM >>>\\n%s\\n<<< DECODED ITEM <<<\",\n                    syntax::print::pprust::item_to_str(i)};\n@@ -245,7 +245,7 @@ fn encode_ast(ebml_w: ebml::writer, item: ast::inlined_item) {\n fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n     fn drop_nested_items(blk: ast::blk_, fld: fold::ast_fold) -> ast::blk_ {\n         let stmts_sans_items = do vec::filter(blk.stmts) |stmt| {\n-            alt stmt.node {\n+            match stmt.node {\n               ast::stmt_expr(_, _) | ast::stmt_semi(_, _) |\n               ast::stmt_decl(@{node: ast::decl_local(_), span: _}, _) => true,\n               ast::stmt_decl(@{node: ast::decl_item(_), span: _}, _) => false\n@@ -260,7 +260,7 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n         with *fold::default_ast_fold()\n     });\n \n-    alt ii {\n+    match ii {\n       ast::ii_item(i) => {\n         ast::ii_item(fld.fold_item(i).get()) //hack: we're not dropping items\n       }\n@@ -300,7 +300,7 @@ fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n         with *fold::default_ast_fold()\n     });\n \n-    alt ii {\n+    match ii {\n       ast::ii_item(i) => {\n         ast::ii_item(fld.fold_item(i).get())\n       }\n@@ -352,7 +352,7 @@ fn decode_def(xcx: extended_decode_ctxt, doc: ebml::doc) -> ast::def {\n \n impl of tr for ast::def {\n     fn tr(xcx: extended_decode_ctxt) -> ast::def {\n-        alt self {\n+        match self {\n           ast::def_fn(did, p) => ast::def_fn(did.tr(xcx), p),\n           ast::def_self(nid) => ast::def_self(xcx.tr_id(nid)),\n           ast::def_mod(did) => ast::def_mod(did.tr(xcx)),\n@@ -422,7 +422,7 @@ impl helper of read_method_map_entry_helper for ebml::ebml_deserializer {\n \n impl of tr for method_origin {\n     fn tr(xcx: extended_decode_ctxt) -> method_origin {\n-        alt self {\n+        match self {\n           typeck::method_static(did) => {\n             typeck::method_static(did.tr(xcx))\n           }\n@@ -455,7 +455,7 @@ fn encode_vtable_origin(ecx: @e::encode_ctxt,\n                       ebml_w: ebml::writer,\n                       vtable_origin: typeck::vtable_origin) {\n     do ebml_w.emit_enum(~\"vtable_origin\") {\n-        alt vtable_origin {\n+        match vtable_origin {\n           typeck::vtable_static(def_id, tys, vtable_res) => {\n             do ebml_w.emit_enum_variant(~\"vtable_static\", 0u, 3u) {\n                 do ebml_w.emit_enum_variant_arg(0u) {\n@@ -508,7 +508,7 @@ impl helpers of vtable_deserialization_helpers for ebml::ebml_deserializer {\n         -> typeck::vtable_origin {\n         do self.read_enum(~\"vtable_origin\") {\n             do self.read_enum_variant |i| {\n-                alt check i {\n+                match check i {\n                   0u => {\n                     typeck::vtable_static(\n                         do self.read_enum_variant_arg(0u) {\n@@ -992,7 +992,7 @@ fn test_simplification() {\n             return {eq_fn: eq_int, mut data: ~[]};\n         }\n     });\n-    alt (item_out, item_exp) {\n+    match (item_out, item_exp) {\n       (ast::ii_item(item_out), ast::ii_item(item_exp)) => {\n         assert pprust::item_to_str(item_out) == pprust::item_to_str(item_exp);\n       }"}, {"sha": "2896ad32d6ae8cd0fd2a4b93bd12e224fa962ce6", "filename": "src/rustc/middle/block_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fblock_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fblock_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fblock_use.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -13,7 +13,7 @@ fn check_crate(tcx: ty::ctxt, crate: @crate) {\n \n fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n     if !cx.allow_block {\n-        alt ty::get(ty::expr_ty(cx.tcx, ex)).struct {\n+        match ty::get(ty::expr_ty(cx.tcx, ex)).struct {\n           ty::ty_fn({proto: p, _}) if is_blockish(p) => {\n             cx.tcx.sess.span_err(ex.span,\n                ~\"expressions with stack closure type \\\n@@ -23,7 +23,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n         }\n     }\n     let outer = cx.allow_block;\n-    alt ex.node {\n+    match ex.node {\n       expr_call(f, args, _) => {\n         cx.allow_block = true;\n         v.visit_expr(f, cx, v);"}, {"sha": "3df0cb3b25e515bfa400380a9df39c9dd3288ff7", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -91,7 +91,7 @@ In other cases, like an enum on the stack, the memory cannot be freed\n but its type can change:\n \n     let mut x = some(5);\n-    alt x {\n+    match x {\n       some(ref y) => { ... }\n       none => { ... }\n     }\n@@ -105,7 +105,7 @@ Finally, in some cases, both dangers can arise.  For example, something\n like the following:\n \n     let mut x = ~some(5);\n-    alt x {\n+    match x {\n       ~some(ref y) => { ... }\n       ~none => { ... }\n     }\n@@ -343,7 +343,7 @@ enum categorization {\n     cat_stack_upvar(cmt),           // upvar in stack closure\n     cat_deref(cmt, uint, ptr_kind), // deref of a ptr\n     cat_comp(cmt, comp_kind),       // adjust to locate an internal component\n-    cat_discr(cmt, ast::node_id),   // alt discriminant (see preserve())\n+    cat_discr(cmt, ast::node_id),   // match discriminant (see preserve())\n }\n \n // different kinds of pointers:\n@@ -456,7 +456,7 @@ impl methods of get_type_for_node for ty::ctxt {\n \n impl error_methods for borrowck_ctxt {\n     fn report_if_err(bres: bckres<()>) {\n-        alt bres {\n+        match bres {\n           ok(()) => (),\n           err(e) => self.report(e)\n         }\n@@ -478,7 +478,7 @@ impl error_methods for borrowck_ctxt {\n     }\n \n     fn add_to_mutbl_map(cmt: cmt) {\n-        alt cmt.cat {\n+        match cmt.cat {\n           cat_local(id) | cat_arg(id) => {\n             self.mutbl_map.insert(id, ());\n           }\n@@ -492,7 +492,7 @@ impl error_methods for borrowck_ctxt {\n \n impl to_str_methods for borrowck_ctxt {\n     fn cat_to_repr(cat: categorization) -> ~str {\n-        alt cat {\n+        match cat {\n           cat_special(sk_method) => ~\"method\",\n           cat_special(sk_static_item) => ~\"static_item\",\n           cat_special(sk_self) => ~\"self\",\n@@ -514,15 +514,15 @@ impl to_str_methods for borrowck_ctxt {\n     }\n \n     fn mut_to_str(mutbl: ast::mutability) -> ~str {\n-        alt mutbl {\n+        match mutbl {\n           m_mutbl => ~\"mutable\",\n           m_const => ~\"const\",\n           m_imm => ~\"immutable\"\n         }\n     }\n \n     fn ptr_sigil(ptr: ptr_kind) -> ~str {\n-        alt ptr {\n+        match ptr {\n           uniq_ptr => ~\"~\",\n           gc_ptr => ~\"@\",\n           region_ptr(_) => ~\"&\",\n@@ -531,7 +531,7 @@ impl to_str_methods for borrowck_ctxt {\n     }\n \n     fn comp_to_repr(comp: comp_kind) -> ~str {\n-        alt comp {\n+        match comp {\n           comp_field(fld, _) => *fld,\n           comp_index(*) => ~\"[]\",\n           comp_tuple => ~\"()\",\n@@ -540,7 +540,7 @@ impl to_str_methods for borrowck_ctxt {\n     }\n \n     fn lp_to_str(lp: @loan_path) -> ~str {\n-        alt *lp {\n+        match *lp {\n           lp_local(node_id) => {\n             fmt!{\"local(%d)\", node_id}\n           }\n@@ -569,7 +569,7 @@ impl to_str_methods for borrowck_ctxt {\n \n     fn cmt_to_str(cmt: cmt) -> ~str {\n         let mut_str = self.mut_to_str(cmt.mutbl);\n-        alt cmt.cat {\n+        match cmt.cat {\n           cat_special(sk_method) => ~\"method\",\n           cat_special(sk_static_item) => ~\"static item\",\n           cat_special(sk_self) => ~\"self reference\",\n@@ -589,7 +589,7 @@ impl to_str_methods for borrowck_ctxt {\n           cat_comp(_, comp_tuple) => ~\"tuple content\",\n           cat_comp(_, comp_variant(_)) => ~\"enum content\",\n           cat_comp(_, comp_index(t, _)) => {\n-            alt ty::get(t).struct {\n+            match ty::get(t).struct {\n               ty::ty_evec(*) => mut_str + ~\" vec content\",\n               ty::ty_estr(*) => mut_str + ~\" str content\",\n               _ => mut_str + ~\" indexed content\"\n@@ -602,7 +602,7 @@ impl to_str_methods for borrowck_ctxt {\n     }\n \n     fn bckerr_code_to_str(code: bckerr_code) -> ~str {\n-        alt code {\n+        match code {\n           err_mutbl(req, act) => {\n             fmt!{\"creating %s alias to aliasable, %s memory\",\n                  self.mut_to_str(req), self.mut_to_str(act)}\n@@ -644,7 +644,7 @@ impl to_str_methods for borrowck_ctxt {\n // mutability can be \"overridden\" if the component is embedded in a\n // mutable structure.\n fn inherent_mutability(ck: comp_kind) -> mutability {\n-    alt ck {\n+    match ck {\n       comp_tuple | comp_variant(_)        => m_imm,\n       comp_field(_, m) | comp_index(_, m) => m\n     }"}, {"sha": "e113c957c15baa90db411547047535b2539393fb", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -43,7 +43,7 @@ export opt_deref_kind;\n // derefable (we model an index as the combination of a deref and then a\n // pointer adjustment).\n fn opt_deref_kind(t: ty::t) -> option<deref_kind> {\n-    alt ty::get(t).struct {\n+    match ty::get(t).struct {\n       ty::ty_uniq(*) |\n       ty::ty_evec(_, ty::vstore_uniq) |\n       ty::ty_estr(ty::vstore_uniq) => {\n@@ -83,7 +83,7 @@ fn opt_deref_kind(t: ty::t) -> option<deref_kind> {\n }\n \n fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n-    alt opt_deref_kind(t) {\n+    match opt_deref_kind(t) {\n       some(k) => k,\n       none => {\n         tcx.sess.bug(\n@@ -97,7 +97,7 @@ impl public_methods for borrowck_ctxt {\n     fn cat_borrow_of_expr(expr: @ast::expr) -> cmt {\n         // a borrowed expression must be either an @, ~, or a @vec, ~vec\n         let expr_ty = ty::expr_ty(self.tcx, expr);\n-        alt ty::get(expr_ty).struct {\n+        match ty::get(expr_ty).struct {\n           ty::ty_evec(*) | ty::ty_estr(*) => {\n             self.cat_index(expr, expr)\n           }\n@@ -128,14 +128,14 @@ impl public_methods for borrowck_ctxt {\n \n         let tcx = self.tcx;\n         let expr_ty = tcx.ty(expr);\n-        alt expr.node {\n+        match expr.node {\n           ast::expr_unary(ast::deref, e_base) => {\n             if self.method_map.contains_key(expr.id) {\n                 return self.cat_rvalue(expr, expr_ty);\n             }\n \n             let base_cmt = self.cat_expr(e_base);\n-            alt self.cat_deref(expr, base_cmt, 0u, true) {\n+            match self.cat_deref(expr, base_cmt, 0u, true) {\n               some(cmt) => return cmt,\n               none => {\n                 tcx.sess.span_bug(\n@@ -190,7 +190,7 @@ impl public_methods for borrowck_ctxt {\n                span: span,\n                expr_ty: ty::t,\n                def: ast::def) -> cmt {\n-        alt def {\n+        match def {\n           ast::def_fn(*) | ast::def_mod(_) |\n           ast::def_foreign_mod(_) | ast::def_const(_) |\n           ast::def_use(_) | ast::def_variant(*) |\n@@ -208,7 +208,7 @@ impl public_methods for borrowck_ctxt {\n \n             // m: mutability of the argument\n             // lp: loan path, must be none for aliasable things\n-            let {m,lp} = alt ty::resolved_mode(self.tcx, mode) {\n+            let {m,lp} = match ty::resolved_mode(self.tcx, mode) {\n               ast::by_mutbl_ref => {\n                 {m: m_mutbl, lp: none}\n               }\n@@ -241,7 +241,7 @@ impl public_methods for borrowck_ctxt {\n           ast::def_upvar(upvid, inner, fn_node_id) => {\n             let ty = ty::node_id_to_type(self.tcx, fn_node_id);\n             let proto = ty::ty_fn_proto(ty);\n-            alt proto {\n+            match proto {\n               ast::proto_block => {\n                 let upcmt = self.cat_def(id, span, expr_ty, *inner);\n                 @{id:id, span:span,\n@@ -311,15 +311,15 @@ impl public_methods for borrowck_ctxt {\n     /// or if the container is mutable.\n     fn inherited_mutability(base_m: ast::mutability,\n                           comp_m: ast::mutability) -> ast::mutability {\n-        alt comp_m {\n+        match comp_m {\n           m_imm => {base_m}  // imm: as mutable as the container\n           m_mutbl | m_const => {comp_m}\n         }\n     }\n \n     fn cat_field<N:ast_node>(node: N, base_cmt: cmt,\n                              f_name: ast::ident) -> cmt {\n-        let f_mutbl = alt field_mutbl(self.tcx, base_cmt.ty, f_name) {\n+        let f_mutbl = match field_mutbl(self.tcx, base_cmt.ty, f_name) {\n           some(f_mutbl) => f_mutbl,\n           none => {\n             self.tcx.sess.span_bug(\n@@ -339,23 +339,23 @@ impl public_methods for borrowck_ctxt {\n     fn cat_deref<N:ast_node>(node: N, base_cmt: cmt, derefs: uint,\n                              expl: bool) -> option<cmt> {\n         do ty::deref(self.tcx, base_cmt.ty, expl).map |mt| {\n-            alt deref_kind(self.tcx, base_cmt.ty) {\n+            match deref_kind(self.tcx, base_cmt.ty) {\n               deref_ptr(ptr) => {\n                 let lp = do base_cmt.lp.chain |l| {\n                     // Given that the ptr itself is loanable, we can\n                     // loan out deref'd uniq ptrs as the data they are\n                     // the only way to reach the data they point at.\n                     // Other ptr types admit aliases and are therefore\n                     // not loanable.\n-                    alt ptr {\n+                    match ptr {\n                       uniq_ptr => {some(@lp_deref(l, ptr))}\n                       gc_ptr | region_ptr(_) | unsafe_ptr => {none}\n                     }\n                 };\n \n                 // for unique ptrs, we inherit mutability from the\n                 // owning reference.\n-                let m = alt ptr {\n+                let m = match ptr {\n                   uniq_ptr => {\n                     self.inherited_mutability(base_cmt.mutbl, mt.mutbl)\n                   }\n@@ -383,7 +383,7 @@ impl public_methods for borrowck_ctxt {\n     fn cat_index(expr: @ast::expr, base: @ast::expr) -> cmt {\n         let base_cmt = self.cat_autoderef(base);\n \n-        let mt = alt ty::index(self.tcx, base_cmt.ty) {\n+        let mt = match ty::index(self.tcx, base_cmt.ty) {\n           some(mt) => mt,\n           none => {\n             self.tcx.sess.span_bug(\n@@ -393,18 +393,18 @@ impl public_methods for borrowck_ctxt {\n           }\n         };\n \n-        return alt deref_kind(self.tcx, base_cmt.ty) {\n+        return match deref_kind(self.tcx, base_cmt.ty) {\n           deref_ptr(ptr) => {\n             // (a) the contents are loanable if the base is loanable\n             // and this is a *unique* vector\n-            let deref_lp = alt ptr {\n+            let deref_lp = match ptr {\n               uniq_ptr => {base_cmt.lp.map(|lp| @lp_deref(lp, uniq_ptr))}\n               _ => {none}\n             };\n \n             // (b) for unique ptrs, we inherit mutability from the\n             // owning reference.\n-            let m = alt ptr {\n+            let m = match ptr {\n               uniq_ptr => {\n                 self.inherited_mutability(base_cmt.mutbl, mt.mutbl)\n               }\n@@ -465,7 +465,7 @@ impl private_methods for borrowck_ctxt {\n         let mut ctr = 0u;\n         loop {\n             ctr += 1u;\n-            alt self.cat_deref(base, cmt, ctr, false) {\n+            match self.cat_deref(base, cmt, ctr, false) {\n               none => return cmt,\n               some(cmt1) => cmt = cmt1\n             }\n@@ -477,7 +477,7 @@ fn field_mutbl(tcx: ty::ctxt,\n                base_ty: ty::t,\n                f_name: ast::ident) -> option<ast::mutability> {\n     // Need to refactor so that records/class fields can be treated uniformly.\n-    alt ty::get(base_ty).struct {\n+    match ty::get(base_ty).struct {\n       ty::ty_rec(fields) => {\n         for fields.each |f| {\n             if f.ident == f_name {\n@@ -488,7 +488,7 @@ fn field_mutbl(tcx: ty::ctxt,\n       ty::ty_class(did, substs) => {\n         for ty::lookup_class_fields(tcx, did).each |fld| {\n             if fld.ident == f_name {\n-                let m = alt fld.mutability {\n+                let m = match fld.mutability {\n                   ast::class_mutable => ast::m_mutbl,\n                   ast::class_immutable => ast::m_imm\n                 };"}, {"sha": "9b7d0e037c1264db55d6302e9130ed2169a541e6", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -64,14 +64,14 @@ impl methods for assignment_type {\n     fn checked_by_liveness() -> bool {\n         // the liveness pass guarantees that immutable local variables\n         // are only assigned once; but it doesn't consider &mut\n-        alt self {\n+        match self {\n           at_straight_up => true,\n           at_swap => true,\n           at_mutbl_ref => false\n         }\n     }\n     fn ing_form(desc: ~str) -> ~str {\n-        alt self {\n+        match self {\n           at_straight_up => ~\"assigning to \" + desc,\n           at_swap => ~\"swapping to and from \" + desc,\n           at_mutbl_ref => ~\"taking mut reference to \" + desc\n@@ -83,7 +83,7 @@ impl methods for check_loan_ctxt {\n     fn tcx() -> ty::ctxt { self.bccx.tcx }\n \n     fn purity(scope_id: ast::node_id) -> option<purity_cause> {\n-        let default_purity = alt self.declared_purity {\n+        let default_purity = match self.declared_purity {\n           // an unsafe declaration overrides all\n           ast::unsafe_fn => return none,\n \n@@ -101,12 +101,12 @@ impl methods for check_loan_ctxt {\n         let region_map = self.tcx().region_map;\n         let pure_map = self.req_maps.pure_map;\n         loop {\n-            alt pure_map.find(scope_id) {\n+            match pure_map.find(scope_id) {\n               none => (),\n               some(e) => return some(pc_cmt(e))\n             }\n \n-            alt region_map.find(scope_id) {\n+            match region_map.find(scope_id) {\n               none => return default_purity,\n               some(next_scope_id) => scope_id = next_scope_id\n             }\n@@ -128,7 +128,7 @@ impl methods for check_loan_ctxt {\n                 }\n             }\n \n-            alt region_map.find(scope_id) {\n+            match region_map.find(scope_id) {\n               none => return,\n               some(next_scope_id) => scope_id = next_scope_id,\n             }\n@@ -173,9 +173,9 @@ impl methods for check_loan_ctxt {\n         // (c) B is a pure fn;\n         // (d) B is not a fn.\n \n-        alt opt_expr {\n+        match opt_expr {\n           some(expr) => {\n-            alt expr.node {\n+            match expr.node {\n               ast::expr_path(_) if pc == pc_pure_fn => {\n                 let def = self.tcx().def_map.get(expr.id);\n                 let did = ast_util::def_id_of_def(def);\n@@ -198,9 +198,9 @@ impl methods for check_loan_ctxt {\n         }\n \n         let callee_ty = ty::node_id_to_type(tcx, callee_id);\n-        alt ty::get(callee_ty).struct {\n+        match ty::get(callee_ty).struct {\n           ty::ty_fn(fn_ty) => {\n-            alt fn_ty.purity {\n+            match fn_ty.purity {\n               ast::pure_fn => return, // case (c) above\n               ast::impure_fn | ast::unsafe_fn | ast::extern_fn => {\n                 self.report_purity_error(\n@@ -219,14 +219,14 @@ impl methods for check_loan_ctxt {\n     fn is_stack_closure(id: ast::node_id) -> bool {\n         let fn_ty = ty::node_id_to_type(self.tcx(), id);\n         let proto = ty::ty_fn_proto(fn_ty);\n-        alt proto {\n+        match proto {\n           ast::proto_block => true,\n           ast::proto_bare | ast::proto_uniq | ast::proto_box => false\n         }\n     }\n \n     fn is_allowed_pure_arg(expr: @ast::expr) -> bool {\n-        return alt expr.node {\n+        return match expr.node {\n           ast::expr_path(_) => {\n             let def = self.tcx().def_map.get(expr.id);\n             let did = ast_util::def_id_of_def(def);\n@@ -241,7 +241,7 @@ impl methods for check_loan_ctxt {\n     }\n \n     fn check_for_conflicting_loans(scope_id: ast::node_id) {\n-        let new_loanss = alt self.req_maps.req_loan_map.find(scope_id) {\n+        let new_loanss = match self.req_maps.req_loan_map.find(scope_id) {\n             none => return,\n             some(loanss) => loanss\n         };\n@@ -251,7 +251,7 @@ impl methods for check_loan_ctxt {\n             for (*new_loanss).each |new_loans| {\n                 for (*new_loans).each |new_loan| {\n                     if old_loan.lp != new_loan.lp { again; }\n-                    alt (old_loan.mutbl, new_loan.mutbl) {\n+                    match (old_loan.mutbl, new_loan.mutbl) {\n                       (m_const, _) | (_, m_const) |\n                       (m_mutbl, m_mutbl) | (m_imm, m_imm) => {\n                         /*ok*/\n@@ -276,16 +276,16 @@ impl methods for check_loan_ctxt {\n     }\n \n     fn is_local_variable(cmt: cmt) -> bool {\n-        alt cmt.cat {\n+        match cmt.cat {\n           cat_local(_) => true,\n           _ => false\n         }\n     }\n \n     fn is_self_field(cmt: cmt) -> bool {\n-        alt cmt.cat {\n+        match cmt.cat {\n           cat_comp(cmt_base, comp_field(*)) => {\n-            alt cmt_base.cat {\n+            match cmt_base.cat {\n               cat_special(sk_self) => true,\n               _ => false\n             }\n@@ -307,7 +307,7 @@ impl methods for check_loan_ctxt {\n             // liveness guarantees that immutable local variables\n             // are only assigned once\n         } else {\n-            alt cmt.mutbl {\n+            match cmt.mutbl {\n               m_mutbl => { /*ok*/ }\n               m_const | m_imm => {\n                 self.bccx.span_err(\n@@ -321,7 +321,7 @@ impl methods for check_loan_ctxt {\n         // if this is a pure function, only loan-able state can be\n         // assigned, because it is uniquely tied to this function and\n         // is not visible from the outside\n-        alt self.purity(ex.id) {\n+        match self.purity(ex.id) {\n           none => (),\n           some(pc) => {\n             if cmt.lp.is_none() {\n@@ -352,7 +352,7 @@ impl methods for check_loan_ctxt {\n         lp: @loan_path) {\n \n         for self.walk_loans_of(ex.id, lp) |loan| {\n-            alt loan.mutbl {\n+            match loan.mutbl {\n               m_mutbl | m_const => { /*ok*/ }\n               m_imm => {\n                 self.bccx.span_err(\n@@ -375,7 +375,7 @@ impl methods for check_loan_ctxt {\n         //    let mut x = {f: some(3)};\n         //    let y = &x; // x loaned out as immutable\n         //    x.f = none; // changes type of y.f, which appears to be imm\n-        alt *lp {\n+        match *lp {\n           lp_comp(lp_base, ck) if inherent_mutability(ck) != m_mutbl => {\n             self.check_for_loan_conflicting_with_assignment(\n                 at, ex, cmt, lp_base);\n@@ -385,7 +385,7 @@ impl methods for check_loan_ctxt {\n     }\n \n     fn report_purity_error(pc: purity_cause, sp: span, msg: ~str) {\n-        alt pc {\n+        match pc {\n           pc_pure_fn => {\n             self.tcx().sess.span_err(\n                 sp,\n@@ -414,7 +414,7 @@ impl methods for check_loan_ctxt {\n         debug!{\"check_move_out_from_cmt(cmt=%s)\",\n                self.bccx.cmt_to_repr(cmt)};\n \n-        alt cmt.cat {\n+        match cmt.cat {\n           // Rvalues, locals, and arguments can be moved:\n           cat_rvalue | cat_local(_) | cat_arg(_) => {}\n \n@@ -437,7 +437,7 @@ impl methods for check_loan_ctxt {\n         self.bccx.add_to_mutbl_map(cmt);\n \n         // check for a conflicting loan:\n-        let lp = alt cmt.lp {\n+        let lp = match cmt.lp {\n           none => return,\n           some(lp) => lp\n         };\n@@ -459,7 +459,7 @@ impl methods for check_loan_ctxt {\n     // safe to consider the use a last_use.\n     fn check_last_use(expr: @ast::expr) {\n         let cmt = self.bccx.cat_expr(expr);\n-        let lp = alt cmt.lp {\n+        let lp = match cmt.lp {\n           none => return,\n           some(lp) => lp\n         };\n@@ -476,7 +476,7 @@ impl methods for check_loan_ctxt {\n                   callee_id: ast::node_id,\n                   callee_span: span,\n                   args: ~[@ast::expr]) {\n-        alt self.purity(expr.id) {\n+        match self.purity(expr.id) {\n           none => {}\n           some(pc) => {\n             self.check_pure_callee_or_arg(\n@@ -491,7 +491,7 @@ impl methods for check_loan_ctxt {\n             ty::ty_fn_args(\n                 ty::node_id_to_type(self.tcx(), callee_id));\n         do vec::iter2(args, arg_tys) |arg, arg_ty| {\n-            alt ty::resolved_mode(self.tcx(), arg_ty.mode) {\n+            match ty::resolved_mode(self.tcx(), arg_ty.mode) {\n               ast::by_move => {\n                 self.check_move_out(arg);\n               }\n@@ -521,7 +521,7 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                 // of otherwise immutable fields and typestate wouldn't be\n                 // able to \"see\" into those functions anyway, so it\n                 // wouldn't be very helpful.\n-                alt fk {\n+                match fk {\n                   visit::fk_ctor(*) => {\n                     self.in_ctor = true;\n                     self.declared_purity = decl.purity;\n@@ -551,7 +551,7 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n fn check_loans_in_local(local: @ast::local,\n                         &&self: check_loan_ctxt,\n                         vt: visit::vt<check_loan_ctxt>) {\n-    alt local.node.init {\n+    match local.node.init {\n       some({op: ast::init_move, expr: expr}) => {\n         self.check_move_out(expr);\n       }\n@@ -565,7 +565,7 @@ fn check_loans_in_expr(expr: @ast::expr,\n                        vt: visit::vt<check_loan_ctxt>) {\n     self.check_for_conflicting_loans(expr.id);\n \n-    alt expr.node {\n+    match expr.node {\n       ast::expr_path(*) if self.bccx.last_use_map.contains_key(expr.id) => {\n         self.check_last_use(expr);\n       }\n@@ -601,7 +601,7 @@ fn check_loans_in_expr(expr: @ast::expr,\n         }\n       }\n       ast::expr_addr_of(mutbl, base) => {\n-        alt mutbl {\n+        match mutbl {\n           m_const => { /*all memory is const*/ }\n           m_mutbl => {\n             // If we are taking an &mut ptr, make sure the memory\n@@ -645,7 +645,7 @@ fn check_loans_in_block(blk: ast::blk,\n     do save_and_restore(self.declared_purity) {\n         self.check_for_conflicting_loans(blk.node.id);\n \n-        alt blk.node.rules {\n+        match blk.node.rules {\n           ast::default_blk => {\n           }\n           ast::unchecked_blk => {"}, {"sha": "86455652faa087b2262178a05ecf39625c87b840", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -70,7 +70,7 @@ fn req_loans_in_fn(fk: visit::fn_kind,\n     let old_root_ub = self.root_ub;\n     self.root_ub = body.node.id;\n \n-    alt fk {\n+    match fk {\n       visit::fk_anon(*) | visit::fk_fn_block(*) => {}\n       visit::fk_item_fn(*) | visit::fk_method(*) |\n       visit::fk_ctor(*) | visit::fk_dtor(*) => {\n@@ -99,14 +99,14 @@ fn req_loans_in_expr(ex: @ast::expr,\n     }\n \n     // Special checks for various kinds of expressions:\n-    alt ex.node {\n+    match ex.node {\n       ast::expr_addr_of(mutbl, base) => {\n         let base_cmt = self.bccx.cat_expr(base);\n \n         // make sure that the thing we are pointing out stays valid\n         // for the lifetime `scope_r` of the resulting ptr:\n         let scope_r =\n-            alt check ty::get(tcx.ty(ex)).struct {\n+            match check ty::get(tcx.ty(ex)).struct {\n               ty::ty_rptr(r, _) => r\n             };\n         self.guarantee_valid(base_cmt, mutbl, scope_r);\n@@ -117,7 +117,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n         let arg_tys = ty::ty_fn_args(ty::expr_ty(self.tcx(), f));\n         let scope_r = ty::re_scope(ex.id);\n         do vec::iter2(args, arg_tys) |arg, arg_ty| {\n-            alt ty::resolved_mode(self.tcx(), arg_ty.mode) {\n+            match ty::resolved_mode(self.tcx(), arg_ty.mode) {\n               ast::by_mutbl_ref => {\n                 let arg_cmt = self.bccx.cat_expr(arg);\n                 self.guarantee_valid(arg_cmt, m_mutbl, scope_r);\n@@ -151,7 +151,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n                 // immutable (whereas something like {f:int} would be\n                 // fine).\n                 //\n-                alt opt_deref_kind(arg_ty.ty) {\n+                match opt_deref_kind(arg_ty.ty) {\n                   some(deref_ptr(region_ptr(_))) |\n                   some(deref_ptr(unsafe_ptr)) => {\n                     /* region pointers are (by induction) guaranteed */\n@@ -265,7 +265,7 @@ impl methods for gather_loan_ctxt {\n                region_to_str(self.tcx(), scope_r)};\n         let _i = indenter();\n \n-        alt cmt.lp {\n+        match cmt.lp {\n           // If this expression is a loanable path, we MUST take out a\n           // loan.  This is somewhat non-obvious.  You might think,\n           // for example, that if we have an immutable local variable\n@@ -277,11 +277,11 @@ impl methods for gather_loan_ctxt {\n           // it within that scope, the loan will be detected and an\n           // error will be reported.\n           some(_) => {\n-            alt self.bccx.loan(cmt, scope_r, req_mutbl) {\n+            match self.bccx.loan(cmt, scope_r, req_mutbl) {\n               err(e) => { self.bccx.report(e); }\n               ok(loans) if loans.len() == 0 => {}\n               ok(loans) => {\n-                alt scope_r {\n+                match scope_r {\n                   ty::re_scope(scope_id) => {\n                     self.add_loans(scope_id, loans);\n \n@@ -325,7 +325,7 @@ impl methods for gather_loan_ctxt {\n                 }\n             };\n \n-            alt result {\n+            match result {\n               ok(pc_ok) => {\n                 // we were able guarantee the validity of the ptr,\n                 // perhaps by rooting or because it is immutably\n@@ -335,7 +335,7 @@ impl methods for gather_loan_ctxt {\n               ok(pc_if_pure(e)) => {\n                 // we are only able to guarantee the validity if\n                 // the scope is pure\n-                alt scope_r {\n+                match scope_r {\n                   ty::re_scope(pure_id) => {\n                     // if the scope is some block/expr in the fn,\n                     // then just require that this scope be pure\n@@ -374,7 +374,7 @@ impl methods for gather_loan_ctxt {\n     // mutable memory.\n     fn check_mutbl(req_mutbl: ast::mutability,\n                    cmt: cmt) -> bckres<preserve_condition> {\n-        alt (req_mutbl, cmt.mutbl) {\n+        match (req_mutbl, cmt.mutbl) {\n           (m_const, _) |\n           (m_imm, m_imm) |\n           (m_mutbl, m_mutbl) => {\n@@ -397,7 +397,7 @@ impl methods for gather_loan_ctxt {\n     }\n \n     fn add_loans(scope_id: ast::node_id, loans: @dvec<loan>) {\n-        alt self.req_maps.req_loan_map.find(scope_id) {\n+        match self.req_maps.req_loan_map.find(scope_id) {\n           some(l) => {\n             (*l).push(loans);\n           }\n@@ -432,7 +432,7 @@ impl methods for gather_loan_ctxt {\n         // To see what I mean about ids etc, consider:\n         //\n         //     let x = @@3;\n-        //     alt x {\n+        //     match x {\n         //       @@y { ... }\n         //     }\n         //\n@@ -450,7 +450,7 @@ impl methods for gather_loan_ctxt {\n         let _i = indenter();\n \n         let tcx = self.tcx();\n-        alt pat.node {\n+        match pat.node {\n           ast::pat_wild => {\n             // _\n           }\n@@ -460,7 +460,7 @@ impl methods for gather_loan_ctxt {\n           }\n           ast::pat_enum(_, some(subpats)) => {\n             // variant(x, y, z)\n-            let enum_did = alt self.bccx.tcx.def_map\n+            let enum_did = match self.bccx.tcx.def_map\n .find(pat.id) {\n               some(ast::def_variant(enum_did, _)) => enum_did,\n               e => tcx.sess.span_bug(pat.span,\n@@ -523,7 +523,7 @@ impl methods for gather_loan_ctxt {\n \n           ast::pat_box(subpat) | ast::pat_uniq(subpat) => {\n             // @p1, ~p1\n-            alt self.bccx.cat_deref(subpat, cmt, 0u, true) {\n+            match self.bccx.cat_deref(subpat, cmt, 0u, true) {\n               some(subcmt) => {\n                 self.gather_pat(subcmt, subpat, arm_id, alt_id);\n               }"}, {"sha": "59e3cd183fc578da888171e666b718b3723bb57b", "filename": "src/rustc/middle/borrowck/loan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -12,7 +12,7 @@ impl public_methods for borrowck_ctxt {\n         let lc = loan_ctxt_(@{bccx: self,\n                               scope_region: scope_region,\n                               loans: @dvec()});\n-        alt lc.loan(cmt, mutbl) {\n+        match lc.loan(cmt, mutbl) {\n           ok(()) => {ok(lc.loans)}\n           err(e) => {err(e)}\n         }\n@@ -70,7 +70,7 @@ impl loan_methods for loan_ctxt {\n                 ~\"loan() called with non-lendable value\");\n         }\n \n-        alt cmt.cat {\n+        match cmt.cat {\n           cat_binding(_) | cat_rvalue | cat_special(_) => {\n             // should never be loanable\n             self.bccx.tcx.sess.span_bug(\n@@ -131,7 +131,7 @@ impl loan_methods for loan_ctxt {\n     fn loan_stable_comp(cmt: cmt,\n                         cmt_base: cmt,\n                         req_mutbl: ast::mutability) -> bckres<()> {\n-        let base_mutbl = alt req_mutbl {\n+        let base_mutbl = match req_mutbl {\n           m_imm => m_imm,\n           m_const | m_mutbl => m_const\n         };"}, {"sha": "a586aca24f3de3c383a05dc89e4a46d27ced4e44", "filename": "src/rustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -14,7 +14,7 @@ impl public_methods for preserve_condition {\n     // combines two preservation conditions such that if either of\n     // them requires purity, the result requires purity\n     fn combine(pc: preserve_condition) -> preserve_condition {\n-        alt self {\n+        match self {\n           pc_ok => {pc}\n           pc_if_pure(e) => {self}\n         }\n@@ -63,7 +63,7 @@ impl private_methods for &preserve_ctxt {\n                self.root_managed_data};\n         let _i = indenter();\n \n-        alt cmt.cat {\n+        match cmt.cat {\n           cat_special(sk_self) | cat_special(sk_heap_upvar) => {\n             self.compare_scope(cmt, ty::re_scope(self.item_ub))\n           }\n@@ -160,7 +160,7 @@ impl private_methods for &preserve_ctxt {\n             if base.mutbl == m_imm {\n                 let non_rooting_ctxt =\n                     preserve_ctxt({root_managed_data: false with **self});\n-                alt (&non_rooting_ctxt).preserve(base) {\n+                match (&non_rooting_ctxt).preserve(base) {\n                   ok(pc_ok) => {\n                     ok(pc_ok)\n                   }\n@@ -191,7 +191,7 @@ impl private_methods for &preserve_ctxt {\n             // As an example, consider this scenario:\n             //\n             //    let mut x = @some(3);\n-            //    alt *x { some(y) {...} none {...} }\n+            //    match *x { some(y) {...} none {...} }\n             //\n             // Technically, the value `x` need only be rooted\n             // in the `some` arm.  However, we evaluate `x` in trans\n@@ -201,7 +201,7 @@ impl private_methods for &preserve_ctxt {\n             // As a second example, consider *this* scenario:\n             //\n             //    let x = @mut @some(3);\n-            //    alt x { @@some(y) {...} @@none {...} }\n+            //    match x { @@some(y) {...} @@none {...} }\n             //\n             // Here again, `x` need only be rooted in the `some` arm.\n             // In this case, the value which needs to be rooted is\n@@ -220,7 +220,7 @@ impl private_methods for &preserve_ctxt {\n             // also yielded suboptimal results for patterns like:\n             //\n             //    let x = @mut @...;\n-            //    alt x { @@some_variant(y) | @@some_other_variant(y) {...} }\n+            //    match x { @@some_variant(y) | @@some_other_variant(y) =>\n             //\n             // The reason is that we would root the value once for\n             // each pattern and not once per arm.  This is also easily\n@@ -234,7 +234,7 @@ impl private_methods for &preserve_ctxt {\n \n             // current scope must be the arm, which is always a child of alt:\n             assert {\n-                alt check self.scope_region {\n+                match check self.scope_region {\n                   ty::re_scope(arm_id) => {\n                     self.tcx().region_map.get(arm_id) == alt_id\n                   }\n@@ -259,11 +259,11 @@ impl private_methods for &preserve_ctxt {\n                    code: bckerr_code) -> bckres<preserve_condition> {\n         // Variant contents and unique pointers: must be immutably\n         // rooted to a preserved address.\n-        alt self.preserve(cmt_base) {\n+        match self.preserve(cmt_base) {\n           // the base is preserved, but if we are not mutable then\n           // purity is required\n           ok(pc_ok) => {\n-            alt cmt_base.mutbl {\n+            match cmt_base.mutbl {\n               m_mutbl | m_const => {\n                 ok(pc_if_pure({cmt:cmt, code:code}))\n               }\n@@ -322,7 +322,7 @@ impl private_methods for &preserve_ctxt {\n         }\n \n         let root_region = ty::re_scope(self.root_ub);\n-        alt self.scope_region {\n+        match self.scope_region {\n           // we can only root values if the desired region is some concrete\n           // scope within the fn body\n           ty::re_scope(scope_id) => {"}, {"sha": "266c31b2805da12c3786e96f51409c1db55c8e8e", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -101,14 +101,14 @@ fn compute_capture_vars(tcx: ty::ctxt,\n     // now go through anything that is referenced but was not explicitly\n     // named and add that\n \n-    let implicit_mode = alt fn_proto {\n+    let implicit_mode = match fn_proto {\n       ast::proto_block => cap_ref,\n       ast::proto_bare | ast::proto_box | ast::proto_uniq => cap_copy\n     };\n \n     do vec::iter(*freevars) |fvar| {\n         let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n-        alt cap_map.find(fvar_def_id) {\n+        match cap_map.find(fvar_def_id) {\n           option::some(_) => { /* was explicitly named, do nothing */ }\n           option::none => {\n             cap_map.insert(fvar_def_id, {def:fvar.def,"}, {"sha": "7ccccbbcc07c3c0e104a92e9ae3cc8f18df08dc0", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -22,7 +22,7 @@ fn check_crate(tcx: ty::ctxt, crate: @crate) {\n \n fn check_expr(tcx: ty::ctxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n     visit::visit_expr(ex, s, v);\n-    alt ex.node {\n+    match ex.node {\n       expr_alt(scrut, arms, mode) => {\n         check_arms(tcx, arms);\n         /* Check for exhaustiveness */\n@@ -33,7 +33,7 @@ fn check_expr(tcx: ty::ctxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n                // Vacuously exhaustive\n                return;\n            }\n-       alt ty::get(pat_ty).struct {\n+       match ty::get(pat_ty).struct {\n           ty_enum(did, _) => {\n               if (*enum_variants(tcx, did)).is_empty() && arms.is_empty() {\n \n@@ -58,7 +58,7 @@ fn check_arms(tcx: ty::ctxt, arms: ~[arm]) {\n     for arms.each |arm| {\n         for arm.pats.each |pat| {\n             let v = ~[pat];\n-            alt is_useful(tcx, seen, v) {\n+            match is_useful(tcx, seen, v) {\n               not_useful => {\n                 tcx.sess.span_err(pat.span, ~\"unreachable pattern\");\n               }\n@@ -70,28 +70,28 @@ fn check_arms(tcx: ty::ctxt, arms: ~[arm]) {\n }\n \n fn raw_pat(p: @pat) -> @pat {\n-    alt p.node {\n+    match p.node {\n       pat_ident(_, _, some(s)) => { raw_pat(s) }\n       _ => { p }\n     }\n }\n \n fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: ~[@pat]) {\n     assert(pats.is_not_empty());\n-    let ext = alt is_useful(tcx, vec::map(pats, |p| ~[p]), ~[wild()]) {\n+    let ext = match is_useful(tcx, vec::map(pats, |p| ~[p]), ~[wild()]) {\n       not_useful => return, // This is good, wildcard pattern isn't reachable\n       useful_ => none,\n       useful(ty, ctor) => {\n-        alt ty::get(ty).struct {\n+        match ty::get(ty).struct {\n           ty::ty_bool => {\n-            alt check ctor {\n+            match check ctor {\n               val(const_int(1i64)) => some(@~\"true\"),\n               val(const_int(0i64)) => some(@~\"false\")\n             }\n           }\n           ty::ty_enum(id, _) => {\n-            let vid = alt check ctor { variant(id) => id };\n-            alt check vec::find(*ty::enum_variants(tcx, id),\n+            let vid = match check ctor { variant(id) => id };\n+            match check vec::find(*ty::enum_variants(tcx, id),\n                                 |v| v.id == vid) {\n               some(v) => some(v.name)\n             }\n@@ -100,7 +100,7 @@ fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: ~[@pat]) {\n         }\n       }\n     };\n-    let msg = ~\"non-exhaustive patterns\" + alt ext {\n+    let msg = ~\"non-exhaustive patterns\" + match ext {\n       some(s) => ~\": \" + *s + ~\" not covered\",\n       none => ~\"\"\n     };\n@@ -134,19 +134,19 @@ enum ctor {\n fn is_useful(tcx: ty::ctxt, m: matrix, v: ~[@pat]) -> useful {\n     if m.len() == 0u { return useful_; }\n     if m[0].len() == 0u { return not_useful; }\n-    let real_pat = alt vec::find(m, |r| r[0].id != 0) {\n+    let real_pat = match vec::find(m, |r| r[0].id != 0) {\n       some(r) => r[0], none => v[0]\n     };\n     let left_ty = if real_pat.id == 0 { ty::mk_nil(tcx) }\n                   else { ty::node_id_to_type(tcx, real_pat.id) };\n \n-    alt pat_ctor_id(tcx, v[0]) {\n+    match pat_ctor_id(tcx, v[0]) {\n       none => {\n-        alt missing_ctor(tcx, m, left_ty) {\n+        match missing_ctor(tcx, m, left_ty) {\n           none => {\n-            alt ty::get(left_ty).struct {\n+            match ty::get(left_ty).struct {\n               ty::ty_bool => {\n-                alt is_useful_specialized(tcx, m, v, val(const_int(1i64)),\n+                match is_useful_specialized(tcx, m, v, val(const_int(1i64)),\n                                           0u, left_ty){\n                   not_useful => {\n                     is_useful_specialized(tcx, m, v, val(const_int(0i64)),\n@@ -157,7 +157,7 @@ fn is_useful(tcx: ty::ctxt, m: matrix, v: ~[@pat]) -> useful {\n               }\n               ty::ty_enum(eid, _) => {\n                 for (*ty::enum_variants(tcx, eid)).each |va| {\n-                    alt is_useful_specialized(tcx, m, v, variant(va.id),\n+                    match is_useful_specialized(tcx, m, v, variant(va.id),\n                                               va.args.len(), left_ty) {\n                       not_useful => (),\n                       u => return u\n@@ -172,7 +172,7 @@ fn is_useful(tcx: ty::ctxt, m: matrix, v: ~[@pat]) -> useful {\n             }\n           }\n           some(ctor) => {\n-            alt is_useful(tcx, vec::filter_map(m, |r| default(tcx, r) ),\n+            match is_useful(tcx, vec::filter_map(m, |r| default(tcx, r) ),\n                           vec::tail(v)) {\n               useful_ => useful(left_ty, ctor),\n               u => u\n@@ -190,18 +190,20 @@ fn is_useful(tcx: ty::ctxt, m: matrix, v: ~[@pat]) -> useful {\n fn is_useful_specialized(tcx: ty::ctxt, m: matrix, v: ~[@pat], ctor: ctor,\n                           arity: uint, lty: ty::t) -> useful {\n     let ms = vec::filter_map(m, |r| specialize(tcx, r, ctor, arity, lty) );\n-    alt is_useful(tcx, ms, option::get(specialize(tcx, v, ctor, arity, lty))){\n+    let could_be_useful = is_useful(\n+        tcx, ms, option::get(specialize(tcx, v, ctor, arity, lty)));\n+    match could_be_useful {\n       useful_ => useful(lty, ctor),\n       u => u\n     }\n }\n \n fn pat_ctor_id(tcx: ty::ctxt, p: @pat) -> option<ctor> {\n     let pat = raw_pat(p);\n-    alt pat.node {\n+    match pat.node {\n       pat_wild => { none }\n       pat_ident(_, _, _) | pat_enum(_, _) => {\n-        alt tcx.def_map.find(pat.id) {\n+        match tcx.def_map.find(pat.id) {\n           some(def_variant(_, id)) => some(variant(id)),\n           _ => none\n         }\n@@ -218,10 +220,10 @@ fn pat_ctor_id(tcx: ty::ctxt, p: @pat) -> option<ctor> {\n \n fn is_wild(tcx: ty::ctxt, p: @pat) -> bool {\n     let pat = raw_pat(p);\n-    alt pat.node {\n+    match pat.node {\n       pat_wild => { true }\n       pat_ident(_, _, _) => {\n-        alt tcx.def_map.find(pat.id) {\n+        match tcx.def_map.find(pat.id) {\n           some(def_variant(_, _)) => { false }\n           _ => { true }\n         }\n@@ -231,7 +233,7 @@ fn is_wild(tcx: ty::ctxt, p: @pat) -> bool {\n }\n \n fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> option<ctor> {\n-    alt ty::get(left_ty).struct {\n+    match ty::get(left_ty).struct {\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_tup(_) | ty::ty_rec(_) => {\n         for m.each |r| {\n             if !is_wild(tcx, r[0]) { return none; }\n@@ -259,7 +261,7 @@ fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> option<ctor> {\n       ty::ty_bool => {\n         let mut true_found = false, false_found = false;\n         for m.each |r| {\n-            alt check pat_ctor_id(tcx, r[0]) {\n+            match check pat_ctor_id(tcx, r[0]) {\n               none => (),\n               some(val(const_int(1i64))) => true_found = true,\n               some(val(const_int(0i64))) => false_found = true\n@@ -274,13 +276,13 @@ fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> option<ctor> {\n }\n \n fn ctor_arity(tcx: ty::ctxt, ctor: ctor, ty: ty::t) -> uint {\n-    alt ty::get(ty).struct {\n+    match ty::get(ty).struct {\n       ty::ty_tup(fs) => fs.len(),\n       ty::ty_rec(fs) => fs.len(),\n       ty::ty_box(_) | ty::ty_uniq(_) => 1u,\n       ty::ty_enum(eid, _) => {\n-        let id = alt check ctor { variant(id) => id };\n-        alt check vec::find(*ty::enum_variants(tcx, eid), |v| v.id == id ) {\n+        let id = match check ctor { variant(id) => id };\n+        match check vec::find(*ty::enum_variants(tcx, eid), |v| v.id == id ) {\n           some(v) => v.args.len()\n         }\n       }\n@@ -295,11 +297,11 @@ fn wild() -> @pat {\n fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n               left_ty: ty::t) -> option<~[@pat]> {\n     let r0 = raw_pat(r[0]);\n-    alt r0.node {\n+    match r0.node {\n       pat_wild => some(vec::append(vec::from_elem(arity, wild()),\n                                    vec::tail(r))),\n       pat_ident(_, _, _) => {\n-        alt tcx.def_map.find(r0.id) {\n+        match tcx.def_map.find(r0.id) {\n           some(def_variant(_, id)) => {\n             if variant(id) == ctor_id { some(vec::tail(r)) }\n             else { none }\n@@ -308,9 +310,9 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n         }\n       }\n       pat_enum(_, args) => {\n-        alt check tcx.def_map.get(r0.id) {\n+        match check tcx.def_map.get(r0.id) {\n           def_variant(_, id) if variant(id) == ctor_id => {\n-            let args = alt args {\n+            let args = match args {\n               some(args) => args,\n               none => vec::from_elem(arity, wild())\n             };\n@@ -320,11 +322,11 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n         }\n       }\n       pat_rec(flds, _) => {\n-        let ty_flds = alt check ty::get(left_ty).struct {\n+        let ty_flds = match check ty::get(left_ty).struct {\n           ty::ty_rec(flds) => flds\n         };\n         let args = vec::map(ty_flds, |ty_f| {\n-            alt vec::find(flds, |f| f.ident == ty_f.ident ) {\n+            match vec::find(flds, |f| f.ident == ty_f.ident ) {\n               some(f) => f.pat, _ => wild()\n             }\n         });\n@@ -334,7 +336,7 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n       pat_box(a) | pat_uniq(a) => some(vec::append(~[a], vec::tail(r))),\n       pat_lit(expr) => {\n         let e_v = eval_const_expr(tcx, expr);\n-        let match_ = alt check ctor_id {\n+        let match_ = match check ctor_id {\n           val(v) => compare_const_vals(e_v, v) == 0,\n           range(c_lo, c_hi) => {\n             compare_const_vals(c_lo, e_v) >= 0 &&\n@@ -345,7 +347,7 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n         if match_ { some(vec::tail(r)) } else { none }\n       }\n       pat_range(lo, hi) => {\n-        let (c_lo, c_hi) = alt check ctor_id {\n+        let (c_lo, c_hi) = match check ctor_id {\n           val(v) => (v, v),\n           range(lo, hi) => (lo, hi),\n           single => return some(vec::tail(r)),\n@@ -373,14 +375,14 @@ fn check_local(tcx: ty::ctxt, loc: @local, &&s: (), v: visit::vt<()>) {\n }\n \n fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n-    alt tcx.def_map.find(pat.id) {\n+    match tcx.def_map.find(pat.id) {\n       some(def_variant(enum_id, var_id)) => {\n         if vec::len(*ty::enum_variants(tcx, enum_id)) != 1u { return true; }\n       }\n       _ => ()\n     }\n \n-    alt pat.node {\n+    match pat.node {\n       pat_box(sub) | pat_uniq(sub) | pat_ident(_, _, some(sub)) => {\n         is_refutable(tcx, sub)\n       }"}, {"sha": "36b0908f435161de31cee6c25c5c08b1fcbfc952", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -20,7 +20,7 @@ fn check_crate(sess: session, crate: @crate, ast_map: ast_map::map,\n fn check_item(sess: session, ast_map: ast_map::map,\n               def_map: resolve3::DefMap,\n               it: @item, &&_is_const: bool, v: visit::vt<bool>) {\n-    alt it.node {\n+    match it.node {\n       item_const(_, ex) => {\n         v.visit_expr(ex, true, v);\n         check_item_recursion(sess, ast_map, def_map, it);\n@@ -38,13 +38,13 @@ fn check_item(sess: session, ast_map: ast_map::map,\n \n fn check_pat(p: @pat, &&_is_const: bool, v: visit::vt<bool>) {\n     fn is_str(e: @expr) -> bool {\n-        alt e.node {\n+        match e.node {\n           expr_vstore(@{node: expr_lit(@{node: lit_str(_), _}), _},\n                       vstore_uniq) => true,\n           _ => false\n         }\n     }\n-    alt p.node {\n+    match p.node {\n       // Let through plain ~-string literals here\n       pat_lit(a) => if !is_str(a) { v.visit_expr(a, true, v); }\n       pat_range(a, b) => {\n@@ -59,7 +59,7 @@ fn check_expr(sess: session, def_map: resolve3::DefMap,\n               method_map: typeck::method_map, tcx: ty::ctxt,\n               e: @expr, &&is_const: bool, v: visit::vt<bool>) {\n     if is_const {\n-        alt e.node {\n+        match e.node {\n           expr_unary(box(_), _) | expr_unary(uniq(_), _) |\n           expr_unary(deref, _) => {\n             sess.span_err(e.span,\n@@ -83,7 +83,7 @@ fn check_expr(sess: session, def_map: resolve3::DefMap,\n             }\n           }\n           expr_path(_) => {\n-            alt def_map.find(e.id) {\n+            match def_map.find(e.id) {\n               some(def_const(def_id)) => {\n                 if !ast_util::is_local(def_id) {\n                     sess.span_err(\n@@ -117,7 +117,7 @@ fn check_expr(sess: session, def_map: resolve3::DefMap,\n           }\n         }\n     }\n-    alt e.node {\n+    match e.node {\n       expr_lit(@{node: lit_int(v, t), _}) => {\n         if t != ty_char {\n             if (v as u64) > ast_util::int_ty_max(\n@@ -175,11 +175,11 @@ fn check_item_recursion(sess: session, ast_map: ast_map::map,\n     }\n \n     fn visit_expr(e: @expr, &&env: env, v: visit::vt<env>) {\n-        alt e.node {\n+        match e.node {\n           expr_path(path) => {\n-            alt env.def_map.find(e.id) {\n+            match env.def_map.find(e.id) {\n               some(def_const(def_id)) => {\n-                alt check env.ast_map.get(def_id.node) {\n+                match check env.ast_map.get(def_id.node) {\n                   ast_map::node_item(it, _) => {\n                     v.visit_item(it, env, v);\n                   }"}, {"sha": "8f3de8c8aa2d071f0f8b004630f4c4515fc73373", "filename": "src/rustc/middle/check_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_loop.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -10,7 +10,7 @@ fn check_crate(tcx: ty::ctxt, crate: @crate) {\n             visit::visit_item(i, {in_loop: false, can_ret: true}, v);\n         },\n         visit_expr: |e: @expr, cx: ctx, v: visit::vt<ctx>| {\n-            alt e.node {\n+            match e.node {\n               expr_while(e, b) => {\n                 v.visit_expr(e, cx, v);\n                 v.visit_block(b, {in_loop: true with cx}, v);"}, {"sha": "e15ef58604243143792c36a1b54fa364d7664726", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -41,7 +41,7 @@ enum constness {\n }\n \n fn join(a: constness, b: constness) -> constness {\n-    alt (a,b) {\n+    match (a,b) {\n       (integral_const, integral_const) => integral_const,\n       (integral_const, general_const)\n       | (general_const, integral_const)\n@@ -58,13 +58,13 @@ fn classify(e: @expr,\n             def_map: resolve3::DefMap,\n             tcx: ty::ctxt) -> constness {\n     let did = ast_util::local_def(e.id);\n-    alt tcx.ccache.find(did) {\n+    match tcx.ccache.find(did) {\n       some(x) => x,\n       none => {\n         let cn =\n-            alt e.node {\n+            match e.node {\n               ast::expr_lit(lit) => {\n-                alt lit.node {\n+                match lit.node {\n                   ast::lit_str(*) |\n                   ast::lit_float(*) => general_const,\n                   _ => integral_const\n@@ -87,7 +87,7 @@ fn classify(e: @expr,\n               }\n \n               ast::expr_vstore(e, vstore) => {\n-                alt vstore {\n+                match vstore {\n                   ast::vstore_fixed(_) |\n                   ast::vstore_slice(_) => classify(e, def_map, tcx),\n                   ast::vstore_uniq |\n@@ -134,7 +134,7 @@ fn classify(e: @expr,\n               // FIXME: #1272, we can probably do something CCI-ish\n               // surrounding nonlocal constants. But we don't yet.\n               ast::expr_path(_) => {\n-                alt def_map.find(e.id) {\n+                match def_map.find(e.id) {\n                   some(ast::def_const(def_id)) => {\n                     if ast_util::is_local(def_id) {\n                         let ty = ty::expr_ty(tcx, e);\n@@ -191,24 +191,24 @@ enum const_val {\n fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n     import middle::ty;\n     fn fromb(b: bool) -> const_val { const_int(b as i64) }\n-    alt check e.node {\n+    match check e.node {\n       expr_unary(neg, inner) => {\n-        alt check eval_const_expr(tcx, inner) {\n+        match check eval_const_expr(tcx, inner) {\n           const_float(f) => const_float(-f),\n           const_int(i) => const_int(-i),\n           const_uint(i) => const_uint(-i)\n         }\n       }\n       expr_unary(not, inner) => {\n-        alt check eval_const_expr(tcx, inner) {\n+        match check eval_const_expr(tcx, inner) {\n           const_int(i) => const_int(!i),\n           const_uint(i) => const_uint(!i)\n         }\n       }\n       expr_binary(op, a, b) => {\n-        alt check (eval_const_expr(tcx, a), eval_const_expr(tcx, b)) {\n+        match check (eval_const_expr(tcx, a), eval_const_expr(tcx, b)) {\n           (const_float(a), const_float(b)) => {\n-            alt check op {\n+            match check op {\n               add => const_float(a + b),\n               subtract => const_float(a - b),\n               mul => const_float(a * b),\n@@ -223,7 +223,7 @@ fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n             }\n           }\n           (const_int(a), const_int(b)) => {\n-            alt check op {\n+            match check op {\n               add => const_int(a + b),\n               subtract => const_int(a - b),\n               mul => const_int(a * b),\n@@ -243,7 +243,7 @@ fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n             }\n           }\n           (const_uint(a), const_uint(b)) => {\n-            alt check op {\n+            match check op {\n               add => const_uint(a + b),\n               subtract => const_uint(a - b),\n               mul => const_uint(a * b),\n@@ -264,13 +264,13 @@ fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n           }\n           // shifts can have any integral type as their rhs\n           (const_int(a), const_uint(b)) => {\n-            alt check op {\n+            match check op {\n               shl => const_int(a << b),\n               shr => const_int(a >> b)\n             }\n           }\n           (const_uint(a), const_int(b)) => {\n-            alt check op {\n+            match check op {\n               shl => const_uint(a << b),\n               shr => const_uint(a >> b)\n             }\n@@ -280,23 +280,23 @@ fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n       expr_cast(base, _) => {\n         let ety = ty::expr_ty(tcx, e);\n         let base = eval_const_expr(tcx, base);\n-        alt check ty::get(ety).struct {\n+        match check ty::get(ety).struct {\n           ty::ty_float(_) => {\n-            alt check base {\n+            match check base {\n               const_uint(u) => const_float(u as f64),\n               const_int(i) => const_float(i as f64),\n               const_float(_) => base\n             }\n           }\n           ty::ty_uint(_) => {\n-            alt check base {\n+            match check base {\n               const_uint(_) => base,\n               const_int(i) => const_uint(i as u64),\n               const_float(f) => const_uint(f as u64)\n             }\n           }\n           ty::ty_int(_) | ty::ty_bool => {\n-            alt check base {\n+            match check base {\n               const_uint(u) => const_int(u as i64),\n               const_int(_) => base,\n               const_float(f) => const_int(f as i64)\n@@ -311,7 +311,7 @@ fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n }\n \n fn lit_to_const(lit: @lit) -> const_val {\n-    alt lit.node {\n+    match lit.node {\n       lit_str(s) => const_str(*s),\n       lit_int(n, _) => const_int(n),\n       lit_uint(n, _) => const_uint(n),\n@@ -323,7 +323,7 @@ fn lit_to_const(lit: @lit) -> const_val {\n }\n \n fn compare_const_vals(a: const_val, b: const_val) -> int {\n-  alt (a, b) {\n+  match (a, b) {\n     (const_int(a), const_int(b)) => {\n         if a == b {\n             0"}, {"sha": "4c81ec303929de30a516e701a3bfa89f3770353c", "filename": "src/rustc/middle/freevars.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ffreevars.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -38,7 +38,7 @@ fn collect_freevars(def_map: resolve3::DefMap, blk: ast::blk)\n     fn ignore_item(_i: @ast::item, &&_depth: int, _v: visit::vt<int>) { }\n \n     let walk_expr = fn@(expr: @ast::expr, &&depth: int, v: visit::vt<int>) {\n-            alt expr.node {\n+            match expr.node {\n               ast::expr_fn(proto, decl, _, _) => {\n                 if proto != ast::proto_bare {\n                     visit::visit_expr(expr, depth + 1, v);\n@@ -49,12 +49,12 @@ fn collect_freevars(def_map: resolve3::DefMap, blk: ast::blk)\n               }\n               ast::expr_path(path) => {\n                   let mut i = 0;\n-                  alt def_map.find(expr.id) {\n+                  match def_map.find(expr.id) {\n                     none => fail (~\"Not found: \" + path_to_str(path)),\n                     some(df) => {\n                       let mut def = df;\n                       while i < depth {\n-                        alt copy def {\n+                        match copy def {\n                           ast::def_upvar(_, inner, _) => { def = *inner; }\n                           _ => break\n                         }\n@@ -104,7 +104,7 @@ fn annotate_freevars(def_map: resolve3::DefMap, crate: @ast::crate) ->\n }\n \n fn get_freevars(tcx: ty::ctxt, fid: ast::node_id) -> freevar_info {\n-    alt tcx.freevars.find(fid) {\n+    match tcx.freevars.find(fid) {\n       none => fail ~\"get_freevars: \" + int::str(fid) + ~\" has no freevars\",\n       some(d) => return d\n     }"}, {"sha": "408b0ef691694c5e75fc86f9aba9d16999bcc745", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -144,7 +144,7 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n     }\n \n     let fty = ty::node_id_to_type(cx.tcx, id);\n-    alt ty::ty_fn_proto(fty) {\n+    match ty::ty_fn_proto(fty) {\n       proto_uniq => b(check_for_uniq),\n       proto_box => b(check_for_box),\n       proto_bare => b(check_for_bare),\n@@ -166,7 +166,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n         // errors and produce a list of the def id's for all capture\n         // variables.  This list is used below to avoid checking and reporting\n         // on a given variable twice.\n-        let cap_clause = alt fk {\n+        let cap_clause = match fk {\n           visit::fk_anon(_, cc) | visit::fk_fn_block(cc) => cc,\n           visit::fk_item_fn(*) | visit::fk_method(*) |\n           visit::fk_ctor(*) | visit::fk_dtor(*) => @~[]\n@@ -190,7 +190,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n             // if this is the last use of the variable, then it will be\n             // a move and not a copy\n             let is_move = {\n-                alt check cx.last_use_map.find(fn_id) {\n+                match check cx.last_use_map.find(fn_id) {\n                   some(vars) => (*vars).contains(id),\n                   none => false\n                 }\n@@ -205,7 +205,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n }\n \n fn check_block(b: blk, cx: ctx, v: visit::vt<ctx>) {\n-    alt b.node.expr {\n+    match b.node.expr {\n       some(ex) => maybe_copy(cx, ex),\n       _ => ()\n     }\n@@ -214,7 +214,7 @@ fn check_block(b: blk, cx: ctx, v: visit::vt<ctx>) {\n \n fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n     debug!{\"kind::check_expr(%s)\", expr_to_str(e)};\n-    alt e.node {\n+    match e.node {\n       expr_assign(_, ex) |\n       expr_unary(box(_), ex) | expr_unary(uniq(_), ex) |\n       expr_ret(some(ex)) => {\n@@ -233,11 +233,11 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n       }\n       expr_rec(fields, def) => {\n         for fields.each |field| { maybe_copy(cx, field.node.expr); }\n-        alt def {\n+        match def {\n           some(ex) => {\n             // All noncopyable fields must be overridden\n             let t = ty::expr_ty(cx.tcx, ex);\n-            let ty_fields = alt ty::get(t).struct {\n+            let ty_fields = match ty::get(t).struct {\n               ty::ty_rec(f) => f,\n               _ => cx.tcx.sess.span_bug(ex.span, ~\"bad expr type in record\")\n             };\n@@ -258,7 +258,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n       expr_call(f, args, _) => {\n         let mut i = 0u;\n         for ty::ty_fn_args(ty::expr_ty(cx.tcx, f)).each |arg_t| {\n-            alt ty::arg_mode(cx.tcx, arg_t) {\n+            match ty::arg_mode(cx.tcx, arg_t) {\n               by_copy => maybe_copy(cx, args[i]),\n               by_ref | by_val | by_mutbl_ref | by_move => ()\n             }\n@@ -267,13 +267,13 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n       }\n       expr_path(_) | expr_field(_, _, _) => {\n         do option::iter(cx.tcx.node_type_substs.find(e.id)) |ts| {\n-            let bounds = alt check e.node {\n+            let bounds = match check e.node {\n               expr_path(_) => {\n                 let did = ast_util::def_id_of_def(cx.tcx.def_map.get(e.id));\n                 ty::lookup_item_type(cx.tcx, did).bounds\n               }\n               expr_field(base, _, _) => {\n-                alt cx.method_map.get(e.id).origin {\n+                match cx.method_map.get(e.id).origin {\n                   typeck::method_static(did) => {\n                     // n.b.: When we encode class/impl methods, the bounds\n                     // that we encode include both the class/impl bounds\n@@ -312,10 +312,10 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n }\n \n fn check_stmt(stmt: @stmt, cx: ctx, v: visit::vt<ctx>) {\n-    alt stmt.node {\n+    match stmt.node {\n       stmt_decl(@{node: decl_local(locals), _}, _) => {\n         for locals.each |local| {\n-            alt local.node.init {\n+            match local.node.init {\n               some({op: init_assign, expr}) => maybe_copy(cx, expr),\n               _ => {}\n             }\n@@ -327,7 +327,7 @@ fn check_stmt(stmt: @stmt, cx: ctx, v: visit::vt<ctx>) {\n }\n \n fn check_ty(aty: @ty, cx: ctx, v: visit::vt<ctx>) {\n-    alt aty.node {\n+    match aty.node {\n       ty_path(_, id) => {\n         do option::iter(cx.tcx.node_type_substs.find(id)) |ts| {\n             let did = ast_util::def_id_of_def(cx.tcx.def_map.get(id));\n@@ -373,9 +373,9 @@ fn maybe_copy(cx: ctx, ex: @expr) {\n }\n \n fn is_nullary_variant(cx: ctx, ex: @expr) -> bool {\n-    alt ex.node {\n+    match ex.node {\n       expr_path(_) => {\n-        alt cx.tcx.def_map.get(ex.id) {\n+        match cx.tcx.def_map.get(ex.id) {\n           def_variant(edid, vdid) => {\n             vec::len(ty::enum_variant_with_id(cx.tcx, edid, vdid).args) == 0u\n           }\n@@ -398,14 +398,14 @@ fn check_copy_ex(cx: ctx, ex: @expr, implicit_copy: bool) {\n fn check_imm_free_var(cx: ctx, def: def, sp: span) {\n     let msg = ~\"mutable variables cannot be implicitly captured; \\\n                use a capture clause\";\n-    alt def {\n+    match def {\n       def_local(_, is_mutbl) => {\n         if is_mutbl {\n             cx.tcx.sess.span_err(sp, msg);\n         }\n       }\n       def_arg(_, mode) => {\n-        alt ty::resolved_mode(cx.tcx, mode) {\n+        match ty::resolved_mode(cx.tcx, mode) {\n           by_ref | by_val | by_move | by_copy => { /* ok */ }\n           by_mutbl_ref => {\n             cx.tcx.sess.span_err(sp, msg);\n@@ -449,7 +449,7 @@ fn check_send(cx: ctx, ty: ty::t, sp: span) -> bool {\n // note: also used from middle::typeck::regionck!\n fn check_owned(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n     if !ty::kind_is_owned(ty::type_kind(tcx, ty)) {\n-        alt ty::get(ty).struct {\n+        match ty::get(ty).struct {\n           ty::ty_param(*) => {\n             tcx.sess.span_err(sp, ~\"value may contain borrowed \\\n                                     pointers; use `owned` bound\");\n@@ -496,15 +496,15 @@ fn check_cast_for_escaping_regions(\n     // Determine what type we are casting to; if it is not an trait, then no\n     // worries.\n     let target_ty = ty::expr_ty(cx.tcx, target);\n-    let target_substs = alt ty::get(target_ty).struct {\n+    let target_substs = match ty::get(target_ty).struct {\n       ty::ty_trait(_, substs) => {substs}\n       _ => { return; /* not a cast to a trait */ }\n     };\n \n     // Check, based on the region associated with the trait, whether it can\n     // possibly escape the enclosing fn item (note that all type parameters\n     // must have been declared on the enclosing fn item):\n-    alt target_substs.self_r {\n+    match target_substs.self_r {\n       some(ty::re_scope(*)) => { return; /* case (1) */ }\n       none | some(ty::re_static) | some(ty::re_free(*)) => {}\n       some(ty::re_bound(*)) | some(ty::re_var(*)) => {\n@@ -519,7 +519,7 @@ fn check_cast_for_escaping_regions(\n     let target_params = ty::param_tys_in_type(target_ty);\n     let source_ty = ty::expr_ty(cx.tcx, source);\n     do ty::walk_ty(source_ty) |ty| {\n-        alt ty::get(ty).struct {\n+        match ty::get(ty).struct {\n           ty::ty_param(source_param) => {\n             if target_params.contains(source_param) {\n                 /* case (2) */"}, {"sha": "877dfd5f90c20c950d8cc82baf2d1e596c6ac99f", "filename": "src/rustc/middle/lang_items.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flang_items.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -98,9 +98,9 @@ class LanguageItemCollector {\n     fn match_and_collect_meta_item(item_def_id: def_id,\n                                    meta_item: meta_item) {\n \n-        alt meta_item.node {\n+        match meta_item.node {\n             meta_name_value(key, literal) => {\n-                alt literal.node {\n+                match literal.node {\n                     lit_str(value) => {\n                         self.match_and_collect_item(item_def_id,\n                                                     *key,\n@@ -122,13 +122,13 @@ class LanguageItemCollector {\n             return;    // Didn't match.\n         }\n \n-        alt self.item_refs.find(value) {\n+        match self.item_refs.find(value) {\n             none => {\n                 // Didn't match.\n             }\n             some(item_ref) => {\n                 // Check for duplicates.\n-                alt copy *item_ref {\n+                match copy *item_ref {\n                     some(original_def_id)\n                             if original_def_id != item_def_id => {\n \n@@ -168,7 +168,7 @@ class LanguageItemCollector {\n         do iter_crate_data(crate_store) |crate_number, _crate_metadata| {\n             for each_path(crate_store, crate_number) |path_entry| {\n                 let def_id;\n-                alt path_entry.def_like {\n+                match path_entry.def_like {\n                     dl_def(def_ty(did)) => {\n                         def_id = did;\n                     }\n@@ -189,7 +189,7 @@ class LanguageItemCollector {\n \n     fn check_completeness() {\n         for self.item_refs.each |key, item_ref| {\n-            alt copy *item_ref {\n+            match copy *item_ref {\n                 none => {\n                     self.session.err(fmt!{\"no item found for `%s`\", key});\n                 }"}, {"sha": "4de9bf8e17ddd79101497af539bf6aa1cd91d6fd", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -55,7 +55,7 @@ enum lint {\n // This is pretty unfortunate. We really want some sort of \"deriving Enum\"\n // type of thing.\n fn int_to_lint(i: int) -> lint {\n-    alt check i {\n+    match check i {\n       0 => ctypes,\n       1 => unused_imports,\n       2 => while_true,\n@@ -70,7 +70,7 @@ fn int_to_lint(i: int) -> lint {\n }\n \n fn level_to_str(lv: level) -> ~str {\n-    alt lv {\n+    match lv {\n       allow => ~\"allow\",\n       warn => ~\"warn\",\n       deny => ~\"deny\",\n@@ -166,7 +166,7 @@ fn mk_lint_settings() -> lint_settings {\n }\n \n fn get_lint_level(modes: lint_modes, lint: lint) -> level {\n-    alt modes.find(lint as uint) {\n+    match modes.find(lint as uint) {\n       some(c) => c,\n       none => allow\n     }\n@@ -176,7 +176,7 @@ fn get_lint_settings_level(settings: lint_settings,\n                               lint_mode: lint,\n                               _expr_id: ast::node_id,\n                               item_id: ast::node_id) -> level {\n-    alt settings.settings_map.find(item_id) {\n+    match settings.settings_map.find(item_id) {\n       some(modes) => get_lint_level(modes, lint_mode),\n       none => get_lint_level(settings.default_settings, lint_mode)\n     }\n@@ -230,10 +230,10 @@ impl methods for ctxt {\n                 attr::attr_metas(attr::find_attrs_by_name(attrs,\n                                                           level_name));\n             for metas.each |meta| {\n-                alt meta.node {\n+                match meta.node {\n                   ast::meta_list(_, metas) => {\n                     for metas.each |meta| {\n-                        alt meta.node {\n+                        match meta.node {\n                           ast::meta_word(lintname) => {\n                             vec::push(triples, (meta, level, lintname));\n                           }\n@@ -255,7 +255,7 @@ impl methods for ctxt {\n \n         for triples.each |pair| {\n             let (meta, level, lintname) = pair;\n-            alt self.dict.find(*lintname) {\n+            match self.dict.find(*lintname) {\n               none => {\n                 self.span_lint(\n                     new_ctxt.get_level(unrecognized_lint),\n@@ -354,9 +354,9 @@ fn item_stopping_visitor<E>(v: visit::vt<E>) -> visit::vt<E> {\n fn check_item_while_true(cx: ty::ctxt, it: @ast::item) {\n     let visit = item_stopping_visitor(visit::mk_simple_visitor(@{\n         visit_expr: fn@(e: @ast::expr) {\n-           alt e.node {\n+           match e.node {\n              ast::expr_while(cond, _) => {\n-                alt cond.node {\n+                match cond.node {\n                     ast::expr_lit(@{node: ast::lit_bool(true),_}) => {\n                             cx.sess.span_lint(\n                                 while_true, e.id, it.id,\n@@ -380,9 +380,9 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n                        decl: ast::fn_decl) {\n         let tys = vec::map(decl.inputs, |a| a.ty );\n         for vec::each(vec::append_one(tys, decl.output)) |ty| {\n-            alt ty.node {\n+            match ty.node {\n               ast::ty_path(_, id) => {\n-                alt cx.def_map.get(id) {\n+                match cx.def_map.get(id) {\n                   ast::def_prim_ty(ast::ty_int(ast::ty_i)) => {\n                     cx.sess.span_lint(\n                         ctypes, id, fn_id,\n@@ -405,11 +405,11 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n         }\n     }\n \n-    alt it.node {\n+    match it.node {\n       ast::item_foreign_mod(nmod) if attr::foreign_abi(it.attrs) !=\n       either::right(ast::foreign_abi_rust_intrinsic) => {\n         for nmod.items.each |ni| {\n-            alt ni.node {\n+            match ni.node {\n               ast::foreign_item_fn(decl, tps) => {\n                 check_foreign_fn(cx, it.id, decl);\n               }\n@@ -423,7 +423,7 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n fn check_item_path_statement(cx: ty::ctxt, it: @ast::item) {\n     let visit = item_stopping_visitor(visit::mk_simple_visitor(@{\n         visit_stmt: fn@(s: @ast::stmt) {\n-            alt s.node {\n+            match s.node {\n               ast::stmt_semi(@{id: id,\n                                callee_id: _,\n                                node: ast::expr_path(@path),\n@@ -458,7 +458,7 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n         }\n     }\n \n-    alt it.node {\n+    match it.node {\n       ast::item_ty(*) | ast::item_class(*) |\n       ast::item_trait(*) | ast::item_impl(*) => {\n         check_case(cx, it.ident, it.id, it.id, it.span)\n@@ -480,13 +480,13 @@ fn check_fn(tcx: ty::ctxt, fk: visit::fn_kind, decl: ast::fn_decl,\n \n     // don't complain about blocks, since they tend to get their modes\n     // specified from the outside\n-    alt fk {\n+    match fk {\n       visit::fk_fn_block(*) => { return; }\n       _ => {}\n     }\n \n     let fn_ty = ty::node_id_to_type(tcx, id);\n-    alt check ty::get(fn_ty).struct {\n+    match check ty::get(fn_ty).struct {\n       ty::ty_fn(fn_ty) => {\n         let mut counter = 0;\n         do vec::iter2(fn_ty.inputs, decl.inputs) |arg_ty, arg_ast| {\n@@ -495,7 +495,7 @@ fn check_fn(tcx: ty::ctxt, fk: visit::fn_kind, decl: ast::fn_decl,\n                    counter,\n                    ty_to_str(tcx, arg_ty.ty),\n                    mode_to_str(arg_ast.mode)};\n-            alt arg_ast.mode {\n+            match arg_ast.mode {\n               ast::expl(ast::by_copy) => {\n                 /* always allow by-copy */\n               }"}, {"sha": "6cad5e19e960942e9d27259697f5df50c5f1df1d", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -201,7 +201,7 @@ enum var_kind {\n }\n \n fn relevant_def(def: def) -> option<relevant_def> {\n-    alt def {\n+    match def {\n       def_self(_) => some(rdef_self),\n       def_arg(nid, _) | def_local(nid, _) => some(rdef_var(nid)),\n       _ => none\n@@ -260,7 +260,7 @@ class ir_maps {\n         vec::push(self.var_kinds, vk);\n         self.num_vars += 1u;\n \n-        alt vk {\n+        match vk {\n           vk_local(node_id, _) | vk_arg(node_id, _, _) => {\n             self.variable_map.insert(node_id, v);\n           }\n@@ -277,7 +277,7 @@ class ir_maps {\n     }\n \n     fn variable(node_id: node_id, span: span) -> variable {\n-        alt self.variable_map.find(node_id) {\n+        match self.variable_map.find(node_id) {\n           some(var) => var,\n           none => {\n             self.tcx.sess.span_bug(\n@@ -287,7 +287,7 @@ class ir_maps {\n     }\n \n     fn variable_name(var: variable) -> ident {\n-        alt self.var_kinds[*var] {\n+        match self.var_kinds[*var] {\n           vk_local(_, name) | vk_arg(_, name, _) => name,\n           vk_field(name) => @(~\"self.\" + *name),\n           vk_self => @~\"self\",\n@@ -300,7 +300,7 @@ class ir_maps {\n     }\n \n     fn captures(expr: @expr) -> @~[capture_info] {\n-        alt self.capture_map.find(expr.id) {\n+        match self.capture_map.find(expr.id) {\n           some(caps) => caps,\n           none => {\n             self.tcx.sess.span_bug(expr.span, ~\"no registered caps\");\n@@ -315,11 +315,11 @@ class ir_maps {\n     fn add_last_use(expr_id: node_id, var: variable) {\n         let vk = self.var_kinds[*var];\n         debug!{\"Node %d is a last use of variable %?\", expr_id, vk};\n-        alt vk {\n+        match vk {\n           vk_arg(id, name, by_move) |\n           vk_arg(id, name, by_copy) |\n           vk_local(id, name) => {\n-            let v = alt self.last_use_map.find(expr_id) {\n+            let v = match self.last_use_map.find(expr_id) {\n               some(v) => v,\n               none => {\n                 let v = @dvec();\n@@ -359,7 +359,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     // and so forth:\n     visit::visit_fn(fk, decl, body, sp, id, fn_maps, v);\n \n-    alt fk {\n+    match fk {\n       visit::fk_ctor(_, _, _, _, class_did) => {\n         add_class_fields(fn_maps, class_did);\n       }\n@@ -414,7 +414,7 @@ fn visit_local(local: @local, &&self: @ir_maps, vt: vt<@ir_maps>) {\n }\n \n fn visit_expr(expr: @expr, &&self: @ir_maps, vt: vt<@ir_maps>) {\n-    alt expr.node {\n+    match expr.node {\n       // live nodes required for uses or definitions of variables:\n       expr_path(_) => {\n         let def = self.tcx.def_map.get(expr.id);\n@@ -435,10 +435,10 @@ fn visit_expr(expr: @expr, &&self: @ir_maps, vt: vt<@ir_maps>) {\n                                                 proto, cap_clause);\n         let mut call_caps = ~[];\n         for cvs.each |cv| {\n-            alt relevant_def(cv.def) {\n+            match relevant_def(cv.def) {\n               some(rv) => {\n                 let cv_ln = (*self).add_live_node(lnk_freevar(cv.span));\n-                let is_move = alt cv.mode {\n+                let is_move = match cv.mode {\n                   cap_move | cap_drop => true, // var must be dead afterwards\n                   cap_copy | cap_ref => false // var can still be used\n                 };\n@@ -533,7 +533,7 @@ class liveness {\n     // _______________________________________________________________________\n \n     fn live_node(node_id: node_id, span: span) -> live_node {\n-        alt self.ir.live_node_map.find(node_id) {\n+        match self.ir.live_node_map.find(node_id) {\n           some(ln) => ln,\n           none => {\n             // This must be a mismatch between the ir_map construction\n@@ -548,14 +548,14 @@ class liveness {\n     }\n \n     fn variable_from_rdef(rv: relevant_def, span: span) -> variable {\n-        alt rv {\n+        match rv {\n           rdef_self => self.s.self_var,\n           rdef_var(nid) => self.variable(nid, span)\n         }\n     }\n \n     fn variable_from_path(expr: @expr) -> option<variable> {\n-        alt expr.node {\n+        match expr.node {\n           expr_path(_) => {\n             let def = self.tcx.def_map.get(expr.id);\n             relevant_def(def).map(\n@@ -572,7 +572,7 @@ class liveness {\n \n     fn variable_from_def_map(node_id: node_id,\n                              span: span) -> option<variable> {\n-        alt self.tcx.def_map.find(node_id) {\n+        match self.tcx.def_map.find(node_id) {\n           some(def) => {\n             relevant_def(def).map(\n                 |rdef| self.variable_from_rdef(rdef, span)\n@@ -794,7 +794,7 @@ class liveness {\n     fn propagate_through_fn_block(decl: fn_decl, blk: blk) -> live_node {\n         // inputs passed by & mode should be considered live on exit:\n         for decl.inputs.each |arg| {\n-            alt ty::resolved_mode(self.tcx, arg.mode) {\n+            match ty::resolved_mode(self.tcx, arg.mode) {\n               by_mutbl_ref | by_ref | by_val => {\n                 // These are \"non-owned\" modes, so register a read at\n                 // the end.  This will prevent us from moving out of\n@@ -836,7 +836,7 @@ class liveness {\n     }\n \n     fn propagate_through_stmt(stmt: @stmt, succ: live_node) -> live_node {\n-        alt stmt.node {\n+        match stmt.node {\n           stmt_decl(decl, _) => {\n             return self.propagate_through_decl(decl, succ);\n           }\n@@ -848,7 +848,7 @@ class liveness {\n     }\n \n     fn propagate_through_decl(decl: @decl, succ: live_node) -> live_node {\n-        alt decl.node {\n+        match decl.node {\n           decl_local(locals) => {\n             do locals.foldr(succ) |local, succ| {\n                 self.propagate_through_local(local, succ)\n@@ -900,7 +900,7 @@ class liveness {\n     }\n \n     fn propagate_through_expr(expr: @expr, succ: live_node) -> live_node {\n-        alt expr.node {\n+        match expr.node {\n           // Interesting cases with control flow or which gen/kill\n \n           expr_path(_) => {\n@@ -912,7 +912,7 @@ class liveness {\n             // then we treat it as a read of that variable.\n             // Otherwise, we ignore it and just propagate down to\n             // process `e`.\n-            alt self.as_self_field(e, nm) {\n+            match self.as_self_field(e, nm) {\n               some((ln, var)) => {\n                 self.init_from_succ(ln, succ);\n                 self.acc(ln, var, ACC_READ | ACC_USE);\n@@ -1185,9 +1185,9 @@ class liveness {\n         // these errors are detected in the later pass borrowck.  We\n         // just ignore such cases and treat them as reads.\n \n-        alt expr.node {\n+        match expr.node {\n           expr_path(_) => succ,\n-          expr_field(e, nm, _) => alt self.as_self_field(e, nm) {\n+          expr_field(e, nm, _) => match self.as_self_field(e, nm) {\n             some(_) => succ,\n             none => self.propagate_through_expr(e, succ)\n           }\n@@ -1199,9 +1199,9 @@ class liveness {\n     fn write_lvalue(expr: @expr,\n                     succ: live_node,\n                     acc: uint) -> live_node {\n-        alt expr.node {\n+        match expr.node {\n           expr_path(_) => self.access_path(expr, succ, acc),\n-          expr_field(e, nm, _) => alt self.as_self_field(e, nm) {\n+          expr_field(e, nm, _) => match self.as_self_field(e, nm) {\n             some((ln, var)) => {\n                 self.init_from_succ(ln, succ);\n                 self.acc(ln, var, acc);\n@@ -1220,7 +1220,7 @@ class liveness {\n \n     fn access_path(expr: @expr, succ: live_node, acc: uint) -> live_node {\n         let def = self.tcx.def_map.get(expr.id);\n-        alt relevant_def(def) {\n+        match relevant_def(def) {\n           some(rdef_self) => {\n             // Accessing `self` is like accessing every field of\n             // the current object. This allows something like\n@@ -1259,10 +1259,10 @@ class liveness {\n         // If we checking a constructor, then we treat self.f as a\n         // variable.  we use the live_node id that will be assigned to\n         // the reference to self but the variable id for `f`.\n-        alt expr.node {\n+        match expr.node {\n           expr_path(_) => {\n             let def = self.tcx.def_map.get(expr.id);\n-            alt def {\n+            match def {\n               def_self(_) => {\n                 // Note: the field_map is empty unless we are in a ctor\n                 return self.ir.field_map.find(fld).map(|var| {\n@@ -1345,12 +1345,12 @@ class liveness {\n // Checking for error conditions\n \n fn check_local(local: @local, &&self: @liveness, vt: vt<@liveness>) {\n-    alt local.node.init {\n+    match local.node.init {\n       some({op: op, expr: expr}) => {\n \n         // Initializer:\n \n-        alt op {\n+        match op {\n           init_move => self.check_move_from_expr(expr, vt),\n           init_assign => ()\n         }\n@@ -1367,7 +1367,7 @@ fn check_local(local: @local, &&self: @liveness, vt: vt<@liveness>) {\n         debug!{\"check_local() with no initializer\"};\n         do (*self).pat_bindings(local.node.pat) |ln, var, sp| {\n             if !self.warn_about_unused(sp, ln, var) {\n-                alt (*self).live_on_exit(ln, var) {\n+                match (*self).live_on_exit(ln, var) {\n                   none => { /* not live: good */ }\n                   some(lnk) => {\n                     self.report_illegal_read(\n@@ -1384,7 +1384,7 @@ fn check_local(local: @local, &&self: @liveness, vt: vt<@liveness>) {\n }\n \n fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n-    alt expr.node {\n+    match expr.node {\n       expr_path(_) => {\n         for (*self).variable_from_def_map(expr.id, expr.span).each |var| {\n             let ln = (*self).live_node(expr.id, expr.span);\n@@ -1437,7 +1437,7 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n         let targs = ty::ty_fn_args(ty::expr_ty(self.tcx, f));\n         vt.visit_expr(f, self, vt);\n         do vec::iter2(args, targs) |arg_expr, arg_ty| {\n-            alt ty::resolved_mode(self.tcx, arg_ty.mode) {\n+            match ty::resolved_mode(self.tcx, arg_ty.mode) {\n               by_val | by_copy | by_ref | by_mutbl_ref => {\n                 vt.visit_expr(arg_expr, self, vt);\n               }\n@@ -1480,7 +1480,7 @@ enum read_kind {\n impl check_methods for @liveness {\n     fn check_fields(sp: span, entry_ln: live_node) {\n         for self.ir.field_map.each |nm, var| {\n-            alt (*self).live_on_entry(entry_ln, var) {\n+            match (*self).live_on_entry(entry_ln, var) {\n               none => { /* ok */ }\n               some(lnk_exit) => {\n                 self.tcx.sess.span_err(\n@@ -1508,7 +1508,7 @@ impl check_methods for @liveness {\n                 self.tcx.sess.span_err(\n                     sp, ~\"some control paths may return\");\n             } else {\n-                alt fk {\n+                match fk {\n                   visit::fk_ctor(*) => {\n                     // ctors are written as though they are unit.\n                   }\n@@ -1525,14 +1525,14 @@ impl check_methods for @liveness {\n         debug!{\"check_move_from_var(%s, %s)\",\n                ln.to_str(), var.to_str()};\n \n-        alt (*self).live_on_exit(ln, var) {\n+        match (*self).live_on_exit(ln, var) {\n           none => {}\n           some(lnk) => self.report_illegal_move(span, lnk, var)\n         }\n     }\n \n     fn consider_last_use(expr: @expr, ln: live_node, var: variable) {\n-        alt (*self).live_on_exit(ln, var) {\n+        match (*self).live_on_exit(ln, var) {\n           some(_) => {}\n           none => (*self.ir).add_last_use(expr.id, var)\n        }\n@@ -1547,9 +1547,9 @@ impl check_methods for @liveness {\n             return vt.visit_expr(expr, self, vt);\n         }\n \n-        alt expr.node {\n+        match expr.node {\n           expr_path(_) => {\n-            alt (*self).variable_from_path(expr) {\n+            match (*self).variable_from_path(expr) {\n               some(var) => {\n                 let ln = (*self).live_node(expr.id, expr.span);\n                 self.check_move_from_var(expr.span, ln, var);\n@@ -1582,9 +1582,9 @@ impl check_methods for @liveness {\n     }\n \n     fn check_lvalue(expr: @expr, vt: vt<@liveness>) {\n-        alt expr.node {\n+        match expr.node {\n           expr_path(_) => {\n-            alt self.tcx.def_map.get(expr.id) {\n+            match self.tcx.def_map.get(expr.id) {\n               def_local(nid, false) => {\n                 // Assignment to an immutable variable or argument:\n                 // only legal if there is no later assignment.\n@@ -1594,7 +1594,7 @@ impl check_methods for @liveness {\n                 self.warn_about_dead_assign(expr.span, ln, var);\n               }\n               def => {\n-                alt relevant_def(def) {\n+                match relevant_def(def) {\n                   some(rdef_var(nid)) => {\n                     let ln = (*self).live_node(expr.id, expr.span);\n                     let var = (*self).variable(nid, expr.span);\n@@ -1623,7 +1623,7 @@ impl check_methods for @liveness {\n \n     fn check_for_reassignment(ln: live_node, var: variable,\n                               orig_span: span) {\n-        alt (*self).assigned_on_exit(ln, var) {\n+        match (*self).assigned_on_exit(ln, var) {\n           some(lnk_expr(span)) => {\n             self.tcx.sess.span_err(\n                 span,\n@@ -1651,7 +1651,7 @@ impl check_methods for @liveness {\n         // we give a slightly different error message in those cases.\n         if lnk == lnk_exit {\n             let vk = self.ir.var_kinds[*var];\n-            alt vk {\n+            match vk {\n               vk_arg(_, name, _) => {\n                 self.tcx.sess.span_err(\n                     move_span,\n@@ -1691,15 +1691,15 @@ impl check_methods for @liveness {\n                            lnk: live_node_kind,\n                            var: variable,\n                            rk: read_kind) {\n-        let msg = alt rk {\n+        let msg = match rk {\n           possibly_uninitialized_variable => {\n             ~\"possibly uninitialized variable\"\n           }\n           possibly_uninitialized_field => ~\"possibly uninitialized field\",\n           moved_variable => ~\"moved variable\"\n         };\n         let name = (*self.ir).variable_name(var);\n-        alt lnk {\n+        match lnk {\n           lnk_freevar(span) => {\n             self.tcx.sess.span_err(\n                 span,\n@@ -1727,13 +1727,13 @@ impl check_methods for @liveness {\n     fn warn_about_unused_args(sp: span, decl: fn_decl, entry_ln: live_node) {\n         for decl.inputs.each |arg| {\n             let var = (*self).variable(arg.id, arg.ty.span);\n-            alt ty::resolved_mode(self.tcx, arg.mode) {\n+            match ty::resolved_mode(self.tcx, arg.mode) {\n               by_mutbl_ref => {\n                 // for mutable reference arguments, something like\n                 //    x = 1;\n                 // is not worth warning about, as it has visible\n                 // side effects outside the fn.\n-                alt (*self).assigned_on_entry(entry_ln, var) {\n+                match (*self).assigned_on_entry(entry_ln, var) {\n                   some(_) => { /*ok*/ }\n                   none => {\n                     // but if it is not written, it ought to be used"}, {"sha": "f1f33e74e5391e311a746beb4134cb039d2bde66", "filename": "src/rustc/middle/pat_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpat_util.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -22,9 +22,9 @@ fn pat_id_map(dm: resolve3::DefMap, pat: @pat) -> pat_id_map {\n }\n \n fn pat_is_variant(dm: resolve3::DefMap, pat: @pat) -> bool {\n-    alt pat.node {\n+    match pat.node {\n       pat_enum(_, _) => true,\n-      pat_ident(_, _, none) => alt dm.find(pat.id) {\n+      pat_ident(_, _, none) => match dm.find(pat.id) {\n         some(def_variant(_, _)) => true,\n         _ => false\n       }\n@@ -35,7 +35,7 @@ fn pat_is_variant(dm: resolve3::DefMap, pat: @pat) -> bool {\n fn pat_bindings(dm: resolve3::DefMap, pat: @pat,\n                 it: fn(node_id, span, @path)) {\n     do walk_pat(pat) |p| {\n-        alt p.node {\n+        match p.node {\n           pat_ident(_, pth, _) if !pat_is_variant(dm, p) => {\n             it(p.id, p.span, pth);\n           }"}, {"sha": "362c4be7abe80c1166a1faee50ab2994b97b3d45", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -88,7 +88,7 @@ fn scope_contains(region_map: region_map, superscope: ast::node_id,\n                   subscope: ast::node_id) -> bool {\n     let mut subscope = subscope;\n     while superscope != subscope {\n-        alt region_map.find(subscope) {\n+        match region_map.find(subscope) {\n             none => return false,\n             some(scope) => subscope = scope\n         }\n@@ -103,7 +103,7 @@ fn subregion(region_map: region_map,\n              super_region: ty::region,\n              sub_region: ty::region) -> bool {\n     super_region == sub_region ||\n-        alt (super_region, sub_region) {\n+        match (super_region, sub_region) {\n           (ty::re_static, _) => {true}\n \n           (ty::re_scope(super_scope), ty::re_scope(sub_scope)) |\n@@ -128,7 +128,7 @@ fn nearest_common_ancestor(region_map: region_map, scope_a: ast::node_id,\n         let mut result = ~[scope];\n         let mut scope = scope;\n         loop {\n-            alt region_map.find(scope) {\n+            match region_map.find(scope) {\n                 none => return result,\n                 some(superscope) => {\n                     vec::push(result, superscope);\n@@ -172,7 +172,7 @@ fn nearest_common_ancestor(region_map: region_map, scope_a: ast::node_id,\n \n /// Extracts that current parent from cx, failing if there is none.\n fn parent_id(cx: ctxt, span: span) -> ast::node_id {\n-    alt cx.parent {\n+    match cx.parent {\n       none => {\n         cx.sess.span_bug(span, ~\"crate should not be parent here\");\n       }\n@@ -184,7 +184,7 @@ fn parent_id(cx: ctxt, span: span) -> ast::node_id {\n \n /// Records the current parent (if any) as the parent of `child_id`.\n fn record_parent(cx: ctxt, child_id: ast::node_id) {\n-    alt cx.parent {\n+    match cx.parent {\n       none => { /* no-op */ }\n       some(parent_id) => {\n         debug!{\"parent of node %d is node %d\", child_id, parent_id};\n@@ -207,10 +207,10 @@ fn resolve_arm(arm: ast::arm, cx: ctxt, visitor: visit::vt<ctxt>) {\n }\n \n fn resolve_pat(pat: @ast::pat, cx: ctxt, visitor: visit::vt<ctxt>) {\n-    alt pat.node {\n+    match pat.node {\n       ast::pat_ident(_, path, _) => {\n         let defn_opt = cx.def_map.find(pat.id);\n-        alt defn_opt {\n+        match defn_opt {\n           some(ast::def_variant(_,_)) => {\n             /* Nothing to do; this names a variant. */\n           }\n@@ -230,7 +230,7 @@ fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n     record_parent(cx, expr.id);\n \n     let mut new_cx = cx;\n-    alt expr.node {\n+    match expr.node {\n       ast::expr_call(*) => {\n         debug!{\"node %d: %s\", expr.id, pprust::expr_to_str(expr)};\n         new_cx.parent = some(expr.id);\n@@ -276,7 +276,7 @@ fn resolve_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n               sp: span, id: ast::node_id, cx: ctxt,\n               visitor: visit::vt<ctxt>) {\n \n-    let fn_cx = alt fk {\n+    let fn_cx = match fk {\n       visit::fk_item_fn(*) | visit::fk_method(*) |\n       visit::fk_ctor(*) | visit::fk_dtor(*) => {\n         // Top-level functions are a root scope.\n@@ -380,7 +380,7 @@ impl methods for determine_rp_ctxt {\n                from, to,\n                ast_map::node_id_to_str(self.ast_map, from),\n                ast_map::node_id_to_str(self.ast_map, to)};\n-        let vec = alt self.dep_map.find(from) {\n+        let vec = match self.dep_map.find(from) {\n             some(vec) => {vec}\n             none => {\n                 let vec = @dvec();\n@@ -424,7 +424,7 @@ impl methods for determine_rp_ctxt {\n     // (anon_implies_rp) to true when we enter an item and setting\n     // that flag to false when we enter a method.\n     fn region_is_relevant(r: @ast::region) -> bool {\n-        alt r.node {\n+        match r.node {\n           ast::re_anon => self.anon_implies_rp,\n           ast::re_named(@~\"self\") => true,\n           ast::re_named(_) => false\n@@ -485,7 +485,7 @@ fn determine_rp_in_ty(ty: @ast::ty,\n     // if this type directly references a region, either via a\n     // region pointer like &r.ty or a region-parameterized path\n     // like path/r, add to the worklist/set\n-    alt ty.node {\n+    match ty.node {\n       ast::ty_rptr(r, _) |\n       ast::ty_path(@{rp: some(r), _}, _) => {\n         debug!{\"referenced type with regions %s\", pprust::ty_to_str(ty)};\n@@ -501,9 +501,9 @@ fn determine_rp_in_ty(ty: @ast::ty,\n     // to the dep_map.  If the type is not defined in this crate,\n     // then check whether it is region-parameterized and consider\n     // that as a direct dependency.\n-    alt ty.node {\n+    match ty.node {\n       ast::ty_path(_, id) => {\n-        alt cx.def_map.get(id) {\n+        match cx.def_map.get(id) {\n           ast::def_ty(did) | ast::def_class(did, _) => {\n             if did.crate == ast::local_crate {\n                 cx.add_dep(did.node, cx.item_id);\n@@ -522,7 +522,7 @@ fn determine_rp_in_ty(ty: @ast::ty,\n       _ => {}\n     }\n \n-    alt ty.node {\n+    match ty.node {\n       ast::ty_fn(*) => {\n         do cx.with(cx.item_id, false) {\n             visit::visit_ty(ty, cx, visitor);\n@@ -561,7 +561,7 @@ fn determine_rp_in_crate(sess: session,\n     while cx.worklist.len() != 0 {\n         let id = cx.worklist.pop();\n         debug!{\"popped %d from worklist\", id};\n-        alt cx.dep_map.find(id) {\n+        match cx.dep_map.find(id) {\n           none => {}\n           some(vec) => {\n             for vec.each |to_id| {"}, {"sha": "11f329669c07e89c0cb3e7afb5524abafc40ef50", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 161, "deletions": 156, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -247,7 +247,7 @@ class AtomTable {\n     }\n \n     fn intern(string: @~str) -> Atom {\n-        alt self.atoms.find(string) {\n+        match self.atoms.find(string) {\n             none => { /* fall through */ }\n             some(atom) => return atom\n         }\n@@ -367,7 +367,7 @@ class ImportResolution {\n     }\n \n     fn target_for_namespace(namespace: Namespace) -> option<Target> {\n-        alt namespace {\n+        match namespace {\n             ModuleNS    => return copy self.module_target,\n             TypeNS      => return copy self.type_target,\n             ValueNS     => return copy self.value_target,\n@@ -461,7 +461,7 @@ class Module {\n // requiring a T:copy.\n \n pure fn is_none<T>(x: option<T>) -> bool {\n-    alt x {\n+    match x {\n         none => return true,\n         some(_) => return false\n     }\n@@ -517,7 +517,7 @@ class NameBindings {\n \n     /// Returns the module node if applicable.\n     fn get_module_if_available() -> option<@Module> {\n-        alt self.module_def {\n+        match self.module_def {\n             NoModuleDef         => return none,\n             ModuleDef(module_)  => return some(module_)\n         }\n@@ -528,7 +528,7 @@ class NameBindings {\n      * definition.\n      */\n     fn get_module() -> @Module {\n-        alt self.module_def {\n+        match self.module_def {\n             NoModuleDef => {\n                 fail\n                     ~\"get_module called on a node with no module definition!\";\n@@ -540,7 +540,7 @@ class NameBindings {\n     }\n \n     fn defined_in_namespace(namespace: Namespace) -> bool {\n-        alt namespace {\n+        match namespace {\n             ModuleNS    => return self.module_def != NoModuleDef,\n             TypeNS      => return self.type_def != none,\n             ValueNS     => return self.value_def != none,\n@@ -549,12 +549,12 @@ class NameBindings {\n     }\n \n     fn def_for_namespace(namespace: Namespace) -> option<def> {\n-        alt namespace {\n+        match namespace {\n           TypeNS => return self.type_def,\n           ValueNS => return self.value_def,\n-          ModuleNS => alt self.module_def {\n+          ModuleNS => match self.module_def {\n             NoModuleDef => return none,\n-            ModuleDef(module_) => alt module_.def_id {\n+            ModuleDef(module_) => match module_.def_id {\n               none => return none,\n               some(def_id) => return some(def_mod(def_id))\n             }\n@@ -750,7 +750,7 @@ class Resolver {\n     /// Returns the current module tracked by the reduced graph parent.\n     fn get_module_from_parent(reduced_graph_parent: ReducedGraphParent)\n                            -> @Module {\n-        alt reduced_graph_parent {\n+        match reduced_graph_parent {\n             ModuleReducedGraphParent(module_) => {\n                 return module_;\n             }\n@@ -776,15 +776,15 @@ class Resolver {\n         // module and add the child to that.\n \n         let mut module_;\n-        alt reduced_graph_parent {\n+        match reduced_graph_parent {\n             ModuleReducedGraphParent(parent_module) => {\n                 module_ = parent_module;\n             }\n         }\n \n         // Add or reuse the child.\n         let new_parent = ModuleReducedGraphParent(module_);\n-        alt module_.children.find(name) {\n+        match module_.children.find(name) {\n             none => {\n                 let child = @NameBindings();\n                 module_.children.insert(name, child);\n@@ -804,9 +804,9 @@ class Resolver {\n \n         // Check each statement.\n         for block.node.stmts.each |statement| {\n-            alt statement.node {\n+            match statement.node {\n                 stmt_decl(declaration, _) => {\n-                    alt declaration.node {\n+                    match declaration.node {\n                         decl_item(_) => {\n                             return true;\n                         }\n@@ -828,7 +828,7 @@ class Resolver {\n     }\n \n     fn get_parent_link(parent: ReducedGraphParent, name: Atom) -> ParentLink {\n-        alt parent {\n+        match parent {\n             ModuleReducedGraphParent(module_) => {\n                 return ModuleParentLink(module_, name);\n             }\n@@ -843,7 +843,7 @@ class Resolver {\n         let atom = (*self.atom_table).intern(item.ident);\n         let (name_bindings, new_parent) = self.add_child(atom, parent);\n \n-        alt item.node {\n+        match item.node {\n             item_mod(module_) => {\n                 let parent_link = self.get_parent_link(new_parent, atom);\n                 let def_id = { crate: 0, node: item.id };\n@@ -894,7 +894,7 @@ class Resolver {\n             item_class(_, _, class_members, optional_ctor, _) => {\n                 (*name_bindings).define_type(def_ty(local_def(item.id)));\n \n-                alt optional_ctor {\n+                match optional_ctor {\n                     none => {\n                         // Nothing to do.\n                     }\n@@ -913,7 +913,7 @@ class Resolver {\n \n                 let mut method_infos = ~[];\n                 for class_members.each |class_member| {\n-                    alt class_member.node {\n+                    match class_member.node {\n                         class_method(method) => {\n                             // XXX: Combine with impl method code below.\n                             method_infos += ~[\n@@ -979,7 +979,7 @@ class Resolver {\n                 let method_names = @atom_hashmap();\n                 for methods.each |method| {\n                     let atom;\n-                    alt method {\n+                    match method {\n                         required(required_method) => {\n                             atom = (*self.atom_table).intern\n                                 (required_method.ident);\n@@ -1028,15 +1028,15 @@ class Resolver {\n     fn build_reduced_graph_for_view_item(view_item: @view_item,\n                                          parent: ReducedGraphParent,\n                                          &&_visitor: vt<ReducedGraphParent>) {\n-        alt view_item.node {\n+        match view_item.node {\n             view_item_import(view_paths) => {\n                 for view_paths.each |view_path| {\n                     // Extract and intern the module part of the path. For\n                     // globs and lists, the path is found directly in the AST;\n                     // for simple paths we have to munge the path a little.\n \n                     let module_path = @dvec();\n-                    alt view_path.node {\n+                    match view_path.node {\n                         view_path_simple(_, full_path, _) => {\n                             let path_len = full_path.idents.len();\n                             assert path_len != 0u;\n@@ -1061,7 +1061,7 @@ class Resolver {\n \n                     // Build up the import directives.\n                     let module_ = self.get_module_from_parent(parent);\n-                    alt view_path.node {\n+                    match view_path.node {\n                         view_path_simple(binding, full_path, _) => {\n                             let target_atom =\n                                 (*self.atom_table).intern(binding);\n@@ -1099,7 +1099,7 @@ class Resolver {\n             view_item_export(view_paths) => {\n                 let module_ = self.get_module_from_parent(parent);\n                 for view_paths.each |view_path| {\n-                    alt view_path.node {\n+                    match view_path.node {\n                         view_path_simple(ident, full_path, ident_id) => {\n                             let last_ident = full_path.idents.last();\n                             if last_ident != ident {\n@@ -1157,7 +1157,7 @@ class Resolver {\n             }\n \n             view_item_use(name, _, node_id) => {\n-                alt find_use_stmt_cnum(self.session.cstore, node_id) {\n+                match find_use_stmt_cnum(self.session.cstore, node_id) {\n                     some(crate_id) => {\n                         let atom = (*self.atom_table).intern(name);\n                         let (child_name_bindings, new_parent) =\n@@ -1189,7 +1189,7 @@ class Resolver {\n         let name = (*self.atom_table).intern(foreign_item.ident);\n         let (name_bindings, new_parent) = self.add_child(name, parent);\n \n-        alt foreign_item.node {\n+        match foreign_item.node {\n             foreign_item_fn(fn_decl, type_parameters) => {\n                 let def = def_fn(local_def(foreign_item.id), fn_decl.purity);\n                 (*name_bindings).define_value(def);\n@@ -1262,7 +1262,7 @@ class Resolver {\n                                    ModuleReducedGraphParent(current_module));\n \n                 // Define or reuse the module node.\n-                alt child_name_bindings.module_def {\n+                match child_name_bindings.module_def {\n                     NoModuleDef => {\n                         debug!{\"(building reduced graph for external crate) \\\n                                 autovivifying %s\", ident};\n@@ -1283,11 +1283,11 @@ class Resolver {\n                 self.add_child(atom,\n                                ModuleReducedGraphParent(current_module));\n \n-            alt path_entry.def_like {\n+            match path_entry.def_like {\n                 dl_def(def) => {\n-                    alt def {\n+                    match def {\n                         def_mod(def_id) | def_foreign_mod(def_id) => {\n-                            alt copy child_name_bindings.module_def {\n+                            match copy child_name_bindings.module_def {\n                                 NoModuleDef => {\n                                     debug!{\"(building reduced graph for \\\n                                             external crate) building module \\\n@@ -1296,7 +1296,7 @@ class Resolver {\n                                         self.get_parent_link(new_parent,\n                                                              atom);\n \n-                                    alt modules.find(def_id) {\n+                                    match modules.find(def_id) {\n                                         none => {\n                                             (*child_name_bindings).\n                                                 define_module(parent_link,\n@@ -1315,7 +1315,9 @@ class Resolver {\n                                             resolution.\n                                                 outstanding_references = 0;\n \n-                                            alt existing_module.parent_link {\n+                                            match existing_module\n+                                                .parent_link {\n+\n                                                 NoParentLink |\n                                                 BlockParentLink(*) => {\n                                                     fail ~\"can't happen\";\n@@ -1368,8 +1370,9 @@ class Resolver {\n                             // If this is a trait, add all the method names\n                             // to the trait info.\n \n-                            alt get_method_names_if_trait(self.session.cstore,\n-                                                          def_id) {\n+                            match get_method_names_if_trait(\n+                                self.session.cstore, def_id) {\n+\n                                 none => {\n                                     // Nothing to do.\n                                 }\n@@ -1437,7 +1440,7 @@ class Resolver {\n         self.build_reduced_graph_for_impls_in_external_module(module_);\n \n         for module_.children.each |_name, child_node| {\n-            alt (*child_node).get_module_if_available() {\n+            match (*child_node).get_module_if_available() {\n                 none => {\n                     // Nothing to do.\n                 }\n@@ -1464,7 +1467,7 @@ class Resolver {\n                self.module_to_str(module_),\n                copy module_.def_id};\n \n-        alt module_.def_id {\n+        match module_.def_id {\n             none => {\n                 debug!{\"(building reduced graph for impls in external \\\n                         module) no def ID for `%s`, skipping\",\n@@ -1516,9 +1519,9 @@ class Resolver {\n         // Bump the reference count on the name. Or, if this is a glob, set\n         // the appropriate flag.\n \n-        alt *subclass {\n+        match *subclass {\n             SingleImport(target, _) => {\n-                alt module_.import_resolutions.find(target) {\n+                match module_.import_resolutions.find(target) {\n                     some(resolution) => {\n                         resolution.outstanding_references += 1u;\n                     }\n@@ -1588,7 +1591,7 @@ class Resolver {\n         self.resolve_imports_for_module(module_);\n \n         for module_.children.each |_name, child_node| {\n-            alt (*child_node).get_module_if_available() {\n+            match (*child_node).get_module_if_available() {\n                 none => {\n                     // Nothing to do.\n                 }\n@@ -1616,7 +1619,7 @@ class Resolver {\n         while module_.resolved_import_count < import_count {\n             let import_index = module_.resolved_import_count;\n             let import_directive = module_.imports.get_elt(import_index);\n-            alt self.resolve_import_for_module(module_, import_directive) {\n+            match self.resolve_import_for_module(module_, import_directive) {\n                 Failed => {\n                     // We presumably emitted an error. Continue.\n                     self.session.span_err(import_directive.span,\n@@ -1663,7 +1666,7 @@ class Resolver {\n                                                        import_directive);\n         } else {\n             // First, resolve the module path for the directive, if necessary.\n-            alt self.resolve_module_path_for_import(module_,\n+            match self.resolve_module_path_for_import(module_,\n                                                     module_path,\n                                                     NoXray,\n                                                     import_directive.span) {\n@@ -1678,7 +1681,7 @@ class Resolver {\n                     // We found the module that the target is contained\n                     // within. Attempt to resolve the import within it.\n \n-                    alt *import_directive.subclass {\n+                    match *import_directive.subclass {\n                         SingleImport(target, source) => {\n                             resolution_result =\n                                 self.resolve_single_import(module_,\n@@ -1699,7 +1702,7 @@ class Resolver {\n         }\n \n         // Decrement the count of unresolved imports.\n-        alt resolution_result {\n+        match resolution_result {\n             Success(()) => {\n                 assert self.unresolved_imports >= 1u;\n                 self.unresolved_imports -= 1u;\n@@ -1715,7 +1718,7 @@ class Resolver {\n         // resolve_imports_for_module.)\n \n         if resolution_result != Indeterminate {\n-            alt *import_directive.subclass {\n+            match *import_directive.subclass {\n                 GlobImport => {\n                     assert module_.glob_count >= 1u;\n                     module_.glob_count -= 1u;\n@@ -1757,7 +1760,7 @@ class Resolver {\n         let mut impl_result = UnknownImplResult;\n \n         // Search for direct children of the containing module.\n-        alt containing_module.children.find(source) {\n+        match containing_module.children.find(source) {\n             none => {\n                 // Continue.\n             }\n@@ -1786,7 +1789,7 @@ class Resolver {\n         // Unless we managed to find a result in all four namespaces\n         // (exceedingly unlikely), search imports as well.\n \n-        alt (module_result, value_result, type_result, impl_result) {\n+        match (module_result, value_result, type_result, impl_result) {\n             (BoundResult(*), BoundResult(*), BoundResult(*),\n              BoundImplResult(*)) => {\n                 // Continue.\n@@ -1805,7 +1808,7 @@ class Resolver {\n                 // Now search the exported imports within the containing\n                 // module.\n \n-                alt containing_module.import_resolutions.find(source) {\n+                match containing_module.import_resolutions.find(source) {\n                     none => {\n                         // The containing module definitely doesn't have an\n                         // exported import with the name in question. We can\n@@ -1833,7 +1836,7 @@ class Resolver {\n                                        namespace: Namespace)\n                                     -> NamespaceResult {\n \n-                            alt (*import_resolution).\n+                            match (*import_resolution).\n                                     target_for_namespace(namespace) {\n                                 none => {\n                                     return UnboundResult;\n@@ -1892,7 +1895,7 @@ class Resolver {\n         assert module_.import_resolutions.contains_key(target);\n         let import_resolution = module_.import_resolutions.get(target);\n \n-        alt module_result {\n+        match module_result {\n             BoundResult(target_module, name_bindings) => {\n                 debug!{\"(resolving single import) found module binding\"};\n                 import_resolution.module_target =\n@@ -1906,7 +1909,7 @@ class Resolver {\n                 fail ~\"module result should be known at this point\";\n             }\n         }\n-        alt value_result {\n+        match value_result {\n             BoundResult(target_module, name_bindings) => {\n                 import_resolution.value_target =\n                     some(Target(target_module, name_bindings));\n@@ -1916,7 +1919,7 @@ class Resolver {\n                 fail ~\"value result should be known at this point\";\n             }\n         }\n-        alt type_result {\n+        match type_result {\n             BoundResult(target_module, name_bindings) => {\n                 import_resolution.type_target =\n                     some(Target(target_module, name_bindings));\n@@ -1926,7 +1929,7 @@ class Resolver {\n                 fail ~\"type result should be known at this point\";\n             }\n         }\n-        alt impl_result {\n+        match impl_result {\n             BoundImplResult(targets) => {\n                 for (*targets).each |target| {\n                     (*import_resolution.impl_target).push(target);\n@@ -1939,7 +1942,8 @@ class Resolver {\n         }\n \n         let i = import_resolution;\n-        alt (i.module_target, i.value_target, i.type_target, i.impl_target) {\n+        match (i.module_target, i.value_target,\n+               i.type_target, i.impl_target) {\n           /*\n             If this name wasn't found in any of the four namespaces, it's\n             definitely unresolved\n@@ -1996,7 +2000,7 @@ class Resolver {\n                    self.module_to_str(module_)};\n \n             // Here we merge two import resolutions.\n-            alt module_.import_resolutions.find(atom) {\n+            match module_.import_resolutions.find(atom) {\n                 none => {\n                     // Simple: just copy the old import resolution.\n                     let new_import_resolution =\n@@ -2017,7 +2021,7 @@ class Resolver {\n                     // Merge the two import resolutions at a finer-grained\n                     // level.\n \n-                    alt copy target_import_resolution.module_target {\n+                    match copy target_import_resolution.module_target {\n                         none => {\n                             // Continue.\n                         }\n@@ -2026,7 +2030,7 @@ class Resolver {\n                                 some(copy module_target);\n                         }\n                     }\n-                    alt copy target_import_resolution.value_target {\n+                    match copy target_import_resolution.value_target {\n                         none => {\n                             // Continue.\n                         }\n@@ -2035,7 +2039,7 @@ class Resolver {\n                                 some(copy value_target);\n                         }\n                     }\n-                    alt copy target_import_resolution.type_target {\n+                    match copy target_import_resolution.type_target {\n                         none => {\n                             // Continue.\n                         }\n@@ -2068,7 +2072,7 @@ class Resolver {\n             }\n \n             let mut dest_import_resolution;\n-            alt module_.import_resolutions.find(atom) {\n+            match module_.import_resolutions.find(atom) {\n                 none => {\n                     // Create a new import resolution from this child.\n                     dest_import_resolution = @ImportResolution(span);\n@@ -2131,7 +2135,7 @@ class Resolver {\n \n         while index < module_path_len {\n             let name = (*module_path).get_elt(index);\n-            alt self.resolve_name_in_module(search_module, name, ModuleNS,\n+            match self.resolve_name_in_module(search_module, name, ModuleNS,\n                                             xray) {\n \n                 Failed => {\n@@ -2145,7 +2149,7 @@ class Resolver {\n                     return Indeterminate;\n                 }\n                 Success(target) => {\n-                    alt target.bindings.module_def {\n+                    match target.bindings.module_def {\n                         NoModuleDef => {\n                             // Not a module.\n                             self.session.span_err(span,\n@@ -2190,7 +2194,7 @@ class Resolver {\n \n         let first_element = (*module_path).get_elt(0u);\n         let mut search_module;\n-        alt self.resolve_module_in_lexical_scope(module_, first_element) {\n+        match self.resolve_module_in_lexical_scope(module_, first_element) {\n             Failed => {\n                 self.session.span_err(span, ~\"unresolved name\");\n                 return Failed;\n@@ -2226,7 +2230,7 @@ class Resolver {\n         // The current module node is handled specially. First, check for\n         // its immediate children.\n \n-        alt module_.children.find(name) {\n+        match module_.children.find(name) {\n             some(name_bindings)\n                     if (*name_bindings).defined_in_namespace(namespace) => {\n \n@@ -2240,12 +2244,12 @@ class Resolver {\n         // adjacent import statements are processed as though they mutated the\n         // current scope.\n \n-        alt module_.import_resolutions.find(name) {\n+        match module_.import_resolutions.find(name) {\n             none => {\n                 // Not found; continue.\n             }\n             some(import_resolution) => {\n-                alt (*import_resolution).target_for_namespace(namespace) {\n+                match (*import_resolution).target_for_namespace(namespace) {\n                     none => {\n                         // Not found; continue.\n                         debug!{\"(resolving item in lexical scope) found \\\n@@ -2264,7 +2268,7 @@ class Resolver {\n         let mut search_module = module_;\n         loop {\n             // Go to the next parent.\n-            alt search_module.parent_link {\n+            match search_module.parent_link {\n                 NoParentLink => {\n                     // No more parents. This module was unresolved.\n                     debug!{\"(resolving item in lexical scope) unresolved \\\n@@ -2278,7 +2282,7 @@ class Resolver {\n             }\n \n             // Resolve the name in the parent module.\n-            alt self.resolve_name_in_module(search_module, name, namespace,\n+            match self.resolve_name_in_module(search_module, name, namespace,\n                                             Xray) {\n                 Failed => {\n                     // Continue up the search chain.\n@@ -2302,9 +2306,9 @@ class Resolver {\n     fn resolve_module_in_lexical_scope(module_: @Module, name: Atom)\n                                     -> ResolveResult<@Module> {\n \n-        alt self.resolve_item_in_lexical_scope(module_, name, ModuleNS) {\n+        match self.resolve_item_in_lexical_scope(module_, name, ModuleNS) {\n             Success(target) => {\n-                alt target.bindings.module_def {\n+                match target.bindings.module_def {\n                     NoModuleDef => {\n                         error!{\"!!! (resolving module in lexical scope) module\n                                 wasn't actually a module!\"};\n@@ -2355,7 +2359,7 @@ class Resolver {\n         }\n \n         // First, check the direct children of the module.\n-        alt module_.children.find(name) {\n+        match module_.children.find(name) {\n             some(name_bindings)\n                     if (*name_bindings).defined_in_namespace(namespace) => {\n \n@@ -2376,15 +2380,15 @@ class Resolver {\n         }\n \n         // Otherwise, we check the list of resolved imports.\n-        alt module_.import_resolutions.find(name) {\n+        match module_.import_resolutions.find(name) {\n             some(import_resolution) => {\n                 if import_resolution.outstanding_references != 0u {\n                     debug!{\"(resolving name in module) import unresolved; \\\n                             bailing out\"};\n                     return Indeterminate;\n                 }\n \n-                alt (*import_resolution).target_for_namespace(namespace) {\n+                match (*import_resolution).target_for_namespace(namespace) {\n                     none => {\n                         debug!{\"(resolving name in module) name found, but \\\n                                 not in namespace %?\",\n@@ -2420,7 +2424,7 @@ class Resolver {\n \n         let mut target_name;\n         let mut source_name;\n-        alt *import_directive.subclass {\n+        match *import_directive.subclass {\n             SingleImport(target, source) => {\n                 target_name = target;\n                 source_name = source;\n@@ -2442,7 +2446,7 @@ class Resolver {\n \n         let mut module_result;\n         debug!{\"(resolving one-level naming result) searching for module\"};\n-        alt self.resolve_item_in_lexical_scope(module_,\n+        match self.resolve_item_in_lexical_scope(module_,\n                                                source_name,\n                                                ModuleNS) {\n \n@@ -2465,7 +2469,7 @@ class Resolver {\n \n         let mut value_result;\n         debug!{\"(resolving one-level naming result) searching for value\"};\n-        alt self.resolve_item_in_lexical_scope(module_,\n+        match self.resolve_item_in_lexical_scope(module_,\n                                                source_name,\n                                                ValueNS) {\n \n@@ -2488,7 +2492,7 @@ class Resolver {\n \n         let mut type_result;\n         debug!{\"(resolving one-level naming result) searching for type\"};\n-        alt self.resolve_item_in_lexical_scope(module_,\n+        match self.resolve_item_in_lexical_scope(module_,\n                                                source_name,\n                                                TypeNS) {\n \n@@ -2528,7 +2532,7 @@ class Resolver {\n \n         let mut impl_result;\n         debug!{\"(resolving one-level naming result) searching for impl\"};\n-        alt self.resolve_item_in_lexical_scope(module_,\n+        match self.resolve_item_in_lexical_scope(module_,\n                                                source_name,\n                                                ImplNS) {\n \n@@ -2559,7 +2563,7 @@ class Resolver {\n         }\n \n         // Otherwise, proceed and write in the bindings.\n-        alt module_.import_resolutions.find(target_name) {\n+        match module_.import_resolutions.find(target_name) {\n             none => {\n                 fail ~\"(resolving one-level renaming import) reduced graph \\\n                       construction or glob importing should have created the \\\n@@ -2576,7 +2580,7 @@ class Resolver {\n                 import_resolution.value_target = value_result;\n                 import_resolution.type_target = type_result;\n \n-                alt impl_result {\n+                match impl_result {\n                     none => {\n                         // Nothing to do.\n                     }\n@@ -2604,7 +2608,7 @@ class Resolver {\n \n         // Descend into children and anonymous children.\n         for module_.children.each |_name, child_node| {\n-            alt (*child_node).get_module_if_available() {\n+            match (*child_node).get_module_if_available() {\n                 none => {\n                     // Continue.\n                 }\n@@ -2637,7 +2641,7 @@ class Resolver {\n         // If this isn't a local crate, then bail out. We don't need to record\n         // exports for local crates.\n \n-        alt module_.def_id {\n+        match module_.def_id {\n             some(def_id) if def_id.crate == local_crate => {\n                 // OK. Continue.\n             }\n@@ -2656,7 +2660,7 @@ class Resolver {\n         self.record_exports_for_module(module_);\n \n         for module_.children.each |_atom, child_name_bindings| {\n-            alt (*child_name_bindings).get_module_if_available() {\n+            match (*child_name_bindings).get_module_if_available() {\n                 none => {\n                     // Nothing to do.\n                 }\n@@ -2682,7 +2686,7 @@ class Resolver {\n                     again;\n                 }\n \n-                alt self.resolve_definition_of_name_in_module(module_,\n+                match self.resolve_definition_of_name_in_module(module_,\n                                                               name,\n                                                               namespace,\n                                                               Xray) {\n@@ -2723,7 +2727,7 @@ class Resolver {\n         // If this isn't a local crate, then bail out. We don't need to\n         // resolve implementations for external crates.\n \n-        alt module_.def_id {\n+        match module_.def_id {\n             some(def_id) if def_id.crate == local_crate => {\n                 // OK. Continue.\n             }\n@@ -2742,7 +2746,7 @@ class Resolver {\n         self.build_impl_scope_for_module(module_);\n \n         for module_.children.each |_atom, child_name_bindings| {\n-            alt (*child_name_bindings).get_module_if_available() {\n+            match (*child_name_bindings).get_module_if_available() {\n                 none => {\n                     // Nothing to do.\n                 }\n@@ -2788,7 +2792,7 @@ class Resolver {\n \n         // Determine the parent's implementation scope.\n         let mut parent_impl_scopes;\n-        alt module_.parent_link {\n+        match module_.parent_link {\n             NoParentLink => {\n                 parent_impl_scopes = @nil;\n             }\n@@ -2830,19 +2834,19 @@ class Resolver {\n         let orig_module = self.current_module;\n \n         // Move down in the graph.\n-        alt name {\n+        match name {\n             none => {\n                 // Nothing to do.\n             }\n             some(name) => {\n-                alt orig_module.children.find(name) {\n+                match orig_module.children.find(name) {\n                     none => {\n                         debug!{\"!!! (with scope) didn't find `%s` in `%s`\",\n                                *(*self.atom_table).atom_to_str(name),\n                                self.module_to_str(orig_module)};\n                     }\n                     some(name_bindings) => {\n-                        alt (*name_bindings).get_module_if_available() {\n+                        match (*name_bindings).get_module_if_available() {\n                             none => {\n                                 debug!{\"!!! (with scope) didn't find module \\\n                                         for `%s` in `%s`\",\n@@ -2873,7 +2877,7 @@ class Resolver {\n         let mut def;\n         let mut is_ty_param;\n \n-        alt def_like {\n+        match def_like {\n             dl_def(d @ def_local(*)) | dl_def(d @ def_upvar(*)) |\n             dl_def(d @ def_arg(*)) | dl_def(d @ def_binding(*)) => {\n                 def = d;\n@@ -2896,7 +2900,7 @@ class Resolver {\n         let mut rib_index = rib_index + 1u;\n         while rib_index < (*ribs).len() {\n             let rib = (*ribs).get_elt(rib_index);\n-            alt rib.kind {\n+            match rib.kind {\n                 NormalRibKind => {\n                     // Nothing to do. Continue.\n                 }\n@@ -2910,7 +2914,7 @@ class Resolver {\n                 MethodRibKind(item_id, method_id) => {\n                   // If the def is a ty param, and came from the parent\n                   // item, it's ok\n-                  alt def {\n+                  match def {\n                     def_ty_param(did, _) if self.def_map.find(copy(did.node))\n                       == some(def_typaram_binder(item_id)) => {\n                       // ok\n@@ -2976,7 +2980,7 @@ class Resolver {\n         while i != 0u {\n             i -= 1u;\n             let rib = (*ribs).get_elt(i);\n-            alt rib.bindings.find(name) {\n+            match rib.bindings.find(name) {\n                 some(def_like) => {\n                     return self.upvarify(ribs, i, def_like, span,\n                                       allow_capturing_self);\n@@ -3028,7 +3032,7 @@ class Resolver {\n             self.xray_context = Xray;\n         }\n \n-        alt item.node {\n+        match item.node {\n             item_enum(_, type_parameters) |\n             item_ty(_, type_parameters) => {\n                 do self.with_type_parameter_rib\n@@ -3090,7 +3094,7 @@ class Resolver {\n                         //\n                         // XXX: Do we need a node ID here?\n \n-                        alt method {\n+                        match method {\n                           required(ty_m) => {\n                             do self.with_type_parameter_rib\n                                 (HasTypeParameters(&ty_m.tps,\n@@ -3148,7 +3152,7 @@ class Resolver {\n                 let atom = (*self.atom_table).intern(item.ident);\n                 do self.with_scope(some(atom)) {\n                     for foreign_module.items.each |foreign_item| {\n-                        alt foreign_item.node {\n+                        match foreign_item.node {\n                             foreign_item_fn(_, type_parameters) => {\n                                 do self.with_type_parameter_rib\n                                     (HasTypeParameters(&type_parameters,\n@@ -3206,7 +3210,7 @@ class Resolver {\n     }\n \n     fn with_type_parameter_rib(type_parameters: TypeParameters, f: fn()) {\n-        alt type_parameters {\n+        match type_parameters {\n             HasTypeParameters(type_parameters, node_id, initial_index,\n                               rib_kind) => {\n \n@@ -3236,7 +3240,7 @@ class Resolver {\n \n         f();\n \n-        alt type_parameters {\n+        match type_parameters {\n             HasTypeParameters(type_parameters, _, _, _) => {\n                 (*self.type_ribs).pop();\n             }\n@@ -3256,14 +3260,14 @@ class Resolver {\n                         visitor: ResolveVisitor) {\n \n         // Check each element of the capture clause.\n-        alt capture_clause {\n+        match capture_clause {\n             NoCaptureClause => {\n                 // Nothing to do.\n             }\n             HasCaptureClause(capture_clause) => {\n                 // Resolve each captured item.\n                 for (*capture_clause).each |capture_item| {\n-                    alt self.resolve_identifier(capture_item.name,\n+                    match self.resolve_identifier(capture_item.name,\n                                                 ValueNS,\n                                                 true,\n                                                 capture_item.span) {\n@@ -3287,7 +3291,7 @@ class Resolver {\n         // If this function has type parameters, add them now.\n         do self.with_type_parameter_rib(type_parameters) {\n             // Resolve the type parameters.\n-            alt type_parameters {\n+            match type_parameters {\n                 NoTypeParameters => {\n                     // Continue.\n                 }\n@@ -3297,7 +3301,7 @@ class Resolver {\n             }\n \n             // Add self to the rib, if necessary.\n-            alt self_binding {\n+            match self_binding {\n                 NoSelfBinding => {\n                     // Nothing to do.\n                 }\n@@ -3309,7 +3313,7 @@ class Resolver {\n             }\n \n             // Add each argument to the rib.\n-            alt optional_declaration {\n+            match optional_declaration {\n                 none => {\n                     // Nothing to do.\n                 }\n@@ -3344,7 +3348,7 @@ class Resolver {\n \n         for type_parameters.each |type_parameter| {\n             for (*type_parameter.bounds).each |bound| {\n-                alt bound {\n+                match bound {\n                     bound_copy | bound_send | bound_const | bound_owned => {\n                         // Nothing to do.\n                     }\n@@ -3379,7 +3383,7 @@ class Resolver {\n \n             // Resolve implemented traits.\n             for traits.each |trt| {\n-                alt self.resolve_path(trt.path, TypeNS, true, visitor) {\n+                match self.resolve_path(trt.path, TypeNS, true, visitor) {\n                     none => {\n                         self.session.span_err(trt.path.span,\n                                               ~\"attempt to implement a \\\n@@ -3404,7 +3408,7 @@ class Resolver {\n \n             // Resolve methods.\n             for class_members.each |class_member| {\n-                alt class_member.node {\n+                match class_member.node {\n                     class_method(method) => {\n                       self.resolve_method(MethodRibKind(id,\n                                                Provided(method.id)),\n@@ -3419,7 +3423,7 @@ class Resolver {\n             }\n \n             // Resolve the constructor, if applicable.\n-            alt optional_constructor {\n+            match optional_constructor {\n                 none => {\n                     // Nothing to do.\n                 }\n@@ -3436,7 +3440,7 @@ class Resolver {\n             }\n \n             // Resolve the destructor, if applicable.\n-            alt optional_destructor {\n+            match optional_destructor {\n                 none => {\n                     // Nothing to do.\n                 }\n@@ -3498,8 +3502,8 @@ class Resolver {\n             if trait_references.len() >= 1 {\n                 let mut new_trait_refs = @dvec();\n                 for trait_references.each |trait_reference| {\n-                    alt self.resolve_path(trait_reference.path, TypeNS, true,\n-                                          visitor) {\n+                    match self.resolve_path(\n+                        trait_reference.path, TypeNS, true, visitor) {\n                         none => {\n                             self.session.span_err(span,\n                                                   ~\"attempt to implement an \\\n@@ -3566,7 +3570,7 @@ class Resolver {\n         self.resolve_type(local.node.ty, visitor);\n \n         // Resolve the initializer, if necessary.\n-        alt local.node.init {\n+        match local.node.init {\n             none => {\n                 // Nothing to do.\n             }\n@@ -3639,7 +3643,7 @@ class Resolver {\n \n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module;\n-        alt self.current_module.anonymous_children.find(block.node.id) {\n+        match self.current_module.anonymous_children.find(block.node.id) {\n             none => { /* Nothing to do. */ }\n             some(anonymous_module) => {\n                 debug!{\"(resolving block) found anonymous module, moving \\\n@@ -3659,7 +3663,7 @@ class Resolver {\n     }\n \n     fn resolve_type(ty: @ty, visitor: ResolveVisitor) {\n-        alt ty.node {\n+        match ty.node {\n             // Like path expressions, the interpretation of path types depends\n             // on whether the path has multiple elements in it or not.\n \n@@ -3668,7 +3672,7 @@ class Resolver {\n                 // scopes looking for it.\n \n                 let mut result_def;\n-                alt self.resolve_path(path, TypeNS, true, visitor) {\n+                match self.resolve_path(path, TypeNS, true, visitor) {\n                     some(def) => {\n                         debug!{\"(resolving type) resolved `%s` to type\",\n                                *path.idents.last()};\n@@ -3679,7 +3683,7 @@ class Resolver {\n                     }\n                 }\n \n-                alt result_def {\n+                match result_def {\n                     some(_) => {\n                         // Continue.\n                     }\n@@ -3689,7 +3693,7 @@ class Resolver {\n                             let name =\n                                 (*self.atom_table).intern(path.idents.last());\n \n-                            alt self.primitive_type_table\n+                            match self.primitive_type_table\n                                     .primitive_types\n                                     .find(name) {\n \n@@ -3705,7 +3709,7 @@ class Resolver {\n                     }\n                 }\n \n-                alt copy result_def {\n+                match copy result_def {\n                     some(def) => {\n                         // Write the result into the def map.\n                         debug!{\"(resolving type) writing resolution for `%s` \\\n@@ -3740,7 +3744,7 @@ class Resolver {\n \n         let pat_id = pattern.id;\n         do walk_pat(pattern) |pattern| {\n-            alt pattern.node {\n+            match pattern.node {\n                 pat_ident(binding_mode, path, _)\n                         if !path.global && path.idents.len() == 1u => {\n \n@@ -3754,7 +3758,7 @@ class Resolver {\n \n                     let atom = (*self.atom_table).intern(path.idents[0]);\n \n-                    alt self.resolve_enum_variant_or_const(atom) {\n+                    match self.resolve_enum_variant_or_const(atom) {\n                         FoundEnumVariant(def) if mode == RefutableMode => {\n                             debug!{\"(resolving pattern) resolving `%s` to \\\n                                     enum variant\",\n@@ -3783,7 +3787,7 @@ class Resolver {\n \n                             let is_mutable = mutability == Mutable;\n \n-                            let def = alt mode {\n+                            let def = match mode {\n                                 RefutableMode => {\n                                     // For pattern arms, we must use\n                                     // `def_binding` definitions.\n@@ -3808,7 +3812,7 @@ class Resolver {\n                             // because that breaks the assumptions later\n                             // passes make about or-patterns.)\n \n-                            alt bindings_list {\n+                            match bindings_list {\n                                 some(bindings_list)\n                                 if !bindings_list.contains_key(atom) => {\n                                     let last_rib = (*self.value_ribs).last();\n@@ -3845,7 +3849,7 @@ class Resolver {\n \n                 pat_ident(_, path, _) | pat_enum(path, _) => {\n                     // These two must be enum variants.\n-                    alt self.resolve_path(path, ValueNS, false, visitor) {\n+                    match self.resolve_path(path, ValueNS, false, visitor) {\n                         some(def @ def_variant(*)) => {\n                             self.record_def(pattern.id, def);\n                         }\n@@ -3886,12 +3890,12 @@ class Resolver {\n     fn resolve_enum_variant_or_const(name: Atom)\n                                   -> EnumVariantOrConstResolution {\n \n-        alt self.resolve_item_in_lexical_scope(self.current_module,\n+        match self.resolve_item_in_lexical_scope(self.current_module,\n                                                name,\n                                                ValueNS) {\n \n             Success(target) => {\n-                alt target.bindings.value_def {\n+                match target.bindings.value_def {\n                     none => {\n                         fail ~\"resolved name in the value namespace to a set \\\n                               of name bindings with no def?!\";\n@@ -3956,7 +3960,7 @@ class Resolver {\n                        -> option<def> {\n \n         if check_ribs {\n-            alt self.resolve_identifier_in_local_ribs(identifier,\n+            match self.resolve_identifier_in_local_ribs(identifier,\n                                                       namespace,\n                                                       span) {\n                 some(def) => {\n@@ -3987,9 +3991,9 @@ class Resolver {\n         }\n \n         // First, search children.\n-        alt containing_module.children.find(name) {\n+        match containing_module.children.find(name) {\n             some(child_name_bindings) => {\n-                alt (*child_name_bindings).def_for_namespace(namespace) {\n+                match (*child_name_bindings).def_for_namespace(namespace) {\n                     some(def) => {\n                         // Found it. Stop the search here.\n                         return ChildNameDefinition(def);\n@@ -4005,11 +4009,12 @@ class Resolver {\n         }\n \n         // Next, search import resolutions.\n-        alt containing_module.import_resolutions.find(name) {\n+        match containing_module.import_resolutions.find(name) {\n             some(import_resolution) => {\n-                alt (*import_resolution).target_for_namespace(namespace) {\n+                match (*import_resolution).target_for_namespace(namespace) {\n                     some(target) => {\n-                        alt (*target.bindings).def_for_namespace(namespace) {\n+                        match (*target.bindings)\n+                            .def_for_namespace(namespace) {\n                             some(def) => {\n                                 // Found it.\n                                 import_resolution.used = true;\n@@ -4055,7 +4060,7 @@ class Resolver {\n         let module_path_atoms = self.intern_module_part_of_path(path);\n \n         let mut containing_module;\n-        alt self.resolve_module_path_for_import(self.current_module,\n+        match self.resolve_module_path_for_import(self.current_module,\n                                                 module_path_atoms,\n                                                 xray,\n                                                 path.span) {\n@@ -4078,7 +4083,7 @@ class Resolver {\n         }\n \n         let name = (*self.atom_table).intern(path.idents.last());\n-        alt self.resolve_definition_of_name_in_module(containing_module,\n+        match self.resolve_definition_of_name_in_module(containing_module,\n                                                       name,\n                                                       namespace,\n                                                       xray) {\n@@ -4108,7 +4113,7 @@ class Resolver {\n         let root_module = (*self.graph_root).get_module();\n \n         let mut containing_module;\n-        alt self.resolve_module_path_from_root(root_module,\n+        match self.resolve_module_path_from_root(root_module,\n                                                module_path_atoms,\n                                                0u,\n                                                xray,\n@@ -4132,7 +4137,7 @@ class Resolver {\n         }\n \n         let name = (*self.atom_table).intern(path.idents.last());\n-        alt self.resolve_definition_of_name_in_module(containing_module,\n+        match self.resolve_definition_of_name_in_module(containing_module,\n                                                       name,\n                                                       namespace,\n                                                       xray) {\n@@ -4161,7 +4166,7 @@ class Resolver {\n \n         // Check the local set of ribs.\n         let mut search_result;\n-        alt namespace {\n+        match namespace {\n             ValueNS => {\n                 search_result = self.search_ribs(self.value_ribs, name, span,\n                                                  DontAllowCapturingSelf);\n@@ -4175,7 +4180,7 @@ class Resolver {\n             }\n         }\n \n-        alt copy search_result {\n+        match copy search_result {\n             some(dl_def(def)) => {\n                 debug!{\"(resolving path in local ribs) resolved `%s` to \\\n                         local: %?\",\n@@ -4196,12 +4201,12 @@ class Resolver {\n         let name = (*self.atom_table).intern(ident);\n \n         // Check the items.\n-        alt self.resolve_item_in_lexical_scope(self.current_module,\n+        match self.resolve_item_in_lexical_scope(self.current_module,\n                                                name,\n                                                namespace) {\n \n             Success(target) => {\n-                alt (*target.bindings).def_for_namespace(namespace) {\n+                match (*target.bindings).def_for_namespace(namespace) {\n                     none => {\n                         fail ~\"resolved name in a namespace to a set of name \\\n                               bindings with no def for that namespace?!\";\n@@ -4235,15 +4240,15 @@ class Resolver {\n         self.record_candidate_traits_for_expr_if_necessary(expr);\n \n         // Next, resolve the node.\n-        alt expr.node {\n+        match expr.node {\n             // The interpretation of paths depends on whether the path has\n             // multiple elements in it or not.\n \n             expr_path(path) => {\n                 // This is a local path in the value namespace. Walk through\n                 // scopes looking for it.\n \n-                alt self.resolve_path(path, ValueNS, true, visitor) {\n+                match self.resolve_path(path, ValueNS, true, visitor) {\n                     some(def) => {\n                         // Write the result into the def map.\n                         debug!{\"(resolving expr) resolved `%s`\",\n@@ -4288,7 +4293,7 @@ class Resolver {\n                 //    type Bar<A> = Foo<A>;\n                 //    let bar = Bar { ... } // no type parameters\n \n-                alt self.resolve_path(path, TypeNS, false, visitor) {\n+                match self.resolve_path(path, TypeNS, false, visitor) {\n                     some(definition @ def_ty(class_id))\n                             if self.structs.contains_key(class_id) => {\n \n@@ -4316,7 +4321,7 @@ class Resolver {\n     }\n \n     fn record_impls_for_expr_if_necessary(expr: @expr) {\n-        alt expr.node {\n+        match expr.node {\n             expr_field(*) | expr_path(*) | expr_cast(*) | expr_binary(*) |\n             expr_unary(*) | expr_assign_op(*) | expr_index(*) => {\n                 self.impl_map.insert(expr.id,\n@@ -4329,7 +4334,7 @@ class Resolver {\n     }\n \n     fn record_candidate_traits_for_expr_if_necessary(expr: @expr) {\n-        alt expr.node {\n+        match expr.node {\n             expr_field(_, ident, _) => {\n                 let atom = (*self.atom_table).intern(ident);\n                 let traits = self.search_for_traits_containing_method(atom);\n@@ -4394,7 +4399,7 @@ class Resolver {\n         let mut search_module = self.current_module;\n         loop {\n             // Look for the current trait.\n-            alt copy self.current_trait_refs {\n+            match copy self.current_trait_refs {\n                 some(trait_def_ids) => {\n                     for trait_def_ids.each |trait_def_id| {\n                         self.add_trait_info_if_containing_method\n@@ -4408,7 +4413,7 @@ class Resolver {\n \n             // Look for trait children.\n             for search_module.children.each |_name, child_name_bindings| {\n-                alt child_name_bindings.def_for_namespace(TypeNS) {\n+                match child_name_bindings.def_for_namespace(TypeNS) {\n                     some(def_ty(trait_def_id)) => {\n                         self.add_trait_info_if_containing_method(found_traits,\n                                                                  trait_def_id,\n@@ -4424,12 +4429,12 @@ class Resolver {\n             for search_module.import_resolutions.each\n                     |_atom, import_resolution| {\n \n-                alt import_resolution.target_for_namespace(TypeNS) {\n+                match import_resolution.target_for_namespace(TypeNS) {\n                     none => {\n                         // Continue.\n                     }\n                     some(target) => {\n-                        alt target.bindings.def_for_namespace(TypeNS) {\n+                        match target.bindings.def_for_namespace(TypeNS) {\n                             some(def_ty(trait_def_id)) => {\n                                 self.add_trait_info_if_containing_method\n                                     (found_traits, trait_def_id, name);\n@@ -4443,7 +4448,7 @@ class Resolver {\n             }\n \n             // Move to the next parent.\n-            alt search_module.parent_link {\n+            match search_module.parent_link {\n                 NoParentLink => {\n                     // Done.\n                     break;\n@@ -4462,7 +4467,7 @@ class Resolver {\n                                            trait_def_id: def_id,\n                                            name: Atom) {\n \n-        alt self.trait_info.find(trait_def_id) {\n+        match self.trait_info.find(trait_def_id) {\n             some(trait_info) if trait_info.contains_key(name) => {\n                 debug!{\"(adding trait info if containing method) found trait \\\n                         %d:%d for method '%s'\",\n@@ -4508,7 +4513,7 @@ class Resolver {\n         // If this isn't a local crate, then bail out. We don't need to check\n         // for unused imports in external crates.\n \n-        alt module_.def_id {\n+        match module_.def_id {\n             some(def_id) if def_id.crate == local_crate => {\n                 // OK. Continue.\n             }\n@@ -4527,7 +4532,7 @@ class Resolver {\n         self.check_for_unused_imports_in_module(module_);\n \n         for module_.children.each |_atom, child_name_bindings| {\n-            alt (*child_name_bindings).get_module_if_available() {\n+            match (*child_name_bindings).get_module_if_available() {\n                 none => {\n                     // Nothing to do.\n                 }\n@@ -4546,7 +4551,7 @@ class Resolver {\n     fn check_for_unused_imports_in_module(module_: @Module) {\n         for module_.import_resolutions.each |_impl_name, import_resolution| {\n             if !import_resolution.used {\n-                alt self.unused_import_lint_level {\n+                match self.unused_import_lint_level {\n                     warn => {\n                         self.session.span_warn(import_resolution.span,\n                                                ~\"unused import\");\n@@ -4577,7 +4582,7 @@ class Resolver {\n         let atoms = dvec();\n         let mut current_module = module_;\n         loop {\n-            alt current_module.parent_link {\n+            match current_module.parent_link {\n                 NoParentLink => {\n                     break;\n                 }\n@@ -4624,7 +4629,7 @@ class Resolver {\n         debug!{\"Import resolutions:\"};\n         for module_.import_resolutions.each |name, import_resolution| {\n             let mut module_repr;\n-            alt (*import_resolution).target_for_namespace(ModuleNS) {\n+            match (*import_resolution).target_for_namespace(ModuleNS) {\n                 none => { module_repr = ~\"\"; }\n                 some(target) => {\n                     module_repr = ~\" module:?\";\n@@ -4633,7 +4638,7 @@ class Resolver {\n             }\n \n             let mut value_repr;\n-            alt (*import_resolution).target_for_namespace(ValueNS) {\n+            match (*import_resolution).target_for_namespace(ValueNS) {\n                 none => { value_repr = ~\"\"; }\n                 some(target) => {\n                     value_repr = ~\" value:?\";\n@@ -4642,7 +4647,7 @@ class Resolver {\n             }\n \n             let mut type_repr;\n-            alt (*import_resolution).target_for_namespace(TypeNS) {\n+            match (*import_resolution).target_for_namespace(TypeNS) {\n                 none => { type_repr = ~\"\"; }\n                 some(target) => {\n                     type_repr = ~\" type:?\";\n@@ -4651,7 +4656,7 @@ class Resolver {\n             }\n \n             let mut impl_repr;\n-            alt (*import_resolution).target_for_namespace(ImplNS) {\n+            match (*import_resolution).target_for_namespace(ImplNS) {\n                 none => { impl_repr = ~\"\"; }\n                 some(target) => {\n                     impl_repr = ~\" impl:?\";\n@@ -4671,7 +4676,7 @@ class Resolver {\n         let mut i = 0u;\n         let mut impl_scopes = impl_scopes;\n         loop {\n-            alt *impl_scopes {\n+            match *impl_scopes {\n                 cons(impl_scope, rest_impl_scopes) => {\n                     debug!{\"Impl scope %u:\", i};\n "}, {"sha": "783a856fd9d9a3cf02dcdfe890839b9f5b0b508f", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -25,7 +25,7 @@ enum opt {\n     range(@ast::expr, @ast::expr)\n }\n fn opt_eq(tcx: ty::ctxt, a: opt, b: opt) -> bool {\n-    alt (a, b) {\n+    match (a, b) {\n       (lit(a), lit(b)) => const_eval::compare_lit_exprs(tcx, a, b) == 0,\n       (range(a1, a2), range(b1, b2)) => {\n         const_eval::compare_lit_exprs(tcx, a1, b1) == 0 &&\n@@ -44,9 +44,9 @@ fn trans_opt(bcx: block, o: opt) -> opt_result {\n     let _icx = bcx.insn_ctxt(~\"alt::trans_opt\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n-    alt o {\n+    match o {\n       lit(l) => {\n-        alt l.node {\n+        match l.node {\n           ast::expr_vstore(@{node: ast::expr_lit(\n               @{node: ast::lit_str(s), _}), _},\n                            ast::vstore_uniq) => {\n@@ -112,7 +112,7 @@ type match_ = ~[match_branch];\n \n fn has_nested_bindings(m: match_, col: uint) -> bool {\n     for vec::each(m) |br| {\n-        alt br.pats[col].node {\n+        match br.pats[col].node {\n           ast::pat_ident(_, _, some(_)) => return true,\n           _ => ()\n         }\n@@ -125,7 +125,7 @@ fn expand_nested_bindings(bcx: block, m: match_, col: uint, val: ValueRef)\n \n     let mut result = ~[];\n     for vec::each(m) |br| {\n-      alt br.pats[col].node {\n+      match br.pats[col].node {\n           ast::pat_ident(mode, name, some(inner)) => {\n             let pats = vec::append(\n                 vec::slice(br.pats, 0u, col),\n@@ -155,13 +155,13 @@ fn enter_match(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef,\n                e: enter_pat) -> match_ {\n     let mut result = ~[];\n     for vec::each(m) |br| {\n-        alt e(br.pats[col]) {\n+        match e(br.pats[col]) {\n           some(sub) => {\n             let pats = vec::append(\n                 vec::append(sub, vec::view(br.pats, 0u, col)),\n                 vec::view(br.pats, col + 1u, br.pats.len()));\n             let self = br.pats[col];\n-            let bound = alt self.node {\n+            let bound = match self.node {\n               ast::pat_ident(mode, name, none)\n                   if !pat_is_variant(dm, self) => {\n                 vec::append(br.bound,\n@@ -186,7 +186,7 @@ fn enter_default(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef)\n               -> match_ {\n \n     do enter_match(bcx, dm, m, col, val) |p| {\n-        alt p.node {\n+        match p.node {\n           ast::pat_wild | ast::pat_rec(_, _) | ast::pat_tup(_) => some(~[]),\n           ast::pat_ident(_, _, none) if !pat_is_variant(dm, p) => some(~[]),\n           _ => none\n@@ -199,7 +199,7 @@ fn enter_opt(bcx: block, m: match_, opt: opt, col: uint,\n     let tcx = bcx.tcx();\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, tcx.def_map, m, col, val) |p| {\n-        alt p.node {\n+        match p.node {\n           ast::pat_enum(_, subpats) => {\n             if opt_eq(tcx, variant_opt(tcx, p.id), opt) {\n               some(option::get_default(subpats,\n@@ -225,7 +225,7 @@ fn enter_rec(bcx: block, dm: DefMap, m: match_, col: uint,\n              fields: ~[ast::ident], val: ValueRef) -> match_ {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n-        alt p.node {\n+        match p.node {\n           ast::pat_rec(fpats, _) => {\n             let mut pats = ~[];\n             for vec::each(fields) |fname| {\n@@ -246,7 +246,7 @@ fn enter_tup(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef,\n              n_elts: uint) -> match_ {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n-        alt p.node {\n+        match p.node {\n           ast::pat_tup(elts) => some(elts),\n           _ => some(vec::from_elem(n_elts, dummy))\n         }\n@@ -257,7 +257,7 @@ fn enter_box(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef)\n           -> match_ {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n-        alt p.node {\n+        match p.node {\n           ast::pat_box(sub) => some(~[sub]),\n           _ => some(~[dummy])\n         }\n@@ -268,7 +268,7 @@ fn enter_uniq(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef)\n            -> match_ {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n-        alt p.node {\n+        match p.node {\n           ast::pat_uniq(sub) => some(~[sub]),\n           _ => some(~[dummy])\n         }\n@@ -287,7 +287,7 @@ fn get_options(ccx: @crate_ctxt, m: match_, col: uint) -> ~[opt] {\n         if pat_is_variant(ccx.tcx.def_map, cur) {\n             add_to_set(ccx.tcx, found, variant_opt(ccx.tcx, br.pats[col].id));\n         } else {\n-            alt cur.node {\n+            match cur.node {\n               ast::pat_lit(l) => add_to_set(ccx.tcx, found, lit(l)),\n               ast::pat_range(l1, l2) => {\n                 add_to_set(ccx.tcx, found, range(l1, l2));\n@@ -304,7 +304,9 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n    {vals: ~[ValueRef], bcx: block} {\n     let _icx = bcx.insn_ctxt(~\"alt::extract_variant_args\");\n     let ccx = bcx.fcx.ccx;\n-    let enum_ty_substs = alt check ty::get(node_id_type(bcx, pat_id)).struct {\n+    let enum_ty_substs = match check ty::get(node_id_type(bcx, pat_id))\n+        .struct {\n+\n       ty::ty_enum(id, substs) => { assert id == vdefs.enm; substs.tps }\n     };\n     let mut blobptr = val;\n@@ -328,7 +330,7 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n fn collect_record_fields(m: match_, col: uint) -> ~[ast::ident] {\n     let mut fields: ~[ast::ident] = ~[];\n     for vec::each(m) |br| {\n-        alt br.pats[col].node {\n+        match br.pats[col].node {\n           ast::pat_rec(fs, _) => {\n             for vec::each(fs) |f| {\n                 if !vec::any(fields, |x| str::eq(f.ident, x)) {\n@@ -346,7 +348,7 @@ fn root_pats_as_necessary(bcx: block, m: match_, col: uint, val: ValueRef) {\n     for vec::each(m) |br| {\n         let pat_id = br.pats[col].id;\n \n-        alt bcx.ccx().maps.root_map.find({id:pat_id, derefs:0u}) {\n+        match bcx.ccx().maps.root_map.find({id:pat_id, derefs:0u}) {\n           none => (),\n           some(scope_id) => {\n             // Note: the scope_id will always be the id of the alt.  See the\n@@ -364,7 +366,7 @@ fn root_pats_as_necessary(bcx: block, m: match_, col: uint, val: ValueRef) {\n \n fn any_box_pat(m: match_, col: uint) -> bool {\n     for vec::each(m) |br| {\n-        alt br.pats[col].node {\n+        match br.pats[col].node {\n           ast::pat_box(_) => return true,\n           _ => ()\n         }\n@@ -374,7 +376,7 @@ fn any_box_pat(m: match_, col: uint) -> bool {\n \n fn any_uniq_pat(m: match_, col: uint) -> bool {\n     for vec::each(m) |br| {\n-        alt br.pats[col].node {\n+        match br.pats[col].node {\n           ast::pat_uniq(_) => return true,\n           _ => ()\n         }\n@@ -384,7 +386,7 @@ fn any_uniq_pat(m: match_, col: uint) -> bool {\n \n fn any_tup_pat(m: match_, col: uint) -> bool {\n     for vec::each(m) |br| {\n-        alt br.pats[col].node {\n+        match br.pats[col].node {\n           ast::pat_tup(_) => return true,\n           _ => ()\n         }\n@@ -397,7 +399,7 @@ type mk_fail = fn@() -> BasicBlockRef;\n \n fn pick_col(m: match_) -> uint {\n     fn score(p: @ast::pat) -> uint {\n-        alt p.node {\n+        match p.node {\n           ast::pat_lit(_) | ast::pat_enum(_, _) | ast::pat_range(_, _) => 1u,\n           ast::pat_ident(_, _, some(p)) => score(p),\n           _ => 0u\n@@ -435,7 +437,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n     if m.len() == 0u { Br(bcx, option::get(chk)()); return; }\n     if m[0].pats.len() == 0u {\n         let data = m[0].data;\n-        alt data.guard {\n+        match data.guard {\n           some(e) => {\n             // Temporarily set bindings. They'll be rewritten to PHI nodes\n             // for the actual arm block.\n@@ -512,7 +514,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n \n     if any_tup_pat(m, col) {\n         let tup_ty = node_id_type(bcx, pat_id);\n-        let n_tup_elts = alt ty::get(tup_ty).struct {\n+        let n_tup_elts = match ty::get(tup_ty).struct {\n           ty::ty_tup(elts) => elts.len(),\n           _ => ccx.sess.bug(~\"non-tuple type in tuple pattern\")\n         };\n@@ -553,7 +555,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n     let mut kind = no_branch;\n     let mut test_val = val;\n     if opts.len() > 0u {\n-        alt opts[0] {\n+        match opts[0] {\n           var(_, vdef) => {\n             if (*ty::enum_variants(tcx, vdef.enm)).len() == 1u {\n                 kind = single;\n@@ -578,12 +580,12 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n         }\n     }\n     for vec::each(opts) |o| {\n-        alt o {\n+        match o {\n           range(_, _) => { kind = compare; break }\n           _ => ()\n         }\n     }\n-    let else_cx = alt kind {\n+    let else_cx = match kind {\n       no_branch | single => bcx,\n       _ => sub_block(bcx, ~\"match_else\")\n     };\n@@ -601,10 +603,10 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n         let mut opt_cx = else_cx;\n         if !exhaustive || i < len {\n             opt_cx = sub_block(bcx, ~\"match_case\");\n-            alt kind {\n+            match kind {\n               single => Br(bcx, opt_cx.llbb),\n               switch => {\n-                alt check trans_opt(bcx, opt) {\n+                match check trans_opt(bcx, opt) {\n                   single_result(r) => {\n                     llvm::LLVMAddCase(sw, r.val, opt_cx.llbb);\n                     bcx = r.bcx;\n@@ -615,7 +617,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n                 let t = node_id_type(bcx, pat_id);\n                 let {bcx: after_cx, val: matches} = {\n                     do with_scope_result(bcx, none, ~\"compare_scope\") |bcx| {\n-                        alt trans_opt(bcx, opt) {\n+                        match trans_opt(bcx, opt) {\n                           single_result({bcx, val}) => {\n                             trans_compare(bcx, ast::eq, test_val, t, val, t)\n                           }\n@@ -638,7 +640,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n         } else if kind == compare { Br(bcx, else_cx.llbb); }\n         let mut size = 0u;\n         let mut unpacked = ~[];\n-        alt opt {\n+        match opt {\n           var(_, vdef) => {\n             let args = extract_variant_args(opt_cx, pat_id, vdef, val);\n             size = args.vals.len();\n@@ -671,7 +673,7 @@ fn make_phi_bindings(bcx: block, map: ~[exit_node],\n         let mut vals = ~[];\n         for vec::each(map) |ex| {\n             if ex.to as uint == our_block {\n-                alt assoc(name, ex.bound) {\n+                match assoc(name, ex.bound) {\n                   some(binding) => {\n                     vec::push(llbbs, ex.from);\n                     vec::push(vals, binding.val);\n@@ -774,14 +776,14 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: ~[ast::arm],\n \n     fn mk_fail(bcx: block, sp: span, msg: ~str,\n                    done: @mut option<BasicBlockRef>) -> BasicBlockRef {\n-            alt *done { some(bb) => return bb, _ => () }\n+            match *done { some(bb) => return bb, _ => () }\n             let fail_cx = sub_block(bcx, ~\"case_fallthrough\");\n             trans_fail(fail_cx, some(sp), msg);\n             *done = some(fail_cx.llbb);\n             return fail_cx.llbb;\n     }\n     let t = node_id_type(bcx, expr.id);\n-    let mk_fail = alt mode {\n+    let mk_fail = match mode {\n       ast::alt_check => {\n         let fail_cx = @mut none;\n         // Cached fail-on-fallthrough block\n@@ -829,7 +831,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n     let mut bcx = bcx;\n \n     // Necessary since bind_irrefutable_pat is called outside trans_alt\n-    alt pat.node {\n+    match pat.node {\n       ast::pat_ident(_, _,inner) => {\n         if pat_is_variant(bcx.tcx().def_map, pat) { return bcx; }\n         if make_copy {\n@@ -841,7 +843,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n             bcx.fcx.lllocals.insert(pat.id, local_mem(alloc));\n             add_clean(bcx, alloc, ty);\n         } else { bcx.fcx.lllocals.insert(pat.id, local_mem(val)); }\n-        alt inner {\n+        match inner {\n           some(pat) => { bcx = bind_irrefutable_pat(bcx, pat, val, true); }\n           _ => ()\n         }"}, {"sha": "6e882d71c00587e8374fa70ea55cd7da286beb6f", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 166, "deletions": 166, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -66,7 +66,7 @@ enum dest {\n }\n \n fn dest_str(ccx: @crate_ctxt, d: dest) -> ~str {\n-    alt d {\n+    match d {\n       by_val(v) => fmt!{\"by_val(%s)\", val_str(ccx.tn, *v)},\n       save_in(v) => fmt!{\"save_in(%s)\", val_str(ccx.tn, v)},\n       ignore => ~\"ignore\"\n@@ -78,7 +78,7 @@ fn empty_dest_cell() -> @mut ValueRef {\n }\n \n fn dup_for_join(dest: dest) -> dest {\n-    alt dest {\n+    match dest {\n       by_val(_) => by_val(empty_dest_cell()),\n       _ => dest\n     }\n@@ -128,7 +128,7 @@ fn join_returns(parent_cx: block, in_cxs: ~[block],\n         if !cx.unreachable {\n             Br(cx, out.llbb);\n             reachable = true;\n-            alt in_ds[i] {\n+            match in_ds[i] {\n               by_val(cell) => {\n                 if option::is_none(phi) {\n                     phi = some(EmptyPhi(out, val_ty(*cell)));\n@@ -143,7 +143,7 @@ fn join_returns(parent_cx: block, in_cxs: ~[block],\n     if !reachable {\n         Unreachable(out);\n     } else {\n-        alt out_dest {\n+        match out_dest {\n           by_val(cell) => *cell = option::get(phi),\n           _ => ()\n         }\n@@ -153,7 +153,7 @@ fn join_returns(parent_cx: block, in_cxs: ~[block],\n \n // Used to put an immediate value in a dest.\n fn store_in_dest(bcx: block, val: ValueRef, dest: dest) -> block {\n-    alt dest {\n+    match dest {\n       ignore => (),\n       by_val(cell) => *cell = val,\n       save_in(addr) => Store(bcx, val, addr)\n@@ -162,7 +162,7 @@ fn store_in_dest(bcx: block, val: ValueRef, dest: dest) -> block {\n }\n \n fn get_dest_addr(dest: dest) -> ValueRef {\n-    alt dest {\n+    match dest {\n        save_in(a) => a,\n        _ => fail ~\"get_dest_addr: not a save_in\"\n     }\n@@ -359,7 +359,7 @@ fn malloc_raw_dyn(bcx: block, t: ty::t, heap: heap,\n     let _icx = bcx.insn_ctxt(~\"malloc_raw\");\n     let ccx = bcx.ccx();\n \n-    let (mk_fn, rtcall) = alt heap {\n+    let (mk_fn, rtcall) = match heap {\n       heap_shared => (ty::mk_imm_box, ~\"malloc\"),\n       heap_exchange => (ty::mk_imm_uniq, ~\"exchange_malloc\")\n     };\n@@ -419,7 +419,7 @@ fn get_tydesc_simple(ccx: @crate_ctxt, t: ty::t) -> ValueRef {\n }\n \n fn get_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n-    alt ccx.tydescs.find(t) {\n+    match ccx.tydescs.find(t) {\n       some(inf) => inf,\n       _ => {\n         ccx.stats.n_static_tydescs += 1u;\n@@ -454,7 +454,7 @@ fn set_inline_hint(f: ValueRef) {\n \n fn set_inline_hint_if_appr(attrs: ~[ast::attribute],\n                            llfn: ValueRef) {\n-    alt attr::find_inline_attr(attrs) {\n+    match attr::find_inline_attr(attrs) {\n       attr::ia_hint => set_inline_hint(llfn),\n       attr::ia_always => set_always_inline(llfn),\n       attr::ia_never => set_no_inline(llfn),\n@@ -577,22 +577,22 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n         let glue_fn_ty = T_ptr(T_glue_fn(ccx));\n         let ti = val;\n         let take_glue =\n-            alt copy ti.take_glue {\n+            match copy ti.take_glue {\n               none => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               some(v) => { ccx.stats.n_real_glues += 1u; v }\n             };\n         let drop_glue =\n-            alt copy ti.drop_glue {\n+            match copy ti.drop_glue {\n               none => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               some(v) => { ccx.stats.n_real_glues += 1u; v }\n             };\n         let free_glue =\n-            alt copy ti.free_glue {\n+            match copy ti.free_glue {\n               none => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               some(v) => { ccx.stats.n_real_glues += 1u; v }\n             };\n         let visit_glue =\n-            alt copy ti.visit_glue {\n+            match copy ti.visit_glue {\n               none => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               some(v) => { ccx.stats.n_real_glues += 1u; v }\n             };\n@@ -623,7 +623,7 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(~\"make_take_glue\");\n     // NB: v is a *pointer* to type t here, not a direct value.\n-    let bcx = alt ty::get(t).struct {\n+    let bcx = match ty::get(t).struct {\n       ty::ty_box(_) | ty::ty_opaque_box |\n       ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) => {\n         incr_refcnt_of_boxed(bcx, Load(bcx, v)); bcx\n@@ -689,7 +689,7 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n     // everything to a pointer to the type that the glue acts on).\n     let _icx = bcx.insn_ctxt(~\"make_free_glue\");\n     let ccx = bcx.ccx();\n-    let bcx = alt ty::get(t).struct {\n+    let bcx = match ty::get(t).struct {\n       ty::ty_box(body_mt) => {\n         let v = PointerCast(bcx, v, type_of(ccx, t));\n         let body = GEPi(bcx, v, ~[0u, abi::box_field_body]);\n@@ -770,7 +770,7 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = bcx.insn_ctxt(~\"make_drop_glue\");\n     let ccx = bcx.ccx();\n-    let bcx = alt ty::get(t).struct {\n+    let bcx = match ty::get(t).struct {\n       ty::ty_box(_) | ty::ty_opaque_box |\n       ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) => {\n         decr_refcnt_maybe_free(bcx, Load(bcx, v0), t)\n@@ -784,7 +784,7 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n       }\n       ty::ty_class(did, substs) => {\n         let tcx = bcx.tcx();\n-        alt ty::ty_dtor(tcx, did) {\n+        match ty::ty_dtor(tcx, did) {\n           some(dtor) => {\n             trans_class_drop(bcx, v0, dtor, did, substs)\n           }\n@@ -880,7 +880,7 @@ fn compare_scalar_types(cx: block, lhs: ValueRef, rhs: ValueRef,\n                         t: ty::t, op: ast::binop) -> result {\n     let f = |a| compare_scalar_values(cx, lhs, rhs, a, op);\n \n-    alt ty::get(t).struct {\n+    match ty::get(t).struct {\n       ty::ty_nil => return rslt(cx, f(nil_type)),\n       ty::ty_bool | ty::ty_ptr(_) => return rslt(cx, f(unsigned_int)),\n       ty::ty_int(_) => return rslt(cx, f(signed_int)),\n@@ -909,19 +909,19 @@ fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n           comparison operator\");\n     }\n     let die = fn@() -> ! { die_(cx) };\n-    alt nt {\n+    match nt {\n       nil_type => {\n         // We don't need to do actual comparisons for nil.\n         // () == () holds but () < () does not.\n-        alt op {\n+        match op {\n           ast::eq | ast::le | ast::ge => return C_bool(true),\n           ast::ne | ast::lt | ast::gt => return C_bool(false),\n           // refinements would be nice\n           _ => die()\n         }\n       }\n       floating_point => {\n-        let cmp = alt op {\n+        let cmp = match op {\n           ast::eq => lib::llvm::RealOEQ,\n           ast::ne => lib::llvm::RealUNE,\n           ast::lt => lib::llvm::RealOLT,\n@@ -933,7 +933,7 @@ fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n         return FCmp(cx, cmp, lhs, rhs);\n       }\n       signed_int => {\n-        let cmp = alt op {\n+        let cmp = match op {\n           ast::eq => lib::llvm::IntEQ,\n           ast::ne => lib::llvm::IntNE,\n           ast::lt => lib::llvm::IntSLT,\n@@ -945,7 +945,7 @@ fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n         return ICmp(cx, cmp, lhs, rhs);\n       }\n       unsigned_int => {\n-        let cmp = alt op {\n+        let cmp = match op {\n           ast::eq => lib::llvm::IntEQ,\n           ast::ne => lib::llvm::IntNE,\n           ast::lt => lib::llvm::IntULT,\n@@ -985,7 +985,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         let fn_ty = variant.ctor_ty;\n         let ccx = cx.ccx();\n         let mut cx = cx;\n-        alt ty::get(fn_ty).struct {\n+        match ty::get(fn_ty).struct {\n           ty::ty_fn({inputs: args, _}) => {\n             let mut j = 0u;\n             let v_id = variant.id;\n@@ -1005,7 +1005,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n     Typestate constraint that shows the unimpl case doesn't happen?\n     */\n     let mut cx = cx;\n-    alt ty::get(t).struct {\n+    match ty::get(t).struct {\n       ty::ty_rec(fields) => {\n         for vec::eachi(fields) |i, fld| {\n             let llfld_a = GEPi(cx, av, ~[0u, i]);\n@@ -1090,7 +1090,7 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n                            ti: @tydesc_info) {\n     let _icx = ccx.insn_ctxt(~\"lazily_emit_tydesc_glue\");\n     if field == abi::tydesc_field_take_glue {\n-        alt ti.take_glue {\n+        match ti.take_glue {\n           some(_) => (),\n           none => {\n             debug!{\"+++ lazily_emit_tydesc_glue TAKE %s\",\n@@ -1105,7 +1105,7 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n           }\n         }\n     } else if field == abi::tydesc_field_drop_glue {\n-        alt ti.drop_glue {\n+        match ti.drop_glue {\n           some(_) => (),\n           none => {\n             debug!{\"+++ lazily_emit_tydesc_glue DROP %s\",\n@@ -1120,7 +1120,7 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n           }\n         }\n     } else if field == abi::tydesc_field_free_glue {\n-        alt ti.free_glue {\n+        match ti.free_glue {\n           some(_) => (),\n           none => {\n             debug!{\"+++ lazily_emit_tydesc_glue FREE %s\",\n@@ -1135,7 +1135,7 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n           }\n         }\n     } else if field == abi::tydesc_field_visit_glue {\n-        alt ti.visit_glue {\n+        match ti.visit_glue {\n           some(_) => (),\n           none => {\n             debug!{\"+++ lazily_emit_tydesc_glue VISIT %s\",\n@@ -1159,7 +1159,7 @@ fn call_tydesc_glue_full(++cx: block, v: ValueRef, tydesc: ValueRef,\n         if cx.unreachable { return; }\n \n     let mut static_glue_fn = none;\n-    alt static_ti {\n+    match static_ti {\n       none => {/* no-op */ }\n       some(sti) => {\n         lazily_emit_tydesc_glue(cx.ccx(), field, sti);\n@@ -1178,7 +1178,7 @@ fn call_tydesc_glue_full(++cx: block, v: ValueRef, tydesc: ValueRef,\n     let llrawptr = PointerCast(cx, v, T_ptr(T_i8()));\n \n     let llfn = {\n-        alt static_glue_fn {\n+        match static_glue_fn {\n           none => {\n             // Select out the glue function to call from the tydesc\n             let llfnptr = GEPi(cx, tydesc, ~[0u, field]);\n@@ -1240,7 +1240,7 @@ fn drop_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n \n fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n     let _icx = bcx.insn_ctxt(~\"drop_ty_immediate\");\n-    alt ty::get(t).struct {\n+    match ty::get(t).struct {\n       ty::ty_uniq(_) |\n       ty::ty_evec(_, ty::vstore_uniq) |\n       ty::ty_estr(ty::vstore_uniq) => {\n@@ -1257,7 +1257,7 @@ fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n \n fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> result {\n     let _icx = bcx.insn_ctxt(~\"take_ty_immediate\");\n-    alt ty::get(t).struct {\n+    match ty::get(t).struct {\n       ty::ty_box(_) | ty::ty_opaque_box |\n       ty::ty_evec(_, ty::vstore_box) |\n       ty::ty_estr(ty::vstore_box) => {\n@@ -1291,7 +1291,7 @@ fn call_memmove(cx: block, dst: ValueRef, src: ValueRef,\n     // constant element of a tydesc works).\n     let _icx = cx.insn_ctxt(~\"call_memmove\");\n     let ccx = cx.ccx();\n-    let key = alt ccx.sess.targ_cfg.arch {\n+    let key = match ccx.sess.targ_cfg.arch {\n       session::arch_x86 | session::arch_arm => ~\"llvm.memmove.p0i8.p0i8.i32\",\n       session::arch_x86_64 => ~\"llvm.memmove.p0i8.p0i8.i64\"\n     };\n@@ -1320,7 +1320,7 @@ enum copy_action { INIT, DROP_EXISTING, }\n // These are the types that are passed by pointer.\n fn type_is_structural_or_param(t: ty::t) -> bool {\n     if ty::type_is_structural(t) { return true; }\n-    alt ty::get(t).struct {\n+    match ty::get(t).struct {\n       ty::ty_param(*) => return true,\n       _ => return false\n     }\n@@ -1446,7 +1446,7 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n                un_expr: @ast::expr, dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(~\"trans_unary\");\n     // Check for user-defined method call\n-    alt bcx.ccx().maps.method_map.find(un_expr.id) {\n+    match bcx.ccx().maps.method_map.find(un_expr.id) {\n       some(mentry) => {\n         let fty = node_id_type(bcx, un_expr.callee_id);\n         return trans_call_inner(\n@@ -1461,7 +1461,7 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n \n     if dest == ignore { return trans_expr(bcx, e, ignore); }\n     let e_ty = expr_ty(bcx, e);\n-    alt op {\n+    match op {\n       ast::not => {\n         let {bcx, val} = trans_temp_expr(bcx, e);\n         store_in_dest(bcx, Not(bcx, val), dest)\n@@ -1508,7 +1508,7 @@ fn trans_compare(cx: block, op: ast::binop, lhs: ValueRef,\n \n     // Determine the operation we need.\n     let llop = {\n-        alt op {\n+        match op {\n           ast::eq | ast::ne => C_u8(abi::cmp_glue_op_eq),\n           ast::lt | ast::ge => C_u8(abi::cmp_glue_op_lt),\n           ast::le | ast::gt => C_u8(abi::cmp_glue_op_le),\n@@ -1519,7 +1519,7 @@ fn trans_compare(cx: block, op: ast::binop, lhs: ValueRef,\n     let cmpval = call_cmp_glue(cx, lhs, rhs, rhs_t, llop);\n \n     // Invert the result if necessary.\n-    alt op {\n+    match op {\n       ast::eq | ast::lt | ast::le => rslt(cx, cmpval),\n       ast::ne | ast::ge | ast::gt => rslt(cx, Not(cx, cmpval)),\n       _ => cx.tcx().sess.bug(~\"trans_compare got non-comparison-op\")\n@@ -1571,7 +1571,7 @@ fn fail_if_zero(cx: block, span: span, divmod: ast::binop,\n     } else {\n         ~\"modulo zero\"\n     };\n-    let is_zero = alt ty::get(rhs_t).struct {\n+    let is_zero = match ty::get(rhs_t).struct {\n       ty::ty_int(t) => {\n         let zero = C_integral(T_int_ty(cx.ccx(), t), 0u64, False);\n         ICmp(cx, lib::llvm::IntEQ, rhs, zero)\n@@ -1607,7 +1607,7 @@ fn trans_eager_binop(cx: block, span: span, op: ast::binop, lhs: ValueRef,\n     let rhs = cast_shift_expr_rhs(cx, op, lhs, rhs);\n \n     let mut cx = cx;\n-    let val = alt op {\n+    let val = match op {\n       ast::add => {\n         if is_float { FAdd(cx, lhs, rhs) }\n         else { Add(cx, lhs, rhs) }\n@@ -1673,7 +1673,7 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n     assert (lhs_res.kind == lv_owned);\n \n     // A user-defined operator method\n-    alt bcx.ccx().maps.method_map.find(ex.id) {\n+    match bcx.ccx().maps.method_map.find(ex.id) {\n       some(origin) => {\n         let bcx = lhs_res.bcx;\n         debug!{\"user-defined method callee_id: %s\",\n@@ -1738,14 +1738,14 @@ fn autoderef(cx: block, e_id: ast::node_id,\n \n         // root the autoderef'd value, if necessary:\n         derefs += 1u;\n-        alt ccx.maps.root_map.find({id:e_id, derefs:derefs}) {\n+        match ccx.maps.root_map.find({id:e_id, derefs:derefs}) {\n           none => (),\n           some(scope_id) => {\n             root_value(cx, v1, t1, scope_id);\n           }\n         }\n \n-        alt ty::get(t1).struct {\n+        match ty::get(t1).struct {\n           ty::ty_box(mt) => {\n             let body = GEPi(cx, v1, ~[0u, abi::box_field_body]);\n             t1 = mt.ty;\n@@ -1800,7 +1800,7 @@ fn trans_lazy_binop(bcx: block, op: lazy_binop_ty, a: @ast::expr,\n     if past_lhs.unreachable { return past_lhs; }\n     let join = sub_block(bcx, ~\"join\"), before_rhs = sub_block(bcx, ~\"rhs\");\n \n-    alt op {\n+    match op {\n       lazy_and => CondBr(past_lhs, lhs, before_rhs.llbb, join.llbb),\n       lazy_or => CondBr(past_lhs, lhs, join.llbb, before_rhs.llbb)\n     }\n@@ -1821,7 +1821,7 @@ fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n                 rhs: @ast::expr, dest: dest, ex: @ast::expr) -> block {\n     let _icx = bcx.insn_ctxt(~\"trans_binary\");\n     // User-defined operators\n-    alt bcx.ccx().maps.method_map.find(ex.id) {\n+    match bcx.ccx().maps.method_map.find(ex.id) {\n       some(origin) => {\n         let fty = node_id_type(bcx, ex.callee_id);\n         return trans_call_inner(\n@@ -1836,7 +1836,7 @@ fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n     }\n \n     // First couple cases are lazy:\n-    alt op {\n+    match op {\n       ast::and => {\n         return trans_lazy_binop(bcx, lazy_and, lhs, rhs, dest);\n       }\n@@ -1872,9 +1872,9 @@ fn trans_if(cx: block, cond: @ast::expr, thn: ast::blk,\n     // because trans_expr will create another scope block\n     // context for the block, but we've already got the\n     // 'else' context\n-    let else_bcx = alt els {\n+    let else_bcx = match els {\n       some(elexpr) => {\n-        alt elexpr.node {\n+        match elexpr.node {\n           ast::expr_if(_, _, _) => {\n             let elseif_blk = ast_util::block_from_expr(elexpr);\n             trans_block(else_cx, elseif_blk, else_dest)\n@@ -1960,7 +1960,7 @@ fn lval_no_env(bcx: block, val: ValueRef, kind: lval_kind)\n fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     -> ValueRef {\n     let name = csearch::get_symbol(ccx.sess.cstore, did);\n-    alt ty::get(t).struct {\n+    match ty::get(t).struct {\n       ty::ty_fn(_) => {\n         let llty = type_of_fn_from_ty(ccx, t);\n         return get_extern_fn(ccx.externs, ccx.llmod, name,\n@@ -1975,7 +1975,7 @@ fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n \n fn normalize_for_monomorphization(tcx: ty::ctxt, ty: ty::t) -> option<ty::t> {\n     // FIXME[mono] could do this recursively. is that worthwhile? (#2529)\n-    alt ty::get(ty).struct {\n+    match ty::get(ty).struct {\n       ty::ty_box(mt) => {\n         some(ty::mk_opaque_box(tcx))\n       }\n@@ -2001,14 +2001,14 @@ fn normalize_for_monomorphization(tcx: ty::ctxt, ty: ty::t) -> option<ty::t> {\n fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n                 vtables: option<typeck::vtable_res>,\n                 param_uses: option<~[type_use::type_uses]>) -> mono_id {\n-    let precise_param_ids = alt vtables {\n+    let precise_param_ids = match vtables {\n       some(vts) => {\n         let bounds = ty::lookup_item_type(ccx.tcx, item).bounds;\n         let mut i = 0u;\n         vec::map2(*bounds, substs, |bounds, subst| {\n             let mut v = ~[];\n             for vec::each(*bounds) |bound| {\n-                alt bound {\n+                match bound {\n                   ty::bound_trait(_) => {\n                     vec::push(v, impl::vtable_id(ccx, vts[i]));\n                     i += 1u;\n@@ -2023,10 +2023,10 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n         vec::map(substs, |subst| mono_precise(subst, none))\n       }\n     };\n-    let param_ids = alt param_uses {\n+    let param_ids = match param_uses {\n       some(uses) => {\n         vec::map2(precise_param_ids, uses, |id, uses| {\n-            alt check id {\n+            match check id {\n               mono_precise(_, some(_)) => id,\n               mono_precise(subst, none) => {\n                 if uses == 0u { mono_any }\n@@ -2058,7 +2058,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n     let _icx = ccx.insn_ctxt(~\"monomorphic_fn\");\n     let mut must_cast = false;\n     let substs = vec::map(real_substs, |t| {\n-        alt normalize_for_monomorphization(ccx.tcx, t) {\n+        match normalize_for_monomorphization(ccx.tcx, t) {\n           some(t) => { must_cast = true; t }\n           none => t\n         }\n@@ -2069,7 +2069,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n     let param_uses = type_use::type_uses_for(ccx, fn_id, substs.len());\n     let hash_id = make_mono_id(ccx, fn_id, substs, vtables, some(param_uses));\n     if vec::any(hash_id.params,\n-                |p| alt p { mono_precise(_, _) => false, _ => true }) {\n+                |p| match p { mono_precise(_, _) => false, _ => true }) {\n         must_cast = true;\n     }\n \n@@ -2079,7 +2079,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n            real_substs.map(|s| ty_to_str(ccx.tcx, s)),\n            substs.map(|s| ty_to_str(ccx.tcx, s)), hash_id];\n \n-    alt ccx.monomorphized.find(hash_id) {\n+    match ccx.monomorphized.find(hash_id) {\n       some(val) => {\n         debug!{\"leaving monomorphic fn %s\",\n                ty::item_path_str(ccx.tcx, fn_id)};\n@@ -2096,7 +2096,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n         (may have attempted to monomorphize an item defined in a different \\\n         crate?)\", fn_id});\n     // Get the path so that we can create a symbol\n-    let (pt, name, span) = alt map_node {\n+    let (pt, name, span) = match map_node {\n       ast_map::node_item(i, pt) => (pt, i.ident, i.span),\n       ast_map::node_variant(v, enm, pt) => (pt, v.node.name, enm.span),\n       ast_map::node_method(m, _, pt) => (pt, m.ident, m.span),\n@@ -2149,7 +2149,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n     };\n \n     let psubsts = some({tys: substs, vtables: vtables, bounds: tpt.bounds});\n-    let lldecl = alt map_node {\n+    let lldecl = match map_node {\n       ast_map::node_item(i@@{node: ast::item_fn(decl, _, body), _}, _) => {\n         let d = mk_lldecl();\n         set_inline_hint_if_appr(i.attrs, d);\n@@ -2195,7 +2195,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n         d\n       }\n       ast_map::node_dtor(_, dtor, _, pt) => {\n-        let parent_id = alt ty::ty_to_def_id(ty::node_id_to_type(ccx.tcx,\n+        let parent_id = match ty::ty_to_def_id(ty::node_id_to_type(ccx.tcx,\n                                               dtor.node.self_id)) {\n                 some(did) => did,\n                 none      => ccx.sess.span_bug(dtor.span, ~\"Bad self ty in \\\n@@ -2231,7 +2231,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n     -> ast::def_id {\n     let _icx = ccx.insn_ctxt(~\"maybe_instantiate_inline\");\n-    alt ccx.external.find(fn_id) {\n+    match ccx.external.find(fn_id) {\n       some(some(node_id)) => {\n         // Already inline\n         debug!{\"maybe_instantiate_inline(%s): already inline as node id %d\",\n@@ -2240,7 +2240,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n       }\n       some(none) => fn_id, // Not inlinable\n       none => { // Not seen yet\n-        alt csearch::maybe_get_item_ast(\n+        match csearch::maybe_get_item_ast(\n             ccx.tcx, fn_id,\n             |a,b,c,d| {\n                 astencode::decode_inlined_item(a, b, ccx.maps, c, d)\n@@ -2266,7 +2266,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n           csearch::found_parent(parent_id, ast::ii_item(item)) => {\n             ccx.external.insert(parent_id, some(item.id));\n             let mut my_id = 0;\n-            alt check item.node {\n+            match check item.node {\n               ast::item_enum(_, _) => {\n                 let vs_here = ty::enum_variants(ccx.tcx, local_def(item.id));\n                 let vs_there = ty::enum_variants(ccx.tcx, parent_id);\n@@ -2350,9 +2350,9 @@ fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n             ccx, node_id_type(bcx, id))));\n     }\n \n-    alt ty::get(tpt.ty).struct {\n+    match ty::get(tpt.ty).struct {\n       ty::ty_fn(fn_ty) => {\n-        alt fn_ty.purity {\n+        match fn_ty.purity {\n           ast::extern_fn => {\n             // Extern functions are just opaque pointers\n             let val = PointerCast(bcx, val, T_ptr(T_i8()));\n@@ -2369,7 +2369,7 @@ fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n \n fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n     let _icx = ccx.insn_ctxt(~\"lookup_discriminant\");\n-    alt ccx.discrims.find(vid) {\n+    match ccx.discrims.find(vid) {\n       none => {\n         // It's an external discriminant that we haven't seen yet.\n         assert (vid.crate != ast::local_crate);\n@@ -2394,13 +2394,13 @@ fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n     let _icx = cx.insn_ctxt(~\"trans_local_var\");\n     fn take_local(table: hashmap<ast::node_id, local_val>,\n                   id: ast::node_id) -> local_var_result {\n-        alt table.find(id) {\n+        match table.find(id) {\n           some(local_mem(v)) => {val: v, kind: lv_owned},\n           some(local_imm(v)) => {val: v, kind: lv_owned_imm},\n           r => fail(~\"take_local: internal error\")\n         }\n     }\n-    alt def {\n+    match def {\n       ast::def_upvar(nid, _, _) => {\n         assert (cx.fcx.llupvars.contains_key(nid));\n         return { val: cx.fcx.llupvars.get(nid), kind: lv_owned };\n@@ -2414,7 +2414,7 @@ fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n         return take_local(cx.fcx.lllocals, nid);\n       }\n       ast::def_self(sid) => {\n-        let slf = alt copy cx.fcx.llself {\n+        let slf = match copy cx.fcx.llself {\n           some(s) => cast_self(cx, s),\n           none => cx.sess().bug(~\"trans_local_var: reference to self \\\n                                  out of context\")\n@@ -2431,7 +2431,7 @@ fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n fn trans_path(cx: block, id: ast::node_id)\n     -> lval_maybe_callee {\n     let _icx = cx.insn_ctxt(~\"trans_path\");\n-    alt cx.tcx().def_map.find(id) {\n+    match cx.tcx().def_map.find(id) {\n       none => cx.sess().bug(~\"trans_path: unbound node ID\"),\n       some(df) => {\n           return trans_var(cx, df, id);\n@@ -2442,7 +2442,7 @@ fn trans_path(cx: block, id: ast::node_id)\n fn trans_var(cx: block, def: ast::def, id: ast::node_id)-> lval_maybe_callee {\n     let _icx = cx.insn_ctxt(~\"trans_var\");\n     let ccx = cx.ccx();\n-    alt def {\n+    match def {\n       ast::def_fn(did, _) => {\n         return lval_static_fn(cx, did, id);\n       }\n@@ -2491,7 +2491,7 @@ fn trans_rec_field(bcx: block, base: @ast::expr,\n fn trans_rec_field_inner(bcx: block, val: ValueRef, ty: ty::t,\n                          field: ast::ident, sp: span) -> lval_result {\n     let mut llderef = false;\n-    let fields = alt ty::get(ty).struct {\n+    let fields = match ty::get(ty).struct {\n        ty::ty_rec(fs) => fs,\n        ty::ty_class(did, substs) => {\n          if option::is_some(ty::ty_dtor(bcx.tcx(), did)) {\n@@ -2583,12 +2583,12 @@ fn expr_is_lval(bcx: block, e: @ast::expr) -> bool {\n \n fn trans_callee(bcx: block, e: @ast::expr) -> lval_maybe_callee {\n     let _icx = bcx.insn_ctxt(~\"trans_callee\");\n-    alt e.node {\n+    match e.node {\n       ast::expr_path(path) => return trans_path(bcx, e.id),\n       ast::expr_field(base, _, _) => {\n         // Lval means this is a record field, so not a method\n         if !expr_is_lval(bcx, e) {\n-            alt bcx.ccx().maps.method_map.find(e.id) {\n+            match bcx.ccx().maps.method_map.find(e.id) {\n               some(origin) => { // An impl method\n                 return impl::trans_method_callee(bcx, e.id, base, origin);\n               }\n@@ -2609,7 +2609,7 @@ fn trans_callee(bcx: block, e: @ast::expr) -> lval_maybe_callee {\n // represented as an alloca or heap, hence needs a 'load' to be used as an\n // immediate).\n fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n-    return alt cx.ccx().maps.root_map.find({id:e.id, derefs:0u}) {\n+    return match cx.ccx().maps.root_map.find({id:e.id, derefs:0u}) {\n       // No need to root this lvalue.\n       none => unrooted(cx, e),\n \n@@ -2634,7 +2634,7 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n \n     fn unrooted(cx: block, e: @ast::expr) -> lval_result {\n         let _icx = cx.insn_ctxt(~\"trans_lval\");\n-        alt e.node {\n+        match e.node {\n           ast::expr_path(_) => {\n             let v = trans_path(cx, e.id);\n             return lval_maybe_callee_to_lval(v, e.span);\n@@ -2649,7 +2649,7 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n             let ccx = cx.ccx();\n             let sub = trans_temp_expr(cx, base);\n             let t = expr_ty(cx, base);\n-            let val = alt check ty::get(t).struct {\n+            let val = match check ty::get(t).struct {\n               ty::ty_box(_) => {\n                 let non_gc_val = non_gc_box_cast(sub.bcx, sub.val);\n                 GEPi(sub.bcx, non_gc_val, ~[0u, abi::box_field_body])\n@@ -2689,7 +2689,7 @@ fn non_gc_box_cast(cx: block, val: ValueRef) -> ValueRef {\n }\n \n fn lval_maybe_callee_to_lval(c: lval_maybe_callee, sp: span) -> lval_result {\n-    alt c.env {\n+    match c.env {\n       self_env(*) => {\n         c.bcx.sess().span_bug(sp, ~\"implicitly binding method call\");\n       }\n@@ -2732,7 +2732,7 @@ fn float_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n enum cast_kind { cast_pointer, cast_integral, cast_float,\n                 cast_enum, cast_other, }\n fn cast_type_kind(t: ty::t) -> cast_kind {\n-    alt ty::get(t).struct {\n+    match ty::get(t).struct {\n       ty::ty_float(*)   => cast_float,\n       ty::ty_ptr(*)     => cast_pointer,\n       ty::ty_rptr(*)    => cast_pointer,\n@@ -2750,7 +2750,7 @@ fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n     let _icx = cx.insn_ctxt(~\"trans_cast\");\n     let ccx = cx.ccx();\n     let t_out = node_id_type(cx, id);\n-    alt ty::get(t_out).struct {\n+    match ty::get(t_out).struct {\n       ty::ty_trait(_, _) => return impl::trans_cast(cx, e, id, dest),\n       _ => ()\n     }\n@@ -2764,7 +2764,7 @@ fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n     let s_in = k_in == cast_integral && ty::type_is_signed(t_in);\n \n     let newval =\n-        alt {in: k_in, out: k_out} {\n+        match {in: k_in, out: k_out} {\n           {in: cast_integral, out: cast_integral} => {\n             int_cast(e_res.bcx, ll_t_out, ll_t_in, e_res.val, s_in)\n           }\n@@ -2797,7 +2797,7 @@ fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n             let av_enum = PointerCast(cx, e_res.val, llenumty);\n             let lldiscrim_a_ptr = GEPi(cx, av_enum, ~[0u, 0u]);\n             let lldiscrim_a = Load(cx, lldiscrim_a_ptr);\n-            alt k_out {\n+            match k_out {\n               cast_integral => int_cast(e_res.bcx, ll_t_out,\n                                         val_ty(lldiscrim_a),\n                                         lldiscrim_a, true),\n@@ -2812,12 +2812,12 @@ fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n \n fn trans_loop_body(bcx: block, e: @ast::expr, ret_flag: option<ValueRef>,\n                    dest: dest) -> block {\n-    alt check e.node {\n+    match check e.node {\n       ast::expr_loop_body(b@@{\n         node: ast::expr_fn_block(decl, body, cap),\n         _\n       }) => {\n-        alt check ty::get(expr_ty(bcx, e)).struct {\n+        match check ty::get(expr_ty(bcx, e)).struct {\n           ty::ty_fn({proto, _}) => {\n             closure::trans_expr_fn(bcx, proto, decl, body, b.id,\n                                    cap, some(ret_flag),\n@@ -2841,9 +2841,9 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n     let is_bot = ty::type_is_bot(e_ty);\n \n     // translate the arg expr as an lvalue\n-    let lv = alt ret_flag {\n+    let lv = match ret_flag {\n       // If there is a ret_flag, this *must* be a loop body\n-      some(ptr) => alt check e.node {\n+      some(ptr) => match check e.node {\n         ast::expr_loop_body(blk) => {\n             let scratch = alloc_ty(cx, expr_ty(cx, blk));\n             let bcx = trans_loop_body(cx, e, ret_flag, save_in(scratch));\n@@ -2884,7 +2884,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n         // to have type lldestty (the callee's expected type).\n         val = llvm::LLVMGetUndef(lldestty);\n     } else {\n-        alt arg_mode {\n+        match arg_mode {\n           ast::by_ref | ast::by_mutbl_ref => {\n             // Ensure that the value is spilled into memory:\n             if lv.kind != lv_owned && ty::type_is_immediate(e_ty) {\n@@ -2949,7 +2949,7 @@ fn adapt_borrowed_value(lv: lval_result,\n         return {lv:lv, ty:e_ty};\n     }\n \n-    alt ty::get(e_ty).struct {\n+    match ty::get(e_ty).struct {\n       ty::ty_uniq(mt) | ty::ty_box(mt) => {\n         let box_ptr = load_value_from_lval_result(lv, e_ty);\n         let body_ptr = GEPi(bcx, box_ptr, ~[0u, abi::box_field_body]);\n@@ -2959,7 +2959,7 @@ fn adapt_borrowed_value(lv: lval_result,\n \n       ty::ty_estr(_) | ty::ty_evec(_, _) => {\n         let ccx = bcx.ccx();\n-        let val = alt lv.kind {\n+        let val = match lv.kind {\n           lv_temporary => lv.val,\n           lv_owned => load_if_immediate(bcx, lv.val, e_ty),\n           lv_owned_imm => lv.val\n@@ -3019,7 +3019,7 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n \n     let retty = ty::ty_fn_ret(fn_ty);\n     // Arg 0: Output pointer.\n-    let llretslot = alt dest {\n+    let llretslot = match dest {\n       ignore => {\n         if ty::type_is_nil(retty) {\n             llvm::LLVMGetUndef(T_ptr(T_nil()))\n@@ -3039,7 +3039,7 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n     // First we figure out the caller's view of the types of the arguments.\n     // This will be needed if this is a generic call, because the callee has\n     // to cast her view of the arguments to the caller's view.\n-    alt args {\n+    match args {\n       arg_exprs(es) => {\n         let llarg_tys = type_of_explicit_args(ccx, arg_tys);\n         let last = es.len() - 1u;\n@@ -3083,7 +3083,7 @@ fn body_contains_ret(body: ast::blk) -> bool {\n         visit_item: |_i, _cx, _v| { },\n         visit_expr: |e: @ast::expr, cx: {mut found: bool}, v| {\n             if !cx.found {\n-                alt e.node {\n+                match e.node {\n                   ast::expr_ret(_) => cx.found = true,\n                   _ => visit::visit_expr(e, cx, v),\n                 }\n@@ -3104,9 +3104,9 @@ fn trans_call_inner(\n     dest: dest) -> block {\n \n     do with_scope(in_cx, call_info, ~\"call\") |cx| {\n-        let ret_in_loop = alt args {\n+        let ret_in_loop = match args {\n           arg_exprs(args) => {\n-            args.len() > 0u && alt vec::last(args).node {\n+            args.len() > 0u && match vec::last(args).node {\n               ast::expr_loop_body(@{\n                 node: ast::expr_fn_block(_, body, _),\n                 _\n@@ -3127,7 +3127,7 @@ fn trans_call_inner(\n         } else { none };\n \n         let mut faddr = f_res.val;\n-        let llenv = alt f_res.env {\n+        let llenv = match f_res.env {\n           null_env => {\n             llvm::LLVMGetUndef(T_opaque_box_ptr(ccx))\n           }\n@@ -3160,7 +3160,7 @@ fn trans_call_inner(\n         type _|_. Since that means it diverges, the code\n         for the call itself is unreachable. */\n         bcx = invoke(bcx, faddr, llargs);\n-        alt dest {\n+        match dest {\n           ignore => {\n             if llvm::LLVMIsUndef(llretslot) != lib::llvm::True {\n                 bcx = drop_ty(bcx, llretslot, ret_ty);\n@@ -3220,10 +3220,10 @@ fn need_invoke(bcx: block) -> bool {\n     // Walk the scopes to look for cleanups\n     let mut cur = bcx;\n     loop {\n-        alt cur.kind {\n+        match cur.kind {\n           block_scope(inf) => {\n             for vec::each(inf.cleanups) |cleanup| {\n-                alt cleanup {\n+                match cleanup {\n                   clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) => {\n                     if cleanup_type == normal_exit_and_unwind {\n                         return true;\n@@ -3234,7 +3234,7 @@ fn need_invoke(bcx: block) -> bool {\n           }\n           _ => ()\n         }\n-        cur = alt cur.parent {\n+        cur = match cur.parent {\n           some(next) => next,\n           none => return false\n         }\n@@ -3244,7 +3244,7 @@ fn need_invoke(bcx: block) -> bool {\n fn have_cached_lpad(bcx: block) -> bool {\n     let mut res = false;\n     do in_lpad_scope_cx(bcx) |inf| {\n-        alt inf.landing_pad {\n+        match inf.landing_pad {\n           some(_) => res = true,\n           none => res = false\n         }\n@@ -3255,7 +3255,7 @@ fn have_cached_lpad(bcx: block) -> bool {\n fn in_lpad_scope_cx(bcx: block, f: fn(scope_info)) {\n     let mut bcx = bcx;\n     loop {\n-        alt bcx.kind {\n+        match bcx.kind {\n           block_scope(inf) => {\n             if inf.cleanups.len() > 0u || is_none(bcx.parent) {\n                 f(inf); return;\n@@ -3273,7 +3273,7 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     let mut cached = none, pad_bcx = bcx; // Guaranteed to be set below\n     do in_lpad_scope_cx(bcx) |inf| {\n         // If there is a valid landing pad still around, use it\n-        alt copy inf.landing_pad {\n+        match copy inf.landing_pad {\n           some(target) => cached = some(target),\n           none => {\n             pad_bcx = lpad_block(bcx, ~\"unwind\");\n@@ -3282,7 +3282,7 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n         }\n     }\n     // Can't return from block above\n-    alt cached { some(b) => return b, none => () }\n+    match cached { some(b) => return b, none => () }\n     // The landing pad return type (the type being propagated). Not sure what\n     // this represents but it's determined by the personality function and\n     // this is what the EH proposal example uses.\n@@ -3303,7 +3303,7 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n \n     // We store the retval in a function-central alloca, so that calls to\n     // Resume can find it.\n-    alt copy bcx.fcx.personality {\n+    match copy bcx.fcx.personality {\n       some(addr) => Store(pad_bcx, llretval, addr),\n       none => {\n         let addr = alloca(pad_bcx, val_ty(llretval));\n@@ -3320,7 +3320,7 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n fn trans_tup(bcx: block, elts: ~[@ast::expr], dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(~\"trans_tup\");\n     let mut bcx = bcx;\n-    let addr = alt dest {\n+    let addr = match dest {\n       ignore => {\n         for vec::each(elts) |ex| { bcx = trans_expr(bcx, ex, ignore); }\n         return bcx;\n@@ -3346,7 +3346,7 @@ fn trans_rec(bcx: block, fields: ~[ast::field],\n     let _icx = bcx.insn_ctxt(~\"trans_rec\");\n     let t = node_id_type(bcx, id);\n     let mut bcx = bcx;\n-    let addr = alt check dest {\n+    let addr = match check dest {\n       ignore => {\n         for vec::each(fields) |fld| {\n             bcx = trans_expr(bcx, fld.node.expr, ignore);\n@@ -3356,7 +3356,7 @@ fn trans_rec(bcx: block, fields: ~[ast::field],\n       save_in(pos) => pos\n     };\n \n-    let ty_fields = alt check ty::get(t).struct { ty::ty_rec(f) => f };\n+    let ty_fields = match check ty::get(t).struct { ty::ty_rec(f) => f };\n \n     let mut temp_cleanups = ~[];\n     for fields.each |fld| {\n@@ -3368,7 +3368,7 @@ fn trans_rec(bcx: block, fields: ~[ast::field],\n         add_clean_temp_mem(bcx, dst, ty_fields[ix].mt.ty);\n         vec::push(temp_cleanups, dst);\n     }\n-    alt base {\n+    match base {\n       some(bexp) => {\n         let {bcx: cx, val: base_val} = trans_temp_expr(bcx, bexp);\n         bcx = cx;\n@@ -3404,7 +3404,7 @@ fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n     // Get the address to store the structure into. If there is no address,\n     // just translate each field and be done with it.\n     let dest_address;\n-    alt dest {\n+    match dest {\n         ignore => {\n             for fields.each |field| {\n                 block_context = trans_expr(block_context,\n@@ -3423,7 +3423,7 @@ fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n \n     // Get the class ID and its fields.\n     let class_fields, class_id, substitutions;\n-    alt ty::get(struct_type).struct {\n+    match ty::get(struct_type).struct {\n         ty::ty_class(existing_class_id, existing_substitutions) => {\n             class_id = existing_class_id;\n             substitutions = existing_substitutions;\n@@ -3458,7 +3458,7 @@ fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n         }\n \n         let index, field_id;\n-        alt found {\n+        match found {\n             some((found_index, found_field_id)) => {\n                 index = found_index;\n                 field_id = found_field_id;\n@@ -3571,7 +3571,7 @@ fn trans_temp_expr(bcx: block, e: @ast::expr) -> result {\n }\n \n fn load_value_from_lval_result(lv: lval_result, ty: ty::t) -> ValueRef {\n-    alt lv.kind {\n+    match lv.kind {\n       lv_temporary => lv.val,\n       lv_owned => load_if_immediate(lv.bcx, lv.val, ty),\n       lv_owned_imm => lv.val\n@@ -3606,12 +3606,12 @@ fn add_root_cleanup(bcx: block, scope_id: ast::node_id,\n     fn find_bcx_for_scope(bcx: block, scope_id: ast::node_id) -> block {\n         let mut bcx_sid = bcx;\n         loop {\n-            bcx_sid = alt bcx_sid.node_info {\n+            bcx_sid = match bcx_sid.node_info {\n               some({id, _}) if id == scope_id => {\n                 return bcx_sid\n               }\n               _ => {\n-                alt bcx_sid.parent {\n+                match bcx_sid.parent {\n                   none => bcx.tcx().sess.bug(\n                       fmt!{\"no enclosing scope with id %d\", scope_id}),\n                   some(bcx_par) => bcx_par\n@@ -3634,7 +3634,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n         return lval_to_dps(bcx, e, dest);\n     }\n \n-    return alt bcx.ccx().maps.root_map.find({id:e.id, derefs:0u}) {\n+    return match bcx.ccx().maps.root_map.find({id:e.id, derefs:0u}) {\n       none => unrooted(bcx, e, dest),\n       some(scope_id) => {\n         debug!{\"expression %d found in root map with scope %d\",\n@@ -3658,7 +3658,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n \n     fn unrooted(bcx: block, e: @ast::expr, dest: dest) -> block {\n         let tcx = bcx.tcx();\n-        alt e.node {\n+        match e.node {\n           ast::expr_if(cond, thn, els) => {\n             return trans_if(bcx, cond, thn, els, dest);\n           }\n@@ -3703,7 +3703,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n                                        cap_clause, none, dest);\n           }\n           ast::expr_fn_block(decl, body, cap_clause) => {\n-            alt check ty::get(expr_ty(bcx, e)).struct {\n+            match check ty::get(expr_ty(bcx, e)).struct {\n               ty::ty_fn({proto, _}) => {\n                 debug!{\"translating fn_block %s with type %s\",\n                        expr_to_str(e),\n@@ -3841,7 +3841,7 @@ fn lval_result_to_dps(lv: lval_result, ty: ty::t,\n                       last_use: bool, dest: dest) -> block {\n     let mut {bcx, val, kind} = lv;\n     let ccx = bcx.ccx();\n-    alt dest {\n+    match dest {\n       by_val(cell) => {\n         if kind == lv_temporary {\n             revoke_clean(bcx, val);\n@@ -3909,7 +3909,7 @@ fn trans_log(log_ex: @ast::expr, lvl: @ast::expr,\n     let modpath = vec::append(\n         ~[path_mod(ccx.link_meta.name)],\n         vec::filter(bcx.fcx.path, |e|\n-            alt e { path_mod(_) => true, _ => false }\n+            match e { path_mod(_) => true, _ => false }\n         ));\n     let modname = path_str(modpath);\n \n@@ -3967,7 +3967,7 @@ fn trans_fail_expr(bcx: block, sp_opt: option<span>,\n                    fail_expr: option<@ast::expr>) -> block {\n     let _icx = bcx.insn_ctxt(~\"trans_fail_expr\");\n     let mut bcx = bcx;\n-    alt fail_expr {\n+    match fail_expr {\n       some(expr) => {\n         let ccx = bcx.ccx(), tcx = ccx.tcx;\n         let expr_res = trans_temp_expr(bcx, expr);\n@@ -3995,7 +3995,7 @@ fn trans_trace(bcx: block, sp_opt: option<span>, trace_str: ~str) {\n     let _icx = bcx.insn_ctxt(~\"trans_trace\");\n     add_comment(bcx, trace_str);\n     let V_trace_str = C_cstr(bcx.ccx(), trace_str);\n-    let {V_filename, V_line} = alt sp_opt {\n+    let {V_filename, V_line} = match sp_opt {\n       some(sp) => {\n         let sess = bcx.sess();\n         let loc = codemap::lookup_char_pos(sess.parse_sess.cm, sp.lo);\n@@ -4025,7 +4025,7 @@ fn trans_fail_value(bcx: block, sp_opt: option<span>,\n                     V_fail_str: ValueRef) -> block {\n     let _icx = bcx.insn_ctxt(~\"trans_fail_value\");\n     let ccx = bcx.ccx();\n-    let {V_filename, V_line} = alt sp_opt {\n+    let {V_filename, V_line} = match sp_opt {\n       some(sp) => {\n         let sess = bcx.sess();\n         let loc = codemap::lookup_char_pos(sess.parse_sess.cm, sp.lo);\n@@ -4067,7 +4067,7 @@ fn trans_break_cont(bcx: block, to_end: bool)\n     let mut unwind = bcx;\n     let mut target;\n     loop {\n-        alt unwind.kind {\n+        match unwind.kind {\n           block_scope({loop_break: some(brk), _}) => {\n             target = if to_end {\n                 brk\n@@ -4078,7 +4078,7 @@ fn trans_break_cont(bcx: block, to_end: bool)\n           }\n           _ => ()\n         }\n-        unwind = alt unwind.parent {\n+        unwind = match unwind.parent {\n           some(cx) => cx,\n           // This is a return from a loop body block\n           none => {\n@@ -4105,22 +4105,22 @@ fn trans_cont(cx: block) -> block {\n fn trans_ret(bcx: block, e: option<@ast::expr>) -> block {\n     let _icx = bcx.insn_ctxt(~\"trans_ret\");\n     let mut bcx = bcx;\n-    let retptr = alt copy bcx.fcx.loop_ret {\n+    let retptr = match copy bcx.fcx.loop_ret {\n       some({flagptr, retptr}) => {\n         // This is a loop body return. Must set continue flag (our retptr)\n         // to false, return flag to true, and then store the value in the\n         // parent's retptr.\n         Store(bcx, C_bool(true), flagptr);\n         Store(bcx, C_bool(false), bcx.fcx.llretptr);\n-        alt e {\n+        match e {\n           some(x) => PointerCast(bcx, retptr,\n                                  T_ptr(type_of(bcx.ccx(), expr_ty(bcx, x)))),\n           none => retptr\n         }\n       }\n       none => bcx.fcx.llretptr\n     };\n-    alt e {\n+    match e {\n       some(x) => {\n         bcx = trans_expr_save_in(bcx, x, retptr);\n       }\n@@ -4139,7 +4139,7 @@ fn build_return(bcx: block) {\n fn init_local(bcx: block, local: @ast::local) -> block {\n     let _icx = bcx.insn_ctxt(~\"init_local\");\n     let ty = node_id_type(bcx, local.node.id);\n-    let llptr = alt bcx.fcx.lllocals.find(local.node.id) {\n+    let llptr = match bcx.fcx.lllocals.find(local.node.id) {\n       some(local_mem(v)) => v,\n       _ => { bcx.tcx().sess.span_bug(local.span,\n                         ~\"init_local: Someone forgot to document why it's\\\n@@ -4148,7 +4148,7 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n     };\n \n     let mut bcx = bcx;\n-    alt local.node.init {\n+    match local.node.init {\n       some(init) => {\n         if init.op == ast::init_assign || !expr_is_lval(bcx, init.expr) {\n             bcx = trans_expr_save_in(bcx, init.expr, llptr);\n@@ -4175,12 +4175,12 @@ fn trans_stmt(cx: block, s: ast::stmt) -> block {\n     let mut bcx = cx;\n     debuginfo::update_source_pos(cx, s.span);\n \n-    alt s.node {\n+    match s.node {\n       ast::stmt_expr(e, _) | ast::stmt_semi(e, _) => {\n         bcx = trans_expr(cx, e, ignore);\n       }\n       ast::stmt_decl(d, _) => {\n-        alt d.node {\n+        match d.node {\n           ast::decl_local(locals) => {\n             for vec::each(locals) |local| {\n                 bcx = init_local(bcx, local);\n@@ -4275,11 +4275,11 @@ fn trans_block_cleanups_(bcx: block, cleanup_cx: block, is_lpad: bool) ->\n     let _icx = bcx.insn_ctxt(~\"trans_block_cleanups\");\n     if bcx.unreachable { return bcx; }\n     let mut bcx = bcx;\n-    alt check cleanup_cx.kind {\n+    match check cleanup_cx.kind {\n       block_scope({cleanups, _}) => {\n         let cleanups = copy cleanups;\n         do vec::riter(cleanups) |cu| {\n-            alt cu {\n+            match cu {\n               clean(cfn, cleanup_type) | clean_temp(_, cfn, cleanup_type) => {\n                 // Some types don't need to be cleaned up during\n                 // landing pads because they can be freed en mass later\n@@ -4311,7 +4311,7 @@ fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n                 fmt!{\"cleanup_and_leave(%s)\", cur.to_str()});\n         }\n \n-        alt cur.kind {\n+        match cur.kind {\n           block_scope(inf) if inf.cleanups.len() > 0u => {\n             for vec::find(inf.cleanup_paths,\n                           |cp| cp.target == leave).each |cp| {\n@@ -4325,16 +4325,16 @@ fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n           }\n           _ => ()\n         }\n-        alt upto {\n+        match upto {\n           some(bb) => { if cur.llbb == bb { break; } }\n           _ => ()\n         }\n-        cur = alt cur.parent {\n+        cur = match cur.parent {\n           some(next) => next,\n           none => { assert is_none(upto); break; }\n         };\n     }\n-    alt leave {\n+    match leave {\n       some(target) => Br(bcx, target),\n       none => { Resume(bcx, Load(bcx, option::get(bcx.fcx.personality))); }\n     }\n@@ -4383,9 +4383,9 @@ fn with_cond(bcx: block, val: ValueRef, f: fn(block) -> block) -> block {\n \n fn block_locals(b: ast::blk, it: fn(@ast::local)) {\n     for vec::each(b.node.stmts) |s| {\n-        alt s.node {\n+        match s.node {\n           ast::stmt_decl(d, _) => {\n-            alt d.node {\n+            match d.node {\n               ast::decl_local(locals) => {\n                 for vec::each(locals) |local| { it(local); }\n               }\n@@ -4410,7 +4410,7 @@ fn alloc_ty(bcx: block, t: ty::t) -> ValueRef {\n fn alloc_local(cx: block, local: @ast::local) -> block {\n     let _icx = cx.insn_ctxt(~\"alloc_local\");\n     let t = node_id_type(cx, local.node.id);\n-    let simple_name = alt local.node.pat.node {\n+    let simple_name = match local.node.pat.node {\n       ast::pat_ident(_, pth, none) => some(path_to_ident(pth)),\n       _ => none\n     };\n@@ -4435,7 +4435,7 @@ fn trans_block(bcx: block, b: ast::blk, dest: dest)\n         debuginfo::update_source_pos(bcx, b.span);\n         bcx = trans_stmt(bcx, *s);\n     }\n-    alt b.node.expr {\n+    match b.node.expr {\n       some(e) => {\n         let bt = ty::type_is_bot(expr_ty(bcx, e));\n         debuginfo::update_source_pos(bcx, e.span);\n@@ -4513,7 +4513,7 @@ fn create_llargs_for_fn_args(cx: fn_ctxt,\n     let _icx = cx.insn_ctxt(~\"create_llargs_for_fn_args\");\n     // Skip the implicit arguments 0, and 1.\n     let mut arg_n = first_real_arg;\n-    alt ty_self {\n+    match ty_self {\n       impl_self(tt) => {\n         cx.llself = some({v: cx.llenv, t: tt});\n       }\n@@ -4544,11 +4544,11 @@ fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: ~[ast::arg],\n     };\n     for vec::each(arg_tys) |arg| {\n         let id = args[arg_n].id;\n-        let argval = alt fcx.llargs.get(id) {\n+        let argval = match fcx.llargs.get(id) {\n           local_mem(v) => v,\n           _ => epic_fail()\n         };\n-        alt ty::resolved_mode(tcx, arg.mode) {\n+        match ty::resolved_mode(tcx, arg.mode) {\n           ast::by_mutbl_ref => (),\n           ast::by_move | ast::by_copy => add_clean(bcx, argval, arg.ty),\n           ast::by_val => {\n@@ -4682,7 +4682,7 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n     let fcx = new_fn_ctxt_w_id(ccx, ~[], llfndecl, variant.node.id,\n                                param_substs, none);\n     create_llargs_for_fn_args(fcx, no_self, fn_args);\n-    let ty_param_substs = alt param_substs {\n+    let ty_param_substs = match param_substs {\n       some(substs) => substs.tys,\n       none => ~[]\n     };\n@@ -4708,7 +4708,7 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n         // If this argument to this function is a enum, it'll have come in to\n         // this function as an opaque blob due to the way that type_of()\n         // works. So we have to cast to the destination's view of the type.\n-        let llarg = alt check fcx.llargs.find(va.id) {\n+        let llarg = match check fcx.llargs.find(va.id) {\n           some(local_mem(x)) => x\n         };\n         let arg_ty = arg_tys[i].ty;\n@@ -4824,10 +4824,10 @@ fn trans_class_dtor(ccx: @crate_ctxt, path: path,\n \n fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n     let _icx = ccx.insn_ctxt(~\"trans_item\");\n-    let path = alt check ccx.tcx.items.get(item.id) {\n+    let path = match check ccx.tcx.items.get(item.id) {\n       ast_map::node_item(_, p) => p\n     };\n-    alt item.node {\n+    match item.node {\n       ast::item_fn(decl, tps, body) => {\n         if decl.purity == ast::extern_fn  {\n             let llfndecl = get_item_val(ccx, item.id);\n@@ -4843,7 +4843,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n                      decl, body, llfndecl, no_self, none, item.id);\n         } else {\n             for vec::each(body.node.stmts) |stmt| {\n-                alt stmt.node {\n+                match stmt.node {\n                   ast::stmt_decl(@{node: ast::decl_item(i), _}, _) => {\n                     trans_item(ccx, *i);\n                   }\n@@ -4876,7 +4876,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n       }\n       ast::item_const(_, expr) => consts::trans_const(ccx, expr, item.id),\n       ast::item_foreign_mod(foreign_mod) => {\n-        let abi = alt attr::foreign_abi(item.attrs) {\n+        let abi = match attr::foreign_abi(item.attrs) {\n           either::right(abi_) => abi_,\n           either::left(msg) => ccx.sess.span_fatal(item.span, msg)\n         };\n@@ -4961,7 +4961,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n \n     let main_takes_argv =\n         // invariant!\n-        alt ty::get(main_node_type).struct {\n+        match ty::get(main_node_type).struct {\n           ty::ty_fn({inputs, _}) => inputs.len() != 0u,\n           _ => ccx.sess.span_fatal(sp, ~\"main has a non-function type\")\n         };\n@@ -5050,7 +5050,7 @@ fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n \n fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n     vec::append(\n-        *alt check ccx.tcx.items.get(i.id) {\n+        *match check ccx.tcx.items.get(i.id) {\n             ast_map::node_item(_, p) => p\n         },\n         ~[path_name(i.ident)])\n@@ -5061,7 +5061,7 @@ fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n fn get_dtor_symbol(ccx: @crate_ctxt, path: path, id: ast::node_id,\n                    substs: option<param_substs>) -> ~str {\n   let t = ty::node_id_to_type(ccx.tcx, id);\n-  alt ccx.item_symbols.find(id) {\n+  match ccx.item_symbols.find(id) {\n      some(s) => s,\n      none if is_none(substs) => {\n        let s = mangle_exported_name(\n@@ -5074,7 +5074,7 @@ fn get_dtor_symbol(ccx: @crate_ctxt, path: path, id: ast::node_id,\n      none   => {\n        // Monomorphizing, so just make a symbol, don't add\n        // this to item_symbols\n-       alt substs {\n+       match substs {\n          some(ss) => {\n            let mono_ty = ty::subst_tps(ccx.tcx, ss.tys, t);\n            mangle_exported_name(\n@@ -5094,14 +5094,14 @@ fn get_dtor_symbol(ccx: @crate_ctxt, path: path, id: ast::node_id,\n \n fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n     let tcx = ccx.tcx;\n-    alt ccx.item_vals.find(id) {\n+    match ccx.item_vals.find(id) {\n       some(v) => v,\n       none => {\n         let mut exprt = false;\n-        let val = alt check ccx.tcx.items.get(id) {\n+        let val = match check ccx.tcx.items.get(id) {\n           ast_map::node_item(i, pth) => {\n             let my_path = vec::append(*pth, ~[path_name(i.ident)]);\n-            alt check i.node {\n+            match check i.node {\n               ast::item_const(_, _) => {\n                 let typ = ty::node_id_to_type(ccx.tcx, i.id);\n                 let s = mangle_exported_name(ccx, my_path, typ);\n@@ -5167,7 +5167,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n             let pth = vec::append(*pth,\n                                   ~[path_name(enm.ident),\n                                    path_name(v.node.name)]);\n-            let llfn = alt check enm.node {\n+            let llfn = match check enm.node {\n               ast::item_enum(_, _) => {\n                 register_fn(ccx, v.span, pth, id)\n               }\n@@ -5188,7 +5188,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n // The constant translation pass.\n fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n     let _icx = ccx.insn_ctxt(~\"trans_constant\");\n-    alt it.node {\n+    match it.node {\n       ast::item_enum(variants, _) => {\n         let vi = ty::enum_variants(ccx.tcx, {crate: ast::local_crate,\n                                              node: it.id});\n@@ -5294,7 +5294,7 @@ fn declare_dbg_intrinsics(llmod: ModuleRef,\n \n fn trap(bcx: block) {\n     let v: ~[ValueRef] = ~[];\n-    alt bcx.ccx().intrinsics.find(~\"llvm.trap\") {\n+    match bcx.ccx().intrinsics.find(~\"llvm.trap\") {\n       some(x) => { Call(bcx, x, v); },\n       _ => bcx.sess().bug(~\"unbound llvm.trap in trap\")\n     }\n@@ -5309,12 +5309,12 @@ fn push_rtcall(ccx: @crate_ctxt, name: ~str, did: ast::def_id) {\n \n fn gather_local_rtcalls(ccx: @crate_ctxt, crate: @ast::crate) {\n     visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n-        visit_item: |item| alt item.node {\n+        visit_item: |item| match item.node {\n           ast::item_fn(decl, _, _) => {\n             let attr_metas = attr::attr_metas(\n                 attr::find_attrs_by_name(item.attrs, ~\"rt\"));\n             do vec::iter(attr_metas) |attr_meta| {\n-                alt attr::get_meta_item_list(attr_meta) {\n+                match attr::get_meta_item_list(attr_meta) {\n                   some(list) => {\n                     let name = *attr::get_meta_item_name(vec::head(list));\n                     push_rtcall(ccx, name, {crate: ast::local_crate,\n@@ -5334,9 +5334,9 @@ fn gather_external_rtcalls(ccx: @crate_ctxt) {\n     do cstore::iter_crate_data(ccx.sess.cstore) |_cnum, cmeta| {\n         do decoder::each_path(cmeta) |path| {\n             let pathname = path.path_string;\n-            alt path.def_like {\n+            match path.def_like {\n               decoder::dl_def(d) => {\n-                alt d {\n+                match d {\n                   ast::def_fn(did, _) => {\n                     // FIXME (#2861): This should really iterate attributes\n                     // like gather_local_rtcalls, but we'll need to\n@@ -5462,7 +5462,7 @@ fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n         for cx.exp_map.each |exp_id, defs| {\n             for defs.each |def| {\n                 if !def.reexp { again; }\n-                let path = alt check cx.tcx.items.get(exp_id) {\n+                let path = match check cx.tcx.items.get(exp_id) {\n                   ast_map::node_export(_, path) => {\n                     ast_map::path_to_str(*path)\n                   }"}, {"sha": "d6083a3c56405c4a0cd5d1baadc5d53379b916f0", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -49,7 +49,7 @@ fn count_insn(cx: block, category: ~str) {\n         s += ~\"/\";\n         s += category;\n \n-        let n = alt h.find(s) {\n+        let n = match h.find(s) {\n           some(n) => n,\n           _ => 0u\n         };"}, {"sha": "752ce97427ca5dd41598ca452150a79cc3a236f7", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -101,7 +101,7 @@ enum environment_value {\n }\n \n fn ev_to_str(ccx: @crate_ctxt, ev: environment_value) -> ~str {\n-    alt ev {\n+    match ev {\n       env_copy(v, t, lk) => fmt!{\"copy(%s,%s)\", val_str(ccx.tn, v),\n                                 ty_to_str(ccx.tcx, t)},\n       env_move(v, t, lk) => fmt!{\"move(%s,%s)\", val_str(ccx.tn, v),\n@@ -124,7 +124,7 @@ fn mk_closure_tys(tcx: ty::ctxt,\n \n     // Compute the closed over data\n     for vec::each(bound_values) |bv| {\n-        vec::push(bound_tys, alt bv {\n+        vec::push(bound_tys, match bv {\n             env_copy(_, t, _) => t,\n             env_move(_, t, _) => t,\n             env_ref(_, t, _) => t\n@@ -153,7 +153,7 @@ fn allocate_cbox(bcx: block,\n     }\n \n     // Allocate and initialize the box:\n-    let {bcx, val} = alt ck {\n+    let {bcx, val} = match ck {\n       ty::ck_box => malloc_raw(bcx, cdata_ty, heap_shared),\n       ty::ck_uniq => malloc_raw(bcx, cdata_ty, heap_exchange),\n       ty::ck_block => {\n@@ -211,7 +211,7 @@ fn store_environment(bcx: block,\n \n         let bound_data = GEPi(bcx, llbox,\n              ~[0u, abi::box_field_body, i]);\n-        alt bv {\n+        match bv {\n           env_copy(val, ty, lv_owned) => {\n             let val1 = load_if_immediate(bcx, val, ty);\n             bcx = base::copy_val(bcx, INIT, bound_data, val1, ty);\n@@ -267,14 +267,14 @@ fn build_closure(bcx0: block,\n         debug!{\"Node id is %s\",\n                syntax::ast_map::node_id_to_str(bcx.ccx().tcx.items, nid)};\n         let mut ty = node_id_type(bcx, nid);\n-        alt cap_var.mode {\n+        match cap_var.mode {\n           capture::cap_ref => {\n             assert ck == ty::ck_block;\n             ty = ty::mk_mut_ptr(tcx, ty);\n             vec::push(env_vals, env_ref(lv.val, ty, lv.kind));\n           }\n           capture::cap_copy => {\n-            let mv = alt check ccx.maps.last_use_map.find(id) {\n+            let mv = match check ccx.maps.last_use_map.find(id) {\n               none => false,\n               some(vars) => (*vars).contains(nid)\n             };\n@@ -292,7 +292,7 @@ fn build_closure(bcx0: block,\n         }\n     }\n     do option::iter(include_ret_handle) |flagptr| {\n-        let our_ret = alt bcx.fcx.loop_ret {\n+        let our_ret = match bcx.fcx.loop_ret {\n           some({retptr, _}) => retptr,\n           none => bcx.fcx.llretptr\n         };\n@@ -323,12 +323,12 @@ fn load_environment(fcx: fn_ctxt,\n     // Populate the upvars from the environment.\n     let mut i = 0u;\n     do vec::iter(cap_vars) |cap_var| {\n-        alt cap_var.mode {\n+        match cap_var.mode {\n           capture::cap_drop => { /* ignore */ }\n           _ => {\n             let mut upvarptr =\n                 GEPi(bcx, llcdata, ~[0u, i]);\n-            alt ck {\n+            match ck {\n               ty::ck_block => { upvarptr = Load(bcx, upvarptr); }\n               ty::ck_uniq | ty::ck_box => ()\n             }\n@@ -368,7 +368,7 @@ fn trans_expr_fn(bcx: block,\n     let trans_closure_env = fn@(ck: ty::closure_kind) -> result {\n         let cap_vars = capture::compute_capture_vars(\n             ccx.tcx, id, proto, cap_clause);\n-        let ret_handle = alt is_loop_body { some(x) => x, none => none };\n+        let ret_handle = match is_loop_body { some(x) => x, none => none };\n         let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, ck, id,\n                                                    ret_handle);\n         trans_closure(ccx, sub_path, decl, body, llfn, no_self,\n@@ -383,7 +383,7 @@ fn trans_expr_fn(bcx: block,\n         {bcx: bcx, val: llbox}\n     };\n \n-    let {bcx: bcx, val: closure} = alt proto {\n+    let {bcx: bcx, val: closure} = match proto {\n       ast::proto_block => trans_closure_env(ty::ck_block),\n       ast::proto_box => trans_closure_env(ty::ck_box),\n       ast::proto_uniq => trans_closure_env(ty::ck_uniq),\n@@ -417,7 +417,7 @@ fn make_fn_glue(\n         }\n     };\n \n-    return alt ty::get(t).struct {\n+    return match ty::get(t).struct {\n       ty::ty_fn({proto: ast::proto_bare, _}) |\n       ty::ty_fn({proto: ast::proto_block, _}) => bcx,\n       ty::ty_fn({proto: ast::proto_uniq, _}) => fn_env(ty::ck_uniq),\n@@ -433,7 +433,7 @@ fn make_opaque_cbox_take_glue(\n     -> block {\n     // Easy cases:\n     let _icx = bcx.insn_ctxt(~\"closure::make_opaque_cbox_take_glue\");\n-    alt ck {\n+    match ck {\n       ty::ck_block => return bcx,\n       ty::ck_box => {\n         incr_refcnt_of_boxed(bcx, Load(bcx, cboxptr));\n@@ -485,7 +485,7 @@ fn make_opaque_cbox_drop_glue(\n     cboxptr: ValueRef)     // ptr to the opaque closure\n     -> block {\n     let _icx = bcx.insn_ctxt(~\"closure::make_opaque_cbox_drop_glue\");\n-    alt ck {\n+    match ck {\n       ty::ck_block => bcx,\n       ty::ck_box => {\n         decr_refcnt_maybe_free(bcx, Load(bcx, cboxptr),\n@@ -504,7 +504,7 @@ fn make_opaque_cbox_free_glue(\n     cbox: ValueRef)     // ptr to the opaque closure\n     -> block {\n     let _icx = bcx.insn_ctxt(~\"closure::make_opaque_cbox_free_glue\");\n-    alt ck {\n+    match ck {\n       ty::ck_block => return bcx,\n       ty::ck_box | ty::ck_uniq => { /* hard cases: */ }\n     }\n@@ -524,7 +524,7 @@ fn make_opaque_cbox_free_glue(\n                               abi::tydesc_field_drop_glue, none);\n \n         // Free the ty descr (if necc) and the box itself\n-        alt ck {\n+        match ck {\n           ty::ck_block => fail ~\"Impossible\",\n           ty::ck_box => trans_free(bcx, cbox),\n           ty::ck_uniq => trans_unique_free(bcx, cbox)"}, {"sha": "7e48297f12ec6394410ad83e7058c7a0e594b64b", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -292,7 +292,7 @@ fn add_clean_temp_mem(cx: block, val: ValueRef, ty: ty::t) {\n     }\n }\n fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n-    let free_fn = alt heap {\n+    let free_fn = match heap {\n       heap_shared => |a| base::trans_free(a, ptr),\n       heap_exchange => |a| base::trans_unique_free(a, ptr)\n     };\n@@ -310,7 +310,7 @@ fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n fn revoke_clean(cx: block, val: ValueRef) {\n     do in_scope_cx(cx) |info| {\n         do option::iter(vec::position(info.cleanups, |cu| {\n-            alt cu {\n+            match cu {\n               clean_temp(v, _, _) if v == val => true,\n               _ => false\n             }\n@@ -453,7 +453,7 @@ fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef unsafe {\n fn in_scope_cx(cx: block, f: fn(scope_info)) {\n     let mut cur = cx;\n     loop {\n-        alt cur.kind {\n+        match cur.kind {\n           block_scope(inf) => { f(inf); return; }\n           _ => ()\n         }\n@@ -462,7 +462,7 @@ fn in_scope_cx(cx: block, f: fn(scope_info)) {\n }\n \n fn block_parent(cx: block) -> block {\n-    alt cx.parent {\n+    match cx.parent {\n       some(b) => b,\n       none    => cx.sess().bug(fmt!{\"block_parent called on root block %?\",\n                                    cx})\n@@ -483,7 +483,7 @@ impl bcx_cxs for block {\n         ty_to_str(self.tcx(), t)\n     }\n     fn to_str() -> ~str {\n-        alt self.node_info {\n+        match self.node_info {\n           some(node_info) => {\n             fmt!{\"[block %d]\", node_info.id}\n           }\n@@ -535,15 +535,15 @@ fn T_f64() -> TypeRef { return llvm::LLVMDoubleType(); }\n fn T_bool() -> TypeRef { return T_i1(); }\n \n fn T_int(targ_cfg: @session::config) -> TypeRef {\n-    return alt targ_cfg.arch {\n+    return match targ_cfg.arch {\n       session::arch_x86 => T_i32(),\n       session::arch_x86_64 => T_i64(),\n       session::arch_arm => T_i32()\n     };\n }\n \n fn T_int_ty(cx: @crate_ctxt, t: ast::int_ty) -> TypeRef {\n-    alt t {\n+    match t {\n       ast::ty_i => cx.int_type,\n       ast::ty_char => T_char(),\n       ast::ty_i8 => T_i8(),\n@@ -554,7 +554,7 @@ fn T_int_ty(cx: @crate_ctxt, t: ast::int_ty) -> TypeRef {\n }\n \n fn T_uint_ty(cx: @crate_ctxt, t: ast::uint_ty) -> TypeRef {\n-    alt t {\n+    match t {\n       ast::ty_u => cx.int_type,\n       ast::ty_u8 => T_i8(),\n       ast::ty_u16 => T_i16(),\n@@ -564,15 +564,15 @@ fn T_uint_ty(cx: @crate_ctxt, t: ast::uint_ty) -> TypeRef {\n }\n \n fn T_float_ty(cx: @crate_ctxt, t: ast::float_ty) -> TypeRef {\n-    alt t {\n+    match t {\n       ast::ty_f => cx.float_type,\n       ast::ty_f32 => T_f32(),\n       ast::ty_f64 => T_f64()\n     }\n }\n \n fn T_float(targ_cfg: @session::config) -> TypeRef {\n-    return alt targ_cfg.arch {\n+    return match targ_cfg.arch {\n       session::arch_x86 => T_f64(),\n       session::arch_x86_64 => T_f64(),\n       session::arch_arm => T_f64()\n@@ -657,7 +657,7 @@ fn T_tydesc_field(cx: @crate_ctxt, field: uint) -> TypeRef unsafe {\n \n fn T_glue_fn(cx: @crate_ctxt) -> TypeRef {\n     let s = ~\"glue_fn\";\n-    alt name_has_type(cx.tn, s) {\n+    match name_has_type(cx.tn, s) {\n       some(t) => return t,\n       _ => ()\n     }\n@@ -764,7 +764,7 @@ fn T_taskptr(cx: @crate_ctxt) -> TypeRef { return T_ptr(cx.task_type); }\n // This type must never be used directly; it must always be cast away.\n fn T_typaram(tn: type_names) -> TypeRef {\n     let s = ~\"typaram\";\n-    alt name_has_type(tn, s) {\n+    match name_has_type(tn, s) {\n       some(t) => return t,\n       _ => ()\n     }\n@@ -787,7 +787,7 @@ fn T_enum_discrim(cx: @crate_ctxt) -> TypeRef {\n \n fn T_opaque_enum(cx: @crate_ctxt) -> TypeRef {\n     let s = ~\"opaque_enum\";\n-    alt name_has_type(cx.tn, s) {\n+    match name_has_type(cx.tn, s) {\n       some(t) => return t,\n       _ => ()\n     }\n@@ -856,7 +856,7 @@ fn C_u8(i: uint) -> ValueRef { return C_integral(T_i8(), i as u64, False); }\n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n fn C_cstr(cx: @crate_ctxt, s: ~str) -> ValueRef {\n-    alt cx.const_cstr_cache.find(s) {\n+    match cx.const_cstr_cache.find(s) {\n       some(llval) => return llval,\n       none => ()\n     }\n@@ -942,7 +942,7 @@ type mono_id = @{def: ast::def_id, params: ~[mono_param_id]};\n pure fn hash_mono_id(mi: &mono_id) -> uint {\n     let mut h = syntax::ast_util::hash_def(&mi.def);\n     for vec::each(mi.params) |param| {\n-        h = h * alt param {\n+        h = h * match param {\n           mono_precise(ty, vts) => {\n             let mut h = ty::type_id(ty);\n             do option::iter(vts) |vts| {\n@@ -978,7 +978,7 @@ fn align_to(cx: block, off: ValueRef, align: ValueRef) -> ValueRef {\n fn path_str(p: path) -> ~str {\n     let mut r = ~\"\", first = true;\n     for vec::each(p) |e| {\n-        alt e { ast_map::path_name(s) | ast_map::path_mod(s) => {\n+        match e { ast_map::path_name(s) | ast_map::path_mod(s) => {\n           if first { first = false; }\n           else { r += ~\"::\"; }\n           r += *s;\n@@ -990,7 +990,7 @@ fn path_str(p: path) -> ~str {\n fn node_id_type(bcx: block, id: ast::node_id) -> ty::t {\n     let tcx = bcx.tcx();\n     let t = ty::node_id_to_type(tcx, id);\n-    alt bcx.fcx.param_substs {\n+    match bcx.fcx.param_substs {\n       some(substs) => ty::subst_tps(tcx, substs.tys, t),\n       _ => { assert !ty::type_has_params(t); t }\n     }\n@@ -1001,7 +1001,7 @@ fn expr_ty(bcx: block, ex: @ast::expr) -> ty::t {\n fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n     let tcx = bcx.tcx();\n     let params = ty::node_id_to_type_params(tcx, id);\n-    alt bcx.fcx.param_substs {\n+    match bcx.fcx.param_substs {\n       some(substs) => {\n         vec::map(params, |t| ty::subst_tps(tcx, substs.tys, t))\n       }\n@@ -1012,7 +1012,7 @@ fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n fn field_idx_strict(cx: ty::ctxt, sp: span, ident: ast::ident,\n                     fields: ~[ty::field])\n     -> uint {\n-    alt ty::field_idx(ident, fields) {\n+    match ty::field_idx(ident, fields) {\n        none => cx.sess.span_bug(\n            sp, fmt!{\"base expr doesn't appear to \\\n                          have a field named %s\", *ident}),"}, {"sha": "49ea20c6e8575fff3ab5b77d94009f8685067104", "filename": "src/rustc/middle/trans/consts.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -5,12 +5,12 @@ import base::get_insn_ctxt;\n fn const_lit(cx: @crate_ctxt, e: @ast::expr, lit: ast::lit)\n     -> ValueRef {\n     let _icx = cx.insn_ctxt(~\"trans_lit\");\n-    alt lit.node {\n+    match lit.node {\n       ast::lit_int(i, t) => C_integral(T_int_ty(cx, t), i as u64, True),\n       ast::lit_uint(u, t) => C_integral(T_uint_ty(cx, t), u, False),\n       ast::lit_int_unsuffixed(i) => {\n         let lit_int_ty = ty::node_id_to_type(cx.tcx, e.id);\n-        alt ty::get(lit_int_ty).struct {\n+        match ty::get(lit_int_ty).struct {\n           ty::ty_int(t) => {\n             C_integral(T_int_ty(cx, t), i as u64, True)\n           }\n@@ -45,7 +45,7 @@ fn const_vec_and_sz(cx: @crate_ctxt, e: @ast::expr, es: &[@ast::expr])\n \n fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n     let _icx = cx.insn_ctxt(~\"const_expr\");\n-    alt e.node {\n+    match e.node {\n       ast::expr_lit(lit) => consts::const_lit(cx, e, *lit),\n       ast::expr_binary(b, e1, e2) => {\n         let te1 = const_expr(cx, e1);\n@@ -58,7 +58,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n         let ty = ty::expr_ty(cx.tcx, e1);\n         let is_float = ty::type_is_fp(ty);\n         let signed = ty::type_is_signed(ty);\n-        return alt b {\n+        return match b {\n           ast::add   => {\n             if is_float { llvm::LLVMConstFAdd(te1, te2) }\n             else        { llvm::LLVMConstAdd(te1, te2) }\n@@ -103,7 +103,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n         let te = const_expr(cx, e);\n         let ty = ty::expr_ty(cx.tcx, e);\n         let is_float = ty::type_is_fp(ty);\n-        return alt u {\n+        return match u {\n           ast::box(_)  |\n           ast::uniq(_) |\n           ast::deref   => cx.sess.span_bug(e.span,\n@@ -119,7 +119,9 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n         let ety = ty::expr_ty(cx.tcx, e), llty = type_of::type_of(cx, ety);\n         let basety = ty::expr_ty(cx.tcx, base);\n         let v = const_expr(cx, base);\n-        alt check (base::cast_type_kind(basety), base::cast_type_kind(ety)) {\n+        match check (base::cast_type_kind(basety),\n+                     base::cast_type_kind(ety)) {\n+\n           (base::cast_integral, base::cast_integral) => {\n             let s = if ty::type_is_signed(basety) { True } else { False };\n             llvm::LLVMConstIntCast(v, llty, s)\n@@ -162,9 +164,9 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n         const_expr(cx, e)\n       }\n       ast::expr_vstore(sub, ast::vstore_slice(_)) => {\n-        alt sub.node {\n+        match sub.node {\n           ast::expr_lit(lit) => {\n-            alt lit.node {\n+            match lit.node {\n               ast::lit_str(*) => { const_expr(cx, sub) }\n               _ => { cx.sess.span_bug(e.span,\n                                       ~\"bad const-slice lit\") }\n@@ -186,11 +188,11 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n         }\n       }\n       ast::expr_path(path) => {\n-        alt cx.tcx.def_map.find(e.id) {\n+        match cx.tcx.def_map.find(e.id) {\n           some(ast::def_const(def_id)) => {\n             // Don't know how to handle external consts\n             assert ast_util::is_local(def_id);\n-            alt cx.tcx.items.get(def_id.node) {\n+            match cx.tcx.items.get(def_id.node) {\n               ast_map::node_item(@{\n                 node: ast::item_const(_, subexpr), _\n               }, _) => {"}, {"sha": "1a207a5313ca31565f50dcd8a55dd37d16fbde65", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -134,7 +134,7 @@ fn cast_safely<T: copy, U>(val: T) -> U unsafe {\n }\n \n fn md_from_metadata<T>(val: debug_metadata) -> T unsafe {\n-    alt val {\n+    match val {\n       file_metadata(md) => cast_safely(md),\n       compile_unit_metadata(md) => cast_safely(md),\n       subprogram_metadata(md) => cast_safely(md),\n@@ -165,7 +165,7 @@ fn create_compile_unit(cx: @crate_ctxt)\n     let cache = get_cache(cx);\n     let crate_name = option::get(cx.dbg_cx).crate_file;\n     let tg = CompileUnitTag;\n-    alt cached_metadata::<@metadata<compile_unit_md>>(cache, tg,\n+    match cached_metadata::<@metadata<compile_unit_md>>(cache, tg,\n                         |md| md.data.name == crate_name) {\n       option::some(md) => return md,\n       option::none => ()\n@@ -208,7 +208,7 @@ fn get_file_path_and_dir(work_dir: ~str, full_path: ~str) -> (~str, ~str) {\n fn create_file(cx: @crate_ctxt, full_path: ~str) -> @metadata<file_md> {\n     let cache = get_cache(cx);;\n     let tg = FileDescriptorTag;\n-    alt cached_metadata::<@metadata<file_md>>(\n+    match cached_metadata::<@metadata<file_md>>(\n         cache, tg, |md| md.data.path == full_path) {\n         option::some(md) => return md,\n         option::none => ()\n@@ -235,7 +235,7 @@ fn create_block(cx: block) -> @metadata<block_md> {\n     let cache = get_cache(cx.ccx());\n     let mut cx = cx;\n     while option::is_none(cx.node_info) {\n-        alt cx.parent {\n+        match cx.parent {\n           some(b) => cx = b,\n           none => fail\n         }\n@@ -253,12 +253,12 @@ fn create_block(cx: block) -> @metadata<block_md> {\n       option::none {}\n     }*/\n \n-    let parent = alt cx.parent {\n+    let parent = match cx.parent {\n         none => create_function(cx.fcx).node,\n         some(bcx) => create_block(bcx).node\n     };\n     let file_node = create_file(cx.ccx(), fname);\n-    let unique_id = alt cache.find(LexicalBlockTag) {\n+    let unique_id = match cache.find(LexicalBlockTag) {\n       option::some(v) => vec::len(v) as int,\n       option::none => 0\n     };\n@@ -285,30 +285,30 @@ fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: ast::prim_ty, span: span)\n     -> @metadata<tydesc_md> {\n     let cache = get_cache(cx);\n     let tg = BasicTypeDescriptorTag;\n-    alt cached_metadata::<@metadata<tydesc_md>>(\n+    match cached_metadata::<@metadata<tydesc_md>>(\n         cache, tg, |md| ty::type_id(t) == md.data.hash) {\n       option::some(md) => return md,\n       option::none => ()\n     }\n \n-    let (name, encoding) = alt check ty {\n+    let (name, encoding) = match check ty {\n       ast::ty_bool => (~\"bool\", DW_ATE_boolean),\n-      ast::ty_int(m) => alt m {\n+      ast::ty_int(m) => match m {\n         ast::ty_char => (~\"char\", DW_ATE_unsigned),\n         ast::ty_i => (~\"int\", DW_ATE_signed),\n         ast::ty_i8 => (~\"i8\", DW_ATE_signed_char),\n         ast::ty_i16 => (~\"i16\", DW_ATE_signed),\n         ast::ty_i32 => (~\"i32\", DW_ATE_signed),\n         ast::ty_i64 => (~\"i64\", DW_ATE_signed)\n       }\n-      ast::ty_uint(m) => alt m {\n+      ast::ty_uint(m) => match m {\n         ast::ty_u => (~\"uint\", DW_ATE_unsigned),\n         ast::ty_u8 => (~\"u8\", DW_ATE_unsigned_char),\n         ast::ty_u16 => (~\"u16\", DW_ATE_unsigned),\n         ast::ty_u32 => (~\"u32\", DW_ATE_unsigned),\n         ast::ty_u64 => (~\"u64\", DW_ATE_unsigned)\n       }\n-      ast::ty_float(m) => alt m {\n+      ast::ty_float(m) => match m {\n         ast::ty_f => (~\"float\", DW_ATE_float),\n         ast::ty_f32 => (~\"f32\", DW_ATE_float),\n         ast::ty_f64 => (~\"f64\", DW_ATE_float)\n@@ -341,7 +341,7 @@ fn create_pointer_type(cx: @crate_ctxt, t: ty::t, span: span,\n     -> @metadata<tydesc_md> {\n     let tg = PointerTypeTag;\n     /*let cache = cx.llmetadata;\n-    alt cached_metadata::<@metadata<tydesc_md>>(\n+    match cached_metadata::<@metadata<tydesc_md>>(\n         cache, tg, {|md| ty::hash_ty(t) == ty::hash_ty(md.data.hash)}) {\n       option::some(md) { return md; }\n       option::none {}\n@@ -434,7 +434,7 @@ fn create_boxed_type(cx: @crate_ctxt, outer: ty::t, _inner: ty::t,\n     -> @metadata<tydesc_md> {\n     //let tg = StructureTypeTag;\n     /*let cache = cx.llmetadata;\n-    alt cached_metadata::<@metadata<tydesc_md>>(\n+    match cached_metadata::<@metadata<tydesc_md>>(\n         cache, tg, {|md| ty::hash_ty(outer) == ty::hash_ty(md.data.hash)}) {\n       option::some(md) { return md; }\n       option::none {}\n@@ -516,7 +516,7 @@ fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n     -> @metadata<tydesc_md> {\n     /*let cache = get_cache(cx);\n-    alt cached_metadata::<@metadata<tydesc_md>>(\n+    match cached_metadata::<@metadata<tydesc_md>>(\n         cache, tg, {|md| t == md.data.hash}) {\n       option::some(md) { return md; }\n       option::none {}\n@@ -536,7 +536,7 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n     fail;\n     /*\n     fn t_to_ty(cx: crate_ctxt, t: ty::t, span: span) -> @ast::ty {\n-        let ty = alt ty::get(t).struct {\n+        let ty = match ty::get(t).struct {\n           ty::ty_nil { ast::ty_nil }\n           ty::ty_bot { ast::ty_bot }\n           ty::ty_bool { ast::ty_bool }\n@@ -566,9 +566,9 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n         return @{node: ty, span: span};\n     }\n \n-    alt ty.node {\n+    match ty.node {\n       ast::ty_box(mt) {\n-        let inner_t = alt ty::get(t).struct {\n+        let inner_t = match ty::get(t).struct {\n           ty::ty_box(boxed) { boxed.ty }\n           _ { cx.sess.span_bug(ty.span, \"t_to_ty was incoherent\"); }\n         };\n@@ -578,7 +578,7 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n       }\n \n       ast::ty_uniq(mt) {\n-        let inner_t = alt ty::get(t).struct {\n+        let inner_t = match ty::get(t).struct {\n           ty::ty_uniq(boxed) { boxed.ty }\n           // Hoping we'll have a way to eliminate this check soon.\n           _ { cx.sess.span_bug(ty.span, \"t_to_ty was incoherent\"); }\n@@ -604,7 +604,7 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n       }\n \n       ast::ty_path(_, id) {\n-        alt cx.tcx.def_map.get(id) {\n+        match cx.tcx.def_map.get(id) {\n           ast::def_prim_ty(pty) {\n             return create_basic_type(cx, t, pty, ty.span);\n           }\n@@ -639,13 +639,13 @@ fn create_local_var(bcx: block, local: @ast::local)\n     let cx = bcx.ccx();\n     let cache = get_cache(cx);\n     let tg = AutoVariableTag;\n-    alt cached_metadata::<@metadata<local_var_md>>(\n+    match cached_metadata::<@metadata<local_var_md>>(\n         cache, tg, |md| md.data.id == local.node.id) {\n       option::some(md) => return md,\n       option::none => ()\n     }\n \n-    let name = alt local.node.pat.node {\n+    let name = match local.node.pat.node {\n       ast::pat_ident(_, pth, _) => ast_util::path_to_ident(pth),\n       // FIXME this should be handled (#2533)\n       _ => fail ~\"no single variable name for local\"\n@@ -655,7 +655,7 @@ fn create_local_var(bcx: block, local: @ast::local)\n     let ty = node_id_type(bcx, local.node.id);\n     let tymd = create_ty(cx, ty, local.node.ty);\n     let filemd = create_file(cx, loc.file.name);\n-    let context = alt bcx.parent {\n+    let context = match bcx.parent {\n         none => create_function(bcx.fcx).node,\n         some(_) => create_block(bcx).node\n     };\n@@ -664,14 +664,14 @@ fn create_local_var(bcx: block, local: @ast::local)\n     let mdval = @{node: mdnode, data: {id: local.node.id}};\n     update_cache(cache, AutoVariableTag, local_var_metadata(mdval));\n \n-    let llptr = alt bcx.fcx.lllocals.find(local.node.id) {\n+    let llptr = match bcx.fcx.lllocals.find(local.node.id) {\n       option::some(local_mem(v)) => v,\n       option::some(_) => {\n         bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n                 something weird\");\n       }\n       option::none => {\n-        alt bcx.fcx.lllocals.get(local.node.pat.id) {\n+        match bcx.fcx.lllocals.get(local.node.pat.id) {\n           local_imm(v) => v,\n           _ => bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n                                                      something weird\")\n@@ -689,7 +689,7 @@ fn create_arg(bcx: block, arg: ast::arg, sp: span)\n     let fcx = bcx.fcx, cx = fcx.ccx;\n     let cache = get_cache(cx);\n     let tg = ArgVariableTag;\n-    alt cached_metadata::<@metadata<argument_md>>(\n+    match cached_metadata::<@metadata<argument_md>>(\n         cache, ArgVariableTag, |md| md.data.id == arg.id) {\n       option::some(md) => return md,\n       option::none => ()\n@@ -706,7 +706,7 @@ fn create_arg(bcx: block, arg: ast::arg, sp: span)\n     let mdval = @{node: mdnode, data: {id: arg.id}};\n     update_cache(cache, tg, argument_metadata(mdval));\n \n-    let llptr = alt fcx.llargs.get(arg.id) {\n+    let llptr = match fcx.llargs.get(arg.id) {\n       local_mem(v) | local_imm(v) => v,\n     };\n     let declargs = ~[llmdnode(~[llptr]), mdnode];\n@@ -740,9 +740,9 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     let sp = option::get(fcx.span);\n     log(debug, codemap::span_to_str(sp, cx.sess.codemap));\n \n-    let (ident, ret_ty, id) = alt cx.tcx.items.get(fcx.id) {\n+    let (ident, ret_ty, id) = match cx.tcx.items.get(fcx.id) {\n       ast_map::node_item(item, _) => {\n-        alt item.node {\n+        match item.node {\n           ast::item_fn(decl, _, _) => {\n             (item.ident, decl.output, item.id)\n           }\n@@ -758,7 +758,7 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n         (nm, ctor.node.dec.output, ctor.node.id)\n       }\n       ast_map::node_expr(expr) => {\n-        alt expr.node {\n+        match expr.node {\n           ast::expr_fn(_, decl, _, _) => {\n             (@dbg_cx.names(~\"fn\"), decl.output, expr.id)\n           }\n@@ -778,7 +778,7 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     log(debug, id);\n \n     let cache = get_cache(cx);\n-    alt cached_metadata::<@metadata<subprogram_md>>(\n+    match cached_metadata::<@metadata<subprogram_md>>(\n         cache, SubprogramTag, |md| md.data.id == id) {\n       option::some(md) => return md,\n       option::none => ()\n@@ -788,7 +788,7 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n                                        sp.lo);\n     let file_node = create_file(cx, loc.file.name).node;\n     let ty_node = if cx.sess.opts.extra_debuginfo {\n-        alt ret_ty.node {\n+        match ret_ty.node {\n           ast::ty_nil => llnull(),\n           _ => create_ty(cx, ty::node_id_to_type(cx.tcx, id), ret_ty).node\n         }"}, {"sha": "1555f2df89ae0eef678d5675412568f49bea3647", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -38,7 +38,7 @@ enum x86_64_reg_class {\n }\n \n fn is_sse(++c: x86_64_reg_class) -> bool {\n-    return alt c {\n+    return match c {\n         sse_fs_class | sse_fv_class |\n         sse_ds_class | sse_dv_class => true,\n         _ => false\n@@ -73,7 +73,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n     }\n \n     fn ty_align(ty: TypeRef) -> uint {\n-        return alt llvm::LLVMGetTypeKind(ty) as int {\n+        return match llvm::LLVMGetTypeKind(ty) as int {\n             8 /* integer */ => {\n                 ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7u) / 8u\n             }\n@@ -94,7 +94,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n     }\n \n     fn ty_size(ty: TypeRef) -> uint {\n-        return alt llvm::LLVMGetTypeKind(ty) as int {\n+        return match llvm::LLVMGetTypeKind(ty) as int {\n             8 /* integer */ => {\n                 ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7u) / 8u\n             }\n@@ -179,7 +179,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n             return;\n         }\n \n-        alt llvm::LLVMGetTypeKind(ty) as int {\n+        match llvm::LLVMGetTypeKind(ty) as int {\n             8 /* integer */ |\n             12 /* pointer */ => {\n                 unify(cls, ix + off / 8u, integer_class);\n@@ -285,7 +285,7 @@ fn llreg_ty(cls: ~[x86_64_reg_class]) -> TypeRef {\n     let mut i = 0u;\n     let e = vec::len(cls);\n     while i < e {\n-        alt cls[i] {\n+        match cls[i] {\n             integer_class => {\n                 vec::push(tys, T_i64());\n             }\n@@ -326,7 +326,7 @@ fn x86_64_tys(atys: ~[TypeRef],\n               rty: TypeRef,\n               ret_def: bool) -> x86_64_tys {\n     fn is_reg_ty(ty: TypeRef) -> bool {\n-        return alt llvm::LLVMGetTypeKind(ty) as int {\n+        return match llvm::LLVMGetTypeKind(ty) as int {\n             8 /* integer */ |\n             12 /* pointer */ |\n             2 /* float */ |\n@@ -401,7 +401,7 @@ fn decl_x86_64_fn(tys: x86_64_tys,\n     let llfn = decl(fnty);\n \n     do vec::iteri(tys.attrs) |i, a| {\n-        alt a {\n+        match a {\n             option::some(attr) => {\n                 let llarg = get_param(llfn, i);\n                 llvm::LLVMAddAttribute(llarg, attr as c_uint);\n@@ -413,7 +413,7 @@ fn decl_x86_64_fn(tys: x86_64_tys,\n }\n \n fn link_name(i: @ast::foreign_item) -> ~str {\n-    alt attr::first_attr_value_str_by_name(i.attrs, ~\"link_name\") {\n+    match attr::first_attr_value_str_by_name(i.attrs, ~\"link_name\") {\n       none => return *i.ident,\n       option::some(ln) => return *ln\n     }\n@@ -430,7 +430,7 @@ type c_stack_tys = {\n \n fn c_arg_and_ret_lltys(ccx: @crate_ctxt,\n                        id: ast::node_id) -> (~[TypeRef], TypeRef, ty::t) {\n-    alt ty::get(ty::node_id_to_type(ccx.tcx, id)).struct {\n+    match ty::get(ty::node_id_to_type(ccx.tcx, id)).struct {\n       ty::ty_fn({inputs: arg_tys, output: ret_ty, _}) => {\n         let llargtys = type_of_explicit_args(ccx, arg_tys);\n         let llretty = type_of::type_of(ccx, ret_ty);\n@@ -587,7 +587,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n             let mut i = 0u;\n             let n = vec::len(tys.arg_tys);\n \n-            alt tys.x86_64_tys {\n+            match tys.x86_64_tys {\n                 some(x86_64) => {\n                     let mut atys = x86_64.arg_tys;\n                     let mut attrs = x86_64.attrs;\n@@ -629,10 +629,10 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n         fn build_ret(bcx: block, tys: @c_stack_tys,\n                      llargbundle: ValueRef, llretval: ValueRef)  {\n             let _icx = bcx.insn_ctxt(~\"foreign::shim::build_ret\");\n-            alt tys.x86_64_tys {\n+            match tys.x86_64_tys {\n                 some(x86_64) => {\n                   do vec::iteri(x86_64.attrs) |i, a| {\n-                        alt a {\n+                        match a {\n                             some(attr) => {\n                                 llvm::LLVMAddInstrAttribute(\n                                     llretval, (i + 1u) as c_uint,\n@@ -680,7 +680,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n     fn base_fn(ccx: @crate_ctxt, lname: ~str, tys: @c_stack_tys,\n                cc: lib::llvm::CallConv) -> ValueRef {\n         // Declare the \"prototype\" for the base function F:\n-        alt tys.x86_64_tys {\n+        match tys.x86_64_tys {\n           some(x86_64) => {\n             do decl_x86_64_fn(x86_64) |fnty| {\n                 decl_fn(ccx.llmod, lname, cc, fnty)\n@@ -747,14 +747,14 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n                        build_args, build_ret);\n     }\n \n-    let mut cc = alt abi {\n+    let mut cc = match abi {\n       ast::foreign_abi_rust_intrinsic |\n       ast::foreign_abi_cdecl => lib::llvm::CCallConv,\n       ast::foreign_abi_stdcall => lib::llvm::X86StdcallCallConv\n     };\n \n     for vec::each(foreign_mod.items) |foreign_item| {\n-      alt foreign_item.node {\n+      match foreign_item.node {\n         ast::foreign_item_fn(fn_decl, typarams) => {\n           let id = foreign_item.id;\n           if abi != ast::foreign_abi_rust_intrinsic {\n@@ -772,7 +772,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n               // monomorphic_fn, but ones without are emitted here\n               if typarams.is_empty() {\n                   let llwrapfn = get_item_val(ccx, id);\n-                  let path = alt ccx.tcx.items.find(id) {\n+                  let path = match ccx.tcx.items.find(id) {\n                       some(ast_map::node_foreign_item(_, _, pt)) => pt,\n                       _ => {\n                           ccx.sess.span_bug(foreign_item.span,\n@@ -799,7 +799,7 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n     let fcx = new_fn_ctxt_w_id(ccx, path, decl, item.id,\n                                some(substs), some(item.span));\n     let mut bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n-    alt check *item.ident {\n+    match check *item.ident {\n       ~\"atomic_xchng\" => {\n         let old = AtomicRMW(bcx, Xchg,\n                   get_param(decl, first_real_arg),\n@@ -925,7 +925,7 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n         let tp_sz = shape::llsize_of_real(ccx, lltp_ty),\n             out_sz = shape::llsize_of_real(ccx, llout_ty);\n         if tp_sz != out_sz {\n-            let sp = alt check ccx.tcx.items.get(option::get(ref_id)) {\n+            let sp = match check ccx.tcx.items.get(option::get(ref_id)) {\n               ast_map::node_expr(e) => e.span\n             };\n             ccx.sess.span_fatal(\n@@ -1045,7 +1045,7 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n         fn build_args(bcx: block, tys: @c_stack_tys,\n                       llwrapfn: ValueRef, llargbundle: ValueRef) {\n             let _icx = bcx.insn_ctxt(~\"foreign::foreign::wrap::build_args\");\n-            alt tys.x86_64_tys {\n+            match tys.x86_64_tys {\n                 option::some(x86_64) => {\n                     let mut atys = x86_64.arg_tys;\n                     let mut attrs = x86_64.attrs;\n@@ -1099,7 +1099,7 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n         fn build_ret(bcx: block, tys: @c_stack_tys,\n                      llargbundle: ValueRef) {\n             let _icx = bcx.insn_ctxt(~\"foreign::foreign::wrap::build_ret\");\n-            alt tys.x86_64_tys {\n+            match tys.x86_64_tys {\n                 option::some(x86_64) => {\n                     if x86_64.sret || !tys.ret_def {\n                         RetVoid(bcx);\n@@ -1161,11 +1161,11 @@ fn register_foreign_fn(ccx: @crate_ctxt, sp: span,\n \n fn abi_of_foreign_fn(ccx: @crate_ctxt, i: @ast::foreign_item)\n     -> ast::foreign_abi {\n-    alt attr::first_attr_value_str_by_name(i.attrs, ~\"abi\") {\n-      none => alt check ccx.tcx.items.get(i.id) {\n+    match attr::first_attr_value_str_by_name(i.attrs, ~\"abi\") {\n+      none => match check ccx.tcx.items.get(i.id) {\n         ast_map::node_foreign_item(_, abi, _) => abi\n       }\n-      some(_) => alt attr::foreign_abi(i.attrs) {\n+      some(_) => match attr::foreign_abi(i.attrs) {\n         either::right(abi) => abi,\n         either::left(msg) => ccx.sess.span_fatal(i.span, msg)\n       }"}, {"sha": "979bb6e847a948a09affc0e1e43a40418ca8cf68", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -52,15 +52,15 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n                        self: @ast::expr, mentry: typeck::method_map_entry)\n     -> lval_maybe_callee {\n     let _icx = bcx.insn_ctxt(~\"impl::trans_method_callee\");\n-    alt mentry.origin {\n+    match mentry.origin {\n       typeck::method_static(did) => {\n         let {bcx, val} = trans_self_arg(bcx, self, mentry.derefs);\n         {env: self_env(val, node_id_type(bcx, self.id), none)\n          with lval_static_fn(bcx, did, callee_id)}\n       }\n       typeck::method_param({trait_id:iid, method_num:off,\n                             param_num:p, bound_num:b}) => {\n-        alt check bcx.fcx.param_substs {\n+        match check bcx.fcx.param_substs {\n           some(substs) => {\n             trans_monomorphized_callee(bcx, callee_id, self, mentry.derefs,\n                                        iid, off, p, b, substs)\n@@ -83,7 +83,7 @@ fn method_from_methods(ms: ~[@ast::method], name: ast::ident)\n fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n                     name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n-        alt check ccx.tcx.items.get(impl_id.node) {\n+        match check ccx.tcx.items.get(impl_id.node) {\n           ast_map::node_item(@{node: ast::item_impl(_, _, _, ms), _}, _) => {\n             method_from_methods(ms, name)\n           }\n@@ -101,7 +101,7 @@ fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n fn method_ty_param_count(ccx: @crate_ctxt, m_id: ast::def_id,\n                          i_id: ast::def_id) -> uint {\n     if m_id.crate == ast::local_crate {\n-        alt check ccx.tcx.items.get(m_id.node) {\n+        match check ccx.tcx.items.get(m_id.node) {\n           ast_map::node_method(m, _, _) => vec::len(m.tps),\n         }\n     } else {\n@@ -116,7 +116,7 @@ fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n                               n_param: uint, n_bound: uint,\n                               substs: param_substs) -> lval_maybe_callee {\n     let _icx = bcx.insn_ctxt(~\"impl::trans_monomorphized_callee\");\n-    alt find_vtable_in_fn_ctxt(substs, n_param, n_bound) {\n+    match find_vtable_in_fn_ctxt(substs, n_param, n_bound) {\n       typeck::vtable_static(impl_did, impl_substs, sub_origins) => {\n         let ccx = bcx.ccx();\n         let mname = ty::trait_methods(ccx.tcx, trait_id)[n_method].ident;\n@@ -173,7 +173,7 @@ fn find_vtable_in_fn_ctxt(ps: param_substs, n_param: uint, n_bound: uint)\n     for vec::each(*ps.bounds) |bounds| {\n         if i >= n_param { break; }\n         for vec::each(*bounds) |bound| {\n-            alt bound { ty::bound_trait(_) => vtable_off += 1u, _ => () }\n+            match bound { ty::bound_trait(_) => vtable_off += 1u, _ => () }\n         }\n         i += 1u;\n     }\n@@ -189,9 +189,9 @@ fn resolve_vtables_in_fn_ctxt(fcx: fn_ctxt, vts: typeck::vtable_res)\n // eliminate any vtable_params.\n fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n     -> typeck::vtable_origin {\n-    alt vt {\n+    match vt {\n       typeck::vtable_static(iid, tys, sub) => {\n-        let tys = alt fcx.param_substs {\n+        let tys = match fcx.param_substs {\n           some(substs) => {\n             vec::map(tys, |t| ty::subst_tps(fcx.ccx.tcx, substs.tys, t))\n           }\n@@ -200,7 +200,7 @@ fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n         typeck::vtable_static(iid, tys, resolve_vtables_in_fn_ctxt(fcx, sub))\n       }\n       typeck::vtable_param(n_param, n_bound) => {\n-        alt check fcx.param_substs {\n+        match check fcx.param_substs {\n           some(substs) => {\n             find_vtable_in_fn_ctxt(substs, n_param, n_bound)\n           }\n@@ -211,7 +211,7 @@ fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n }\n \n fn vtable_id(ccx: @crate_ctxt, origin: typeck::vtable_origin) -> mono_id {\n-    alt check origin {\n+    match check origin {\n       typeck::vtable_static(impl_id, substs, sub_vtables) => {\n         make_mono_id(ccx, impl_id, substs,\n                      if (*sub_vtables).len() == 0u { none }\n@@ -227,9 +227,9 @@ fn vtable_id(ccx: @crate_ctxt, origin: typeck::vtable_origin) -> mono_id {\n fn get_vtable(ccx: @crate_ctxt, origin: typeck::vtable_origin)\n     -> ValueRef {\n     let hash_id = vtable_id(ccx, origin);\n-    alt ccx.vtables.find(hash_id) {\n+    match ccx.vtables.find(hash_id) {\n       some(val) => val,\n-      none => alt check origin {\n+      none => match check origin {\n         typeck::vtable_static(id, substs, sub_vtables) => {\n             make_impl_vtable(ccx, id, substs, sub_vtables)\n         }"}, {"sha": "9637b5b7ce5f4ce0fb8f9ae817ef047280ecd055", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -34,11 +34,11 @@ fn find_reachable(crate_mod: _mod, exp_map: resolve3::ExportMap,\n fn traverse_exports(cx: ctx, vis: ~[@view_item]) -> bool {\n     let mut found_export = false;\n     for vec::each(vis) |vi| {\n-        alt vi.node {\n+        match vi.node {\n           view_item_export(vps) => {\n             found_export = true;\n             for vec::each(vps) |vp| {\n-                alt vp.node {\n+                match vp.node {\n                   view_path_simple(_, _, id) | view_path_glob(_, id) |\n                   view_path_list(_, _, id) => {\n                     traverse_export(cx, id);\n@@ -60,11 +60,11 @@ fn traverse_export(cx: ctx, exp_id: node_id) {\n \n fn traverse_def_id(cx: ctx, did: def_id) {\n     if did.crate != local_crate { return; }\n-    let n = alt cx.tcx.items.find(did.node) {\n+    let n = match cx.tcx.items.find(did.node) {\n         none => return, // This can happen for self, for example\n         some(n) => n\n     };\n-    alt n {\n+    match n {\n       ast_map::node_item(item, _) => traverse_public_item(cx, item),\n       ast_map::node_method(_, impl_id, _) => traverse_def_id(cx, impl_id),\n       ast_map::node_foreign_item(item, _, _) => {\n@@ -89,7 +89,7 @@ fn traverse_public_mod(cx: ctx, m: _mod) {\n fn traverse_public_item(cx: ctx, item: @item) {\n     if cx.rmap.contains_key(item.id) { return; }\n     cx.rmap.insert(item.id, ());\n-    alt item.node {\n+    match item.node {\n       item_mod(m) => traverse_public_mod(cx, m),\n       item_foreign_mod(nm) => {\n           if !traverse_exports(cx, nm.view_items) {\n@@ -127,7 +127,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n             }\n         }\n         for vec::each(items) |item| {\n-            alt item.node {\n+            match item.node {\n               class_method(m) => {\n                 cx.rmap.insert(m.id, ());\n                 if tps.len() > 0u ||\n@@ -156,9 +156,9 @@ fn traverse_ty(ty: @ty, cx: ctx, v: visit::vt<ctx>) {\n     if cx.rmap.contains_key(ty.id) { return; }\n     cx.rmap.insert(ty.id, ());\n \n-    alt ty.node {\n+    match ty.node {\n       ty_path(p, p_id) => {\n-        alt cx.tcx.def_map.find(p_id) {\n+        match cx.tcx.def_map.find(p_id) {\n           // Kind of a hack to check this here, but I'm not sure what else\n           // to do\n           some(def_prim_ty(_)) => { /* do nothing */ }\n@@ -173,9 +173,9 @@ fn traverse_ty(ty: @ty, cx: ctx, v: visit::vt<ctx>) {\n \n fn traverse_inline_body(cx: ctx, body: blk) {\n     fn traverse_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n-        alt e.node {\n+        match e.node {\n           expr_path(_) => {\n-            alt cx.tcx.def_map.find(e.id) {\n+            match cx.tcx.def_map.find(e.id) {\n                 some(d) => {\n                   traverse_def_id(cx, def_id_of_def(d));\n                 }\n@@ -184,7 +184,7 @@ fn traverse_inline_body(cx: ctx, body: blk) {\n             }\n           }\n           expr_field(_, _, _) => {\n-            alt cx.method_map.find(e.id) {\n+            match cx.method_map.find(e.id) {\n               some({origin: typeck::method_static(did), _}) => {\n                 traverse_def_id(cx, did);\n               }\n@@ -213,7 +213,7 @@ fn traverse_all_resources_and_impls(cx: ctx, crate_mod: _mod) {\n         visit_expr: |_e, _cx, _v| { },\n         visit_item: |i, cx, v| {\n             visit::visit_item(i, cx, v);\n-            alt i.node {\n+            match i.node {\n               item_class(_, _, _, _, some(_)) => {\n                 traverse_public_item(cx, i);\n               }"}, {"sha": "fbcb01ff68e76d0efb5d1dd40aae3842f76adeec", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -91,7 +91,7 @@ impl methods for reflector {\n     fn vstore_name_and_extra(t: ty::t,\n                              vstore: ty::vstore,\n                              f: fn(~str,~[ValueRef])) {\n-        alt vstore {\n+        match vstore {\n           ty::vstore_fixed(n) => {\n             let extra = vec::append(~[self.c_uint(n)],\n                                     self.c_size_and_align(t));\n@@ -114,7 +114,7 @@ impl methods for reflector {\n         debug!{\"reflect::visit_ty %s\",\n                ty_to_str(bcx.ccx().tcx, t)};\n \n-        alt ty::get(t).struct {\n+        match ty::get(t).struct {\n           ty::ty_bot => self.leaf(~\"bot\"),\n           ty::ty_nil => self.leaf(~\"nil\"),\n           ty::ty_bool => self.leaf(~\"bool\"),\n@@ -178,19 +178,19 @@ impl methods for reflector {\n           // FIXME (#2594): fetch constants out of intrinsic:: for the\n           // numbers.\n           ty::ty_fn(fty) => {\n-            let pureval = alt fty.purity {\n+            let pureval = match fty.purity {\n               ast::pure_fn => 0u,\n               ast::unsafe_fn => 1u,\n               ast::impure_fn => 2u,\n               ast::extern_fn => 3u\n             };\n-            let protoval = alt fty.proto {\n+            let protoval = match fty.proto {\n               ast::proto_bare => 0u,\n               ast::proto_uniq => 2u,\n               ast::proto_box => 3u,\n               ast::proto_block => 4u\n             };\n-            let retval = alt fty.ret_style {\n+            let retval = match fty.ret_style {\n               ast::noreturn => 0u,\n               ast::return_val => 1u\n             };\n@@ -200,9 +200,9 @@ impl methods for reflector {\n                          self.c_uint(retval)];\n             self.visit(~\"enter_fn\", extra);\n             for fty.inputs.eachi |i, arg| {\n-                let modeval = alt arg.mode {\n+                let modeval = match arg.mode {\n                   ast::infer(_) => 0u,\n-                  ast::expl(e) => alt e {\n+                  ast::expl(e) => match e {\n                     ast::by_ref => 1u,\n                     ast::by_val => 2u,\n                     ast::by_mutbl_ref => 3u,\n@@ -274,7 +274,7 @@ impl methods for reflector {\n           ty::ty_type => self.leaf(~\"type\"),\n           ty::ty_opaque_box => self.leaf(~\"opaque_box\"),\n           ty::ty_opaque_closure_ptr(ck) => {\n-            let ckval = alt ck {\n+            let ckval = match ck {\n               ty::ck_block => 0u,\n               ty::ck_box => 1u,\n               ty::ck_uniq => 2u"}, {"sha": "2d57b71e68383a868879e36db72a0ab4223fc1bc", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -149,23 +149,23 @@ fn enum_kind(ccx: @crate_ctxt, did: ast::def_id) -> enum_kind {\n \n // Returns the code corresponding to the pointer size on this architecture.\n fn s_int(tcx: ty_ctxt) -> u8 {\n-    return alt tcx.sess.targ_cfg.arch {\n+    return match tcx.sess.targ_cfg.arch {\n         session::arch_x86 => shape_i32,\n         session::arch_x86_64 => shape_i64,\n         session::arch_arm => shape_i32\n     };\n }\n \n fn s_uint(tcx: ty_ctxt) -> u8 {\n-    return alt tcx.sess.targ_cfg.arch {\n+    return match tcx.sess.targ_cfg.arch {\n         session::arch_x86 => shape_u32,\n         session::arch_x86_64 => shape_u64,\n         session::arch_arm => shape_u32\n     };\n }\n \n fn s_float(tcx: ty_ctxt) -> u8 {\n-    return alt tcx.sess.targ_cfg.arch {\n+    return match tcx.sess.targ_cfg.arch {\n         session::arch_x86 => shape_f64,\n         session::arch_x86_64 => shape_f64,\n         session::arch_arm => shape_f64\n@@ -213,7 +213,7 @@ fn add_substr(&dest: ~[u8], src: ~[u8]) {\n }\n \n fn shape_of(ccx: @crate_ctxt, t: ty::t) -> ~[u8] {\n-    alt ty::get(t).struct {\n+    match ty::get(t).struct {\n       ty::ty_nil | ty::ty_bool | ty::ty_uint(ast::ty_u8) |\n       ty::ty_bot => ~[shape_u8],\n       ty::ty_int(ast::ty_i) => ~[s_int(ccx.tcx)],\n@@ -233,13 +233,13 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> ~[u8] {\n         shape_of(ccx, tvec::expand_boxed_vec_ty(ccx.tcx, t))\n       }\n       ty::ty_enum(did, substs) => {\n-        alt enum_kind(ccx, did) {\n+        match enum_kind(ccx, did) {\n           tk_unit => ~[s_variant_enum_t(ccx.tcx)],\n           tk_enum => ~[s_variant_enum_t(ccx.tcx)],\n           tk_newtype | tk_complex => {\n             let mut s = ~[shape_enum], id;\n             let nom_id = mk_nominal_id(ccx.tcx, did, none, substs.tps);\n-            alt ccx.shape_cx.tag_id_to_index.find(nom_id) {\n+            match ccx.shape_cx.tag_id_to_index.find(nom_id) {\n               none => {\n                 id = ccx.shape_cx.next_tag_id;\n                 ccx.shape_cx.tag_id_to_index.insert(nom_id, id);\n@@ -678,7 +678,7 @@ fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n // Computes the size of the data part of an enum.\n fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n     if cx.enum_sizes.contains_key(t) { return cx.enum_sizes.get(t); }\n-    alt ty::get(t).struct {\n+    match ty::get(t).struct {\n       ty::ty_enum(tid, substs) => {\n         // Compute max(variant sizes).\n         let mut max_size = 0u;\n@@ -712,7 +712,7 @@ fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n         ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx), mutbl: ast::m_imm})\n     }\n     fn simplifier(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n-        alt ty::get(typ).struct {\n+        match ty::get(typ).struct {\n           ty::ty_box(_) | ty::ty_opaque_box | ty::ty_uniq(_) |\n           ty::ty_evec(_, ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_box) |\n           ty::ty_estr(ty::vstore_uniq) | ty::ty_estr(ty::vstore_box) |"}, {"sha": "aa92c96a686819831a37c91adb66a88813b71662", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -19,7 +19,7 @@ import util::ppaux::ty_to_str;\n fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     let unit_ty = ty::sequence_element_type(tcx, t);\n     let unboxed_vec_ty = ty::mk_mut_unboxed_vec(tcx, unit_ty);\n-    alt ty::get(t).struct {\n+    match ty::get(t).struct {\n       ty::ty_estr(ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_uniq) => {\n         ty::mk_imm_uniq(tcx, unboxed_vec_ty)\n       }\n@@ -156,10 +156,10 @@ fn trans_evec(bcx: block, elements: evec_elements,\n     let unit_sz = llsize_of(ccx, llunitty);\n \n     let mut {bcx, val, dataptr} =\n-        alt vst {\n+        match vst {\n           ast::vstore_fixed(_) => {\n             // Destination should be pre-allocated for us.\n-            let v = alt dest {\n+            let v = match dest {\n               base::save_in(v) => {\n                 PointerCast(bcx, v, T_ptr(llunitty))\n               }\n@@ -245,7 +245,7 @@ fn trans_evec(bcx: block, elements: evec_elements,\n \n     for vec::each(temp_cleanups) |cln| { revoke_clean(bcx, cln); }\n \n-    alt vst {\n+    match vst {\n       ast::vstore_fixed(_) => {\n         // We wrote into the destination in the fixed case.\n         return bcx;\n@@ -261,7 +261,7 @@ fn trans_evec(bcx: block, elements: evec_elements,\n \n fn trans_vstore(bcx: block, e: @ast::expr,\n                 v: ast::vstore, dest: dest) -> block {\n-    alt e.node {\n+    match e.node {\n       ast::expr_lit(@{node: ast::lit_str(s), span: _}) => {\n         return trans_estr(bcx, s, some(v), dest);\n       }\n@@ -288,12 +288,12 @@ fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n     let llunitty = type_of::type_of(ccx, unit_ty);\n     let unit_sz = llsize_of(ccx, llunitty);\n \n-    let vstore = alt ty::get(vec_ty).struct {\n+    let vstore = match ty::get(vec_ty).struct {\n       ty::ty_estr(vst) | ty::ty_evec(_, vst) => vst,\n       _ => ty::vstore_uniq\n     };\n \n-    alt vstore {\n+    match vstore {\n       ty::vstore_fixed(n) => {\n         let base = GEPi(cx, v, ~[0u, 0u]);\n         let n = if ty::type_is_str(e_ty) { n + 1u } else { n };\n@@ -319,7 +319,7 @@ fn trans_estr(bcx: block, s: @~str, vstore: option<ast::vstore>,\n     if dest == base::ignore { return bcx; }\n     let ccx = bcx.ccx();\n \n-    let c = alt vstore {\n+    let c = match vstore {\n       some(ast::vstore_fixed(_)) => {\n         // \"hello\"/_  =>  \"hello\"/5  =>  ~[i8 x 6] in llvm\n         debug!{\"trans_estr: fixed: %s\", *s};"}, {"sha": "73daa654d28d2be82c589cb64f5b18a85f701c26", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -17,7 +17,7 @@ fn type_of_explicit_args(cx: @crate_ctxt,\n     do vec::map(inputs) |arg| {\n         let arg_ty = arg.ty;\n         let llty = type_of(cx, arg_ty);\n-        alt ty::resolved_mode(cx.tcx, arg.mode) {\n+        match ty::resolved_mode(cx.tcx, arg.mode) {\n           ast::by_val => llty,\n           _ => T_ptr(llty)\n         }\n@@ -51,7 +51,7 @@ fn type_of_non_gc_box(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     if t != t_norm {\n         type_of_non_gc_box(cx, t_norm)\n     } else {\n-        alt ty::get(t).struct {\n+        match ty::get(t).struct {\n           ty::ty_box(mt) => {\n             T_ptr(T_box(cx, type_of(cx, mt.ty)))\n           }\n@@ -83,7 +83,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n         llty = type_of(cx, t_norm);\n         cx.lltypes.insert(t, llty);\n     } else {\n-        llty = alt ty::get(t).struct {\n+        llty = match ty::get(t).struct {\n           ty::ty_nil | ty::ty_bot => T_nil(),\n           ty::ty_bool => T_bool(),\n           ty::ty_int(t) => T_int_ty(cx, t),\n@@ -166,7 +166,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n         cx.lltypes.insert(t, llty);\n \n         // If this was a class, fill in the type now.\n-        alt ty::get(t).struct {\n+        match ty::get(t).struct {\n           ty::ty_class(did, ts) => {\n             // Only instance vars are record fields at runtime.\n             let fields = ty::lookup_class_fields(cx.tcx, did);\n@@ -225,7 +225,7 @@ fn type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t)\n }\n \n fn llvm_type_name(cx: @crate_ctxt, t: ty::t) -> ~str {\n-    let (name, did, tps) = alt check ty::get(t).struct {\n+    let (name, did, tps) = match check ty::get(t).struct {\n       ty::ty_enum(did, substs) => (~\"enum\", did, substs.tps),\n       ty::ty_class(did, substs) => (~\"class\", did, substs.tps)\n     };"}, {"sha": "b7f9fdc459dba31f0f5ba29aa296b21328df754c", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -35,7 +35,7 @@ type ctx = {ccx: @crate_ctxt,\n \n fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n     -> ~[type_uses] {\n-    alt ccx.type_use_cache.find(fn_id) {\n+    match ccx.type_use_cache.find(fn_id) {\n       some(uses) => return uses,\n       none => ()\n     }\n@@ -45,7 +45,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n     ccx.type_use_cache.insert(fn_id, vec::from_elem(n_tps, 3u));\n \n     let cx = {ccx: ccx, uses: vec::to_mut(vec::from_elem(n_tps, 0u))};\n-    alt ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).struct {\n+    match ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).struct {\n       ty::ty_fn({inputs, _}) => {\n         for vec::each(inputs) |arg| {\n             if arg.mode == expl(by_val) { type_needs(cx, use_repr, arg.ty); }\n@@ -59,12 +59,12 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n         ccx.type_use_cache.insert(fn_id, uses);\n         return uses;\n     }\n-    let map_node = alt ccx.tcx.items.find(fn_id_loc.node) {\n+    let map_node = match ccx.tcx.items.find(fn_id_loc.node) {\n         some(x) => x,\n         none    => ccx.sess.bug(fmt!{\"type_uses_for: unbound item ID %?\",\n                                      fn_id_loc})\n     };\n-    alt check map_node {\n+    match check map_node {\n       ast_map::node_item(@{node: item_fn(_, _, body), _}, _) |\n       ast_map::node_method(@{body, _}, _, _) => {\n         handle_body(cx, body);\n@@ -75,7 +75,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n       ast_map::node_foreign_item(i@@{node: foreign_item_fn(_, _), _},\n                                  abi, _) => {\n         if abi == foreign_abi_rust_intrinsic {\n-            let flags = alt check *i.ident {\n+            let flags = match check *i.ident {\n               ~\"size_of\" |  ~\"pref_align_of\" | ~\"min_align_of\" |\n               ~\"init\" |  ~\"reinterpret_cast\" |\n               ~\"move_val\" | ~\"move_val_init\" => {\n@@ -120,7 +120,7 @@ fn type_needs_inner(cx: ctx, use: uint, ty: ty::t,\n                     enums_seen: @list<def_id>) {\n     do ty::maybe_walk_ty(ty) |ty| {\n         if ty::type_has_params(ty) {\n-            alt ty::get(ty).struct {\n+            match ty::get(ty).struct {\n                 /*\n                  This previously included ty_box -- that was wrong\n                  because if we cast an @T to an trait (for example) and return\n@@ -156,7 +156,7 @@ fn node_type_needs(cx: ctx, use: uint, id: node_id) {\n }\n \n fn mark_for_expr(cx: ctx, e: @expr) {\n-    alt e.node {\n+    match e.node {\n       expr_vstore(_, _) |\n       expr_vec(_, _) |\n       expr_rec(_, _) | expr_struct(*) | expr_tup(_) |\n@@ -168,7 +168,7 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n       }\n       expr_cast(base, _) => {\n         let result_t = ty::node_id_to_type(cx.ccx.tcx, e.id);\n-        alt ty::get(result_t).struct {\n+        match ty::get(result_t).struct {\n             ty::ty_trait(*) => {\n               // When we're casting to an trait, we need the\n               // tydesc for the expr that's being cast.\n@@ -178,7 +178,7 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n         }\n       }\n       expr_binary(op, lhs, _) => {\n-        alt op {\n+        match op {\n           eq | lt | le | ne | ge | gt => {\n             node_type_needs(cx, use_tydesc, lhs.id)\n           }\n@@ -195,7 +195,7 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n         }\n       }\n       expr_fn(*) | expr_fn_block(*) => {\n-        alt ty::ty_fn_proto(ty::expr_ty(cx.ccx.tcx, e)) {\n+        match ty::ty_fn_proto(ty::expr_ty(cx.ccx.tcx, e)) {\n           proto_bare | proto_uniq => {}\n           proto_box | proto_block => {\n             for vec::each(*freevars::get_freevars(cx.ccx.tcx, e.id)) |fv| {\n@@ -216,7 +216,7 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n         type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n \n         do option::iter(cx.ccx.maps.method_map.find(e.id)) |mth| {\n-            alt mth.origin {\n+            match mth.origin {\n               typeck::method_static(did) => {\n                 do option::iter(cx.ccx.tcx.node_type_substs.find(e.id)) |ts| {\n                     do vec::iter2(type_uses_for(cx.ccx, did, ts.len()), ts)\n@@ -235,7 +235,7 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n       }\n       expr_call(f, _, _) => {\n         vec::iter(ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, f.id)), |a| {\n-            alt a.mode {\n+            match a.mode {\n               expl(by_move) | expl(by_copy) | expl(by_val) => {\n                 type_needs(cx, use_repr, a.ty);\n               }"}, {"sha": "e66ae41e5c6441e70bb3dd3d57b07b80dd701f18", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -19,7 +19,7 @@ fn make_free_glue(bcx: block, vptr: ValueRef, t: ty::t)\n }\n \n fn content_ty(t: ty::t) -> ty::t {\n-    alt ty::get(t).struct {\n+    match ty::get(t).struct {\n       ty::ty_uniq({ty: ct, _}) => ct,\n       _ => core::unreachable()\n     }"}, {"sha": "19a2ca1572366d84176a8491999f52465c3193aa", "filename": "src/rustc/middle/tstate/ann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -240,7 +240,7 @@ fn implies(a: t, b: t) -> bool {\n }\n \n fn trit_str(t: trit) -> ~str {\n-    alt t { dont_care { ~\"?\" } ttrue { ~\"1\" } tfalse { ~\"0\" } }\n+    match t { dont_care { ~\"?\" } ttrue { ~\"1\" } tfalse { ~\"0\" } }\n }\n \n // FIXME (#2538): Would be nice to have unit tests for some of these"}, {"sha": "379546015ccd5e0107452adfbcdc7f23041b8ef6", "filename": "src/rustc/middle/tstate/annotate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -14,7 +14,7 @@ fn collect_ids_block(b: blk, rs: @mut ~[node_id]) {\n }\n \n fn collect_ids_stmt(s: @stmt, rs: @mut ~[node_id]) {\n-    alt s.node {\n+    match s.node {\n       stmt_decl(_, id) | stmt_expr(_, id) | stmt_semi(_, id) {\n         debug!{\"node_id %s\", int::str(id)};\n         debug!{\"%s\", stmt_to_str(*s)};"}, {"sha": "ce3b65db6ff3113215596df77057efd6c82f199e", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -39,7 +39,7 @@ fn comma_str(args: ~[@constr_arg_use]) -> ~str {\n     let mut comma = false;\n     for args.each |a| {\n         if comma { rslt += ~\", \"; } else { comma = true; }\n-        alt a.node {\n+        match a.node {\n           carg_base { rslt += ~\"*\"; }\n           carg_ident(i) { rslt += *i.ident; }\n           carg_lit(l) { rslt += lit_to_str(l); }\n@@ -59,7 +59,7 @@ fn tritv_to_str(fcx: fn_ctxt, v: tritv::t) -> ~str {\n     let mut s = ~\"\";\n     let mut comma = false;\n     for constraints(fcx).each |p| {\n-        alt v.get(p.bit_num) {\n+        match v.get(p.bit_num) {\n           dont_care { }\n           tt {\n             s +=\n@@ -261,7 +261,7 @@ fn get_ts_ann(ccx: crate_ctxt, i: node_id) -> option<ts_ann> {\n \n /********* utils ********/\n fn node_id_to_ts_ann(ccx: crate_ctxt, id: node_id) -> ts_ann {\n-    alt get_ts_ann(ccx, id) {\n+    match get_ts_ann(ccx, id) {\n       none {\n         error!{\"node_id_to_ts_ann: no ts_ann for node_id %d\", id};\n         fail;\n@@ -277,7 +277,7 @@ fn node_id_to_poststate(ccx: crate_ctxt, id: node_id) -> poststate {\n \n fn stmt_to_ann(ccx: crate_ctxt, s: stmt) -> ts_ann {\n     debug!{\"stmt_to_ann\"};\n-    alt s.node {\n+    match s.node {\n       stmt_decl(_, id) | stmt_expr(_, id) | stmt_semi(_, id) {\n         return node_id_to_ts_ann(ccx, id);\n       }\n@@ -445,21 +445,21 @@ fn new_crate_ctxt(cx: ty::ctxt) -> crate_ctxt {\n  If it has a function type with a ! annotation,\n the answer is noreturn. */\n fn controlflow_expr(ccx: crate_ctxt, e: @expr) -> ret_style {\n-    alt ty::get(ty::node_id_to_type(ccx.tcx, e.id)).struct {\n+    match ty::get(ty::node_id_to_type(ccx.tcx, e.id)).struct {\n       ty::ty_fn(f) { return f.ret_style; }\n       _ { return return_val; }\n     }\n }\n \n fn constraints_expr(cx: ty::ctxt, e: @expr) -> ~[@ty::constr] {\n-    alt ty::get(ty::node_id_to_type(cx, e.id)).struct {\n+    match ty::get(ty::node_id_to_type(cx, e.id)).struct {\n       ty::ty_fn(f) { return f.constraints; }\n       _ { return ~[]; }\n     }\n }\n \n fn node_id_to_def_strict(cx: ty::ctxt, id: node_id) -> def {\n-    alt cx.def_map.find(id) {\n+    match cx.def_map.find(id) {\n       none {\n         error!{\"node_id_to_def: node_id %d has no def\", id};\n         fail;\n@@ -511,7 +511,7 @@ fn match_args(fcx: fn_ctxt, occs: @dvec<pred_args>,\n }\n \n fn def_id_for_constr(tcx: ty::ctxt, t: node_id) -> def_id {\n-    alt tcx.def_map.find(t) {\n+    match tcx.def_map.find(t) {\n       none {\n         tcx.sess.bug(~\"node_id_for_constr: bad node_id \" + int::str(t));\n       }\n@@ -521,9 +521,9 @@ fn def_id_for_constr(tcx: ty::ctxt, t: node_id) -> def_id {\n }\n \n fn expr_to_constr_arg(tcx: ty::ctxt, e: @expr) -> @constr_arg_use {\n-    alt e.node {\n+    match e.node {\n       expr_path(p) {\n-        alt tcx.def_map.find(e.id) {\n+        match tcx.def_map.find(e.id) {\n           some(def_local(nid, _)) | some(def_arg(nid, _)) |\n           some(def_binding(nid, _)) | some(def_upvar(nid, _, _)) {\n             return @respan(p.span,\n@@ -559,9 +559,9 @@ fn exprs_to_constr_args(tcx: ty::ctxt,\n }\n \n fn expr_to_constr(tcx: ty::ctxt, e: @expr) -> sp_constr {\n-    alt e.node {\n+    match e.node {\n       expr_call(operator, args, _) {\n-        alt operator.node {\n+        match operator.node {\n           expr_path(p) {\n             return respan(e.span,\n                        {path: p,\n@@ -601,7 +601,7 @@ fn substitute_constr_args(cx: ty::ctxt, actuals: ~[@expr], c: @ty::constr) ->\n fn substitute_arg(cx: ty::ctxt, actuals: ~[@expr], a: @constr_arg) ->\n    @constr_arg_use {\n     let num_actuals = vec::len(actuals);\n-    alt a.node {\n+    match a.node {\n       carg_ident(i) {\n         if i < num_actuals {\n             return expr_to_constr_arg(cx, actuals[i]);\n@@ -620,16 +620,16 @@ fn pred_args_matches(pattern: ~[constr_arg_general_<inst>],\n     let mut i = 0u;\n     for desc.node.args.each |c| {\n         let n = pattern[i];\n-        alt c.node {\n+        match c.node {\n           carg_ident(p) {\n-            alt n {\n+            match n {\n               carg_ident(q) { if p.node != q.node { return false; } }\n               _ { return false; }\n             }\n           }\n           carg_base { if n != carg_base { return false; } }\n           carg_lit(l) {\n-            alt n {\n+            match n {\n               carg_lit(m) { if !const_eval::lit_eq(l, m) { return false; } }\n               _ { return false; }\n             }\n@@ -669,7 +669,7 @@ fn find_instances(_fcx: fn_ctxt, subst: subst,\n             if args_mention(d.node.args, find_in_subst_bool, subst) {\n                 let old_bit_num = d.node.bit_num;\n                 let newv = replace(subst, d);\n-                alt find_instance_(newv, v) {\n+                match find_instance_(newv, v) {\n                   some(d1) {vec::push(res, {from: old_bit_num, to: d1})}\n                   _ {}\n                 }\n@@ -696,7 +696,7 @@ fn insts_to_str(stuff: ~[constr_arg_general_<inst>]) -> ~str {\n     for stuff.each |i| {\n         rslt +=\n             ~\" \" +\n-                alt i {\n+                match i {\n                   carg_ident(p) { *p.ident }\n                   carg_base { ~\"*\" }\n                   carg_lit(_) { ~\"~[lit]\" }\n@@ -709,9 +709,9 @@ fn insts_to_str(stuff: ~[constr_arg_general_<inst>]) -> ~str {\n fn replace(subst: subst, d: pred_args) -> ~[constr_arg_general_<inst>] {\n     let mut rslt: ~[constr_arg_general_<inst>] = ~[];\n     for d.node.args.each |c| {\n-        alt c.node {\n+        match c.node {\n           carg_ident(p) {\n-            alt find_in_subst(p.node, subst) {\n+            match find_in_subst(p.node, subst) {\n               some(newv) { vec::push(rslt, carg_ident(newv)); }\n               _ { vec::push(rslt, c.node); }\n             }\n@@ -736,7 +736,7 @@ fn for_constraints_mentioning(fcx: fn_ctxt, id: node_id,\n \n fn local_node_id_to_def_id_strict(fcx: fn_ctxt, sp: span, i: node_id) ->\n    def_id {\n-    alt local_node_id_to_def(fcx, i) {\n+    match local_node_id_to_def(fcx, i) {\n       some(def_local(nid, _)) | some(def_arg(nid, _)) |\n       some(def_upvar(nid, _, _)) {\n         return local_def(nid);\n@@ -760,7 +760,7 @@ fn local_node_id_to_def(fcx: fn_ctxt, i: node_id) -> option<def> {\n }\n \n fn local_node_id_to_def_id(fcx: fn_ctxt, i: node_id) -> option<def_id> {\n-    alt local_node_id_to_def(fcx, i) {\n+    match local_node_id_to_def(fcx, i) {\n       some(def_local(nid, _)) | some(def_arg(nid, _)) |\n       some(def_binding(nid, _)) | some(def_upvar(nid, _, _)) {\n         some(local_def(nid))\n@@ -771,7 +771,7 @@ fn local_node_id_to_def_id(fcx: fn_ctxt, i: node_id) -> option<def_id> {\n \n fn local_node_id_to_local_def_id(fcx: fn_ctxt, i: node_id) ->\n    option<node_id> {\n-    alt local_node_id_to_def_id(fcx, i) {\n+    match local_node_id_to_def_id(fcx, i) {\n       some(did) { some(did.node) }\n       _ { none }\n     }\n@@ -798,7 +798,7 @@ fn copy_in_poststate_two(fcx: fn_ctxt, src_post: poststate,\n                          target_post: poststate, dest: inst, src: inst,\n                          ty: oper_type) {\n     let mut subst;\n-    alt ty {\n+    match ty {\n       oper_swap { subst = ~[{from: dest, to: src}, {from: src, to: dest}]; }\n       oper_assign_op {\n         return; // Don't do any propagation\n@@ -863,7 +863,7 @@ fn args_mention<T>(args: ~[@constr_arg_use],\n                    s: ~[T]) -> bool {\n \n     for args.each |a| {\n-        alt a.node {\n+        match a.node {\n           carg_ident(p1) { if q(s, p1.node) { return true; } } _ { }\n         }\n     }\n@@ -875,7 +875,7 @@ fn use_var(fcx: fn_ctxt, v: node_id) {\n }\n \n fn op_to_oper_ty(io: init_op) -> oper_type {\n-    alt io { init_move { oper_move } _ { oper_assign } }\n+    match io { init_move { oper_move } _ { oper_assign } }\n }\n \n // default function visitor\n@@ -894,7 +894,7 @@ fn args_to_constr_args(tcx: ty::ctxt, args: ~[arg],\n         vec::push(\n             actuals,\n             @respan(a.span,\n-                    alt a.node {\n+                    match a.node {\n                         carg_base { carg_base }\n                         carg_ident(i) {\n                             if i < num_args {\n@@ -945,7 +945,7 @@ fn locals_to_bindings(tcx: ty::ctxt, locals: ~[@local]) -> ~[binding] {\n fn callee_modes(fcx: fn_ctxt, callee: node_id) -> ~[mode] {\n     let ty = ty::type_autoderef(fcx.ccx.tcx,\n                                 ty::node_id_to_type(fcx.ccx.tcx, callee));\n-    alt ty::get(ty).struct {\n+    match ty::get(ty).struct {\n       ty::ty_fn({inputs: args, _}) {\n         let mut modes = ~[];\n         for args.each |arg| { vec::push(modes, arg.mode); }\n@@ -961,7 +961,7 @@ fn callee_modes(fcx: fn_ctxt, callee: node_id) -> ~[mode] {\n \n fn callee_arg_init_ops(fcx: fn_ctxt, callee: node_id) -> ~[init_op] {\n     do vec::map(callee_modes(fcx, callee)) |m| {\n-        alt ty::resolved_mode(fcx.ccx.tcx, m) {\n+        match ty::resolved_mode(fcx.ccx.tcx, m) {\n           by_move { init_move }\n           by_copy | by_ref | by_val | by_mutbl_ref { init_assign }\n         }"}, {"sha": "6379e8898f732d5d4437800f0d0f70b716f92ba5", "filename": "src/rustc/middle/tstate/collect_locals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -13,7 +13,7 @@ import dvec::{dvec, extensions};\n type ctxt = {cs: @mut ~[sp_constr], tcx: ty::ctxt};\n \n fn collect_pred(e: @expr, cx: ctxt, v: visit::vt<ctxt>) {\n-    alt e.node {\n+    match e.node {\n       expr_check(_, ch) { vec::push(*cx.cs, expr_to_constr(cx.tcx, ch)); }\n       expr_if_check(ex, _, _) {\n         vec::push(*cx.cs, expr_to_constr(cx.tcx, ex));\n@@ -58,7 +58,7 @@ fn add_constraint(tcx: ty::ctxt, c: sp_constr, next: uint, tbl: constr_map) ->\n              constraint_to_str(tcx, c) + ~\" |-> \" + uint::str(next));\n \n     let {path: p, def_id: d_id, args: args} = c.node;\n-    alt tbl.find(d_id) {\n+    match tbl.find(d_id) {\n       some(ct) {\n         (*ct.descs).push(respan(c.span, {args: args, bit_num: next}));\n       }"}, {"sha": "6036db54432368f89076aa35f68dfa237b206c6d", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -36,7 +36,7 @@ fn find_pre_post_method(ccx: crate_ctxt, m: @method) {\n }\n \n fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n-    alt i.node {\n+    match i.node {\n       item_const(_, e) {\n           // do nothing -- item_consts don't refer to local vars\n       }\n@@ -100,9 +100,9 @@ fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n                   maybe_alt: option<@expr>, id: node_id, chck: if_ty) {\n     find_pre_post_expr(fcx, antec);\n     find_pre_post_block(fcx, conseq);\n-    alt maybe_alt {\n+    match maybe_alt {\n       none {\n-        alt chck {\n+        match chck {\n           if_check {\n             let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n             gen(fcx, antec.id, c.node);\n@@ -135,7 +135,7 @@ fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n \n         /* Be sure to set the bit for the check condition here,\n          so that it's *not* set in the alternative. */\n-        alt chck {\n+        match chck {\n           if_check {\n             let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n             gen(fcx, antec.id, c.node);\n@@ -162,9 +162,9 @@ fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n \n fn gen_if_local(fcx: fn_ctxt, lhs: @expr, rhs: @expr, larger_id: node_id,\n                 new_var: node_id) {\n-    alt node_id_to_def(fcx.ccx, new_var) {\n+    match node_id_to_def(fcx.ccx, new_var) {\n       some(d) {\n-        alt d {\n+        match d {\n           def_local(nid, _) {\n             find_pre_post_expr(fcx, rhs);\n             let p = expr_pp(fcx.ccx, rhs);\n@@ -181,12 +181,12 @@ fn gen_if_local(fcx: fn_ctxt, lhs: @expr, rhs: @expr, larger_id: node_id,\n fn handle_update(fcx: fn_ctxt, parent: @expr, lhs: @expr, rhs: @expr,\n                  ty: oper_type) {\n     find_pre_post_expr(fcx, rhs);\n-    alt lhs.node {\n+    match lhs.node {\n       expr_path(p) {\n         let post = expr_postcond(fcx.ccx, parent);\n         let tmp = post.clone();\n \n-        alt ty {\n+        match ty {\n           oper_move {\n             if is_path(rhs) { forget_in_postcond(fcx, parent.id, rhs.id); }\n           }\n@@ -201,13 +201,13 @@ fn handle_update(fcx: fn_ctxt, parent: @expr, lhs: @expr, rhs: @expr,\n         }\n \n         gen_if_local(fcx, lhs, rhs, parent.id, lhs.id);\n-        alt rhs.node {\n+        match rhs.node {\n           expr_path(p1) {\n             let d = local_node_id_to_local_def_id(fcx, lhs.id);\n             let d1 = local_node_id_to_local_def_id(fcx, rhs.id);\n-            alt d {\n+            match d {\n               some(id) {\n-                alt d1 {\n+                match d1 {\n                   some(id1) {\n                     let instlhs =\n                         {ident: path_to_ident(p), node: id};\n@@ -232,7 +232,7 @@ fn handle_update(fcx: fn_ctxt, parent: @expr, lhs: @expr, rhs: @expr,\n fn forget_args_moved_in(fcx: fn_ctxt, parent: @expr, modes: ~[mode],\n                         operands: ~[@expr]) {\n     do vec::iteri(modes) |i,mode| {\n-        alt ty::resolved_mode(fcx.ccx.tcx, mode) {\n+        match ty::resolved_mode(fcx.ccx.tcx, mode) {\n           by_move { forget_in_postcond(fcx, parent.id, operands[i].id); }\n           by_ref | by_val | by_mutbl_ref | by_copy { }\n         }\n@@ -251,7 +251,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n     fn do_rand_(fcx: fn_ctxt, e: @expr) { find_pre_post_expr(fcx, e); }\n \n \n-    alt e.node {\n+    match e.node {\n       expr_call(operator, operands, _) {\n         /* copy */\n \n@@ -270,7 +270,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n                              operands);\n \n         /* if this is a failing call, its postcondition sets everything */\n-        alt controlflow_expr(fcx.ccx, operator) {\n+        match controlflow_expr(fcx.ccx, operator) {\n           noreturn { set_postcond_false(fcx.ccx, e.id); }\n           _ { }\n         }\n@@ -315,7 +315,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       }\n       expr_rec(fields, maybe_base) {\n         let mut es = field_exprs(fields);\n-        alt maybe_base { none {/* no-op */ } some(b) { vec::push(es, b); } }\n+        match maybe_base { none {/* no-op */ } some(b) { vec::push(es, b); } }\n         find_pre_post_exprs(fcx, es, e.id);\n       }\n       expr_tup(elts) { find_pre_post_exprs(fcx, elts, e.id); }\n@@ -331,7 +331,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       }\n       expr_lit(_) { clear_pp(expr_pp(fcx.ccx, e)); }\n       expr_ret(maybe_val) {\n-        alt maybe_val {\n+        match maybe_val {\n           none {\n             clear_precond(fcx.ccx, e.id);\n             set_postcond_false(fcx.ccx, e.id);\n@@ -391,7 +391,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       expr_alt(ex, alts, _) {\n         find_pre_post_expr(fcx, ex);\n         fn do_an_alt(fcx: fn_ctxt, an_alt: arm) -> pre_and_post {\n-            alt an_alt.guard {\n+            match an_alt.guard {\n               some(e) { find_pre_post_expr(fcx, e); }\n               _ {}\n             }\n@@ -422,7 +422,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       }\n       expr_fail(maybe_val) {\n         let mut prestate;\n-        alt maybe_val {\n+        match maybe_val {\n           none { prestate = empty_prestate(num_local_vars); }\n           some(fail_val) {\n             find_pre_post_expr(fcx, fail_val);\n@@ -453,13 +453,13 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n \n fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n     debug!{\"stmt = %s\", stmt_to_str(s)};\n-    alt s.node {\n+    match s.node {\n       stmt_decl(adecl, id) {\n-        alt adecl.node {\n+        match adecl.node {\n           decl_local(alocals) {\n             let prev_pp = empty_pre_post(num_constraints(fcx.enclosing));\n             for alocals.each |alocal| {\n-                alt alocal.node.init {\n+                match alocal.node.init {\n                   some(an_init) {\n                     /* LHS always becomes initialized,\n                      whether or not this is a move */\n@@ -473,15 +473,15 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                     copy_pre_post(fcx.ccx, id, an_init.expr);\n \n                     let mut p = none;\n-                    alt an_init.expr.node {\n+                    match an_init.expr.node {\n                       expr_path(_p) { p = some(_p); }\n                       _ { }\n                     }\n \n                     do pat_bindings(fcx.ccx.tcx.def_map, alocal.node.pat)\n                         |p_id, _s, n| {\n                         let ident = path_to_ident(n);\n-                        alt p {\n+                        match p {\n                           some(p) {\n                             copy_in_postcond(fcx, id,\n                                              {ident: ident, node: p_id},\n@@ -557,7 +557,7 @@ fn find_pre_post_block(fcx: fn_ctxt, b: blk) {\n \n     let mut pps: ~[pre_and_post] = ~[];\n     for b.node.stmts.each |s| { vec::push(pps, stmt_pp(fcx.ccx, *s)); }\n-    alt b.node.expr {\n+    match b.node.expr {\n       none {/* no-op */ }\n       some(e) { vec::push(pps, expr_pp(fcx.ccx, e)); }\n     }\n@@ -584,7 +584,7 @@ fn find_pre_post_fn(fcx: fn_ctxt, body: blk) {\n     find_pre_post_block(fcx, body);\n \n     // Treat the tail expression as a return statement\n-    alt body.node.expr {\n+    match body.node.expr {\n       some(tailexpr) { set_postcond_false(fcx.ccx, tailexpr.id); }\n       none {/* fallthrough */ }\n     }"}, {"sha": "9c4191fc20a2dc132a2a64e0fcd65c34f9707744", "filename": "src/rustc/middle/tstate/states.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -15,9 +15,9 @@ import driver::session::session;\n import std::map::hashmap;\n \n fn forbid_upvar(fcx: fn_ctxt, rhs_id: node_id, sp: span, t: oper_type) {\n-    alt t {\n+    match t {\n       oper_move {\n-        alt local_node_id_to_def(fcx, rhs_id) {\n+        match local_node_id_to_def(fcx, rhs_id) {\n           some(def_upvar(_, _, _)) {\n             fcx.ccx.tcx.sess.span_err(sp,\n                                       ~\"tried to deinitialize a variable \\\n@@ -35,12 +35,12 @@ fn handle_move_or_copy(fcx: fn_ctxt, post: poststate, rhs_path: @path,\n     forbid_upvar(fcx, rhs_id, rhs_path.span, op_to_oper_ty(init_op));\n \n     let rhs_d_id = local_node_id_to_def_id(fcx, rhs_id);\n-    alt rhs_d_id {\n+    match rhs_d_id {\n       some(rhsid) {\n         // RHS is a local var\n         let instrhs =\n             {ident: path_to_ident(rhs_path), node: rhsid.node};\n-        alt destlhs {\n+        match destlhs {\n           local_dest(instlhs) {\n              copy_in_poststate(fcx, post, instlhs, instrhs,\n                                op_to_oper_ty(init_op));\n@@ -59,14 +59,14 @@ fn seq_states(fcx: fn_ctxt, pres: prestate, bindings: ~[binding]) ->\n     let mut changed = false;\n     let mut post = pres.clone();\n     for bindings.each |b| {\n-        alt b.rhs {\n+        match b.rhs {\n           some(an_init) {\n             // an expression, with or without a destination\n             changed |=\n                 find_pre_post_state_expr(fcx, post, an_init.expr) || changed;\n             post = expr_poststate(fcx.ccx, an_init.expr).clone();\n             for b.lhs.each |d| {\n-                alt an_init.expr.node {\n+                match an_init.expr.node {\n                   expr_path(p) {\n                     handle_move_or_copy(fcx, post, p, an_init.expr.id, d,\n                                         an_init.op);\n@@ -94,7 +94,7 @@ fn find_pre_post_state_sub(fcx: fn_ctxt, pres: prestate, e: @expr,\n     changed = set_prestate_ann(fcx.ccx, parent, pres) || changed;\n \n     let post = expr_poststate(fcx.ccx, e).clone();\n-    alt c {\n+    match c {\n       none { }\n       some(c1) { set_in_poststate_(bit_num(fcx, c1), post); }\n     }\n@@ -115,15 +115,15 @@ fn find_pre_post_state_two(fcx: fn_ctxt, pres: prestate, lhs: @expr,\n \n     let post = expr_poststate(fcx.ccx, rhs).clone();\n \n-    alt lhs.node {\n+    match lhs.node {\n       expr_path(p) {\n         // for termination, need to make sure intermediate changes don't set\n         // changed flag\n         // tmp remembers \"old\" constraints we'd otherwise forget,\n         // for substitution purposes\n         let tmp = post.clone();\n \n-        alt ty {\n+        match ty {\n           oper_move {\n             if is_path(rhs) { forget_in_poststate(fcx, post, rhs.id); }\n             forget_in_poststate(fcx, post, lhs.id);\n@@ -135,13 +135,13 @@ fn find_pre_post_state_two(fcx: fn_ctxt, pres: prestate, lhs: @expr,\n           _ { forget_in_poststate(fcx, post, lhs.id); }\n         }\n \n-        alt rhs.node {\n+        match rhs.node {\n           expr_path(p1) {\n             let d = local_node_id_to_local_def_id(fcx, lhs.id);\n             let d1 = local_node_id_to_local_def_id(fcx, rhs.id);\n-            alt d {\n+            match d {\n               some(id) {\n-                alt d1 {\n+                match d1 {\n                   some(id1) {\n                     let instlhs =\n                         {ident: path_to_ident(p), node: id};\n@@ -188,7 +188,7 @@ fn find_pre_post_state_exprs(fcx: fn_ctxt, pres: prestate, id: node_id,\n     let rs = seq_states(fcx, pres, arg_bindings(ops, es));\n     let mut changed = rs.changed | set_prestate_ann(fcx.ccx, id, pres);\n     /* if this is a failing call, it sets everything as initialized */\n-    alt cf {\n+    match cf {\n       noreturn {\n         let post = false_postcond(num_constraints(fcx.enclosing));\n         changed |= set_poststate_ann(fcx.ccx, id, post);\n@@ -205,9 +205,9 @@ fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n         set_prestate_ann(fcx.ccx, id, pres) |\n             find_pre_post_state_expr(fcx, pres, antec);\n \n-    alt maybe_alt {\n+    match maybe_alt {\n       none {\n-        alt chk {\n+        match chk {\n           if_check {\n             let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n             let conseq_prestate = expr_poststate(fcx.ccx, antec).clone();\n@@ -232,7 +232,7 @@ fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n                                      altern);\n \n         let mut conseq_prestate = expr_poststate(fcx.ccx, antec);\n-        alt chk {\n+        match chk {\n           if_check {\n             let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n             conseq_prestate = conseq_prestate.clone();\n@@ -282,7 +282,7 @@ fn find_pre_post_state_cap_clause(fcx: fn_ctxt, e_id: node_id,\n fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n     let num_constrs = num_constraints(fcx.enclosing);\n \n-    alt e.node {\n+    match e.node {\n       expr_new(p, _, v) {\n         return find_pre_post_state_two(fcx, pres, p, v, e.id, oper_pure);\n       }\n@@ -330,7 +330,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n                                                     init_assign),\n                                       exs, return_val);\n \n-        let base_pres = alt vec::last_opt(exs) { none { pres }\n+        let base_pres = match vec::last_opt(exs) { none { pres }\n                           some(f) { expr_poststate(fcx.ccx, f) }};\n         option::iter(maybe_base, |base| {\n             changed |= find_pre_post_state_expr(fcx, base_pres, base) |\n@@ -366,7 +366,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n \n         set_poststate_ann(fcx.ccx, e.id, post);\n \n-        alt maybe_ret_val {\n+        match maybe_ret_val {\n           none {/* do nothing */ }\n           some(ret_val) {\n             changed |= find_pre_post_state_expr(fcx, pres, ret_val);\n@@ -452,7 +452,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n         if vec::len(alts) > 0u {\n             a_post = false_postcond(num_constrs);\n             for alts.each |an_alt| {\n-                alt an_alt.guard {\n+                match an_alt.guard {\n                   some(e) {\n                     changed |= find_pre_post_state_expr(fcx, e_post, e);\n                   }\n@@ -512,9 +512,9 @@ fn find_pre_post_state_stmt(fcx: fn_ctxt, pres: prestate, s: @stmt) -> bool {\n     debug!{\"*prestate = %s\", stmt_ann.states.prestate.to_str()};\n     debug!{\"*poststate = %s\", stmt_ann.states.prestate.to_str()};\n \n-    alt s.node {\n+    match s.node {\n       stmt_decl(adecl, id) {\n-        alt adecl.node {\n+        match adecl.node {\n           decl_local(alocals) {\n             set_prestate(stmt_ann, pres);\n             let c_and_p = seq_states(fcx, pres,\n@@ -574,7 +574,7 @@ fn find_pre_post_state_block(fcx: fn_ctxt, pres0: prestate, b: blk) -> bool {\n         pres = stmt_poststate(fcx.ccx, *s);\n     }\n     let mut post = pres;\n-    alt b.node.expr {\n+    match b.node.expr {\n       none { }\n       some(e) {\n         changed |= find_pre_post_state_expr(fcx, pres, e);"}, {"sha": "b6110121171c18af7cff7948759cd9f9216b20f7", "filename": "src/rustc/middle/tstate/tritv.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -57,7 +57,7 @@ class t {\n     }\n     pure fn set(i: uint, t: trit) -> bool {\n         let old = self.get(i);\n-        alt t {\n+        match t {\n           dont_care {\n             self.uncertain.set(i, true);\n             self.val.set(i, false);\n@@ -103,7 +103,7 @@ class t {\n       let mut rslt: ~[uint] = ~[];\n       for uint::range(0, self.nbits) |i| {\n         vec::push(rslt,\n-                  alt self.get(i) {\n+                  match self.get(i) {\n                       dont_care { 2 }\n                       ttrue     { 1 }\n                       tfalse    { 0 }\n@@ -116,7 +116,7 @@ class t {\n        let mut rs: str = \"\";\n        for uint::range(0, self.nbits) |i| {\n         rs +=\n-            alt self.get(i) {\n+            match self.get(i) {\n               dont_care { \"?\" }\n               ttrue { \"1\" }\n               tfalse { \"0\" }\n@@ -177,10 +177,10 @@ fn minus(a: trit, b: trit) -> trit {\n          0 - 1 is an error\n          0 - anything else - 0\n      */\n-    alt a {\n+    match a {\n       dont_care { dont_care }\n       ttrue {\n-        alt b {\n+        match b {\n           ttrue { dont_care }\n           tfalse { ttrue }\n           /* internally contradictory, but\n@@ -191,7 +191,7 @@ fn minus(a: trit, b: trit) -> trit {\n         }\n       }\n       tfalse {\n-        alt b {\n+        match b {\n           ttrue { tfalse }\n           /* see above comment */\n           _ {\n@@ -203,11 +203,11 @@ fn minus(a: trit, b: trit) -> trit {\n     }\n \n fn trit_or(a: trit, b: trit) -> trit {\n-    alt a {\n+    match a {\n       dont_care { b }\n       ttrue { ttrue }\n       tfalse {\n-        alt b {\n+        match b {\n           ttrue { dont_care }\n           /* FIXME (#2538): ??????\n              Again, unit tests would help here\n@@ -226,11 +226,11 @@ fn trit_or(a: trit, b: trit) -> trit {\n // to make it so that all constraints start out in a 0 state\n // (we consider a constraint false until proven true), too.\n fn trit_and(a: trit, b: trit) -> trit {\n-    alt a {\n+    match a {\n       dont_care { b }\n       // also seems wrong for case b = ttrue\n       ttrue {\n-        alt b {\n+        match b {\n           dont_care { ttrue }\n           // ??? Seems wrong\n           ttrue {"}, {"sha": "814e0cc2f1575c6edc832706c50c21afd1209f9c", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 107, "deletions": 107, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -510,7 +510,7 @@ impl of purity_to_str for purity {\n fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n     let mut kind = kind_noncopyable();\n     for vec::each(*bounds) |bound| {\n-        alt bound {\n+        match bound {\n           bound_copy => {\n             kind = raise_kind(kind, kind_implicitly_copyable());\n           }\n@@ -608,14 +608,14 @@ fn mk_t(cx: ctxt, st: sty) -> t { mk_t_with_id(cx, st, none) }\n // and returns the box as cast to an unsafe ptr (see comments for t above).\n fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n     let key = {struct: st, o_def_id: o_def_id};\n-    alt cx.interner.find(key) {\n+    match cx.interner.find(key) {\n       some(t) => unsafe { return unsafe::reinterpret_cast(t); }\n       _ => ()\n     }\n     let mut flags = 0u;\n     fn rflags(r: region) -> uint {\n         (has_regions as uint) | {\n-            alt r {\n+            match r {\n               ty::re_var(_) => needs_infer as uint,\n               _ => 0u\n             }\n@@ -627,7 +627,7 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n         substs.self_r.iter(|r| f |= rflags(r));\n         return f;\n     }\n-    alt st {\n+    match st {\n       ty_estr(vstore_slice(r)) => {\n         flags |= rflags(r);\n       }\n@@ -786,7 +786,7 @@ fn mk_with_id(cx: ctxt, base: t, def_id: ast::def_id) -> t {\n \n // Converts s to its machine type equivalent\n pure fn mach_sty(cfg: @session::config, t: t) -> sty {\n-    alt get(t).struct {\n+    match get(t).struct {\n       ty_int(ast::ty_i) => ty_int(cfg.int_type),\n       ty_uint(ast::ty_u) => ty_uint(cfg.uint_type),\n       ty_float(ast::ty_f) => ty_float(cfg.float_type),\n@@ -802,7 +802,7 @@ fn default_arg_mode_for_ty(ty: ty::t) -> ast::rmode {\n // Returns the narrowest lifetime enclosing the evaluation of the expression\n // with id `id`.\n fn encl_region(cx: ctxt, id: ast::node_id) -> ty::region {\n-    alt cx.region_map.find(id) {\n+    match cx.region_map.find(id) {\n       some(encl_scope) => ty::re_scope(encl_scope),\n       none => ty::re_static\n     }\n@@ -814,7 +814,7 @@ fn walk_ty(ty: t, f: fn(t)) {\n \n fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n     if !f(ty) { return; }\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_estr(_) | ty_type | ty_opaque_box | ty_self |\n       ty_opaque_closure_ptr(_) | ty_var(_) | ty_var_integral(_) |\n@@ -851,7 +851,7 @@ fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n          tps: substs.tps.map(|t| fldop(t))}\n     }\n \n-    alt sty {\n+    match sty {\n       ty_box(tm) => {\n         ty_box({ty: fldop(tm.ty), mutbl: tm.mutbl})\n       }\n@@ -947,7 +947,7 @@ fn fold_regions_and_ty(\n     }\n \n     let tb = ty::get(ty);\n-    alt tb.struct {\n+    match tb.struct {\n       ty::ty_rptr(r, mt) => {\n         let m_r = fldr(r);\n         let m_t = fldt(mt.ty);\n@@ -1004,7 +1004,7 @@ fn fold_region(cx: ctxt, t0: t, fldop: fn(region, bool) -> region) -> t {\n                fldop: fn(region, bool) -> region) -> t {\n         let tb = get(t0);\n         if !tbox_has_flag(tb, has_regions) { return t0; }\n-        alt tb.struct {\n+        match tb.struct {\n           ty_rptr(r, {ty: t1, mutbl: m}) => {\n             let m_r = fldop(r, under_r);\n             let m_t1 = do_fold(cx, t1, true, fldop);\n@@ -1039,7 +1039,7 @@ fn subst_tps(cx: ctxt, tps: ~[t], typ: t) -> t {\n     if tps.len() == 0u { return typ; }\n     let tb = ty::get(typ);\n     if !tbox_has_flag(tb, has_params) { return typ; }\n-    alt tb.struct {\n+    match tb.struct {\n       ty_param(p) => tps[p.idx],\n       sty => fold_sty_to_ty(cx, sty, |t| subst_tps(cx, tps, t))\n     }\n@@ -1076,13 +1076,13 @@ fn subst(cx: ctxt,\n                 typ: t) -> t {\n         let tb = get(typ);\n         if !tbox_has_flag(tb, needs_subst) { return typ; }\n-        alt tb.struct {\n+        match tb.struct {\n           ty_param(p) => substs.tps[p.idx],\n           ty_self => substs.self_ty.get(),\n           _ => {\n             fold_regions_and_ty(\n                 cx, typ,\n-                |r| alt r {\n+                |r| match r {\n                     re_bound(br_self) => substs.self_r.get(),\n                     _ => r\n                 },\n@@ -1100,14 +1100,14 @@ fn type_is_nil(ty: t) -> bool { get(ty).struct == ty_nil }\n fn type_is_bot(ty: t) -> bool { get(ty).struct == ty_bot }\n \n fn type_is_var(ty: t) -> bool {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_var(_) => true,\n       _ => false\n     }\n }\n \n fn type_is_var_integral(ty: t) -> bool {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_var_integral(_) => true,\n       _ => false\n     }\n@@ -1116,7 +1116,7 @@ fn type_is_var_integral(ty: t) -> bool {\n fn type_is_bool(ty: t) -> bool { get(ty).struct == ty_bool }\n \n fn type_is_structural(ty: t) -> bool {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_rec(_) | ty_class(*) | ty_tup(_) | ty_enum(*) | ty_fn(_) |\n       ty_trait(*) |\n       ty_evec(_, vstore_fixed(_)) | ty_estr(vstore_fixed(_)) |\n@@ -1131,21 +1131,21 @@ fn type_is_copyable(cx: ctxt, ty: t) -> bool {\n }\n \n fn type_is_sequence(ty: t) -> bool {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_estr(_) | ty_evec(_, _) => true,\n       _ => false\n     }\n }\n \n fn type_is_str(ty: t) -> bool {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_estr(_) => true,\n       _ => false\n     }\n }\n \n fn sequence_element_type(cx: ctxt, ty: t) -> t {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_estr(_) => return mk_mach_uint(cx, ast::ty_u8),\n       ty_evec(mt, _) | ty_unboxed_vec(mt) => return mt.ty,\n       _ => cx.sess.bug(\n@@ -1154,66 +1154,66 @@ fn sequence_element_type(cx: ctxt, ty: t) -> t {\n }\n \n fn get_element_type(ty: t, i: uint) -> t {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_rec(flds) => return flds[i].mt.ty,\n       ty_tup(ts) => return ts[i],\n       _ => fail ~\"get_element_type called on invalid type\"\n     }\n }\n \n pure fn type_is_box(ty: t) -> bool {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_box(_) => return true,\n       _ => return false\n     }\n }\n \n pure fn type_is_boxed(ty: t) -> bool {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_box(_) | ty_opaque_box |\n       ty_evec(_, vstore_box) | ty_estr(vstore_box) => true,\n       _ => false\n     }\n }\n \n pure fn type_is_region_ptr(ty: t) -> bool {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_rptr(_, _) => true,\n       _ => false\n     }\n }\n \n pure fn type_is_slice(ty: t) -> bool {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_evec(_, vstore_slice(_)) | ty_estr(vstore_slice(_)) => true,\n       _ => return false\n     }\n }\n \n pure fn type_is_unique_box(ty: t) -> bool {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_uniq(_) => return true,\n       _ => return false\n     }\n }\n \n pure fn type_is_unsafe_ptr(ty: t) -> bool {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_ptr(_) => return true,\n       _ => return false\n     }\n }\n \n pure fn type_is_vec(ty: t) -> bool {\n-    return alt get(ty).struct {\n+    return match get(ty).struct {\n           ty_evec(_, _) | ty_unboxed_vec(_) => true,\n           ty_estr(_) => true,\n           _ => false\n         };\n }\n \n pure fn type_is_unique(ty: t) -> bool {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_uniq(_) => return true,\n       ty_evec(_, vstore_uniq) => true,\n       ty_estr(vstore_uniq) => true,\n@@ -1227,7 +1227,7 @@ pure fn type_is_unique(ty: t) -> bool {\n  contents are abstract to rustc.)\n */\n pure fn type_is_scalar(ty: t) -> bool {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_nil | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_var_integral(_) | ty_type | ty_ptr(_) => true,\n       _ => false\n@@ -1240,13 +1240,13 @@ fn type_is_immediate(ty: t) -> bool {\n }\n \n fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n-    alt cx.needs_drop_cache.find(ty) {\n+    match cx.needs_drop_cache.find(ty) {\n       some(result) => return result,\n       none => {/* fall through */ }\n     }\n \n     let mut accum = false;\n-    let result = alt get(ty).struct {\n+    let result = match get(ty).struct {\n       // scalar types\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_type | ty_ptr(_) | ty_rptr(_, _) |\n@@ -1286,7 +1286,7 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n         accum\n       }\n       ty_fn(fty) => {\n-        alt fty.proto {\n+        match fty.proto {\n           proto_bare | proto_block => false,\n           _ => true\n         }\n@@ -1303,7 +1303,7 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n // that only contain scalars and shared boxes can avoid unwind\n // cleanups.\n fn type_needs_unwind_cleanup(cx: ctxt, ty: t) -> bool {\n-    alt cx.needs_unwind_cleanup_cache.find(ty) {\n+    match cx.needs_unwind_cleanup_cache.find(ty) {\n       some(result) => return result,\n       none => ()\n     }\n@@ -1320,7 +1320,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n                               encountered_box: bool) -> bool {\n \n     // Prevent infinite recursion\n-    alt tycache.find(ty) {\n+    match tycache.find(ty) {\n       some(_) => return false,\n       none => { tycache.insert(ty, ()); }\n     }\n@@ -1329,7 +1329,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n     let mut needs_unwind_cleanup = false;\n     do maybe_walk_ty(ty) |ty| {\n         let old_encountered_box = encountered_box;\n-        let result = alt get(ty).struct {\n+        let result = match get(ty).struct {\n           ty_box(_) | ty_opaque_box => {\n             encountered_box = true;\n             true\n@@ -1528,7 +1528,7 @@ pure fn kind_is_owned(k: kind) -> bool {\n }\n \n fn proto_kind(p: proto) -> kind {\n-    alt p {\n+    match p {\n       ast::proto_block => kind_noncopyable(),\n       ast::proto_box => kind_safe_for_default_mode() | kind_owned(),\n       ast::proto_uniq => kind_send_copy() | kind_owned(),\n@@ -1571,7 +1571,7 @@ fn test_kinds() {\n // This is used to prevent objects containing mutable state from being\n // implicitly copied and to compute whether things have const kind.\n fn mutability_kind(m: mutability) -> kind {\n-    alt (m) {\n+    match (m) {\n       m_mutbl => remove_const(remove_implicit(kind_top())),\n       m_const => remove_implicit(kind_top()),\n       m_imm => kind_top()\n@@ -1583,15 +1583,15 @@ fn mutable_type_kind(cx: ctxt, ty: mt) -> kind {\n }\n \n fn type_kind(cx: ctxt, ty: t) -> kind {\n-    alt cx.kind_cache.find(ty) {\n+    match cx.kind_cache.find(ty) {\n       some(result) => return result,\n       none => {/* fall through */ }\n     }\n \n     // Insert a default in case we loop back on self recursively.\n     cx.kind_cache.insert(ty, kind_top());\n \n-    let mut result = alt get(ty).struct {\n+    let mut result = match get(ty).struct {\n       // Scalar and unique types are sendable, constant, and owned\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_ptr(_) => {\n@@ -1743,7 +1743,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n /// gives a rough estimate of how much space it takes to represent\n /// an instance of `ty`.  Used for the mode transition.\n fn type_size(cx: ctxt, ty: t) -> uint {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_ptr(_) | ty_box(_) | ty_uniq(_) | ty_estr(vstore_uniq) |\n       ty_trait(*) | ty_rptr(*) | ty_evec(_, vstore_uniq) |\n@@ -1828,7 +1828,7 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                ty_to_str(cx, r_ty),\n                ty_to_str(cx, ty)};\n \n-        let r = alt get(ty).struct {\n+        let r = match get(ty).struct {\n           ty_nil |\n           ty_bot |\n           ty_bool |\n@@ -1919,7 +1919,7 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n     let sty = get(ty).struct;\n     debug!{\"type_structurally_contains: %s\", ty_to_str(cx, ty)};\n     if test(sty) { return true; }\n-    alt sty {\n+    match sty {\n       ty_enum(did, substs) => {\n         for vec::each(*enum_variants(cx, did)) |variant| {\n             for variant.args.each |aty| {\n@@ -1960,7 +1960,7 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n \n fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n     return type_structurally_contains(cx, ty, |sty| {\n-        alt sty {\n+        match sty {\n           ty_uniq(_) |\n           ty_evec(_, vstore_uniq) |\n           ty_estr(vstore_uniq) => true,\n@@ -1970,14 +1970,14 @@ fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n }\n \n fn type_is_integral(ty: t) -> bool {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_var_integral(_) | ty_int(_) | ty_uint(_) | ty_bool => true,\n       _ => false\n     }\n }\n \n fn type_is_fp(ty: t) -> bool {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_float(_) => true,\n       _ => false\n     }\n@@ -1988,7 +1988,7 @@ fn type_is_numeric(ty: t) -> bool {\n }\n \n fn type_is_signed(ty: t) -> bool {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_int(_) => true,\n       _ => false\n     }\n@@ -1998,7 +1998,7 @@ fn type_is_signed(ty: t) -> bool {\n // that the cycle collector might care about.\n fn type_is_pod(cx: ctxt, ty: t) -> bool {\n     let mut result = true;\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       // Scalar types\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_type | ty_ptr(_) => result = true,\n@@ -2053,7 +2053,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n }\n \n fn type_is_enum(ty: t) -> bool {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_enum(_, _) => return true,\n       _ => return false\n     }\n@@ -2062,7 +2062,7 @@ fn type_is_enum(ty: t) -> bool {\n // Whether a type is enum like, that is a enum type with only nullary\n // constructors\n fn type_is_c_like_enum(cx: ctxt, ty: t) -> bool {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_enum(did, substs) => {\n         let variants = enum_variants(cx, did);\n         let some_n_ary = vec::any(*variants, |v| vec::len(v.args) > 0u);\n@@ -2073,7 +2073,7 @@ fn type_is_c_like_enum(cx: ctxt, ty: t) -> bool {\n }\n \n fn type_param(ty: t) -> option<uint> {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_param(p) => return some(p.idx),\n       _ => {/* fall through */ }\n     }\n@@ -2088,7 +2088,7 @@ fn deref(cx: ctxt, t: t, expl: bool) -> option<mt> {\n     deref_sty(cx, get(t).struct, expl)\n }\n fn deref_sty(cx: ctxt, sty: sty, expl: bool) -> option<mt> {\n-    alt sty {\n+    match sty {\n       ty_rptr(_, mt) | ty_box(mt) | ty_uniq(mt) => {\n         some(mt)\n       }\n@@ -2114,7 +2114,7 @@ fn deref_sty(cx: ctxt, sty: sty, expl: bool) -> option<mt> {\n fn type_autoderef(cx: ctxt, t: t) -> t {\n     let mut t = t;\n     loop {\n-        alt deref(cx, t, false) {\n+        match deref(cx, t, false) {\n           none => return t,\n           some(mt) => t = mt.ty\n         }\n@@ -2127,15 +2127,15 @@ fn index(cx: ctxt, t: t) -> option<mt> {\n }\n \n fn index_sty(cx: ctxt, sty: sty) -> option<mt> {\n-    alt sty {\n+    match sty {\n       ty_evec(mt, _) => some(mt),\n       ty_estr(_) => some({ty: mk_u8(cx), mutbl: ast::m_imm}),\n       _ => none\n     }\n }\n \n pure fn hash_bound_region(br: &bound_region) -> uint {\n-    alt *br { // no idea if this is any good\n+    match *br { // no idea if this is any good\n       ty::br_self => 0u,\n       ty::br_anon => 1u,\n       ty::br_named(str) => str::hash(str),\n@@ -2163,7 +2163,7 @@ pure fn hash_type_structure(st: sty) -> uint {\n         h\n     }\n     pure fn hash_region(r: &region) -> uint {\n-        alt *r { // no idea if this is any good\n+        match *r { // no idea if this is any good\n           re_bound(br) => (hash_bound_region(&br)) << 2u | 0u,\n           re_free(id, br) => ((id as uint) << 4u) |\n                                (hash_bound_region(&br)) << 2u | 1u,\n@@ -2176,25 +2176,25 @@ pure fn hash_type_structure(st: sty) -> uint {\n         let h = hash_subtys(h, substs.tps);\n         h + substs.self_r.map_default(0u, |r| hash_region(&r))\n     }\n-    alt st {\n+    match st {\n       ty_nil => 0u,\n       ty_bool => 1u,\n-      ty_int(t) => alt t {\n+      ty_int(t) => match t {\n         ast::ty_i => 2u,\n         ast::ty_char => 3u,\n         ast::ty_i8 => 4u,\n         ast::ty_i16 => 5u,\n         ast::ty_i32 => 6u,\n         ast::ty_i64 => 7u\n       }\n-      ty_uint(t) => alt t {\n+      ty_uint(t) => match t {\n         ast::ty_u => 8u,\n         ast::ty_u8 => 9u,\n         ast::ty_u16 => 10u,\n         ast::ty_u32 => 11u,\n         ast::ty_u64 => 12u\n       }\n-      ty_float(t) => alt t {\n+      ty_float(t) => match t {\n         ast::ty_f => 13u,\n         ast::ty_f32 => 14u,\n         ast::ty_f64 => 15u\n@@ -2246,15 +2246,15 @@ pure fn hash_type_structure(st: sty) -> uint {\n }\n \n fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n-    alt smallintmap::find(*cx.node_types, id as uint) {\n+    match smallintmap::find(*cx.node_types, id as uint) {\n        some(t) => t,\n        none => cx.sess.bug(fmt!{\"node_id_to_type: unbound node ID %s\",\n                                 ast_map::node_id_to_str(cx.items, id)})\n     }\n }\n \n fn node_id_to_type_params(cx: ctxt, id: ast::node_id) -> ~[t] {\n-    alt cx.node_type_substs.find(id) {\n+    match cx.node_type_substs.find(id) {\n       none => return ~[],\n       some(ts) => return ts\n     }\n@@ -2266,35 +2266,35 @@ fn node_id_has_type_params(cx: ctxt, id: ast::node_id) -> bool {\n \n // Type accessors for substructures of types\n fn ty_fn_args(fty: t) -> ~[arg] {\n-    alt get(fty).struct {\n+    match get(fty).struct {\n       ty_fn(f) => f.inputs,\n       _ => fail ~\"ty_fn_args() called on non-fn type\"\n     }\n }\n \n fn ty_fn_proto(fty: t) -> ast::proto {\n-    alt get(fty).struct {\n+    match get(fty).struct {\n       ty_fn(f) => f.proto,\n       _ => fail ~\"ty_fn_proto() called on non-fn type\"\n     }\n }\n \n pure fn ty_fn_ret(fty: t) -> t {\n-    alt get(fty).struct {\n+    match get(fty).struct {\n       ty_fn(f) => f.output,\n       _ => fail ~\"ty_fn_ret() called on non-fn type\"\n     }\n }\n \n fn ty_fn_ret_style(fty: t) -> ast::ret_style {\n-    alt get(fty).struct {\n+    match get(fty).struct {\n       ty_fn(f) => f.ret_style,\n       _ => fail ~\"ty_fn_ret_style() called on non-fn type\"\n     }\n }\n \n fn is_fn_ty(fty: t) -> bool {\n-    alt get(fty).struct {\n+    match get(fty).struct {\n       ty_fn(_) => return true,\n       _ => return false\n     }\n@@ -2312,14 +2312,14 @@ fn is_pred_ty(fty: t) -> bool {\n }\n \n fn ty_var_id(typ: t) -> tv_vid {\n-    alt get(typ).struct {\n+    match get(typ).struct {\n       ty_var(vid) => return vid,\n       _ => { error!{\"ty_var_id called on non-var ty\"}; fail; }\n     }\n }\n \n fn ty_var_integral_id(typ: t) -> tvi_vid {\n-    alt get(typ).struct {\n+    match get(typ).struct {\n       ty_var_integral(vid) => return vid,\n       _ => { error!{\"ty_var_integral_id called on ty other than \\\n                   ty_var_integral\"};\n@@ -2361,7 +2361,7 @@ fn expr_has_ty_params(cx: ctxt, expr: @ast::expr) -> bool {\n }\n \n fn expr_is_lval(method_map: typeck::method_map, e: @ast::expr) -> bool {\n-    alt e.node {\n+    match e.node {\n       ast::expr_path(_) | ast::expr_unary(ast::deref, _) => true,\n       ast::expr_field(_, _, _) | ast::expr_index(_, _) => {\n         !method_map.contains_key(e.id)\n@@ -2371,7 +2371,7 @@ fn expr_is_lval(method_map: typeck::method_map, e: @ast::expr) -> bool {\n }\n \n fn stmt_node_id(s: @ast::stmt) -> ast::node_id {\n-    alt s.node {\n+    match s.node {\n       ast::stmt_decl(_, id) | stmt_expr(_, id) | stmt_semi(_, id) => {\n         return id;\n       }\n@@ -2385,13 +2385,13 @@ fn field_idx(id: ast::ident, fields: ~[field]) -> option<uint> {\n }\n \n fn get_field(rec_ty: t, id: ast::ident) -> field {\n-    alt check vec::find(get_fields(rec_ty), |f| str::eq(f.ident, id)) {\n+    match check vec::find(get_fields(rec_ty), |f| str::eq(f.ident, id)) {\n       some(f) => f\n     }\n }\n \n fn get_fields(rec_ty:t) -> ~[field] {\n-    alt check get(rec_ty).struct {\n+    match check get(rec_ty).struct {\n       ty_rec(fields) => fields\n     }\n }\n@@ -2408,7 +2408,7 @@ fn method_idx(id: ast::ident, meths: ~[method]) -> option<uint> {\n fn param_tys_in_type(ty: t) -> ~[param_ty] {\n     let mut rslt = ~[];\n     do walk_ty(ty) |ty| {\n-        alt get(ty).struct {\n+        match get(ty).struct {\n           ty_param(p) => {\n             vec::push(rslt, p);\n           }\n@@ -2425,7 +2425,7 @@ fn occurs_check(tcx: ctxt, sp: span, vid: tv_vid, rt: t) {\n     fn vars_in_type(ty: t) -> ~[tv_vid] {\n         let mut rslt = ~[];\n         do walk_ty(ty) |ty| {\n-            alt get(ty).struct {\n+            match get(ty).struct {\n               ty_var(v) => vec::push(rslt, v),\n               _ => ()\n             }\n@@ -2454,8 +2454,8 @@ fn occurs_check(tcx: ctxt, sp: span, vid: tv_vid, rt: t) {\n // the current head value for `m0`.\n fn canon<T:copy>(tbl: hashmap<ast::node_id, ast::inferable<T>>,\n                  m0: ast::inferable<T>) -> ast::inferable<T> {\n-    alt m0 {\n-      ast::infer(id) => alt tbl.find(id) {\n+    match m0 {\n+      ast::infer(id) => match tbl.find(id) {\n         none => m0,\n         some(m1) => {\n             let cm1 = canon(tbl, m1);\n@@ -2477,7 +2477,7 @@ fn canon_mode(cx: ctxt, m0: ast::mode) -> ast::mode {\n // Returns the head value for mode, failing if `m` was a infer(_) that\n // was never inferred.  This should be safe for use after typeck.\n fn resolved_mode(cx: ctxt, m: ast::mode) -> ast::rmode {\n-    alt canon_mode(cx, m) {\n+    match canon_mode(cx, m) {\n       ast::infer(_) => {\n         cx.sess.bug(fmt!{\"mode %? was never resolved\", m});\n       }\n@@ -2490,7 +2490,7 @@ fn arg_mode(cx: ctxt, a: arg) -> ast::rmode { resolved_mode(cx, a.mode) }\n // Unifies `m1` and `m2`.  Returns unified value or failure code.\n fn unify_mode(cx: ctxt, m1: ast::mode, m2: ast::mode)\n     -> result<ast::mode, type_err> {\n-    alt (canon_mode(cx, m1), canon_mode(cx, m2)) {\n+    match (canon_mode(cx, m1), canon_mode(cx, m2)) {\n       (m1, m2) if (m1 == m2) => {\n         result::ok(m1)\n       }\n@@ -2511,7 +2511,7 @@ fn unify_mode(cx: ctxt, m1: ast::mode, m2: ast::mode)\n // If `m` was never unified, unifies it with `m_def`.  Returns the final value\n // for `m`.\n fn set_default_mode(cx: ctxt, m: ast::mode, m_def: ast::rmode) {\n-    alt canon_mode(cx, m) {\n+    match canon_mode(cx, m) {\n       ast::infer(id) => {\n         cx.inferred_modes.insert(id, ast::expl(m_def));\n       }\n@@ -2520,7 +2520,7 @@ fn set_default_mode(cx: ctxt, m: ast::mode, m_def: ast::rmode) {\n }\n \n fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n-    alt get(t).struct {\n+    match get(t).struct {\n       ty_nil | ty_bot | ty_bool | ty_int(_) |\n       ty_uint(_) | ty_float(_) | ty_estr(_) |\n       ty_type | ty_opaque_box | ty_opaque_closure_ptr(_) => {\n@@ -2548,14 +2548,14 @@ fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n \n fn type_err_to_str(cx: ctxt, err: type_err) -> ~str {\n     fn terr_vstore_kind_to_str(k: terr_vstore_kind) -> ~str {\n-        alt k { terr_vec => ~\"[]\", terr_str => ~\"str\" }\n+        match k { terr_vec => ~\"[]\", terr_str => ~\"str\" }\n     }\n \n-    alt err {\n+    match err {\n       terr_mismatch => return ~\"types differ\",\n       terr_ret_style_mismatch(expect, actual) => {\n         fn to_str(s: ast::ret_style) -> ~str {\n-            alt s {\n+            match s {\n               ast::noreturn => ~\"non-returning\",\n               ast::return_val => ~\"return-by-value\"\n             }\n@@ -2631,7 +2631,7 @@ fn type_err_to_str(cx: ctxt, err: type_err) -> ~str {\n }\n \n fn def_has_ty_params(def: ast::def) -> bool {\n-    alt def {\n+    match def {\n       ast::def_fn(_, _) | ast::def_variant(_, _) | ast::def_class(_, _)\n         => true,\n       _ => false\n@@ -2643,7 +2643,7 @@ fn store_trait_methods(cx: ctxt, id: ast::node_id, ms: @~[method]) {\n }\n \n fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n-    alt cx.trait_method_cache.find(id) {\n+    match cx.trait_method_cache.find(id) {\n       some(ms) => return ms,\n       _ => ()\n     }\n@@ -2657,7 +2657,7 @@ fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n fn impl_traits(cx: ctxt, id: ast::def_id) -> ~[t] {\n     if id.crate == ast::local_crate {\n         debug!{\"(impl_traits) searching for trait impl %?\", id};\n-        alt cx.items.find(id.node) {\n+        match cx.items.find(id.node) {\n            some(ast_map::node_item(@{\n                         node: ast::item_impl(_, trait_refs, _, _),\n                         _},\n@@ -2669,7 +2669,7 @@ fn impl_traits(cx: ctxt, id: ast::def_id) -> ~[t] {\n            }\n            some(ast_map::node_item(@{node: ast::item_class(*),\n                            _},_)) => {\n-             alt cx.def_map.find(id.node) {\n+             match cx.def_map.find(id.node) {\n                some(def_ty(trait_id)) => {\n                    // XXX: Doesn't work cross-crate.\n                    debug!{\"(impl_traits) found trait id %?\", trait_id};\n@@ -2692,7 +2692,7 @@ fn impl_traits(cx: ctxt, id: ast::def_id) -> ~[t] {\n }\n \n fn ty_to_def_id(ty: t) -> option<ast::def_id> {\n-    alt get(ty).struct {\n+    match get(ty).struct {\n       ty_trait(id, _) | ty_class(id, _) | ty_enum(id, _) => some(id),\n       _ => none\n     }\n@@ -2723,7 +2723,7 @@ fn item_path_str(cx: ctxt, id: ast::def_id) -> ~str {\n    Otherwise return none. */\n fn ty_dtor(cx: ctxt, class_id: def_id) -> option<def_id> {\n     if is_local(class_id) {\n-       alt cx.items.find(class_id.node) {\n+       match cx.items.find(class_id.node) {\n          some(ast_map::node_item(@{node: ast::item_class(_, _, _, _,\n                                      some(dtor)), _}, _))\n              => some(local_def(dtor.node.id)),\n@@ -2744,9 +2744,9 @@ fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n         csearch::get_item_path(cx, id)\n     } else {\n         let node = cx.items.get(id.node);\n-        alt node {\n+        match node {\n           ast_map::node_item(item, path) => {\n-            let item_elt = alt item.node {\n+            let item_elt = match item.node {\n               item_mod(_) | item_foreign_mod(_) => {\n                 ast_map::path_mod(item.ident)\n               }\n@@ -2796,14 +2796,14 @@ fn enum_is_univariant(cx: ctxt, id: ast::def_id) -> bool {\n }\n \n fn type_is_empty(cx: ctxt, t: t) -> bool {\n-    alt ty::get(t).struct {\n+    match ty::get(t).struct {\n        ty_enum(did, _) => (*enum_variants(cx, did)).is_empty(),\n        _ => false\n      }\n }\n \n fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[variant_info] {\n-    alt cx.enum_var_cache.find(id) {\n+    match cx.enum_var_cache.find(id) {\n       some(variants) => return variants,\n       _ => { /* fallthrough */ }\n     }\n@@ -2816,7 +2816,7 @@ fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[variant_info] {\n           call eval_const_expr, it should never get called twice for the same\n           expr, since check_enum_variants also updates the enum_var_cache\n          */\n-        alt cx.items.get(id.node) {\n+        match cx.items.get(id.node) {\n           ast_map::node_item(@{node: ast::item_enum(variants, _), _}, _) => {\n             let mut disr_val = -1;\n             @vec::map(variants, |variant| {\n@@ -2826,10 +2826,10 @@ fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[variant_info] {\n                         ty_fn_args(ctor_ty).map(|a| a.ty)\n                     } else { ~[] }\n                 };\n-                alt variant.node.disr_expr {\n+                match variant.node.disr_expr {\n                   some (ex) => {\n                     // FIXME: issue #1417\n-                    disr_val = alt const_eval::eval_const_expr(cx, ex) {\n+                    disr_val = match const_eval::eval_const_expr(cx, ex) {\n                       const_eval::const_int(val) =>val as int,\n                       _ => cx.sess.bug(~\"tag_variants: bad disr expr\")\n                     }\n@@ -2869,7 +2869,7 @@ fn enum_variant_with_id(cx: ctxt, enum_id: ast::def_id,\n // If the given item is in an external crate, looks up its type and adds it to\n // the type cache. Returns the type parameters and type.\n fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_bounds_and_ty {\n-    alt cx.tcache.find(did) {\n+    match cx.tcache.find(did) {\n       some(tpt) => return tpt,\n       none => {\n         // The item is in this crate. The caller should have added it to the\n@@ -2891,7 +2891,7 @@ fn lookup_field_type(tcx: ctxt, class_id: def_id, id: def_id,\n         node_id_to_type(tcx, id.node)\n     }\n     else {\n-        alt tcx.tcache.find(id) {\n+        match tcx.tcache.find(id) {\n            some(tpt) => tpt.ty,\n            none => {\n                let tpt = csearch::get_field_type(tcx, class_id, id);\n@@ -2907,9 +2907,9 @@ fn lookup_field_type(tcx: ctxt, class_id: def_id, id: def_id,\n // Fails if the id is not bound to a class.\n fn lookup_class_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n   if did.crate == ast::local_crate {\n-    alt cx.items.find(did.node) {\n+    match cx.items.find(did.node) {\n        some(ast_map::node_item(i,_)) => {\n-         alt i.node {\n+         match i.node {\n                  ast::item_class(_, _, items, _, _) => {\n                class_field_tys(items)\n            }\n@@ -2929,7 +2929,7 @@ fn lookup_class_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n \n fn lookup_class_field(cx: ctxt, parent: ast::def_id, field_id: ast::def_id)\n     -> field_ty {\n-    alt vec::find(lookup_class_fields(cx, parent),\n+    match vec::find(lookup_class_fields(cx, parent),\n                  |f| f.id.node == field_id.node) {\n         some(t) => t,\n         none => cx.sess.bug(~\"class ID not found in parent's fields\")\n@@ -2962,7 +2962,7 @@ fn lookup_class_method_by_name(cx:ctxt, did: ast::def_id, name: ident,\n         -> ~[{name: ident, id: node_id, vis: visibility}] {\n \n         assert is_local(did);\n-        alt cx.items.find(did.node) {\n+        match cx.items.find(did.node) {\n           some(ast_map::node_item(@{\n             node: item_class(_,_,items,_,_), _\n           }, _)) => {\n@@ -2994,7 +2994,7 @@ fn lookup_class_method_by_name(cx:ctxt, did: ast::def_id, name: ident,\n fn class_field_tys(items: ~[@class_member]) -> ~[field_ty] {\n     let mut rslt = ~[];\n     for items.each |it| {\n-       alt it.node {\n+       match it.node {\n           instance_var(nm, _, cm, id, vis) => {\n               vec::push(rslt, {ident: nm, id: ast_util::local_def(id),\n                         vis: vis, mutability: cm});\n@@ -3020,7 +3020,7 @@ fn class_items_as_mutable_fields(cx:ctxt, did: ast::def_id,\n // mutability.\n fn class_items_as_fields(cx:ctxt, did: ast::def_id,\n                          substs: substs) -> ~[field] {\n-    class_item_fields(cx, did, substs, |mt| alt mt {\n+    class_item_fields(cx, did, substs, |mt| match mt {\n       class_mutable => m_mutbl,\n         class_immutable => m_imm })\n }\n@@ -3058,7 +3058,7 @@ fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n     const opcat_logic: int = 7;\n \n     fn opcat(op: ast::binop) -> int {\n-        alt op {\n+        match op {\n           ast::add => opcat_add,\n           ast::subtract => opcat_sub,\n           ast::mul => opcat_mult,\n@@ -3081,7 +3081,7 @@ fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n     }\n \n     fn tycat(ty: t) -> int {\n-        alt get(ty).struct {\n+        match get(ty).struct {\n           ty_bool => tycat_bool,\n           ty_int(_) | ty_uint(_) | ty_var_integral(_) => tycat_int,\n           ty_float(_) => tycat_float,\n@@ -3126,7 +3126,7 @@ fn normalize_ty(cx: ctxt, t: t) -> t {\n         }\n     }\n \n-    alt cx.normalized_cache.find(t) {\n+    match cx.normalized_cache.find(t) {\n       some(t) => return t,\n       none => ()\n     }"}, {"sha": "e96fe4e867947b0c0a2306031b997e41e78016dd", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -180,7 +180,7 @@ fn write_substs_to_tcx(tcx: ty::ctxt,\n }\n \n fn lookup_def_tcx(tcx: ty::ctxt, sp: span, id: ast::node_id) -> ast::def {\n-    alt tcx.def_map.find(id) {\n+    match tcx.def_map.find(id) {\n       some(x) => x,\n       _ => {\n         tcx.sess.span_fatal(sp, ~\"internal error looking up a definition\")\n@@ -205,7 +205,7 @@ fn require_same_types(\n     msg: fn() -> ~str) -> bool {\n \n     let l_tcx, l_infcx;\n-    alt maybe_infcx {\n+    match maybe_infcx {\n       none => {\n         l_tcx = tcx;\n         l_infcx = infer::new_infer_ctxt(tcx);\n@@ -216,7 +216,7 @@ fn require_same_types(\n       }\n     }\n \n-    alt infer::mk_eqty(l_infcx, t1, t2) {\n+    match infer::mk_eqty(l_infcx, t1, t2) {\n       result::ok(()) => true,\n       result::err(terr) => {\n         l_tcx.sess.span_err(span, msg() + ~\": \" +\n@@ -227,10 +227,10 @@ fn require_same_types(\n }\n \n fn arg_is_argv_ty(_tcx: ty::ctxt, a: ty::arg) -> bool {\n-    alt ty::get(a.ty).struct {\n+    match ty::get(a.ty).struct {\n       ty::ty_evec(mt, vstore_uniq) => {\n         if mt.mutbl != ast::m_imm { return false; }\n-        alt ty::get(mt.ty).struct {\n+        match ty::get(mt.ty).struct {\n           ty::ty_estr(vstore_uniq) => return true,\n           _ => return false\n         }\n@@ -245,12 +245,12 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n \n     let tcx = ccx.tcx;\n     let main_t = ty::node_id_to_type(tcx, main_id);\n-    alt ty::get(main_t).struct {\n+    match ty::get(main_t).struct {\n       ty::ty_fn({purity: ast::impure_fn, proto: ast::proto_bare,\n                  inputs, output, ret_style: ast::return_val}) => {\n-        alt tcx.items.find(main_id) {\n+        match tcx.items.find(main_id) {\n          some(ast_map::node_item(it,_)) => {\n-             alt it.node {\n+             match it.node {\n                ast::item_fn(_,ps,_) if vec::is_not_empty(ps) => {\n                   tcx.sess.span_err(main_span,\n                     ~\"main function is not allowed to have type parameters\");\n@@ -284,7 +284,7 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n fn check_for_main_fn(ccx: @crate_ctxt) {\n     let tcx = ccx.tcx;\n     if !tcx.sess.building_library {\n-        alt copy tcx.sess.main_fn {\n+        match copy tcx.sess.main_fn {\n           some((id, sp)) => check_main_fn_ty(ccx, id, sp),\n           none => tcx.sess.err(~\"main function not found\")\n         }"}, {"sha": "fffc70e95259b3e979c83a60b19928c0df2a36e9", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -59,7 +59,7 @@ fn get_region_reporting_err(tcx: ty::ctxt,\n                             span: span,\n                             res: result<ty::region, ~str>) -> ty::region {\n \n-    alt res {\n+    match res {\n       result::ok(r) => r,\n       result::err(e) => {\n         tcx.sess.span_err(span, e);\n@@ -71,7 +71,7 @@ fn get_region_reporting_err(tcx: ty::ctxt,\n fn ast_region_to_region<AC: ast_conv, RS: region_scope copy owned>(\n     self: AC, rscope: RS, span: span, a_r: @ast::region) -> ty::region {\n \n-    let res = alt a_r.node {\n+    let res = match a_r.node {\n       ast::re_anon => rscope.anon_region(),\n       ast::re_named(id) => rscope.named_region(id)\n     };\n@@ -93,7 +93,7 @@ fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope copy owned>(\n     // If the type is parameterized by the self region, then replace self\n     // region with the current anon region binding (in other words,\n     // whatever & would get replaced with).\n-    let self_r = alt (decl_rp, path.rp) {\n+    let self_r = match (decl_rp, path.rp) {\n       (false, none) => {\n         none\n       }\n@@ -168,14 +168,14 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy owned>(\n \n         let tcx = self.tcx();\n \n-        alt a_seq_ty.ty.node {\n+        match a_seq_ty.ty.node {\n           // to convert to an e{vec,str}, there can't be a mutability argument\n           _ if a_seq_ty.mutbl != ast::m_imm => (),\n           ast::ty_vec(mt) => {\n             return ty::mk_evec(tcx, ast_mt_to_mt(self, rscope, mt), vst);\n           }\n           ast::ty_path(path, id) => {\n-            alt tcx.def_map.find(id) {\n+            match tcx.def_map.find(id) {\n               some(ast::def_prim_ty(ast::ty_str)) => {\n                 check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                 return ty::mk_estr(tcx, vst);\n@@ -212,7 +212,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy owned>(\n \n     let tcx = self.tcx();\n \n-    alt tcx.ast_ty_to_ty_cache.find(ast_ty) {\n+    match tcx.ast_ty_to_ty_cache.find(ast_ty) {\n       some(ty::atttce_resolved(ty)) => return ty,\n       some(ty::atttce_unresolved) => {\n         tcx.sess.span_fatal(ast_ty.span, ~\"illegal recursive type; \\\n@@ -223,7 +223,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy owned>(\n     }\n \n     tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_unresolved);\n-    let typ = alt ast_ty.node {\n+    let typ = match ast_ty.node {\n       ast::ty_nil => ty::mk_nil(tcx),\n       ast::ty_bot => ty::mk_bot(tcx),\n       ast::ty_box(mt) => {\n@@ -265,17 +265,17 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy owned>(\n         ty::mk_fn(tcx, ty_of_fn_decl(self, rscope, proto, decl, none))\n       }\n       ast::ty_path(path, id) => {\n-        let a_def = alt tcx.def_map.find(id) {\n+        let a_def = match tcx.def_map.find(id) {\n           none => tcx.sess.span_fatal(ast_ty.span, fmt!{\"unbound path %s\",\n                                                         path_to_str(path)}),\n           some(d) => d\n         };\n-        alt a_def {\n+        match a_def {\n           ast::def_ty(did) | ast::def_class(did, _) => {\n             ast_path_to_ty(self, rscope, did, path, id).ty\n           }\n           ast::def_prim_ty(nty) => {\n-            alt nty {\n+            match nty {\n               ast::ty_bool => {\n                 check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                 ty::mk_bool(tcx)\n@@ -356,20 +356,20 @@ fn ty_of_arg<AC: ast_conv, RS: region_scope copy owned>(\n     self: AC, rscope: RS, a: ast::arg,\n     expected_ty: option<ty::arg>) -> ty::arg {\n \n-    let ty = alt a.ty.node {\n+    let ty = match a.ty.node {\n       ast::ty_infer if expected_ty.is_some() => expected_ty.get().ty,\n       ast::ty_infer => self.ty_infer(a.ty.span),\n       _ => ast_ty_to_ty(self, rscope, a.ty)\n     };\n \n     let mode = {\n-        alt a.mode {\n+        match a.mode {\n           ast::infer(_) if expected_ty.is_some() => {\n             result::get(ty::unify_mode(self.tcx(), a.mode,\n                                        expected_ty.get().mode))\n           }\n           ast::infer(_) => {\n-            alt ty::get(ty).struct {\n+            match ty::get(ty).struct {\n               // If the type is not specified, then this must be a fn expr.\n               // Leave the mode as infer(_), it will get inferred based\n               // on constraints elsewhere.\n@@ -417,7 +417,7 @@ fn ty_of_fn_decl<AC: ast_conv, RS: region_scope copy owned>(\n         };\n \n         let expected_ret_ty = expected_tys.map(|e| e.output);\n-        let output_ty = alt decl.output.node {\n+        let output_ty = match decl.output.node {\n           ast::ty_infer if expected_ret_ty.is_some() => expected_ret_ty.get(),\n           ast::ty_infer => self.ty_infer(decl.output.span),\n           _ => ast_ty_to_ty(self, rb, decl.output)"}, {"sha": "efe728f9e127a4cb8c3d363686ceeec6b7422547", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 92, "deletions": 92, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -177,7 +177,7 @@ fn check_bare_fn(ccx: @crate_ctxt,\n                  id: ast::node_id,\n                  self_info: option<self_info>) {\n     let fty = ty::node_id_to_type(ccx.tcx, id);\n-    let fn_ty = alt check ty::get(fty).struct { ty::ty_fn(f) => f };\n+    let fn_ty = match check ty::get(fty).struct { ty::ty_fn(f) => f };\n     check_fn(ccx, self_info, fn_ty, decl, body, false, none);\n }\n \n@@ -216,7 +216,7 @@ fn check_fn(ccx: @crate_ctxt,\n     // in the case of function expressions, based on the outer context.\n     let fcx: @fn_ctxt = {\n         let {infcx, locals, purity, node_types, node_type_substs} =\n-        alt old_fcx {\n+        match old_fcx {\n           none => {\n             {infcx: infer::new_infer_ctxt(tcx),\n              locals: int_hash(),\n@@ -236,7 +236,7 @@ fn check_fn(ccx: @crate_ctxt,\n \n         let indirect_ret_ty = if indirect_ret {\n             let ofcx = option::get(old_fcx);\n-            alt ofcx.indirect_ret_ty {\n+            match ofcx.indirect_ret_ty {\n               some(t) => some(t),\n               none => some(ofcx.ret_ty)\n             }\n@@ -260,7 +260,7 @@ fn check_fn(ccx: @crate_ctxt,\n \n     // We unify the tail expr's type with the\n     // function result type, if there is a tail expr.\n-    alt body.node.expr {\n+    match body.node.expr {\n       some(tail_expr) => {\n         let tail_expr_ty = fcx.expr_ty(tail_expr);\n         demand::suptype(fcx, tail_expr.span, fcx.ret_ty, tail_expr_ty);\n@@ -293,7 +293,7 @@ fn check_fn(ccx: @crate_ctxt,\n         let assign = fn@(nid: ast::node_id, ty_opt: option<ty::t>) {\n             let var_id = fcx.infcx.next_ty_var_id();\n             fcx.locals.insert(nid, var_id);\n-            alt ty_opt {\n+            match ty_opt {\n               none => {/* nothing to do */ }\n               some(typ) => {\n                 infer::mk_eqty(fcx.infcx, ty::mk_var(tcx, var_id), typ);\n@@ -311,7 +311,7 @@ fn check_fn(ccx: @crate_ctxt,\n         // Add explicitly-declared locals.\n         let visit_local = fn@(local: @ast::local,\n                               &&e: (), v: visit::vt<()>) {\n-            let o_ty = alt local.node.ty.node {\n+            let o_ty = match local.node.ty.node {\n               ast::ty_infer => none,\n               _ => some(fcx.to_ty(local.node.ty))\n             };\n@@ -324,7 +324,7 @@ fn check_fn(ccx: @crate_ctxt,\n \n         // Add pattern bindings.\n         let visit_pat = fn@(p: @ast::pat, &&e: (), v: visit::vt<()>) {\n-            alt p.node {\n+            match p.node {\n               ast::pat_ident(_, path, _)\n                   if !pat_util::pat_is_variant(fcx.ccx.tcx.def_map, p) => {\n                 assign(p.id, none);\n@@ -371,7 +371,7 @@ fn check_method(ccx: @crate_ctxt, method: @ast::method,\n \n fn check_class_member(ccx: @crate_ctxt, class_t: self_info,\n                       cm: @ast::class_member) {\n-    alt cm.node {\n+    match cm.node {\n       ast::instance_var(_,t,_,_,_) => (),\n       ast::class_method(m) => check_method(ccx, m, class_t)\n     }\n@@ -383,7 +383,7 @@ fn check_no_duplicate_fields(tcx: ty::ctxt, fields:\n                                              |x,y| str::eq(*x, *y));\n     for fields.each |p| {\n         let (id, sp) = p;\n-        alt field_names.find(id) {\n+        match field_names.find(id) {\n           some(orig_sp) => {\n             tcx.sess.span_err(sp, fmt!{\"Duplicate field \\\n                                    name %s in record type declaration\",\n@@ -401,7 +401,7 @@ fn check_no_duplicate_fields(tcx: ty::ctxt, fields:\n }\n \n fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n-    alt it.node {\n+    match it.node {\n       ast::item_const(_, e) => check_const(ccx, it.span, e, it.id),\n       ast::item_enum(vs, _) => {\n         check_enum_variants(ccx, it.span, vs, it.id);\n@@ -419,7 +419,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n       }\n       ast::item_trait(_, _, trait_methods) => {\n         for trait_methods.each |trait_method| {\n-            alt trait_method {\n+            match trait_method {\n               required(ty_m) => {\n                 // Nothing to do, since required methods don't have\n                 // bodies to check.\n@@ -471,7 +471,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         let tpt_ty = ty::node_id_to_type(ccx.tcx, it.id);\n         check_bounds_are_used(ccx, t.span, tps, tpt_ty);\n         // If this is a record ty, check for duplicate fields\n-        alt t.node {\n+        match t.node {\n             ast::ty_rec(fields) => {\n               check_no_duplicate_fields(ccx.tcx, fields.map(|f|\n                                               (f.node.ident, f.span)));\n@@ -519,7 +519,7 @@ impl of region_scope for @fn_ctxt {\n     }\n     fn named_region(id: ast::ident) -> result<ty::region, ~str> {\n         do empty_rscope.named_region(id).chain_err |_e| {\n-            alt self.in_scope_regions.find(ty::br_named(id)) {\n+            match self.in_scope_regions.find(ty::br_named(id)) {\n               some(r) => result::ok(r),\n               none if *id == ~\"blk\" => self.block_region(),\n               none => {\n@@ -564,7 +564,7 @@ impl methods for @fn_ctxt {\n     }\n \n     fn expr_ty(ex: @ast::expr) -> ty::t {\n-        alt self.node_types.find(ex.id) {\n+        match self.node_types.find(ex.id) {\n           some(t) => t,\n           none => {\n             self.tcx().sess.bug(fmt!{\"no type for expr %d (%s) in fcx %s\",\n@@ -573,7 +573,7 @@ impl methods for @fn_ctxt {\n         }\n     }\n     fn node_ty(id: ast::node_id) -> ty::t {\n-        alt self.node_types.find(id) {\n+        match self.node_types.find(id) {\n           some(t) => t,\n           none => {\n             self.tcx().sess.bug(\n@@ -584,7 +584,7 @@ impl methods for @fn_ctxt {\n         }\n     }\n     fn node_ty_substs(id: ast::node_id) -> ty::substs {\n-        alt self.node_type_substs.find(id) {\n+        match self.node_type_substs.find(id) {\n           some(ts) => ts,\n           none => {\n             self.tcx().sess.bug(\n@@ -637,7 +637,7 @@ impl methods for @fn_ctxt {\n     }\n \n     fn require_unsafe(sp: span, op: ~str) {\n-        alt self.purity {\n+        match self.purity {\n           ast::unsafe_fn => {/*ok*/}\n           _ => {\n             self.ccx.tcx.sess.span_err(\n@@ -662,9 +662,9 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n         let sty = structure_of(fcx, sp, t1);\n \n         // Some extra checks to detect weird cycles and so forth:\n-        alt sty {\n+        match sty {\n           ty::ty_box(inner) | ty::ty_uniq(inner) | ty::ty_rptr(_, inner) => {\n-            alt ty::get(t1).struct {\n+            match ty::get(t1).struct {\n               ty::ty_var(v1) => {\n                 ty::occurs_check(fcx.ccx.tcx, sp, v1,\n                                  ty::mk_box(fcx.ccx.tcx, inner));\n@@ -687,7 +687,7 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n         }\n \n         // Otherwise, deref if type is derefable:\n-        alt ty::deref_sty(fcx.ccx.tcx, sty, false) {\n+        match ty::deref_sty(fcx.ccx.tcx, sty, false) {\n           none => return t1,\n           some(mt) => t1 = mt.ty\n         }\n@@ -698,7 +698,7 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n fn check_lit(fcx: @fn_ctxt, lit: @ast::lit) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n \n-    alt lit.node {\n+    match lit.node {\n       ast::lit_str(s) => ty::mk_estr(tcx, ty::vstore_slice(ty::re_static)),\n       ast::lit_int(_, t) => ty::mk_mach_int(tcx, t),\n       ast::lit_uint(_, t) => ty::mk_mach_uint(tcx, t),\n@@ -740,7 +740,7 @@ fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n \n     let {n_tps, rp, raw_ty} = if did.crate == ast::local_crate {\n         let rp = fcx.tcx().region_paramd_items.contains_key(did.node);\n-        alt check tcx.items.find(did.node) {\n+        match check tcx.items.find(did.node) {\n           some(ast_map::node_item(@{node: ast::item_impl(ts, _, st, _),\n                                   _}, _)) => {\n             {n_tps: ts.len(),\n@@ -818,7 +818,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // process the types bound by the function but not by any nested\n         // functions.  Therefore, we match one level of structure.\n         let fn_ty =\n-            alt structure_of(fcx, sp, in_fty) {\n+            match structure_of(fcx, sp, in_fty) {\n               sty @ ty::ty_fn(fn_ty) => {\n                 replace_bound_regions_in_fn_ty(\n                     fcx.ccx.tcx, @nil, none, fn_ty,\n@@ -872,7 +872,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // right way to do this.\n         for [false, true]/_.each |check_blocks| {\n             for args.eachi |i, a| {\n-                let is_block = alt a.node {\n+                let is_block = match a.node {\n                   ast::expr_fn_block(*) => true,\n                   _ => false\n                 };\n@@ -905,7 +905,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         // Index expressions need to be handled seperately, to inform\n         // them that they appear in call position.\n-        let mut bot = alt f.node {\n+        let mut bot = match f.node {\n           ast::expr_field(base, field, tys) => {\n             check_field(fcx, f, true, base, field, tys)\n           }\n@@ -922,7 +922,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         };\n \n         // Pull the return type out of the type of the function.\n-        alt structure_of(fcx, sp, fty) {\n+        match structure_of(fcx, sp, fty) {\n           ty::ty_fn(f) => {\n             bot |= (f.ret_style == ast::noreturn);\n             fcx.write_ty(call_expr_id, f.output);\n@@ -952,7 +952,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                        elsopt: option<@ast::expr>, id: ast::node_id,\n                        _sp: span) -> bool {\n         let (if_t, if_bot) =\n-            alt elsopt {\n+            match elsopt {\n               some(els) => {\n                 let if_t = fcx.infcx.next_ty_var();\n                 let thn_bot = check_block(fcx, thn);\n@@ -976,7 +976,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         -> option<(ty::t, bool)> {\n         let lkup = method::lookup(fcx, op_ex, self_ex, op_ex.id,\n                      op_ex.callee_id, @opname, self_t, ~[], false);\n-        alt lkup.method() {\n+        match lkup.method() {\n           some(origin) => {\n             let {fty: method_ty, bot: bot} = {\n                 let method_ty = fcx.node_ty(op_ex.callee_id);\n@@ -998,7 +998,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let lhs_bot = check_expr(fcx, lhs, none);\n         let lhs_t = fcx.expr_ty(lhs);\n         let lhs_t = structurally_resolved_type(fcx, lhs.span, lhs_t);\n-        return alt (op, ty::get(lhs_t).struct) {\n+        return match (op, ty::get(lhs_t).struct) {\n           (_, _) if ty::type_is_integral(lhs_t) &&\n           ast_util::is_shift_binop(op) => {\n             // Shift is a special case: rhs can be any integral type\n@@ -1013,7 +1013,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             let tvar = fcx.infcx.next_ty_var();\n             demand::suptype(fcx, expr.span, tvar, lhs_t);\n             let rhs_bot = check_expr_with(fcx, rhs, tvar);\n-            let rhs_t = alt op {\n+            let rhs_t = match op {\n               ast::eq | ast::lt | ast::le | ast::ne | ast::ge |\n               ast::gt => {\n                 // these comparison operators are handled in a\n@@ -1042,9 +1042,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                         lhs_expr: @ast::expr, lhs_resolved_t: ty::t,\n                         op: ast::binop, rhs: @ast::expr) -> (ty::t, bool) {\n         let tcx = fcx.ccx.tcx;\n-        alt ast_util::binop_to_method_name(op) {\n+        match ast_util::binop_to_method_name(op) {\n           some(name) => {\n-            alt lookup_op_method(fcx, ex,\n+            match lookup_op_method(fcx, ex,\n                                  lhs_expr, lhs_resolved_t,\n                                  name, ~[rhs]) {\n               some(pair) => return pair,\n@@ -1064,7 +1064,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // If the or operator is used it might be that the user forgot to\n         // supply the do keyword.  Let's be more helpful in that situation.\n         if op == ast::or {\n-          alt ty::get(lhs_resolved_t).struct {\n+          match ty::get(lhs_resolved_t).struct {\n             ty::ty_fn(f) => {\n               tcx.sess.span_note(\n                   ex.span, ~\"did you forget the 'do' keyword for the call?\");\n@@ -1078,7 +1078,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     fn check_user_unop(fcx: @fn_ctxt, op_str: ~str, mname: ~str,\n                        ex: @ast::expr,\n                        rhs_expr: @ast::expr, rhs_t: ty::t) -> ty::t {\n-        alt lookup_op_method(fcx, ex, rhs_expr, rhs_t, mname, ~[]) {\n+        match lookup_op_method(fcx, ex, rhs_expr, rhs_t, mname, ~[]) {\n           some((ret_ty, _)) => ret_ty,\n           _ => {\n             fcx.ccx.tcx.sess.span_err(\n@@ -1096,9 +1096,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     fn unpack_expected<O: copy>(fcx: @fn_ctxt, expected: option<ty::t>,\n                                 unpack: fn(ty::sty) -> option<O>)\n         -> option<O> {\n-        alt expected {\n+        match expected {\n           some(t) => {\n-            alt resolve_type(fcx.infcx, t, force_tvar) {\n+            match resolve_type(fcx.infcx, t, force_tvar) {\n               result::ok(t) => unpack(ty::get(t).struct),\n               _ => none\n             }\n@@ -1121,7 +1121,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // def'n of br_cap_avoid() for a more lengthy explanation of\n         // what's going on here.\n         let expected_tys = do unpack_expected(fcx, expected) |sty| {\n-            alt sty {\n+            match sty {\n               ty::ty_fn(fn_ty) => {\n                 let {fn_ty, _} =\n                     replace_bound_regions_in_fn_ty(\n@@ -1160,9 +1160,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let base_t = do_autoderef(fcx, expr.span, expr_t);\n         let mut handled = false;\n         let n_tys = vec::len(tys);\n-        alt structure_of(fcx, expr.span, base_t) {\n+        match structure_of(fcx, expr.span, base_t) {\n           ty::ty_rec(fields) => {\n-            alt ty::field_idx(field, fields) {\n+            match ty::field_idx(field, fields) {\n               some(ix) => {\n                 if n_tys > 0u {\n                     tcx.sess.span_err(expr.span,\n@@ -1194,7 +1194,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               else {\n                   lookup_public_fields(tcx, base_id)\n               };\n-              alt lookup_field_ty(tcx, base_id, cls_items, field, substs) {\n+              match lookup_field_ty(tcx, base_id, cls_items, field, substs) {\n                  some(field_ty) => {\n                     // (2) look up what field's type is, and return it\n                      fcx.write_ty(expr.id, field_ty);\n@@ -1216,7 +1216,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             let lkup = method::lookup(fcx, expr, base, borrow_lb,\n                                       expr.id, field, expr_t, tps,\n                                       is_self_ref);\n-            alt lkup.method() {\n+            match lkup.method() {\n               some(entry) => {\n                 fcx.ccx.method_map.insert(expr.id, entry);\n \n@@ -1248,9 +1248,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n     let mut bot = false;\n-    alt expr.node {\n+    match expr.node {\n       ast::expr_vstore(ev, vst) => {\n-        let typ = alt ev.node {\n+        let typ = match ev.node {\n           ast::expr_lit(@{node: ast::lit_str(s), span:_}) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, str::len(*s), vst);\n             ty::mk_estr(tcx, tt)\n@@ -1315,8 +1315,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n       ast::expr_unary(unop, oprnd) => {\n         let exp_inner = do unpack_expected(fcx, expected) |sty| {\n-            alt unop {\n-              ast::box(_) | ast::uniq(_) => alt sty {\n+            match unop {\n+              ast::box(_) | ast::uniq(_) => match sty {\n                 ty::ty_box(mt) | ty::ty_uniq(mt) => some(mt.ty),\n                 _ => none\n               }\n@@ -1326,7 +1326,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         };\n         bot = check_expr(fcx, oprnd, exp_inner);\n         let mut oprnd_t = fcx.expr_ty(oprnd);\n-        alt unop {\n+        match unop {\n           ast::box(mutbl) => {\n             oprnd_t = ty::mk_box(tcx, {ty: oprnd_t, mutbl: mutbl});\n           }\n@@ -1338,7 +1338,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n             // deref'ing an unsafe pointer requires that we be in an unsafe\n             // context\n-            alt sty {\n+            match sty {\n               ty::ty_ptr(*) => {\n                 fcx.require_unsafe(\n                     expr.span,\n@@ -1347,10 +1347,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               _ => { /*ok*/ }\n             }\n \n-            alt ty::deref_sty(tcx, sty, true) {\n+            match ty::deref_sty(tcx, sty, true) {\n               some(mt) => { oprnd_t = mt.ty }\n               none => {\n-                alt sty {\n+                match sty {\n                   ty::ty_enum(*) => {\n                     tcx.sess.span_err(\n                         expr.span,\n@@ -1389,7 +1389,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n       ast::expr_addr_of(mutbl, oprnd) => {\n         bot = check_expr(fcx, oprnd, unpack_expected(fcx, expected, |ty|\n-            alt ty { ty::ty_rptr(_, mt) => some(mt.ty), _ => none }\n+            match ty { ty::ty_rptr(_, mt) => some(mt.ty), _ => none }\n         ));\n         //let region = region_of(fcx, oprnd);\n         let region = fcx.infcx.next_region_var_with_scope_lb(expr.id);\n@@ -1406,7 +1406,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       ast::expr_mac(_) => tcx.sess.bug(~\"unexpanded macro\"),\n       ast::expr_fail(expr_opt) => {\n         bot = true;\n-        alt expr_opt {\n+        match expr_opt {\n           none => {/* do nothing */ }\n           some(e) => {\n             check_expr_with(fcx, e,\n@@ -1419,11 +1419,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       ast::expr_again => { fcx.write_bot(id); bot = true; }\n       ast::expr_ret(expr_opt) => {\n         bot = true;\n-        let ret_ty = alt fcx.indirect_ret_ty {\n+        let ret_ty = match fcx.indirect_ret_ty {\n           some(t) =>  t, none => fcx.ret_ty\n         };\n-        alt expr_opt {\n-          none => alt fcx.mk_eqty(ret_ty, ty::mk_nil(tcx)) {\n+        match expr_opt {\n+          none => match fcx.mk_eqty(ret_ty, ty::mk_nil(tcx)) {\n             result::ok(_) => { /* fall through */ }\n             result::err(_) => {\n                 tcx.sess.span_err(\n@@ -1482,7 +1482,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       ast::expr_fn_block(decl, body, cap_clause) => {\n          // Take the prototype from the expected type, but default to block:\n           let proto = unpack_expected(fcx, expected, |sty|\n-              alt sty { ty::ty_fn({proto, _}) => some(proto), _ => none }\n+              match sty { ty::ty_fn({proto, _}) => some(proto), _ => none }\n           ).get_default(ast::proto_box);\n         check_expr_fn(fcx, expr, proto, decl, body, false, expected);\n         capture::check_capture_clause(tcx, expr.id, cap_clause);\n@@ -1495,9 +1495,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // 1. a closure that returns a bool is expected\n         // 2. the cloure that was given returns unit\n         let expected_sty = unpack_expected(fcx, expected, |x| some(x));\n-        let (inner_ty, proto) = alt expected_sty {\n+        let (inner_ty, proto) = match expected_sty {\n           some(ty::ty_fn(fty)) => {\n-            alt infer::mk_subty(fcx.infcx, fty.output, ty::mk_bool(tcx)) {\n+            match infer::mk_subty(fcx.infcx, fty.output, ty::mk_bool(tcx)) {\n               result::ok(_) => (),\n               result::err(err) => {\n                 tcx.sess.span_fatal(\n@@ -1514,7 +1514,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                                             type\");\n           }\n         };\n-        alt check b.node {\n+        match check b.node {\n           ast::expr_fn_block(decl, body, cap_clause) => {\n             check_expr_fn(fcx, b, proto, decl, body, true, some(inner_ty));\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n@@ -1523,7 +1523,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         }\n         let block_ty = structurally_resolved_type(\n             fcx, expr.span, fcx.node_ty(b.id));\n-        alt check ty::get(block_ty).struct {\n+        match check ty::get(block_ty).struct {\n           ty::ty_fn(fty) => {\n             fcx.write_ty(expr.id, ty::mk_fn(tcx, {output: ty::mk_bool(tcx)\n                                                   with fty}));\n@@ -1532,7 +1532,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n       ast::expr_do_body(b) => {\n         let expected_sty = unpack_expected(fcx, expected, |x| some(x));\n-        let (inner_ty, proto) = alt expected_sty {\n+        let (inner_ty, proto) = match expected_sty {\n           some(ty::ty_fn(fty)) => {\n             (ty::mk_fn(tcx, fty), fty.proto)\n           }\n@@ -1542,7 +1542,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               passed to a `do` function\");\n           }\n         };\n-        alt check b.node {\n+        match check b.node {\n           ast::expr_fn_block(decl, body, cap_clause) => {\n             check_expr_fn(fcx, b, proto, decl, body, true, some(inner_ty));\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n@@ -1551,7 +1551,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         }\n         let block_ty = structurally_resolved_type(\n             fcx, expr.span, fcx.node_ty(b.id));\n-        alt check ty::get(block_ty).struct {\n+        match check ty::get(block_ty).struct {\n           ty::ty_fn(fty) => {\n             fcx.write_ty(expr.id, ty::mk_fn(tcx, fty));\n           }\n@@ -1561,7 +1561,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // If this is an unchecked block, turn off purity-checking\n         bot = check_block(fcx, b);\n         let typ =\n-            alt b.node.expr {\n+            match b.node.expr {\n               some(expr) => fcx.expr_ty(expr),\n               none => ty::mk_nil(tcx)\n             };\n@@ -1578,7 +1578,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         debug!{\"t_1=%s\", fcx.infcx.ty_to_str(t_1)};\n         debug!{\"t_e=%s\", fcx.infcx.ty_to_str(t_e)};\n \n-        alt ty::get(t_1).struct {\n+        match ty::get(t_1).struct {\n           // This will be looked up later on\n           ty::ty_trait(*) => (),\n \n@@ -1631,7 +1631,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let mut elt_ts = ~[];\n         vec::reserve(elt_ts, vec::len(elts));\n         let flds = unpack_expected(fcx, expected, |sty| {\n-            alt sty { ty::ty_tup(flds) => some(flds), _ => none }\n+            match sty { ty::ty_tup(flds) => some(flds), _ => none }\n         });\n         for elts.eachi |i, e| {\n             check_expr(fcx, e, flds.map(|fs| fs[i]));\n@@ -1647,7 +1647,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             some(fcx.expr_ty(base.get()))\n         } else { expected };\n         let flds = unpack_expected(fcx, expected, |sty|\n-            alt sty { ty::ty_rec(flds) => some(flds), _ => none }\n+            match sty { ty::ty_rec(flds) => some(flds), _ => none }\n         );\n         let fields_t = vec::map(fields, |f| {\n             bot |= check_expr(fcx, f.node.expr, flds.chain(|flds|\n@@ -1659,7 +1659,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             // should be f.node.expr.span, not f.span\n             respan(f.node.expr.span, {ident: f.node.ident, mt: expr_mt})\n         });\n-        alt base {\n+        match base {\n           none => {\n             fn get_node(f: spanned<field>) -> field { f.node }\n             let typ = ty::mk_rec(tcx, vec::map(fields_t, get_node));\n@@ -1674,7 +1674,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           }\n           some(bexpr) => {\n             let bexpr_t = fcx.expr_ty(bexpr);\n-            let base_fields =  alt structure_of(fcx, expr.span, bexpr_t) {\n+            let base_fields =  match structure_of(fcx, expr.span, bexpr_t) {\n               ty::ty_rec(flds) => flds,\n               _ => {\n                 tcx.sess.span_fatal(expr.span,\n@@ -1702,7 +1702,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       ast::expr_struct(path, fields, base_expr) => {\n         // Resolve the path.\n         let class_id;\n-        alt tcx.def_map.find(id) {\n+        match tcx.def_map.find(id) {\n             some(ast::def_class(type_def_id, _)) => {\n                 class_id = type_def_id;\n             }\n@@ -1718,7 +1718,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         if class_id.crate == ast::local_crate {\n             region_parameterized =\n                 tcx.region_paramd_items.contains_key(class_id.node);\n-            alt tcx.items.find(class_id.node) {\n+            match tcx.items.find(class_id.node) {\n                 some(ast_map::node_item(@{\n                         node: ast::item_class(type_parameters, _, _, _, _),\n                         _\n@@ -1779,7 +1779,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         // Typecheck each field.\n         for fields.each |field| {\n-            alt class_field_map.find(*field.node.ident) {\n+            match class_field_map.find(*field.node.ident) {\n                 none => {\n                     tcx.sess.span_err(field.span,\n                                       fmt!{\"structure has no field named \\\n@@ -1848,15 +1848,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let base_t = do_autoderef(fcx, expr.span, raw_base_t);\n         bot |= check_expr(fcx, idx, none);\n         let idx_t = fcx.expr_ty(idx);\n-        alt ty::index_sty(tcx, structure_of(fcx, expr.span, base_t)) {\n+        match ty::index_sty(tcx, structure_of(fcx, expr.span, base_t)) {\n           some(mt) => {\n             require_integral(fcx, idx.span, idx_t);\n             fcx.write_ty(id, mt.ty);\n           }\n           none => {\n             let resolved = structurally_resolved_type(fcx, expr.span,\n                                                       raw_base_t);\n-            alt lookup_op_method(fcx, expr, base, resolved, ~\"index\",\n+            match lookup_op_method(fcx, expr, base, resolved, ~\"index\",\n                                  ~[idx]) {\n               some((ret_ty, _)) => fcx.write_ty(id, ret_ty),\n               _ => {\n@@ -1874,7 +1874,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     debug!{\"type of expr %s is %s, expected is %s\",\n            syntax::print::pprust::expr_to_str(expr),\n            ty_to_str(tcx, fcx.expr_ty(expr)),\n-           alt expected {\n+           match expected {\n                some(t) => ty_to_str(tcx, t),\n                _ => ~\"empty\"\n            }};\n@@ -1904,7 +1904,7 @@ fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n \n     let t = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(local.node.id));\n     fcx.write_ty(local.node.id, t);\n-    alt local.node.init {\n+    match local.node.init {\n       some(init) => {\n         bot = check_decl_initializer(fcx, local.node.id, init);\n       }\n@@ -1927,10 +1927,10 @@ fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n fn check_stmt(fcx: @fn_ctxt, stmt: @ast::stmt) -> bool {\n     let mut node_id;\n     let mut bot = false;\n-    alt stmt.node {\n+    match stmt.node {\n       ast::stmt_decl(decl, id) => {\n         node_id = id;\n-        alt decl.node {\n+        match decl.node {\n           ast::decl_local(ls) => for ls.each |l| {\n             bot |= check_decl_local(fcx, l);\n           }\n@@ -1961,7 +1961,7 @@ fn check_block_no_value(fcx: @fn_ctxt, blk: ast::blk) -> bool {\n }\n \n fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n-    let fcx = alt blk.node.rules {\n+    let fcx = match blk.node.rules {\n       ast::unchecked_blk => @fn_ctxt_({purity: ast::impure_fn with **fcx0}),\n       ast::unsafe_blk => @fn_ctxt_({purity: ast::unsafe_fn with **fcx0}),\n       ast::default_blk => fcx0\n@@ -1971,7 +1971,7 @@ fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n         let mut warned = false;\n         for blk.node.stmts.each |s| {\n             if bot && !warned &&\n-                alt s.node {\n+                match s.node {\n                   ast::stmt_decl(@{node: ast::decl_local(_), _}, _) |\n                   ast::stmt_expr(_, _) | ast::stmt_semi(_, _) => {\n                     true\n@@ -1983,7 +1983,7 @@ fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n             }\n             bot |= check_stmt(fcx, s);\n         }\n-        alt blk.node.expr {\n+        match blk.node.expr {\n           none => fcx.write_nil(blk.node.id),\n           some(e) => {\n             if bot && !warned {\n@@ -2044,7 +2044,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n     let mut disr_val = 0;\n     let mut variants = ~[];\n     for vs.each |v| {\n-        alt v.node.disr_expr {\n+        match v.node.disr_expr {\n           some(e) => {\n             let fcx = blank_fn_ctxt(ccx, rty, e.id);\n             check_expr(fcx, e, none);\n@@ -2055,7 +2055,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n             // Also, check_expr (from check_const pass) doesn't guarantee that\n             // the expression in an form that eval_const_expr can handle, so\n             // we may still get an internal compiler error\n-            alt const_eval::eval_const_expr(ccx.tcx, e) {\n+            match const_eval::eval_const_expr(ccx.tcx, e) {\n               const_eval::const_int(val) => {\n                 disr_val = val as int;\n               }\n@@ -2088,7 +2088,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n     // Check that it is possible to represent this enum:\n     let mut outer = true, did = local_def(id);\n     if ty::type_structurally_contains(ccx.tcx, rty, |sty| {\n-        alt sty {\n+        match sty {\n           ty::ty_enum(id, _) if id == did => {\n             if outer { outer = false; false }\n             else { true }\n@@ -2119,7 +2119,7 @@ fn self_ref(fcx: @fn_ctxt, id: ast::node_id) -> bool {\n }\n \n fn lookup_local(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> tv_vid {\n-    alt fcx.locals.find(id) {\n+    match fcx.locals.find(id) {\n       some(x) => x,\n       _ => {\n         fcx.ccx.tcx.sess.span_fatal(sp,\n@@ -2136,7 +2136,7 @@ fn lookup_def(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> ast::def {\n fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n     ty_param_bounds_and_ty {\n \n-    alt defn {\n+    match defn {\n       ast::def_arg(nid, _) => {\n         assert (fcx.locals.contains_key(nid));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, nid));\n@@ -2148,7 +2148,7 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n         return no_params(typ);\n       }\n       ast::def_self(_) => {\n-        alt fcx.self_info {\n+        match fcx.self_info {\n           some(self_info) => {\n             return no_params(self_info.self_ty);\n           }\n@@ -2223,7 +2223,7 @@ fn instantiate_path(fcx: @fn_ctxt,\n \n     // determine the region bound, using the value given by the user\n     // (if any) and otherwise using a fresh region variable\n-    let self_r = alt pth.rp {\n+    let self_r = match pth.rp {\n       some(r) if !tpt.rp => {\n         fcx.ccx.tcx.sess.span_err\n             (sp, ~\"this item is not region-parameterized\");\n@@ -2267,7 +2267,7 @@ fn instantiate_path(fcx: @fn_ctxt,\n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n // resolution is possible, then an error is reported.\n fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n-    alt infer::resolve_type(fcx.infcx, tp, force_tvar) {\n+    match infer::resolve_type(fcx.infcx, tp, force_tvar) {\n       result::ok(t_s) if !ty::type_is_var(t_s) => return t_s,\n       _ => {\n         fcx.ccx.tcx.sess.span_fatal\n@@ -2298,7 +2298,7 @@ fn type_is_c_like_enum(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n \n fn ast_expr_vstore_to_vstore(fcx: @fn_ctxt, e: @ast::expr, n: uint,\n                              v: ast::vstore) -> ty::vstore {\n-    alt v {\n+    match v {\n       ast::vstore_fixed(none) => ty::vstore_fixed(n),\n       ast::vstore_fixed(some(u)) => {\n         if n != u {\n@@ -2309,7 +2309,7 @@ fn ast_expr_vstore_to_vstore(fcx: @fn_ctxt, e: @ast::expr, n: uint,\n       }\n       ast::vstore_uniq => ty::vstore_uniq,\n       ast::vstore_box => ty::vstore_box,\n-      ast::vstore_slice(a_r) =>  alt fcx.block_region() {\n+      ast::vstore_slice(a_r) =>  match fcx.block_region() {\n         result::ok(b_r) => {\n             let rscope = in_anon_rscope(fcx, b_r);\n             let r = astconv::ast_region_to_region(fcx, rscope, e.span, a_r);\n@@ -2335,7 +2335,7 @@ fn check_bounds_are_used(ccx: @crate_ctxt,\n         ccx.tcx, ty,\n         |_r| {},\n         |t| {\n-            alt ty::get(t).struct {\n+            match ty::get(t).struct {\n               ty::ty_param({idx, _}) => { tps_used[idx] = true; }\n               _ => ()\n             }\n@@ -2358,7 +2358,7 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n         {mode: ast::expl(m), ty: ty}\n     }\n     let tcx = ccx.tcx;\n-    let (n_tps, inputs, output) = alt *it.ident {\n+    let (n_tps, inputs, output) = match *it.ident {\n       ~\"size_of\" |\n       ~\"pref_align_of\" | ~\"min_align_of\" => (1u, ~[], ty::mk_uint(ccx.tcx)),\n       ~\"init\" => (1u, ~[], param(ccx, 0u)),"}, {"sha": "2de26873316ef12617b4ecd8be9939d262af3251", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -29,7 +29,7 @@ fn check_alt(fcx: @fn_ctxt,\n     let mut result_ty = fcx.infcx.next_ty_var();\n     let mut arm_non_bot = false;\n     for arms.each |arm| {\n-        alt arm.guard {\n+        match arm.guard {\n           some(e) => { check_expr_with(fcx, e, ty::mk_bool(tcx)); },\n           none => ()\n         }\n@@ -68,7 +68,7 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n     instantiate_path(pcx.fcx, path, enum_tpt, pat.span, pat.id);\n \n     // Take the enum type params out of `expected`.\n-    alt structure_of(pcx.fcx, pat.span, expected) {\n+    match structure_of(pcx.fcx, pat.span, expected) {\n       ty::ty_enum(_, expected_substs) => {\n         // check that the type of the value being matched is a subtype\n         // of the type of the pattern:\n@@ -82,7 +82,7 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n                     tcx, v_def_ids.enm, v_def_ids.var);\n             vinfo.args.map(|t| { ty::subst(tcx, expected_substs, t) })\n         };\n-        let arg_len = arg_types.len(), subpats_len = alt subpats {\n+        let arg_len = arg_types.len(), subpats_len = match subpats {\n             none => arg_len,\n             some(ps) => ps.len()\n         };\n@@ -127,7 +127,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    alt pat.node {\n+    match pat.node {\n       ast::pat_wild => {\n         fcx.write_ty(pat.id, expected);\n       }\n@@ -167,7 +167,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             demand::suptype(fcx, pat.span, ct, typ);\n         }\n         fcx.write_ty(pat.id, typ);\n-        alt sub {\n+        match sub {\n           some(p) => check_pat(pcx, p, expected),\n           _ => ()\n         }\n@@ -179,7 +179,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         check_pat_variant(pcx, pat, path, subpats, expected);\n       }\n       ast::pat_rec(fields, etc) => {\n-        let ex_fields = alt structure_of(fcx, pat.span, expected) {\n+        let ex_fields = match structure_of(fcx, pat.span, expected) {\n           ty::ty_rec(fields) => fields,\n           _ => {\n             tcx.sess.span_fatal\n@@ -201,7 +201,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             str::eq(name, f.ident)\n         }\n         for fields.each |f| {\n-            alt vec::find(ex_fields, |a| matches(f.ident, a)) {\n+            match vec::find(ex_fields, |a| matches(f.ident, a)) {\n               some(field) => {\n                 check_pat(pcx, f.pat, field.mt.ty);\n               }\n@@ -216,7 +216,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         fcx.write_ty(pat.id, expected);\n       }\n       ast::pat_tup(elts) => {\n-        let ex_elts = alt structure_of(fcx, pat.span, expected) {\n+        let ex_elts = match structure_of(fcx, pat.span, expected) {\n           ty::ty_tup(elts) => elts,\n           _ => {\n             tcx.sess.span_fatal\n@@ -241,7 +241,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         fcx.write_ty(pat.id, expected);\n       }\n       ast::pat_box(inner) => {\n-        alt structure_of(fcx, pat.span, expected) {\n+        match structure_of(fcx, pat.span, expected) {\n           ty::ty_box(e_inner) => {\n             check_pat(pcx, inner, e_inner.ty);\n             fcx.write_ty(pat.id, expected);\n@@ -256,7 +256,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         }\n       }\n       ast::pat_uniq(inner) => {\n-        alt structure_of(fcx, pat.span, expected) {\n+        match structure_of(fcx, pat.span, expected) {\n           ty::ty_uniq(e_inner) => {\n             check_pat(pcx, inner, e_inner.ty);\n             fcx.write_ty(pat.id, expected);"}, {"sha": "17f171bdf908080ceb616f4267d77371e613bb6b", "filename": "src/rustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -6,7 +6,7 @@ fn suptype(fcx: @fn_ctxt, sp: span,\n            expected: ty::t, actual: ty::t) {\n \n     // n.b.: order of actual, expected is reversed\n-    alt infer::mk_subty(fcx.infcx, actual, expected) {\n+    match infer::mk_subty(fcx.infcx, actual, expected) {\n       result::ok(()) => { /* ok */ }\n       result::err(err) => {\n         fcx.report_mismatched_types(sp, expected, actual, err);\n@@ -17,7 +17,7 @@ fn suptype(fcx: @fn_ctxt, sp: span,\n fn eqtype(fcx: @fn_ctxt, sp: span,\n           expected: ty::t, actual: ty::t) {\n \n-    alt infer::mk_eqty(fcx.infcx, actual, expected) {\n+    match infer::mk_eqty(fcx.infcx, actual, expected) {\n       result::ok(()) => { /* ok */ }\n       result::err(err) => {\n         fcx.report_mismatched_types(sp, expected, actual, err);\n@@ -29,7 +29,7 @@ fn eqtype(fcx: @fn_ctxt, sp: span,\n fn assign(fcx: @fn_ctxt, sp: span, borrow_lb: ast::node_id,\n           expected: ty::t, expr: @ast::expr) {\n     let expr_ty = fcx.expr_ty(expr);\n-    alt fcx.mk_assignty(expr, borrow_lb, expr_ty, expected) {\n+    match fcx.mk_assignty(expr, borrow_lb, expr_ty, expected) {\n       result::ok(()) => { /* ok */ }\n       result::err(err) => {\n         fcx.report_mismatched_types(sp, expected, expr_ty, err);"}, {"sha": "442920a0681bcfe468f2ceeb634364340198095e", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -24,7 +24,7 @@ fn transform_self_type_for_method(fcx: @fn_ctxt,\n                                   impl_ty: ty::t,\n                                   method_info: MethodInfo)\n                                -> ty::t {\n-    alt method_info.self_type {\n+    match method_info.self_type {\n         sty_by_ref | sty_value => {\n             impl_ty\n         }\n@@ -88,7 +88,7 @@ class lookup {\n \n         // Determine if there are any inherent methods we can call.\n         let optional_inherent_methods;\n-        alt get_base_type_def_id(self.fcx.infcx,\n+        match get_base_type_def_id(self.fcx.infcx,\n                                  self.self_expr.span,\n                                  self.self_ty) {\n             none => {\n@@ -110,7 +110,7 @@ class lookup {\n \n         loop {\n             // First, see whether this is a bounded parameter.\n-            alt ty::get(self.self_ty).struct {\n+            match ty::get(self.self_ty).struct {\n               ty::ty_param(p) => {\n                 self.add_candidates_from_param(p.idx, p.def_id);\n               }\n@@ -151,7 +151,7 @@ class lookup {\n             if self.candidates.len() > 0u { break; }\n \n             // check whether we can autoderef and if so loop around again.\n-            alt ty::deref(self.tcx(), self.self_ty, false) {\n+            match ty::deref(self.tcx(), self.self_ty, false) {\n               none => break,\n               some(mt) => {\n                 self.self_ty = mt.ty;\n@@ -168,7 +168,7 @@ class lookup {\n                 ~\"multiple applicable methods in scope\");\n \n             for self.candidates.eachi |i, candidate| {\n-                alt candidate.entry.origin {\n+                match candidate.entry.origin {\n                   method_static(did) => {\n                     self.report_static_candidate(i, did);\n                   }\n@@ -189,7 +189,7 @@ class lookup {\n \n     fn report_static_candidate(idx: uint, did: ast::def_id) {\n         let span = if did.crate == ast::local_crate {\n-            alt check self.tcx().items.get(did.node) {\n+            match check self.tcx().items.get(did.node) {\n               ast_map::node_method(m, _, _) => m.span,\n             }\n         } else {\n@@ -226,20 +226,20 @@ class lookup {\n         let mut trait_bnd_idx = 0u; // count only trait bounds\n         let bounds = tcx.ty_param_bounds.get(did.node);\n         for vec::each(*bounds) |bound| {\n-            let (iid, bound_substs) = alt bound {\n+            let (iid, bound_substs) = match bound {\n               ty::bound_copy | ty::bound_send | ty::bound_const |\n               ty::bound_owned => {\n                 again; /* ok */\n               }\n               ty::bound_trait(bound_t) => {\n-                alt check ty::get(bound_t).struct {\n+                match check ty::get(bound_t).struct {\n                   ty::ty_trait(i, substs) => (i, substs)\n                 }\n               }\n             };\n \n             let trt_methods = ty::trait_methods(tcx, iid);\n-            alt vec::position(*trt_methods, |m| m.ident == self.m_name) {\n+            match vec::position(*trt_methods, |m| m.ident == self.m_name) {\n               none => {\n                 /* check next bound */\n                 trait_bnd_idx += 1u;\n@@ -329,22 +329,24 @@ class lookup {\n     }\n \n     fn ty_from_did(did: ast::def_id) -> ty::t {\n-        alt check ty::get(ty::lookup_item_type(self.tcx(), did).ty).struct {\n+        match check ty::get(ty::lookup_item_type(self.tcx(), did).ty).struct {\n           ty::ty_fn(fty) => {\n             ty::mk_fn(self.tcx(), {proto: ast::proto_box with fty})\n           }\n         }\n         /*\n         if did.crate == ast::local_crate {\n-            alt check self.tcx().items.get(did.node) {\n+            match check self.tcx().items.get(did.node) {\n               ast_map::node_method(m, _, _) {\n                 // NDM trait/impl regions\n                 let mt = ty_of_method(self.fcx.ccx, m, ast::rp_none);\n                 ty::mk_fn(self.tcx(), {proto: ast::proto_box with mt.fty})\n               }\n             }\n         } else {\n-            alt check ty::get(csearch::get_type(self.tcx(), did).ty).struct {\n+            match check ty::get(csearch::get_type(self.tcx(), did).ty)\n+              .struct {\n+\n               ty::ty_fn(fty) {\n                 ty::mk_fn(self.tcx(), {proto: ast::proto_box with fty})\n               }\n@@ -408,7 +410,7 @@ class lookup {\n                 self.fcx.can_mk_subty(self.self_ty, impl_ty)\n             };\n             debug!{\"matches = %?\", matches};\n-            alt matches {\n+            match matches {\n               result::err(_) => { /* keep looking */ }\n               result::ok(_) => {\n                 if !self.candidate_impls.contains_key(im.did) {\n@@ -454,7 +456,7 @@ class lookup {\n                                              use_assignability: bool) {\n \n         // Add inherent methods.\n-        alt optional_inherent_methods {\n+        match optional_inherent_methods {\n             none => {\n                 // Continue.\n             }\n@@ -473,7 +475,7 @@ class lookup {\n         }\n \n         // Add trait methods.\n-        alt self.fcx.ccx.trait_map.find(self.expr.id) {\n+        match self.fcx.ccx.trait_map.find(self.expr.id) {\n             none => {\n                 // Should only happen for placement new right now.\n             }\n@@ -484,7 +486,7 @@ class lookup {\n                            self.def_id_to_str(trait_id)};\n \n                     let coherence_info = self.fcx.ccx.coherence_info;\n-                    alt coherence_info.extension_methods.find(trait_id) {\n+                    match coherence_info.extension_methods.find(trait_id) {\n                         none => {\n                             // Do nothing.\n                         }\n@@ -523,7 +525,7 @@ class lookup {\n         // Make the actual receiver type (cand.self_ty) assignable to the\n         // required receiver type (cand.rcvr_ty).  If this method is not\n         // from an impl, this'll basically be a no-nop.\n-        alt self.fcx.mk_assignty(self.self_expr, self.borrow_lb,\n+        match self.fcx.mk_assignty(self.self_expr, self.borrow_lb,\n                                  cand.self_ty, cand.rcvr_ty) {\n           result::ok(_) => (),\n           result::err(_) => {"}, {"sha": "03a27e88c9784cce5bde52cf9ed1edf164e9fe1f", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99", "patch": "@@ -104,7 +104,7 @@ fn visit_local(l: @ast::local, &&rcx: @rcx, v: rvt) {\n \n fn visit_pat(p: @ast::pat, &&rcx: @rcx, v: rvt) {\n     let fcx = rcx.fcx;\n-    alt p.node {\n+    match p.node {\n       ast::pat_ident(_, path, _)\n       if !pat_util::pat_is_variant(fcx.ccx.tcx.def_map, p) => {\n         debug!{\"visit_pat binding=%s\", *path.idents[0]};\n@@ -123,14 +123,14 @@ fn visit_block(b: ast::blk, &&rcx: @rcx, v: rvt) {\n fn visit_expr(e: @ast::expr, &&rcx: @rcx, v: rvt) {\n     debug!{\"visit_expr(e=%s)\", pprust::expr_to_str(e)};\n \n-    alt e.node {\n+    match e.node {\n       ast::expr_path(*) => {\n         // Avoid checking the use of local variables, as we already\n         // check their definitions.  The def'n always encloses the\n         // use.  So if the def'n is enclosed by the region, then the\n         // uses will also be enclosed (and otherwise, an error will\n         // have been reported at the def'n site).\n-        alt lookup_def(rcx.fcx, e.span, e.id) {\n+        match lookup_def(rcx.fcx, e.span, e.id) {\n           ast::def_local(*) | ast::def_arg(*) | ast::def_upvar(*) => return,\n           _ => ()\n         }\n@@ -150,12 +150,12 @@ fn visit_expr(e: @ast::expr, &&rcx: @rcx, v: rvt) {\n         // is an extensive comment on the function\n         // check_cast_for_escaping_regions() in kind.rs explaining how\n         // it goes about doing that.\n-        alt rcx.resolve_node_type(e.id) {\n+        match rcx.resolve_node_type(e.id) {\n           result::err(_) => { return; /* typeck will fail anyhow */ }\n           result::ok(target_ty) => {\n-            alt ty::get(target_ty).struct {\n+            match ty::get(target_ty).struct {\n               ty::ty_trait(_, substs) => {\n-                let trait_region = alt substs.self_r {\n+                let trait_region = match substs.self_r {\n                   some(r) => {r}\n                   none => {ty::re_static}\n                 };\n@@ -191,7 +191,7 @@ fn visit_node(id: ast::node_id, span: span, rcx: @rcx) -> bool {\n     // Try to resolve the type.  If we encounter an error, then typeck\n     // is going to fail anyway, so just stop here and let typeck\n     // report errors later on in the writeback phase.\n-    let ty = alt rcx.resolve_node_type(id) {\n+    let ty = match rcx.resolve_node_type(id) {\n       result::err(_) => return true,\n       result::ok(ty) => ty\n     };\n@@ -232,7 +232,7 @@ fn constrain_regions_in_type(\n                ppaux::region_to_str(tcx, encl_region),\n                ppaux::region_to_str(tcx, region)};\n \n-        alt region {\n+        match region {\n           ty::re_bound(_) => {\n             // a bound region is one which appears inside an fn type.\n             // (e.g., the `&` in `fn(&T)`).  Such regions need not be\n@@ -243,7 +243,7 @@ fn constrain_regions_in_type(\n           _ => ()\n         }\n \n-        alt rcx.fcx.mk_subr(encl_region, region) {\n+        match rcx.fcx.mk_subr(encl_region, region) {\n           result::err(_) => {\n             let region1 = rcx.fcx.infcx.resolve_region_if_possible(region);\n             tcx.sess.span_err("}, {"sha": "b9073f97399a04e1ad9d2291dcfc3918a3b8b63d", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "ec8e89ef2ada2396acbe6e1529dca9dda556249c", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "fc5a376361551bc615f95ffc0112e8a71907223c", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "c6633efe43f9f2eeb4ae84b394fe272d2c088693", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "c1211d79a7e4dde5f7cf7a23e4284477e65930fc", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "8c9cbc0759873ea79d9be76467fa4cca518abbde", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "906f3b7bdb3ec557056d95e798a6d6b68d436c51", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "1f180bfb76428fa9227cbec1ba4b510eee99a64f", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "655587b165d264d0b328df980cf9a10d59d8aee1", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "c590a1ac61ecfacc0e7e9ea6593659752a75fab4", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "0a404ce1f51cea82033bd86e761cc376124c6545", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "9a03a3e44558c115758ee6024f73ba341a9744f8", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "661eb3f879ec2723d95423624f2c26d795a9a5bb", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "6fb1faa44832aecd4df0e7500f411d128fe86b5f", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "b8be338bffd4bc62b7785bd7bcd71069dab21e73", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "45d4882a87b7ab16975fd1bcf6a55ad7e83548c4", "filename": "src/rustdoc/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ffold.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "9a58d0c917975b08f87e54657ee45b225fd57f3f", "filename": "src/rustdoc/markdown_index_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_index_pass.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "dbba57960c0d686033f4c06903d6c0763e9e2b37", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "a3b40a1caaab6d8efb1ac978081c1aa8da22f441", "filename": "src/rustdoc/markdown_writer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_writer.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "09543ae59ca364328d04e37c546888be5813ae37", "filename": "src/rustdoc/page_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpage_pass.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "970c081903aec6ad79f653cb9dbc0763bca551d2", "filename": "src/rustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_hidden_pass.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "eb6c88c62e795109d97e0cf2a8a961ae2c0cafd5", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "0ff86ecbcbeff030cf45f5426673b237012f2a71", "filename": "src/rustdoc/sectionalize_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsectionalize_pass.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "1d619f0a8f117da4bfe7bee293a802549c80d61c", "filename": "src/rustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_item_type_pass.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "ba3b9f74ab3d79d554c0b151336c1a8a6c8aefd3", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "b34ba63404ca253846c8c2a238532435d4b41cdc", "filename": "src/test/auxiliary/issue2378a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fauxiliary%2Fissue2378a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fauxiliary%2Fissue2378a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue2378a.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "dd92b28c41c9d0c4ba4f5b1381efb966b7b0f839", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "d510b978f93ba6f35877651e35ecbd521ae18197", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "423cec10f5aa36bcd0512e4e10e2f6a59aec1a89", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "60cc52825e84d5ffaa930211fdb56a2806a529f7", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "42df57f5bf3640ec0ff4c27c7739aa15c6463ce0", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "adbf62532141673120a6086dbe8661b00fca4b24", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "17830af6869f6746601ad4d6b02f4d2869f9d855", "filename": "src/test/bench/pingpong.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "c9a984117daf40ca707ee2ed497f1b8cd8f8135e", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "fd367181df47368d1c44e74e054817af6dd1a078", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "7aed4749eed5f4b6fe15250f99a1494726d8486d", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "6eeb50d52f5e01316a71e3374bfe445f7491ecd5", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "93a1d60ff7f605067f91c49374918c793916c007", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "4b4d41e72ba1c4e556f2a514644785b3f29bd7f4", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "26bc2b739fab83ebbf5199c323d5261818dd0d10", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "eac1f67dcaa1b5c8e7f430ac2ac79ec2ef518c4c", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "7b434a5f255c846f86f7b10cc61245f4db72d351", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "2281939b57a956b86d31ca90f71fcaa171714d64", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "7b973633c7d39c44c7a41f9ef21957b418972ee1", "filename": "src/test/compile-fail/alt-arrows-block-then-binop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Falt-arrows-block-then-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Falt-arrows-block-then-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-arrows-block-then-binop.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "83dcc69609e51f6161df936ce2734f133d54bcf0", "filename": "src/test/compile-fail/alt-join.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-join.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "617bb16862900ebf313b1339eafa2f802b9ea36d", "filename": "src/test/compile-fail/alt-pattern-field-mismatch-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Falt-pattern-field-mismatch-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Falt-pattern-field-mismatch-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-pattern-field-mismatch-2.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "9a54985efc17e932d90150f3657c3b7e64951bf0", "filename": "src/test/compile-fail/alt-pattern-field-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Falt-pattern-field-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Falt-pattern-field-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-pattern-field-mismatch.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "f58d08652656a35d3549a1399eac8376bbbd8456", "filename": "src/test/compile-fail/alt-range-fail-dominate.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Falt-range-fail-dominate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Falt-range-fail-dominate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-range-fail-dominate.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "229b5c47eba8037b4af11f9706e43a1b025c5bdc", "filename": "src/test/compile-fail/alt-range-fail.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Falt-range-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Falt-range-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-range-fail.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "9f7b471221dd75c019dec7d167dbdca14d5afd43", "filename": "src/test/compile-fail/alt-tag-nullary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Falt-tag-nullary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Falt-tag-nullary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-tag-nullary.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "5902454c46155098f83599c44400236f15617b90", "filename": "src/test/compile-fail/alt-tag-unary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Falt-tag-unary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Falt-tag-unary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-tag-unary.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "041f84bc6ee0ed3ce6c4dfdcc3e9f49facdef865", "filename": "src/test/compile-fail/bad-alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fbad-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fbad-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-alt.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "c043a07604292f8a685f05d56f065c5bd1af2e8b", "filename": "src/test/compile-fail/bad-record-pat-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fbad-record-pat-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fbad-record-pat-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-record-pat-2.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "d7e7fb16ad82d584750ce50a222415a09a79d662", "filename": "src/test/compile-fail/bad-record-pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fbad-record-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fbad-record-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-record-pat.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "06cfb60e1a81ca0ca0886a386d3b7c9d62448700", "filename": "src/test/compile-fail/bogus-tag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "57c0375f4e4b25fb2c07e820043f34f41ee94958", "filename": "src/test/compile-fail/borrowck-binding-mutbl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fborrowck-binding-mutbl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fborrowck-binding-mutbl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-binding-mutbl.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "f8cbb52d996396bd58d87f2ef904d9bcb5c05409", "filename": "src/test/compile-fail/borrowck-issue-2657-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "ab6e63174aa2f76287038093695dfde2bbcfef75", "filename": "src/test/compile-fail/borrowck-issue-2657-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "ef696048219a5e64fa0ca5cf7b65c73b889c9237", "filename": "src/test/compile-fail/borrowck-no-cycle-in-exchange-heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fborrowck-no-cycle-in-exchange-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fborrowck-no-cycle-in-exchange-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-no-cycle-in-exchange-heap.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "cd4893f87f2a9b4fca2df9dff50a52949d70f2f9", "filename": "src/test/compile-fail/borrowck-pat-enum-in-box.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "b29321ed818e3a6b38a783cf677e7ae00f5e0dcb", "filename": "src/test/compile-fail/borrowck-pat-enum.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "02604f6522712d6a74fd687da7c3c4bae105f3b4", "filename": "src/test/compile-fail/borrowck-pat-reassign-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "42dd5024603c3fa18b6bfc43e904be08fe5585a3", "filename": "src/test/compile-fail/borrowck-pat-reassign-sometimes-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "86a855de6f18b7ea1def6a5ef761fbb352261d46", "filename": "src/test/compile-fail/borrowck-unchecked-with-borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fborrowck-unchecked-with-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fborrowck-unchecked-with-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-unchecked-with-borrow.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "8c23b1db2dec004d7c4bf693112e3cda92e265d9", "filename": "src/test/compile-fail/deref-non-pointer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fderef-non-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fderef-non-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderef-non-pointer.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "e9a5d91c9d2b514fbd345657eb8c08071aea1c62", "filename": "src/test/compile-fail/issue-1193.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fissue-1193.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fissue-1193.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1193.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "7c7ec4f5f8fa7aa183088da5a1f933158a056963", "filename": "src/test/compile-fail/issue-2111.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fissue-2111.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fissue-2111.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2111.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "ebda510e87983d2f557b56f3c38a7949343ef2ab", "filename": "src/test/compile-fail/issue-2354.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fissue-2354.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fissue-2354.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2354.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "c721887e496f0f7b2346c1e6c86081238a1b94d8", "filename": "src/test/compile-fail/issue-2848.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fissue-2848.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fissue-2848.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2848.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "5e8a9905c2fdd158f8d3d002badb00556c552d10", "filename": "src/test/compile-fail/issue-2849.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fissue-2849.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fissue-2849.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2849.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "ec66d3bafe6f78a85a5826849e50cc0bd4d9e382", "filename": "src/test/compile-fail/issue-3038.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fissue-3038.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fissue-3038.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3038.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "5f488c4dc5a9906760d6c2eada3525d589c0b8a4", "filename": "src/test/compile-fail/liveness-missing-ret2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fliveness-missing-ret2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fliveness-missing-ret2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-missing-ret2.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "c1d4cdb4a57d5a885b6fc3bdcc0c264a2d876cd5", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "01641f5b9c7d482443f623d98895bf239beef189", "filename": "src/test/compile-fail/non-exhaustive-match-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "173fd2b41097064fb1b38a161a634da272bec752", "filename": "src/test/compile-fail/non-exhaustive-match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "e8c8f32b72fdf828465eee8e658da2155450ebd1", "filename": "src/test/compile-fail/occurs-check-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Foccurs-check-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Foccurs-check-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foccurs-check-3.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "f309ead4623bd200676bf94d6263c789596e3e31", "filename": "src/test/compile-fail/or-patter-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2For-patter-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2For-patter-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2For-patter-mismatch.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "f1e8224efc5c15339fc7e988c529a880768a506d", "filename": "src/test/compile-fail/pattern-tyvar-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "8b7c065dbf71175aa65440e1095e4dae1b835d9b", "filename": "src/test/compile-fail/pattern-tyvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "6cacf49300dda150060765db0d19ba7276ce5b38", "filename": "src/test/compile-fail/regions-creating-enums.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "c301d8199ded22f30637c4584bc0d1e8413dca1e", "filename": "src/test/compile-fail/restricted-keyword1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Frestricted-keyword1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Frestricted-keyword1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frestricted-keyword1.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "71875e92a8fd1cf678d7fa181dce8537f89f69b4", "filename": "src/test/compile-fail/unreachable-arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Funreachable-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fcompile-fail%2Funreachable-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funreachable-arm.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "3e3b4581f62b9e7e0cf4865911e45e9db1a797af", "filename": "src/test/pretty/alt-naked-expr-long.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fpretty%2Falt-naked-expr-long.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fpretty%2Falt-naked-expr-long.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Falt-naked-expr-long.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "9c6e74f48330f58e2f78327fc1be38595506e552", "filename": "src/test/pretty/alt-naked-expr-medium.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fpretty%2Falt-naked-expr-medium.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fpretty%2Falt-naked-expr-medium.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Falt-naked-expr-medium.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "0ad75ab68f94abfaaf5549727bbf9831ff2092f4", "filename": "src/test/pretty/alt-naked-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fpretty%2Falt-naked-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fpretty%2Falt-naked-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Falt-naked-expr.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "357a6d19fe422703cef84eb53bbf52f0c5dcecb2", "filename": "src/test/pretty/block-disambig.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-disambig.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "1e2c95fa3255b99ac786423011e920844934426d", "filename": "src/test/pretty/unary-op-disambig.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fpretty%2Funary-op-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Fpretty%2Funary-op-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Funary-op-disambig.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "da4ffdd5afc53ca3f2ce35a36881063d3ca499a6", "filename": "src/test/run-fail/alt-bot-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-fail%2Falt-bot-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-fail%2Falt-bot-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Falt-bot-fail.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "e3bc3c16384da39d20ae98f15efed1e54e38a25f", "filename": "src/test/run-fail/alt-disc-bot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-fail%2Falt-disc-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-fail%2Falt-disc-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Falt-disc-bot.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "39a381dd3aca614b9a10d24fa0bb521264b8f823", "filename": "src/test/run-fail/alt-wildcards.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-fail%2Falt-wildcards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-fail%2Falt-wildcards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Falt-wildcards.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "6c21859baebd7da2fe9009ca7ba91f3c7f2c189e", "filename": "src/test/run-fail/expr-alt-fail-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-fail%2Fexpr-alt-fail-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-fail%2Fexpr-alt-fail-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexpr-alt-fail-fn.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "a7f19c6d3ce57b7f13f612d174d4c46a1370f34e", "filename": "src/test/run-fail/expr-alt-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-fail%2Fexpr-alt-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-fail%2Fexpr-alt-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexpr-alt-fail.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "ddbd1200fcf4df433d969574c0f2d4da08da4462", "filename": "src/test/run-fail/fail-parens.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-fail%2Ffail-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-fail%2Ffail-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-parens.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "d18c7de3d3474a42c5affd56422ad6c6362435f4", "filename": "src/test/run-fail/issue-2156.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-fail%2Fissue-2156.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-fail%2Fissue-2156.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-2156.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "579067927ca9faedd02b7a478ade020cb670ea24", "filename": "src/test/run-fail/unwind-alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-fail%2Funwind-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-fail%2Funwind-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-alt.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "289018013d3532f0f1600c58f21c0990efb98a6d", "filename": "src/test/run-pass/alt-arrows-blocky-commas.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-arrows-blocky-commas.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-arrows-blocky-commas.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-arrows-blocky-commas.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "8b9f606d8d8a7bf2d4b8b252b8bc443e39702f2d", "filename": "src/test/run-pass/alt-bot-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-bot-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-bot-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-bot-2.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "06b6eca4b8354f759b289482780e312fd72616bc", "filename": "src/test/run-pass/alt-bot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-bot.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "eca726e827782e7578aede7ea5f9fcfe643d2b30", "filename": "src/test/run-pass/alt-implicit-copy-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-implicit-copy-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-implicit-copy-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-implicit-copy-unique.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "f4d14cbc728bc366477a7f1e50668c10702ce363", "filename": "src/test/run-pass/alt-implicit-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-implicit-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-implicit-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-implicit-copy.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "5c51fd0d34da17ecb014c8b475c7a745f045e8dd", "filename": "src/test/run-pass/alt-join.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-join.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "df2e9f5acd862dde36fe7f55a36b924146e7f2ca", "filename": "src/test/run-pass/alt-naked-record-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-naked-record-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-naked-record-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-naked-record-expr.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "042861d0a861e6e288f0ab0518271cda473f5933", "filename": "src/test/run-pass/alt-naked-record.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-naked-record.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-naked-record.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-naked-record.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "cd8b21fc2481ea95ae3d77d8ed7ca433dbc2a700", "filename": "src/test/run-pass/alt-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-path.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "ba8bef7e124a0553d79d2d4643215fb6cb5266a8", "filename": "src/test/run-pass/alt-pattern-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "e5f86159421338efd8e8a992711afe0dfc3dfa2c", "filename": "src/test/run-pass/alt-pattern-lit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "447fd417e8d3fafb1d3644824dfb7eeee5251214", "filename": "src/test/run-pass/alt-pattern-no-type-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-pattern-no-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-pattern-no-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-no-type-params.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "fd31a235ba9909c741174380d91b96cecead0342", "filename": "src/test/run-pass/alt-pattern-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-pattern-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-pattern-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-simple.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "cea0e1b4533539681e71d3d1ddb1e57d99808b97", "filename": "src/test/run-pass/alt-phi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-phi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-phi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-phi.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "f3713fabb13bb790892f580db6e8f70c8c8c7141", "filename": "src/test/run-pass/alt-range.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-range.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "98754ecf0e28cb470d1e8c142c333a6015f1f50a", "filename": "src/test/run-pass/alt-str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-str.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "0c75cafa204b79e882378016888078b43d5d9c73", "filename": "src/test/run-pass/alt-tag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-tag.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "4881a6bba4a94cda3c7edcb8e830763948ca01b9", "filename": "src/test/run-pass/alt-type-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-type-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-type-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-type-simple.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "7548d171d1c0d2d248bb35f4a4d50db1b46b257c", "filename": "src/test/run-pass/alt-unique-bind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-unique-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-unique-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-unique-bind.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "c07391b691baec80bf81cc7e5c2f98bc6ed243d6", "filename": "src/test/run-pass/alt-with-ret-arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "86bdd52c6af16b8b35ef8ddc7ef373a960a49517", "filename": "src/test/run-pass/binary-minus-without-space.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fbinary-minus-without-space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fbinary-minus-without-space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinary-minus-without-space.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "db941d32e11ad768b33676a03cf5b96a93d9b085", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "5f4804c778b714ed9a8180d7c8f965cd82f63274", "filename": "src/test/run-pass/borrowck-pat-reassign-no-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fborrowck-pat-reassign-no-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fborrowck-pat-reassign-no-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-pat-reassign-no-binding.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "58694e8f1353e0fed99524290ee46117a6c3c7c1", "filename": "src/test/run-pass/borrowck-preserve-box-in-arm-not-taken.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-arm-not-taken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-arm-not-taken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-arm-not-taken.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "101f9c787d31205232b4bb60c3d1c3bccab685c9", "filename": "src/test/run-pass/borrowck-preserve-box-in-discr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "c5d5fd96673345100d5e60926a63fcee0231c98f", "filename": "src/test/run-pass/borrowck-preserve-box-in-pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "11bc8e6fa7fb9f17630ea4897770be438a66f9d6", "filename": "src/test/run-pass/borrowck-preserve-box-sometimes-needed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-sometimes-needed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-sometimes-needed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-sometimes-needed.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "15f22e7ced8656875259d0d5467b6a2bcd431ec1", "filename": "src/test/run-pass/borrowck-univariant-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "90228f3dcf25ebaa6fcfeec8e6e96780f71f6a77", "filename": "src/test/run-pass/box-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fbox-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fbox-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-pattern.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "fc85484193c8f56d48328d21d53c8d9a5112c102", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "4a39797066936745d18fdec6c90d732ec2957ea0", "filename": "src/test/run-pass/drop-on-empty-block-exit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fdrop-on-empty-block-exit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fdrop-on-empty-block-exit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-on-empty-block-exit.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "eb49160ce6f16cc5ccad0d27b7d7518fa24195d8", "filename": "src/test/run-pass/expr-alt-box.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fexpr-alt-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fexpr-alt-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-box.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "bd55f4d663e41662ae624708bee8fc13e6c9c085", "filename": "src/test/run-pass/expr-alt-fail-all.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fexpr-alt-fail-all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fexpr-alt-fail-all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-fail-all.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "a490aac5c95f9a2f7a895e90115a0a10c2068e21", "filename": "src/test/run-pass/expr-alt-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fexpr-alt-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fexpr-alt-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-fail.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "40121de92db96dff1876f20dacc414ebdfe6a3c9", "filename": "src/test/run-pass/expr-alt-generic-box1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "73c6a4b68b4c6a3494dbaa65e51b1441b289b8b9", "filename": "src/test/run-pass/expr-alt-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "420cb030134bf79965b9d59ec3229be6a7af1190", "filename": "src/test/run-pass/expr-alt-generic-unique1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}, {"sha": "c425bedcef97d46579ceb08e6faa9928870160c3", "filename": "src/test/run-pass/expr-alt-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecaf9e39c9435fa2de4fe393c4b263be36eb2d99/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs?ref=ecaf9e39c9435fa2de4fe393c4b263be36eb2d99"}]}