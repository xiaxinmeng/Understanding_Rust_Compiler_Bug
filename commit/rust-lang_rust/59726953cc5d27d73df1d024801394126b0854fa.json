{"sha": "59726953cc5d27d73df1d024801394126b0854fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5NzI2OTUzY2M1ZDI3ZDczZGYxZDAyNDgwMTM5NDEyNmIwODU0ZmE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-23T09:14:06Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-23T17:58:46Z"}, "message": "Rollup merge of #22514 - diamondman:intro_doc_threading, r=steveklabnik\n\n Fixed example threaded code in intro doc never printing results. Threads were created with Thread::spawn instead of Thread::scoped. Also added correct thread handling like in the first example of the document.", "tree": {"sha": "ef462fbcba1f6ad5e055f11baef09e5b384b9475", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef462fbcba1f6ad5e055f11baef09e5b384b9475"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59726953cc5d27d73df1d024801394126b0854fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59726953cc5d27d73df1d024801394126b0854fa", "html_url": "https://github.com/rust-lang/rust/commit/59726953cc5d27d73df1d024801394126b0854fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59726953cc5d27d73df1d024801394126b0854fa/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1517313a74b34805ab1beaea0335dd7dbdd046a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1517313a74b34805ab1beaea0335dd7dbdd046a1", "html_url": "https://github.com/rust-lang/rust/commit/1517313a74b34805ab1beaea0335dd7dbdd046a1"}, {"sha": "6154c88ddcbe7ffacbf72a9acf508a377bbb96a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/6154c88ddcbe7ffacbf72a9acf508a377bbb96a7", "html_url": "https://github.com/rust-lang/rust/commit/6154c88ddcbe7ffacbf72a9acf508a377bbb96a7"}], "stats": {"total": 64, "additions": 30, "deletions": 34}, "files": [{"sha": "c9d834ee123bb55f6bce8e16dff8ef94ef89d8ba", "filename": "src/doc/intro.md", "status": "modified", "additions": 30, "deletions": 34, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/59726953cc5d27d73df1d024801394126b0854fa/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/59726953cc5d27d73df1d024801394126b0854fa/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=59726953cc5d27d73df1d024801394126b0854fa", "patch": "@@ -426,39 +426,33 @@ use std::thread::Thread;\n fn main() {\n     let mut numbers = vec![1, 2, 3];\n \n-    for i in 0..3 {\n-        Thread::spawn(move || {\n+    let guards: Vec<_> = (0..3).map(|i| {\n+        Thread::scoped(move || {\n             for j in 0..3 { numbers[j] += 1 }\n         });\n-    }\n+    }).collect();\n }\n ```\n \n It gives us this error:\n \n ```text\n-6:71 error: capture of moved value: `numbers`\n-    for j in 0..3 { numbers[j] += 1 }\n-                    ^~~~~~~\n-7:50 note: `numbers` moved into closure environment here\n-    spawn(move || {\n-        for j in 0..3 { numbers[j] += 1 }\n-    });\n-6:79 error: cannot assign to immutable dereference (dereference is implicit, due to indexing)\n-        for j in 0..3 { numbers[j] += 1 }\n-                        ^~~~~~~~~~~~~~~\n+7:29: 9:10 error: cannot move out of captured outer variable in an `FnMut` closure\n+7         Thread::scoped(move || {\n+8             for j in 0..3 { numbers[j] += 1 }\n+9         });\n ```\n \n-It mentions that \"numbers moved into closure environment\". Because we\n-declared the closure as a moving closure, and it referred to\n-`numbers`, the closure will try to take ownership of the vector. But\n-the closure itself is created in a loop, and hence we will actually\n-create three closures, one for every iteration of the loop. This means\n-that all three of those closures would try to own `numbers`, which is\n-impossible -- `numbers` must have just one owner. Rust detects this\n-and gives us the error: we claim that `numbers` has ownership, but our\n-code tries to make three owners. This may cause a safety problem, so\n-Rust disallows it.\n+It mentions that \"captured outer variable in an `FnMut` closure\".\n+Because we declared the closure as a moving closure, and it referred\n+to `numbers`, the closure will try to take ownership of the\n+vector. But the closure itself is created in a loop, and hence we will\n+actually create three closures, one for every iteration of the\n+loop. This means that all three of those closures would try to own\n+`numbers`, which is impossible -- `numbers` must have just one\n+owner. Rust detects this and gives us the error: we claim that\n+`numbers` has ownership, but our code tries to make three owners. This\n+may cause a safety problem, so Rust disallows it.\n \n What to do here? Rust has two types that helps us: `Arc<T>` and `Mutex<T>`.\n *Arc* stands for \"atomically reference counted\". In other words, an Arc will\n@@ -480,14 +474,14 @@ use std::sync::{Arc,Mutex};\n fn main() {\n     let numbers = Arc::new(Mutex::new(vec![1, 2, 3]));\n \n-    for i in 0..3 {\n+    let guards: Vec<_> = (0..3).map(|i| {\n         let number = numbers.clone();\n-        Thread::spawn(move || {\n+        Thread::scoped(move || {\n             let mut array = number.lock().unwrap();\n             array[i] += 1;\n             println!(\"numbers[{}] is {}\", i, array[i]);\n         });\n-    }\n+    }).collect();\n }\n ```\n \n@@ -516,8 +510,10 @@ numbers[1] is 3\n numbers[0] is 2\n ```\n \n-Each time, we get a slightly different output, because each thread works in a\n-different order. You may not get the same output as this sample, even.\n+Each time, we can get a slithtly different output because the threads\n+are not quaranteed to run in any set order. If you get the same order\n+every time it is because each of these threads are very small and\n+complete too fast for their indeterminate behavior to surface.\n \n The important part here is that the Rust compiler was able to use ownership to\n give us assurance _at compile time_ that we weren't doing something incorrect\n@@ -539,13 +535,13 @@ safety check that makes this an error about moved values:\n use std::thread::Thread;\n \n fn main() {\n-    let vec = vec![1, 2, 3];\n-\n-    for i in 0..3 {\n-        Thread::spawn(move || {\n-            println!(\"{}\", vec[i]);\n+    let numbers = vec![1, 2, 3];\n+    \n+    let guards: Vec<_> = (0..3).map(|i| {\n+        Thread::scoped(move || {\n+            println!(\"{}\", numbers[i]);\n         });\n-    }\n+    }).collect();\n }\n ```\n "}]}