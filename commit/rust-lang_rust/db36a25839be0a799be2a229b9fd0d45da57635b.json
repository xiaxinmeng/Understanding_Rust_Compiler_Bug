{"sha": "db36a25839be0a799be2a229b9fd0d45da57635b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiMzZhMjU4MzliZTBhNzk5YmUyYTIyOWI5ZmQwZDQ1ZGE1NzYzNWI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-08T12:26:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-08T12:26:33Z"}, "message": "Merge #4683\n\n4683: Implement syntax highlighting for doctests r=ltentrup a=ltentrup\n\nThe implementation is more complicated than the previous injection logic as the doctest comments consist of multiple ranges. The implementation extracts the doctests together with an offset-mapping, applies the syntax highlighting, and updates the text ranges.\r\n\r\n<img width=\"478\" alt=\"Bildschirmfoto 2020-06-01 um 15 45 25\" src=\"https://user-images.githubusercontent.com/201808/83415249-1f0b5800-a41f-11ea-8fa6-c282434d6ff7.png\">\r\n\r\nPart of #4170.\n\nCo-authored-by: Leander Tentrup <leander.tentrup@gmail.com>", "tree": {"sha": "c6787e78879c7c2c86938e8d7c659fd756609ffd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6787e78879c7c2c86938e8d7c659fd756609ffd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db36a25839be0a799be2a229b9fd0d45da57635b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe3i55CRBK7hj4Ov3rIwAAdHIIAJdqH57AKOYk3ZH7Yam/661r\nAj3Dm2dWfi++Bx/eA0++eNu+rvky3z+0uFmq1SaFEcFJ+s6Xvvaaz/HC6Aa3NFkZ\nDnirHpzeikUO4NNKIUV9QUwNPsOFv/dedWgQChf65/KbXk1d/frbZ9/HPsRH69po\nDy/JfW7d9mqs4t23TyOTcSz3HFuAttLLAtIMHO4X4PsuIotT7DMjVp3pGSnfCwtX\nz10LS16G2lfzVD3tVGnRCRoIN1vLH+ebh2EGttbhXKmXj/WvzLYaYP0KOACewMia\nyvnaIcPPfCITTOKJyWD62WRf6y3kOXXKnCVhPJtpiVoeYPdHC4e9DLuhW5ms+sU=\n=NO59\n-----END PGP SIGNATURE-----\n", "payload": "tree c6787e78879c7c2c86938e8d7c659fd756609ffd\nparent ab86f15ff2c237ac3f4237961e4484ae71cedf00\nparent 4a2efb2f42494f62891ac801e0a27d246bd36684\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1591619193 +0000\ncommitter GitHub <noreply@github.com> 1591619193 +0000\n\nMerge #4683\n\n4683: Implement syntax highlighting for doctests r=ltentrup a=ltentrup\n\nThe implementation is more complicated than the previous injection logic as the doctest comments consist of multiple ranges. The implementation extracts the doctests together with an offset-mapping, applies the syntax highlighting, and updates the text ranges.\r\n\r\n<img width=\"478\" alt=\"Bildschirmfoto 2020-06-01 um 15 45 25\" src=\"https://user-images.githubusercontent.com/201808/83415249-1f0b5800-a41f-11ea-8fa6-c282434d6ff7.png\">\r\n\r\nPart of #4170.\n\nCo-authored-by: Leander Tentrup <leander.tentrup@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db36a25839be0a799be2a229b9fd0d45da57635b", "html_url": "https://github.com/rust-lang/rust/commit/db36a25839be0a799be2a229b9fd0d45da57635b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db36a25839be0a799be2a229b9fd0d45da57635b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab86f15ff2c237ac3f4237961e4484ae71cedf00", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab86f15ff2c237ac3f4237961e4484ae71cedf00", "html_url": "https://github.com/rust-lang/rust/commit/ab86f15ff2c237ac3f4237961e4484ae71cedf00"}, {"sha": "4a2efb2f42494f62891ac801e0a27d246bd36684", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a2efb2f42494f62891ac801e0a27d246bd36684", "html_url": "https://github.com/rust-lang/rust/commit/4a2efb2f42494f62891ac801e0a27d246bd36684"}], "stats": {"total": 414, "additions": 368, "deletions": 46}, "files": [{"sha": "2f2d8c900ef66d17b38f6b693fea1b4012de826e", "filename": "crates/ra_ide/src/snapshots/highlight_doctest.html", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/db36a25839be0a799be2a229b9fd0d45da57635b/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_doctest.html", "raw_url": "https://github.com/rust-lang/rust/raw/db36a25839be0a799be2a229b9fd0d45da57635b/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_doctest.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_doctest.html?ref=db36a25839be0a799be2a229b9fd0d45da57635b", "patch": "@@ -0,0 +1,70 @@\n+\n+<style>\n+body                { margin: 0; }\n+pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padding: 0.4em; }\n+\n+.lifetime           { color: #DFAF8F; font-style: italic; }\n+.comment            { color: #7F9F7F; }\n+.struct, .enum      { color: #7CB8BB; }\n+.enum_variant       { color: #BDE0F3; }\n+.string_literal     { color: #CC9393; }\n+.field              { color: #94BFF3; }\n+.function           { color: #93E0E3; }\n+.operator.unsafe    { color: #E28C14; }\n+.parameter          { color: #94BFF3; }\n+.text               { color: #DCDCCC; }\n+.type               { color: #7CB8BB; }\n+.builtin_type       { color: #8CD0D3; }\n+.type_param         { color: #DFAF8F; }\n+.attribute          { color: #94BFF3; }\n+.numeric_literal    { color: #BFEBBF; }\n+.bool_literal       { color: #BFE6EB; }\n+.macro              { color: #94BFF3; }\n+.module             { color: #AFD8AF; }\n+.variable           { color: #DCDCCC; }\n+.format_specifier   { color: #CC696B; }\n+.mutable            { text-decoration: underline; }\n+\n+.keyword            { color: #F0DFAF; font-weight: bold; }\n+.keyword.unsafe     { color: #BC8383; font-weight: bold; }\n+.control            { font-style: italic; }\n+</style>\n+<pre><code><span class=\"keyword\">impl</span> <span class=\"unresolved_reference\">Foo</span> {\n+    <span class=\"comment\">/// Constructs a new `Foo`.</span>\n+    <span class=\"comment\">///</span>\n+    <span class=\"comment\">/// # Examples</span>\n+    <span class=\"comment\">///</span>\n+    <span class=\"comment\">/// ```</span>\n+    <span class=\"comment\">/// #</span> <span class=\"attribute\">#![</span><span class=\"function attribute\">allow</span><span class=\"attribute\">(unused_mut)]</span>\n+    <span class=\"comment\">/// </span><span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable declaration mutable\">foo</span>: <span class=\"unresolved_reference\">Foo</span> = <span class=\"unresolved_reference\">Foo</span>::<span class=\"unresolved_reference\">new</span>();\n+    <span class=\"comment\">/// ```</span>\n+    <span class=\"keyword\">pub</span> <span class=\"keyword\">const</span> <span class=\"keyword\">fn</span> <span class=\"function declaration\">new</span>() -&gt; <span class=\"unresolved_reference\">Foo</span> {\n+        <span class=\"unresolved_reference\">Foo</span> { }\n+    }\n+\n+    <span class=\"comment\">/// `bar` method on `Foo`.</span>\n+    <span class=\"comment\">///</span>\n+    <span class=\"comment\">/// # Examples</span>\n+    <span class=\"comment\">///</span>\n+    <span class=\"comment\">/// ```</span>\n+    <span class=\"comment\">/// </span><span class=\"keyword\">let</span> <span class=\"variable declaration\">foo</span> = <span class=\"unresolved_reference\">Foo</span>::<span class=\"unresolved_reference\">new</span>();\n+    <span class=\"comment\">///</span>\n+    <span class=\"comment\">/// </span><span class=\"comment\">// calls bar on foo</span>\n+    <span class=\"comment\">/// </span><span class=\"macro\">assert!</span>(foo.bar());\n+    <span class=\"comment\">///</span>\n+    <span class=\"comment\">/// </span><span class=\"comment\">/* multi-line\n+    </span><span class=\"comment\">/// </span><span class=\"comment\">       comment */</span>\n+    <span class=\"comment\">///</span>\n+    <span class=\"comment\">/// </span><span class=\"keyword\">let</span> <span class=\"variable declaration\">multi_line_string</span> = <span class=\"string_literal\">\"Foo\n+    </span><span class=\"comment\">/// </span><span class=\"string_literal\">  bar\n+    </span><span class=\"comment\">/// </span><span class=\"string_literal\">         \"</span>;\n+    <span class=\"comment\">///</span>\n+    <span class=\"comment\">/// ```</span>\n+    <span class=\"comment\">///</span>\n+    <span class=\"comment\">/// ```</span>\n+    <span class=\"comment\">/// </span><span class=\"keyword\">let</span> <span class=\"variable declaration\">foobar</span> = <span class=\"unresolved_reference\">Foo</span>::<span class=\"unresolved_reference\">new</span>().<span class=\"unresolved_reference\">bar</span>();\n+    <span class=\"comment\">/// ```</span>\n+    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function declaration\">foo</span>(&<span class=\"self_keyword\">self</span>) -&gt; <span class=\"builtin_type\">bool</span> {\n+        <span class=\"bool_literal\">true</span>\n+    }\n+}</code></pre>\n\\ No newline at end of file"}, {"sha": "6903403b2fc2f3f35fa1be90f34126560866dd0b", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 80, "deletions": 46, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/db36a25839be0a799be2a229b9fd0d45da57635b/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db36a25839be0a799be2a229b9fd0d45da57635b/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=db36a25839be0a799be2a229b9fd0d45da57635b", "patch": "@@ -1,5 +1,6 @@\n mod tags;\n mod html;\n+mod injection;\n #[cfg(test)]\n mod tests;\n \n@@ -10,14 +11,14 @@ use ra_ide_db::{\n };\n use ra_prof::profile;\n use ra_syntax::{\n-    ast::{self, HasFormatSpecifier, HasQuotes, HasStringValue},\n+    ast::{self, HasFormatSpecifier},\n     AstNode, AstToken, Direction, NodeOrToken, SyntaxElement,\n     SyntaxKind::*,\n-    SyntaxToken, TextRange, WalkEvent, T,\n+    TextRange, WalkEvent, T,\n };\n use rustc_hash::FxHashMap;\n \n-use crate::{call_info::ActiveParameter, Analysis, FileId};\n+use crate::FileId;\n \n use ast::FormatSpecifier;\n pub(crate) use html::highlight_as_html;\n@@ -123,6 +124,23 @@ pub(crate) fn highlight(\n             _ => (),\n         }\n \n+        // Check for Rust code in documentation\n+        match &event {\n+            WalkEvent::Leave(NodeOrToken::Node(node)) => {\n+                if let Some((doctest, range_mapping, new_comments)) =\n+                    injection::extract_doc_comments(node)\n+                {\n+                    injection::highlight_doc_comment(\n+                        doctest,\n+                        range_mapping,\n+                        new_comments,\n+                        &mut stack,\n+                    );\n+                }\n+            }\n+            _ => (),\n+        }\n+\n         let element = match event {\n             WalkEvent::Enter(it) => it,\n             WalkEvent::Leave(_) => continue,\n@@ -173,7 +191,7 @@ pub(crate) fn highlight(\n \n         if let Some(token) = element.as_token().cloned().and_then(ast::RawString::cast) {\n             let expanded = element_to_highlight.as_token().unwrap().clone();\n-            if highlight_injection(&mut stack, &sema, token, expanded).is_some() {\n+            if injection::highlight_injection(&mut stack, &sema, token, expanded).is_some() {\n                 continue;\n             }\n         }\n@@ -259,9 +277,8 @@ impl HighlightedRangeStack {\n             let mut parent = prev.pop().unwrap();\n             for ele in children {\n                 assert!(parent.range.contains_range(ele.range));\n-                let mut cloned = parent.clone();\n-                parent.range = TextRange::new(parent.range.start(), ele.range.start());\n-                cloned.range = TextRange::new(ele.range.end(), cloned.range.end());\n+\n+                let cloned = Self::intersect(&mut parent, &ele);\n                 if !parent.range.is_empty() {\n                     prev.push(parent);\n                 }\n@@ -274,6 +291,62 @@ impl HighlightedRangeStack {\n         }\n     }\n \n+    /// Intersects the `HighlightedRange` `parent` with `child`.\n+    /// `parent` is mutated in place, becoming the range before `child`.\n+    /// Returns the range (of the same type as `parent`) *after* `child`.\n+    fn intersect(parent: &mut HighlightedRange, child: &HighlightedRange) -> HighlightedRange {\n+        assert!(parent.range.contains_range(child.range));\n+\n+        let mut cloned = parent.clone();\n+        parent.range = TextRange::new(parent.range.start(), child.range.start());\n+        cloned.range = TextRange::new(child.range.end(), cloned.range.end());\n+\n+        cloned\n+    }\n+\n+    /// Similar to `pop`, but can modify arbitrary prior ranges (where `pop`)\n+    /// can only modify the last range currently on the stack.\n+    /// Can be used to do injections that span multiple ranges, like the\n+    /// doctest injection below.\n+    /// If `delete` is set to true, the parent range is deleted instead of\n+    /// intersected.\n+    ///\n+    /// Note that `pop` can be simulated by `pop_and_inject(false)` but the\n+    /// latter is computationally more expensive.\n+    fn pop_and_inject(&mut self, delete: bool) {\n+        let mut children = self.stack.pop().unwrap();\n+        let prev = self.stack.last_mut().unwrap();\n+        children.sort_by_key(|range| range.range.start());\n+        prev.sort_by_key(|range| range.range.start());\n+\n+        for child in children {\n+            if let Some(idx) =\n+                prev.iter().position(|parent| parent.range.contains_range(child.range))\n+            {\n+                let cloned = Self::intersect(&mut prev[idx], &child);\n+                let insert_idx = if delete || prev[idx].range.is_empty() {\n+                    prev.remove(idx);\n+                    idx\n+                } else {\n+                    idx + 1\n+                };\n+                prev.insert(insert_idx, child);\n+                if !delete && !cloned.range.is_empty() {\n+                    prev.insert(insert_idx + 1, cloned);\n+                }\n+            } else if let Some(_idx) =\n+                prev.iter().position(|parent| parent.range.contains(child.range.start()))\n+            {\n+                unreachable!(\"child range should be completely contained in parent range\");\n+            } else {\n+                let idx = prev\n+                    .binary_search_by_key(&child.range.start(), |range| range.range.start())\n+                    .unwrap_or_else(|x| x);\n+                prev.insert(idx, child);\n+            }\n+        }\n+    }\n+\n     fn add(&mut self, range: HighlightedRange) {\n         self.stack\n             .last_mut()\n@@ -539,42 +612,3 @@ fn highlight_name_by_syntax(name: ast::Name) -> Highlight {\n \n     tag.into()\n }\n-\n-fn highlight_injection(\n-    acc: &mut HighlightedRangeStack,\n-    sema: &Semantics<RootDatabase>,\n-    literal: ast::RawString,\n-    expanded: SyntaxToken,\n-) -> Option<()> {\n-    let active_parameter = ActiveParameter::at_token(&sema, expanded)?;\n-    if !active_parameter.name.starts_with(\"ra_fixture\") {\n-        return None;\n-    }\n-    let value = literal.value()?;\n-    let (analysis, tmp_file_id) = Analysis::from_single_file(value);\n-\n-    if let Some(range) = literal.open_quote_text_range() {\n-        acc.add(HighlightedRange {\n-            range,\n-            highlight: HighlightTag::StringLiteral.into(),\n-            binding_hash: None,\n-        })\n-    }\n-\n-    for mut h in analysis.highlight(tmp_file_id).unwrap() {\n-        if let Some(r) = literal.map_range_up(h.range) {\n-            h.range = r;\n-            acc.add(h)\n-        }\n-    }\n-\n-    if let Some(range) = literal.close_quote_text_range() {\n-        acc.add(HighlightedRange {\n-            range,\n-            highlight: HighlightTag::StringLiteral.into(),\n-            binding_hash: None,\n-        })\n-    }\n-\n-    Some(())\n-}"}, {"sha": "3575a0fc6e9f84c6d4a4c77bd0df00d50ab48579", "filename": "crates/ra_ide/src/syntax_highlighting/injection.rs", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/db36a25839be0a799be2a229b9fd0d45da57635b/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Finjection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db36a25839be0a799be2a229b9fd0d45da57635b/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Finjection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Finjection.rs?ref=db36a25839be0a799be2a229b9fd0d45da57635b", "patch": "@@ -0,0 +1,168 @@\n+//! Syntax highlighting injections such as highlighting of documentation tests.\n+\n+use std::{collections::BTreeMap, convert::TryFrom};\n+\n+use ast::{HasQuotes, HasStringValue};\n+use hir::Semantics;\n+use ra_syntax::{ast, AstToken, SyntaxNode, SyntaxToken, TextRange, TextSize};\n+use stdx::SepBy;\n+\n+use crate::{call_info::ActiveParameter, Analysis, HighlightTag, HighlightedRange, RootDatabase};\n+\n+use super::HighlightedRangeStack;\n+\n+pub(super) fn highlight_injection(\n+    acc: &mut HighlightedRangeStack,\n+    sema: &Semantics<RootDatabase>,\n+    literal: ast::RawString,\n+    expanded: SyntaxToken,\n+) -> Option<()> {\n+    let active_parameter = ActiveParameter::at_token(&sema, expanded)?;\n+    if !active_parameter.name.starts_with(\"ra_fixture\") {\n+        return None;\n+    }\n+    let value = literal.value()?;\n+    let (analysis, tmp_file_id) = Analysis::from_single_file(value);\n+\n+    if let Some(range) = literal.open_quote_text_range() {\n+        acc.add(HighlightedRange {\n+            range,\n+            highlight: HighlightTag::StringLiteral.into(),\n+            binding_hash: None,\n+        })\n+    }\n+\n+    for mut h in analysis.highlight(tmp_file_id).unwrap() {\n+        if let Some(r) = literal.map_range_up(h.range) {\n+            h.range = r;\n+            acc.add(h)\n+        }\n+    }\n+\n+    if let Some(range) = literal.close_quote_text_range() {\n+        acc.add(HighlightedRange {\n+            range,\n+            highlight: HighlightTag::StringLiteral.into(),\n+            binding_hash: None,\n+        })\n+    }\n+\n+    Some(())\n+}\n+\n+/// Mapping from extracted documentation code to original code\n+type RangesMap = BTreeMap<TextSize, TextSize>;\n+\n+/// Extracts Rust code from documentation comments as well as a mapping from\n+/// the extracted source code back to the original source ranges.\n+/// Lastly, a vector of new comment highlight ranges (spanning only the\n+/// comment prefix) is returned which is used in the syntax highlighting\n+/// injection to replace the previous (line-spanning) comment ranges.\n+pub(super) fn extract_doc_comments(\n+    node: &SyntaxNode,\n+) -> Option<(String, RangesMap, Vec<HighlightedRange>)> {\n+    // wrap the doctest into function body to get correct syntax highlighting\n+    let prefix = \"fn doctest() {\\n\";\n+    let suffix = \"}\\n\";\n+    // Mapping from extracted documentation code to original code\n+    let mut range_mapping: RangesMap = BTreeMap::new();\n+    let mut line_start = TextSize::try_from(prefix.len()).unwrap();\n+    let mut is_doctest = false;\n+    // Replace the original, line-spanning comment ranges by new, only comment-prefix\n+    // spanning comment ranges.\n+    let mut new_comments = Vec::new();\n+    let doctest = node\n+        .children_with_tokens()\n+        .filter_map(|el| el.into_token().and_then(ast::Comment::cast))\n+        .filter(|comment| comment.kind().doc.is_some())\n+        .filter(|comment| {\n+            if comment.text().contains(\"```\") {\n+                is_doctest = !is_doctest;\n+                false\n+            } else {\n+                is_doctest\n+            }\n+        })\n+        .map(|comment| {\n+            let prefix_len = comment.prefix().len();\n+            let line: &str = comment.text().as_str();\n+            let range = comment.syntax().text_range();\n+\n+            // whitespace after comment is ignored\n+            let pos = if let Some(ws) = line.chars().nth(prefix_len).filter(|c| c.is_whitespace()) {\n+                prefix_len + ws.len_utf8()\n+            } else {\n+                prefix_len\n+            };\n+\n+            // lines marked with `#` should be ignored in output, we skip the `#` char\n+            let pos = if let Some(ws) = line.chars().nth(pos).filter(|&c| c == '#') {\n+                pos + ws.len_utf8()\n+            } else {\n+                pos\n+            };\n+\n+            range_mapping.insert(line_start, range.start() + TextSize::try_from(pos).unwrap());\n+            new_comments.push(HighlightedRange {\n+                range: TextRange::new(\n+                    range.start(),\n+                    range.start() + TextSize::try_from(pos).unwrap(),\n+                ),\n+                highlight: HighlightTag::Comment.into(),\n+                binding_hash: None,\n+            });\n+            line_start += range.len() - TextSize::try_from(pos).unwrap();\n+            line_start += TextSize::try_from('\\n'.len_utf8()).unwrap();\n+\n+            line[pos..].to_owned()\n+        })\n+        .sep_by(\"\\n\")\n+        .to_string();\n+\n+    if doctest.is_empty() {\n+        return None;\n+    }\n+\n+    let doctest = format!(\"{}{}{}\", prefix, doctest, suffix);\n+    Some((doctest, range_mapping, new_comments))\n+}\n+\n+/// Injection of syntax highlighting of doctests.\n+pub(super) fn highlight_doc_comment(\n+    text: String,\n+    range_mapping: RangesMap,\n+    new_comments: Vec<HighlightedRange>,\n+    stack: &mut HighlightedRangeStack,\n+) {\n+    let (analysis, tmp_file_id) = Analysis::from_single_file(text);\n+\n+    stack.push();\n+    for mut h in analysis.highlight(tmp_file_id).unwrap() {\n+        // Determine start offset and end offset in case of multi-line ranges\n+        let mut start_offset = None;\n+        let mut end_offset = None;\n+        for (line_start, orig_line_start) in range_mapping.range(..h.range.end()).rev() {\n+            if line_start <= &h.range.start() {\n+                start_offset.get_or_insert(orig_line_start - line_start);\n+                break;\n+            } else {\n+                end_offset.get_or_insert(orig_line_start - line_start);\n+            }\n+        }\n+        if let Some(start_offset) = start_offset {\n+            h.range = TextRange::new(\n+                h.range.start() + start_offset,\n+                h.range.end() + end_offset.unwrap_or(start_offset),\n+            );\n+            stack.add(h);\n+        }\n+    }\n+\n+    // Inject the comment prefix highlight ranges\n+    stack.push();\n+    for comment in new_comments {\n+        stack.add(comment);\n+    }\n+    stack.pop_and_inject(false);\n+    stack.pop_and_inject(true);\n+}"}, {"sha": "ba345d90a0396950ef043112f45d5e0c17f8985e", "filename": "crates/ra_ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/db36a25839be0a799be2a229b9fd0d45da57635b/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db36a25839be0a799be2a229b9fd0d45da57635b/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=db36a25839be0a799be2a229b9fd0d45da57635b", "patch": "@@ -284,3 +284,53 @@ fn main() {\n         false,\n     );\n }\n+\n+#[test]\n+fn test_highlight_doctest() {\n+    check_highlighting(\n+        r#\"\n+impl Foo {\n+    /// Constructs a new `Foo`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![allow(unused_mut)]\n+    /// let mut foo: Foo = Foo::new();\n+    /// ```\n+    pub const fn new() -> Foo {\n+        Foo { }\n+    }\n+\n+    /// `bar` method on `Foo`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let foo = Foo::new();\n+    ///\n+    /// // calls bar on foo\n+    /// assert!(foo.bar());\n+    ///\n+    /// /* multi-line\n+    ///        comment */\n+    ///\n+    /// let multi_line_string = \"Foo\n+    ///   bar\n+    ///          \";\n+    ///\n+    /// ```\n+    ///\n+    /// ```\n+    /// let foobar = Foo::new().bar();\n+    /// ```\n+    pub fn foo(&self) -> bool {\n+        true\n+    }\n+}\n+\"#\n+        .trim(),\n+        \"crates/ra_ide/src/snapshots/highlight_doctest.html\",\n+        false,\n+    )\n+}"}]}