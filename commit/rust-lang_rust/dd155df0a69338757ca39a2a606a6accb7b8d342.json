{"sha": "dd155df0a69338757ca39a2a606a6accb7b8d342", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkMTU1ZGYwYTY5MzM4NzU3Y2EzOWEyYTYwNmE2YWNjYjdiOGQzNDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-10T05:48:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-10T05:48:27Z"}, "message": "Auto merge of #69879 - Centril:rollup-ryea91j, r=Centril\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #69475 (Remove the `no_force` query attribute)\n - #69514 (Remove spotlight)\n - #69677 (rustc_metadata: Give decoder access to whole crate store)\n - #69714 (Make PlaceRef take just one lifetime)\n - #69799 (Allow ZSTs in `AllocRef`)\n - #69817 (test(patterns): add patterns feature tests to borrowck test suite)\n - #69836 (Check if output is immediate value)\n - #69847 (clean up E0393 explanation)\n - #69861 (Add note about localization to std::fmt docs)\n - #69877 (Vec::new is const stable in 1.39 not 1.32)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "1f4a4549551e14c95a31a995a46a57536212e686", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f4a4549551e14c95a31a995a46a57536212e686"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd155df0a69338757ca39a2a606a6accb7b8d342", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd155df0a69338757ca39a2a606a6accb7b8d342", "html_url": "https://github.com/rust-lang/rust/commit/dd155df0a69338757ca39a2a606a6accb7b8d342", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd155df0a69338757ca39a2a606a6accb7b8d342/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dbade652ed8ebac70f903e01f51cd92c4e4302c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dbade652ed8ebac70f903e01f51cd92c4e4302c", "html_url": "https://github.com/rust-lang/rust/commit/3dbade652ed8ebac70f903e01f51cd92c4e4302c"}, {"sha": "3e9efbd8b409faeaf97943699ce2a15ffb8fc629", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e9efbd8b409faeaf97943699ce2a15ffb8fc629", "html_url": "https://github.com/rust-lang/rust/commit/3e9efbd8b409faeaf97943699ce2a15ffb8fc629"}], "stats": {"total": 1811, "additions": 925, "deletions": 886}, "files": [{"sha": "f704fe8e099b85faab4279c6bf743c781ecf1db8", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -138,27 +138,6 @@ Book][unstable-doc-cfg] and [its tracking issue][issue-doc-cfg].\n [unstable-doc-cfg]: ../unstable-book/language-features/doc-cfg.html\n [issue-doc-cfg]: https://github.com/rust-lang/rust/issues/43781\n \n-### Adding your trait to the \"Important Traits\" dialog\n-\n-Rustdoc keeps a list of a few traits that are believed to be \"fundamental\" to a given type when\n-implemented on it. These traits are intended to be the primary interface for their types, and are\n-often the only thing available to be documented on their types. For this reason, Rustdoc will track\n-when a given type implements one of these traits and call special attention to it when a function\n-returns one of these types. This is the \"Important Traits\" dialog, visible as a circle-i button next\n-to the function, which, when clicked, shows the dialog.\n-\n-In the standard library, the traits that qualify for inclusion are `Iterator`, `io::Read`, and\n-`io::Write`. However, rather than being implemented as a hard-coded list, these traits have a\n-special marker attribute on them: `#[doc(spotlight)]`. This means that you could apply this\n-attribute to your own trait to include it in the \"Important Traits\" dialog in documentation.\n-\n-The `#[doc(spotlight)]` attribute currently requires the `#![feature(doc_spotlight)]` feature gate.\n-For more information, see [its chapter in the Unstable Book][unstable-spotlight] and [its tracking\n-issue][issue-spotlight].\n-\n-[unstable-spotlight]: ../unstable-book/language-features/doc-spotlight.html\n-[issue-spotlight]: https://github.com/rust-lang/rust/issues/45040\n-\n ### Exclude certain dependencies from documentation\n \n The standard library uses several dependencies which, in turn, use several types and traits from the"}, {"sha": "8117755fef1c8741f45648c178c98d37f4e3928d", "filename": "src/doc/unstable-book/src/language-features/doc-spotlight.md", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdoc-spotlight.md", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdoc-spotlight.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdoc-spotlight.md?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -1,30 +0,0 @@\n-# `doc_spotlight`\n-\n-The tracking issue for this feature is: [#45040]\n-\n-The `doc_spotlight` feature allows the use of the `spotlight` parameter to the `#[doc]` attribute,\n-to \"spotlight\" a specific trait on the return values of functions. Adding a `#[doc(spotlight)]`\n-attribute to a trait definition will make rustdoc print extra information for functions which return\n-a type that implements that trait. This attribute is applied to the `Iterator`, `io::Read`, and\n-`io::Write` traits in the standard library.\n-\n-You can do this on your own traits, like this:\n-\n-```\n-#![feature(doc_spotlight)]\n-\n-#[doc(spotlight)]\n-pub trait MyTrait {}\n-\n-pub struct MyStruct;\n-impl MyTrait for MyStruct {}\n-\n-/// The docs for this function will have an extra line about `MyStruct` implementing `MyTrait`,\n-/// without having to write that yourself!\n-pub fn my_fn() -> MyStruct { MyStruct }\n-```\n-\n-This feature was originally implemented in PR [#45039].\n-\n-[#45040]: https://github.com/rust-lang/rust/issues/45040\n-[#45039]: https://github.com/rust-lang/rust/pull/45039"}, {"sha": "9f82b2c6fa66d6a27085d71c1bb144387ff470c4", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -165,13 +165,19 @@ pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for Global {\n     #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        NonNull::new(alloc(layout)).ok_or(AllocErr).map(|p| (p, layout.size()))\n+    fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        if layout.size() == 0 {\n+            Ok((layout.dangling(), 0))\n+        } else {\n+            unsafe { NonNull::new(alloc(layout)).ok_or(AllocErr).map(|p| (p, layout.size())) }\n+        }\n     }\n \n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n-        dealloc(ptr.as_ptr(), layout)\n+        if layout.size() != 0 {\n+            dealloc(ptr.as_ptr(), layout)\n+        }\n     }\n \n     #[inline]\n@@ -181,12 +187,28 @@ unsafe impl AllocRef for Global {\n         layout: Layout,\n         new_size: usize,\n     ) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        NonNull::new(realloc(ptr.as_ptr(), layout, new_size)).ok_or(AllocErr).map(|p| (p, new_size))\n+        match (layout.size(), new_size) {\n+            (0, 0) => Ok((layout.dangling(), 0)),\n+            (0, _) => self.alloc(Layout::from_size_align_unchecked(new_size, layout.align())),\n+            (_, 0) => {\n+                self.dealloc(ptr, layout);\n+                Ok((layout.dangling(), 0))\n+            }\n+            (_, _) => NonNull::new(realloc(ptr.as_ptr(), layout, new_size))\n+                .ok_or(AllocErr)\n+                .map(|p| (p, new_size)),\n+        }\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        NonNull::new(alloc_zeroed(layout)).ok_or(AllocErr).map(|p| (p, layout.size()))\n+    fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        if layout.size() == 0 {\n+            Ok((layout.dangling(), 0))\n+        } else {\n+            unsafe {\n+                NonNull::new(alloc_zeroed(layout)).ok_or(AllocErr).map(|p| (p, layout.size()))\n+            }\n+        }\n     }\n }\n "}, {"sha": "13ef2f063f95faa5e0b584650bc48a39124acb13", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -247,6 +247,21 @@\n //! Hello, `     123` has 3 right-aligned characters\n //! ```\n //!\n+//! ## Localization\n+//!\n+//! In some programming languages, the behavior of string formatting functions\n+//! depends on the operating system's locale setting. The format functions\n+//! provided by Rust's standard library do not have any concept of locale, and\n+//! will produce the same results on all systems regardless of user\n+//! configuration.\n+//!\n+//! For example, the following code will always print `1.5` even if the system\n+//! locale uses a decimal separator other than a dot.\n+//!\n+//! ```\n+//! println!(\"The value is {}\", 1.5);\n+//! ```\n+//!\n //! # Escaping\n //!\n //! The literal characters `{` and `}` may be included in a string by preceding"}, {"sha": "b31fec7f037c966ba48bba4bf079827b20757430", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -73,30 +73,28 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     }\n \n     fn allocate_in(mut capacity: usize, zeroed: bool, mut a: A) -> Self {\n-        unsafe {\n-            let elem_size = mem::size_of::<T>();\n+        let elem_size = mem::size_of::<T>();\n \n-            let alloc_size = capacity.checked_mul(elem_size).unwrap_or_else(|| capacity_overflow());\n-            alloc_guard(alloc_size).unwrap_or_else(|_| capacity_overflow());\n+        let alloc_size = capacity.checked_mul(elem_size).unwrap_or_else(|| capacity_overflow());\n+        alloc_guard(alloc_size).unwrap_or_else(|_| capacity_overflow());\n \n-            // Handles ZSTs and `capacity == 0` alike.\n-            let ptr = if alloc_size == 0 {\n-                NonNull::<T>::dangling()\n-            } else {\n-                let align = mem::align_of::<T>();\n-                let layout = Layout::from_size_align(alloc_size, align).unwrap();\n-                let result = if zeroed { a.alloc_zeroed(layout) } else { a.alloc(layout) };\n-                match result {\n-                    Ok((ptr, size)) => {\n-                        capacity = size / elem_size;\n-                        ptr.cast()\n-                    }\n-                    Err(_) => handle_alloc_error(layout),\n+        // Handles ZSTs and `capacity == 0` alike.\n+        let ptr = if alloc_size == 0 {\n+            NonNull::<T>::dangling()\n+        } else {\n+            let align = mem::align_of::<T>();\n+            let layout = Layout::from_size_align(alloc_size, align).unwrap();\n+            let result = if zeroed { a.alloc_zeroed(layout) } else { a.alloc(layout) };\n+            match result {\n+                Ok((ptr, size)) => {\n+                    capacity = size / elem_size;\n+                    ptr.cast()\n                 }\n-            };\n+                Err(_) => handle_alloc_error(layout),\n+            }\n+        };\n \n-            RawVec { ptr: ptr.into(), cap: capacity, a }\n-        }\n+        RawVec { ptr: ptr.into(), cap: capacity, a }\n     }\n }\n "}, {"sha": "21a8a76d0a75b179b8c7d5208f432d1295d57654", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -20,7 +20,7 @@ fn allocator_param() {\n         fuel: usize,\n     }\n     unsafe impl AllocRef for BoundedAlloc {\n-        unsafe fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n             let size = layout.size();\n             if size > self.fuel {\n                 return Err(AllocErr);"}, {"sha": "f661b8304286810d8ecdc1fd2f00e29a9bcb88c2", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -317,7 +317,7 @@ impl<T> Vec<T> {\n     /// let mut vec: Vec<i32> = Vec::new();\n     /// ```\n     #[inline]\n-    #[rustc_const_stable(feature = \"const_vec_new\", since = \"1.32.0\")]\n+    #[rustc_const_stable(feature = \"const_vec_new\", since = \"1.39.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn new() -> Vec<T> {\n         Vec { buf: RawVec::NEW, len: 0 }"}, {"sha": "d2a513451ccb6bda48317f696b93098e0800d10c", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 13, "deletions": 43, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -606,20 +606,11 @@ pub unsafe trait GlobalAlloc {\n ///   method (`dealloc`) or by being passed to a reallocation method\n ///  (see above) that returns `Ok`.\n ///\n-/// A note regarding zero-sized types and zero-sized layouts: many\n-/// methods in the `AllocRef` trait state that allocation requests\n-/// must be non-zero size, or else undefined behavior can result.\n-///\n-/// * If an `AllocRef` implementation chooses to return `Ok` in this\n-///   case (i.e., the pointer denotes a zero-sized inaccessible block)\n-///   then that returned pointer must be considered \"currently\n-///   allocated\". On such an allocator, *all* methods that take\n-///   currently-allocated pointers as inputs must accept these\n-///   zero-sized pointers, *without* causing undefined behavior.\n-///\n-/// * In other words, if a zero-sized pointer can flow out of an\n-///   allocator, then that allocator must likewise accept that pointer\n-///   flowing back into its deallocation and reallocation methods.\n+/// Unlike [`GlobalAlloc`], zero-sized allocations are allowed in\n+/// `AllocRef`. If an underlying allocator does not support this (like\n+/// jemalloc) or return a null pointer (such as `libc::malloc`), this case\n+/// must be caught. In this case [`Layout::dangling()`] can be used to\n+/// create a dangling, but aligned `NonNull<u8>`.\n ///\n /// Some of the methods require that a layout *fit* a memory block.\n /// What it means for a layout to \"fit\" a memory block means (or\n@@ -649,6 +640,9 @@ pub unsafe trait GlobalAlloc {\n ///  * if an allocator does not support overallocating, it is fine to\n ///    simply return `layout.size()` as the allocated size.\n ///\n+/// [`GlobalAlloc`]: self::GlobalAlloc\n+/// [`Layout::dangling()`]: self::Layout::dangling\n+///\n /// # Safety\n ///\n /// The `AllocRef` trait is an `unsafe` trait for a number of reasons, and\n@@ -669,14 +663,6 @@ pub unsafe trait GlobalAlloc {\n /// the future.\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub unsafe trait AllocRef {\n-    // (Note: some existing allocators have unspecified but well-defined\n-    // behavior in response to a zero size allocation request ;\n-    // e.g., in C, `malloc` of 0 will either return a null pointer or a\n-    // unique pointer, but will not have arbitrary undefined\n-    // behavior.\n-    // However in jemalloc for example,\n-    // `mallocx(0)` is documented as undefined behavior.)\n-\n     /// On success, returns a pointer meeting the size and alignment\n     /// guarantees of `layout` and the actual size of the allocated block,\n     /// which must be greater than or equal to `layout.size()`.\n@@ -690,15 +676,6 @@ pub unsafe trait AllocRef {\n     /// behavior, e.g., to ensure initialization to particular sets of\n     /// bit patterns.)\n     ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure that `layout` has non-zero size.\n-    ///\n-    /// (Extension subtraits might provide more specific bounds on\n-    /// behavior, e.g., guarantee a sentinel address or a null pointer\n-    /// in response to a zero-size allocation request.)\n-    ///\n     /// # Errors\n     ///\n     /// Returning `Err` indicates that either memory is exhausted or\n@@ -716,7 +693,7 @@ pub unsafe trait AllocRef {\n     /// rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr>;\n+    fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr>;\n \n     /// Deallocate the memory referenced by `ptr`.\n     ///\n@@ -738,10 +715,6 @@ pub unsafe trait AllocRef {\n     /// Behaves like `alloc`, but also ensures that the contents\n     /// are set to zero before being returned.\n     ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe for the same reasons that `alloc` is.\n-    ///\n     /// # Errors\n     ///\n     /// Returning `Err` indicates that either memory is exhausted or\n@@ -753,17 +726,17 @@ pub unsafe trait AllocRef {\n     /// rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+    fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n         let size = layout.size();\n         let result = self.alloc(layout);\n         if let Ok((p, _)) = result {\n-            ptr::write_bytes(p.as_ptr(), 0, size);\n+            unsafe { ptr::write_bytes(p.as_ptr(), 0, size) }\n         }\n         result\n     }\n \n     // == METHODS FOR MEMORY REUSE ==\n-    // realloc. alloc_excess, realloc_excess\n+    // realloc, realloc_zeroed, grow_in_place, grow_in_place_zeroed, shrink_in_place\n \n     /// Returns a pointer suitable for holding data described by\n     /// a new layout with `layout`\u2019s alignment and a size given\n@@ -793,8 +766,6 @@ pub unsafe trait AllocRef {\n     /// * `layout` must *fit* the `ptr` (see above). (The `new_size`\n     ///   argument need not fit it.)\n     ///\n-    /// * `new_size` must be greater than zero.\n-    ///\n     /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`,\n     ///   must not overflow (i.e., the rounded value must be less than `usize::MAX`).\n     ///\n@@ -1009,8 +980,7 @@ pub unsafe trait AllocRef {\n     /// * `layout` must *fit* the `ptr` (see above); note the\n     ///   `new_size` argument need not fit it,\n     ///\n-    /// * `new_size` must not be greater than `layout.size()`\n-    ///   (and must be greater than zero),\n+    /// * `new_size` must not be greater than `layout.size()`,\n     ///\n     /// # Errors\n     ///"}, {"sha": "00a171e6b5fb11b19b2bbae03d45da32c2f187f4", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -24,7 +24,6 @@ use crate::task::{Context, Poll};\n /// `.await` the value.\n ///\n /// [`Waker`]: ../task/struct.Waker.html\n-#[doc(spotlight)]\n #[must_use = \"futures do nothing unless you `.await` or poll them\"]\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n #[lang = \"future_trait\"]"}, {"sha": "e2ebef9c6ce2f0dda4ab7fed0e06d1a8719b7af1", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -92,7 +92,6 @@ fn _assert_is_object_safe(_: &dyn Iterator<Item = ()>) {}\n     label = \"`{Self}` is not an iterator\",\n     message = \"`{Self}` is not an iterator\"\n )]\n-#[doc(spotlight)]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub trait Iterator {\n     /// The type of the elements being iterated over."}, {"sha": "81a3c419db86fe005a994a2928b0a59ff9ece45a", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -90,7 +90,6 @@\n #![feature(custom_inner_attributes)]\n #![feature(decl_macro)]\n #![feature(doc_cfg)]\n-#![feature(doc_spotlight)]\n #![feature(extern_types)]\n #![feature(fundamental)]\n #![feature(intrinsics)]"}, {"sha": "156f412e0902ec83aef1749f4063333701b9befb", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -360,33 +360,9 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     [anon] TraitSelect,\n \n     [] CompileCodegenUnit(Symbol),\n-\n-    [eval_always] Analysis(CrateNum),\n ]);\n \n-pub trait RecoverKey<'tcx>: Sized {\n-    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self>;\n-}\n-\n-impl RecoverKey<'tcx> for CrateNum {\n-    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n-        dep_node.extract_def_id(tcx).map(|id| id.krate)\n-    }\n-}\n-\n-impl RecoverKey<'tcx> for DefId {\n-    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n-        dep_node.extract_def_id(tcx)\n-    }\n-}\n-\n-impl RecoverKey<'tcx> for DefIndex {\n-    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n-        dep_node.extract_def_id(tcx).map(|id| id.index)\n-    }\n-}\n-\n-trait DepNodeParams<'tcx>: fmt::Debug {\n+pub(crate) trait DepNodeParams<'tcx>: fmt::Debug + Sized {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool;\n \n     /// This method turns the parameters of a DepNodeConstructor into an opaque\n@@ -400,6 +376,14 @@ trait DepNodeParams<'tcx>: fmt::Debug {\n     fn to_debug_str(&self, _: TyCtxt<'tcx>) -> String {\n         format!(\"{:?}\", self)\n     }\n+\n+    /// This method tries to recover the query key from the given `DepNode`,\n+    /// something which is needed when forcing `DepNode`s during red-green\n+    /// evaluation. The query system will only call this method if\n+    /// `CAN_RECONSTRUCT_QUERY_KEY` is `true`.\n+    /// It is always valid to return `None` here, in which case incremental\n+    /// compilation will treat the query as having changed instead of forcing it.\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self>;\n }\n \n impl<'tcx, T> DepNodeParams<'tcx> for T\n@@ -420,6 +404,10 @@ where\n     default fn to_debug_str(&self, _: TyCtxt<'tcx>) -> String {\n         format!(\"{:?}\", *self)\n     }\n+\n+    default fn recover(_: TyCtxt<'tcx>, _: &DepNode) -> Option<Self> {\n+        None\n+    }\n }\n \n impl<'tcx> DepNodeParams<'tcx> for DefId {\n@@ -432,6 +420,10 @@ impl<'tcx> DepNodeParams<'tcx> for DefId {\n     fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n         tcx.def_path_str(*self)\n     }\n+\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n+        dep_node.extract_def_id(tcx)\n+    }\n }\n \n impl<'tcx> DepNodeParams<'tcx> for DefIndex {\n@@ -444,6 +436,10 @@ impl<'tcx> DepNodeParams<'tcx> for DefIndex {\n     fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n         tcx.def_path_str(DefId::local(*self))\n     }\n+\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n+        dep_node.extract_def_id(tcx).map(|id| id.index)\n+    }\n }\n \n impl<'tcx> DepNodeParams<'tcx> for CrateNum {\n@@ -457,6 +453,10 @@ impl<'tcx> DepNodeParams<'tcx> for CrateNum {\n     fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n         tcx.crate_name(*self).to_string()\n     }\n+\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n+        dep_node.extract_def_id(tcx).map(|id| id.krate)\n+    }\n }\n \n impl<'tcx> DepNodeParams<'tcx> for (DefId, DefId) {"}, {"sha": "1fbd90743f402e764212ab57b8cfdca142f4f36b", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -6,7 +6,8 @@ mod query;\n mod safe;\n mod serialized;\n \n-pub use self::dep_node::{label_strs, DepConstructor, DepKind, DepNode, RecoverKey, WorkProductId};\n+pub(crate) use self::dep_node::DepNodeParams;\n+pub use self::dep_node::{label_strs, DepConstructor, DepKind, DepNode, WorkProductId};\n pub use self::graph::WorkProductFileKind;\n pub use self::graph::{hash_result, DepGraph, DepNodeColor, DepNodeIndex, TaskDeps, WorkProduct};\n pub use self::prev::PreviousDepGraph;"}, {"sha": "b2413f5a2c83ff402b25e2aec7e24837a331fd5d", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -1827,9 +1827,9 @@ rustc_index::newtype_index! {\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct PlaceRef<'a, 'tcx> {\n+pub struct PlaceRef<'tcx> {\n     pub local: Local,\n-    pub projection: &'a [PlaceElem<'tcx>],\n+    pub projection: &'tcx [PlaceElem<'tcx>],\n }\n \n impl<'tcx> Place<'tcx> {\n@@ -1864,7 +1864,7 @@ impl<'tcx> Place<'tcx> {\n         self.as_ref().as_local()\n     }\n \n-    pub fn as_ref(&self) -> PlaceRef<'_, 'tcx> {\n+    pub fn as_ref(&self) -> PlaceRef<'tcx> {\n         PlaceRef { local: self.local, projection: &self.projection }\n     }\n }\n@@ -1875,7 +1875,7 @@ impl From<Local> for Place<'_> {\n     }\n }\n \n-impl<'a, 'tcx> PlaceRef<'a, 'tcx> {\n+impl<'tcx> PlaceRef<'tcx> {\n     /// Finds the innermost `Local` from this `Place`, *if* it is either a local itself or\n     /// a single deref of a local.\n     //"}, {"sha": "11e9acf3a3912828fd6657eab393a6b5c5ed5be6", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 6, "deletions": 39, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -1,4 +1,4 @@\n-use crate::dep_graph::{DepKind, DepNode, RecoverKey, SerializedDepNodeIndex};\n+use crate::dep_graph::SerializedDepNodeIndex;\n use crate::mir;\n use crate::mir::interpret::{GlobalId, LitToConstInput};\n use crate::traits;\n@@ -60,6 +60,11 @@ rustc_queries! {\n             cache_on_disk_if { key.is_local() }\n         }\n \n+        query analysis(key: CrateNum) -> Result<(), ErrorReported> {\n+            eval_always\n+            desc { \"running analysis passes on this crate\" }\n+        }\n+\n         /// Maps from the `DefId` of an item (trait/struct/enum/fn) to its\n         /// associated generics.\n         query generics_of(key: DefId) -> &'tcx ty::Generics {\n@@ -195,7 +200,6 @@ rustc_queries! {\n             // queries). Making it anonymous avoids hashing the result, which\n             // may save a bit of time.\n             anon\n-            no_force\n             desc { \"erasing regions from `{:?}`\", ty }\n         }\n \n@@ -204,7 +208,6 @@ rustc_queries! {\n         }\n \n         query program_clauses_for_env(_: traits::Environment<'tcx>) -> Clauses<'tcx> {\n-            no_force\n             desc { \"generating chalk-style clauses for environment\" }\n         }\n \n@@ -247,7 +250,6 @@ rustc_queries! {\n         /// To avoid cycles within the predicates of a single item we compute\n         /// per-type-parameter predicates for resolving `T::AssocTy`.\n         query type_param_predicates(key: (DefId, DefId)) -> ty::GenericPredicates<'tcx> {\n-            no_force\n             desc { |tcx| \"computing the bounds for type parameter `{}`\", {\n                 let id = tcx.hir().as_local_hir_id(key.1).unwrap();\n                 tcx.hir().ty_param_name(id)\n@@ -503,7 +505,6 @@ rustc_queries! {\n         /// form to be used outside of const eval.\n         query const_eval_raw(key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n             -> ConstEvalRawResult<'tcx> {\n-            no_force\n             desc { |tcx|\n                 \"const-evaluating `{}`\",\n                 tcx.def_path_str(key.value.instance.def.def_id())\n@@ -520,7 +521,6 @@ rustc_queries! {\n         /// `tcx.const_eval_resolve`, `tcx.const_eval_instance`, or `tcx.const_eval_global_id`.\n         query const_eval_validated(key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n             -> ConstEvalResult<'tcx> {\n-            no_force\n             desc { |tcx|\n                 \"const-evaluating + checking `{}`\",\n                 tcx.def_path_str(key.value.instance.def.def_id())\n@@ -535,7 +535,6 @@ rustc_queries! {\n         query const_field(\n             key: ty::ParamEnvAnd<'tcx, (&'tcx ty::Const<'tcx>, mir::Field)>\n         ) -> ConstValue<'tcx> {\n-            no_force\n             desc { \"extract field of const\" }\n         }\n \n@@ -544,19 +543,16 @@ rustc_queries! {\n         query destructure_const(\n             key: ty::ParamEnvAnd<'tcx, &'tcx ty::Const<'tcx>>\n         ) -> mir::DestructuredConst<'tcx> {\n-            no_force\n             desc { \"destructure constant\" }\n         }\n \n         query const_caller_location(key: (rustc_span::Symbol, u32, u32)) -> ConstValue<'tcx> {\n-            no_force\n             desc { \"get a &core::panic::Location referring to a span\" }\n         }\n \n         query lit_to_const(\n             key: LitToConstInput<'tcx>\n         ) -> Result<&'tcx ty::Const<'tcx>, LitToConstError> {\n-            no_force\n             desc { \"converting literal to const\" }\n         }\n     }\n@@ -587,15 +583,13 @@ rustc_queries! {\n         query region_scope_tree(_: DefId) -> &'tcx region::ScopeTree {}\n \n         query mir_shims(key: ty::InstanceDef<'tcx>) -> &'tcx mir::BodyAndCache<'tcx> {\n-            no_force\n             desc { |tcx| \"generating MIR shim for `{}`\", tcx.def_path_str(key.def_id()) }\n         }\n \n         /// The `symbol_name` query provides the symbol name for calling a\n         /// given instance from the local crate. In particular, it will also\n         /// look up the correct symbol name of instances from upstream crates.\n         query symbol_name(key: ty::Instance<'tcx>) -> ty::SymbolName {\n-            no_force\n             desc { \"computing the symbol for `{}`\", key }\n             cache_on_disk_if { true }\n         }\n@@ -642,7 +636,6 @@ rustc_queries! {\n     Other {\n         query vtable_methods(key: ty::PolyTraitRef<'tcx>)\n                             -> &'tcx [Option<(DefId, SubstsRef<'tcx>)>] {\n-            no_force\n             desc { |tcx| \"finding all methods for trait {}\", tcx.def_path_str(key.def_id()) }\n         }\n     }\n@@ -651,7 +644,6 @@ rustc_queries! {\n         query codegen_fulfill_obligation(\n             key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)\n         ) -> Option<Vtable<'tcx, ()>> {\n-            no_force\n             cache_on_disk_if { true }\n             desc { |tcx|\n                 \"checking if `{}` fulfills its obligations\",\n@@ -683,22 +675,18 @@ rustc_queries! {\n         /// Trait selection queries. These are best used by invoking `ty.is_copy_modulo_regions()`,\n         /// `ty.is_copy()`, etc, since that will prune the environment where possible.\n         query is_copy_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-            no_force\n             desc { \"computing whether `{}` is `Copy`\", env.value }\n         }\n         /// Query backing `TyS::is_sized`.\n         query is_sized_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-            no_force\n             desc { \"computing whether `{}` is `Sized`\", env.value }\n         }\n         /// Query backing `TyS::is_freeze`.\n         query is_freeze_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-            no_force\n             desc { \"computing whether `{}` is freeze\", env.value }\n         }\n         /// Query backing `TyS::needs_drop`.\n         query needs_drop_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-            no_force\n             desc { \"computing whether `{}` needs drop\", env.value }\n         }\n \n@@ -712,7 +700,6 @@ rustc_queries! {\n         query layout_raw(\n             env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n         ) -> Result<&'tcx ty::layout::LayoutDetails, ty::layout::LayoutError<'tcx>> {\n-            no_force\n             desc { \"computing layout of `{}`\", env.value }\n         }\n     }\n@@ -768,7 +755,6 @@ rustc_queries! {\n \n     TypeChecking {\n         query specializes(_: (DefId, DefId)) -> bool {\n-            no_force\n             desc { \"computing whether impls specialize one another\" }\n         }\n         query in_scope_traits_map(_: DefIndex)\n@@ -853,7 +839,6 @@ rustc_queries! {\n         ///       (like `Clone::clone` for example).\n         query upstream_drop_glue_for(substs: SubstsRef<'tcx>) -> Option<CrateNum> {\n             desc { \"available upstream drop-glue for `{:?}`\", substs }\n-            no_force\n         }\n     }\n \n@@ -898,7 +883,6 @@ rustc_queries! {\n     TypeChecking {\n         query implementations_of_trait(_: (CrateNum, DefId))\n             -> &'tcx [DefId] {\n-            no_force\n             desc { \"looking up implementations of a trait in a crate\" }\n         }\n         query all_trait_implementations(_: CrateNum)\n@@ -1065,7 +1049,6 @@ rustc_queries! {\n         }\n         query is_codegened_item(_: DefId) -> bool {}\n         query codegen_unit(_: Symbol) -> Arc<CodegenUnit<'tcx>> {\n-            no_force\n             desc { \"codegen_unit\" }\n         }\n         query backend_optimization_level(_: CrateNum) -> OptLevel {\n@@ -1088,15 +1071,13 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, NormalizationResult<'tcx>>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"normalizing `{:?}`\", goal }\n         }\n \n         /// Do not call this query directly: invoke `normalize_erasing_regions` instead.\n         query normalize_ty_after_erasing_regions(\n             goal: ParamEnvAnd<'tcx, Ty<'tcx>>\n         ) -> Ty<'tcx> {\n-            no_force\n             desc { \"normalizing `{:?}`\", goal }\n         }\n \n@@ -1106,7 +1087,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, Vec<OutlivesBound<'tcx>>>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"computing implied outlives bounds for `{:?}`\", goal }\n         }\n \n@@ -1117,7 +1097,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, DropckOutlivesResult<'tcx>>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"computing dropck types for `{:?}`\", goal }\n         }\n \n@@ -1126,7 +1105,6 @@ rustc_queries! {\n         query evaluate_obligation(\n             goal: CanonicalPredicateGoal<'tcx>\n         ) -> Result<traits::EvaluationResult, traits::OverflowError> {\n-            no_force\n             desc { \"evaluating trait selection obligation `{}`\", goal.value.value }\n         }\n \n@@ -1137,7 +1115,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"evaluating `type_op_ascribe_user_type` `{:?}`\", goal }\n         }\n \n@@ -1148,7 +1125,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"evaluating `type_op_eq` `{:?}`\", goal }\n         }\n \n@@ -1159,7 +1135,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"evaluating `type_op_subtype` `{:?}`\", goal }\n         }\n \n@@ -1170,7 +1145,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"evaluating `type_op_prove_predicate` `{:?}`\", goal }\n         }\n \n@@ -1181,7 +1155,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, Ty<'tcx>>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"normalizing `{:?}`\", goal }\n         }\n \n@@ -1192,7 +1165,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ty::Predicate<'tcx>>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"normalizing `{:?}`\", goal }\n         }\n \n@@ -1203,7 +1175,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ty::PolyFnSig<'tcx>>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"normalizing `{:?}`\", goal }\n         }\n \n@@ -1214,12 +1185,10 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ty::FnSig<'tcx>>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"normalizing `{:?}`\", goal }\n         }\n \n         query substitute_normalize_and_test_predicates(key: (DefId, SubstsRef<'tcx>)) -> bool {\n-            no_force\n             desc { |tcx|\n                 \"testing substituted normalized predicates:`{}`\",\n                 tcx.def_path_str(key.0)\n@@ -1229,7 +1198,6 @@ rustc_queries! {\n         query method_autoderef_steps(\n             goal: CanonicalTyGoal<'tcx>\n         ) -> MethodAutoderefStepsResult<'tcx> {\n-            no_force\n             desc { \"computing autoderef types for `{:?}`\", goal }\n         }\n     }\n@@ -1243,7 +1211,6 @@ rustc_queries! {\n         // Get an estimate of the size of an InstanceDef based on its MIR for CGU partitioning.\n         query instance_def_size_estimate(def: ty::InstanceDef<'tcx>)\n             -> usize {\n-            no_force\n             desc { |tcx| \"estimating size for `{}`\", tcx.def_path_str(def.def_id()) }\n         }\n "}, {"sha": "178c2362def6e9db554cbdef6f8c67c63c2048f5", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -2,11 +2,10 @@ use crate::dep_graph::SerializedDepNodeIndex;\n use crate::dep_graph::{DepKind, DepNode};\n use crate::ty::query::caches::QueryCache;\n use crate::ty::query::plumbing::CycleError;\n-use crate::ty::query::queries;\n use crate::ty::query::{Query, QueryState};\n use crate::ty::TyCtxt;\n use rustc_data_structures::profiling::ProfileCategory;\n-use rustc_hir::def_id::{CrateNum, DefId};\n+use rustc_hir::def_id::DefId;\n \n use crate::ich::StableHashingContext;\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -87,9 +86,3 @@ where\n         bug!(\"QueryDescription::load_from_disk() called for an unsupported query.\")\n     }\n }\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::analysis<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_>, _: CrateNum) -> Cow<'static, str> {\n-        \"running analysis passes on this crate\".into()\n-    }\n-}"}, {"sha": "8adb828fbebc4467876a0f7de758bea32ad4ebb0", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 104, "deletions": 8, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -1,4 +1,4 @@\n-use crate::dep_graph::{self, DepConstructor, DepNode};\n+use crate::dep_graph::{self, DepConstructor, DepNode, DepNodeParams};\n use crate::hir::exports::Export;\n use crate::infer::canonical::{self, Canonical};\n use crate::lint::LintLevelMap;\n@@ -60,8 +60,8 @@ use std::sync::Arc;\n \n #[macro_use]\n mod plumbing;\n+pub use self::plumbing::CycleError;\n use self::plumbing::*;\n-pub use self::plumbing::{force_from_dep_node, CycleError};\n \n mod stats;\n pub use self::stats::print_stats;\n@@ -104,9 +104,105 @@ pub use self::profiling_support::{IntoSelfProfilingString, QueryKeyStringBuilder\n // Queries marked with `fatal_cycle` do not need the latter implementation,\n // as they will raise an fatal error on query cycles instead.\n \n-rustc_query_append! { [define_queries!][ <'tcx>\n-    Other {\n-        /// Runs analysis passes on the crate.\n-        [eval_always] fn analysis: Analysis(CrateNum) -> Result<(), ErrorReported>,\n-    },\n-]}\n+rustc_query_append! { [define_queries!][<'tcx>] }\n+\n+/// The red/green evaluation system will try to mark a specific DepNode in the\n+/// dependency graph as green by recursively trying to mark the dependencies of\n+/// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n+/// where we don't know if it is red or green and we therefore actually have\n+/// to recompute its value in order to find out. Since the only piece of\n+/// information that we have at that point is the `DepNode` we are trying to\n+/// re-evaluate, we need some way to re-run a query from just that. This is what\n+/// `force_from_dep_node()` implements.\n+///\n+/// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n+/// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n+/// is usually constructed by computing a stable hash of the query-key that the\n+/// `DepNode` corresponds to. Consequently, it is not in general possible to go\n+/// back from hash to query-key (since hash functions are not reversible). For\n+/// this reason `force_from_dep_node()` is expected to fail from time to time\n+/// because we just cannot find out, from the `DepNode` alone, what the\n+/// corresponding query-key is and therefore cannot re-run the query.\n+///\n+/// The system deals with this case letting `try_mark_green` fail which forces\n+/// the root query to be re-evaluated.\n+///\n+/// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n+/// Fortunately, we can use some contextual information that will allow us to\n+/// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n+/// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n+/// valid `DefPathHash`. Since we also always build a huge table that maps every\n+/// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n+/// everything we need to re-run the query.\n+///\n+/// Take the `mir_validated` query as an example. Like many other queries, it\n+/// just has a single parameter: the `DefId` of the item it will compute the\n+/// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n+/// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n+/// is actually a `DefPathHash`, and can therefore just look up the corresponding\n+/// `DefId` in `tcx.def_path_hash_to_def_id`.\n+///\n+/// When you implement a new query, it will likely have a corresponding new\n+/// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n+/// a rule of thumb, if your query takes a `DefId` or `DefIndex` as sole parameter,\n+/// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n+/// add it to the \"We don't have enough information to reconstruct...\" group in\n+/// the match below.\n+pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool {\n+    use crate::dep_graph::DepKind;\n+\n+    // We must avoid ever having to call `force_from_dep_node()` for a\n+    // `DepNode::codegen_unit`:\n+    // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n+    // would always end up having to evaluate the first caller of the\n+    // `codegen_unit` query that *is* reconstructible. This might very well be\n+    // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n+    // to re-trigger calling the `codegen_unit` query with the right key. At\n+    // that point we would already have re-done all the work we are trying to\n+    // avoid doing in the first place.\n+    // The solution is simple: Just explicitly call the `codegen_unit` query for\n+    // each CGU, right after partitioning. This way `try_mark_green` will always\n+    // hit the cache instead of having to go through `force_from_dep_node`.\n+    // This assertion makes sure, we actually keep applying the solution above.\n+    debug_assert!(\n+        dep_node.kind != DepKind::codegen_unit,\n+        \"calling force_from_dep_node() on DepKind::codegen_unit\"\n+    );\n+\n+    if !dep_node.kind.can_reconstruct_query_key() {\n+        return false;\n+    }\n+\n+    rustc_dep_node_force!([dep_node, tcx]\n+        // These are inputs that are expected to be pre-allocated and that\n+        // should therefore always be red or green already.\n+        DepKind::AllLocalTraitImpls |\n+        DepKind::CrateMetadata |\n+        DepKind::HirBody |\n+        DepKind::Hir |\n+\n+        // These are anonymous nodes.\n+        DepKind::TraitSelect |\n+\n+        // We don't have enough information to reconstruct the query key of\n+        // these.\n+        DepKind::CompileCodegenUnit => {\n+            bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n+        }\n+    );\n+\n+    false\n+}\n+\n+impl DepNode {\n+    /// Check whether the query invocation corresponding to the given\n+    /// DepNode is eligible for on-disk-caching. If so, this is method\n+    /// will execute the query corresponding to the given DepNode.\n+    /// Also, as a sanity check, it expects that the corresponding query\n+    /// invocation has been marked as green already.\n+    pub fn try_load_from_on_disk_cache<'tcx>(&self, tcx: TyCtxt<'tcx>) {\n+        use crate::dep_graph::DepKind;\n+\n+        rustc_dep_node_try_load_from_on_disk_cache!(self, tcx)\n+    }\n+}"}, {"sha": "acf67f52dceaa94ebe9bb50ebd6a4979e78cf73c", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 104, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -2,7 +2,7 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph::{DepKind, DepNode, DepNodeIndex, SerializedDepNodeIndex};\n+use crate::dep_graph::{DepNode, DepNodeIndex, SerializedDepNodeIndex};\n use crate::ty::query::caches::QueryCache;\n use crate::ty::query::config::{QueryAccessors, QueryDescription};\n use crate::ty::query::job::{QueryInfo, QueryJob, QueryJobId, QueryShardJobId};\n@@ -720,7 +720,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[allow(dead_code)]\n-    fn force_query<Q: QueryDescription<'tcx> + 'tcx>(\n+    pub(super) fn force_query<Q: QueryDescription<'tcx> + 'tcx>(\n         self,\n         key: Q::Key,\n         span: Span,\n@@ -1162,105 +1162,3 @@ macro_rules! define_provider_struct {\n         }\n     };\n }\n-\n-/// The red/green evaluation system will try to mark a specific DepNode in the\n-/// dependency graph as green by recursively trying to mark the dependencies of\n-/// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n-/// where we don't know if it is red or green and we therefore actually have\n-/// to recompute its value in order to find out. Since the only piece of\n-/// information that we have at that point is the `DepNode` we are trying to\n-/// re-evaluate, we need some way to re-run a query from just that. This is what\n-/// `force_from_dep_node()` implements.\n-///\n-/// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n-/// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n-/// is usually constructed by computing a stable hash of the query-key that the\n-/// `DepNode` corresponds to. Consequently, it is not in general possible to go\n-/// back from hash to query-key (since hash functions are not reversible). For\n-/// this reason `force_from_dep_node()` is expected to fail from time to time\n-/// because we just cannot find out, from the `DepNode` alone, what the\n-/// corresponding query-key is and therefore cannot re-run the query.\n-///\n-/// The system deals with this case letting `try_mark_green` fail which forces\n-/// the root query to be re-evaluated.\n-///\n-/// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n-/// Fortunately, we can use some contextual information that will allow us to\n-/// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n-/// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n-/// valid `DefPathHash`. Since we also always build a huge table that maps every\n-/// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n-/// everything we need to re-run the query.\n-///\n-/// Take the `mir_validated` query as an example. Like many other queries, it\n-/// just has a single parameter: the `DefId` of the item it will compute the\n-/// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n-/// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n-/// is actually a `DefPathHash`, and can therefore just look up the corresponding\n-/// `DefId` in `tcx.def_path_hash_to_def_id`.\n-///\n-/// When you implement a new query, it will likely have a corresponding new\n-/// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n-/// a rule of thumb, if your query takes a `DefId` or `DefIndex` as sole parameter,\n-/// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n-/// add it to the \"We don't have enough information to reconstruct...\" group in\n-/// the match below.\n-pub fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n-    use crate::dep_graph::RecoverKey;\n-\n-    // We must avoid ever having to call `force_from_dep_node()` for a\n-    // `DepNode::codegen_unit`:\n-    // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n-    // would always end up having to evaluate the first caller of the\n-    // `codegen_unit` query that *is* reconstructible. This might very well be\n-    // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n-    // to re-trigger calling the `codegen_unit` query with the right key. At\n-    // that point we would already have re-done all the work we are trying to\n-    // avoid doing in the first place.\n-    // The solution is simple: Just explicitly call the `codegen_unit` query for\n-    // each CGU, right after partitioning. This way `try_mark_green` will always\n-    // hit the cache instead of having to go through `force_from_dep_node`.\n-    // This assertion makes sure, we actually keep applying the solution above.\n-    debug_assert!(\n-        dep_node.kind != DepKind::codegen_unit,\n-        \"calling force_from_dep_node() on DepKind::codegen_unit\"\n-    );\n-\n-    if !dep_node.kind.can_reconstruct_query_key() {\n-        return false;\n-    }\n-\n-    rustc_dep_node_force!([dep_node, tcx]\n-        // These are inputs that are expected to be pre-allocated and that\n-        // should therefore always be red or green already.\n-        DepKind::AllLocalTraitImpls |\n-        DepKind::CrateMetadata |\n-        DepKind::HirBody |\n-        DepKind::Hir |\n-\n-        // These are anonymous nodes.\n-        DepKind::TraitSelect |\n-\n-        // We don't have enough information to reconstruct the query key of\n-        // these.\n-        DepKind::CompileCodegenUnit => {\n-            bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n-        }\n-\n-        DepKind::Analysis => {\n-            let def_id = if let Some(def_id) = dep_node.extract_def_id(tcx) {\n-                def_id\n-            } else {\n-                // Return from the whole function.\n-                return false\n-            };\n-            tcx.force_query::<crate::ty::query::queries::analysis<'_>>(\n-                def_id.krate,\n-                DUMMY_SP,\n-                *dep_node\n-            );\n-        }\n-    );\n-\n-    true\n-}"}, {"sha": "a4ab54f8b4a86334a27c8ea1123dcc245e57ba8e", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -245,7 +245,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     include => external_doc\n                     cfg => doc_cfg\n                     masked => doc_masked\n-                    spotlight => doc_spotlight\n                     alias => doc_alias\n                     keyword => doc_keyword\n                 );"}, {"sha": "7975a70ab269c9d40ff0bcb69c8c9156a7b08e8c", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -29,11 +29,17 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         let mut indirect_outputs = vec![];\n         for (i, (out, &place)) in ia.outputs.iter().zip(&outputs).enumerate() {\n             if out.is_rw {\n-                inputs.push(self.load_operand(place).immediate());\n+                let operand = self.load_operand(place);\n+                if let OperandValue::Immediate(_) = operand.val {\n+                    inputs.push(operand.immediate());\n+                }\n                 ext_constraints.push(i.to_string());\n             }\n             if out.is_indirect {\n-                indirect_outputs.push(self.load_operand(place).immediate());\n+                let operand = self.load_operand(place);\n+                if let OperandValue::Immediate(_) = operand.val {\n+                    indirect_outputs.push(operand.immediate());\n+                }\n             } else {\n                 output_types.push(place.layout.llvm_type(self.cx()));\n             }"}, {"sha": "04680a1751734de8e296a1acb51f05b252f6517f", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -97,7 +97,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n \n     fn process_place(\n         &mut self,\n-        place_ref: &mir::PlaceRef<'_, 'tcx>,\n+        place_ref: &mir::PlaceRef<'tcx>,\n         context: PlaceContext,\n         location: Location,\n     ) {"}, {"sha": "1e1fede2588df54c22c353239294e033913cb614", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -364,7 +364,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     fn maybe_codegen_consume_direct(\n         &mut self,\n         bx: &mut Bx,\n-        place_ref: mir::PlaceRef<'_, 'tcx>,\n+        place_ref: mir::PlaceRef<'tcx>,\n     ) -> Option<OperandRef<'tcx, Bx::Value>> {\n         debug!(\"maybe_codegen_consume_direct(place_ref={:?})\", place_ref);\n \n@@ -408,7 +408,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_consume(\n         &mut self,\n         bx: &mut Bx,\n-        place_ref: mir::PlaceRef<'_, 'tcx>,\n+        place_ref: mir::PlaceRef<'tcx>,\n     ) -> OperandRef<'tcx, Bx::Value> {\n         debug!(\"codegen_consume(place_ref={:?})\", place_ref);\n "}, {"sha": "2eba88c6b5f3108a8fddaf0cc557e1805b48037d", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -408,7 +408,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_place(\n         &mut self,\n         bx: &mut Bx,\n-        place_ref: mir::PlaceRef<'_, 'tcx>,\n+        place_ref: mir::PlaceRef<'tcx>,\n     ) -> PlaceRef<'tcx, Bx::Value> {\n         debug!(\"codegen_place(place_ref={:?})\", place_ref);\n         let cx = self.cx;\n@@ -497,7 +497,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         result\n     }\n \n-    pub fn monomorphized_place_ty(&self, place_ref: mir::PlaceRef<'_, 'tcx>) -> Ty<'tcx> {\n+    pub fn monomorphized_place_ty(&self, place_ref: mir::PlaceRef<'tcx>) -> Ty<'tcx> {\n         let tcx = self.cx.tcx();\n         let place_ty = mir::Place::ty_from(place_ref.local, place_ref.projection, *self.mir, tcx);\n         self.monomorphize(&place_ty.ty)"}, {"sha": "3e853cf1b8a360f7e94d858d30e63470f6683225", "filename": "src/librustc_error_codes/error_codes/E0393.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_error_codes%2Ferror_codes%2FE0393.md", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_error_codes%2Ferror_codes%2FE0393.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0393.md?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -1,5 +1,6 @@\n A type parameter which references `Self` in its default value was not specified.\n-Example of erroneous code:\n+\n+Erroneous code example:\n \n ```compile_fail,E0393\n trait A<T=Self> {}"}, {"sha": "3a0fc6f8da143a4491f2f0ed66bc2e7dd4f493e9", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -360,9 +360,6 @@ declare_features! (\n     /// Allows `#[doc(masked)]`.\n     (active, doc_masked, \"1.21.0\", Some(44027), None),\n \n-    /// Allows `#[doc(spotlight)]`.\n-    (active, doc_spotlight, \"1.22.0\", Some(45040), None),\n-\n     /// Allows `#[doc(include = \"some-file\")]`.\n     (active, external_doc, \"1.22.0\", Some(44732), None),\n "}, {"sha": "56b7be2f7e2d531912a1aa88c04a7dbd868dc871", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 21, "deletions": 52, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -51,9 +51,6 @@ enum QueryModifier {\n     /// Don't hash the result, instead just mark a query red if it runs\n     NoHash,\n \n-    /// Don't force the query\n-    NoForce,\n-\n     /// Generate a dep node based on the dependencies of the query\n     Anon,\n \n@@ -118,8 +115,6 @@ impl Parse for QueryModifier {\n             Ok(QueryModifier::CycleDelayBug)\n         } else if modifier == \"no_hash\" {\n             Ok(QueryModifier::NoHash)\n-        } else if modifier == \"no_force\" {\n-            Ok(QueryModifier::NoForce)\n         } else if modifier == \"anon\" {\n             Ok(QueryModifier::Anon)\n         } else if modifier == \"eval_always\" {\n@@ -222,9 +217,6 @@ struct QueryModifiers {\n     /// Don't hash the result, instead just mark a query red if it runs\n     no_hash: bool,\n \n-    /// Don't force the query\n-    no_force: bool,\n-\n     /// Generate a dep node based on the dependencies of the query\n     anon: bool,\n \n@@ -241,7 +233,6 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n     let mut fatal_cycle = false;\n     let mut cycle_delay_bug = false;\n     let mut no_hash = false;\n-    let mut no_force = false;\n     let mut anon = false;\n     let mut eval_always = false;\n     for modifier in query.modifiers.0.drain(..) {\n@@ -288,12 +279,6 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n                 }\n                 no_hash = true;\n             }\n-            QueryModifier::NoForce => {\n-                if no_force {\n-                    panic!(\"duplicate modifier `no_force` for query `{}`\", query.name);\n-                }\n-                no_force = true;\n-            }\n             QueryModifier::Anon => {\n                 if anon {\n                     panic!(\"duplicate modifier `anon` for query `{}`\", query.name);\n@@ -316,7 +301,6 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n         fatal_cycle,\n         cycle_delay_bug,\n         no_hash,\n-        no_force,\n         anon,\n         eval_always,\n     }\n@@ -425,7 +409,6 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n     let mut dep_node_def_stream = quote! {};\n     let mut dep_node_force_stream = quote! {};\n     let mut try_load_from_on_disk_cache_stream = quote! {};\n-    let mut no_force_queries = Vec::new();\n     let mut cached_queries = quote! {};\n \n     for group in groups.0 {\n@@ -444,19 +427,19 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 cached_queries.extend(quote! {\n                     #name,\n                 });\n-            }\n \n-            if modifiers.cache.is_some() && !modifiers.no_force {\n                 try_load_from_on_disk_cache_stream.extend(quote! {\n                     DepKind::#name => {\n-                        debug_assert!(tcx.dep_graph\n-                                         .node_color(self)\n-                                         .map(|c| c.is_green())\n-                                         .unwrap_or(false));\n-\n-                        let key = RecoverKey::recover(tcx, self).unwrap();\n-                        if queries::#name::cache_on_disk(tcx, key, None) {\n-                            let _ = tcx.#name(key);\n+                        if <#arg as DepNodeParams>::CAN_RECONSTRUCT_QUERY_KEY {\n+                            debug_assert!($tcx.dep_graph\n+                                            .node_color($dep_node)\n+                                            .map(|c| c.is_green())\n+                                            .unwrap_or(false));\n+\n+                            let key = <#arg as DepNodeParams>::recover($tcx, $dep_node).unwrap();\n+                            if queries::#name::cache_on_disk($tcx, key, None) {\n+                                let _ = $tcx.#name(key);\n+                            }\n                         }\n                     }\n                 });\n@@ -501,24 +484,21 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 [#attribute_stream] #name(#arg),\n             });\n \n-            if modifiers.no_force {\n-                no_force_queries.push(name.clone());\n-            } else {\n-                // Add a match arm to force the query given the dep node\n-                dep_node_force_stream.extend(quote! {\n-                    DepKind::#name => {\n-                        if let Some(key) = RecoverKey::recover($tcx, $dep_node) {\n+            // Add a match arm to force the query given the dep node\n+            dep_node_force_stream.extend(quote! {\n+                DepKind::#name => {\n+                    if <#arg as DepNodeParams>::CAN_RECONSTRUCT_QUERY_KEY {\n+                        if let Some(key) = <#arg as DepNodeParams>::recover($tcx, $dep_node) {\n                             $tcx.force_query::<crate::ty::query::queries::#name<'_>>(\n                                 key,\n                                 DUMMY_SP,\n                                 *$dep_node\n                             );\n-                        } else {\n-                            return false;\n+                            return true;\n                         }\n                     }\n-                });\n-            }\n+                }\n+            });\n \n             add_query_description_impl(&query, modifiers, &mut query_description_stream);\n         }\n@@ -528,12 +508,6 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n         });\n     }\n \n-    // Add an arm for the no force queries to panic when trying to force them\n-    for query in no_force_queries {\n-        dep_node_force_stream.extend(quote! {\n-            DepKind::#query |\n-        });\n-    }\n     dep_node_force_stream.extend(quote! {\n         DepKind::Null => {\n             bug!(\"Cannot force dep node: {:?}\", $dep_node)\n@@ -577,14 +551,9 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n \n         #query_description_stream\n \n-        impl DepNode {\n-            /// Check whether the query invocation corresponding to the given\n-            /// DepNode is eligible for on-disk-caching. If so, this is method\n-            /// will execute the query corresponding to the given DepNode.\n-            /// Also, as a sanity check, it expects that the corresponding query\n-            /// invocation has been marked as green already.\n-            pub fn try_load_from_on_disk_cache(&self, tcx: TyCtxt<'_>) {\n-                match self.kind {\n+        macro_rules! rustc_dep_node_try_load_from_on_disk_cache {\n+            ($dep_node:expr, $tcx:expr) => {\n+                match $dep_node.kind {\n                     #try_load_from_on_disk_cache_stream\n                     _ => (),\n                 }"}, {"sha": "18b4c9ad5044ca401575d0a7e9ab3f073cd42fc8", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -76,6 +76,21 @@ impl<'a> LoadError<'a> {\n     }\n }\n \n+/// A reference to `CrateMetadata` that can also give access to whole crate store when necessary.\n+#[derive(Clone, Copy)]\n+crate struct CrateMetadataRef<'a> {\n+    pub cdata: &'a CrateMetadata,\n+    pub cstore: &'a CStore,\n+}\n+\n+impl std::ops::Deref for CrateMetadataRef<'_> {\n+    type Target = CrateMetadata;\n+\n+    fn deref(&self) -> &Self::Target {\n+        self.cdata\n+    }\n+}\n+\n fn dump_crates(cstore: &CStore) {\n     info!(\"resolved crates:\");\n     cstore.iter_crate_data(|cnum, data| {\n@@ -100,10 +115,11 @@ impl CStore {\n         CrateNum::new(self.metas.len() - 1)\n     }\n \n-    crate fn get_crate_data(&self, cnum: CrateNum) -> &CrateMetadata {\n-        self.metas[cnum]\n+    crate fn get_crate_data(&self, cnum: CrateNum) -> CrateMetadataRef<'_> {\n+        let cdata = self.metas[cnum]\n             .as_ref()\n-            .unwrap_or_else(|| panic!(\"Failed to get crate data for {:?}\", cnum))\n+            .unwrap_or_else(|| panic!(\"Failed to get crate data for {:?}\", cnum));\n+        CrateMetadataRef { cdata, cstore: self }\n     }\n \n     fn set_crate_data(&mut self, cnum: CrateNum, data: CrateMetadata) {\n@@ -217,7 +233,7 @@ impl<'a> CrateLoader<'a> {\n             // We're also sure to compare *paths*, not actual byte slices. The\n             // `source` stores paths which are normalized which may be different\n             // from the strings on the command line.\n-            let source = self.cstore.get_crate_data(cnum).source();\n+            let source = self.cstore.get_crate_data(cnum).cdata.source();\n             if let Some(entry) = self.sess.opts.externs.get(&name.as_str()) {\n                 // Only use `--extern crate_name=path` here, not `--extern crate_name`.\n                 if let Some(mut files) = entry.files() {"}, {"sha": "e60ae5b6c25ee311206613cd66109745dd8f96d1", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 105, "deletions": 102, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -1,5 +1,6 @@\n // Decoding metadata from a single crate's metadata\n \n+use crate::creader::CrateMetadataRef;\n use crate::rmeta::table::{FixedSizeEncoding, Table};\n use crate::rmeta::*;\n \n@@ -125,7 +126,7 @@ struct ImportedSourceFile {\n \n pub(super) struct DecodeContext<'a, 'tcx> {\n     opaque: opaque::Decoder<'a>,\n-    cdata: Option<&'a CrateMetadata>,\n+    cdata: Option<CrateMetadataRef<'a>>,\n     sess: Option<&'tcx Session>,\n     tcx: Option<TyCtxt<'tcx>>,\n \n@@ -141,7 +142,7 @@ pub(super) struct DecodeContext<'a, 'tcx> {\n /// Abstract over the various ways one can create metadata decoders.\n pub(super) trait Metadata<'a, 'tcx>: Copy {\n     fn raw_bytes(self) -> &'a [u8];\n-    fn cdata(self) -> Option<&'a CrateMetadata> {\n+    fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n         None\n     }\n     fn sess(self) -> Option<&'tcx Session> {\n@@ -162,7 +163,7 @@ pub(super) trait Metadata<'a, 'tcx>: Copy {\n             lazy_state: LazyState::NoNode,\n             alloc_decoding_session: self\n                 .cdata()\n-                .map(|cdata| cdata.alloc_decoding_state.new_decoding_session()),\n+                .map(|cdata| cdata.cdata.alloc_decoding_state.new_decoding_session()),\n         }\n     }\n }\n@@ -185,33 +186,33 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a MetadataBlob, &'tcx Session) {\n     }\n }\n \n-impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a CrateMetadata {\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a CrateMetadataRef<'a> {\n     fn raw_bytes(self) -> &'a [u8] {\n         self.blob.raw_bytes()\n     }\n-    fn cdata(self) -> Option<&'a CrateMetadata> {\n-        Some(self)\n+    fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n+        Some(*self)\n     }\n }\n \n-impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, &'tcx Session) {\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadataRef<'a>, &'tcx Session) {\n     fn raw_bytes(self) -> &'a [u8] {\n         self.0.raw_bytes()\n     }\n-    fn cdata(self) -> Option<&'a CrateMetadata> {\n-        Some(self.0)\n+    fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n+        Some(*self.0)\n     }\n     fn sess(self) -> Option<&'tcx Session> {\n         Some(&self.1)\n     }\n }\n \n-impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'tcx>) {\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadataRef<'a>, TyCtxt<'tcx>) {\n     fn raw_bytes(self) -> &'a [u8] {\n         self.0.raw_bytes()\n     }\n-    fn cdata(self) -> Option<&'a CrateMetadata> {\n-        Some(self.0)\n+    fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n+        Some(*self.0)\n     }\n     fn tcx(self) -> Option<TyCtxt<'tcx>> {\n         Some(self.1)\n@@ -242,7 +243,7 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n         self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n     }\n \n-    fn cdata(&self) -> &'a CrateMetadata {\n+    fn cdata(&self) -> CrateMetadataRef<'a> {\n         self.cdata.expect(\"missing CrateMetadata in DecodeContext\")\n     }\n \n@@ -558,50 +559,7 @@ impl CrateRoot<'_> {\n     }\n }\n \n-impl<'a, 'tcx> CrateMetadata {\n-    crate fn new(\n-        sess: &Session,\n-        blob: MetadataBlob,\n-        root: CrateRoot<'static>,\n-        raw_proc_macros: Option<&'static [ProcMacro]>,\n-        cnum: CrateNum,\n-        cnum_map: CrateNumMap,\n-        dep_kind: DepKind,\n-        source: CrateSource,\n-        private_dep: bool,\n-        host_hash: Option<Svh>,\n-    ) -> CrateMetadata {\n-        let def_path_table = record_time(&sess.perf_stats.decode_def_path_tables_time, || {\n-            root.def_path_table.decode((&blob, sess))\n-        });\n-        let trait_impls = root\n-            .impls\n-            .decode((&blob, sess))\n-            .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n-            .collect();\n-        let alloc_decoding_state =\n-            AllocDecodingState::new(root.interpret_alloc_index.decode(&blob).collect());\n-        let dependencies = Lock::new(cnum_map.iter().cloned().collect());\n-        CrateMetadata {\n-            blob,\n-            root,\n-            def_path_table,\n-            trait_impls,\n-            raw_proc_macros,\n-            source_map_import_info: Once::new(),\n-            alloc_decoding_state,\n-            dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n-            cnum,\n-            cnum_map,\n-            dependencies,\n-            dep_kind: Lock::new(dep_kind),\n-            source,\n-            private_dep,\n-            host_hash,\n-            extern_crate: Lock::new(None),\n-        }\n-    }\n-\n+impl<'a, 'tcx> CrateMetadataRef<'a> {\n     fn is_proc_macro(&self, id: DefIndex) -> bool {\n         self.root.proc_macro_data.and_then(|data| data.decode(self).find(|x| *x == id)).is_some()\n     }\n@@ -622,10 +580,6 @@ impl<'a, 'tcx> CrateMetadata {\n         })\n     }\n \n-    fn local_def_id(&self, index: DefIndex) -> DefId {\n-        DefId { krate: self.cnum, index }\n-    }\n-\n     fn raw_proc_macro(&self, id: DefIndex) -> &ProcMacro {\n         // DefIndex's in root.proc_macro_data have a one-to-one correspondence\n         // with items in 'raw_proc_macros'.\n@@ -1191,18 +1145,6 @@ impl<'a, 'tcx> CrateMetadata {\n             .collect()\n     }\n \n-    // Translate a DefId from the current compilation environment to a DefId\n-    // for an external crate.\n-    fn reverse_translate_def_id(&self, did: DefId) -> Option<DefId> {\n-        for (local, &global) in self.cnum_map.iter_enumerated() {\n-            if global == did.krate {\n-                return Some(DefId { krate: local, index: did.index });\n-            }\n-        }\n-\n-        None\n-    }\n-\n     fn get_inherent_implementations_for_type(\n         &self,\n         tcx: TyCtxt<'tcx>,\n@@ -1409,11 +1351,6 @@ impl<'a, 'tcx> CrateMetadata {\n         DefPath::make(self.cnum, id, |parent| self.def_key(parent))\n     }\n \n-    #[inline]\n-    fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n-        self.def_path_table.def_path_hash(index)\n-    }\n-\n     /// Imports the source_map from an external crate into the source_map of the crate\n     /// currently being compiled (the \"local crate\").\n     ///\n@@ -1440,10 +1377,10 @@ impl<'a, 'tcx> CrateMetadata {\n     /// Proc macro crates don't currently export spans, so this function does not have\n     /// to work for them.\n     fn imported_source_files(\n-        &'a self,\n+        &self,\n         local_source_map: &source_map::SourceMap,\n-    ) -> &[ImportedSourceFile] {\n-        self.source_map_import_info.init_locking(|| {\n+    ) -> &'a [ImportedSourceFile] {\n+        self.cdata.source_map_import_info.init_locking(|| {\n             let external_source_map = self.root.source_map.decode(self);\n \n             external_source_map\n@@ -1516,29 +1453,50 @@ impl<'a, 'tcx> CrateMetadata {\n                 .collect()\n         })\n     }\n+}\n \n-    /// Get the `DepNodeIndex` corresponding this crate. The result of this\n-    /// method is cached in the `dep_node_index` field.\n-    fn get_crate_dep_node_index(&self, tcx: TyCtxt<'tcx>) -> DepNodeIndex {\n-        let mut dep_node_index = self.dep_node_index.load();\n-\n-        if unlikely!(dep_node_index == DepNodeIndex::INVALID) {\n-            // We have not cached the DepNodeIndex for this upstream crate yet,\n-            // so use the dep-graph to find it out and cache it.\n-            // Note that multiple threads can enter this block concurrently.\n-            // That is fine because the DepNodeIndex remains constant\n-            // throughout the whole compilation session, and multiple stores\n-            // would always write the same value.\n-\n-            let def_path_hash = self.def_path_hash(CRATE_DEF_INDEX);\n-            let dep_node = def_path_hash.to_dep_node(dep_graph::DepKind::CrateMetadata);\n-\n-            dep_node_index = tcx.dep_graph.dep_node_index_of(&dep_node);\n-            assert!(dep_node_index != DepNodeIndex::INVALID);\n-            self.dep_node_index.store(dep_node_index);\n+impl CrateMetadata {\n+    crate fn new(\n+        sess: &Session,\n+        blob: MetadataBlob,\n+        root: CrateRoot<'static>,\n+        raw_proc_macros: Option<&'static [ProcMacro]>,\n+        cnum: CrateNum,\n+        cnum_map: CrateNumMap,\n+        dep_kind: DepKind,\n+        source: CrateSource,\n+        private_dep: bool,\n+        host_hash: Option<Svh>,\n+    ) -> CrateMetadata {\n+        let def_path_table = record_time(&sess.perf_stats.decode_def_path_tables_time, || {\n+            root.def_path_table.decode((&blob, sess))\n+        });\n+        let trait_impls = root\n+            .impls\n+            .decode((&blob, sess))\n+            .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n+            .collect();\n+        let alloc_decoding_state =\n+            AllocDecodingState::new(root.interpret_alloc_index.decode(&blob).collect());\n+        let dependencies = Lock::new(cnum_map.iter().cloned().collect());\n+        CrateMetadata {\n+            blob,\n+            root,\n+            def_path_table,\n+            trait_impls,\n+            raw_proc_macros,\n+            source_map_import_info: Once::new(),\n+            alloc_decoding_state,\n+            dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n+            cnum,\n+            cnum_map,\n+            dependencies,\n+            dep_kind: Lock::new(dep_kind),\n+            source,\n+            private_dep,\n+            host_hash,\n+            extern_crate: Lock::new(None),\n         }\n-\n-        dep_node_index\n     }\n \n     crate fn dependencies(&self) -> LockGuard<'_, Vec<CrateNum>> {\n@@ -1613,6 +1571,51 @@ impl<'a, 'tcx> CrateMetadata {\n     crate fn hash(&self) -> Svh {\n         self.root.hash\n     }\n+\n+    fn local_def_id(&self, index: DefIndex) -> DefId {\n+        DefId { krate: self.cnum, index }\n+    }\n+\n+    // Translate a DefId from the current compilation environment to a DefId\n+    // for an external crate.\n+    fn reverse_translate_def_id(&self, did: DefId) -> Option<DefId> {\n+        for (local, &global) in self.cnum_map.iter_enumerated() {\n+            if global == did.krate {\n+                return Some(DefId { krate: local, index: did.index });\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    #[inline]\n+    fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n+        self.def_path_table.def_path_hash(index)\n+    }\n+\n+    /// Get the `DepNodeIndex` corresponding this crate. The result of this\n+    /// method is cached in the `dep_node_index` field.\n+    fn get_crate_dep_node_index(&self, tcx: TyCtxt<'tcx>) -> DepNodeIndex {\n+        let mut dep_node_index = self.dep_node_index.load();\n+\n+        if unlikely!(dep_node_index == DepNodeIndex::INVALID) {\n+            // We have not cached the DepNodeIndex for this upstream crate yet,\n+            // so use the dep-graph to find it out and cache it.\n+            // Note that multiple threads can enter this block concurrently.\n+            // That is fine because the DepNodeIndex remains constant\n+            // throughout the whole compilation session, and multiple stores\n+            // would always write the same value.\n+\n+            let def_path_hash = self.def_path_hash(CRATE_DEF_INDEX);\n+            let dep_node = def_path_hash.to_dep_node(dep_graph::DepKind::CrateMetadata);\n+\n+            dep_node_index = tcx.dep_graph.dep_node_index_of(&dep_node);\n+            assert!(dep_node_index != DepNodeIndex::INVALID);\n+            self.dep_node_index.store(dep_node_index);\n+        }\n+\n+        dep_node_index\n+    }\n }\n \n // Cannot be implemented on 'ProcMacro', as libproc_macro"}, {"sha": "c890640d432a7ac2ae0c5232c10c34d193d09593", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -517,7 +517,7 @@ impl CrateStore for CStore {\n     }\n \n     fn def_path_table(&self, cnum: CrateNum) -> &DefPathTable {\n-        &self.get_crate_data(cnum).def_path_table\n+        &self.get_crate_data(cnum).cdata.def_path_table\n     }\n \n     fn crates_untracked(&self) -> Vec<CrateNum> {"}, {"sha": "8d4afd2c3b3afdc6c4851eafc54ad85586ec0895", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -51,7 +51,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &mut self,\n         location: Location,\n         desired_action: InitializationRequiringAction,\n-        (moved_place, used_place, span): (PlaceRef<'cx, 'tcx>, PlaceRef<'cx, 'tcx>, Span),\n+        (moved_place, used_place, span): (PlaceRef<'tcx>, PlaceRef<'tcx>, Span),\n         mpi: MovePathIndex,\n     ) {\n         debug!(\n@@ -647,7 +647,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // borrowed place and look for a access to a different field of the same union.\n                 let Place { local, projection } = second_borrowed_place;\n \n-                let mut cursor = projection.as_ref();\n+                let mut cursor = &projection[..];\n                 while let [proj_base @ .., elem] = cursor {\n                     cursor = proj_base;\n \n@@ -1521,7 +1521,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         err.buffer(&mut self.errors_buffer);\n     }\n \n-    fn classify_drop_access_kind(&self, place: PlaceRef<'cx, 'tcx>) -> StorageDeadOrDrop<'tcx> {\n+    fn classify_drop_access_kind(&self, place: PlaceRef<'tcx>) -> StorageDeadOrDrop<'tcx> {\n         let tcx = self.infcx.tcx;\n         match place.projection {\n             [] => StorageDeadOrDrop::LocalStorageDead,"}, {"sha": "7110a4a3058a65f93d24a238ca96f833bb7ae326", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -51,7 +51,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     pub(super) fn add_moved_or_invoked_closure_note(\n         &self,\n         location: Location,\n-        place: PlaceRef<'cx, 'tcx>,\n+        place: PlaceRef<'tcx>,\n         diag: &mut DiagnosticBuilder<'_>,\n     ) {\n         debug!(\"add_moved_or_invoked_closure_note: location={:?} place={:?}\", location, place);\n@@ -139,7 +139,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// End-user visible description of `place` if one can be found. If the\n     /// place is a temporary for instance, None will be returned.\n-    pub(super) fn describe_place(&self, place_ref: PlaceRef<'cx, 'tcx>) -> Option<String> {\n+    pub(super) fn describe_place(&self, place_ref: PlaceRef<'tcx>) -> Option<String> {\n         self.describe_place_with_options(place_ref, IncludingDowncast(false))\n     }\n \n@@ -149,7 +149,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// `Downcast` and `IncludingDowncast` is true\n     pub(super) fn describe_place_with_options(\n         &self,\n-        place: PlaceRef<'cx, 'tcx>,\n+        place: PlaceRef<'tcx>,\n         including_downcast: IncludingDowncast,\n     ) -> Option<String> {\n         let mut buf = String::new();\n@@ -162,7 +162,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Appends end-user visible description of `place` to `buf`.\n     fn append_place_to_string(\n         &self,\n-        place: PlaceRef<'cx, 'tcx>,\n+        place: PlaceRef<'tcx>,\n         buf: &mut String,\n         mut autoderef: bool,\n         including_downcast: &IncludingDowncast,\n@@ -303,7 +303,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n \n     /// End-user visible description of the `field`nth field of `base`\n-    fn describe_field(&self, place: PlaceRef<'cx, 'tcx>, field: Field) -> String {\n+    fn describe_field(&self, place: PlaceRef<'tcx>, field: Field) -> String {\n         // FIXME Place2 Make this work iteratively\n         match place {\n             PlaceRef { local, projection: [] } => {\n@@ -399,7 +399,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     pub(super) fn borrowed_content_source(\n         &self,\n-        deref_base: PlaceRef<'cx, 'tcx>,\n+        deref_base: PlaceRef<'tcx>,\n     ) -> BorrowedContentSource<'tcx> {\n         let tcx = self.infcx.tcx;\n \n@@ -694,7 +694,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Finds the spans associated to a move or copy of move_place at location.\n     pub(super) fn move_spans(\n         &self,\n-        moved_place: PlaceRef<'cx, 'tcx>, // Could also be an upvar.\n+        moved_place: PlaceRef<'tcx>, // Could also be an upvar.\n         location: Location,\n     ) -> UseSpans {\n         use self::UseSpans::*;\n@@ -782,7 +782,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn closure_span(\n         &self,\n         def_id: DefId,\n-        target_place: PlaceRef<'cx, 'tcx>,\n+        target_place: PlaceRef<'tcx>,\n         places: &Vec<Operand<'tcx>>,\n     ) -> Option<(Span, Option<GeneratorKind>, Span)> {\n         debug!("}, {"sha": "c6fe0dba80cd580e7cfc1a3aed2971144ac4fd74", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -23,7 +23,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         &mut self,\n         access_place: &Place<'tcx>,\n         span: Span,\n-        the_place_err: PlaceRef<'cx, 'tcx>,\n+        the_place_err: PlaceRef<'tcx>,\n         error_access: AccessKind,\n         location: Location,\n     ) {"}, {"sha": "a61d00b0120cb340e33f7697e0f543e88c46f3fd", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -86,6 +86,8 @@ crate struct Upvar {\n     mutability: Mutability,\n }\n \n+const DEREF_PROJECTION: &[PlaceElem<'_>; 1] = &[ProjectionElem::Deref];\n+\n pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers { mir_borrowck, ..*providers };\n }\n@@ -466,10 +468,10 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     /// `BTreeMap` is used to preserve the order of insertions when iterating. This is necessary\n     /// when errors in the map are being re-added to the error buffer so that errors with the\n     /// same primary span come out in a consistent order.\n-    move_error_reported: BTreeMap<Vec<MoveOutIndex>, (PlaceRef<'cx, 'tcx>, DiagnosticBuilder<'cx>)>,\n+    move_error_reported: BTreeMap<Vec<MoveOutIndex>, (PlaceRef<'tcx>, DiagnosticBuilder<'cx>)>,\n     /// This field keeps track of errors reported in the checking of uninitialized variables,\n     /// so that we don't report seemingly duplicate errors.\n-    uninitialized_error_reported: FxHashSet<PlaceRef<'cx, 'tcx>>,\n+    uninitialized_error_reported: FxHashSet<PlaceRef<'tcx>>,\n     /// Errors to be reported buffer\n     errors_buffer: Vec<Diagnostic>,\n     /// This field keeps track of all the local variables that are declared mut and are mutated.\n@@ -841,9 +843,9 @@ enum InitializationRequiringAction {\n     PartialAssignment,\n }\n \n-struct RootPlace<'d, 'tcx> {\n+struct RootPlace<'tcx> {\n     place_local: Local,\n-    place_projection: &'d [PlaceElem<'tcx>],\n+    place_projection: &'tcx [PlaceElem<'tcx>],\n     is_local_mutation_allowed: LocalMutationIsAllowed,\n }\n \n@@ -1413,7 +1415,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) {\n         debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n         let place = &borrow.borrowed_place;\n-        let deref = [ProjectionElem::Deref];\n         let mut root_place = PlaceRef { local: place.local, projection: &[] };\n \n         // FIXME(nll-rfc#40): do more precise destructor tracking here. For now\n@@ -1427,7 +1428,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // Thread-locals might be dropped after the function exits\n                 // We have to dereference the outer reference because\n                 // borrows don't conflict behind shared references.\n-                root_place.projection = &deref;\n+                root_place.projection = DEREF_PROJECTION;\n                 (true, true)\n             } else {\n                 (false, self.locals_are_invalidated_at_exit)\n@@ -1526,7 +1527,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &mut self,\n         location: Location,\n         desired_action: InitializationRequiringAction,\n-        place_span: (PlaceRef<'cx, 'tcx>, Span),\n+        place_span: (PlaceRef<'tcx>, Span),\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         let maybe_uninits = &flow_state.uninits;\n@@ -1592,7 +1593,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &mut self,\n         location: Location,\n         desired_action: InitializationRequiringAction,\n-        place_span: (PlaceRef<'cx, 'tcx>, Span),\n+        place_span: (PlaceRef<'tcx>, Span),\n         maybe_uninits: &BitSet<MovePathIndex>,\n         from: u32,\n         to: u32,\n@@ -1631,7 +1632,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &mut self,\n         location: Location,\n         desired_action: InitializationRequiringAction,\n-        place_span: (PlaceRef<'cx, 'tcx>, Span),\n+        place_span: (PlaceRef<'tcx>, Span),\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         let maybe_uninits = &flow_state.uninits;\n@@ -1709,10 +1710,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// An Err result includes a tag indicated why the search failed.\n     /// Currently this can only occur if the place is built off of a\n     /// static variable, as we do not track those in the MoveData.\n-    fn move_path_closest_to(\n-        &mut self,\n-        place: PlaceRef<'_, 'tcx>,\n-    ) -> (PlaceRef<'cx, 'tcx>, MovePathIndex) {\n+    fn move_path_closest_to(&mut self, place: PlaceRef<'tcx>) -> (PlaceRef<'tcx>, MovePathIndex) {\n         match self.move_data.rev_lookup.find(place) {\n             LookupResult::Parent(Some(mpi)) | LookupResult::Exact(mpi) => {\n                 (self.move_data.move_paths[mpi].place.as_ref(), mpi)\n@@ -1721,7 +1719,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n-    fn move_path_for_place(&mut self, place: PlaceRef<'_, 'tcx>) -> Option<MovePathIndex> {\n+    fn move_path_for_place(&mut self, place: PlaceRef<'tcx>) -> Option<MovePathIndex> {\n         // If returns None, then there is no move path corresponding\n         // to a direct owner of `place` (which means there is nothing\n         // that borrowck tracks for its analysis).\n@@ -1816,7 +1814,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         fn check_parent_of_field<'cx, 'tcx>(\n             this: &mut MirBorrowckCtxt<'cx, 'tcx>,\n             location: Location,\n-            base: PlaceRef<'cx, 'tcx>,\n+            base: PlaceRef<'tcx>,\n             span: Span,\n             flow_state: &Flows<'cx, 'tcx>,\n         ) {\n@@ -2029,7 +2027,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n \n     /// Adds the place into the used mutable variables set\n-    fn add_used_mut<'d>(&mut self, root_place: RootPlace<'d, 'tcx>, flow_state: &Flows<'cx, 'tcx>) {\n+    fn add_used_mut(&mut self, root_place: RootPlace<'tcx>, flow_state: &Flows<'cx, 'tcx>) {\n         match root_place {\n             RootPlace { place_local: local, place_projection: [], is_local_mutation_allowed } => {\n                 // If the local may have been initialized, and it is now currently being\n@@ -2063,11 +2061,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// Whether this value can be written or borrowed mutably.\n     /// Returns the root place if the place passed in is a projection.\n-    fn is_mutable<'d>(\n+    fn is_mutable(\n         &self,\n-        place: PlaceRef<'d, 'tcx>,\n+        place: PlaceRef<'tcx>,\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n-    ) -> Result<RootPlace<'d, 'tcx>, PlaceRef<'d, 'tcx>> {\n+    ) -> Result<RootPlace<'tcx>, PlaceRef<'tcx>> {\n         match place {\n             PlaceRef { local, projection: [] } => {\n                 let local = &self.body.local_decls[local];\n@@ -2218,7 +2216,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// then returns the index of the field being projected. Note that this closure will always\n     /// be `self` in the current MIR, because that is the only time we directly access the fields\n     /// of a closure type.\n-    pub fn is_upvar_field_projection(&self, place_ref: PlaceRef<'cx, 'tcx>) -> Option<Field> {\n+    pub fn is_upvar_field_projection(&self, place_ref: PlaceRef<'tcx>) -> Option<Field> {\n         let mut place_projection = place_ref.projection;\n         let mut by_ref = false;\n "}, {"sha": "767ffa50fedb4cd23f30434c70ae559308e9a95c", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -48,7 +48,7 @@ pub(super) fn borrow_conflicts_with_place<'tcx>(\n     body: &Body<'tcx>,\n     borrow_place: &Place<'tcx>,\n     borrow_kind: BorrowKind,\n-    access_place: PlaceRef<'_, 'tcx>,\n+    access_place: PlaceRef<'tcx>,\n     access: AccessDepth,\n     bias: PlaceConflictBias,\n ) -> bool {\n@@ -73,7 +73,7 @@ fn place_components_conflict<'tcx>(\n     body: &Body<'tcx>,\n     borrow_place: &Place<'tcx>,\n     borrow_kind: BorrowKind,\n-    access_place: PlaceRef<'_, 'tcx>,\n+    access_place: PlaceRef<'tcx>,\n     access: AccessDepth,\n     bias: PlaceConflictBias,\n ) -> bool {"}, {"sha": "c64e8c363af54c9777c6279122733b3b8592d0d1", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -13,12 +13,12 @@ use rustc::mir::{Place, PlaceRef, ProjectionElem, ReadOnlyBodyAndCache};\n use rustc::ty::{self, TyCtxt};\n use rustc_hir as hir;\n \n-pub trait IsPrefixOf<'cx, 'tcx> {\n-    fn is_prefix_of(&self, other: PlaceRef<'cx, 'tcx>) -> bool;\n+pub trait IsPrefixOf<'tcx> {\n+    fn is_prefix_of(&self, other: PlaceRef<'tcx>) -> bool;\n }\n \n-impl<'cx, 'tcx> IsPrefixOf<'cx, 'tcx> for PlaceRef<'cx, 'tcx> {\n-    fn is_prefix_of(&self, other: PlaceRef<'cx, 'tcx>) -> bool {\n+impl<'tcx> IsPrefixOf<'tcx> for PlaceRef<'tcx> {\n+    fn is_prefix_of(&self, other: PlaceRef<'tcx>) -> bool {\n         self.local == other.local\n             && self.projection.len() <= other.projection.len()\n             && self.projection == &other.projection[..self.projection.len()]\n@@ -29,7 +29,7 @@ pub(super) struct Prefixes<'cx, 'tcx> {\n     body: ReadOnlyBodyAndCache<'cx, 'tcx>,\n     tcx: TyCtxt<'tcx>,\n     kind: PrefixSet,\n-    next: Option<PlaceRef<'cx, 'tcx>>,\n+    next: Option<PlaceRef<'tcx>>,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -50,15 +50,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// terminating the iteration early based on `kind`.\n     pub(super) fn prefixes(\n         &self,\n-        place_ref: PlaceRef<'cx, 'tcx>,\n+        place_ref: PlaceRef<'tcx>,\n         kind: PrefixSet,\n     ) -> Prefixes<'cx, 'tcx> {\n         Prefixes { next: Some(place_ref), kind, body: self.body, tcx: self.infcx.tcx }\n     }\n }\n \n impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n-    type Item = PlaceRef<'cx, 'tcx>;\n+    type Item = PlaceRef<'tcx>;\n     fn next(&mut self) -> Option<Self::Item> {\n         let mut cursor = self.next?;\n "}, {"sha": "7c449ad119796fb165376d9161b960c1c5862fbe", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -483,7 +483,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n         self.builder.data.loc_map[self.loc].push(move_out);\n     }\n \n-    fn gather_init(&mut self, place: PlaceRef<'cx, 'tcx>, kind: InitKind) {\n+    fn gather_init(&mut self, place: PlaceRef<'tcx>, kind: InitKind) {\n         debug!(\"gather_init({:?}, {:?})\", self.loc, place);\n \n         let mut place = place;"}, {"sha": "593952bfa7c809609195eb29c51153dba8e2a5f6", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -312,7 +312,7 @@ impl MovePathLookup {\n     // alternative will *not* create a MovePath on the fly for an\n     // unknown place, but will rather return the nearest available\n     // parent.\n-    pub fn find(&self, place: PlaceRef<'_, '_>) -> LookupResult {\n+    pub fn find(&self, place: PlaceRef<'_>) -> LookupResult {\n         let mut result = self.locals[place.local];\n \n         for elem in place.projection.iter() {"}, {"sha": "2306177c14b8a20d1be4f6ffcac3219e8813fdf3", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -14,7 +14,7 @@ pub struct AddRetag;\n /// after the assignment, we can be sure to obtain the same place value.\n /// (Concurrent accesses by other threads are no problem as these are anyway non-atomic\n /// copies.  Data races are UB.)\n-fn is_stable(place: PlaceRef<'_, '_>) -> bool {\n+fn is_stable(place: PlaceRef<'_>) -> bool {\n     place.projection.iter().all(|elem| {\n         match elem {\n             // Which place this evaluates to can change with any memory write,"}, {"sha": "baff8383c20a445ebffd52cc4e3c687ed33d6723", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -35,7 +35,7 @@ pub trait Qualif {\n     fn in_projection_structurally(\n         cx: &ConstCx<'_, 'tcx>,\n         per_local: &mut impl FnMut(Local) -> bool,\n-        place: PlaceRef<'_, 'tcx>,\n+        place: PlaceRef<'tcx>,\n     ) -> bool {\n         if let [proj_base @ .., elem] = place.projection {\n             let base_qualif = Self::in_place(\n@@ -67,15 +67,15 @@ pub trait Qualif {\n     fn in_projection(\n         cx: &ConstCx<'_, 'tcx>,\n         per_local: &mut impl FnMut(Local) -> bool,\n-        place: PlaceRef<'_, 'tcx>,\n+        place: PlaceRef<'tcx>,\n     ) -> bool {\n         Self::in_projection_structurally(cx, per_local, place)\n     }\n \n     fn in_place(\n         cx: &ConstCx<'_, 'tcx>,\n         per_local: &mut impl FnMut(Local) -> bool,\n-        place: PlaceRef<'_, 'tcx>,\n+        place: PlaceRef<'tcx>,\n     ) -> bool {\n         match place {\n             PlaceRef { local, projection: [] } => per_local(local),"}, {"sha": "7dd134a35d9095925b75a7b87c9d3a3683ac34e3", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -474,7 +474,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n         }\n     }\n \n-    fn validate_place(&self, place: PlaceRef<'_, 'tcx>) -> Result<(), Unpromotable> {\n+    fn validate_place(&self, place: PlaceRef<'tcx>) -> Result<(), Unpromotable> {\n         match place {\n             PlaceRef { local, projection: [] } => self.validate_local(local),\n             PlaceRef { local: _, projection: [proj_base @ .., elem] } => {"}, {"sha": "1e09cd79dbe18bd139d05e36f11e147d18b9bea7", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -270,7 +270,6 @@ symbols! {\n         doc_cfg,\n         doc_keyword,\n         doc_masked,\n-        doc_spotlight,\n         doctest,\n         document_private_items,\n         dotdoteq_in_patterns,\n@@ -689,7 +688,6 @@ symbols! {\n         Some,\n         specialization,\n         speed,\n-        spotlight,\n         sse4a_target_feature,\n         stable,\n         staged_api,"}, {"sha": "7cb870ae702fb57aaf98ea2cb5509c42ef792249", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -198,15 +198,13 @@ pub fn build_external_trait(cx: &DocContext<'_>, did: DefId) -> clean::Trait {\n     let generics = (cx.tcx.generics_of(did), predicates).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n     let (generics, supertrait_bounds) = separate_supertrait_bounds(generics);\n-    let is_spotlight = load_attrs(cx, did).clean(cx).has_doc_flag(sym::spotlight);\n     let is_auto = cx.tcx.trait_is_auto(did);\n     clean::Trait {\n         auto: auto_trait,\n         unsafety: cx.tcx.trait_def(did).unsafety,\n         generics,\n         items: trait_items,\n         bounds: supertrait_bounds,\n-        is_spotlight,\n         is_auto,\n     }\n }"}, {"sha": "b28f1899925745571d01302963406e376125b897", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -1013,7 +1013,6 @@ impl Clean<FnRetTy> for hir::FnRetTy<'_> {\n impl Clean<Item> for doctree::Trait<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let attrs = self.attrs.clean(cx);\n-        let is_spotlight = attrs.has_doc_flag(sym::spotlight);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs,\n@@ -1028,7 +1027,6 @@ impl Clean<Item> for doctree::Trait<'_> {\n                 items: self.items.iter().map(|ti| ti.clean(cx)).collect(),\n                 generics: self.generics.clean(cx),\n                 bounds: self.bounds.clean(cx),\n-                is_spotlight,\n                 is_auto: self.is_auto.clean(cx),\n             }),\n         }"}, {"sha": "b1aa094204a1eda7a9f9c64e8c263ba1c848918c", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -951,7 +951,6 @@ pub struct Trait {\n     pub items: Vec<Item>,\n     pub generics: Generics,\n     pub bounds: Vec<GenericBound>,\n-    pub is_spotlight: bool,\n     pub is_auto: bool,\n }\n "}, {"sha": "e60ff37fd279aa9725c27cc43232b1d086a6c5c0", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -63,22 +63,10 @@ impl Buffer {\n         Buffer { for_html: false, buffer: String::new() }\n     }\n \n-    crate fn is_empty(&self) -> bool {\n-        self.buffer.is_empty()\n-    }\n-\n     crate fn into_inner(self) -> String {\n         self.buffer\n     }\n \n-    crate fn insert_str(&mut self, idx: usize, s: &str) {\n-        self.buffer.insert_str(idx, s);\n-    }\n-\n-    crate fn push_str(&mut self, s: &str) {\n-        self.buffer.push_str(s);\n-    }\n-\n     // Intended for consumption by write! and writeln! (std::fmt) but without\n     // the fmt::Result return type imposed by fmt::Write (and avoiding the trait\n     // import)."}, {"sha": "6063ad093885f88600104af2afbed200951420eb", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 81, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -2325,7 +2325,7 @@ fn item_function(w: &mut Buffer, cx: &Context, it: &clean::Item, f: &clean::Func\n         f.generics.print()\n     )\n     .len();\n-    write!(w, \"{}<pre class='rust fn'>\", render_spotlight_traits(it));\n+    write!(w, \"<pre class='rust fn'>\");\n     render_attributes(w, it, false);\n     write!(\n         w,\n@@ -2528,13 +2528,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n         let item_type = m.type_();\n         let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n         let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-        write!(\n-            w,\n-            \"<h3 id='{id}' class='method'>{extra}<code id='{ns_id}'>\",\n-            extra = render_spotlight_traits(m),\n-            id = id,\n-            ns_id = ns_id\n-        );\n+        write!(w, \"<h3 id='{id}' class='method'><code id='{ns_id}'>\", id = id, ns_id = ns_id);\n         render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)), ItemType::Impl);\n         write!(w, \"</code>\");\n         render_stability_since(w, m, t);\n@@ -3520,76 +3514,6 @@ fn should_render_item(item: &clean::Item, deref_mut_: bool) -> bool {\n     }\n }\n \n-fn render_spotlight_traits(item: &clean::Item) -> String {\n-    match item.inner {\n-        clean::FunctionItem(clean::Function { ref decl, .. })\n-        | clean::TyMethodItem(clean::TyMethod { ref decl, .. })\n-        | clean::MethodItem(clean::Method { ref decl, .. })\n-        | clean::ForeignFunctionItem(clean::Function { ref decl, .. }) => spotlight_decl(decl),\n-        _ => String::new(),\n-    }\n-}\n-\n-fn spotlight_decl(decl: &clean::FnDecl) -> String {\n-    let mut out = Buffer::html();\n-    let mut trait_ = String::new();\n-\n-    if let Some(did) = decl.output.def_id() {\n-        let c = cache();\n-        if let Some(impls) = c.impls.get(&did) {\n-            for i in impls {\n-                let impl_ = i.inner_impl();\n-                if impl_.trait_.def_id().map_or(false, |d| c.traits[&d].is_spotlight) {\n-                    if out.is_empty() {\n-                        out.push_str(&format!(\n-                            \"<h3 class=\\\"important\\\">Important traits for {}</h3>\\\n-                                      <code class=\\\"content\\\">\",\n-                            impl_.for_.print()\n-                        ));\n-                        trait_.push_str(&impl_.for_.print().to_string());\n-                    }\n-\n-                    //use the \"where\" class here to make it small\n-                    out.push_str(&format!(\n-                        \"<span class=\\\"where fmt-newline\\\">{}</span>\",\n-                        impl_.print()\n-                    ));\n-                    let t_did = impl_.trait_.def_id().unwrap();\n-                    for it in &impl_.items {\n-                        if let clean::TypedefItem(ref tydef, _) = it.inner {\n-                            out.push_str(\"<span class=\\\"where fmt-newline\\\">    \");\n-                            assoc_type(\n-                                &mut out,\n-                                it,\n-                                &[],\n-                                Some(&tydef.type_),\n-                                AssocItemLink::GotoSource(t_did, &FxHashSet::default()),\n-                                \"\",\n-                            );\n-                            out.push_str(\";</span>\");\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    if !out.is_empty() {\n-        out.insert_str(\n-            0,\n-            &format!(\n-                \"<div class=\\\"important-traits\\\"><div class='tooltip'>\u24d8\\\n-                                    <span class='tooltiptext'>Important traits for {}</span></div>\\\n-                                    <div class=\\\"content hidden\\\">\",\n-                trait_\n-            ),\n-        );\n-        out.push_str(\"</code></div></div>\");\n-    }\n-\n-    out.into_inner()\n-}\n-\n fn render_impl(\n     w: &mut Buffer,\n     cx: &Context,\n@@ -3696,14 +3620,13 @@ fn render_impl(\n                 (true, \" hidden\")\n             };\n         match item.inner {\n-            clean::MethodItem(clean::Method { ref decl, .. })\n-            | clean::TyMethodItem(clean::TyMethod { ref decl, .. }) => {\n+            clean::MethodItem(clean::Method { .. })\n+            | clean::TyMethodItem(clean::TyMethod { .. }) => {\n                 // Only render when the method is not static or we allow static methods\n                 if render_method_item {\n                     let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n                     let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n                     write!(w, \"<h4 id='{}' class=\\\"{}{}\\\">\", id, item_type, extra_class);\n-                    write!(w, \"{}\", spotlight_decl(decl));\n                     write!(w, \"<code id='{}'>\", ns_id);\n                     render_assoc_item(w, item, link.anchor(&id), ItemType::Impl);\n                     write!(w, \"</code>\");"}, {"sha": "a799aed698578916b67881f8986aea99dbe0d40e", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -341,7 +341,6 @@ function getSearchElement() {\n     function handleEscape(ev) {\n         var help = getHelpElement();\n         var search = getSearchElement();\n-        hideModal();\n         if (hasClass(help, \"hidden\") === false) {\n             displayHelp(false, ev, help);\n         } else if (hasClass(search, \"hidden\") === false) {\n@@ -373,7 +372,6 @@ function getSearchElement() {\n             case \"s\":\n             case \"S\":\n                 displayHelp(false, ev);\n-                hideModal();\n                 ev.preventDefault();\n                 focusSearchBar();\n                 break;\n@@ -386,7 +384,6 @@ function getSearchElement() {\n \n             case \"?\":\n                 if (ev.shiftKey) {\n-                    hideModal();\n                     displayHelp(true, ev);\n                 }\n                 break;\n@@ -2504,31 +2501,6 @@ function getSearchElement() {\n         lineNumbersFunc(e);\n     });\n \n-    function showModal(content) {\n-        var modal = document.createElement(\"div\");\n-        modal.id = \"important\";\n-        addClass(modal, \"modal\");\n-        modal.innerHTML = \"<div class=\\\"modal-content\\\"><div class=\\\"close\\\" id=\\\"modal-close\\\">\u2715\" +\n-                          \"</div><div class=\\\"whiter\\\"></div><span class=\\\"docblock\\\">\" + content +\n-                          \"</span></div>\";\n-        document.getElementsByTagName(\"body\")[0].appendChild(modal);\n-        document.getElementById(\"modal-close\").onclick = hideModal;\n-        modal.onclick = hideModal;\n-    }\n-\n-    function hideModal() {\n-        var modal = document.getElementById(\"important\");\n-        if (modal) {\n-            modal.parentNode.removeChild(modal);\n-        }\n-    }\n-\n-    onEachLazy(document.getElementsByClassName(\"important-traits\"), function(e) {\n-        e.onclick = function() {\n-            showModal(e.lastElementChild.innerHTML);\n-        };\n-    });\n-\n     // In the search display, allows to switch between tabs.\n     function printTab(nb) {\n         if (nb === 0 || nb === 1 || nb === 2) {"}, {"sha": "f05db6c218524c15b4af697b1166110bf794570c", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 3, "deletions": 93, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -143,12 +143,9 @@ code, pre, a.test-arrow {\n \tborder-radius: 3px;\n \tpadding: 0 0.1em;\n }\n-.docblock pre code, .docblock-short pre code, .docblock code.spotlight {\n+.docblock pre code, .docblock-short pre code {\n \tpadding: 0;\n }\n-.docblock code.spotlight :last-child {\n-\tpadding-bottom: 0.6em;\n-}\n pre {\n \tpadding: 14px;\n }\n@@ -503,7 +500,7 @@ h4 > code, h3 > code, .invisible > code {\n \tfont-size: 0.8em;\n }\n \n-.content .methods > div:not(.important-traits) {\n+.content .methods > div {\n \tmargin-left: 40px;\n \tmargin-bottom: 15px;\n }\n@@ -1072,7 +1069,7 @@ h3 > .collapse-toggle, h4 > .collapse-toggle {\n \tborder-style: solid;\n }\n \n-.important-traits .tooltip .tooltiptext {\n+.tooltip .tooltiptext {\n \tborder: 1px solid;\n }\n \n@@ -1117,17 +1114,6 @@ pre.rust {\n \tfont-size: 16px;\n }\n \n-.important-traits {\n-\tcursor: pointer;\n-\tz-index: 2;\n-}\n-\n-h4 > .important-traits {\n-\tposition: absolute;\n-\tleft: -44px;\n-\ttop: 2px;\n-}\n-\n #all-types {\n \ttext-align: center;\n \tborder: 1px solid;\n@@ -1354,12 +1340,6 @@ h4 > .important-traits {\n \t\tz-index: 1;\n \t}\n \n-\th4 > .important-traits {\n-\t\tposition: absolute;\n-\t\tleft: -22px;\n-\t\ttop: 24px;\n-\t}\n-\n \t#titles > div > div.count {\n \t\tfloat: left;\n \t\twidth: 100%;\n@@ -1462,82 +1442,12 @@ h4 > .important-traits {\n \t}\n }\n \n-.modal {\n-\tposition: fixed;\n-\twidth: 100vw;\n-\theight: 100vh;\n-\tz-index: 10000;\n-\ttop: 0;\n-\tleft: 0;\n-}\n-\n-.modal-content {\n-\tdisplay: block;\n-\tmax-width: 60%;\n-\tmin-width: 200px;\n-\tpadding: 8px;\n-\ttop: 40%;\n-\tposition: absolute;\n-\tleft: 50%;\n-\ttransform: translate(-50%, -40%);\n-\tborder: 1px solid;\n-\tborder-radius: 4px;\n-\tborder-top-right-radius: 0;\n-}\n-\n-.modal-content > .docblock {\n-\tmargin: 0;\n-}\n-\n h3.important {\n \tmargin: 0;\n \tmargin-bottom: 13px;\n \tfont-size: 19px;\n }\n \n-.modal-content > .docblock > code.content {\n-\tmargin: 0;\n-\tpadding: 0;\n-\tfont-size: 20px;\n-}\n-\n-.modal-content > .close {\n-\tposition: absolute;\n-\tfont-weight: 900;\n-\tright: -25px;\n-\ttop: -1px;\n-\tfont-size: 18px;\n-\twidth: 25px;\n-\tpadding-right: 2px;\n-\tborder-top-right-radius: 5px;\n-\tborder-bottom-right-radius: 5px;\n-\ttext-align: center;\n-\tborder: 1px solid;\n-\tborder-right: 0;\n-\tcursor: pointer;\n-}\n-\n-.modal-content > .whiter {\n-\theight: 25px;\n-\tposition: absolute;\n-\twidth: 3px;\n-\tright: -2px;\n-\ttop: 0px;\n-}\n-\n-#main > div.important-traits {\n-\tposition: absolute;\n-\tleft: -24px;\n-\tmargin-top: 16px;\n-}\n-\n-.content > .methods > .method > div.important-traits {\n-\tposition: absolute;\n-\tfont-weight: 400;\n-\tleft: -42px;\n-\tmargin-top: 2px;\n-}\n-\n kbd {\n \tdisplay: inline-block;\n \tpadding: 3px 5px;"}, {"sha": "e7041d54c6bfdb10badc616d423b9bef08d9a1cb", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -298,12 +298,6 @@ pre.ignore:hover, .information:hover + pre.ignore {\n \tborder-color: transparent black transparent transparent;\n }\n \n-.important-traits .tooltip .tooltiptext {\n-\tbackground-color: white;\n-\tcolor: black;\n-\tborder-color: black;\n-}\n-\n #titles > div:not(.selected) {\n \tbackground-color: #252525;\n \tborder-top-color: #252525;\n@@ -317,33 +311,6 @@ pre.ignore:hover, .information:hover + pre.ignore {\n \tcolor: #888;\n }\n \n-.modal {\n-\tbackground-color: rgba(0,0,0,0.3);\n-}\n-\n-.modal-content {\n-\tbackground-color: #272727;\n-\tborder-color: #999;\n-}\n-\n-.modal-content > .close {\n-\tbackground-color: #272727;\n-\tborder-color: #999;\n-}\n-\n-.modal-content > .close:hover {\n-\tbackground-color: #ff1f1f;\n-\tcolor: white;\n-}\n-\n-.modal-content > .whiter {\n-\tbackground-color: #272727;\n-}\n-\n-.modal-content > .close:hover + .whiter {\n-\tbackground-color: #ff1f1f;\n-}\n-\n @media (max-width: 700px) {\n \t.sidebar-menu {\n \t\tbackground-color: #505050;"}, {"sha": "a1efef6701fd1c97b0214b9e7deeabe6f8acaab9", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -292,12 +292,6 @@ pre.ignore:hover, .information:hover + pre.ignore {\n \tborder-color: transparent black transparent transparent;\n }\n \n-.important-traits .tooltip .tooltiptext {\n-\tbackground-color: white;\n-\tcolor: black;\n-\tborder-color: black;\n-}\n-\n #titles > div:not(.selected) {\n \tbackground-color: #e6e6e6;\n \tborder-top-color: #e6e6e6;\n@@ -311,33 +305,6 @@ pre.ignore:hover, .information:hover + pre.ignore {\n \tcolor: #888;\n }\n \n-.modal {\n-\tbackground-color: rgba(0,0,0,0.3);\n-}\n-\n-.modal-content {\n-\tbackground-color: #eee;\n-\tborder-color: #999;\n-}\n-\n-.modal-content > .close {\n-\tbackground-color: #eee;\n-\tborder-color: #999;\n-}\n-\n-.modal-content > .close:hover {\n-\tbackground-color: #ff1f1f;\n-\tcolor: white;\n-}\n-\n-.modal-content > .whiter {\n-\tbackground-color: #eee;\n-}\n-\n-.modal-content > .close:hover + .whiter {\n-\tbackground-color: #ff1f1f;\n-}\n-\n @media (max-width: 700px) {\n \t.sidebar-menu {\n \t\tbackground-color: #F1F1F1;"}, {"sha": "25f3ddcbebab69f848ebceae9b668022ef625a2e", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -133,24 +133,41 @@ pub use alloc_crate::alloc::*;\n #[derive(Debug, Default, Copy, Clone)]\n pub struct System;\n \n-// The AllocRef impl just forwards to the GlobalAlloc impl, which is in `std::sys::*::alloc`.\n+// The AllocRef impl checks the layout size to be non-zero and forwards to the GlobalAlloc impl,\n+// which is in `std::sys::*::alloc`.\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for System {\n     #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr).map(|p| (p, layout.size()))\n+    fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        if layout.size() == 0 {\n+            Ok((layout.dangling(), 0))\n+        } else {\n+            unsafe {\n+                NonNull::new(GlobalAlloc::alloc(self, layout))\n+                    .ok_or(AllocErr)\n+                    .map(|p| (p, layout.size()))\n+            }\n+        }\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        NonNull::new(GlobalAlloc::alloc_zeroed(self, layout))\n-            .ok_or(AllocErr)\n-            .map(|p| (p, layout.size()))\n+    fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        if layout.size() == 0 {\n+            Ok((layout.dangling(), 0))\n+        } else {\n+            unsafe {\n+                NonNull::new(GlobalAlloc::alloc_zeroed(self, layout))\n+                    .ok_or(AllocErr)\n+                    .map(|p| (p, layout.size()))\n+            }\n+        }\n     }\n \n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n-        GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n+        if layout.size() != 0 {\n+            GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n+        }\n     }\n \n     #[inline]\n@@ -160,9 +177,17 @@ unsafe impl AllocRef for System {\n         layout: Layout,\n         new_size: usize,\n     ) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size))\n-            .ok_or(AllocErr)\n-            .map(|p| (p, new_size))\n+        match (layout.size(), new_size) {\n+            (0, 0) => Ok((layout.dangling(), 0)),\n+            (0, _) => self.alloc(Layout::from_size_align_unchecked(new_size, layout.align())),\n+            (_, 0) => {\n+                self.dealloc(ptr, layout);\n+                Ok((layout.dangling(), 0))\n+            }\n+            (_, _) => NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size))\n+                .ok_or(AllocErr)\n+                .map(|p| (p, new_size)),\n+        }\n     }\n }\n "}, {"sha": "420d6ea589a224662ed79d6b6c001101a737beaa", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -497,7 +497,6 @@ where\n /// [`&str`]: ../../std/primitive.str.html\n /// [slice]: ../../std/primitive.slice.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(spotlight)]\n pub trait Read {\n     /// Pull some bytes from this source into the specified buffer, returning\n     /// how many bytes were read.\n@@ -1228,7 +1227,6 @@ impl Initializer {\n ///\n /// [`write_all`]: #method.write_all\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(spotlight)]\n pub trait Write {\n     /// Write a buffer into this writer, returning how many bytes were written.\n     ///"}, {"sha": "231908ddda0ae2c8231e031e053169c96154bf12", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -255,7 +255,6 @@\n #![feature(doc_cfg)]\n #![feature(doc_keyword)]\n #![feature(doc_masked)]\n-#![feature(doc_spotlight)]\n #![feature(dropck_eyepatch)]\n #![feature(duration_constants)]\n #![feature(exact_size_is_empty)]"}, {"sha": "ddd46c3c2155f8b74a55aa30144381499c3498d3", "filename": "src/test/rustdoc/doc-spotlight.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Frustdoc%2Fdoc-spotlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Frustdoc%2Fdoc-spotlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-spotlight.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -1,36 +0,0 @@\n-#![feature(doc_spotlight)]\n-\n-pub struct Wrapper<T> {\n-    inner: T,\n-}\n-\n-impl<T: SomeTrait> SomeTrait for Wrapper<T> {}\n-\n-#[doc(spotlight)]\n-pub trait SomeTrait {\n-    // @has doc_spotlight/trait.SomeTrait.html\n-    // @has - '//code[@class=\"content\"]' 'impl<T: SomeTrait> SomeTrait for Wrapper<T>'\n-    fn wrap_me(self) -> Wrapper<Self> where Self: Sized {\n-        Wrapper {\n-            inner: self,\n-        }\n-    }\n-}\n-\n-pub struct SomeStruct;\n-impl SomeTrait for SomeStruct {}\n-\n-impl SomeStruct {\n-    // @has doc_spotlight/struct.SomeStruct.html\n-    // @has - '//code[@class=\"content\"]' 'impl SomeTrait for SomeStruct'\n-    // @has - '//code[@class=\"content\"]' 'impl<T: SomeTrait> SomeTrait for Wrapper<T>'\n-    pub fn new() -> SomeStruct {\n-        SomeStruct\n-    }\n-}\n-\n-// @has doc_spotlight/fn.bare_fn.html\n-// @has - '//code[@class=\"content\"]' 'impl SomeTrait for SomeStruct'\n-pub fn bare_fn() -> SomeStruct {\n-    SomeStruct\n-}"}, {"sha": "105dadd5fd373f420bd7fd441c4fac80b095028f", "filename": "src/test/ui/asm/issue-62046.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Ftest%2Fui%2Fasm%2Fissue-62046.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Ftest%2Fui%2Fasm%2Fissue-62046.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fissue-62046.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -0,0 +1,11 @@\n+// build-fail\n+// ignore-emscripten no asm! support\n+\n+#![feature(asm)]\n+\n+fn main() {\n+    unsafe {\n+        asm!(\"nop\" : \"+r\"(\"r15\"));\n+        //~^ malformed inline assembly\n+    }\n+}"}, {"sha": "a38a300548d4836dca4104fefdce751a41458d16", "filename": "src/test/ui/asm/issue-62046.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Ftest%2Fui%2Fasm%2Fissue-62046.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Ftest%2Fui%2Fasm%2Fissue-62046.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fissue-62046.stderr?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -0,0 +1,11 @@\n+error[E0668]: malformed inline assembly\n+  --> $DIR/issue-62046.rs:8:9\n+   |\n+LL |         asm!(\"nop\" : \"+r\"(\"r15\"));\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0668`."}, {"sha": "b67d494866b85d7f181e30a8b6dea1e124b2c2bb", "filename": "src/test/ui/borrowck/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Ftest%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Ftest%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.rs?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -0,0 +1,224 @@\n+// Tests using a combination of pattern features has the expected borrow checking behavior\n+#![feature(bindings_after_at)]\n+#![feature(or_patterns)]\n+#![feature(box_patterns)]\n+\n+#![feature(move_ref_pattern)]\n+\n+enum Test {\n+    Foo,\n+    Bar,\n+    _Baz,\n+}\n+\n+// bindings_after_at + slice_patterns\n+\n+fn bindings_after_at_slice_patterns_move_binding(x: [String; 4]) {\n+    match x {\n+        a @ [.., _] => (),\n+        _ => (),\n+    };\n+\n+    &x;\n+    //~^ ERROR borrow of moved value\n+}\n+\n+fn bindings_after_at_slice_patterns_borrows_binding_mut(mut x: [String; 4]) {\n+    let r = match x {\n+        ref mut foo @ [.., _] => Some(foo),\n+        _ => None,\n+    };\n+\n+    &x;\n+    //~^ ERROR cannot borrow\n+\n+    drop(r);\n+}\n+\n+fn bindings_after_at_slice_patterns_borrows_slice_mut1(mut x: [String; 4]) {\n+    let r = match x {\n+        ref foo @ [.., ref mut bar] => (),\n+        //~^ ERROR cannot borrow\n+        _ => (),\n+    };\n+\n+    drop(r);\n+}\n+\n+fn bindings_after_at_slice_patterns_borrows_slice_mut2(mut x: [String; 4]) {\n+    let r = match x {\n+        [ref foo @ .., ref bar] => Some(foo),\n+        _ => None,\n+    };\n+\n+    &mut x;\n+    //~^ ERROR cannot borrow\n+\n+    drop(r);\n+}\n+\n+fn bindings_after_at_slice_patterns_borrows_both(mut x: [String; 4]) {\n+    let r = match x {\n+        ref foo @ [.., ref bar] => Some(foo),\n+        _ => None,\n+    };\n+\n+    &mut x;\n+    //~^ ERROR cannot borrow\n+\n+    drop(r);\n+}\n+\n+// bindings_after_at + or_patterns\n+\n+fn bindings_after_at_or_patterns_move(x: Option<Test>) {\n+    match x {\n+        foo @ Some(Test::Foo | Test::Bar) => (),\n+        _ => (),\n+    }\n+\n+    &x;\n+    //~^ ERROR borrow of moved value\n+}\n+\n+fn bindings_after_at_or_patterns_borrows(mut x: Option<Test>) {\n+    let r = match x {\n+        ref foo @ Some(Test::Foo | Test::Bar) => Some(foo),\n+        _ => None,\n+    };\n+\n+    &mut x;\n+    //~^ ERROR cannot borrow\n+\n+    drop(r);\n+}\n+\n+fn bindings_after_at_or_patterns_borrows_mut(mut x: Option<Test>) {\n+    let r = match x {\n+        ref mut foo @ Some(Test::Foo | Test::Bar) => Some(foo),\n+        _ => None,\n+    };\n+\n+    &x;\n+    //~^ ERROR cannot borrow\n+\n+    drop(r);\n+}\n+\n+// bindings_after_at + box_patterns\n+\n+fn bindings_after_at_box_patterns_borrows_both(mut x: Option<Box<String>>) {\n+    let r = match x {\n+        ref foo @ Some(box ref s) => Some(foo),\n+        _ => None,\n+    };\n+\n+    &mut x;\n+    //~^ ERROR cannot borrow\n+\n+    drop(r);\n+}\n+\n+fn bindings_after_at_box_patterns_borrows_mut(mut x: Option<Box<String>>) {\n+    match x {\n+        ref foo @ Some(box ref mut s) => (),\n+        //~^ ERROR cannot borrow\n+        _ => (),\n+    };\n+}\n+\n+// bindings_after_at + slice_patterns + or_patterns\n+\n+fn bindings_after_at_slice_patterns_or_patterns_moves(x: [Option<Test>; 4]) {\n+    match x {\n+        a @ [.., Some(Test::Foo | Test::Bar)] => (),\n+        _ => (),\n+    };\n+\n+    &x;\n+    //~^ ERROR borrow of moved value\n+}\n+\n+fn bindings_after_at_slice_patterns_or_patterns_borrows_binding(mut x: [Option<Test>; 4]) {\n+    let r = match x {\n+        ref a @ [ref b @ .., Some(Test::Foo | Test::Bar)] => Some(a),\n+        _ => None,\n+    };\n+\n+    &mut x;\n+    //~^ ERROR cannot borrow\n+\n+    drop(r);\n+}\n+\n+fn bindings_after_at_slice_patterns_or_patterns_borrows_slice(mut x: [Option<Test>; 4]) {\n+    let r = match x {\n+        ref a @ [ref b @ .., Some(Test::Foo | Test::Bar)] => Some(b),\n+        _ => None,\n+    };\n+\n+    &mut x;\n+    //~^ ERROR cannot borrow\n+\n+    drop(r);\n+}\n+\n+// bindings_after_at + slice_patterns + box_patterns\n+\n+fn bindings_after_at_slice_patterns_box_patterns_borrows(mut x: [Option<Box<String>>; 4]) {\n+    let r = match x {\n+        [_, ref a @ Some(box ref b), ..] => Some(a),\n+        _ => None,\n+    };\n+\n+    &mut x;\n+    //~^ ERROR cannot borrow\n+\n+    drop(r);\n+}\n+\n+// bindings_after_at + slice_patterns + or_patterns + box_patterns\n+\n+fn bindings_after_at_slice_patterns_or_patterns_box_patterns_borrows(\n+    mut x: [Option<Box<Test>>; 4]\n+) {\n+    let r = match x {\n+        [_, ref a @ Some(box Test::Foo | box Test::Bar), ..] => Some(a),\n+        _ => None,\n+    };\n+\n+    &mut x;\n+    //~^ ERROR cannot borrow\n+\n+    drop(r);\n+}\n+\n+fn bindings_after_at_slice_patterns_or_patterns_box_patterns_borrows_mut(\n+    mut x: [Option<Box<Test>>; 4]\n+) {\n+    let r = match x {\n+        [_, ref mut a @ Some(box Test::Foo | box Test::Bar), ..] => Some(a),\n+        _ => None,\n+    };\n+\n+    &x;\n+    //~^ ERROR cannot borrow\n+\n+    drop(r);\n+}\n+\n+fn bindings_after_at_slice_patterns_or_patterns_box_patterns_borrows_binding(\n+    mut x: [Option<Box<Test>>; 4]\n+) {\n+    let r = match x {\n+        ref a @ [_, ref b @ Some(box Test::Foo | box Test::Bar), ..] => Some(a),\n+        _ => None,\n+    };\n+\n+    &mut x;\n+    //~^ ERROR cannot borrow\n+\n+    drop(r);\n+}\n+\n+fn main() {}"}, {"sha": "35ed2763c2b08635a6f56c802efcad2ad5130e9d", "filename": "src/test/ui/borrowck/bindings-after-at-or-patterns-slice-patterns-box-patterns.stderr", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Ftest%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd155df0a69338757ca39a2a606a6accb7b8d342/src%2Ftest%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.stderr?ref=dd155df0a69338757ca39a2a606a6accb7b8d342", "patch": "@@ -0,0 +1,208 @@\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:40:9\n+   |\n+LL |         ref foo @ [.., ref mut bar] => (),\n+   |         -------^^^^^^^^-----------^\n+   |         |              |\n+   |         |              mutable borrow, by `bar`, occurs here\n+   |         immutable borrow, by `foo`, occurs here\n+\n+error: cannot borrow value as mutable because it is also borrowed as immutable\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:124:9\n+   |\n+LL |         ref foo @ Some(box ref mut s) => (),\n+   |         -------^^^^^^^^^^^^---------^\n+   |         |                  |\n+   |         |                  mutable borrow, by `s`, occurs here\n+   |         immutable borrow, by `foo`, occurs here\n+\n+error[E0382]: borrow of moved value: `x`\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:22:5\n+   |\n+LL | fn bindings_after_at_slice_patterns_move_binding(x: [String; 4]) {\n+   |                                                  - move occurs because `x` has type `[std::string::String; 4]`, which does not implement the `Copy` trait\n+LL |     match x {\n+LL |         a @ [.., _] => (),\n+   |         ----------- value moved here\n+...\n+LL |     &x;\n+   |     ^^ value borrowed here after move\n+\n+error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:32:5\n+   |\n+LL |         ref mut foo @ [.., _] => Some(foo),\n+   |         --------------------- mutable borrow occurs here\n+...\n+LL |     &x;\n+   |     ^^ immutable borrow occurs here\n+...\n+LL |     drop(r);\n+   |          - mutable borrow later used here\n+\n+error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:54:5\n+   |\n+LL |         [ref foo @ .., ref bar] => Some(foo),\n+   |          ------------ immutable borrow occurs here\n+...\n+LL |     &mut x;\n+   |     ^^^^^^ mutable borrow occurs here\n+...\n+LL |     drop(r);\n+   |          - immutable borrow later used here\n+\n+error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:66:5\n+   |\n+LL |         ref foo @ [.., ref bar] => Some(foo),\n+   |         ----------------------- immutable borrow occurs here\n+...\n+LL |     &mut x;\n+   |     ^^^^^^ mutable borrow occurs here\n+...\n+LL |     drop(r);\n+   |          - immutable borrow later used here\n+\n+error[E0382]: borrow of moved value: `x`\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:80:5\n+   |\n+LL | fn bindings_after_at_or_patterns_move(x: Option<Test>) {\n+   |                                       - move occurs because `x` has type `std::option::Option<Test>`, which does not implement the `Copy` trait\n+LL |     match x {\n+LL |         foo @ Some(Test::Foo | Test::Bar) => (),\n+   |         ---------------------------------\n+   |         |\n+   |         value moved here\n+   |         value moved here\n+...\n+LL |     &x;\n+   |     ^^ value borrowed here after move\n+\n+error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:90:5\n+   |\n+LL |         ref foo @ Some(Test::Foo | Test::Bar) => Some(foo),\n+   |         ------------------------------------- immutable borrow occurs here\n+...\n+LL |     &mut x;\n+   |     ^^^^^^ mutable borrow occurs here\n+...\n+LL |     drop(r);\n+   |          - immutable borrow later used here\n+\n+error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:102:5\n+   |\n+LL |         ref mut foo @ Some(Test::Foo | Test::Bar) => Some(foo),\n+   |         ----------------------------------------- mutable borrow occurs here\n+...\n+LL |     &x;\n+   |     ^^ immutable borrow occurs here\n+...\n+LL |     drop(r);\n+   |          - mutable borrow later used here\n+\n+error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:116:5\n+   |\n+LL |         ref foo @ Some(box ref s) => Some(foo),\n+   |         ------------------------- immutable borrow occurs here\n+...\n+LL |     &mut x;\n+   |     ^^^^^^ mutable borrow occurs here\n+...\n+LL |     drop(r);\n+   |          - immutable borrow later used here\n+\n+error[E0382]: borrow of moved value: `x`\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:138:5\n+   |\n+LL | fn bindings_after_at_slice_patterns_or_patterns_moves(x: [Option<Test>; 4]) {\n+   |                                                       - move occurs because `x` has type `[std::option::Option<Test>; 4]`, which does not implement the `Copy` trait\n+LL |     match x {\n+LL |         a @ [.., Some(Test::Foo | Test::Bar)] => (),\n+   |         -------------------------------------\n+   |         |\n+   |         value moved here\n+   |         value moved here\n+...\n+LL |     &x;\n+   |     ^^ value borrowed here after move\n+\n+error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:148:5\n+   |\n+LL |         ref a @ [ref b @ .., Some(Test::Foo | Test::Bar)] => Some(a),\n+   |         ------------------------------------------------- immutable borrow occurs here\n+...\n+LL |     &mut x;\n+   |     ^^^^^^ mutable borrow occurs here\n+...\n+LL |     drop(r);\n+   |          - immutable borrow later used here\n+\n+error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:160:5\n+   |\n+LL |         ref a @ [ref b @ .., Some(Test::Foo | Test::Bar)] => Some(b),\n+   |                  ---------- immutable borrow occurs here\n+...\n+LL |     &mut x;\n+   |     ^^^^^^ mutable borrow occurs here\n+...\n+LL |     drop(r);\n+   |          - immutable borrow later used here\n+\n+error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:174:5\n+   |\n+LL |         [_, ref a @ Some(box ref b), ..] => Some(a),\n+   |             ----------------------- immutable borrow occurs here\n+...\n+LL |     &mut x;\n+   |     ^^^^^^ mutable borrow occurs here\n+...\n+LL |     drop(r);\n+   |          - immutable borrow later used here\n+\n+error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:190:5\n+   |\n+LL |         [_, ref a @ Some(box Test::Foo | box Test::Bar), ..] => Some(a),\n+   |             ------------------------------------------- immutable borrow occurs here\n+...\n+LL |     &mut x;\n+   |     ^^^^^^ mutable borrow occurs here\n+...\n+LL |     drop(r);\n+   |          - immutable borrow later used here\n+\n+error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:204:5\n+   |\n+LL |         [_, ref mut a @ Some(box Test::Foo | box Test::Bar), ..] => Some(a),\n+   |             ----------------------------------------------- mutable borrow occurs here\n+...\n+LL |     &x;\n+   |     ^^ immutable borrow occurs here\n+...\n+LL |     drop(r);\n+   |          - mutable borrow later used here\n+\n+error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n+  --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:218:5\n+   |\n+LL |         ref a @ [_, ref b @ Some(box Test::Foo | box Test::Bar), ..] => Some(a),\n+   |         ------------------------------------------------------------ immutable borrow occurs here\n+...\n+LL |     &mut x;\n+   |     ^^^^^^ mutable borrow occurs here\n+...\n+LL |     drop(r);\n+   |          - immutable borrow later used here\n+\n+error: aborting due to 17 previous errors\n+\n+Some errors have detailed explanations: E0382, E0502.\n+For more information about an error, try `rustc --explain E0382`."}, {"sha": "452b45b34456bbb37771e3bbe31eefc1602cfa39", "filename": "src/test/ui/feature-gates/feature-gate-doc_spotlight.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-doc_spotlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-doc_spotlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-doc_spotlight.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -1,4 +0,0 @@\n-#[doc(spotlight)] //~ ERROR: `#[doc(spotlight)]` is experimental\n-trait SomeTrait {}\n-\n-fn main() {}"}, {"sha": "010d74054a4120fa3b687afc2e8e9f21a0405164", "filename": "src/test/ui/feature-gates/feature-gate-doc_spotlight.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-doc_spotlight.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-doc_spotlight.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-doc_spotlight.stderr?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -1,12 +0,0 @@\n-error[E0658]: `#[doc(spotlight)]` is experimental\n-  --> $DIR/feature-gate-doc_spotlight.rs:1:1\n-   |\n-LL | #[doc(spotlight)]\n-   | ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #45040 <https://github.com/rust-lang/rust/issues/45040> for more information\n-   = help: add `#![feature(doc_spotlight)]` to the crate attributes to enable\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0658`."}]}