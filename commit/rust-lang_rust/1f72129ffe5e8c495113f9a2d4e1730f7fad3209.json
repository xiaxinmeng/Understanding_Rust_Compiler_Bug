{"sha": "1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "node_id": "C_kwDOAAsO6NoAKDFmNzIxMjlmZmU1ZThjNDk1MTEzZjlhMmQ0ZTE3MzBmN2ZhZDMyMDk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-18T10:26:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-18T10:26:12Z"}, "message": "Auto merge of #107026 - Dylan-DPC:rollup-4fonvdc, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #103702 (Lift `T: Sized` bounds from some `strict_provenance` pointer methods)\n - #106441 (relax reference requirement on SocketAddrExt::from_abstract_name)\n - #106718 (finish trait solver skeleton work)\n - #106950 (Don't do pointer arithmetic on pointers to deallocated memory)\n - #107014 (rustdoc: remove deprecated / unused code from main.js)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "2b23072899d2c9caedcf05edfab580b746e926da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b23072899d2c9caedcf05edfab580b746e926da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "html_url": "https://github.com/rust-lang/rust/commit/1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74c1ad5d35c7fbdb834c42144d966279fdff3679", "url": "https://api.github.com/repos/rust-lang/rust/commits/74c1ad5d35c7fbdb834c42144d966279fdff3679", "html_url": "https://github.com/rust-lang/rust/commit/74c1ad5d35c7fbdb834c42144d966279fdff3679"}, {"sha": "43b1e732db5466148afda10d6e78c871ab2d91b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/43b1e732db5466148afda10d6e78c871ab2d91b3", "html_url": "https://github.com/rust-lang/rust/commit/43b1e732db5466148afda10d6e78c871ab2d91b3"}], "stats": {"total": 1658, "additions": 952, "deletions": 706}, "files": [{"sha": "b3afaaa35c0a2511c346e87720e0239bb66d5521", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -4783,6 +4783,7 @@ dependencies = [\n  \"rustc_middle\",\n  \"rustc_parse_format\",\n  \"rustc_query_system\",\n+ \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\","}, {"sha": "43583b5723e698f763e7c03f5a35b19b41e25108", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -339,6 +339,12 @@ TrivialTypeTraversalAndLiftImpls! {\n }\n \n impl<'tcx> CanonicalVarValues<'tcx> {\n+    /// Creates dummy var values which should not be used in a\n+    /// canonical response.\n+    pub fn dummy() -> CanonicalVarValues<'tcx> {\n+        CanonicalVarValues { var_values: Default::default() }\n+    }\n+\n     #[inline]\n     pub fn len(&self) -> usize {\n         self.var_values.len()"}, {"sha": "00225a60d8308b206526b89c53da7c848eb118a6", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -1113,17 +1113,6 @@ impl<'tcx, T> Binder<'tcx, T> {\n         if self.0.has_escaping_bound_vars() { None } else { Some(self.skip_binder()) }\n     }\n \n-    pub fn no_bound_vars_ignoring_escaping(self, tcx: TyCtxt<'tcx>) -> Option<T>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        if !self.0.has_escaping_bound_vars() {\n-            Some(self.skip_binder())\n-        } else {\n-            self.0.try_fold_with(&mut SkipBindersAt { index: ty::INNERMOST, tcx }).ok()\n-        }\n-    }\n-\n     /// Splits the contents into two things that share the same binder\n     /// level as the original, returning two distinct binders.\n     ///"}, {"sha": "90d879976c260cb33d84020b09a0ff33c9423d71", "filename": "compiler/rustc_trait_selection/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2FCargo.toml?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -19,6 +19,7 @@ rustc_infer = { path = \"../rustc_infer\" }\n rustc_lint_defs = { path = \"../rustc_lint_defs\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n+rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }"}, {"sha": "6fa0941036390a675beafe5305269c0e9633c740", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -21,6 +21,7 @@\n #![feature(never_type)]\n #![feature(result_option_inspect)]\n #![feature(type_alias_impl_trait)]\n+#![feature(min_specialization)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "cd6e4d2bccd5cfdae00dae9e2fdb09514c1431a2", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 216, "deletions": 82, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -1,95 +1,138 @@\n //! Code shared by trait and projection goals for candidate assembly.\n \n use super::infcx_ext::InferCtxtExt;\n-use super::{\n-    instantiate_canonical_query_response, CanonicalGoal, CanonicalResponse, Certainty, EvalCtxt,\n-    Goal,\n-};\n+use super::{CanonicalResponse, Certainty, EvalCtxt, Goal};\n use rustc_hir::def_id::DefId;\n-use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::infer::{\n-    canonical::{CanonicalVarValues, OriginalQueryValues},\n-    InferCtxt,\n-};\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_span::DUMMY_SP;\n use std::fmt::Debug;\n \n /// A candidate is a possible way to prove a goal.\n ///\n /// It consists of both the `source`, which describes how that goal would be proven,\n /// and the `result` when using the given `source`.\n-///\n-/// For the list of possible candidates, please look at the documentation of\n-/// [super::trait_goals::CandidateSource] and [super::project_goals::CandidateSource].\n #[derive(Debug, Clone)]\n-pub(super) struct Candidate<'tcx, G: GoalKind<'tcx>> {\n-    pub(super) source: G::CandidateSource,\n+pub(super) struct Candidate<'tcx> {\n+    pub(super) source: CandidateSource,\n     pub(super) result: CanonicalResponse<'tcx>,\n }\n \n-pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy {\n-    type CandidateSource: Debug + Copy;\n+/// Possible ways the given goal can be proven.\n+#[derive(Debug, Clone, Copy)]\n+pub(super) enum CandidateSource {\n+    /// A user written impl.\n+    ///\n+    /// ## Examples\n+    ///\n+    /// ```rust\n+    /// fn main() {\n+    ///     let x: Vec<u32> = Vec::new();\n+    ///     // This uses the impl from the standard library to prove `Vec<T>: Clone`.\n+    ///     let y = x.clone();\n+    /// }\n+    /// ```\n+    Impl(DefId),\n+    /// A builtin impl generated by the compiler. When adding a new special\n+    /// trait, try to use actual impls whenever possible. Builtin impls should\n+    /// only be used in cases where the impl cannot be manually be written.\n+    ///\n+    /// Notable examples are auto traits, `Sized`, and `DiscriminantKind`.\n+    /// For a list of all traits with builtin impls, check out the\n+    /// [`EvalCtxt::assemble_builtin_impl_candidates`] method. Not\n+    BuiltinImpl,\n+    /// An assumption from the environment.\n+    ///\n+    /// More precicely we've used the `n-th` assumption in the `param_env`.\n+    ///\n+    /// ## Examples\n+    ///\n+    /// ```rust\n+    /// fn is_clone<T: Clone>(x: T) -> (T, T) {\n+    ///     // This uses the assumption `T: Clone` from the `where`-bounds\n+    ///     // to prove `T: Clone`.\n+    ///     (x.clone(), x)\n+    /// }\n+    /// ```\n+    ParamEnv(usize),\n+    /// If the self type is an alias type, e.g. an opaque type or a projection,\n+    /// we know the bounds on that alias to hold even without knowing its concrete\n+    /// underlying type.\n+    ///\n+    /// More precisely this candidate is using the `n-th` bound in the `item_bounds` of\n+    /// the self type.\n+    ///\n+    /// ## Examples\n+    ///\n+    /// ```rust\n+    /// trait Trait {\n+    ///     type Assoc: Clone;\n+    /// }\n+    ///\n+    /// fn foo<T: Trait>(x: <T as Trait>::Assoc) {\n+    ///     // We prove `<T as Trait>::Assoc` by looking at the bounds on `Assoc` in\n+    ///     // in the trait definition.\n+    ///     let _y = x.clone();\n+    /// }\n+    /// ```\n+    AliasBound(usize),\n+}\n \n+pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy {\n     fn self_ty(self) -> Ty<'tcx>;\n \n     fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self;\n \n     fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId;\n \n     fn consider_impl_candidate(\n-        acx: &mut AssemblyCtxt<'_, 'tcx, Self>,\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         impl_def_id: DefId,\n-    );\n-}\n+    ) -> Result<Certainty, NoSolution>;\n \n-/// An abstraction which correctly deals with the canonical results for candidates.\n-///\n-/// It also deduplicates the behavior between trait and projection predicates.\n-pub(super) struct AssemblyCtxt<'a, 'tcx, G: GoalKind<'tcx>> {\n-    pub(super) cx: &'a mut EvalCtxt<'tcx>,\n-    pub(super) infcx: &'a InferCtxt<'tcx>,\n-    var_values: CanonicalVarValues<'tcx>,\n-    candidates: Vec<Candidate<'tcx, G>>,\n+    fn consider_builtin_sized_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> Result<Certainty, NoSolution>;\n+\n+    fn consider_assumption(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> Result<Certainty, NoSolution>;\n }\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    pub(super) fn assemble_and_evaluate_candidates<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+    ) -> Vec<Candidate<'tcx>> {\n+        let mut candidates = Vec::new();\n \n-impl<'a, 'tcx, G: GoalKind<'tcx>> AssemblyCtxt<'a, 'tcx, G> {\n-    pub(super) fn assemble_and_evaluate_candidates(\n-        cx: &'a mut EvalCtxt<'tcx>,\n-        goal: CanonicalGoal<'tcx, G>,\n-    ) -> Vec<Candidate<'tcx, G>> {\n-        let (ref infcx, goal, var_values) =\n-            cx.tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &goal);\n-        let mut acx = AssemblyCtxt { cx, infcx, var_values, candidates: Vec::new() };\n+        self.assemble_candidates_after_normalizing_self_ty(goal, &mut candidates);\n \n-        acx.assemble_candidates_after_normalizing_self_ty(goal);\n+        self.assemble_impl_candidates(goal, &mut candidates);\n \n-        acx.assemble_impl_candidates(goal);\n+        self.assemble_builtin_impl_candidates(goal, &mut candidates);\n \n-        acx.candidates\n-    }\n+        self.assemble_param_env_candidates(goal, &mut candidates);\n \n-    pub(super) fn try_insert_candidate(\n-        &mut self,\n-        source: G::CandidateSource,\n-        certainty: Certainty,\n-    ) {\n-        match self.infcx.make_canonical_response(self.var_values.clone(), certainty) {\n-            Ok(result) => self.candidates.push(Candidate { source, result }),\n-            Err(NoSolution) => debug!(?source, ?certainty, \"failed leakcheck\"),\n-        }\n+        self.assemble_alias_bound_candidates(goal, &mut candidates);\n+\n+        candidates\n     }\n \n     /// If the self type of a goal is a projection, computing the relevant candidates is difficult.\n     ///\n     /// To deal with this, we first try to normalize the self type and add the candidates for the normalized\n     /// self type to the list of candidates in case that succeeds. Note that we can't just eagerly return in\n     /// this case as projections as self types add `\n-    fn assemble_candidates_after_normalizing_self_ty(&mut self, goal: Goal<'tcx, G>) {\n-        let tcx = self.cx.tcx;\n+    fn assemble_candidates_after_normalizing_self_ty<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        let tcx = self.tcx();\n         // FIXME: We also have to normalize opaque types, not sure where to best fit that in.\n         let &ty::Alias(ty::Projection, projection_ty) = goal.predicate.self_ty().kind() else {\n             return\n@@ -103,45 +146,136 @@ impl<'a, 'tcx, G: GoalKind<'tcx>> AssemblyCtxt<'a, 'tcx, G> {\n                     term: normalized_ty.into(),\n                 }),\n             );\n-            let normalization_certainty =\n-                match self.cx.evaluate_goal(&self.infcx, normalizes_to_goal) {\n-                    Ok((_, certainty)) => certainty,\n-                    Err(NoSolution) => return,\n-                };\n+            let normalization_certainty = match self.evaluate_goal(normalizes_to_goal) {\n+                Ok((_, certainty)) => certainty,\n+                Err(NoSolution) => return,\n+            };\n \n             // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n-            // This doesn't work as long as we use `CandidateSource` in both winnowing and to resolve associated items.\n+            // This doesn't work as long as we use `CandidateSource` in winnowing.\n             let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n-            let mut orig_values = OriginalQueryValues::default();\n-            let goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n-            let normalized_candidates =\n-                AssemblyCtxt::assemble_and_evaluate_candidates(self.cx, goal);\n-\n-            // Map each candidate from being canonical wrt the current inference context to being\n-            // canonical wrt the caller.\n-            for Candidate { source, result } in normalized_candidates {\n-                self.infcx.probe(|_| {\n-                    let candidate_certainty =\n-                        instantiate_canonical_query_response(&self.infcx, &orig_values, result);\n-\n-                    // FIXME: This is a bit scary if the `normalizes_to_goal` overflows.\n-                    //\n-                    // If we have an ambiguous candidate it hides that normalization\n-                    // caused an overflow which may cause issues.\n-                    self.try_insert_candidate(\n-                        source,\n-                        normalization_certainty.unify_and(candidate_certainty),\n-                    )\n-                })\n+            // FIXME: This is broken if we care about the `usize` of `AliasBound` because the self type\n+            // could be normalized to yet another projection with different item bounds.\n+            let normalized_candidates = self.assemble_and_evaluate_candidates(goal);\n+            for mut normalized_candidate in normalized_candidates {\n+                normalized_candidate.result =\n+                    normalized_candidate.result.unchecked_map(|mut response| {\n+                        // FIXME: This currently hides overflow in the normalization step of the self type\n+                        // which is probably wrong. Maybe `unify_and` should actually keep overflow as\n+                        // we treat it as non-fatal anyways.\n+                        response.certainty = response.certainty.unify_and(normalization_certainty);\n+                        response\n+                    });\n+                candidates.push(normalized_candidate);\n             }\n         })\n     }\n \n-    fn assemble_impl_candidates(&mut self, goal: Goal<'tcx, G>) {\n-        self.cx.tcx.for_each_relevant_impl(\n-            goal.predicate.trait_def_id(self.cx.tcx),\n+    fn assemble_impl_candidates<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        let tcx = self.tcx();\n+        tcx.for_each_relevant_impl(\n+            goal.predicate.trait_def_id(tcx),\n             goal.predicate.self_ty(),\n-            |impl_def_id| G::consider_impl_candidate(self, goal, impl_def_id),\n+            |impl_def_id| match G::consider_impl_candidate(self, goal, impl_def_id)\n+                .and_then(|certainty| self.make_canonical_response(certainty))\n+            {\n+                Ok(result) => candidates\n+                    .push(Candidate { source: CandidateSource::Impl(impl_def_id), result }),\n+                Err(NoSolution) => (),\n+            },\n         );\n     }\n+\n+    fn assemble_builtin_impl_candidates<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        let lang_items = self.tcx().lang_items();\n+        let trait_def_id = goal.predicate.trait_def_id(self.tcx());\n+        let result = if lang_items.sized_trait() == Some(trait_def_id) {\n+            G::consider_builtin_sized_candidate(self, goal)\n+        } else {\n+            Err(NoSolution)\n+        };\n+\n+        match result.and_then(|certainty| self.make_canonical_response(certainty)) {\n+            Ok(result) => {\n+                candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n+            }\n+            Err(NoSolution) => (),\n+        }\n+    }\n+\n+    fn assemble_param_env_candidates<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        for (i, assumption) in goal.param_env.caller_bounds().iter().enumerate() {\n+            match G::consider_assumption(self, goal, assumption)\n+                .and_then(|certainty| self.make_canonical_response(certainty))\n+            {\n+                Ok(result) => {\n+                    candidates.push(Candidate { source: CandidateSource::ParamEnv(i), result })\n+                }\n+                Err(NoSolution) => (),\n+            }\n+        }\n+    }\n+\n+    fn assemble_alias_bound_candidates<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        let alias_ty = match goal.predicate.self_ty().kind() {\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Adt(_, _)\n+            | ty::Foreign(_)\n+            | ty::Str\n+            | ty::Array(_, _)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::Ref(_, _, _)\n+            | ty::FnDef(_, _)\n+            | ty::FnPtr(_)\n+            | ty::Dynamic(..)\n+            | ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(_)\n+            | ty::Never\n+            | ty::Tuple(_)\n+            | ty::Param(_)\n+            | ty::Placeholder(..)\n+            | ty::Infer(_)\n+            | ty::Error(_) => return,\n+            ty::Bound(..) => bug!(\"unexpected bound type: {goal:?}\"),\n+            ty::Alias(_, alias_ty) => alias_ty,\n+        };\n+\n+        for (i, (assumption, _)) in self\n+            .tcx()\n+            .bound_explicit_item_bounds(alias_ty.def_id)\n+            .subst_iter_copied(self.tcx(), alias_ty.substs)\n+            .enumerate()\n+        {\n+            match G::consider_assumption(self, goal, assumption)\n+                .and_then(|certainty| self.make_canonical_response(certainty))\n+            {\n+                Ok(result) => {\n+                    candidates.push(Candidate { source: CandidateSource::AliasBound(i), result })\n+                }\n+                Err(NoSolution) => (),\n+            }\n+        }\n+    }\n }"}, {"sha": "f1ee73a5b853f463ad9c77b2104a231bcabd3be2", "filename": "compiler/rustc_trait_selection/src/solve/cache.rs", "status": "removed", "additions": 0, "deletions": 291, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/74c1ad5d35c7fbdb834c42144d966279fdff3679/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74c1ad5d35c7fbdb834c42144d966279fdff3679/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs?ref=74c1ad5d35c7fbdb834c42144d966279fdff3679", "patch": "@@ -1,291 +0,0 @@\n-//! This module both handles the global cache which stores \"finished\" goals,\n-//! and the provisional cache which contains partially computed goals.\n-//!\n-//! The provisional cache is necessary when dealing with coinductive cycles.\n-//!\n-//! For more information about the provisional cache and coinduction in general,\n-//! check out the relevant section of the rustc-dev-guide.\n-//!\n-//! FIXME(@lcnr): Write that section, feel free to ping me if you need help here\n-//! before then or if I still haven't done that before January 2023.\n-use super::overflow::OverflowData;\n-use super::{CanonicalGoal, Certainty, MaybeCause, Response};\n-use super::{EvalCtxt, QueryResult};\n-\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_infer::infer::canonical::{Canonical, CanonicalVarKind, CanonicalVarValues};\n-use rustc_middle::ty::{self, TyCtxt};\n-use std::{cmp::Ordering, collections::hash_map::Entry};\n-\n-#[derive(Debug, Clone)]\n-struct ProvisionalEntry<'tcx> {\n-    // In case we have a coinductive cycle, this is the\n-    // the currently least restrictive result of this goal.\n-    response: QueryResult<'tcx>,\n-    // The lowest element on the stack on which this result\n-    // relies on. Starts out as just being the depth at which\n-    // we've proven this obligation, but gets lowered to the\n-    // depth of another goal if we rely on it in a cycle.\n-    depth: usize,\n-}\n-\n-struct StackElem<'tcx> {\n-    goal: CanonicalGoal<'tcx>,\n-    has_been_used: bool,\n-}\n-\n-/// The cache used for goals which are currently in progress or which depend\n-/// on in progress results.\n-///\n-/// Once we're done with a goal we can store it in the global trait solver\n-/// cache of the `TyCtxt`. For goals which we're currently proving, or which\n-/// have only been proven via a coinductive cycle using a goal still on our stack\n-/// we have to use this separate data structure.\n-///\n-/// The current data structure is not perfect, so there may still be room for\n-/// improvement here. We have the following requirements:\n-///\n-/// ## Is there is a provisional entry for the given goal:\n-///\n-/// ```ignore (for syntax highlighting)\n-/// self.entries.get(goal)\n-/// ```\n-///\n-/// ## Get all goals on the stack involved in a cycle:\n-///\n-/// ```ignore (for syntax highlighting)\n-/// let entry = self.entries.get(goal).unwrap();\n-/// let involved_goals = self.stack.iter().skip(entry.depth);\n-/// ```\n-///\n-/// ## Capping the depth of all entries\n-///\n-/// Needed whenever we encounter a cycle. The current implementation always\n-/// iterates over all entries instead of only the ones with a larger depth.\n-/// Changing this may result in notable performance improvements.\n-///\n-/// ```ignore (for syntax highlighting)\n-/// let cycle_depth = self.entries.get(goal).unwrap().depth;\n-/// for e in &mut self.entries {\n-///     e.depth = e.depth.min(cycle_depth);\n-/// }\n-/// ```\n-///\n-/// ## Checking whether we have to rerun the current goal\n-///\n-/// A goal has to be rerun if its provisional result was used in a cycle\n-/// and that result is different from its final result. We update\n-/// [StackElem::has_been_used] for the deepest stack element involved in a cycle.\n-///\n-/// ## Moving all finished goals into the global cache\n-///\n-/// If `stack_elem.has_been_used` is true, iterate over all entries, moving the ones\n-/// with equal depth. If not, simply move this single entry.\n-pub(super) struct ProvisionalCache<'tcx> {\n-    stack: Vec<StackElem<'tcx>>,\n-    entries: FxHashMap<CanonicalGoal<'tcx>, ProvisionalEntry<'tcx>>,\n-}\n-\n-impl<'tcx> ProvisionalCache<'tcx> {\n-    pub(super) fn empty() -> ProvisionalCache<'tcx> {\n-        ProvisionalCache { stack: Vec::new(), entries: Default::default() }\n-    }\n-\n-    pub(super) fn current_depth(&self) -> usize {\n-        self.stack.len()\n-    }\n-}\n-\n-impl<'tcx> EvalCtxt<'tcx> {\n-    /// Tries putting the new goal on the stack, returning an error if it is already cached.\n-    ///\n-    /// This correctly updates the provisional cache if there is a cycle.\n-    pub(super) fn try_push_stack(\n-        &mut self,\n-        goal: CanonicalGoal<'tcx>,\n-    ) -> Result<(), QueryResult<'tcx>> {\n-        // FIXME: start by checking the global cache\n-\n-        // Look at the provisional cache to check for cycles.\n-        let cache = &mut self.provisional_cache;\n-        match cache.entries.entry(goal) {\n-            // No entry, simply push this goal on the stack after dealing with overflow.\n-            Entry::Vacant(v) => {\n-                if self.overflow_data.has_overflow(cache.stack.len()) {\n-                    return Err(self.deal_with_overflow(goal));\n-                }\n-\n-                v.insert(ProvisionalEntry {\n-                    response: response_no_constraints(self.tcx, goal, Certainty::Yes),\n-                    depth: cache.stack.len(),\n-                });\n-                cache.stack.push(StackElem { goal, has_been_used: false });\n-                Ok(())\n-            }\n-            // We have a nested goal which relies on a goal `root` deeper in the stack.\n-            //\n-            // We first store that we may have to rerun `evaluate_goal` for `root` in case the\n-            // provisional response is not equal to the final response. We also update the depth\n-            // of all goals which recursively depend on our current goal to depend on `root`\n-            // instead.\n-            //\n-            // Finally we can return either the provisional response for that goal if we have a\n-            // coinductive cycle or an ambiguous result if the cycle is inductive.\n-            Entry::Occupied(entry) => {\n-                // FIXME: `ProvisionalEntry` should be `Copy`.\n-                let entry = entry.get().clone();\n-                cache.stack[entry.depth].has_been_used = true;\n-                for provisional_entry in cache.entries.values_mut() {\n-                    provisional_entry.depth = provisional_entry.depth.min(entry.depth);\n-                }\n-\n-                // NOTE: The goals on the stack aren't the only goals involved in this cycle.\n-                // We can also depend on goals which aren't part of the stack but coinductively\n-                // depend on the stack themselves. We already checked whether all the goals\n-                // between these goals and their root on the stack. This means that as long as\n-                // each goal in a cycle is checked for coinductivity by itself simply checking\n-                // the stack is enough.\n-                if cache.stack[entry.depth..]\n-                    .iter()\n-                    .all(|g| g.goal.value.predicate.is_coinductive(self.tcx))\n-                {\n-                    Err(entry.response)\n-                } else {\n-                    Err(response_no_constraints(\n-                        self.tcx,\n-                        goal,\n-                        Certainty::Maybe(MaybeCause::Ambiguity),\n-                    ))\n-                }\n-            }\n-        }\n-    }\n-\n-    /// We cannot simply store the result of [EvalCtxt::compute_goal] as we have to deal with\n-    /// coinductive cycles.\n-    ///\n-    /// When we encounter a coinductive cycle, we have to prove the final result of that cycle\n-    /// while we are still computing that result. Because of this we continously recompute the\n-    /// cycle until the result of the previous iteration is equal to the final result, at which\n-    /// point we are done.\n-    ///\n-    /// This function returns `true` if we were able to finalize the goal and `false` if it has\n-    /// updated the provisional cache and we have to recompute the current goal.\n-    ///\n-    /// FIXME: Refer to the rustc-dev-guide entry once it exists.\n-    pub(super) fn try_finalize_goal(\n-        &mut self,\n-        actual_goal: CanonicalGoal<'tcx>,\n-        response: QueryResult<'tcx>,\n-    ) -> bool {\n-        let cache = &mut self.provisional_cache;\n-        let StackElem { goal, has_been_used } = cache.stack.pop().unwrap();\n-        assert_eq!(goal, actual_goal);\n-\n-        let provisional_entry = cache.entries.get_mut(&goal).unwrap();\n-        // Check whether the current stack entry is the root of a cycle.\n-        //\n-        // If so, we either move all participants of that cycle to the global cache\n-        // or, in case the provisional response used in the cycle is not equal to the\n-        // final response, have to recompute the goal after updating the provisional\n-        // response to the final response of this iteration.\n-        if has_been_used {\n-            if provisional_entry.response == response {\n-                // We simply drop all entries according to an immutable condition, so\n-                // query instability is not a concern here.\n-                #[allow(rustc::potential_query_instability)]\n-                cache.entries.retain(|goal, entry| match entry.depth.cmp(&cache.stack.len()) {\n-                    Ordering::Less => true,\n-                    Ordering::Equal => {\n-                        Self::try_move_finished_goal_to_global_cache(\n-                            self.tcx,\n-                            &mut self.overflow_data,\n-                            &cache.stack,\n-                            // FIXME: these should be `Copy` :(\n-                            goal.clone(),\n-                            entry.response.clone(),\n-                        );\n-                        false\n-                    }\n-                    Ordering::Greater => bug!(\"entry with greater depth than the current leaf\"),\n-                });\n-\n-                true\n-            } else {\n-                provisional_entry.response = response;\n-                cache.stack.push(StackElem { goal, has_been_used: false });\n-                false\n-            }\n-        } else {\n-            Self::try_move_finished_goal_to_global_cache(\n-                self.tcx,\n-                &mut self.overflow_data,\n-                &cache.stack,\n-                goal,\n-                response,\n-            );\n-            cache.entries.remove(&goal);\n-            true\n-        }\n-    }\n-\n-    fn try_move_finished_goal_to_global_cache(\n-        tcx: TyCtxt<'tcx>,\n-        overflow_data: &mut OverflowData,\n-        stack: &[StackElem<'tcx>],\n-        goal: CanonicalGoal<'tcx>,\n-        response: QueryResult<'tcx>,\n-    ) {\n-        // We move goals to the global cache if we either did not hit an overflow or if it's\n-        // the root goal as that will now always hit the same overflow limit.\n-        //\n-        // NOTE: We cannot move any non-root goals to the global cache even if their final result\n-        // isn't impacted by the overflow as that goal still has unstable query dependencies\n-        // because it didn't go its full depth.\n-        //\n-        // FIXME(@lcnr): We could still cache subtrees which are not impacted by overflow though.\n-        // Tracking that info correctly isn't trivial, so I haven't implemented it for now.\n-        let should_cache_globally = !overflow_data.did_overflow() || stack.is_empty();\n-        if should_cache_globally {\n-            // FIXME: move the provisional entry to the global cache.\n-            let _ = (tcx, goal, response);\n-        }\n-    }\n-}\n-\n-pub(super) fn response_no_constraints<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    goal: Canonical<'tcx, impl Sized>,\n-    certainty: Certainty,\n-) -> QueryResult<'tcx> {\n-    let var_values = goal\n-        .variables\n-        .iter()\n-        .enumerate()\n-        .map(|(i, info)| match info.kind {\n-            CanonicalVarKind::Ty(_) | CanonicalVarKind::PlaceholderTy(_) => {\n-                tcx.mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_usize(i).into())).into()\n-            }\n-            CanonicalVarKind::Region(_) | CanonicalVarKind::PlaceholderRegion(_) => {\n-                let br = ty::BoundRegion {\n-                    var: ty::BoundVar::from_usize(i),\n-                    kind: ty::BrAnon(i as u32, None),\n-                };\n-                tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n-            }\n-            CanonicalVarKind::Const(_, ty) | CanonicalVarKind::PlaceholderConst(_, ty) => tcx\n-                .mk_const(ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_usize(i)), ty)\n-                .into(),\n-        })\n-        .collect();\n-\n-    Ok(Canonical {\n-        max_universe: goal.max_universe,\n-        variables: goal.variables,\n-        value: Response {\n-            var_values: CanonicalVarValues { var_values },\n-            external_constraints: Default::default(),\n-            certainty,\n-        },\n-    })\n-}"}, {"sha": "b086c0684d28d48315afaf67c14da1c53628e8eb", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -10,7 +10,7 @@ use rustc_infer::{\n };\n use rustc_middle::ty;\n \n-use super::{Certainty, EvalCtxt};\n+use super::{search_graph, Certainty, EvalCtxt};\n \n /// A trait engine using the new trait solver.\n ///\n@@ -67,9 +67,10 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n \n             let mut has_changed = false;\n             for obligation in mem::take(&mut self.obligations) {\n-                let mut cx = EvalCtxt::new(infcx.tcx);\n-                let (changed, certainty) = match cx.evaluate_goal(infcx, obligation.clone().into())\n-                {\n+                let goal = obligation.clone().into();\n+                let search_graph = &mut search_graph::SearchGraph::new(infcx.tcx);\n+                let mut ecx = EvalCtxt::new_outside_solver(infcx, search_graph);\n+                let (changed, certainty) = match ecx.evaluate_goal(goal) {\n                     Ok(result) => result,\n                     Err(NoSolution) => {\n                         errors.push(FulfillmentError {"}, {"sha": "9b7feb50537871d09d66ef7212a1aed5899095b0", "filename": "compiler/rustc_trait_selection/src/solve/infcx_ext.rs", "status": "modified", "additions": 39, "deletions": 32, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -1,23 +1,30 @@\n-use rustc_infer::infer::canonical::CanonicalVarValues;\n+use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::InferCtxt;\n+use rustc_infer::infer::{InferCtxt, InferOk};\n use rustc_infer::traits::query::NoSolution;\n-use rustc_middle::ty::Ty;\n+use rustc_infer::traits::ObligationCause;\n+use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::DUMMY_SP;\n \n-use crate::solve::ExternalConstraints;\n-\n-use super::{Certainty, QueryResult, Response};\n+use super::Goal;\n \n /// Methods used inside of the canonical queries of the solver.\n+///\n+/// Most notably these do not care about diagnostics information.\n+/// If you find this while looking for methods to use outside of the\n+/// solver, you may look at the implementation of these method for\n+/// help.\n pub(super) trait InferCtxtExt<'tcx> {\n     fn next_ty_infer(&self) -> Ty<'tcx>;\n+    fn next_const_infer(&self, ty: Ty<'tcx>) -> ty::Const<'tcx>;\n \n-    fn make_canonical_response(\n+    fn eq<T: ToTrace<'tcx>>(\n         &self,\n-        var_values: CanonicalVarValues<'tcx>,\n-        certainty: Certainty,\n-    ) -> QueryResult<'tcx>;\n+        param_env: ty::ParamEnv<'tcx>,\n+        lhs: T,\n+        rhs: T,\n+    ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution>;\n }\n \n impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n@@ -27,29 +34,29 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             span: DUMMY_SP,\n         })\n     }\n+    fn next_const_infer(&self, ty: Ty<'tcx>) -> ty::Const<'tcx> {\n+        self.next_const_var(\n+            ty,\n+            ConstVariableOrigin { kind: ConstVariableOriginKind::MiscVariable, span: DUMMY_SP },\n+        )\n+    }\n \n-    fn make_canonical_response(\n+    #[instrument(level = \"debug\", skip(self, param_env), ret)]\n+    fn eq<T: ToTrace<'tcx>>(\n         &self,\n-        var_values: CanonicalVarValues<'tcx>,\n-        certainty: Certainty,\n-    ) -> QueryResult<'tcx> {\n-        let external_constraints = take_external_constraints(self)?;\n-\n-        Ok(self.canonicalize_response(Response { var_values, external_constraints, certainty }))\n+        param_env: ty::ParamEnv<'tcx>,\n+        lhs: T,\n+        rhs: T,\n+    ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution> {\n+        self.at(&ObligationCause::dummy(), param_env)\n+            .define_opaque_types(false)\n+            .eq(lhs, rhs)\n+            .map(|InferOk { value: (), obligations }| {\n+                obligations.into_iter().map(|o| o.into()).collect()\n+            })\n+            .map_err(|e| {\n+                debug!(?e, \"failed to equate\");\n+                NoSolution\n+            })\n     }\n }\n-\n-#[instrument(level = \"debug\", skip(infcx), ret)]\n-fn take_external_constraints<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-) -> Result<ExternalConstraints<'tcx>, NoSolution> {\n-    let region_obligations = infcx.take_registered_region_obligations();\n-    let opaque_types = infcx.take_opaque_types_for_query_response();\n-    Ok(ExternalConstraints {\n-        // FIXME: Now that's definitely wrong :)\n-        //\n-        // Should also do the leak check here I think\n-        regions: drop(region_obligations),\n-        opaque_types,\n-    })\n-}"}, {"sha": "579cd6a2d59cde4d0469ee928b6ea68fb918e782", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 137, "deletions": 80, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -19,27 +19,23 @@\n \n use std::mem;\n \n+use rustc_infer::infer::canonical::{Canonical, CanonicalVarKind, CanonicalVarValues};\n use rustc_infer::infer::canonical::{OriginalQueryValues, QueryRegionConstraints, QueryResponse};\n use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::Obligation;\n use rustc_middle::infer::canonical::Certainty as OldCertainty;\n-use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{RegionOutlivesPredicate, ToPredicate, TypeOutlivesPredicate};\n use rustc_span::DUMMY_SP;\n \n use crate::traits::ObligationCause;\n \n-use self::cache::response_no_constraints;\n-use self::infcx_ext::InferCtxtExt;\n-\n mod assembly;\n-mod cache;\n mod fulfill;\n mod infcx_ext;\n-mod overflow;\n mod project_goals;\n+mod search_graph;\n mod trait_goals;\n \n pub use fulfill::FulfillmentCtxt;\n@@ -146,45 +142,42 @@ pub trait TyCtxtExt<'tcx> {\n \n impl<'tcx> TyCtxtExt<'tcx> for TyCtxt<'tcx> {\n     fn evaluate_goal(self, goal: CanonicalGoal<'tcx>) -> QueryResult<'tcx> {\n-        let mut cx = EvalCtxt::new(self);\n-        cx.evaluate_canonical_goal(goal)\n+        let mut search_graph = search_graph::SearchGraph::new(self);\n+        EvalCtxt::evaluate_canonical_goal(self, &mut search_graph, goal)\n     }\n }\n \n-struct EvalCtxt<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n+struct EvalCtxt<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'tcx>,\n+    var_values: CanonicalVarValues<'tcx>,\n \n-    provisional_cache: cache::ProvisionalCache<'tcx>,\n-    overflow_data: overflow::OverflowData,\n+    search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n }\n \n-impl<'tcx> EvalCtxt<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> EvalCtxt<'tcx> {\n-        EvalCtxt {\n-            tcx,\n-            provisional_cache: cache::ProvisionalCache::empty(),\n-            overflow_data: overflow::OverflowData::new(tcx),\n-        }\n+impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n     }\n \n-    /// Recursively evaluates `goal`, returning whether any inference vars have\n-    /// been constrained and the certainty of the result.\n-    fn evaluate_goal(\n-        &mut self,\n-        infcx: &InferCtxt<'tcx>,\n-        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution> {\n-        let mut orig_values = OriginalQueryValues::default();\n-        let canonical_goal = infcx.canonicalize_query(goal, &mut orig_values);\n-        let canonical_response = self.evaluate_canonical_goal(canonical_goal)?;\n-        Ok((\n-            !canonical_response.value.var_values.is_identity(),\n-            instantiate_canonical_query_response(infcx, &orig_values, canonical_response),\n-        ))\n+    /// Creates a new evaluation context outside of the trait solver.\n+    ///\n+    /// With this solver making a canonical response doesn't make much sense.\n+    /// The `search_graph` for this solver has to be completely empty.\n+    fn new_outside_solver(\n+        infcx: &'a InferCtxt<'tcx>,\n+        search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n+    ) -> EvalCtxt<'a, 'tcx> {\n+        assert!(search_graph.is_empty());\n+        EvalCtxt { infcx, var_values: CanonicalVarValues::dummy(), search_graph }\n     }\n \n-    fn evaluate_canonical_goal(&mut self, goal: CanonicalGoal<'tcx>) -> QueryResult<'tcx> {\n-        match self.try_push_stack(goal) {\n+    #[instrument(level = \"debug\", skip(tcx, search_graph), ret)]\n+    fn evaluate_canonical_goal(\n+        tcx: TyCtxt<'tcx>,\n+        search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n+        canonical_goal: CanonicalGoal<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        match search_graph.try_push_stack(tcx, canonical_goal) {\n             Ok(()) => {}\n             // Our goal is already on the stack, eager return.\n             Err(response) => return response,\n@@ -195,41 +188,61 @@ impl<'tcx> EvalCtxt<'tcx> {\n         //\n         // FIXME: Similar to `evaluate_all`, this has to check for overflow.\n         loop {\n-            let result = self.compute_goal(goal);\n+            let (ref infcx, goal, var_values) =\n+                tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n+            let mut ecx = EvalCtxt { infcx, var_values, search_graph };\n+            let result = ecx.compute_goal(goal);\n \n             // FIXME: `Response` should be `Copy`\n-            if self.try_finalize_goal(goal, result.clone()) {\n+            if search_graph.try_finalize_goal(tcx, canonical_goal, result.clone()) {\n                 return result;\n             }\n         }\n     }\n \n-    fn compute_goal(&mut self, canonical_goal: CanonicalGoal<'tcx>) -> QueryResult<'tcx> {\n-        // WARNING: We're looking at a canonical value without instantiating it here.\n-        //\n-        // We have to be incredibly careful to not change the order of bound variables or\n-        // remove any. As we go from `Goal<'tcx, Predicate>` to `Goal` with the variants\n-        // of `PredicateKind` this is the case and it is and faster than instantiating and\n-        // recanonicalizing.\n-        let Goal { param_env, predicate } = canonical_goal.value;\n+    fn make_canonical_response(&self, certainty: Certainty) -> QueryResult<'tcx> {\n+        let external_constraints = take_external_constraints(self.infcx)?;\n+\n+        Ok(self.infcx.canonicalize_response(Response {\n+            var_values: self.var_values.clone(),\n+            external_constraints,\n+            certainty,\n+        }))\n+    }\n+\n+    /// Recursively evaluates `goal`, returning whether any inference vars have\n+    /// been constrained and the certainty of the result.\n+    fn evaluate_goal(\n+        &mut self,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> Result<(bool, Certainty), NoSolution> {\n+        let mut orig_values = OriginalQueryValues::default();\n+        let canonical_goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n+        let canonical_response =\n+            EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n+        Ok((\n+            !canonical_response.value.var_values.is_identity(),\n+            instantiate_canonical_query_response(self.infcx, &orig_values, canonical_response),\n+        ))\n+    }\n \n-        if let Some(kind) = predicate.kind().no_bound_vars_ignoring_escaping(self.tcx) {\n+    fn compute_goal(&mut self, goal: Goal<'tcx, ty::Predicate<'tcx>>) -> QueryResult<'tcx> {\n+        let Goal { param_env, predicate } = goal;\n+        let kind = predicate.kind();\n+        if let Some(kind) = kind.no_bound_vars() {\n             match kind {\n-                ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => self.compute_trait_goal(\n-                    canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n-                ),\n-                ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => self\n-                    .compute_projection_goal(\n-                        canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n-                    ),\n-                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => self\n-                    .compute_type_outlives_goal(\n-                        canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n-                    ),\n-                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => self\n-                    .compute_region_outlives_goal(\n-                        canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n-                    ),\n+                ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => {\n+                    self.compute_trait_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => {\n+                    self.compute_projection_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => {\n+                    self.compute_type_outlives_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => {\n+                    self.compute_region_outlives_goal(Goal { param_env, predicate })\n+                }\n                 // FIXME: implement these predicates :)\n                 ty::PredicateKind::WellFormed(_)\n                 | ty::PredicateKind::ObjectSafe(_)\n@@ -239,49 +252,41 @@ impl<'tcx> EvalCtxt<'tcx> {\n                 | ty::PredicateKind::ConstEvaluatable(_)\n                 | ty::PredicateKind::ConstEquate(_, _)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(_)\n-                | ty::PredicateKind::Ambiguous => {\n-                    // FIXME\n-                    response_no_constraints(self.tcx, canonical_goal, Certainty::Yes)\n-                }\n+                | ty::PredicateKind::Ambiguous => self.make_canonical_response(Certainty::Yes),\n             }\n         } else {\n-            let (infcx, goal, var_values) =\n-                self.tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n-            let kind = infcx.replace_bound_vars_with_placeholders(goal.predicate.kind());\n-            let goal = goal.with(self.tcx, ty::Binder::dummy(kind));\n-            let (_, certainty) = self.evaluate_goal(&infcx, goal)?;\n-            infcx.make_canonical_response(var_values, certainty)\n+            let kind = self.infcx.replace_bound_vars_with_placeholders(kind);\n+            let goal = goal.with(self.tcx(), ty::Binder::dummy(kind));\n+            let (_, certainty) = self.evaluate_goal(goal)?;\n+            self.make_canonical_response(certainty)\n         }\n     }\n \n     fn compute_type_outlives_goal(\n         &mut self,\n-        goal: CanonicalGoal<'tcx, TypeOutlivesPredicate<'tcx>>,\n+        _goal: Goal<'tcx, TypeOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        // FIXME\n-        response_no_constraints(self.tcx, goal, Certainty::Yes)\n+        self.make_canonical_response(Certainty::Yes)\n     }\n \n     fn compute_region_outlives_goal(\n         &mut self,\n-        goal: CanonicalGoal<'tcx, RegionOutlivesPredicate<'tcx>>,\n+        _goal: Goal<'tcx, RegionOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        // FIXME\n-        response_no_constraints(self.tcx, goal, Certainty::Yes)\n+        self.make_canonical_response(Certainty::Yes)\n     }\n }\n \n-impl<'tcx> EvalCtxt<'tcx> {\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n     fn evaluate_all(\n         &mut self,\n-        infcx: &InferCtxt<'tcx>,\n         mut goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n     ) -> Result<Certainty, NoSolution> {\n         let mut new_goals = Vec::new();\n         self.repeat_while_none(|this| {\n             let mut has_changed = Err(Certainty::Yes);\n             for goal in goals.drain(..) {\n-                let (changed, certainty) = match this.evaluate_goal(infcx, goal) {\n+                let (changed, certainty) = match this.evaluate_goal(goal) {\n                     Ok(result) => result,\n                     Err(NoSolution) => return Some(Err(NoSolution)),\n                 };\n@@ -310,6 +315,21 @@ impl<'tcx> EvalCtxt<'tcx> {\n     }\n }\n \n+#[instrument(level = \"debug\", skip(infcx), ret)]\n+fn take_external_constraints<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+) -> Result<ExternalConstraints<'tcx>, NoSolution> {\n+    let region_obligations = infcx.take_registered_region_obligations();\n+    let opaque_types = infcx.take_opaque_types_for_query_response();\n+    Ok(ExternalConstraints {\n+        // FIXME: Now that's definitely wrong :)\n+        //\n+        // Should also do the leak check here I think\n+        regions: drop(region_obligations),\n+        opaque_types,\n+    })\n+}\n+\n fn instantiate_canonical_query_response<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     original_values: &OriginalQueryValues<'tcx>,\n@@ -334,3 +354,40 @@ fn instantiate_canonical_query_response<'tcx>(\n     assert!(obligations.is_empty());\n     value\n }\n+\n+pub(super) fn response_no_constraints<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    goal: Canonical<'tcx, impl Sized>,\n+    certainty: Certainty,\n+) -> QueryResult<'tcx> {\n+    let var_values = goal\n+        .variables\n+        .iter()\n+        .enumerate()\n+        .map(|(i, info)| match info.kind {\n+            CanonicalVarKind::Ty(_) | CanonicalVarKind::PlaceholderTy(_) => {\n+                tcx.mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_usize(i).into())).into()\n+            }\n+            CanonicalVarKind::Region(_) | CanonicalVarKind::PlaceholderRegion(_) => {\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_usize(i),\n+                    kind: ty::BrAnon(i as u32, None),\n+                };\n+                tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n+            }\n+            CanonicalVarKind::Const(_, ty) | CanonicalVarKind::PlaceholderConst(_, ty) => tcx\n+                .mk_const(ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_usize(i)), ty)\n+                .into(),\n+        })\n+        .collect();\n+\n+    Ok(Canonical {\n+        max_universe: goal.max_universe,\n+        variables: goal.variables,\n+        value: Response {\n+            var_values: CanonicalVarValues { var_values },\n+            external_constraints: Default::default(),\n+            certainty,\n+        },\n+    })\n+}"}, {"sha": "0658836fb9cd36a8d58aac9c6da7573a801cfeed", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 157, "deletions": 61, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -1,38 +1,123 @@\n use crate::traits::{specialization_graph, translate_substs};\n \n-use super::assembly::{self, AssemblyCtxt};\n-use super::{CanonicalGoal, EvalCtxt, Goal, QueryResult};\n+use super::assembly::{self, Candidate, CandidateSource};\n+use super::infcx_ext::InferCtxtExt;\n+use super::{Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n-use rustc_infer::infer::{InferCtxt, InferOk};\n+use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::specialization_graph::LeafDef;\n-use rustc_infer::traits::{ObligationCause, Reveal};\n+use rustc_infer::traits::Reveal;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n-use rustc_middle::ty::ProjectionPredicate;\n use rustc_middle::ty::TypeVisitable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{ProjectionPredicate, TypeSuperVisitable, TypeVisitor};\n use rustc_span::DUMMY_SP;\n use std::iter;\n+use std::ops::ControlFlow;\n \n-#[allow(dead_code)] // FIXME: implement and use all variants.\n-#[derive(Debug, Clone, Copy)]\n-pub(super) enum CandidateSource {\n-    Impl(DefId),\n-    ParamEnv(usize),\n-    Builtin,\n-}\n-\n-type Candidate<'tcx> = assembly::Candidate<'tcx, ProjectionPredicate<'tcx>>;\n-\n-impl<'tcx> EvalCtxt<'tcx> {\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn compute_projection_goal(\n         &mut self,\n-        goal: CanonicalGoal<'tcx, ProjectionPredicate<'tcx>>,\n+        goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        let candidates = AssemblyCtxt::assemble_and_evaluate_candidates(self, goal);\n-        self.merge_project_candidates(candidates)\n+        // To only compute normalization ones for each projection we only\n+        // normalize if the expected term is an unconstrained inference variable.\n+        //\n+        // E.g. for `<T as Trait>::Assoc = u32` we recursively compute the goal\n+        // `exists<U> <T as Trait>::Assoc = U` and then take the resulting type for\n+        // `U` and equate it with `u32`. This means that we don't need a separate\n+        // projection cache in the solver.\n+        if self.term_is_fully_unconstrained(goal) {\n+            let candidates = self.assemble_and_evaluate_candidates(goal);\n+            self.merge_project_candidates(candidates)\n+        } else {\n+            let predicate = goal.predicate;\n+            let unconstrained_rhs = match predicate.term.unpack() {\n+                ty::TermKind::Ty(_) => self.infcx.next_ty_infer().into(),\n+                ty::TermKind::Const(ct) => self.infcx.next_const_infer(ct.ty()).into(),\n+            };\n+            let unconstrained_predicate = ty::Clause::Projection(ProjectionPredicate {\n+                projection_ty: goal.predicate.projection_ty,\n+                term: unconstrained_rhs,\n+            });\n+            let (_has_changed, normalize_certainty) =\n+                self.evaluate_goal(goal.with(self.tcx(), unconstrained_predicate))?;\n+\n+            let nested_eq_goals =\n+                self.infcx.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n+            let eval_certainty = self.evaluate_all(nested_eq_goals)?;\n+            self.make_canonical_response(normalize_certainty.unify_and(eval_certainty))\n+        }\n+    }\n+\n+    /// Is the projection predicate is of the form `exists<T> <Ty as Trait>::Assoc = T`.\n+    ///\n+    /// This is the case if the `term` is an inference variable in the innermost universe\n+    /// and does not occur in any other part of the predicate.\n+    fn term_is_fully_unconstrained(&self, goal: Goal<'tcx, ProjectionPredicate<'tcx>>) -> bool {\n+        let infcx = self.infcx;\n+        let term_is_infer = match goal.predicate.term.unpack() {\n+            ty::TermKind::Ty(ty) => {\n+                if let &ty::Infer(ty::TyVar(vid)) = ty.kind() {\n+                    match infcx.probe_ty_var(vid) {\n+                        Ok(value) => bug!(\"resolved var in query: {goal:?} {value:?}\"),\n+                        Err(universe) => universe == infcx.universe(),\n+                    }\n+                } else {\n+                    false\n+                }\n+            }\n+            ty::TermKind::Const(ct) => {\n+                if let ty::ConstKind::Infer(ty::InferConst::Var(vid)) = ct.kind() {\n+                    match self.infcx.probe_const_var(vid) {\n+                        Ok(value) => bug!(\"resolved var in query: {goal:?} {value:?}\"),\n+                        Err(universe) => universe == infcx.universe(),\n+                    }\n+                } else {\n+                    false\n+                }\n+            }\n+        };\n+\n+        // Guard against `<T as Trait<?0>>::Assoc = ?0>`.\n+        struct ContainsTerm<'tcx> {\n+            term: ty::Term<'tcx>,\n+        }\n+        impl<'tcx> TypeVisitor<'tcx> for ContainsTerm<'tcx> {\n+            type BreakTy = ();\n+            fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+                if t.needs_infer() {\n+                    if ty::Term::from(t) == self.term {\n+                        ControlFlow::BREAK\n+                    } else {\n+                        t.super_visit_with(self)\n+                    }\n+                } else {\n+                    ControlFlow::CONTINUE\n+                }\n+            }\n+\n+            fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+                if c.needs_infer() {\n+                    if ty::Term::from(c) == self.term {\n+                        ControlFlow::BREAK\n+                    } else {\n+                        c.super_visit_with(self)\n+                    }\n+                } else {\n+                    ControlFlow::CONTINUE\n+                }\n+            }\n+        }\n+\n+        let mut visitor = ContainsTerm { term: goal.predicate.term };\n+\n+        term_is_infer\n+            && goal.predicate.projection_ty.visit_with(&mut visitor).is_continue()\n+            && goal.param_env.visit_with(&mut visitor).is_continue()\n     }\n \n     fn merge_project_candidates(\n@@ -83,14 +168,13 @@ impl<'tcx> EvalCtxt<'tcx> {\n         match (candidate.source, other.source) {\n             (CandidateSource::Impl(_), _)\n             | (CandidateSource::ParamEnv(_), _)\n-            | (CandidateSource::Builtin, _) => unimplemented!(),\n+            | (CandidateSource::BuiltinImpl, _)\n+            | (CandidateSource::AliasBound(_), _) => unimplemented!(),\n         }\n     }\n }\n \n impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n-    type CandidateSource = CandidateSource;\n-\n     fn self_ty(self) -> Ty<'tcx> {\n         self.self_ty()\n     }\n@@ -104,51 +188,48 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n     }\n \n     fn consider_impl_candidate(\n-        acx: &mut AssemblyCtxt<'_, 'tcx, ProjectionPredicate<'tcx>>,\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n         impl_def_id: DefId,\n-    ) {\n-        let tcx = acx.cx.tcx;\n+    ) -> Result<Certainty, NoSolution> {\n+        let tcx = ecx.tcx();\n+\n         let goal_trait_ref = goal.predicate.projection_ty.trait_ref(tcx);\n         let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n         if iter::zip(goal_trait_ref.substs, impl_trait_ref.skip_binder().substs)\n             .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))\n         {\n-            return;\n+            return Err(NoSolution);\n         }\n \n-        acx.infcx.probe(|_| {\n-            let impl_substs = acx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+        ecx.infcx.probe(|_| {\n+            let impl_substs = ecx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n \n-            let Ok(InferOk { obligations, .. }) = acx\n-                .infcx\n-                .at(&ObligationCause::dummy(), goal.param_env)\n-                .define_opaque_types(false)\n-                .eq(goal_trait_ref, impl_trait_ref)\n-                .map_err(|e| debug!(\"failed to equate trait refs: {e:?}\"))\n-            else {\n-                return\n-            };\n+            let mut nested_goals = ecx.infcx.eq(goal.param_env, goal_trait_ref, impl_trait_ref)?;\n             let where_clause_bounds = tcx\n                 .predicates_of(impl_def_id)\n                 .instantiate(tcx, impl_substs)\n                 .predicates\n                 .into_iter()\n                 .map(|pred| goal.with(tcx, pred));\n \n-            let nested_goals = obligations.into_iter().map(|o| o.into()).chain(where_clause_bounds).collect();\n-            let Ok(trait_ref_certainty) = acx.cx.evaluate_all(acx.infcx, nested_goals) else { return };\n+            nested_goals.extend(where_clause_bounds);\n+            let trait_ref_certainty = ecx.evaluate_all(nested_goals)?;\n \n+            // In case the associated item is hidden due to specialization, we have to\n+            // return ambiguity this would otherwise be incomplete, resulting in\n+            // unsoundness during coherence (#105782).\n             let Some(assoc_def) = fetch_eligible_assoc_item_def(\n-                acx.infcx,\n+                ecx.infcx,\n                 goal.param_env,\n                 goal_trait_ref,\n                 goal.predicate.def_id(),\n                 impl_def_id\n-            ) else {\n-                return\n+            )? else {\n+                let certainty = Certainty::Maybe(MaybeCause::Ambiguity);\n+                return Ok(trait_ref_certainty.unify_and(certainty));\n             };\n \n             if !assoc_def.item.defaultness(tcx).has_value() {\n@@ -174,7 +255,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 impl_substs,\n             );\n             let substs = translate_substs(\n-                acx.infcx,\n+                ecx.infcx,\n                 goal.param_env,\n                 impl_def_id,\n                 impl_substs_with_gat,\n@@ -185,7 +266,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             let is_const = matches!(tcx.def_kind(assoc_def.item.def_id), DefKind::AssocConst);\n             let ty = tcx.bound_type_of(assoc_def.item.def_id);\n             let term: ty::EarlyBinder<ty::Term<'tcx>> = if is_const {\n-                let identity_substs = ty::InternalSubsts::identity_for_item(tcx, assoc_def.item.def_id);\n+                let identity_substs =\n+                    ty::InternalSubsts::identity_for_item(tcx, assoc_def.item.def_id);\n                 let did = ty::WithOptConstParam::unknown(assoc_def.item.def_id);\n                 let kind =\n                     ty::ConstKind::Unevaluated(ty::UnevaluatedConst::new(did, identity_substs));\n@@ -194,23 +276,38 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ty.map_bound(|ty| ty.into())\n             };\n \n-            let Ok(InferOk { obligations, .. }) = acx\n+            // The term of our goal should be fully unconstrained, so this should never fail.\n+            //\n+            // It can however be ambiguous when the resolved type is a projection.\n+            let nested_goals = ecx\n                 .infcx\n-                .at(&ObligationCause::dummy(), goal.param_env)\n-                .define_opaque_types(false)\n-                .eq(goal.predicate.term,  term.subst(tcx, substs))\n-                .map_err(|e| debug!(\"failed to equate trait refs: {e:?}\"))\n-            else {\n-                return\n-            };\n+                .eq(goal.param_env, goal.predicate.term, term.subst(tcx, substs))\n+                .expect(\"failed to unify with unconstrained term\");\n+            let rhs_certainty =\n+                ecx.evaluate_all(nested_goals).expect(\"failed to unify with unconstrained term\");\n \n-            let nested_goals = obligations.into_iter().map(|o| o.into()).collect();\n-            let Ok(rhs_certainty) = acx.cx.evaluate_all(acx.infcx, nested_goals) else { return };\n-\n-            let certainty = trait_ref_certainty.unify_and(rhs_certainty);\n-            acx.try_insert_candidate(CandidateSource::Impl(impl_def_id), certainty);\n+            Ok(trait_ref_certainty.unify_and(rhs_certainty))\n         })\n     }\n+\n+    fn consider_builtin_sized_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> Result<Certainty, NoSolution> {\n+        bug!(\"`Sized` does not have an associated type: {:?}\", goal);\n+    }\n+\n+    fn consider_assumption(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        _goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> Result<Certainty, NoSolution> {\n+        if let Some(_poly_projection_pred) = assumption.to_opt_poly_projection_pred() {\n+            unimplemented!()\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n }\n \n /// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code.\n@@ -224,10 +321,9 @@ fn fetch_eligible_assoc_item_def<'tcx>(\n     goal_trait_ref: ty::TraitRef<'tcx>,\n     trait_assoc_def_id: DefId,\n     impl_def_id: DefId,\n-) -> Option<LeafDef> {\n+) -> Result<Option<LeafDef>, NoSolution> {\n     let node_item = specialization_graph::assoc_def(infcx.tcx, impl_def_id, trait_assoc_def_id)\n-        .map_err(|ErrorGuaranteed { .. }| ())\n-        .ok()?;\n+        .map_err(|ErrorGuaranteed { .. }| NoSolution)?;\n \n     let eligible = if node_item.is_final() {\n         // Non-specializable items are always projectable.\n@@ -246,5 +342,5 @@ fn fetch_eligible_assoc_item_def<'tcx>(\n         }\n     };\n \n-    if eligible { Some(node_item) } else { None }\n+    if eligible { Ok(Some(node_item)) } else { Ok(None) }\n }"}, {"sha": "730a8e6125887ae6fcdfb1e7379f38df33d2016e", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/cache.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -0,0 +1,123 @@\n+//! This module both handles the global cache which stores \"finished\" goals,\n+//! and the provisional cache which contains partially computed goals.\n+//!\n+//! The provisional cache is necessary when dealing with coinductive cycles.\n+//!\n+//! For more information about the provisional cache and coinduction in general,\n+//! check out the relevant section of the rustc-dev-guide.\n+//!\n+//! FIXME(@lcnr): Write that section, feel free to ping me if you need help here\n+//! before then or if I still haven't done that before January 2023.\n+use super::overflow::OverflowData;\n+use super::StackDepth;\n+use crate::solve::{CanonicalGoal, QueryResult};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::ty::TyCtxt;\n+\n+rustc_index::newtype_index! {\n+    pub struct EntryIndex {}\n+}\n+\n+#[derive(Debug, Clone)]\n+pub(super) struct ProvisionalEntry<'tcx> {\n+    // In case we have a coinductive cycle, this is the\n+    // the currently least restrictive result of this goal.\n+    pub(super) response: QueryResult<'tcx>,\n+    // In case of a cycle, the position of deepest stack entry involved\n+    // in that cycle. This is monotonically decreasing in the stack as all\n+    // elements between the current stack element in the deepest stack entry\n+    // involved have to also be involved in that cycle.\n+    //\n+    // We can only move entries to the global cache once we're complete done\n+    // with the cycle. If this entry has not been involved in a cycle,\n+    // this is just its own depth.\n+    pub(super) depth: StackDepth,\n+\n+    // The goal for this entry. Should always be equal to the corresponding goal\n+    // in the lookup table.\n+    pub(super) goal: CanonicalGoal<'tcx>,\n+}\n+\n+pub(super) struct ProvisionalCache<'tcx> {\n+    pub(super) entries: IndexVec<EntryIndex, ProvisionalEntry<'tcx>>,\n+    // FIXME: This is only used to quickly check whether a given goal\n+    // is in the cache. We should experiment with using something like\n+    // `SsoHashSet` here because in most cases there are only a few entries.\n+    pub(super) lookup_table: FxHashMap<CanonicalGoal<'tcx>, EntryIndex>,\n+}\n+\n+impl<'tcx> ProvisionalCache<'tcx> {\n+    pub(super) fn empty() -> ProvisionalCache<'tcx> {\n+        ProvisionalCache { entries: Default::default(), lookup_table: Default::default() }\n+    }\n+\n+    pub(super) fn is_empty(&self) -> bool {\n+        self.entries.is_empty() && self.lookup_table.is_empty()\n+    }\n+\n+    /// Adds a dependency from the current leaf to `target` in the cache\n+    /// to prevent us from moving any goals which depend on the current leaf\n+    /// to the global cache while we're still computing `target`.\n+    ///\n+    /// Its important to note that `target` may already be part of a different cycle.\n+    /// In this case we have to ensure that we also depend on all other goals\n+    /// in the existing cycle in addition to the potentially direct cycle with `target`.\n+    pub(super) fn add_dependency_of_leaf_on(&mut self, target: EntryIndex) {\n+        let depth = self.entries[target].depth;\n+        for provisional_entry in &mut self.entries.raw[target.index()..] {\n+            // The depth of `target` is the position of the deepest goal in the stack\n+            // on which `target` depends. That goal is the `root` of this cycle.\n+            //\n+            // Any entry which was added after `target` is either on the stack itself\n+            // at which point its depth is definitely at least as high as the depth of\n+            // `root`. If it's not on the stack itself it has to depend on a goal\n+            // between `root` and `leaf`. If it were to depend on a goal deeper in the\n+            // stack than `root`, then `root` would also depend on that goal, at which\n+            // point `root` wouldn't be the root anymore.\n+            debug_assert!(provisional_entry.depth >= depth);\n+            provisional_entry.depth = depth;\n+        }\n+\n+        // We only update entries which were added after `target` as no other\n+        // entry should have a higher depth.\n+        //\n+        // Any entry which previously had a higher depth than target has to\n+        // be between `target` and `root`. Because of this we would have updated\n+        // its depth when calling `add_dependency_of_leaf_on(root)` for `target`.\n+        if cfg!(debug_assertions) {\n+            self.entries.iter().all(|e| e.depth <= depth);\n+        }\n+    }\n+\n+    pub(super) fn depth(&self, entry_index: EntryIndex) -> StackDepth {\n+        self.entries[entry_index].depth\n+    }\n+\n+    pub(super) fn provisional_result(&self, entry_index: EntryIndex) -> QueryResult<'tcx> {\n+        self.entries[entry_index].response.clone()\n+    }\n+}\n+\n+pub(super) fn try_move_finished_goal_to_global_cache<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    overflow_data: &mut OverflowData,\n+    stack: &IndexVec<super::StackDepth, super::StackElem<'tcx>>,\n+    goal: CanonicalGoal<'tcx>,\n+    response: QueryResult<'tcx>,\n+) {\n+    // We move goals to the global cache if we either did not hit an overflow or if it's\n+    // the root goal as that will now always hit the same overflow limit.\n+    //\n+    // NOTE: We cannot move any non-root goals to the global cache even if their final result\n+    // isn't impacted by the overflow as that goal still has unstable query dependencies\n+    // because it didn't go its full depth.\n+    //\n+    // FIXME(@lcnr): We could still cache subtrees which are not impacted by overflow though.\n+    // Tracking that info correctly isn't trivial, so I haven't implemented it for now.\n+    let should_cache_globally = !overflow_data.did_overflow() || stack.is_empty();\n+    if should_cache_globally {\n+        // FIXME: move the provisional entry to the global cache.\n+        let _ = (tcx, goal, response);\n+    }\n+}"}, {"sha": "0030e9aa3e5149343098dda7c96c3989f92889ae", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -0,0 +1,178 @@\n+mod cache;\n+mod overflow;\n+\n+use self::cache::ProvisionalEntry;\n+use super::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n+use cache::ProvisionalCache;\n+use overflow::OverflowData;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::ty::TyCtxt;\n+use std::collections::hash_map::Entry;\n+\n+rustc_index::newtype_index! {\n+    pub struct StackDepth {}\n+}\n+\n+struct StackElem<'tcx> {\n+    goal: CanonicalGoal<'tcx>,\n+    has_been_used: bool,\n+}\n+\n+pub(super) struct SearchGraph<'tcx> {\n+    /// The stack of goals currently being computed.\n+    ///\n+    /// An element is *deeper* in the stack if its index is *lower*.\n+    stack: IndexVec<StackDepth, StackElem<'tcx>>,\n+    overflow_data: OverflowData,\n+    provisional_cache: ProvisionalCache<'tcx>,\n+}\n+\n+impl<'tcx> SearchGraph<'tcx> {\n+    pub(super) fn new(tcx: TyCtxt<'tcx>) -> SearchGraph<'tcx> {\n+        Self {\n+            stack: Default::default(),\n+            overflow_data: OverflowData::new(tcx),\n+            provisional_cache: ProvisionalCache::empty(),\n+        }\n+    }\n+\n+    pub(super) fn is_empty(&self) -> bool {\n+        self.stack.is_empty()\n+            && self.provisional_cache.is_empty()\n+            && !self.overflow_data.did_overflow()\n+    }\n+\n+    /// Tries putting the new goal on the stack, returning an error if it is already cached.\n+    ///\n+    /// This correctly updates the provisional cache if there is a cycle.\n+    pub(super) fn try_push_stack(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        goal: CanonicalGoal<'tcx>,\n+    ) -> Result<(), QueryResult<'tcx>> {\n+        // FIXME: start by checking the global cache\n+\n+        // Look at the provisional cache to check for cycles.\n+        let cache = &mut self.provisional_cache;\n+        match cache.lookup_table.entry(goal) {\n+            // No entry, simply push this goal on the stack after dealing with overflow.\n+            Entry::Vacant(v) => {\n+                if self.overflow_data.has_overflow(self.stack.len()) {\n+                    return Err(self.deal_with_overflow(tcx, goal));\n+                }\n+\n+                let depth = self.stack.push(StackElem { goal, has_been_used: false });\n+                let response = super::response_no_constraints(tcx, goal, Certainty::Yes);\n+                let entry_index = cache.entries.push(ProvisionalEntry { response, depth, goal });\n+                v.insert(entry_index);\n+                Ok(())\n+            }\n+            // We have a nested goal which relies on a goal `root` deeper in the stack.\n+            //\n+            // We first store that we may have to rerun `evaluate_goal` for `root` in case the\n+            // provisional response is not equal to the final response. We also update the depth\n+            // of all goals which recursively depend on our current goal to depend on `root`\n+            // instead.\n+            //\n+            // Finally we can return either the provisional response for that goal if we have a\n+            // coinductive cycle or an ambiguous result if the cycle is inductive.\n+            Entry::Occupied(entry_index) => {\n+                let entry_index = *entry_index.get();\n+\n+                cache.add_dependency_of_leaf_on(entry_index);\n+                let stack_depth = cache.depth(entry_index);\n+\n+                self.stack[stack_depth].has_been_used = true;\n+                // NOTE: The goals on the stack aren't the only goals involved in this cycle.\n+                // We can also depend on goals which aren't part of the stack but coinductively\n+                // depend on the stack themselves. We already checked whether all the goals\n+                // between these goals and their root on the stack. This means that as long as\n+                // each goal in a cycle is checked for coinductivity by itself, simply checking\n+                // the stack is enough.\n+                if self.stack.raw[stack_depth.index()..]\n+                    .iter()\n+                    .all(|g| g.goal.value.predicate.is_coinductive(tcx))\n+                {\n+                    Err(cache.provisional_result(entry_index))\n+                } else {\n+                    Err(super::response_no_constraints(\n+                        tcx,\n+                        goal,\n+                        Certainty::Maybe(MaybeCause::Overflow),\n+                    ))\n+                }\n+            }\n+        }\n+    }\n+\n+    /// We cannot simply store the result of [super::EvalCtxt::compute_goal] as we have to deal with\n+    /// coinductive cycles.\n+    ///\n+    /// When we encounter a coinductive cycle, we have to prove the final result of that cycle\n+    /// while we are still computing that result. Because of this we continously recompute the\n+    /// cycle until the result of the previous iteration is equal to the final result, at which\n+    /// point we are done.\n+    ///\n+    /// This function returns `true` if we were able to finalize the goal and `false` if it has\n+    /// updated the provisional cache and we have to recompute the current goal.\n+    ///\n+    /// FIXME: Refer to the rustc-dev-guide entry once it exists.\n+    pub(super) fn try_finalize_goal(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        actual_goal: CanonicalGoal<'tcx>,\n+        response: QueryResult<'tcx>,\n+    ) -> bool {\n+        let StackElem { goal, has_been_used } = self.stack.pop().unwrap();\n+        assert_eq!(goal, actual_goal);\n+\n+        let cache = &mut self.provisional_cache;\n+        let provisional_entry_index = *cache.lookup_table.get(&goal).unwrap();\n+        let provisional_entry = &mut cache.entries[provisional_entry_index];\n+        let depth = provisional_entry.depth;\n+        // Was the current goal the root of a cycle and was the provisional response\n+        // different from the final one.\n+        if has_been_used && provisional_entry.response != response {\n+            // If so, update the provisional reponse for this goal...\n+            provisional_entry.response = response;\n+            // ...remove all entries whose result depends on this goal\n+            // from the provisional cache...\n+            //\n+            // That's not completely correct, as a nested goal can also\n+            // depend on a goal which is lower in the stack so it doesn't\n+            // actually depend on the current goal. This should be fairly\n+            // rare and is hopefully not relevant for performance.\n+            #[allow(rustc::potential_query_instability)]\n+            cache.lookup_table.retain(|_key, index| *index <= provisional_entry_index);\n+            cache.entries.truncate(provisional_entry_index.index() + 1);\n+\n+            // ...and finally push our goal back on the stack and reevaluate it.\n+            self.stack.push(StackElem { goal, has_been_used: false });\n+            false\n+        } else {\n+            // If not, we're done with this goal.\n+            //\n+            // Check whether that this goal doesn't depend on a goal deeper on the stack\n+            // and if so, move it and all nested goals to the global cache.\n+            //\n+            // Note that if any nested goal were to depend on something deeper on the stack,\n+            // this would have also updated the depth of the current goal.\n+            if depth == self.stack.next_index() {\n+                for (i, entry) in cache.entries.drain_enumerated(provisional_entry_index.index()..)\n+                {\n+                    let actual_index = cache.lookup_table.remove(&entry.goal);\n+                    debug_assert_eq!(Some(i), actual_index);\n+                    debug_assert!(entry.depth == depth);\n+                    cache::try_move_finished_goal_to_global_cache(\n+                        tcx,\n+                        &mut self.overflow_data,\n+                        &self.stack,\n+                        entry.goal,\n+                        entry.response,\n+                    );\n+                }\n+            }\n+            true\n+        }\n+    }\n+}"}, {"sha": "1dd3894c91adc009c9c9e8fbaa1103fed4beeca2", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/overflow.rs", "status": "renamed", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -3,8 +3,8 @@ use rustc_infer::traits::query::NoSolution;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Limit;\n \n-use super::cache::response_no_constraints;\n-use super::{Certainty, EvalCtxt, MaybeCause, QueryResult};\n+use super::SearchGraph;\n+use crate::solve::{response_no_constraints, Certainty, EvalCtxt, MaybeCause, QueryResult};\n \n /// When detecting a solver overflow, we return ambiguity. Overflow can be\n /// *hidden* by either a fatal error in an **AND** or a trivial success in an **OR**.\n@@ -50,32 +50,35 @@ impl OverflowData {\n     }\n }\n \n-impl<'tcx> EvalCtxt<'tcx> {\n-    pub(super) fn deal_with_overflow(\n+impl<'tcx> SearchGraph<'tcx> {\n+    pub fn deal_with_overflow(\n         &mut self,\n+        tcx: TyCtxt<'tcx>,\n         goal: Canonical<'tcx, impl Sized>,\n     ) -> QueryResult<'tcx> {\n         self.overflow_data.deal_with_overflow();\n-        response_no_constraints(self.tcx, goal, Certainty::Maybe(MaybeCause::Overflow))\n+        response_no_constraints(tcx, goal, Certainty::Maybe(MaybeCause::Overflow))\n     }\n+}\n \n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n     /// A `while`-loop which tracks overflow.\n-    pub(super) fn repeat_while_none(\n+    pub fn repeat_while_none(\n         &mut self,\n         mut loop_body: impl FnMut(&mut Self) -> Option<Result<Certainty, NoSolution>>,\n     ) -> Result<Certainty, NoSolution> {\n-        let start_depth = self.overflow_data.additional_depth;\n-        let depth = self.provisional_cache.current_depth();\n-        while !self.overflow_data.has_overflow(depth) {\n+        let start_depth = self.search_graph.overflow_data.additional_depth;\n+        let depth = self.search_graph.stack.len();\n+        while !self.search_graph.overflow_data.has_overflow(depth) {\n             if let Some(result) = loop_body(self) {\n-                self.overflow_data.additional_depth = start_depth;\n+                self.search_graph.overflow_data.additional_depth = start_depth;\n                 return result;\n             }\n \n-            self.overflow_data.additional_depth += 1;\n+            self.search_graph.overflow_data.additional_depth += 1;\n         }\n-        self.overflow_data.additional_depth = start_depth;\n-        self.overflow_data.deal_with_overflow();\n+        self.search_graph.overflow_data.additional_depth = start_depth;\n+        self.search_graph.overflow_data.deal_with_overflow();\n         Ok(Certainty::Maybe(MaybeCause::Overflow))\n     }\n }", "previous_filename": "compiler/rustc_trait_selection/src/solve/overflow.rs"}, {"sha": "bbe175d5cc8536ce72792b2a14592d2bc4ec6827", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 36, "deletions": 70, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -2,58 +2,17 @@\n \n use std::iter;\n \n-use super::assembly::{self, AssemblyCtxt};\n-use super::{CanonicalGoal, EvalCtxt, Goal, QueryResult};\n+use super::assembly::{self, Candidate, CandidateSource};\n+use super::infcx_ext::InferCtxtExt;\n+use super::{Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n-use rustc_infer::infer::InferOk;\n use rustc_infer::traits::query::NoSolution;\n-use rustc_infer::traits::ObligationCause;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::TraitPredicate;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::DUMMY_SP;\n \n-#[allow(dead_code)] // FIXME: implement and use all variants.\n-#[derive(Debug, Clone, Copy)]\n-pub(super) enum CandidateSource {\n-    /// Some user-defined impl with the given `DefId`.\n-    Impl(DefId),\n-    /// The n-th caller bound in the `param_env` of our goal.\n-    ///\n-    /// This is pretty much always a bound from the `where`-clauses of the\n-    /// currently checked item.\n-    ParamEnv(usize),\n-    /// A bound on the `self_ty` in case it is a projection or an opaque type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore (for syntax highlighting)\n-    /// trait Trait {\n-    ///     type Assoc: OtherTrait;\n-    /// }\n-    /// ```\n-    ///\n-    /// We know that `<Whatever as Trait>::Assoc: OtherTrait` holds by looking at\n-    /// the bounds on `Trait::Assoc`.\n-    AliasBound(usize),\n-    /// A builtin implementation for some specific traits, used in cases\n-    /// where we cannot rely an ordinary library implementations.\n-    ///\n-    /// The most notable examples are `Sized`, `Copy` and `Clone`. This is also\n-    /// used for the `DiscriminantKind` and `Pointee` trait, both of which have\n-    /// an associated type.\n-    Builtin,\n-    /// An automatic impl for an auto trait, e.g. `Send`. These impls recursively look\n-    /// at the constituent types of the `self_ty` to check whether the auto trait\n-    /// is implemented for those.\n-    AutoImpl,\n-}\n-\n-type Candidate<'tcx> = assembly::Candidate<'tcx, TraitPredicate<'tcx>>;\n-\n impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n-    type CandidateSource = CandidateSource;\n-\n     fn self_ty(self) -> Ty<'tcx> {\n         self.self_ty()\n     }\n@@ -67,55 +26,63 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     }\n \n     fn consider_impl_candidate(\n-        acx: &mut AssemblyCtxt<'_, 'tcx, Self>,\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,\n         impl_def_id: DefId,\n-    ) {\n-        let tcx = acx.cx.tcx;\n+    ) -> Result<Certainty, NoSolution> {\n+        let tcx = ecx.tcx();\n \n         let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n         if iter::zip(goal.predicate.trait_ref.substs, impl_trait_ref.skip_binder().substs)\n             .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))\n         {\n-            return;\n+            return Err(NoSolution);\n         }\n \n-        acx.infcx.probe(|_| {\n-            let impl_substs = acx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+        ecx.infcx.probe(|_| {\n+            let impl_substs = ecx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n \n-            let Ok(InferOk { obligations, .. }) = acx\n-                .infcx\n-                .at(&ObligationCause::dummy(), goal.param_env)\n-                .define_opaque_types(false)\n-                .eq(goal.predicate.trait_ref, impl_trait_ref)\n-                .map_err(|e| debug!(\"failed to equate trait refs: {e:?}\"))\n-            else {\n-                return\n-            };\n+            let mut nested_goals =\n+                ecx.infcx.eq(goal.param_env, goal.predicate.trait_ref, impl_trait_ref)?;\n             let where_clause_bounds = tcx\n                 .predicates_of(impl_def_id)\n                 .instantiate(tcx, impl_substs)\n                 .predicates\n                 .into_iter()\n                 .map(|pred| goal.with(tcx, pred));\n+            nested_goals.extend(where_clause_bounds);\n+            ecx.evaluate_all(nested_goals)\n+        })\n+    }\n \n-            let nested_goals =\n-                obligations.into_iter().map(|o| o.into()).chain(where_clause_bounds).collect();\n+    fn consider_builtin_sized_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        _goal: Goal<'tcx, Self>,\n+    ) -> Result<Certainty, NoSolution> {\n+        unimplemented!();\n+    }\n \n-            let Ok(certainty) = acx.cx.evaluate_all(acx.infcx, nested_goals) else { return };\n-            acx.try_insert_candidate(CandidateSource::Impl(impl_def_id), certainty);\n-        })\n+    fn consider_assumption(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        _goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> Result<Certainty, NoSolution> {\n+        if let Some(_poly_trait_pred) = assumption.to_opt_poly_trait_pred() {\n+            unimplemented!()\n+        } else {\n+            Err(NoSolution)\n+        }\n     }\n }\n \n-impl<'tcx> EvalCtxt<'tcx> {\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn compute_trait_goal(\n         &mut self,\n-        goal: CanonicalGoal<'tcx, TraitPredicate<'tcx>>,\n+        goal: Goal<'tcx, TraitPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        let candidates = AssemblyCtxt::assemble_and_evaluate_candidates(self, goal);\n+        let candidates = self.assemble_and_evaluate_candidates(goal);\n         self.merge_trait_candidates_discard_reservation_impls(candidates)\n     }\n \n@@ -169,14 +136,13 @@ impl<'tcx> EvalCtxt<'tcx> {\n             (CandidateSource::Impl(_), _)\n             | (CandidateSource::ParamEnv(_), _)\n             | (CandidateSource::AliasBound(_), _)\n-            | (CandidateSource::Builtin, _)\n-            | (CandidateSource::AutoImpl, _) => unimplemented!(),\n+            | (CandidateSource::BuiltinImpl, _) => unimplemented!(),\n         }\n     }\n \n     fn discard_reservation_impl(&self, candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n         if let CandidateSource::Impl(def_id) = candidate.source {\n-            if let ty::ImplPolarity::Reservation = self.tcx.impl_polarity(def_id) {\n+            if let ty::ImplPolarity::Reservation = self.tcx().impl_polarity(def_id) {\n                 debug!(\"Selected reservation impl\");\n                 // FIXME: reduce candidate to ambiguous\n                 // FIXME: replace `var_values` with identity, yeet external constraints."}, {"sha": "2b1a787cc549929231be0dfe33f1b8b57d1e9441", "filename": "library/alloc/src/vec/drain.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -223,9 +223,9 @@ impl<T, A: Allocator> Drop for Drain<'_, T, A> {\n         }\n \n         // as_slice() must only be called when iter.len() is > 0 because\n-        // vec::Splice modifies vec::Drain fields and may grow the vec which would invalidate\n-        // the iterator's internal pointers. Creating a reference to deallocated memory\n-        // is invalid even when it is zero-length\n+        // it also gets touched by vec::Splice which may turn it into a dangling pointer\n+        // which would make it and the vec pointer point to different allocations which would\n+        // lead to invalid pointer arithmetic below.\n         let drop_ptr = iter.as_slice().as_ptr();\n \n         unsafe {"}, {"sha": "1861147fe72fb676920d5a8ac8847288253e6797", "filename": "library/alloc/src/vec/splice.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/library%2Falloc%2Fsrc%2Fvec%2Fsplice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/library%2Falloc%2Fsrc%2Fvec%2Fsplice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fsplice.rs?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -54,6 +54,12 @@ impl<I: Iterator, A: Allocator> ExactSizeIterator for Splice<'_, I, A> {}\n impl<I: Iterator, A: Allocator> Drop for Splice<'_, I, A> {\n     fn drop(&mut self) {\n         self.drain.by_ref().for_each(drop);\n+        // At this point draining is done and the only remaining tasks are splicing\n+        // and moving things into the final place.\n+        // Which means we can replace the slice::Iter with pointers that won't point to deallocated\n+        // memory, so that Drain::drop is still allowed to call iter.len(), otherwise it would break\n+        // the ptr.sub_ptr contract.\n+        self.drain.iter = (&[]).iter();\n \n         unsafe {\n             if self.drain.tail_len == 0 {"}, {"sha": "7b1cb5488bcac650871b9ee38de84fb536bef4e7", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -202,14 +202,11 @@ impl<T: ?Sized> *const T {\n     #[must_use]\n     #[inline(always)]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn addr(self) -> usize\n-    where\n-        T: Sized,\n-    {\n+    pub fn addr(self) -> usize {\n         // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n         // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n         // provenance).\n-        unsafe { mem::transmute(self) }\n+        unsafe { mem::transmute(self.cast::<()>()) }\n     }\n \n     /// Gets the \"address\" portion of the pointer, and 'exposes' the \"provenance\" part for future\n@@ -239,12 +236,9 @@ impl<T: ?Sized> *const T {\n     #[must_use]\n     #[inline(always)]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn expose_addr(self) -> usize\n-    where\n-        T: Sized,\n-    {\n+    pub fn expose_addr(self) -> usize {\n         // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n-        self as usize\n+        self.cast::<()>() as usize\n     }\n \n     /// Creates a new pointer with the given address.\n@@ -262,10 +256,7 @@ impl<T: ?Sized> *const T {\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn with_addr(self, addr: usize) -> Self\n-    where\n-        T: Sized,\n-    {\n+    pub fn with_addr(self, addr: usize) -> Self {\n         // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n         //\n         // In the mean-time, this operation is defined to be \"as if\" it was\n@@ -288,10 +279,7 @@ impl<T: ?Sized> *const T {\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn map_addr(self, f: impl FnOnce(usize) -> usize) -> Self\n-    where\n-        T: Sized,\n-    {\n+    pub fn map_addr(self, f: impl FnOnce(usize) -> usize) -> Self {\n         self.with_addr(f(self.addr()))\n     }\n "}, {"sha": "ed1e3bd48122761607f22a10f0bfb11608c0d892", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -208,14 +208,11 @@ impl<T: ?Sized> *mut T {\n     #[must_use]\n     #[inline(always)]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn addr(self) -> usize\n-    where\n-        T: Sized,\n-    {\n+    pub fn addr(self) -> usize {\n         // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n         // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n         // provenance).\n-        unsafe { mem::transmute(self) }\n+        unsafe { mem::transmute(self.cast::<()>()) }\n     }\n \n     /// Gets the \"address\" portion of the pointer, and 'exposes' the \"provenance\" part for future\n@@ -245,12 +242,9 @@ impl<T: ?Sized> *mut T {\n     #[must_use]\n     #[inline(always)]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn expose_addr(self) -> usize\n-    where\n-        T: Sized,\n-    {\n+    pub fn expose_addr(self) -> usize {\n         // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n-        self as usize\n+        self.cast::<()>() as usize\n     }\n \n     /// Creates a new pointer with the given address.\n@@ -268,10 +262,7 @@ impl<T: ?Sized> *mut T {\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn with_addr(self, addr: usize) -> Self\n-    where\n-        T: Sized,\n-    {\n+    pub fn with_addr(self, addr: usize) -> Self {\n         // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n         //\n         // In the mean-time, this operation is defined to be \"as if\" it was\n@@ -294,10 +285,7 @@ impl<T: ?Sized> *mut T {\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn map_addr(self, f: impl FnOnce(usize) -> usize) -> Self\n-    where\n-        T: Sized,\n-    {\n+    pub fn map_addr(self, f: impl FnOnce(usize) -> usize) -> Self {\n         self.with_addr(f(self.addr()))\n     }\n "}, {"sha": "8c1a648860555bacacf1d8b9d7cce1e621f08cc0", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -268,10 +268,7 @@ impl<T: ?Sized> NonNull<T> {\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn addr(self) -> NonZeroUsize\n-    where\n-        T: Sized,\n-    {\n+    pub fn addr(self) -> NonZeroUsize {\n         // SAFETY: The pointer is guaranteed by the type to be non-null,\n         // meaning that the address will be non-zero.\n         unsafe { NonZeroUsize::new_unchecked(self.pointer.addr()) }\n@@ -286,10 +283,7 @@ impl<T: ?Sized> NonNull<T> {\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn with_addr(self, addr: NonZeroUsize) -> Self\n-    where\n-        T: Sized,\n-    {\n+    pub fn with_addr(self, addr: NonZeroUsize) -> Self {\n         // SAFETY: The result of `ptr::from::with_addr` is non-null because `addr` is guaranteed to be non-zero.\n         unsafe { NonNull::new_unchecked(self.pointer.with_addr(addr.get()) as *mut _) }\n     }\n@@ -303,10 +297,7 @@ impl<T: ?Sized> NonNull<T> {\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn map_addr(self, f: impl FnOnce(NonZeroUsize) -> NonZeroUsize) -> Self\n-    where\n-        T: Sized,\n-    {\n+    pub fn map_addr(self, f: impl FnOnce(NonZeroUsize) -> NonZeroUsize) -> Self {\n         self.with_addr(f(self.addr()))\n     }\n "}, {"sha": "85065984fbbb19872e7c2935e683969b4e8feef2", "filename": "library/std/src/os/net/linux_ext/addr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Faddr.rs?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -38,7 +38,7 @@ pub trait SocketAddrExt: Sealed {\n     ///     Ok(())\n     /// }\n     /// ```\n-    fn from_abstract_name<N>(name: &N) -> crate::io::Result<SocketAddr>\n+    fn from_abstract_name<N>(name: N) -> crate::io::Result<SocketAddr>\n     where\n         N: AsRef<[u8]>;\n "}, {"sha": "ece2b33bddf364e16c1421b68f5a37e362ee5793", "filename": "library/std/src/os/unix/net/addr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -256,7 +256,7 @@ impl linux_ext::addr::SocketAddrExt for SocketAddr {\n         if let AddressKind::Abstract(name) = self.address() { Some(name) } else { None }\n     }\n \n-    fn from_abstract_name<N>(name: &N) -> crate::io::Result<Self>\n+    fn from_abstract_name<N>(name: N) -> crate::io::Result<Self>\n     where\n         N: AsRef<[u8]>,\n     {"}, {"sha": "9ceeeb5ae8fd84b7a3c4747b08654c1abac6c664", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -803,15 +803,10 @@ function loadCss(cssUrl) {\n         }\n     });\n \n-    function handleClick(id, f) {\n-        const elem = document.getElementById(id);\n-        if (elem) {\n-            elem.addEventListener(\"click\", f);\n-        }\n+    const mainElem = document.getElementById(MAIN_ID);\n+    if (mainElem) {\n+        mainElem.addEventListener(\"click\", hideSidebar);\n     }\n-    handleClick(MAIN_ID, () => {\n-        hideSidebar();\n-    });\n \n     onEachLazy(document.querySelectorAll(\"a[href^='#']\"), el => {\n         // For clicks on internal links (<A> tags with a hash property), we expand the section we're\n@@ -945,7 +940,7 @@ function loadCss(cssUrl) {\n                 return;\n             }\n             if (!this.NOTABLE_FORCE_VISIBLE &&\n-                !elemIsInParent(event.relatedTarget, window.CURRENT_NOTABLE_ELEMENT)) {\n+                !elemIsInParent(ev.relatedTarget, window.CURRENT_NOTABLE_ELEMENT)) {\n                 hideNotable(true);\n             }\n         };"}, {"sha": "30a28bc5803ddf41f0479606e9e94ca99d06d6c3", "filename": "src/tools/miri/tests/pass/vec.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f72129ffe5e8c495113f9a2d4e1730f7fad3209/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fvec.rs?ref=1f72129ffe5e8c495113f9a2d4e1730f7fad3209", "patch": "@@ -162,6 +162,11 @@ fn reverse() {\n     assert!(v[0].0 == 49);\n }\n \n+fn miri_issue_2759() {\n+    let mut input = \"1\".to_string();\n+    input.replace_range(0..0, \"0\");\n+}\n+\n fn main() {\n     assert_eq!(vec_reallocate().len(), 5);\n \n@@ -191,4 +196,5 @@ fn main() {\n     swap();\n     swap_remove();\n     reverse();\n+    miri_issue_2759();\n }"}]}