{"sha": "bff22cf1665e98a1c3feb60e1c23fc30a4120934", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmZjIyY2YxNjY1ZTk4YTFjM2ZlYjYwZTFjMjNmYzMwYTQxMjA5MzQ=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-25T02:32:02Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-26T07:37:45Z"}, "message": "libsyntax: add some explicit copies", "tree": {"sha": "1625f6d0921cf8944742a4dc6142ed4e92b1206c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1625f6d0921cf8944742a4dc6142ed4e92b1206c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bff22cf1665e98a1c3feb60e1c23fc30a4120934", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bff22cf1665e98a1c3feb60e1c23fc30a4120934", "html_url": "https://github.com/rust-lang/rust/commit/bff22cf1665e98a1c3feb60e1c23fc30a4120934", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bff22cf1665e98a1c3feb60e1c23fc30a4120934/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "752befe2a6401108f27ff0141bdd73baac44c41c", "url": "https://api.github.com/repos/rust-lang/rust/commits/752befe2a6401108f27ff0141bdd73baac44c41c", "html_url": "https://github.com/rust-lang/rust/commit/752befe2a6401108f27ff0141bdd73baac44c41c"}], "stats": {"total": 162, "additions": 94, "deletions": 68}, "files": [{"sha": "48fe0ca5b2d7fb6fe20857458327761e108d3aef", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bff22cf1665e98a1c3feb60e1c23fc30a4120934/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff22cf1665e98a1c3feb60e1c23fc30a4120934/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=bff22cf1665e98a1c3feb60e1c23fc30a4120934", "patch": "@@ -60,8 +60,8 @@ pub fn path_to_str_with_sep(p: &[path_elt], sep: ~str, itr: @ident_interner)\n                          -> ~str {\n     let strs = do p.map |e| {\n         match *e {\n-          path_mod(s) => *itr.get(s),\n-          path_name(s) => *itr.get(s)\n+          path_mod(s) => copy *itr.get(s),\n+          path_name(s) => copy *itr.get(s)\n         }\n     };\n     str::connect(strs, sep)\n@@ -70,7 +70,7 @@ pub fn path_to_str_with_sep(p: &[path_elt], sep: ~str, itr: @ident_interner)\n pub fn path_ident_to_str(p: path, i: ident, itr: @ident_interner) -> ~str {\n     if vec::is_empty(p) {\n         //FIXME /* FIXME (#2543) */ copy *i\n-        *itr.get(i)\n+        copy *itr.get(i)\n     } else {\n         fmt!(\"%s::%s\", path_to_str(p, itr), *itr.get(i))\n     }\n@@ -82,8 +82,8 @@ pub fn path_to_str(p: &[path_elt], itr: @ident_interner) -> ~str {\n \n pub fn path_elt_to_str(pe: path_elt, itr: @ident_interner) -> ~str {\n     match pe {\n-        path_mod(s) => *itr.get(s),\n-        path_name(s) => *itr.get(s)\n+        path_mod(s) => copy *itr.get(s),\n+        path_name(s) => copy *itr.get(s)\n     }\n }\n \n@@ -310,7 +310,10 @@ pub fn map_item(i: @item, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n             for methods.each |tm| {\n                 let id = ast_util::trait_method_to_ty_method(tm).id;\n                 let d_id = ast_util::local_def(i.id);\n-                cx.map.insert(id, node_trait_method(@*tm, d_id, item_path));\n+                cx.map.insert(\n+                    id,\n+                    node_trait_method(@copy *tm, d_id, item_path)\n+                );\n             }\n         }\n         _ => ()"}, {"sha": "59f25024c82b28341492f077c3bd1d16ce139899", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bff22cf1665e98a1c3feb60e1c23fc30a4120934/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff22cf1665e98a1c3feb60e1c23fc30a4120934/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=bff22cf1665e98a1c3feb60e1c23fc30a4120934", "patch": "@@ -27,7 +27,7 @@ use core::vec;\n pub pure fn path_name_i(idents: &[ident], intr: @token::ident_interner)\n                      -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n-    str::connect(idents.map(|i| *intr.get(*i)), ~\"::\")\n+    str::connect(idents.map(|i| copy *intr.get(*i)), ~\"::\")\n }\n \n \n@@ -283,7 +283,7 @@ pub fn split_trait_methods(trait_methods: &[trait_method])\n     let mut reqd = ~[], provd = ~[];\n     for trait_methods.each |trt_method| {\n         match *trt_method {\n-          required(ref tm) => reqd.push((*tm)),\n+          required(ref tm) => reqd.push(copy *tm),\n           provided(m) => provd.push(m)\n         }\n     };"}, {"sha": "fae5b1b49af2dbadb0ca67f1942376abcf71e0ba", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bff22cf1665e98a1c3feb60e1c23fc30a4120934/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff22cf1665e98a1c3feb60e1c23fc30a4120934/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=bff22cf1665e98a1c3feb60e1c23fc30a4120934", "patch": "@@ -27,10 +27,14 @@ pub impl proto_parser for parser::Parser {\n     fn parse_proto(&self, id: ~str) -> protocol {\n         let proto = protocol(id, *self.span);\n \n-        self.parse_seq_to_before_end(token::EOF, SeqSep {\n-                                        sep: None,\n-                                        trailing_sep_allowed: false\n-                                     }, |self| self.parse_state(proto));\n+        self.parse_seq_to_before_end(\n+            token::EOF,\n+            SeqSep {\n+                sep: None,\n+                trailing_sep_allowed: false,\n+            },\n+            |self| self.parse_state(proto)\n+        );\n \n         return proto;\n     }\n@@ -40,9 +44,9 @@ pub impl proto_parser for parser::Parser {\n         let name = *self.interner.get(id);\n \n         self.expect(&token::COLON);\n-        let dir = match *self.token {\n-          token::IDENT(n, _) => self.interner.get(n),\n-          _ => fail!()\n+        let dir = match copy *self.token {\n+            token::IDENT(n, _) => self.interner.get(n),\n+            _ => fail!()\n         };\n         self.bump();\n         let dir = match dir {\n@@ -61,21 +65,29 @@ pub impl proto_parser for parser::Parser {\n \n         // parse the messages\n         self.parse_unspanned_seq(\n-            token::LBRACE, token::RBRACE, SeqSep {\n+            token::LBRACE,\n+            token::RBRACE,\n+            SeqSep {\n                 sep: Some(token::COMMA),\n-                trailing_sep_allowed: true\n-            }, |self| self.parse_message(state));\n+                trailing_sep_allowed: true,\n+            },\n+            |self| self.parse_message(state)\n+        );\n     }\n \n     fn parse_message(&self, state: state) {\n         let mname = *self.interner.get(self.parse_ident());\n \n         let args = if *self.token == token::LPAREN {\n-            self.parse_unspanned_seq(token::LPAREN,\n-                                     token::RPAREN, SeqSep {\n-                                        sep: Some(token::COMMA),\n-                                        trailing_sep_allowed: true\n-                                     }, |p| p.parse_ty(false))\n+            self.parse_unspanned_seq(\n+                token::LPAREN,\n+                token::RPAREN,\n+                SeqSep {\n+                    sep: Some(token::COMMA),\n+                    trailing_sep_allowed: true,\n+                },\n+                |p| p.parse_ty(false)\n+            )\n         }\n         else { ~[] };\n \n@@ -85,11 +97,15 @@ pub impl proto_parser for parser::Parser {\n           token::IDENT(_, _) => {\n             let name = *self.interner.get(self.parse_ident());\n             let ntys = if *self.token == token::LT {\n-                self.parse_unspanned_seq(token::LT,\n-                                         token::GT, SeqSep {\n-                                            sep: Some(token::COMMA),\n-                                            trailing_sep_allowed: true\n-                                         }, |p| p.parse_ty(false))\n+                self.parse_unspanned_seq(\n+                    token::LT,\n+                    token::GT,\n+                    SeqSep {\n+                        sep: Some(token::COMMA),\n+                        trailing_sep_allowed: true,\n+                    },\n+                    |p| p.parse_ty(false)\n+                )\n             }\n             else { ~[] };\n             Some(next_state {state: name, tys: ntys})"}, {"sha": "713bf9afcd0f06d53b16045c354476dae719925a", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bff22cf1665e98a1c3feb60e1c23fc30a4120934/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff22cf1665e98a1c3feb60e1c23fc30a4120934/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=bff22cf1665e98a1c3feb60e1c23fc30a4120934", "patch": "@@ -424,7 +424,7 @@ pub fn parse_nt(p: Parser, name: ~str) -> nonterminal {\n       ~\"ident\" => match *p.token {\n         token::IDENT(sn,b) => { p.bump(); token::nt_ident(sn,b) }\n         _ => p.fatal(~\"expected ident, found \"\n-                     + token::to_str(p.reader.interner(), *p.token))\n+                     + token::to_str(p.reader.interner(), copy *p.token))\n       },\n       ~\"path\" => token::nt_path(p.parse_path_with_tps(false)),\n       ~\"tt\" => {"}, {"sha": "d67596e100fa09ea145612e32354fbac4b73ba06", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bff22cf1665e98a1c3feb60e1c23fc30a4120934/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff22cf1665e98a1c3feb60e1c23fc30a4120934/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=bff22cf1665e98a1c3feb60e1c23fc30a4120934", "patch": "@@ -280,7 +280,7 @@ pub fn noop_fold_item_underscore(i: &item_, fld: ast_fold) -> item_ {\n         }\n         item_mac(ref m) => {\n             // FIXME #2888: we might actually want to do something here.\n-            item_mac((*m))\n+            item_mac(copy *m)\n         }\n     }\n }"}, {"sha": "785270625157a0228da5e64ce8844deae3efb414", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bff22cf1665e98a1c3feb60e1c23fc30a4120934/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff22cf1665e98a1c3feb60e1c23fc30a4120934/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=bff22cf1665e98a1c3feb60e1c23fc30a4120934", "patch": "@@ -27,13 +27,13 @@ pub struct SeqSep {\n     trailing_sep_allowed: bool\n }\n \n-pub fn seq_sep_trailing_disallowed(t: token::Token) -> SeqSep {\n+pub fn seq_sep_trailing_disallowed(+t: token::Token) -> SeqSep {\n     SeqSep {\n         sep: Some(t),\n         trailing_sep_allowed: false,\n     }\n }\n-pub fn seq_sep_trailing_allowed(t: token::Token) -> SeqSep {\n+pub fn seq_sep_trailing_allowed(+t: token::Token) -> SeqSep {\n     SeqSep {\n         sep: Some(t),\n         trailing_sep_allowed: true,"}, {"sha": "96ed81e476e7fea644e0c1bb64d302279f2efa84", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bff22cf1665e98a1c3feb60e1c23fc30a4120934/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff22cf1665e98a1c3feb60e1c23fc30a4120934/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=bff22cf1665e98a1c3feb60e1c23fc30a4120934", "patch": "@@ -198,7 +198,7 @@ pub impl Parser {\n \n     fn try_parse_obsolete_priv_section() -> bool {\n         if self.is_keyword(&~\"priv\") && self.look_ahead(1) == token::LBRACE {\n-            self.obsolete(*self.span, ObsoletePrivSection);\n+            self.obsolete(copy *self.span, ObsoletePrivSection);\n             self.eat_keyword(&~\"priv\");\n             self.bump();\n             while *self.token != token::RBRACE {"}, {"sha": "9fe53fe50e2d2ce03625e5a55cdb403384f4e41f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 42, "deletions": 35, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/bff22cf1665e98a1c3feb60e1c23fc30a4120934/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff22cf1665e98a1c3feb60e1c23fc30a4120934/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=bff22cf1665e98a1c3feb60e1c23fc30a4120934", "patch": "@@ -195,27 +195,26 @@ struct ParsedItemsAndViewItems {\n /* ident is handled by common.rs */\n \n pub fn Parser(sess: @mut ParseSess,\n-              cfg: ast::crate_cfg,\n+              +cfg: ast::crate_cfg,\n               +rdr: reader) -> Parser {\n \n-    let tok0 = rdr.next_token();\n-    let span0 = tok0.sp;\n+    let tok0 = copy rdr.next_token();\n     let interner = rdr.interner();\n \n     Parser {\n         reader: rdr,\n         interner: interner,\n         sess: sess,\n         cfg: cfg,\n-        token: @mut tok0.tok,\n-        span: @mut span0,\n-        last_span: @mut span0,\n-        buffer: @mut [TokenAndSpan {tok: tok0.tok, sp: span0}, ..4],\n+        token: @mut copy tok0.tok,\n+        span: @mut copy tok0.sp,\n+        last_span: @mut copy tok0.sp,\n+        buffer: @mut [copy tok0, .. 4],\n         buffer_start: @mut 0,\n         buffer_end: @mut 0,\n-        tokens_consumed: @mut 0u,\n+        tokens_consumed: @mut 0,\n         restriction: @mut UNRESTRICTED,\n-        quote_depth: @mut 0u,\n+        quote_depth: @mut 0,\n         keywords: token::keyword_table(),\n         strict_keywords: token::strict_keyword_table(),\n         reserved_keywords: token::reserved_keyword_table(),\n@@ -253,20 +252,20 @@ pub struct Parser {\n pub impl Parser {\n     // advance the parser by one token\n     fn bump() {\n-        *self.last_span = *self.span;\n+        *self.last_span = copy *self.span;\n         let next = if *self.buffer_start == *self.buffer_end {\n             self.reader.next_token()\n         } else {\n-            let next = self.buffer[*self.buffer_start];\n+            let next = copy self.buffer[*self.buffer_start];\n             *self.buffer_start = (*self.buffer_start + 1) & 3;\n             next\n         };\n-        *self.token = next.tok;\n-        *self.span = next.sp;\n+        *self.token = copy next.tok;\n+        *self.span = copy next.sp;\n         *self.tokens_consumed += 1u;\n     }\n     // EFFECT: replace the current token and span with the given one\n-    fn replace_token(next: token::Token, +lo: BytePos, +hi: BytePos) {\n+    fn replace_token(+next: token::Token, +lo: BytePos, +hi: BytePos) {\n         *self.token = next;\n         *self.span = mk_sp(lo, hi);\n     }\n@@ -461,7 +460,7 @@ pub impl Parser {\n             let hi = p.last_span.hi;\n             debug!(\"parse_trait_methods(): trait method signature ends in \\\n                     `%s`\",\n-                   token_to_str(p.reader, *p.token));\n+                   token_to_str(p.reader, copy *p.token));\n             match *p.token {\n               token::SEMI => {\n                 p.bump();\n@@ -499,8 +498,13 @@ pub impl Parser {\n                 })\n               }\n \n-              _ => { p.fatal(~\"expected `;` or `}` but found `\" +\n-                          token_to_str(p.reader, *p.token) + ~\"`\");\n+              _ => {\n+                    p.fatal(\n+                        fmt!(\n+                            \"expected `;` or `}` but found `%s`\",\n+                            token_to_str(p.reader, copy *p.token)\n+                        )\n+                    );\n                 }\n             }\n         }\n@@ -649,7 +653,7 @@ pub impl Parser {\n             self.parse_borrowed_pointee()\n         } else if self.eat_keyword(&~\"extern\") {\n             self.parse_ty_bare_fn()\n-        } else if self.token_is_closure_keyword(&*self.token) {\n+        } else if self.token_is_closure_keyword(&copy *self.token) {\n             self.parse_ty_closure(None, None)\n         } else if *self.token == token::MOD_SEP\n             || is_ident_or_path(*self.token) {\n@@ -681,7 +685,7 @@ pub impl Parser {\n                     self.bump();\n                     self.bump();\n                     return self.parse_ty_closure(Some(sigil), Some(rname));\n-                } else if self.token_is_closure_keyword(&*self.token) {\n+                } else if self.token_is_closure_keyword(&copy *self.token) {\n                     return self.parse_ty_closure(Some(sigil), None);\n                 }\n             }\n@@ -716,7 +720,7 @@ pub impl Parser {\n             _ => { None }\n         };\n \n-        if self.token_is_closure_keyword(&*self.token) {\n+        if self.token_is_closure_keyword(&copy *self.token) {\n             return self.parse_ty_closure(Some(BorrowedSigil), rname);\n         }\n \n@@ -841,9 +845,12 @@ pub impl Parser {\n                 }\n                 _ => {\n                     self.fatal(\n-                        fmt!(\"expected integral vector length \\\n-                              but found `%s`\",\n-                             token_to_str(self.reader, *self.token)));\n+                        fmt!(\n+                            \"expected integral vector length \\\n+                            but found `%s`\",\n+                            token_to_str(self.reader, copy *self.token)\n+                        )\n+                    );\n                 }\n             }\n         } else {\n@@ -873,7 +880,7 @@ pub impl Parser {\n             lit_bool(false)\n         } else {\n             // XXX: This is a really bad copy!\n-            let tok = *self.token;\n+            let tok = copy *self.token;\n             self.bump();\n             self.lit_from_token(tok)\n         };\n@@ -1063,7 +1070,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn mk_mac_expr(+lo: BytePos, +hi: BytePos, m: mac_) -> @expr {\n+    fn mk_mac_expr(+lo: BytePos, +hi: BytePos, +m: mac_) -> @expr {\n         @expr {\n             id: self.get_id(),\n             callee_id: self.get_id(),\n@@ -1391,7 +1398,7 @@ pub impl Parser {\n             self.bump();\n             (None, zerok)\n         } else {\n-            let sep = *self.token;\n+            let sep = copy *self.token;\n             self.bump();\n             if *self.token == token::BINOP(token::STAR)\n                 || *self.token == token::BINOP(token::PLUS) {\n@@ -1416,7 +1423,7 @@ pub impl Parser {\n                 p.fatal(\n                     fmt!(\n                         \"incorrect close delimiter: `%s`\",\n-                        token_to_str(p.reader, *p.token)\n+                        token_to_str(p.reader, copy *p.token)\n                     )\n                 );\n               }\n@@ -1912,7 +1919,7 @@ pub impl Parser {\n         // labeled loop headers look like 'loop foo: {'\n         let is_labeled_loop_header =\n             is_ident(*self.token)\n-            && !self.is_any_keyword(&*self.token)\n+            && !self.is_any_keyword(&copy *self.token)\n             && self.look_ahead(1) == token::COLON;\n \n         if is_loop_header || is_labeled_loop_header {\n@@ -2143,7 +2150,7 @@ pub impl Parser {\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n         let mut pat;\n-        match *self.token {\n+        match copy *self.token {\n           token::UNDERSCORE => { self.bump(); pat = pat_wild; }\n           token::AT => {\n             self.bump();\n@@ -2446,7 +2453,7 @@ pub impl Parser {\n             let decl = self.parse_let();\n             return @spanned(lo, decl.span.hi, stmt_decl(decl, self.get_id()));\n         } else if is_ident(*self.token)\n-            && !self.is_any_keyword(&*self.token)\n+            && !self.is_any_keyword(&copy *self.token)\n             && self.look_ahead(1) == token::NOT {\n \n             check_expected_item(self, first_item_attrs);\n@@ -2540,7 +2547,7 @@ pub impl Parser {\n \n         let lo = self.span.lo;\n         if self.eat_keyword(&~\"unsafe\") {\n-            self.obsolete(*self.span, ObsoleteUnsafeBlock);\n+            self.obsolete(copy *self.span, ObsoleteUnsafeBlock);\n         }\n         self.expect(&token::LBRACE);\n         let (inner, next) =\n@@ -3049,7 +3056,7 @@ pub impl Parser {\n             ty = self.parse_ty(false);\n             opt_trait_ref\n         } else if self.eat(&token::COLON) {\n-            self.obsolete(*self.span, ObsoleteImplSyntax);\n+            self.obsolete(copy *self.span, ObsoleteImplSyntax);\n             Some(self.parse_trait_ref())\n         } else {\n             None\n@@ -3116,7 +3123,7 @@ pub impl Parser {\n         self.parse_region_param();\n         let ty_params = self.parse_ty_params();\n         if self.eat(&token::COLON) {\n-            self.obsolete(*self.span, ObsoleteClassTraits);\n+            self.obsolete(copy *self.span, ObsoleteClassTraits);\n             let _ = self.parse_trait_ref_list(token::LBRACE);\n         }\n \n@@ -3948,7 +3955,7 @@ pub impl Parser {\n                 vis: visibility,\n                 span: mk_sp(lo, self.last_span.hi)\n             });\n-        } else if macros_allowed && !self.is_any_keyword(&*self.token)\n+        } else if macros_allowed && !self.is_any_keyword(&copy *self.token)\n                 && self.look_ahead(1) == token::NOT\n                 && (is_plain_ident(self.look_ahead(2))\n                     || self.look_ahead(2) == token::LPAREN\n@@ -4121,7 +4128,7 @@ pub impl Parser {\n     fn is_view_item() -> bool {\n         let tok, next_tok;\n         if !self.is_keyword(&~\"pub\") && !self.is_keyword(&~\"priv\") {\n-            tok = *self.token;\n+            tok = copy *self.token;\n             next_tok = self.look_ahead(1);\n         } else {\n             tok = self.look_ahead(1);"}]}