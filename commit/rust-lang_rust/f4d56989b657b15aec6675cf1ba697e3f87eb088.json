{"sha": "f4d56989b657b15aec6675cf1ba697e3f87eb088", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0ZDU2OTg5YjY1N2IxNWFlYzY2NzVjZjFiYTY5N2UzZjg3ZWIwODg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-02T16:43:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-02T16:43:16Z"}, "message": "Merge #8284\n\n8284: Reduce memory usage by using global `Arc`-based interning r=jonas-schievink a=jonas-schievink\n\nThis saves around 50 mb when running `analysis-stats` on r-a itself. Not a lot, but this infra can be easily reused to intern more stuff.\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "23e4d8265444257f2e4018a003659a711fde0414", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23e4d8265444257f2e4018a003659a711fde0414"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4d56989b657b15aec6675cf1ba697e3f87eb088", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgZ0mkCRBK7hj4Ov3rIwAAdHIIADdYN4usv1/ioWbNnFNjYkVw\nFVEADLi7NTQZ6j0XkPyfeQnv1tWoRZK13B1YYea2ADLT4NH0m0O9uRkZWnc2QzuY\n897CyeLjyNqp/hYNc3/JLBUdlDjkWvEkAODOerf6lXQ/oqgJ+9DwsC3oRoYu2X0H\nkoP92uffwxNRj6sZf2QAvOKji3a9m4hGvs5tOFsxAYJxrpSptwhF5SdiXaMwGQ7x\nx+jIp8kHPnY3R+1X1QdeHSGMoDd6VdGOYvwwR84lyjAAVSfpeQGZDfZV7y+FUzPh\ni5u33oK581gnBDK4NIFbQXuklPKGaAfGK5soUOF/yK5hq9XiEsxg5De52x5ychE=\n=AvBx\n-----END PGP SIGNATURE-----\n", "payload": "tree 23e4d8265444257f2e4018a003659a711fde0414\nparent 9bcdbefc7b657f34704439d068113180b14359dc\nparent 6e227b80a7686a7ea5bc039d54c307fda29c99ba\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1617381796 +0000\ncommitter GitHub <noreply@github.com> 1617381796 +0000\n\nMerge #8284\n\n8284: Reduce memory usage by using global `Arc`-based interning r=jonas-schievink a=jonas-schievink\n\nThis saves around 50 mb when running `analysis-stats` on r-a itself. Not a lot, but this infra can be easily reused to intern more stuff.\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4d56989b657b15aec6675cf1ba697e3f87eb088", "html_url": "https://github.com/rust-lang/rust/commit/f4d56989b657b15aec6675cf1ba697e3f87eb088", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4d56989b657b15aec6675cf1ba697e3f87eb088/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bcdbefc7b657f34704439d068113180b14359dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bcdbefc7b657f34704439d068113180b14359dc", "html_url": "https://github.com/rust-lang/rust/commit/9bcdbefc7b657f34704439d068113180b14359dc"}, {"sha": "6e227b80a7686a7ea5bc039d54c307fda29c99ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e227b80a7686a7ea5bc039d54c307fda29c99ba", "html_url": "https://github.com/rust-lang/rust/commit/6e227b80a7686a7ea5bc039d54c307fda29c99ba"}], "stats": {"total": 366, "additions": 230, "deletions": 136}, "files": [{"sha": "4344f8df5aa69aed33df1c4422d7f9500608cc94", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4d56989b657b15aec6675cf1ba697e3f87eb088/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f4d56989b657b15aec6675cf1ba697e3f87eb088/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f4d56989b657b15aec6675cf1ba697e3f87eb088", "patch": "@@ -500,6 +500,7 @@ dependencies = [\n  \"base_db\",\n  \"cfg\",\n  \"cov-mark\",\n+ \"dashmap\",\n  \"drop_bomb\",\n  \"either\",\n  \"expect-test\","}, {"sha": "ab04c55bc19e02498350bbc019599854eecbe4a2", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=f4d56989b657b15aec6675cf1ba697e3f87eb088", "patch": "@@ -91,7 +91,7 @@ impl HirDisplay for Function {\n         let ret_type = if !qual.is_async {\n             &data.ret_type\n         } else {\n-            match &data.ret_type {\n+            match &*data.ret_type {\n                 TypeRef::ImplTrait(bounds) => match &bounds[0] {\n                     TypeBound::Path(path) => {\n                         path.segments().iter().last().unwrap().args_and_bindings.unwrap().bindings"}, {"sha": "06fd6542d61c973d2601dee3f448e7bad9c82f3a", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=f4d56989b657b15aec6675cf1ba697e3f87eb088", "patch": "@@ -957,7 +957,7 @@ impl SelfParam {\n         func_data\n             .params\n             .first()\n-            .map(|param| match *param {\n+            .map(|param| match &**param {\n                 TypeRef::Reference(.., mutability) => match mutability {\n                     hir_def::type_ref::Mutability::Shared => Access::Shared,\n                     hir_def::type_ref::Mutability::Mut => Access::Exclusive,\n@@ -1011,7 +1011,7 @@ impl Const {\n     }\n \n     pub fn type_ref(self, db: &dyn HirDatabase) -> TypeRef {\n-        db.const_data(self.id).type_ref.clone()\n+        db.const_data(self.id).type_ref.as_ref().clone()\n     }\n }\n \n@@ -1101,7 +1101,7 @@ impl TypeAlias {\n     }\n \n     pub fn type_ref(self, db: &dyn HirDatabase) -> Option<TypeRef> {\n-        db.type_alias_data(self.id).type_ref.clone()\n+        db.type_alias_data(self.id).type_ref.as_deref().cloned()\n     }\n \n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n@@ -1615,7 +1615,7 @@ impl Impl {\n     // FIXME: the return type is wrong. This should be a hir version of\n     // `TraitRef` (ie, resolved `TypeRef`).\n     pub fn trait_(self, db: &dyn HirDatabase) -> Option<TraitRef> {\n-        db.impl_data(self.id).target_trait.clone()\n+        db.impl_data(self.id).target_trait.as_deref().cloned()\n     }\n \n     pub fn self_ty(self, db: &dyn HirDatabase) -> Type {"}, {"sha": "43324d8d9b160319a3c6c725383c429db3e12e5d", "filename": "crates/hir_def/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2FCargo.toml?ref=f4d56989b657b15aec6675cf1ba697e3f87eb088", "patch": "@@ -11,6 +11,7 @@ doctest = false\n \n [dependencies]\n cov-mark = { version = \"1.1\", features = [\"thread-local\"] }\n+dashmap = { version = \"4.0.2\", features = [\"raw-api\"] }\n log = \"0.4.8\"\n once_cell = \"1.3.1\"\n rustc-hash = \"1.1.0\""}, {"sha": "402fb1d8dc61fee6f8da3f7482dc574edcdc63ee", "filename": "crates/hir_def/src/adt.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fadt.rs?ref=f4d56989b657b15aec6675cf1ba697e3f87eb088", "patch": "@@ -15,6 +15,7 @@ use tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree};\n use crate::{\n     body::{CfgExpander, LowerCtx},\n     db::DefDatabase,\n+    intern::Interned,\n     item_tree::{AttrOwner, Field, Fields, ItemTree, ModItem, RawVisibilityId},\n     src::HasChildSource,\n     src::HasSource,\n@@ -58,7 +59,7 @@ pub enum VariantData {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct FieldData {\n     pub name: Name,\n-    pub type_ref: TypeRef,\n+    pub type_ref: Interned<TypeRef>,\n     pub visibility: RawVisibility,\n }\n \n@@ -292,7 +293,7 @@ fn lower_struct(\n                     || Either::Left(fd.clone()),\n                     || FieldData {\n                         name: Name::new_tuple_field(i),\n-                        type_ref: TypeRef::from_ast_opt(&ctx, fd.ty()),\n+                        type_ref: Interned::new(TypeRef::from_ast_opt(&ctx, fd.ty())),\n                         visibility: RawVisibility::from_ast(db, ast.with_value(fd.visibility())),\n                     },\n                 );\n@@ -309,7 +310,7 @@ fn lower_struct(\n                     || Either::Right(fd.clone()),\n                     || FieldData {\n                         name: fd.name().map(|n| n.as_name()).unwrap_or_else(Name::missing),\n-                        type_ref: TypeRef::from_ast_opt(&ctx, fd.ty()),\n+                        type_ref: Interned::new(TypeRef::from_ast_opt(&ctx, fd.ty())),\n                         visibility: RawVisibility::from_ast(db, ast.with_value(fd.visibility())),\n                     },\n                 );\n@@ -358,7 +359,7 @@ fn lower_field(\n ) -> FieldData {\n     FieldData {\n         name: field.name.clone(),\n-        type_ref: item_tree[field.type_ref].clone(),\n+        type_ref: field.type_ref.clone(),\n         visibility: item_tree[override_visibility.unwrap_or(field.visibility)].clone(),\n     }\n }"}, {"sha": "2bab121d993032fb06f3e071b6315adabfdaa65c", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=f4d56989b657b15aec6675cf1ba697e3f87eb088", "patch": "@@ -18,6 +18,7 @@ use tt::Subtree;\n \n use crate::{\n     db::DefDatabase,\n+    intern::Interned,\n     item_tree::{ItemTreeId, ItemTreeNode},\n     nameres::ModuleSource,\n     path::{ModPath, PathKind},\n@@ -98,7 +99,7 @@ impl RawAttrs {\n                 Either::Right(comment) => comment.doc_comment().map(|doc| Attr {\n                     index: i as u32,\n                     input: Some(AttrInput::Literal(SmolStr::new(doc))),\n-                    path: ModPath::from(hir_expand::name!(doc)),\n+                    path: Interned::new(ModPath::from(hir_expand::name!(doc))),\n                 }),\n             })\n             .collect::<Arc<_>>();\n@@ -510,7 +511,7 @@ impl AttrSourceMap {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Attr {\n     index: u32,\n-    pub(crate) path: ModPath,\n+    pub(crate) path: Interned<ModPath>,\n     pub(crate) input: Option<AttrInput>,\n }\n \n@@ -524,7 +525,7 @@ pub enum AttrInput {\n \n impl Attr {\n     fn from_src(ast: ast::Attr, hygiene: &Hygiene, index: u32) -> Option<Attr> {\n-        let path = ModPath::from_src(ast.path()?, hygiene)?;\n+        let path = Interned::new(ModPath::from_src(ast.path()?, hygiene)?);\n         let input = if let Some(ast::Expr::Literal(lit)) = ast.expr() {\n             let value = match lit.kind() {\n                 ast::LiteralKind::String(string) => string.value()?.into(),"}, {"sha": "31f994681960a893fc0a3759532937e9e4960696", "filename": "crates/hir_def/src/data.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdata.rs?ref=f4d56989b657b15aec6675cf1ba697e3f87eb088", "patch": "@@ -9,6 +9,7 @@ use crate::{\n     attr::Attrs,\n     body::Expander,\n     db::DefDatabase,\n+    intern::Interned,\n     item_tree::{AssocItem, FunctionQualifier, ItemTreeId, ModItem, Param},\n     type_ref::{TraitRef, TypeBound, TypeRef},\n     visibility::RawVisibility,\n@@ -19,8 +20,8 @@ use crate::{\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct FunctionData {\n     pub name: Name,\n-    pub params: Vec<TypeRef>,\n-    pub ret_type: TypeRef,\n+    pub params: Vec<Interned<TypeRef>>,\n+    pub ret_type: Interned<TypeRef>,\n     pub attrs: Attrs,\n     /// True if the first param is `self`. This is relevant to decide whether this\n     /// can be called as a method.\n@@ -57,11 +58,11 @@ impl FunctionData {\n             params: enabled_params\n                 .clone()\n                 .filter_map(|id| match &item_tree[id] {\n-                    Param::Normal(ty) => Some(item_tree[*ty].clone()),\n+                    Param::Normal(ty) => Some(ty.clone()),\n                     Param::Varargs => None,\n                 })\n                 .collect(),\n-            ret_type: item_tree[func.ret_type].clone(),\n+            ret_type: func.ret_type.clone(),\n             attrs: item_tree.attrs(db, krate, ModItem::from(loc.id.value).into()),\n             has_self_param: func.has_self_param,\n             has_body: func.has_body,\n@@ -76,7 +77,7 @@ impl FunctionData {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct TypeAliasData {\n     pub name: Name,\n-    pub type_ref: Option<TypeRef>,\n+    pub type_ref: Option<Interned<TypeRef>>,\n     pub visibility: RawVisibility,\n     pub is_extern: bool,\n     /// Bounds restricting the type alias itself (eg. `type Ty: Bound;` in a trait or impl).\n@@ -94,7 +95,7 @@ impl TypeAliasData {\n \n         Arc::new(TypeAliasData {\n             name: typ.name.clone(),\n-            type_ref: typ.type_ref.map(|id| item_tree[id].clone()),\n+            type_ref: typ.type_ref.clone(),\n             visibility: item_tree[typ.visibility].clone(),\n             is_extern: typ.is_extern,\n             bounds: typ.bounds.to_vec(),\n@@ -156,8 +157,8 @@ impl TraitData {\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ImplData {\n-    pub target_trait: Option<TraitRef>,\n-    pub self_ty: TypeRef,\n+    pub target_trait: Option<Interned<TraitRef>>,\n+    pub self_ty: Interned<TypeRef>,\n     pub items: Vec<AssocItemId>,\n     pub is_negative: bool,\n }\n@@ -169,8 +170,8 @@ impl ImplData {\n \n         let item_tree = impl_loc.id.item_tree(db);\n         let impl_def = &item_tree[impl_loc.id.value];\n-        let target_trait = impl_def.target_trait.map(|id| item_tree[id].clone());\n-        let self_ty = item_tree[impl_def.self_ty].clone();\n+        let target_trait = impl_def.target_trait.clone();\n+        let self_ty = impl_def.self_ty.clone();\n         let is_negative = impl_def.is_negative;\n         let module_id = impl_loc.container;\n         let container = AssocContainerId::ImplId(id);\n@@ -195,7 +196,7 @@ impl ImplData {\n pub struct ConstData {\n     /// const _: () = ();\n     pub name: Option<Name>,\n-    pub type_ref: TypeRef,\n+    pub type_ref: Interned<TypeRef>,\n     pub visibility: RawVisibility,\n }\n \n@@ -207,7 +208,7 @@ impl ConstData {\n \n         Arc::new(ConstData {\n             name: konst.name.clone(),\n-            type_ref: item_tree[konst.type_ref].clone(),\n+            type_ref: konst.type_ref.clone(),\n             visibility: item_tree[konst.visibility].clone(),\n         })\n     }\n@@ -216,7 +217,7 @@ impl ConstData {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct StaticData {\n     pub name: Option<Name>,\n-    pub type_ref: TypeRef,\n+    pub type_ref: Interned<TypeRef>,\n     pub visibility: RawVisibility,\n     pub mutable: bool,\n     pub is_extern: bool,\n@@ -230,7 +231,7 @@ impl StaticData {\n \n         Arc::new(StaticData {\n             name: Some(statik.name.clone()),\n-            type_ref: item_tree[statik.type_ref].clone(),\n+            type_ref: statik.type_ref.clone(),\n             visibility: item_tree[statik.visibility].clone(),\n             mutable: statik.mutable,\n             is_extern: statik.is_extern,"}, {"sha": "cc0b5d3503916ae471c80737288476252a380972", "filename": "crates/hir_def/src/intern.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2Fsrc%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2Fsrc%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fintern.rs?ref=f4d56989b657b15aec6675cf1ba697e3f87eb088", "patch": "@@ -0,0 +1,163 @@\n+//! Global `Arc`-based object interning infrastructure.\n+//!\n+//! Eventually this should probably be replaced with salsa-based interning.\n+\n+use std::{\n+    fmt::{self, Debug},\n+    hash::{BuildHasherDefault, Hash},\n+    ops::Deref,\n+    sync::Arc,\n+};\n+\n+use dashmap::{DashMap, SharedValue};\n+use once_cell::sync::OnceCell;\n+use rustc_hash::FxHasher;\n+\n+type InternMap<T> = DashMap<Arc<T>, (), BuildHasherDefault<FxHasher>>;\n+\n+#[derive(Hash)]\n+pub struct Interned<T: Internable + ?Sized> {\n+    arc: Arc<T>,\n+}\n+\n+impl<T: Internable> Interned<T> {\n+    pub fn new(obj: T) -> Self {\n+        let storage = T::storage().get();\n+        let shard_idx = storage.determine_map(&obj);\n+        let shard = &storage.shards()[shard_idx];\n+        let shard = shard.upgradeable_read();\n+\n+        // Atomically,\n+        // - check if `obj` is already in the map\n+        //   - if so, clone its `Arc` and return it\n+        //   - if not, box it up, insert it, and return a clone\n+        // This needs to be atomic (locking the shard) to avoid races with other thread, which could\n+        // insert the same object between us looking it up and inserting it.\n+\n+        // FIXME: avoid double lookup by using raw entry API (once stable, or when hashbrown can be\n+        // plugged into dashmap)\n+        if let Some((arc, _)) = shard.get_key_value(&obj) {\n+            return Self { arc: arc.clone() };\n+        }\n+\n+        let arc = Arc::new(obj);\n+        let arc2 = arc.clone();\n+\n+        {\n+            let mut shard = shard.upgrade();\n+            shard.insert(arc2, SharedValue::new(()));\n+        }\n+\n+        Self { arc }\n+    }\n+}\n+\n+impl<T: Internable + ?Sized> Drop for Interned<T> {\n+    #[inline]\n+    fn drop(&mut self) {\n+        // When the last `Ref` is dropped, remove the object from the global map.\n+        if Arc::strong_count(&self.arc) == 2 {\n+            // Only `self` and the global map point to the object.\n+\n+            self.drop_slow();\n+        }\n+    }\n+}\n+\n+impl<T: Internable + ?Sized> Interned<T> {\n+    #[cold]\n+    fn drop_slow(&mut self) {\n+        let storage = T::storage().get();\n+        let shard_idx = storage.determine_map(&self.arc);\n+        let shard = &storage.shards()[shard_idx];\n+        let mut shard = shard.write();\n+\n+        // FIXME: avoid double lookup\n+        let (arc, _) = shard.get_key_value(&self.arc).expect(\"interned value removed prematurely\");\n+\n+        if Arc::strong_count(arc) != 2 {\n+            // Another thread has interned another copy\n+            return;\n+        }\n+\n+        shard.remove(&self.arc);\n+\n+        // Shrink the backing storage if the shard is less than 50% occupied.\n+        if shard.len() * 2 < shard.capacity() {\n+            shard.shrink_to_fit();\n+        }\n+    }\n+}\n+\n+/// Compares interned `Ref`s using pointer equality.\n+impl<T: Internable> PartialEq for Interned<T> {\n+    // NOTE: No `?Sized` because `ptr_eq` doesn't work right with trait objects.\n+\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        Arc::ptr_eq(&self.arc, &other.arc)\n+    }\n+}\n+\n+impl<T: Internable> Eq for Interned<T> {}\n+\n+impl<T: Internable + ?Sized> AsRef<T> for Interned<T> {\n+    #[inline]\n+    fn as_ref(&self) -> &T {\n+        &self.arc\n+    }\n+}\n+\n+impl<T: Internable + ?Sized> Deref for Interned<T> {\n+    type Target = T;\n+\n+    #[inline]\n+    fn deref(&self) -> &Self::Target {\n+        &self.arc\n+    }\n+}\n+\n+impl<T: Internable + ?Sized> Clone for Interned<T> {\n+    fn clone(&self) -> Self {\n+        Self { arc: self.arc.clone() }\n+    }\n+}\n+\n+impl<T: Debug + Internable + ?Sized> Debug for Interned<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        (*self.arc).fmt(f)\n+    }\n+}\n+\n+pub struct InternStorage<T: ?Sized> {\n+    map: OnceCell<InternMap<T>>,\n+}\n+\n+impl<T: ?Sized> InternStorage<T> {\n+    pub const fn new() -> Self {\n+        Self { map: OnceCell::new() }\n+    }\n+}\n+\n+impl<T: Internable + ?Sized> InternStorage<T> {\n+    fn get(&self) -> &InternMap<T> {\n+        self.map.get_or_init(DashMap::default)\n+    }\n+}\n+\n+pub trait Internable: Hash + Eq + 'static {\n+    fn storage() -> &'static InternStorage<Self>;\n+}\n+\n+macro_rules! impl_internable {\n+    ( $($t:path),+ $(,)? ) => { $(\n+        impl Internable for $t {\n+            fn storage() -> &'static InternStorage<Self> {\n+                static STORAGE: InternStorage<$t> = InternStorage::new();\n+                &STORAGE\n+            }\n+        }\n+    )+ };\n+}\n+\n+impl_internable!(crate::type_ref::TypeRef, crate::type_ref::TraitRef, crate::path::ModPath);"}, {"sha": "69a313c7e2d44cb8146aacb70959e13800857a55", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 10, "deletions": 84, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=f4d56989b657b15aec6675cf1ba697e3f87eb088", "patch": "@@ -30,6 +30,7 @@ use crate::{\n     attr::{Attrs, RawAttrs},\n     db::DefDatabase,\n     generics::GenericParams,\n+    intern::Interned,\n     path::{path, AssociatedTypeBinding, GenericArgs, ImportAlias, ModPath, Path, PathKind},\n     type_ref::{Mutability, TraitRef, TypeBound, TypeRef},\n     visibility::RawVisibility,\n@@ -146,8 +147,6 @@ impl ItemTree {\n                 macro_defs,\n                 vis,\n                 generics,\n-                type_refs,\n-                trait_refs,\n                 inner_items,\n             } = &mut **data;\n \n@@ -172,9 +171,6 @@ impl ItemTree {\n \n             vis.arena.shrink_to_fit();\n             generics.arena.shrink_to_fit();\n-            type_refs.arena.shrink_to_fit();\n-            type_refs.map.shrink_to_fit();\n-            trait_refs.map.shrink_to_fit();\n \n             inner_items.shrink_to_fit();\n         }\n@@ -271,58 +267,6 @@ static EMPTY_GENERICS: GenericParams = GenericParams {\n     where_predicates: Vec::new(),\n };\n \n-/// `TypeRef` interner.\n-#[derive(Default, Debug, Eq, PartialEq)]\n-struct TypeRefStorage {\n-    arena: Arena<Arc<TypeRef>>,\n-    map: FxHashMap<Arc<TypeRef>, Idx<Arc<TypeRef>>>,\n-}\n-\n-impl TypeRefStorage {\n-    // Note: We lie about the `Idx<TypeRef>` to hide the interner details.\n-\n-    fn intern(&mut self, ty: TypeRef) -> Idx<TypeRef> {\n-        if let Some(id) = self.map.get(&ty) {\n-            return Idx::from_raw(id.into_raw());\n-        }\n-\n-        let ty = Arc::new(ty);\n-        let idx = self.arena.alloc(ty.clone());\n-        self.map.insert(ty, idx);\n-        Idx::from_raw(idx.into_raw())\n-    }\n-\n-    fn lookup(&self, id: Idx<TypeRef>) -> &TypeRef {\n-        &self.arena[Idx::from_raw(id.into_raw())]\n-    }\n-}\n-\n-/// `TraitRef` interner.\n-#[derive(Default, Debug, Eq, PartialEq)]\n-struct TraitRefStorage {\n-    arena: Arena<Arc<TraitRef>>,\n-    map: FxHashMap<Arc<TraitRef>, Idx<Arc<TraitRef>>>,\n-}\n-\n-impl TraitRefStorage {\n-    // Note: We lie about the `Idx<TraitRef>` to hide the interner details.\n-\n-    fn intern(&mut self, ty: TraitRef) -> Idx<TraitRef> {\n-        if let Some(id) = self.map.get(&ty) {\n-            return Idx::from_raw(id.into_raw());\n-        }\n-\n-        let ty = Arc::new(ty);\n-        let idx = self.arena.alloc(ty.clone());\n-        self.map.insert(ty, idx);\n-        Idx::from_raw(idx.into_raw())\n-    }\n-\n-    fn lookup(&self, id: Idx<TraitRef>) -> &TraitRef {\n-        &self.arena[Idx::from_raw(id.into_raw())]\n-    }\n-}\n-\n #[derive(Default, Debug, Eq, PartialEq)]\n struct ItemTreeData {\n     imports: Arena<Import>,\n@@ -346,8 +290,6 @@ struct ItemTreeData {\n \n     vis: ItemVisibilities,\n     generics: GenericParamsStorage,\n-    type_refs: TypeRefStorage,\n-    trait_refs: TraitRefStorage,\n \n     inner_items: FxHashMap<FileAstId<ast::BlockExpr>, SmallVec<[ModItem; 1]>>,\n }\n@@ -577,22 +519,6 @@ impl Index<GenericParamsId> for ItemTree {\n     }\n }\n \n-impl Index<Idx<TypeRef>> for ItemTree {\n-    type Output = TypeRef;\n-\n-    fn index(&self, id: Idx<TypeRef>) -> &Self::Output {\n-        self.data().type_refs.lookup(id)\n-    }\n-}\n-\n-impl Index<Idx<TraitRef>> for ItemTree {\n-    type Output = TraitRef;\n-\n-    fn index(&self, id: Idx<TraitRef>) -> &Self::Output {\n-        self.data().trait_refs.lookup(id)\n-    }\n-}\n-\n impl<N: ItemTreeNode> Index<FileItemTreeId<N>> for ItemTree {\n     type Output = N;\n     fn index(&self, id: FileItemTreeId<N>) -> &N {\n@@ -637,13 +563,13 @@ pub struct Function {\n     /// `extern \"abi\" fn`).\n     pub is_in_extern_block: bool,\n     pub params: IdRange<Param>,\n-    pub ret_type: Idx<TypeRef>,\n+    pub ret_type: Interned<TypeRef>,\n     pub ast_id: FileAstId<ast::Fn>,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Param {\n-    Normal(Idx<TypeRef>),\n+    Normal(Interned<TypeRef>),\n     Varargs,\n }\n \n@@ -699,7 +625,7 @@ pub struct Const {\n     /// const _: () = ();\n     pub name: Option<Name>,\n     pub visibility: RawVisibilityId,\n-    pub type_ref: Idx<TypeRef>,\n+    pub type_ref: Interned<TypeRef>,\n     pub ast_id: FileAstId<ast::Const>,\n }\n \n@@ -710,7 +636,7 @@ pub struct Static {\n     pub mutable: bool,\n     /// Whether the static is in an `extern` block.\n     pub is_extern: bool,\n-    pub type_ref: Idx<TypeRef>,\n+    pub type_ref: Interned<TypeRef>,\n     pub ast_id: FileAstId<ast::Static>,\n }\n \n@@ -729,8 +655,8 @@ pub struct Trait {\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct Impl {\n     pub generic_params: GenericParamsId,\n-    pub target_trait: Option<Idx<TraitRef>>,\n-    pub self_ty: Idx<TypeRef>,\n+    pub target_trait: Option<Interned<TraitRef>>,\n+    pub self_ty: Interned<TypeRef>,\n     pub is_negative: bool,\n     pub items: Box<[AssocItem]>,\n     pub ast_id: FileAstId<ast::Impl>,\n@@ -743,7 +669,7 @@ pub struct TypeAlias {\n     /// Bounds on the type alias itself. Only valid in trait declarations, eg. `type Assoc: Copy;`.\n     pub bounds: Box<[TypeBound]>,\n     pub generic_params: GenericParamsId,\n-    pub type_ref: Option<Idx<TypeRef>>,\n+    pub type_ref: Option<Interned<TypeRef>>,\n     pub is_extern: bool,\n     pub ast_id: FileAstId<ast::TypeAlias>,\n }\n@@ -768,7 +694,7 @@ pub enum ModKind {\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct MacroCall {\n     /// Path to the called macro.\n-    pub path: ModPath,\n+    pub path: Interned<ModPath>,\n     pub ast_id: FileAstId<ast::MacroCall>,\n }\n \n@@ -933,6 +859,6 @@ pub enum Fields {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Field {\n     pub name: Name,\n-    pub type_ref: Idx<TypeRef>,\n+    pub type_ref: Interned<TypeRef>,\n     pub visibility: RawVisibilityId,\n }"}, {"sha": "5247379c58c4a66be55a28ca2b03c65a6888f2c4", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=f4d56989b657b15aec6675cf1ba697e3f87eb088", "patch": "@@ -362,7 +362,7 @@ impl Ctx {\n                         }\n                     }\n                 };\n-                let ty = self.data().type_refs.intern(self_type);\n+                let ty = Interned::new(self_type);\n                 let idx = self.data().params.alloc(Param::Normal(ty));\n                 self.add_attrs(idx.into(), RawAttrs::new(&self_param, &self.hygiene));\n                 has_self_param = true;\n@@ -372,7 +372,7 @@ impl Ctx {\n                     Some(_) => self.data().params.alloc(Param::Varargs),\n                     None => {\n                         let type_ref = TypeRef::from_ast_opt(&self.body_ctx, param.ty());\n-                        let ty = self.data().type_refs.intern(type_ref);\n+                        let ty = Interned::new(type_ref);\n                         self.data().params.alloc(Param::Normal(ty))\n                     }\n                 };\n@@ -395,8 +395,6 @@ impl Ctx {\n             ret_type\n         };\n \n-        let ret_type = self.data().type_refs.intern(ret_type);\n-\n         let has_body = func.body().is_some();\n \n         let ast_id = self.source_ast_id_map.ast_id(func);\n@@ -428,7 +426,7 @@ impl Ctx {\n             qualifier,\n             is_in_extern_block: false,\n             params,\n-            ret_type,\n+            ret_type: Interned::new(ret_type),\n             ast_id,\n         };\n         res.generic_params = self.lower_generic_params(GenericsOwner::Function(&res), func);\n@@ -608,7 +606,7 @@ impl Ctx {\n     }\n \n     fn lower_macro_call(&mut self, m: &ast::MacroCall) -> Option<FileItemTreeId<MacroCall>> {\n-        let path = ModPath::from_src(m.path()?, &self.hygiene)?;\n+        let path = Interned::new(ModPath::from_src(m.path()?, &self.hygiene)?);\n         let ast_id = self.source_ast_id_map.ast_id(m);\n         let res = MacroCall { path, ast_id };\n         Some(id(self.data().macro_calls.alloc(res)))\n@@ -694,8 +692,7 @@ impl Ctx {\n                 generics.fill(&self.body_ctx, sm, node);\n                 // lower `impl Trait` in arguments\n                 for id in func.params.clone() {\n-                    if let Param::Normal(ty) = self.data().params[id] {\n-                        let ty = self.data().type_refs.lookup(ty);\n+                    if let Param::Normal(ty) = &self.data().params[id] {\n                         generics.fill_implicit_impl_trait_args(ty);\n                     }\n                 }\n@@ -749,20 +746,20 @@ impl Ctx {\n         self.data().vis.alloc(vis)\n     }\n \n-    fn lower_trait_ref(&mut self, trait_ref: &ast::Type) -> Option<Idx<TraitRef>> {\n+    fn lower_trait_ref(&mut self, trait_ref: &ast::Type) -> Option<Interned<TraitRef>> {\n         let trait_ref = TraitRef::from_ast(&self.body_ctx, trait_ref.clone())?;\n-        Some(self.data().trait_refs.intern(trait_ref))\n+        Some(Interned::new(trait_ref))\n     }\n \n-    fn lower_type_ref(&mut self, type_ref: &ast::Type) -> Idx<TypeRef> {\n+    fn lower_type_ref(&mut self, type_ref: &ast::Type) -> Interned<TypeRef> {\n         let tyref = TypeRef::from_ast(&self.body_ctx, type_ref.clone());\n-        self.data().type_refs.intern(tyref)\n+        Interned::new(tyref)\n     }\n \n-    fn lower_type_ref_opt(&mut self, type_ref: Option<ast::Type>) -> Idx<TypeRef> {\n+    fn lower_type_ref_opt(&mut self, type_ref: Option<ast::Type>) -> Interned<TypeRef> {\n         match type_ref.map(|ty| self.lower_type_ref(&ty)) {\n             Some(it) => it,\n-            None => self.data().type_refs.intern(TypeRef::Error),\n+            None => Interned::new(TypeRef::Error),\n         }\n     }\n "}, {"sha": "f408e510ad24694f5a3db32c7f3fe47a0b06e519", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=f4d56989b657b15aec6675cf1ba697e3f87eb088", "patch": "@@ -49,6 +49,7 @@ pub mod import_map;\n \n #[cfg(test)]\n mod test_db;\n+mod intern;\n \n use std::{\n     hash::{Hash, Hasher},"}, {"sha": "5badefabf5786bbfc492096bdff9365ef5df783e", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=f4d56989b657b15aec6675cf1ba697e3f87eb088", "patch": "@@ -1464,7 +1464,7 @@ impl ModCollector<'_, '_> {\n     }\n \n     fn collect_macro_call(&mut self, mac: &MacroCall) {\n-        let mut ast_id = AstIdWithPath::new(self.file_id, mac.ast_id, mac.path.clone());\n+        let mut ast_id = AstIdWithPath::new(self.file_id, mac.ast_id, (*mac.path).clone());\n \n         // Case 1: try to resolve in legacy scope and expand macro_rules\n         let mut error = None;"}, {"sha": "a3e83e2cf1e8953231a0b8829e1ca163b236890a", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=f4d56989b657b15aec6675cf1ba697e3f87eb088", "patch": "@@ -7,7 +7,7 @@ use std::{\n     sync::Arc,\n };\n \n-use crate::{body::LowerCtx, type_ref::LifetimeRef};\n+use crate::{body::LowerCtx, intern::Interned, type_ref::LifetimeRef};\n use base_db::CrateId;\n use hir_expand::{\n     hygiene::Hygiene,\n@@ -48,7 +48,7 @@ pub enum ImportAlias {\n \n impl ModPath {\n     pub fn from_src(path: ast::Path, hygiene: &Hygiene) -> Option<ModPath> {\n-        lower::lower_path(path, hygiene).map(|it| it.mod_path)\n+        lower::lower_path(path, hygiene).map(|it| (*it.mod_path).clone())\n     }\n \n     pub fn from_segments(kind: PathKind, segments: impl IntoIterator<Item = Name>) -> ModPath {\n@@ -123,7 +123,7 @@ pub struct Path {\n     /// Type based path like `<T>::foo`.\n     /// Note that paths like `<Type as Trait>::foo` are desugard to `Trait::<Self=Type>::foo`.\n     type_anchor: Option<Box<TypeRef>>,\n-    mod_path: ModPath,\n+    mod_path: Interned<ModPath>,\n     /// Invariant: the same len as `self.mod_path.segments`\n     generic_args: Vec<Option<Arc<GenericArgs>>>,\n }\n@@ -176,7 +176,7 @@ impl Path {\n         path: ModPath,\n         generic_args: Vec<Option<Arc<GenericArgs>>>,\n     ) -> Path {\n-        Path { type_anchor: None, mod_path: path, generic_args }\n+        Path { type_anchor: None, mod_path: Interned::new(path), generic_args }\n     }\n \n     pub fn kind(&self) -> &PathKind {\n@@ -204,10 +204,10 @@ impl Path {\n         }\n         let res = Path {\n             type_anchor: self.type_anchor.clone(),\n-            mod_path: ModPath::from_segments(\n+            mod_path: Interned::new(ModPath::from_segments(\n                 self.mod_path.kind.clone(),\n                 self.mod_path.segments[..self.mod_path.segments.len() - 1].iter().cloned(),\n-            ),\n+            )),\n             generic_args: self.generic_args[..self.generic_args.len() - 1].to_vec(),\n         };\n         Some(res)\n@@ -283,7 +283,7 @@ impl From<Name> for Path {\n     fn from(name: Name) -> Path {\n         Path {\n             type_anchor: None,\n-            mod_path: ModPath::from_segments(PathKind::Plain, iter::once(name)),\n+            mod_path: Interned::new(ModPath::from_segments(PathKind::Plain, iter::once(name))),\n             generic_args: vec![None],\n         }\n     }"}, {"sha": "28f6244da199634dcfc60ccf01cc6649c9bfe260", "filename": "crates/hir_def/src/path/lower.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs?ref=f4d56989b657b15aec6675cf1ba697e3f87eb088", "patch": "@@ -2,6 +2,7 @@\n \n mod lower_use;\n \n+use crate::intern::Interned;\n use std::sync::Arc;\n \n use either::Either;\n@@ -74,10 +75,11 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n                     // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n                     Some(trait_ref) => {\n                         let path = Path::from_src(trait_ref.path()?, hygiene)?;\n+                        let mod_path = (*path.mod_path).clone();\n                         let num_segments = path.mod_path.segments.len();\n-                        kind = path.mod_path.kind;\n+                        kind = mod_path.kind;\n \n-                        let mut prefix_segments = path.mod_path.segments;\n+                        let mut prefix_segments = mod_path.segments;\n                         prefix_segments.reverse();\n                         segments.extend(prefix_segments);\n \n@@ -140,7 +142,7 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n         }\n     }\n \n-    let mod_path = ModPath::from_segments(kind, segments);\n+    let mod_path = Interned::new(ModPath::from_segments(kind, segments));\n     return Some(Path { type_anchor, mod_path, generic_args });\n \n     fn qualifier(path: &ast::Path) -> Option<ast::Path> {"}, {"sha": "72ee060e085ee2c1c52a076229db786ce3ce0ce0", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4d56989b657b15aec6675cf1ba697e3f87eb088/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=f4d56989b657b15aec6675cf1ba697e3f87eb088", "patch": "@@ -1154,7 +1154,7 @@ fn type_for_type_alias(db: &dyn HirDatabase, t: TypeAliasId) -> Binders<Ty> {\n         Binders::new(0, TyKind::ForeignType(crate::to_foreign_def_id(t)).intern(&Interner))\n     } else {\n         let type_ref = &db.type_alias_data(t).type_ref;\n-        let inner = ctx.lower_ty(type_ref.as_ref().unwrap_or(&TypeRef::Error));\n+        let inner = ctx.lower_ty(type_ref.as_deref().unwrap_or(&TypeRef::Error));\n         Binders::new(generics.len(), inner)\n     }\n }"}]}