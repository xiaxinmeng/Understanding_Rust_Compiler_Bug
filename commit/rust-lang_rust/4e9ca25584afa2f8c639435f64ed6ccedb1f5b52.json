{"sha": "4e9ca25584afa2f8c639435f64ed6ccedb1f5b52", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlOWNhMjU1ODRhZmEyZjhjNjM5NDM1ZjY0ZWQ2Y2NlZGIxZjViNTI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-07-03T09:09:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-03T09:09:20Z"}, "message": "Merge pull request #1067 from Manishearth/pr-991\n\nRebase #991", "tree": {"sha": "477b377d93655c2554eb558b2d231ba8bdcad438", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/477b377d93655c2554eb558b2d231ba8bdcad438"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e9ca25584afa2f8c639435f64ed6ccedb1f5b52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e9ca25584afa2f8c639435f64ed6ccedb1f5b52", "html_url": "https://github.com/rust-lang/rust/commit/4e9ca25584afa2f8c639435f64ed6ccedb1f5b52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e9ca25584afa2f8c639435f64ed6ccedb1f5b52/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d243d686fd9dd717d7293429e2bf53fe84d76f14", "url": "https://api.github.com/repos/rust-lang/rust/commits/d243d686fd9dd717d7293429e2bf53fe84d76f14", "html_url": "https://github.com/rust-lang/rust/commit/d243d686fd9dd717d7293429e2bf53fe84d76f14"}, {"sha": "31948c481524247ddfe3dd600c51b0f501891414", "url": "https://api.github.com/repos/rust-lang/rust/commits/31948c481524247ddfe3dd600c51b0f501891414", "html_url": "https://github.com/rust-lang/rust/commit/31948c481524247ddfe3dd600c51b0f501891414"}], "stats": {"total": 212, "additions": 194, "deletions": 18}, "files": [{"sha": "ae316a90b05a144994bd78492e38710c065333ee", "filename": "CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e9ca25584afa2f8c639435f64ed6ccedb1f5b52/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e9ca25584afa2f8c639435f64ed6ccedb1f5b52/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=4e9ca25584afa2f8c639435f64ed6ccedb1f5b52", "patch": "@@ -15,6 +15,7 @@ All notable changes to this project will be documented in this file.\n ## 0.0.76 \u2014 2016-06-10\n * Rustup to *rustc 1.11.0-nightly (7d2f75a95 2016-06-09)*\n * `cargo clippy` now automatically defines the `clippy` feature\n+* New lint: [`not_unsafe_ptr_arg_deref`]\n \n ## 0.0.75 \u2014 2016-06-08\n * Rustup to *rustc 1.11.0-nightly (763f9234b 2016-06-06)*\n@@ -220,6 +221,7 @@ All notable changes to this project will be documented in this file.\n [`non_ascii_literal`]: https://github.com/Manishearth/rust-clippy/wiki#non_ascii_literal\n [`nonminimal_bool`]: https://github.com/Manishearth/rust-clippy/wiki#nonminimal_bool\n [`nonsensical_open_options`]: https://github.com/Manishearth/rust-clippy/wiki#nonsensical_open_options\n+[`not_unsafe_ptr_arg_deref`]: https://github.com/Manishearth/rust-clippy/wiki#not_unsafe_ptr_arg_deref\n [`ok_expect`]: https://github.com/Manishearth/rust-clippy/wiki#ok_expect\n [`option_map_unwrap_or`]: https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or\n [`option_map_unwrap_or_else`]: https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or_else"}, {"sha": "3159a3e8979c8219320cb904b932bf1e904ad7e9", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e9ca25584afa2f8c639435f64ed6ccedb1f5b52/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e9ca25584afa2f8c639435f64ed6ccedb1f5b52/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=4e9ca25584afa2f8c639435f64ed6ccedb1f5b52", "patch": "@@ -17,7 +17,7 @@ Table of contents:\n \n ## Lints\n \n-There are 157 lints included in this crate:\n+There are 158 lints included in this crate:\n \n name                                                                                                                 | default | meaning\n ---------------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -115,6 +115,7 @@ name\n [non_ascii_literal](https://github.com/Manishearth/rust-clippy/wiki#non_ascii_literal)                               | allow   | using any literal non-ASCII chars in a string literal; suggests using the \\\\u escape instead\n [nonminimal_bool](https://github.com/Manishearth/rust-clippy/wiki#nonminimal_bool)                                   | allow   | checks for boolean expressions that can be written more concisely\n [nonsensical_open_options](https://github.com/Manishearth/rust-clippy/wiki#nonsensical_open_options)                 | warn    | nonsensical combination of options for opening a file\n+[not_unsafe_ptr_arg_deref](https://github.com/Manishearth/rust-clippy/wiki#not_unsafe_ptr_arg_deref)                 | warn    | public functions dereferencing raw pointer arguments but not marked `unsafe`\n [ok_expect](https://github.com/Manishearth/rust-clippy/wiki#ok_expect)                                               | warn    | using `ok().expect()`, which gives worse error messages than calling `expect` directly on the Result\n [option_map_unwrap_or](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or)                         | warn    | using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as `map_or(a, f)`\n [option_map_unwrap_or_else](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or_else)               | warn    | using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as `map_or_else(g, f)`"}, {"sha": "0dec4e94c0b87d46903d0aaefc384b9ca9f64c55", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 124, "deletions": 15, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/4e9ca25584afa2f8c639435f64ed6ccedb1f5b52/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9ca25584afa2f8c639435f64ed6ccedb1f5b52/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=4e9ca25584afa2f8c639435f64ed6ccedb1f5b52", "patch": "@@ -1,9 +1,11 @@\n-use rustc::lint::*;\n-use rustc::hir;\n use rustc::hir::intravisit;\n+use rustc::hir;\n+use rustc::ty;\n+use rustc::lint::*;\n+use std::collections::HashSet;\n use syntax::ast;\n use syntax::codemap::Span;\n-use utils::span_lint;\n+use utils::{span_lint, type_is_unsafe_function};\n \n /// **What it does:** Check for functions with too many parameters.\n ///\n@@ -15,7 +17,7 @@ use utils::span_lint;\n ///\n /// **Example:**\n ///\n-/// ```\n+/// ```rust\n /// fn foo(x: u32, y: u32, name: &str, c: Color, w: f32, h: f32, a: f32, b: f32) { .. }\n /// ```\n declare_lint! {\n@@ -24,6 +26,30 @@ declare_lint! {\n     \"functions with too many arguments\"\n }\n \n+/// **What it does:** Check for public functions that dereferences raw pointer arguments but are\n+/// not marked unsafe.\n+///\n+/// **Why is this bad?** The function should probably be marked `unsafe`, since for an arbitrary\n+/// raw pointer, there is no way of telling for sure if it is valid.\n+///\n+/// **Known problems:**\n+///\n+/// * It does not check functions recursively so if the pointer is passed to a private non-\n+/// `unsafe` function which does the dereferencing, the lint won't trigger.\n+/// * It only checks for arguments whose type are raw pointers, not raw pointers got from an\n+/// argument in some other way (`fn foo(bar: &[*const u8])` or `some_argument.get_raw_ptr()`).\n+///\n+/// **Example:**\n+///\n+/// ```rust\n+/// pub fn foo(x: *const u8) { println!(\"{}\", unsafe { *x }); }\n+/// ```\n+declare_lint! {\n+    pub NOT_UNSAFE_PTR_ARG_DEREF,\n+    Warn,\n+    \"public functions dereferencing raw pointer arguments but not marked `unsafe`\"\n+}\n+\n #[derive(Copy,Clone)]\n pub struct Functions {\n     threshold: u64,\n@@ -37,29 +63,41 @@ impl Functions {\n \n impl LintPass for Functions {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(TOO_MANY_ARGUMENTS)\n+        lint_array!(TOO_MANY_ARGUMENTS, NOT_UNSAFE_PTR_ARG_DEREF)\n     }\n }\n \n impl LateLintPass for Functions {\n-    fn check_fn(&mut self, cx: &LateContext, _: intravisit::FnKind, decl: &hir::FnDecl, _: &hir::Block, span: Span,\n-                nodeid: ast::NodeId) {\n+    fn check_fn(&mut self, cx: &LateContext, kind: intravisit::FnKind, decl: &hir::FnDecl, block: &hir::Block, span: Span, nodeid: ast::NodeId) {\n         use rustc::hir::map::Node::*;\n \n-        if let Some(NodeItem(ref item)) = cx.tcx.map.find(cx.tcx.map.get_parent_node(nodeid)) {\n-            match item.node {\n-                hir::ItemImpl(_, _, _, Some(_), _, _) |\n-                hir::ItemDefaultImpl(..) => return,\n-                _ => (),\n-            }\n+        let is_impl = if let Some(NodeItem(ref item)) = cx.tcx.map.find(cx.tcx.map.get_parent_node(nodeid)) {\n+            matches!(item.node, hir::ItemImpl(_, _, _, Some(_), _, _) | hir::ItemDefaultImpl(..))\n+        } else {\n+            false\n+        };\n+\n+        let unsafety = match kind {\n+            hir::intravisit::FnKind::ItemFn(_, _, unsafety, _, _, _, _) => unsafety,\n+            hir::intravisit::FnKind::Method(_, sig, _, _) => sig.unsafety,\n+            hir::intravisit::FnKind::Closure(_) => return,\n+        };\n+\n+        // don't warn for implementations, it's not their fault\n+        if !is_impl {\n+            self.check_arg_number(cx, decl, span);\n         }\n \n-        self.check_arg_number(cx, decl, span);\n+        self.check_raw_ptr(cx, unsafety, decl, block, nodeid);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext, item: &hir::TraitItem) {\n-        if let hir::MethodTraitItem(ref sig, _) = item.node {\n+        if let hir::MethodTraitItem(ref sig, ref block) = item.node {\n             self.check_arg_number(cx, &sig.decl, item.span);\n+\n+            if let Some(ref block) = *block {\n+                self.check_raw_ptr(cx, sig.unsafety, &sig.decl, block, item.id);\n+            }\n         }\n     }\n }\n@@ -74,4 +112,75 @@ impl Functions {\n                       &format!(\"this function has too many arguments ({}/{})\", args, self.threshold));\n         }\n     }\n+\n+    fn check_raw_ptr(&self, cx: &LateContext, unsafety: hir::Unsafety, decl: &hir::FnDecl, block: &hir::Block, nodeid: ast::NodeId) {\n+        if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(nodeid) {\n+            let raw_ptrs = decl.inputs.iter().filter_map(|arg| raw_ptr_arg(cx, arg)).collect::<HashSet<_>>();\n+\n+            if !raw_ptrs.is_empty() {\n+                let mut v = DerefVisitor {\n+                    cx: cx,\n+                    ptrs: raw_ptrs,\n+                };\n+\n+                hir::intravisit::walk_block(&mut v, block);\n+            }\n+        }\n+    }\n+}\n+\n+fn raw_ptr_arg(cx: &LateContext, arg: &hir::Arg) -> Option<hir::def_id::DefId> {\n+    if let (&hir::PatKind::Binding(_, _, _), &hir::TyPtr(_)) = (&arg.pat.node, &arg.ty.node) {\n+        cx.tcx.def_map.borrow().get(&arg.pat.id).map(|pr| pr.full_def().def_id())\n+    } else {\n+        None\n+    }\n+}\n+\n+struct DerefVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    ptrs: HashSet<hir::def_id::DefId>,\n+}\n+\n+impl<'a, 'tcx, 'v> hir::intravisit::Visitor<'v> for DerefVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'v hir::Expr) {\n+        match expr.node {\n+            hir::ExprCall(ref f, ref args) => {\n+                let ty = self.cx.tcx.expr_ty(f);\n+\n+                if type_is_unsafe_function(ty) {\n+                    for arg in args {\n+                        self.check_arg(arg);\n+                    }\n+                }\n+            }\n+            hir::ExprMethodCall(_, _, ref args) => {\n+                let method_call = ty::MethodCall::expr(expr.id);\n+                let base_type = self.cx.tcx.tables.borrow().method_map[&method_call].ty;\n+\n+                if type_is_unsafe_function(base_type) {\n+                    for arg in args {\n+                        self.check_arg(arg);\n+                    }\n+                }\n+            }\n+            hir::ExprUnary(hir::UnDeref, ref ptr) => self.check_arg(ptr),\n+            _ => (),\n+        }\n+\n+        hir::intravisit::walk_expr(self, expr);\n+    }\n+}\n+\n+impl<'a, 'tcx: 'a> DerefVisitor<'a, 'tcx> {\n+    fn check_arg(&self, ptr: &hir::Expr) {\n+        if let Some(def) = self.cx.tcx.def_map.borrow().get(&ptr.id) {\n+            if self.ptrs.contains(&def.full_def().def_id()) {\n+                span_lint(self.cx,\n+                          NOT_UNSAFE_PTR_ARG_DEREF,\n+                          ptr.span,\n+                          \"this public function dereferences a raw pointer but is not marked `unsafe`\");\n+            }\n+        }\n+    }\n }"}, {"sha": "5ba52374135ef79b35ae2afdb5d525172acda9b8", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e9ca25584afa2f8c639435f64ed6ccedb1f5b52/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9ca25584afa2f8c639435f64ed6ccedb1f5b52/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=4e9ca25584afa2f8c639435f64ed6ccedb1f5b52", "patch": "@@ -322,6 +322,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         format::USELESS_FORMAT,\n         formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING,\n         formatting::SUSPICIOUS_ELSE_FORMATTING,\n+        functions::NOT_UNSAFE_PTR_ARG_DEREF,\n         functions::TOO_MANY_ARGUMENTS,\n         identity_op::IDENTITY_OP,\n         len_zero::LEN_WITHOUT_IS_EMPTY,"}, {"sha": "30bb6dfeb7659408f899baac7c39ec6208e50438", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4e9ca25584afa2f8c639435f64ed6ccedb1f5b52/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9ca25584afa2f8c639435f64ed6ccedb1f5b52/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=4e9ca25584afa2f8c639435f64ed6ccedb1f5b52", "patch": "@@ -813,3 +813,12 @@ pub fn recover_for_loop(expr: &Expr) -> Option<(&Pat, &Expr, &Expr)> {\n     }}\n     None\n }\n+\n+/// Return whether the given type is an `unsafe` function.\n+pub fn type_is_unsafe_function(ty: ty::Ty) -> bool {\n+    match ty.sty {\n+        ty::TyFnDef(_, _, ref f) |\n+        ty::TyFnPtr(ref f) => f.unsafety == Unsafety::Unsafe,\n+        _ => false,\n+    }\n+}"}, {"sha": "f7ee41d281699d631863a8f4e3e4b1f97d526160", "filename": "tests/compile-fail/functions.rs", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4e9ca25584afa2f8c639435f64ed6ccedb1f5b52/tests%2Fcompile-fail%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e9ca25584afa2f8c639435f64ed6ccedb1f5b52/tests%2Fcompile-fail%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffunctions.rs?ref=4e9ca25584afa2f8c639435f64ed6ccedb1f5b52", "patch": "@@ -3,20 +3,24 @@\n \n #![deny(clippy)]\n #![allow(dead_code)]\n+#![allow(unused_unsafe)]\n \n+// TOO_MANY_ARGUMENTS\n fn good(_one: u32, _two: u32, _three: &str, _four: bool, _five: f32, _six: f32, _seven: bool) {}\n \n fn bad(_one: u32, _two: u32, _three: &str, _four: bool, _five: f32, _six: f32, _seven: bool, _eight: ()) {\n     //~^ ERROR: this function has too many arguments (8/7)\n }\n \n-trait Foo {\n+pub trait Foo {\n     fn good(_one: u32, _two: u32, _three: &str, _four: bool, _five: f32, _six: f32, _seven: bool);\n     fn bad(_one: u32, _two: u32, _three: &str, _four: bool, _five: f32, _six: f32, _seven: bool, _eight: ());\n     //~^ ERROR: this function has too many arguments (8/7)\n+\n+    fn ptr(p: *const u8);\n }\n \n-struct Bar;\n+pub struct Bar;\n \n impl Bar {\n     fn good_method(_one: u32, _two: u32, _three: &str, _four: bool, _five: f32, _six: f32, _seven: bool) {}\n@@ -28,6 +32,56 @@ impl Bar {\n impl Foo for Bar {\n     fn good(_one: u32, _two: u32, _three: &str, _four: bool, _five: f32, _six: f32, _seven: bool) {}\n     fn bad(_one: u32, _two: u32, _three: &str, _four: bool, _five: f32, _six: f32, _seven: bool, _eight: ()) {}\n+\n+    fn ptr(p: *const u8) {\n+        println!(\"{}\", unsafe { *p });\n+        //~^ ERROR: this public function dereferences a raw pointer but is not marked `unsafe`\n+        println!(\"{:?}\", unsafe { p.as_ref() });\n+        //~^ ERROR: this public function dereferences a raw pointer but is not marked `unsafe`\n+        unsafe { std::ptr::read(p) };\n+        //~^ ERROR: this public function dereferences a raw pointer but is not marked `unsafe`\n+    }\n+}\n+\n+// NOT_UNSAFE_PTR_ARG_DEREF\n+\n+fn private(p: *const u8) {\n+    println!(\"{}\", unsafe { *p });\n+}\n+\n+pub fn public(p: *const u8) {\n+    println!(\"{}\", unsafe { *p });\n+    //~^ ERROR: this public function dereferences a raw pointer but is not marked `unsafe`\n+    println!(\"{:?}\", unsafe { p.as_ref() });\n+    //~^ ERROR: this public function dereferences a raw pointer but is not marked `unsafe`\n+    unsafe { std::ptr::read(p) };\n+    //~^ ERROR: this public function dereferences a raw pointer but is not marked `unsafe`\n+}\n+\n+impl Bar {\n+    fn private(self, p: *const u8) {\n+        println!(\"{}\", unsafe { *p });\n+    }\n+\n+    pub fn public(self, p: *const u8) {\n+        println!(\"{}\", unsafe { *p });\n+        //~^ ERROR: this public function dereferences a raw pointer but is not marked `unsafe`\n+        println!(\"{:?}\", unsafe { p.as_ref() });\n+        //~^ ERROR: this public function dereferences a raw pointer but is not marked `unsafe`\n+        unsafe { std::ptr::read(p) };\n+        //~^ ERROR: this public function dereferences a raw pointer but is not marked `unsafe`\n+    }\n+\n+    pub fn public_ok(self, p: *const u8) {\n+        if !p.is_null() {\n+            println!(\"{:p}\", p);\n+        }\n+    }\n+\n+    pub unsafe fn public_unsafe(self, p: *const u8) {\n+        println!(\"{}\", unsafe { *p });\n+        println!(\"{:?}\", unsafe { p.as_ref() });\n+    }\n }\n \n fn main() {}"}]}