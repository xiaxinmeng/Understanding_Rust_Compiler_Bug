{"sha": "79fcd51b4659aabb8cf92bcc69a20207dbd53492", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZmNkNTFiNDY1OWFhYmI4Y2Y5MmJjYzY5YTIwMjA3ZGJkNTM0OTI=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-06-03T01:58:23Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-04T01:47:11Z"}, "message": "Make the macro system more modular.", "tree": {"sha": "f05cd2b936664691a4ca25e39bb123d9aeb04e6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f05cd2b936664691a4ca25e39bb123d9aeb04e6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79fcd51b4659aabb8cf92bcc69a20207dbd53492", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79fcd51b4659aabb8cf92bcc69a20207dbd53492", "html_url": "https://github.com/rust-lang/rust/commit/79fcd51b4659aabb8cf92bcc69a20207dbd53492", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79fcd51b4659aabb8cf92bcc69a20207dbd53492/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfc75695a57de94de618b1f5f7c163d213fbc36b", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfc75695a57de94de618b1f5f7c163d213fbc36b", "html_url": "https://github.com/rust-lang/rust/commit/cfc75695a57de94de618b1f5f7c163d213fbc36b"}], "stats": {"total": 139, "additions": 64, "deletions": 75}, "files": [{"sha": "ecceabd9c07d8f84ee773bfbbe799ec3831c1df0", "filename": "src/comp/front/extenv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79fcd51b4659aabb8cf92bcc69a20207dbd53492/src%2Fcomp%2Ffront%2Fextenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79fcd51b4659aabb8cf92bcc69a20207dbd53492/src%2Fcomp%2Ffront%2Fextenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextenv.rs?ref=79fcd51b4659aabb8cf92bcc69a20207dbd53492", "patch": "@@ -14,9 +14,9 @@ import std::generic_os;\n export expand_syntax_ext;\n \n // FIXME: Need to thread parser through here to handle errors correctly\n-fn expand_syntax_ext(parser::parser p,\n+fn expand_syntax_ext(&parser::parser p,\n                      common::span sp,\n-                     vec[@ast::expr] args,\n+                     &vec[@ast::expr] args,\n                      option::t[str] body) -> @ast::expr {\n \n     if (vec::len[@ast::expr](args) != 1u) {"}, {"sha": "672de538510fa859177880abb7d3536a51255c14", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 3, "deletions": 32, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/79fcd51b4659aabb8cf92bcc69a20207dbd53492/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79fcd51b4659aabb8cf92bcc69a20207dbd53492/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=79fcd51b4659aabb8cf92bcc69a20207dbd53492", "patch": "@@ -13,41 +13,12 @@ import std::option;\n import std::option::none;\n import std::option::some;\n \n-import std::extfmt::ct::signedness;\n-import std::extfmt::ct::signed;\n-import std::extfmt::ct::unsigned;\n-import std::extfmt::ct::caseness;\n-import std::extfmt::ct::case_upper;\n-import std::extfmt::ct::case_lower;\n-import std::extfmt::ct::ty;\n-import std::extfmt::ct::ty_bool;\n-import std::extfmt::ct::ty_str;\n-import std::extfmt::ct::ty_char;\n-import std::extfmt::ct::ty_int;\n-import std::extfmt::ct::ty_bits;\n-import std::extfmt::ct::ty_hex;\n-import std::extfmt::ct::ty_octal;\n-import std::extfmt::ct::flag;\n-import std::extfmt::ct::flag_left_justify;\n-import std::extfmt::ct::flag_left_zero_pad;\n-import std::extfmt::ct::flag_space_for_sign;\n-import std::extfmt::ct::flag_sign_always;\n-import std::extfmt::ct::flag_alternate;\n-import std::extfmt::ct::count;\n-import std::extfmt::ct::count_is;\n-import std::extfmt::ct::count_is_param;\n-import std::extfmt::ct::count_is_next_param;\n-import std::extfmt::ct::count_implied;\n-import std::extfmt::ct::conv;\n-import std::extfmt::ct::piece;\n-import std::extfmt::ct::piece_string;\n-import std::extfmt::ct::piece_conv;\n-import std::extfmt::ct::parse_fmt_string;\n+import std::extfmt::ct::*;\n \n export expand_syntax_ext;\n \n-fn expand_syntax_ext(parser p,\n-                     vec[@ast::expr] args,\n+fn expand_syntax_ext(&parser p, common::span sp, \n+                     &vec[@ast::expr] args,\n                      option::t[str] body) -> @ast::expr {\n \n     if (vec::len[@ast::expr](args) == 0u) {"}, {"sha": "bafde70c9d7fc8c0dfca01583ae5867729d4d5c7", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 54, "deletions": 41, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/79fcd51b4659aabb8cf92bcc69a20207dbd53492/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79fcd51b4659aabb8cf92bcc69a20207dbd53492/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=79fcd51b4659aabb8cf92bcc69a20207dbd53492", "patch": "@@ -27,32 +27,41 @@ tag file_type {\n \n type ty_or_bang = util::common::ty_or_bang[@ast::ty];\n \n+// Temporary: to introduce a tag in order to make a recursive type work\n+tag xmacro {\n+    x(macro);\n+}\n+\n state type parser =\n     state obj {\n-          fn peek() -> token::token;\n-          fn bump();\n-          fn err(str s) -> !;\n-          fn restrict(restriction r);\n-          fn get_restriction() -> restriction;\n-          fn get_file_type() -> file_type;\n-          fn get_env() -> eval::env;\n-          fn get_session() -> session::session;\n-          fn get_span() -> common::span;\n-          fn get_lo_pos() -> uint;\n-          fn get_hi_pos() -> uint;\n-          fn get_last_lo_pos() -> uint;\n-          fn next_def_id() -> ast::def_id;\n-          fn set_def(ast::def_num);\n-          fn get_prec_table() -> vec[op_spec];\n-          fn get_str(token::str_num) -> str;\n-          fn get_reader() -> lexer::reader;\n-          fn get_filemap() -> codemap::filemap;\n-          fn get_bad_expr_words() -> std::map::hashmap[str, ()];\n-          fn get_chpos() -> uint;\n-          fn get_ann() -> ast::ann;\n-          fn next_ann_num() -> uint;\n+        fn peek() -> token::token;\n+        fn bump();\n+        fn err(str s) -> !;\n+        fn restrict(restriction r);\n+        fn get_restriction() -> restriction;\n+        fn get_file_type() -> file_type;\n+        fn get_env() -> eval::env;\n+        fn get_session() -> session::session;\n+        fn get_span() -> common::span;\n+        fn get_lo_pos() -> uint;\n+        fn get_hi_pos() -> uint;\n+        fn get_last_lo_pos() -> uint;\n+        fn next_def_id() -> ast::def_id;\n+        fn set_def(ast::def_num);\n+        fn get_prec_table() -> vec[op_spec];\n+        fn get_str(token::str_num) -> str;\n+        fn get_reader() -> lexer::reader;\n+        fn get_filemap() -> codemap::filemap;\n+        fn get_bad_expr_words() -> std::map::hashmap[str, ()];\n+        fn get_macros() -> std::map::hashmap[str, xmacro];\n+        fn get_chpos() -> uint;\n+        fn get_ann() -> ast::ann;\n+        fn next_ann_num() -> uint;\n     };\n \n+type macro = fn(&parser, common::span, &vec[@ast::expr], option::t[str]) \n+    -> @ast::expr;\n+\n fn new_parser(session::session sess,\n                      eval::env env,\n                      ast::def_id initial_def,\n@@ -70,7 +79,8 @@ fn new_parser(session::session sess,\n                            lexer::reader rdr,\n                            vec[op_spec] precs,\n                            mutable uint next_ann_var,\n-                           std::map::hashmap[str, ()] bad_words)\n+                           std::map::hashmap[str, ()] bad_words,\n+                           std::map::hashmap[str, xmacro] macros)\n         {\n             fn peek() -> token::token {\n                 ret tok;\n@@ -143,6 +153,10 @@ fn new_parser(session::session sess,\n                 ret bad_words;\n             }\n \n+            fn get_macros() -> std::map::hashmap[str, xmacro] {\n+                ret macros;\n+            }\n+\n             fn get_chpos() -> uint {ret rdr.get_chpos();}\n \n             fn get_ann() -> ast::ann {\n@@ -169,7 +183,7 @@ fn new_parser(session::session sess,\n     ret stdio_parser(sess, env, ftype, lexer::next_token(rdr),\n                      npos, npos, npos, initial_def._1, UNRESTRICTED,\n                      initial_def._0, rdr, prec_table(), next_ann,\n-                     bad_expr_word_table());\n+                     bad_expr_word_table(), macro_table());\n }\n \n // These are the words that shouldn't be allowed as value identifiers,\n@@ -213,6 +227,13 @@ fn bad_expr_word_table() -> std::map::hashmap[str, ()] {\n     ret words;\n }\n \n+fn macro_table() -> std::map::hashmap[str, xmacro] {\n+    auto macros = new_str_hash[xmacro]();\n+    macros.insert(\"fmt\", x(extfmt::expand_syntax_ext));\n+    macros.insert(\"env\", x(extenv::expand_syntax_ext));\n+    ret macros;\n+}\n+\n fn unexpected(&parser p, token::token t) -> ! {\n     let str s = \"unexpected token: \";\n     s += token::to_str(p.get_reader(), t);\n@@ -1037,23 +1058,15 @@ fn expand_syntax_ext(&parser p, common::span sp,\n \n     assert (vec::len[ast::ident](path.node.idents) > 0u);\n     auto extname = path.node.idents.(0);\n-    if (str::eq(extname, \"fmt\")) {\n-        auto expanded = extfmt::expand_syntax_ext(p, args, body);\n-        auto newexpr = ast::expr_ext(path, args, body,\n-                                    expanded,\n-                                    p.get_ann());\n-\n-        ret newexpr;\n-    } else if (str::eq(extname, \"env\")) {\n-        auto expanded = extenv::expand_syntax_ext(p, sp, args, body);\n-        auto newexpr = ast::expr_ext(path, args, body,\n-                                    expanded,\n-                                    p.get_ann());\n-\n-        ret newexpr;\n-    } else {\n-        p.err(\"unknown syntax extension\");\n-        fail;\n+\n+    alt (p.get_macros().find(extname)) {\n+        case (none[xmacro]) {\n+            p.err(\"unknown macro: '\" + extname + \"'\");\n+        }\n+        case (some[xmacro](x(?ext))) {\n+            ret ast::expr_ext(path, args, body, ext(p, sp, args, body), \n+                              p.get_ann());\n+        }\n     }\n }\n "}, {"sha": "df913ece3801d55436bdf9fd807947528685732f", "filename": "src/test/compile-fail/ext-nonexistent.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/79fcd51b4659aabb8cf92bcc69a20207dbd53492/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79fcd51b4659aabb8cf92bcc69a20207dbd53492/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs?ref=79fcd51b4659aabb8cf92bcc69a20207dbd53492", "patch": "@@ -0,0 +1,5 @@\n+\n+// error-pattern:unknown macro\n+fn main() {\n+  #iamnotanextensionthatexists(\"\");\n+}\n\\ No newline at end of file"}]}