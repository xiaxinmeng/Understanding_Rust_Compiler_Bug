{"sha": "48e206ee8117c12b7f75fbb3e0497272a965c5bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ZTIwNmVlODExN2MxMmI3Zjc1ZmJiM2UwNDk3MjcyYTk2NWM1YmY=", "commit": {"author": {"name": "Tycho Sci", "email": "tychosci@gmail.com", "date": "2012-02-05T09:30:03Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-09T20:15:30Z"}, "message": "cargo: Add local mode and use it by default", "tree": {"sha": "a70a0f9c274b58b51095402f777f7661ee8bc8ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a70a0f9c274b58b51095402f777f7661ee8bc8ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48e206ee8117c12b7f75fbb3e0497272a965c5bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48e206ee8117c12b7f75fbb3e0497272a965c5bf", "html_url": "https://github.com/rust-lang/rust/commit/48e206ee8117c12b7f75fbb3e0497272a965c5bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48e206ee8117c12b7f75fbb3e0497272a965c5bf/comments", "author": {"login": "tychosci", "id": 1026254, "node_id": "MDQ6VXNlcjEwMjYyNTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1026254?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tychosci", "html_url": "https://github.com/tychosci", "followers_url": "https://api.github.com/users/tychosci/followers", "following_url": "https://api.github.com/users/tychosci/following{/other_user}", "gists_url": "https://api.github.com/users/tychosci/gists{/gist_id}", "starred_url": "https://api.github.com/users/tychosci/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tychosci/subscriptions", "organizations_url": "https://api.github.com/users/tychosci/orgs", "repos_url": "https://api.github.com/users/tychosci/repos", "events_url": "https://api.github.com/users/tychosci/events{/privacy}", "received_events_url": "https://api.github.com/users/tychosci/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b4851cff6751a015dcfc1d6d495231058b2f515", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b4851cff6751a015dcfc1d6d495231058b2f515", "html_url": "https://github.com/rust-lang/rust/commit/0b4851cff6751a015dcfc1d6d495231058b2f515"}], "stats": {"total": 130, "additions": 99, "deletions": 31}, "files": [{"sha": "0056059b1c8fbf6ccca098142811984daae2d0db", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 62, "deletions": 31, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/48e206ee8117c12b7f75fbb3e0497272a965c5bf/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48e206ee8117c12b7f75fbb3e0497272a965c5bf/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=48e206ee8117c12b7f75fbb3e0497272a965c5bf", "patch": "@@ -5,7 +5,7 @@ use std;\n \n import rustc::syntax::{ast, codemap};\n import rustc::syntax::parse::parser;\n-import rustc::util::filesearch::get_cargo_root;\n+import rustc::util::filesearch::{get_cargo_root, get_cargo_root_nearest};\n import rustc::driver::diagnostic;\n \n import std::fs;\n@@ -19,6 +19,8 @@ import std::run;\n import str;\n import std::tempfile;\n import vec;\n+import std::getopts;\n+import getopts::{optflag, opt_present};\n \n enum _src {\n     /* Break cycles in package <-> source */\n@@ -53,7 +55,7 @@ type cargo = {\n     workdir: str,\n     sourcedir: str,\n     sources: map::hashmap<str, source>,\n-    mutable test: bool\n+    opts: options\n };\n \n type pkg = {\n@@ -65,6 +67,16 @@ type pkg = {\n     crate_type: option<str>\n };\n \n+type options = {\n+    test: bool,\n+    cwd: bool,\n+    free: [str],\n+};\n+\n+fn opts() -> [getopts::opt] {\n+    [optflag(\"g\"), optflag(\"global\"), optflag(\"test\")]\n+}\n+\n fn info(msg: str) {\n     io::stdout().write_line(\"info: \" + msg);\n }\n@@ -322,8 +334,28 @@ fn load_source_packages(&c: cargo, &src: source) {\n     };\n }\n \n-fn configure() -> cargo {\n-    let p = alt get_cargo_root() {\n+fn build_cargo_options(argv: [str]) -> options {\n+    let match = alt getopts::getopts(argv, opts()) {\n+        result::ok(m) { m }\n+        result::err(f) {\n+            fail #fmt[\"%s\", getopts::fail_str(f)];\n+        }\n+    };\n+\n+    let test = opt_present(match, \"test\");\n+    let cwd = !(opt_present(match, \"g\") || opt_present(match, \"global\"));\n+\n+    {test: test, cwd: cwd, free: match.free}\n+}\n+\n+fn configure(opts: options) -> cargo {\n+    let get_cargo_dir = if opts.cwd {\n+        get_cargo_root_nearest\n+    } else {\n+        get_cargo_root\n+    };\n+\n+    let p = alt get_cargo_dir() {\n       result::ok(p) { p }\n       result::err(e) { fail e }\n     };\n@@ -339,7 +371,7 @@ fn configure() -> cargo {\n         workdir: fs::connect(p, \"work\"),\n         sourcedir: fs::connect(p, \"sources\"),\n         sources: sources,\n-        mutable test: false\n+        opts: opts\n     };\n \n     need_dir(c.root);\n@@ -430,7 +462,7 @@ fn install_source(c: cargo, path: str) {\n         alt p {\n             none { cont; }\n             some(_p) {\n-                if c.test {\n+                if c.opts.test {\n                     test_one_crate(c, path, cf, _p);\n                 }\n                 install_one_crate(c, path, cf, _p);\n@@ -573,19 +605,14 @@ fn install_named_specific(c: cargo, wd: str, src: str, name: str) {\n     error(\"Can't find package \" + src + \"/\" + name);\n }\n \n-fn cmd_install(c: cargo, argv: [str]) unsafe {\n+fn cmd_install(c: cargo) unsafe {\n     // cargo install <pkg>\n-    if vec::len(argv) < 3u {\n+    if vec::len(c.opts.free) < 3u {\n         cmd_usage();\n         ret;\n     }\n \n-    let target = argv[2];\n-    // TODO: getopts\n-    if vec::len(argv) > 3u && argv[2] == \"--test\" {\n-        c.test = true;\n-        target = argv[3];\n-    }\n+    let target = c.opts.free[2];\n \n     let wd = alt tempfile::mkdtemp(c.workdir + fs::path_sep(), \"\") {\n         some(_wd) { _wd }\n@@ -671,9 +698,9 @@ fn sync_one(c: cargo, name: str, src: source) {\n     run::run_program(\"cp\", [pkgfile, destpkgfile]);\n }\n \n-fn cmd_sync(c: cargo, argv: [str]) {\n-    if vec::len(argv) == 3u {\n-        sync_one(c, argv[2], c.sources.get(argv[2]));\n+fn cmd_sync(c: cargo) {\n+    if vec::len(c.opts.free) == 3u {\n+        sync_one(c, c.opts.free[2], c.sources.get(c.opts.free[2]));\n     } else {\n         cargo_suggestion(c, true, { || } );\n         c.sources.items { |k, v|\n@@ -721,22 +748,22 @@ fn print_pkg(s: source, p: package) {\n         print(\"   >> \" + p.description + \"\\n\")\n     }\n }\n-fn cmd_list(c: cargo, argv: [str]) {\n+fn cmd_list(c: cargo) {\n     for_each_package(c, { |s, p|\n-        if vec::len(argv) <= 2u || argv[2] == s.name {\n+        if vec::len(c.opts.free) <= 2u || c.opts.free[2] == s.name {\n             print_pkg(s, p);\n         }\n     });\n }\n \n-fn cmd_search(c: cargo, argv: [str]) {\n-    if vec::len(argv) < 3u {\n+fn cmd_search(c: cargo) {\n+    if vec::len(c.opts.free) < 3u {\n         cmd_usage();\n         ret;\n     }\n     let n = 0;\n-    let name = argv[2];\n-    let tags = vec::slice(argv, 3u, vec::len(argv));\n+    let name = c.opts.free[2];\n+    let tags = vec::slice(c.opts.free, 3u, vec::len(c.opts.free));\n     for_each_package(c, { |s, p|\n         if (str::contains(p.name, name) || name == \"*\") &&\n             vec::all(tags, { |t| vec::member(t, p.tags) }) {\n@@ -749,7 +776,7 @@ fn cmd_search(c: cargo, argv: [str]) {\n \n fn cmd_usage() {\n     print(\"Usage: cargo <verb> [args...]\");\n-    print(\"  init                                          Set up ~/.cargo\");\n+    print(\"  init                                          Set up .cargo\");\n     print(\"  install [--test] [source/]package-name        Install by name\");\n     print(\"  install [--test] uuid:[source/]package-uuid   Install by uuid\");\n     print(\"  list [source]                                 List packages\");\n@@ -759,17 +786,21 @@ fn cmd_usage() {\n }\n \n fn main(argv: [str]) {\n-    if vec::len(argv) < 2u {\n+    let o = build_cargo_options(argv);\n+\n+    if vec::len(o.free) < 2u {\n         cmd_usage();\n         ret;\n     }\n-    let c = configure();\n-    alt argv[1] {\n+\n+    let c = configure(o);\n+\n+    alt o.free[1] {\n         \"init\" { cmd_init(c); }\n-        \"install\" { cmd_install(c, argv); }\n-        \"list\" { cmd_list(c, argv); }\n-        \"search\" { cmd_search(c, argv); }\n-        \"sync\" { cmd_sync(c, argv); }\n+        \"install\" { cmd_install(c); }\n+        \"list\" { cmd_list(c); }\n+        \"search\" { cmd_search(c); }\n+        \"sync\" { cmd_sync(c); }\n         \"usage\" { cmd_usage(); }\n         _ { cmd_usage(); }\n     }"}, {"sha": "f71fbab81bd3923e7e5d2215021ac122f07803c1", "filename": "src/comp/util/filesearch.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/48e206ee8117c12b7f75fbb3e0497272a965c5bf/src%2Fcomp%2Futil%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48e206ee8117c12b7f75fbb3e0497272a965c5bf/src%2Fcomp%2Futil%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ffilesearch.rs?ref=48e206ee8117c12b7f75fbb3e0497272a965c5bf", "patch": "@@ -11,6 +11,7 @@ export pick_file;\n export search;\n export relative_target_lib_path;\n export get_cargo_root;\n+export get_cargo_root_nearest;\n export libdir;\n \n type pick<T> = fn(path: fs::path) -> option<T>;\n@@ -38,6 +39,10 @@ fn mk_filesearch(maybe_sysroot: option<fs::path>,\n         fn lib_search_paths() -> [fs::path] {\n             self.addl_lib_search_paths\n                 + [make_target_lib_path(self.sysroot, self.target_triple)]\n+                + alt get_cargo_lib_path_nearest() {\n+                  result::ok(p) { [p] }\n+                  result::err(p) { [] }\n+                }\n                 + alt get_cargo_lib_path() {\n                   result::ok(p) { [p] }\n                   result::err(p) { [] }\n@@ -116,12 +121,44 @@ fn get_cargo_root() -> result::t<fs::path, str> {\n     }\n }\n \n+fn get_cargo_root_nearest() -> result::t<fs::path, str> {\n+    result::chain(get_cargo_root()) { |p|\n+        let cwd = os::getcwd();\n+        let dirname = fs::dirname(cwd);\n+        let dirpath = fs::split(dirname);\n+        let cwd_cargo = fs::connect(cwd, \".cargo\");\n+        let par_cargo = fs::connect(dirname, \".cargo\");\n+\n+        // FIXME: this duplicates lib path\n+        if cwd_cargo == p {\n+            ret result::ok(p);\n+        }\n+\n+        while vec::is_not_empty(dirpath) && par_cargo != p {\n+            if fs::path_is_dir(par_cargo) {\n+                ret result::ok(par_cargo);\n+            }\n+            vec::pop(dirpath);\n+            dirname = fs::dirname(dirname);\n+            par_cargo = fs::connect(dirname, \".cargo\");\n+        }\n+\n+        result::ok(cwd_cargo)\n+    }\n+}\n+\n fn get_cargo_lib_path() -> result::t<fs::path, str> {\n     result::chain(get_cargo_root()) { |p|\n         result::ok(fs::connect(p, libdir()))\n     }\n }\n \n+fn get_cargo_lib_path_nearest() -> result::t<fs::path, str> {\n+    result::chain(get_cargo_root_nearest()) { |p|\n+        result::ok(fs::connect(p, libdir()))\n+    }\n+}\n+\n // The name of the directory rustc expects libraries to be located.\n // On Unix should be \"lib\", on windows \"bin\"\n fn libdir() -> str {"}]}