{"sha": "0f03b5608cc66aedb94409d62335ec539880b875", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmMDNiNTYwOGNjNjZhZWRiOTQ0MDlkNjIzMzVlYzUzOTg4MGI4NzU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-05-14T19:31:30Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-06-06T23:51:23Z"}, "message": "Move Def out of syntax crate, where it does not belong", "tree": {"sha": "6a4a9da63f88c9732164710640fc04addbeaf407", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a4a9da63f88c9732164710640fc04addbeaf407"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f03b5608cc66aedb94409d62335ec539880b875", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f03b5608cc66aedb94409d62335ec539880b875", "html_url": "https://github.com/rust-lang/rust/commit/0f03b5608cc66aedb94409d62335ec539880b875", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f03b5608cc66aedb94409d62335ec539880b875/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14d626a9fa645186b87717cab6bfb976d5c13ab0", "url": "https://api.github.com/repos/rust-lang/rust/commits/14d626a9fa645186b87717cab6bfb976d5c13ab0", "html_url": "https://github.com/rust-lang/rust/commit/14d626a9fa645186b87717cab6bfb976d5c13ab0"}], "stats": {"total": 834, "additions": 442, "deletions": 392}, "files": [{"sha": "1b17cfb1bae01dd8b038ea644fb8a82812330e1c", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -46,6 +46,7 @@ extern crate time;\n extern crate log;\n \n pub mod middle {\n+    pub mod def;\n     pub mod trans;\n     pub mod ty;\n     pub mod ty_fold;"}, {"sha": "6469462734e553190560e6e43937c9b3185f8434", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -22,6 +22,7 @@ use metadata::tydecode::{parse_ty_data, parse_def_id,\n                          parse_type_param_def_data,\n                          parse_bare_fn_ty_data, parse_trait_ref_data};\n use middle::lang_items;\n+use middle::def;\n use middle::ty::{ImplContainer, TraitContainer};\n use middle::ty;\n use middle::typeck;\n@@ -333,11 +334,11 @@ fn item_to_def_like(item: ebml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n     -> DefLike {\n     let fam = item_family(item);\n     match fam {\n-        ImmStatic => DlDef(ast::DefStatic(did, false)),\n-        MutStatic => DlDef(ast::DefStatic(did, true)),\n-        Struct    => DlDef(ast::DefStruct(did)),\n-        UnsafeFn  => DlDef(ast::DefFn(did, ast::UnsafeFn)),\n-        Fn        => DlDef(ast::DefFn(did, ast::NormalFn)),\n+        ImmStatic => DlDef(def::DefStatic(did, false)),\n+        MutStatic => DlDef(def::DefStatic(did, true)),\n+        Struct    => DlDef(def::DefStruct(did)),\n+        UnsafeFn  => DlDef(def::DefFn(did, ast::UnsafeFn)),\n+        Fn        => DlDef(def::DefFn(did, ast::NormalFn)),\n         StaticMethod | UnsafeStaticMethod => {\n             let fn_style = if fam == UnsafeStaticMethod { ast::UnsafeFn } else\n                 { ast::NormalFn };\n@@ -348,27 +349,27 @@ fn item_to_def_like(item: ebml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n             // a trait_method_sort.\n             let provenance = if reader::maybe_get_doc(\n                   item, tag_item_trait_method_sort).is_some() {\n-                ast::FromTrait(item_reqd_and_translated_parent_item(cnum,\n+                def::FromTrait(item_reqd_and_translated_parent_item(cnum,\n                                                                     item))\n             } else {\n-                ast::FromImpl(item_reqd_and_translated_parent_item(cnum,\n+                def::FromImpl(item_reqd_and_translated_parent_item(cnum,\n                                                                    item))\n             };\n-            DlDef(ast::DefStaticMethod(did, provenance, fn_style))\n+            DlDef(def::DefStaticMethod(did, provenance, fn_style))\n         }\n-        Type | ForeignType => DlDef(ast::DefTy(did)),\n-        Mod => DlDef(ast::DefMod(did)),\n-        ForeignMod => DlDef(ast::DefForeignMod(did)),\n+        Type | ForeignType => DlDef(def::DefTy(did)),\n+        Mod => DlDef(def::DefMod(did)),\n+        ForeignMod => DlDef(def::DefForeignMod(did)),\n         StructVariant => {\n             let enum_did = item_reqd_and_translated_parent_item(cnum, item);\n-            DlDef(ast::DefVariant(enum_did, did, true))\n+            DlDef(def::DefVariant(enum_did, did, true))\n         }\n         TupleVariant => {\n             let enum_did = item_reqd_and_translated_parent_item(cnum, item);\n-            DlDef(ast::DefVariant(enum_did, did, false))\n+            DlDef(def::DefVariant(enum_did, did, false))\n         }\n-        Trait => DlDef(ast::DefTrait(did)),\n-        Enum => DlDef(ast::DefTy(did)),\n+        Trait => DlDef(def::DefTrait(did)),\n+        Enum => DlDef(def::DefTy(did)),\n         Impl => DlImpl(did),\n         PublicField | InheritedField => DlField,\n     }\n@@ -459,7 +460,7 @@ pub fn get_symbol(data: &[u8], id: ast::NodeId) -> String {\n // Something that a name can resolve to.\n #[deriving(Clone)]\n pub enum DefLike {\n-    DlDef(ast::Def),\n+    DlDef(def::Def),\n     DlImpl(ast::DefId),\n     DlField\n }"}, {"sha": "2cc06f7a32dde70ab2a39971709739dcfab26778", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -1631,7 +1631,7 @@ impl<'a,'b,'c> Visitor<()> for ImplVisitor<'a,'b,'c> {\n             ItemImpl(_, Some(ref trait_ref), _, _) => {\n                 let def_map = &self.ecx.tcx.def_map;\n                 let trait_def = def_map.borrow().get_copy(&trait_ref.ref_id);\n-                let def_id = ast_util::def_id_of_def(trait_def);\n+                let def_id = trait_def.def_id();\n \n                 // Load eagerly if this is an implementation of the Drop trait\n                 // or if the trait is not defined in this crate."}, {"sha": "f0caf0e7fe83248c403e6fa2eea54335b203ad82", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -16,6 +16,7 @@ use c = metadata::common;\n use cstore = metadata::cstore;\n use driver::session::Session;\n use metadata::decoder;\n+use middle::def;\n use e = metadata::encoder;\n use middle::freevars::freevar_entry;\n use middle::region;\n@@ -395,58 +396,58 @@ fn renumber_and_map_ast(xcx: &ExtendedDecodeContext,\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-fn decode_def(xcx: &ExtendedDecodeContext, doc: ebml::Doc) -> ast::Def {\n+fn decode_def(xcx: &ExtendedDecodeContext, doc: ebml::Doc) -> def::Def {\n     let mut dsr = reader::Decoder::new(doc);\n-    let def: ast::Def = Decodable::decode(&mut dsr).unwrap();\n+    let def: def::Def = Decodable::decode(&mut dsr).unwrap();\n     def.tr(xcx)\n }\n \n-impl tr for ast::Def {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> ast::Def {\n+impl tr for def::Def {\n+    fn tr(&self, xcx: &ExtendedDecodeContext) -> def::Def {\n         match *self {\n-          ast::DefFn(did, p) => ast::DefFn(did.tr(xcx), p),\n-          ast::DefStaticMethod(did, wrapped_did2, p) => {\n-            ast::DefStaticMethod(did.tr(xcx),\n+          def::DefFn(did, p) => def::DefFn(did.tr(xcx), p),\n+          def::DefStaticMethod(did, wrapped_did2, p) => {\n+            def::DefStaticMethod(did.tr(xcx),\n                                    match wrapped_did2 {\n-                                    ast::FromTrait(did2) => {\n-                                        ast::FromTrait(did2.tr(xcx))\n+                                    def::FromTrait(did2) => {\n+                                        def::FromTrait(did2.tr(xcx))\n                                     }\n-                                    ast::FromImpl(did2) => {\n-                                        ast::FromImpl(did2.tr(xcx))\n+                                    def::FromImpl(did2) => {\n+                                        def::FromImpl(did2.tr(xcx))\n                                     }\n                                    },\n                                    p)\n           }\n-          ast::DefMethod(did0, did1) => {\n-            ast::DefMethod(did0.tr(xcx), did1.map(|did1| did1.tr(xcx)))\n+          def::DefMethod(did0, did1) => {\n+            def::DefMethod(did0.tr(xcx), did1.map(|did1| did1.tr(xcx)))\n           }\n-          ast::DefSelfTy(nid) => { ast::DefSelfTy(xcx.tr_id(nid)) }\n-          ast::DefMod(did) => { ast::DefMod(did.tr(xcx)) }\n-          ast::DefForeignMod(did) => { ast::DefForeignMod(did.tr(xcx)) }\n-          ast::DefStatic(did, m) => { ast::DefStatic(did.tr(xcx), m) }\n-          ast::DefArg(nid, b) => { ast::DefArg(xcx.tr_id(nid), b) }\n-          ast::DefLocal(nid, b) => { ast::DefLocal(xcx.tr_id(nid), b) }\n-          ast::DefVariant(e_did, v_did, is_s) => {\n-            ast::DefVariant(e_did.tr(xcx), v_did.tr(xcx), is_s)\n+          def::DefSelfTy(nid) => { def::DefSelfTy(xcx.tr_id(nid)) }\n+          def::DefMod(did) => { def::DefMod(did.tr(xcx)) }\n+          def::DefForeignMod(did) => { def::DefForeignMod(did.tr(xcx)) }\n+          def::DefStatic(did, m) => { def::DefStatic(did.tr(xcx), m) }\n+          def::DefArg(nid, b) => { def::DefArg(xcx.tr_id(nid), b) }\n+          def::DefLocal(nid, b) => { def::DefLocal(xcx.tr_id(nid), b) }\n+          def::DefVariant(e_did, v_did, is_s) => {\n+            def::DefVariant(e_did.tr(xcx), v_did.tr(xcx), is_s)\n           },\n-          ast::DefTrait(did) => ast::DefTrait(did.tr(xcx)),\n-          ast::DefTy(did) => ast::DefTy(did.tr(xcx)),\n-          ast::DefPrimTy(p) => ast::DefPrimTy(p),\n-          ast::DefTyParam(did, v) => ast::DefTyParam(did.tr(xcx), v),\n-          ast::DefBinding(nid, bm) => ast::DefBinding(xcx.tr_id(nid), bm),\n-          ast::DefUse(did) => ast::DefUse(did.tr(xcx)),\n-          ast::DefUpvar(nid1, def, nid2, nid3) => {\n-            ast::DefUpvar(xcx.tr_id(nid1),\n+          def::DefTrait(did) => def::DefTrait(did.tr(xcx)),\n+          def::DefTy(did) => def::DefTy(did.tr(xcx)),\n+          def::DefPrimTy(p) => def::DefPrimTy(p),\n+          def::DefTyParam(did, v) => def::DefTyParam(did.tr(xcx), v),\n+          def::DefBinding(nid, bm) => def::DefBinding(xcx.tr_id(nid), bm),\n+          def::DefUse(did) => def::DefUse(did.tr(xcx)),\n+          def::DefUpvar(nid1, def, nid2, nid3) => {\n+            def::DefUpvar(xcx.tr_id(nid1),\n                            @(*def).tr(xcx),\n                            xcx.tr_id(nid2),\n                            xcx.tr_id(nid3))\n           }\n-          ast::DefStruct(did) => ast::DefStruct(did.tr(xcx)),\n-          ast::DefRegion(nid) => ast::DefRegion(xcx.tr_id(nid)),\n-          ast::DefTyParamBinder(nid) => {\n-            ast::DefTyParamBinder(xcx.tr_id(nid))\n+          def::DefStruct(did) => def::DefStruct(did.tr(xcx)),\n+          def::DefRegion(nid) => def::DefRegion(xcx.tr_id(nid)),\n+          def::DefTyParamBinder(nid) => {\n+            def::DefTyParamBinder(xcx.tr_id(nid))\n           }\n-          ast::DefLabel(nid) => ast::DefLabel(xcx.tr_id(nid))\n+          def::DefLabel(nid) => def::DefLabel(xcx.tr_id(nid))\n         }\n     }\n }"}, {"sha": "5706d249c46dabd98f12e670462b468dff96c1f1", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -14,6 +14,7 @@\n \n use middle::dataflow::DataFlowContext;\n use middle::dataflow::DataFlowOperator;\n+use middle::def;\n use euv = middle::expr_use_visitor;\n use mc = middle::mem_categorization;\n use middle::ty;\n@@ -399,7 +400,7 @@ impl<'a> BorrowckCtxt<'a> {\n                    id: ast::NodeId,\n                    span: Span,\n                    ty: ty::t,\n-                   def: ast::Def)\n+                   def: def::Def)\n                    -> mc::cmt {\n         match self.mc().cat_def(id, span, ty, def) {\n             Ok(c) => c,\n@@ -412,11 +413,11 @@ impl<'a> BorrowckCtxt<'a> {\n     pub fn cat_captured_var(&self,\n                             closure_id: ast::NodeId,\n                             closure_span: Span,\n-                            upvar_def: ast::Def)\n+                            upvar_def: def::Def)\n                             -> mc::cmt {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n-        let var_id = ast_util::def_id_of_def(upvar_def).node;\n+        let var_id = upvar_def.def_id().node;\n         let var_ty = ty::node_id_to_type(self.tcx, var_id);\n         self.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }"}, {"sha": "4a36e84fbe56e0663ca28d9a7bb0de1aed3736ce", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use middle::cfg::*;\n+use middle::def;\n use middle::graph;\n use middle::typeck;\n use middle::ty;\n@@ -531,7 +532,7 @@ impl<'a> CFGBuilder<'a> {\n \n             Some(_) => {\n                 match self.tcx.def_map.borrow().find(&expr.id) {\n-                    Some(&ast::DefLabel(loop_id)) => {\n+                    Some(&def::DefLabel(loop_id)) => {\n                         for l in self.loop_scopes.iter() {\n                             if l.loop_id == loop_id {\n                                 return *l;"}, {"sha": "2bb7d0bc5c8d471a3b8e9b58026d42ea251cb5f4", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -10,6 +10,7 @@\n \n \n use driver::session::Session;\n+use middle::def::*;\n use middle::resolve;\n use middle::ty;\n use middle::typeck;"}, {"sha": "39a35e3adfab62ca899cb2a7adbb986657164c01", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -12,6 +12,7 @@\n \n use middle::const_eval::{compare_const_vals, lookup_const_by_id};\n use middle::const_eval::{eval_const_expr, const_val, const_bool, const_float};\n+use middle::def::*;\n use middle::pat_util::*;\n use middle::ty::*;\n use middle::ty;"}, {"sha": "ca94cf2485038a93f5bd16269692108748334d8b", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -14,6 +14,7 @@\n use metadata::csearch;\n use middle::astencode;\n \n+use middle::def;\n use middle::ty;\n use middle::typeck::astconv;\n use util::nodemap::{DefIdMap};\n@@ -83,10 +84,10 @@ pub fn join_all<It: Iterator<constness>>(mut cs: It) -> constness {\n pub fn lookup_const(tcx: &ty::ctxt, e: &Expr) -> Option<@Expr> {\n     let opt_def = tcx.def_map.borrow().find_copy(&e.id);\n     match opt_def {\n-        Some(ast::DefStatic(def_id, false)) => {\n+        Some(def::DefStatic(def_id, false)) => {\n             lookup_const_by_id(tcx, def_id)\n         }\n-        Some(ast::DefVariant(enum_def, variant_def, _)) => {\n+        Some(def::DefVariant(enum_def, variant_def, _)) => {\n             lookup_variant_by_id(tcx, enum_def, variant_def)\n         }\n         _ => None"}, {"sha": "3eec3c7e8811aa5a34e7f60f1d2914ddc68c038d", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -17,15 +17,16 @@\n  */\n \n \n+use middle::def;\n+use middle::ty;\n+use middle::typeck;\n use std::io;\n use std::string::String;\n use std::uint;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::ast_util::IdRange;\n use syntax::print::{pp, pprust};\n-use middle::ty;\n-use middle::typeck;\n use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n \n@@ -757,7 +758,7 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n \n             Some(_) => {\n                 match self.tcx().def_map.borrow().find(&expr.id) {\n-                    Some(&ast::DefLabel(loop_id)) => {\n+                    Some(&def::DefLabel(loop_id)) => {\n                         match loop_scopes.iter().position(|l| l.loop_id == loop_id) {\n                             Some(i) => i,\n                             None => {"}, {"sha": "fb19fbd70c69e117c0159c6454bbc6bcc956b179", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -12,6 +12,7 @@\n // closely. The idea is that all reachable symbols are live, codes called\n // from live codes are live, and everything else is dead.\n \n+use middle::def;\n use middle::lint::{Allow, contains_lint, DeadCode};\n use middle::privacy;\n use middle::ty;\n@@ -21,7 +22,7 @@ use util::nodemap::NodeSet;\n use std::collections::HashSet;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{local_def, def_id_of_def, is_local};\n+use syntax::ast_util::{local_def, is_local};\n use syntax::attr;\n use syntax::codemap;\n use syntax::parse::token;\n@@ -77,9 +78,9 @@ impl<'a> MarkSymbolVisitor<'a> {\n             None => return\n         };\n         let def_id = match def {\n-            ast::DefVariant(enum_id, _, _) => Some(enum_id),\n-            ast::DefPrimTy(_) => None,\n-            _ => Some(def_id_of_def(def)),\n+            def::DefVariant(enum_id, _, _) => Some(enum_id),\n+            def::DefPrimTy(_) => None,\n+            _ => Some(def.def_id())\n         };\n         match def_id {\n             Some(def_id) => self.check_def_id(def_id),"}, {"sha": "ca89439eabad57dd87a39c5aa4ba77622555bd42", "filename": "src/librustc/middle/def.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -0,0 +1,89 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::ast;\n+use syntax::ast_util::local_def;\n+\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+pub enum Def {\n+    DefFn(ast::DefId, ast::FnStyle),\n+    DefStaticMethod(/* method */ ast::DefId, MethodProvenance, ast::FnStyle),\n+    DefSelfTy(/* trait id */ ast::NodeId),\n+    DefMod(ast::DefId),\n+    DefForeignMod(ast::DefId),\n+    DefStatic(ast::DefId, bool /* is_mutbl */),\n+    DefArg(ast::NodeId, ast::BindingMode),\n+    DefLocal(ast::NodeId, ast::BindingMode),\n+    DefVariant(ast::DefId /* enum */, ast::DefId /* variant */, bool /* is_structure */),\n+    DefTy(ast::DefId),\n+    DefTrait(ast::DefId),\n+    DefPrimTy(ast::PrimTy),\n+    DefTyParam(ast::DefId, uint),\n+    DefBinding(ast::NodeId, ast::BindingMode),\n+    DefUse(ast::DefId),\n+    DefUpvar(ast::NodeId,  // id of closed over var\n+             @Def,     // closed over def\n+             ast::NodeId,  // expr node that creates the closure\n+             ast::NodeId), // id for the block/body of the closure expr\n+\n+    /// Note that if it's a tuple struct's definition, the node id of the ast::DefId\n+    /// may either refer to the item definition's id or the StructDef.ctor_id.\n+    ///\n+    /// The cases that I have encountered so far are (this is not exhaustive):\n+    /// - If it's a ty_path referring to some tuple struct, then DefMap maps\n+    ///   it to a def whose id is the item definition's id.\n+    /// - If it's an ExprPath referring to some tuple struct, then DefMap maps\n+    ///   it to a def whose id is the StructDef.ctor_id.\n+    DefStruct(ast::DefId),\n+    DefTyParamBinder(ast::NodeId), /* struct, impl or trait with ty params */\n+    DefRegion(ast::NodeId),\n+    DefLabel(ast::NodeId),\n+    DefMethod(ast::DefId /* method */, Option<ast::DefId> /* trait */),\n+}\n+\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+pub enum MethodProvenance {\n+    FromTrait(ast::DefId),\n+    FromImpl(ast::DefId),\n+}\n+\n+impl Def {\n+    pub fn def_id(&self) -> ast::DefId {\n+        match *self {\n+            DefFn(id, _) | DefStaticMethod(id, _, _) | DefMod(id) |\n+            DefForeignMod(id) | DefStatic(id, _) |\n+            DefVariant(_, id, _) | DefTy(id) | DefTyParam(id, _) |\n+            DefUse(id) | DefStruct(id) | DefTrait(id) | DefMethod(id, _) => {\n+                id\n+            }\n+            DefArg(id, _) |\n+            DefLocal(id, _) |\n+            DefSelfTy(id) |\n+            DefUpvar(id, _, _, _) |\n+            DefBinding(id, _) |\n+            DefRegion(id) |\n+            DefTyParamBinder(id) |\n+            DefLabel(id) => {\n+                local_def(id)\n+            }\n+\n+            DefPrimTy(_) => fail!()\n+        }\n+    }\n+\n+    pub fn variant_def_ids(&self) -> Option<(ast::DefId, ast::DefId)> {\n+        match *self {\n+            DefVariant(enum_id, var_id, _) => {\n+                Some((enum_id, var_id))\n+            }\n+            _ => None\n+        }\n+    }\n+}"}, {"sha": "c75d793cba637c355d2bfa5c243f90da1974536a", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -11,6 +11,7 @@\n //! Enforces the Rust effect system. Currently there is just one effect,\n /// `unsafe`.\n \n+use middle::def;\n use middle::ty;\n use middle::typeck::MethodCall;\n use util::ppaux;\n@@ -183,7 +184,7 @@ impl<'a> Visitor<()> for EffectCheckVisitor<'a> {\n             }\n             ast::ExprPath(..) => {\n                 match ty::resolve_expr(self.tcx, expr) {\n-                    ast::DefStatic(_, true) => {\n+                    def::DefStatic(_, true) => {\n                         self.require_unsafe(expr.span, \"use of mutable static\")\n                     }\n                     _ => {}"}, {"sha": "c44ea0ae78b10a9765fbc466a8a1b70672f041ce", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -15,12 +15,12 @@\n  */\n \n use mc = middle::mem_categorization;\n+use middle::def;\n use middle::freevars;\n use middle::pat_util;\n use middle::ty;\n use middle::typeck;\n use syntax::ast;\n-use syntax::ast_util;\n use syntax::codemap::{Span};\n use util::ppaux::Repr;\n \n@@ -814,7 +814,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                             closure_expr: &ast::Expr,\n                             freevars: &[freevars::freevar_entry]) {\n         for freevar in freevars.iter() {\n-            let id_var = ast_util::def_id_of_def(freevar.def).node;\n+            let id_var = freevar.def.def_id().node;\n             let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n                                                                closure_expr.span,\n                                                                freevar.def));\n@@ -850,11 +850,11 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n     fn cat_captured_var(&mut self,\n                         closure_id: ast::NodeId,\n                         closure_span: Span,\n-                        upvar_def: ast::Def)\n+                        upvar_def: def::Def)\n                         -> mc::McResult<mc::cmt> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n-        let var_id = ast_util::def_id_of_def(upvar_def).node;\n+        let var_id = upvar_def.def_id().node;\n         let var_ty = ty::node_id_to_type(self.tcx(), var_id);\n         self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }"}, {"sha": "614972f3d5776dbd3ed6349b0ff690f66e9be3a9", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -13,12 +13,13 @@\n \n #![allow(non_camel_case_types)]\n \n+use middle::def;\n use middle::resolve;\n use middle::ty;\n use util::nodemap::{NodeMap, NodeSet};\n \n use syntax::codemap::Span;\n-use syntax::{ast, ast_util};\n+use syntax::{ast};\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -35,7 +36,7 @@ pub enum CaptureMode {\n // (The def_upvar will already have been stripped).\n #[deriving(Encodable, Decodable)]\n pub struct freevar_entry {\n-    pub def: ast::Def, //< The variable being accessed free.\n+    pub def: def::Def, //< The variable being accessed free.\n     pub span: Span     //< First span where it is accessed (there can be multiple)\n }\n pub type freevar_map = NodeMap<Vec<freevar_entry>>;\n@@ -64,13 +65,13 @@ impl<'a> Visitor<int> for CollectFreevarsVisitor<'a> {\n                         let mut def = df;\n                         while i < depth {\n                             match def {\n-                                ast::DefUpvar(_, inner, _, _) => { def = *inner; }\n+                                def::DefUpvar(_, inner, _, _) => { def = *inner; }\n                                 _ => break\n                             }\n                             i += 1;\n                         }\n                         if i == depth { // Made it to end of loop\n-                            let dnum = ast_util::def_id_of_def(def).node;\n+                            let dnum = def.def_id().node;\n                             if !self.seen.contains(&dnum) {\n                                 self.refs.push(freevar_entry {\n                                     def: def,"}, {"sha": "39f2e8425833c1e065c6a84cd479914638c29b2a", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -21,7 +21,7 @@ use syntax::ast::*;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::print::pprust::{expr_to_str,path_to_str};\n-use syntax::{visit,ast_util};\n+use syntax::{visit};\n use syntax::visit::Visitor;\n \n // Kind analysis pass.\n@@ -116,7 +116,7 @@ fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_t\n     let ast_trait_def = *cx.tcx.def_map.borrow()\n                               .find(&trait_ref.ref_id)\n                               .expect(\"trait ref not in def map!\");\n-    let trait_def_id = ast_util::def_id_of_def(ast_trait_def);\n+    let trait_def_id = ast_trait_def.def_id();\n     let trait_def = cx.tcx.trait_defs.borrow()\n                           .find_copy(&trait_def_id)\n                           .expect(\"trait def not in trait-defs map!\");\n@@ -141,7 +141,7 @@ fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_t\n             TyPath(_, ref bounds, path_node_id) => {\n                 assert!(bounds.is_none());\n                 let struct_def = cx.tcx.def_map.borrow().get_copy(&path_node_id);\n-                let struct_did = ast_util::def_id_of_def(struct_def);\n+                let struct_did = struct_def.def_id();\n                 check_struct_safe_for_destructor(cx, self_type.span, struct_did);\n             }\n             _ => {\n@@ -174,15 +174,15 @@ fn with_appropriate_checker(cx: &Context,\n     fn check_for_uniq(cx: &Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n         // all captured data must be owned, regardless of whether it is\n         // moved in or copied in.\n-        let id = ast_util::def_id_of_def(fv.def).node;\n+        let id = fv.def.def_id().node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n \n         check_freevar_bounds(cx, fv.span, var_t, bounds, None);\n     }\n \n     fn check_for_block(cx: &Context, fv: &freevar_entry,\n                        bounds: ty::BuiltinBounds, region: ty::Region) {\n-        let id = ast_util::def_id_of_def(fv.def).node;\n+        let id = fv.def.def_id().node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n         // FIXME(#3569): Figure out whether the implicit borrow is actually\n         // mutable. Currently we assume all upvars are referenced mutably.\n@@ -257,7 +257,7 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n             let def_map = cx.tcx.def_map.borrow();\n             let type_param_defs = match e.node {\n               ExprPath(_) => {\n-                let did = ast_util::def_id_of_def(def_map.get_copy(&e.id));\n+                let did = def_map.get_copy(&e.id).def_id();\n                 ty::lookup_item_type(cx.tcx, did).generics.type_param_defs.clone()\n               }\n               _ => {\n@@ -348,7 +348,7 @@ fn check_ty(cx: &mut Context, aty: &Ty) {\n                 None => { }\n                 Some(ref item_substs) => {\n                     let def_map = cx.tcx.def_map.borrow();\n-                    let did = ast_util::def_id_of_def(def_map.get_copy(&id));\n+                    let did = def_map.get_copy(&id).def_id();\n                     let generics = ty::lookup_item_type(cx.tcx, did).generics;\n                     let type_param_defs = generics.type_param_defs();\n                     for (&ty, type_param_def) in"}, {"sha": "cae8436d6df7079a240dc9bfbaa9689b1f1ca591", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -38,6 +38,8 @@\n use driver::session;\n use metadata::csearch;\n use middle::dead::DEAD_CODE_LINT_STR;\n+use middle::def;\n+use middle::def::*;\n use middle::pat_util;\n use middle::privacy;\n use middle::trans::adt; // for `adt::is_ffi_safe`\n@@ -935,17 +937,17 @@ fn check_item_ctypes(cx: &Context, it: &ast::Item) {\n         match ty.node {\n             ast::TyPath(_, _, id) => {\n                 match cx.tcx.def_map.borrow().get_copy(&id) {\n-                    ast::DefPrimTy(ast::TyInt(ast::TyI)) => {\n+                    def::DefPrimTy(ast::TyInt(ast::TyI)) => {\n                         cx.span_lint(CTypes, ty.span,\n                                 \"found rust type `int` in foreign module, while \\\n                                 libc::c_int or libc::c_long should be used\");\n                     }\n-                    ast::DefPrimTy(ast::TyUint(ast::TyU)) => {\n+                    def::DefPrimTy(ast::TyUint(ast::TyU)) => {\n                         cx.span_lint(CTypes, ty.span,\n                                 \"found rust type `uint` in foreign module, while \\\n                                 libc::c_uint or libc::c_ulong should be used\");\n                     }\n-                    ast::DefTy(def_id) => {\n+                    def::DefTy(def_id) => {\n                         if !adt::is_ffi_safe(cx.tcx, def_id) {\n                             cx.span_lint(CTypes, ty.span,\n                                          \"found enum type without foreign-function-safe \\\n@@ -1394,7 +1396,7 @@ fn check_item_non_uppercase_statics(cx: &Context, it: &ast::Item) {\n fn check_pat_non_uppercase_statics(cx: &Context, p: &ast::Pat) {\n     // Lint for constants that look like binding identifiers (#7526)\n     match (&p.node, cx.tcx.def_map.borrow().find(&p.id)) {\n-        (&ast::PatIdent(_, ref path, _), Some(&ast::DefStatic(_, false))) => {\n+        (&ast::PatIdent(_, ref path, _), Some(&def::DefStatic(_, false))) => {\n             // last identifier alone is right choice for this lint.\n             let ident = path.segments.last().unwrap().identifier;\n             let s = token::get_ident(ident);\n@@ -1411,8 +1413,8 @@ fn check_pat_uppercase_variable(cx: &Context, p: &ast::Pat) {\n     match &p.node {\n         &ast::PatIdent(_, ref path, _) => {\n             match cx.tcx.def_map.borrow().find(&p.id) {\n-                Some(&ast::DefLocal(_, _)) | Some(&ast::DefBinding(_, _)) |\n-                        Some(&ast::DefArg(_, _)) => {\n+                Some(&def::DefLocal(_, _)) | Some(&def::DefBinding(_, _)) |\n+                        Some(&def::DefArg(_, _)) => {\n                     // last identifier alone is right choice for this lint.\n                     let ident = path.segments.last().unwrap().identifier;\n                     let s = token::get_ident(ident);\n@@ -1726,7 +1728,7 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n     let id = match e.node {\n         ast::ExprPath(..) | ast::ExprStruct(..) => {\n             match cx.tcx.def_map.borrow().find(&e.id) {\n-                Some(&def) => ast_util::def_id_of_def(def),\n+                Some(&def) => def.def_id(),\n                 None => return\n             }\n         }"}, {"sha": "8b1de130053ee15f944f3640a9a87769df2784b8", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -102,7 +102,7 @@\n  *   to return explicitly.\n  */\n \n-\n+use middle::def::*;\n use middle::freevars;\n use middle::lint::{UnusedVariable, DeadAssignment};\n use middle::pat_util;\n@@ -486,7 +486,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n                 match moved_variable_node_id_from_def(fv.def) {\n                     Some(rv) => {\n                         let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n-                        let fv_id = ast_util::def_id_of_def(fv.def).node;\n+                        let fv_id = fv.def.def_id().node;\n                         let fv_ty = ty::node_id_to_type(ir.tcx, fv_id);\n                         let is_move = match fv_mode {\n                             // var must be dead afterwards"}, {"sha": "06e0a12577270b359dc87e012d29db6ddeca3474", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -62,6 +62,7 @@\n \n #![allow(non_camel_case_types)]\n \n+use middle::def;\n use middle::ty;\n use middle::typeck;\n use util::nodemap::NodeMap;\n@@ -489,20 +490,20 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                    id: ast::NodeId,\n                    span: Span,\n                    expr_ty: ty::t,\n-                   def: ast::Def)\n+                   def: def::Def)\n                    -> McResult<cmt> {\n         debug!(\"cat_def: id={} expr={} def={:?}\",\n                id, expr_ty.repr(self.tcx()), def);\n \n         match def {\n-          ast::DefStruct(..) | ast::DefVariant(..) => {\n+          def::DefStruct(..) | def::DefVariant(..) => {\n                 Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n-          ast::DefFn(..) | ast::DefStaticMethod(..) | ast::DefMod(_) |\n-          ast::DefForeignMod(_) | ast::DefStatic(_, false) |\n-          ast::DefUse(_) | ast::DefTrait(_) | ast::DefTy(_) | ast::DefPrimTy(_) |\n-          ast::DefTyParam(..) | ast::DefTyParamBinder(..) | ast::DefRegion(_) |\n-          ast::DefLabel(_) | ast::DefSelfTy(..) | ast::DefMethod(..) => {\n+          def::DefFn(..) | def::DefStaticMethod(..) | def::DefMod(_) |\n+          def::DefForeignMod(_) | def::DefStatic(_, false) |\n+          def::DefUse(_) | def::DefTrait(_) | def::DefTy(_) | def::DefPrimTy(_) |\n+          def::DefTyParam(..) | def::DefTyParamBinder(..) | def::DefRegion(_) |\n+          def::DefLabel(_) | def::DefSelfTy(..) | def::DefMethod(..) => {\n               Ok(Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n@@ -512,7 +513,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n               }))\n           }\n \n-          ast::DefStatic(_, true) => {\n+          def::DefStatic(_, true) => {\n               Ok(Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n@@ -522,7 +523,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n               }))\n           }\n \n-          ast::DefArg(vid, binding_mode) => {\n+          def::DefArg(vid, binding_mode) => {\n             // Idea: make this could be rewritten to model by-ref\n             // stuff as `&const` and `&mut`?\n \n@@ -540,7 +541,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n             }))\n           }\n \n-          ast::DefUpvar(var_id, _, fn_node_id, _) => {\n+          def::DefUpvar(var_id, _, fn_node_id, _) => {\n               let ty = if_ok!(self.node_ty(fn_node_id));\n               match ty::get(ty).sty {\n                   ty::ty_closure(ref closure_ty) => {\n@@ -582,8 +583,8 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n               }\n           }\n \n-          ast::DefLocal(vid, binding_mode) |\n-          ast::DefBinding(vid, binding_mode) => {\n+          def::DefLocal(vid, binding_mode) |\n+          def::DefBinding(vid, binding_mode) => {\n             // by-value/by-ref bindings are local variables\n             let m = match binding_mode {\n                 ast::BindByValue(ast::MutMutable) => McDeclared,\n@@ -987,7 +988,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n           }\n           ast::PatEnum(_, Some(ref subpats)) => {\n             match self.tcx().def_map.borrow().find(&pat.id) {\n-                Some(&ast::DefVariant(enum_did, _, _)) => {\n+                Some(&def::DefVariant(enum_did, _, _)) => {\n                     // variant(x, y, z)\n \n                     let downcast_cmt = {\n@@ -1009,8 +1010,8 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                         if_ok!(self.cat_pattern(subcmt, subpat, |x,y,z| op(x,y,z)));\n                     }\n                 }\n-                Some(&ast::DefFn(..)) |\n-                Some(&ast::DefStruct(..)) => {\n+                Some(&def::DefFn(..)) |\n+                Some(&def::DefStruct(..)) => {\n                     for (i, &subpat) in subpats.iter().enumerate() {\n                         let subpat_ty = if_ok!(self.pat_ty(subpat)); // see (*2)\n                         let cmt_field =\n@@ -1020,7 +1021,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                         if_ok!(self.cat_pattern(cmt_field, subpat, |x,y,z| op(x,y,z)));\n                     }\n                 }\n-                Some(&ast::DefStatic(..)) => {\n+                Some(&def::DefStatic(..)) => {\n                     for &subpat in subpats.iter() {\n                         if_ok!(self.cat_pattern(cmt.clone(), subpat, |x,y,z| op(x,y,z)));\n                     }"}, {"sha": "44ed0192d1d27601d809613ca6d7967db6ec615c", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use middle::def::*;\n use middle::resolve;\n \n use std::collections::HashMap;"}, {"sha": "fcd6d4246592ba54bba18f4cadcaa4047252a363", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -15,6 +15,7 @@\n use std::mem::replace;\n \n use metadata::csearch;\n+use middle::def;\n use middle::lint;\n use middle::resolve;\n use middle::ty;\n@@ -24,7 +25,7 @@ use util::nodemap::{NodeMap, NodeSet};\n \n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{is_local, def_id_of_def, local_def};\n+use syntax::ast_util::{is_local, local_def};\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token;\n@@ -243,9 +244,9 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n                 let public_ty = match ty.node {\n                     ast::TyPath(_, _, id) => {\n                         match self.tcx.def_map.borrow().get_copy(&id) {\n-                            ast::DefPrimTy(..) => true,\n+                            def::DefPrimTy(..) => true,\n                             def => {\n-                                let did = def_id_of_def(def);\n+                                let did = def.def_id();\n                                 !is_local(did) ||\n                                  self.exported_items.contains(&did.node)\n                             }\n@@ -301,9 +302,9 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n                 match ty.node {\n                     ast::TyPath(_, _, id) => {\n                         match self.tcx.def_map.borrow().get_copy(&id) {\n-                            ast::DefPrimTy(..) => {},\n+                            def::DefPrimTy(..) => {},\n                             def => {\n-                                let did = def_id_of_def(def);\n+                                let did = def.def_id();\n                                 if is_local(did) {\n                                     self.exported_items.insert(did.node);\n                                 }\n@@ -576,7 +577,7 @@ impl<'a> PrivacyVisitor<'a> {\n                             _ => return Some((err_span, err_msg, None)),\n                         };\n                         let def = self.tcx.def_map.borrow().get_copy(&id);\n-                        let did = def_id_of_def(def);\n+                        let did = def.def_id();\n                         assert!(is_local(did));\n                         match self.tcx.map.get(did.node) {\n                             ast_map::NodeItem(item) => item,\n@@ -673,7 +674,7 @@ impl<'a> PrivacyVisitor<'a> {\n                                                 .last()\n                                                 .unwrap()\n                                                 .identifier);\n-                let origdid = def_id_of_def(orig_def);\n+                let origdid = orig_def.def_id();\n                 self.ensure_public(span,\n                                    def,\n                                    Some(origdid),\n@@ -750,16 +751,16 @@ impl<'a> PrivacyVisitor<'a> {\n         // be accurate and we can get slightly wonky error messages (but type\n         // checking is always correct).\n         match self.tcx.def_map.borrow().get_copy(&path_id) {\n-            ast::DefStaticMethod(..) => ck(\"static method\"),\n-            ast::DefFn(..) => ck(\"function\"),\n-            ast::DefStatic(..) => ck(\"static\"),\n-            ast::DefVariant(..) => ck(\"variant\"),\n-            ast::DefTy(..) => ck(\"type\"),\n-            ast::DefTrait(..) => ck(\"trait\"),\n-            ast::DefStruct(..) => ck(\"struct\"),\n-            ast::DefMethod(_, Some(..)) => ck(\"trait method\"),\n-            ast::DefMethod(..) => ck(\"method\"),\n-            ast::DefMod(..) => ck(\"module\"),\n+            def::DefStaticMethod(..) => ck(\"static method\"),\n+            def::DefFn(..) => ck(\"function\"),\n+            def::DefStatic(..) => ck(\"static\"),\n+            def::DefVariant(..) => ck(\"variant\"),\n+            def::DefTy(..) => ck(\"type\"),\n+            def::DefTrait(..) => ck(\"trait\"),\n+            def::DefStruct(..) => ck(\"struct\"),\n+            def::DefMethod(_, Some(..)) => ck(\"trait method\"),\n+            def::DefMethod(..) => ck(\"method\"),\n+            def::DefMod(..) => ck(\"module\"),\n             _ => {}\n         }\n     }\n@@ -829,7 +830,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                     }\n                     ty::ty_enum(_, _) => {\n                         match self.tcx.def_map.borrow().get_copy(&expr.id) {\n-                            ast::DefVariant(_, variant_id, _) => {\n+                            def::DefVariant(_, variant_id, _) => {\n                                 for field in fields.iter() {\n                                     self.check_field(expr.span, variant_id,\n                                                      NamedField(field.ident.node));\n@@ -862,7 +863,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                     }\n                 };\n                 match self.tcx.def_map.borrow().find(&expr.id) {\n-                    Some(&ast::DefStruct(did)) => {\n+                    Some(&def::DefStruct(did)) => {\n                         guard(if is_local(did) {\n                             local_def(self.tcx.map.get_parent(did.node))\n                         } else {\n@@ -877,7 +878,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                     }\n                     // Tuple struct constructors across crates are identified as\n                     // DefFn types, so we explicitly handle that case here.\n-                    Some(&ast::DefFn(did, _)) if !is_local(did) => {\n+                    Some(&def::DefFn(did, _)) if !is_local(did) => {\n                         match csearch::get_tuple_struct_definition_if_ctor(\n                                     &self.tcx.sess.cstore, did) {\n                             Some(did) => guard(did),\n@@ -940,7 +941,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                     }\n                     ty::ty_enum(_, _) => {\n                         match self.tcx.def_map.borrow().find(&pattern.id) {\n-                            Some(&ast::DefVariant(_, variant_id, _)) => {\n+                            Some(&def::DefVariant(_, variant_id, _)) => {\n                                 for field in fields.iter() {\n                                     self.check_field(pattern.span, variant_id,\n                                                      NamedField(field.ident));\n@@ -1205,8 +1206,8 @@ impl<'a> VisiblePrivateTypesVisitor<'a> {\n     fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n         let did = match self.tcx.def_map.borrow().find_copy(&path_id) {\n             // `int` etc. (None doesn't seem to occur.)\n-            None | Some(ast::DefPrimTy(..)) => return false,\n-            Some(def) => def_id_of_def(def)\n+            None | Some(def::DefPrimTy(..)) => return false,\n+            Some(def) => def.def_id()\n         };\n         // A path can only be private if:\n         // it's in this crate..."}, {"sha": "ef2f78de8f975d0f59efa16db74b871e4cf3eaa4", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -16,6 +16,7 @@\n // reachable as well.\n \n use driver::config;\n+use middle::def;\n use middle::ty;\n use middle::typeck;\n use middle::privacy;\n@@ -25,7 +26,7 @@ use std::collections::HashSet;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{def_id_of_def, is_local};\n+use syntax::ast_util::{is_local};\n use syntax::attr;\n use syntax::visit::Visitor;\n use syntax::visit;\n@@ -109,7 +110,7 @@ impl<'a> Visitor<()> for ReachableContext<'a> {\n                     }\n                 };\n \n-                let def_id = def_id_of_def(def);\n+                let def_id = def.def_id();\n                 if is_local(def_id) {\n                     if self.def_id_represents_local_inlined_item(def_id) {\n                         self.worklist.push(def_id.node)\n@@ -119,7 +120,7 @@ impl<'a> Visitor<()> for ReachableContext<'a> {\n                             // to do some work to figure out whether the static\n                             // is indeed reachable (address_insignificant\n                             // statics are *never* reachable).\n-                            ast::DefStatic(..) => {\n+                            def::DefStatic(..) => {\n                                 self.worklist.push(def_id.node);\n                             }\n "}, {"sha": "f4962c9083aff1d0dbeee2554aab1563587bf605", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -13,14 +13,15 @@\n use driver::session::Session;\n use metadata::csearch;\n use metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n+use middle::def::*;\n use middle::lang_items::LanguageItems;\n use middle::lint::{UnnecessaryQualification, UnusedImports};\n use middle::pat_util::pat_bindings;\n use util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n \n use syntax::ast::*;\n use syntax::ast;\n-use syntax::ast_util::{def_id_of_def, local_def};\n+use syntax::ast_util::{local_def};\n use syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n use syntax::ext::mtwt;\n use syntax::parse::token::special_idents;\n@@ -1599,7 +1600,7 @@ impl<'a> Resolver<'a> {\n             }\n         };\n         if is_exported {\n-            self.external_exports.insert(def_id_of_def(def));\n+            self.external_exports.insert(def.def_id());\n         }\n         match def {\n           DefMod(def_id) | DefForeignMod(def_id) | DefStruct(def_id) |\n@@ -2438,7 +2439,7 @@ impl<'a> Resolver<'a> {\n             Some(ref target) => {\n                 let def = target.bindings.def_for_namespace(ValueNS).unwrap();\n                 self.def_map.borrow_mut().insert(directive.id, def);\n-                let did = def_id_of_def(def);\n+                let did = def.def_id();\n                 if value_used_public {Some(lp)} else {Some(DependsOn(did))}\n             },\n             // AllPublic here and below is a dummy value, it should never be used because\n@@ -2449,7 +2450,7 @@ impl<'a> Resolver<'a> {\n             Some(ref target) => {\n                 let def = target.bindings.def_for_namespace(TypeNS).unwrap();\n                 self.def_map.borrow_mut().insert(directive.id, def);\n-                let did = def_id_of_def(def);\n+                let did = def.def_id();\n                 if type_used_public {Some(lp)} else {Some(DependsOn(did))}\n             },\n             None => None,\n@@ -3307,10 +3308,10 @@ impl<'a> Resolver<'a> {\n             Some(d) => {\n                 let name = token::get_name(name);\n                 debug!(\"(computing exports) YES: export '{}' => {:?}\",\n-                       name, def_id_of_def(d));\n+                       name, d.def_id());\n                 exports2.push(Export2 {\n                     name: name.get().to_string(),\n-                    def_id: def_id_of_def(d)\n+                    def_id: d.def_id()\n                 });\n             }\n             d_opt => {\n@@ -3434,10 +3435,10 @@ impl<'a> Resolver<'a> {\n                 }\n                 FunctionRibKind(function_id, body_id) => {\n                     if !is_ty_param {\n-                        def = DefUpvar(def_id_of_def(def).node,\n-                                        @def,\n-                                        function_id,\n-                                        body_id);\n+                        def = DefUpvar(def.def_id().node,\n+                                       @def,\n+                                       function_id,\n+                                       body_id);\n                     }\n                 }\n                 MethodRibKind(item_id, _) => {\n@@ -3967,7 +3968,7 @@ impl<'a> Resolver<'a> {\n \n                 match self.def_map.borrow().find(&trait_ref.ref_id) {\n                     Some(def) => {\n-                        let did = def_id_of_def(*def);\n+                        let did = def.def_id();\n                         Some((did, trait_ref.clone()))\n                     }\n                     None => None\n@@ -4638,7 +4639,7 @@ impl<'a> Resolver<'a> {\n                         let p = child_name_bindings.defined_in_public_namespace(\n                                         namespace);\n                         let lp = if p {LastMod(AllPublic)} else {\n-                            LastMod(DependsOn(def_id_of_def(def)))\n+                            LastMod(DependsOn(def.def_id()))\n                         };\n                         return ChildNameDefinition(def, lp);\n                     }"}, {"sha": "c581dda3164a769c3db612dce72e3ce045417b5d", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -24,7 +24,7 @@ use syntax::codemap::Span;\n  * Represents the values to use when substituting lifetime parameters.\n  * If the value is `ErasedRegions`, then this subst is occurring during\n  * trans, and all region parameters will be replaced with `ty::ReStatic`. */\n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub enum RegionSubsts {\n     ErasedRegions,\n     NonerasedRegions(Vec<ty::Region>)\n@@ -47,7 +47,7 @@ pub enum RegionSubsts {\n  * - `self_ty` is the type to which `self` should be remapped, if any.  The\n  *   `self` type is rather funny in that it can only appear on traits and is\n  *   always substituted away to the implementing type for a trait. */\n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n pub struct Substs {\n     pub self_ty: Option<ty::t>,\n     pub tps: Vec<ty::t>,"}, {"sha": "2a3ec63e995ef3b089211fe9313339ca81acbc07", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -198,6 +198,7 @@ use back::abi;\n use driver::config::FullDebugInfo;\n use lib::llvm::{llvm, ValueRef, BasicBlockRef};\n use middle::const_eval;\n+use middle::def;\n use middle::lang_items::{UniqStrEqFnLangItem, StrEqFnLangItem};\n use middle::pat_util::*;\n use middle::resolve::DefMap;\n@@ -336,7 +337,7 @@ fn variant_opt(bcx: &Block, pat_id: ast::NodeId) -> Opt {\n     let ccx = bcx.ccx();\n     let def = ccx.tcx.def_map.borrow().get_copy(&pat_id);\n     match def {\n-        ast::DefVariant(enum_id, var_id, _) => {\n+        def::DefVariant(enum_id, var_id, _) => {\n             let variants = ty::enum_variants(ccx.tcx(), enum_id);\n             for v in (*variants).iter() {\n                 if var_id == v.id {\n@@ -346,8 +347,8 @@ fn variant_opt(bcx: &Block, pat_id: ast::NodeId) -> Opt {\n             }\n             unreachable!();\n         }\n-        ast::DefFn(..) |\n-        ast::DefStruct(_) => {\n+        def::DefFn(..) |\n+        def::DefStruct(_) => {\n             return lit(UnitLikeStructLit(pat_id));\n         }\n         _ => {\n@@ -603,7 +604,7 @@ fn enter_opt<'a, 'b>(\n             ast::PatEnum(..) |\n             ast::PatIdent(_, _, None) if pat_is_const(&tcx.def_map, p) => {\n                 let const_def = tcx.def_map.borrow().get_copy(&p.id);\n-                let const_def_id = ast_util::def_id_of_def(const_def);\n+                let const_def_id = const_def.def_id();\n                 if opt_eq(tcx, &lit(ConstLit(const_def_id)), opt) {\n                     Some(Vec::new())\n                 } else {\n@@ -644,7 +645,7 @@ fn enter_opt<'a, 'b>(\n                     // Look up the struct variant ID.\n                     let struct_id;\n                     match tcx.def_map.borrow().get_copy(&p.id) {\n-                        ast::DefVariant(_, found_struct_id, _) => {\n+                        def::DefVariant(_, found_struct_id, _) => {\n                             struct_id = found_struct_id;\n                         }\n                         _ => {\n@@ -918,15 +919,15 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n                 // variable binding.\n                 let opt_def = ccx.tcx.def_map.borrow().find_copy(&cur.id);\n                 match opt_def {\n-                    Some(ast::DefVariant(..)) => {\n+                    Some(def::DefVariant(..)) => {\n                         add_to_set(ccx.tcx(), &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n-                    Some(ast::DefStruct(..)) => {\n+                    Some(def::DefStruct(..)) => {\n                         add_to_set(ccx.tcx(), &mut found,\n                                    lit(UnitLikeStructLit(cur.id)));\n                     }\n-                    Some(ast::DefStatic(const_did, false)) => {\n+                    Some(def::DefStatic(const_did, false)) => {\n                         add_to_set(ccx.tcx(), &mut found,\n                                    lit(ConstLit(const_did)));\n                     }\n@@ -938,12 +939,12 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n                 // struct-like enum variant, or a struct.\n                 let opt_def = ccx.tcx.def_map.borrow().find_copy(&cur.id);\n                 match opt_def {\n-                    Some(ast::DefFn(..)) |\n-                    Some(ast::DefVariant(..)) => {\n+                    Some(def::DefFn(..)) |\n+                    Some(def::DefVariant(..)) => {\n                         add_to_set(ccx.tcx(), &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n-                    Some(ast::DefStatic(const_did, false)) => {\n+                    Some(def::DefStatic(const_did, false)) => {\n                         add_to_set(ccx.tcx(), &mut found,\n                                    lit(ConstLit(const_did)));\n                     }\n@@ -1122,8 +1123,8 @@ fn any_tuple_struct_pat(bcx: &Block, m: &[Match], col: uint) -> bool {\n         match pat.node {\n             ast::PatEnum(_, _) => {\n                 match bcx.tcx().def_map.borrow().find(&pat.id) {\n-                    Some(&ast::DefFn(..)) |\n-                    Some(&ast::DefStruct(..)) => true,\n+                    Some(&def::DefFn(..)) |\n+                    Some(&def::DefStruct(..)) => true,\n                     _ => false\n                 }\n             }\n@@ -2205,7 +2206,7 @@ fn bind_irrefutable_pat<'a>(\n         ast::PatEnum(_, ref sub_pats) => {\n             let opt_def = bcx.tcx().def_map.borrow().find_copy(&pat.id);\n             match opt_def {\n-                Some(ast::DefVariant(enum_id, var_id, _)) => {\n+                Some(def::DefVariant(enum_id, var_id, _)) => {\n                     let repr = adt::represent_node(bcx, pat.id);\n                     let vinfo = ty::enum_variant_with_id(ccx.tcx(),\n                                                          enum_id,\n@@ -2222,8 +2223,8 @@ fn bind_irrefutable_pat<'a>(\n                         }\n                     }\n                 }\n-                Some(ast::DefFn(..)) |\n-                Some(ast::DefStruct(..)) => {\n+                Some(def::DefFn(..)) |\n+                Some(def::DefStruct(..)) => {\n                     match *sub_pats {\n                         None => {\n                             // This is a unit-like struct. Nothing to do here.\n@@ -2241,7 +2242,7 @@ fn bind_irrefutable_pat<'a>(\n                         }\n                     }\n                 }\n-                Some(ast::DefStatic(_, false)) => {\n+                Some(def::DefStatic(_, false)) => {\n                 }\n                 _ => {\n                     // Nothing to do here."}, {"sha": "005fc446888a771ca28efe606fea2feae3dc5006", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -21,6 +21,7 @@ use driver::session;\n use lib::llvm::ValueRef;\n use lib::llvm::llvm;\n use metadata::csearch;\n+use middle::def;\n use middle::subst;\n use middle::subst::Subst;\n use middle::trans::base;\n@@ -114,42 +115,42 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n         return Callee {bcx: bcx, data: Fn(llfn)};\n     }\n \n-    fn trans_def<'a>(bcx: &'a Block<'a>, def: ast::Def, ref_expr: &ast::Expr)\n+    fn trans_def<'a>(bcx: &'a Block<'a>, def: def::Def, ref_expr: &ast::Expr)\n                  -> Callee<'a> {\n         match def {\n-            ast::DefFn(did, _) |\n-            ast::DefStaticMethod(did, ast::FromImpl(_), _) => {\n+            def::DefFn(did, _) |\n+            def::DefStaticMethod(did, def::FromImpl(_), _) => {\n                 fn_callee(bcx, trans_fn_ref(bcx, did, ExprId(ref_expr.id)))\n             }\n-            ast::DefStaticMethod(impl_did,\n-                                   ast::FromTrait(trait_did),\n-                                   _) => {\n+            def::DefStaticMethod(impl_did,\n+                                 def::FromTrait(trait_did),\n+                                 _) => {\n                 fn_callee(bcx, meth::trans_static_method_callee(bcx, impl_did,\n                                                                 trait_did,\n                                                                 ref_expr.id))\n             }\n-            ast::DefVariant(tid, vid, _) => {\n+            def::DefVariant(tid, vid, _) => {\n                 // nullary variants are not callable\n                 assert!(ty::enum_variant_with_id(bcx.tcx(),\n                                                       tid,\n                                                       vid).args.len() > 0u);\n                 fn_callee(bcx, trans_fn_ref(bcx, vid, ExprId(ref_expr.id)))\n             }\n-            ast::DefStruct(def_id) => {\n+            def::DefStruct(def_id) => {\n                 fn_callee(bcx, trans_fn_ref(bcx, def_id, ExprId(ref_expr.id)))\n             }\n-            ast::DefStatic(..) |\n-            ast::DefArg(..) |\n-            ast::DefLocal(..) |\n-            ast::DefBinding(..) |\n-            ast::DefUpvar(..) => {\n+            def::DefStatic(..) |\n+            def::DefArg(..) |\n+            def::DefLocal(..) |\n+            def::DefBinding(..) |\n+            def::DefUpvar(..) => {\n                 datum_callee(bcx, ref_expr)\n             }\n-            ast::DefMod(..) | ast::DefForeignMod(..) | ast::DefTrait(..) |\n-            ast::DefTy(..) | ast::DefPrimTy(..) |\n-            ast::DefUse(..) | ast::DefTyParamBinder(..) |\n-            ast::DefRegion(..) | ast::DefLabel(..) | ast::DefTyParam(..) |\n-            ast::DefSelfTy(..) | ast::DefMethod(..) => {\n+            def::DefMod(..) | def::DefForeignMod(..) | def::DefTrait(..) |\n+            def::DefTy(..) | def::DefPrimTy(..) |\n+            def::DefUse(..) | def::DefTyParamBinder(..) |\n+            def::DefRegion(..) | def::DefLabel(..) | def::DefTyParam(..) |\n+            def::DefSelfTy(..) | def::DefMethod(..) => {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n                     format!(\"cannot translate def {:?} \\"}, {"sha": "b5fd37d815fba78163bb8c0052c490b01141b969", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -13,6 +13,7 @@ use back::abi;\n use back::link::mangle_internal_name_by_path_and_seq;\n use driver::config::FullDebugInfo;\n use lib::llvm::ValueRef;\n+use middle::def;\n use middle::freevars;\n use middle::lang_items::ClosureExchangeMallocFnLangItem;\n use middle::trans::base::*;\n@@ -30,7 +31,6 @@ use util::ppaux::ty_to_str;\n \n use arena::TypedArena;\n use syntax::ast;\n-use syntax::ast_util;\n \n // ___Good to know (tm)__________________________________________________\n //\n@@ -282,7 +282,7 @@ fn load_environment<'a>(bcx: &'a Block<'a>,\n             ty::RegionTraitStore(..) => { upvarptr = Load(bcx, upvarptr); }\n             ty::UniqTraitStore => {}\n         }\n-        let def_id = ast_util::def_id_of_def(freevar.def);\n+        let def_id = freevar.def.def_id();\n \n         bcx.fcx.llupvars.borrow_mut().insert(def_id.node, upvarptr);\n \n@@ -368,13 +368,13 @@ pub fn trans_expr_fn<'a>(\n \n pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n                                closure_ty: ty::t,\n-                               def: ast::Def,\n+                               def: def::Def,\n                                fn_ptr: ValueRef,\n                                is_local: bool) -> ValueRef {\n \n     let def_id = match def {\n-        ast::DefFn(did, _) | ast::DefStaticMethod(did, _, _) |\n-        ast::DefVariant(_, did, _) | ast::DefStruct(did) => did,\n+        def::DefFn(did, _) | def::DefStaticMethod(did, _, _) |\n+        def::DefVariant(_, did, _) | def::DefStruct(did) => did,\n         _ => {\n             ccx.sess().bug(format!(\"get_wrapper_for_bare_fn: \\\n                                     expected a statically resolved fn, got \\\n@@ -453,7 +453,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n \n pub fn make_closure_from_bare_fn<'a>(bcx: &'a Block<'a>,\n                                      closure_ty: ty::t,\n-                                     def: ast::Def,\n+                                     def: def::Def,\n                                      fn_ptr: ValueRef)\n                                      -> DatumBlock<'a, Expr>  {\n     let scratch = rvalue_scratch_datum(bcx, closure_ty, \"__adjust\");"}, {"sha": "dbb6f3fe1cfb10d02d73b3b645d4df4c07a30209", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -17,6 +17,7 @@ use lib::llvm::{ValueRef, BasicBlockRef, BuilderRef};\n use lib::llvm::{True, False, Bool};\n use lib::llvm::llvm;\n use lib;\n+use middle::def;\n use middle::lang_items::LangItem;\n use middle::subst;\n use middle::subst::Subst;\n@@ -454,7 +455,7 @@ impl<'a> Block<'a> {\n         e.repr(self.tcx())\n     }\n \n-    pub fn def(&self, nid: ast::NodeId) -> ast::Def {\n+    pub fn def(&self, nid: ast::NodeId) -> def::Def {\n         match self.tcx().def_map.borrow().find(&nid) {\n             Some(&v) => v,\n             None => {"}, {"sha": "ac6e9ca6c645ef68e041f782386b6ca8dc2b13bc", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -17,6 +17,7 @@ use lib::llvm::{IntEQ, IntNE, IntUGT, IntUGE, IntULT, IntULE, IntSGT, IntSGE, In\n \n use metadata::csearch;\n use middle::const_eval;\n+use middle::def;\n use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::base::push_ctxt;\n@@ -617,7 +618,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n \n             let opt_def = cx.tcx().def_map.borrow().find_copy(&e.id);\n             match opt_def {\n-                Some(ast::DefFn(def_id, _fn_style)) => {\n+                Some(def::DefFn(def_id, _fn_style)) => {\n                     if !ast_util::is_local(def_id) {\n                         let ty = csearch::get_type(cx.tcx(), def_id).ty;\n                         (base::trans_external_path(cx, def_id, ty), true)\n@@ -626,18 +627,18 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                         (base::get_item_val(cx, def_id.node), true)\n                     }\n                 }\n-                Some(ast::DefStatic(def_id, false)) => {\n+                Some(def::DefStatic(def_id, false)) => {\n                     get_const_val(cx, def_id)\n                 }\n-                Some(ast::DefVariant(enum_did, variant_did, _)) => {\n+                Some(def::DefVariant(enum_did, variant_did, _)) => {\n                     let ety = ty::expr_ty(cx.tcx(), e);\n                     let repr = adt::represent_type(cx, ety);\n                     let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                          enum_did,\n                                                          variant_did);\n                     (adt::trans_const(cx, &*repr, vinfo.disr_val, []), true)\n                 }\n-                Some(ast::DefStruct(_)) => {\n+                Some(def::DefStruct(_)) => {\n                     let ety = ty::expr_ty(cx.tcx(), e);\n                     let llty = type_of::type_of(cx, ety);\n                     (C_null(llty), true)\n@@ -650,14 +651,14 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n           ast::ExprCall(callee, ref args) => {\n               let opt_def = cx.tcx().def_map.borrow().find_copy(&callee.id);\n               match opt_def {\n-                  Some(ast::DefStruct(_)) => {\n+                  Some(def::DefStruct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n                       let (arg_vals, inlineable) = map_list(args.as_slice());\n                       (adt::trans_const(cx, &*repr, 0, arg_vals.as_slice()),\n                        inlineable)\n                   }\n-                  Some(ast::DefVariant(enum_did, variant_did, _)) => {\n+                  Some(def::DefVariant(enum_did, variant_did, _)) => {\n                       let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n                       let vinfo = ty::enum_variant_with_id(cx.tcx(),"}, {"sha": "ea152c348087c4052d05682e862909f16f775464", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -10,6 +10,7 @@\n \n use lib::llvm::*;\n use driver::config::FullDebugInfo;\n+use middle::def;\n use middle::lang_items::{FailFnLangItem, FailBoundsCheckFnLangItem};\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -288,7 +289,7 @@ pub fn trans_break_cont<'a>(bcx: &'a Block<'a>,\n         None => fcx.top_loop_scope(),\n         Some(_) => {\n             match bcx.tcx().def_map.borrow().find(&expr_id) {\n-                Some(&ast::DefLabel(loop_id)) => loop_id,\n+                Some(&def::DefLabel(loop_id)) => loop_id,\n                 ref r => {\n                     bcx.tcx().sess.bug(format!(\"{:?} in def-map for label\",\n                                                r).as_slice())"}, {"sha": "d9ae9b08381708fc6cbdeb71983becba468b17e0", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -37,6 +37,7 @@ use back::abi;\n use lib::llvm::{ValueRef, llvm};\n use lib;\n use metadata::csearch;\n+use middle::def;\n use middle::lang_items::MallocFnLangItem;\n use middle::trans::_match;\n use middle::trans::adt;\n@@ -499,18 +500,18 @@ fn trans_index<'a>(bcx: &'a Block<'a>,\n \n fn trans_def<'a>(bcx: &'a Block<'a>,\n                  ref_expr: &ast::Expr,\n-                 def: ast::Def)\n+                 def: def::Def)\n                  -> DatumBlock<'a, Expr>\n {\n     //! Translates a reference to a path.\n \n     let _icx = push_ctxt(\"trans_def_lvalue\");\n     match def {\n-        ast::DefFn(..) | ast::DefStaticMethod(..) |\n-        ast::DefStruct(_) | ast::DefVariant(..) => {\n+        def::DefFn(..) | def::DefStaticMethod(..) |\n+        def::DefStruct(_) | def::DefVariant(..) => {\n             trans_def_fn_unadjusted(bcx, ref_expr, def)\n         }\n-        ast::DefStatic(did, _) => {\n+        def::DefStatic(did, _) => {\n             let const_ty = expr_ty(bcx, ref_expr);\n \n             fn get_did(ccx: &CrateContext, did: ast::DefId)\n@@ -775,7 +776,7 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n fn trans_def_dps_unadjusted<'a>(\n                             bcx: &'a Block<'a>,\n                             ref_expr: &ast::Expr,\n-                            def: ast::Def,\n+                            def: def::Def,\n                             dest: Dest)\n                             -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_def_dps_unadjusted\");\n@@ -786,7 +787,7 @@ fn trans_def_dps_unadjusted<'a>(\n     };\n \n     match def {\n-        ast::DefVariant(tid, vid, _) => {\n+        def::DefVariant(tid, vid, _) => {\n             let variant_info = ty::enum_variant_with_id(bcx.tcx(), tid, vid);\n             if variant_info.args.len() > 0u {\n                 // N-ary variant.\n@@ -802,7 +803,7 @@ fn trans_def_dps_unadjusted<'a>(\n                 return bcx;\n             }\n         }\n-        ast::DefStruct(_) => {\n+        def::DefStruct(_) => {\n             let ty = expr_ty(bcx, ref_expr);\n             match ty::get(ty).sty {\n                 ty::ty_struct(did, _) if ty::has_dtor(bcx.tcx(), did) => {\n@@ -823,16 +824,16 @@ fn trans_def_dps_unadjusted<'a>(\n \n fn trans_def_fn_unadjusted<'a>(bcx: &'a Block<'a>,\n                                ref_expr: &ast::Expr,\n-                               def: ast::Def) -> DatumBlock<'a, Expr> {\n+                               def: def::Def) -> DatumBlock<'a, Expr> {\n     let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n \n     let llfn = match def {\n-        ast::DefFn(did, _) |\n-        ast::DefStruct(did) | ast::DefVariant(_, did, _) |\n-        ast::DefStaticMethod(did, ast::FromImpl(_), _) => {\n+        def::DefFn(did, _) |\n+        def::DefStruct(did) | def::DefVariant(_, did, _) |\n+        def::DefStaticMethod(did, def::FromImpl(_), _) => {\n             callee::trans_fn_ref(bcx, did, ExprId(ref_expr.id))\n         }\n-        ast::DefStaticMethod(impl_did, ast::FromTrait(trait_did), _) => {\n+        def::DefStaticMethod(impl_did, def::FromTrait(trait_did), _) => {\n             meth::trans_static_method_callee(bcx, impl_did,\n                                              trait_did, ref_expr.id)\n         }\n@@ -849,7 +850,7 @@ fn trans_def_fn_unadjusted<'a>(bcx: &'a Block<'a>,\n }\n \n pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n-                           def: ast::Def)\n+                           def: def::Def)\n                            -> Datum<Lvalue> {\n     /*!\n      * Translates a reference to a local variable or argument.\n@@ -859,7 +860,7 @@ pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n     let _icx = push_ctxt(\"trans_local_var\");\n \n     return match def {\n-        ast::DefUpvar(nid, _, _, _) => {\n+        def::DefUpvar(nid, _, _, _) => {\n             // Can't move upvars, so this is never a ZeroMemLastUse.\n             let local_ty = node_id_type(bcx, nid);\n             match bcx.fcx.llupvars.borrow().find(&nid) {\n@@ -871,10 +872,10 @@ pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n                 }\n             }\n         }\n-        ast::DefArg(nid, _) => {\n+        def::DefArg(nid, _) => {\n             take_local(bcx, &*bcx.fcx.llargs.borrow(), nid)\n         }\n-        ast::DefLocal(nid, _) | ast::DefBinding(nid, _) => {\n+        def::DefLocal(nid, _) | def::DefBinding(nid, _) => {\n             take_local(bcx, &*bcx.fcx.lllocals.borrow(), nid)\n         }\n         _ => {\n@@ -931,7 +932,7 @@ pub fn with_field_tys<R>(tcx: &ty::ctxt,\n                 Some(node_id) => {\n                     let def = tcx.def_map.borrow().get_copy(&node_id);\n                     match def {\n-                        ast::DefVariant(enum_id, variant_id, _) => {\n+                        def::DefVariant(enum_id, variant_id, _) => {\n                             let variant_info = ty::enum_variant_with_id(\n                                 tcx, enum_id, variant_id);\n                             op(variant_info.disr_val,"}, {"sha": "6275abdc8ab209a893742e8a0dd017833e535b75", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -16,6 +16,7 @@ use metadata::csearch;\n use mc = middle::mem_categorization;\n use middle::lint;\n use middle::const_eval;\n+use middle::def;\n use middle::dependency_format;\n use middle::lang_items::{ExchangeHeapLangItem, OpaqueStructLangItem};\n use middle::lang_items::{TyDescStructLangItem, TyVisitorTraitLangItem};\n@@ -2945,7 +2946,7 @@ pub fn method_call_type_param_defs(tcx: &ctxt, origin: typeck::MethodOrigin)\n     }\n }\n \n-pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> ast::Def {\n+pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> def::Def {\n     match tcx.def_map.borrow().find(&expr.id) {\n         Some(&def) => def,\n         None => {\n@@ -2993,7 +2994,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n     match expr.node {\n         ast::ExprPath(..) => {\n             match resolve_expr(tcx, expr) {\n-                ast::DefVariant(tid, vid, _) => {\n+                def::DefVariant(tid, vid, _) => {\n                     let variant_info = enum_variant_with_id(tcx, tid, vid);\n                     if variant_info.args.len() > 0u {\n                         // N-ary variant.\n@@ -3004,24 +3005,24 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                     }\n                 }\n \n-                ast::DefStruct(_) => {\n+                def::DefStruct(_) => {\n                     match get(expr_ty(tcx, expr)).sty {\n                         ty_bare_fn(..) => RvalueDatumExpr,\n                         _ => RvalueDpsExpr\n                     }\n                 }\n \n                 // Fn pointers are just scalar values.\n-                ast::DefFn(..) | ast::DefStaticMethod(..) => RvalueDatumExpr,\n+                def::DefFn(..) | def::DefStaticMethod(..) => RvalueDatumExpr,\n \n                 // Note: there is actually a good case to be made that\n                 // DefArg's, particularly those of immediate type, ought to\n                 // considered rvalues.\n-                ast::DefStatic(..) |\n-                ast::DefBinding(..) |\n-                ast::DefUpvar(..) |\n-                ast::DefArg(..) |\n-                ast::DefLocal(..) => LvalueExpr,\n+                def::DefStatic(..) |\n+                def::DefBinding(..) |\n+                def::DefUpvar(..) |\n+                def::DefArg(..) |\n+                def::DefLocal(..) => LvalueExpr,\n \n                 def => {\n                     tcx.sess.span_bug(\n@@ -3112,7 +3113,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 Some(&def) => def,\n                 None => fail!(\"no def for place\"),\n             };\n-            let def_id = ast_util::def_id_of_def(definition);\n+            let def_id = definition.def_id();\n             match tcx.lang_items.items.get(ExchangeHeapLangItem as uint) {\n                 &Some(item_def_id) if def_id == item_def_id => {\n                     RvalueDatumExpr\n@@ -3534,7 +3535,7 @@ pub fn trait_ref_to_def_id(tcx: &ctxt, tr: &ast::TraitRef) -> ast::DefId {\n     let def = *tcx.def_map.borrow()\n                      .find(&tr.ref_id)\n                      .expect(\"no def-map entry for trait\");\n-    ast_util::def_id_of_def(def)\n+    def.def_id()\n }\n \n pub fn try_add_builtin_trait(tcx: &ctxt,"}, {"sha": "f8821a86e717770d56cfa39cc6c851c2c672da92", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -49,8 +49,8 @@\n  * an rptr (`&r.T`) use the region `r` that appears in the rptr.\n  */\n \n-\n use middle::const_eval;\n+use middle::def;\n use middle::subst;\n use middle::subst::{Subst, Substs};\n use middle::ty::{ty_param_substs_and_ty};\n@@ -329,7 +329,7 @@ pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n                 Some(&d) => d\n             };\n             match a_def {\n-                ast::DefPrimTy(nty) => {\n+                def::DefPrimTy(nty) => {\n                     match nty {\n                         ast::TyBool => {\n                             check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n@@ -402,7 +402,7 @@ pub fn ast_ty_to_builtin_ty<AC:AstConv,\n             // FIXME(#12938): This is a hack until we have full support for\n             // DST.\n             match a_def {\n-                ast::DefTy(did) | ast::DefStruct(did)\n+                def::DefTy(did) | def::DefStruct(did)\n                         if Some(did) == this.tcx().lang_items.owned_box() => {\n                     if path.segments\n                            .iter()\n@@ -496,7 +496,7 @@ fn mk_pointer<AC:AstConv,\n             // restriction is enforced in the below case for ty_path, which\n             // will run after this as long as the path isn't a trait.\n             match tcx.def_map.borrow().find(&id) {\n-                Some(&ast::DefPrimTy(ast::TyStr)) => {\n+                Some(&def::DefPrimTy(ast::TyStr)) => {\n                     check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                     match ptr_ty {\n                         Uniq => {\n@@ -512,7 +512,7 @@ fn mk_pointer<AC:AstConv,\n                         }\n                     }\n                 }\n-                Some(&ast::DefTrait(trait_def_id)) => {\n+                Some(&def::DefTrait(trait_def_id)) => {\n                     let result = ast_path_to_trait_ref(\n                         this, rscope, trait_def_id, None, path);\n                     let trait_store = match ptr_ty {\n@@ -661,14 +661,14 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 // Kind bounds on path types are only supported for traits.\n                 match a_def {\n                     // But don't emit the error if the user meant to do a trait anyway.\n-                    ast::DefTrait(..) => { },\n+                    def::DefTrait(..) => { },\n                     _ if bounds.is_some() =>\n                         tcx.sess.span_err(ast_ty.span,\n                                           \"kind bounds can only be used on trait types\"),\n                     _ => { },\n                 }\n                 match a_def {\n-                    ast::DefTrait(_) => {\n+                    def::DefTrait(_) => {\n                         let path_str = path_to_str(path);\n                         tcx.sess.span_err(\n                             ast_ty.span,\n@@ -678,27 +678,27 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                                     name=path_str).as_slice());\n                         ty::mk_err()\n                     }\n-                    ast::DefTy(did) | ast::DefStruct(did) => {\n+                    def::DefTy(did) | def::DefStruct(did) => {\n                         ast_path_to_ty(this, rscope, did, path).ty\n                     }\n-                    ast::DefTyParam(id, n) => {\n+                    def::DefTyParam(id, n) => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                         ty::mk_param(tcx, n, id)\n                     }\n-                    ast::DefSelfTy(id) => {\n+                    def::DefSelfTy(id) => {\n                         // n.b.: resolve guarantees that the this type only appears in a\n                         // trait, which we rely upon in various places when creating\n                         // substs\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                         let did = ast_util::local_def(id);\n                         ty::mk_self(tcx, did)\n                     }\n-                    ast::DefMod(id) => {\n+                    def::DefMod(id) => {\n                         tcx.sess.span_fatal(ast_ty.span,\n                             format!(\"found module name used as a type: {}\",\n                                     tcx.map.node_to_str(id.node)).as_slice());\n                     }\n-                    ast::DefPrimTy(_) => {\n+                    def::DefPrimTy(_) => {\n                         fail!(\"DefPrimTy arm missed in previous ast_ty_to_prim_ty call\");\n                     }\n                     _ => {\n@@ -912,7 +912,7 @@ fn conv_builtin_bounds(tcx: &ty::ctxt, ast_bounds: &Option<OwnedSlice<ast::TyPar\n                 match *ast_bound {\n                     ast::TraitTyParamBound(ref b) => {\n                         match lookup_def_tcx(tcx, b.path.span, b.ref_id) {\n-                            ast::DefTrait(trait_did) => {\n+                            def::DefTrait(trait_did) => {\n                                 if ty::try_add_builtin_trait(tcx, trait_did,\n                                                              &mut builtin_bounds) {\n                                     continue; // success"}, {"sha": "df774b215042b6cccd73a6740b4797873643ccf4", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -10,6 +10,7 @@\n \n #![allow(non_camel_case_types)]\n \n+use middle::def;\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding, pat_is_const};\n use middle::subst;\n use middle::subst::Subst;\n@@ -128,7 +129,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n         ty::ty_enum(_, ref expected_substs) => {\n             // Lookup the enum and variant def ids:\n             let v_def = lookup_def(pcx.fcx, pat.span, pat.id);\n-            match ast_util::variant_def_ids(v_def) {\n+            match v_def.variant_def_ids() {\n                 Some((enm, var)) => {\n                     // Assign the pattern the type of the *enum*, not the variant.\n                     let enum_tpt = ty::lookup_item_type(tcx, enm);\n@@ -188,7 +189,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n         ty::ty_struct(struct_def_id, ref expected_substs) => {\n             // Lookup the struct ctor def id\n             let s_def = lookup_def(pcx.fcx, pat.span, pat.id);\n-            let s_def_id = ast_util::def_id_of_def(s_def);\n+            let s_def_id = s_def.def_id();\n \n             // Assign the pattern the type of the struct.\n             let ctor_tpt = ty::lookup_item_type(tcx, s_def_id);\n@@ -372,11 +373,11 @@ pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::NodeId, span: Span,\n \n     // Check to ensure that the struct is the one specified.\n     match tcx.def_map.borrow().find(&pat_id) {\n-        Some(&ast::DefStruct(supplied_def_id))\n+        Some(&def::DefStruct(supplied_def_id))\n                 if supplied_def_id == struct_id => {\n             // OK.\n         }\n-        Some(&ast::DefStruct(..)) | Some(&ast::DefVariant(..)) => {\n+        Some(&def::DefStruct(..)) | Some(&def::DefVariant(..)) => {\n             let name = pprust::path_to_str(path);\n             tcx.sess\n                .span_err(span,\n@@ -408,15 +409,15 @@ pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n \n     // Find the variant that was specified.\n     match tcx.def_map.borrow().find(&pat_id) {\n-        Some(&ast::DefVariant(found_enum_id, variant_id, _))\n+        Some(&def::DefVariant(found_enum_id, variant_id, _))\n                 if found_enum_id == enum_id => {\n             // Get the struct fields from this struct-like enum variant.\n             let class_fields = ty::lookup_struct_fields(tcx, variant_id);\n \n             check_struct_pat_fields(pcx, span, fields, class_fields,\n                                     variant_id, substitutions, etc);\n         }\n-        Some(&ast::DefStruct(..)) | Some(&ast::DefVariant(..)) => {\n+        Some(&def::DefStruct(..)) | Some(&def::DefVariant(..)) => {\n             let name = pprust::path_to_str(path);\n             tcx.sess.span_err(span,\n                               format!(\"mismatched types: expected `{}` but \\\n@@ -477,8 +478,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n       }\n       ast::PatEnum(..) |\n       ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n-        let const_did = ast_util::def_id_of_def(tcx.def_map.borrow()\n-                                                   .get_copy(&pat.id));\n+        let const_did = tcx.def_map.borrow().get_copy(&pat.id).def_id();\n         let const_tpt = ty::lookup_item_type(tcx, const_did);\n         demand::suptype(fcx, pat.span, expected, const_tpt.ty);\n         fcx.write_ty(pat.id, const_tpt.ty);\n@@ -558,7 +558,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                             \"a structure pattern\".to_string(),\n                             None);\n                 match tcx.def_map.borrow().find(&pat.id) {\n-                    Some(&ast::DefStruct(supplied_def_id)) => {\n+                    Some(&def::DefStruct(supplied_def_id)) => {\n                          check_struct_pat(pcx,\n                                           pat.id,\n                                           pat.span,"}, {"sha": "a09c92d4db01fa29765cd0a52a35fce0af711060", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -78,6 +78,7 @@ type parameter).\n \n \n use middle::const_eval;\n+use middle::def;\n use middle::lang_items::{ExchangeHeapLangItem, GcLangItem};\n use middle::lang_items::{ManagedHeapLangItem};\n use middle::lint::UnreachableCode;\n@@ -1523,13 +1524,13 @@ pub enum DerefArgs {\n // Given the provenance of a static method, returns the generics of the static\n // method's container.\n fn generics_of_static_method_container(type_context: &ty::ctxt,\n-                                       provenance: ast::MethodProvenance)\n+                                       provenance: def::MethodProvenance)\n                                        -> ty::Generics {\n     match provenance {\n-        ast::FromTrait(trait_def_id) => {\n+        def::FromTrait(trait_def_id) => {\n             ty::lookup_trait_def(type_context, trait_def_id).generics.clone()\n         }\n-        ast::FromImpl(impl_def_id) => {\n+        def::FromImpl(impl_def_id) => {\n             ty::lookup_item_type(type_context, impl_def_id).generics.clone()\n         }\n     }\n@@ -1539,7 +1540,7 @@ fn generics_of_static_method_container(type_context: &ty::ctxt,\n // locations.\n fn check_type_parameter_positions_in_path(function_context: &FnCtxt,\n                                           path: &ast::Path,\n-                                          def: ast::Def) {\n+                                          def: def::Def) {\n     // We only care about checking the case in which the path has two or\n     // more segments.\n     if path.segments.len() < 2 {\n@@ -1580,13 +1581,13 @@ fn check_type_parameter_positions_in_path(function_context: &FnCtxt,\n         // ensure that the segment of the path which names the trait or\n         // implementation (the penultimate segment) is annotated with the\n         // right number of type parameters.\n-        ast::DefStaticMethod(_, provenance, _) => {\n+        def::DefStaticMethod(_, provenance, _) => {\n             let generics =\n                 generics_of_static_method_container(function_context.ccx.tcx,\n                                                     provenance);\n             let name = match provenance {\n-                ast::FromTrait(_) => \"trait\",\n-                ast::FromImpl(_) => \"impl\",\n+                def::FromTrait(_) => \"trait\",\n+                def::FromImpl(_) => \"impl\",\n             };\n \n             let trait_segment = &path.segments.get(path.segments.len() - 2);\n@@ -2706,7 +2707,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                   // FIXME(pcwalton): For now we hardcode the two permissible\n                   // places: the exchange heap and the managed heap.\n                   let definition = lookup_def(fcx, path.span, place.id);\n-                  let def_id = ast_util::def_id_of_def(definition);\n+                  let def_id = definition.def_id();\n                   match tcx.lang_items\n                            .items\n                            .get(ExchangeHeapLangItem as uint) {\n@@ -3256,11 +3257,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         // Resolve the path.\n         let def = tcx.def_map.borrow().find(&id).map(|i| *i);\n         match def {\n-            Some(ast::DefStruct(type_def_id)) => {\n+            Some(def::DefStruct(type_def_id)) => {\n                 check_struct_constructor(fcx, id, expr.span, type_def_id,\n                                          fields.as_slice(), base_expr);\n             }\n-            Some(ast::DefVariant(enum_id, variant_id, _)) => {\n+            Some(def::DefVariant(enum_id, variant_id, _)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n                                           variant_id, fields.as_slice());\n             }\n@@ -3809,54 +3810,54 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n     check_instantiable(ccx.tcx, sp, id);\n }\n \n-pub fn lookup_def(fcx: &FnCtxt, sp: Span, id: ast::NodeId) -> ast::Def {\n+pub fn lookup_def(fcx: &FnCtxt, sp: Span, id: ast::NodeId) -> def::Def {\n     lookup_def_ccx(fcx.ccx, sp, id)\n }\n \n // Returns the type parameter count and the type for the given definition.\n pub fn ty_param_bounds_and_ty_for_def(fcx: &FnCtxt,\n                                       sp: Span,\n-                                      defn: ast::Def)\n+                                      defn: def::Def)\n                                    -> ty_param_bounds_and_ty {\n     match defn {\n-      ast::DefArg(nid, _) | ast::DefLocal(nid, _) |\n-      ast::DefBinding(nid, _) => {\n+      def::DefArg(nid, _) | def::DefLocal(nid, _) |\n+      def::DefBinding(nid, _) => {\n           let typ = fcx.local_ty(sp, nid);\n           return no_params(typ);\n       }\n-      ast::DefFn(id, _) | ast::DefStaticMethod(id, _, _) |\n-      ast::DefStatic(id, _) | ast::DefVariant(_, id, _) |\n-      ast::DefStruct(id) => {\n+      def::DefFn(id, _) | def::DefStaticMethod(id, _, _) |\n+      def::DefStatic(id, _) | def::DefVariant(_, id, _) |\n+      def::DefStruct(id) => {\n         return ty::lookup_item_type(fcx.ccx.tcx, id);\n       }\n-      ast::DefUpvar(_, inner, _, _) => {\n+      def::DefUpvar(_, inner, _, _) => {\n         return ty_param_bounds_and_ty_for_def(fcx, sp, *inner);\n       }\n-      ast::DefTrait(_) |\n-      ast::DefTy(_) |\n-      ast::DefPrimTy(_) |\n-      ast::DefTyParam(..)=> {\n+      def::DefTrait(_) |\n+      def::DefTy(_) |\n+      def::DefPrimTy(_) |\n+      def::DefTyParam(..)=> {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found type\");\n       }\n-      ast::DefMod(..) | ast::DefForeignMod(..) => {\n+      def::DefMod(..) | def::DefForeignMod(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found module\");\n       }\n-      ast::DefUse(..) => {\n+      def::DefUse(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found use\");\n       }\n-      ast::DefRegion(..) => {\n+      def::DefRegion(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found region\");\n       }\n-      ast::DefTyParamBinder(..) => {\n+      def::DefTyParamBinder(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found type parameter\");\n       }\n-      ast::DefLabel(..) => {\n+      def::DefLabel(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found label\");\n       }\n-      ast::DefSelfTy(..) => {\n+      def::DefSelfTy(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found self ty\");\n       }\n-      ast::DefMethod(..) => {\n+      def::DefMethod(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found method\");\n       }\n     }\n@@ -3867,7 +3868,7 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: &FnCtxt,\n pub fn instantiate_path(fcx: &FnCtxt,\n                         pth: &ast::Path,\n                         tpt: ty_param_bounds_and_ty,\n-                        def: ast::Def,\n+                        def: def::Def,\n                         span: Span,\n                         node_id: ast::NodeId) {\n     debug!(\">>> instantiate_path\");\n@@ -3918,7 +3919,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n     // of type parameters actually manifest in the AST. This will differ from\n     // the internal type parameter count when there are self types involved.\n     let (user_ty_param_count, user_ty_param_req, self_parameter_index) = match def {\n-        ast::DefStaticMethod(_, provenance @ ast::FromTrait(_), _) => {\n+        def::DefStaticMethod(_, provenance @ def::FromTrait(_), _) => {\n             let generics = generics_of_static_method_container(fcx.ccx.tcx,\n                                                                provenance);\n             (ty_param_count - 1, ty_param_req - 1, Some(generics.type_param_defs().len()))\n@@ -4153,7 +4154,7 @@ pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: ast::P<ast::Block>) -> bool\n         match e.node {\n             ast::ExprBreak(Some(_)) => {\n                 match cx.def_map.borrow().find(&e.id) {\n-                    Some(&ast::DefLabel(loop_id)) if id == loop_id => true,\n+                    Some(&def::DefLabel(loop_id)) if id == loop_id => true,\n                     _ => false,\n                 }\n             }"}, {"sha": "e1db465424af88946486e9362e1f09bed4082c93", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -118,7 +118,8 @@ and report an error, and it just seems like more mess in the end.)\n \n */\n \n-\n+use middle::def;\n+use middle::def::{DefArg, DefBinding, DefLocal, DefUpvar};\n use middle::freevars;\n use mc = middle::mem_categorization;\n use middle::ty::{ReScope};\n@@ -134,9 +135,7 @@ use middle::pat_util;\n use util::nodemap::NodeMap;\n use util::ppaux::{ty_to_str, region_to_str, Repr};\n \n-use syntax::ast::{DefArg, DefBinding, DefLocal, DefUpvar};\n use syntax::ast;\n-use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -163,7 +162,7 @@ pub struct Rcx<'a> {\n     repeating_scope: ast::NodeId,\n }\n \n-fn region_of_def(fcx: &FnCtxt, def: ast::Def) -> ty::Region {\n+fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n     /*!\n      * Returns the validity region of `def` -- that is, how long\n      * is `def` valid?\n@@ -665,7 +664,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n \n             // Identify the variable being closed over and its node-id.\n             let def = freevar.def;\n-            let def_id = ast_util::def_id_of_def(def);\n+            let def_id = def.def_id();\n             assert!(def_id.krate == ast::LOCAL_CRATE);\n             let upvar_id = ty::UpvarId { var_id: def_id.node,\n                                          closure_expr_id: expr.id };\n@@ -725,7 +724,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             // determining the final borrow_kind) and propagate that as\n             // a constraint on the outer closure.\n             match freevar.def {\n-                ast::DefUpvar(var_id, _, outer_closure_id, _) => {\n+                def::DefUpvar(var_id, _, outer_closure_id, _) => {\n                     // thing being captured is itself an upvar:\n                     let outer_upvar_id = ty::UpvarId {\n                         var_id: var_id,"}, {"sha": "2bbbf3102eac20a99488ba7dc94df5cc0f7f61e0", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -632,7 +632,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n             debug!(\"vtable resolution on parameter bounds for expr {}\",\n                    ex.repr(fcx.tcx()));\n             let def = cx.tcx.def_map.borrow().get_copy(&ex.id);\n-            let did = ast_util::def_id_of_def(def);\n+            let did = def.def_id();\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n             debug!(\"early resolve expr: def {:?} {:?}, {:?}, {}\", ex.id, did, def,\n                    fcx.infcx().ty_to_str(item_ty.ty));"}, {"sha": "63dc122f7cbf64c3082ae050e15e631466a7df71", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -12,7 +12,7 @@\n // unresolved type variables and replaces \"ty_var\" types with their\n // substitutions.\n \n-\n+use middle::def;\n use middle::pat_util;\n use middle::subst;\n use middle::ty;\n@@ -232,10 +232,10 @@ impl<'cx> WritebackCx<'cx> {\n                         // bare functions to coerce to a closure to avoid\n                         // constructing (slower) indirect call wrappers.\n                         match self.tcx().def_map.borrow().find(&id) {\n-                            Some(&ast::DefFn(..)) |\n-                            Some(&ast::DefStaticMethod(..)) |\n-                            Some(&ast::DefVariant(..)) |\n-                            Some(&ast::DefStruct(_)) => {\n+                            Some(&def::DefFn(..)) |\n+                            Some(&def::DefStaticMethod(..)) |\n+                            Some(&def::DefVariant(..)) |\n+                            Some(&def::DefStruct(_)) => {\n                             }\n                             _ => {\n                                 self.tcx().sess.span_err("}, {"sha": "99a6aad715ccbf548c9f1895e3a6b58f77a5651b", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -35,13 +35,14 @@ use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::{new_infer_ctxt, resolve_ivar, resolve_type};\n use middle::typeck::infer;\n use util::ppaux::Repr;\n-use syntax::ast::{Crate, DefId, DefStruct, DefTy};\n+use middle::def::{DefStruct, DefTy};\n+use syntax::ast::{Crate, DefId};\n use syntax::ast::{Item, ItemEnum, ItemImpl, ItemMod, ItemStruct};\n use syntax::ast::{LOCAL_CRATE, TraitRef, TyPath};\n use syntax::ast;\n use syntax::ast_map::NodeItem;\n use syntax::ast_map;\n-use syntax::ast_util::{def_id_of_def, local_def};\n+use syntax::ast_util::{local_def};\n use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::visit;\n@@ -543,7 +544,7 @@ impl<'a> CoherenceChecker<'a> {\n     fn trait_ref_to_trait_def_id(&self, trait_ref: &TraitRef) -> DefId {\n         let def_map = &self.crate_context.tcx.def_map;\n         let trait_def = def_map.borrow().get_copy(&trait_ref.ref_id);\n-        let trait_id = def_id_of_def(trait_def);\n+        let trait_id = trait_def.def_id();\n         return trait_id;\n     }\n "}, {"sha": "c6bc6ce72974052cc40b7143650ad0e8efa98547", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -32,6 +32,7 @@ are represented as `ty_param()` instances.\n \n \n use metadata::csearch;\n+use middle::def;\n use middle::lang_items::SizedTraitLangItem;\n use middle::resolve_lifetime;\n use middle::subst;\n@@ -740,7 +741,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n             ast::TyPath(_, _, path_id) => {\n                 let def_map = tcx.def_map.borrow();\n                 match def_map.find(&path_id) {\n-                    Some(&ast::DefStruct(def_id)) => {\n+                    Some(&def::DefStruct(def_id)) => {\n                         // FIXME(#12511) Check for cycles in the inheritance hierarchy.\n                         // Check super-struct is virtual.\n                         match tcx.map.find(def_id.node) {\n@@ -831,7 +832,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n     let rscope = ExplicitRscope;\n \n     match lookup_def_tcx(ccx.tcx, ast_trait_ref.path.span, ast_trait_ref.ref_id) {\n-        ast::DefTrait(trait_did) => {\n+        def::DefTrait(trait_did) => {\n             let trait_ref =\n                 astconv::ast_path_to_trait_ref(\n                     ccx, &rscope, trait_did, Some(self_ty), &ast_trait_ref.path);"}, {"sha": "6464b191b76911b431cdabbb970ef4af4d9ae57f", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -60,6 +60,7 @@ time of error detection.\n */\n \n use std::collections::HashSet;\n+use middle::def;\n use middle::ty;\n use middle::ty::{Region, ReFree};\n use middle::typeck::infer;\n@@ -1045,7 +1046,7 @@ impl<'a> Rebuilder<'a> {\n                         Some(&d) => d\n                     };\n                     match a_def {\n-                        ast::DefTy(did) | ast::DefStruct(did) => {\n+                        def::DefTy(did) | def::DefStruct(did) => {\n                             let ty::ty_param_bounds_and_ty {\n                                 generics: generics,\n                                 ty: _"}, {"sha": "9bf6728c95ba325bd324337cabe2417d61d7113e", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -63,6 +63,7 @@ independently:\n \n use driver::config;\n \n+use middle::def;\n use middle::resolve;\n use middle::subst;\n use middle::ty;\n@@ -266,7 +267,7 @@ pub fn write_substs_to_tcx(tcx: &ty::ctxt,\n         tcx.item_substs.borrow_mut().insert(node_id, item_substs);\n     }\n }\n-pub fn lookup_def_tcx(tcx:&ty::ctxt, sp: Span, id: ast::NodeId) -> ast::Def {\n+pub fn lookup_def_tcx(tcx:&ty::ctxt, sp: Span, id: ast::NodeId) -> def::Def {\n     match tcx.def_map.borrow().find(&id) {\n         Some(&x) => x,\n         _ => {\n@@ -276,7 +277,7 @@ pub fn lookup_def_tcx(tcx:&ty::ctxt, sp: Span, id: ast::NodeId) -> ast::Def {\n }\n \n pub fn lookup_def_ccx(ccx: &CrateCtxt, sp: Span, id: ast::NodeId)\n-                   -> ast::Def {\n+                   -> def::Def {\n     lookup_def_tcx(ccx.tcx, sp, id)\n }\n "}, {"sha": "9db9a0e7612a6908a5f9bba2a5a11d59366c968d", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -16,6 +16,7 @@ use syntax::attr::AttrMetaMethods;\n \n use rustc::metadata::csearch;\n use rustc::metadata::decoder;\n+use rustc::middle::def;\n use rustc::middle::ty;\n \n use core;\n@@ -46,22 +47,22 @@ pub fn try_inline(id: ast::NodeId) -> Option<Vec<clean::Item>> {\n         Some(def) => *def,\n         None => return None,\n     };\n-    let did = ast_util::def_id_of_def(def);\n+    let did = def.def_id();\n     if ast_util::is_local(did) { return None }\n     try_inline_def(&**cx, tcx, def)\n }\n \n fn try_inline_def(cx: &core::DocContext,\n                   tcx: &ty::ctxt,\n-                  def: ast::Def) -> Option<Vec<clean::Item>> {\n+                  def: def::Def) -> Option<Vec<clean::Item>> {\n     let mut ret = Vec::new();\n-    let did = ast_util::def_id_of_def(def);\n+    let did = def.def_id();\n     let inner = match def {\n-        ast::DefTrait(did) => {\n+        def::DefTrait(did) => {\n             record_extern_fqn(cx, did, clean::TypeTrait);\n             clean::TraitItem(build_external_trait(tcx, did))\n         }\n-        ast::DefFn(did, style) => {\n+        def::DefFn(did, style) => {\n             // If this function is a tuple struct constructor, we just skip it\n             if csearch::get_tuple_struct_definition_if_ctor(&tcx.sess.cstore,\n                                                             did).is_some() {\n@@ -70,20 +71,20 @@ fn try_inline_def(cx: &core::DocContext,\n             record_extern_fqn(cx, did, clean::TypeFunction);\n             clean::FunctionItem(build_external_function(tcx, did, style))\n         }\n-        ast::DefStruct(did) => {\n+        def::DefStruct(did) => {\n             record_extern_fqn(cx, did, clean::TypeStruct);\n             ret.extend(build_impls(cx, tcx, did).move_iter());\n             clean::StructItem(build_struct(tcx, did))\n         }\n-        ast::DefTy(did) => {\n+        def::DefTy(did) => {\n             record_extern_fqn(cx, did, clean::TypeEnum);\n             ret.extend(build_impls(cx, tcx, did).move_iter());\n             build_type(tcx, did)\n         }\n         // Assume that the enum type is reexported next to the variant, and\n         // variants don't show up in documentation specially.\n-        ast::DefVariant(..) => return Some(Vec::new()),\n-        ast::DefMod(did) => {\n+        def::DefVariant(..) => return Some(Vec::new()),\n+        def::DefMod(did) => {\n             record_extern_fqn(cx, did, clean::TypeModule);\n             clean::ModuleItem(build_module(cx, tcx, did))\n         }\n@@ -248,7 +249,7 @@ fn build_impls(cx: &core::DocContext,\n                           impls: &mut Vec<Option<clean::Item>>) {\n             match def {\n                 decoder::DlImpl(did) => impls.push(build_impl(cx, tcx, did)),\n-                decoder::DlDef(ast::DefMod(did)) => {\n+                decoder::DlDef(def::DefMod(did)) => {\n                     csearch::each_child_of_item(&tcx.sess.cstore,\n                                                 did,\n                                                 |def, _, _| {"}, {"sha": "3cb5c663c4ea5a4d64db78b9c57b2b639baf7fb1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -25,6 +25,7 @@ use rustc::driver::driver;\n use rustc::metadata::cstore;\n use rustc::metadata::csearch;\n use rustc::metadata::decoder;\n+use rustc::middle::def;\n use rustc::middle::subst;\n use rustc::middle::ty;\n \n@@ -191,7 +192,7 @@ impl Clean<ExternalCrate> for cstore::crate_metadata {\n                                                       self.cnum,\n                                                       |def, _, _| {\n                     let did = match def {\n-                        decoder::DlDef(ast::DefMod(did)) => did,\n+                        decoder::DlDef(def::DefMod(did)) => did,\n                         _ => return\n                     };\n                     let attrs = inline::load_attrs(tcx, did);\n@@ -1949,8 +1950,8 @@ fn resolve_type(path: Path, tpbs: Option<Vec<TyParamBound>>,\n     };\n \n     match def {\n-        ast::DefSelfTy(i) => return Self(ast_util::local_def(i)),\n-        ast::DefPrimTy(p) => match p {\n+        def::DefSelfTy(i) => return Self(ast_util::local_def(i)),\n+        def::DefPrimTy(p) => match p {\n             ast::TyStr => return Primitive(Str),\n             ast::TyBool => return Primitive(Bool),\n             ast::TyChar => return Primitive(Char),\n@@ -1968,24 +1969,24 @@ fn resolve_type(path: Path, tpbs: Option<Vec<TyParamBound>>,\n             ast::TyFloat(ast::TyF64) => return Primitive(F64),\n             ast::TyFloat(ast::TyF128) => return Primitive(F128),\n         },\n-        ast::DefTyParam(i, _) => return Generic(i),\n-        ast::DefTyParamBinder(i) => return TyParamBinder(i),\n+        def::DefTyParam(i, _) => return Generic(i),\n+        def::DefTyParamBinder(i) => return TyParamBinder(i),\n         _ => {}\n     };\n     let did = register_def(&**cx, def);\n     ResolvedPath { path: path, typarams: tpbs, did: did }\n }\n \n-fn register_def(cx: &core::DocContext, def: ast::Def) -> ast::DefId {\n+fn register_def(cx: &core::DocContext, def: def::Def) -> ast::DefId {\n     let (did, kind) = match def {\n-        ast::DefFn(i, _) => (i, TypeFunction),\n-        ast::DefTy(i) => (i, TypeEnum),\n-        ast::DefTrait(i) => (i, TypeTrait),\n-        ast::DefStruct(i) => (i, TypeStruct),\n-        ast::DefMod(i) => (i, TypeModule),\n-        ast::DefStatic(i, _) => (i, TypeStatic),\n-        ast::DefVariant(i, _, _) => (i, TypeEnum),\n-        _ => return ast_util::def_id_of_def(def),\n+        def::DefFn(i, _) => (i, TypeFunction),\n+        def::DefTy(i) => (i, TypeEnum),\n+        def::DefTrait(i) => (i, TypeTrait),\n+        def::DefStruct(i) => (i, TypeStruct),\n+        def::DefMod(i) => (i, TypeModule),\n+        def::DefStatic(i, _) => (i, TypeStatic),\n+        def::DefVariant(i, _, _) => (i, TypeEnum),\n+        _ => return def.def_id()\n     };\n     if ast_util::is_local(did) { return did }\n     let tcx = match cx.maybe_typed {"}, {"sha": "da9169d70fd3c9f5a37395e388f20a63055459d6", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -195,7 +195,7 @@ impl<'a> RustdocVisitor<'a> {\n             core::Typed(ref tcx) => tcx,\n             core::NotTyped(_) => return false\n         };\n-        let def = ast_util::def_id_of_def(*tcx.def_map.borrow().get(&id));\n+        let def = tcx.def_map.borrow().get(&id).def_id();\n         if !ast_util::is_local(def) { return false }\n         let analysis = match self.analysis {\n             Some(analysis) => analysis, None => return false"}, {"sha": "2bc24fd1eb36994fa3801ed3cbfc6b6ebea0b044", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -206,49 +206,6 @@ impl Generics {\n     }\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n-pub enum MethodProvenance {\n-    FromTrait(DefId),\n-    FromImpl(DefId),\n-}\n-\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n-pub enum Def {\n-    DefFn(DefId, FnStyle),\n-    DefStaticMethod(/* method */ DefId, MethodProvenance, FnStyle),\n-    DefSelfTy(/* trait id */ NodeId),\n-    DefMod(DefId),\n-    DefForeignMod(DefId),\n-    DefStatic(DefId, bool /* is_mutbl */),\n-    DefArg(NodeId, BindingMode),\n-    DefLocal(NodeId, BindingMode),\n-    DefVariant(DefId /* enum */, DefId /* variant */, bool /* is_structure */),\n-    DefTy(DefId),\n-    DefTrait(DefId),\n-    DefPrimTy(PrimTy),\n-    DefTyParam(DefId, uint),\n-    DefBinding(NodeId, BindingMode),\n-    DefUse(DefId),\n-    DefUpvar(NodeId,  // id of closed over var\n-              @Def,     // closed over def\n-              NodeId,  // expr node that creates the closure\n-              NodeId), // id for the block/body of the closure expr\n-\n-    /// Note that if it's a tuple struct's definition, the node id of the DefId\n-    /// may either refer to the item definition's id or the StructDef.ctor_id.\n-    ///\n-    /// The cases that I have encountered so far are (this is not exhaustive):\n-    /// - If it's a ty_path referring to some tuple struct, then DefMap maps\n-    ///   it to a def whose id is the item definition's id.\n-    /// - If it's an ExprPath referring to some tuple struct, then DefMap maps\n-    ///   it to a def whose id is the StructDef.ctor_id.\n-    DefStruct(DefId),\n-    DefTyParamBinder(NodeId), /* struct, impl or trait with ty params */\n-    DefRegion(NodeId),\n-    DefLabel(NodeId),\n-    DefMethod(DefId /* method */, Option<DefId> /* trait */),\n-}\n-\n #[deriving(Clone, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n pub enum DefRegion {\n     DefStaticRegion,"}, {"sha": "a1ad3cc14c5180fa13cc7ca4ebcf099372a74f42", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f03b5608cc66aedb94409d62335ec539880b875/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=0f03b5608cc66aedb94409d62335ec539880b875", "patch": "@@ -52,33 +52,6 @@ pub fn stmt_id(s: &Stmt) -> NodeId {\n     }\n }\n \n-pub fn variant_def_ids(d: Def) -> Option<(DefId, DefId)> {\n-    match d {\n-      DefVariant(enum_id, var_id, _) => {\n-          Some((enum_id, var_id))\n-      }\n-      _ => None\n-    }\n-}\n-\n-pub fn def_id_of_def(d: Def) -> DefId {\n-    match d {\n-        DefFn(id, _) | DefStaticMethod(id, _, _) | DefMod(id) |\n-        DefForeignMod(id) | DefStatic(id, _) |\n-        DefVariant(_, id, _) | DefTy(id) | DefTyParam(id, _) |\n-        DefUse(id) | DefStruct(id) | DefTrait(id) | DefMethod(id, _) => {\n-            id\n-        }\n-        DefArg(id, _) | DefLocal(id, _) | DefSelfTy(id)\n-        | DefUpvar(id, _, _, _) | DefBinding(id, _) | DefRegion(id)\n-        | DefTyParamBinder(id) | DefLabel(id) => {\n-            local_def(id)\n-        }\n-\n-        DefPrimTy(_) => fail!()\n-    }\n-}\n-\n pub fn binop_to_str(op: BinOp) -> &'static str {\n     match op {\n         BiAdd => \"+\","}]}