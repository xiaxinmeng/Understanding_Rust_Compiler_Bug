{"sha": "f6d18db402cfebcf5c1bdc8e730f3923b3bb0421", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZDE4ZGI0MDJjZmViY2Y1YzFiZGM4ZTczMGYzOTIzYjNiYjA0MjE=", "commit": {"author": {"name": "Sasha", "email": "sasha.pourcelot@protonmail.com", "date": "2020-08-28T21:04:42Z"}, "committer": {"name": "Sasha", "email": "sasha.pourcelot@protonmail.com", "date": "2020-08-30T20:09:58Z"}, "message": "Use string literal directly when available in format\n\nPrevious implementation used the `Parser::parse_expr` function in order\nto extract the format expression. If the first comma following the\nformat expression was mistakenly replaced with a dot, then the next\nformat expression was eaten by the function, because it looked as a\nsyntactically valid expression, which resulted in incorrectly spanned\nerror messages.\n\nThe way the format expression is exctracted is changed: we first look at\nthe first available token in the first argument supplied to the\n`format!` macro call. If it is a string literal, then it is promoted as\na format expression immediatly, otherwise we fall back to the original\n`parse_expr`-related method.\n\nThis allows us to ensure that the parser won't consume too much tokens\nwhen a typo is made.\n\nA test has been created so that it is ensured that the issue is properly\nfixed.", "tree": {"sha": "75a6755f7e97b1a5e7da581a8361ee65193b6b25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75a6755f7e97b1a5e7da581a8361ee65193b6b25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6d18db402cfebcf5c1bdc8e730f3923b3bb0421", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6d18db402cfebcf5c1bdc8e730f3923b3bb0421", "html_url": "https://github.com/rust-lang/rust/commit/f6d18db402cfebcf5c1bdc8e730f3923b3bb0421", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6d18db402cfebcf5c1bdc8e730f3923b3bb0421/comments", "author": {"login": "scrabsha", "id": 25402018, "node_id": "MDQ6VXNlcjI1NDAyMDE4", "avatar_url": "https://avatars.githubusercontent.com/u/25402018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scrabsha", "html_url": "https://github.com/scrabsha", "followers_url": "https://api.github.com/users/scrabsha/followers", "following_url": "https://api.github.com/users/scrabsha/following{/other_user}", "gists_url": "https://api.github.com/users/scrabsha/gists{/gist_id}", "starred_url": "https://api.github.com/users/scrabsha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scrabsha/subscriptions", "organizations_url": "https://api.github.com/users/scrabsha/orgs", "repos_url": "https://api.github.com/users/scrabsha/repos", "events_url": "https://api.github.com/users/scrabsha/events{/privacy}", "received_events_url": "https://api.github.com/users/scrabsha/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scrabsha", "id": 25402018, "node_id": "MDQ6VXNlcjI1NDAyMDE4", "avatar_url": "https://avatars.githubusercontent.com/u/25402018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scrabsha", "html_url": "https://github.com/scrabsha", "followers_url": "https://api.github.com/users/scrabsha/followers", "following_url": "https://api.github.com/users/scrabsha/following{/other_user}", "gists_url": "https://api.github.com/users/scrabsha/gists{/gist_id}", "starred_url": "https://api.github.com/users/scrabsha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scrabsha/subscriptions", "organizations_url": "https://api.github.com/users/scrabsha/orgs", "repos_url": "https://api.github.com/users/scrabsha/repos", "events_url": "https://api.github.com/users/scrabsha/events{/privacy}", "received_events_url": "https://api.github.com/users/scrabsha/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85fbf49ce0e2274d0acf798f6e703747674feec3", "url": "https://api.github.com/repos/rust-lang/rust/commits/85fbf49ce0e2274d0acf798f6e703747674feec3", "html_url": "https://github.com/rust-lang/rust/commit/85fbf49ce0e2274d0acf798f6e703747674feec3"}], "stats": {"total": 77, "additions": 75, "deletions": 2}, "files": [{"sha": "48506148ed9a7b2d02ad4ca1ddab4cf36d7f4d7e", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f6d18db402cfebcf5c1bdc8e730f3923b3bb0421/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d18db402cfebcf5c1bdc8e730f3923b3bb0421/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=f6d18db402cfebcf5c1bdc8e730f3923b3bb0421", "patch": "@@ -135,7 +135,26 @@ fn parse_args<'a>(\n         return Err(ecx.struct_span_err(sp, \"requires at least a format string argument\"));\n     }\n \n-    let fmtstr = p.parse_expr()?;\n+    let first_token = &p.token;\n+    let fmtstr = match first_token.kind {\n+        token::TokenKind::Literal(token::Lit {\n+            kind: token::LitKind::Str | token::LitKind::StrRaw(_),\n+            ..\n+        }) => {\n+            // If the first token is a string literal, then a format expression\n+            // is constructed from it.\n+            //\n+            // This allows us to properly handle cases when the first comma\n+            // after the format string is mistakenly replaced with any operator,\n+            // which cause the expression parser to eat too much tokens.\n+            p.parse_literal_maybe_minus()?\n+        }\n+        _ => {\n+            // Otherwise, we fall back to the expression parser.\n+            p.parse_expr()?\n+        }\n+    };\n+\n     let mut first = true;\n     let mut named = false;\n "}, {"sha": "69d13b5cf53a2771adb73b6a2d20f08454e931f3", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d18db402cfebcf5c1bdc8e730f3923b3bb0421/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d18db402cfebcf5c1bdc8e730f3923b3bb0421/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=f6d18db402cfebcf5c1bdc8e730f3923b3bb0421", "patch": "@@ -1480,7 +1480,7 @@ impl<'a> Parser<'a> {\n \n     /// Matches `'-' lit | lit` (cf. `ast_validation::AstValidator::check_expr_within_pat`).\n     /// Keep this in sync with `Token::can_begin_literal_maybe_minus`.\n-    pub(super) fn parse_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n+    pub fn parse_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n         maybe_whole_expr!(self);\n \n         let lo = self.token.span;"}, {"sha": "0b097fdfab81fe20950d76b650c74e7ce82c1538", "filename": "src/test/ui/fmt/incorrect-first-separator.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f6d18db402cfebcf5c1bdc8e730f3923b3bb0421/src%2Ftest%2Fui%2Ffmt%2Fincorrect-first-separator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d18db402cfebcf5c1bdc8e730f3923b3bb0421/src%2Ftest%2Fui%2Ffmt%2Fincorrect-first-separator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fincorrect-first-separator.rs?ref=f6d18db402cfebcf5c1bdc8e730f3923b3bb0421", "patch": "@@ -0,0 +1,22 @@\n+// Allows to track issue #75492:\n+// https://github.com/rust-lang/rust/issues/75492\n+\n+use std::iter;\n+\n+fn main() {\n+    format!(\"A number: {}\". iter::once(42).next().unwrap());\n+    //~^ ERROR expected token: `,`\n+\n+    // Other kind of types are also checked:\n+\n+    format!(\"A number: {}\" / iter::once(42).next().unwrap());\n+    //~^ ERROR expected token: `,`\n+\n+    format!(\"A number: {}\"; iter::once(42).next().unwrap());\n+    //~^ ERROR expected token: `,`\n+\n+    // Note: this character is an COMBINING COMMA BELOW unicode char\n+    format!(\"A number: {}\" \u0326 iter::once(42).next().unwrap());\n+    //~^ ERROR expected token: `,`\n+    //~^^ ERROR unknown start of token: \\u{326}\n+}"}, {"sha": "60d2a82855e898393d0ab16ba8d70c70da1505d9", "filename": "src/test/ui/fmt/incorrect-first-separator.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f6d18db402cfebcf5c1bdc8e730f3923b3bb0421/src%2Ftest%2Fui%2Ffmt%2Fincorrect-first-separator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d18db402cfebcf5c1bdc8e730f3923b3bb0421/src%2Ftest%2Fui%2Ffmt%2Fincorrect-first-separator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fincorrect-first-separator.stderr?ref=f6d18db402cfebcf5c1bdc8e730f3923b3bb0421", "patch": "@@ -0,0 +1,32 @@\n+error: unknown start of token: \\u{326}\n+  --> $DIR/incorrect-first-separator.rs:19:28\n+   |\n+LL |     format!(\"A number: {}\" \u0326 iter::once(42).next().unwrap());\n+   |                            ^\n+\n+error: expected token: `,`\n+  --> $DIR/incorrect-first-separator.rs:7:27\n+   |\n+LL |     format!(\"A number: {}\". iter::once(42).next().unwrap());\n+   |                           ^ expected `,`\n+\n+error: expected token: `,`\n+  --> $DIR/incorrect-first-separator.rs:12:28\n+   |\n+LL |     format!(\"A number: {}\" / iter::once(42).next().unwrap());\n+   |                            ^ expected `,`\n+\n+error: expected token: `,`\n+  --> $DIR/incorrect-first-separator.rs:15:27\n+   |\n+LL |     format!(\"A number: {}\"; iter::once(42).next().unwrap());\n+   |                           ^ expected `,`\n+\n+error: expected token: `,`\n+  --> $DIR/incorrect-first-separator.rs:19:30\n+   |\n+LL |     format!(\"A number: {}\" \u0326 iter::once(42).next().unwrap());\n+   |                             ^^^^ expected `,`\n+\n+error: aborting due to 5 previous errors\n+"}]}