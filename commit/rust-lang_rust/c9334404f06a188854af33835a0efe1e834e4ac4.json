{"sha": "c9334404f06a188854af33835a0efe1e834e4ac4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5MzM0NDA0ZjA2YTE4ODg1NGFmMzM4MzVhMGVmZTFlODM0ZTRhYzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-05T18:39:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-05T18:39:40Z"}, "message": "Auto merge of #48208 - michaelwoerister:track-features, r=petrochenkov\n\nTurn feature-gate table into a query so it is covered by dependency tracking.\n\nTurn access to feature gates into a query so we handle them correctly during incremental compilation.\n\nFeatures are still available via `Session` through `features_untracked()`. I wish we had a better way of hiding untracked information. It would be great if we could remove the `sess` field from `TyCtxt`.\n\nFixes #47003.", "tree": {"sha": "03b1a99ea356ab965646579c28a2e8941095cfa3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03b1a99ea356ab965646579c28a2e8941095cfa3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9334404f06a188854af33835a0efe1e834e4ac4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9334404f06a188854af33835a0efe1e834e4ac4", "html_url": "https://github.com/rust-lang/rust/commit/c9334404f06a188854af33835a0efe1e834e4ac4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9334404f06a188854af33835a0efe1e834e4ac4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2746d870017c869b84fc56ecd63f5e4f9646c96", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2746d870017c869b84fc56ecd63f5e4f9646c96", "html_url": "https://github.com/rust-lang/rust/commit/e2746d870017c869b84fc56ecd63f5e4f9646c96"}, {"sha": "93625f12e080ac85f5a7a712a316847a891c1d07", "url": "https://api.github.com/repos/rust-lang/rust/commits/93625f12e080ac85f5a7a712a316847a891c1d07", "html_url": "https://github.com/rust-lang/rust/commit/93625f12e080ac85f5a7a712a316847a891c1d07"}], "stats": {"total": 372, "additions": 231, "deletions": 141}, "files": [{"sha": "5f6a7c452c4c457db7e9bff5bd2cdb59a20176e8", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -436,6 +436,9 @@ impl DepKind {\n }\n \n define_dep_nodes!( <'tcx>\n+    // We use this for most things when incr. comp. is turned off.\n+    [] Null,\n+\n     // Represents the `Krate` as a whole (the `hir::Krate` value) (as\n     // distinct from the krate module). This is basically a hash of\n     // the entire krate, so if you read from `Krate` (e.g., by calling\n@@ -605,8 +608,8 @@ define_dep_nodes!( <'tcx>\n     [input] MissingExternCrateItem(CrateNum),\n     [input] UsedCrateSource(CrateNum),\n     [input] PostorderCnums,\n-    [input] HasCloneClosures(CrateNum),\n-    [input] HasCopyClosures(CrateNum),\n+    [] HasCloneClosures(CrateNum),\n+    [] HasCopyClosures(CrateNum),\n \n     // This query is not expected to have inputs -- as a result, it's\n     // not a good candidate for \"replay\" because it's essentially a\n@@ -630,8 +633,6 @@ define_dep_nodes!( <'tcx>\n     [] CompileCodegenUnit(InternedString),\n     [input] OutputFilenames,\n     [anon] NormalizeTy,\n-    // We use this for most things when incr. comp. is turned off.\n-    [] Null,\n \n     [] SubstituteNormalizeAndTestPredicates { key: (DefId, &'tcx Substs<'tcx>) },\n \n@@ -642,6 +643,7 @@ define_dep_nodes!( <'tcx>\n \n     [] GetSymbolExportLevel(DefId),\n \n+    [input] Features,\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {"}, {"sha": "877027a21a22189a1721f20e8ecb1a31e457eace", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -550,7 +550,7 @@ impl<'a> LoweringContext<'a> {\n     {\n         assert!(!self.is_collecting_in_band_lifetimes);\n         assert!(self.lifetimes_to_define.is_empty());\n-        self.is_collecting_in_band_lifetimes = self.sess.features.borrow().in_band_lifetimes;\n+        self.is_collecting_in_band_lifetimes = self.sess.features_untracked().in_band_lifetimes;\n \n         assert!(self.in_band_ty_params.is_empty());\n \n@@ -964,7 +964,7 @@ impl<'a> LoweringContext<'a> {\n                 let span = t.span;\n                 match itctx {\n                     ImplTraitContext::Existential => {\n-                        let has_feature = self.sess.features.borrow().conservative_impl_trait;\n+                        let has_feature = self.sess.features_untracked().conservative_impl_trait;\n                         if !t.span.allows_unstable() && !has_feature {\n                             emit_feature_err(&self.sess.parse_sess, \"conservative_impl_trait\",\n                                              t.span, GateIssue::Language,\n@@ -988,7 +988,7 @@ impl<'a> LoweringContext<'a> {\n                         }, lifetimes)\n                     },\n                     ImplTraitContext::Universal(def_id) => {\n-                        let has_feature = self.sess.features.borrow().universal_impl_trait;\n+                        let has_feature = self.sess.features_untracked().universal_impl_trait;\n                         if !t.span.allows_unstable() && !has_feature {\n                             emit_feature_err(&self.sess.parse_sess, \"universal_impl_trait\",\n                                              t.span, GateIssue::Language,\n@@ -3713,7 +3713,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn maybe_lint_bare_trait(&self, span: Span, id: NodeId, is_global: bool) {\n-        if self.sess.features.borrow().dyn_trait {\n+        if self.sess.features_untracked().dyn_trait {\n             self.sess.buffer_lint_with_diagnostic(\n                 builtin::BARE_TRAIT_OBJECT, id, span,\n                 \"trait objects without an explicit `dyn` are deprecated\","}, {"sha": "f935cbfcde992d394f95f844e86d8f2f2a4b74e3", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -17,6 +17,7 @@ use std::hash as std_hash;\n use std::mem;\n \n use syntax::ast;\n+use syntax::feature_gate;\n use syntax::parse::token;\n use syntax::symbol::InternedString;\n use syntax::tokenstream;\n@@ -460,3 +461,21 @@ fn stable_non_narrow_char(swc: ::syntax_pos::NonNarrowChar,\n \n     (pos.0 - filemap_start.0, width as u32)\n }\n+\n+\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for feature_gate::Features {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        // Unfortunately we cannot exhaustively list fields here, since the\n+        // struct is macro generated.\n+        self.declared_stable_lang_features.hash_stable(hcx, hasher);\n+        self.declared_lib_features.hash_stable(hcx, hasher);\n+\n+        self.walk_feature_fields(|feature_name, value| {\n+            feature_name.hash_stable(hcx, hasher);\n+            value.hash_stable(hcx, hasher);\n+        });\n+    }\n+}"}, {"sha": "559b2720076f447030d042710fa0a698c55ddc3a", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -289,11 +289,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ) {\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n-        if will_later_be_reported_by_nll && self.tcx.sess.nll() {\n+        if will_later_be_reported_by_nll && self.tcx.nll() {\n             // With `#![feature(nll)]`, we want to present a nice user\n             // experience, so don't even mention the errors from the\n             // AST checker.\n-            if self.tcx.sess.features.borrow().nll {\n+            if self.tcx.features().nll {\n                 return;\n             }\n "}, {"sha": "16c33d6bd837da03f301396a7eb42a43b11d2ac9", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -131,7 +131,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                    item_sp: Span, kind: AnnotationKind, visit_children: F)\n         where F: FnOnce(&mut Self)\n     {\n-        if self.tcx.sess.features.borrow().staged_api {\n+        if self.tcx.features().staged_api {\n             // This crate explicitly wants staged API.\n             debug!(\"annotate(id = {:?}, attrs = {:?})\", id, attrs);\n             if let Some(..) = attr::find_deprecation(self.tcx.sess.diagnostic(), attrs, item_sp) {\n@@ -398,7 +398,7 @@ impl<'a, 'tcx> Index<'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Index<'tcx> {\n         let is_staged_api =\n             tcx.sess.opts.debugging_opts.force_unstable_if_unmarked ||\n-            tcx.sess.features.borrow().staged_api;\n+            tcx.features().staged_api;\n         let mut staged_api = FxHashMap();\n         staged_api.insert(LOCAL_CRATE, is_staged_api);\n         let mut index = Index {\n@@ -408,7 +408,7 @@ impl<'a, 'tcx> Index<'tcx> {\n             active_features: FxHashSet(),\n         };\n \n-        let ref active_lib_features = tcx.sess.features.borrow().declared_lib_features;\n+        let ref active_lib_features = tcx.features().declared_lib_features;\n \n         // Put the active features into a map for quick lookup\n         index.active_features = active_lib_features.iter().map(|&(ref s, _)| s.clone()).collect();\n@@ -677,7 +677,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n             // There's no good place to insert stability check for non-Copy unions,\n             // so semi-randomly perform it here in stability.rs\n-            hir::ItemUnion(..) if !self.tcx.sess.features.borrow().untagged_unions => {\n+            hir::ItemUnion(..) if !self.tcx.features().untagged_unions => {\n                 let def_id = self.tcx.hir.local_def_id(item.id);\n                 let adt_def = self.tcx.adt_def(def_id);\n                 let ty = self.tcx.type_of(def_id);\n@@ -721,8 +721,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n /// were expected to be library features), and the list of features used from\n /// libraries, identify activated features that don't exist and error about them.\n pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let sess = &tcx.sess;\n-\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n     if tcx.stability().staged_api[&LOCAL_CRATE] {\n@@ -736,12 +734,12 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         krate.visit_all_item_likes(&mut missing.as_deep_visitor());\n     }\n \n-    let ref declared_lib_features = sess.features.borrow().declared_lib_features;\n+    let ref declared_lib_features = tcx.features().declared_lib_features;\n     let mut remaining_lib_features: FxHashMap<Symbol, Span>\n         = declared_lib_features.clone().into_iter().collect();\n     remaining_lib_features.remove(&Symbol::intern(\"proc_macro\"));\n \n-    for &(ref stable_lang_feature, span) in &sess.features.borrow().declared_stable_lang_features {\n+    for &(ref stable_lang_feature, span) in &tcx.features().declared_stable_lang_features {\n         let version = find_lang_feature_accepted_version(&stable_lang_feature.as_str())\n             .expect(\"unexpectedly couldn't find version feature was stabilized\");\n         tcx.lint_node(lint::builtin::STABLE_FEATURES,"}, {"sha": "5e9eeb973007f26f71fc0c366d1d4cdad6e6a1e8", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 19, "deletions": 47, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -20,7 +20,7 @@ use lint::builtin::BuiltinLintDiagnostics;\n use middle::allocator::AllocatorKind;\n use middle::dependency_format;\n use session::search_paths::PathKind;\n-use session::config::{BorrowckMode, DebugInfoLevel, OutputType, Epoch};\n+use session::config::{DebugInfoLevel, OutputType, Epoch};\n use ty::tls;\n use util::nodemap::{FxHashMap, FxHashSet};\n use util::common::{duration_to_secs_str, ErrorReported};\n@@ -93,7 +93,8 @@ pub struct Session {\n     /// multiple crates with the same name to coexist. See the\n     /// trans::back::symbol_names module for more information.\n     pub crate_disambiguator: RefCell<Option<CrateDisambiguator>>,\n-    pub features: RefCell<feature_gate::Features>,\n+\n+    features: RefCell<Option<feature_gate::Features>>,\n \n     /// The maximum recursion limit for potentially infinitely recursive\n     /// operations such as auto-dereference and monomorphization.\n@@ -194,6 +195,7 @@ impl Session {\n             None => bug!(\"accessing disambiguator before initialization\"),\n         }\n     }\n+\n     pub fn struct_span_warn<'a, S: Into<MultiSpan>>(&'a self,\n                                                     sp: S,\n                                                     msg: &str)\n@@ -456,16 +458,22 @@ impl Session {\n         self.opts.debugging_opts.print_llvm_passes\n     }\n \n-    /// If true, we should use NLL-style region checking instead of\n-    /// lexical style.\n-    pub fn nll(&self) -> bool {\n-        self.features.borrow().nll || self.opts.debugging_opts.nll\n+    /// Get the features enabled for the current compilation session.\n+    /// DO NOT USE THIS METHOD if there is a TyCtxt available, as it circumvents\n+    /// dependency tracking. Use tcx.features() instead.\n+    #[inline]\n+    pub fn features_untracked(&self) -> cell::Ref<feature_gate::Features> {\n+        let features = self.features.borrow();\n+\n+        if features.is_none() {\n+            bug!(\"Access to Session::features before it is initialized\");\n+        }\n+\n+        cell::Ref::map(features, |r| r.as_ref().unwrap())\n     }\n \n-    /// If true, we should use the MIR-based borrowck (we may *also* use\n-    /// the AST-based borrowck).\n-    pub fn use_mir(&self) -> bool {\n-        self.borrowck_mode().use_mir()\n+    pub fn init_features(&self, features: feature_gate::Features) {\n+        *(self.features.borrow_mut()) = Some(features);\n     }\n \n     /// If true, we should gather causal information during NLL\n@@ -475,42 +483,6 @@ impl Session {\n         self.opts.debugging_opts.nll_dump_cause\n     }\n \n-    /// If true, we should enable two-phase borrows checks. This is\n-    /// done with either `-Ztwo-phase-borrows` or with\n-    /// `#![feature(nll)]`.\n-    pub fn two_phase_borrows(&self) -> bool {\n-        self.features.borrow().nll || self.opts.debugging_opts.two_phase_borrows\n-    }\n-\n-    /// What mode(s) of borrowck should we run? AST? MIR? both?\n-    /// (Also considers the `#![feature(nll)]` setting.)\n-    pub fn borrowck_mode(&self) -> BorrowckMode {\n-        match self.opts.borrowck_mode {\n-            mode @ BorrowckMode::Mir |\n-            mode @ BorrowckMode::Compare => mode,\n-\n-            mode @ BorrowckMode::Ast => {\n-                if self.nll() {\n-                    BorrowckMode::Mir\n-                } else {\n-                    mode\n-                }\n-            }\n-\n-        }\n-    }\n-\n-    /// Should we emit EndRegion MIR statements? These are consumed by\n-    /// MIR borrowck, but not when NLL is used. They are also consumed\n-    /// by the validation stuff.\n-    pub fn emit_end_regions(&self) -> bool {\n-        // FIXME(#46875) -- we should not emit end regions when NLL is enabled,\n-        // but for now we can't stop doing so because it causes false positives\n-        self.opts.debugging_opts.emit_end_regions ||\n-            self.opts.debugging_opts.mir_emit_validate > 0 ||\n-            self.use_mir()\n-    }\n-\n     /// Calculates the flavor of LTO to use for this compilation.\n     pub fn lto(&self) -> config::Lto {\n         // If our target has codegen requirements ignore the command line\n@@ -1029,7 +1001,7 @@ pub fn build_session_(sopts: config::Options,\n         crate_types: RefCell::new(Vec::new()),\n         dependency_formats: RefCell::new(FxHashMap()),\n         crate_disambiguator: RefCell::new(None),\n-        features: RefCell::new(feature_gate::Features::new()),\n+        features: RefCell::new(None),\n         recursion_limit: Cell::new(64),\n         type_length_limit: Cell::new(1048576),\n         next_node_id: Cell::new(NodeId::new(1)),"}, {"sha": "d11565618a687ede894f069fa6f841c4ab38599c", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -164,7 +164,7 @@ pub(super) fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // The feature gate should prevent introducing new specializations, but not\n     // taking advantage of upstream ones.\n-    if !tcx.sess.features.borrow().specialization &&\n+    if !tcx.features().specialization &&\n         (impl1_def_id.is_local() || impl2_def_id.is_local()) {\n         return false;\n     }"}, {"sha": "a7f065d57aeed645a3e06676a8220d9f3a4ccb78", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -14,7 +14,7 @@ use dep_graph::DepGraph;\n use dep_graph::{DepNode, DepConstructor};\n use errors::DiagnosticBuilder;\n use session::Session;\n-use session::config::OutputFilenames;\n+use session::config::{BorrowckMode, OutputFilenames};\n use middle;\n use hir::{TraitCandidate, HirId, ItemLocalId};\n use hir::def::{Def, Export};\n@@ -71,6 +71,7 @@ use syntax::abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n use syntax::codemap::MultiSpan;\n+use syntax::feature_gate;\n use syntax::symbol::{Symbol, keywords};\n use syntax_pos::Span;\n \n@@ -1255,6 +1256,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.all_crate_nums(LOCAL_CRATE)\n     }\n \n+    pub fn features(self) -> Lrc<feature_gate::Features> {\n+        self.features_query(LOCAL_CRATE)\n+    }\n+\n     pub fn def_key(self, id: DefId) -> hir_map::DefKey {\n         if id.is_local() {\n             self.hir.def_key(id)\n@@ -1362,6 +1367,53 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.on_disk_query_result_cache.serialize(self.global_tcx(), encoder)\n     }\n \n+    /// If true, we should use NLL-style region checking instead of\n+    /// lexical style.\n+    pub fn nll(self) -> bool {\n+        self.features().nll || self.sess.opts.debugging_opts.nll\n+    }\n+\n+    /// If true, we should use the MIR-based borrowck (we may *also* use\n+    /// the AST-based borrowck).\n+    pub fn use_mir(self) -> bool {\n+        self.borrowck_mode().use_mir()\n+    }\n+\n+    /// If true, we should enable two-phase borrows checks. This is\n+    /// done with either `-Ztwo-phase-borrows` or with\n+    /// `#![feature(nll)]`.\n+    pub fn two_phase_borrows(self) -> bool {\n+        self.features().nll || self.sess.opts.debugging_opts.two_phase_borrows\n+    }\n+\n+    /// What mode(s) of borrowck should we run? AST? MIR? both?\n+    /// (Also considers the `#![feature(nll)]` setting.)\n+    pub fn borrowck_mode(&self) -> BorrowckMode {\n+        match self.sess.opts.borrowck_mode {\n+            mode @ BorrowckMode::Mir |\n+            mode @ BorrowckMode::Compare => mode,\n+\n+            mode @ BorrowckMode::Ast => {\n+                if self.nll() {\n+                    BorrowckMode::Mir\n+                } else {\n+                    mode\n+                }\n+            }\n+\n+        }\n+    }\n+\n+    /// Should we emit EndRegion MIR statements? These are consumed by\n+    /// MIR borrowck, but not when NLL is used. They are also consumed\n+    /// by the validation stuff.\n+    pub fn emit_end_regions(self) -> bool {\n+        // FIXME(#46875) -- we should not emit end regions when NLL is enabled,\n+        // but for now we can't stop doing so because it causes false positives\n+        self.sess.opts.debugging_opts.emit_end_regions ||\n+            self.sess.opts.debugging_opts.mir_emit_validate > 0 ||\n+            self.use_mir()\n+    }\n }\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n@@ -2020,7 +2072,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_diverging_default(self) -> Ty<'tcx> {\n-        if self.sess.features.borrow().never_type {\n+        if self.features().never_type {\n             self.types.never\n         } else {\n             self.intern_tup(&[], true)\n@@ -2395,13 +2447,17 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n     };\n     providers.has_copy_closures = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        tcx.sess.features.borrow().copy_closures\n+        tcx.features().copy_closures\n     };\n     providers.has_clone_closures = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        tcx.sess.features.borrow().clone_closures\n+        tcx.features().clone_closures\n     };\n     providers.fully_normalize_monormophic_ty = |tcx, ty| {\n         tcx.fully_normalize_associated_types_in(&ty)\n     };\n+    providers.features_query = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        Lrc::new(tcx.sess.features_untracked().clone())\n+    };\n }"}, {"sha": "c91b30440e5e31ff0d506ca5e5e4b03a83a4a82f", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -593,6 +593,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::fully_normalize_monormophic_ty<'t\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::features_query<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up enabled feature gates\")\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::typeck_tables_of<'tcx> {\n     #[inline]\n     fn cache_on_disk(def_id: Self::Key) -> bool {"}, {"sha": "c211713db6bc091a324930c65968238eb7aa9e2a", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -52,6 +52,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use syntax_pos::symbol::InternedString;\n use syntax::attr;\n use syntax::ast;\n+use syntax::feature_gate;\n use syntax::symbol::Symbol;\n \n #[macro_use]\n@@ -374,12 +375,19 @@ define_maps! { <'tcx>\n     // Get an estimate of the size of an InstanceDef based on its MIR for CGU partitioning.\n     [] fn instance_def_size_estimate: instance_def_size_estimate_dep_node(ty::InstanceDef<'tcx>)\n         -> usize,\n+\n+    [] fn features_query: features_node(CrateNum) -> Lrc<feature_gate::Features>,\n }\n \n //////////////////////////////////////////////////////////////////////\n // These functions are little shims used to find the dep-node for a\n // given query when there is not a *direct* mapping:\n \n+\n+fn features_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::Features\n+}\n+\n fn erase_regions_ty<'tcx>(ty: Ty<'tcx>) -> DepConstructor<'tcx> {\n     DepConstructor::EraseRegionsTy { ty }\n }"}, {"sha": "3443b9b61b2156ba718864b0497371cb5a03a8cd", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -936,6 +936,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::TargetFeaturesEnabled => { force!(target_features_enabled, def_id!()); }\n \n         DepKind::GetSymbolExportLevel => { force!(symbol_export_level, def_id!()); }\n+        DepKind::Features => { force!(features_query, LOCAL_CRATE); }\n     }\n \n     true"}, {"sha": "f6f4e1ceb1563a05c9a69326f32fcf09fdd2a62e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -2335,7 +2335,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns true if the impls are the same polarity and are implementing\n     /// a trait which contains no items\n     pub fn impls_are_allowed_to_overlap(self, def_id1: DefId, def_id2: DefId) -> bool {\n-        if !self.sess.features.borrow().overlapping_marker_traits {\n+        if !self.features().overlapping_marker_traits {\n             return false;\n         }\n         let trait1_is_empty = self.impl_trait_ref(def_id1)"}, {"sha": "bb198adea4a6a6c88a0c304163a1da053747a04b", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -276,7 +276,7 @@ impl<'b, 'tcx: 'b> BorrowckErrors for BorrowckCtxt<'b, 'tcx> {\n                                 o: Origin)\n                                 -> DiagnosticBuilder<'a>\n     {\n-        if !o.should_emit_errors(self.tcx.sess.borrowck_mode()) {\n+        if !o.should_emit_errors(self.tcx.borrowck_mode()) {\n             self.tcx.sess.diagnostic().cancel(&mut diag);\n         }\n         diag"}, {"sha": "8e3b99f2dbfee86a13c3007ff5e18877ce50fa76", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -201,7 +201,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     }\n \n     fn is_uninhabited(&self, ty: Ty<'tcx>) -> bool {\n-        if self.tcx.sess.features.borrow().never_type {\n+        if self.tcx.features().never_type {\n             self.tcx.is_ty_uninhabited_from(self.module, ty)\n         } else {\n             false\n@@ -227,7 +227,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n                               substs: &'tcx ty::subst::Substs<'tcx>)\n                               -> bool\n     {\n-        if self.tcx.sess.features.borrow().never_type {\n+        if self.tcx.features().never_type {\n             self.tcx.is_enum_variant_uninhabited_from(self.module, variant, substs)\n         } else {\n             false"}, {"sha": "6f7143c185cb3ad2718ae1463fee873fd8ea77ff", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             let pat_ty = self.tables.node_id_to_type(scrut.hir_id);\n             let module = self.tcx.hir.get_module_parent(scrut.id);\n             if inlined_arms.is_empty() {\n-                let scrutinee_is_uninhabited = if self.tcx.sess.features.borrow().never_type {\n+                let scrutinee_is_uninhabited = if self.tcx.features().never_type {\n                     self.tcx.is_ty_uninhabited_from(module, pat_ty)\n                 } else {\n                     self.conservative_is_uninhabited(pat_ty)"}, {"sha": "2a571fa82643b2d97777158abcead4396f283349", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -398,7 +398,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n         }).collect::<Result<Vec<_>, _>>()?))))\n       }\n       hir::ExprIndex(ref arr, ref idx) => {\n-        if !tcx.sess.features.borrow().const_indexing {\n+        if !tcx.features().const_indexing {\n             signal!(e, IndexOpFeatureGated);\n         }\n         let arr = cx.eval(arr)?;"}, {"sha": "571cc46bc6413e2eb4f8a9ac9366db05b30b71f2", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -650,7 +650,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n \n     let (mut krate, features) = syntax::config::features(krate, &sess.parse_sess, sess.opts.test);\n     // these need to be set \"early\" so that expansion sees `quote` if enabled.\n-    *sess.features.borrow_mut() = features;\n+    sess.init_features(features);\n \n     *sess.crate_types.borrow_mut() = collect_crate_types(sess, &krate.attrs);\n \n@@ -699,7 +699,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n     let mut registry = registry.unwrap_or(Registry::new(sess, krate.span));\n \n     time(time_passes, \"plugin registration\", || {\n-        if sess.features.borrow().rustc_diagnostic_macros {\n+        if sess.features_untracked().rustc_diagnostic_macros {\n             registry.register_macro(\"__diagnostic_used\",\n                                     diagnostics::plugin::expand_diagnostic_used);\n             registry.register_macro(\"__register_diagnostic\",\n@@ -749,7 +749,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n                                      crate_loader,\n                                      &resolver_arenas);\n     resolver.whitelisted_legacy_custom_derives = whitelisted_legacy_custom_derives;\n-    syntax_ext::register_builtins(&mut resolver, syntax_exts, sess.features.borrow().quote);\n+    syntax_ext::register_builtins(&mut resolver, syntax_exts, sess.features_untracked().quote);\n \n     krate = time(time_passes, \"expansion\", || {\n         // Windows dlls do not have rpaths, so they don't know how to find their\n@@ -780,7 +780,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n                                          .filter(|p| env::join_paths(iter::once(p)).is_ok()))\n                      .unwrap());\n         }\n-        let features = sess.features.borrow();\n+        let features = sess.features_untracked();\n         let cfg = syntax::ext::expand::ExpansionConfig {\n             features: Some(&features),\n             recursion_limit: sess.recursion_limit.get(),\n@@ -819,7 +819,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n                                          sess.opts.test,\n                                          krate,\n                                          sess.diagnostic(),\n-                                         &sess.features.borrow())\n+                                         &sess.features_untracked())\n     });\n \n     // If we're actually rustdoc then there's no need to actually compile\n@@ -886,7 +886,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n         sess.track_errors(|| {\n             syntax::feature_gate::check_crate(&krate,\n                                               &sess.parse_sess,\n-                                              &sess.features.borrow(),\n+                                              &sess.features_untracked(),\n                                               &attributes,\n                                               sess.opts.unstable_features);\n         })"}, {"sha": "17a6176b79e954d4cbb72d2968cb65dff82cf12f", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -69,7 +69,7 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         // if the `rustc_attrs` feature is not enabled, then the\n         // attributes we are interested in cannot be present anyway, so\n         // skip the walk.\n-        if !tcx.sess.features.borrow().rustc_attrs {\n+        if !tcx.features().rustc_attrs {\n             return;\n         }\n "}, {"sha": "e114606a631159c142461f4d67a730c942eb1a8d", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -219,7 +219,7 @@ impl Assertion {\n \n pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // can't add `#[rustc_dirty]` etc without opting in to this feature\n-    if !tcx.sess.features.borrow().rustc_attrs {\n+    if !tcx.features().rustc_attrs {\n         return;\n     }\n "}, {"sha": "62ac898337ca9a13f083cdad8d1bf5aa5115a28d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -1356,7 +1356,7 @@ impl UnreachablePub {\n             // visibility is token at start of declaration (can be macro\n             // variable rather than literal `pub`)\n             let pub_span = cx.tcx.sess.codemap().span_until_char(def_span, ' ');\n-            let replacement = if cx.tcx.sess.features.borrow().crate_visibility_modifier {\n+            let replacement = if cx.tcx.features().crate_visibility_modifier {\n                 \"crate\"\n             } else {\n                 \"pub(crate)\""}, {"sha": "6ab3172c4fefaaa1604dfdf0ec72ae75d5521fe9", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n \n         let mut fn_warned = false;\n         let mut op_warned = false;\n-        if cx.tcx.sess.features.borrow().fn_must_use {\n+        if cx.tcx.features().fn_must_use {\n             let maybe_def = match expr.node {\n                 hir::ExprCall(ref callee, _) => {\n                     match callee.node {"}, {"sha": "2504f8dc251f9e0d11db9fc81dc750a0646eaf63", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -146,15 +146,15 @@ impl<'a, 'tcx> Collector<'a, 'tcx> {\n                 None => self.tcx.sess.err(msg),\n             }\n         }\n-        if lib.cfg.is_some() && !self.tcx.sess.features.borrow().link_cfg {\n+        if lib.cfg.is_some() && !self.tcx.features().link_cfg {\n             feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n                                            \"link_cfg\",\n                                            span.unwrap(),\n                                            GateIssue::Language,\n                                            \"is feature gated\");\n         }\n         if lib.kind == cstore::NativeStaticNobundle &&\n-           !self.tcx.sess.features.borrow().static_nobundle {\n+           !self.tcx.features().static_nobundle {\n             feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n                                            \"static_nobundle\",\n                                            span.unwrap(),"}, {"sha": "b77e7cf2ec8b5f1e597802e54cb39d3bb6ab613c", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -535,7 +535,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err.span_label(borrow_span, \"borrowed value does not live long enough\");\n         err.span_label(drop_span, \"borrowed value only lives until here\");\n \n-        if !self.tcx.sess.nll() {\n+        if !self.tcx.nll() {\n             self.tcx.note_and_explain_region(\n                 scope_tree,\n                 &mut err,\n@@ -572,7 +572,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err.span_label(proper_span, \"temporary value does not live long enough\");\n         err.span_label(drop_span, \"temporary value only lives until here\");\n \n-        if !self.tcx.sess.nll() {\n+        if !self.tcx.nll() {\n             self.tcx.note_and_explain_region(\n                 scope_tree,\n                 &mut err,"}, {"sha": "1ff0ffaaa68b398e7166b2a6c01b4cc632cfc71d", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -72,7 +72,7 @@ fn mir_borrowck<'a, 'tcx>(\n     let input_mir = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.item_path_str(def_id));\n \n-    if !tcx.has_attr(def_id, \"rustc_mir_borrowck\") && !tcx.sess.use_mir() {\n+    if !tcx.has_attr(def_id, \"rustc_mir_borrowck\") && !tcx.use_mir() {\n         return None;\n     }\n \n@@ -101,7 +101,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     // contain non-lexical lifetimes. It will have a lifetime tied\n     // to the inference context.\n     let mut mir: Mir<'tcx> = input_mir.clone();\n-    let free_regions = if !tcx.sess.nll() {\n+    let free_regions = if !tcx.nll() {\n         None\n     } else {\n         let mir = &mut mir;\n@@ -204,7 +204,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         );\n         (Some(Rc::new(regioncx)), opt_closure_req)\n     } else {\n-        assert!(!tcx.sess.nll());\n+        assert!(!tcx.nll());\n         (None, None)\n     };\n     let flow_inits = flow_inits; // remove mut\n@@ -719,7 +719,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// allowed to be split into separate Reservation and\n     /// Activation phases.\n     fn allow_two_phase_borrow(&self, kind: BorrowKind) -> bool {\n-        self.tcx.sess.two_phase_borrows() &&\n+        self.tcx.two_phase_borrows() &&\n             (kind.allows_two_phase_borrow() ||\n              self.tcx.sess.opts.debugging_opts.two_phase_beyond_autoref)\n     }\n@@ -1253,7 +1253,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         span: Span,\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n-        if !self.tcx.sess.two_phase_borrows() {\n+        if !self.tcx.two_phase_borrows() {\n             return;\n         }\n "}, {"sha": "3af10c5c25169e8205c0f72fa1fd1bb8efec5285", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -1587,7 +1587,7 @@ impl MirPass for TypeckMir {\n \n         // When NLL is enabled, the borrow checker runs the typeck\n         // itself, so we don't need this MIR pass anymore.\n-        if tcx.sess.nll() {\n+        if tcx.nll() {\n             return;\n         }\n "}, {"sha": "1ed8289d4418469544d5cd7400a6b718584516c6", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -50,7 +50,7 @@ impl<'tcx> CFG<'tcx> {\n                                              block: BasicBlock,\n                                              source_info: SourceInfo,\n                                              region_scope: region::Scope) {\n-        if tcx.sess.emit_end_regions() {\n+        if tcx.emit_end_regions() {\n             if let region::ScopeData::CallSite(_) = region_scope.data() {\n                 // The CallSite scope (aka the root scope) is sort of weird, in that it is\n                 // supposed to \"separate\" the \"interior\" and \"exterior\" of a closure. Being"}, {"sha": "abea55835466f60434e538f0b2189867afb2c356", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             PatternKind::Variant { adt_def, substs, variant_index, ref subpatterns } => {\n                 let irrefutable = adt_def.variants.iter().enumerate().all(|(i, v)| {\n                     i == variant_index || {\n-                        self.hir.tcx().sess.features.borrow().never_type &&\n+                        self.hir.tcx().features().never_type &&\n                         self.hir.tcx().is_variant_uninhabited_from_all_modules(v, substs)\n                     }\n                 });"}, {"sha": "6e8985d99d287b83b14b6d32ddd44ea061445145", "filename": "src/librustc_mir/transform/clean_end_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_mir%2Ftransform%2Fclean_end_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_mir%2Ftransform%2Fclean_end_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fclean_end_regions.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -42,7 +42,7 @@ impl MirPass for CleanEndRegions {\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _source: MirSource,\n                           mir: &mut Mir<'tcx>) {\n-        if !tcx.sess.emit_end_regions() { return; }\n+        if !tcx.emit_end_regions() { return; }\n \n         let mut gather = GatherBorrowedRegions {\n             seen_regions: FxHashSet()"}, {"sha": "8f5831270d6e5afa94af754ef71f2f7e24914c61", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -936,7 +936,7 @@ This does not pose a problem by itself because they can't be accessed directly.\"\n                     if self.mode != Mode::Fn &&\n \n                         // feature-gate is not enabled,\n-                        !self.tcx.sess.features.borrow()\n+                        !self.tcx.features()\n                             .declared_lib_features\n                             .iter()\n                             .any(|&(ref sym, _)| sym == feature_name) &&"}, {"sha": "89242ca32bcbfa1586ddb2541e3c13b9d8bc5fce", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -514,7 +514,7 @@ impl<'b, 'gcx, 'tcx> BorrowckErrors for TyCtxt<'b, 'gcx, 'tcx> {\n                                 o: Origin)\n                                 -> DiagnosticBuilder<'a>\n     {\n-        if !o.should_emit_errors(self.sess.borrowck_mode()) {\n+        if !o.should_emit_errors(self.borrowck_mode()) {\n             self.sess.diagnostic().cancel(&mut diag);\n         }\n         diag"}, {"sha": "bf59165a9c4614f010e9ca359f3c9bc59d7dc079", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -52,7 +52,7 @@ pub fn load_plugins(sess: &Session,\n     // do not report any error now. since crate attributes are\n     // not touched by expansion, every use of plugin without\n     // the feature enabled will result in an error later...\n-    if sess.features.borrow().plugin {\n+    if sess.features_untracked().plugin {\n         for attr in &krate.attrs {\n             if !attr.check_name(\"plugin\") {\n                 continue;"}, {"sha": "bf7b81c4d0e420938ad8ca08a906ec9c02330366", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -590,7 +590,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         let ext = Lrc::new(macro_rules::compile(&self.session.parse_sess,\n-                                               &self.session.features,\n+                                               &self.session.features_untracked(),\n                                                &macro_def));\n         self.macro_map.insert(def_id, ext.clone());\n         ext"}, {"sha": "fc1ff248184033dc11d7410375bac313a23c488d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -1524,7 +1524,7 @@ impl<'a> Resolver<'a> {\n         invocations.insert(Mark::root(),\n                            arenas.alloc_invocation_data(InvocationData::root(graph_root)));\n \n-        let features = session.features.borrow();\n+        let features = session.features_untracked();\n \n         let mut macro_defs = FxHashMap();\n         macro_defs.insert(Mark::root(), root_def_id);\n@@ -2998,7 +2998,7 @@ impl<'a> Resolver<'a> {\n                 let prim = self.primitive_type_table.primitive_types[&path[0].node.name];\n                 match prim {\n                     TyUint(UintTy::U128) | TyInt(IntTy::I128) => {\n-                        if !self.session.features.borrow().i128_type {\n+                        if !self.session.features_untracked().i128_type {\n                             emit_feature_err(&self.session.parse_sess,\n                                                 \"i128_type\", span, GateIssue::Language,\n                                                 \"128-bit type is unstable\");\n@@ -3089,7 +3089,7 @@ impl<'a> Resolver<'a> {\n                     let prev_name = path[0].node.name;\n                     if prev_name == keywords::Extern.name() ||\n                        prev_name == keywords::CrateRoot.name() &&\n-                       self.session.features.borrow().extern_absolute_paths {\n+                       self.session.features_untracked().extern_absolute_paths {\n                         // `::extern_crate::a::b`\n                         let crate_id = self.crate_loader.resolve_crate_from_path(name, ident.span);\n                         let crate_root ="}, {"sha": "95fa0f3b52fef6b181523c81edef431f6c634e26", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -744,7 +744,7 @@ impl<'a> Resolver<'a> {\n \n         let def_id = self.definitions.local_def_id(item.id);\n         let ext = Lrc::new(macro_rules::compile(&self.session.parse_sess,\n-                                               &self.session.features,\n+                                               &self.session.features_untracked(),\n                                                item));\n         self.macro_map.insert(def_id, ext);\n \n@@ -838,7 +838,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn gate_legacy_custom_derive(&mut self, name: Symbol, span: Span) {\n-        if !self.session.features.borrow().custom_derive {\n+        if !self.session.features_untracked().custom_derive {\n             let sess = &self.session.parse_sess;\n             let explain = feature_gate::EXPLAIN_CUSTOM_DERIVE;\n             emit_feature_err(sess, \"custom_derive\", span, GateIssue::Language, explain);"}, {"sha": "01c1ded94578ecc1fa45da7521930f70595598e7", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -609,7 +609,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         if module_path.len() == 1 && (module_path[0].node.name == keywords::CrateRoot.name() ||\n                                       module_path[0].node.name == keywords::Extern.name()) {\n             let is_extern = module_path[0].node.name == keywords::Extern.name() ||\n-                            self.session.features.borrow().extern_absolute_paths;\n+                            self.session.features_untracked().extern_absolute_paths;\n             match directive.subclass {\n                 GlobImport { .. } if is_extern => {\n                     return Some((directive.span,"}, {"sha": "267c8d2bd03c861bcfac1d495c359c6fdfe1b8fd", "filename": "src/librustc_trans_utils/symbol_names_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_trans_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_trans_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fsymbol_names_test.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -28,7 +28,7 @@ pub fn report_symbol_names<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // if the `rustc_attrs` feature is not enabled, then the\n     // attributes we are interested in cannot be present anyway, so\n     // skip the walk.\n-    if !tcx.sess.features.borrow().rustc_attrs {\n+    if !tcx.features().rustc_attrs {\n         return;\n     }\n "}, {"sha": "0df1225cf26247d157d47284abac2f52f0816ddc", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -415,7 +415,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let trait_def = self.tcx().trait_def(trait_def_id);\n \n-        if !self.tcx().sess.features.borrow().unboxed_closures &&\n+        if !self.tcx().features().unboxed_closures &&\n            trait_segment.with_parameters(|p| p.parenthesized) != trait_def.paren_sugar {\n             // For now, require that parenthetical notation be used only with `Fn()` etc.\n             let msg = if trait_def.paren_sugar {"}, {"sha": "a261c12bcdd946dcc88cca1beeb2a5ce29f86d7c", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             };\n             if pat_adjustments.len() > 0 {\n-                if tcx.sess.features.borrow().match_default_bindings {\n+                if tcx.features().match_default_bindings {\n                     debug!(\"default binding mode is now {:?}\", def_bm);\n                     self.inh.tables.borrow_mut()\n                         .pat_adjustments_mut()"}, {"sha": "abb0acd699cba0b148296bf1580684805d3dff22", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -586,7 +586,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n         }\n \n-        if has_unsized_tuple_coercion && !self.tcx.sess.features.borrow().unsized_tuple_coercion {\n+        if has_unsized_tuple_coercion && !self.tcx.features().unsized_tuple_coercion {\n             feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n                                            \"unsized_tuple_coercion\",\n                                            self.cause.span,"}, {"sha": "841559013a093352731791934b3b872c74450c60", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -324,7 +324,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // possible that there will be multiple applicable methods.\n                 if !is_suggestion.0 {\n                     if reached_raw_pointer\n-                    && !self.tcx.sess.features.borrow().arbitrary_self_types {\n+                    && !self.tcx.features().arbitrary_self_types {\n                         // this case used to be allowed by the compiler,\n                         // so we do a future-compat lint here for the 2015 epoch\n                         // (see https://github.com/rust-lang/rust/issues/46906)"}, {"sha": "0f59973eab251245ddfc004b9b97e6a2d6e4c167", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -1105,7 +1105,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     }\n     fcx.demand_suptype(span, ret_ty, actual_return_ty);\n \n-    if fcx.tcx.sess.features.borrow().termination_trait {\n+    if fcx.tcx.features().termination_trait {\n         // If the termination trait language item is activated, check that the main return type\n         // implements the termination trait.\n         if let Some(term_id) = fcx.tcx.lang_items().termination() {\n@@ -1616,7 +1616,7 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let repr_type_ty = def.repr.discr_type().to_ty(tcx);\n     if repr_type_ty == tcx.types.i128 || repr_type_ty == tcx.types.u128 {\n-        if !tcx.sess.features.borrow().repr128 {\n+        if !tcx.features().repr128 {\n             emit_feature_err(&tcx.sess.parse_sess,\n                              \"repr128\",\n                              sp,"}, {"sha": "d10ee358e072846e77be1591c47c141b1f55d4b1", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -536,7 +536,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         let is_self_ty = |ty| fcx.infcx.can_eq(fcx.param_env, self_ty, ty).is_ok();\n         let self_kind = ExplicitSelf::determine(self_arg_ty, is_self_ty);\n \n-        if !fcx.tcx.sess.features.borrow().arbitrary_self_types {\n+        if !fcx.tcx.features().arbitrary_self_types {\n             match self_kind {\n                 ExplicitSelf::ByValue |\n                 ExplicitSelf::ByReference(_, _) |"}, {"sha": "d3de31d630a97469b8fad938a3b3912d7cd21a3b", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -74,7 +74,7 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, impl_def_id: DefId, trait_d\n         return;\n     }\n \n-    if tcx.sess.features.borrow().unboxed_closures {\n+    if tcx.features().unboxed_closures {\n         // the feature gate allows all Fn traits\n         return;\n     }"}, {"sha": "f7158593f0b6e37cd64d51e121afc009e2033392", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -711,7 +711,7 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     let paren_sugar = tcx.has_attr(def_id, \"rustc_paren_sugar\");\n-    if paren_sugar && !tcx.sess.features.borrow().unboxed_closures {\n+    if paren_sugar && !tcx.features().unboxed_closures {\n         let mut err = tcx.sess.struct_span_err(\n             item.span,\n             \"the `#[rustc_paren_sugar]` attribute is a temporary means of controlling \\\n@@ -953,7 +953,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         if !allow_defaults && p.default.is_some() {\n-            if !tcx.sess.features.borrow().default_type_parameter_fallback {\n+            if !tcx.features().default_type_parameter_fallback {\n                 tcx.lint_node(\n                     lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n                     p.id,\n@@ -1692,7 +1692,7 @@ fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n     // feature gate SIMD types in FFI, since I (huonw) am not sure the\n     // ABIs are handled at all correctly.\n     if abi != abi::Abi::RustIntrinsic && abi != abi::Abi::PlatformIntrinsic\n-            && !tcx.sess.features.borrow().simd_ffi {\n+            && !tcx.features().simd_ffi {\n         let check = |ast_ty: &hir::Ty, ty: Ty| {\n             if ty.is_simd() {\n                 tcx.sess.struct_span_err(ast_ty.span,"}, {"sha": "d9bd96b0d769fea0fb7ae6c686eb57f17b5470ef", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -207,7 +207,7 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             let actual = tcx.fn_sig(main_def_id);\n             let expected_return_type = if tcx.lang_items().termination().is_some()\n-                && tcx.sess.features.borrow().termination_trait {\n+                && tcx.features().termination_trait {\n                 // we take the return type of the given main function, the real check is done\n                 // in `check_fn`\n                 actual.output().skip_binder()"}, {"sha": "e4477bee5c0e9e39e8b0dddd5b9b67959760fc05", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -629,7 +629,7 @@ impl<'a, 'hir> HirCollector<'a, 'hir> {\n                                             nested: F) {\n         let mut attrs = Attributes::from_ast(self.sess.diagnostic(), attrs);\n         if let Some(ref cfg) = attrs.cfg {\n-            if !cfg.matches(&self.sess.parse_sess, Some(&self.sess.features.borrow())) {\n+            if !cfg.matches(&self.sess.parse_sess, Some(&self.sess.features_untracked())) {\n                 return;\n             }\n         }"}, {"sha": "9162a582599fc6dc79f1b1b9ed6161c47fd6479b", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -26,7 +26,6 @@ use parse::token::Token::*;\n use symbol::Symbol;\n use tokenstream::{TokenStream, TokenTree};\n \n-use std::cell::RefCell;\n use std::collections::HashMap;\n use std::collections::hash_map::Entry;\n \n@@ -184,7 +183,7 @@ fn generic_extension<'cx>(cx: &'cx mut ExtCtxt,\n // Holy self-referential!\n \n /// Converts a `macro_rules!` invocation into a syntax extension.\n-pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item) -> SyntaxExtension {\n+pub fn compile(sess: &ParseSess, features: &Features, def: &ast::Item) -> SyntaxExtension {\n     let lhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"lhs\"));\n     let rhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"rhs\"));\n \n@@ -296,7 +295,7 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n }\n \n fn check_lhs_nt_follows(sess: &ParseSess,\n-                        features: &RefCell<Features>,\n+                        features: &Features,\n                         attrs: &[ast::Attribute],\n                         lhs: &quoted::TokenTree) -> bool {\n     // lhs is going to be like TokenTree::Delimited(...), where the\n@@ -353,7 +352,7 @@ fn check_rhs(sess: &ParseSess, rhs: &quoted::TokenTree) -> bool {\n }\n \n fn check_matcher(sess: &ParseSess,\n-                 features: &RefCell<Features>,\n+                 features: &Features,\n                  attrs: &[ast::Attribute],\n                  matcher: &[quoted::TokenTree]) -> bool {\n     let first_sets = FirstSets::new(matcher);\n@@ -601,7 +600,7 @@ impl TokenSet {\n // Requires that `first_sets` is pre-computed for `matcher`;\n // see `FirstSets::new`.\n fn check_matcher_core(sess: &ParseSess,\n-                      features: &RefCell<Features>,\n+                      features: &Features,\n                       attrs: &[ast::Attribute],\n                       first_sets: &FirstSets,\n                       matcher: &[quoted::TokenTree],\n@@ -869,7 +868,7 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> Result<bool, (String, &'\n }\n \n fn has_legal_fragment_specifier(sess: &ParseSess,\n-                                features: &RefCell<Features>,\n+                                features: &Features,\n                                 attrs: &[ast::Attribute],\n                                 tok: &quoted::TokenTree) -> Result<(), String> {\n     debug!(\"has_legal_fragment_specifier({:?})\", tok);\n@@ -884,15 +883,15 @@ fn has_legal_fragment_specifier(sess: &ParseSess,\n }\n \n fn is_legal_fragment_specifier(sess: &ParseSess,\n-                               features: &RefCell<Features>,\n+                               features: &Features,\n                                attrs: &[ast::Attribute],\n                                frag_name: &str,\n                                frag_span: Span) -> bool {\n     match frag_name {\n         \"item\" | \"block\" | \"stmt\" | \"expr\" | \"pat\" |\n         \"path\" | \"ty\" | \"ident\" | \"meta\" | \"tt\" | \"\" => true,\n         \"lifetime\" => {\n-            if !features.borrow().macro_lifetime_matcher &&\n+            if !features.macro_lifetime_matcher &&\n                !attr::contains_name(attrs, \"allow_internal_unstable\") {\n                 let explain = feature_gate::EXPLAIN_LIFETIME_MATCHER;\n                 emit_feature_err(sess,\n@@ -904,7 +903,7 @@ fn is_legal_fragment_specifier(sess: &ParseSess,\n             true\n         },\n         \"vis\" => {\n-            if !features.borrow().macro_vis_matcher &&\n+            if !features.macro_vis_matcher &&\n                !attr::contains_name(attrs, \"allow_internal_unstable\") {\n                 let explain = feature_gate::EXPLAIN_VIS_MATCHER;\n                 emit_feature_err(sess,"}, {"sha": "122bb9ba024a40c321e54a945da2ba0c9020a349", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -17,7 +17,6 @@ use symbol::keywords;\n use syntax_pos::{BytePos, Span, DUMMY_SP};\n use tokenstream;\n \n-use std::cell::RefCell;\n use std::iter::Peekable;\n use rustc_data_structures::sync::Lrc;\n \n@@ -183,7 +182,7 @@ pub fn parse(\n     input: tokenstream::TokenStream,\n     expect_matchers: bool,\n     sess: &ParseSess,\n-    features: &RefCell<Features>,\n+    features: &Features,\n     attrs: &[ast::Attribute],\n ) -> Vec<TokenTree> {\n     // Will contain the final collection of `self::TokenTree`\n@@ -251,7 +250,7 @@ fn parse_tree<I>(\n     trees: &mut Peekable<I>,\n     expect_matchers: bool,\n     sess: &ParseSess,\n-    features: &RefCell<Features>,\n+    features: &Features,\n     attrs: &[ast::Attribute],\n ) -> TokenTree\n where\n@@ -382,7 +381,7 @@ fn parse_sep_and_kleene_op<I>(\n     input: &mut Peekable<I>,\n     span: Span,\n     sess: &ParseSess,\n-    features: &RefCell<Features>,\n+    features: &Features,\n     attrs: &[ast::Attribute],\n ) -> (Option<token::Token>, KleeneOp)\n where\n@@ -415,7 +414,7 @@ where\n                 match parse_kleene_op(input, span) {\n                     // #2 is a KleeneOp (this is the only valid option) :)\n                     Ok(Ok(op)) if op == KleeneOp::ZeroOrOne => {\n-                        if !features.borrow().macro_at_most_once_rep\n+                        if !features.macro_at_most_once_rep\n                             && !attr::contains_name(attrs, \"allow_internal_unstable\")\n                         {\n                             let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n@@ -438,7 +437,7 @@ where\n                     Err(span) => span,\n                 }\n             } else {\n-                if !features.borrow().macro_at_most_once_rep\n+                if !features.macro_at_most_once_rep\n                     && !attr::contains_name(attrs, \"allow_internal_unstable\")\n                 {\n                     let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n@@ -460,7 +459,7 @@ where\n         Ok(Err((tok, span))) => match parse_kleene_op(input, span) {\n             // #2 is a KleeneOp :D\n             Ok(Ok(op)) if op == KleeneOp::ZeroOrOne => {\n-                if !features.borrow().macro_at_most_once_rep\n+                if !features.macro_at_most_once_rep\n                     && !attr::contains_name(attrs, \"allow_internal_unstable\")\n                 {\n                     let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n@@ -487,7 +486,7 @@ where\n         Err(span) => span,\n     };\n \n-    if !features.borrow().macro_at_most_once_rep\n+    if !features.macro_at_most_once_rep\n         && !attr::contains_name(attrs, \"allow_internal_unstable\")\n     {\n         sess.span_diagnostic"}, {"sha": "45d82bc7af38e824e40ca2d9d27d0c787ae690ca", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -62,6 +62,7 @@ macro_rules! declare_features {\n             &[$((stringify!($feature), $ver, $issue, set!($feature))),+];\n \n         /// A set of features to be used by later passes.\n+        #[derive(Clone)]\n         pub struct Features {\n             /// `#![feature]` attrs for stable language features, for error reporting\n             pub declared_stable_lang_features: Vec<(Symbol, Span)>,\n@@ -78,6 +79,12 @@ macro_rules! declare_features {\n                     $($feature: false),+\n                 }\n             }\n+\n+            pub fn walk_feature_fields<F>(&self, mut f: F)\n+                where F: FnMut(&str, bool)\n+            {\n+                $(f(stringify!($feature), self.$feature);)+\n+            }\n         }\n     };\n "}, {"sha": "de2f9ab52f60b330cb4af02b6561047ad1fe5588", "filename": "src/test/incremental/feature_gate.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Ftest%2Fincremental%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Ftest%2Fincremental%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Ffeature_gate.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test makes sure that we detect changed feature gates.\n+\n+// revisions:rpass1 cfail2\n+// compile-flags: -Z query-dep-graph\n+\n+#![feature(rustc_attrs)]\n+#![cfg_attr(rpass1, feature(nll))]\n+\n+fn main() {\n+    let mut v = vec![1];\n+    v.push(v[0]);\n+    //[cfail2]~^ ERROR cannot borrow\n+}"}, {"sha": "fd8f7b9e384f35410136eb58eb9fd8030db12921", "filename": "src/test/run-pass-fulldeps/auxiliary/procedural_mbe_matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9334404f06a188854af33835a0efe1e834e4ac4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs?ref=c9334404f06a188854af33835a0efe1e834e4ac4", "patch": "@@ -41,7 +41,7 @@ fn expand_mbe_matches(cx: &mut ExtCtxt, _: Span, args: &[TokenTree])\n     let mbe_matcher = quoted::parse(mbe_matcher.into_iter().collect(),\n                                     true,\n                                     cx.parse_sess,\n-                                    &RefCell::new(Features::new()),\n+                                    &Features::new(),\n                                     &[]);\n     let map = match TokenTree::parse(cx, &mbe_matcher, args.iter().cloned().collect()) {\n         Success(map) => map,"}]}