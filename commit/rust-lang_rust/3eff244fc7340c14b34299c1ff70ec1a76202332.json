{"sha": "3eff244fc7340c14b34299c1ff70ec1a76202332", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlZmYyNDRmYzczNDBjMTRiMzQyOTljMWZmNzBlYzFhNzYyMDIzMzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-09T18:15:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-09T18:15:20Z"}, "message": "Auto merge of #85832 - kornelski:raw_arg, r=yaahc\n\nUnescaped command-line arguments for Windows\n\nSome Windows commands, expecially `cmd.exe /c`, have unusual quoting requirements which are incompatible with default rules assumed for `.arg()`.\n\nThis adds `.unquoted_arg()` to `Command` via Windows `CommandExt` trait.\n\nFixes #29494", "tree": {"sha": "08a0659ad2595275748196e6a51897df89e2b426", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08a0659ad2595275748196e6a51897df89e2b426"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3eff244fc7340c14b34299c1ff70ec1a76202332", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3eff244fc7340c14b34299c1ff70ec1a76202332", "html_url": "https://github.com/rust-lang/rust/commit/3eff244fc7340c14b34299c1ff70ec1a76202332", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3eff244fc7340c14b34299c1ff70ec1a76202332/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "619c27a53959e2d79aadb01cba5b2c49756df771", "url": "https://api.github.com/repos/rust-lang/rust/commits/619c27a53959e2d79aadb01cba5b2c49756df771", "html_url": "https://github.com/rust-lang/rust/commit/619c27a53959e2d79aadb01cba5b2c49756df771"}, {"sha": "bc67f6bc95106ef0e0b4681a384af153a7228bf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc67f6bc95106ef0e0b4681a384af153a7228bf1", "html_url": "https://github.com/rust-lang/rust/commit/bc67f6bc95106ef0e0b4681a384af153a7228bf1"}], "stats": {"total": 118, "additions": 97, "deletions": 21}, "files": [{"sha": "9e7ccd015b65815336ce3cac06c3b2ed2f9cf76a", "filename": "library/std/src/os/windows/process.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3eff244fc7340c14b34299c1ff70ec1a76202332/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eff244fc7340c14b34299c1ff70ec1a76202332/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fprocess.rs?ref=3eff244fc7340c14b34299c1ff70ec1a76202332", "patch": "@@ -2,6 +2,7 @@\n \n #![stable(feature = \"process_extensions\", since = \"1.2.0\")]\n \n+use crate::ffi::OsStr;\n use crate::os::windows::io::{AsRawHandle, FromRawHandle, IntoRawHandle, RawHandle};\n use crate::process;\n use crate::sealed::Sealed;\n@@ -125,6 +126,13 @@ pub trait CommandExt: Sealed {\n     /// [2]: <https://msdn.microsoft.com/en-us/library/17w5ykft.aspx>\n     #[unstable(feature = \"windows_process_extensions_force_quotes\", issue = \"82227\")]\n     fn force_quotes(&mut self, enabled: bool) -> &mut process::Command;\n+\n+    /// Append literal text to the command line without any quoting or escaping.\n+    ///\n+    /// This is useful for passing arguments to `cmd.exe /c`, which doesn't follow\n+    /// `CommandLineToArgvW` escaping rules.\n+    #[unstable(feature = \"windows_process_extensions_raw_arg\", issue = \"29494\")]\n+    fn raw_arg<S: AsRef<OsStr>>(&mut self, text_to_append_as_is: S) -> &mut process::Command;\n }\n \n #[stable(feature = \"windows_process_extensions\", since = \"1.16.0\")]\n@@ -138,4 +146,9 @@ impl CommandExt for process::Command {\n         self.as_inner_mut().force_quotes(enabled);\n         self\n     }\n+\n+    fn raw_arg<S: AsRef<OsStr>>(&mut self, raw_text: S) -> &mut process::Command {\n+        self.as_inner_mut().raw_arg(raw_text.as_ref());\n+        self\n+    }\n }"}, {"sha": "0fdf72c8067d25abf66ddc39df771fb5bcf9f37d", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 57, "deletions": 20, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/3eff244fc7340c14b34299c1ff70ec1a76202332/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eff244fc7340c14b34299c1ff70ec1a76202332/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=3eff244fc7340c14b34299c1ff70ec1a76202332", "patch": "@@ -137,7 +137,7 @@ fn ensure_no_nuls<T: AsRef<OsStr>>(str: T) -> io::Result<T> {\n \n pub struct Command {\n     program: OsString,\n-    args: Vec<OsString>,\n+    args: Vec<Arg>,\n     env: CommandEnv,\n     cwd: Option<OsString>,\n     flags: u32,\n@@ -161,6 +161,14 @@ pub struct StdioPipes {\n     pub stderr: Option<AnonPipe>,\n }\n \n+#[derive(Debug)]\n+enum Arg {\n+    /// Add quotes (if needed)\n+    Regular(OsString),\n+    /// Append raw string without quoting\n+    Raw(OsString),\n+}\n+\n impl Command {\n     pub fn new(program: &OsStr) -> Command {\n         Command {\n@@ -178,7 +186,7 @@ impl Command {\n     }\n \n     pub fn arg(&mut self, arg: &OsStr) {\n-        self.args.push(arg.to_os_string())\n+        self.args.push(Arg::Regular(arg.to_os_string()))\n     }\n     pub fn env_mut(&mut self) -> &mut CommandEnv {\n         &mut self.env\n@@ -203,6 +211,10 @@ impl Command {\n         self.force_quotes_enabled = enabled;\n     }\n \n+    pub fn raw_arg(&mut self, command_str_to_append: &OsStr) {\n+        self.args.push(Arg::Raw(command_str_to_append.to_os_string()))\n+    }\n+\n     pub fn get_program(&self) -> &OsStr {\n         &self.program\n     }\n@@ -315,9 +327,13 @@ impl Command {\n \n impl fmt::Debug for Command {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{:?}\", self.program)?;\n+        self.program.fmt(f)?;\n         for arg in &self.args {\n-            write!(f, \" {:?}\", arg)?;\n+            f.write_str(\" \")?;\n+            match arg {\n+                Arg::Regular(s) => s.fmt(f),\n+                Arg::Raw(s) => f.write_str(&s.to_string_lossy()),\n+            }?;\n         }\n         Ok(())\n     }\n@@ -536,44 +552,63 @@ fn zeroed_process_information() -> c::PROCESS_INFORMATION {\n     }\n }\n \n+enum Quote {\n+    // Every arg is quoted\n+    Always,\n+    // Whitespace and empty args are quoted\n+    Auto,\n+    // Arg appended without any changes (#29494)\n+    Never,\n+}\n+\n // Produces a wide string *without terminating null*; returns an error if\n // `prog` or any of the `args` contain a nul.\n-fn make_command_line(prog: &OsStr, args: &[OsString], force_quotes: bool) -> io::Result<Vec<u16>> {\n+fn make_command_line(prog: &OsStr, args: &[Arg], force_quotes: bool) -> io::Result<Vec<u16>> {\n     // Encode the command and arguments in a command line string such\n     // that the spawned process may recover them using CommandLineToArgvW.\n     let mut cmd: Vec<u16> = Vec::new();\n     // Always quote the program name so CreateProcess doesn't interpret args as\n     // part of the name if the binary wasn't found first time.\n-    append_arg(&mut cmd, prog, true)?;\n+    append_arg(&mut cmd, prog, Quote::Always)?;\n     for arg in args {\n         cmd.push(' ' as u16);\n-        append_arg(&mut cmd, arg, force_quotes)?;\n+        let (arg, quote) = match arg {\n+            Arg::Regular(arg) => (arg, if force_quotes { Quote::Always } else { Quote::Auto }),\n+            Arg::Raw(arg) => (arg, Quote::Never),\n+        };\n+        append_arg(&mut cmd, arg, quote)?;\n     }\n     return Ok(cmd);\n \n-    fn append_arg(cmd: &mut Vec<u16>, arg: &OsStr, force_quotes: bool) -> io::Result<()> {\n+    fn append_arg(cmd: &mut Vec<u16>, arg: &OsStr, quote: Quote) -> io::Result<()> {\n         // If an argument has 0 characters then we need to quote it to ensure\n         // that it actually gets passed through on the command line or otherwise\n         // it will be dropped entirely when parsed on the other end.\n         ensure_no_nuls(arg)?;\n         let arg_bytes = &arg.as_inner().inner.as_inner();\n-        let quote = force_quotes\n-            || arg_bytes.iter().any(|c| *c == b' ' || *c == b'\\t')\n-            || arg_bytes.is_empty();\n+        let (quote, escape) = match quote {\n+            Quote::Always => (true, true),\n+            Quote::Auto => {\n+                (arg_bytes.iter().any(|c| *c == b' ' || *c == b'\\t') || arg_bytes.is_empty(), true)\n+            }\n+            Quote::Never => (false, false),\n+        };\n         if quote {\n             cmd.push('\"' as u16);\n         }\n \n         let mut backslashes: usize = 0;\n         for x in arg.encode_wide() {\n-            if x == '\\\\' as u16 {\n-                backslashes += 1;\n-            } else {\n-                if x == '\"' as u16 {\n-                    // Add n+1 backslashes to total 2n+1 before internal '\"'.\n-                    cmd.extend((0..=backslashes).map(|_| '\\\\' as u16));\n+            if escape {\n+                if x == '\\\\' as u16 {\n+                    backslashes += 1;\n+                } else {\n+                    if x == '\"' as u16 {\n+                        // Add n+1 backslashes to total 2n+1 before internal '\"'.\n+                        cmd.extend((0..=backslashes).map(|_| '\\\\' as u16));\n+                    }\n+                    backslashes = 0;\n                 }\n-                backslashes = 0;\n             }\n             cmd.push(x);\n         }\n@@ -626,13 +661,15 @@ fn make_dirp(d: Option<&OsString>) -> io::Result<(*const u16, Vec<u16>)> {\n }\n \n pub struct CommandArgs<'a> {\n-    iter: crate::slice::Iter<'a, OsString>,\n+    iter: crate::slice::Iter<'a, Arg>,\n }\n \n impl<'a> Iterator for CommandArgs<'a> {\n     type Item = &'a OsStr;\n     fn next(&mut self) -> Option<&'a OsStr> {\n-        self.iter.next().map(|s| s.as_ref())\n+        self.iter.next().map(|arg| match arg {\n+            Arg::Regular(s) | Arg::Raw(s) => s.as_ref(),\n+        })\n     }\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()"}, {"sha": "3b65856dcaca6d4f3e017a2ba97fccf2cf8f339c", "filename": "library/std/src/sys/windows/process/tests.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3eff244fc7340c14b34299c1ff70ec1a76202332/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eff244fc7340c14b34299c1ff70ec1a76202332/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs?ref=3eff244fc7340c14b34299c1ff70ec1a76202332", "patch": "@@ -1,14 +1,35 @@\n use super::make_command_line;\n+use super::Arg;\n use crate::env;\n use crate::ffi::{OsStr, OsString};\n use crate::process::Command;\n \n+#[test]\n+fn test_raw_args() {\n+    let command_line = &make_command_line(\n+        OsStr::new(\"quoted exe\"),\n+        &[\n+            Arg::Regular(OsString::from(\"quote me\")),\n+            Arg::Raw(OsString::from(\"quote me *not*\")),\n+            Arg::Raw(OsString::from(\"\\t\\\\\")),\n+            Arg::Raw(OsString::from(\"internal \\\\\\\"backslash-\\\"quote\")),\n+            Arg::Regular(OsString::from(\"optional-quotes\")),\n+        ],\n+        false,\n+    )\n+    .unwrap();\n+    assert_eq!(\n+        String::from_utf16(command_line).unwrap(),\n+        \"\\\"quoted exe\\\" \\\"quote me\\\" quote me *not* \\t\\\\ internal \\\\\\\"backslash-\\\"quote optional-quotes\"\n+    );\n+}\n+\n #[test]\n fn test_make_command_line() {\n     fn test_wrapper(prog: &str, args: &[&str], force_quotes: bool) -> String {\n         let command_line = &make_command_line(\n             OsStr::new(prog),\n-            &args.iter().map(|a| OsString::from(a)).collect::<Vec<OsString>>(),\n+            &args.iter().map(|a| Arg::Regular(OsString::from(a))).collect::<Vec<_>>(),\n             force_quotes,\n         )\n         .unwrap();\n@@ -17,6 +38,11 @@ fn test_make_command_line() {\n \n     assert_eq!(test_wrapper(\"prog\", &[\"aaa\", \"bbb\", \"ccc\"], false), \"\\\"prog\\\" aaa bbb ccc\");\n \n+    assert_eq!(test_wrapper(\"prog\", &[r\"C:\\\"], false), r#\"\"prog\" C:\\\"#);\n+    assert_eq!(test_wrapper(\"prog\", &[r\"2slashes\\\\\"], false), r#\"\"prog\" 2slashes\\\\\"#);\n+    assert_eq!(test_wrapper(\"prog\", &[r\" C:\\\"], false), r#\"\"prog\" \" C:\\\\\"\"#);\n+    assert_eq!(test_wrapper(\"prog\", &[r\" 2slashes\\\\\"], false), r#\"\"prog\" \" 2slashes\\\\\\\\\"\"#);\n+\n     assert_eq!(\n         test_wrapper(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", &[\"aaa\"], false),\n         \"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\""}]}