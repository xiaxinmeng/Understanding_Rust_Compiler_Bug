{"sha": "88c11c5bfffea445c6cc49b62da17f172eb8f055", "node_id": "C_kwDOAAsO6NoAKDg4YzExYzViZmZmZWE0NDVjNmNjNDliNjJkYTE3ZjE3MmViOGYwNTU", "commit": {"author": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-07-11T16:15:31Z"}, "committer": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-07-15T15:13:49Z"}, "message": "macros: support `MultiSpan` in diag derives\n\nAdd support for `MultiSpan` with any of the attributes that work on a\n`Span` - requires that diagnostic logic generated for these attributes\nare emitted in the by-move block rather than the by-ref block that they\nwould normally have been generated in.\n\nSigned-off-by: David Wood <david.wood@huawei.com>", "tree": {"sha": "1b5cbd5bd5b9a384bbd6ed7830777f42ba39c309", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b5cbd5bd5b9a384bbd6ed7830777f42ba39c309"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88c11c5bfffea445c6cc49b62da17f172eb8f055", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88c11c5bfffea445c6cc49b62da17f172eb8f055", "html_url": "https://github.com/rust-lang/rust/commit/88c11c5bfffea445c6cc49b62da17f172eb8f055", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88c11c5bfffea445c6cc49b62da17f172eb8f055/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3fdf748856fa220dc251647808db8535ac0bba2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3fdf748856fa220dc251647808db8535ac0bba2", "html_url": "https://github.com/rust-lang/rust/commit/c3fdf748856fa220dc251647808db8535ac0bba2"}], "stats": {"total": 172, "additions": 104, "deletions": 68}, "files": [{"sha": "db3ba20d8f9d8272b10808e237b89706fba74a60", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 81, "deletions": 58, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/88c11c5bfffea445c6cc49b62da17f172eb8f055/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88c11c5bfffea445c6cc49b62da17f172eb8f055/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=88c11c5bfffea445c6cc49b62da17f172eb8f055", "patch": "@@ -13,7 +13,8 @@ use quote::{format_ident, quote};\n use std::collections::HashMap;\n use std::str::FromStr;\n use syn::{\n-    parse_quote, spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta, Path, Type,\n+    parse_quote, spanned::Spanned, Attribute, Field, Meta, MetaList, MetaNameValue, NestedMeta,\n+    Path, Type,\n };\n use synstructure::{BindingInfo, Structure};\n \n@@ -80,8 +81,8 @@ impl DiagnosticDeriveBuilder {\n     }\n \n     pub fn body<'s>(&mut self, structure: &mut Structure<'s>) -> (TokenStream, TokenStream) {\n-        // Keep track of which fields are subdiagnostics or have no attributes.\n-        let mut subdiagnostics_or_empty = std::collections::HashSet::new();\n+        // Keep track of which fields need to be handled with a by-move binding.\n+        let mut needs_moved = std::collections::HashSet::new();\n \n         // Generates calls to `span_label` and similar functions based on the attributes\n         // on fields. Code for suggestions uses formatting machinery and the value of\n@@ -92,16 +93,11 @@ impl DiagnosticDeriveBuilder {\n         let attrs = structure\n             .clone()\n             .filter(|field_binding| {\n-                let attrs = &field_binding.ast().attrs;\n-\n-                (!attrs.is_empty()\n-                    && attrs.iter().all(|attr| {\n-                        \"subdiagnostic\" != attr.path.segments.last().unwrap().ident.to_string()\n-                    }))\n-                    || {\n-                        subdiagnostics_or_empty.insert(field_binding.binding.clone());\n-                        false\n-                    }\n+                let ast = &field_binding.ast();\n+                !self.needs_move(ast) || {\n+                    needs_moved.insert(field_binding.binding.clone());\n+                    false\n+                }\n             })\n             .each(|field_binding| self.generate_field_attrs_code(field_binding));\n \n@@ -111,12 +107,41 @@ impl DiagnosticDeriveBuilder {\n         // attributes or a `#[subdiagnostic]` attribute then it must be passed as an\n         // argument to the diagnostic so that it can be referred to by Fluent messages.\n         let args = structure\n-            .filter(|field_binding| subdiagnostics_or_empty.contains(&field_binding.binding))\n+            .filter(|field_binding| needs_moved.contains(&field_binding.binding))\n             .each(|field_binding| self.generate_field_attrs_code(field_binding));\n \n         (attrs, args)\n     }\n \n+    /// Returns `true` if `field` should generate a `set_arg` call rather than any other diagnostic\n+    /// call (like `span_label`).\n+    fn should_generate_set_arg(&self, field: &Field) -> bool {\n+        field.attrs.is_empty()\n+    }\n+\n+    /// Returns `true` if `field` needs to have code generated in the by-move branch of the\n+    /// generated derive rather than the by-ref branch.\n+    fn needs_move(&self, field: &Field) -> bool {\n+        let generates_set_arg = self.should_generate_set_arg(field);\n+        let is_multispan = type_matches_path(&field.ty, &[\"rustc_errors\", \"MultiSpan\"]);\n+        // FIXME(davidtwco): better support for one field needing to be in the by-move and\n+        // by-ref branches.\n+        let is_subdiagnostic = field\n+            .attrs\n+            .iter()\n+            .map(|attr| attr.path.segments.last().unwrap().ident.to_string())\n+            .any(|attr| attr == \"subdiagnostic\");\n+\n+        // `set_arg` calls take their argument by-move..\n+        generates_set_arg\n+            // If this is a `MultiSpan` field then it needs to be moved to be used by any\n+            // attribute..\n+            || is_multispan\n+            // If this a `#[subdiagnostic]` then it needs to be moved as the other diagnostic is\n+            // unlikely to be `Copy`..\n+            || is_subdiagnostic\n+    }\n+\n     /// Establishes state in the `DiagnosticDeriveBuilder` resulting from the struct\n     /// attributes like `#[error(..)`, such as the diagnostic kind and slug. Generates\n     /// diagnostic builder calls for setting error code and creating note/help messages.\n@@ -227,57 +252,55 @@ impl DiagnosticDeriveBuilder {\n         let field = binding_info.ast();\n         let field_binding = &binding_info.binding;\n \n-        let inner_ty = FieldInnerTy::from_type(&field.ty);\n-\n-        // When generating `set_arg` or `add_subdiagnostic` calls, move data rather than\n-        // borrow it to avoid requiring clones - this must therefore be the last use of\n-        // each field (for example, any formatting machinery that might refer to a field\n-        // should be generated already).\n-        if field.attrs.is_empty() {\n+        if self.should_generate_set_arg(&field) {\n             let diag = &self.diag;\n             let ident = field.ident.as_ref().unwrap();\n-            quote! {\n+            return quote! {\n                 #diag.set_arg(\n                     stringify!(#ident),\n                     #field_binding\n                 );\n-            }\n-        } else {\n-            field\n-                .attrs\n-                .iter()\n-                .map(move |attr| {\n-                    let name = attr.path.segments.last().unwrap().ident.to_string();\n-                    let (binding, needs_destructure) = match (name.as_str(), &inner_ty) {\n-                        // `primary_span` can accept a `Vec<Span>` so don't destructure that.\n-                        (\"primary_span\", FieldInnerTy::Vec(_)) => {\n-                            (quote! { #field_binding.clone() }, false)\n-                        }\n-                        // `subdiagnostics` are not derefed because they are bound by value.\n-                        (\"subdiagnostic\", _) => (quote! { #field_binding }, true),\n-                        _ => (quote! { *#field_binding }, true),\n-                    };\n-\n-                    let generated_code = self\n-                        .generate_inner_field_code(\n-                            attr,\n-                            FieldInfo {\n-                                binding: binding_info,\n-                                ty: inner_ty.inner_type().unwrap_or(&field.ty),\n-                                span: &field.span(),\n-                            },\n-                            binding,\n-                        )\n-                        .unwrap_or_else(|v| v.to_compile_error());\n-\n-                    if needs_destructure {\n-                        inner_ty.with(field_binding, generated_code)\n-                    } else {\n-                        generated_code\n-                    }\n-                })\n-                .collect()\n+            };\n         }\n+\n+        let needs_move = self.needs_move(&field);\n+        let inner_ty = FieldInnerTy::from_type(&field.ty);\n+\n+        field\n+            .attrs\n+            .iter()\n+            .map(move |attr| {\n+                let name = attr.path.segments.last().unwrap().ident.to_string();\n+                let needs_clone =\n+                    name == \"primary_span\" && matches!(inner_ty, FieldInnerTy::Vec(_));\n+                let (binding, needs_destructure) = if needs_clone {\n+                    // `primary_span` can accept a `Vec<Span>` so don't destructure that.\n+                    (quote! { #field_binding.clone() }, false)\n+                } else if needs_move {\n+                    (quote! { #field_binding }, true)\n+                } else {\n+                    (quote! { *#field_binding }, true)\n+                };\n+\n+                let generated_code = self\n+                    .generate_inner_field_code(\n+                        attr,\n+                        FieldInfo {\n+                            binding: binding_info,\n+                            ty: inner_ty.inner_type().unwrap_or(&field.ty),\n+                            span: &field.span(),\n+                        },\n+                        binding,\n+                    )\n+                    .unwrap_or_else(|v| v.to_compile_error());\n+\n+                if needs_destructure {\n+                    inner_ty.with(field_binding, generated_code)\n+                } else {\n+                    generated_code\n+                }\n+            })\n+            .collect()\n     }\n \n     fn generate_inner_field_code("}, {"sha": "002abb152f7597a788fa4cbb954febfa6e94d00e", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88c11c5bfffea445c6cc49b62da17f172eb8f055/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88c11c5bfffea445c6cc49b62da17f172eb8f055/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=88c11c5bfffea445c6cc49b62da17f172eb8f055", "patch": "@@ -85,7 +85,13 @@ pub(crate) fn report_error_if_not_applied_to_span(\n     attr: &Attribute,\n     info: &FieldInfo<'_>,\n ) -> Result<(), DiagnosticDeriveError> {\n-    report_error_if_not_applied_to_ty(attr, info, &[\"rustc_span\", \"Span\"], \"`Span`\")\n+    if !type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"])\n+        && !type_matches_path(&info.ty, &[\"rustc_errors\", \"MultiSpan\"])\n+    {\n+        report_type_error(attr, \"`Span` or `MultiSpan`\")?;\n+    }\n+\n+    Ok(())\n }\n \n /// Inner type of a field and type of wrapper."}, {"sha": "b343bcb772142f6445ed62fdb8fbeb18a9d09fbf", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/88c11c5bfffea445c6cc49b62da17f172eb8f055/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88c11c5bfffea445c6cc49b62da17f172eb8f055/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=88c11c5bfffea445c6cc49b62da17f172eb8f055", "patch": "@@ -23,7 +23,7 @@ extern crate rustc_middle;\n use rustc_middle::ty::Ty;\n \n extern crate rustc_errors;\n-use rustc_errors::Applicability;\n+use rustc_errors::{Applicability, MultiSpan};\n \n extern crate rustc_session;\n \n@@ -140,7 +140,7 @@ struct CodeNotProvided {}\n #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct MessageWrongType {\n     #[primary_span]\n-    //~^ ERROR `#[primary_span]` attribute can only be applied to fields of type `Span`\n+    //~^ ERROR `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n     foo: String,\n }\n \n@@ -165,7 +165,7 @@ struct ErrorWithField {\n #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithMessageAppliedToField {\n     #[label(typeck::label)]\n-    //~^ ERROR the `#[label(...)]` attribute can only be applied to fields of type `Span`\n+    //~^ ERROR the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n     name: String,\n }\n \n@@ -208,7 +208,7 @@ struct LabelOnSpan {\n #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct LabelOnNonSpan {\n     #[label(typeck::label)]\n-    //~^ ERROR the `#[label(...)]` attribute can only be applied to fields of type `Span`\n+    //~^ ERROR the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n     id: u32,\n }\n \n@@ -552,3 +552,10 @@ struct LintsGood {\n //~^ ERROR only `#[lint(..)]` is supported\n struct ErrorsBad {\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+struct ErrorWithMultiSpan {\n+    #[primary_span]\n+    span: MultiSpan,\n+}"}, {"sha": "e2580c6485a9592c098c28f89b777a782e44d52c", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88c11c5bfffea445c6cc49b62da17f172eb8f055/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/88c11c5bfffea445c6cc49b62da17f172eb8f055/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=88c11c5bfffea445c6cc49b62da17f172eb8f055", "patch": "@@ -233,7 +233,7 @@ LL | | struct SlugNotProvided {}\n    |\n    = help: specify the slug as the first argument to the attribute, such as `#[error(typeck::example_error)]`\n \n-error: the `#[primary_span]` attribute can only be applied to fields of type `Span`\n+error: the `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n   --> $DIR/diagnostic-derive.rs:142:5\n    |\n LL |     #[primary_span]\n@@ -247,7 +247,7 @@ LL |     #[nonsense]\n    |\n    = help: only `skip_arg`, `primary_span`, `label`, `note`, `help` and `subdiagnostic` are valid field attributes\n \n-error: the `#[label(...)]` attribute can only be applied to fields of type `Span`\n+error: the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n   --> $DIR/diagnostic-derive.rs:167:5\n    |\n LL |     #[label(typeck::label)]\n@@ -279,7 +279,7 @@ LL | #[derive(SessionDiagnostic)]\n    = note: if you intended to print `}`, you can escape it using `}}`\n    = note: this error originates in the derive macro `SessionDiagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: the `#[label(...)]` attribute can only be applied to fields of type `Span`\n+error: the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n   --> $DIR/diagnostic-derive.rs:210:5\n    |\n LL |     #[label(typeck::label)]"}, {"sha": "cbb66c13c680c82333a3d82aad3fcde970e82be6", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88c11c5bfffea445c6cc49b62da17f172eb8f055/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88c11c5bfffea445c6cc49b62da17f172eb8f055/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs?ref=88c11c5bfffea445c6cc49b62da17f172eb8f055", "patch": "@@ -244,7 +244,7 @@ enum V {\n //~^ ERROR label without `#[primary_span]` field\n struct W {\n     #[primary_span]\n-    //~^ ERROR the `#[primary_span]` attribute can only be applied to fields of type `Span`\n+    //~^ ERROR the `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n     span: String,\n }\n "}, {"sha": "a289c4fffd9365e6882e9bd0a60fff2d420c6988", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88c11c5bfffea445c6cc49b62da17f172eb8f055/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/88c11c5bfffea445c6cc49b62da17f172eb8f055/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr?ref=88c11c5bfffea445c6cc49b62da17f172eb8f055", "patch": "@@ -120,7 +120,7 @@ error: subdiagnostic kind not specified\n LL |     B {\n    |     ^\n \n-error: the `#[primary_span]` attribute can only be applied to fields of type `Span`\n+error: the `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n   --> $DIR/subdiagnostic-derive.rs:246:5\n    |\n LL |     #[primary_span]"}]}