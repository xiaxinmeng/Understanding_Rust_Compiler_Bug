{"sha": "1a331689d1b6be3ece47737838572e6d7371424d", "node_id": "C_kwDOAAsO6NoAKDFhMzMxNjg5ZDFiNmJlM2VjZTQ3NzM3ODM4NTcyZTZkNzM3MTQyNGQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-14T10:22:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-14T10:22:33Z"}, "message": "Auto merge of #14573 - Veykril:expr-scopes, r=Veykril\n\ninternal: Allocate ExprScopes ScopeEntries in a single arena instead of per ScopeData", "tree": {"sha": "a497af41d2c35af975f9a7f5dab958e210feb82c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a497af41d2c35af975f9a7f5dab958e210feb82c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a331689d1b6be3ece47737838572e6d7371424d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a331689d1b6be3ece47737838572e6d7371424d", "html_url": "https://github.com/rust-lang/rust/commit/1a331689d1b6be3ece47737838572e6d7371424d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a331689d1b6be3ece47737838572e6d7371424d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c479804d79533b2e3441fe856f4c348e8385fdbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/c479804d79533b2e3441fe856f4c348e8385fdbe", "html_url": "https://github.com/rust-lang/rust/commit/c479804d79533b2e3441fe856f4c348e8385fdbe"}, {"sha": "ce0896b78cec180fad11a631abbce38efad69697", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce0896b78cec180fad11a631abbce38efad69697", "html_url": "https://github.com/rust-lang/rust/commit/ce0896b78cec180fad11a631abbce38efad69697"}], "stats": {"total": 62, "additions": 49, "deletions": 13}, "files": [{"sha": "1143f666eea182d9ad84086278e3476eeb8992bb", "filename": "crates/hir-def/src/body/scope.rs", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1a331689d1b6be3ece47737838572e6d7371424d/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a331689d1b6be3ece47737838572e6d7371424d/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs?ref=1a331689d1b6be3ece47737838572e6d7371424d", "patch": "@@ -2,7 +2,7 @@\n use std::sync::Arc;\n \n use hir_expand::name::Name;\n-use la_arena::{Arena, Idx};\n+use la_arena::{Arena, Idx, IdxRange, RawIdx};\n use rustc_hash::FxHashMap;\n \n use crate::{\n@@ -17,6 +17,7 @@ pub type ScopeId = Idx<ScopeData>;\n #[derive(Debug, PartialEq, Eq)]\n pub struct ExprScopes {\n     scopes: Arena<ScopeData>,\n+    scope_entries: Arena<ScopeEntry>,\n     scope_by_expr: FxHashMap<ExprId, ScopeId>,\n }\n \n@@ -41,7 +42,7 @@ pub struct ScopeData {\n     parent: Option<ScopeId>,\n     block: Option<BlockId>,\n     label: Option<(LabelId, Name)>,\n-    entries: Vec<ScopeEntry>,\n+    entries: IdxRange<ScopeEntry>,\n }\n \n impl ExprScopes {\n@@ -53,7 +54,7 @@ impl ExprScopes {\n     }\n \n     pub fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n-        &self.scopes[scope].entries\n+        &self.scope_entries[self.scopes[scope].entries.clone()]\n     }\n \n     /// If `scope` refers to a block expression scope, returns the corresponding `BlockId`.\n@@ -85,31 +86,48 @@ impl ExprScopes {\n     }\n }\n \n+fn empty_entries(idx: usize) -> IdxRange<ScopeEntry> {\n+    IdxRange::new(Idx::from_raw(RawIdx::from(idx as u32))..Idx::from_raw(RawIdx::from(idx as u32)))\n+}\n+\n impl ExprScopes {\n     fn new(body: &Body) -> ExprScopes {\n-        let mut scopes =\n-            ExprScopes { scopes: Arena::default(), scope_by_expr: FxHashMap::default() };\n+        let mut scopes = ExprScopes {\n+            scopes: Arena::default(),\n+            scope_entries: Arena::default(),\n+            scope_by_expr: FxHashMap::default(),\n+        };\n         let mut root = scopes.root_scope();\n         scopes.add_params_bindings(body, root, &body.params);\n         compute_expr_scopes(body.body_expr, body, &mut scopes, &mut root);\n         scopes\n     }\n \n     fn root_scope(&mut self) -> ScopeId {\n-        self.scopes.alloc(ScopeData { parent: None, block: None, label: None, entries: vec![] })\n+        self.scopes.alloc(ScopeData {\n+            parent: None,\n+            block: None,\n+            label: None,\n+            entries: empty_entries(self.scope_entries.len()),\n+        })\n     }\n \n     fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n         self.scopes.alloc(ScopeData {\n             parent: Some(parent),\n             block: None,\n             label: None,\n-            entries: vec![],\n+            entries: empty_entries(self.scope_entries.len()),\n         })\n     }\n \n     fn new_labeled_scope(&mut self, parent: ScopeId, label: Option<(LabelId, Name)>) -> ScopeId {\n-        self.scopes.alloc(ScopeData { parent: Some(parent), block: None, label, entries: vec![] })\n+        self.scopes.alloc(ScopeData {\n+            parent: Some(parent),\n+            block: None,\n+            label,\n+            entries: empty_entries(self.scope_entries.len()),\n+        })\n     }\n \n     fn new_block_scope(\n@@ -118,13 +136,19 @@ impl ExprScopes {\n         block: Option<BlockId>,\n         label: Option<(LabelId, Name)>,\n     ) -> ScopeId {\n-        self.scopes.alloc(ScopeData { parent: Some(parent), block, label, entries: vec![] })\n+        self.scopes.alloc(ScopeData {\n+            parent: Some(parent),\n+            block,\n+            label,\n+            entries: empty_entries(self.scope_entries.len()),\n+        })\n     }\n \n     fn add_bindings(&mut self, body: &Body, scope: ScopeId, binding: BindingId) {\n         let Binding { name, .. } = &body.bindings[binding];\n-        let entry = ScopeEntry { name: name.clone(), binding };\n-        self.scopes[scope].entries.push(entry);\n+        let entry = self.scope_entries.alloc(ScopeEntry { name: name.clone(), binding });\n+        self.scopes[scope].entries =\n+            IdxRange::new_inclusive(self.scopes[scope].entries.start()..=entry);\n     }\n \n     fn add_pat_bindings(&mut self, body: &Body, scope: ScopeId, pat: PatId) {\n@@ -145,9 +169,9 @@ impl ExprScopes {\n     }\n \n     fn shrink_to_fit(&mut self) {\n-        let ExprScopes { scopes, scope_by_expr } = self;\n+        let ExprScopes { scopes, scope_entries, scope_by_expr } = self;\n         scopes.shrink_to_fit();\n-        scopes.values_mut().for_each(|it| it.entries.shrink_to_fit());\n+        scope_entries.shrink_to_fit();\n         scope_by_expr.shrink_to_fit();\n     }\n }"}, {"sha": "b03fa5b61d3058493b079aecd3967fe813c73922", "filename": "lib/la-arena/src/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1a331689d1b6be3ece47737838572e6d7371424d/lib%2Fla-arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a331689d1b6be3ece47737838572e6d7371424d/lib%2Fla-arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fla-arena%2Fsrc%2Flib.rs?ref=1a331689d1b6be3ece47737838572e6d7371424d", "patch": "@@ -19,12 +19,14 @@ pub use map::{ArenaMap, Entry, OccupiedEntry, VacantEntry};\n pub struct RawIdx(u32);\n \n impl From<RawIdx> for u32 {\n+    #[inline]\n     fn from(raw: RawIdx) -> u32 {\n         raw.0\n     }\n }\n \n impl From<u32> for RawIdx {\n+    #[inline]\n     fn from(idx: u32) -> RawIdx {\n         RawIdx(idx)\n     }\n@@ -160,6 +162,16 @@ impl<T> IdxRange<T> {\n     pub fn is_empty(&self) -> bool {\n         self.range.is_empty()\n     }\n+\n+    /// Returns the start of the index range.\n+    pub fn start(&self) -> Idx<T> {\n+        Idx::from_raw(RawIdx::from(self.range.start))\n+    }\n+\n+    /// Returns the start of the index range.\n+    pub fn end(&self) -> Idx<T> {\n+        Idx::from_raw(RawIdx::from(self.range.end))\n+    }\n }\n \n impl<T> Iterator for IdxRange<T> {"}]}