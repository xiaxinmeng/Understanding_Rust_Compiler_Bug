{"sha": "21f6e55ce99d59733cc49977a1a416882da1c808", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxZjZlNTVjZTk5ZDU5NzMzY2M0OTk3N2ExYTQxNjg4MmRhMWM4MDg=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-04-13T17:22:22Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-04-16T21:30:34Z"}, "message": "Call default_span lazily when query cycles occur instead of in the hot path for queries", "tree": {"sha": "2f92905ef63c9ebee7ef43432a33796acce6ce0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f92905ef63c9ebee7ef43432a33796acce6ce0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21f6e55ce99d59733cc49977a1a416882da1c808", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21f6e55ce99d59733cc49977a1a416882da1c808", "html_url": "https://github.com/rust-lang/rust/commit/21f6e55ce99d59733cc49977a1a416882da1c808", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21f6e55ce99d59733cc49977a1a416882da1c808/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49317cd511fbb60178bd5122e484609568938468", "url": "https://api.github.com/repos/rust-lang/rust/commits/49317cd511fbb60178bd5122e484609568938468", "html_url": "https://github.com/rust-lang/rust/commit/49317cd511fbb60178bd5122e484609568938468"}], "stats": {"total": 53, "additions": 28, "deletions": 25}, "files": [{"sha": "1475c36977aac68776d92a313228da625f63f54b", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/21f6e55ce99d59733cc49977a1a416882da1c808/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21f6e55ce99d59733cc49977a1a416882da1c808/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=21f6e55ce99d59733cc49977a1a416882da1c808", "patch": "@@ -17,6 +17,7 @@ use errors::DiagnosticBuilder;\n use errors::Level;\n use ty::tls;\n use ty::{TyCtxt};\n+use ty::maps::Query;\n use ty::maps::config::QueryDescription;\n use ty::maps::job::{QueryResult, QueryInfo};\n use ty::item_path;\n@@ -63,6 +64,7 @@ pub(super) trait GetCacheInternal<'tcx>: QueryDescription<'tcx> + Sized {\n \n #[derive(Clone)]\n pub(super) struct CycleError<'tcx> {\n+    /// The span of the reason the first query in `cycle` ran the last query in `cycle`\n     pub(super) span: Span,\n     pub(super) cycle: Vec<QueryInfo<'tcx>>,\n }\n@@ -79,27 +81,31 @@ pub(super) enum TryGetLock<'a, 'tcx: 'a, T, D: QueryDescription<'tcx> + 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub(super) fn report_cycle(self, CycleError { span, cycle: stack }: CycleError)\n+    pub(super) fn report_cycle(self, CycleError { span, cycle: stack }: CycleError<'gcx>)\n         -> DiagnosticBuilder<'a>\n     {\n         assert!(!stack.is_empty());\n \n+        let fix_span = |span: Span, query: &Query<'gcx>| {\n+            self.sess.codemap().def_span(query.default_span(self, span))\n+        };\n+\n         // Disable naming impls with types in this path, since that\n         // sometimes cycles itself, leading to extra cycle errors.\n         // (And cycle errors around impls tend to occur during the\n         // collect/coherence phases anyhow.)\n         item_path::with_forced_impl_filename_line(|| {\n-            let span = self.sess.codemap().def_span(span);\n+            let span = fix_span(span, &stack.first().unwrap().query);\n             let mut err =\n                 struct_span_err!(self.sess, span, E0391,\n                                  \"cyclic dependency detected\");\n             err.span_label(span, \"cyclic reference\");\n \n-            err.span_note(self.sess.codemap().def_span(stack[0].span),\n+            err.span_note(fix_span(stack[0].span, &stack[0].query),\n                           &format!(\"the cycle begins when {}...\", stack[0].query.describe(self)));\n \n             for &QueryInfo { span, ref query, .. } in &stack[1..] {\n-                err.span_note(self.sess.codemap().def_span(span),\n+                err.span_note(fix_span(span, query),\n                               &format!(\"...which then requires {}...\", query.describe(self)));\n             }\n \n@@ -266,6 +272,22 @@ macro_rules! define_maps {\n                     r\n                 }\n             }\n+\n+            // FIXME(eddyb) Get more valid Span's on queries.\n+            pub fn default_span(&self, tcx: TyCtxt<'_, $tcx, '_>, span: Span) -> Span {\n+                if span != DUMMY_SP {\n+                    return span;\n+                }\n+                // The def_span query is used to calculate default_span,\n+                // so exit to avoid infinite recursion\n+                match *self {\n+                    Query::def_span(..) => return span,\n+                    _ => ()\n+                }\n+                match *self {\n+                    $(Query::$name(key) => key.default_span(tcx),)*\n+                }\n+            }\n         }\n \n         pub mod queries {\n@@ -303,7 +325,7 @@ macro_rules! define_maps {\n             /// If the query already executed and panicked, this will fatal error / silently panic\n             fn try_get_lock(\n                 tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                mut span: Span,\n+                span: Span,\n                 key: &$K\n             ) -> TryGetLock<'a, $tcx, $V, Self>\n             {\n@@ -329,21 +351,14 @@ macro_rules! define_maps {\n                     };\n                     mem::drop(lock);\n \n-                    // This just matches the behavior of `try_get_with` so the span when\n-                    // we await matches the span we would use when executing.\n-                    // See the FIXME there.\n-                    if span == DUMMY_SP && stringify!($name) != \"def_span\" {\n-                        span = key.default_span(tcx);\n-                    }\n-\n                     if let Err(cycle) = job.await(tcx, span) {\n                         return TryGetLock::JobCompleted(Err(cycle));\n                     }\n                 }\n             }\n \n             fn try_get_with(tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                            mut span: Span,\n+                            span: Span,\n                             key: $K)\n                             -> Result<$V, CycleError<$tcx>>\n             {\n@@ -377,18 +392,6 @@ macro_rules! define_maps {\n \n                 let mut lock = get_lock_or_return!();\n \n-                // FIXME(eddyb) Get more valid Span's on queries.\n-                // def_span guard is necessary to prevent a recursive loop,\n-                // default_span calls def_span query internally.\n-                if span == DUMMY_SP && stringify!($name) != \"def_span\" {\n-                    // This might deadlock if we hold the map lock since we might be\n-                    // waiting for the def_span query and switch to some other fiber\n-                    // So we drop the lock here and reacquire it\n-                    mem::drop(lock);\n-                    span = key.default_span(tcx);\n-                    lock = get_lock_or_return!();\n-                }\n-\n                 // Fast path for when incr. comp. is off. `to_dep_node` is\n                 // expensive for some DepKinds.\n                 if !tcx.dep_graph.is_fully_enabled() {"}]}