{"sha": "abfd44d8a3b13d56dc0c7904c35a8155a62f19fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiZmQ0NGQ4YTNiMTNkNTZkYzBjNzkwNGMzNWE4MTU1YTYyZjE5ZmI=", "commit": {"author": {"name": "Ellen", "email": "supbscripter@gmail.com", "date": "2021-07-17T10:59:42Z"}, "committer": {"name": "Ellen", "email": "supbscripter@gmail.com", "date": "2021-07-17T10:59:56Z"}, "message": "Comments", "tree": {"sha": "d5960201c118a20ea17cbf638ef2afa0b1e671d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5960201c118a20ea17cbf638ef2afa0b1e671d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abfd44d8a3b13d56dc0c7904c35a8155a62f19fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abfd44d8a3b13d56dc0c7904c35a8155a62f19fb", "html_url": "https://github.com/rust-lang/rust/commit/abfd44d8a3b13d56dc0c7904c35a8155a62f19fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abfd44d8a3b13d56dc0c7904c35a8155a62f19fb/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c40360ed413c0024787cf14fc83af0d98037c7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c40360ed413c0024787cf14fc83af0d98037c7a", "html_url": "https://github.com/rust-lang/rust/commit/8c40360ed413c0024787cf14fc83af0d98037c7a"}], "stats": {"total": 57, "additions": 52, "deletions": 5}, "files": [{"sha": "a2ac3e2555f50a2c04c4bff1292db00de5f4ce6a", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/abfd44d8a3b13d56dc0c7904c35a8155a62f19fb/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abfd44d8a3b13d56dc0c7904c35a8155a62f19fb/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=abfd44d8a3b13d56dc0c7904c35a8155a62f19fb", "patch": "@@ -1441,16 +1441,43 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n                 // of a const parameter type, e.g. `struct Foo<const N: usize, const M: [u8; N]>` is not allowed.\n                 None\n             } else if tcx.lazy_normalization() {\n-                // Only provide backwards declared generics to cg defaults (#86580)\n                 if let Some(param_id) = tcx.hir().opt_const_param_default_param_hir_id(hir_id) {\n+                    // If the def_id we are calling generics_of on is an anon ct default i.e:\n+                    //\n+                    // struct Foo<const N: usize = { .. }>;\n+                    //        ^^^       ^          ^^^^^^ def id of this anon const\n+                    //        ^         ^ param_id\n+                    //        ^ parent_def_id\n+                    //\n+                    // then we only want to return generics for params to the left of `N`. If we don't do that we\n+                    // end up with that const looking like: `ty::ConstKind::Unevaluated(def_id, substs: [N#0])`.\n+                    //\n+                    // This causes ICEs (#86580) when building the substs for Foo in `fn foo() -> Foo { .. }` as\n+                    // we substitute the defaults with the partially built substs when we build the substs. Subst'ing\n+                    // the `N#0` on the unevaluated const indexes into the empty substs we're in the process of building.\n+                    //\n+                    // We fix this by having this function return the parent's generics ourselves and truncating the\n+                    // generics to only include non-forward declared params (with the exception of the `Self` ty)\n+                    //\n+                    // For the above code example that means we want `substs: []`\n+                    // For the following struct def we want `substs: [N#0]` when generics_of is called on\n+                    // the def id of the `{ N + 1 }` anon const\n+                    // struct Foo<const N: usize, const M: usize = { N + 1 }>;\n+                    //\n+                    // This has some implications for how we get the predicates available to the anon const\n+                    // see `explicit_predicates_of` for more information on this\n                     let generics = tcx.generics_of(parent_def_id.to_def_id());\n                     let param_def = tcx.hir().local_def_id(param_id).to_def_id();\n                     let param_def_idx = generics.param_def_id_to_index[&param_def];\n+                    // In the above example this would be .params[..N#0]\n                     let params = generics.params[..param_def_idx as usize].to_owned();\n                     let param_def_id_to_index =\n                         params.iter().map(|param| (param.def_id, param.index)).collect();\n \n                     return ty::Generics {\n+                        // we set the parent of these generics to be our parent's parent so that we\n+                        // dont end up with substs: [N, M, N] for the const default on a struct like this:\n+                        // struct Foo<const N: usize, const M: usize = { ... }>;\n                         parent: generics.parent,\n                         parent_count: generics.parent_count,\n                         params,\n@@ -2425,12 +2452,22 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n         }\n     } else {\n         if matches!(def_kind, DefKind::AnonConst) && tcx.lazy_normalization() {\n-            // Provide predicates of parent item of cg defaults manually as `generics_of`\n-            // doesn't set the parent item as the parent for the generics (#86580)\n             let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n             if let Some(_) = tcx.hir().opt_const_param_default_param_hir_id(hir_id) {\n+                // In `generics_of` we set the generics' parent to be our parent's parent which means that\n+                // we lose out on the predicates of our actual parent if we dont return those predicates here.\n+                // (See comment in `generics_of` for more information on why the parent shenanigans is necessary)\n+                //\n+                // struct Foo<T, const N: usize = { <T as Trait>::ASSOC }>(T) where T: Trait;\n+                //        ^^^                     ^^^^^^^^^^^^^^^^^^^^^^^ the def id we are calling\n+                //        ^^^                                             explicit_predicates_of on\n+                //        parent item we dont have set as the\n+                //        parent of generics returned by `generics_of`\n+                //\n+                // In the above code we want the anon const to have predicates in its param env for `T: Trait`\n                 let item_id = tcx.hir().get_parent_item(hir_id);\n                 let item_def_id = tcx.hir().local_def_id(item_id).to_def_id();\n+                // In the above code example we would be calling `explicit_predicates_of(Foo)` here\n                 return tcx.explicit_predicates_of(item_def_id);\n             }\n         }"}, {"sha": "70a2ba7fcd9d9cc5e2c54238246e21b2d2ec86f0", "filename": "compiler/rustc_typeck/src/outlives/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/abfd44d8a3b13d56dc0c7904c35a8155a62f19fb/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abfd44d8a3b13d56dc0c7904c35a8155a62f19fb/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs?ref=abfd44d8a3b13d56dc0c7904c35a8155a62f19fb", "patch": "@@ -22,11 +22,21 @@ fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate\n \n     if matches!(tcx.def_kind(item_def_id), hir::def::DefKind::AnonConst) && tcx.lazy_normalization()\n     {\n-        // Provide predicates of parent item of cg defaults manually as `generics_of`\n-        // doesn't set the parent item as the parent for the generics (#86580)\n         if let Some(_) = tcx.hir().opt_const_param_default_param_hir_id(id) {\n+            // In `generics_of` we set the generics' parent to be our parent's parent which means that\n+            // we lose out on the predicates of our actual parent if we dont return those predicates here.\n+            // (See comment in `generics_of` for more information on why the parent shenanigans is necessary)\n+            //\n+            // struct Foo<'a, 'b, const N: usize = { ... }>(&'a &'b ());\n+            //        ^^^                          ^^^^^^^ the def id we are calling\n+            //        ^^^                                  inferred_outlives_of on\n+            //        parent item we dont have set as the\n+            //        parent of generics returned by `generics_of`\n+            //\n+            // In the above code we want the anon const to have predicates in its param env for `'b: 'a`\n             let item_id = tcx.hir().get_parent_item(id);\n             let item_def_id = tcx.hir().local_def_id(item_id).to_def_id();\n+            // In the above code example we would be calling `inferred_outlives_of(Foo)` here\n             return tcx.inferred_outlives_of(item_def_id);\n         }\n     }"}]}