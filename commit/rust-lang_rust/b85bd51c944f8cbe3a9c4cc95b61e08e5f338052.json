{"sha": "b85bd51c944f8cbe3a9c4cc95b61e08e5f338052", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4NWJkNTFjOTQ0ZjhjYmUzYTljNGNjOTViNjFlMDhlNWYzMzgwNTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-17T08:44:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-17T08:44:41Z"}, "message": "Auto merge of #47926 - mikhail-m1:subslice_pattern_array_drop2, r=nikomatsakis\n\nadd transform for uniform array move out\n\nreworked second step for fix #34708\nprevious try #46686\nr? @nikomatsakis", "tree": {"sha": "215edf84c149a563139f3667bfe781c084f582c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/215edf84c149a563139f3667bfe781c084f582c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b85bd51c944f8cbe3a9c4cc95b61e08e5f338052", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b85bd51c944f8cbe3a9c4cc95b61e08e5f338052", "html_url": "https://github.com/rust-lang/rust/commit/b85bd51c944f8cbe3a9c4cc95b61e08e5f338052", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b85bd51c944f8cbe3a9c4cc95b61e08e5f338052/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "507a46a4aa67555cd9b60ea2852f6b8cc681217b", "url": "https://api.github.com/repos/rust-lang/rust/commits/507a46a4aa67555cd9b60ea2852f6b8cc681217b", "html_url": "https://github.com/rust-lang/rust/commit/507a46a4aa67555cd9b60ea2852f6b8cc681217b"}, {"sha": "31253d5557f8c161ac97028a3966d617491b86a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/31253d5557f8c161ac97028a3966d617491b86a6", "html_url": "https://github.com/rust-lang/rust/commit/31253d5557f8c161ac97028a3966d617491b86a6"}], "stats": {"total": 303, "additions": 302, "deletions": 1}, "files": [{"sha": "7ed250e94c52f595a01df323c29251dfc1c35d7b", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b85bd51c944f8cbe3a9c4cc95b61e08e5f338052/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85bd51c944f8cbe3a9c4cc95b61e08e5f338052/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=b85bd51c944f8cbe3a9c4cc95b61e08e5f338052", "patch": "@@ -44,6 +44,7 @@ pub mod copy_prop;\n pub mod generator;\n pub mod inline;\n pub mod lower_128bit;\n+pub mod uniform_array_move_out;\n \n pub(crate) fn provide(providers: &mut Providers) {\n     self::qualify_consts::provide(providers);\n@@ -197,6 +198,7 @@ fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Stea\n         simplify::SimplifyCfg::new(\"initial\"),\n         type_check::TypeckMir,\n         rustc_peek::SanityCheck,\n+        uniform_array_move_out::UniformArrayMoveOut,\n     ];\n     tcx.alloc_steal_mir(mir)\n }\n@@ -253,6 +255,7 @@ fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n \n         lower_128bit::Lower128Bit,\n \n+\n         // Optimizations begin.\n         inline::Inline,\n         instcombine::InstCombine,"}, {"sha": "0db5ecf0eb2702f29a890313c3932e5e06514ed8", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/b85bd51c944f8cbe3a9c4cc95b61e08e5f338052/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85bd51c944f8cbe3a9c4cc95b61e08e5f338052/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=b85bd51c944f8cbe3a9c4cc95b61e08e5f338052", "patch": "@@ -0,0 +1,153 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This pass converts move out from array by Subslice and\n+// ConstIndex{.., from_end: true} to ConstIndex move out(s) from begin\n+// of array. It allows detect error by mir borrowck and elaborate\n+// drops for array without additional work.\n+//\n+// Example:\n+//\n+// let a = [ box 1,box 2, box 3];\n+// if b {\n+//  let [_a.., _] = a;\n+// } else {\n+//  let [.., _b] = a;\n+// }\n+//\n+//  mir statement _10 = move _2[:-1]; replaced by:\n+//  StorageLive(_12);\n+//  _12 = move _2[0 of 3];\n+//  StorageLive(_13);\n+//  _13 = move _2[1 of 3];\n+//  _10 = [move _12, move _13]\n+//  StorageDead(_12);\n+//  StorageDead(_13);\n+//\n+//  and mir statement _11 = move _2[-1 of 1]; replaced by:\n+//  _11 = move _2[2 of 3];\n+//\n+// FIXME: convert to Subslice back for performance reason\n+// FIXME: integrate this transformation to the mir build\n+\n+use rustc::ty;\n+use rustc::ty::TyCtxt;\n+use rustc::mir::*;\n+use rustc::mir::visit::Visitor;\n+use transform::{MirPass, MirSource};\n+use util::patch::MirPatch;\n+\n+pub struct UniformArrayMoveOut;\n+\n+impl MirPass for UniformArrayMoveOut {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _src: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n+        let mut patch = MirPatch::new(mir);\n+        {\n+            let mut visitor = UniformArrayMoveOutVisitor{mir, patch: &mut patch, tcx};\n+            visitor.visit_mir(mir);\n+        }\n+        patch.apply(mir);\n+    }\n+}\n+\n+struct UniformArrayMoveOutVisitor<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    patch: &'a mut MirPatch<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n+    fn visit_statement(&mut self,\n+                       block: BasicBlock,\n+                       statement: &Statement<'tcx>,\n+                       location: Location) {\n+        if let StatementKind::Assign(ref dst_place,\n+                                     Rvalue::Use(Operand::Move(ref src_place))) = statement.kind {\n+            if let Place::Projection(ref proj) = *src_place {\n+                if let ProjectionElem::ConstantIndex{offset: _,\n+                                                     min_length: _,\n+                                                     from_end: false} = proj.elem {\n+                    // no need to transformation\n+                } else {\n+                    let place_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                    if let ty::TyArray(item_ty, const_size) = place_ty.sty {\n+                        if let Some(size) = const_size.val.to_const_int().and_then(|v| v.to_u64()) {\n+                            assert!(size <= (u32::max_value() as u64),\n+                                    \"unform array move out doesn't supported\n+                                     for array bigger then u32\");\n+                            self.uniform(location, dst_place, proj, item_ty, size as u32);\n+                        }\n+                    }\n+\n+                }\n+            }\n+        }\n+        return self.super_statement(block, statement, location);\n+    }\n+}\n+\n+impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n+    fn uniform(&mut self,\n+               location: Location,\n+               dst_place: &Place<'tcx>,\n+               proj: &PlaceProjection<'tcx>,\n+               item_ty: &'tcx ty::TyS<'tcx>,\n+               size: u32) {\n+        match proj.elem {\n+            // uniform _10 = move _2[:-1];\n+            ProjectionElem::Subslice{from, to} => {\n+                self.patch.make_nop(location);\n+                let temps : Vec<_> = (from..(size-to)).map(|i| {\n+                    let temp = self.patch.new_temp(item_ty, self.mir.source_info(location).span);\n+                    self.patch.add_statement(location, StatementKind::StorageLive(temp));\n+                    self.patch.add_assign(location,\n+                                          Place::Local(temp),\n+                                          Rvalue::Use(\n+                                              Operand::Move(\n+                                                  Place::Projection(box PlaceProjection{\n+                                                      base: proj.base.clone(),\n+                                                      elem: ProjectionElem::ConstantIndex{\n+                                                          offset: i,\n+                                                          min_length: size,\n+                                                          from_end: false}\n+                                                  }))));\n+                    temp\n+                }).collect();\n+                self.patch.add_assign(location,\n+                                      dst_place.clone(),\n+                                      Rvalue::Aggregate(box AggregateKind::Array(item_ty),\n+                                      temps.iter().map(\n+                                          |x| Operand::Move(Place::Local(*x))).collect()\n+                                      ));\n+                for temp in temps {\n+                    self.patch.add_statement(location, StatementKind::StorageDead(temp));\n+                }\n+            }\n+            // _11 = move _2[-1 of 1];\n+            ProjectionElem::ConstantIndex{offset, min_length: _, from_end: true} => {\n+                self.patch.make_nop(location);\n+                self.patch.add_assign(location,\n+                                      dst_place.clone(),\n+                                      Rvalue::Use(\n+                                          Operand::Move(\n+                                              Place::Projection(box PlaceProjection{\n+                                                  base: proj.base.clone(),\n+                                                  elem: ProjectionElem::ConstantIndex{\n+                                                      offset: size - offset,\n+                                                      min_length: size,\n+                                                      from_end: false }}))));\n+            }\n+            _ => {}\n+        }\n+    }\n+}"}, {"sha": "f1bdcfcd22f935ade79d9c33c6595647ed88fec3", "filename": "src/librustc_mir/util/patch.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b85bd51c944f8cbe3a9c4cc95b61e08e5f338052/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85bd51c944f8cbe3a9c4cc95b61e08e5f338052/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpatch.rs?ref=b85bd51c944f8cbe3a9c4cc95b61e08e5f338052", "patch": "@@ -23,6 +23,7 @@ pub struct MirPatch<'tcx> {\n     new_locals: Vec<LocalDecl<'tcx>>,\n     resume_block: BasicBlock,\n     next_local: usize,\n+    make_nop: Vec<Location>,\n }\n \n impl<'tcx> MirPatch<'tcx> {\n@@ -33,7 +34,8 @@ impl<'tcx> MirPatch<'tcx> {\n             new_statements: vec![],\n             new_locals: vec![],\n             next_local: mir.local_decls.len(),\n-            resume_block: START_BLOCK\n+            resume_block: START_BLOCK,\n+            make_nop: vec![]\n         };\n \n         // make sure the MIR we create has a resume block. It is\n@@ -131,7 +133,15 @@ impl<'tcx> MirPatch<'tcx> {\n         self.add_statement(loc, StatementKind::Assign(place, rv));\n     }\n \n+    pub fn make_nop(&mut self, loc: Location) {\n+        self.make_nop.push(loc);\n+    }\n+\n     pub fn apply(self, mir: &mut Mir<'tcx>) {\n+        debug!(\"MirPatch: make nops at: {:?}\", self.make_nop);\n+        for loc in self.make_nop {\n+            mir.make_statement_nop(loc);\n+        }\n         debug!(\"MirPatch: {:?} new temps, starting from index {}: {:?}\",\n                self.new_locals.len(), mir.local_decls.len(), self.new_locals);\n         debug!(\"MirPatch: {} new blocks, starting from index {}\","}, {"sha": "e01161734623217ecd2dc7c2bf104c358877575a", "filename": "src/test/compile-fail/borrowck/borrowck-move-out-from-array.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b85bd51c944f8cbe3a9c4cc95b61e08e5f338052/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-from-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85bd51c944f8cbe3a9c4cc95b61e08e5f338052/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-from-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-from-array.rs?ref=b85bd51c944f8cbe3a9c4cc95b61e08e5f338052", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n+#![feature(box_syntax, slice_patterns, advanced_slice_patterns)]\n+\n+fn move_out_from_begin_and_end() {\n+    let a = [box 1, box 2];\n+    let [_, _x] = a;\n+    let [.., _y] = a; //[ast]~ ERROR [E0382]\n+                      //[mir]~^ ERROR [E0382]\n+}\n+\n+fn move_out_by_const_index_and_subslice() {\n+    let a = [box 1, box 2];\n+    let [_x, _] = a;\n+    let [_y..] = a; //[ast]~ ERROR [E0382]\n+                    //[mir]~^ ERROR [E0382]\n+}\n+\n+fn main() {}"}, {"sha": "4a310255aac576a3d3d7ede99bff59ef38f2fb87", "filename": "src/test/mir-opt/uniform_array_move_out.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b85bd51c944f8cbe3a9c4cc95b61e08e5f338052/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85bd51c944f8cbe3a9c4cc95b61e08e5f338052/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs?ref=b85bd51c944f8cbe3a9c4cc95b61e08e5f338052", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax, slice_patterns, advanced_slice_patterns)]\n+\n+fn move_out_from_end() {\n+    let a = [box 1, box 2];\n+    let [.., _y] = a;\n+}\n+\n+fn move_out_by_subslice() {\n+    let a = [box 1, box 2];\n+    let [_y..] = a;\n+}\n+\n+fn main() {\n+    move_out_by_subslice();\n+    move_out_from_end();\n+}\n+\n+// END RUST SOURCE\n+\n+// START rustc.move_out_from_end.UniformArrayMoveOut.before.mir\n+//     StorageLive(_6);\n+//      _6 = move _1[-1 of 1];\n+//      _0 = ();\n+// END rustc.move_out_from_end.UniformArrayMoveOut.before.mir\n+\n+// START rustc.move_out_from_end.UniformArrayMoveOut.after.mir\n+//     StorageLive(_6);\n+//      _6 = move _1[1 of 2];\n+//      nop;\n+//      _0 = ();\n+// END rustc.move_out_from_end.UniformArrayMoveOut.after.mir\n+\n+// START rustc.move_out_by_subslice.UniformArrayMoveOut.before.mir\n+//     StorageLive(_6);\n+//      _6 = move _1[0:];\n+// END rustc.move_out_by_subslice.UniformArrayMoveOut.before.mir\n+\n+// START rustc.move_out_by_subslice.UniformArrayMoveOut.after.mir\n+//     StorageLive(_6);\n+//     StorageLive(_7);\n+//     _7 = move _1[0 of 2];\n+//     StorageLive(_8);\n+//     _8 = move _1[1 of 2];\n+//     _6 = [move _7, move _8];\n+//     StorageDead(_7);\n+//     StorageDead(_8);\n+//     nop;\n+//     _0 = ();\n+// END rustc.move_out_by_subslice.UniformArrayMoveOut.after.mir"}, {"sha": "4d0bd3f3412f1f7fd0933363af3779e4b0cd4807", "filename": "src/test/run-pass/dynamic-drop.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b85bd51c944f8cbe3a9c4cc95b61e08e5f338052/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85bd51c944f8cbe3a9c4cc95b61e08e5f338052/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs?ref=b85bd51c944f8cbe3a9c4cc95b61e08e5f338052", "patch": "@@ -225,6 +225,43 @@ fn slice_pattern_one_of(a: &Allocator, i: usize) {\n     };\n }\n \n+fn subslice_pattern_from_end(a: &Allocator, arg: bool) {\n+    let a = [a.alloc(), a.alloc(), a.alloc()];\n+    if arg {\n+        let[.., _x, _] = a;\n+    } else {\n+        let[_, _y..] = a;\n+    }\n+}\n+\n+fn subslice_pattern_from_end_with_drop(a: &Allocator, arg: bool, arg2: bool) {\n+    let a = [a.alloc(), a.alloc(), a.alloc(), a.alloc(), a.alloc()];\n+    if arg2 {\n+        drop(a);\n+        return;\n+    }\n+\n+    if arg {\n+        let[.., _x, _] = a;\n+    } else {\n+        let[_, _y..] = a;\n+    }\n+}\n+\n+fn slice_pattern_reassign(a: &Allocator) {\n+    let mut ar = [a.alloc(), a.alloc()];\n+    let[_, _x] = ar;\n+    ar = [a.alloc(), a.alloc()];\n+    let[.., _y] = ar;\n+}\n+\n+fn subslice_pattern_reassign(a: &Allocator) {\n+    let mut ar = [a.alloc(), a.alloc(), a.alloc()];\n+    let[_, _, _x] = ar;\n+    ar = [a.alloc(), a.alloc(), a.alloc()];\n+    let[_, _y..] = ar;\n+}\n+\n fn run_test<F>(mut f: F)\n     where F: FnMut(&Allocator)\n {\n@@ -303,5 +340,14 @@ fn main() {\n     run_test(|a| slice_pattern_one_of(a, 2));\n     run_test(|a| slice_pattern_one_of(a, 3));\n \n+    run_test(|a| subslice_pattern_from_end(a, true));\n+    run_test(|a| subslice_pattern_from_end(a, false));\n+    run_test(|a| subslice_pattern_from_end_with_drop(a, true, true));\n+    run_test(|a| subslice_pattern_from_end_with_drop(a, true, false));\n+    run_test(|a| subslice_pattern_from_end_with_drop(a, false, true));\n+    run_test(|a| subslice_pattern_from_end_with_drop(a, false, false));\n+    run_test(|a| slice_pattern_reassign(a));\n+    run_test(|a| subslice_pattern_reassign(a));\n+\n     run_test_nopanic(|a| union1(a));\n }"}]}