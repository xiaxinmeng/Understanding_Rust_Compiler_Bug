{"sha": "30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZmJhMjJhOWJlZjdjOWIxNWRkOWUxNTY1NzEzNWMxYjdkNmQxYTk=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-23T20:10:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-23T20:10:11Z"}, "message": "Rollup merge of #73601 - Aaron1011:fix/better-mono-overflow-err, r=ecstatic-morse\n\nPoint at the call span when overflow occurs during monomorphization\n\nThis improves the output for issue #72577, but there's still more work\nto be done.\n\nCurrently, an overflow error during monomorphization results in an error\nthat points at the function we were unable to monomorphize. However, we\ndon't point at the call that caused the monomorphization to happen. In\nthe overflow occurs in a large recursive function, it may be difficult\nto determine where the issue is.\n\nThis commit tracks and `Span` information during collection of\n`MonoItem`s, which is used when emitting an overflow error. `MonoItem`\nitself is unchanged, so this only affects\n`src/librustc_mir/monomorphize/collector.rs`", "tree": {"sha": "b6355dfb8453f385464c1c54965c923b7f63825f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6355dfb8453f385464c1c54965c923b7f63825f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe8mGjCRBK7hj4Ov3rIwAAdHIIAA3yzp4lX4izbOa9FyE/WQil\nOMVHRwLzeSacF07F4C18PqjN0S0rSlmHK1Gu4vdNYiFCYAydR/gFNPfXDh7nDRx+\ne2Gp4LRuj59DsiqcldrG6Tn2FsVeKhsJdjtzGcAlCY7ecA6hUhU4gVSOZStySC39\nfjbDB2IUQ3bjgXxIRKWhm7441dBPRLHJ6vUNil1FB/g5sBXjMwnKxZRljfOFbjNV\n8qYANLlSF/RjZEMAHbpWhekmuTR/Hy3amMq7U7Oc0bcA7HIQnYoCO83XedDD8ktx\nNII+iFtvxovzOJbYVRBACXXovQgD6QyXmNtNyyi/uyjHNZ0w3qbLcdwQHi9yehc=\n=ywLf\n-----END PGP SIGNATURE-----\n", "payload": "tree b6355dfb8453f385464c1c54965c923b7f63825f\nparent 045761c8d0cf39e637c3a5cc69fcb25fe2043d71\nparent 3ed96a6d638f8dc8aa081ca1ad82e61caa8930ca\nauthor Manish Goregaokar <manishsmail@gmail.com> 1592943011 -0700\ncommitter GitHub <noreply@github.com> 1592943011 -0700\n\nRollup merge of #73601 - Aaron1011:fix/better-mono-overflow-err, r=ecstatic-morse\n\nPoint at the call span when overflow occurs during monomorphization\n\nThis improves the output for issue #72577, but there's still more work\nto be done.\n\nCurrently, an overflow error during monomorphization results in an error\nthat points at the function we were unable to monomorphize. However, we\ndon't point at the call that caused the monomorphization to happen. In\nthe overflow occurs in a large recursive function, it may be difficult\nto determine where the issue is.\n\nThis commit tracks and `Span` information during collection of\n`MonoItem`s, which is used when emitting an overflow error. `MonoItem`\nitself is unchanged, so this only affects\n`src/librustc_mir/monomorphize/collector.rs`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9", "html_url": "https://github.com/rust-lang/rust/commit/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "url": "https://api.github.com/repos/rust-lang/rust/commits/045761c8d0cf39e637c3a5cc69fcb25fe2043d71", "html_url": "https://github.com/rust-lang/rust/commit/045761c8d0cf39e637c3a5cc69fcb25fe2043d71"}, {"sha": "3ed96a6d638f8dc8aa081ca1ad82e61caa8930ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ed96a6d638f8dc8aa081ca1ad82e61caa8930ca", "html_url": "https://github.com/rust-lang/rust/commit/3ed96a6d638f8dc8aa081ca1ad82e61caa8930ca"}], "stats": {"total": 212, "additions": 132, "deletions": 80}, "files": [{"sha": "f9b3c319c1f66654463ee89ff3c6386007f9325c", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 80, "deletions": 57, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9", "patch": "@@ -178,7 +178,7 @@ use crate::monomorphize;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{par_iter, MTLock, MTRef, ParallelIterator};\n-use rustc_errors::ErrorReported;\n+use rustc_errors::{ErrorReported, FatalError};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n@@ -195,6 +195,7 @@ use rustc_middle::ty::print::obsolete::DefPathBasedNames;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::{self, GenericParamDefKind, Instance, Ty, TyCtxt, TypeFoldable};\n use rustc_session::config::EntryFnType;\n+use rustc_span::source_map::{dummy_spanned, respan, Span, Spanned, DUMMY_SP};\n use smallvec::SmallVec;\n use std::iter;\n \n@@ -294,7 +295,13 @@ pub fn collect_crate_mono_items(\n         tcx.sess.time(\"monomorphization_collector_graph_walk\", || {\n             par_iter(roots).for_each(|root| {\n                 let mut recursion_depths = DefIdMap::default();\n-                collect_items_rec(tcx, root, visited, &mut recursion_depths, inlining_map);\n+                collect_items_rec(\n+                    tcx,\n+                    dummy_spanned(root),\n+                    visited,\n+                    &mut recursion_depths,\n+                    inlining_map,\n+                );\n             });\n         });\n     }\n@@ -323,37 +330,38 @@ fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<\n     // We can only codegen items that are instantiable - items all of\n     // whose predicates hold. Luckily, items that aren't instantiable\n     // can't actually be used, so we can just skip codegenning them.\n-    roots.retain(|root| root.is_instantiable(tcx));\n-\n     roots\n+        .into_iter()\n+        .filter_map(|root| root.node.is_instantiable(tcx).then_some(root.node))\n+        .collect()\n }\n \n // Collect all monomorphized items reachable from `starting_point`\n fn collect_items_rec<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    starting_point: MonoItem<'tcx>,\n+    starting_point: Spanned<MonoItem<'tcx>>,\n     visited: MTRef<'_, MTLock<FxHashSet<MonoItem<'tcx>>>>,\n     recursion_depths: &mut DefIdMap<usize>,\n     inlining_map: MTRef<'_, MTLock<InliningMap<'tcx>>>,\n ) {\n-    if !visited.lock_mut().insert(starting_point) {\n+    if !visited.lock_mut().insert(starting_point.node) {\n         // We've been here already, no need to search again.\n         return;\n     }\n-    debug!(\"BEGIN collect_items_rec({})\", starting_point.to_string(tcx, true));\n+    debug!(\"BEGIN collect_items_rec({})\", starting_point.node.to_string(tcx, true));\n \n     let mut neighbors = Vec::new();\n     let recursion_depth_reset;\n \n-    match starting_point {\n+    match starting_point.node {\n         MonoItem::Static(def_id) => {\n             let instance = Instance::mono(tcx, def_id);\n \n             // Sanity check whether this ended up being collected accidentally\n             debug_assert!(should_monomorphize_locally(tcx, &instance));\n \n             let ty = instance.monomorphic_ty(tcx);\n-            visit_drop_use(tcx, ty, true, &mut neighbors);\n+            visit_drop_use(tcx, ty, true, starting_point.span, &mut neighbors);\n \n             recursion_depth_reset = None;\n \n@@ -366,7 +374,8 @@ fn collect_items_rec<'tcx>(\n             debug_assert!(should_monomorphize_locally(tcx, &instance));\n \n             // Keep track of the monomorphization recursion depth\n-            recursion_depth_reset = Some(check_recursion_limit(tcx, instance, recursion_depths));\n+            recursion_depth_reset =\n+                Some(check_recursion_limit(tcx, instance, starting_point.span, recursion_depths));\n             check_type_length_limit(tcx, instance);\n \n             rustc_data_structures::stack::ensure_sufficient_stack(|| {\n@@ -378,7 +387,7 @@ fn collect_items_rec<'tcx>(\n         }\n     }\n \n-    record_accesses(tcx, starting_point, &neighbors[..], inlining_map);\n+    record_accesses(tcx, starting_point.node, neighbors.iter().map(|i| &i.node), inlining_map);\n \n     for neighbour in neighbors {\n         collect_items_rec(tcx, neighbour, visited, recursion_depths, inlining_map);\n@@ -388,13 +397,13 @@ fn collect_items_rec<'tcx>(\n         recursion_depths.insert(def_id, depth);\n     }\n \n-    debug!(\"END collect_items_rec({})\", starting_point.to_string(tcx, true));\n+    debug!(\"END collect_items_rec({})\", starting_point.node.to_string(tcx, true));\n }\n \n-fn record_accesses<'tcx>(\n+fn record_accesses<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'tcx>,\n     caller: MonoItem<'tcx>,\n-    callees: &[MonoItem<'tcx>],\n+    callees: impl Iterator<Item = &'a MonoItem<'tcx>>,\n     inlining_map: MTRef<'_, MTLock<InliningMap<'tcx>>>,\n ) {\n     let is_inlining_candidate = |mono_item: &MonoItem<'tcx>| {\n@@ -405,14 +414,15 @@ fn record_accesses<'tcx>(\n     // FIXME: Call `is_inlining_candidate` when pushing to `neighbors` in `collect_items_rec`\n     // instead to avoid creating this `SmallVec`.\n     let accesses: SmallVec<[_; 128]> =\n-        callees.iter().map(|mono_item| (*mono_item, is_inlining_candidate(mono_item))).collect();\n+        callees.map(|mono_item| (*mono_item, is_inlining_candidate(mono_item))).collect();\n \n     inlining_map.lock_mut().record_accesses(caller, &accesses);\n }\n \n fn check_recursion_limit<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: Instance<'tcx>,\n+    span: Span,\n     recursion_depths: &mut DefIdMap<usize>,\n ) -> (DefId, usize) {\n     let def_id = instance.def_id();\n@@ -432,12 +442,13 @@ fn check_recursion_limit<'tcx>(\n     // infinite expansion.\n     if !tcx.sess.recursion_limit().value_within_limit(adjusted_recursion_depth) {\n         let error = format!(\"reached the recursion limit while instantiating `{}`\", instance);\n-        if let Some(def_id) = def_id.as_local() {\n-            let hir_id = tcx.hir().as_local_hir_id(def_id);\n-            tcx.sess.span_fatal(tcx.hir().span(hir_id), &error);\n-        } else {\n-            tcx.sess.fatal(&error);\n-        }\n+        let mut err = tcx.sess.struct_span_fatal(span, &error);\n+        err.span_note(\n+            tcx.def_span(def_id),\n+            &format!(\"`{}` defined here\", tcx.def_path_str(def_id)),\n+        );\n+        err.emit();\n+        FatalError.raise();\n     }\n \n     recursion_depths.insert(def_id, recursion_depth + 1);\n@@ -498,7 +509,7 @@ fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) {\n struct MirNeighborCollector<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n-    output: &'a mut Vec<MonoItem<'tcx>>,\n+    output: &'a mut Vec<Spanned<MonoItem<'tcx>>>,\n     instance: Instance<'tcx>,\n }\n \n@@ -520,6 +531,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &mir::Rvalue<'tcx>, location: Location) {\n         debug!(\"visiting rvalue {:?}\", *rvalue);\n \n+        let span = self.body.source_info(location).span;\n+\n         match *rvalue {\n             // When doing an cast from a regular pointer to a fat pointer, we\n             // have to instantiate all methods of the trait being cast to, so we\n@@ -542,6 +555,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                         self.tcx,\n                         target_ty,\n                         source_ty,\n+                        span,\n                         self.output,\n                     );\n                 }\n@@ -553,7 +567,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             ) => {\n                 let fn_ty = operand.ty(self.body, self.tcx);\n                 let fn_ty = self.monomorphize(fn_ty);\n-                visit_fn_use(self.tcx, fn_ty, false, &mut self.output);\n+                visit_fn_use(self.tcx, fn_ty, false, span, &mut self.output);\n             }\n             mir::Rvalue::Cast(\n                 mir::CastKind::Pointer(PointerCast::ClosureFnPointer(_)),\n@@ -571,7 +585,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                             ty::ClosureKind::FnOnce,\n                         );\n                         if should_monomorphize_locally(self.tcx, &instance) {\n-                            self.output.push(create_fn_mono_item(instance));\n+                            self.output.push(create_fn_mono_item(instance, span));\n                         }\n                     }\n                     _ => bug!(),\n@@ -583,15 +597,15 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     tcx.require_lang_item(ExchangeMallocFnLangItem, None);\n                 let instance = Instance::mono(tcx, exchange_malloc_fn_def_id);\n                 if should_monomorphize_locally(tcx, &instance) {\n-                    self.output.push(create_fn_mono_item(instance));\n+                    self.output.push(create_fn_mono_item(instance, span));\n                 }\n             }\n             mir::Rvalue::ThreadLocalRef(def_id) => {\n                 assert!(self.tcx.is_thread_local_static(def_id));\n                 let instance = Instance::mono(self.tcx, def_id);\n                 if should_monomorphize_locally(self.tcx, &instance) {\n                     trace!(\"collecting thread-local static {:?}\", def_id);\n-                    self.output.push(MonoItem::Static(def_id));\n+                    self.output.push(respan(span, MonoItem::Static(def_id)));\n                 }\n             }\n             _ => { /* not interesting */ }\n@@ -626,32 +640,33 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n \n     fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, location: Location) {\n         debug!(\"visiting terminator {:?} @ {:?}\", terminator, location);\n+        let source = self.body.source_info(location).span;\n \n         let tcx = self.tcx;\n         match terminator.kind {\n             mir::TerminatorKind::Call { ref func, .. } => {\n                 let callee_ty = func.ty(self.body, tcx);\n                 let callee_ty = self.monomorphize(callee_ty);\n-                visit_fn_use(self.tcx, callee_ty, true, &mut self.output);\n+                visit_fn_use(self.tcx, callee_ty, true, source, &mut self.output);\n             }\n             mir::TerminatorKind::Drop { ref place, .. }\n             | mir::TerminatorKind::DropAndReplace { ref place, .. } => {\n                 let ty = place.ty(self.body, self.tcx).ty;\n                 let ty = self.monomorphize(ty);\n-                visit_drop_use(self.tcx, ty, true, self.output);\n+                visit_drop_use(self.tcx, ty, true, source, self.output);\n             }\n             mir::TerminatorKind::InlineAsm { ref operands, .. } => {\n                 for op in operands {\n                     match *op {\n                         mir::InlineAsmOperand::SymFn { ref value } => {\n                             let fn_ty = self.monomorphize(value.literal.ty);\n-                            visit_fn_use(self.tcx, fn_ty, false, &mut self.output);\n+                            visit_fn_use(self.tcx, fn_ty, false, source, &mut self.output);\n                         }\n                         mir::InlineAsmOperand::SymStatic { def_id } => {\n                             let instance = Instance::mono(self.tcx, def_id);\n                             if should_monomorphize_locally(self.tcx, &instance) {\n                                 trace!(\"collecting asm sym static {:?}\", def_id);\n-                                self.output.push(MonoItem::Static(def_id));\n+                                self.output.push(respan(source, MonoItem::Static(def_id)));\n                             }\n                         }\n                         _ => {}\n@@ -687,17 +702,19 @@ fn visit_drop_use<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n     is_direct_call: bool,\n-    output: &mut Vec<MonoItem<'tcx>>,\n+    source: Span,\n+    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n ) {\n     let instance = Instance::resolve_drop_in_place(tcx, ty);\n-    visit_instance_use(tcx, instance, is_direct_call, output);\n+    visit_instance_use(tcx, instance, is_direct_call, source, output);\n }\n \n fn visit_fn_use<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n     is_direct_call: bool,\n-    output: &mut Vec<MonoItem<'tcx>>,\n+    source: Span,\n+    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n ) {\n     if let ty::FnDef(def_id, substs) = ty.kind {\n         let instance = if is_direct_call {\n@@ -706,15 +723,16 @@ fn visit_fn_use<'tcx>(\n             ty::Instance::resolve_for_fn_ptr(tcx, ty::ParamEnv::reveal_all(), def_id, substs)\n                 .unwrap()\n         };\n-        visit_instance_use(tcx, instance, is_direct_call, output);\n+        visit_instance_use(tcx, instance, is_direct_call, source, output);\n     }\n }\n \n fn visit_instance_use<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: ty::Instance<'tcx>,\n     is_direct_call: bool,\n-    output: &mut Vec<MonoItem<'tcx>>,\n+    source: Span,\n+    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n ) {\n     debug!(\"visit_item_use({:?}, is_direct_call={:?})\", instance, is_direct_call);\n     if !should_monomorphize_locally(tcx, &instance) {\n@@ -730,7 +748,7 @@ fn visit_instance_use<'tcx>(\n         ty::InstanceDef::DropGlue(_, None) => {\n             // Don't need to emit noop drop glue if we are calling directly.\n             if !is_direct_call {\n-                output.push(create_fn_mono_item(instance));\n+                output.push(create_fn_mono_item(instance, source));\n             }\n         }\n         ty::InstanceDef::DropGlue(_, Some(_))\n@@ -740,7 +758,7 @@ fn visit_instance_use<'tcx>(\n         | ty::InstanceDef::Item(..)\n         | ty::InstanceDef::FnPtrShim(..)\n         | ty::InstanceDef::CloneShim(..) => {\n-            output.push(create_fn_mono_item(instance));\n+            output.push(create_fn_mono_item(instance, source));\n         }\n     }\n }\n@@ -832,7 +850,6 @@ fn find_vtable_types_for_unsizing<'tcx>(\n     let ptr_vtable = |inner_source: Ty<'tcx>, inner_target: Ty<'tcx>| {\n         let param_env = ty::ParamEnv::reveal_all();\n         let type_has_metadata = |ty: Ty<'tcx>| -> bool {\n-            use rustc_span::DUMMY_SP;\n             if ty.is_sized(tcx.at(DUMMY_SP), param_env) {\n                 return false;\n             }\n@@ -886,9 +903,9 @@ fn find_vtable_types_for_unsizing<'tcx>(\n     }\n }\n \n-fn create_fn_mono_item(instance: Instance<'_>) -> MonoItem<'_> {\n+fn create_fn_mono_item(instance: Instance<'_>, source: Span) -> Spanned<MonoItem<'_>> {\n     debug!(\"create_fn_mono_item(instance={})\", instance);\n-    MonoItem::Fn(instance)\n+    respan(source, MonoItem::Fn(instance))\n }\n \n /// Creates a `MonoItem` for each method that is referenced by the vtable for\n@@ -897,7 +914,8 @@ fn create_mono_items_for_vtable_methods<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ty: Ty<'tcx>,\n     impl_ty: Ty<'tcx>,\n-    output: &mut Vec<MonoItem<'tcx>>,\n+    source: Span,\n+    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n ) {\n     assert!(\n         !trait_ty.needs_subst()\n@@ -927,12 +945,12 @@ fn create_mono_items_for_vtable_methods<'tcx>(\n                     .unwrap()\n                 })\n                 .filter(|&instance| should_monomorphize_locally(tcx, &instance))\n-                .map(create_fn_mono_item);\n+                .map(|item| create_fn_mono_item(item, source));\n             output.extend(methods);\n         }\n \n         // Also add the destructor.\n-        visit_drop_use(tcx, impl_ty, false, output);\n+        visit_drop_use(tcx, impl_ty, false, source, output);\n     }\n }\n \n@@ -943,7 +961,7 @@ fn create_mono_items_for_vtable_methods<'tcx>(\n struct RootCollector<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     mode: MonoItemCollectionMode,\n-    output: &'a mut Vec<MonoItem<'tcx>>,\n+    output: &'a mut Vec<Spanned<MonoItem<'tcx>>>,\n     entry_fn: Option<(LocalDefId, EntryFnType)>,\n }\n \n@@ -980,7 +998,7 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n \n                         let ty = Instance::new(def_id.to_def_id(), InternalSubsts::empty())\n                             .monomorphic_ty(self.tcx);\n-                        visit_drop_use(self.tcx, ty, true, self.output);\n+                        visit_drop_use(self.tcx, ty, true, DUMMY_SP, self.output);\n                     }\n                 }\n             }\n@@ -989,12 +1007,12 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n                     \"RootCollector: ItemKind::GlobalAsm({})\",\n                     def_id_to_string(self.tcx, self.tcx.hir().local_def_id(item.hir_id))\n                 );\n-                self.output.push(MonoItem::GlobalAsm(item.hir_id));\n+                self.output.push(dummy_spanned(MonoItem::GlobalAsm(item.hir_id)));\n             }\n             hir::ItemKind::Static(..) => {\n                 let def_id = self.tcx.hir().local_def_id(item.hir_id);\n                 debug!(\"RootCollector: ItemKind::Static({})\", def_id_to_string(self.tcx, def_id));\n-                self.output.push(MonoItem::Static(def_id.to_def_id()));\n+                self.output.push(dummy_spanned(MonoItem::Static(def_id.to_def_id())));\n             }\n             hir::ItemKind::Const(..) => {\n                 // const items only generate mono items if they are\n@@ -1051,7 +1069,7 @@ impl RootCollector<'_, 'v> {\n             debug!(\"RootCollector::push_if_root: found root def_id={:?}\", def_id);\n \n             let instance = Instance::mono(self.tcx, def_id.to_def_id());\n-            self.output.push(create_fn_mono_item(instance));\n+            self.output.push(create_fn_mono_item(instance, DUMMY_SP));\n         }\n     }\n \n@@ -1088,7 +1106,7 @@ impl RootCollector<'_, 'v> {\n         .unwrap()\n         .unwrap();\n \n-        self.output.push(create_fn_mono_item(start_instance));\n+        self.output.push(create_fn_mono_item(start_instance, DUMMY_SP));\n     }\n }\n \n@@ -1100,7 +1118,7 @@ fn item_requires_monomorphization(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n fn create_mono_items_for_default_impls<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     item: &'tcx hir::Item<'tcx>,\n-    output: &mut Vec<MonoItem<'tcx>>,\n+    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n ) {\n     match item.kind {\n         hir::ItemKind::Impl { ref generics, ref items, .. } => {\n@@ -1145,8 +1163,9 @@ fn create_mono_items_for_default_impls<'tcx>(\n                         .unwrap()\n                         .unwrap();\n \n-                    let mono_item = create_fn_mono_item(instance);\n-                    if mono_item.is_instantiable(tcx) && should_monomorphize_locally(tcx, &instance)\n+                    let mono_item = create_fn_mono_item(instance, DUMMY_SP);\n+                    if mono_item.node.is_instantiable(tcx)\n+                        && should_monomorphize_locally(tcx, &instance)\n                     {\n                         output.push(mono_item);\n                     }\n@@ -1158,14 +1177,18 @@ fn create_mono_items_for_default_impls<'tcx>(\n }\n \n /// Scans the miri alloc in order to find function calls, closures, and drop-glue.\n-fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut Vec<MonoItem<'tcx>>) {\n+fn collect_miri<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    alloc_id: AllocId,\n+    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n+) {\n     match tcx.global_alloc(alloc_id) {\n         GlobalAlloc::Static(def_id) => {\n             assert!(!tcx.is_thread_local_static(def_id));\n             let instance = Instance::mono(tcx, def_id);\n             if should_monomorphize_locally(tcx, &instance) {\n                 trace!(\"collecting static {:?}\", def_id);\n-                output.push(MonoItem::Static(def_id));\n+                output.push(dummy_spanned(MonoItem::Static(def_id)));\n             }\n         }\n         GlobalAlloc::Memory(alloc) => {\n@@ -1179,7 +1202,7 @@ fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut Vec<Mon\n         GlobalAlloc::Function(fn_instance) => {\n             if should_monomorphize_locally(tcx, &fn_instance) {\n                 trace!(\"collecting {:?} with {:#?}\", alloc_id, fn_instance);\n-                output.push(create_fn_mono_item(fn_instance));\n+                output.push(create_fn_mono_item(fn_instance, DUMMY_SP));\n             }\n         }\n     }\n@@ -1189,7 +1212,7 @@ fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut Vec<Mon\n fn collect_neighbours<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: Instance<'tcx>,\n-    output: &mut Vec<MonoItem<'tcx>>,\n+    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n ) {\n     debug!(\"collect_neighbours: {:?}\", instance.def_id());\n     let body = tcx.instance_mir(instance.def);\n@@ -1207,7 +1230,7 @@ fn def_id_to_string(tcx: TyCtxt<'_>, def_id: LocalDefId) -> String {\n fn collect_const_value<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     value: ConstValue<'tcx>,\n-    output: &mut Vec<MonoItem<'tcx>>,\n+    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n ) {\n     match value {\n         ConstValue::Scalar(Scalar::Ptr(ptr)) => collect_miri(tcx, ptr.alloc_id, output),"}, {"sha": "9fee01c1ba62329789f91af0e17a8c080203df7d", "filename": "src/test/ui/infinite/infinite-instantiation.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9/src%2Ftest%2Fui%2Finfinite%2Finfinite-instantiation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9/src%2Ftest%2Fui%2Finfinite%2Finfinite-instantiation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite%2Finfinite-instantiation.rs?ref=30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9", "patch": "@@ -1,9 +1,3 @@\n-//\n-// We get an error message at the top of file (dummy span).\n-// This is not helpful, but also kind of annoying to prevent,\n-// so for now just live with it.\n-// This test case was originally for issue #2258.\n-\n // build-fail\n \n trait ToOpt: Sized {\n@@ -23,11 +17,9 @@ impl<T:Clone> ToOpt for Option<T> {\n }\n \n fn function<T:ToOpt + Clone>(counter: usize, t: T) {\n-//~^ ERROR reached the recursion limit while instantiating `function::<std::option::Option<\n     if counter > 0 {\n         function(counter - 1, t.to_option());\n-        // FIXME(#4287) Error message should be here. It should be\n-        // a type error to instantiate `test` at a type other than T.\n+        //~^ ERROR reached the recursion limit while instantiating `function::<std::option::Option<\n     }\n }\n "}, {"sha": "7b22393ee7c0f7a7ee856a87c1dbd9d35fd83fca", "filename": "src/test/ui/infinite/infinite-instantiation.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9/src%2Ftest%2Fui%2Finfinite%2Finfinite-instantiation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9/src%2Ftest%2Fui%2Finfinite%2Finfinite-instantiation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite%2Finfinite-instantiation.stderr?ref=30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9", "patch": "@@ -1,11 +1,16 @@\n error: reached the recursion limit while instantiating `function::<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<usize>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n-  --> $DIR/infinite-instantiation.rs:25:1\n+  --> $DIR/infinite-instantiation.rs:21:9\n+   |\n+LL |         function(counter - 1, t.to_option());\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `function` defined here\n+  --> $DIR/infinite-instantiation.rs:19:1\n    |\n LL | / fn function<T:ToOpt + Clone>(counter: usize, t: T) {\n-LL | |\n LL | |     if counter > 0 {\n LL | |         function(counter - 1, t.to_option());\n-...  |\n+LL | |\n LL | |     }\n LL | | }\n    | |_^"}, {"sha": "b0fcb74764b987b8e3f2fe1160cf4d1d2ee48a9e", "filename": "src/test/ui/issues/issue-67552.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9/src%2Ftest%2Fui%2Fissues%2Fissue-67552.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9/src%2Ftest%2Fui%2Fissues%2Fissue-67552.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-67552.rs?ref=30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9", "patch": "@@ -18,13 +18,13 @@ fn identity<T>(x: T) -> T {\n }\n \n fn rec<T>(mut it: T)\n-//~^ ERROR reached the recursion limit while instantiating\n where\n     T: Iterator,\n {\n     if () == () {\n         T::count(it);\n     } else {\n         rec(identity(&mut it))\n+        //~^ ERROR reached the recursion limit while instantiating\n     }\n }"}, {"sha": "3bb2016f07d24f03fc2f609343be749f589e3408", "filename": "src/test/ui/issues/issue-67552.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9/src%2Ftest%2Fui%2Fissues%2Fissue-67552.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9/src%2Ftest%2Fui%2Fissues%2Fissue-67552.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-67552.stderr?ref=30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9", "patch": "@@ -1,10 +1,16 @@\n error: reached the recursion limit while instantiating `rec::<&mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut Empty>`\n+  --> $DIR/issue-67552.rs:27:9\n+   |\n+LL |         rec(identity(&mut it))\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `rec` defined here\n   --> $DIR/issue-67552.rs:20:1\n    |\n LL | / fn rec<T>(mut it: T)\n-LL | |\n LL | | where\n LL | |     T: Iterator,\n+LL | | {\n ...  |\n LL | |     }\n LL | | }"}, {"sha": "14bdd8511119e0fdda184fb679c9d44925c5218c", "filename": "src/test/ui/issues/issue-8727.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9/src%2Ftest%2Fui%2Fissues%2Fissue-8727.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9/src%2Ftest%2Fui%2Fissues%2Fissue-8727.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-8727.rs?ref=30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9", "patch": "@@ -3,12 +3,10 @@\n \n // build-fail\n \n-fn generic<T>() {\n+fn generic<T>() { //~ WARN function cannot return without recursing\n     generic::<Option<T>>();\n }\n-//~^^^ ERROR reached the recursion limit while instantiating `generic::<std::option::Option<\n-//~| WARN function cannot return without recursing\n-\n+//~^^ ERROR reached the recursion limit while instantiating `generic::<std::option::Option<\n \n \n fn main () {"}, {"sha": "70709fd33ac3ac170f287fbeaaf70ce118c59c2f", "filename": "src/test/ui/issues/issue-8727.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9/src%2Ftest%2Fui%2Fissues%2Fissue-8727.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9/src%2Ftest%2Fui%2Fissues%2Fissue-8727.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-8727.stderr?ref=30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9", "patch": "@@ -10,6 +10,12 @@ LL |     generic::<Option<T>>();\n    = help: a `loop` may express intention better if this is on purpose\n \n error: reached the recursion limit while instantiating `generic::<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<std::option::Option<i32>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+  --> $DIR/issue-8727.rs:7:5\n+   |\n+LL |     generic::<Option<T>>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `generic` defined here\n   --> $DIR/issue-8727.rs:6:1\n    |\n LL | / fn generic<T>() {"}, {"sha": "0552847c48ca9ac7b3ecaeac38d422e7e89b296c", "filename": "src/test/ui/recursion/issue-38591-non-regular-dropck-recursion.stderr", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9/src%2Ftest%2Fui%2Frecursion%2Fissue-38591-non-regular-dropck-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9/src%2Ftest%2Fui%2Frecursion%2Fissue-38591-non-regular-dropck-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Fissue-38591-non-regular-dropck-recursion.stderr?ref=30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9", "patch": "@@ -1,4 +1,22 @@\n error: reached the recursion limit while instantiating `std::intrinsics::drop_in_place::<S<fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(u32))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))>> - shim(Some(S<fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(fn(u32))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))>))`\n+  --> $SRC_DIR/libcore/ptr/mod.rs:LL:COL\n+   |\n+LL | / pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+LL | |     // Code here does not matter - this is replaced by the\n+LL | |     // real drop glue by the compiler.\n+LL | |     drop_in_place(to_drop)\n+LL | | }\n+   | |_^\n+   |\n+note: `std::intrinsics::drop_in_place` defined here\n+  --> $SRC_DIR/libcore/ptr/mod.rs:LL:COL\n+   |\n+LL | / pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+LL | |     // Code here does not matter - this is replaced by the\n+LL | |     // real drop glue by the compiler.\n+LL | |     drop_in_place(to_drop)\n+LL | | }\n+   | |_^\n \n error: aborting due to previous error\n "}, {"sha": "373cc17d0e0fe1c05ceccc17740f8e3733a13d9a", "filename": "src/test/ui/recursion/recursion.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9/src%2Ftest%2Fui%2Frecursion%2Frecursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9/src%2Ftest%2Fui%2Frecursion%2Frecursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursion.rs?ref=30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9", "patch": "@@ -12,11 +12,10 @@ impl<T:Dot> Dot for Cons<T> {\n     self.head * other.head + self.tail.dot(other.tail)\n   }\n }\n-fn test<T:Dot> (n:isize, i:isize, first:T, second:T) ->isize { //~ ERROR recursion limit\n+fn test<T:Dot> (n:isize, i:isize, first:T, second:T) ->isize {\n   match n {    0 => {first.dot(second)}\n-      // FIXME(#4287) Error message should be here. It should be\n-      // a type error to instantiate `test` at a type other than T.\n     _ => {test (n-1, i+1, Cons {head:2*i+1, tail:first}, Cons{head:i*i, tail:second})}\n+    //~^ ERROR recursion limit\n   }\n }\n pub fn main() {"}, {"sha": "0c0eba68c83b4d1ac7cd4181db93e553e0c9ca93", "filename": "src/test/ui/recursion/recursion.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9/src%2Ftest%2Fui%2Frecursion%2Frecursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9/src%2Ftest%2Fui%2Frecursion%2Frecursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursion.stderr?ref=30fba22a9bef7c9b15dd9e15657135c1b7d6d1a9", "patch": "@@ -1,11 +1,16 @@\n error: reached the recursion limit while instantiating `test::<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Cons<Nil>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+  --> $DIR/recursion.rs:17:11\n+   |\n+LL |     _ => {test (n-1, i+1, Cons {head:2*i+1, tail:first}, Cons{head:i*i, tail:second})}\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `test` defined here\n   --> $DIR/recursion.rs:15:1\n    |\n LL | / fn test<T:Dot> (n:isize, i:isize, first:T, second:T) ->isize {\n LL | |   match n {    0 => {first.dot(second)}\n-LL | |       // FIXME(#4287) Error message should be here. It should be\n-LL | |       // a type error to instantiate `test` at a type other than T.\n LL | |     _ => {test (n-1, i+1, Cons {head:2*i+1, tail:first}, Cons{head:i*i, tail:second})}\n+LL | |\n LL | |   }\n LL | | }\n    | |_^"}]}