{"sha": "65cca4bd3fa0abe1000662014b3e3ea1420728f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1Y2NhNGJkM2ZhMGFiZTEwMDA2NjIwMTRiM2UzZWExNDIwNzI4ZjU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-11T04:27:34Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-13T00:59:14Z"}, "message": "rustuv: Fix a use-after-free in TTY failure\n\nIf a TTY fails to get initialized, it still needs to have uv_close invoked on\nit. This fixes the problem by constructing the TtyWatcher struct before the call\nto uv_tty_init. The struct has a destructor on it which will close the handle\nproperly.\n\nCloses #12666", "tree": {"sha": "bd9e4e4e1a5f6068103ce49a5b5c0164c2079c40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd9e4e4e1a5f6068103ce49a5b5c0164c2079c40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65cca4bd3fa0abe1000662014b3e3ea1420728f5", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65cca4bd3fa0abe1000662014b3e3ea1420728f5", "html_url": "https://github.com/rust-lang/rust/commit/65cca4bd3fa0abe1000662014b3e3ea1420728f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65cca4bd3fa0abe1000662014b3e3ea1420728f5/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cad7d24a23fec68c93a0aaefc974ab18a386c6b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/cad7d24a23fec68c93a0aaefc974ab18a386c6b5", "html_url": "https://github.com/rust-lang/rust/commit/cad7d24a23fec68c93a0aaefc974ab18a386c6b5"}], "stats": {"total": 105, "additions": 93, "deletions": 12}, "files": [{"sha": "19c98c79b6abd9828baa4115ce833cb9b5906b80", "filename": "src/librustuv/tty.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/65cca4bd3fa0abe1000662014b3e3ea1420728f5/src%2Flibrustuv%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65cca4bd3fa0abe1000662014b3e3ea1420728f5/src%2Flibrustuv%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftty.rs?ref=65cca4bd3fa0abe1000662014b3e3ea1420728f5", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::libc;\n use std::io::IoError;\n+use std::libc;\n+use std::ptr;\n use std::rt::rtio::RtioTTY;\n \n use homing::{HomingIO, HomeHandle};\n@@ -54,20 +55,24 @@ impl TtyWatcher {\n         // If this file descriptor is indeed guessed to be a tty, then go ahead\n         // with attempting to open it as a tty.\n         let handle = UvHandle::alloc(None::<TtyWatcher>, uvll::UV_TTY);\n+        let mut watcher = TtyWatcher {\n+            tty: handle,\n+            stream: StreamWatcher::new(handle),\n+            home: io.make_handle(),\n+            fd: fd,\n+        };\n         match unsafe {\n             uvll::uv_tty_init(io.uv_loop(), handle, fd as libc::c_int,\n                               readable as libc::c_int)\n         } {\n-            0 => {\n-                Ok(TtyWatcher {\n-                    tty: handle,\n-                    stream: StreamWatcher::new(handle),\n-                    home: io.make_handle(),\n-                    fd: fd,\n-                })\n-            }\n+            0 => Ok(watcher),\n             n => {\n-                unsafe { uvll::free_handle(handle) }\n+                // On windows, libuv returns errors before initializing the\n+                // handle, so our only cleanup is to free the handle itself\n+                if cfg!(windows) {\n+                    unsafe { uvll::free_handle(handle); }\n+                    watcher.tty = ptr::null();\n+                }\n                 Err(UvError(n))\n             }\n         }\n@@ -124,7 +129,9 @@ impl HomingIO for TtyWatcher {\n \n impl Drop for TtyWatcher {\n     fn drop(&mut self) {\n-        let _m = self.fire_homing_missile();\n-        self.close_async_();\n+        if !self.tty.is_null() {\n+            let _m = self.fire_homing_missile();\n+            self.close_async_();\n+        }\n     }\n }"}, {"sha": "d1fc90cf007f0fb0c7705571b5d61444df52f378", "filename": "src/test/run-pass/tcp-stress.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/65cca4bd3fa0abe1000662014b3e3ea1420728f5/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65cca4bd3fa0abe1000662014b3e3ea1420728f5/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=65cca4bd3fa0abe1000662014b3e3ea1420728f5", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-linux see joyent/libuv#1189\n+// ignore-fast\n+// ignore-android needs extra network permissions\n+// exec-env:RUST_LOG=debug\n+\n+use std::libc;\n+use std::io::net::ip::{Ipv4Addr, SocketAddr};\n+use std::io::net::tcp::{TcpListener, TcpStream};\n+use std::io::{Acceptor, Listener};\n+\n+fn main() {\n+    // This test has a chance to time out, try to not let it time out\n+    spawn(proc() {\n+        use std::io::timer;\n+        timer::sleep(30 * 1000);\n+        println!(\"timed out!\");\n+        unsafe { libc::exit(1) }\n+    });\n+\n+    let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 0 };\n+    let (p, c) = Chan::new();\n+    spawn(proc() {\n+        let mut listener = TcpListener::bind(addr).unwrap();\n+        c.send(listener.socket_name().unwrap());\n+        let mut acceptor = listener.listen();\n+        loop {\n+            let mut stream = match acceptor.accept() {\n+                Ok(stream) => stream,\n+                Err(error) => {\n+                    debug!(\"accept failed: {:?}\", error);\n+                    continue;\n+                }\n+            };\n+            stream.read_byte();\n+            stream.write([2]);\n+        }\n+    });\n+    let addr = p.recv();\n+\n+    let (p, c) = Chan::new();\n+    for _ in range(0, 1000) {\n+        let c = c.clone();\n+        spawn(proc() {\n+            match TcpStream::connect(addr) {\n+                Ok(stream) => {\n+                    let mut stream = stream;\n+                    stream.write([1]);\n+                    let mut buf = [0];\n+                    stream.read(buf);\n+                },\n+                Err(e) => debug!(\"{:?}\", e)\n+            }\n+            c.send(());\n+        });\n+    }\n+\n+    // Wait for all clients to exit, but don't wait for the server to exit. The\n+    // server just runs infinitely.\n+    drop(c);\n+    for _ in range(0, 1000) {\n+        p.recv();\n+    }\n+    unsafe { libc::exit(0) }\n+}"}]}