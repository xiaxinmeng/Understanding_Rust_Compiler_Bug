{"sha": "3466c9b4befd03fd39b099466b97fea92bb5109f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0NjZjOWI0YmVmZDAzZmQzOWIwOTk0NjZiOTdmZWE5MmJiNTEwOWY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-16T01:23:59Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-16T01:48:58Z"}, "message": "rustc: Parse fn inner attributes. Closes #1506", "tree": {"sha": "77c3918572db83a837878cdd5af428b3a12e7dec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77c3918572db83a837878cdd5af428b3a12e7dec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3466c9b4befd03fd39b099466b97fea92bb5109f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3466c9b4befd03fd39b099466b97fea92bb5109f", "html_url": "https://github.com/rust-lang/rust/commit/3466c9b4befd03fd39b099466b97fea92bb5109f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3466c9b4befd03fd39b099466b97fea92bb5109f/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17585cc47ec7c4ffc9d14f33473c4238b6680e88", "url": "https://api.github.com/repos/rust-lang/rust/commits/17585cc47ec7c4ffc9d14f33473c4238b6680e88", "html_url": "https://github.com/rust-lang/rust/commit/17585cc47ec7c4ffc9d14f33473c4238b6680e88"}], "stats": {"total": 164, "additions": 134, "deletions": 30}, "files": [{"sha": "3f5cae0a16119e3ca180047575240b9fed6558f1", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 96, "deletions": 29, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/3466c9b4befd03fd39b099466b97fea92bb5109f/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3466c9b4befd03fd39b099466b97fea92bb5109f/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=3466c9b4befd03fd39b099466b97fea92bb5109f", "patch": "@@ -1531,21 +1531,32 @@ fn parse_let(p: parser) -> @ast::decl {\n     ret @spanned(lo, p.last_span.hi, ast::decl_local(locals));\n }\n \n-fn parse_stmt(p: parser) -> @ast::stmt {\n+fn parse_stmt(p: parser, first_item_attrs: [ast::attribute]) -> @ast::stmt {\n+    fn check_expected_item(p: parser, current_attrs: [ast::attribute]) {\n+        // If we have attributes then we should have an item\n+        if vec::is_not_empty(current_attrs) {\n+            p.fatal(\"expected item\");\n+        }\n+    }\n+\n     let lo = p.span.lo;\n-    if eat_word(p, \"let\") {\n+    if is_word(p, \"let\") {\n+        check_expected_item(p, first_item_attrs);\n+        expect_word(p, \"let\");\n         let decl = parse_let(p);\n         ret @spanned(lo, decl.span.hi, ast::stmt_decl(decl, p.get_id()));\n     } else {\n         let item_attrs;\n-        alt parse_outer_attrs_or_ext(p) {\n+        alt parse_outer_attrs_or_ext(p, first_item_attrs) {\n           none. { item_attrs = []; }\n           some(left(attrs)) { item_attrs = attrs; }\n           some(right(ext)) {\n             ret @spanned(lo, ext.span.hi, ast::stmt_expr(ext, p.get_id()));\n           }\n         }\n \n+        let item_attrs = first_item_attrs + item_attrs;\n+\n         alt parse_item(p, item_attrs) {\n           some(i) {\n             let hi = i.span.hi;\n@@ -1555,10 +1566,7 @@ fn parse_stmt(p: parser) -> @ast::stmt {\n           none() { /* fallthrough */ }\n         }\n \n-        // If we have attributes then we should have an item\n-        if vec::len(item_attrs) > 0u {\n-            ret p.fatal(\"expected item\");\n-        }\n+        check_expected_item(p, item_attrs);\n \n         // Remainder are line-expr stmts.\n         let e = parse_expr_res(p, RESTRICT_STMT_EXPR);\n@@ -1605,16 +1613,37 @@ fn stmt_ends_with_semi(stmt: ast::stmt) -> bool {\n }\n \n fn parse_block(p: parser) -> ast::blk {\n+    let (attrs, blk) = parse_inner_attrs_and_block(p, false);\n+    assert vec::is_empty(attrs);\n+    ret blk;\n+}\n+\n+fn parse_inner_attrs_and_block(\n+    p: parser, parse_attrs: bool) -> ([ast::attribute], ast::blk) {\n+\n+    fn maybe_parse_inner_attrs_and_next(\n+        p: parser, parse_attrs: bool) ->\n+        {inner: [ast::attribute], next: [ast::attribute]} {\n+        if parse_attrs {\n+            parse_inner_attrs_and_next(p)\n+        } else {\n+            {inner: [], next: []}\n+        }\n+    }\n+\n     let lo = p.span.lo;\n     if eat_word(p, \"unchecked\") {\n         expect(p, token::LBRACE);\n-        be parse_block_tail(p, lo, ast::unchecked_blk);\n+        let {inner, next} = maybe_parse_inner_attrs_and_next(p, parse_attrs);\n+        ret (inner, parse_block_tail_(p, lo, ast::unchecked_blk, next));\n     } else if eat_word(p, \"unsafe\") {\n         expect(p, token::LBRACE);\n-        be parse_block_tail(p, lo, ast::unsafe_blk);\n+        let {inner, next} = maybe_parse_inner_attrs_and_next(p, parse_attrs);\n+        ret (inner, parse_block_tail_(p, lo, ast::unsafe_blk, next));\n     } else {\n         expect(p, token::LBRACE);\n-        be parse_block_tail(p, lo, ast::default_blk);\n+        let {inner, next} = maybe_parse_inner_attrs_and_next(p, parse_attrs);\n+        ret (inner, parse_block_tail_(p, lo, ast::default_blk, next));\n     }\n }\n \n@@ -1630,15 +1659,28 @@ fn parse_block_no_value(p: parser) -> ast::blk {\n // necessary, and this should take a qualifier.\n // some blocks start with \"#{\"...\n fn parse_block_tail(p: parser, lo: uint, s: ast::blk_check_mode) -> ast::blk {\n-    let stmts = [], expr = none;\n-    let view_items = parse_view_import_only(p);\n+    parse_block_tail_(p, lo, s, [])\n+}\n+\n+fn parse_block_tail_(p: parser, lo: uint, s: ast::blk_check_mode,\n+                     first_item_attrs: [ast::attribute]) -> ast::blk {\n+    let stmts = [];\n+    let expr = none;\n+    let view_items = maybe_parse_view_import_only(p, first_item_attrs);\n+    let initial_attrs = first_item_attrs;\n+\n+    if p.token == token::RBRACE && !vec::is_empty(initial_attrs) {\n+        p.fatal(\"expected item\");\n+    }\n+\n     while p.token != token::RBRACE {\n         alt p.token {\n           token::SEMI. {\n             p.bump(); // empty\n           }\n           _ {\n-            let stmt = parse_stmt(p);\n+            let stmt = parse_stmt(p, initial_attrs);\n+            initial_attrs = [];\n             alt stmt.node {\n               ast::stmt_expr(e, stmt_id) { // Expression without semicolon:\n                 alt p.token {\n@@ -1751,7 +1793,8 @@ fn parse_item_fn(p: parser, purity: ast::purity,\n     let lo = p.last_span.lo;\n     let t = parse_fn_header(p);\n     let decl = parse_fn_decl(p, purity);\n-    let body = parse_block(p);\n+    let (inner_attrs, body) = parse_inner_attrs_and_block(p, true);\n+    let attrs = attrs + inner_attrs;\n     ret mk_item(p, lo, body.span.hi, t.ident,\n                 ast::item_fn(decl, t.tps, body), attrs);\n }\n@@ -1832,8 +1875,7 @@ fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n fn parse_mod_items(p: parser, term: token::token,\n                    first_item_attrs: [ast::attribute]) -> ast::_mod {\n     // Shouldn't be any view items since we've already parsed an item attr\n-    let view_items =\n-        if vec::len(first_item_attrs) == 0u { parse_view(p) } else { [] };\n+    let view_items = maybe_parse_view(p, first_item_attrs);\n     let items: [@ast::item] = [];\n     let initial_attrs = first_item_attrs;\n     while p.token != term {\n@@ -2134,14 +2176,20 @@ fn parse_item(p: parser, attrs: [ast::attribute]) -> option::t<@ast::item> {\n // extensions, which both begin with token.POUND\n type attr_or_ext = option::t<either::t<[ast::attribute], @ast::expr>>;\n \n-fn parse_outer_attrs_or_ext(p: parser) -> attr_or_ext {\n+fn parse_outer_attrs_or_ext(\n+    p: parser,\n+    first_item_attrs: [ast::attribute]) -> attr_or_ext {\n+    let expect_item_next = vec::is_not_empty(first_item_attrs);\n     if p.token == token::POUND {\n         let lo = p.span.lo;\n-        p.bump();\n-        if p.token == token::LBRACKET {\n+        if p.look_ahead(1u) == token::LBRACKET {\n+            p.bump();\n             let first_attr = parse_attribute_naked(p, ast::attr_outer, lo);\n             ret some(left([first_attr] + parse_outer_attributes(p)));\n-        } else if !(p.token == token::LT || p.token == token::LBRACKET) {\n+        } else if !(p.look_ahead(1u) == token::LT\n+                    || p.look_ahead(1u) == token::LBRACKET\n+                    || expect_item_next) {\n+            p.bump();\n             ret some(right(parse_syntax_ext_naked(p, lo)));\n         } else { ret none; }\n     } else { ret none; }\n@@ -2182,6 +2230,10 @@ fn parse_inner_attrs_and_next(p: parser) ->\n     let inner_attrs: [ast::attribute] = [];\n     let next_outer_attrs: [ast::attribute] = [];\n     while p.token == token::POUND {\n+        if p.look_ahead(1u) != token::LBRACKET {\n+            // This is an extension\n+            break;\n+        }\n         let attr = parse_attribute(p, ast::attr_inner);\n         if p.token == token::SEMI {\n             p.bump();\n@@ -2377,22 +2429,37 @@ fn is_view_item(p: parser) -> bool {\n     }\n }\n \n-fn parse_view(p: parser) -> [@ast::view_item] {\n-    parse_view_while(p, is_view_item)\n+fn maybe_parse_view(\n+    p: parser,\n+    first_item_attrs: [ast::attribute]) -> [@ast::view_item] {\n+\n+    maybe_parse_view_while(p, first_item_attrs, is_view_item)\n }\n \n-fn parse_view_import_only(p: parser) -> [@ast::view_item] {\n-    parse_view_while(p, bind is_word(_, \"import\"))\n+fn maybe_parse_view_import_only(\n+    p: parser,\n+    first_item_attrs: [ast::attribute]) -> [@ast::view_item] {\n+\n+    maybe_parse_view_while(p, first_item_attrs, bind is_word(_, \"import\"))\n }\n \n-fn parse_view_while(p: parser, f: fn@(parser) -> bool) -> [@ast::view_item] {\n-    let items = [];\n-    while f(p) { items += [parse_view_item(p)]; }\n-    ret items;\n+fn maybe_parse_view_while(\n+    p: parser,\n+    first_item_attrs: [ast::attribute],\n+    f: fn@(parser) -> bool) -> [@ast::view_item] {\n+\n+    if vec::len(first_item_attrs) == 0u {\n+        let items = [];\n+        while f(p) { items += [parse_view_item(p)]; }\n+        ret items;\n+    } else {\n+        // Shouldn't be any view items since we've already parsed an item attr\n+        ret [];\n+    }\n }\n \n fn parse_native_view(p: parser) -> [@ast::view_item] {\n-    parse_view_while(p, is_view_item)\n+    maybe_parse_view_while(p, [], is_view_item)\n }\n \n fn parse_crate_from_source_file(input: str, cfg: ast::crate_cfg,"}, {"sha": "e0c1acc4fcc015ec7e2c6f56d4a3b50eb70957e6", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3466c9b4befd03fd39b099466b97fea92bb5109f/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3466c9b4befd03fd39b099466b97fea92bb5109f/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=3466c9b4befd03fd39b099466b97fea92bb5109f", "patch": "@@ -366,7 +366,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n       ast::item_fn(decl, typarams, body) {\n         print_fn(s, decl, item.ident, typarams);\n         word(s.s, \" \");\n-        print_block(s, body);\n+        print_block_with_attrs(s, body, item.attrs);\n       }\n       ast::item_mod(_mod) {\n         head(s, \"mod\");\n@@ -551,10 +551,20 @@ fn print_block(s: ps, blk: ast::blk) {\n     print_possibly_embedded_block(s, blk, block_normal, indent_unit);\n }\n \n+fn print_block_with_attrs(s: ps, blk: ast::blk, attrs: [ast::attribute]) {\n+    print_possibly_embedded_block_(s, blk, block_normal, indent_unit, attrs);\n+}\n+\n tag embed_type { block_macro; block_block_fn; block_normal; }\n \n fn print_possibly_embedded_block(s: ps, blk: ast::blk, embedded: embed_type,\n                                  indented: uint) {\n+    print_possibly_embedded_block_(\n+        s, blk, embedded, indented, []);\n+}\n+\n+fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n+                                  indented: uint, attrs: [ast::attribute]) {\n     alt blk.node.rules {\n       ast::unchecked_blk. { word(s.s, \"unchecked\"); }\n       ast::unsafe_blk. { word(s.s, \"unsafe\"); }\n@@ -570,6 +580,8 @@ fn print_possibly_embedded_block(s: ps, blk: ast::blk, embedded: embed_type,\n       block_normal. { bopen(s); }\n     }\n \n+    print_inner_attributes(s, attrs);\n+\n     for vi in blk.node.view_items { print_view_item(s, vi); }\n     for st: @ast::stmt in blk.node.stmts {\n         print_stmt(s, *st);"}, {"sha": "8409ab8ef528d26e63d9743c110d58b48d242e30", "filename": "src/test/compile-fail/attr-before-ext.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3466c9b4befd03fd39b099466b97fea92bb5109f/src%2Ftest%2Fcompile-fail%2Fattr-before-ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3466c9b4befd03fd39b099466b97fea92bb5109f/src%2Ftest%2Fcompile-fail%2Fattr-before-ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-before-ext.rs?ref=3466c9b4befd03fd39b099466b97fea92bb5109f", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    #[attr]\n+    #debug(\"hi\"); //! ERROR expected item\n+}\n\\ No newline at end of file"}, {"sha": "814ad400d6baa74a374b8dfc5492993097e7231c", "filename": "src/test/compile-fail/attr-before-let.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3466c9b4befd03fd39b099466b97fea92bb5109f/src%2Ftest%2Fcompile-fail%2Fattr-before-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3466c9b4befd03fd39b099466b97fea92bb5109f/src%2Ftest%2Fcompile-fail%2Fattr-before-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-before-let.rs?ref=3466c9b4befd03fd39b099466b97fea92bb5109f", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    #[attr]\n+    let _i = 0; //! ERROR expected item\n+}\n\\ No newline at end of file"}, {"sha": "87e62c004fed4e49aca82197e26997b85fb50afa", "filename": "src/test/pretty/attr-fn-inner.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3466c9b4befd03fd39b099466b97fea92bb5109f/src%2Ftest%2Fpretty%2Fattr-fn-inner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3466c9b4befd03fd39b099466b97fea92bb5109f/src%2Ftest%2Fpretty%2Fattr-fn-inner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fattr-fn-inner.rs?ref=3466c9b4befd03fd39b099466b97fea92bb5109f", "patch": "@@ -0,0 +1,13 @@\n+// pp-exact\n+// Testing that both the inner item and next outer item are\n+// preserved, and that the first outer item parsed in main is not\n+// accidentally carried over to each inner function\n+\n+fn main() {\n+    #[inner_attr];\n+    #[outer_attr]\n+    fn f() { }\n+\n+    #[outer_attr]\n+    fn g() { }\n+}"}, {"sha": "ba00bb4a3020a28377bb0f7c758a67ac9a56d7b9", "filename": "src/test/run-pass/item-attributes.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3466c9b4befd03fd39b099466b97fea92bb5109f/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3466c9b4befd03fd39b099466b97fea92bb5109f/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fitem-attributes.rs?ref=3466c9b4befd03fd39b099466b97fea92bb5109f", "patch": "@@ -183,6 +183,10 @@ mod test_literals {\n     mod m { }\n }\n \n+fn test_fn_inner() {\n+    #[inner_fn_attr];\n+}\n+\n fn main() { }\n \n //"}]}