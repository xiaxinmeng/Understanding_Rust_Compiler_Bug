{"sha": "b6943736bd37e0e932089c27dd0638f0a7ddc3fe", "node_id": "C_kwDOAAsO6NoAKGI2OTQzNzM2YmQzN2UwZTkzMjA4OWMyN2RkMDYzOGYwYTdkZGMzZmU", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2023-03-28T03:01:24Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2023-04-26T05:47:37Z"}, "message": "Inline tweaks", "tree": {"sha": "ca82c653cb1158528306247bede9cc43702ee25f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca82c653cb1158528306247bede9cc43702ee25f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6943736bd37e0e932089c27dd0638f0a7ddc3fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6943736bd37e0e932089c27dd0638f0a7ddc3fe", "html_url": "https://github.com/rust-lang/rust/commit/b6943736bd37e0e932089c27dd0638f0a7ddc3fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6943736bd37e0e932089c27dd0638f0a7ddc3fe/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4440e8196aee718cbd3aafa41a0919f432c06330", "url": "https://api.github.com/repos/rust-lang/rust/commits/4440e8196aee718cbd3aafa41a0919f432c06330", "html_url": "https://github.com/rust-lang/rust/commit/4440e8196aee718cbd3aafa41a0919f432c06330"}], "stats": {"total": 28, "additions": 24, "deletions": 4}, "files": [{"sha": "e56faff5ed47cda1e62d7fc125201629e2dd89cf", "filename": "compiler/rustc_middle/src/query/on_disk_cache.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b6943736bd37e0e932089c27dd0638f0a7ddc3fe/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6943736bd37e0e932089c27dd0638f0a7ddc3fe/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fon_disk_cache.rs?ref=b6943736bd37e0e932089c27dd0638f0a7ddc3fe", "patch": "@@ -121,10 +121,12 @@ struct SourceFileIndex(u32);\n pub struct AbsoluteBytePos(u64);\n \n impl AbsoluteBytePos {\n+    #[inline]\n     pub fn new(pos: usize) -> AbsoluteBytePos {\n         AbsoluteBytePos(pos.try_into().expect(\"Incremental cache file size overflowed u64.\"))\n     }\n \n+    #[inline]\n     fn to_usize(self) -> usize {\n         self.0 as usize\n     }\n@@ -142,11 +144,13 @@ struct EncodedSourceFileId {\n }\n \n impl EncodedSourceFileId {\n+    #[inline]\n     fn translate(&self, tcx: TyCtxt<'_>) -> StableSourceFileId {\n         let cnum = tcx.stable_crate_id_to_crate_num(self.stable_crate_id);\n         StableSourceFileId { file_name_hash: self.file_name_hash, cnum }\n     }\n \n+    #[inline]\n     fn new(tcx: TyCtxt<'_>, file: &SourceFile) -> EncodedSourceFileId {\n         let source_file_id = StableSourceFileId::new(file);\n         EncodedSourceFileId {\n@@ -372,15 +376,14 @@ impl<'sess> OnDiskCache<'sess> {\n     /// Stores a `QuerySideEffects` emitted during the current compilation session.\n     /// Anything stored like this will be available via `load_side_effects` in\n     /// the next compilation session.\n-    #[inline(never)]\n-    #[cold]\n     pub fn store_side_effects(&self, dep_node_index: DepNodeIndex, side_effects: QuerySideEffects) {\n         let mut current_side_effects = self.current_side_effects.borrow_mut();\n         let prev = current_side_effects.insert(dep_node_index, side_effects);\n         debug_assert!(prev.is_none());\n     }\n \n     /// Return whether the cached query result can be decoded.\n+    #[inline]\n     pub fn loadable_from_disk(&self, dep_node_index: SerializedDepNodeIndex) -> bool {\n         self.query_result_index.contains_key(&dep_node_index)\n         // with_decoder is infallible, so we can stop here\n@@ -405,8 +408,6 @@ impl<'sess> OnDiskCache<'sess> {\n     /// Since many anonymous queries can share the same `DepNode`, we aggregate\n     /// them -- as opposed to regular queries where we assume that there is a\n     /// 1:1 relationship between query-key and `DepNode`.\n-    #[inline(never)]\n-    #[cold]\n     pub fn store_side_effects_for_anon_node(\n         &self,\n         dep_node_index: DepNodeIndex,\n@@ -477,6 +478,7 @@ pub struct CacheDecoder<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> CacheDecoder<'a, 'tcx> {\n+    #[inline]\n     fn file_index_to_file(&self, index: SourceFileIndex) -> Lrc<SourceFile> {\n         let CacheDecoder {\n             tcx,\n@@ -697,6 +699,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for Span {\n \n // copy&paste impl from rustc_metadata\n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for Symbol {\n+    #[inline]\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         let tag = d.read_u8();\n \n@@ -725,6 +728,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for Symbol {\n }\n \n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for CrateNum {\n+    #[inline]\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         let stable_id = StableCrateId::decode(d);\n         let cnum = d.tcx.stable_crate_id_to_crate_num(stable_id);\n@@ -746,6 +750,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for DefIndex {\n // compilation sessions. We use the `DefPathHash`, which is stable across\n // sessions, to map the old `DefId` to the new one.\n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for DefId {\n+    #[inline]\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         // Load the `DefPathHash` which is was we encoded the `DefId` as.\n         let def_path_hash = DefPathHash::decode(d);\n@@ -762,6 +767,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for DefId {\n }\n \n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx UnordSet<LocalDefId> {\n+    #[inline]\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         RefDecodable::decode(d)\n     }\n@@ -770,6 +776,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx UnordSet<LocalDefId>\n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>>\n     for &'tcx FxHashMap<DefId, ty::EarlyBinder<Ty<'tcx>>>\n {\n+    #[inline]\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         RefDecodable::decode(d)\n     }\n@@ -778,24 +785,28 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>>\n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>>\n     for &'tcx IndexVec<mir::Promoted, mir::Body<'tcx>>\n {\n+    #[inline]\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         RefDecodable::decode(d)\n     }\n }\n \n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>, Span)] {\n+    #[inline]\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         RefDecodable::decode(d)\n     }\n }\n \n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [(ty::Clause<'tcx>, Span)] {\n+    #[inline]\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         RefDecodable::decode(d)\n     }\n }\n \n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [rustc_ast::InlineAsmTemplatePiece] {\n+    #[inline]\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         RefDecodable::decode(d)\n     }\n@@ -804,6 +815,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [rustc_ast::InlineAsm\n macro_rules! impl_ref_decoder {\n     (<$tcx:tt> $($ty:ty,)*) => {\n         $(impl<'a, $tcx> Decodable<CacheDecoder<'a, $tcx>> for &$tcx [$ty] {\n+            #[inline]\n             fn decode(d: &mut CacheDecoder<'a, $tcx>) -> Self {\n                 RefDecodable::decode(d)\n             }\n@@ -838,6 +850,7 @@ pub struct CacheEncoder<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> CacheEncoder<'a, 'tcx> {\n+    #[inline]\n     fn source_file_index(&mut self, source_file: Lrc<SourceFile>) -> SourceFileIndex {\n         self.file_to_file_index[&(&*source_file as *const SourceFile)]\n     }\n@@ -857,6 +870,7 @@ impl<'a, 'tcx> CacheEncoder<'a, 'tcx> {\n         ((end_pos - start_pos) as u64).encode(self);\n     }\n \n+    #[inline]\n     fn finish(self) -> Result<usize, io::Error> {\n         self.encoder.finish()\n     }\n@@ -949,15 +963,19 @@ impl<'a, 'tcx> TyEncoder for CacheEncoder<'a, 'tcx> {\n     type I = TyCtxt<'tcx>;\n     const CLEAR_CROSS_CRATE: bool = false;\n \n+    #[inline]\n     fn position(&self) -> usize {\n         self.encoder.position()\n     }\n+    #[inline]\n     fn type_shorthands(&mut self) -> &mut FxHashMap<Ty<'tcx>, usize> {\n         &mut self.type_shorthands\n     }\n+    #[inline]\n     fn predicate_shorthands(&mut self) -> &mut FxHashMap<ty::PredicateKind<'tcx>, usize> {\n         &mut self.predicate_shorthands\n     }\n+    #[inline]\n     fn encode_alloc_id(&mut self, alloc_id: &interpret::AllocId) {\n         let (index, _) = self.interpret_allocs.insert_full(*alloc_id);\n \n@@ -966,12 +984,14 @@ impl<'a, 'tcx> TyEncoder for CacheEncoder<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx>> for CrateNum {\n+    #[inline]\n     fn encode(&self, s: &mut CacheEncoder<'a, 'tcx>) {\n         s.tcx.stable_crate_id(*self).encode(s);\n     }\n }\n \n impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx>> for DefId {\n+    #[inline]\n     fn encode(&self, s: &mut CacheEncoder<'a, 'tcx>) {\n         s.tcx.def_path_hash(*self).encode(s);\n     }"}]}