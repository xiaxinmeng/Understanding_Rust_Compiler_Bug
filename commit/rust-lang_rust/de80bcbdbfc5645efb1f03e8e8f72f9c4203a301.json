{"sha": "de80bcbdbfc5645efb1f03e8e8f72f9c4203a301", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlODBiY2JkYmZjNTY0NWVmYjFmMDNlOGU4ZjcyZjljNDIwM2EzMDE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-08-07T22:39:27Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-08-09T22:49:47Z"}, "message": "some tests for RangeMap", "tree": {"sha": "cb91289416dcbe5a6f7bc8f681a46c7c2cc0d5b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb91289416dcbe5a6f7bc8f681a46c7c2cc0d5b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de80bcbdbfc5645efb1f03e8e8f72f9c4203a301", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de80bcbdbfc5645efb1f03e8e8f72f9c4203a301", "html_url": "https://github.com/rust-lang/rust/commit/de80bcbdbfc5645efb1f03e8e8f72f9c4203a301", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de80bcbdbfc5645efb1f03e8e8f72f9c4203a301/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65a31317a4f48aca99f73237a060be975f591663", "url": "https://api.github.com/repos/rust-lang/rust/commits/65a31317a4f48aca99f73237a060be975f591663", "html_url": "https://github.com/rust-lang/rust/commit/65a31317a4f48aca99f73237a060be975f591663"}], "stats": {"total": 69, "additions": 59, "deletions": 10}, "files": [{"sha": "ef15fa98d3fc83f4ed6ea9795e744a865d9dea62", "filename": ".travis.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de80bcbdbfc5645efb1f03e8e8f72f9c4203a301/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/de80bcbdbfc5645efb1f03e8e8f72f9c4203a301/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=de80bcbdbfc5645efb1f03e8e8f72f9c4203a301", "patch": "@@ -16,7 +16,7 @@ script:\n - |\n   # Test plain miri\n   cargo build --release --features \"cargo_miri\" &&\n-  cargo test --release &&\n+  cargo test --release --all &&\n   cargo install --features \"cargo_miri\"\n - |\n   # Test cargo miri"}, {"sha": "4189f240c582415ab1f512cce0d0689eb4ead000", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/de80bcbdbfc5645efb1f03e8e8f72f9c4203a301/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/de80bcbdbfc5645efb1f03e8e8f72f9c4203a301/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=de80bcbdbfc5645efb1f03e8e8f72f9c4203a301", "patch": "@@ -8,7 +8,6 @@ version = \"0.1.0\"\n workspace = \"../..\"\n \n [lib]\n-test = false\n path = \"lib.rs\"\n \n [dependencies]"}, {"sha": "e4db9b0e0fc45bfd710dff018d9674e2cabbd9fb", "filename": "src/librustc_mir/interpret/range_map.rs", "status": "modified", "additions": 58, "deletions": 8, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/de80bcbdbfc5645efb1f03e8e8f72f9c4203a301/src%2Flibrustc_mir%2Finterpret%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de80bcbdbfc5645efb1f03e8e8f72f9c4203a301/src%2Flibrustc_mir%2Finterpret%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Frange_map.rs?ref=de80bcbdbfc5645efb1f03e8e8f72f9c4203a301", "patch": "@@ -1,4 +1,9 @@\n-//! Implements a map from disjoint non-empty integer ranges to data associated with those ranges\n+//! Implements a map from integer indices to data.\n+//! Rather than storing data for every index, internally, this maps entire ranges to the data.\n+//! To this end, the APIs all work on ranges, not on individual integers. Ranges are split as\n+//! necessary (e.g. when [0,5) is first associated with X, and then [1,2) is mutated).\n+//! Users must not depend on whether a range is coalesced or not, even though this is observable\n+//! via the iteration APIs.\n use std::collections::{BTreeMap};\n use std::ops;\n \n@@ -21,6 +26,7 @@ struct Range {\n \n impl Range {\n     fn range(offset: u64, len: u64) -> ops::Range<Range> {\n+        assert!(len > 0);\n         // We select all elements that are within\n         // the range given by the offset into the allocation and the length.\n         // This is sound if all ranges that intersect with the argument range, are in the\n@@ -36,6 +42,7 @@ impl Range {\n         left..right\n     }\n \n+    /// Tests if all of [offset, offset+len) are contained in this range.\n     fn overlaps(&self, offset: u64, len: u64) -> bool {\n         assert!(len > 0);\n         offset < self.end && offset+len >= self.start\n@@ -48,6 +55,7 @@ impl<T> RangeMap<T> {\n     }\n \n     fn iter_with_range<'a>(&'a self, offset: u64, len: u64) -> impl Iterator<Item=(&'a Range, &'a T)> + 'a {\n+        assert!(len > 0);\n         self.map.range(Range::range(offset, len))\n             .filter_map(move |(range, data)| {\n                 if range.overlaps(offset, len) {\n@@ -63,7 +71,7 @@ impl<T> RangeMap<T> {\n     }\n \n     fn split_entry_at(&mut self, offset: u64) where T: Clone {\n-        let range = match self.iter_with_range(offset, 0).next() {\n+        let range = match self.iter_with_range(offset, 1).next() {\n             Some((&range, _)) => range,\n             None => return,\n         };\n@@ -88,6 +96,7 @@ impl<T> RangeMap<T> {\n     pub fn iter_mut_with_gaps<'a>(&'a mut self, offset: u64, len: u64) -> impl Iterator<Item=&'a mut T> + 'a\n         where T: Clone\n     {\n+        assert!(len > 0);\n         // Preparation: Split first and last entry as needed.\n         self.split_entry_at(offset);\n         self.split_entry_at(offset+len);\n@@ -112,14 +121,15 @@ impl<T> RangeMap<T> {\n     {\n         // Do a first iteration to collect the gaps\n         let mut gaps = Vec::new();\n-        let mut last_end = None;\n+        let mut last_end = offset;\n         for (range, _) in self.iter_with_range(offset, len) {\n-            if let Some(last_end) = last_end {\n-                if last_end < range.start {\n-                    gaps.push(Range { start: last_end, end: range.start });\n-                }\n+            if last_end < range.start {\n+                gaps.push(Range { start: last_end, end: range.start });\n             }\n-            last_end = Some(range.end);\n+            last_end = range.end;\n+        }\n+        if last_end < offset+len {\n+            gaps.push(Range { start: last_end, end: offset+len });\n         }\n \n         // Add default for all gaps\n@@ -147,3 +157,43 @@ impl<T> RangeMap<T> {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    /// Query the map at every offset in the range and collect the results.\n+    fn to_vec<T: Copy>(map: &RangeMap<T>, offset: u64, len: u64) -> Vec<T> {\n+        (offset..offset+len).into_iter().map(|i| *map.iter(i, 1).next().unwrap()).collect()\n+    }\n+\n+    #[test]\n+    fn basic_insert() {\n+        let mut map = RangeMap::<i32>::new();\n+        // Insert\n+        for x in map.iter_mut(10, 1) {\n+            *x = 42;\n+        }\n+        // Check\n+        assert_eq!(to_vec(&map, 10, 1), vec![42]);\n+    }\n+\n+    #[test]\n+    fn gaps() {\n+        let mut map = RangeMap::<i32>::new();\n+        for x in map.iter_mut(11, 1) {\n+            *x = 42;\n+        }\n+        for x in map.iter_mut(15, 1) {\n+            *x = 42;\n+        }\n+\n+        // Now request a range that needs three gaps filled\n+        for x in map.iter_mut(10, 10) {\n+            if *x != 42 { *x = 23; }\n+        }\n+\n+        assert_eq!(to_vec(&map, 10, 10), vec![23, 42, 23, 23, 23, 42, 23, 23, 23, 23]);\n+        assert_eq!(to_vec(&map, 13, 5), vec![23, 23, 42, 23, 23]);\n+    }\n+}"}]}