{"sha": "3f15b0a24bc95c3a94325fdb4a9670787da87e62", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmMTViMGEyNGJjOTVjM2E5NDMyNWZkYjRhOTY3MDc4N2RhODdlNjI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-06-16T10:54:37Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-06-16T10:54:37Z"}, "message": "Implement scalar pair abi pass mode", "tree": {"sha": "c8fcae8ff8838b30d009746d97a4c80aad3caeb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8fcae8ff8838b30d009746d97a4c80aad3caeb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f15b0a24bc95c3a94325fdb4a9670787da87e62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f15b0a24bc95c3a94325fdb4a9670787da87e62", "html_url": "https://github.com/rust-lang/rust/commit/3f15b0a24bc95c3a94325fdb4a9670787da87e62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f15b0a24bc95c3a94325fdb4a9670787da87e62/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65bc1e5b5b9191db6f0082447e22c4d971c8cc19", "url": "https://api.github.com/repos/rust-lang/rust/commits/65bc1e5b5b9191db6f0082447e22c4d971c8cc19", "html_url": "https://github.com/rust-lang/rust/commit/65bc1e5b5b9191db6f0082447e22c4d971c8cc19"}], "stats": {"total": 218, "additions": 162, "deletions": 56}, "files": [{"sha": "e8523cd2de08034e907a7328bd31912d606aeec2", "filename": "src/abi.rs", "status": "modified", "additions": 162, "deletions": 56, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/3f15b0a24bc95c3a94325fdb4a9670787da87e62/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f15b0a24bc95c3a94325fdb4a9670787da87e62/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=3f15b0a24bc95c3a94325fdb4a9670787da87e62", "patch": "@@ -9,15 +9,73 @@ use crate::prelude::*;\n enum PassMode {\n     NoPass,\n     ByVal(Type),\n+    ByValPair(Type, Type),\n     ByRef,\n }\n \n+#[derive(Copy, Clone, Debug)]\n+enum EmptySinglePair<T> {\n+    Empty,\n+    Single(T),\n+    Pair(T, T),\n+}\n+\n+impl<T> EmptySinglePair<T> {\n+    fn into_iter(self) -> EmptySinglePairIter<T> {\n+        EmptySinglePairIter(self)\n+    }\n+\n+    fn map<U>(self, mut f: impl FnMut(T) -> U) -> EmptySinglePair<U> {\n+        match self {\n+            Empty => Empty,\n+            Single(v) => Single(f(v)),\n+            Pair(a, b) => Pair(f(a), f(b)),\n+        }\n+    }\n+}\n+\n+struct EmptySinglePairIter<T>(EmptySinglePair<T>);\n+\n+impl<T> Iterator for EmptySinglePairIter<T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        match std::mem::replace(&mut self.0, Empty) {\n+            Empty => None,\n+            Single(v) => Some(v),\n+            Pair(a, b) => {\n+                self.0 = Single(b);\n+                Some(a)\n+            }\n+        }\n+    }\n+}\n+\n+impl<T: std::fmt::Debug> EmptySinglePair<T> {\n+    fn assert_single(self) -> T {\n+        match self {\n+            Single(v) => v,\n+            _ => panic!(\"Called assert_single on {:?}\", self)\n+        }\n+    }\n+\n+    fn assert_pair(self) -> (T, T) {\n+        match self {\n+            Pair(a, b) => (a, b),\n+            _ => panic!(\"Called assert_pair on {:?}\", self)\n+        }\n+    }\n+}\n+\n+use EmptySinglePair::*;\n+\n impl PassMode {\n-    fn get_param_ty(self, fx: &FunctionCx<impl Backend>) -> Type {\n+    fn get_param_ty(self, fx: &FunctionCx<impl Backend>) -> EmptySinglePair<Type> {\n         match self {\n-            PassMode::NoPass => unimplemented!(\"pass mode nopass\"),\n-            PassMode::ByVal(clif_type) => clif_type,\n-            PassMode::ByRef => fx.pointer_type,\n+            PassMode::NoPass => Empty,\n+            PassMode::ByVal(clif_type) => Single(clif_type),\n+            PassMode::ByValPair(a, b) => Pair(a, b),\n+            PassMode::ByRef => Single(fx.pointer_type),\n         }\n     }\n }\n@@ -41,9 +99,8 @@ pub fn scalar_to_clif_type(tcx: TyCtxt, scalar: Scalar) -> Type {\n \n fn get_pass_mode<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    ty: Ty<'tcx>,\n+    layout: TyLayout<'tcx>,\n ) -> PassMode {\n-    let layout = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n     assert!(!layout.is_unsized());\n \n     if layout.is_zst() {\n@@ -55,9 +112,14 @@ fn get_pass_mode<'tcx>(\n             layout::Abi::Scalar(scalar) => {\n                 PassMode::ByVal(scalar_to_clif_type(tcx, scalar.clone()))\n             }\n+            layout::Abi::ScalarPair(a, b) => {\n+                PassMode::ByValPair(\n+                    scalar_to_clif_type(tcx, a.clone()),\n+                    scalar_to_clif_type(tcx, b.clone()),\n+                )\n+            }\n \n-            // FIXME implement ScalarPair and Vector Abi in a cg_llvm compatible way\n-            layout::Abi::ScalarPair(_, _) => PassMode::ByRef,\n+            // FIXME implement Vector Abi in a cg_llvm compatible way\n             layout::Abi::Vector { .. } => PassMode::ByRef,\n \n             layout::Abi::Aggregate { .. } => PassMode::ByRef,\n@@ -68,15 +130,19 @@ fn get_pass_mode<'tcx>(\n fn adjust_arg_for_abi<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     arg: CValue<'tcx>,\n-) -> Option<Value> {\n-    match get_pass_mode(fx.tcx, arg.layout().ty) {\n-        PassMode::NoPass => None,\n-        PassMode::ByVal(_) => Some(arg.load_scalar(fx)),\n-        PassMode::ByRef => Some(arg.force_stack(fx)),\n+) -> EmptySinglePair<Value> {\n+    match get_pass_mode(fx.tcx, arg.layout()) {\n+        PassMode::NoPass => Empty,\n+        PassMode::ByVal(_) => Single(arg.load_scalar(fx)),\n+        PassMode::ByValPair(_, _) => {\n+            let (a, b) = arg.load_scalar_pair(fx);\n+            Pair(a, b)\n+        }\n+        PassMode::ByRef => Single(arg.force_stack(fx)),\n     }\n }\n \n-fn clif_sig_from_fn_sig<'tcx>(tcx: TyCtxt<'tcx>, sig: FnSig<'tcx>) -> Signature {\n+fn clif_sig_from_fn_sig<'tcx>(tcx: TyCtxt<'tcx>, sig: FnSig<'tcx>, is_vtable_fn: bool) -> Signature {\n     let (call_conv, inputs, output): (CallConv, Vec<Ty>, Ty) = match sig.abi {\n         Abi::Rust => (CallConv::SystemV, sig.inputs().to_vec(), sig.output()),\n         Abi::C => (CallConv::SystemV, sig.inputs().to_vec(), sig.output()),\n@@ -97,18 +163,32 @@ fn clif_sig_from_fn_sig<'tcx>(tcx: TyCtxt<'tcx>, sig: FnSig<'tcx>) -> Signature\n \n     let inputs = inputs\n         .into_iter()\n-        .filter_map(|ty| match get_pass_mode(tcx, ty) {\n-            PassMode::NoPass => None,\n-            PassMode::ByVal(clif_ty) => Some(clif_ty),\n-            PassMode::ByRef => Some(pointer_ty(tcx)),\n-        });\n-\n-    let (params, returns) = match get_pass_mode(tcx, output) {\n+        .enumerate()\n+        .map(|(i, ty)| {\n+            let mut layout = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n+            if i == 0 && is_vtable_fn {\n+                // Virtual calls turn their self param into a thin pointer.\n+                // See https://doc.rust-lang.org/nightly/nightly-rustc/src/rustc/ty/layout.rs.html#2519-2572 for more info\n+                layout = tcx.layout_of(ParamEnv::reveal_all().and(tcx.mk_mut_ptr(tcx.mk_unit()))).unwrap();\n+            }\n+            match get_pass_mode(tcx, layout) {\n+                PassMode::NoPass => Empty,\n+                PassMode::ByVal(clif_ty) => Single(clif_ty),\n+                PassMode::ByValPair(clif_ty_a, clif_ty_b) => Pair(clif_ty_a, clif_ty_b),\n+                PassMode::ByRef => Single(pointer_ty(tcx)),\n+            }.into_iter()\n+        }).flatten();\n+\n+    let (params, returns) = match get_pass_mode(tcx, tcx.layout_of(ParamEnv::reveal_all().and(output)).unwrap()) {\n         PassMode::NoPass => (inputs.map(AbiParam::new).collect(), vec![]),\n         PassMode::ByVal(ret_ty) => (\n             inputs.map(AbiParam::new).collect(),\n             vec![AbiParam::new(ret_ty)],\n         ),\n+        PassMode::ByValPair(ret_ty_a, ret_ty_b) => (\n+            inputs.map(AbiParam::new).collect(),\n+            vec![AbiParam::new(ret_ty_a), AbiParam::new(ret_ty_b)],\n+        ),\n         PassMode::ByRef => {\n             (\n                 Some(pointer_ty(tcx)) // First param is place to put return val\n@@ -138,7 +218,7 @@ pub fn get_function_name_and_sig<'tcx>(\n     if fn_sig.c_variadic && !support_vararg {\n         unimpl!(\"Variadic function definitions are not yet supported\");\n     }\n-    let sig = clif_sig_from_fn_sig(tcx, fn_sig);\n+    let sig = clif_sig_from_fn_sig(tcx, fn_sig, false);\n     (tcx.symbol_name(inst).as_str().to_string(), sig)\n }\n \n@@ -238,8 +318,8 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n         self.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &self.instance.fn_sig(self.tcx))\n     }\n \n-    fn return_type(&self) -> Ty<'tcx> {\n-        self.self_sig().output()\n+    fn return_layout(&self) -> TyLayout<'tcx> {\n+        self.layout_of(self.self_sig().output())\n     }\n }\n \n@@ -249,7 +329,7 @@ fn add_arg_comment<'a, 'tcx: 'a>(\n     msg: &str,\n     local: mir::Local,\n     local_field: Option<usize>,\n-    param: Option<Value>,\n+    params: EmptySinglePair<Value>,\n     pass_mode: PassMode,\n     ssa: crate::analyze::Flags,\n     ty: Ty<'tcx>,\n@@ -259,18 +339,18 @@ fn add_arg_comment<'a, 'tcx: 'a>(\n     } else {\n         Cow::Borrowed(\"\")\n     };\n-    let param = if let Some(param) = param {\n-        Cow::Owned(format!(\"= {:?}\", param))\n-    } else {\n-        Cow::Borrowed(\"-\")\n+    let params = match params {\n+        Empty => Cow::Borrowed(\"-\"),\n+        Single(param) => Cow::Owned(format!(\"= {:?}\", param)),\n+        Pair(param_a, param_b) => Cow::Owned(format!(\"= {:?}, {:?}\", param_a, param_b)),\n     };\n     let pass_mode = format!(\"{:?}\", pass_mode);\n     fx.add_global_comment(format!(\n-        \"{msg:5} {local:>3}{local_field:<5} {param:10} {pass_mode:20} {ssa:10} {ty:?}\",\n+        \"{msg:5} {local:>3}{local_field:<5} {params:10} {pass_mode:20} {ssa:10} {ty:?}\",\n         msg = msg,\n         local = format!(\"{:?}\", local),\n         local_field = local_field,\n-        param = param,\n+        params = params,\n         pass_mode = pass_mode,\n         ssa = format!(\"{:?}\", ssa),\n         ty = ty,\n@@ -347,31 +427,35 @@ fn cvalue_for_param<'a, 'tcx: 'a>(\n     ssa_flags: crate::analyze::Flags,\n ) -> Option<CValue<'tcx>> {\n     let layout = fx.layout_of(arg_ty);\n-    let pass_mode = get_pass_mode(fx.tcx, arg_ty);\n+    let pass_mode = get_pass_mode(fx.tcx, fx.layout_of(arg_ty));\n \n     if let PassMode::NoPass = pass_mode {\n         return None;\n     }\n \n-    let clif_type = pass_mode.get_param_ty(fx);\n-    let ebb_param = fx.bcx.append_ebb_param(start_ebb, clif_type);\n+    let clif_types = pass_mode.get_param_ty(fx);\n+    let ebb_params = clif_types.map(|t| fx.bcx.append_ebb_param(start_ebb, t));\n \n     #[cfg(debug_assertions)]\n     add_arg_comment(\n         fx,\n         \"arg\",\n         local,\n         local_field,\n-        Some(ebb_param),\n+        ebb_params,\n         pass_mode,\n         ssa_flags,\n         arg_ty,\n     );\n \n     match pass_mode {\n         PassMode::NoPass => unreachable!(),\n-        PassMode::ByVal(_) => Some(CValue::by_val(ebb_param, layout)),\n-        PassMode::ByRef => Some(CValue::by_ref(ebb_param, layout)),\n+        PassMode::ByVal(_) => Some(CValue::by_val(ebb_params.assert_single(), layout)),\n+        PassMode::ByValPair(_, _) => {\n+            let (a, b) = ebb_params.assert_pair();\n+            Some(CValue::by_val_pair(a, b, layout))\n+        }\n+        PassMode::ByRef => Some(CValue::by_ref(ebb_params.assert_single(), layout)),\n     }\n }\n \n@@ -384,17 +468,20 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n     #[cfg(debug_assertions)]\n     fx.add_global_comment(format!(\"ssa {:?}\", ssa_analyzed));\n \n-    let ret_layout = fx.layout_of(fx.return_type());\n-    let output_pass_mode = get_pass_mode(fx.tcx, fx.return_type());\n+    let ret_layout = fx.return_layout();\n+    let output_pass_mode = get_pass_mode(fx.tcx, fx.return_layout());\n     let ret_param = match output_pass_mode {\n-        PassMode::NoPass => None,\n-        PassMode::ByVal(_) => None,\n+        PassMode::NoPass | PassMode::ByVal(_) | PassMode::ByValPair(_, _) => None,\n         PassMode::ByRef => Some(fx.bcx.append_ebb_param(start_ebb, fx.pointer_type)),\n     };\n \n     #[cfg(debug_assertions)]\n     {\n         add_local_header_comment(fx);\n+        let ret_param = match ret_param {\n+            Some(param) => Single(param),\n+            None => Empty,\n+        };\n         add_arg_comment(\n             fx,\n             \"ret\",\n@@ -460,7 +547,7 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n             fx.local_map\n                 .insert(RETURN_PLACE, CPlace::no_place(ret_layout));\n         }\n-        PassMode::ByVal(_) => {\n+        PassMode::ByVal(_) | PassMode::ByValPair(_, _) => {\n             let is_ssa = !ssa_analyzed\n                 .get(&RETURN_PLACE)\n                 .unwrap()\n@@ -603,14 +690,14 @@ pub fn codegen_call_inner<'a, 'tcx: 'a>(\n \n     let ret_layout = fx.layout_of(fn_sig.output());\n \n-    let output_pass_mode = get_pass_mode(fx.tcx, fn_sig.output());\n+    let output_pass_mode = get_pass_mode(fx.tcx, fx.layout_of(fn_sig.output()));\n     let return_ptr = match output_pass_mode {\n         PassMode::NoPass => None,\n         PassMode::ByRef => match ret_place {\n             Some(ret_place) => Some(ret_place.to_addr(fx)),\n             None => Some(fx.bcx.ins().iconst(fx.pointer_type, 43)),\n         },\n-        PassMode::ByVal(_) => None,\n+        PassMode::ByVal(_) | PassMode::ByValPair(_, _) => None,\n     };\n \n     let instance = match fn_ty.sty {\n@@ -620,46 +707,53 @@ pub fn codegen_call_inner<'a, 'tcx: 'a>(\n         _ => None,\n     };\n \n-    //   | Indirect call target\n-    //   v         v the first argument to be passed\n-    let (func_ref, first_arg) = match instance {\n+    //   | indirect call target\n+    //   |         | the first argument to be passed\n+    //   v         v          v virtual calls are special cased below\n+    let (func_ref, first_arg, is_virtual_call) = match instance {\n         // Trait object call\n         Some(Instance {\n             def: InstanceDef::Virtual(_, idx),\n             ..\n         }) => {\n+            let nop_inst = fx.bcx.ins().nop();\n+            fx.add_comment(nop_inst, format!(\"virtual call; self arg pass mode: {:?}\", get_pass_mode(fx.tcx, args[0].layout())));\n             let (ptr, method) = crate::vtable::get_ptr_and_method_ref(fx, args[0], idx);\n-            (Some(method), Some(ptr))\n+            (Some(method), Single(ptr), true)\n         }\n \n         // Normal call\n-        Some(_) => (None, args.get(0).and_then(|arg| adjust_arg_for_abi(fx, *arg))),\n+        Some(_) => (None, args.get(0).map(|arg| adjust_arg_for_abi(fx, *arg)).unwrap_or(Empty), false),\n \n         // Indirect call\n         None => {\n+            let nop_inst = fx.bcx.ins().nop();\n+            fx.add_comment(nop_inst, \"indirect call\");\n             let func = trans_operand(fx, func.expect(\"indirect call without func Operand\"))\n                 .load_scalar(fx);\n             (\n                 Some(func),\n-                args.get(0).and_then(|arg| adjust_arg_for_abi(fx, *arg)),\n+                args.get(0).map(|arg| adjust_arg_for_abi(fx, *arg)).unwrap_or(Empty),\n+                false,\n             )\n         }\n     };\n \n     let call_args: Vec<Value> = return_ptr\n         .into_iter()\n-        .chain(first_arg)\n+        .chain(first_arg.into_iter())\n         .chain(\n             args.into_iter()\n                 .skip(1)\n-                .filter_map(|arg| adjust_arg_for_abi(fx, arg)),\n+                .map(|arg| adjust_arg_for_abi(fx, arg).into_iter())\n+                .flatten(),\n         )\n         .collect::<Vec<_>>();\n \n     let call_inst = if let Some(func_ref) = func_ref {\n         let sig = fx\n             .bcx\n-            .import_signature(clif_sig_from_fn_sig(fx.tcx, fn_sig));\n+            .import_signature(clif_sig_from_fn_sig(fx.tcx, fn_sig, is_virtual_call));\n         fx.bcx.ins().call_indirect(sig, func_ref, &call_args)\n     } else {\n         let func_ref = fx.get_function_ref(instance.expect(\"non-indirect call on non-FnDef type\"));\n@@ -694,6 +788,13 @@ pub fn codegen_call_inner<'a, 'tcx: 'a>(\n                 ret_place.write_cvalue(fx, CValue::by_val(ret_val, ret_layout));\n             }\n         }\n+        PassMode::ByValPair(_, _) => {\n+            if let Some(ret_place) = ret_place {\n+                let ret_val_a = fx.bcx.inst_results(call_inst)[0];\n+                let ret_val_b = fx.bcx.inst_results(call_inst)[1];\n+                ret_place.write_cvalue(fx, CValue::by_val_pair(ret_val_a, ret_val_b, ret_layout));\n+            }\n+        }\n         PassMode::ByRef => {}\n     }\n }\n@@ -708,19 +809,19 @@ pub fn codegen_drop<'a, 'tcx: 'a>(\n \n     let fn_sig = fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &drop_fn_ty.fn_sig(fx.tcx));\n \n-    match get_pass_mode(fx.tcx, fn_sig.output()) {\n+    match get_pass_mode(fx.tcx, fx.layout_of(fn_sig.output())) {\n         PassMode::NoPass => {}\n         _ => unreachable!(),\n     };\n \n     let sig = fx\n         .bcx\n-        .import_signature(clif_sig_from_fn_sig(fx.tcx, fn_sig));\n+        .import_signature(clif_sig_from_fn_sig(fx.tcx, fn_sig, true));\n     fx.bcx.ins().call_indirect(sig, drop_fn, &[ptr]);\n }\n \n pub fn codegen_return(fx: &mut FunctionCx<impl Backend>) {\n-    match get_pass_mode(fx.tcx, fx.return_type()) {\n+    match get_pass_mode(fx.tcx, fx.return_layout()) {\n         PassMode::NoPass | PassMode::ByRef => {\n             fx.bcx.ins().return_(&[]);\n         }\n@@ -729,5 +830,10 @@ pub fn codegen_return(fx: &mut FunctionCx<impl Backend>) {\n             let ret_val = place.to_cvalue(fx).load_scalar(fx);\n             fx.bcx.ins().return_(&[ret_val]);\n         }\n+        PassMode::ByValPair(_, _) => {\n+            let place = fx.get_local_place(RETURN_PLACE);\n+            let (ret_val_a, ret_val_b) = place.to_cvalue(fx).load_scalar_pair(fx);\n+            fx.bcx.ins().return_(&[ret_val_a, ret_val_b]);\n+        }\n     }\n }"}]}