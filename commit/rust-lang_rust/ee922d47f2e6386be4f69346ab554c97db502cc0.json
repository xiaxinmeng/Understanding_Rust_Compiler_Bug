{"sha": "ee922d47f2e6386be4f69346ab554c97db502cc0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlOTIyZDQ3ZjJlNjM4NmJlNGY2OTM0NmFiNTU0Yzk3ZGI1MDJjYzA=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-01-02T05:42:31Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-01-05T19:37:59Z"}, "message": "Fix ICE involving calling `Instance.ty` during const evaluation\n\nFixes #67639\n\n`Instance.ty` assumes that we are in a fully monomorphic context (e.g.\ncodegen), and can therefore use an empty `ParamEnv` when performing\nnormalization. Howver, the MIR constant evaluator code ends up calling\n`Instance.ty` as a result of us attemptign to 'speculatively'\nconst-evaluate generic functions during const propagation.\n\nAs a result,\nwe may end up with projections involving type parameters\n(e.g. <T as MyTrait>::Bar>) in the type we are trying to normalize.\nNormalization expects us to have proper predicates in the `ParamEnv` for\nsuch projections, and will ICE if we don't.\n\nThis commit adds a new method `Instance.ty_env`, which takes a\n`ParamEnv` for use during normalization. The MIR const-evaluator code is\nchanged to use this method, passing in the proper `ParamEnv` for the\ncontext at hand.", "tree": {"sha": "c49bfb27290b3031f2e9bbd55b7aea1e321b3ff1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c49bfb27290b3031f2e9bbd55b7aea1e321b3ff1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee922d47f2e6386be4f69346ab554c97db502cc0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl4SOxcACgkQtAh+UQ6Y\nsWQ3UA//VdNfhLFy3ocGLuyWi/d3fRrRwKeTfzMIbCyavAf0ADo7ux+uBvSqykQQ\n2REpgx/FP7h2A5Ym1GELJM/GDAseMBo5rIRRj991Ek8v+p01ale68NbYZIttc3MT\nFuMrYmY1sC3m+VQnkZPXlk2YGAkJox5rs3gqYsQAZcxqID17oZf84Tol3tdLv/3h\nGnBzxFhryqQFaLpo1npOaAfh/WxpYbVPVM5s35JmKZ8fr4eMK4KpODl7KhpN0GyE\nvZ3Inf5xE7DA7jJQrItag1YHa/0R9FsFkIqvp8bH8sWiX6yI0m0JAZLzSn+sXP3H\nIuh1xlwf3nyZxdYwVSpr5eE6pUmHOzHdYojG8671vEpyi+korC0ZmZlgqi0hC/YM\nUCeHnX802TdoLc7b0UiO8Mkoo1DJ4jrwTyIO552nfiKQDDXMCUiFparXNdos/IOQ\nvdO9O7NE1gzRDFyAF1rlKSDEjpoZwtiikpEMfyM8K9NBElNa97bF5lkTBcyouCbk\ndGF78dPQkXMHbxr6wufnVneJdekZiMcTwVjoz8iOF2PdFj1HwjhyHbh6T3t1linh\nwVM1DBRR9wYMcPgLC6ksY9AduQLlEJnuhEjOT0d94zluCPyGBjZJDKvfpOlPZnfE\nv7B7esUWXFBZ2AxJcZEcS5Kz8i7NFVNoalm1lQGt0CyJbK+Btoc=\n=ZoZl\n-----END PGP SIGNATURE-----", "payload": "tree c49bfb27290b3031f2e9bbd55b7aea1e321b3ff1\nparent b69f6e65c081f9a628ef5db83ba77e3861e60e60\nauthor Aaron Hill <aa1ronham@gmail.com> 1577943751 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1578253079 -0500\n\nFix ICE involving calling `Instance.ty` during const evaluation\n\nFixes #67639\n\n`Instance.ty` assumes that we are in a fully monomorphic context (e.g.\ncodegen), and can therefore use an empty `ParamEnv` when performing\nnormalization. Howver, the MIR constant evaluator code ends up calling\n`Instance.ty` as a result of us attemptign to 'speculatively'\nconst-evaluate generic functions during const propagation.\n\nAs a result,\nwe may end up with projections involving type parameters\n(e.g. <T as MyTrait>::Bar>) in the type we are trying to normalize.\nNormalization expects us to have proper predicates in the `ParamEnv` for\nsuch projections, and will ICE if we don't.\n\nThis commit adds a new method `Instance.ty_env`, which takes a\n`ParamEnv` for use during normalization. The MIR const-evaluator code is\nchanged to use this method, passing in the proper `ParamEnv` for the\ncontext at hand.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee922d47f2e6386be4f69346ab554c97db502cc0", "html_url": "https://github.com/rust-lang/rust/commit/ee922d47f2e6386be4f69346ab554c97db502cc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee922d47f2e6386be4f69346ab554c97db502cc0/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b69f6e65c081f9a628ef5db83ba77e3861e60e60", "url": "https://api.github.com/repos/rust-lang/rust/commits/b69f6e65c081f9a628ef5db83ba77e3861e60e60", "html_url": "https://github.com/rust-lang/rust/commit/b69f6e65c081f9a628ef5db83ba77e3861e60e60"}], "stats": {"total": 66, "additions": 64, "deletions": 2}, "files": [{"sha": "8d4717384f754a24a28bdafa0ef05d39edeb1a00", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ee922d47f2e6386be4f69346ab554c97db502cc0/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee922d47f2e6386be4f69346ab554c97db502cc0/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=ee922d47f2e6386be4f69346ab554c97db502cc0", "patch": "@@ -62,10 +62,38 @@ pub enum InstanceDef<'tcx> {\n }\n \n impl<'tcx> Instance<'tcx> {\n+    /// Returns the `Ty` corresponding to this `Instance`,\n+    /// with generic substitutions applied and lifetimes erased.\n+    ///\n+    /// This method can only be called when the 'substs' for this Instance\n+    /// are fully monomorphic (no `ty::Param`'s are present).\n+    /// This is usually the case (e.g. during codegen).\n+    /// However, during constant evaluation, we may want\n+    /// to try to resolve a `Instance` using generic parameters\n+    /// (e.g. when we are attempting to to do const-propagation).\n+    /// In this case, `Instace.ty_env` should be used to provide\n+    /// the `ParamEnv` for our generic context.\n     pub fn ty(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         let ty = tcx.type_of(self.def.def_id());\n+        // There shouldn't be any params - if there are, then\n+        // Instance.ty_env should have been used to provide the proper\n+        // ParamEnv\n+        if self.substs.has_param_types() {\n+            panic!(\n+                \"Instance.ty called for type {:?} with projections in substs: {:?}\",\n+                ty, self.substs\n+            );\n+        }\n         tcx.subst_and_normalize_erasing_regions(self.substs, ty::ParamEnv::reveal_all(), &ty)\n     }\n+\n+    /// Like `Instance.ty`, but allows a `ParamEnv` to be specified for use during\n+    /// normalization. This method is only really useful during constant evaluation,\n+    /// where we are dealing with potentially generic types.\n+    pub fn ty_env(&self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> Ty<'tcx> {\n+        let ty = tcx.type_of(self.def.def_id());\n+        tcx.subst_and_normalize_erasing_regions(self.substs, param_env, &ty)\n+    }\n }\n \n impl<'tcx> InstanceDef<'tcx> {"}, {"sha": "46e76512d35fc16d4a3cd8baca22276163da4cf6", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee922d47f2e6386be4f69346ab554c97db502cc0/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee922d47f2e6386be4f69346ab554c97db502cc0/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=ee922d47f2e6386be4f69346ab554c97db502cc0", "patch": "@@ -221,7 +221,7 @@ pub fn const_eval_validated_provider<'tcx>(\n     // We call `const_eval` for zero arg intrinsics, too, in order to cache their value.\n     // Catch such calls and evaluate them instead of trying to load a constant's MIR.\n     if let ty::InstanceDef::Intrinsic(def_id) = key.value.instance.def {\n-        let ty = key.value.instance.ty(tcx);\n+        let ty = key.value.instance.ty_env(tcx, key.param_env);\n         let substs = match ty.kind {\n             ty::FnDef(_, substs) => substs,\n             _ => bug!(\"intrinsic with type {:?}\", ty),"}, {"sha": "a28bb539fd0703f6ef8ba947b1420029e3ac84e7", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee922d47f2e6386be4f69346ab554c97db502cc0/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee922d47f2e6386be4f69346ab554c97db502cc0/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=ee922d47f2e6386be4f69346ab554c97db502cc0", "patch": "@@ -204,7 +204,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // ABI check\n         {\n             let callee_abi = {\n-                let instance_ty = instance.ty(*self.tcx);\n+                let instance_ty = instance.ty_env(*self.tcx, self.param_env);\n                 match instance_ty.kind {\n                     ty::FnDef(..) => instance_ty.fn_sig(*self.tcx).abi(),\n                     ty::Closure(..) => Abi::RustCall,"}, {"sha": "21851a725254f7943d395f2bfacfeddf875c1f9f", "filename": "src/test/ui/mir/issue-67639-normalization-ice.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ee922d47f2e6386be4f69346ab554c97db502cc0/src%2Ftest%2Fui%2Fmir%2Fissue-67639-normalization-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee922d47f2e6386be4f69346ab554c97db502cc0/src%2Ftest%2Fui%2Fmir%2Fissue-67639-normalization-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fissue-67639-normalization-ice.rs?ref=ee922d47f2e6386be4f69346ab554c97db502cc0", "patch": "@@ -0,0 +1,34 @@\n+// compile-flags: -Z mir-opt-level=3\n+// build-pass\n+\n+// This used to ICE in const-prop due\n+// to an empty ParamEnv being used during normalization\n+// of a generic type\n+\n+\n+fn main() {\n+    join_all::<u32>();\n+}\n+\n+trait Foo {\n+    type Item;\n+}\n+\n+impl Foo for u32 {\n+    type Item = u8;\n+}\n+\n+trait Bar {\n+    type Item2;\n+}\n+\n+impl Bar for u8 {\n+    type Item2 = u64;\n+}\n+\n+fn join_all<I>()\n+where I: Foo,\n+    I::Item: Bar\n+{\n+    Vec::<<I::Item as Bar>::Item2>::new(); // ICE occurs processing this line\n+}"}]}