{"sha": "81c909488eebcba16610402349563380772e0d1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxYzkwOTQ4OGVlYmNiYTE2NjEwNDAyMzQ5NTYzMzgwNzcyZTBkMWQ=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-05-29T22:09:43Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-06-15T16:06:57Z"}, "message": "Suggest substituting `'static` lifetime in impl/dyn `Trait + 'static` return types", "tree": {"sha": "872e3753a5d89ee3fb05f2e7e40be612402e9056", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/872e3753a5d89ee3fb05f2e7e40be612402e9056"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81c909488eebcba16610402349563380772e0d1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81c909488eebcba16610402349563380772e0d1d", "html_url": "https://github.com/rust-lang/rust/commit/81c909488eebcba16610402349563380772e0d1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81c909488eebcba16610402349563380772e0d1d/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "html_url": "https://github.com/rust-lang/rust/commit/ff4a2533a0720f9cdd86e02eafa3725f07aa7752"}], "stats": {"total": 261, "additions": 232, "deletions": 29}, "files": [{"sha": "88d6c23d51441693de6754854b1d082cf679a514", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 56, "deletions": 8, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/81c909488eebcba16610402349563380772e0d1d/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c909488eebcba16610402349563380772e0d1d/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=81c909488eebcba16610402349563380772e0d1d", "patch": "@@ -4,6 +4,7 @@ use crate::infer::error_reporting::msg_span_from_free_region;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use rustc_errors::{Applicability, ErrorReported};\n+use rustc_hir::{GenericBound, ItemKind, Lifetime, LifetimeName, TyKind};\n use rustc_middle::ty::RegionKind;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n@@ -20,8 +21,9 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             ) = error.clone()\n             {\n                 let anon_reg_sup = self.tcx().is_suitable_region(sup_r)?;\n-                let (fn_return_span, is_dyn) =\n-                    self.tcx().return_type_impl_or_dyn_trait(anon_reg_sup.def_id)?;\n+                let fn_return = self.tcx().return_type_impl_or_dyn_trait(anon_reg_sup.def_id)?;\n+                let is_dyn = matches!(fn_return.kind, TyKind::TraitObject(..));\n+                let fn_return_span = fn_return.span;\n                 if sub_r == &RegionKind::ReStatic {\n                     let sp = var_origin.span();\n                     let return_sp = sub_origin.span();\n@@ -67,12 +69,58 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                             lifetime,\n                         );\n                         // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n-                        err.span_suggestion_verbose(\n-                            fn_return_span.shrink_to_hi(),\n-                            &msg,\n-                            format!(\" + {}\", lifetime_name),\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                        match fn_return.kind {\n+                            TyKind::Def(item_id, _) => {\n+                                let item = self.tcx().hir().item(item_id.id);\n+                                let opaque = if let ItemKind::OpaqueTy(opaque) = &item.kind {\n+                                    opaque\n+                                } else {\n+                                    err.emit();\n+                                    return Some(ErrorReported);\n+                                };\n+                                let (span, sugg) = opaque\n+                                    .bounds\n+                                    .iter()\n+                                    .filter_map(|arg| match arg {\n+                                        GenericBound::Outlives(Lifetime {\n+                                            name: LifetimeName::Static,\n+                                            span,\n+                                            ..\n+                                        }) => Some((*span, lifetime_name.clone())),\n+                                        _ => None,\n+                                    })\n+                                    .next()\n+                                    .unwrap_or_else(|| {\n+                                        (\n+                                            fn_return_span.shrink_to_hi(),\n+                                            format!(\" + {}\", lifetime_name),\n+                                        )\n+                                    });\n+\n+                                err.span_suggestion_verbose(\n+                                    span,\n+                                    &msg,\n+                                    sugg,\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                            TyKind::TraitObject(_, lt) => {\n+                                let (span, sugg) = match lt.name {\n+                                    LifetimeName::ImplicitObjectLifetimeDefault => (\n+                                        fn_return_span.shrink_to_hi(),\n+                                        format!(\" + {}\", lifetime_name),\n+                                    ),\n+                                    _ => (lt.span, lifetime_name),\n+                                };\n+                                err.span_suggestion_verbose(\n+                                    span,\n+                                    &msg,\n+                                    sugg,\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                            _ => {}\n+                        }\n                     }\n                     err.emit();\n                     return Some(ErrorReported);"}, {"sha": "4770993d9cb07ac6f104e2d2af519de6e44e919a", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/81c909488eebcba16610402349563380772e0d1d/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c909488eebcba16610402349563380772e0d1d/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=81c909488eebcba16610402349563380772e0d1d", "patch": "@@ -1383,7 +1383,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    pub fn return_type_impl_or_dyn_trait(&self, scope_def_id: DefId) -> Option<(Span, bool)> {\n+    pub fn return_type_impl_or_dyn_trait(\n+        &self,\n+        scope_def_id: DefId,\n+    ) -> Option<&'tcx hir::Ty<'tcx>> {\n         let hir_id = self.hir().as_local_hir_id(scope_def_id.expect_local());\n         let hir_output = match self.hir().get(hir_id) {\n             Node::Item(hir::Item {\n@@ -1429,15 +1432,17 @@ impl<'tcx> TyCtxt<'tcx> {\n                 let output = self.erase_late_bound_regions(&sig.output());\n                 if output.is_impl_trait() {\n                     let fn_decl = self.hir().fn_decl_by_hir_id(hir_id).unwrap();\n-                    Some((fn_decl.output.span(), false))\n+                    if let hir::FnRetTy::Return(ty) = fn_decl.output {\n+                        return Some(ty);\n+                    }\n                 } else {\n                     let mut v = TraitObjectVisitor(vec![]);\n                     rustc_hir::intravisit::walk_ty(&mut v, hir_output);\n                     if v.0.len() == 1 {\n-                        return Some((v.0[0], true));\n+                        return Some(v.0[0]);\n                     }\n-                    None\n                 }\n+                None\n             }\n             _ => None,\n         }"}, {"sha": "3ca506fe0d59043bb49c7a1c3bbb3e8e208aeff2", "filename": "src/librustc_middle/ty/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/81c909488eebcba16610402349563380772e0d1d/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c909488eebcba16610402349563380772e0d1d/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs?ref=81c909488eebcba16610402349563380772e0d1d", "patch": "@@ -236,21 +236,21 @@ pub fn suggest_constraining_type_param(\n     }\n }\n \n-pub struct TraitObjectVisitor(pub Vec<rustc_span::Span>);\n-impl<'v> hir::intravisit::Visitor<'v> for TraitObjectVisitor {\n+pub struct TraitObjectVisitor<'tcx>(pub Vec<&'tcx hir::Ty<'tcx>>);\n+impl<'v> hir::intravisit::Visitor<'v> for TraitObjectVisitor<'v> {\n     type Map = rustc_hir::intravisit::ErasedMap<'v>;\n \n     fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n         hir::intravisit::NestedVisitorMap::None\n     }\n \n-    fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n+    fn visit_ty(&mut self, ty: &'v hir::Ty<'v>) {\n         if let hir::TyKind::TraitObject(\n             _,\n             hir::Lifetime { name: hir::LifetimeName::ImplicitObjectLifetimeDefault, .. },\n         ) = ty.kind\n         {\n-            self.0.push(ty.span);\n+            self.0.push(ty);\n         }\n     }\n }"}, {"sha": "ca9ca8a9debe2a62dfee8a8b31a77f81506bb096", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.nll.stderr", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/81c909488eebcba16610402349563380772e0d1d/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81c909488eebcba16610402349563380772e0d1d/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr?ref=81c909488eebcba16610402349563380772e0d1d", "patch": "@@ -26,7 +26,34 @@ LL | fn explicit<'a>(x: &'a i32) -> impl Copy + 'a { x }\n    |                                ^^^^^^^^^^^^^^\n \n error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:12:69\n+  --> $DIR/must_outlive_least_region_or_bound.rs:9:46\n+   |\n+LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n+   |               -                              ^ returning this value requires that `'1` must outlive `'static`\n+   |               |\n+   |               let's call the lifetime of this reference `'1`\n+   |\n+   = help: consider replacing `'1` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/must_outlive_least_region_or_bound.rs:12:55\n+   |\n+LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n+   |              -- lifetime `'a` defined here            ^ returning this value requires that `'a` must outlive `'static`\n+   |\n+   = help: consider replacing `'a` with `'static`\n+   = help: consider replacing `'a` with `'static`\n+\n+error[E0621]: explicit lifetime required in the type of `x`\n+  --> $DIR/must_outlive_least_region_or_bound.rs:15:41\n+   |\n+LL | fn foo<'a>(x: &i32) -> impl Copy + 'a { x }\n+   |               ----                      ^ lifetime `'a` required\n+   |               |\n+   |               help: add explicit lifetime `'a` to the type of `x`: `&'a i32`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/must_outlive_least_region_or_bound.rs:33:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |               -- lifetime `'a` defined here                         ^ returning this value requires that `'a` must outlive `'static`\n@@ -35,7 +62,7 @@ LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    = help: consider replacing `'a` with `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:17:61\n+  --> $DIR/must_outlive_least_region_or_bound.rs:38:61\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n    |                          --  -- lifetime `'b` defined here  ^^^^^^^^^^^^^^^^ opaque type requires that `'b` must outlive `'a`\n@@ -45,13 +72,14 @@ LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32\n    = help: consider adding the following bound: `'b: 'a`\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:22:51\n+  --> $DIR/must_outlive_least_region_or_bound.rs:43:51\n    |\n LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n    |                                                   ^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'static`...\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 8 previous errors\n \n-For more information about this error, try `rustc --explain E0310`.\n+Some errors have detailed explanations: E0310, E0621.\n+For more information about an error, try `rustc --explain E0310`."}, {"sha": "beafe9258209d29694b295fda741d8038587f2a8", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/81c909488eebcba16610402349563380772e0d1d/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c909488eebcba16610402349563380772e0d1d/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs?ref=81c909488eebcba16610402349563380772e0d1d", "patch": "@@ -6,6 +6,27 @@ fn elided(x: &i32) -> impl Copy { x }\n fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n //~^ ERROR cannot infer an appropriate lifetime\n \n+fn elided2(x: &i32) -> impl Copy + 'static { x }\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n+fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n+fn foo<'a>(x: &i32) -> impl Copy + 'a { x }\n+//~^ ERROR explicit lifetime required in the type of `x`\n+\n+fn elided3(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n+fn explicit3<'a>(x: &'a i32) -> Box<dyn Debug> { Box::new(x) }\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n+fn elided4(x: &i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n+//~^ ERROR explicit lifetime required in the type of `x`\n+\n+fn explicit4<'a>(x: &'a i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n trait LifetimeTrait<'a> {}\n impl<'a> LifetimeTrait<'a> for &'a i32 {}\n "}, {"sha": "525e271bea9c3bb937f7a165ac033fa3234b4e95", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.stderr", "status": "modified", "additions": 109, "deletions": 8, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/81c909488eebcba16610402349563380772e0d1d/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81c909488eebcba16610402349563380772e0d1d/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr?ref=81c909488eebcba16610402349563380772e0d1d", "patch": "@@ -27,21 +27,57 @@ LL | fn explicit<'a>(x: &'a i32) -> impl Copy + 'a { x }\n    |                                          ^^^^\n \n error: cannot infer an appropriate lifetime\n-  --> $DIR/must_outlive_least_region_or_bound.rs:12:69\n+  --> $DIR/must_outlive_least_region_or_bound.rs:9:46\n+   |\n+LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n+   |               ----     -------------------   ^ ...and is captured here\n+   |               |        |\n+   |               |        ...is required to be `'static` by this...\n+   |               data with this lifetime...\n+   |\n+help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 9:1\n+   |\n+LL | fn elided2(x: &i32) -> impl Copy + '_ { x }\n+   |                                    ^^\n+\n+error: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:12:55\n+   |\n+LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n+   |                     -------     -------------------   ^ ...and is captured here\n+   |                     |           |\n+   |                     |           ...is required to be `'static` by this...\n+   |                     data with this lifetime...\n+   |\n+help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the lifetime `'a` as defined on the function body at 12:14\n+   |\n+LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'a { x }\n+   |                                             ^^\n+\n+error[E0621]: explicit lifetime required in the type of `x`\n+  --> $DIR/must_outlive_least_region_or_bound.rs:15:24\n+   |\n+LL | fn foo<'a>(x: &i32) -> impl Copy + 'a { x }\n+   |               ----     ^^^^^^^^^^^^^^ lifetime `'a` required\n+   |               |\n+   |               help: add explicit lifetime `'a` to the type of `x`: `&'a i32`\n+\n+error: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:33:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |                      -------     --------------------------------   ^ ...and is captured here\n    |                      |           |\n    |                      |           ...is required to be `'static` by this...\n    |                      data with this lifetime...\n    |\n-help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the lifetime `'a` as defined on the function body at 12:15\n+help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the lifetime `'a` as defined on the function body at 33:15\n    |\n-LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static + 'a { x }\n-   |                                                                   ^^^^\n+LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'a { x }\n+   |                                                           ^^\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/must_outlive_least_region_or_bound.rs:17:61\n+  --> $DIR/must_outlive_least_region_or_bound.rs:38:61\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n    |                                                 -------     ^^^^^^^^^^^^^^^^\n@@ -50,14 +86,79 @@ LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32\n    |                                                 this parameter and the return type are declared with different lifetimes...\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:22:51\n+  --> $DIR/must_outlive_least_region_or_bound.rs:43:51\n    |\n LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n    |                                 --                ^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |                                 |\n    |                                 help: consider adding an explicit lifetime bound...: `T: 'static +`\n \n-error: aborting due to 5 previous errors\n+error: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n+   |\n+LL | fn elided3(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n+   |               ----                      ---------^-\n+   |               |                         |        |\n+   |               |                         |        ...and is captured here\n+   |               |                         ...is required to be `'static` by this...\n+   |               data with this lifetime...\n+   |\n+help: to permit non-static references in a `dyn Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 18:1\n+   |\n+LL | fn elided3(x: &i32) -> Box<dyn Debug + '_> { Box::new(x) }\n+   |                                      ^^^^\n+\n+error: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:21:59\n+   |\n+LL | fn explicit3<'a>(x: &'a i32) -> Box<dyn Debug> { Box::new(x) }\n+   |                     -------                      ---------^-\n+   |                     |                            |        |\n+   |                     |                            |        ...and is captured here\n+   |                     |                            ...is required to be `'static` by this...\n+   |                     data with this lifetime...\n+   |\n+help: to permit non-static references in a `dyn Trait` value, you can add an explicit bound for the lifetime `'a` as defined on the function body at 21:14\n+   |\n+LL | fn explicit3<'a>(x: &'a i32) -> Box<dyn Debug + 'a> { Box::new(x) }\n+   |                                               ^^^^\n+\n+error[E0621]: explicit lifetime required in the type of `x`\n+  --> $DIR/must_outlive_least_region_or_bound.rs:24:51\n+   |\n+LL | fn elided4(x: &i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n+   |               ----                                ^^^^^^^^^^^ lifetime `'static` required\n+   |               |\n+   |               help: add explicit lifetime `'static` to the type of `x`: `&'static i32`\n+\n+error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n+  --> $DIR/must_outlive_least_region_or_bound.rs:27:69\n+   |\n+LL | fn explicit4<'a>(x: &'a i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n+   |                                                                     ^\n+   |\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 27:14...\n+  --> $DIR/must_outlive_least_region_or_bound.rs:27:14\n+   |\n+LL | fn explicit4<'a>(x: &'a i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n+   |              ^^\n+note: ...so that the expression is assignable\n+  --> $DIR/must_outlive_least_region_or_bound.rs:27:69\n+   |\n+LL | fn explicit4<'a>(x: &'a i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n+   |                                                                     ^\n+   = note: expected  `&i32`\n+              found  `&'a i32`\n+   = note: but, the lifetime must be valid for the static lifetime...\n+note: ...so that the expression is assignable\n+  --> $DIR/must_outlive_least_region_or_bound.rs:27:60\n+   |\n+LL | fn explicit4<'a>(x: &'a i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n+   |                                                            ^^^^^^^^^^^\n+   = note: expected  `std::boxed::Box<(dyn std::fmt::Debug + 'static)>`\n+              found  `std::boxed::Box<dyn std::fmt::Debug>`\n+\n+error: aborting due to 12 previous errors\n \n-Some errors have detailed explanations: E0310, E0623.\n+Some errors have detailed explanations: E0310, E0495, E0621, E0623.\n For more information about an error, try `rustc --explain E0310`."}]}