{"sha": "3c398d28a42f85ea5f8fd27d9878806311f0b6ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjMzk4ZDI4YTQyZjg1ZWE1ZjhmZDI3ZDk4Nzg4MDYzMTFmMGI2ZWQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-27T02:00:11Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-28T21:24:18Z"}, "message": "rustc: Universally quantify regions when calling functions. Un-XFAIL regions-addr-of-ret.rs.", "tree": {"sha": "c4c9c170d2fae1566cace69c7716bfdaa230d684", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4c9c170d2fae1566cace69c7716bfdaa230d684"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c398d28a42f85ea5f8fd27d9878806311f0b6ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c398d28a42f85ea5f8fd27d9878806311f0b6ed", "html_url": "https://github.com/rust-lang/rust/commit/3c398d28a42f85ea5f8fd27d9878806311f0b6ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c398d28a42f85ea5f8fd27d9878806311f0b6ed/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca6636d6b689fe209a210b0eda51e368f01cdb0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca6636d6b689fe209a210b0eda51e368f01cdb0f", "html_url": "https://github.com/rust-lang/rust/commit/ca6636d6b689fe209a210b0eda51e368f01cdb0f"}], "stats": {"total": 226, "additions": 106, "deletions": 120}, "files": [{"sha": "efe01f2cbd822952a92d7f51a38497d716bd4e2d", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c398d28a42f85ea5f8fd27d9878806311f0b6ed/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c398d28a42f85ea5f8fd27d9878806311f0b6ed/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=3c398d28a42f85ea5f8fd27d9878806311f0b6ed", "patch": "@@ -834,7 +834,7 @@ impl resolve_methods for infer_ctxt {\n               }\n               _ { region }\n             }\n-        }), typ);\n+        }, false), typ);\n \n         let ur = *unresolved;\n         alt ur {"}, {"sha": "93ddbee165644054638aeb465a88c561f10a5592", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3c398d28a42f85ea5f8fd27d9878806311f0b6ed/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c398d28a42f85ea5f8fd27d9878806311f0b6ed/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=3c398d28a42f85ea5f8fd27d9878806311f0b6ed", "patch": "@@ -610,7 +610,8 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n enum fold_mode {\n     fm_var(fn@(int) -> t),\n     fm_param(fn@(uint, def_id) -> t),\n-    fm_rptr(fn@(region, bool /* under & */) -> region),\n+    fm_rptr(fn@(region, bool /* under & */) -> region,\n+            bool /* descend into outermost fn */),\n     fm_general(fn@(t) -> t),\n }\n \n@@ -622,7 +623,7 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n         alt fld {\n           fm_var(_) { if !tb.has_vars { ret ty; } }\n           fm_param(_) { if !tb.has_params { ret ty; } }\n-          fm_rptr(_) { if !tb.has_rptrs { ret ty; } }\n+          fm_rptr(_,_) { if !tb.has_rptrs { ret ty; } }\n           fm_general(_) {/* no fast path */ }\n         }\n \n@@ -678,22 +679,27 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n             ty = mk_tup(cx, new_ts);\n           }\n           ty_fn(f) {\n+            let mut new_fld;\n             alt fld {\n-              fm_rptr(_) {\n+              fm_rptr(_, false) {\n                 // Don't recurse into functions, because regions are\n                 // universally quantified, well, universally, at function\n                 // boundaries.\n+                ret ty;\n               }\n-              _ {\n-                let mut new_args: [arg] = [];\n-                for a: arg in f.inputs {\n-                    let new_ty = do_fold(cx, fld, a.ty, under_rptr);\n-                    new_args += [{mode: a.mode, ty: new_ty}];\n-                }\n-                let new_output = do_fold(cx, fld, f.output, under_rptr);\n-                ty = mk_fn(cx, {inputs: new_args, output: new_output with f});\n+              fm_rptr(f, true) {\n+                new_fld = fm_rptr(f, false);\n               }\n+              _ { new_fld = fld; }\n+            }\n+\n+            let mut new_args: [arg] = [];\n+            for a: arg in f.inputs {\n+                let new_ty = do_fold(cx, new_fld, a.ty, under_rptr);\n+                new_args += [{mode: a.mode, ty: new_ty}];\n             }\n+            let new_output = do_fold(cx, new_fld, f.output, under_rptr);\n+            ty = mk_fn(cx, {inputs: new_args, output: new_output with f});\n           }\n           ty_res(did, subty, tps) {\n             let mut new_tps = [];\n@@ -711,7 +717,7 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n           }\n           ty_rptr(r, tm) {\n             let region = alt fld {\n-                fm_rptr(folder) { folder(r, under_rptr) }\n+                fm_rptr(folder, _) { folder(r, under_rptr) }\n                 _ { r }\n             };\n             ty = mk_rptr(cx, region,"}, {"sha": "6e11e483ecfaf921eacf81133a4c4de420cf2073", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 87, "deletions": 105, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/3c398d28a42f85ea5f8fd27d9878806311f0b6ed/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c398d28a42f85ea5f8fd27d9878806311f0b6ed/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=3c398d28a42f85ea5f8fd27d9878806311f0b6ed", "patch": "@@ -80,6 +80,7 @@ type fn_ctxt =\n      infcx: infer::infer_ctxt,\n      locals: hashmap<ast::node_id, int>,\n      next_var_id: @mut int,\n+     next_region_var_id: @mut int,\n      ccx: @crate_ctxt};\n \n \n@@ -559,7 +560,7 @@ fn fixup_regions(tcx: ty::ctxt, next_region_param_id: next_region_param_id,\n             }\n             _ { region }\n         }\n-    }), ty);\n+    }, false), ty);\n }\n \n fn fixup_regions_to_block(tcx: ty::ctxt, ty: ty::t, ast_ty: @ast::ty)\n@@ -570,7 +571,7 @@ fn fixup_regions_to_block(tcx: ty::ctxt, ty: ty::t, ast_ty: @ast::ty)\n             ty::re_inferred { region }\n             _ { this_region }\n         }\n-    }), ty);\n+    }, false), ty);\n }\n \n fn ty_of_arg(tcx: ty::ctxt, mode: mode, a: ast::arg) -> ty::arg {\n@@ -621,7 +622,7 @@ fn ty_of_fn_decl(tcx: ty::ctxt,\n                     _ { /* no-op */ }\n                 };\n                 r\n-            }), arg_ty.ty);\n+            }, false), arg_ty.ty);\n         }\n \n         arg_ty\n@@ -876,7 +877,7 @@ fn fixup_self_region_in_method_ty(fcx: @fn_ctxt, mty: ty::t,\n             ty::re_self { self_region }\n             _ { r }\n         }\n-    }), mty)\n+    }, false), mty)\n }\n \n // Item collection - a pair of bootstrap passes:\n@@ -1133,15 +1134,6 @@ mod collect {\n \n // Type unification\n mod unify {\n-    fn unify_with_region_bindings(fcx: @fn_ctxt,\n-                                  _rb: @ty::unify::region_bindings,\n-                                  expected: ty::t,\n-                                  actual: ty::t)\n-            -> result<(), ty::type_err> {\n-        //let irb = ty::unify::in_region_bindings(fcx.var_bindings, rb);\n-        ret infer::mk_subty(fcx.infcx, actual, expected);\n-    }\n-\n     fn unify(fcx: @fn_ctxt, expected: ty::t, actual: ty::t) ->\n         result<(), ty::type_err> {\n         ret infer::mk_subty(fcx.infcx, actual, expected);\n@@ -1222,16 +1214,6 @@ mod demand {\n         full(fcx, sp, unify::unify, expected, actual, []);\n     }\n \n-    fn with_region_bindings(fcx: @fn_ctxt,\n-                            sp: span,\n-                            rb: @ty::unify::region_bindings,\n-                            expected: ty::t,\n-                            actual: ty::t)\n-            -> ty::t {\n-        full(fcx, sp, bind unify::unify_with_region_bindings(_, rb, _, _),\n-             expected, actual, []).ty\n-    }\n-\n     fn with_substs(fcx: @fn_ctxt, sp: span, expected: ty::t, actual: ty::t,\n                    ty_param_substs_0: [ty::t]) -> ty_param_substs_and_ty {\n         full(fcx, sp, unify::unify, expected, actual, ty_param_substs_0)\n@@ -1661,6 +1643,23 @@ type pat_ctxt = {\n     pat_region: ty::region\n };\n \n+fn count_region_params(ty: ty::t) -> uint {\n+    if (!ty::type_has_rptrs(ty)) { ret 0u; }\n+\n+    let count = @mut 0u;\n+    ty::walk_ty(ty) {|ty|\n+        alt ty::get(ty).struct {\n+            ty::ty_rptr(ty::re_param(param_id), _) {\n+                if param_id > *count {\n+                    *count = param_id;\n+                }\n+            }\n+            _ { /* no-op */ }\n+        }\n+    };\n+    ret *count;\n+}\n+\n // Replaces self, caller, or inferred regions in the given type with the given\n // region.\n fn instantiate_self_regions(tcx: ty::ctxt, region: ty::region, &&ty: ty::t)\n@@ -1671,48 +1670,39 @@ fn instantiate_self_regions(tcx: ty::ctxt, region: ty::region, &&ty: ty::t)\n                 ty::re_inferred | ty::re_self | ty::re_param(_) { region }\n                 _ { r }\n             }\n-        }), ty)\n+        }, false), ty)\n     } else {\n         ty\n     }\n }\n \n-// Replaces all region variables in the given type with \"inferred regions\".\n-// This is used during method lookup to allow typeclass implementations to\n-// refer to inferred regions.\n-fn universally_quantify_regions(tcx: ty::ctxt, ty: ty::t) -> ty::t {\n-    if ty::type_has_rptrs(ty) {\n-        ty::fold_ty(tcx, ty::fm_rptr({|_r, _under_rptr|\n-            // FIXME: Should these all be different variables?\n-            ty::re_var(0u)\n-        }), ty)\n-    } else {\n-        ty\n-    }\n+type region_env = smallintmap::smallintmap<int>;\n+\n+fn region_env() -> @region_env {\n+    ret @smallintmap::mk::<int>();\n }\n \n-// Replaces region parameter types in the given type with the appropriate\n-// bindings.\n-fn replace_region_params(tcx: ty::ctxt,\n-                         sp: span,\n-                         rb: @ty::unify::region_bindings,\n-                         ty: ty::t)\n+// Replaces all region parameters in the given type with region variables.\n+// This is used when typechecking function calls, bind expressions, and method\n+// calls.\n+fn universally_quantify_regions(fcx: @fn_ctxt, renv: @region_env, ty: ty::t)\n         -> ty::t {\n-\n     if ty::type_has_rptrs(ty) {\n-        ty::fold_ty(tcx, ty::fm_rptr({ |r, _under_rptr|\n+        ty::fold_ty(fcx.ccx.tcx, ty::fm_rptr({|r, _under_rptr|\n             alt r {\n-                ty::re_param(n) {\n-                    if n < ufind::set_count(rb.sets) {\n-                        smallintmap::get(rb.regions, ufind::find(rb.sets, n))\n-                    } else {\n-                        tcx.sess.span_err(sp, \"unresolved region\");\n-                        r\n+                ty::re_param(param_id) {\n+                    alt smallintmap::find(*renv, param_id) {\n+                        some(var_id) { ty::re_var(var_id as uint) }\n+                        none {\n+                            let var_id = next_region_var_id(fcx);\n+                            smallintmap::insert(*renv, param_id, var_id);\n+                            ty::re_var(var_id as uint)\n+                        }\n                     }\n                 }\n                 _ { r }\n             }\n-        }), ty)\n+        }, true), ty)\n     } else {\n         ty\n     }\n@@ -2189,8 +2179,17 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n                         {vars: [], ty: self_ty}\n                     };\n \n-                    self_ty = universally_quantify_regions(tcx, self_ty);\n-                    let ty = universally_quantify_regions(tcx, ty);\n+                    // Here \"self\" refers to the callee side...\n+                    let next_rid = count_region_params(self_ty);\n+                    self_ty = instantiate_self_regions(fcx.ccx.tcx,\n+                                                       ty::re_param(next_rid),\n+                                                       self_ty);\n+                    self_ty = universally_quantify_regions(fcx, region_env(),\n+                                                           self_ty);\n+\n+                    // ... and \"ty\" refers to the caller side.\n+                    let ty = universally_quantify_regions(fcx, region_env(),\n+                                                          ty);\n \n                     alt unify::unify(fcx, self_ty, ty) {\n                       result::ok(_) {\n@@ -2311,11 +2310,6 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n     check_fn(fcx.ccx, proto, decl, body, expr.id, is_loop_body, some(fcx));\n }\n \n-type check_call_or_bind_result = {\n-    bot: bool,\n-    rb: @ty::unify::region_bindings\n-};\n-\n fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                            expected: ty::t) -> bool {\n \n@@ -2325,35 +2319,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     // A generic function to factor out common logic from call and bind\n     // expressions.\n     fn check_call_or_bind(fcx: @fn_ctxt, sp: span, fty: ty::t,\n-                          args: [option<@ast::expr>])\n-            -> check_call_or_bind_result {\n-\n-        // Replaces \"caller\" regions in the arguments with the local region.\n-        fn instantiate_caller_regions(fcx: @fn_ctxt, args: [ty::arg])\n-                -> [ty::arg] {\n-\n-            ret vec::map(args) {|arg|\n-                if ty::type_has_rptrs(arg.ty) {\n-                    let ty = ty::fold_ty(fcx.ccx.tcx,\n-                                         ty::fm_rptr({|r, _under_rptr|\n-                        alt r {\n-                            ty::re_param(param) {\n-                                // FIXME: We should not recurse into nested\n-                                // function types here.\n-                                ty::re_var(param)\n-                            }\n-                            _ { r }\n-                        }\n-                    }), arg.ty);\n-                    {ty: ty with arg}\n-                } else {\n-                    arg\n-                }\n-            };\n-        }\n-\n-        let rb = ty::unify::mk_region_bindings();\n-        let unifier = bind demand::with_region_bindings(_, _, rb, _, _);\n+                          args: [option<@ast::expr>]) -> bool {\n \n         let sty = structure_of(fcx, sp, fty);\n         // Grab the argument types\n@@ -2392,9 +2358,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             arg_tys = vec::from_elem(supplied_arg_count, dummy);\n         }\n \n-        // FIXME: This should instantiate re_params instead.\n-        arg_tys = instantiate_caller_regions(fcx, arg_tys);\n-\n         // Check the arguments.\n         // We do this in a pretty awful way: first we typecheck any arguments\n         // that are not anonymous functions, then we typecheck the anonymous\n@@ -2413,7 +2376,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                     };\n                     if is_block == check_blocks {\n                         let t = arg_tys[i].ty;\n-                        bot |= check_expr_with_unifier(fcx, a, unifier, t);\n+                        bot |= check_expr_with_unifier(fcx, a, demand::simple,\n+                                                       t);\n                     }\n                   }\n                   none { }\n@@ -2422,8 +2386,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             }\n             ret bot;\n         };\n-        let bot = check_args(false) | check_args(true);\n-        ret { bot: bot, rb: rb };\n+        ret check_args(false) | check_args(true);\n     }\n \n     // A generic function for checking assignment expressions\n@@ -2437,24 +2400,25 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n     // A generic function for checking call expressions\n     fn check_call(fcx: @fn_ctxt, sp: span, f: @ast::expr, args: [@ast::expr])\n-            -> check_call_or_bind_result {\n+            -> bool {\n         let mut args_opt_0: [option<@ast::expr>] = [];\n         for arg: @ast::expr in args {\n             args_opt_0 += [some::<@ast::expr>(arg)];\n         }\n \n         let bot = check_expr(fcx, f);\n+\n+        let mut fn_ty = expr_ty(fcx.ccx.tcx, f);\n+        fn_ty = universally_quantify_regions(fcx, region_env(), fn_ty);\n+\n         // Call the generic checker.\n-        let ccobr = check_call_or_bind(fcx, sp, expr_ty(fcx.ccx.tcx, f),\n-                                       args_opt_0);\n-        ret { bot: bot | ccobr.bot with ccobr };\n+        ret check_call_or_bind(fcx, sp, fn_ty, args_opt_0) | bot;\n     }\n \n     // A generic function for doing all of the checking for call expressions\n     fn check_call_full(fcx: @fn_ctxt, sp: span, id: ast::node_id,\n                        f: @ast::expr, args: [@ast::expr]) -> bool {\n-        let ccobr = check_call(fcx, sp, f, args);\n-        let mut bot = ccobr.bot;\n+        let mut bot = check_call(fcx, sp, f, args);\n         /* need to restrict oper to being an explicit expr_path if we're\n         inside a pure function */\n         require_pure_call(fcx.ccx, fcx.purity, f, sp);\n@@ -2468,7 +2432,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           }\n           _ { fcx.ccx.tcx.sess.span_fatal(sp, \"calling non-function\"); }\n         };\n-        rt_1 = replace_region_params(fcx.ccx.tcx, f.span, ccobr.rb, rt_1);\n         write_ty(fcx.ccx.tcx, id, rt_1);\n         ret bot;\n     }\n@@ -2525,10 +2488,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let callee_id = ast_util::op_expr_callee_id(op_ex);\n         alt lookup_method(fcx, op_ex, callee_id, opname, self_t, []) {\n           some(origin) {\n-            let method_ty = ty::node_id_to_type(fcx.ccx.tcx, callee_id);\n-            let r = check_call_or_bind(fcx, op_ex.span, method_ty, args);\n+            let mut method_ty = ty::node_id_to_type(fcx.ccx.tcx, callee_id);\n+            method_ty = universally_quantify_regions(fcx, region_env(),\n+                                                     method_ty);\n+            let bot = check_call_or_bind(fcx, op_ex.span, method_ty, args);\n             fcx.ccx.method_map.insert(op_ex.id, origin);\n-            some((ty::ty_fn_ret(method_ty), r.bot))\n+            some((ty::ty_fn_ret(method_ty), bot))\n           }\n           _ { none }\n         }\n@@ -2955,8 +2920,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       ast::expr_bind(f, args) {\n         // Call the generic checker.\n         bot = check_expr(fcx, f);\n-        let ccobr = check_call_or_bind(fcx, expr.span, expr_ty(tcx, f), args);\n-        bot |= ccobr.bot;\n+\n+        let mut fn_ty = expr_ty(fcx.ccx.tcx, f);\n+        fn_ty = universally_quantify_regions(fcx, region_env(), fn_ty);\n+\n+        let ccob_bot = check_call_or_bind(fcx, expr.span, fn_ty, args);\n+        bot |= ccob_bot;\n \n         // TODO: Perform substitutions on the return type.\n \n@@ -3280,6 +3249,16 @@ fn next_ty_var(fcx: @fn_ctxt) -> ty::t {\n     ret ty::mk_var(fcx.ccx.tcx, next_ty_var_id(fcx));\n }\n \n+fn next_region_var_id(fcx: @fn_ctxt) -> int {\n+    let id = *fcx.next_region_var_id;\n+    *fcx.next_region_var_id += 1;\n+    ret id;\n+}\n+\n+fn next_region_var(fcx: @fn_ctxt) -> ty::region {\n+    ret ty::re_var(next_region_var_id(fcx) as uint);\n+}\n+\n fn bind_params(fcx: @fn_ctxt, tp: ty::t, count: uint)\n     -> {vars: [ty::t], ty: ty::t} {\n     let vars = vec::from_fn(count, {|_i| next_ty_var(fcx)});\n@@ -3409,6 +3388,7 @@ fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n           infcx: infer::new_infer_ctxt(ccx.tcx),\n           locals: int_hash::<int>(),\n           next_var_id: @mut 0,\n+          next_region_var_id: @mut 0,\n           ccx: ccx};\n     check_expr(fcx, e);\n     let cty = expr_ty(fcx.ccx.tcx, e);\n@@ -3429,6 +3409,7 @@ fn check_enum_variants(ccx: @crate_ctxt, sp: span, vs: [ast::variant],\n           infcx: infer::new_infer_ctxt(ccx.tcx),\n           locals: int_hash::<int>(),\n           next_var_id: @mut 0,\n+          next_region_var_id: @mut 0,\n           ccx: ccx};\n     let mut disr_vals: [int] = [];\n     let mut disr_val = 0;\n@@ -3616,6 +3597,7 @@ fn check_fn(ccx: @crate_ctxt,\n           infcx: gather_result.infcx,\n           locals: gather_result.locals,\n           next_var_id: gather_result.next_var_id,\n+          next_region_var_id: @mut 0,\n           ccx: ccx};\n \n     check_constraints(fcx, decl.constraints, decl.inputs);"}, {"sha": "8974af4c7c68504768045e02f6082055b90fcb10", "filename": "src/test/run-pass/regions-addr-of-ret.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c398d28a42f85ea5f8fd27d9878806311f0b6ed/src%2Ftest%2Frun-pass%2Fregions-addr-of-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c398d28a42f85ea5f8fd27d9878806311f0b6ed/src%2Ftest%2Frun-pass%2Fregions-addr-of-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-addr-of-ret.rs?ref=3c398d28a42f85ea5f8fd27d9878806311f0b6ed", "patch": "@@ -1,5 +1,3 @@\n-// xfail-test\n-\n fn f(x : &a.int) -> &a.int {\n     ret &*x;\n }"}]}