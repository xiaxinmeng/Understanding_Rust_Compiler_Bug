{"sha": "e9493d63c2a57b91556dccd219e21821432c7445", "node_id": "C_kwDOAAsO6NoAKGU5NDkzZDYzYzJhNTdiOTE1NTZkY2NkMjE5ZTIxODIxNDMyYzc0NDU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-16T19:52:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-16T19:52:45Z"}, "message": "Auto merge of #104456 - RalfJung:miri, r=RalfJung\n\nupdate Miri\n\nNot a huge sync, but there was a conflict and [josh](https://github.com/josh-project/josh/) seems to prefer those to be merged back ASAP.", "tree": {"sha": "be8277e8c7741b6ca7f5270ef2b0e4fef28619f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be8277e8c7741b6ca7f5270ef2b0e4fef28619f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9493d63c2a57b91556dccd219e21821432c7445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9493d63c2a57b91556dccd219e21821432c7445", "html_url": "https://github.com/rust-lang/rust/commit/e9493d63c2a57b91556dccd219e21821432c7445", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9493d63c2a57b91556dccd219e21821432c7445/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e69336efe035c274f2ee66922cd9cac6015956ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/e69336efe035c274f2ee66922cd9cac6015956ea", "html_url": "https://github.com/rust-lang/rust/commit/e69336efe035c274f2ee66922cd9cac6015956ea"}, {"sha": "157b2d5436c9373935ee8a904ecbe413cf0ce0ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/157b2d5436c9373935ee8a904ecbe413cf0ce0ed", "html_url": "https://github.com/rust-lang/rust/commit/157b2d5436c9373935ee8a904ecbe413cf0ce0ed"}], "stats": {"total": 721, "additions": 347, "deletions": 374}, "files": [{"sha": "c867bb4ceaa9ec6fb3e6ea2ea62e3fa082d386a8", "filename": "Cargo.lock", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e9493d63c2a57b91556dccd219e21821432c7445/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e9493d63c2a57b91556dccd219e21821432c7445/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e9493d63c2a57b91556dccd219e21821432c7445", "patch": "@@ -214,6 +214,18 @@ dependencies = [\n  \"regex-automata\",\n ]\n \n+[[package]]\n+name = \"bstr\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fca0852af221f458706eb0725c03e4ed6c46af9ac98e6a689d5e634215d594dd\"\n+dependencies = [\n+ \"memchr\",\n+ \"once_cell\",\n+ \"regex-automata\",\n+ \"serde\",\n+]\n+\n [[package]]\n name = \"build-manifest\"\n version = \"0.1.0\"\n@@ -919,25 +931,11 @@ dependencies = [\n  \"cfg-if 1.0.0\",\n ]\n \n-[[package]]\n-name = \"crossbeam\"\n-version = \"0.8.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4ae5588f6b3c3cb05239e90bd110f257254aecd01e4635400391aeae07497845\"\n-dependencies = [\n- \"cfg-if 1.0.0\",\n- \"crossbeam-channel\",\n- \"crossbeam-deque\",\n- \"crossbeam-epoch\",\n- \"crossbeam-queue\",\n- \"crossbeam-utils\",\n-]\n-\n [[package]]\n name = \"crossbeam-channel\"\n-version = \"0.5.4\"\n+version = \"0.5.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5aaa7bd5fb665c6864b5f963dd9097905c54125909c7aa94c9e18507cdbe6c53\"\n+checksum = \"c2dd04ddaf88237dc3b8d8f9a3c1004b506b54b3313403944054d23c0870c521\"\n dependencies = [\n  \"cfg-if 1.0.0\",\n  \"crossbeam-utils\",\n@@ -967,16 +965,6 @@ dependencies = [\n  \"scopeguard\",\n ]\n \n-[[package]]\n-name = \"crossbeam-queue\"\n-version = \"0.3.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1f25d8400f4a7a5778f0e4e52384a48cbd9b5c495d110786187fc750075277a2\"\n-dependencies = [\n- \"cfg-if 1.0.0\",\n- \"crossbeam-utils\",\n-]\n-\n [[package]]\n name = \"crossbeam-utils\"\n version = \"0.8.8\"\n@@ -1260,6 +1248,15 @@ version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"4443176a9f2c162692bd3d352d745ef9413eec5782a80d8fd6f8a1ac692a07f7\"\n \n+[[package]]\n+name = \"fastrand\"\n+version = \"1.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a7a407cfaa3385c4ae6b23e84623d48c2798d06e3e6a1878f7f59f17b3f86499\"\n+dependencies = [\n+ \"instant\",\n+]\n+\n [[package]]\n name = \"filetime\"\n version = \"0.2.14\"\n@@ -1584,7 +1581,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"0a1e17342619edbc21a964c2afbeb6c820c6a2560032872f397bb97ea127bd0a\"\n dependencies = [\n  \"aho-corasick\",\n- \"bstr\",\n+ \"bstr 0.2.17\",\n  \"fnv\",\n  \"log\",\n  \"regex\",\n@@ -2341,17 +2338,17 @@ dependencies = [\n \n [[package]]\n name = \"once_cell\"\n-version = \"1.12.0\"\n+version = \"1.16.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7709cef83f0c1f58f666e746a08b21e0085f7440fa6a29cc194d68aac97a4225\"\n+checksum = \"86f0b0d4bf799edbc74508c1e8bf170ff5f41238e5f8225603ca7caaae2b7860\"\n \n [[package]]\n name = \"opener\"\n version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"4ea3ebcd72a54701f56345f16785a6d3ac2df7e986d273eb4395c0b01db17952\"\n dependencies = [\n- \"bstr\",\n+ \"bstr 0.2.17\",\n  \"winapi\",\n ]\n \n@@ -3008,9 +3005,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-build-sysroot\"\n-version = \"0.3.3\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ec5f3689b6c560d6a3a17fcbe54204cd870b4fcf46342d60de16715b660d2c92\"\n+checksum = \"20c4b4625eeb148cccf82d5e9b90ad7fab3b11a0204cf75cc7fa04981a0fdffd\"\n dependencies = [\n  \"anyhow\",\n  \"rustc_version\",\n@@ -3098,9 +3095,10 @@ dependencies = [\n name = \"rustc-workspace-hack\"\n version = \"1.0.0\"\n dependencies = [\n- \"bstr\",\n+ \"bstr 0.2.17\",\n  \"clap 3.2.20\",\n  \"libz-sys\",\n+ \"rand 0.8.5\",\n  \"regex\",\n  \"serde_json\",\n  \"syn\",\n@@ -4767,13 +4765,13 @@ dependencies = [\n \n [[package]]\n name = \"tempfile\"\n-version = \"3.2.0\"\n+version = \"3.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dac1c663cfc93810f88aed9b8941d48cabf856a1b111c29a40439018d870eb22\"\n+checksum = \"5cdb1ef4eaeeaddc8fbd371e5017057064af0911902ef36b39801f67cc6d79e4\"\n dependencies = [\n  \"cfg-if 1.0.0\",\n+ \"fastrand\",\n  \"libc\",\n- \"rand 0.8.5\",\n  \"redox_syscall\",\n  \"remove_dir_all\",\n  \"winapi\",\n@@ -5119,20 +5117,22 @@ checksum = \"56dee185309b50d1f11bfedef0fe6d036842e3fb77413abef29f8f8d1c5d4c1c\"\n \n [[package]]\n name = \"ui_test\"\n-version = \"0.3.1\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7d1f546a5883ae78da735bba529ec1116661e2f73582f23920d994dc97da3a22\"\n+checksum = \"bf4559da3fe6b481f8674a29379677cb9606cd6f75fc254a2c9834c55638503d\"\n dependencies = [\n+ \"bstr 1.0.1\",\n  \"cargo_metadata 0.15.0\",\n  \"color-eyre\",\n  \"colored\",\n- \"crossbeam\",\n+ \"crossbeam-channel\",\n  \"diff\",\n  \"lazy_static\",\n  \"regex\",\n  \"rustc_version\",\n  \"serde\",\n  \"serde_json\",\n+ \"tempfile\",\n ]\n \n [[package]]"}, {"sha": "138a69974e14472d36c499d5e0a5883597876d26", "filename": "src/tools/miri/.github/workflows/ci.yml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2F.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2F.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2F.github%2Fworkflows%2Fci.yml?ref=e9493d63c2a57b91556dccd219e21821432c7445", "patch": "@@ -67,10 +67,10 @@ jobs:\n         shell: bash\n         run: |\n           if [[ ${{ github.event_name }} == 'schedule' ]]; then\n-            ./miri toolchain HEAD --host ${{ matrix.host_target }}\n-          else\n-            ./miri toolchain \"\" --host ${{ matrix.host_target }}\n+            echo \"Building against latest rustc git version\"\n+            git ls-remote https://github.com/rust-lang/rust/ HEAD | cut -f 1 > rust-version\n           fi\n+          ./miri toolchain --host ${{ matrix.host_target }}\n \n       - name: Show Rust version\n         run: |"}, {"sha": "5f46e2af0f9c3d37836b89d39b513de6ae7c1c20", "filename": "src/tools/miri/CONTRIBUTING.md", "status": "modified", "additions": 9, "deletions": 24, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCONTRIBUTING.md?ref=e9493d63c2a57b91556dccd219e21821432c7445", "patch": "@@ -150,7 +150,8 @@ is set the `MIRI_LIB_SRC` environment variable to the `library` folder of a\n `rust-lang/rust` repository checkout. Note that changing files in that directory\n does not automatically trigger a re-build of the standard library; you have to\n clear the Miri build cache manually (on Linux, `rm -rf ~/.cache/miri`;\n-and on Windows, `rmdir /S \"%LOCALAPPDATA%\\rust-lang\\miri\\cache\"`).\n+on Windows, `rmdir /S \"%LOCALAPPDATA%\\rust-lang\\miri\\cache\"`;\n+and on macOS, `rm -rf ~/Library/Caches/org.rust-lang.miri`).\n \n ### Benchmarking\n \n@@ -208,23 +209,6 @@ We described above the simplest way to get a working build environment for Miri,\n which is to use the version of rustc indicated by `rustc-version`. But\n sometimes, that is not enough.\n \n-### Updating `rustc-version`\n-\n-The `rustc-version` file is regularly updated to keep Miri close to the latest\n-version of rustc. Usually, new contributors do not have to worry about this. But\n-sometimes a newer rustc is needed for a patch, and sometimes Miri needs fixing\n-for changes in rustc. In both cases, `rustc-version` needs updating.\n-\n-To update the `rustc-version` file and install the latest rustc, you can run:\n-```\n-./miri toolchain HEAD\n-```\n-\n-Now edit Miri until `./miri test` passes, and submit a PR. Generally, it is\n-preferred to separate updating `rustc-version` and doing what it takes to get\n-Miri working again, from implementing new features that rely on the updated\n-rustc. This avoids blocking all Miri development on landing a big PR.\n-\n ### Building Miri with a locally built rustc\n \n [building Miri with a locally built rustc]: #building-miri-with-a-locally-built-rustc\n@@ -282,13 +266,13 @@ With this, you should now have a working development setup! See\n ## Advanced topic: Syncing with the rustc repo\n \n We use the [`josh` proxy](https://github.com/josh-project/josh) to transmit\n-changes between the rustc and Miri repositories. For now, a fork of josh needs to be built\n-from source. This downloads and runs josh:\n+changes between the rustc and Miri repositories. For now, the latest git version\n+of josh needs to be built from source. This downloads and runs josh:\n \n ```sh\n-git clone https://github.com/RalfJung/josh\n+git clone https://github.com/josh-project/josh\n cd josh\n-cargo run --release -p josh-proxy -- --local=$(pwd)/local --remote=https://github.com --no-background\n+cargo run --release -p josh-proxy -- --local=local --remote=https://github.com --no-background\n ```\n \n ### Importing changes from the rustc repo\n@@ -298,9 +282,10 @@ We assume we start on an up-to-date master branch in the Miri repo.\n \n ```sh\n # Fetch and merge rustc side of the history. Takes ca 5 min the first time.\n+# This will also update the 'rustc-version' file.\n ./miri rustc-pull\n-# Update toolchain reference and apply formatting.\n-./miri toolchain HEAD && ./miri fmt\n+# Update local toolchain and apply formatting.\n+./miri toolchain && ./miri fmt\n git commit -am \"rustup\"\n ```\n "}, {"sha": "3c890df08cc26d7d8c97fa52ade29d1078d24c6c", "filename": "src/tools/miri/Cargo.lock", "status": "modified", "additions": 55, "deletions": 61, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCargo.lock?ref=e9493d63c2a57b91556dccd219e21821432c7445", "patch": "@@ -64,6 +64,18 @@ version = \"1.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n \n+[[package]]\n+name = \"bstr\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fca0852af221f458706eb0725c03e4ed6c46af9ac98e6a689d5e634215d594dd\"\n+dependencies = [\n+ \"memchr\",\n+ \"once_cell\",\n+ \"regex-automata\",\n+ \"serde\",\n+]\n+\n [[package]]\n name = \"camino\"\n version = \"1.1.1\"\n@@ -145,20 +157,6 @@ dependencies = [\n  \"winapi\",\n ]\n \n-[[package]]\n-name = \"crossbeam\"\n-version = \"0.8.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2801af0d36612ae591caa9568261fddce32ce6e08a7275ea334a06a4ad021a2c\"\n-dependencies = [\n- \"cfg-if\",\n- \"crossbeam-channel\",\n- \"crossbeam-deque\",\n- \"crossbeam-epoch\",\n- \"crossbeam-queue\",\n- \"crossbeam-utils\",\n-]\n-\n [[package]]\n name = \"crossbeam-channel\"\n version = \"0.5.6\"\n@@ -169,41 +167,6 @@ dependencies = [\n  \"crossbeam-utils\",\n ]\n \n-[[package]]\n-name = \"crossbeam-deque\"\n-version = \"0.8.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"715e8152b692bba2d374b53d4875445368fdf21a94751410af607a5ac677d1fc\"\n-dependencies = [\n- \"cfg-if\",\n- \"crossbeam-epoch\",\n- \"crossbeam-utils\",\n-]\n-\n-[[package]]\n-name = \"crossbeam-epoch\"\n-version = \"0.9.10\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"045ebe27666471bb549370b4b0b3e51b07f56325befa4284db65fc89c02511b1\"\n-dependencies = [\n- \"autocfg\",\n- \"cfg-if\",\n- \"crossbeam-utils\",\n- \"memoffset\",\n- \"once_cell\",\n- \"scopeguard\",\n-]\n-\n-[[package]]\n-name = \"crossbeam-queue\"\n-version = \"0.3.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1cd42583b04998a5363558e5f9291ee5a5ff6b49944332103f251e7479a82aa7\"\n-dependencies = [\n- \"cfg-if\",\n- \"crossbeam-utils\",\n-]\n-\n [[package]]\n name = \"crossbeam-utils\"\n version = \"0.8.11\"\n@@ -243,6 +206,15 @@ dependencies = [\n  \"once_cell\",\n ]\n \n+[[package]]\n+name = \"fastrand\"\n+version = \"1.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a7a407cfaa3385c4ae6b23e84623d48c2798d06e3e6a1878f7f59f17b3f86499\"\n+dependencies = [\n+ \"instant\",\n+]\n+\n [[package]]\n name = \"getrandom\"\n version = \"0.2.7\"\n@@ -385,15 +357,6 @@ dependencies = [\n  \"libc\",\n ]\n \n-[[package]]\n-name = \"memoffset\"\n-version = \"0.6.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5aa361d4faea93603064a027415f07bd8e1d5c88c9fbf68bf56a285428fd79ce\"\n-dependencies = [\n- \"autocfg\",\n-]\n-\n [[package]]\n name = \"miniz_oxide\"\n version = \"0.5.4\"\n@@ -560,12 +523,27 @@ dependencies = [\n  \"regex-syntax\",\n ]\n \n+[[package]]\n+name = \"regex-automata\"\n+version = \"0.1.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6c230d73fb8d8c1b9c0b3135c5142a8acee3a0558fb8db5cf1cb65f8d7862132\"\n+\n [[package]]\n name = \"regex-syntax\"\n version = \"0.6.27\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a3f87b73ce11b1619a3c6332f45341e0047173771e8b8b73f87bfeefb7b56244\"\n \n+[[package]]\n+name = \"remove_dir_all\"\n+version = \"0.5.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3acd125665422973a33ac9d3dd2df85edad0f4ae9b00dafb1a05e43a9f5ef8e7\"\n+dependencies = [\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"rustc-demangle\"\n version = \"0.1.21\"\n@@ -677,6 +655,20 @@ dependencies = [\n  \"unicode-ident\",\n ]\n \n+[[package]]\n+name = \"tempfile\"\n+version = \"3.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5cdb1ef4eaeeaddc8fbd371e5017057064af0911902ef36b39801f67cc6d79e4\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"fastrand\",\n+ \"libc\",\n+ \"redox_syscall\",\n+ \"remove_dir_all\",\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"termcolor\"\n version = \"1.1.3\"\n@@ -739,20 +731,22 @@ dependencies = [\n \n [[package]]\n name = \"ui_test\"\n-version = \"0.3.1\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7d1f546a5883ae78da735bba529ec1116661e2f73582f23920d994dc97da3a22\"\n+checksum = \"bf4559da3fe6b481f8674a29379677cb9606cd6f75fc254a2c9834c55638503d\"\n dependencies = [\n+ \"bstr\",\n  \"cargo_metadata\",\n  \"color-eyre\",\n  \"colored\",\n- \"crossbeam\",\n+ \"crossbeam-channel\",\n  \"diff\",\n  \"lazy_static\",\n  \"regex\",\n  \"rustc_version\",\n  \"serde\",\n  \"serde_json\",\n+ \"tempfile\",\n ]\n \n [[package]]"}, {"sha": "65ef92e21d6b101e38fb9434c3502e1d106ee680", "filename": "src/tools/miri/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCargo.toml?ref=e9493d63c2a57b91556dccd219e21821432c7445", "patch": "@@ -40,7 +40,7 @@ libloading = \"0.7\"\n \n [dev-dependencies]\n colored = \"2\"\n-ui_test = \"0.3.1\"\n+ui_test = \"0.4\"\n rustc_version = \"0.4\"\n # Features chosen to match those required by env_logger, to avoid rebuilds\n regex = { version = \"1.5.5\", default-features = false, features = [\"perf\", \"std\"] }"}, {"sha": "e9738cbc515ff7028652b2ec0c415249e793335d", "filename": "src/tools/miri/README.md", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FREADME.md?ref=e9493d63c2a57b91556dccd219e21821432c7445", "patch": "@@ -432,7 +432,9 @@ Moreover, Miri recognizes some environment variables:\n   must point to the `library` subdirectory of a `rust-lang/rust` repository\n   checkout. Note that changing files in that directory does not automatically\n   trigger a re-build of the standard library; you have to clear the Miri build\n-  cache manually (on Linux, `rm -rf ~/.cache/miri`).\n+  cache manually (on Linux, `rm -rf ~/.cache/miri`;\n+  on Windows, `rmdir /S \"%LOCALAPPDATA%\\rust-lang\\miri\\cache\"`;\n+  and on macOS, `rm -rf ~/Library/Caches/org.rust-lang.miri`).\n * `MIRI_SYSROOT` (recognized by `cargo miri` and the Miri driver) indicates the sysroot to use. When\n   using `cargo miri`, this skips the automatic setup -- only set this if you do not want to use the\n   automatically created sysroot. For directly invoking the Miri driver, this variable (or a\n@@ -568,6 +570,15 @@ extern \"Rust\" {\n     /// program) the contents of a section of program memory, as bytes. Bytes\n     /// written using this function will emerge from the interpreter's stderr.\n     fn miri_write_to_stderr(bytes: &[u8]);\n+\n+    /// Miri-provided extern function to allocate memory from the interpreter.\n+    /// \n+    /// This is useful when no fundamental way of allocating memory is\n+    /// available, e.g. when using `no_std` + `alloc`.\n+    fn miri_alloc(size: usize, align: usize) -> *mut u8;\n+\n+    /// Miri-provided extern function to deallocate memory.\n+    fn miri_dealloc(ptr: *mut u8, size: usize, align: usize);\n }\n ```\n "}, {"sha": "3e5d388668b3e64130fea4c5700026dc2ab8cf27", "filename": "src/tools/miri/cargo-miri/Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Fcargo-miri%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Fcargo-miri%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2FCargo.lock?ref=e9493d63c2a57b91556dccd219e21821432c7445", "patch": "@@ -175,9 +175,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-build-sysroot\"\n-version = \"0.3.3\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ec5f3689b6c560d6a3a17fcbe54204cd870b4fcf46342d60de16715b660d2c92\"\n+checksum = \"20c4b4625eeb148cccf82d5e9b90ad7fab3b11a0204cf75cc7fa04981a0fdffd\"\n dependencies = [\n  \"anyhow\",\n  \"rustc_version\","}, {"sha": "ce8457469e7cf029887514a193b9691961ddc777", "filename": "src/tools/miri/cargo-miri/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Fcargo-miri%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Fcargo-miri%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2FCargo.toml?ref=e9493d63c2a57b91556dccd219e21821432c7445", "patch": "@@ -18,7 +18,7 @@ directories = \"4\"\n rustc_version = \"0.4\"\n serde_json = \"1.0.40\"\n cargo_metadata = \"0.15.0\"\n-rustc-build-sysroot = \"0.3.3\"\n+rustc-build-sysroot = \"0.4\"\n \n # A noop dependency that changes in the Rust repository, it's a bit of a hack.\n # See the `src/tools/rustc-workspace-hack/README.md` file in `rust-lang/rust`"}, {"sha": "9c179e82ba1370fe3c758a366fbac01e68a5b44a", "filename": "src/tools/miri/cargo-miri/src/setup.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fsetup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fsetup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fsetup.rs?ref=e9493d63c2a57b91556dccd219e21821432c7445", "patch": "@@ -5,7 +5,7 @@ use std::ffi::OsStr;\n use std::path::PathBuf;\n use std::process::{self, Command};\n \n-use rustc_build_sysroot::{BuildMode, Sysroot, SysrootConfig};\n+use rustc_build_sysroot::{BuildMode, SysrootBuilder, SysrootConfig};\n use rustc_version::VersionMeta;\n \n use crate::util::*;\n@@ -70,9 +70,11 @@ pub fn setup(subcommand: &MiriCommand, target: &str, rustc_version: &VersionMeta\n     let sysroot_config = if std::env::var_os(\"MIRI_NO_STD\").is_some() {\n         SysrootConfig::NoStd\n     } else {\n-        SysrootConfig::WithStd { std_features: &[\"panic_unwind\", \"backtrace\"] }\n+        SysrootConfig::WithStd {\n+            std_features: [\"panic_unwind\", \"backtrace\"].into_iter().map(Into::into).collect(),\n+        }\n     };\n-    let cargo_cmd = || {\n+    let cargo_cmd = {\n         let mut command = cargo();\n         // Use Miri as rustc to build a libstd compatible with us (and use the right flags).\n         // However, when we are running in bootstrap, we cannot just overwrite `RUSTC`,\n@@ -106,13 +108,14 @@ pub fn setup(subcommand: &MiriCommand, target: &str, rustc_version: &VersionMeta\n             command.stdout(process::Stdio::null());\n             command.stderr(process::Stdio::null());\n         }\n-        // Disable debug assertions in the standard library -- Miri is already slow enough.\n-        // But keep the overflow checks, they are cheap. This completely overwrites flags\n-        // the user might have set, which is consistent with normal `cargo build` that does\n-        // not apply `RUSTFLAGS` to the sysroot either.\n-        let rustflags = vec![\"-Cdebug-assertions=off\".into(), \"-Coverflow-checks=on\".into()];\n-        (command, rustflags)\n+\n+        command\n     };\n+    // Disable debug assertions in the standard library -- Miri is already slow enough.\n+    // But keep the overflow checks, they are cheap. This completely overwrites flags\n+    // the user might have set, which is consistent with normal `cargo build` that does\n+    // not apply `RUSTFLAGS` to the sysroot either.\n+    let rustflags = &[\"-Cdebug-assertions=off\", \"-Coverflow-checks=on\"];\n     // Make sure all target-level Miri invocations know their sysroot.\n     std::env::set_var(\"MIRI_SYSROOT\", &sysroot_dir);\n \n@@ -124,8 +127,13 @@ pub fn setup(subcommand: &MiriCommand, target: &str, rustc_version: &VersionMeta\n         // We want to be quiet, but still let the user know that something is happening.\n         eprint!(\"Preparing a sysroot for Miri (target: {target})... \");\n     }\n-    Sysroot::new(&sysroot_dir, target)\n-        .build_from_source(&rust_src, BuildMode::Check, sysroot_config, rustc_version, cargo_cmd)\n+    SysrootBuilder::new(&sysroot_dir, target)\n+        .build_mode(BuildMode::Check)\n+        .rustc_version(rustc_version.clone())\n+        .sysroot_config(sysroot_config)\n+        .rustflags(rustflags)\n+        .cargo(cargo_cmd)\n+        .build_from_source(&rust_src)\n         .unwrap_or_else(|_| {\n             if only_setup {\n                 show_error!(\"failed to build sysroot, see error details above\")"}, {"sha": "b09897c294cd17f3bf539b6a74420510f44e3d18", "filename": "src/tools/miri/miri", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Fmiri", "raw_url": "https://github.com/rust-lang/rust/raw/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Fmiri", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fmiri?ref=e9493d63c2a57b91556dccd219e21821432c7445", "patch": "@@ -42,21 +42,21 @@ many different seeds.\n Runs the benchmarks from bench-cargo-miri in hyperfine. hyperfine needs to be installed.\n <benches> can explicitly list the benchmarks to run; by default, all of them are run.\n \n+./miri toolchain <flags>:\n+Update and activate the rustup toolchain 'miri' to the commit given in the\n+`rust-version` file.\n+`rustup-toolchain-install-master` must be installed for this to work. Any extra\n+flags are passed to `rustup-toolchain-install-master`.\n+\n ./miri rustc-pull:\n-Pull and merge Miri changes from the rustc repo.\n+Pull and merge Miri changes from the rustc repo. The fetched commit is stored in\n+the `rust-version` file, so the next `./miri toolchain` will install the rustc\n+we just pulled.\n \n ./miri rustc-push <github user> <branch>:\n-Push Miri changes back to the rustc repo. This will update the 'master' branch\n-in the Rust fork of the given user to upstream. It will also pull a copy of the\n-rustc history into the Miri repo, unless you set the RUSTC_GIT env var to an\n-existing clone of the rustc repo.\n-\n-./miri toolchain <commit> <flags>:\n-Update and activate the rustup toolchain 'miri'. If no commit is given, updates\n-to the commit given in the `rust-version` file. If the commit is `HEAD`, updates\n-to the latest upstream rustc commit.\n-`rustup-toolchain-install-master` must be installed for this to work. Any extra\n-flags are passed to `rustup-toolchain-install-master`.\n+Push Miri changes back to the rustc repo. This will pull a copy of the rustc\n+history into the Miri repo, unless you set the RUSTC_GIT env var to an existing\n+clone of the rustc repo.\n \n   ENVIRONMENT VARIABLES\n \n@@ -78,29 +78,20 @@ shift\n # macOS does not have a useful readlink/realpath so we have to use Python instead...\n MIRIDIR=$(python3 -c 'import os, sys; print(os.path.dirname(os.path.realpath(sys.argv[1])))' \"$0\")\n # Used for rustc syncs.\n-JOSH_FILTER=\":at_commit=75dd959a3a40eb5b4574f8d2e23aa6efbeb33573[:prefix=src/tools/miri]:/src/tools/miri\"\n+JOSH_FILTER=\":rev(75dd959a3a40eb5b4574f8d2e23aa6efbeb33573:prefix=src/tools/miri):/src/tools/miri\"\n # Needed for `./miri bench`.\n TOOLCHAIN=$(cd \"$MIRIDIR\"; rustup show active-toolchain | head -n 1 | cut -d ' ' -f 1)\n \n ## Early commands, that don't do auto-things and don't want the environment-altering things happening below.\n case \"$COMMAND\" in\n toolchain)\n     cd \"$MIRIDIR\"\n+    NEW_COMMIT=$(cat rust-version)\n     # Make sure rustup-toolchain-install-master is installed.\n     if ! which rustup-toolchain-install-master >/dev/null; then\n         echo \"Please install rustup-toolchain-install-master by running 'cargo install rustup-toolchain-install-master'\"\n         exit 1\n     fi\n-    # Determine new commit.\n-    if [[ \"$1\" == \"\" ]]; then\n-        NEW_COMMIT=$(cat rust-version)\n-    elif [[ \"$1\" == \"HEAD\" ]]; then\n-        NEW_COMMIT=$(git ls-remote https://github.com/rust-lang/rust/ HEAD | cut -f 1)\n-    else\n-        NEW_COMMIT=\"$1\"\n-    fi\n-    echo \"$NEW_COMMIT\" > rust-version\n-    shift || true # don't fail if shifting fails because no commit was given\n     # Check if we already are at that commit.\n     CUR_COMMIT=$(rustc +miri --version -v 2>/dev/null | grep \"^commit-hash: \" | cut -d \" \" -f 2)\n     if [[ \"$CUR_COMMIT\" == \"$NEW_COMMIT\" ]]; then\n@@ -122,8 +113,18 @@ toolchain)\n     ;;\n rustc-pull)\n     cd \"$MIRIDIR\"\n+    FETCH_COMMIT=$(git ls-remote https://github.com/rust-lang/rust/ HEAD | cut -f 1)\n+    # We can't pull from a commit with josh\n+    # (https://github.com/josh-project/josh/issues/1034), so we just hope that\n+    # nothing gets merged into rustc *during* this pull.\n     git fetch http://localhost:8000/rust-lang/rust.git$JOSH_FILTER.git master\n+    # Just verify that `master` didn't move.\n+    if [[ $FETCH_COMMIT != $(git ls-remote https://github.com/rust-lang/rust/ HEAD | cut -f 1) ]]; then\n+        echo \"Looks like something got merged into Rust *while we were pulling*. Aborting. Please try again.\"\n+    fi\n+    echo \"$FETCH_COMMIT\" > rust-version # do this *before* merging as merging will fail in case of conflicts\n     git merge FETCH_HEAD --no-ff -m \"Merge from rustc\"\n+    git commit rust-version --amend -m \"Merge from rustc\"\n     exit 0\n     ;;\n rustc-push)\n@@ -145,19 +146,21 @@ rustc-push)\n         fi\n         cd \"$MIRIDIR\"\n     fi\n-    # Prepare the branches. For reliable pushing we need to push to a non-existent branch\n-    # and set `-o base` to a branch that holds current rustc master.\n-    echo \"Preparing $USER/rust...\"\n-    if git fetch https://github.com/$USER/rust $BRANCH &>/dev/null; then\n-        echo \"The '$BRANCH' seems to already exist in $USER/rust. Please delete it and try again.\"\n+    # Prepare the branch. Pushing works much better if we use as base exactly\n+    # the commit that we pulled from last time, so we use the `rust-version`\n+    # file as a good approximation of that.\n+    BASE=$(cat \"$MIRIDIR/rust-version\")\n+    echo \"Preparing $USER/rust (base: $BASE)...\"\n+    if git fetch \"https://github.com/$USER/rust\" \"$BRANCH\" &>/dev/null; then\n+        echo \"The branch '$BRANCH' seems to already exist in 'https://github.com/$USER/rust'. Please delete it and try again.\"\n         exit 1\n     fi\n-    git fetch https://github.com/rust-lang/rust master\n-    git push https://github.com/$USER/rust FETCH_HEAD:master\n+    git fetch https://github.com/rust-lang/rust $BASE\n+    git push https://github.com/$USER/rust $BASE:refs/heads/$BRANCH -f\n     # Do the actual push.\n     cd \"$MIRIDIR\"\n     echo \"Pushing Miri changes...\"\n-    git push http://localhost:8000/$USER/rust.git$JOSH_FILTER.git HEAD:$BRANCH -o base=master\n+    git push http://localhost:8000/$USER/rust.git$JOSH_FILTER.git HEAD:$BRANCH\n     exit 0\n     ;;\n many-seeds)"}, {"sha": "746fcb2e183c656781a766a8266d4207113f666e", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=e9493d63c2a57b91556dccd219e21821432c7445", "patch": "@@ -1 +1 @@\n-b03502b35d111bef0399a66ab3cc765f0802e8ba\n+101e1822c3e54e63996c8aaa014d55716f3937eb"}, {"sha": "b0f766462127fcec5f5da8793707a282a1c93f3d", "filename": "src/tools/miri/src/concurrency/data_race.rs", "status": "modified", "additions": 5, "deletions": 29, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs?ref=e9493d63c2a57b91556dccd219e21821432c7445", "patch": "@@ -49,7 +49,7 @@ use std::{\n use rustc_ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::{mir, ty::layout::TyAndLayout};\n+use rustc_middle::mir;\n use rustc_target::abi::{Align, Size};\n \n use crate::*;\n@@ -440,33 +440,6 @@ impl MemoryCellClocks {\n /// Evaluation context extensions.\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for MiriInterpCx<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n-    /// Atomic variant of read_scalar_at_offset.\n-    fn read_scalar_at_offset_atomic(\n-        &self,\n-        op: &OpTy<'tcx, Provenance>,\n-        offset: u64,\n-        layout: TyAndLayout<'tcx>,\n-        atomic: AtomicReadOrd,\n-    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n-        let this = self.eval_context_ref();\n-        let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n-        this.read_scalar_atomic(&value_place, atomic)\n-    }\n-\n-    /// Atomic variant of write_scalar_at_offset.\n-    fn write_scalar_at_offset_atomic(\n-        &mut self,\n-        op: &OpTy<'tcx, Provenance>,\n-        offset: u64,\n-        value: impl Into<Scalar<Provenance>>,\n-        layout: TyAndLayout<'tcx>,\n-        atomic: AtomicWriteOrd,\n-    ) -> InterpResult<'tcx> {\n-        let this = self.eval_context_mut();\n-        let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n-        this.write_scalar_atomic(value.into(), &value_place, atomic)\n-    }\n-\n     /// Perform an atomic read operation at the memory location.\n     fn read_scalar_atomic(\n         &self,\n@@ -713,7 +686,10 @@ impl VClockAlloc {\n         let (alloc_timestamp, alloc_index) = match kind {\n             // User allocated and stack memory should track allocation.\n             MemoryKind::Machine(\n-                MiriMemoryKind::Rust | MiriMemoryKind::C | MiriMemoryKind::WinHeap,\n+                MiriMemoryKind::Rust\n+                | MiriMemoryKind::Miri\n+                | MiriMemoryKind::C\n+                | MiriMemoryKind::WinHeap,\n             )\n             | MemoryKind::Stack => {\n                 let (alloc_index, clocks) = global.current_thread_state(thread_mgr);"}, {"sha": "dc4b435b7101ca1bad35fee51959de80b3691f81", "filename": "src/tools/miri/src/concurrency/sync.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs?ref=e9493d63c2a57b91556dccd219e21821432c7445", "patch": "@@ -193,8 +193,9 @@ impl<'mir, 'tcx: 'mir> EvalContextExtPriv<'mir, 'tcx> for crate::MiriInterpCx<'m\n pub(super) trait EvalContextExtPriv<'mir, 'tcx: 'mir>:\n     crate::MiriInterpCxExt<'mir, 'tcx>\n {\n+    /// Lazily initialize the ID of this Miri sync structure.\n+    /// ('0' indicates uninit.)\n     #[inline]\n-    // Miri sync structures contain zero-initialized ids stored at some offset behind a pointer\n     fn get_or_create_id<Id: SyncId>(\n         &mut self,\n         next_id: Id,\n@@ -205,6 +206,7 @@ pub(super) trait EvalContextExtPriv<'mir, 'tcx: 'mir>:\n         let value_place =\n             this.deref_operand_and_offset(lock_op, offset, this.machine.layouts.u32)?;\n \n+        // Since we are lazy, this update has to be atomic.\n         let (old, success) = this\n             .atomic_compare_exchange_scalar(\n                 &value_place,"}, {"sha": "cd5e989b43482b6661c0c5b9e8cf25f0fd48d1e7", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=e9493d63c2a57b91556dccd219e21821432c7445", "patch": "@@ -668,7 +668,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         layout: TyAndLayout<'tcx>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, Provenance>> {\n         let this = self.eval_context_ref();\n-        let op_place = this.deref_operand(op)?;\n+        let op_place = this.deref_operand(op)?; // FIXME: we still deref with the original type!\n         let offset = Size::from_bytes(offset);\n \n         // Ensure that the access is within bounds.\n@@ -688,25 +688,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.read_scalar(&value_place.into())\n     }\n \n-    fn write_immediate_at_offset(\n-        &mut self,\n-        op: &OpTy<'tcx, Provenance>,\n-        offset: u64,\n-        value: &ImmTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, ()> {\n-        let this = self.eval_context_mut();\n-        let value_place = this.deref_operand_and_offset(op, offset, value.layout)?;\n-        this.write_immediate(**value, &value_place.into())\n-    }\n-\n     fn write_scalar_at_offset(\n         &mut self,\n         op: &OpTy<'tcx, Provenance>,\n         offset: u64,\n         value: impl Into<Scalar<Provenance>>,\n         layout: TyAndLayout<'tcx>,\n     ) -> InterpResult<'tcx, ()> {\n-        self.write_immediate_at_offset(op, offset, &ImmTy::from_scalar(value.into(), layout))\n+        let this = self.eval_context_mut();\n+        let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n+        this.write_scalar(value, &value_place.into())\n     }\n \n     /// Parse a `timespec` struct and return it as a `std::time::Duration`. It returns `None`"}, {"sha": "8243ccd90a3661f115ddaa9e249d309207b334d0", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=e9493d63c2a57b91556dccd219e21821432c7445", "patch": "@@ -77,6 +77,8 @@ impl VisitTags for FrameData<'_> {\n pub enum MiriMemoryKind {\n     /// `__rust_alloc` memory.\n     Rust,\n+    /// `miri_alloc` memory.\n+    Miri,\n     /// `malloc` memory.\n     C,\n     /// Windows `HeapAlloc` memory.\n@@ -110,7 +112,7 @@ impl MayLeak for MiriMemoryKind {\n     fn may_leak(self) -> bool {\n         use self::MiriMemoryKind::*;\n         match self {\n-            Rust | C | WinHeap | Runtime => false,\n+            Rust | Miri | C | WinHeap | Runtime => false,\n             Machine | Global | ExternStatic | Tls => true,\n         }\n     }\n@@ -121,6 +123,7 @@ impl fmt::Display for MiriMemoryKind {\n         use self::MiriMemoryKind::*;\n         match self {\n             Rust => write!(f, \"Rust heap\"),\n+            Miri => write!(f, \"Miri bare-metal heap\"),\n             C => write!(f, \"C heap\"),\n             WinHeap => write!(f, \"Windows heap\"),\n             Machine => write!(f, \"machine-managed memory\"),"}, {"sha": "058f730833bb41983685d7cadc644ae6f4e7c1ba", "filename": "src/tools/miri/src/shims/foreign_items.rs", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs?ref=e9493d63c2a57b91556dccd219e21821432c7445", "patch": "@@ -513,22 +513,37 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             }\n \n             // Rust allocation\n-            \"__rust_alloc\" => {\n+            \"__rust_alloc\" | \"miri_alloc\" => {\n                 let [size, align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n \n-                return this.emulate_allocator(Symbol::intern(\"__rg_alloc\"), |this| {\n+                let default = |this: &mut MiriInterpCx<'mir, 'tcx>| {\n                     Self::check_alloc_request(size, align)?;\n \n+                    let memory_kind = match link_name.as_str() {\n+                        \"__rust_alloc\" => MiriMemoryKind::Rust,\n+                        \"miri_alloc\" => MiriMemoryKind::Miri,\n+                        _ => unreachable!(),\n+                    };\n+\n                     let ptr = this.allocate_ptr(\n                         Size::from_bytes(size),\n                         Align::from_bytes(align).unwrap(),\n-                        MiriMemoryKind::Rust.into(),\n+                        memory_kind.into(),\n                     )?;\n \n                     this.write_pointer(ptr, dest)\n-                });\n+                };\n+\n+                match link_name.as_str() {\n+                    \"__rust_alloc\" => return this.emulate_allocator(Symbol::intern(\"__rg_alloc\"), default),\n+                    \"miri_alloc\" => {\n+                        default(this)?;\n+                        return Ok(EmulateByNameResult::NeedsJumping);\n+                    },\n+                    _ => unreachable!(),\n+                }\n             }\n             \"__rust_alloc_zeroed\" => {\n                 let [size, align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n@@ -549,20 +564,35 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     this.write_pointer(ptr, dest)\n                 });\n             }\n-            \"__rust_dealloc\" => {\n+            \"__rust_dealloc\" | \"miri_dealloc\" => {\n                 let [ptr, old_size, align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n                 let old_size = this.read_scalar(old_size)?.to_machine_usize(this)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n \n-                return this.emulate_allocator(Symbol::intern(\"__rg_dealloc\"), |this| {\n+                let default = |this: &mut MiriInterpCx<'mir, 'tcx>| {\n+                    let memory_kind = match link_name.as_str() {\n+                        \"__rust_dealloc\" => MiriMemoryKind::Rust,\n+                        \"miri_dealloc\" => MiriMemoryKind::Miri,\n+                        _ => unreachable!(),\n+                    };\n+\n                     // No need to check old_size/align; we anyway check that they match the allocation.\n                     this.deallocate_ptr(\n                         ptr,\n                         Some((Size::from_bytes(old_size), Align::from_bytes(align).unwrap())),\n-                        MiriMemoryKind::Rust.into(),\n+                        memory_kind.into(),\n                     )\n-                });\n+                };\n+\n+                match link_name.as_str() {\n+                    \"__rust_dealloc\" => return this.emulate_allocator(Symbol::intern(\"__rg_dealloc\"), default),\n+                    \"miri_dealloc\" => {\n+                        default(this)?;\n+                        return Ok(EmulateByNameResult::NeedsJumping);\n+                    }\n+                    _ => unreachable!(),\n+                }\n             }\n             \"__rust_realloc\" => {\n                 let [ptr, old_size, align, new_size] = this.check_shim(abi, Abi::Rust, link_name, args)?;"}, {"sha": "e0afb500cb18a99cb4309ec40dbd08f91975ee94", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 82, "deletions": 133, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=e9493d63c2a57b91556dccd219e21821432c7445", "patch": "@@ -1,8 +1,5 @@\n use std::time::SystemTime;\n \n-use rustc_hir::LangItem;\n-use rustc_middle::ty::{layout::TyAndLayout, query::TyCtxtAt, Ty};\n-\n use crate::concurrency::sync::CondvarLock;\n use crate::concurrency::thread::{MachineCallback, Time};\n use crate::*;\n@@ -20,39 +17,34 @@ use crate::*;\n /// in `pthread_mutexattr_settype` function.\n const PTHREAD_MUTEX_NORMAL_FLAG: i32 = 0x8000000;\n \n-const MUTEX_ID_OFFSET: u64 = 4;\n-const RWLOCK_ID_OFFSET: u64 = 4;\n-const CONDVAR_ID_OFFSET: u64 = 4;\n-\n fn is_mutex_kind_default<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n-    kind: Scalar<Provenance>,\n+    kind: i32,\n ) -> InterpResult<'tcx, bool> {\n-    Ok(kind == ecx.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?)\n+    Ok(kind == ecx.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")?)\n }\n \n fn is_mutex_kind_normal<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n-    kind: Scalar<Provenance>,\n+    kind: i32,\n ) -> InterpResult<'tcx, bool> {\n-    let kind = kind.to_i32()?;\n-    let mutex_normal_kind = ecx.eval_libc(\"PTHREAD_MUTEX_NORMAL\")?.to_i32()?;\n+    let mutex_normal_kind = ecx.eval_libc_i32(\"PTHREAD_MUTEX_NORMAL\")?;\n     Ok(kind == (mutex_normal_kind | PTHREAD_MUTEX_NORMAL_FLAG))\n }\n \n fn mutexattr_get_kind<'mir, 'tcx: 'mir>(\n     ecx: &MiriInterpCx<'mir, 'tcx>,\n     attr_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, Scalar<Provenance>> {\n-    ecx.read_scalar_at_offset(attr_op, 0, ecx.machine.layouts.i32)\n+) -> InterpResult<'tcx, i32> {\n+    ecx.read_scalar_at_offset(attr_op, 0, ecx.machine.layouts.i32)?.to_i32()\n }\n \n fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     attr_op: &OpTy<'tcx, Provenance>,\n-    kind: impl Into<Scalar<Provenance>>,\n+    kind: i32,\n ) -> InterpResult<'tcx, ()> {\n-    ecx.write_scalar_at_offset(attr_op, 0, kind, layout_of_maybe_uninit(ecx.tcx, ecx.tcx.types.i32))\n+    ecx.write_scalar_at_offset(attr_op, 0, Scalar::from_i32(kind), ecx.machine.layouts.i32)\n }\n \n // pthread_mutex_t is between 24 and 48 bytes, depending on the platform.\n@@ -64,53 +56,35 @@ fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n // bytes 12-15 or 16-19 (depending on platform): mutex kind, as an i32\n // (the kind has to be at its offset for compatibility with static initializer macros)\n \n-fn mutex_get_kind<'mir, 'tcx: 'mir>(\n-    ecx: &MiriInterpCx<'mir, 'tcx>,\n+fn mutex_get_id<'mir, 'tcx: 'mir>(\n+    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, Scalar<Provenance>> {\n-    let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n-    ecx.read_scalar_at_offset_atomic(\n-        mutex_op,\n-        offset,\n-        ecx.machine.layouts.i32,\n-        AtomicReadOrd::Relaxed,\n-    )\n+) -> InterpResult<'tcx, MutexId> {\n+    ecx.mutex_get_or_create_id(mutex_op, 4)\n }\n \n-fn mutex_set_kind<'mir, 'tcx: 'mir>(\n+fn mutex_reset_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Provenance>,\n-    kind: impl Into<Scalar<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n-    let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n-    ecx.write_scalar_at_offset_atomic(\n-        mutex_op,\n-        offset,\n-        kind,\n-        layout_of_maybe_uninit(ecx.tcx, ecx.tcx.types.i32),\n-        AtomicWriteOrd::Relaxed,\n-    )\n+    ecx.write_scalar_at_offset(mutex_op, 4, Scalar::from_i32(0), ecx.machine.layouts.u32)\n }\n \n-fn mutex_get_id<'mir, 'tcx: 'mir>(\n+fn mutex_get_kind<'mir, 'tcx: 'mir>(\n     ecx: &MiriInterpCx<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, Scalar<Provenance>> {\n-    ecx.read_scalar_at_offset_atomic(mutex_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n+) -> InterpResult<'tcx, i32> {\n+    let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n+    ecx.read_scalar_at_offset(mutex_op, offset, ecx.machine.layouts.i32)?.to_i32()\n }\n \n-fn mutex_set_id<'mir, 'tcx: 'mir>(\n+fn mutex_set_kind<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Provenance>,\n-    id: impl Into<Scalar<Provenance>>,\n+    kind: i32,\n ) -> InterpResult<'tcx, ()> {\n-    ecx.write_scalar_at_offset_atomic(\n-        mutex_op,\n-        4,\n-        id,\n-        layout_of_maybe_uninit(ecx.tcx, ecx.tcx.types.u32),\n-        AtomicWriteOrd::Relaxed,\n-    )\n+    let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n+    ecx.write_scalar_at_offset(mutex_op, offset, Scalar::from_i32(kind), ecx.machine.layouts.i32)\n }\n \n // pthread_rwlock_t is between 32 and 56 bytes, depending on the platform.\n@@ -121,10 +95,10 @@ fn mutex_set_id<'mir, 'tcx: 'mir>(\n // bytes 4-7: rwlock id as u32 or 0 if id is not assigned yet.\n \n fn rwlock_get_id<'mir, 'tcx: 'mir>(\n-    ecx: &MiriInterpCx<'mir, 'tcx>,\n+    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     rwlock_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, Scalar<Provenance>> {\n-    ecx.read_scalar_at_offset_atomic(rwlock_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n+) -> InterpResult<'tcx, RwLockId> {\n+    ecx.rwlock_get_or_create_id(rwlock_op, 4)\n }\n \n // pthread_condattr_t\n@@ -136,21 +110,16 @@ fn rwlock_get_id<'mir, 'tcx: 'mir>(\n fn condattr_get_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriInterpCx<'mir, 'tcx>,\n     attr_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, Scalar<Provenance>> {\n-    ecx.read_scalar_at_offset(attr_op, 0, ecx.machine.layouts.i32)\n+) -> InterpResult<'tcx, i32> {\n+    ecx.read_scalar_at_offset(attr_op, 0, ecx.machine.layouts.i32)?.to_i32()\n }\n \n fn condattr_set_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     attr_op: &OpTy<'tcx, Provenance>,\n-    clock_id: impl Into<Scalar<Provenance>>,\n+    clock_id: i32,\n ) -> InterpResult<'tcx, ()> {\n-    ecx.write_scalar_at_offset(\n-        attr_op,\n-        0,\n-        clock_id,\n-        layout_of_maybe_uninit(ecx.tcx, ecx.machine.layouts.i32.ty),\n-    )\n+    ecx.write_scalar_at_offset(attr_op, 0, Scalar::from_i32(clock_id), ecx.machine.layouts.i32)\n }\n \n // pthread_cond_t\n@@ -163,44 +132,32 @@ fn condattr_set_clock_id<'mir, 'tcx: 'mir>(\n // bytes 8-11: the clock id constant as i32\n \n fn cond_get_id<'mir, 'tcx: 'mir>(\n-    ecx: &MiriInterpCx<'mir, 'tcx>,\n+    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, Scalar<Provenance>> {\n-    ecx.read_scalar_at_offset_atomic(cond_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n+) -> InterpResult<'tcx, CondvarId> {\n+    ecx.condvar_get_or_create_id(cond_op, 4)\n }\n \n-fn cond_set_id<'mir, 'tcx: 'mir>(\n+fn cond_reset_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Provenance>,\n-    id: impl Into<Scalar<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n-    ecx.write_scalar_at_offset_atomic(\n-        cond_op,\n-        4,\n-        id,\n-        layout_of_maybe_uninit(ecx.tcx, ecx.tcx.types.u32),\n-        AtomicWriteOrd::Relaxed,\n-    )\n+    ecx.write_scalar_at_offset(cond_op, 4, Scalar::from_i32(0), ecx.machine.layouts.u32)\n }\n \n fn cond_get_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriInterpCx<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, Scalar<Provenance>> {\n-    ecx.read_scalar_at_offset(cond_op, 8, ecx.machine.layouts.i32)\n+) -> InterpResult<'tcx, i32> {\n+    ecx.read_scalar_at_offset(cond_op, 8, ecx.machine.layouts.i32)?.to_i32()\n }\n \n fn cond_set_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Provenance>,\n-    clock_id: impl Into<Scalar<Provenance>>,\n+    clock_id: i32,\n ) -> InterpResult<'tcx, ()> {\n-    ecx.write_scalar_at_offset(\n-        cond_op,\n-        8,\n-        clock_id,\n-        layout_of_maybe_uninit(ecx.tcx, ecx.tcx.types.i32),\n-    )\n+    ecx.write_scalar_at_offset(cond_op, 8, Scalar::from_i32(clock_id), ecx.machine.layouts.i32)\n }\n \n /// Try to reacquire the mutex associated with the condition variable after we\n@@ -260,7 +217,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let default_kind = this.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?;\n+        let default_kind = this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")?;\n         mutexattr_set_kind(this, attr_op, default_kind)?;\n \n         Ok(0)\n@@ -273,8 +230,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let kind = this.read_scalar(kind_op)?;\n-        if kind == this.eval_libc(\"PTHREAD_MUTEX_NORMAL\")? {\n+        let kind = this.read_scalar(kind_op)?.to_i32()?;\n+        if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_NORMAL\")? {\n             // In `glibc` implementation, the numeric values of\n             // `PTHREAD_MUTEX_NORMAL` and `PTHREAD_MUTEX_DEFAULT` are equal.\n             // However, a mutex created by explicitly passing\n@@ -287,16 +244,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             // use the same trick as glibc: for the case when\n             // `pthread_mutexattr_settype` is caled explicitly, we set the\n             // `PTHREAD_MUTEX_NORMAL_FLAG` flag.\n-            let normal_kind = kind.to_i32()? | PTHREAD_MUTEX_NORMAL_FLAG;\n+            let normal_kind = kind | PTHREAD_MUTEX_NORMAL_FLAG;\n             // Check that after setting the flag, the kind is distinguishable\n             // from all other kinds.\n-            assert_ne!(normal_kind, this.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?.to_i32()?);\n-            assert_ne!(normal_kind, this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")?.to_i32()?);\n-            assert_ne!(normal_kind, this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")?.to_i32()?);\n-            mutexattr_set_kind(this, attr_op, Scalar::from_i32(normal_kind))?;\n-        } else if kind == this.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?\n-            || kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")?\n-            || kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")?\n+            assert_ne!(normal_kind, this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")?);\n+            assert_ne!(normal_kind, this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")?);\n+            assert_ne!(normal_kind, this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")?);\n+            mutexattr_set_kind(this, attr_op, normal_kind)?;\n+        } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")?\n+            || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")?\n+            || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")?\n         {\n             mutexattr_set_kind(this, attr_op, kind)?;\n         } else {\n@@ -342,13 +299,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let attr = this.read_pointer(attr_op)?;\n         let kind = if this.ptr_is_null(attr)? {\n-            this.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?\n+            this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")?\n         } else {\n             mutexattr_get_kind(this, attr_op)?\n         };\n \n         // Write 0 to use the same code path as the static initializers.\n-        mutex_set_id(this, mutex_op, Scalar::from_i32(0))?;\n+        mutex_reset_id(this, mutex_op)?;\n \n         mutex_set_kind(this, mutex_op, kind)?;\n \n@@ -359,7 +316,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?;\n-        let id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n+        let id = mutex_get_id(this, mutex_op)?;\n         let active_thread = this.get_active_thread();\n \n         if this.mutex_is_locked(id) {\n@@ -374,9 +331,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     throw_ub_format!(\"trying to acquire already locked default mutex\");\n                 } else if is_mutex_kind_normal(this, kind)? {\n                     throw_machine_stop!(TerminationInfo::Deadlock);\n-                } else if kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")? {\n+                } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")? {\n                     this.eval_libc_i32(\"EDEADLK\")\n-                } else if kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")? {\n+                } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")? {\n                     this.mutex_lock(id, active_thread);\n                     Ok(0)\n                 } else {\n@@ -399,7 +356,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?;\n-        let id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n+        let id = mutex_get_id(this, mutex_op)?;\n         let active_thread = this.get_active_thread();\n \n         if this.mutex_is_locked(id) {\n@@ -409,10 +366,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             } else {\n                 if is_mutex_kind_default(this, kind)?\n                     || is_mutex_kind_normal(this, kind)?\n-                    || kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")?\n+                    || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")?\n                 {\n                     this.eval_libc_i32(\"EBUSY\")\n-                } else if kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")? {\n+                } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")? {\n                     this.mutex_lock(id, active_thread);\n                     Ok(0)\n                 } else {\n@@ -435,7 +392,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?;\n-        let id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n+        let id = mutex_get_id(this, mutex_op)?;\n         let active_thread = this.get_active_thread();\n \n         if let Some(_old_locked_count) = this.mutex_unlock(id, active_thread) {\n@@ -453,8 +410,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 throw_ub_format!(\n                     \"unlocked a PTHREAD_MUTEX_NORMAL mutex that was not locked by the current thread\"\n                 );\n-            } else if kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")?\n-                || kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")?\n+            } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")?\n+                || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")?\n             {\n                 this.eval_libc_i32(\"EPERM\")\n             } else {\n@@ -469,7 +426,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n+        let id = mutex_get_id(this, mutex_op)?;\n \n         if this.mutex_is_locked(id) {\n             throw_ub_format!(\"destroyed a locked mutex\");\n@@ -492,7 +449,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n+        let id = rwlock_get_id(this, rwlock_op)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n@@ -510,7 +467,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n+        let id = rwlock_get_id(this, rwlock_op)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n@@ -527,7 +484,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n+        let id = rwlock_get_id(this, rwlock_op)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n@@ -557,7 +514,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n+        let id = rwlock_get_id(this, rwlock_op)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n@@ -574,7 +531,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n+        let id = rwlock_get_id(this, rwlock_op)?;\n         let active_thread = this.get_active_thread();\n \n         #[allow(clippy::if_same_then_else)]\n@@ -593,7 +550,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n+        let id = rwlock_get_id(this, rwlock_op)?;\n \n         if this.rwlock_is_locked(id) {\n             throw_ub_format!(\"destroyed a locked rwlock\");\n@@ -618,7 +575,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // The default value of the clock attribute shall refer to the system\n         // clock.\n         // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_condattr_setclock.html\n-        let default_clock_id = this.eval_libc(\"CLOCK_REALTIME\")?;\n+        let default_clock_id = this.eval_libc_i32(\"CLOCK_REALTIME\")?;\n         condattr_set_clock_id(this, attr_op, default_clock_id)?;\n \n         Ok(0)\n@@ -631,9 +588,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n-        let clock_id = this.read_scalar(clock_id_op)?;\n-        if clock_id == this.eval_libc(\"CLOCK_REALTIME\")?\n-            || clock_id == this.eval_libc(\"CLOCK_MONOTONIC\")?\n+        let clock_id = this.read_scalar(clock_id_op)?.to_i32()?;\n+        if clock_id == this.eval_libc_i32(\"CLOCK_REALTIME\")?\n+            || clock_id == this.eval_libc_i32(\"CLOCK_MONOTONIC\")?\n         {\n             condattr_set_clock_id(this, attr_op, clock_id)?;\n         } else {\n@@ -652,7 +609,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let clock_id = condattr_get_clock_id(this, attr_op)?;\n-        this.write_scalar(clock_id, &this.deref_operand(clk_id_op)?.into())?;\n+        this.write_scalar(Scalar::from_i32(clock_id), &this.deref_operand(clk_id_op)?.into())?;\n \n         Ok(Scalar::from_i32(0))\n     }\n@@ -681,13 +638,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let attr = this.read_pointer(attr_op)?;\n         let clock_id = if this.ptr_is_null(attr)? {\n-            this.eval_libc(\"CLOCK_REALTIME\")?\n+            this.eval_libc_i32(\"CLOCK_REALTIME\")?\n         } else {\n             condattr_get_clock_id(this, attr_op)?\n         };\n \n         // Write 0 to use the same code path as the static initializers.\n-        cond_set_id(this, cond_op, Scalar::from_i32(0))?;\n+        cond_reset_id(this, cond_op)?;\n \n         cond_set_clock_id(this, cond_op, clock_id)?;\n \n@@ -696,7 +653,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n     fn pthread_cond_signal(&mut self, cond_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n-        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n+        let id = cond_get_id(this, cond_op)?;\n         if let Some((thread, lock)) = this.condvar_signal(id) {\n             if let CondvarLock::Mutex(mutex) = lock {\n                 post_cond_signal(this, thread, mutex)?;\n@@ -713,7 +670,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         cond_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n-        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n+        let id = cond_get_id(this, cond_op)?;\n \n         while let Some((thread, lock)) = this.condvar_signal(id) {\n             if let CondvarLock::Mutex(mutex) = lock {\n@@ -733,8 +690,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n-        let mutex_id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n+        let id = cond_get_id(this, cond_op)?;\n+        let mutex_id = mutex_get_id(this, mutex_op)?;\n         let active_thread = this.get_active_thread();\n \n         release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n@@ -752,12 +709,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n-        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n-        let mutex_id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n+        let id = cond_get_id(this, cond_op)?;\n+        let mutex_id = mutex_get_id(this, mutex_op)?;\n         let active_thread = this.get_active_thread();\n \n         // Extract the timeout.\n-        let clock_id = cond_get_clock_id(this, cond_op)?.to_i32()?;\n+        let clock_id = cond_get_clock_id(this, cond_op)?;\n         let duration = match this.read_timespec(&this.deref_operand(abstime_op)?)? {\n             Some(duration) => duration,\n             None => {\n@@ -830,7 +787,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n+        let id = cond_get_id(this, cond_op)?;\n         if this.condvar_is_awaited(id) {\n             throw_ub_format!(\"destroying an awaited conditional variable\");\n         }\n@@ -846,11 +803,3 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         Ok(0)\n     }\n }\n-\n-fn layout_of_maybe_uninit<'tcx>(tcx: TyCtxtAt<'tcx>, param: Ty<'tcx>) -> TyAndLayout<'tcx> {\n-    let def_id = tcx.require_lang_item(LangItem::MaybeUninit, None);\n-    let ty = tcx.bound_type_of(def_id).subst(*tcx, &[param.into()]);\n-\n-    let param_env = tcx.param_env(def_id);\n-    tcx.layout_of(param_env.and(ty)).unwrap()\n-}"}, {"sha": "1d7ed34c59abe26ec2d0642581243d53bb366274", "filename": "src/tools/miri/tests/compiletest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Ftests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Ftests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fcompiletest.rs?ref=e9493d63c2a57b91556dccd219e21821432c7445", "patch": "@@ -1,5 +1,5 @@\n use colored::*;\n-use regex::Regex;\n+use regex::bytes::Regex;\n use std::path::{Path, PathBuf};\n use std::{env, process::Command};\n use ui_test::{color_eyre::Result, Config, Mode, OutputConflictHandling};\n@@ -129,8 +129,8 @@ fn run_tests(mode: Mode, path: &str, target: &str, with_dependencies: bool) -> R\n \n macro_rules! regexes {\n     ($name:ident: $($regex:expr => $replacement:expr,)*) => {lazy_static::lazy_static! {\n-        static ref $name: Vec<(Regex, &'static str)> = vec![\n-            $((Regex::new($regex).unwrap(), $replacement),)*\n+        static ref $name: Vec<(Regex, &'static [u8])> = vec![\n+            $((Regex::new($regex).unwrap(), $replacement.as_bytes()),)*\n         ];\n     }};\n }"}, {"sha": "290de49c82c0b09cdb83d7d5920d2abbfa1442fb", "filename": "src/tools/miri/tests/fail/memleak_rc.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e69336efe035c274f2ee66922cd9cac6015956ea/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e69336efe035c274f2ee66922cd9cac6015956ea/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.stderr?ref=e69336efe035c274f2ee66922cd9cac6015956ea", "patch": "@@ -1,11 +0,0 @@\n-The following memory was leaked: ALLOC (Rust heap, size: 32, align: 8) {\n-    0x00 \u2502 01 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 \u2502 ................\n-    0x10 \u2502 00 00 00 00 00 00 00 00 \u257e$HEX[a1765]<TAG>\u2500\u257c \u2502 ........\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-}\n-\n-error: the evaluated program leaked memory\n-\n-note: pass `-Zmiri-ignore-leaks` to disable this check\n-\n-error: aborting due to previous error\n-"}, {"sha": "f6464b5bd018157f2c452e1be7e56f7e4344f9b6", "filename": "src/tools/miri/tests/pass/miri-alloc.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fmiri-alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fmiri-alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fmiri-alloc.rs?ref=e9493d63c2a57b91556dccd219e21821432c7445", "patch": "@@ -0,0 +1,29 @@\n+#![feature(lang_items, start)]\n+#![no_std]\n+// windows tls dtors go through libstd right now, thus this test\n+// cannot pass. When windows tls dtors go through the special magic\n+// windows linker section, we can run this test on windows again.\n+//@ignore-target-windows: no-std not supported on Windows\n+\n+extern \"Rust\" {\n+    fn miri_alloc(size: usize, align: usize) -> *mut u8;\n+    fn miri_dealloc(ptr: *mut u8, size: usize, align: usize);\n+}\n+\n+#[start]\n+fn start(_: isize, _: *const *const u8) -> isize {\n+    unsafe {\n+        let ptr = miri_alloc(123, 1);\n+        core::ptr::write_bytes(ptr, 0u8, 123);\n+        miri_dealloc(ptr, 123, 1);\n+    }\n+    0\n+}\n+\n+#[panic_handler]\n+fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n+    loop {}\n+}\n+\n+#[lang = \"eh_personality\"]\n+fn eh_personality() {}"}, {"sha": "07cf89f7d338dbd103996602e107b80506ddd886", "filename": "src/tools/rustc-workspace-hack/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml?ref=e9493d63c2a57b91556dccd219e21821432c7445", "patch": "@@ -82,6 +82,8 @@ regex = { version = \"1.5.6\" }\n serde_json = { version = \"1.0.31\", features = [\"raw_value\", \"unbounded_depth\"] }\n syn = { version = \"1\", features = ['full', 'visit'] }\n url = { version = \"2.0\", features = ['serde'] }\n+# Ensure default features of rand, which are disabled in some scenarios.\n+rand = { version = \"0.8.5\" }\n \n [target.'cfg(not(windows))'.dependencies]\n openssl = { version = \"0.10.35\", optional = true }"}, {"sha": "f1f5a1941579b93044a764faa5e5bd4c7040d2f7", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9493d63c2a57b91556dccd219e21821432c7445/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=e9493d63c2a57b91556dccd219e21821432c7445", "patch": "@@ -117,6 +117,7 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"env_logger\",\n     \"expect-test\",\n     \"fallible-iterator\", // dependency of `thorin`\n+    \"fastrand\",\n     \"filetime\",\n     \"fixedbitset\",\n     \"flate2\","}]}