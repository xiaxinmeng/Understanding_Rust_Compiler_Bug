{"sha": "c01c3d9fc6e28b8260894c9522eb29e29874dcbd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwMWMzZDlmYzZlMjhiODI2MDg5NGM5NTIyZWIyOWUyOTg3NGRjYmQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-04-17T20:53:34Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-04-17T21:32:34Z"}, "message": "rustpkg: Fail when crate inference fails; inject link attributes\n\n1. Fail when there's no package script and no crates named\nmain.rs, lib.rs, bench.rs, or test.rs.\n\n2. Inject the crate link_meta \"name\" and \"vers\" attributes, so\nthat the output file gets named correctly in the library case.\n\n3. Normalize '-' to '_' in package names.", "tree": {"sha": "513ac6794d09de418527e420db683a6113ff6bb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/513ac6794d09de418527e420db683a6113ff6bb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c01c3d9fc6e28b8260894c9522eb29e29874dcbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c01c3d9fc6e28b8260894c9522eb29e29874dcbd", "html_url": "https://github.com/rust-lang/rust/commit/c01c3d9fc6e28b8260894c9522eb29e29874dcbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c01c3d9fc6e28b8260894c9522eb29e29874dcbd/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2f5a87cdd79e5531b751749827d2e8a3d269c9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2f5a87cdd79e5531b751749827d2e8a3d269c9e", "html_url": "https://github.com/rust-lang/rust/commit/c2f5a87cdd79e5531b751749827d2e8a3d269c9e"}], "stats": {"total": 227, "additions": 142, "deletions": 85}, "files": [{"sha": "140d9ced5808d362d1213385785a88a5075ede56", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c01c3d9fc6e28b8260894c9522eb29e29874dcbd/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01c3d9fc6e28b8260894c9522eb29e29874dcbd/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=c01c3d9fc6e28b8260894c9522eb29e29874dcbd", "patch": "@@ -11,7 +11,8 @@\n // rustpkg utilities having to do with paths and directories\n \n use core::path::*;\n-use core::os;\n+use core::{os, str};\n+use core::option::*;\n use util::PkgId;\n \n /// Returns the output directory to use.\n@@ -50,6 +51,24 @@ pub fn default_dest_dir(pkg_dir: &Path) -> Path {\n     }\n }\n \n+/// Replace all occurrences of '-' in the stem part of path with '_'\n+/// This is because we treat rust-foo-bar-quux and rust_foo_bar_quux\n+/// as the same name\n+pub fn normalize(p: ~Path) -> ~Path {\n+    match p.filestem() {\n+        None => p,\n+        Some(st) => {\n+            let replaced = str::replace(st, \"-\", \"_\");\n+            if replaced != st {\n+                ~p.with_filestem(replaced)\n+            }\n+            else {\n+                p\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use core::{os, rand};"}, {"sha": "b663c8742ff01c758b58d906076b820d3d4ffd71", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 38, "deletions": 54, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/c01c3d9fc6e28b8260894c9522eb29e29874dcbd/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c01c3d9fc6e28b8260894c9522eb29e29874dcbd/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=c01c3d9fc6e28b8260894c9522eb29e29874dcbd", "patch": "@@ -36,8 +36,9 @@ use rustc::metadata::filesearch;\n use std::net::url;\n use std::{getopts};\n use syntax::{ast, diagnostic};\n-use util::{ExitCode, Pkg, PkgId};\n-use path_util::dest_dir;\n+use util::*;\n+use path_util::{dest_dir, normalize};\n+use rustc::driver::session::{lib_crate, bin_crate, unknown_crate, crate_type};\n \n mod conditions;\n mod usage;\n@@ -117,9 +118,12 @@ impl PkgScript {\n             Ok(r) => {\n                 let root = r.pop().pop().pop().pop(); // :-\\\n                 debug!(\"Root is %s, calling compile_rest\", root.to_str());\n-                util::compile_crate_from_input(self.input, Some(self.build_dir),\n-                                               sess, Some(crate), os::args()[0]);\n                 let exe = self.build_dir.push(~\"pkg\" + util::exe_suffix());\n+                util::compile_crate_from_input(self.input, self.id,\n+                                               Some(self.build_dir),\n+                                               sess, Some(crate),\n+                                               exe, os::args()[0],\n+                                               driver::cu_everything);\n                 debug!(\"Running program: %s %s %s\", exe.to_str(), root.to_str(), what);\n                 let status = run::run_program(exe.to_str(), ~[root.to_str(), what]);\n                 if status != 0 {\n@@ -199,15 +203,15 @@ impl Ctx {\n                 // relative to the CWD. In the future, we should search\n                 // paths\n                 let cwd = os::getcwd().normalize();\n-                debug!(\"Current working directory = %?\", cwd);\n+                debug!(\"Current working directory = %s\", cwd.to_str());\n \n-                // Find crates inside the workspace\n+                // Create the package source\n                 let mut src = PkgSrc::new(&cwd, &dst_dir, &pkgid);\n                 debug!(\"Package src = %?\", src);\n-                src.find_crates();\n \n                 // Is there custom build logic? If so, use it\n                 let pkg_src_dir = cwd.push_rel(&pkgid.path);\n+                let mut custom = false;;\n                 debug!(\"Package source directory = %s\", pkg_src_dir.to_str());\n                 let cfgs = match src.package_script_option(&pkg_src_dir) {\n                     Some(package_script_path) => {\n@@ -221,6 +225,7 @@ impl Ctx {\n                         if hook_result != 0 {\n                             fail!(fmt!(\"Error running custom build command\"))\n                         }\n+                        custom = true;\n                         // otherwise, the package script succeeded\n                         cfgs\n                     }\n@@ -229,6 +234,13 @@ impl Ctx {\n                         ~[]\n                     }\n                 };\n+\n+                // Find crates inside the workspace\n+                if !custom {\n+                    src.find_crates();\n+                }\n+\n+                // Build it!\n                 src.build(&dst_dir, cfgs);\n             }\n             ~\"clean\" => {\n@@ -728,7 +740,6 @@ condition! {\n \n impl PkgSrc {\n \n-\n     fn new(src_dir: &Path, dst_dir: &Path,\n                   id: &PkgId) -> PkgSrc {\n         PkgSrc {\n@@ -765,12 +776,6 @@ impl PkgSrc {\n         dir\n     }\n \n-\n-    fn has_pkg_file(&self) -> bool {\n-        let dir = self.check_dir();\n-        dir.push(\"pkg.rs\").exists()\n-    }\n-\n     // If a file named \"pkg.rs\" in the current directory exists,\n     // return the path for it. Otherwise, None\n     fn package_script_option(&self, cwd: &Path) -> Option<Path> {\n@@ -786,14 +791,16 @@ impl PkgSrc {\n     /// True if the given path's stem is self's pkg ID's stem\n     /// or if the pkg ID's stem is <rust-foo> and the given path's\n     /// stem is foo\n+    /// Requires that dashes in p have already been normalized to\n+    /// underscores\n     fn stem_matches(&self, p: &Path) -> bool {\n-        let self_id = self.id.path.filestem();\n+        let self_id = normalize(~self.id.path).filestem();\n         if self_id == p.filestem() {\n             return true;\n         }\n         else {\n             for self_id.each |pth| {\n-                if pth.starts_with(\"rust-\")\n+                if pth.starts_with(\"rust_\") // because p is already normalized\n                     && match p.filestem() {\n                            Some(s) => str::eq_slice(s, pth.slice(5, pth.len())),\n                            None => false\n@@ -814,17 +821,14 @@ impl PkgSrc {\n         cs.push(Crate::new(&sub));\n     }\n \n+    /// Infers crates to build. Called only in the case where there\n+    /// is no custom build logic\n     fn find_crates(&mut self) {\n         use PkgSrc::push_crate;\n \n         let dir = self.check_dir();\n         let prefix = dir.components.len();\n-        // This is ugly, but can go away once we get rid\n-        // of .rc files\n-        let mut saw_rs = false;\n-        let mut saw_rc = false;\n-        debug!(\"Matching against %?\",\n-               self.id.path.filestem());\n+        debug!(\"Matching against %?\", self.id.path.filestem());\n         for os::walk_dir(&dir) |pth| {\n             match pth.filename() {\n                 Some(~\"lib.rs\") => push_crate(&mut self.libs,\n@@ -836,30 +840,10 @@ impl PkgSrc {\n                 Some(~\"bench.rs\") => push_crate(&mut self.benchs,\n                                                 prefix, pth),\n                 _ => {\n-                    // If the file stem is the same as the\n-                    // package ID, with an .rs or .rc extension,\n-                    // consider it to be a crate\n-                    let ext = pth.filetype();\n-                    let matches = |p: &Path| {\n-                        self.stem_matches(p) && (ext == Some(~\".rc\")\n-                                                  || ext == Some(~\".rs\"))\n-                    };\n-                    debug!(\"Checking %? which %s and ext = %? %? %?\", pth.filestem(),\n-                           if matches(pth) { \"matches\" } else { \"does not match\" },\n-                           ext, saw_rs, saw_rc);\n-                    if matches(pth) &&\n-                        // Avoid pushing foo.rc *and* foo.rs\n-                         !((ext == Some(~\".rc\") && saw_rs) ||\n-                           (ext == Some(~\".rs\") && saw_rc)) {\n-                        push_crate(&mut self.libs, // ????\n-                                   prefix, pth);\n-                        if ext == Some(~\".rc\") {\n-                            saw_rc = true;\n-                        }\n-                        else if ext == Some(~\".rs\") {\n-                            saw_rs = true;\n-                        }\n-                    }\n+                    util::note(~\"Couldn't infer any crates to build.\\n\\\n+                                Try naming a crate `main.rs`, `lib.rs`, \\\n+                                `test.rs`, or `bench.rs`.\");\n+                    fail!(~\"Failed to infer crates to build\");\n                 }\n             }\n         }\n@@ -870,22 +854,22 @@ impl PkgSrc {\n                self.benchs.len())\n     }\n \n-    fn build_crates(dst_dir: &Path,\n+    fn build_crates(&self, dst_dir: &Path,\n                            src_dir: &Path,\n                            crates: &[Crate],\n                            cfgs: ~[~str],\n-                           test: bool) {\n+                           test: bool, crate_type: crate_type) {\n \n         for crates.each |&crate| {\n             let path = &src_dir.push_rel(&crate.file).normalize();\n             util::note(fmt!(\"build_crates: compiling %s\", path.to_str()));\n             util::note(fmt!(\"build_crates: destination dir is %s\", dst_dir.to_str()));\n \n-            let result = util::compile_crate(None, path,\n+            let result = util::compile_crate(None, self.id, path,\n                                      dst_dir,\n                                      crate.flags,\n                                      crate.cfgs + cfgs,\n-                                     false, test);\n+                                     false, test, crate_type);\n             if !result {\n                 build_err::cond.raise(fmt!(\"build failure on %s\",\n                                            path.to_str()));\n@@ -898,12 +882,12 @@ impl PkgSrc {\n     fn build(&self, dst_dir: &Path, cfgs: ~[~str]) {\n         let dir = self.check_dir();\n         debug!(\"Building libs\");\n-        PkgSrc::build_crates(dst_dir, &dir, self.libs, cfgs, false);\n+        self.build_crates(dst_dir, &dir, self.libs, cfgs, false, lib_crate);\n         debug!(\"Building mains\");\n-        PkgSrc::build_crates(dst_dir, &dir, self.mains, cfgs, false);\n+        self.build_crates(dst_dir, &dir, self.mains, cfgs, false, bin_crate);\n         debug!(\"Building tests\");\n-        PkgSrc::build_crates(dst_dir, &dir, self.tests, cfgs, true);\n+        self.build_crates(dst_dir, &dir, self.tests, cfgs, true, bin_crate);\n         debug!(\"Building benches\");\n-        PkgSrc::build_crates(dst_dir, &dir, self.benchs, cfgs, true);\n+        self.build_crates(dst_dir, &dir, self.benchs, cfgs, true, bin_crate);\n     }\n }"}, {"sha": "1709a8d06ad15a028abadcf2f89e5a77d80de76b", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 84, "deletions": 30, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/c01c3d9fc6e28b8260894c9522eb29e29874dcbd/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c01c3d9fc6e28b8260894c9522eb29e29874dcbd/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=c01c3d9fc6e28b8260894c9522eb29e29874dcbd", "patch": "@@ -12,16 +12,20 @@ use core::*;\n use core::cmp::Ord;\n use core::hash::Streaming;\n use rustc::driver::{driver, session};\n+use rustc::driver::session::{lib_crate, bin_crate, unknown_crate};\n use rustc::metadata::filesearch;\n use std::getopts::groups::getopts;\n use std::semver;\n use std::{json, term, getopts};\n use syntax::ast_util::*;\n-use syntax::codemap::{dummy_sp};\n+use syntax::codemap::{dummy_sp, spanned, dummy_spanned};\n use syntax::ext::base::{mk_ctxt, ext_ctxt};\n use syntax::ext::build;\n use syntax::{ast, attr, codemap, diagnostic, fold};\n+use syntax::ast::{meta_name_value, meta_list, attribute, crate_};\n+use syntax::attr::{mk_attr};\n use rustc::back::link::output_type_exe;\n+use rustc::driver::session::{lib_crate, bin_crate, unknown_crate, crate_type};\n \n pub type ExitCode = int; // For now\n \n@@ -112,7 +116,7 @@ pub impl PkgId {\n impl ToStr for PkgId {\n     fn to_str(&self) -> ~str {\n         // should probably use the filestem and not the whole path\n-        fmt!(\"%s-v%s\", self.path.to_str(), self.version.to_str())\n+        fmt!(\"%s-%s\", self.path.to_str(), self.version.to_str())\n     }\n }\n \n@@ -425,44 +429,51 @@ pub fn add_pkg(pkg: &Pkg) -> bool {\n \n // FIXME (#4432): Use workcache to only compile when needed\n pub fn compile_input(sysroot: Option<Path>,\n+                     pkg_id: PkgId,\n                      in_file: &Path,\n                      out_dir: &Path,\n                      flags: ~[~str],\n                      cfgs: ~[~str],\n                      opt: bool,\n-                     test: bool) -> bool {\n+                     test: bool,\n+                     crate_type: session::crate_type) -> bool {\n+\n+    let short_name = pkg_id.to_str();\n \n     assert!(in_file.components.len() > 1);\n     let input = driver::file_input(copy *in_file);\n-    debug!(\"compile_input: %s\", in_file.to_str());\n+    debug!(\"compile_input: %s / %?\", in_file.to_str(), crate_type);\n     // tjc: by default, use the package ID name as the link name\n     // not sure if we should support anything else\n-    let short_name = in_file.filestem().expect(\"Can't compile a directory!\");\n-    debug!(\"short_name = %s\", short_name.to_str());\n \n-// Right now we're always assuming that we're building a library.\n-// What we should do is parse the crate and infer whether it's a library\n-// from the absence or presence of a main fn\n-    let out_file = out_dir.push(os::dll_filename(short_name));\n-    let building_library = true;\n+    let binary = os::args()[0];\n+    let building_library = match crate_type {\n+        lib_crate | unknown_crate => true,\n+        _ => false\n+    };\n+\n+    let out_file = if building_library {\n+        out_dir.push(os::dll_filename(short_name))\n+    }\n+    else {\n+        out_dir.push(short_name + if test { ~\"test\" } else { ~\"\" }\n+                     + os::EXE_SUFFIX)\n+    };\n \n     debug!(\"compiling %s into %s\",\n            in_file.to_str(),\n            out_file.to_str());\n-\n-    let binary = os::args()[0];\n-\n     debug!(\"flags: %s\", str::connect(flags, ~\" \"));\n     debug!(\"cfgs: %s\", str::connect(cfgs, ~\" \"));\n-// Again, we assume we're building a library\n+\n     let matches = getopts(~[~\"-Z\", ~\"time-passes\"]\n-                          + if building_library { ~[~\"--lib\"] } else { ~[] }\n+                          + if building_library { ~[~\"--lib\"] }\n+                            else { ~[] }\n                           + flags\n                           + cfgs.flat_map(|&c| { ~[~\"--cfg\", c] }),\n                           driver::optgroups()).get();\n     let options = @session::options {\n-        crate_type: if building_library { session::lib_crate }\n-                    else { session::bin_crate },\n+        crate_type: crate_type,\n         optimize: if opt { session::Aggressive } else { session::No },\n         test: test,\n         maybe_sysroot: sysroot,\n@@ -485,32 +496,55 @@ pub fn compile_input(sysroot: Option<Path>,\n \n     debug!(\"calling compile_crate_from_input, out_dir = %s,\n            building_library = %?\", out_dir.to_str(), sess.building_library);\n-    compile_crate_from_input(input, Some(*out_dir), sess, None, binary);\n+    let _ = compile_crate_from_input(input, pkg_id, Some(*out_dir), sess, None,\n+                                     out_file, binary,\n+                                     driver::cu_everything);\n     true\n }\n \n // Should use workcache to avoid recompiling when not necessary\n // Should also rename this to something better\n // If crate_opt is present, then finish compilation. If it's None, then\n // call compile_upto and return the crate\n-pub fn compile_crate_from_input(input: driver::input, build_dir_opt: Option<Path>,\n-    sess: session::Session, crate_opt: Option<@ast::crate>,\n-                                binary: ~str) -> @ast::crate {\n+// also, too many arguments\n+pub fn compile_crate_from_input(input: driver::input,\n+                                pkg_id: PkgId,\n+                                build_dir_opt: Option<Path>,\n+                                sess: session::Session,\n+                                crate_opt: Option<@ast::crate>,\n+                                out_file: Path,\n+                                binary: ~str,\n+                                what: driver::compile_upto) -> @ast::crate {\n     debug!(\"Calling build_output_filenames with %?\", build_dir_opt);\n-    let outputs = driver::build_output_filenames(input, &build_dir_opt, &None, sess);\n+    let outputs = driver::build_output_filenames(input, &build_dir_opt, &Some(out_file), sess);\n     debug!(\"Outputs are %? and output type = %?\", outputs, sess.opts.output_type);\n     let cfg = driver::build_configuration(sess, binary, input);\n     match crate_opt {\n         Some(c) => {\n             debug!(\"Calling compile_rest, outputs = %?\", outputs);\n+            assert!(what == driver::cu_everything);\n             driver::compile_rest(sess, cfg, driver::cu_everything, Some(outputs), Some(c));\n             c\n         }\n         None => {\n             debug!(\"Calling compile_upto, outputs = %?\", outputs);\n-            let (crate, _) = driver::compile_upto(sess, cfg, input, driver::cu_parse,\n-                                                  Some(outputs));\n-            crate\n+            let (crate, _) = driver::compile_upto(sess, cfg, input, driver::cu_parse, Some(outputs));\n+\n+            // Inject the inferred link_meta info if it's not already there\n+            // (assumes that name and vers are the only linkage metas)\n+            let mut crate_to_use = crate;\n+            if attr::find_linkage_metas(crate.node.attrs).is_empty() {\n+                crate_to_use = add_attrs(*crate, ~[mk_attr(@dummy_spanned(meta_list(@~\"link\",\n+                                                  // change PkgId to have a <shortname> field?\n+                    ~[@dummy_spanned(meta_name_value(@~\"name\",\n+                                                    mk_string_lit(@pkg_id.path.filestem().get()))),\n+                      @dummy_spanned(meta_name_value(@~\"vers\",\n+                                                    mk_string_lit(@pkg_id.version.to_str())))])))]);\n+            }\n+\n+\n+            driver::compile_rest(sess, cfg, what, Some(outputs), Some(crate_to_use));\n+            crate_to_use\n         }\n     }\n }\n@@ -525,17 +559,30 @@ pub fn exe_suffix() -> ~str { ~\".exe\" }\n pub fn exe_suffix() -> ~str { ~\"\" }\n \n \n+/// Returns a copy of crate `c` with attributes `attrs` added to its\n+/// attributes\n+fn add_attrs(c: ast::crate, new_attrs: ~[attribute]) -> @ast::crate {\n+    @spanned {\n+        node: crate_ {\n+            attrs: c.node.attrs + new_attrs, ..c.node\n+        },\n+        span: c.span\n+    }\n+}\n+\n // Called by build_crates\n // FIXME (#4432): Use workcache to only compile when needed\n-pub fn compile_crate(sysroot: Option<Path>, crate: &Path, dir: &Path,\n+pub fn compile_crate(sysroot: Option<Path>, pkg_id: PkgId,\n+                     crate: &Path, dir: &Path,\n                      flags: ~[~str], cfgs: ~[~str], opt: bool,\n-                     test: bool) -> bool {\n+                     test: bool, crate_type: crate_type) -> bool {\n     debug!(\"compile_crate: crate=%s, dir=%s\", crate.to_str(), dir.to_str());\n-    debug!(\"compile_crate: flags =...\");\n+    debug!(\"compile_crate: short_name = %s, flags =...\", pkg_id.to_str());\n     for flags.each |&fl| {\n         debug!(\"+++ %s\", fl);\n     }\n-    compile_input(sysroot, crate, dir, flags, cfgs, opt, test)\n+    compile_input(sysroot, pkg_id,\n+                  crate, dir, flags, cfgs, opt, test, crate_type)\n }\n \n \n@@ -563,6 +610,13 @@ pub fn link_exe(src: &Path, dest: &Path) -> bool {\n     }\n }\n \n+pub fn mk_string_lit(s: @~str) -> ast::lit {\n+    spanned {\n+        node: ast::lit_str(s),\n+        span: dummy_sp()\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::{is_cmd, parse_name};"}]}