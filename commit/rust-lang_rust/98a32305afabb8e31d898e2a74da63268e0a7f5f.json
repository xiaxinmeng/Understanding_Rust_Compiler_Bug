{"sha": "98a32305afabb8e31d898e2a74da63268e0a7f5f", "node_id": "C_kwDOAAsO6NoAKDk4YTMyMzA1YWZhYmI4ZTMxZDg5OGUyYTc0ZGE2MzI2OGUwYTdmNWY", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-09-22T13:44:06Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-09-22T13:44:06Z"}, "message": "Apply changes proposed in the review", "tree": {"sha": "2439a522a12a494a8b1bcdb83f388c801945bcf5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2439a522a12a494a8b1bcdb83f388c801945bcf5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98a32305afabb8e31d898e2a74da63268e0a7f5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98a32305afabb8e31d898e2a74da63268e0a7f5f", "html_url": "https://github.com/rust-lang/rust/commit/98a32305afabb8e31d898e2a74da63268e0a7f5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98a32305afabb8e31d898e2a74da63268e0a7f5f/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31b71816cd66d53b544902f38b7043c773d3ecda", "url": "https://api.github.com/repos/rust-lang/rust/commits/31b71816cd66d53b544902f38b7043c773d3ecda", "html_url": "https://github.com/rust-lang/rust/commit/31b71816cd66d53b544902f38b7043c773d3ecda"}], "stats": {"total": 66, "additions": 33, "deletions": 33}, "files": [{"sha": "d8365ae9bf92034c4b6c592b780c93ebb2ec77f4", "filename": "library/core/src/fmt/num.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/98a32305afabb8e31d898e2a74da63268e0a7f5f/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a32305afabb8e31d898e2a74da63268e0a7f5f/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs?ref=98a32305afabb8e31d898e2a74da63268e0a7f5f", "patch": "@@ -345,7 +345,7 @@ macro_rules! impl_Exp {\n \n             // decode 2 chars at a time\n             while n >= 100 {\n-                let d1 = ((n % 100) << 1) as usize;\n+                let d1 = ((n % 100) as usize) << 1;\n                 curr -= 2;\n                 // SAFETY: `d1 <= 198`, so we can copy from `lut_ptr[d1..d1 + 2]` since\n                 // `DEC_DIGITS_LUT` has a length of 200.\n@@ -494,73 +494,73 @@ fn parse_u64_into<const N: usize>(mut n: u64, buf: &mut [MaybeUninit<u8>; N], cu\n             n /= 1e16 as u64;\n \n             // Some of these are nops but it looks more elegant this way.\n-            let d1 = (((to_parse / 1e14 as u64) % 100) << 1) as usize;\n-            let d2 = (((to_parse / 1e12 as u64) % 100) << 1) as usize;\n-            let d3 = (((to_parse / 1e10 as u64) % 100) << 1) as usize;\n-            let d4 = (((to_parse / 1e8 as u64) % 100) << 1) as usize;\n-            let d5 = (((to_parse / 1e6 as u64) % 100) << 1) as usize;\n-            let d6 = (((to_parse / 1e4 as u64) % 100) << 1) as usize;\n-            let d7 = (((to_parse / 1e2 as u64) % 100) << 1) as usize;\n-            let d8 = (((to_parse / 1e0 as u64) % 100) << 1) as usize;\n+            let d1 = ((to_parse / 1e14 as u64) % 100) << 1;\n+            let d2 = ((to_parse / 1e12 as u64) % 100) << 1;\n+            let d3 = ((to_parse / 1e10 as u64) % 100) << 1;\n+            let d4 = ((to_parse / 1e8 as u64) % 100) << 1;\n+            let d5 = ((to_parse / 1e6 as u64) % 100) << 1;\n+            let d6 = ((to_parse / 1e4 as u64) % 100) << 1;\n+            let d7 = ((to_parse / 1e2 as u64) % 100) << 1;\n+            let d8 = ((to_parse / 1e0 as u64) % 100) << 1;\n \n             *curr -= 16;\n \n-            ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(*curr + 0), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.add(d2), buf_ptr.add(*curr + 2), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.add(d3), buf_ptr.add(*curr + 4), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.add(d4), buf_ptr.add(*curr + 6), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.add(d5), buf_ptr.add(*curr + 8), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.add(d6), buf_ptr.add(*curr + 10), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.add(d7), buf_ptr.add(*curr + 12), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.add(d8), buf_ptr.add(*curr + 14), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d1 as usize), buf_ptr.add(*curr + 0), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d2 as usize), buf_ptr.add(*curr + 2), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d3 as usize), buf_ptr.add(*curr + 4), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d4 as usize), buf_ptr.add(*curr + 6), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d5 as usize), buf_ptr.add(*curr + 8), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d6 as usize), buf_ptr.add(*curr + 10), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d7 as usize), buf_ptr.add(*curr + 12), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d8 as usize), buf_ptr.add(*curr + 14), 2);\n         }\n         if n >= 1e8 as u64 {\n             let to_parse = n % 1e8 as u64;\n             n /= 1e8 as u64;\n \n             // Some of these are nops but it looks more elegant this way.\n-            let d1 = (((to_parse / 1e6 as u64) % 100) << 1) as usize;\n-            let d2 = (((to_parse / 1e4 as u64) % 100) << 1) as usize;\n-            let d3 = (((to_parse / 1e2 as u64) % 100) << 1) as usize;\n-            let d4 = (((to_parse / 1e0 as u64) % 100) << 1) as usize;\n+            let d1 = ((to_parse / 1e6 as u64) % 100) << 1;\n+            let d2 = ((to_parse / 1e4 as u64) % 100) << 1;\n+            let d3 = ((to_parse / 1e2 as u64) % 100) << 1;\n+            let d4 = ((to_parse / 1e0 as u64) % 100) << 1;\n             *curr -= 8;\n \n-            ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(*curr + 0), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.add(d2), buf_ptr.add(*curr + 2), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.add(d3), buf_ptr.add(*curr + 4), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.add(d4), buf_ptr.add(*curr + 6), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d1 as usize), buf_ptr.add(*curr + 0), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d2 as usize), buf_ptr.add(*curr + 2), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d3 as usize), buf_ptr.add(*curr + 4), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d4 as usize), buf_ptr.add(*curr + 6), 2);\n         }\n         // `n` < 1e8 < (1 << 32)\n         let mut n = n as u32;\n         if n >= 1e4 as u32 {\n             let to_parse = n % 1e4 as u32;\n             n /= 1e4 as u32;\n \n-            let d1 = ((to_parse / 100) << 1) as usize;\n-            let d2 = ((to_parse % 100) << 1) as usize;\n+            let d1 = (to_parse / 100) << 1;\n+            let d2 = (to_parse % 100) << 1;\n             *curr -= 4;\n \n-            ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(*curr + 0), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.add(d2), buf_ptr.add(*curr + 2), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d1 as usize), buf_ptr.add(*curr + 0), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d2 as usize), buf_ptr.add(*curr + 2), 2);\n         }\n \n         // `n` < 1e4 < (1 << 16)\n         let mut n = n as u16;\n         if n >= 100 {\n-            let d1 = ((n % 100) << 1) as usize;\n+            let d1 = (n % 100) << 1;\n             n /= 100;\n             *curr -= 2;\n-            ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(*curr), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d1 as usize), buf_ptr.add(*curr), 2);\n         }\n \n         // decode last 1 or 2 chars\n         if n < 10 {\n             *curr -= 1;\n             *buf_ptr.add(*curr) = (n as u8) + b'0';\n         } else {\n-            let d1 = (n << 1) as usize;\n+            let d1 = n << 1;\n             *curr -= 2;\n-            ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(*curr), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d1 as usize), buf_ptr.add(*curr), 2);\n         }\n     }\n }"}]}