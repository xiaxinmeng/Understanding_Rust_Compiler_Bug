{"sha": "68b0e7dd99ff374adf1babc481e415bad133cba7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4YjBlN2RkOTlmZjM3NGFkZjFiYWJjNDgxZTQxNWJhZDEzM2NiYTc=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-07T23:01:47Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-19T19:02:34Z"}, "message": "Refactor generic argument count check in method/confirm.rs", "tree": {"sha": "bfbd8b71187e004ed51e4f1916f27e5648844fe7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfbd8b71187e004ed51e4f1916f27e5648844fe7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68b0e7dd99ff374adf1babc481e415bad133cba7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68b0e7dd99ff374adf1babc481e415bad133cba7", "html_url": "https://github.com/rust-lang/rust/commit/68b0e7dd99ff374adf1babc481e415bad133cba7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68b0e7dd99ff374adf1babc481e415bad133cba7/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49c45734c0d1a038e44767bdf9cd6721652d5002", "url": "https://api.github.com/repos/rust-lang/rust/commits/49c45734c0d1a038e44767bdf9cd6721652d5002", "html_url": "https://github.com/rust-lang/rust/commit/49c45734c0d1a038e44767bdf9cd6721652d5002"}], "stats": {"total": 319, "additions": 195, "deletions": 124}, "files": [{"sha": "8fb2bb63760a68491139969a2b7af1ba5959269a", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/68b0e7dd99ff374adf1babc481e415bad133cba7/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68b0e7dd99ff374adf1babc481e415bad133cba7/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=68b0e7dd99ff374adf1babc481e415bad133cba7", "patch": "@@ -401,6 +401,13 @@ impl GenericArg {\n             GenericArg::Type(t) => t.span,\n         }\n     }\n+\n+    pub fn id(&self) -> NodeId {\n+        match self {\n+            GenericArg::Lifetime(l) => l.id,\n+            GenericArg::Type(t) => t.id,\n+        }\n+    }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "2e59c5959fbe50476486b9ab3fd1fb9075595d33", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 169, "deletions": 119, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/68b0e7dd99ff374adf1babc481e415bad133cba7/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68b0e7dd99ff374adf1babc481e415bad133cba7/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=68b0e7dd99ff374adf1babc481e415bad133cba7", "patch": "@@ -30,11 +30,12 @@ use require_c_abi_if_variadic;\n use util::common::ErrorReported;\n use util::nodemap::{FxHashSet, FxHashMap};\n use errors::{FatalError, DiagnosticId};\n+use lint;\n \n use std::iter;\n use syntax::ast;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax_pos::Span;\n+use syntax_pos::{Span, MultiSpan};\n \n pub trait AstConv<'gcx, 'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n@@ -172,21 +173,164 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         -> &'tcx Substs<'tcx>\n     {\n \n-        let (substs, assoc_bindings) =\n-            item_segment.with_generic_args(|generic_args| {\n-                self.create_substs_for_ast_path(\n-                    span,\n-                    def_id,\n-                    generic_args,\n-                    item_segment.infer_types,\n-                    None)\n-            });\n+        let (substs, assoc_bindings) = item_segment.with_generic_args(|generic_args| {\n+            self.create_substs_for_ast_path(\n+                span,\n+                def_id,\n+                generic_args,\n+                item_segment.infer_types,\n+                None,\n+            )\n+        });\n \n-        assoc_bindings.first().map(|b| self.prohibit_projection(b.span));\n+        assoc_bindings.first().map(|b| Self::prohibit_assoc_ty_binding(self.tcx(), b.span));\n \n         substs\n     }\n \n+    /// Check that the correct number of generic arguments have been provided.\n+    /// This is used both for type declarations and function calls.\n+    pub fn check_generic_arg_count(\n+        tcx: TyCtxt,\n+        span: Span,\n+        def: &ty::Generics,\n+        args: &hir::GenericArgs,\n+        is_declaration: bool,\n+        is_method_call: bool,\n+        has_self: bool,\n+        infer_types: bool,\n+    ) -> bool {\n+        // At this stage we are guaranteed that the generic arguments are in the correct order, e.g.\n+        // that lifetimes will proceed types. So it suffices to check the number of each generic\n+        // arguments in order to validate them with respect to the generic parameters.\n+        let param_counts = def.own_counts();\n+        let arg_counts = args.own_counts();\n+        let infer_lifetimes = !is_declaration && arg_counts.lifetimes == 0;\n+\n+        let mut defaults: ty::GenericParamCount = Default::default();\n+        for param in &def.params {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => {}\n+                GenericParamDefKind::Type { has_default, .. } => {\n+                    defaults.types += has_default as usize\n+                }\n+            };\n+        }\n+\n+        if !is_declaration && !args.bindings.is_empty() {\n+            AstConv::prohibit_assoc_ty_binding(tcx, args.bindings[0].span);\n+        }\n+\n+        // Prohibit explicit lifetime arguments if late-bound lifetime parameters are present.\n+        if !infer_lifetimes {\n+            if let Some(span_late) = def.has_late_bound_regions {\n+                let msg = \"cannot specify lifetime arguments explicitly \\\n+                           if late bound lifetime parameters are present\";\n+                let note = \"the late bound lifetime parameter is introduced here\";\n+                let span = args.args[0].span();\n+                if !is_method_call && arg_counts.lifetimes != param_counts.lifetimes {\n+                    let mut err = tcx.sess.struct_span_err(span, msg);\n+                    err.span_note(span_late, note);\n+                    err.emit();\n+                    return true;\n+                } else {\n+                    let mut multispan = MultiSpan::from_span(span);\n+                    multispan.push_span_label(span_late, note.to_string());\n+                    tcx.lint_node(lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS,\n+                                  args.args[0].id(), multispan, msg);\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        let check_kind_count = |error_code_less: &str,\n+                                error_code_more: &str,\n+                                kind,\n+                                required,\n+                                permitted,\n+                                provided| {\n+            // We enforce the following: `required` <= `provided` <= `permitted`.\n+            // For kinds without defaults (i.e. lifetimes), `required == permitted`.\n+            // For other kinds (i.e. types), `permitted` may be greater than `required`.\n+            if required <= provided && provided <= permitted {\n+                return false;\n+            }\n+\n+            // Unfortunately lifetime and type parameter mismatches are typically styled\n+            // differently in diagnostics, which means we have a few cases to consider here.\n+            let (bound, quantifier, suppress_error) = if required != permitted {\n+                if provided < required {\n+                    (required, \"at least \", false)\n+                } else { // provided > permitted\n+                    (permitted, \"at most \", true)\n+                }\n+            } else {\n+                (required, \"\", false)\n+            };\n+            let label = if required == permitted && provided > permitted {\n+                let diff = provided - permitted;\n+                format!(\n+                    \"{}unexpected {} argument{}\",\n+                    if diff != 1 { format!(\"{} \", diff) } else { String::new() },\n+                    kind,\n+                    if diff != 1 { \"s\" } else { \"\" },\n+                )\n+            } else {\n+                format!(\n+                    \"expected {}{} {} argument{}\",\n+                    quantifier,\n+                    bound,\n+                    kind,\n+                    if required != 1 { \"s\" } else { \"\" },\n+                )\n+            };\n+\n+            tcx.sess.struct_span_err_with_code(\n+                span,\n+                &format!(\n+                    \"wrong number of {} arguments: expected {}{}, found {}\",\n+                    kind,\n+                    quantifier,\n+                    bound,\n+                    provided,\n+                ),\n+                DiagnosticId::Error({\n+                    if provided <= permitted {\n+                        error_code_less\n+                    } else {\n+                        error_code_more\n+                    }\n+                }.into())\n+            ).span_label(span, label).emit();\n+\n+            suppress_error\n+        };\n+\n+        if !infer_lifetimes || arg_counts.lifetimes > param_counts.lifetimes {\n+            check_kind_count(\n+                \"E0107\",\n+                \"E0107\",\n+                \"lifetime\",\n+                param_counts.lifetimes,\n+                param_counts.lifetimes,\n+                arg_counts.lifetimes,\n+            );\n+        }\n+        if !infer_types\n+            || arg_counts.types > param_counts.types - defaults.types - has_self as usize {\n+            check_kind_count(\n+                \"E0243\",\n+                \"E0244\", // FIXME: E0243 and E0244 should be unified.\n+                \"type\",\n+                param_counts.types - defaults.types - has_self as usize,\n+                param_counts.types - has_self as usize,\n+                arg_counts.types,\n+            )\n+        } else {\n+            false\n+        }\n+    }\n+\n     /// Creates the relevant generic argument substitutions\n     /// corresponding to a set of generic parameters.\n     pub fn create_substs_for_generic_args<'a, 'b, A, P, I>(\n@@ -355,7 +499,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         assert_eq!(generic_params.has_self, self_ty.is_some());\n \n         let has_self = generic_params.has_self;\n-        check_generic_arg_count(tcx, span, &generic_params, &generic_args, has_self, infer_types);\n+        Self::check_generic_arg_count(\n+            self.tcx(),\n+            span,\n+            &generic_params,\n+            &generic_args,\n+            true, // `is_declaration`\n+            false, // `is_method_call` (irrelevant here)\n+            has_self,\n+            infer_types,\n+        );\n \n         let is_object = self_ty.map_or(false, |ty| ty.sty == TRAIT_OBJECT_DUMMY_SELF);\n         let default_needs_object_self = |param: &ty::GenericParamDef| {\n@@ -548,7 +701,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                                                  trait_def_id,\n                                                  self_ty,\n                                                  trait_segment);\n-        assoc_bindings.first().map(|b| self.prohibit_projection(b.span));\n+        assoc_bindings.first().map(|b| AstConv::prohibit_assoc_ty_binding(self.tcx(), b.span));\n         ty::TraitRef::new(trait_def_id, substs)\n     }\n \n@@ -1113,15 +1266,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                     }\n                 }\n                 for binding in &generic_args.bindings {\n-                    self.prohibit_projection(binding.span);\n+                    Self::prohibit_assoc_ty_binding(self.tcx(), binding.span);\n                     break;\n                 }\n             })\n         }\n     }\n \n-    pub fn prohibit_projection(&self, span: Span) {\n-        let mut err = struct_span_err!(self.tcx().sess, span, E0229,\n+    pub fn prohibit_assoc_ty_binding(tcx: TyCtxt, span: Span) {\n+        let mut err = struct_span_err!(tcx.sess, span, E0229,\n                                        \"associated type bindings are not allowed here\");\n         err.span_label(span, \"associated type not allowed here\").emit();\n     }\n@@ -1497,109 +1650,6 @@ fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     (auto_traits, trait_bounds)\n }\n \n-pub fn check_generic_arg_count(\n-    tcx: TyCtxt,\n-    span: Span,\n-    def: &ty::Generics,\n-    args: &hir::GenericArgs,\n-    has_self: bool,\n-    infer_types: bool,\n-) {\n-    // At this stage we are guaranteed that the generic arguments are in the correct order, e.g.\n-    // that lifetimes will proceed types. So it suffices to check the number of each generic\n-    // arguments in order to validate them with respect to the generic parameters.\n-    let param_counts = def.own_counts();\n-    let arg_counts = args.own_counts();\n-\n-    let mut defaults: ty::GenericParamCount = Default::default();\n-    for param in &def.params {\n-        match param.kind {\n-            GenericParamDefKind::Lifetime => {}\n-            GenericParamDefKind::Type { has_default, .. } => defaults.types += has_default as usize,\n-        };\n-    }\n-\n-    let check_kind_count = |error_code_less: &str,\n-                            error_code_more: &str,\n-                            kind,\n-                            required,\n-                            permitted,\n-                            provided| {\n-        // We enforce the following: `required` <= `provided` <= `permitted`.\n-        // For kinds without defaults (i.e. lifetimes), `required == permitted`.\n-        // For other kinds (i.e. types), `permitted` may be greater than `required`.\n-        if required <= provided && provided <= permitted {\n-            return;\n-        }\n-\n-        // Unfortunately lifetime and type parameter mismatches are typically styled\n-        // differently in diagnostics, which means we have a few cases to consider here.\n-        let (bound, quantifier) = if required != permitted {\n-            if provided < required {\n-                (required, \"at least \")\n-            } else { // provided > permitted\n-                (permitted, \"at most \")\n-            }\n-        } else {\n-            (required, \"\")\n-        };\n-        let label = if required == permitted && provided > permitted {\n-            let diff = provided - permitted;\n-            format!(\n-                \"{}unexpected {} argument{}\",\n-                if diff != 1 { format!(\"{} \", diff) } else { String::new() },\n-                kind,\n-                if diff != 1 { \"s\" } else { \"\" },\n-            )\n-        } else {\n-            format!(\n-                \"expected {}{} {} argument{}\",\n-                quantifier,\n-                bound,\n-                kind,\n-                if required != 1 { \"s\" } else { \"\" },\n-            )\n-        };\n-\n-        tcx.sess.struct_span_err_with_code(\n-            span,\n-            &format!(\n-                \"wrong number of {} arguments: expected {}{}, found {}\",\n-                kind,\n-                quantifier,\n-                bound,\n-                provided,\n-            ),\n-            DiagnosticId::Error({\n-                if provided <= permitted {\n-                    error_code_less\n-                } else {\n-                    error_code_more\n-                }\n-            }.into())\n-        ).span_label(span, label).emit();\n-    };\n-\n-    check_kind_count(\n-        \"E0107\",\n-        \"E0107\",\n-        \"lifetime\",\n-        param_counts.lifetimes,\n-        param_counts.lifetimes,\n-        arg_counts.lifetimes,\n-    );\n-    if !infer_types || arg_counts.types > param_counts.types - defaults.types - has_self as usize {\n-        check_kind_count(\n-            \"E0243\",\n-            \"E0244\", // FIXME: E0243 and E0244 should be unified.\n-            \"type\",\n-            param_counts.types - defaults.types - has_self as usize,\n-            param_counts.types - has_self as usize,\n-            arg_counts.types,\n-        );\n-    }\n-}\n-\n // A helper struct for conveniently grouping a set of bounds which we pass to\n // and return from functions in multiple places.\n #[derive(PartialEq, Eq, Clone, Debug)]"}, {"sha": "49225680432d9773538aeff37fc0d39361c5c174", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/68b0e7dd99ff374adf1babc481e415bad133cba7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68b0e7dd99ff374adf1babc481e415bad133cba7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=68b0e7dd99ff374adf1babc481e415bad133cba7", "patch": "@@ -14,6 +14,7 @@ use astconv::AstConv;\n use check::{FnCtxt, PlaceOp, callee, Needs};\n use hir::GenericArg;\n use hir::def_id::DefId;\n+use hir::HirVec;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty, GenericParamDefKind};\n@@ -22,8 +23,9 @@ use rustc::ty::adjustment::{Adjustment, Adjust, OverloadedDeref};\n use rustc::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::infer::{self, InferOk};\n-use syntax_pos::Span;\n use rustc::hir;\n+use syntax_pos::Span;\n+use syntax::ptr::P;\n \n use std::ops::Deref;\n \n@@ -315,9 +317,21 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n         let method_generics = self.tcx.generics_of(pick.item.def_id);\n-        let supress_mismatch = self.fcx.check_impl_trait(self.span, segment, &method_generics);\n-        self.fcx.check_generic_arg_count(self.span, &segment, &method_generics, true,\n-                                         supress_mismatch);\n+        let suppress_mismatch = self.fcx.check_impl_trait(self.span, segment, &method_generics);\n+        AstConv::check_generic_arg_count(\n+            self.tcx,\n+            self.span,\n+            &method_generics,\n+            &segment.args.clone().unwrap_or_else(|| P(hir::GenericArgs {\n+                args: HirVec::new(), bindings: HirVec::new(), parenthesized: false,\n+            })),\n+            false, // `is_declaration`\n+            true, // `is_method_call`\n+            method_generics.parent.is_none() && method_generics.has_self,\n+            segment.infer_types || suppress_mismatch,\n+        );\n+        // self.fcx.check_generic_arg_count(self.span, &segment, &method_generics, true,\n+                                        //  supress_mismatch);\n \n         // Create subst for early-bound lifetime parameters, combining\n         // parameters from the type and those from the method."}, {"sha": "ae5c0fc6fb14b8c275a91b7ae23c6f5cc0eb2acb", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68b0e7dd99ff374adf1babc481e415bad133cba7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68b0e7dd99ff374adf1babc481e415bad133cba7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=68b0e7dd99ff374adf1babc481e415bad133cba7", "patch": "@@ -5168,7 +5168,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         if !bindings.is_empty() {\n-            AstConv::prohibit_projection(self, bindings[0].span);\n+            AstConv::prohibit_assoc_ty_binding(self.tcx, bindings[0].span);\n         }\n \n         let infer_lifetimes = lifetimes.len() == 0;"}]}