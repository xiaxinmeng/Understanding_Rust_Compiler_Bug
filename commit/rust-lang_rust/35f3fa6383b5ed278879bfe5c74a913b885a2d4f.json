{"sha": "35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1ZjNmYTYzODNiNWVkMjc4ODc5YmZlNWM3NGE5MTNiODg1YTJkNGY=", "commit": {"author": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-06-17T19:45:40Z"}, "committer": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-06-17T19:45:40Z"}, "message": "Merge remote-tracking branch 'upstream/io' into io\n\nConflicts:\n\tsrc/libstd/rt/uvio.rs", "tree": {"sha": "be8ca61c0beccd0b4c5d1e486c5322c1181c49f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be8ca61c0beccd0b4c5d1e486c5322c1181c49f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "html_url": "https://github.com/rust-lang/rust/commit/35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/comments", "author": null, "committer": null, "parents": [{"sha": "33ae193a3c1a156e73bf6880366c9785dd4b7393", "url": "https://api.github.com/repos/rust-lang/rust/commits/33ae193a3c1a156e73bf6880366c9785dd4b7393", "html_url": "https://github.com/rust-lang/rust/commit/33ae193a3c1a156e73bf6880366c9785dd4b7393"}, {"sha": "319cf6e465f203c794d71800808c2bd60a1e7613", "url": "https://api.github.com/repos/rust-lang/rust/commits/319cf6e465f203c794d71800808c2bd60a1e7613", "html_url": "https://github.com/rust-lang/rust/commit/319cf6e465f203c794d71800808c2bd60a1e7613"}], "stats": {"total": 86020, "additions": 68437, "deletions": 17583}, "files": [{"sha": "22d42a82a3b83108883e23a72f310b6b902f1b09", "filename": ".gitattributes", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -7,3 +7,4 @@\n src/rt/msvc/* -whitespace\n src/rt/vg/* -whitespace\n src/rt/linenoise/* -whitespace\n+src/rt/jemalloc/**/* -whitespace"}, {"sha": "637b9ec8c4efb78e6751cf39aae7c0555e8b44a6", "filename": ".mailmap", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -0,0 +1,12 @@\n+#\n+# This list is used by git-shortlog to aggregate contributions.  It is\n+# necessary when either the author's full name is not always written\n+# the same way, and/or the same author contributes from different\n+# email addresses.\n+#\n+\n+Elly Jones <elly@leptoquark.net>\n+ILyoan <ilyoan@gmail.com>\n+Junyoung Cho <june0.cho@samsung.com>\n+Matthijs Hofstra <thiezz@gmail.com>\n+Rob Arnold <robarnold@cs.cmu.edu>"}, {"sha": "56be6c3ec78d1664c87ed21e4fff0827790773fe", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -1,27 +1,38 @@\n ## Pull request procedure\n \n-Pull requests should be targeted at Rust's `incoming` branch (note that by default Github will aim them at the `master` branch) --\n-see \"Changing The Commit Range and Destination Repository\" in Github's documentation on [pull requests](https://help.github.com/articles/using-pull-requests).\n-Before pushing to your Github repo and issuing the pull request, please do two things:\n+Pull requests should be targeted at Rust's `master` branch.\n+Before pushing to your Github repo and issuing the pull request,\n+please do two things:\n \n-1. [Rebase](http://git-scm.com/book/en/Git-Branching-Rebasing) your local changes against the `incoming` branch. Resolve any conflicts that arise.\n-2. Run the full Rust test suite with the `make check` command.\n-You're not off the hook even if you just stick to documentation; code examples in the docs are tested as well!\n+1. [Rebase](http://git-scm.com/book/en/Git-Branching-Rebasing) your\n+   local changes against the `master` branch. Resolve any conflicts\n+   that arise.\n \n-Pull requests will be treated as \"review requests\",\n-and we will give feedback we expect to see corrected on [style](https://github.com/mozilla/rust/wiki/Note-style-guide) and substance before pulling.\n-Changes contributed via pull request should focus on a single issue at a time, like any other.\n-We will not accept pull-requests that try to \"sneak\" unrelated changes in.\n+2. Run the full Rust test suite with the `make check` command.  You're\n+   not off the hook even if you just stick to documentation; code\n+   examples in the docs are tested as well!\n \n-Normally, all pull requests must include regression tests (see [Note-testsuite](https://github.com/mozilla/rust/wiki/Note-testsuite)) that test your change.\n-Occasionally, a change will be very difficult to test for.\n-In those cases, please include a note in your commit message explaining why.\n+Pull requests will be treated as \"review requests\", and we will give\n+feedback we expect to see corrected on\n+[style](https://github.com/mozilla/rust/wiki/Note-style-guide) and\n+substance before pulling.  Changes contributed via pull request should\n+focus on a single issue at a time, like any other.  We will not accept\n+pull-requests that try to \"sneak\" unrelated changes in.\n \n-In the licensing header at the beginning of any files you change, please make sure the listed date range includes the current year.\n-For example, if it's 2013, and you change a Rust file that was created in 2010, it should begin:\n+Normally, all pull requests must include regression tests (see\n+[Note-testsuite](https://github.com/mozilla/rust/wiki/Note-testsuite))\n+that test your change.  Occasionally, a change will be very difficult\n+to test for.  In those cases, please include a note in your commit\n+message explaining why.\n+\n+In the licensing header at the beginning of any files you change,\n+please make sure the listed date range includes the current year.  For\n+example, if it's 2013, and you change a Rust file that was created in\n+2010, it should begin:\n \n ```\n // Copyright 2010-2013 The Rust Project Developers.\n ```\n \n-For more details, please refer to [Note-development-policy](https://github.com/mozilla/rust/wiki/Note-development-policy).\n\\ No newline at end of file\n+For more details, please refer to\n+[Note-development-policy](https://github.com/mozilla/rust/wiki/Note-development-policy)."}, {"sha": "ca82f29602278466080bd89b6cf7db941c363791", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -146,8 +146,7 @@ ifneq ($(wildcard $(CFG_GIT)),)\n ifneq ($(wildcard $(CFG_GIT_DIR)),)\n     CFG_VERSION += $(shell git --git-dir=$(CFG_GIT_DIR) log -1 \\\n                      --pretty=format:'(%h %ci)')\n-    CFG_VER_HASH = $(shell git --git-dir=$(CFG_GIT_DIR) log -1 \\\n-                     --pretty=format:'%H')\n+    CFG_VER_HASH = $(shell git --git-dir=$(CFG_GIT_DIR) rev-parse HEAD)\n endif\n endif\n "}, {"sha": "5bf160d62487497876090cd506ca40fbeb022f01", "filename": "RELEASES.txt", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/RELEASES.txt", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/RELEASES.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.txt?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -3,12 +3,37 @@ Version 0.7 (July 2013)\n \n    * ??? changes, numerous bugfixes\n \n+   * Syntax changes\n+      * `#[deriving(Encodable)]`, `#[deriving(Decodable)]`\n+\n    * Semantic changes\n-      * The `self` parameter no longer implicitly means `&'self self`, and can be explicitly marked\n-        with a lifetime.\n+      * The `self` parameter no longer implicitly means `&'self self`,\n+        and can be explicitly marked with a lifetime.\n+      * Structs with the `#[packed]` attribute have byte alignment and\n+        no padding between fields.\n \n    * Libraries\n-      * New `core::iterator` module for external iterator objects\n+\n+      **Note: in 0.7 `core` was renamed `std` and `std` to `extra.\n+        These notes use the new crate names.**\n+\n+      * The `core` crate was renamed to `std`.\n+      * The `std` crate was renamed to `extra`.\n+      * `std::mut` removed.\n+      * std: `iterator` module for external iterator objects.\n+      * std: many types implement `Clone` - tuples, @, @mut. TODO\n+      * std: `path` type renamed to `Path`.\n+      * std: Many standalone functions removed in favor of methods in\n+        `vec`, `str`, TODO. In the future methods will also work as functions.\n+      * extra: `FileInput` implements `std::io::Reader`.\n+      * extra: `Complex` number type and `complex` module.\n+      * extra: `Rational` number type and `rational` module.\n+      * extra: `BigInt`, `BigUint` implement numeric and comparison traits.\n+\n+   * Other\n+      * `unused_unsafe` lint mode for detecting unnecessary `unsafe` blocks.\n+      * More and improved library documentation.\n+      * The `rusti` command has been rewritten and a number of bugs addressed.\n \n Version 0.6 (April 2013)\n ------------------------"}, {"sha": "1c658af9feed25772b847f3e4e5c5bf7285850b2", "filename": "configure", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/configure", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -138,7 +138,7 @@ validate_opt () {\n         done\n         if [ \"$arg\" = \"--help\" ]\n         then\n-            echo \"\"\n+            echo\n             echo \"No more help available for Configure options,\"\n             echo \"check the Wiki or join our IRC channel\"\n             break\n@@ -349,11 +349,11 @@ if [ \"$1\" = \"--help\" ]\n then\n     HELP=1\n     shift\n-    echo \"\"\n+    echo\n     echo \"Usage: $CFG_SELF [options]\"\n-    echo \"\"\n+    echo\n     echo \"Options:\"\n-    echo \"\"\n+    echo\n else\n     msg \"recreating config.tmp\"\n     echo '' >config.tmp\n@@ -394,7 +394,7 @@ validate_opt\n \n if [ $HELP -eq 1 ]\n then\n-    echo \"\"\n+    echo\n     exit 0\n fi\n \n@@ -561,7 +561,7 @@ then\n                       | cut -d ' ' -f 2)\n \n     case $CFG_CLANG_VERSION in\n-        (3.0svn | 3.0 | 3.1* | 3.2* | 3.3*)\n+        (3.0svn | 3.0 | 3.1* | 3.2* | 3.3* | 3.4* )\n         step_msg \"found ok version of CLANG: $CFG_CLANG_VERSION\"\n         CFG_C_COMPILER=\"clang\"\n         ;;\n@@ -683,7 +683,8 @@ do\n     for i in                                          \\\n       isaac linenoise sync test \\\n       arch/i386 arch/x86_64 arch/arm arch/mips  \\\n-      libuv libuv/src/ares libuv/src/eio libuv/src/ev\n+      libuv libuv/src/ares libuv/src/eio libuv/src/ev \\\n+      jemalloc\n     do\n       make_dir rt/$t/stage$s/$i\n     done\n@@ -970,6 +971,13 @@ then\n     putvar CFG_CCACHE_CPP2\n fi\n \n+if [ ! -z \"$CFG_ENABLE_CCACHE\" ]\n+then\n+    CFG_CCACHE_BASEDIR=${CFG_SRC_DIR}\n+    putvar CFG_CCACHE_BASEDIR\n+fi\n+\n+\n if [ ! -z $BAD_PANDOC ]\n then\n     CFG_PANDOC="}, {"sha": "35581a8d4edf89d6015ee61e0f011f75bf75e65f", "filename": "doc/rust.css", "status": "modified", "additions": 73, "deletions": 23, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/doc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/doc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.css?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -1,39 +1,81 @@\n body {\n-  padding: 1em;\n-  margin: 0;\n-  margin-bottom: 4em;\n-  font-family: \"Helvetica Neue\", Helvetica, sans-serif;\n-  background-color: white;\n-  color: black;\n-  line-height: 1.6em;\n-}\n-\n-body {\n-  padding: 1em 6em;\n-  max-width: 60em;\n+    padding: 1em 6em;\n+    margin: 0;\n+    margin-bottom: 4em;\n+    font-family: \"Helvetica Neue\", Helvetica, sans-serif;\n+    font-size: 12pt;\n+    background-color: white;\n+    color: black;\n+    line-height: 1.6em;\n+    min-width: 45em;\n+    max-width: 60em;\n }\n \n h1 {\n-  font-size: 20pt;\n-  margin-top: 2em;\n-  border-bottom: 1px solid silver;\n-  line-height: 1.6em;\n+    font-size: 20pt;\n+    margin-top: 2em;\n+    padding-left: 0.4em;\n+    line-height: 1.6em;\n+    background-color:#FFF2CE;\n+    border-radius: 0.2em;\n+    border: 1px solid rgba(0, 0, 0, 0.15);\n }\n+\n h2 {\n     font-size: 15pt;\n     margin-top: 2em;\n+    padding-left: 0.4em;\n+    background-color:#FFF2CE;\n+    border-radius: 0.4em;\n+    border: 1px solid rgba(0, 0, 0, 0.15);\n+}\n+\n+h2 code {\n+    color: #097334;\n+    font-size: 15pt;\n+}\n+\n+h3 {\n+    font-size: 13pt;\n+    color: black;\n+    background-color:#D9E7FF;\n+    border-radius: 0.4em;\n+    border: 1px solid rgba(0, 0, 0, 0.15);\n+    padding: 0 0.4em 0 0.4em;\n+}\n+\n+h3 code {\n+    color: #541800;\n+    font-size: 13pt;\n+    font-style: italic;\n+}\n+\n+h4 {\n+    font-size: 11pt;\n+    margin-top: 0em;\n+    margin-bottom: 0em;\n+}\n+\n+code {\n+    font-size: 11pt;\n }\n-h3 { font-size: 13pt; }\n \n pre {\n-  margin: 1.1em 0;\n-  padding: .4em .4em .4em 2em;\n-  font-size: 120%;\n+    margin-left: 1.1em;\n+    padding: .4em .4em .4em .8em;\n+    font-size: 10pt;\n+    background-color: #F5F5F5;\n+    border-radius: 0.5em;\n+    border: 1px solid rgba(0, 0, 0, 0.15);\n+}\n+\n+pre.rust {\n+    background-color: #F3F6FF;\n }\n \n a, a:visited, a:link {\n-  text-decoration: none;\n-  color: rgb(0, 105, 214);\n+    text-decoration: none;\n+    color: rgb(0, 105, 214);\n }\n \n h1 a:link, h1 a:visited, h2 a:link, h2 a:visited,\n@@ -106,4 +148,12 @@ td {\n /* Adjust list alignment so rustdoc indexes don't align with blockquotes */\n div.index ul {\n     padding-left: 1em;\n-}\n\\ No newline at end of file\n+}\n+\n+ul {\n+    margin-top: 0em\n+}\n+\n+div.section.level3  {\n+    margin-left: 1.0em;\n+}"}, {"sha": "3c0828def154ac60d2296f73e4226539e964367a", "filename": "doc/rust.md", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -301,10 +301,10 @@ num_lit : nonzero_dec [ dec_digit | '_' ] * num_suffix ?\n num_suffix : int_suffix | float_suffix ;\n \n int_suffix : 'u' int_suffix_size ?\n-           | 'i' int_suffix_size ;\n+           | 'i' int_suffix_size ? ;\n int_suffix_size : [ '8' | '1' '6' | '3' '2' | '6' '4' ] ;\n \n-float_suffix : [ exponent | '.' dec_lit exponent ? ] float_suffix_ty ? ;\n+float_suffix : [ exponent | '.' dec_lit exponent ? ] ? float_suffix_ty ? ;\n float_suffix_ty : 'f' [ '3' '2' | '6' '4' ] ;\n exponent : ['E' | 'e'] ['-' | '+' ] ? dec_lit ;\n dec_lit : [ dec_digit | '_' ] + ;\n@@ -803,19 +803,14 @@ An example of `use` declarations:\n \n ~~~~\n use std::float::sin;\n-use std::str::{slice, contains};\n-use std::option::Some;\n+use std::option::{Some, None};\n \n fn main() {\n     // Equivalent to 'info!(std::float::sin(1.0));'\n     info!(sin(1.0));\n \n-    // Equivalent to 'info!(std::option::Some(1.0));'\n-    info!(Some(1.0));\n-\n-    // Equivalent to\n-    // 'info!(std::str::contains(std::str::slice(\"foo\", 0, 1), \"oo\"));'\n-    info!(contains(slice(\"foo\", 0, 1), \"oo\"));\n+    // Equivalent to 'info!(~[std::option::Some(1.0), std::option::None]);'\n+    info!(~[Some(1.0), None]);\n }\n ~~~~\n \n@@ -1297,7 +1292,7 @@ with matching types and type parameter counts.\n \n An implementation can take type parameters,\n which can be different from the type parameters taken by the trait it implements.\n-Implementation parameters are written after after the `impl` keyword.\n+Implementation parameters are written after the `impl` keyword.\n \n ~~~~\n # trait Seq<T> { }\n@@ -1840,6 +1835,7 @@ is bounds-checked at run-time. When the check fails, it will put the\n task in a _failing state_.\n \n ~~~~\n+# use std::task;\n # do task::spawn_unlinked {\n \n ([1, 2, 3, 4])[0];\n@@ -2032,7 +2028,8 @@ as\n =\n ~~~~\n \n-Operators at the same precedence level are evaluated left-to-right.\n+Operators at the same precedence level are evaluated left-to-right. [Unary operators](#unary-operator-expressions)\n+have the same precedence level and it is stronger than any of the binary operators'.\n \n ### Grouped expressions\n \n@@ -2168,7 +2165,7 @@ fn ten_times(f: &fn(int)) {\n     }\n }\n \n-ten_times(|j| io::println(fmt!(\"hello, %d\", j)));\n+ten_times(|j| println(fmt!(\"hello, %d\", j)));\n \n ~~~~\n \n@@ -2189,7 +2186,7 @@ An example:\n let mut i = 0;\n \n while i < 10 {\n-    io::println(\"hello\\n\");\n+    println(\"hello\\n\");\n     i = i + 1;\n }\n ~~~~\n@@ -2323,7 +2320,9 @@ An example of a for loop over the contents of a vector:\n ~~~~\n # type foo = int;\n # fn bar(f: foo) { }\n-# let a = 0, b = 0, c = 0;\n+# let a = 0;\n+# let b = 0;\n+# let c = 0;\n \n let v: &[foo] = &[a, b, c];\n \n@@ -2335,6 +2334,7 @@ for v.each |e| {\n An example of a for loop over a series of integers:\n \n ~~~~\n+# use std::uint;\n # fn bar(b:uint) { }\n for uint::range(0, 256) |i| {\n     bar(i);\n@@ -2798,6 +2798,7 @@ the vtable pointer for the `T` implementation of `R`, and the pointer value of `\n An example of an object type:\n \n ~~~~~~~~\n+# use std::int;\n trait Printable {\n   fn to_str(&self) -> ~str;\n }\n@@ -2807,7 +2808,7 @@ impl Printable for int {\n }\n \n fn print(a: @Printable) {\n-   io::println(a.to_str());\n+   println(a.to_str());\n }\n \n fn main() {\n@@ -2996,7 +2997,7 @@ allocated within the stack's memory. The value is a part of the stack frame.\n \n Local variables are immutable unless declared with `let mut`.  The\n `mut` keyword applies to all local variables declared within that\n-declaration (so `let mut x, y` declares two mutable variables, `x` and\n+declaration (so `let mut (x, y) = ...` declares two mutable variables, `x` and\n `y`).\n \n Function parameters are immutable unless declared with `mut`. The"}, {"sha": "b12bce5a0afdfdda0caebad4c3bb5bf176238f16", "filename": "doc/rustpkg.md", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/doc%2Frustpkg.md", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/doc%2Frustpkg.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frustpkg.md?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -30,6 +30,12 @@ or the equivalent on Windows.\n \n Each workspace may contain one or more packages.\n \n+When building code that contains one or more directives of the form `extern mod P`,\n+rustpkg automatically searches for packages named `P` in the `RUST_PATH` (as described above).\n+It builds those dependencies if necessary.\n+Thus, when using rustpkg,\n+there is no need for `-L` flags to tell the linker where to find libraries for external crates.\n+\n # Package structure\n \n A valid workspace must contain each of the following subdirectories:\n@@ -66,6 +72,10 @@ A package can be stored in a workspace on the local file system,\n or on a remote Web server, in which case the package ID resembles a URL.\n For example, `github.com/mozilla/rust` is a package ID\n that would refer to the git repository browsable at `http://github.com/mozilla/rust`.\n+A package ID can also specify a version, like:\n+`github.com/mozilla/rust#0.3`.\n+In this case, `rustpkg` will check that the repository `github.com/mozilla/rust` has a tag named `0.3`,\n+and report an error otherwise.\n \n ## Source files\n \n@@ -76,6 +86,15 @@ rustpkg searches for four different fixed filenames in order to determine the cr\n * `test.rs`: Assumed to contain tests declared with the `#[test]` attribute.\n * `bench.rs`: Assumed to contain benchmarks declared with the `#[bench]` attribute.\n \n+## Versions\n+\n+`rustpkg` packages do not need to declare their versions with an attribute inside one of the source files,\n+because `rustpkg` infers it from the version control system.\n+When building a package that is in a `git` repository,\n+`rustpkg` assumes that the most recent tag specifies the current version.\n+When building a package that is not under version control,\n+or that has no tags, `rustpkg` assumes the intended version is 0.1.\n+\n # Custom build scripts\n \n A file called `pkg.rs` at the root level in a workspace is called a *package script*."}, {"sha": "d3c682ce1adcd293dbc82d720ab52a8815dddf66", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -149,17 +149,18 @@ A type with the same functionality as owned boxes can be implemented by\n wrapping `malloc` and `free`:\n \n ~~~~\n+use std::cast;\n use std::libc::{c_void, size_t, malloc, free};\n+use std::ptr;\n use std::unstable::intrinsics;\n-use std::util;\n \n // a wrapper around the handle returned by the foreign code\n pub struct Unique<T> {\n     priv ptr: *mut T\n }\n \n-pub impl<T: Owned> Unique<T> {\n-    fn new(value: T) -> Unique<T> {\n+impl<T: Owned> Unique<T> {\n+    pub fn new(value: T) -> Unique<T> {\n         unsafe {\n             let ptr = malloc(std::sys::size_of::<T>() as size_t) as *mut T;\n             assert!(!ptr::is_null(ptr));\n@@ -170,12 +171,12 @@ pub impl<T: Owned> Unique<T> {\n     }\n \n     // the 'r lifetime results in the same semantics as `&*x` with ~T\n-    fn borrow<'r>(&'r self) -> &'r T {\n+    pub fn borrow<'r>(&'r self) -> &'r T {\n         unsafe { cast::copy_lifetime(self, &*self.ptr) }\n     }\n \n     // the 'r lifetime results in the same semantics as `&mut *x` with ~T\n-    fn borrow_mut<'r>(&'r mut self) -> &'r mut T {\n+    pub fn borrow_mut<'r>(&'r mut self) -> &'r mut T {\n         unsafe { cast::copy_mut_lifetime(self, &mut *self.ptr) }\n     }\n }\n@@ -184,9 +185,9 @@ pub impl<T: Owned> Unique<T> {\n impl<T: Owned> Drop for Unique<T> {\n     fn finalize(&self) {\n         unsafe {\n-            let mut x = intrinsics::init(); // dummy value to swap in\n+            let x = intrinsics::init(); // dummy value to swap in\n             // moving the object out is needed to call the destructor\n-            util::replace_ptr(self.ptr, x);\n+            ptr::replace_ptr(self.ptr, x);\n             free(self.ptr as *c_void)\n         }\n     }"}, {"sha": "f1f4ade0542d5068672ec76fa3486b2de02f3c52", "filename": "doc/tutorial-macros.md", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/doc%2Ftutorial-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/doc%2Ftutorial-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-macros.md?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -13,7 +13,8 @@ doing nothing otherwise:\n ~~~~\n # enum t { special_a(uint), special_b(uint) };\n # fn f() -> uint {\n-# let input_1 = special_a(0), input_2 = special_a(0);\n+# let input_1 = special_a(0);\n+# let input_2 = special_a(0);\n match input_1 {\n     special_a(x) => { return x; }\n     _ => {}\n@@ -38,7 +39,8 @@ the pattern in the above code:\n ~~~~\n # enum t { special_a(uint), special_b(uint) };\n # fn f() -> uint {\n-# let input_1 = special_a(0), input_2 = special_a(0);\n+# let input_1 = special_a(0);\n+# let input_2 = special_a(0);\n macro_rules! early_return(\n     ($inp:expr $sp:ident) => ( // invoke it like `(input_5 special_e)`\n         match $inp {\n@@ -155,7 +157,8 @@ instead of `*` to mean \"at least one\".\n ~~~~\n # enum t { special_a(uint),special_b(uint),special_c(uint),special_d(uint)};\n # fn f() -> uint {\n-# let input_1 = special_a(0), input_2 = special_a(0);\n+# let input_1 = special_a(0);\n+# let input_2 = special_a(0);\n macro_rules! early_return(\n     ($inp:expr, [ $($sp:ident)|+ ]) => (\n         match $inp {"}, {"sha": "b00cd665271f63cd959c8ae40c8a2bafad5631ea", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -120,6 +120,7 @@ should interleave the output in vaguely random order.\n ~~~\n # use std::io::print;\n # use std::task::spawn;\n+# use std::int;\n \n for int::range(0, 20) |child_task_number| {\n     do spawn {\n@@ -236,6 +237,7 @@ Instead we can use a `SharedChan`, a type that allows a single\n ~~~\n # use std::task::spawn;\n # use std::comm::{stream, SharedChan};\n+# use std::uint;\n \n let (port, chan) = stream();\n let chan = SharedChan::new(chan);\n@@ -269,6 +271,7 @@ might look like the example below.\n ~~~\n # use std::task::spawn;\n # use std::comm::stream;\n+# use std::vec;\n \n // Create a vector of ports, one for each child task\n let ports = do vec::from_fn(3) |init_val| {\n@@ -310,10 +313,12 @@ the future needs to be mutable so that it can save the result for next time `get\n Here is another example showing how futures allow you to background computations. The workload will\n be distributed on the available cores.\n ~~~\n+# use std::vec;\n+# use std::uint;\n fn partial_sum(start: uint) -> f64 {\n     let mut local_sum = 0f64;\n     for uint::range(start*100000, (start+1)*100000) |num| {\n-        local_sum += (num as f64 + 1.0).pow(-2.0);\n+        local_sum += (num as f64 + 1.0).pow(&-2.0);\n     }\n     local_sum\n }\n@@ -322,7 +327,7 @@ fn main() {\n     let mut futures = vec::from_fn(1000, |ind| do extra::future::spawn { partial_sum(ind) });\n \n     let mut final_res = 0f64;\n-    for futures.each_mut |ft|  {\n+    for futures.mut_iter().advance |ft|  {\n         final_res += ft.get();\n     }\n     println(fmt!(\"\u03c0^2/6 is not far from : %?\", final_res));\n@@ -343,14 +348,17 @@ acts as a reference to the shared data and only this reference is shared and clo\n Here is a small example showing how to use ARCs. We wish to run concurrently several computations on\n a single large vector of floats. Each task needs the full vector to perform its duty.\n ~~~\n+# use std::vec;\n+# use std::uint;\n+# use std::rand;\n use extra::arc::ARC;\n \n fn pnorm(nums: &~[float], p: uint) -> float {\n-    (vec::foldl(0.0, *nums, |a,b| a+(*b).pow(p as float) )).pow(1f / (p as float))\n+    nums.iter().fold(0.0, |a,b| a+(*b).pow(&(p as float)) ).pow(&(1f / (p as float)))\n }\n \n fn main() {\n-    let numbers=vec::from_fn(1000000, |_| rand::random::<float>());\n+    let numbers = vec::from_fn(1000000, |_| rand::random::<float>());\n     println(fmt!(\"Inf-norm = %?\",  numbers.max()));\n \n     let numbers_arc = ARC(numbers);\n@@ -373,12 +381,16 @@ at the power given as argument and takes the inverse power of this value). The A\n created by the line\n ~~~\n # use extra::arc::ARC;\n-# let numbers=vec::from_fn(1000000, |_| rand::random::<float>());\n+# use std::vec;\n+# use std::rand;\n+# let numbers = vec::from_fn(1000000, |_| rand::random::<float>());\n let numbers_arc=ARC(numbers);\n ~~~\n and a clone of it is sent to each task\n ~~~\n # use extra::arc::ARC;\n+# use std::vec;\n+# use std::rand;\n # let numbers=vec::from_fn(1000000, |_| rand::random::<float>());\n # let numbers_arc = ARC(numbers);\n # let (port, chan)  = stream();\n@@ -389,6 +401,8 @@ copying only the wrapper and not its contents.\n Each task recovers the underlying data by\n ~~~\n # use extra::arc::ARC;\n+# use std::vec;\n+# use std::rand;\n # let numbers=vec::from_fn(1000000, |_| rand::random::<float>());\n # let numbers_arc=ARC(numbers);\n # let (port, chan)  = stream();\n@@ -416,6 +430,7 @@ of all tasks are intertwined: if one fails, so do all the others.\n \n ~~~\n # use std::task::spawn;\n+# use std::task;\n # fn do_some_work() { loop { task::yield() } }\n # do task::try {\n // Create a child task that fails\n@@ -437,6 +452,7 @@ field (representing a successful result) or an `Err` result (representing\n termination with an error).\n \n ~~~\n+# use std::task;\n # fn some_condition() -> bool { false }\n # fn calculate_result() -> int { 0 }\n let result: Result<int, ()> = do task::try {\n@@ -479,6 +495,7 @@ By default, task failure is _bidirectionally linked_, which means that if\n either task fails, it kills the other one.\n \n ~~~\n+# use std::task;\n # fn sleep_forever() { loop { task::yield() } }\n # do task::try {\n do spawn {\n@@ -501,6 +518,7 @@ before returning. Hence:\n ~~~\n # use std::comm::{stream, Chan, Port};\n # use std::task::{spawn, try};\n+# use std::task;\n # fn sleep_forever() { loop { task::yield() } }\n # do task::try {\n let (receiver, sender): (Port<int>, Chan<int>) = stream();\n@@ -528,6 +546,7 @@ Supervised task failure propagates across multiple generations even if\n an intermediate generation has already exited:\n \n ~~~\n+# use std::task;\n # fn sleep_forever() { loop { task::yield() } }\n # fn wait_for_a_while() { for 1000.times { task::yield() } }\n # do task::try::<int> {\n@@ -546,6 +565,7 @@ Finally, tasks can be configured to not propagate failure to each\n other at all, using `task::spawn_unlinked` for _isolated failure_.\n \n ~~~\n+# use std::task;\n # fn random() -> uint { 100 }\n # fn sleep_for(i: uint) { for i.times { task::yield() } }\n # do task::try::<()> {\n@@ -574,6 +594,7 @@ Here is the function that implements the child task:\n \n ~~~~\n # use extra::comm::DuplexStream;\n+# use std::uint;\n fn stringifier(channel: &DuplexStream<~str, uint>) {\n     let mut value: uint;\n     loop {\n@@ -596,6 +617,7 @@ Here is the code for the parent task:\n \n ~~~~\n # use std::task::spawn;\n+# use std::uint;\n # use extra::comm::DuplexStream;\n # fn stringifier(channel: &DuplexStream<~str, uint>) {\n #     let mut value: uint;"}, {"sha": "a458036116665354c214f48f46ae181dff3fdc50", "filename": "doc/tutorial.md", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -502,6 +502,7 @@ types.\n > items.\n \n ~~~~\n+# use std::float;\n fn angle(vector: (float, float)) -> float {\n     let pi = float::consts::pi;\n     match vector {\n@@ -556,6 +557,7 @@ while cake_amount > 0 {\n `loop` denotes an infinite loop, and is the preferred way of writing `while true`:\n \n ~~~~\n+# use std::int;\n let mut x = 5;\n loop {\n     x += x - 3;\n@@ -567,8 +569,10 @@ loop {\n This code prints out a weird sequence of numbers and stops as soon as\n it finds one that can be divided by five.\n \n-For more involved iteration, such as enumerating the elements of a\n-collection, Rust uses [higher-order functions](#closures).\n+Rust also has a `for` construct. It's different from C's `for` and it works\n+best when iterating over collections. See the section on [closures](#closures)\n+to find out how to use `for` and higher-order functions for enumerating\n+elements of a collection.\n \n # Data structures\n \n@@ -699,6 +703,7 @@ get at their contents. All variant constructors can be used as\n patterns, as in this definition of `area`:\n \n ~~~~\n+# use std::float;\n # struct Point {x: float, y: float}\n # enum Shape { Circle(Point, float), Rectangle(Point, Point) }\n fn area(sh: Shape) -> float {\n@@ -1390,6 +1395,7 @@ assert!(crayons.len() == 3);\n assert!(!crayons.is_empty());\n \n // Iterate over a vector, obtaining a pointer to each element\n+// (`for` is explained in the next section)\n for crayons.each |crayon| {\n     let delicious_crayon_wax = unwrap_crayon(*crayon);\n     eat_crayon_wax(delicious_crayon_wax);\n@@ -1404,7 +1410,7 @@ let new_favorite_crayon_name = favorite_crayon_name.trim();\n \n if favorite_crayon_name.len() > 5 {\n    // Create a substring\n-   println(favorite_crayon_name.substr(0, 5));\n+   println(favorite_crayon_name.slice_chars(0, 5));\n }\n ~~~\n \n@@ -1436,10 +1442,15 @@ call_closure_with_ten(closure);\n ~~~~\n \n Closures begin with the argument list between vertical bars and are followed by\n-a single expression. The types of the arguments are generally omitted,\n-as is the return type, because the compiler can almost always infer\n-them. In the rare case where the compiler needs assistance, though, the\n-arguments and return types may be annotated.\n+a single expression. Remember that a block, `{ <expr1>; <expr2>; ... }`, is\n+considered a single expression: it evaluates to the result of the last\n+expression it contains if that expression is not followed by a semicolon,\n+otherwise the block evaluates to `()`.\n+\n+The types of the arguments are generally omitted, as is the return type,\n+because the compiler can almost always infer them. In the rare case where the\n+compiler needs assistance, though, the arguments and return types may be\n+annotated.\n \n ~~~~\n let square = |x: int| -> uint { x * x as uint };\n@@ -1610,18 +1621,19 @@ loop. Like `do`, `for` is a nice syntax for describing control flow\n with closures.  Additionally, within a `for` loop, `break`, `loop`,\n and `return` work just as they do with `while` and `loop`.\n \n-Consider again our `each` function, this time improved to\n-break early when the iteratee returns `false`:\n+Consider again our `each` function, this time improved to return\n+immediately when the iteratee returns `false`:\n \n ~~~~\n-fn each(v: &[int], op: &fn(v: &int) -> bool) {\n+fn each(v: &[int], op: &fn(v: &int) -> bool) -> bool {\n    let mut n = 0;\n    while n < v.len() {\n        if !op(&v[n]) {\n-           break;\n+           return false;\n        }\n        n += 1;\n    }\n+   return true;\n }\n ~~~~\n \n@@ -1829,6 +1841,7 @@ vector consisting of the result of applying `function` to each element\n of `vector`:\n \n ~~~~\n+# use std::vec;\n fn map<T, U>(vector: &[T], function: &fn(v: &T) -> U) -> ~[U] {\n     let mut accumulator = ~[];\n     for vec::each(vector) |element| {\n@@ -2026,13 +2039,14 @@ themselves contain type parameters. A trait for generalized sequence\n types might look like the following:\n \n ~~~~\n+# use std::vec;\n trait Seq<T> {\n     fn len(&self) -> uint;\n     fn iter(&self, b: &fn(v: &T));\n }\n \n impl<T> Seq<T> for ~[T] {\n-    fn len(&self) -> uint { vec::len(*self) }\n+    fn len(&self) -> uint { self.len() }\n     fn iter(&self, b: &fn(v: &T)) {\n         for vec::each(*self) |elt| { b(elt); }\n     }"}, {"sha": "4bb8de28aefa390d88ad91d413cae9f086c163d4", "filename": "mk/platform.mk", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -146,7 +146,7 @@ CFG_LIB_GLOB_x86_64-unknown-linux-gnu=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_x86_64-unknown-linux-gnu=lib$(1)-*.dylib.dSYM\n CFG_GCCISH_CFLAGS_x86_64-unknown-linux-gnu := -Wall -Werror -g -fPIC -m64\n CFG_GCCISH_CXXFLAGS_x86_64-unknown-linux-gnu := -fno-rtti\n-CFG_GCCISH_LINK_FLAGS_x86_64-unknown-linux-gnu := -shared -fPIC -ldl -lpthread -lrt -g -m64\n+CFG_GCCISH_LINK_FLAGS_x86_64-unknown-linux-gnu := -shared -fPIC -ldl -pthread  -lrt -g -m64\n CFG_GCCISH_DEF_FLAG_x86_64-unknown-linux-gnu := -Wl,--export-dynamic,--dynamic-list=\n CFG_GCCISH_PRE_LIB_FLAGS_x86_64-unknown-linux-gnu := -Wl,-whole-archive\n CFG_GCCISH_POST_LIB_FLAGS_x86_64-unknown-linux-gnu := -Wl,-no-whole-archive\n@@ -172,7 +172,7 @@ CFG_LIB_GLOB_i686-unknown-linux-gnu=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_i686-unknown-linux-gnu=lib$(1)-*.dylib.dSYM\n CFG_GCCISH_CFLAGS_i686-unknown-linux-gnu := -Wall -Werror -g -fPIC -m32\n CFG_GCCISH_CXXFLAGS_i686-unknown-linux-gnu := -fno-rtti\n-CFG_GCCISH_LINK_FLAGS_i686-unknown-linux-gnu := -shared -fPIC -ldl -lpthread -lrt -g -m32\n+CFG_GCCISH_LINK_FLAGS_i686-unknown-linux-gnu := -shared -fPIC -ldl -pthread  -lrt -g -m32\n CFG_GCCISH_DEF_FLAG_i686-unknown-linux-gnu := -Wl,--export-dynamic,--dynamic-list=\n CFG_GCCISH_PRE_LIB_FLAGS_i686-unknown-linux-gnu := -Wl,-whole-archive\n CFG_GCCISH_POST_LIB_FLAGS_i686-unknown-linux-gnu := -Wl,-no-whole-archive\n@@ -198,7 +198,7 @@ CFG_LIB_GLOB_x86_64-apple-darwin=lib$(1)-*.dylib\n CFG_LIB_DSYM_GLOB_x86_64-apple-darwin=lib$(1)-*.dylib.dSYM\n CFG_GCCISH_CFLAGS_x86_64-apple-darwin := -Wall -Werror -g -fPIC -m64 -arch x86_64\n CFG_GCCISH_CXXFLAGS_x86_64-apple-darwin := -fno-rtti\n-CFG_GCCISH_LINK_FLAGS_x86_64-apple-darwin := -dynamiclib -lpthread -framework CoreServices -Wl,-no_compact_unwind -m64\n+CFG_GCCISH_LINK_FLAGS_x86_64-apple-darwin := -dynamiclib -pthread  -framework CoreServices -Wl,-no_compact_unwind -m64\n CFG_GCCISH_DEF_FLAG_x86_64-apple-darwin := -Wl,-exported_symbols_list,\n CFG_GCCISH_PRE_LIB_FLAGS_x86_64-apple-darwin :=\n CFG_GCCISH_POST_LIB_FLAGS_x86_64-apple-darwin :=\n@@ -223,7 +223,7 @@ CFG_LIB_GLOB_i686-apple-darwin=lib$(1)-*.dylib\n CFG_LIB_DSYM_GLOB_i686-apple-darwin=lib$(1)-*.dylib.dSYM\n CFG_GCCISH_CFLAGS_i686-apple-darwin := -Wall -Werror -g -fPIC -m32 -arch i386\n CFG_GCCISH_CXXFLAGS_i686-apple-darwin := -fno-rtti\n-CFG_GCCISH_LINK_FLAGS_i686-apple-darwin := -dynamiclib -lpthread -framework CoreServices -Wl,-no_compact_unwind -m32\n+CFG_GCCISH_LINK_FLAGS_i686-apple-darwin := -dynamiclib -pthread  -framework CoreServices -Wl,-no_compact_unwind -m32\n CFG_GCCISH_DEF_FLAG_i686-apple-darwin := -Wl,-exported_symbols_list,\n CFG_GCCISH_PRE_LIB_FLAGS_i686-apple-darwin :=\n CFG_GCCISH_POST_LIB_FLAGS_i686-apple-darwin :=\n@@ -376,13 +376,13 @@ CFG_LIB_NAME_x86_64-unknown-freebsd=lib$(1).so\n CFG_LIB_GLOB_x86_64-unknown-freebsd=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_x86_64-unknown-freebsd=$(1)-*.dylib.dSYM\n CFG_GCCISH_CFLAGS_x86_64-unknown-freebsd := -Wall -Werror -g -fPIC -I/usr/local/include\n-CFG_GCCISH_LINK_FLAGS_x86_64-unknown-freebsd := -shared -fPIC -g -lpthread -lrt\n+CFG_GCCISH_LINK_FLAGS_x86_64-unknown-freebsd := -shared -fPIC -g -pthread  -lrt\n CFG_GCCISH_DEF_FLAG_x86_64-unknown-freebsd := -Wl,--export-dynamic,--dynamic-list=\n CFG_GCCISH_PRE_LIB_FLAGS_x86_64-unknown-freebsd := -Wl,-whole-archive\n CFG_GCCISH_POST_LIB_FLAGS_x86_64-unknown-freebsd := -Wl,-no-whole-archive\n CFG_DEF_SUFFIX_x86_64-unknown-freebsd := .bsd.def\n CFG_INSTALL_NAME_x86_64-unknown-freebsd =\n-CFG_LIBUV_LINK_FLAGS_x86_64-unknown-freebsd := -lpthread -lkvm\n+CFG_LIBUV_LINK_FLAGS_x86_64-unknown-freebsd := -pthread  -lkvm\n CFG_EXE_SUFFIX_x86_64-unknown-freebsd :=\n CFG_WINDOWSY_x86_64-unknown-freebsd :=\n CFG_UNIXY_x86_64-unknown-freebsd := 1\n@@ -396,6 +396,11 @@ ifeq ($(CFG_CCACHE_CPP2),1)\n   export CCACHE_CPP\n endif\n \n+ifdef CFG_CCACHE_BASEDIR\n+  CCACHE_BASEDIR=$(CFG_CCACHE_BASEDIR)\n+  export CCACHE_BASEDIR\n+endif\n+\n define CFG_MAKE_TOOLCHAIN\n   CFG_COMPILE_C_$(1) = $$(CC_$(1))  \\\n         $$(CFG_GCCISH_CFLAGS)      \\"}, {"sha": "1c498aacdddc0751cdf3d7831471ca74864aae95", "filename": "mk/rt.mk", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -53,6 +53,15 @@ define DEF_RUNTIME_TARGETS\n RUNTIME_CFLAGS_$(1)_$(2) = -D_RUST_STAGE$(2)\n RUNTIME_CXXFLAGS_$(1)_$(2) = -D_RUST_STAGE$(2)\n \n+# XXX: Like with --cfg stage0, pass the defines for stage1 to the stage0\n+# build of non-build-triple host compilers\n+ifeq ($(2),0)\n+ifneq ($(strip $(CFG_BUILD_TRIPLE)),$(strip $(1)))\n+RUNTIME_CFLAGS_$(1)_$(2) = -D_RUST_STAGE1\n+RUNTIME_CXXFLAGS_$(1)_$(2) = -D_RUST_STAGE1\n+endif\n+endif\n+\n RUNTIME_CXXS_$(1)_$(2) := \\\n               rt/sync/timer.cpp \\\n               rt/sync/lock_and_signal.cpp \\\n@@ -97,18 +106,23 @@ RUNTIME_S_$(1)_$(2) := rt/arch/$$(HOST_$(1))/_context.S \\\n ifeq ($$(CFG_WINDOWSY_$(1)), 1)\n   LIBUV_OSTYPE_$(1)_$(2) := win\n   LIBUV_LIB_$(1)_$(2) := rt/$(1)/stage$(2)/libuv/libuv.a\n+  JEMALLOC_LIB_$(1)_$(2) := rt/$(1)/stage$(2)/jemalloc/lib/jemalloc.lib\n else ifeq ($(OSTYPE_$(1)), apple-darwin)\n   LIBUV_OSTYPE_$(1)_$(2) := mac\n   LIBUV_LIB_$(1)_$(2) := rt/$(1)/stage$(2)/libuv/libuv.a\n+  JEMALLOC_LIB_$(1)_$(2) := rt/$(1)/stage$(2)/jemalloc/lib/libjemalloc_pic.a\n else ifeq ($(OSTYPE_$(1)), unknown-freebsd)\n   LIBUV_OSTYPE_$(1)_$(2) := unix/freebsd\n   LIBUV_LIB_$(1)_$(2) := rt/$(1)/stage$(2)/libuv/libuv.a\n+  JEMALLOC_LIB_$(1)_$(2) := rt/$(1)/stage$(2)/jemalloc/lib/libjemalloc_pic.a\n else ifeq ($(OSTYPE_$(1)), linux-androideabi)\n   LIBUV_OSTYPE_$(1)_$(2) := unix/android\n   LIBUV_LIB_$(1)_$(2) := rt/$(1)/stage$(2)/libuv/libuv.a\n+  JEMALLOC_LIB_$(1)_$(2) := rt/$(1)/stage$(2)/jemalloc/lib/libjemalloc_pic.a\n else\n   LIBUV_OSTYPE_$(1)_$(2) := unix/linux\n   LIBUV_LIB_$(1)_$(2) := rt/$(1)/stage$(2)/libuv/libuv.a\n+  JEMALLOC_LIB_$(1)_$(2) := rt/$(1)/stage$(2)/jemalloc/lib/libjemalloc_pic.a\n endif\n \n RUNTIME_DEF_$(1)_$(2) := rt/rustrt$(CFG_DEF_SUFFIX_$(1))\n@@ -124,8 +138,6 @@ ALL_OBJ_FILES += $$(RUNTIME_OBJS_$(1)_$(2))\n MORESTACK_OBJ_$(1)_$(2) := rt/$(1)/stage$(2)/arch/$$(HOST_$(1))/morestack.o\n ALL_OBJ_FILES += $$(MORESTACK_OBJS_$(1)_$(2))\n \n-RUNTIME_LIBS_$(1)_$(2) := $$(LIBUV_LIB_$(1)_$(2))\n-\n rt/$(1)/stage$(2)/%.o: rt/%.cpp $$(MKFILE_DEPS)\n \t@$$(call E, compile: $$@)\n \t$$(Q)$$(call CFG_COMPILE_CXX_$(1), $$@, $$(RUNTIME_INCS_$(1)_$(2)) \\\n@@ -146,11 +158,10 @@ rt/$(1)/stage$(2)/arch/$$(HOST_$(1))/libmorestack.a: $$(MORESTACK_OBJ_$(1)_$(2))\n \t$$(Q)$(AR_$(1)) rcs $$@ $$<\n \n rt/$(1)/stage$(2)/$(CFG_RUNTIME_$(1)): $$(RUNTIME_OBJS_$(1)_$(2)) $$(MKFILE_DEPS) \\\n-                        $$(RUNTIME_DEF_$(1)_$(2)) \\\n-                        $$(RUNTIME_LIBS_$(1)_$(2))\n+                        $$(RUNTIME_DEF_$(1)_$(2)) $$(LIBUV_LIB_$(1)_$(2)) $$(JEMALLOC_LIB_$(1)_$(2))\n \t@$$(call E, link: $$@)\n \t$$(Q)$$(call CFG_LINK_CXX_$(1),$$@, $$(RUNTIME_OBJS_$(1)_$(2)) \\\n-\t  $$(CFG_GCCISH_POST_LIB_FLAGS_$(1)) $$(RUNTIME_LIBS_$(1)_$(2)) \\\n+\t  $$(JEMALLOC_LIB_$(1)_$(2)) $$(CFG_GCCISH_POST_LIB_FLAGS_$(1)) $$(LIBUV_LIB_$(1)_$(2)) \\\n \t  $$(CFG_LIBUV_LINK_FLAGS_$(1)),$$(RUNTIME_DEF_$(1)_$(2)),$$(CFG_RUNTIME_$(1)))\n \n # FIXME: For some reason libuv's makefiles can't figure out the\n@@ -199,6 +210,28 @@ $$(LIBUV_LIB_$(1)_$(2)): $$(LIBUV_DEPS)\n \t\tV=$$(VERBOSE)\n endif\n \n+ifeq ($(OSTYPE_$(1)), linux-androideabi)\n+$$(JEMALLOC_LIB_$(1)_$(2)):\n+\tcd $$(CFG_BUILD_DIR)/rt/$(1)/stage$(2)/jemalloc; $(S)src/rt/jemalloc/configure \\\n+\t\t--disable-experimental --build=$(CFG_BUILD_TRIPLE) --host=$(1) --disable-tls \\\n+\t\tEXTRA_CFLAGS=\"$$(CFG_GCCISH_CFLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1))) $$(SNAP_DEFINES)\" \\\n+\t\tLDFLAGS=\"$$(CFG_GCCISH_LINK_FLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1)))\" \\\n+\t\tCC=\"$$(CC_$(1))\" \\\n+\t\tCXX=\"$$(CXX_$(1))\" \\\n+\t\tAR=\"$$(AR_$(1))\"\n+\t$$(Q)$$(MAKE) -C $$(CFG_BUILD_DIR)/rt/$(1)/stage$(2)/jemalloc\n+else\n+$$(JEMALLOC_LIB_$(1)_$(2)):\n+\tcd $$(CFG_BUILD_DIR)/rt/$(1)/stage$(2)/jemalloc; $(S)src/rt/jemalloc/configure \\\n+\t\t--disable-experimental --build=$(CFG_BUILD_TRIPLE) --host=$(1) \\\n+\t\tEXTRA_CFLAGS=\"$$(CFG_GCCISH_CFLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1))) $$(SNAP_DEFINES)\" \\\n+\t\tLDFLAGS=\"$$(CFG_GCCISH_LINK_FLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1)))\" \\\n+\t\tCC=\"$$(CC_$(1))\" \\\n+\t\tCXX=\"$$(CXX_$(1))\" \\\n+\t\tAR=\"$$(AR_$(1))\"\n+\t$$(Q)$$(MAKE) -C $$(CFG_BUILD_DIR)/rt/$(1)/stage$(2)/jemalloc\n+endif\n+\n \n # These could go in rt.mk or rustllvm.mk, they're needed for both.\n "}, {"sha": "3858de3f264df46d56d162369ea03508fb8a2f26", "filename": "mk/tests.mk", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -122,8 +122,18 @@ CFG_ADB_TEST_DIR=/data/tmp\n $(info check: android device test dir $(CFG_ADB_TEST_DIR) ready \\\n  $(shell adb remount 1>/dev/null) \\\n  $(shell adb shell mkdir $(CFG_ADB_TEST_DIR) 1>/dev/null) \\\n+ $(shell adb shell rm $(CFG_ADB_TEST_DIR)/*.so 1>/dev/null) \\\n+ $(shell adb shell rm $(CFG_ADB_TEST_DIR)/*-arm-linux-androideabi 1>/dev/null) \\\n+ $(shell adb shell rm $(CFG_ADB_TEST_DIR)/*-arm-linux-androideabi.* 1>/dev/null) \\\n+ $(shell adb push $(S)src/etc/adb_run_wrapper.sh $(CFG_ADB_TEST_DIR) 1>/dev/null) \\\n  $(shell adb push $(CFG_ANDROID_CROSS_PATH)/arm-linux-androideabi/lib/armv7-a/libgnustl_shared.so \\\n                   $(CFG_ADB_TEST_DIR) 1>/dev/null) \\\n+ $(shell adb push $(TLIB2_T_arm-linux-androideabi_H_$(CFG_BUILD_TRIPLE))/$(CFG_RUNTIME_arm-linux-androideabi) \\\n+                  $(CFG_ADB_TEST_DIR)) \\\n+ $(shell adb push $(TLIB2_T_arm-linux-androideabi_H_$(CFG_BUILD_TRIPLE))/$(STDLIB_GLOB_arm-linux-androideabi) \\\n+                  $(CFG_ADB_TEST_DIR)) \\\n+ $(shell adb push $(TLIB2_T_arm-linux-androideabi_H_$(CFG_BUILD_TRIPLE))/$(EXTRALIB_GLOB_arm-linux-androideabi) \\\n+                  $(CFG_ADB_TEST_DIR)) \\\n  )\n else\n CFG_ADB_TEST_DIR=\n@@ -666,7 +676,7 @@ TEST_GROUPS = \\\n \tperf \\\n \tdebuginfo \\\n \tdoc \\\n-\t$(foreach docname,$(DOC_TEST_NAMES),$(docname)) \\\n+\t$(foreach docname,$(DOC_TEST_NAMES),doc-$(docname)) \\\n \tpretty \\\n \tpretty-rpass \\\n \tpretty-rpass-full \\"}, {"sha": "e832534b227a9b6a294c2731bc4cadc9676a9fb2", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -16,13 +16,13 @@\n #[no_std];\n \n extern mod core(name = \"std\", vers = \"0.7-pre\");\n-extern mod std(name = \"extra\", vers = \"0.7-pre\");\n+extern mod extra(name = \"extra\", vers = \"0.7-pre\");\n \n use core::prelude::*;\n use core::*;\n \n-use std::getopts;\n-use std::test;\n+use extra::getopts;\n+use extra::test;\n \n use core::result::{Ok, Err};\n \n@@ -42,6 +42,13 @@ pub mod runtest;\n pub mod common;\n pub mod errors;\n \n+mod std {\n+    pub use core::cmp;\n+    pub use core::str;\n+    pub use core::sys;\n+    pub use core::unstable;\n+}\n+\n pub fn main() {\n     let args = os::args();\n     let config = parse_config(args);\n@@ -90,7 +97,7 @@ pub fn parse_config(args: ~[~str]) -> config {\n         mode: str_mode(getopts::opt_str(matches, \"mode\")),\n         run_ignored: getopts::opt_present(matches, \"ignored\"),\n         filter:\n-             if vec::len(matches.free) > 0u {\n+             if !matches.free.is_empty() {\n                  option::Some(copy matches.free[0])\n              } else { option::None },\n         logfile: getopts::opt_maybe_str(matches, \"logfile\").map(|s| Path(*s)),\n@@ -224,11 +231,11 @@ pub fn is_test(config: &config, testfile: &Path) -> bool {\n     let mut valid = false;\n \n     for valid_extensions.each |ext| {\n-        if str::ends_with(name, *ext) { valid = true; }\n+        if name.ends_with(*ext) { valid = true; }\n     }\n \n     for invalid_prefixes.each |pre| {\n-        if str::starts_with(name, *pre) { valid = false; }\n+        if name.starts_with(*pre) { valid = false; }\n     }\n \n     return valid;\n@@ -253,7 +260,7 @@ pub fn make_test_name(config: &config, testfile: &Path) -> test::TestName {\n \n pub fn make_test_closure(config: &config, testfile: &Path) -> test::TestFn {\n     use core::cell::Cell;\n-    let config = Cell(copy *config);\n-    let testfile = Cell(testfile.to_str());\n+    let config = Cell::new(copy *config);\n+    let testfile = Cell::new(testfile.to_str());\n     test::DynTestFn(|| { runtest::run(config.take(), testfile.take()) })\n }"}, {"sha": "cdc0defcbcab08c3bd9ffb00f857cb628be6c4bc", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -10,6 +10,8 @@\n \n use core::prelude::*;\n \n+use core::io;\n+\n pub struct ExpectedError { line: uint, kind: ~str, msg: ~str }\n \n // Load any test directives embedded in the file\n@@ -28,15 +30,15 @@ pub fn load_errors(testfile: &Path) -> ~[ExpectedError] {\n fn parse_expected(line_num: uint, line: ~str) -> ~[ExpectedError] {\n     let error_tag = ~\"//~\";\n     let mut idx;\n-    match str::find_str(line, error_tag) {\n+    match line.find_str(error_tag) {\n       None => return ~[],\n-      Some(nn) => { idx = (nn as uint) + str::len(error_tag); }\n+      Some(nn) => { idx = (nn as uint) + error_tag.len(); }\n     }\n \n     // \"//~^^^ kind msg\" denotes a message expected\n     // three lines above current line:\n     let mut adjust_line = 0u;\n-    let len = str::len(line);\n+    let len = line.len();\n     while idx < len && line[idx] == ('^' as u8) {\n         adjust_line += 1u;\n         idx += 1u;\n@@ -49,12 +51,12 @@ fn parse_expected(line_num: uint, line: ~str) -> ~[ExpectedError] {\n \n     // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n     // to_ascii_consume and to_str_consume to not do a unnecessary copy.\n-    let kind = str::slice(line, start_kind, idx);\n+    let kind = line.slice(start_kind, idx);\n     let kind = kind.to_ascii().to_lower().to_str_ascii();\n \n     // Extract msg:\n     while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n-    let msg = str::slice(line, idx, len).to_owned();\n+    let msg = line.slice(idx, len).to_owned();\n \n     debug!(\"line=%u kind=%s msg=%s\", line_num - adjust_line, kind, msg);\n "}, {"sha": "ddb68d481167ab895a20e90f540402b76e45059a", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -10,8 +10,11 @@\n \n use core::prelude::*;\n \n-use common;\n use common::config;\n+use common;\n+\n+use core::io;\n+use core::os;\n \n pub struct TestProps {\n     // Lines that should be expected, in order, on standard out\n@@ -95,7 +98,7 @@ pub fn is_test_ignored(config: &config, testfile: &Path) -> bool {\n     return false;\n \n     fn xfail_target() -> ~str {\n-        ~\"xfail-\" + str::to_owned(os::SYSNAME)\n+        ~\"xfail-\" + os::SYSNAME\n     }\n }\n \n@@ -107,7 +110,7 @@ fn iter_header(testfile: &Path, it: &fn(~str) -> bool) -> bool {\n         // Assume that any directives will be found before the first\n         // module or function. This doesn't seem to be an optimization\n         // with a warm page cache. Maybe with a cold one.\n-        if str::starts_with(ln, \"fn\") || str::starts_with(ln, \"mod\") {\n+        if ln.starts_with(\"fn\") || ln.starts_with(\"mod\") {\n             return false;\n         } else { if !(it(ln)) { return false; } }\n     }\n@@ -137,8 +140,8 @@ fn parse_check_line(line: &str) -> Option<~str> {\n fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n     do parse_name_value_directive(line, ~\"exec-env\").map |nv| {\n         // nv is either FOO or FOO=BAR\n-        let mut strs = ~[];\n-        for str::each_splitn_char(*nv, '=', 1u) |s| { strs.push(s.to_owned()); }\n+        let mut strs: ~[~str] = nv.splitn_iter('=', 1).transform(|s| s.to_owned()).collect();\n+\n         match strs.len() {\n           1u => (strs.pop(), ~\"\"),\n           2u => {\n@@ -164,16 +167,16 @@ fn parse_pp_exact(line: &str, testfile: &Path) -> Option<Path> {\n }\n \n fn parse_name_directive(line: &str, directive: &str) -> bool {\n-    str::contains(line, directive)\n+    line.contains(directive)\n }\n \n fn parse_name_value_directive(line: &str,\n                               directive: ~str) -> Option<~str> {\n-    let keycolon = directive + ~\":\";\n-    match str::find_str(line, keycolon) {\n+    let keycolon = directive + \":\";\n+    match line.find_str(keycolon) {\n         Some(colon) => {\n-            let value = str::slice(line, colon + str::len(keycolon),\n-                                   str::len(line)).to_owned();\n+            let value = line.slice(colon + keycolon.len(),\n+                                   line.len()).to_owned();\n             debug!(\"%s: %s\", directive,  value);\n             Some(value)\n         }"}, {"sha": "b5404e38ec961853404b062fa60fad4766c3b642", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -10,23 +10,25 @@\n \n use core::prelude::*;\n \n+use core::os;\n use core::run;\n+use core::str;\n \n #[cfg(target_os = \"win32\")]\n fn target_env(lib_path: &str, prog: &str) -> ~[(~str,~str)] {\n \n     let mut env = os::env();\n \n     // Make sure we include the aux directory in the path\n-    assert!(prog.ends_with(~\".exe\"));\n-    let aux_path = prog.slice(0u, prog.len() - 4u).to_owned() + ~\".libaux\";\n+    assert!(prog.ends_with(\".exe\"));\n+    let aux_path = prog.slice(0u, prog.len() - 4u).to_owned() + \".libaux\";\n \n     env = do vec::map(env) |pair| {\n-        let (k,v) = *pair;\n-        if k == ~\"PATH\" { (~\"PATH\", v + ~\";\" + lib_path + ~\";\" + aux_path) }\n+        let (k,v) = copy *pair;\n+        if k == ~\"PATH\" { (~\"PATH\", v + \";\" + lib_path + \";\" + aux_path) }\n         else { (k,v) }\n     };\n-    if str::ends_with(prog, \"rustc.exe\") {\n+    if prog.ends_with(\"rustc.exe\") {\n         env.push((~\"RUST_THREADS\", ~\"1\"));\n     }\n     return env;\n@@ -56,7 +58,7 @@ pub fn run(lib_path: &str,\n         err_fd: None\n     });\n \n-    for input.each |input| {\n+    for input.iter().advance |input| {\n         proc.input().write_str(*input);\n     }\n     let output = proc.finish_with_output();\n@@ -67,4 +69,3 @@ pub fn run(lib_path: &str,\n         err: str::from_bytes(output.error)\n     }\n }\n-"}, {"sha": "891935dcadd0c02f4b57bb4d8025f6bbbf5f1d75", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 77, "deletions": 68, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -22,6 +22,12 @@ use procsrv;\n use util;\n use util::logv;\n \n+use core::io;\n+use core::os;\n+use core::str;\n+use core::uint;\n+use core::vec;\n+\n pub fn run(config: config, testfile: ~str) {\n     if config.verbose {\n         // We're going to be dumping a lot of info. Start on a new line.\n@@ -164,8 +170,8 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     if props.pp_exact.is_some() {\n         // Now we have to care about line endings\n         let cr = ~\"\\r\";\n-        actual = str::replace(actual, cr, \"\");\n-        expected = str::replace(expected, cr, \"\");\n+        actual = actual.replace(cr, \"\");\n+        expected = expected.replace(cr, \"\");\n     }\n \n     compare_source(expected, actual);\n@@ -231,13 +237,13 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n     // do not optimize debuginfo tests\n     let mut config = match config.rustcflags {\n         Some(ref flags) => config {\n-            rustcflags: Some(str::replace(*flags, \"-O\", \"\")),\n+            rustcflags: Some(flags.replace(\"-O\", \"\")),\n             .. copy *config\n         },\n         None => copy *config\n     };\n     let config = &mut config;\n-    let cmds = str::connect(props.debugger_cmds, \"\\n\");\n+    let cmds = props.debugger_cmds.connect(\"\\n\");\n     let check_lines = copy props.check_lines;\n \n     // compile test file (it shoud have 'compile-flags:-g' in the header)\n@@ -247,7 +253,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n     }\n \n     // write debugger script\n-    let script_str = str::append(cmds, \"\\nquit\\n\");\n+    let script_str = cmds.append(\"\\nquit\\n\");\n     debug!(\"script_str = %s\", script_str);\n     dump_output_file(config, testfile, script_str, \"debugger.script\");\n \n@@ -271,7 +277,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n         // check if each line in props.check_lines appears in the\n         // output (in order)\n         let mut i = 0u;\n-        for str::each_line(ProcRes.stdout) |line| {\n+        for ProcRes.stdout.line_iter().advance |line| {\n             if check_lines[i].trim() == line.trim() {\n                 i += 1u;\n             }\n@@ -290,7 +296,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n fn check_error_patterns(props: &TestProps,\n                         testfile: &Path,\n                         ProcRes: &ProcRes) {\n-    if vec::is_empty(props.error_patterns) {\n+    if props.error_patterns.is_empty() {\n         fatal(~\"no error pattern specified in \" + testfile.to_str());\n     }\n \n@@ -301,8 +307,8 @@ fn check_error_patterns(props: &TestProps,\n     let mut next_err_idx = 0u;\n     let mut next_err_pat = &props.error_patterns[next_err_idx];\n     let mut done = false;\n-    for str::each_line(ProcRes.stderr) |line| {\n-        if str::contains(line, *next_err_pat) {\n+    for ProcRes.stderr.line_iter().advance |line| {\n+        if line.contains(*next_err_pat) {\n             debug!(\"found error pattern %s\", *next_err_pat);\n             next_err_idx += 1u;\n             if next_err_idx == props.error_patterns.len() {\n@@ -351,15 +357,15 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n     //    filename:line1:col1: line2:col2: *warning:* msg\n     // where line1:col1: is the starting point, line2:col2:\n     // is the ending point, and * represents ANSI color codes.\n-    for str::each_line(ProcRes.stderr) |line| {\n+    for ProcRes.stderr.line_iter().advance |line| {\n         let mut was_expected = false;\n         for vec::eachi(expected_errors) |i, ee| {\n             if !found_flags[i] {\n                 debug!(\"prefix=%s ee.kind=%s ee.msg=%s line=%s\",\n                        prefixes[i], ee.kind, ee.msg, line);\n-                if (str::starts_with(line, prefixes[i]) &&\n-                    str::contains(line, ee.kind) &&\n-                    str::contains(line, ee.msg)) {\n+                if (line.starts_with(prefixes[i]) &&\n+                    line.contains(ee.kind) &&\n+                    line.contains(ee.msg)) {\n                     found_flags[i] = true;\n                     was_expected = true;\n                     break;\n@@ -368,11 +374,11 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n         }\n \n         // ignore this msg which gets printed at the end\n-        if str::contains(line, \"aborting due to\") {\n+        if line.contains(\"aborting due to\") {\n             was_expected = true;\n         }\n \n-        if !was_expected && is_compiler_error_or_warning(str::to_owned(line)) {\n+        if !was_expected && is_compiler_error_or_warning(line) {\n             fatal_ProcRes(fmt!(\"unexpected compiler error or warning: '%s'\",\n                                line),\n                           ProcRes);\n@@ -410,7 +416,7 @@ fn scan_until_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n     if *idx >= haystack.len() {\n         return false;\n     }\n-    let opt = str::find_char_from(haystack, needle, *idx);\n+    let opt = haystack.slice_from(*idx).find(needle);\n     if opt.is_none() {\n         return false;\n     }\n@@ -422,7 +428,7 @@ fn scan_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n     if *idx >= haystack.len() {\n         return false;\n     }\n-    let range = str::char_range_at(haystack, *idx);\n+    let range = haystack.char_range_at(*idx);\n     if range.ch != needle {\n         return false;\n     }\n@@ -433,7 +439,7 @@ fn scan_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n fn scan_integer(haystack: &str, idx: &mut uint) -> bool {\n     let mut i = *idx;\n     while i < haystack.len() {\n-        let range = str::char_range_at(haystack, i);\n+        let range = haystack.char_range_at(i);\n         if range.ch < '0' || '9' < range.ch {\n             break;\n         }\n@@ -453,7 +459,7 @@ fn scan_string(haystack: &str, needle: &str, idx: &mut uint) -> bool {\n         if haystack_i >= haystack.len() {\n             return false;\n         }\n-        let range = str::char_range_at(haystack, haystack_i);\n+        let range = haystack.char_range_at(haystack_i);\n         haystack_i = range.next;\n         if !scan_char(needle, range.ch, &mut needle_i) {\n             return false;\n@@ -590,8 +596,7 @@ fn make_lib_name(config: &config, auxfile: &Path, testfile: &Path) -> Path {\n }\n \n fn make_exe_name(config: &config, testfile: &Path) -> Path {\n-    Path(output_base_name(config, testfile).to_str() +\n-            str::to_owned(os::EXE_SUFFIX))\n+    Path(output_base_name(config, testfile).to_str() + os::EXE_SUFFIX)\n }\n \n fn make_run_args(config: &config, _props: &TestProps, testfile: &Path) ->\n@@ -600,21 +605,17 @@ fn make_run_args(config: &config, _props: &TestProps, testfile: &Path) ->\n     // then split apart its command\n     let toolargs = split_maybe_args(&config.runtool);\n \n-    let mut args = toolargs + ~[make_exe_name(config, testfile).to_str()];\n+    let mut args = toolargs + [make_exe_name(config, testfile).to_str()];\n     let prog = args.shift();\n     return ProcArgs {prog: prog, args: args};\n }\n \n fn split_maybe_args(argstr: &Option<~str>) -> ~[~str] {\n-    fn rm_whitespace(v: ~[~str]) -> ~[~str] {\n-        v.filtered(|s| !str::is_whitespace(*s))\n-    }\n-\n     match *argstr {\n         Some(ref s) => {\n-            let mut ss = ~[];\n-            for str::each_split_char(*s, ' ') |s| { ss.push(s.to_owned()) }\n-            rm_whitespace(ss)\n+            s.split_iter(' ')\n+                .filter_map(|s| if s.is_whitespace() {None} else {Some(s.to_owned())})\n+                .collect()\n         }\n         None => ~[]\n     }\n@@ -643,13 +644,13 @@ fn program_output(config: &config, testfile: &Path, lib_path: &str, prog: ~str,\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n fn make_cmdline(_libpath: &str, prog: &str, args: &[~str]) -> ~str {\n-    fmt!(\"%s %s\", prog, str::connect(args, \" \"))\n+    fmt!(\"%s %s\", prog, args.connect(\" \"))\n }\n \n #[cfg(target_os = \"win32\")]\n fn make_cmdline(libpath: &str, prog: &str, args: &[~str]) -> ~str {\n     fmt!(\"%s %s %s\", lib_path_cmd_prefix(libpath), prog,\n-         str::connect(args, ~\" \"))\n+         args.connect(\" \"))\n }\n \n // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n@@ -733,8 +734,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     let cmdline = make_cmdline(\"\", args.prog, args.args);\n \n     // get bare program string\n-    let mut tvec = ~[];\n-    for str::each_split_char(args.prog, '/') |ts| { tvec.push(ts.to_owned()) }\n+    let mut tvec: ~[~str] = args.prog.split_iter('/').transform(|ts| ts.to_owned()).collect();\n     let prog_short = tvec.pop();\n \n     // copy to target\n@@ -748,53 +748,62 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n             copy_result.out, copy_result.err));\n     }\n \n-    // execute program\n     logv(config, fmt!(\"executing (%s) %s\", config.target, cmdline));\n \n-    // adb shell dose not forward stdout and stderr of internal result\n-    // to stdout and stderr separately but to stdout only\n-    let mut newargs_out = ~[];\n-    let mut newargs_err = ~[];\n-    newargs_out.push(~\"shell\");\n-    newargs_err.push(~\"shell\");\n+    let mut runargs = ~[];\n \n-    let mut newcmd_out = ~\"\";\n-    let mut newcmd_err = ~\"\";\n+    // run test via adb_run_wrapper\n+    runargs.push(~\"shell\");\n+    runargs.push(fmt!(\"%s/adb_run_wrapper.sh\", config.adb_test_dir));\n+    runargs.push(fmt!(\"%s\", config.adb_test_dir));\n+    runargs.push(fmt!(\"%s\", prog_short));\n \n-    newcmd_out.push_str(fmt!(\"LD_LIBRARY_PATH=%s %s/%s\",\n-        config.adb_test_dir, config.adb_test_dir, prog_short));\n+    for args.args.each |tv| {\n+        runargs.push(tv.to_owned());\n+    }\n \n-    newcmd_err.push_str(fmt!(\"LD_LIBRARY_PATH=%s %s/%s\",\n-        config.adb_test_dir, config.adb_test_dir, prog_short));\n+    procsrv::run(\"\", config.adb_path, runargs, ~[(~\"\",~\"\")], Some(~\"\"));\n \n-    for args.args.each |tv| {\n-        newcmd_out.push_str(\" \");\n-        newcmd_err.push_str(\" \");\n-        newcmd_out.push_str(tv.to_owned());\n-        newcmd_err.push_str(tv.to_owned());\n+    // get exitcode of result\n+    runargs = ~[];\n+    runargs.push(~\"shell\");\n+    runargs.push(~\"cat\");\n+    runargs.push(fmt!(\"%s/%s.exitcode\", config.adb_test_dir, prog_short));\n+\n+    let procsrv::Result{ out: exitcode_out, err: _, status: _ } =\n+        procsrv::run(\"\", config.adb_path, runargs, ~[(~\"\",~\"\")],\n+                     Some(~\"\"));\n+\n+    let mut exitcode : int = 0;\n+    for exitcode_out.iter().advance |c| {\n+        if !c.is_digit() { break; }\n+        exitcode = exitcode * 10 + match c {\n+            '0' .. '9' => c as int - ('0' as int),\n+            _ => 101,\n+        }\n     }\n \n-    newcmd_out.push_str(\" 2>/dev/null\");\n-    newcmd_err.push_str(\" 1>/dev/null\");\n+    // get stdout of result\n+    runargs = ~[];\n+    runargs.push(~\"shell\");\n+    runargs.push(~\"cat\");\n+    runargs.push(fmt!(\"%s/%s.stdout\", config.adb_test_dir, prog_short));\n \n-    newargs_out.push(newcmd_out);\n-    newargs_err.push(newcmd_err);\n+    let procsrv::Result{ out: stdout_out, err: _, status: _ } =\n+        procsrv::run(\"\", config.adb_path, runargs, ~[(~\"\",~\"\")], Some(~\"\"));\n \n-    let procsrv::Result{ out: out_out, err: _out_err, status: out_status } =\n-            procsrv::run(\"\", config.adb_path, newargs_out, ~[(~\"\",~\"\")],\n-                         Some(~\"\"));\n-    let procsrv::Result{ out: err_out, err: _err_err, status: _err_status } =\n-            procsrv::run(\"\", config.adb_path, newargs_err, ~[(~\"\",~\"\")],\n-                         Some(~\"\"));\n+    // get stderr of result\n+    runargs = ~[];\n+    runargs.push(~\"shell\");\n+    runargs.push(~\"cat\");\n+    runargs.push(fmt!(\"%s/%s.stderr\", config.adb_test_dir, prog_short));\n \n-    dump_output(config, testfile, out_out, err_out);\n+    let procsrv::Result{ out: stderr_out, err: _, status: _ } =\n+        procsrv::run(\"\", config.adb_path, runargs, ~[(~\"\",~\"\")], Some(~\"\"));\n \n-    match err_out {\n-        ~\"\" => ProcRes {status: out_status, stdout: out_out,\n-            stderr: err_out, cmdline: cmdline },\n-        _   => ProcRes {status: 101, stdout: out_out,\n-            stderr: err_out, cmdline: cmdline }\n-    }\n+    dump_output(config, testfile, stdout_out, stderr_out);\n+\n+    ProcRes {status: exitcode, stdout: stdout_out, stderr: stderr_out, cmdline: cmdline }\n }\n \n fn _dummy_exec_compiled_test(config: &config, props: &TestProps,"}, {"sha": "26a62f8a5b22456c58687e690b22dd3265209411", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -12,6 +12,7 @@ use core::prelude::*;\n \n use common::config;\n \n+use core::io;\n use core::os::getenv;\n \n pub fn make_new_path(path: &str) -> ~str {"}, {"sha": "fb1e0937fc920510a029564c14bd2068a9f06b3a", "filename": "src/etc/adb_run_wrapper.sh", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fetc%2Fadb_run_wrapper.sh", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fetc%2Fadb_run_wrapper.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fadb_run_wrapper.sh?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -0,0 +1,35 @@\n+#\n+# usage : adb_run_wrapper [test dir - where test executables exist] [test executable]\n+#\n+\n+# Sometimes android shell produce exitcode \"1 : Text File Busy\"\n+# Retry after $WAIT seconds, expecting resource cleaned-up\n+WAIT=10\n+PATH=$1\n+if [ -d \"$PATH\" ]\n+then\n+    shift\n+    RUN=$1\n+\n+    if [ ! -z \"$RUN\" ]\n+    then\n+        shift\n+\n+        L_RET=1\n+        L_COUNT=0\n+        while [ $L_RET -eq 1 ]\n+        do\n+            LD_LIBRARY_PATH=$PATH $PATH/$RUN $@ 1>$PATH/$RUN.stdout 2>$PATH/$RUN.stderr\n+            L_RET=$?\n+            if [ $L_COUNT -gt 0 ]\n+            then\n+               /system/bin/sleep $WAIT\n+               /system/bin/sync\n+            fi\n+            L_COUNT=`expr $L_COUNT+1`\n+        done\n+\n+        echo $L_RET > $PATH/$RUN.exitcode\n+\n+    fi\n+fi"}, {"sha": "8e9caf189c220fdbbfecae4d2b5c8dd20fb28c3e", "filename": "src/etc/combine-tests.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fetc%2Fcombine-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fetc%2Fcombine-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcombine-tests.py?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -53,6 +53,7 @@ def scrub(b):\n d.write(\"extern mod run_pass_stage2;\\n\")\n d.write(\"use run_pass_stage2::*;\\n\")\n d.write(\"use std::io::WriterUtil;\\n\");\n+d.write(\"use std::io;\\n\");\n d.write(\"fn main() {\\n\");\n d.write(\"    let out = io::stdout();\\n\");\n i = 0"}, {"sha": "44d0ce1a27fc51d28de752c7a1b03c108ff080c2", "filename": "src/etc/kate/rust.xml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fetc%2Fkate%2Frust.xml", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fetc%2Fkate%2Frust.xml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fkate%2Frust.xml?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -49,6 +49,7 @@\n \t\t<item> Copy </item>\n \t\t<item> Send </item>\n \t\t<item> Owned </item>\n+\t\t<item> Sized </item>\n \t\t<item> Eq </item>\n \t\t<item> Ord </item>\n \t\t<item> Num </item>"}, {"sha": "5c08fdfecca55fcf2d37ea377621377d570338f4", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -44,7 +44,7 @@ syn keyword   rustType        size_t ptrdiff_t clock_t time_t\n syn keyword   rustType        c_longlong c_ulonglong intptr_t uintptr_t\n syn keyword   rustType        off_t dev_t ino_t pid_t mode_t ssize_t\n \n-syn keyword   rustTrait       Const Copy Send Owned \" inherent traits\n+syn keyword   rustTrait       Const Copy Send Owned Sized \" inherent traits\n syn keyword   rustTrait       Eq Ord Num Ptr\n syn keyword   rustTrait       Drop Add Sub Mul Quot Rem Neg BitAnd BitOr\n syn keyword   rustTrait       BitXor Shl Shr Index"}, {"sha": "faa21a296169404ef528dff6e336c287355494ad", "filename": "src/etc/zsh/_rust", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fetc%2Fzsh%2F_rust", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Fetc%2Fzsh%2F_rust", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fzsh%2F_rust?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -0,0 +1,102 @@\n+#compdef rustc\n+\n+local -a _rustc_opts_switches _rustc_opts_lint _rustc_opts_debug\n+\n+typeset -A opt_args\n+\n+_rustc_opts_switches=(\n+    --bin'[Compile an executable crate (default)]'\n+    -c'[Compile and assemble, but do not link]'\n+    --cfg'[Configure the compilation environment]'\n+    --emit-llvm'[Produce an LLVM bitcode file]'\n+    {-h,--help}'[Display this message]'\n+    -L'[Add a directory to the library search path]'\n+    --lib'[Compile a library crate]'\n+    --linker'[Program to use for linking instead of the default.]'\n+    --link-args'[FLAGS is a space-separated list of flags passed to the linker]'\n+    --ls'[List the symbols defined by a library crate]'\n+    --no-trans'[Run all passes except translation; no output]'\n+    -O'[Equivalent to --opt-level=2]'\n+    -o'[Write output to <filename>]'\n+    --opt-level'[Optimize with possible levels 0-3]'\n+    --out-dir'[Write output to compiler-chosen filename in <dir>]'\n+    --parse-only'[Parse only; do not compile, assemble, or link]'\n+    --pretty'[Pretty-print the input instead of compiling]'\n+    -S'[Compile only; do not assemble or link]'\n+    --save-temps'[Write intermediate files (.bc, .opt.bc, .o) in addition to normal output]'\n+    --sysroot'[Override the system root]'\n+    --test'[Build a test harness]'\n+    --target'[Target triple cpu-manufacturer-kernel\\[-os\\] to compile]'\n+    --target-feature'[Target specific attributes (llc -mattr=help for detail)]'\n+    --android-cross-path'[The path to the Android NDK]'\n+    {-W,--warn}'[Set lint warnings]'\n+    {-A,--allow}'[Set lint allowed]'\n+    {-D,--deny}'[Set lint denied]'\n+    {-F,--forbid}'[Set lint forbidden]'\n+    -Z'[Set internal debugging options]'\n+    {-v,--version}'[Print version info and exit]'\n+)\n+\n+_rustc_opts_lint=(\n+    'path-statement:path statements with no effect'\n+    'deprecated-pattern:warn about deprecated uses of pattern bindings'\n+    'non-implicitly-copyable-typarams:passing non implicitly copyable types as copy type params'\n+    'missing-trait-doc:detects missing documentation for traits'\n+    'missing-struct-doc:detects missing documentation for structs'\n+    'ctypes:proper use of core::libc types in foreign modules'\n+    'implicit-copies:implicit copies of non implicitly copyable data'\n+    \"unused-mut:detect mut variables which don't need to be mutable\"\n+    'unused-imports:imports that are never used'\n+    'heap-memory:use of any (~ type or @ type) heap memory'\n+    'default-methods:allow default methods'\n+    'unused-variable:detect variables which are not used in any way'\n+    'dead-assignment:detect assignments that will never be read'\n+    'unrecognized-lint:unrecognized lint attribute'\n+    'type-limits:comparisons made useless by limits of the types involved'\n+    'unused-unsafe:unnecessary use of an `unsafe` block'\n+    'while-true:suggest using loop { } instead of while(true) { }'\n+    'non-camel-case-types:types, variants and traits should have camel case names'\n+    'managed-heap-memory:use of managed (@ type) heap memory'\n+    'unnecessary-allocation:detects unnecessary allocations that can be eliminated'\n+    'owned-heap-memory:use of owned (~ type) heap memory'\n+)\n+\n+_rustc_opts_debug=(\n+    'verbose:in general, enable more debug printouts'\n+    'time-passes:measure time of each rustc pass'\n+    'count-llvm-insns:count where LLVM instrs originate'\n+    'time-llvm-passes:measure time of each LLVM pass'\n+    'trans-stats:gather trans statistics'\n+    'asm-comments:generate comments into the assembly (may change behavior)'\n+    'no-verify:skip LLVM verification'\n+    'trace:emit trace logs'\n+    'coherence:perform coherence checking'\n+    'borrowck-stats:gather borrowck statistics'\n+    \"borrowck-note-pure:note where purity is req'd\"\n+    \"borrowck-note-loan:note where loans are req'd\"\n+    'no-landing-pads:omit landing pads for unwinding'\n+    'debug-llvm:enable debug output from LLVM'\n+    'count-type-sizes:count the sizes of aggregate types'\n+    'meta-stats:gather metadata statistics'\n+    'no-opt:do not optimize, even if -O is passed'\n+    'no-monomorphic-collapse:do not collapse template instantiations'\n+    'print-link-args:Print the arguments passed to the linker'\n+    'gc:Garbage collect shared data (experimental)'\n+    'jit:Execute using JIT (experimental)'\n+    'extra-debug-info:Extra debugging info (experimental)'\n+    'debug-info:Produce debug info (experimental)'\n+    'static:Use or produce static libraries or binaries (experimental)'\n+    'no-debug-borrows:do not show where borrow checks fail'\n+    'lint-llvm:Run the LLVM lint pass on the pre-optimization IR'\n+)\n+\n+_rustc() {\n+    case $words[2] in\n+        -[WADF]) _describe 'options' _rustc_opts_lint ;;\n+        -Z) _describe 'options' _rustc_opts_debug ;;\n+        -)  _arguments -s -w : \"$_rustc_opts_switches[@]\" ;;\n+        *) _files -g \"*.rs\" ;;\n+  esac\n+}\n+\n+_rustc \"$@\""}, {"sha": "b1bec1f95dbd72d991bae07229644c384848b21e", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 172, "deletions": 92, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -37,15 +37,17 @@\n  * ~~~\n  */\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n use sync;\n use sync::{Mutex, mutex_with_condvars, RWlock, rwlock_with_condvars};\n \n use core::cast;\n use core::unstable::sync::UnsafeAtomicRcBox;\n-use core::ptr;\n use core::task;\n+use core::borrow;\n \n /// As sync::condvar, a mechanism for unlock-and-descheduling and signaling.\n pub struct Condvar<'self> {\n@@ -54,10 +56,10 @@ pub struct Condvar<'self> {\n     cond: &'self sync::Condvar<'self>\n }\n \n-pub impl<'self> Condvar<'self> {\n+impl<'self> Condvar<'self> {\n     /// Atomically exit the associated ARC and block until a signal is sent.\n     #[inline(always)]\n-    fn wait(&self) { self.wait_on(0) }\n+    pub fn wait(&self) { self.wait_on(0) }\n \n     /**\n      * Atomically exit the associated ARC and block on a specified condvar\n@@ -66,7 +68,7 @@ pub impl<'self> Condvar<'self> {\n      * wait() is equivalent to wait_on(0).\n      */\n     #[inline(always)]\n-    fn wait_on(&self, condvar_id: uint) {\n+    pub fn wait_on(&self, condvar_id: uint) {\n         assert!(!*self.failed);\n         self.cond.wait_on(condvar_id);\n         // This is why we need to wrap sync::condvar.\n@@ -75,28 +77,28 @@ pub impl<'self> Condvar<'self> {\n \n     /// Wake up a blocked task. Returns false if there was no blocked task.\n     #[inline(always)]\n-    fn signal(&self) -> bool { self.signal_on(0) }\n+    pub fn signal(&self) -> bool { self.signal_on(0) }\n \n     /**\n      * Wake up a blocked task on a specified condvar (as\n      * sync::cond.signal_on). Returns false if there was no blocked task.\n      */\n     #[inline(always)]\n-    fn signal_on(&self, condvar_id: uint) -> bool {\n+    pub fn signal_on(&self, condvar_id: uint) -> bool {\n         assert!(!*self.failed);\n         self.cond.signal_on(condvar_id)\n     }\n \n     /// Wake up all blocked tasks. Returns the number of tasks woken.\n     #[inline(always)]\n-    fn broadcast(&self) -> uint { self.broadcast_on(0) }\n+    pub fn broadcast(&self) -> uint { self.broadcast_on(0) }\n \n     /**\n      * Wake up all blocked tasks on a specified condvar (as\n-     * sync::cond.broadcast_on). Returns Returns the number of tasks woken.\n+     * sync::cond.broadcast_on). Returns the number of tasks woken.\n      */\n     #[inline(always)]\n-    fn broadcast_on(&self, condvar_id: uint) -> uint {\n+    pub fn broadcast_on(&self, condvar_id: uint) -> uint {\n         assert!(!*self.failed);\n         self.cond.broadcast_on(condvar_id)\n     }\n@@ -118,8 +120,8 @@ pub fn ARC<T:Const + Owned>(data: T) -> ARC<T> {\n  * Access the underlying data in an atomically reference counted\n  * wrapper.\n  */\n-pub impl<T:Const+Owned> ARC<T> {\n-    fn get<'a>(&'a self) -> &'a T {\n+impl<T:Const+Owned> ARC<T> {\n+    pub fn get<'a>(&'a self) -> &'a T {\n         unsafe { &*self.x.get_immut() }\n     }\n }\n@@ -171,7 +173,7 @@ impl<T:Owned> Clone for MutexARC<T> {\n     }\n }\n \n-pub impl<T:Owned> MutexARC<T> {\n+impl<T:Owned> MutexARC<T> {\n \n     /**\n      * Access the underlying mutable data with mutual exclusion from other\n@@ -197,23 +199,25 @@ pub impl<T:Owned> MutexARC<T> {\n      * blocked on the mutex) will also fail immediately.\n      */\n     #[inline(always)]\n-    unsafe fn access<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n-        let state = self.x.get();\n-        // Borrowck would complain about this if the function were\n-        // not already unsafe. See borrow_rwlock, far below.\n-        do (&(*state).lock).lock {\n-            check_poison(true, (*state).failed);\n-            let _z = PoisonOnFail(&mut (*state).failed);\n-            blk(&mut (*state).data)\n+    pub unsafe fn access<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n+        unsafe {\n+            let state = self.x.get();\n+            // Borrowck would complain about this if the function were\n+            // not already unsafe. See borrow_rwlock, far below.\n+            do (&(*state).lock).lock {\n+                check_poison(true, (*state).failed);\n+                let _z = PoisonOnFail(&mut (*state).failed);\n+                blk(&mut (*state).data)\n+            }\n         }\n     }\n \n     /// As access(), but with a condvar, as sync::mutex.lock_cond().\n     #[inline(always)]\n-    unsafe fn access_cond<'x, 'c, U>(\n-        &self,\n-        blk: &fn(x: &'x mut T, c: &'c Condvar) -> U) -> U\n-    {\n+    pub unsafe fn access_cond<'x, 'c, U>(&self,\n+                                         blk: &fn(x: &'x mut T,\n+                                                  c: &'c Condvar) -> U)\n+                                         -> U {\n         let state = self.x.get();\n         do (&(*state).lock).lock_cond |cond| {\n             check_poison(true, (*state).failed);\n@@ -258,7 +262,7 @@ impl Drop for PoisonOnFail {\n \n fn PoisonOnFail<'r>(failed: &'r mut bool) -> PoisonOnFail {\n     PoisonOnFail {\n-        failed: ptr::to_mut_unsafe_ptr(failed)\n+        failed: failed\n     }\n }\n \n@@ -277,7 +281,6 @@ struct RWARCInner<T> { lock: RWlock, failed: bool, data: T }\n #[mutable]\n struct RWARC<T> {\n     x: UnsafeAtomicRcBox<RWARCInner<T>>,\n-    cant_nest: ()\n }\n \n /// Create a reader/writer ARC with the supplied data.\n@@ -295,19 +298,20 @@ pub fn rw_arc_with_condvars<T:Const + Owned>(\n     let data =\n         RWARCInner { lock: rwlock_with_condvars(num_condvars),\n                      failed: false, data: user_data };\n-    RWARC { x: UnsafeAtomicRcBox::new(data), cant_nest: () }\n+    RWARC { x: UnsafeAtomicRcBox::new(data), }\n }\n \n-pub impl<T:Const + Owned> RWARC<T> {\n+impl<T:Const + Owned> RWARC<T> {\n     /// Duplicate a rwlock-protected ARC, as arc::clone.\n-    fn clone(&self) -> RWARC<T> {\n-        RWARC { x: self.x.clone(),\n-                cant_nest: () }\n+    pub fn clone(&self) -> RWARC<T> {\n+        RWARC {\n+            x: self.x.clone(),\n+        }\n     }\n \n }\n \n-pub impl<T:Const + Owned> RWARC<T> {\n+impl<T:Const + Owned> RWARC<T> {\n     /**\n      * Access the underlying data mutably. Locks the rwlock in write mode;\n      * other readers and writers will block.\n@@ -319,7 +323,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n      * poison the ARC, so subsequent readers and writers will both also fail.\n      */\n     #[inline(always)]\n-    fn write<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n+    pub fn write<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n         unsafe {\n             let state = self.x.get();\n             do (*borrow_rwlock(state)).write {\n@@ -329,11 +333,12 @@ pub impl<T:Const + Owned> RWARC<T> {\n             }\n         }\n     }\n+\n     /// As write(), but with a condvar, as sync::rwlock.write_cond().\n     #[inline(always)]\n-    fn write_cond<'x, 'c, U>(&self,\n-                             blk: &fn(x: &'x mut T, c: &'c Condvar) -> U)\n-                          -> U {\n+    pub fn write_cond<'x, 'c, U>(&self,\n+                                 blk: &fn(x: &'x mut T, c: &'c Condvar) -> U)\n+                                 -> U {\n         unsafe {\n             let state = self.x.get();\n             do (*borrow_rwlock(state)).write_cond |cond| {\n@@ -346,6 +351,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n             }\n         }\n     }\n+\n     /**\n      * Access the underlying data immutably. May run concurrently with other\n      * reading tasks.\n@@ -355,9 +361,9 @@ pub impl<T:Const + Owned> RWARC<T> {\n      * Failing will unlock the ARC while unwinding. However, unlike all other\n      * access modes, this will not poison the ARC.\n      */\n-    fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n-        let state = self.x.get();\n+    pub fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n         unsafe {\n+            let state = self.x.get();\n             do (*state).lock.read {\n                 check_poison(false, (*state).failed);\n                 blk(&(*state).data)\n@@ -374,18 +380,18 @@ pub impl<T:Const + Owned> RWARC<T> {\n      * # Example\n      *\n      * ~~~ {.rust}\n-     * do arc.write_downgrade |write_mode| {\n-     *     do (&write_mode).write_cond |state, condvar| {\n+     * do arc.write_downgrade |mut write_token| {\n+     *     do write_token.write_cond |state, condvar| {\n      *         ... exclusive access with mutable state ...\n      *     }\n-     *     let read_mode = arc.downgrade(write_mode);\n-     *     do (&read_mode).read |state| {\n+     *     let read_token = arc.downgrade(write_token);\n+     *     do read_token.read |state| {\n      *         ... shared access with immutable state ...\n      *     }\n      * }\n      * ~~~\n      */\n-    fn write_downgrade<U>(&self, blk: &fn(v: RWWriteMode<T>) -> U) -> U {\n+    pub fn write_downgrade<U>(&self, blk: &fn(v: RWWriteMode<T>) -> U) -> U {\n         unsafe {\n             let state = self.x.get();\n             do (*borrow_rwlock(state)).write_downgrade |write_mode| {\n@@ -400,7 +406,8 @@ pub impl<T:Const + Owned> RWARC<T> {\n     }\n \n     /// To be called inside of the write_downgrade block.\n-    fn downgrade<'a>(&self, token: RWWriteMode<'a, T>) -> RWReadMode<'a, T> {\n+    pub fn downgrade<'a>(&self, token: RWWriteMode<'a, T>)\n+                         -> RWReadMode<'a, T> {\n         unsafe {\n             // The rwlock should assert that the token belongs to us for us.\n             let state = self.x.get();\n@@ -416,7 +423,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n             // of this cast is removing the mutability.)\n             let new_data = cast::transmute_immut(data);\n             // Downgrade ensured the token belonged to us. Just a sanity check.\n-            assert!(ptr::ref_eq(&(*state).data, new_data));\n+            assert!(borrow::ref_eq(&(*state).data, new_data));\n             // Produce new token\n             RWReadMode {\n                 data: new_data,\n@@ -447,9 +454,9 @@ pub struct RWReadMode<'self, T> {\n     token: sync::RWlockReadMode<'self>,\n }\n \n-pub impl<'self, T:Const + Owned> RWWriteMode<'self, T> {\n+impl<'self, T:Const + Owned> RWWriteMode<'self, T> {\n     /// Access the pre-downgrade RWARC in write mode.\n-    fn write<U>(&mut self, blk: &fn(x: &mut T) -> U) -> U {\n+    pub fn write<U>(&mut self, blk: &fn(x: &mut T) -> U) -> U {\n         match *self {\n             RWWriteMode {\n                 data: &ref mut data,\n@@ -462,10 +469,11 @@ pub impl<'self, T:Const + Owned> RWWriteMode<'self, T> {\n             }\n         }\n     }\n+\n     /// Access the pre-downgrade RWARC in write mode with a condvar.\n-    fn write_cond<'x, 'c, U>(&mut self,\n-                             blk: &fn(x: &'x mut T, c: &'c Condvar) -> U)\n-                          -> U {\n+    pub fn write_cond<'x, 'c, U>(&mut self,\n+                                 blk: &fn(x: &'x mut T, c: &'c Condvar) -> U)\n+                                 -> U {\n         match *self {\n             RWWriteMode {\n                 data: &ref mut data,\n@@ -487,9 +495,9 @@ pub impl<'self, T:Const + Owned> RWWriteMode<'self, T> {\n     }\n }\n \n-pub impl<'self, T:Const + Owned> RWReadMode<'self, T> {\n+impl<'self, T:Const + Owned> RWReadMode<'self, T> {\n     /// Access the post-downgrade rwlock in read mode.\n-    fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n+    pub fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n         match *self {\n             RWReadMode {\n                 data: data,\n@@ -508,9 +516,13 @@ pub impl<'self, T:Const + Owned> RWReadMode<'self, T> {\n #[cfg(test)]\n mod tests {\n     use core::prelude::*;\n-    use core::cell::Cell;\n+\n     use arc::*;\n \n+    use core::cell::Cell;\n+    use core::comm;\n+    use core::task;\n+\n     #[test]\n     fn manually_share_arc() {\n         let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n@@ -539,59 +551,65 @@ mod tests {\n \n     #[test]\n     fn test_mutex_arc_condvar() {\n-        let arc = ~MutexARC(false);\n-        let arc2 = ~arc.clone();\n-        let (p,c) = comm::oneshot();\n-        let (c,p) = (Cell(c), Cell(p));\n-        do task::spawn || {\n-            // wait until parent gets in\n-            comm::recv_one(p.take());\n-            do arc2.access_cond |state, cond| {\n-                *state = true;\n-                cond.signal();\n+        unsafe {\n+            let arc = ~MutexARC(false);\n+            let arc2 = ~arc.clone();\n+            let (p,c) = comm::oneshot();\n+            let (c,p) = (Cell::new(c), Cell::new(p));\n+            do task::spawn || {\n+                // wait until parent gets in\n+                comm::recv_one(p.take());\n+                do arc2.access_cond |state, cond| {\n+                    *state = true;\n+                    cond.signal();\n+                }\n             }\n-        }\n-        do arc.access_cond |state, cond| {\n-            comm::send_one(c.take(), ());\n-            assert!(!*state);\n-            while !*state {\n-                cond.wait();\n+            do arc.access_cond |state, cond| {\n+                comm::send_one(c.take(), ());\n+                assert!(!*state);\n+                while !*state {\n+                    cond.wait();\n+                }\n             }\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_arc_condvar_poison() {\n-        let arc = ~MutexARC(1);\n-        let arc2 = ~arc.clone();\n-        let (p, c) = comm::stream();\n-\n-        do task::spawn_unlinked || {\n-            let _ = p.recv();\n-            do arc2.access_cond |one, cond| {\n-                cond.signal();\n-                // Parent should fail when it wakes up.\n-                assert_eq!(*one, 0);\n+        unsafe {\n+            let arc = ~MutexARC(1);\n+            let arc2 = ~arc.clone();\n+            let (p, c) = comm::stream();\n+\n+            do task::spawn_unlinked || {\n+                let _ = p.recv();\n+                do arc2.access_cond |one, cond| {\n+                    cond.signal();\n+                    // Parent should fail when it wakes up.\n+                    assert_eq!(*one, 0);\n+                }\n             }\n-        }\n \n-        do arc.access_cond |one, cond| {\n-            c.send(());\n-            while *one == 1 {\n-                cond.wait();\n+            do arc.access_cond |one, cond| {\n+                c.send(());\n+                while *one == 1 {\n+                    cond.wait();\n+                }\n             }\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_mutex_arc_poison() {\n-        let arc = ~MutexARC(1);\n-        let arc2 = ~arc.clone();\n-        do task::try || {\n-            do arc2.access |one| {\n-                assert_eq!(*one, 2);\n+        unsafe {\n+            let arc = ~MutexARC(1);\n+            let arc2 = ~arc.clone();\n+            do task::try || {\n+                do arc2.access |one| {\n+                    assert_eq!(*one, 2);\n+                }\n+            };\n+            do arc.access |one| {\n+                assert_eq!(*one, 1);\n             }\n-        };\n-        do arc.access |one| {\n-            assert_eq!(*one, 1);\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -795,4 +813,66 @@ mod tests {\n \n         wp2.recv(); // complete handshake with writer\n     }\n+    #[cfg(test)]\n+    fn test_rw_write_cond_downgrade_read_race_helper() {\n+        // Tests that when a downgrader hands off the \"reader cloud\" lock\n+        // because of a contending reader, a writer can't race to get it\n+        // instead, which would result in readers_and_writers. This tests\n+        // the sync module rather than this one, but it's here because an\n+        // rwarc gives us extra shared state to help check for the race.\n+        // If you want to see this test fail, go to sync.rs and replace the\n+        // line in RWlock::write_cond() that looks like:\n+        //     \"blk(&Condvar { order: opt_lock, ..*cond })\"\n+        // with just \"blk(cond)\".\n+        let x = ~RWARC(true);\n+        let (wp, wc) = comm::stream();\n+\n+        // writer task\n+        let xw = (*x).clone();\n+        do task::spawn {\n+            do xw.write_cond |state, c| {\n+                wc.send(()); // tell downgrader it's ok to go\n+                c.wait();\n+                // The core of the test is here: the condvar reacquire path\n+                // must involve order_lock, so that it cannot race with a reader\n+                // trying to receive the \"reader cloud lock hand-off\".\n+                *state = false;\n+            }\n+        }\n+\n+        wp.recv(); // wait for writer to get in\n+\n+        do x.write_downgrade |mut write_mode| {\n+            do write_mode.write_cond |state, c| {\n+                assert!(*state);\n+                // make writer contend in the cond-reacquire path\n+                c.signal();\n+            }\n+            // make a reader task to trigger the \"reader cloud lock\" handoff\n+            let xr = (*x).clone();\n+            let (rp, rc) = comm::stream();\n+            do task::spawn {\n+                rc.send(());\n+                do xr.read |_state| { }\n+            }\n+            rp.recv(); // wait for reader task to exist\n+\n+            let read_mode = x.downgrade(write_mode);\n+            do read_mode.read |state| {\n+                // if writer mistakenly got in, make sure it mutates state\n+                // before we assert on it\n+                for 5.times { task::yield(); }\n+                // make sure writer didn't get in.\n+                assert!(*state);\n+            }\n+        }\n+    }\n+    #[test]\n+    fn test_rw_write_cond_downgrade_read_race() {\n+        // Ideally the above test case would have yield statements in it that\n+        // helped to expose the race nearly 100% of the time... but adding\n+        // yields in the intuitively-right locations made it even less likely,\n+        // and I wasn't sure why :( . This is a mediocre \"next best\" option.\n+        for 8.times { test_rw_write_cond_downgrade_read_race_helper() }\n+    }\n }"}, {"sha": "2926d5958f16cac065c40944ae730a63df4d640f", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -32,6 +32,8 @@\n // overhead when initializing plain-old-data and means we don't need\n // to waste time running the destructors of POD.\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n use list::{MutList, MutCons, MutNil};\n@@ -132,7 +134,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n     while idx < fill {\n         let tydesc_data: *uint = transmute(ptr::offset(buf, idx));\n         let (tydesc, is_done) = un_bitpack_tydesc_ptr(*tydesc_data);\n-        let size = (*tydesc).size, align = (*tydesc).align;\n+        let (size, align) = ((*tydesc).size, (*tydesc).align);\n \n         let after_tydesc = idx + sys::size_of::<*TypeDesc>();\n \n@@ -164,9 +166,9 @@ unsafe fn un_bitpack_tydesc_ptr(p: uint) -> (*TypeDesc, bool) {\n     (transmute(p & !1), p & 1 == 1)\n }\n \n-pub impl Arena {\n+impl Arena {\n     // Functions for the POD part of the arena\n-    priv fn alloc_pod_grow(&mut self, n_bytes: uint, align: uint) -> *u8 {\n+    fn alloc_pod_grow(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         // Allocate a new chunk.\n         let chunk_size = at_vec::capacity(self.pod_head.data);\n         let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n@@ -178,7 +180,7 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    priv fn alloc_pod_inner(&mut self, n_bytes: uint, align: uint) -> *u8 {\n+    fn alloc_pod_inner(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         unsafe {\n             // XXX: Borrow check\n             let head = transmute_mut_region(&mut self.pod_head);\n@@ -198,7 +200,7 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    priv fn alloc_pod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n+    fn alloc_pod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n@@ -209,8 +211,8 @@ pub impl Arena {\n     }\n \n     // Functions for the non-POD part of the arena\n-    priv fn alloc_nonpod_grow(&mut self, n_bytes: uint, align: uint)\n-                             -> (*u8, *u8) {\n+    fn alloc_nonpod_grow(&mut self, n_bytes: uint, align: uint)\n+                         -> (*u8, *u8) {\n         // Allocate a new chunk.\n         let chunk_size = at_vec::capacity(self.head.data);\n         let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n@@ -222,8 +224,8 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    priv fn alloc_nonpod_inner(&mut self, n_bytes: uint, align: uint)\n-                               -> (*u8, *u8) {\n+    fn alloc_nonpod_inner(&mut self, n_bytes: uint, align: uint)\n+                          -> (*u8, *u8) {\n         unsafe {\n             let head = transmute_mut_region(&mut self.head);\n \n@@ -245,7 +247,7 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    priv fn alloc_nonpod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n+    fn alloc_nonpod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let (ty_ptr, ptr) =\n@@ -267,7 +269,7 @@ pub impl Arena {\n \n     // The external interface\n     #[inline(always)]\n-    fn alloc<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n+    pub fn alloc<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             // XXX: Borrow check\n             let this = transmute_mut_region(self);"}, {"sha": "f4754b3e4cbe1c7f0bffbbb8549633060c4fe4d6", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -12,7 +12,12 @@\n \n use core::prelude::*;\n \n+use core::vec;\n+\n+/// A trait for converting a value to base64 encoding.\n pub trait ToBase64 {\n+    /// Converts the value of `self` to a base64 value, returning the owned\n+    /// string\n     fn to_base64(&self) -> ~str;\n }\n \n@@ -43,7 +48,7 @@ impl<'self> ToBase64 for &'self [u8] {\n     fn to_base64(&self) -> ~str {\n         let mut s = ~\"\";\n         let len = self.len();\n-        str::reserve(&mut s, ((len + 3u) / 4u) * 3u);\n+        s.reserve(((len + 3u) / 4u) * 3u);\n \n         let mut i = 0u;\n \n@@ -53,10 +58,10 @@ impl<'self> ToBase64 for &'self [u8] {\n                     (self[i + 2u] as uint);\n \n             // This 24-bit number gets separated into four 6-bit numbers.\n-            str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n-            str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n-            str::push_char(&mut s, CHARS[(n >> 6u) & 63u]);\n-            str::push_char(&mut s, CHARS[n & 63u]);\n+            s.push_char(CHARS[(n >> 18u) & 63u]);\n+            s.push_char(CHARS[(n >> 12u) & 63u]);\n+            s.push_char(CHARS[(n >> 6u) & 63u]);\n+            s.push_char(CHARS[n & 63u]);\n \n             i += 3u;\n         }\n@@ -67,18 +72,18 @@ impl<'self> ToBase64 for &'self [u8] {\n           0 => (),\n           1 => {\n             let n = (self[i] as uint) << 16u;\n-            str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n-            str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n-            str::push_char(&mut s, '=');\n-            str::push_char(&mut s, '=');\n+            s.push_char(CHARS[(n >> 18u) & 63u]);\n+            s.push_char(CHARS[(n >> 12u) & 63u]);\n+            s.push_char('=');\n+            s.push_char('=');\n           }\n           2 => {\n             let n = (self[i] as uint) << 16u |\n                 (self[i + 1u] as uint) << 8u;\n-            str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n-            str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n-            str::push_char(&mut s, CHARS[(n >> 6u) & 63u]);\n-            str::push_char(&mut s, '=');\n+            s.push_char(CHARS[(n >> 18u) & 63u]);\n+            s.push_char(CHARS[(n >> 12u) & 63u]);\n+            s.push_char(CHARS[(n >> 6u) & 63u]);\n+            s.push_char('=');\n           }\n           _ => fail!(\"Algebra is broken, please alert the math police\")\n         }\n@@ -105,10 +110,11 @@ impl<'self> ToBase64 for &'self str {\n      *\n      */\n     fn to_base64(&self) -> ~str {\n-        str::to_bytes(*self).to_base64()\n+        self.as_bytes().to_base64()\n     }\n }\n \n+#[allow(missing_doc)]\n pub trait FromBase64 {\n     fn from_base64(&self) -> ~[u8];\n }\n@@ -217,7 +223,7 @@ impl<'self> FromBase64 for &'self str {\n      * ~~~\n      */\n     fn from_base64(&self) -> ~[u8] {\n-        str::to_bytes(*self).from_base64()\n+        self.as_bytes().from_base64()\n     }\n }\n \n@@ -238,12 +244,12 @@ mod tests {\n \n     #[test]\n     fn test_from_base64() {\n-        assert_eq!(\"\".from_base64(), str::to_bytes(\"\"));\n-        assert_eq!(\"Zg==\".from_base64(), str::to_bytes(\"f\"));\n-        assert_eq!(\"Zm8=\".from_base64(), str::to_bytes(\"fo\"));\n-        assert_eq!(\"Zm9v\".from_base64(), str::to_bytes(\"foo\"));\n-        assert_eq!(\"Zm9vYg==\".from_base64(), str::to_bytes(\"foob\"));\n-        assert_eq!(\"Zm9vYmE=\".from_base64(), str::to_bytes(\"fooba\"))\n-        assert_eq!(\"Zm9vYmFy\".from_base64(), str::to_bytes(\"foobar\"));\n+        assert_eq!(\"\".from_base64(), \"\".as_bytes().to_owned());\n+        assert_eq!(\"Zg==\".from_base64(), \"f\".as_bytes().to_owned());\n+        assert_eq!(\"Zm8=\".from_base64(), \"fo\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9v\".from_base64(), \"foo\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9vYg==\".from_base64(), \"foob\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9vYmE=\".from_base64(), \"fooba\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9vYmFy\".from_base64(), \"foobar\".as_bytes().to_owned());\n     }\n }"}, {"sha": "e3a15f76c786bed62621675aed22869fb152e47d", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 89, "deletions": 75, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,8 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n+use core::cmp;\n+use core::ops;\n+use core::uint;\n+use core::vec;\n+\n struct SmallBitv {\n     /// only the lowest nbits of this value are used. the rest is undefined.\n     bits: uint\n@@ -21,14 +28,17 @@ fn small_mask(nbits: uint) -> uint {\n     (1 << nbits) - 1\n }\n \n-pub impl SmallBitv {\n-    fn new(bits: uint) -> SmallBitv {\n+impl SmallBitv {\n+    pub fn new(bits: uint) -> SmallBitv {\n         SmallBitv {bits: bits}\n     }\n \n     #[inline(always)]\n-    fn bits_op(&mut self, right_bits: uint, nbits: uint,\n-               f: &fn(uint, uint) -> uint) -> bool {\n+    pub fn bits_op(&mut self,\n+                   right_bits: uint,\n+                   nbits: uint,\n+                   f: &fn(uint, uint) -> uint)\n+                   -> bool {\n         let mask = small_mask(nbits);\n         let old_b: uint = self.bits;\n         let new_b = f(old_b, right_bits);\n@@ -37,32 +47,32 @@ pub impl SmallBitv {\n     }\n \n     #[inline(always)]\n-    fn union(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n+    pub fn union(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 | u2)\n     }\n \n     #[inline(always)]\n-    fn intersect(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n+    pub fn intersect(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 & u2)\n     }\n \n     #[inline(always)]\n-    fn become(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n+    pub fn become(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |_u1, u2| u2)\n     }\n \n     #[inline(always)]\n-    fn difference(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n+    pub fn difference(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 & !u2)\n     }\n \n     #[inline(always)]\n-    fn get(&self, i: uint) -> bool {\n+    pub fn get(&self, i: uint) -> bool {\n         (self.bits & (1 << i)) != 0\n     }\n \n     #[inline(always)]\n-    fn set(&mut self, i: uint, x: bool) {\n+    pub fn set(&mut self, i: uint, x: bool) {\n         if x {\n             self.bits |= 1<<i;\n         }\n@@ -72,30 +82,29 @@ pub impl SmallBitv {\n     }\n \n     #[inline(always)]\n-    fn equals(&self, b: &SmallBitv, nbits: uint) -> bool {\n+    pub fn equals(&self, b: &SmallBitv, nbits: uint) -> bool {\n         let mask = small_mask(nbits);\n         mask & self.bits == mask & b.bits\n     }\n \n     #[inline(always)]\n-    fn clear(&mut self) { self.bits = 0; }\n+    pub fn clear(&mut self) { self.bits = 0; }\n \n     #[inline(always)]\n-    fn set_all(&mut self) { self.bits = !0; }\n+    pub fn set_all(&mut self) { self.bits = !0; }\n \n     #[inline(always)]\n-    fn is_true(&self, nbits: uint) -> bool {\n+    pub fn is_true(&self, nbits: uint) -> bool {\n         small_mask(nbits) & !self.bits == 0\n     }\n \n     #[inline(always)]\n-    fn is_false(&self, nbits: uint) -> bool {\n+    pub fn is_false(&self, nbits: uint) -> bool {\n         small_mask(nbits) & self.bits == 0\n     }\n \n     #[inline(always)]\n-    fn invert(&mut self) { self.bits = !self.bits; }\n-\n+    pub fn invert(&mut self) { self.bits = !self.bits; }\n }\n \n struct BigBitv {\n@@ -118,14 +127,17 @@ fn big_mask(nbits: uint, elem: uint) -> uint {\n     }\n }\n \n-pub impl BigBitv {\n-    fn new(storage: ~[uint]) -> BigBitv {\n+impl BigBitv {\n+    pub fn new(storage: ~[uint]) -> BigBitv {\n         BigBitv {storage: storage}\n     }\n \n     #[inline(always)]\n-    fn process(&mut self, b: &BigBitv, nbits: uint,\n-               op: &fn(uint, uint) -> uint) -> bool {\n+    pub fn process(&mut self,\n+                   b: &BigBitv,\n+                   nbits: uint,\n+                   op: &fn(uint, uint) -> uint)\n+                   -> bool {\n         let len = b.storage.len();\n         assert_eq!(self.storage.len(), len);\n         let mut changed = false;\n@@ -143,43 +155,43 @@ pub impl BigBitv {\n     }\n \n     #[inline(always)]\n-    fn each_storage(&mut self, op: &fn(v: &mut uint) -> bool) -> bool {\n+    pub fn each_storage(&mut self, op: &fn(v: &mut uint) -> bool) -> bool {\n         uint::range(0, self.storage.len(), |i| op(&mut self.storage[i]))\n     }\n \n     #[inline(always)]\n-    fn invert(&mut self) { for self.each_storage |w| { *w = !*w } }\n+    pub fn invert(&mut self) { for self.each_storage |w| { *w = !*w } }\n \n     #[inline(always)]\n-    fn union(&mut self, b: &BigBitv, nbits: uint) -> bool {\n+    pub fn union(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, |w1, w2| w1 | w2)\n     }\n \n     #[inline(always)]\n-    fn intersect(&mut self, b: &BigBitv, nbits: uint) -> bool {\n+    pub fn intersect(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, |w1, w2| w1 & w2)\n     }\n \n     #[inline(always)]\n-    fn become(&mut self, b: &BigBitv, nbits: uint) -> bool {\n+    pub fn become(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, |_, w| w)\n     }\n \n     #[inline(always)]\n-    fn difference(&mut self, b: &BigBitv, nbits: uint) -> bool {\n+    pub fn difference(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, |w1, w2| w1 & !w2)\n     }\n \n     #[inline(always)]\n-    fn get(&self, i: uint) -> bool {\n+    pub fn get(&self, i: uint) -> bool {\n         let w = i / uint::bits;\n         let b = i % uint::bits;\n         let x = 1 & self.storage[w] >> b;\n         x == 1\n     }\n \n     #[inline(always)]\n-    fn set(&mut self, i: uint, x: bool) {\n+    pub fn set(&mut self, i: uint, x: bool) {\n         let w = i / uint::bits;\n         let b = i % uint::bits;\n         let flag = 1 << b;\n@@ -188,7 +200,7 @@ pub impl BigBitv {\n     }\n \n     #[inline(always)]\n-    fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n+    pub fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n         let len = b.storage.len();\n         for uint::iterate(0, len) |i| {\n             let mask = big_mask(nbits, i);\n@@ -198,25 +210,25 @@ pub impl BigBitv {\n         }\n         return true;\n     }\n-\n }\n \n enum BitvVariant { Big(~BigBitv), Small(~SmallBitv) }\n \n enum Op {Union, Intersect, Assign, Difference}\n \n-// The bitvector type\n+/// The bitvector type\n pub struct Bitv {\n+    /// Internal representation of the bit vector (small or large)\n     rep: BitvVariant,\n+    /// The number of valid bits in the internal representation\n     nbits: uint\n }\n \n fn die() -> ! {\n     fail!(\"Tried to do operation on bit vectors with different sizes\");\n }\n \n-priv impl Bitv {\n-\n+impl Bitv {\n     #[inline(always)]\n     fn do_op(&mut self, op: Op, other: &Bitv) -> bool {\n         if self.nbits != other.nbits {\n@@ -246,8 +258,8 @@ priv impl Bitv {\n \n }\n \n-pub impl Bitv {\n-    fn new(nbits: uint, init: bool) -> Bitv {\n+impl Bitv {\n+    pub fn new(nbits: uint, init: bool) -> Bitv {\n         let rep = if nbits <= uint::bits {\n             Small(~SmallBitv::new(if init {!0} else {0}))\n         }\n@@ -268,7 +280,7 @@ pub impl Bitv {\n      * the same length. Returns 'true' if `self` changed.\n     */\n     #[inline(always)]\n-    fn union(&mut self, v1: &Bitv) -> bool { self.do_op(Union, v1) }\n+    pub fn union(&mut self, v1: &Bitv) -> bool { self.do_op(Union, v1) }\n \n     /**\n      * Calculates the intersection of two bitvectors\n@@ -277,7 +289,9 @@ pub impl Bitv {\n      * must be the same length. Returns 'true' if `self` changed.\n     */\n     #[inline(always)]\n-    fn intersect(&mut self, v1: &Bitv) -> bool { self.do_op(Intersect, v1) }\n+    pub fn intersect(&mut self, v1: &Bitv) -> bool {\n+        self.do_op(Intersect, v1)\n+    }\n \n     /**\n      * Assigns the value of `v1` to `self`\n@@ -286,16 +300,16 @@ pub impl Bitv {\n      * changed\n      */\n     #[inline(always)]\n-    fn assign(&mut self, v: &Bitv) -> bool { self.do_op(Assign, v) }\n+    pub fn assign(&mut self, v: &Bitv) -> bool { self.do_op(Assign, v) }\n \n     /// Retrieve the value at index `i`\n     #[inline(always)]\n-    fn get(&self, i: uint) -> bool {\n-       assert!((i < self.nbits));\n-       match self.rep {\n-         Big(ref b)   => b.get(i),\n-         Small(ref s) => s.get(i)\n-       }\n+    pub fn get(&self, i: uint) -> bool {\n+        assert!((i < self.nbits));\n+        match self.rep {\n+            Big(ref b)   => b.get(i),\n+            Small(ref s) => s.get(i)\n+        }\n     }\n \n     /**\n@@ -304,7 +318,7 @@ pub impl Bitv {\n      * `i` must be less than the length of the bitvector.\n      */\n     #[inline(always)]\n-    fn set(&mut self, i: uint, x: bool) {\n+    pub fn set(&mut self, i: uint, x: bool) {\n       assert!((i < self.nbits));\n       match self.rep {\n         Big(ref mut b)   => b.set(i, x),\n@@ -319,7 +333,7 @@ pub impl Bitv {\n      * bitvectors contain identical elements.\n      */\n     #[inline(always)]\n-    fn equal(&self, v1: &Bitv) -> bool {\n+    pub fn equal(&self, v1: &Bitv) -> bool {\n       if self.nbits != v1.nbits { return false; }\n       match self.rep {\n         Small(ref b) => match v1.rep {\n@@ -335,7 +349,7 @@ pub impl Bitv {\n \n     /// Set all bits to 0\n     #[inline(always)]\n-    fn clear(&mut self) {\n+    pub fn clear(&mut self) {\n         match self.rep {\n           Small(ref mut b) => b.clear(),\n           Big(ref mut s) => for s.each_storage() |w| { *w = 0u }\n@@ -344,15 +358,15 @@ pub impl Bitv {\n \n     /// Set all bits to 1\n     #[inline(always)]\n-    fn set_all(&mut self) {\n+    pub fn set_all(&mut self) {\n       match self.rep {\n         Small(ref mut b) => b.set_all(),\n         Big(ref mut s) => for s.each_storage() |w| { *w = !0u } }\n     }\n \n     /// Invert all bits\n     #[inline(always)]\n-    fn invert(&mut self) {\n+    pub fn invert(&mut self) {\n       match self.rep {\n         Small(ref mut b) => b.invert(),\n         Big(ref mut s) => for s.each_storage() |w| { *w = !*w } }\n@@ -368,11 +382,13 @@ pub impl Bitv {\n      * Returns `true` if `v0` was changed.\n      */\n     #[inline(always)]\n-    fn difference(&mut self, v: &Bitv) -> bool { self.do_op(Difference, v) }\n+    pub fn difference(&mut self, v: &Bitv) -> bool {\n+        self.do_op(Difference, v)\n+    }\n \n     /// Returns true if all bits are 1\n     #[inline(always)]\n-    fn is_true(&self) -> bool {\n+    pub fn is_true(&self) -> bool {\n       match self.rep {\n         Small(ref b) => b.is_true(self.nbits),\n         _ => {\n@@ -383,7 +399,7 @@ pub impl Bitv {\n     }\n \n     #[inline(always)]\n-    fn each(&self, f: &fn(bool) -> bool) -> bool {\n+    pub fn each(&self, f: &fn(bool) -> bool) -> bool {\n         let mut i = 0;\n         while i < self.nbits {\n             if !f(self.get(i)) { return false; }\n@@ -393,7 +409,7 @@ pub impl Bitv {\n     }\n \n     /// Returns true if all bits are 0\n-    fn is_false(&self) -> bool {\n+    pub fn is_false(&self) -> bool {\n       match self.rep {\n         Small(ref b) => b.is_false(self.nbits),\n         Big(_) => {\n@@ -403,7 +419,7 @@ pub impl Bitv {\n       }\n     }\n \n-    fn init_to_vec(&self, i: uint) -> uint {\n+    pub fn init_to_vec(&self, i: uint) -> uint {\n       return if self.get(i) { 1 } else { 0 };\n     }\n \n@@ -412,7 +428,7 @@ pub impl Bitv {\n      *\n      * Each uint in the resulting vector has either value 0u or 1u.\n      */\n-    fn to_vec(&self) -> ~[uint] {\n+    pub fn to_vec(&self) -> ~[uint] {\n         vec::from_fn(self.nbits, |x| self.init_to_vec(x))\n     }\n \n@@ -422,8 +438,7 @@ pub impl Bitv {\n      * size of the bitv is not a multiple of 8 then trailing bits\n      * will be filled-in with false/0\n      */\n-    fn to_bytes(&self) -> ~[u8] {\n-\n+    pub fn to_bytes(&self) -> ~[u8] {\n         fn bit (bitv: &Bitv, byte: uint, bit: uint) -> u8 {\n             let offset = byte * 8 + bit;\n             if offset >= bitv.nbits {\n@@ -450,7 +465,7 @@ pub impl Bitv {\n     /**\n      * Transform self into a [bool] by turning each bit into a bool\n      */\n-    fn to_bools(&self) -> ~[bool] {\n+    pub fn to_bools(&self) -> ~[bool] {\n         vec::from_fn(self.nbits, |i| self[i])\n     }\n \n@@ -460,7 +475,7 @@ pub impl Bitv {\n      * The resulting string has the same length as `self`, and each\n      * character is either '0' or '1'.\n      */\n-     fn to_str(&self) -> ~str {\n+     pub fn to_str(&self) -> ~str {\n        let mut rs = ~\"\";\n        for self.each() |i| { if i { rs += \"1\"; } else { rs += \"0\"; } };\n        rs\n@@ -473,7 +488,7 @@ pub impl Bitv {\n      * The uint vector is expected to only contain the values 0u and 1u. Both\n      * the bitvector and vector must have the same length\n      */\n-    fn eq_vec(&self, v: ~[uint]) -> bool {\n+    pub fn eq_vec(&self, v: ~[uint]) -> bool {\n         assert_eq!(self.nbits, v.len());\n         let mut i = 0;\n         while i < self.nbits {\n@@ -485,7 +500,7 @@ pub impl Bitv {\n         true\n     }\n \n-    fn ones(&self, f: &fn(uint) -> bool) -> bool {\n+    pub fn ones(&self, f: &fn(uint) -> bool) -> bool {\n         uint::range(0, self.nbits, |i| !self.get(i) || f(i))\n     }\n \n@@ -507,7 +522,6 @@ impl Clone for Bitv {\n           }\n         }\n     }\n-\n }\n \n /**\n@@ -578,14 +592,14 @@ pub struct BitvSet {\n     priv bitv: BigBitv\n }\n \n-pub impl BitvSet {\n+impl BitvSet {\n     /// Creates a new bit vector set with initially no contents\n-    fn new() -> BitvSet {\n+    pub fn new() -> BitvSet {\n         BitvSet{ size: 0, bitv: BigBitv::new(~[0]) }\n     }\n \n     /// Creates a new bit vector set from the given bit vector\n-    fn from_bitv(bitv: Bitv) -> BitvSet {\n+    pub fn from_bitv(bitv: Bitv) -> BitvSet {\n         let mut size = 0;\n         for bitv.ones |_| {\n             size += 1;\n@@ -600,17 +614,17 @@ pub impl BitvSet {\n \n     /// Returns the capacity in bits for this bit vector. Inserting any\n     /// element less than this amount will not trigger a resizing.\n-    fn capacity(&self) -> uint { self.bitv.storage.len() * uint::bits }\n+    pub fn capacity(&self) -> uint { self.bitv.storage.len() * uint::bits }\n \n     /// Consumes this set to return the underlying bit vector\n-    fn unwrap(self) -> Bitv {\n+    pub fn unwrap(self) -> Bitv {\n         let cap = self.capacity();\n         let BitvSet{bitv, _} = self;\n         return Bitv{ nbits:cap, rep: Big(~bitv) };\n     }\n \n     #[inline(always)]\n-    priv fn other_op(&mut self, other: &BitvSet, f: &fn(uint, uint) -> uint) {\n+    fn other_op(&mut self, other: &BitvSet, f: &fn(uint, uint) -> uint) {\n         fn nbits(mut w: uint) -> uint {\n             let mut bits = 0;\n             for uint::bits.times {\n@@ -634,22 +648,22 @@ pub impl BitvSet {\n     }\n \n     /// Union in-place with the specified other bit vector\n-    fn union_with(&mut self, other: &BitvSet) {\n+    pub fn union_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 | w2);\n     }\n \n     /// Intersect in-place with the specified other bit vector\n-    fn intersect_with(&mut self, other: &BitvSet) {\n+    pub fn intersect_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 & w2);\n     }\n \n     /// Difference in-place with the specified other bit vector\n-    fn difference_with(&mut self, other: &BitvSet) {\n+    pub fn difference_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 & !w2);\n     }\n \n     /// Symmetric difference in-place with the specified other bit vector\n-    fn symmetric_difference_with(&mut self, other: &BitvSet) {\n+    pub fn symmetric_difference_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 ^ w2);\n     }\n }\n@@ -803,7 +817,7 @@ impl Set<uint> for BitvSet {\n     }\n }\n \n-priv impl BitvSet {\n+impl BitvSet {\n     /// Visits each of the words that the two bit vectors (self and other)\n     /// both have in common. The three yielded arguments are (bit location,\n     /// w1, w2) where the bit location is the number of bits offset so far,"}, {"sha": "7cc7b659ed9dd9f38b53718c807b48f54ac72c91", "filename": "src/libextra/c_vec.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fc_vec.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -38,6 +38,9 @@\n \n use core::prelude::*;\n \n+use core::option;\n+use core::ptr;\n+\n /**\n  * The type representing a foreign chunk of memory\n  *"}, {"sha": "1001d4f6ac9ed26ef484a37637f42c0624589a09", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -14,10 +14,13 @@ Higher level communication abstractions.\n \n */\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n use core::comm::{GenericChan, GenericSmartChan, GenericPort};\n use core::comm::{Chan, Port, Selectable, Peekable};\n+use core::comm;\n use core::pipes;\n \n /// An extension of `pipes::stream` that allows both sending and receiving.\n@@ -27,20 +30,20 @@ pub struct DuplexStream<T, U> {\n }\n \n // Allow these methods to be used without import:\n-pub impl<T:Owned,U:Owned> DuplexStream<T, U> {\n-    fn send(&self, x: T) {\n+impl<T:Owned,U:Owned> DuplexStream<T, U> {\n+    pub fn send(&self, x: T) {\n         self.chan.send(x)\n     }\n-    fn try_send(&self, x: T) -> bool {\n+    pub fn try_send(&self, x: T) -> bool {\n         self.chan.try_send(x)\n     }\n-    fn recv(&self, ) -> U {\n+    pub fn recv(&self, ) -> U {\n         self.port.recv()\n     }\n-    fn try_recv(&self) -> Option<U> {\n+    pub fn try_recv(&self) -> Option<U> {\n         self.port.try_recv()\n     }\n-    fn peek(&self) -> bool {\n+    pub fn peek(&self) -> bool {\n         self.port.peek()\n     }\n }"}, {"sha": "cbd7cb5e3c08f75709f45c0a63a7c8192ac13509", "filename": "src/libextra/dbg.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdbg.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -10,6 +10,8 @@\n \n //! Unsafe debugging functions for inspecting values.\n \n+#[allow(missing_doc)];\n+\n use core::cast::transmute;\n use core::sys;\n "}, {"sha": "89e23a3a77ffb95eb4fdc8ee61cbb747debe41e5", "filename": "src/libextra/deque.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdeque.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -12,10 +12,13 @@\n \n use core::prelude::*;\n \n+use core::uint;\n use core::util::replace;\n+use core::vec;\n \n static initial_capacity: uint = 32u; // 2^5\n \n+#[allow(missing_doc)]\n pub struct Deque<T> {\n     priv nelts: uint,\n     priv lo: uint,\n@@ -34,52 +37,52 @@ impl<T> Container for Deque<T> {\n impl<T> Mutable for Deque<T> {\n     /// Clear the deque, removing all values.\n     fn clear(&mut self) {\n-        for self.elts.each_mut |x| { *x = None }\n+        for self.elts.mut_iter().advance |x| { *x = None }\n         self.nelts = 0;\n         self.lo = 0;\n         self.hi = 0;\n     }\n }\n \n-pub impl<T> Deque<T> {\n+impl<T> Deque<T> {\n     /// Create an empty Deque\n-    fn new() -> Deque<T> {\n+    pub fn new() -> Deque<T> {\n         Deque{nelts: 0, lo: 0, hi: 0,\n               elts: vec::from_fn(initial_capacity, |_| None)}\n     }\n \n     /// Return a reference to the first element in the deque\n     ///\n     /// Fails if the deque is empty\n-    fn peek_front<'a>(&'a self) -> &'a T { get(self.elts, self.lo) }\n+    pub fn peek_front<'a>(&'a self) -> &'a T { get(self.elts, self.lo) }\n \n     /// Return a reference to the last element in the deque\n     ///\n     /// Fails if the deque is empty\n-    fn peek_back<'a>(&'a self) -> &'a T { get(self.elts, self.hi - 1u) }\n+    pub fn peek_back<'a>(&'a self) -> &'a T { get(self.elts, self.hi - 1u) }\n \n     /// Retrieve an element in the deque by index\n     ///\n     /// Fails if there is no element with the given index\n-    fn get<'a>(&'a self, i: int) -> &'a T {\n+    pub fn get<'a>(&'a self, i: int) -> &'a T {\n         let idx = (self.lo + (i as uint)) % self.elts.len();\n         get(self.elts, idx)\n     }\n \n     /// Iterate over the elements in the deque\n-    fn each(&self, f: &fn(&T) -> bool) -> bool {\n+    pub fn each(&self, f: &fn(&T) -> bool) -> bool {\n         self.eachi(|_i, e| f(e))\n     }\n \n     /// Iterate over the elements in the deque by index\n-    fn eachi(&self, f: &fn(uint, &T) -> bool) -> bool {\n+    pub fn eachi(&self, f: &fn(uint, &T) -> bool) -> bool {\n         uint::range(0, self.nelts, |i| f(i, self.get(i as int)))\n     }\n \n     /// Remove and return the first element in the deque\n     ///\n     /// Fails if the deque is empty\n-    fn pop_front(&mut self) -> T {\n+    pub fn pop_front(&mut self) -> T {\n         let result = self.elts[self.lo].swap_unwrap();\n         self.lo = (self.lo + 1u) % self.elts.len();\n         self.nelts -= 1u;\n@@ -89,7 +92,7 @@ pub impl<T> Deque<T> {\n     /// Remove and return the last element in the deque\n     ///\n     /// Fails if the deque is empty\n-    fn pop_back(&mut self) -> T {\n+    pub fn pop_back(&mut self) -> T {\n         if self.hi == 0u {\n             self.hi = self.elts.len() - 1u;\n         } else { self.hi -= 1u; }\n@@ -100,7 +103,7 @@ pub impl<T> Deque<T> {\n     }\n \n     /// Prepend an element to the deque\n-    fn add_front(&mut self, t: T) {\n+    pub fn add_front(&mut self, t: T) {\n         let oldlo = self.lo;\n         if self.lo == 0u {\n             self.lo = self.elts.len() - 1u;\n@@ -115,7 +118,7 @@ pub impl<T> Deque<T> {\n     }\n \n     /// Append an element to the deque\n-    fn add_back(&mut self, t: T) {\n+    pub fn add_back(&mut self, t: T) {\n         if self.lo == self.hi && self.nelts != 0u {\n             self.elts = grow(self.nelts, self.lo, self.elts);\n             self.lo = 0u;\n@@ -133,7 +136,7 @@ pub impl<T> Deque<T> {\n     /// # Arguments\n     ///\n     /// * n - The number of elements to reserve space for\n-    fn reserve(&mut self, n: uint) {\n+    pub fn reserve(&mut self, n: uint) {\n         vec::reserve(&mut self.elts, n);\n     }\n \n@@ -147,7 +150,7 @@ pub impl<T> Deque<T> {\n     /// # Arguments\n     ///\n     /// * n - The number of elements to reserve space for\n-    fn reserve_at_least(&mut self, n: uint) {\n+    pub fn reserve_at_least(&mut self, n: uint) {\n         vec::reserve_at_least(&mut self.elts, n);\n     }\n }"}, {"sha": "c3e2beb122f01d4787ee0cb941497683ac490ca5", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 60, "deletions": 54, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -21,23 +21,27 @@ Do not use ==, !=, <, etc on doubly-linked lists -- it may not terminate.\n use core::prelude::*;\n \n use core::managed;\n+use core::old_iter;\n+use core::vec;\n \n pub type DListLink<T> = Option<@mut DListNode<T>>;\n \n+#[allow(missing_doc)]\n pub struct DListNode<T> {\n     data: T,\n     linked: bool, // for assertions\n     prev: DListLink<T>,\n     next: DListLink<T>,\n }\n \n+#[allow(missing_doc)]\n pub struct DList<T> {\n     size: uint,\n     hd: DListLink<T>,\n     tl: DListLink<T>,\n }\n \n-priv impl<T> DListNode<T> {\n+impl<T> DListNode<T> {\n     fn assert_links(@mut self) {\n         match self.next {\n             Some(neighbour) => match neighbour.prev {\n@@ -60,26 +64,26 @@ priv impl<T> DListNode<T> {\n     }\n }\n \n-pub impl<T> DListNode<T> {\n+impl<T> DListNode<T> {\n     /// Get the next node in the list, if there is one.\n-    fn next_link(@mut self) -> DListLink<T> {\n+    pub fn next_link(@mut self) -> DListLink<T> {\n         self.assert_links();\n         self.next\n     }\n     /// Get the next node in the list, failing if there isn't one.\n-    fn next_node(@mut self) -> @mut DListNode<T> {\n+    pub fn next_node(@mut self) -> @mut DListNode<T> {\n         match self.next_link() {\n             Some(nobe) => nobe,\n             None       => fail!(\"This dlist node has no next neighbour.\")\n         }\n     }\n     /// Get the previous node in the list, if there is one.\n-    fn prev_link(@mut self) -> DListLink<T> {\n+    pub fn prev_link(@mut self) -> DListLink<T> {\n         self.assert_links();\n         self.prev\n     }\n     /// Get the previous node in the list, failing if there isn't one.\n-    fn prev_node(@mut self) -> @mut DListNode<T> {\n+    pub fn prev_node(@mut self) -> @mut DListNode<T> {\n         match self.prev_link() {\n             Some(nobe) => nobe,\n             None       => fail!(\"This dlist node has no previous neighbour.\")\n@@ -104,8 +108,9 @@ pub fn from_elem<T>(data: T) -> @mut DList<T> {\n     list\n }\n \n+/// Creates a new dlist from a vector of elements, maintaining the same order\n pub fn from_vec<T:Copy>(vec: &[T]) -> @mut DList<T> {\n-    do vec::foldl(DList(), vec) |list,data| {\n+    do vec.iter().fold(DList()) |list,data| {\n         list.push(*data); // Iterating left-to-right -- add newly to the tail.\n         list\n     }\n@@ -121,7 +126,7 @@ pub fn concat<T>(lists: @mut DList<@mut DList<T>>) -> @mut DList<T> {\n     result\n }\n \n-priv impl<T> DList<T> {\n+impl<T> DList<T> {\n     fn new_link(data: T) -> DListLink<T> {\n         Some(@mut DListNode {\n             data: data,\n@@ -206,34 +211,34 @@ priv impl<T> DList<T> {\n     }\n }\n \n-pub impl<T> DList<T> {\n+impl<T> DList<T> {\n     /// Get the size of the list. O(1).\n-    fn len(@mut self) -> uint { self.size }\n+    pub fn len(@mut self) -> uint { self.size }\n     /// Returns true if the list is empty. O(1).\n-    fn is_empty(@mut self) -> bool { self.len() == 0 }\n+    pub fn is_empty(@mut self) -> bool { self.len() == 0 }\n \n     /// Add data to the head of the list. O(1).\n-    fn push_head(@mut self, data: T) {\n+    pub fn push_head(@mut self, data: T) {\n         self.add_head(DList::new_link(data));\n     }\n     /**\n      * Add data to the head of the list, and get the new containing\n      * node. O(1).\n      */\n-    fn push_head_n(@mut self, data: T) -> @mut DListNode<T> {\n+    pub fn push_head_n(@mut self, data: T) -> @mut DListNode<T> {\n         let nobe = DList::new_link(data);\n         self.add_head(nobe);\n         nobe.get()\n     }\n     /// Add data to the tail of the list. O(1).\n-    fn push(@mut self, data: T) {\n+    pub fn push(@mut self, data: T) {\n         self.add_tail(DList::new_link(data));\n     }\n     /**\n      * Add data to the tail of the list, and get the new containing\n      * node. O(1).\n      */\n-    fn push_n(@mut self, data: T) -> @mut DListNode<T> {\n+    pub fn push_n(@mut self, data: T) -> @mut DListNode<T> {\n         let nobe = DList::new_link(data);\n         self.add_tail(nobe);\n         nobe.get()\n@@ -242,28 +247,27 @@ pub impl<T> DList<T> {\n      * Insert data into the middle of the list, left of the given node.\n      * O(1).\n      */\n-    fn insert_before(@mut self, data: T, neighbour: @mut DListNode<T>) {\n+    pub fn insert_before(@mut self, data: T, neighbour: @mut DListNode<T>) {\n         self.insert_left(DList::new_link(data), neighbour);\n     }\n     /**\n      * Insert an existing node in the middle of the list, left of the\n      * given node. O(1).\n      */\n-    fn insert_n_before(@mut self,\n-                       nobe: @mut DListNode<T>,\n-                       neighbour: @mut DListNode<T>) {\n+    pub fn insert_n_before(@mut self,\n+                           nobe: @mut DListNode<T>,\n+                           neighbour: @mut DListNode<T>) {\n         self.make_mine(nobe);\n         self.insert_left(Some(nobe), neighbour);\n     }\n     /**\n      * Insert data in the middle of the list, left of the given node,\n      * and get its containing node. O(1).\n      */\n-    fn insert_before_n(\n-        @mut self,\n-        data: T,\n-        neighbour: @mut DListNode<T>\n-    ) -> @mut DListNode<T> {\n+    pub fn insert_before_n(@mut self,\n+                           data: T,\n+                           neighbour: @mut DListNode<T>)\n+                           -> @mut DListNode<T> {\n         let nobe = DList::new_link(data);\n         self.insert_left(nobe, neighbour);\n         nobe.get()\n@@ -272,73 +276,72 @@ pub impl<T> DList<T> {\n      * Insert data into the middle of the list, right of the given node.\n      * O(1).\n      */\n-    fn insert_after(@mut self, data: T, neighbour: @mut DListNode<T>) {\n+    pub fn insert_after(@mut self, data: T, neighbour: @mut DListNode<T>) {\n         self.insert_right(neighbour, DList::new_link(data));\n     }\n     /**\n      * Insert an existing node in the middle of the list, right of the\n      * given node. O(1).\n      */\n-    fn insert_n_after(@mut self,\n-                      nobe: @mut DListNode<T>,\n-                      neighbour: @mut DListNode<T>) {\n+    pub fn insert_n_after(@mut self,\n+                          nobe: @mut DListNode<T>,\n+                          neighbour: @mut DListNode<T>) {\n         self.make_mine(nobe);\n         self.insert_right(neighbour, Some(nobe));\n     }\n     /**\n      * Insert data in the middle of the list, right of the given node,\n      * and get its containing node. O(1).\n      */\n-    fn insert_after_n(\n-        @mut self,\n-        data: T,\n-        neighbour: @mut DListNode<T>\n-    ) -> @mut DListNode<T> {\n+    pub fn insert_after_n(@mut self,\n+                          data: T,\n+                          neighbour: @mut DListNode<T>)\n+                          -> @mut DListNode<T> {\n         let nobe = DList::new_link(data);\n         self.insert_right(neighbour, nobe);\n         nobe.get()\n     }\n \n     /// Remove a node from the head of the list. O(1).\n-    fn pop_n(@mut self) -> DListLink<T> {\n+    pub fn pop_n(@mut self) -> DListLink<T> {\n         let hd = self.peek_n();\n         hd.map(|nobe| self.unlink(*nobe));\n         hd\n     }\n     /// Remove a node from the tail of the list. O(1).\n-    fn pop_tail_n(@mut self) -> DListLink<T> {\n+    pub fn pop_tail_n(@mut self) -> DListLink<T> {\n         let tl = self.peek_tail_n();\n         tl.map(|nobe| self.unlink(*nobe));\n         tl\n     }\n     /// Get the node at the list's head. O(1).\n-    fn peek_n(@mut self) -> DListLink<T> { self.hd }\n+    pub fn peek_n(@mut self) -> DListLink<T> { self.hd }\n     /// Get the node at the list's tail. O(1).\n-    fn peek_tail_n(@mut self) -> DListLink<T> { self.tl }\n+    pub fn peek_tail_n(@mut self) -> DListLink<T> { self.tl }\n \n     /// Get the node at the list's head, failing if empty. O(1).\n-    fn head_n(@mut self) -> @mut DListNode<T> {\n+    pub fn head_n(@mut self) -> @mut DListNode<T> {\n         match self.hd {\n             Some(nobe) => nobe,\n             None       => fail!(\"Attempted to get the head of an empty dlist.\")\n         }\n     }\n     /// Get the node at the list's tail, failing if empty. O(1).\n-    fn tail_n(@mut self) -> @mut DListNode<T> {\n+    pub fn tail_n(@mut self) -> @mut DListNode<T> {\n         match self.tl {\n             Some(nobe) => nobe,\n             None       => fail!(\"Attempted to get the tail of an empty dlist.\")\n         }\n     }\n \n     /// Remove a node from anywhere in the list. O(1).\n-    fn remove(@mut self, nobe: @mut DListNode<T>) { self.unlink(nobe); }\n+    pub fn remove(@mut self, nobe: @mut DListNode<T>) { self.unlink(nobe); }\n \n     /**\n      * Empty another list onto the end of this list, joining this list's tail\n      * to the other list's head. O(1).\n      */\n-    fn append(@mut self, them: @mut DList<T>) {\n+    pub fn append(@mut self, them: @mut DList<T>) {\n         if managed::mut_ptr_eq(self, them) {\n             fail!(\"Cannot append a dlist to itself!\")\n         }\n@@ -355,7 +358,7 @@ pub impl<T> DList<T> {\n      * Empty another list onto the start of this list, joining the other\n      * list's tail to this list's head. O(1).\n      */\n-    fn prepend(@mut self, them: @mut DList<T>) {\n+    pub fn prepend(@mut self, them: @mut DList<T>) {\n         if managed::mut_ptr_eq(self, them) {\n             fail!(\"Cannot prepend a dlist to itself!\")\n         }\n@@ -370,7 +373,7 @@ pub impl<T> DList<T> {\n     }\n \n     /// Reverse the list's elements in place. O(n).\n-    fn reverse(@mut self) {\n+    pub fn reverse(@mut self) {\n         do self.hd.while_some |nobe| {\n             let next_nobe = nobe.next;\n             self.remove(nobe);\n@@ -384,7 +387,7 @@ pub impl<T> DList<T> {\n      * Remove everything from the list. This is important because the cyclic\n      * links won't otherwise be automatically refcounted-collected. O(n).\n      */\n-    fn clear(@mut self) {\n+    pub fn clear(@mut self) {\n         // Cute as it would be to simply detach the list and proclaim \"O(1)!\",\n         // the GC would still be a hidden O(n). Better to be honest about it.\n         while !self.is_empty() {\n@@ -393,7 +396,7 @@ pub impl<T> DList<T> {\n     }\n \n     /// Iterate over nodes.\n-    fn each_node(@mut self, f: &fn(@mut DListNode<T>) -> bool) -> bool {\n+    pub fn each_node(@mut self, f: &fn(@mut DListNode<T>) -> bool) -> bool {\n         let mut link = self.peek_n();\n         while link.is_some() {\n             let nobe = link.get();\n@@ -404,7 +407,7 @@ pub impl<T> DList<T> {\n     }\n \n     /// Check data structure integrity. O(n).\n-    fn assert_consistent(@mut self) {\n+    pub fn assert_consistent(@mut self) {\n         if self.hd.is_none() || self.tl.is_none() {\n             assert!(self.hd.is_none() && self.tl.is_none());\n         }\n@@ -454,35 +457,35 @@ pub impl<T> DList<T> {\n     }\n }\n \n-pub impl<T:Copy> DList<T> {\n+impl<T:Copy> DList<T> {\n     /// Remove data from the head of the list. O(1).\n-    fn pop(@mut self) -> Option<T> {\n+    pub fn pop(@mut self) -> Option<T> {\n         self.pop_n().map(|nobe| nobe.data)\n     }\n \n     /// Remove data from the tail of the list. O(1).\n-    fn pop_tail(@mut self) -> Option<T> {\n+    pub fn pop_tail(@mut self) -> Option<T> {\n         self.pop_tail_n().map(|nobe| nobe.data)\n     }\n \n     /// Get data at the list's head. O(1).\n-    fn peek(@mut self) -> Option<T> {\n+    pub fn peek(@mut self) -> Option<T> {\n         self.peek_n().map(|nobe| nobe.data)\n     }\n \n     /// Get data at the list's tail. O(1).\n-    fn peek_tail(@mut self) -> Option<T> {\n+    pub fn peek_tail(@mut self) -> Option<T> {\n         self.peek_tail_n().map (|nobe| nobe.data)\n     }\n \n     /// Get data at the list's head, failing if empty. O(1).\n-    fn head(@mut self) -> T { self.head_n().data }\n+    pub fn head(@mut self) -> T { self.head_n().data }\n \n     /// Get data at the list's tail, failing if empty. O(1).\n-    fn tail(@mut self) -> T { self.tail_n().data }\n+    pub fn tail(@mut self) -> T { self.tail_n().data }\n \n     /// Get the elements of the list as a vector. O(n).\n-    fn to_vec(@mut self) -> ~[T] {\n+    pub fn to_vec(@mut self) -> ~[T] {\n         let mut v = vec::with_capacity(self.size);\n         for old_iter::eachi(&self) |index,data| {\n             v[index] = *data;\n@@ -538,6 +541,9 @@ mod tests {\n \n     use super::*;\n \n+    use core::old_iter;\n+    use core::vec;\n+\n     #[test]\n     fn test_dlist_concat() {\n         let a = from_vec([1,2]);"}, {"sha": "dd08f23a7a10f69ad47071bf46978ed4a69bf36a", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 121, "deletions": 106, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n@@ -49,32 +51,34 @@ pub enum EbmlEncoderTag {\n     EsI16,      // 8\n     EsI8,       // 9\n     EsBool,     // 10\n-    EsStr,      // 11\n-    EsF64,      // 12\n-    EsF32,      // 13\n-    EsFloat,    // 14\n-    EsEnum,     // 15\n-    EsEnumVid,  // 16\n-    EsEnumBody, // 17\n-    EsVec,      // 18\n-    EsVecLen,   // 19\n-    EsVecElt,   // 20\n+    EsChar,     // 11\n+    EsStr,      // 12\n+    EsF64,      // 13\n+    EsF32,      // 14\n+    EsFloat,    // 15\n+    EsEnum,     // 16\n+    EsEnumVid,  // 17\n+    EsEnumBody, // 18\n+    EsVec,      // 19\n+    EsVecLen,   // 20\n+    EsVecElt,   // 21\n+    EsMap,      // 22\n+    EsMapLen,   // 23\n+    EsMapKey,   // 24\n+    EsMapVal,   // 25\n \n     EsOpaque,\n \n-    EsLabel // Used only when debugging\n+    EsLabel, // Used only when debugging\n }\n // --------------------------------------\n \n pub mod reader {\n-    use core::prelude::*;\n+    use super::*;\n \n-    use ebml::{Doc, EbmlEncoderTag, EsBool, EsEnum, EsEnumBody, EsEnumVid};\n-    use ebml::{EsI16, EsI32, EsI64, EsI8, EsInt};\n-    use ebml::{EsLabel, EsOpaque, EsStr, EsU16, EsU32, EsU64, EsU8, EsUint};\n-    use ebml::{EsVec, EsVecElt, EsVecLen, TaggedDoc};\n     use serialize;\n \n+    use core::prelude::*;\n     use core::cast::transmute;\n     use core::int;\n     use core::io;\n@@ -85,10 +89,18 @@ pub mod reader {\n \n     // ebml reading\n \n-    pub impl Doc {\n-        fn get(&self, tag: uint) -> Doc {\n+    impl Doc {\n+        pub fn get(&self, tag: uint) -> Doc {\n             get_doc(*self, tag)\n         }\n+\n+        pub fn as_str_slice<'a>(&'a self) -> &'a str {\n+            str::from_bytes_slice(self.data.slice(self.start, self.end))\n+        }\n+\n+        pub fn as_str(&self) -> ~str {\n+            self.as_str_slice().to_owned()\n+        }\n     }\n \n     struct Res {\n@@ -167,7 +179,7 @@ pub mod reader {\n     }\n \n     pub fn Doc(data: @~[u8]) -> Doc {\n-        Doc { data: data, start: 0u, end: vec::len::<u8>(*data) }\n+        Doc { data: data, start: 0u, end: data.len() }\n     }\n \n     pub fn doc_at(data: @~[u8], start: uint) -> TaggedDoc {\n@@ -235,15 +247,10 @@ pub mod reader {\n         return true;\n     }\n \n-    pub fn doc_data(d: Doc) -> ~[u8] {\n-        vec::slice::<u8>(*d.data, d.start, d.end).to_vec()\n-    }\n-\n     pub fn with_doc_data<T>(d: Doc, f: &fn(x: &[u8]) -> T) -> T {\n         f(vec::slice(*d.data, d.start, d.end))\n     }\n \n-    pub fn doc_as_str(d: Doc) -> ~str { str::from_bytes(doc_data(d)) }\n \n     pub fn doc_as_u8(d: Doc) -> u8 {\n         assert_eq!(d.end, d.start + 1u);\n@@ -282,15 +289,15 @@ pub mod reader {\n         }\n     }\n \n-    priv impl Decoder {\n+    impl Decoder {\n         fn _check_label(&mut self, lbl: &str) {\n             if self.pos < self.parent.end {\n                 let TaggedDoc { tag: r_tag, doc: r_doc } =\n                     doc_at(self.parent.data, self.pos);\n \n                 if r_tag == (EsLabel as uint) {\n                     self.pos = r_doc.end;\n-                    let str = doc_as_str(r_doc);\n+                    let str = r_doc.as_str_slice();\n                     if lbl != str {\n                         fail!(\"Expected label %s but found %s\", lbl, str);\n                     }\n@@ -319,12 +326,14 @@ pub mod reader {\n             r_doc\n         }\n \n-        fn push_doc<T>(&mut self, d: Doc, f: &fn() -> T) -> T {\n+        fn push_doc<T>(&mut self, exp_tag: EbmlEncoderTag,\n+                       f: &fn(&mut Decoder) -> T) -> T {\n+            let d = self.next_doc(exp_tag);\n             let old_parent = self.parent;\n             let old_pos = self.pos;\n             self.parent = d;\n             self.pos = d.start;\n-            let r = f();\n+            let r = f(self);\n             self.parent = old_parent;\n             self.pos = old_pos;\n             r\n@@ -337,8 +346,9 @@ pub mod reader {\n         }\n     }\n \n-    pub impl Decoder {\n-        fn read_opaque<R>(&mut self, op: &fn(&mut Decoder, Doc) -> R) -> R {\n+    impl Decoder {\n+        pub fn read_opaque<R>(&mut self, op: &fn(&mut Decoder, Doc) -> R)\n+                              -> R {\n             let doc = self.next_doc(EsOpaque);\n \n             let (old_parent, old_pos) = (self.parent, self.pos);\n@@ -393,11 +403,24 @@ pub mod reader {\n             doc_as_u8(self.next_doc(EsBool)) as bool\n         }\n \n-        fn read_f64(&mut self) -> f64 { fail!(\"read_f64()\"); }\n-        fn read_f32(&mut self) -> f32 { fail!(\"read_f32()\"); }\n-        fn read_float(&mut self) -> float { fail!(\"read_float()\"); }\n-        fn read_char(&mut self) -> char { fail!(\"read_char()\"); }\n-        fn read_str(&mut self) -> ~str { doc_as_str(self.next_doc(EsStr)) }\n+        fn read_f64(&mut self) -> f64 {\n+            let bits = doc_as_u64(self.next_doc(EsF64));\n+            unsafe { transmute(bits) }\n+        }\n+        fn read_f32(&mut self) -> f32 {\n+            let bits = doc_as_u32(self.next_doc(EsF32));\n+            unsafe { transmute(bits) }\n+        }\n+        fn read_float(&mut self) -> float {\n+            let bits = doc_as_u64(self.next_doc(EsFloat));\n+            (unsafe { transmute::<u64, f64>(bits) }) as float\n+        }\n+        fn read_char(&mut self) -> char {\n+            doc_as_u32(self.next_doc(EsChar)) as char\n+        }\n+        fn read_str(&mut self) -> ~str {\n+            self.next_doc(EsStr).as_str()\n+        }\n \n         // Compound types:\n         fn read_enum<T>(&mut self,\n@@ -539,68 +562,51 @@ pub mod reader {\n \n         fn read_seq<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n             debug!(\"read_seq()\");\n-            let doc = self.next_doc(EsVec);\n-\n-            let (old_parent, old_pos) = (self.parent, self.pos);\n-            self.parent = doc;\n-            self.pos = self.parent.start;\n-\n-            let len = self._next_uint(EsVecLen);\n-            debug!(\"  len=%u\", len);\n-            let result = f(self, len);\n-\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            result\n+            do self.push_doc(EsVec) |d| {\n+                let len = d._next_uint(EsVecLen);\n+                debug!(\"  len=%u\", len);\n+                f(d, len)\n+            }\n         }\n \n         fn read_seq_elt<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n                            -> T {\n             debug!(\"read_seq_elt(idx=%u)\", idx);\n-            let doc = self.next_doc(EsVecElt);\n-\n-            let (old_parent, old_pos) = (self.parent, self.pos);\n-            self.parent = doc;\n-            self.pos = self.parent.start;\n-\n-            let result = f(self);\n-\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            result\n+            self.push_doc(EsVecElt, f)\n         }\n \n-        fn read_map<T>(&mut self, _: &fn(&mut Decoder, uint) -> T) -> T {\n+        fn read_map<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n             debug!(\"read_map()\");\n-            fail!(\"read_map is unimplemented\");\n+            do self.push_doc(EsMap) |d| {\n+                let len = d._next_uint(EsMapLen);\n+                debug!(\"  len=%u\", len);\n+                f(d, len)\n+            }\n         }\n \n         fn read_map_elt_key<T>(&mut self,\n                                idx: uint,\n-                               _: &fn(&mut Decoder) -> T)\n+                               f: &fn(&mut Decoder) -> T)\n                                -> T {\n             debug!(\"read_map_elt_key(idx=%u)\", idx);\n-            fail!(\"read_map_elt_val is unimplemented\");\n+            self.push_doc(EsMapKey, f)\n         }\n \n         fn read_map_elt_val<T>(&mut self,\n                                idx: uint,\n-                               _: &fn(&mut Decoder) -> T)\n+                               f: &fn(&mut Decoder) -> T)\n                                -> T {\n             debug!(\"read_map_elt_val(idx=%u)\", idx);\n-            fail!(\"read_map_elt_val is unimplemented\");\n+            self.push_doc(EsMapVal, f)\n         }\n     }\n }\n \n pub mod writer {\n-    use ebml::{EbmlEncoderTag, EsBool, EsEnum, EsEnumBody, EsEnumVid};\n-    use ebml::{EsI16, EsI32, EsI64, EsI8, EsInt};\n-    use ebml::{EsLabel, EsOpaque, EsStr, EsU16, EsU32, EsU64, EsU8, EsUint};\n-    use ebml::{EsVec, EsVecElt, EsVecLen};\n+    use super::*;\n \n+    use core::cast;\n     use core::io;\n-    use core::str;\n \n     // ebml writing\n     pub struct Encoder {\n@@ -637,8 +643,8 @@ pub mod writer {\n     }\n \n     // FIXME (#2741): Provide a function to write the standard ebml header.\n-    pub impl Encoder {\n-        fn start_tag(&mut self, tag_id: uint) {\n+    impl Encoder {\n+        pub fn start_tag(&mut self, tag_id: uint) {\n             debug!(\"Start tag %u\", tag_id);\n \n             // Write the enum ID:\n@@ -650,7 +656,7 @@ pub mod writer {\n             self.writer.write(zeroes);\n         }\n \n-        fn end_tag(&mut self) {\n+        pub fn end_tag(&mut self) {\n             let last_size_pos = self.size_positions.pop();\n             let cur_pos = self.writer.tell();\n             self.writer.seek(last_size_pos as int, io::SeekSet);\n@@ -661,74 +667,74 @@ pub mod writer {\n             debug!(\"End tag (size = %u)\", size);\n         }\n \n-        fn wr_tag(&mut self, tag_id: uint, blk: &fn()) {\n+        pub fn wr_tag(&mut self, tag_id: uint, blk: &fn()) {\n             self.start_tag(tag_id);\n             blk();\n             self.end_tag();\n         }\n \n-        fn wr_tagged_bytes(&mut self, tag_id: uint, b: &[u8]) {\n+        pub fn wr_tagged_bytes(&mut self, tag_id: uint, b: &[u8]) {\n             write_vuint(self.writer, tag_id);\n             write_vuint(self.writer, b.len());\n             self.writer.write(b);\n         }\n \n-        fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) {\n+        pub fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) {\n             do io::u64_to_be_bytes(v, 8u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_u32(&mut self, tag_id: uint, v: u32) {\n+        pub fn wr_tagged_u32(&mut self, tag_id: uint, v: u32) {\n             do io::u64_to_be_bytes(v as u64, 4u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_u16(&mut self, tag_id: uint, v: u16) {\n+        pub fn wr_tagged_u16(&mut self, tag_id: uint, v: u16) {\n             do io::u64_to_be_bytes(v as u64, 2u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_u8(&mut self, tag_id: uint, v: u8) {\n+        pub fn wr_tagged_u8(&mut self, tag_id: uint, v: u8) {\n             self.wr_tagged_bytes(tag_id, &[v]);\n         }\n \n-        fn wr_tagged_i64(&mut self, tag_id: uint, v: i64) {\n+        pub fn wr_tagged_i64(&mut self, tag_id: uint, v: i64) {\n             do io::u64_to_be_bytes(v as u64, 8u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_i32(&mut self, tag_id: uint, v: i32) {\n+        pub fn wr_tagged_i32(&mut self, tag_id: uint, v: i32) {\n             do io::u64_to_be_bytes(v as u64, 4u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_i16(&mut self, tag_id: uint, v: i16) {\n+        pub fn wr_tagged_i16(&mut self, tag_id: uint, v: i16) {\n             do io::u64_to_be_bytes(v as u64, 2u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_i8(&mut self, tag_id: uint, v: i8) {\n+        pub fn wr_tagged_i8(&mut self, tag_id: uint, v: i8) {\n             self.wr_tagged_bytes(tag_id, &[v as u8]);\n         }\n \n-        fn wr_tagged_str(&mut self, tag_id: uint, v: &str) {\n-            str::byte_slice(v, |b| self.wr_tagged_bytes(tag_id, b));\n+        pub fn wr_tagged_str(&mut self, tag_id: uint, v: &str) {\n+            self.wr_tagged_bytes(tag_id, v.as_bytes());\n         }\n \n-        fn wr_bytes(&mut self, b: &[u8]) {\n+        pub fn wr_bytes(&mut self, b: &[u8]) {\n             debug!(\"Write %u bytes\", b.len());\n             self.writer.write(b);\n         }\n \n-        fn wr_str(&mut self, s: &str) {\n+        pub fn wr_str(&mut self, s: &str) {\n             debug!(\"Write str: %?\", s);\n-            self.writer.write(str::to_bytes(s));\n+            self.writer.write(s.as_bytes());\n         }\n     }\n \n@@ -739,7 +745,7 @@ pub mod writer {\n     // Totally lame approach.\n     static debug: bool = true;\n \n-    priv impl Encoder {\n+    impl Encoder {\n         // used internally to emit things like the vector length and so on\n         fn _emit_tagged_uint(&mut self, t: EbmlEncoderTag, v: uint) {\n             assert!(v <= 0xFFFF_FFFF_u);\n@@ -757,8 +763,8 @@ pub mod writer {\n         }\n     }\n \n-    pub impl Encoder {\n-        fn emit_opaque(&mut self, f: &fn(&mut Encoder)) {\n+    impl Encoder {\n+        pub fn emit_opaque(&mut self, f: &fn(&mut Encoder)) {\n             self.start_tag(EsOpaque as uint);\n             f(self);\n             self.end_tag();\n@@ -804,19 +810,21 @@ pub mod writer {\n             self.wr_tagged_u8(EsBool as uint, v as u8)\n         }\n \n-        // FIXME (#2742): implement these\n-        fn emit_f64(&mut self, _v: f64) {\n-            fail!(\"Unimplemented: serializing an f64\");\n+        fn emit_f64(&mut self, v: f64) {\n+            let bits = unsafe { cast::transmute(v) };\n+            self.wr_tagged_u64(EsF64 as uint, bits);\n         }\n-        fn emit_f32(&mut self, _v: f32) {\n-            fail!(\"Unimplemented: serializing an f32\");\n+        fn emit_f32(&mut self, v: f32) {\n+            let bits = unsafe { cast::transmute(v) };\n+            self.wr_tagged_u32(EsF32 as uint, bits);\n         }\n-        fn emit_float(&mut self, _v: float) {\n-            fail!(\"Unimplemented: serializing a float\");\n+        fn emit_float(&mut self, v: float) {\n+            let bits = unsafe { cast::transmute(v as f64) };\n+            self.wr_tagged_u64(EsFloat as uint, bits);\n         }\n \n-        fn emit_char(&mut self, _v: char) {\n-            fail!(\"Unimplemented: serializing a char\");\n+        fn emit_char(&mut self, v: char) {\n+            self.wr_tagged_u32(EsChar as uint, v as u32);\n         }\n \n         fn emit_str(&mut self, v: &str) {\n@@ -912,16 +920,23 @@ pub mod writer {\n             self.end_tag();\n         }\n \n-        fn emit_map(&mut self, _len: uint, _f: &fn(&mut Encoder)) {\n-            fail!(\"emit_map is unimplemented\");\n+        fn emit_map(&mut self, len: uint, f: &fn(&mut Encoder)) {\n+            self.start_tag(EsMap as uint);\n+            self._emit_tagged_uint(EsMapLen, len);\n+            f(self);\n+            self.end_tag();\n         }\n \n-        fn emit_map_elt_key(&mut self, _idx: uint, _f: &fn(&mut Encoder)) {\n-            fail!(\"emit_map_elt_key is unimplemented\");\n+        fn emit_map_elt_key(&mut self, _idx: uint, f: &fn(&mut Encoder)) {\n+            self.start_tag(EsMapKey as uint);\n+            f(self);\n+            self.end_tag();\n         }\n \n-        fn emit_map_elt_val(&mut self, _idx: uint, _f: &fn(&mut Encoder)) {\n-            fail!(\"emit_map_elt_val is unimplemented\");\n+        fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut Encoder)) {\n+            self.start_tag(EsMapVal as uint);\n+            f(self);\n+            self.end_tag();\n         }\n     }\n }"}, {"sha": "ed38db1d686eb19eb35bcad8d176157f84c2437c", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -94,8 +94,15 @@ total line count).\n     }\n */\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n+use core::io::ReaderUtil;\n+use core::io;\n+use core::os;\n+use core::vec;\n+\n /**\n A summary of the internal state of a `FileInput` object. `line_num`\n and `line_num_file` represent the number of lines read in total and in\n@@ -187,8 +194,8 @@ impl FileInput {\n     arguments. `\"-\"` represents `stdin`.\n     */\n     pub fn from_args() -> FileInput {\n-        let args = os::args(),\n-            pathed = pathify(args.tail(), true);\n+        let args = os::args();\n+        let pathed = pathify(args.tail(), true);\n         FileInput::from_vec(pathed)\n     }\n \n@@ -215,11 +222,11 @@ impl FileInput {\n             return false;\n         }\n \n-        let path_option = self.fi.files.shift(),\n-            file = match path_option {\n-                None => io::stdin(),\n-                Some(ref path) => io::file_reader(path).get()\n-            };\n+        let path_option = self.fi.files.shift();\n+        let file = match path_option {\n+            None => io::stdin(),\n+            Some(ref path) => io::file_reader(path).get()\n+        };\n \n         self.fi.current_reader = Some(file);\n         self.fi.state.current_path = path_option;\n@@ -407,6 +414,10 @@ mod test {\n \n     use super::{FileInput, pathify, input_vec, input_vec_state};\n \n+    use core::io;\n+    use core::uint;\n+    use core::vec;\n+\n     fn make_file(path : &Path, contents: &[~str]) {\n         let file = io::file_writer(path, [io::Create, io::Truncate]).get();\n \n@@ -419,8 +430,8 @@ mod test {\n     #[test]\n     fn test_pathify() {\n         let strs = [~\"some/path\",\n-                    ~\"some/other/path\"],\n-            paths = ~[Some(Path(\"some/path\")),\n+                    ~\"some/other/path\"];\n+        let paths = ~[Some(Path(\"some/path\")),\n                       Some(Path(\"some/other/path\"))];\n \n         assert_eq!(pathify(strs, true), copy paths);\n@@ -443,7 +454,7 @@ mod test {\n \n         let fi = FileInput::from_vec(copy filenames);\n \n-        for \"012\".each_chari |line, c| {\n+        for \"012\".iter().enumerate().advance |(line, c)| {\n             assert_eq!(fi.read_byte(), c as int);\n             assert_eq!(fi.state().line_num, line);\n             assert_eq!(fi.state().line_num_file, 0);\n@@ -475,7 +486,7 @@ mod test {\n         let mut buf : ~[u8] = vec::from_elem(6, 0u8);\n         let count = fi.read(buf, 10);\n         assert_eq!(count, 6);\n-        assert_eq!(buf, \"0\\n1\\n2\\n\".to_bytes());\n+        assert_eq!(buf, \"0\\n1\\n2\\n\".as_bytes().to_owned());\n         assert!(fi.eof())\n         assert_eq!(fi.state().line_num, 3);\n     }\n@@ -514,9 +525,7 @@ mod test {\n         }\n \n         for input_vec_state(filenames) |line, state| {\n-            let nums = do vec::build |p| {\n-                for str::each_split_char(line, ' ') |s| { p(s.to_owned()); }\n-            };\n+            let nums: ~[&str] = line.split_iter(' ').collect();\n             let file_num = uint::from_str(nums[0]).get();\n             let line_num = uint::from_str(nums[1]).get();\n             assert_eq!(line_num, state.line_num_file);\n@@ -549,8 +558,10 @@ mod test {\n \n     #[test]\n     fn test_no_trailing_newline() {\n-        let f1 = Some(Path(\"tmp/lib-fileinput-test-no-trailing-newline-1.tmp\")),\n-            f2 = Some(Path(\"tmp/lib-fileinput-test-no-trailing-newline-2.tmp\"));\n+        let f1 =\n+            Some(Path(\"tmp/lib-fileinput-test-no-trailing-newline-1.tmp\"));\n+        let f2 =\n+            Some(Path(\"tmp/lib-fileinput-test-no-trailing-newline-2.tmp\"));\n \n         let wr = io::file_writer(f1.get_ref(), [io::Create, io::Truncate]).get();\n         wr.write_str(\"1\\n2\");"}, {"sha": "0fde03b69cbf56f05da07454d03e445aa36f06c4", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -14,10 +14,11 @@ Simple compression\n \n */\n \n-use core::prelude::*;\n+#[allow(missing_doc)];\n \n-use core::libc;\n use core::libc::{c_void, size_t, c_int};\n+use core::libc;\n+use core::vec;\n \n pub mod rustrt {\n     use core::libc::{c_int, c_void, size_t};\n@@ -84,6 +85,7 @@ mod tests {\n     use super::*;\n     use core::rand;\n     use core::rand::RngUtil;\n+    use core::prelude::*;\n \n     #[test]\n     #[allow(non_implicitly_copyable_typarams)]"}, {"sha": "c0f619c1b858d9d89c014a6f6cf75c240c02ab55", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 39, "deletions": 26, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -47,6 +47,8 @@ block the scheduler thread, so will their pipes.\n \n */\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n // The basic send/recv interface FlatChan and PortChan will implement\n@@ -315,17 +317,17 @@ impl<T,F:Flattener<T>,C:ByteChan> GenericChan<T> for FlatChan<T, F, C> {\n     }\n }\n \n-pub impl<T,U:Unflattener<T>,P:BytePort> FlatPort<T, U, P> {\n-    fn new(u: U, p: P) -> FlatPort<T, U, P> {\n+impl<T,U:Unflattener<T>,P:BytePort> FlatPort<T, U, P> {\n+    pub fn new(u: U, p: P) -> FlatPort<T, U, P> {\n         FlatPort {\n             unflattener: u,\n             byte_port: p\n         }\n     }\n }\n \n-pub impl<T,F:Flattener<T>,C:ByteChan> FlatChan<T, F, C> {\n-    fn new(f: F, c: C) -> FlatChan<T, F, C> {\n+impl<T,F:Flattener<T>,C:ByteChan> FlatChan<T, F, C> {\n+    pub fn new(f: F, c: C) -> FlatChan<T, F, C> {\n         FlatChan {\n             flattener: f,\n             byte_chan: c\n@@ -345,11 +347,11 @@ pub mod flatteners {\n \n     use core::cast;\n     use core::io::{Writer, Reader, ReaderUtil};\n+    use core::io;\n     use core::ptr;\n     use core::sys::size_of;\n     use core::vec;\n \n-\n     // FIXME #4074: Copy + Owned != POD\n     pub struct PodUnflattener<T> {\n         bogus: ()\n@@ -378,16 +380,16 @@ pub mod flatteners {\n         }\n     }\n \n-    pub impl<T:Copy + Owned> PodUnflattener<T> {\n-        fn new() -> PodUnflattener<T> {\n+    impl<T:Copy + Owned> PodUnflattener<T> {\n+        pub fn new() -> PodUnflattener<T> {\n             PodUnflattener {\n                 bogus: ()\n             }\n         }\n     }\n \n-    pub impl<T:Copy + Owned> PodFlattener<T> {\n-        fn new() -> PodFlattener<T> {\n+    impl<T:Copy + Owned> PodFlattener<T> {\n+        pub fn new() -> PodFlattener<T> {\n             PodFlattener {\n                 bogus: ()\n             }\n@@ -421,17 +423,17 @@ pub mod flatteners {\n         }\n     }\n \n-    pub impl<D:Decoder,T:Decodable<D>> DeserializingUnflattener<D, T> {\n-        fn new(deserialize_buffer: DeserializeBuffer<T>)\n+    impl<D:Decoder,T:Decodable<D>> DeserializingUnflattener<D, T> {\n+        pub fn new(deserialize_buffer: DeserializeBuffer<T>)\n                    -> DeserializingUnflattener<D, T> {\n             DeserializingUnflattener {\n                 deserialize_buffer: deserialize_buffer\n             }\n         }\n     }\n \n-    pub impl<S:Encoder,T:Encodable<S>> SerializingFlattener<S, T> {\n-        fn new(serialize_value: SerializeValue<T>)\n+    impl<S:Encoder,T:Encodable<S>> SerializingFlattener<S, T> {\n+        pub fn new(serialize_value: SerializeValue<T>)\n                    -> SerializingFlattener<S, T> {\n             SerializingFlattener {\n                 serialize_value: serialize_value\n@@ -511,8 +513,10 @@ pub mod bytepipes {\n \n     use flatpipes::{ByteChan, BytePort};\n \n-    use core::io::{Writer, Reader, ReaderUtil};\n     use core::comm::{Port, Chan};\n+    use core::comm;\n+    use core::io::{Writer, Reader, ReaderUtil};\n+    use core::vec;\n \n     pub struct ReaderBytePort<R> {\n         reader: R\n@@ -550,16 +554,16 @@ pub mod bytepipes {\n         }\n     }\n \n-    pub impl<R:Reader> ReaderBytePort<R> {\n-        fn new(r: R) -> ReaderBytePort<R> {\n+    impl<R:Reader> ReaderBytePort<R> {\n+        pub fn new(r: R) -> ReaderBytePort<R> {\n             ReaderBytePort {\n                 reader: r\n             }\n         }\n     }\n \n-    pub impl<W:Writer> WriterByteChan<W> {\n-        fn new(w: W) -> WriterByteChan<W> {\n+    impl<W:Writer> WriterByteChan<W> {\n+        pub fn new(w: W) -> WriterByteChan<W> {\n             WriterByteChan {\n                 writer: w\n             }\n@@ -615,17 +619,17 @@ pub mod bytepipes {\n         }\n     }\n \n-    pub impl PipeBytePort {\n-        fn new(p: Port<~[u8]>) -> PipeBytePort {\n+    impl PipeBytePort {\n+        pub fn new(p: Port<~[u8]>) -> PipeBytePort {\n             PipeBytePort {\n                 port: p,\n                 buf: @mut ~[]\n             }\n         }\n     }\n \n-    pub impl PipeByteChan {\n-        fn new(c: Chan<~[u8]>) -> PipeByteChan {\n+    impl PipeByteChan {\n+        pub fn new(c: Chan<~[u8]>) -> PipeByteChan {\n             PipeByteChan {\n                 chan: c\n             }\n@@ -646,12 +650,16 @@ mod test {\n     use flatpipes::{BytePort, FlatChan, FlatPort};\n     use net::tcp::TcpSocketBuf;\n \n+    use core::comm;\n+    use core::int;\n     use core::io::BytesWriter;\n+    use core::result;\n+    use core::task;\n \n     #[test]\n     #[ignore(reason = \"ebml failure\")]\n     fn test_serializing_memory_stream() {\n-        let writer = BytesWriter();\n+        let writer = BytesWriter::new();\n         let chan = serial::writer_chan(writer);\n \n         chan.send(10);\n@@ -699,7 +707,7 @@ mod test {\n \n     #[test]\n     fn test_pod_memory_stream() {\n-        let writer = BytesWriter();\n+        let writer = BytesWriter::new();\n         let chan = pod::writer_chan(writer);\n \n         chan.send(10);\n@@ -782,8 +790,8 @@ mod test {\n \n         let addr0 = ip::v4::parse_addr(\"127.0.0.1\");\n \n-        let begin_connect_chan = Cell(begin_connect_chan);\n-        let accept_chan = Cell(accept_chan);\n+        let begin_connect_chan = Cell::new(begin_connect_chan);\n+        let accept_chan = Cell::new(accept_chan);\n \n         // The server task\n         let addr = copy addr0;\n@@ -873,6 +881,11 @@ mod test {\n         use flatpipes::pod;\n         use io_util::BufReader;\n \n+        use core::comm;\n+        use core::io;\n+        use core::sys;\n+        use core::task;\n+\n         type PortLoader<P> =\n             ~fn(~[u8]) -> FlatPort<int, PodUnflattener<int>, P>;\n "}, {"sha": "eb8c27e9902b5bb047b247f49e5dc0ab5143236a", "filename": "src/libextra/fun_treemap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffun_treemap.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -35,13 +35,13 @@ enum TreeNode<K, V> {\n pub fn init<K, V>() -> Treemap<K, V> { @Empty }\n \n /// Insert a value into the map\n-pub fn insert<K:Copy + Eq + Ord,V:Copy>(m: Treemap<K, V>, k: K, v: V) -> Treemap<K, V> {\n+pub fn insert<K:Eq + Ord,V>(m: Treemap<K, V>, k: K, v: V) -> Treemap<K, V> {\n     @match m {\n         @Empty => Node(@k, @v, @Empty, @Empty),\n-        @Node(@copy kk, vv, left, right) => cond!(\n-            (k <  kk) { Node(@kk, vv, insert(left, k, v), right) }\n-            (k == kk) { Node(@kk, @v, left, right)               }\n-            _         { Node(@kk, vv, left, insert(right, k, v)) }\n+        @Node(kk, vv, left, right) => cond!(\n+            (k <  *kk) { Node(kk, vv, insert(left, k, v), right) }\n+            (k == *kk) { Node(kk, @v, left, right)               }\n+            _          { Node(kk, vv, left, insert(right, k, v)) }\n         )\n     }\n }\n@@ -50,8 +50,8 @@ pub fn insert<K:Copy + Eq + Ord,V:Copy>(m: Treemap<K, V>, k: K, v: V) -> Treemap\n pub fn find<K:Eq + Ord,V:Copy>(m: Treemap<K, V>, k: K) -> Option<V> {\n     match *m {\n         Empty => None,\n-        Node(@ref kk, @copy v, left, right) => cond!(\n-            (k == *kk) { Some(v)        }\n+        Node(kk, v, left, right) => cond!(\n+            (k == *kk) { Some(copy *v)  }\n             (k <  *kk) { find(left, k)  }\n             _          { find(right, k) }\n         )"}, {"sha": "40cfeebd5dcd8b869dceb5717c3c60732662211d", "filename": "src/libextra/future.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -23,6 +23,8 @@\n  * ~~~\n  */\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n use core::cast;\n@@ -52,15 +54,15 @@ priv enum FutureState<A> {\n }\n \n /// Methods on the `future` type\n-pub impl<A:Copy> Future<A> {\n-    fn get(&mut self) -> A {\n+impl<A:Copy> Future<A> {\n+    pub fn get(&mut self) -> A {\n         //! Get the value of the future.\n         *(self.get_ref())\n     }\n }\n \n-pub impl<A> Future<A> {\n-    fn get_ref<'a>(&'a mut self) -> &'a A {\n+impl<A> Future<A> {\n+    pub fn get_ref<'a>(&'a mut self) -> &'a A {\n         /*!\n         * Executes the future's closure and then returns a borrowed\n         * pointer to the result.  The borrowed pointer lasts as long as\n@@ -107,7 +109,7 @@ pub fn from_port<A:Owned>(port: PortOne<A>) -> Future<A> {\n      * waiting for the result to be received on the port.\n      */\n \n-    let port = Cell(port);\n+    let port = Cell::new(port);\n     do from_fn {\n         recv_one(port.take())\n     }\n@@ -135,7 +137,7 @@ pub fn spawn<A:Owned>(blk: ~fn() -> A) -> Future<A> {\n \n     let (port, chan) = oneshot();\n \n-    let chan = Cell(chan);\n+    let chan = Cell::new(chan);\n     do task::spawn {\n         let chan = chan.take();\n         send_one(chan, blk());\n@@ -202,7 +204,7 @@ mod test {\n     #[test]\n     fn test_sendable_future() {\n         let expected = \"schlorf\";\n-        let f = Cell(do spawn { expected });\n+        let f = Cell::new(do spawn { expected });\n         do task::spawn {\n             let mut f = f.take();\n             let actual = f.get();"}, {"sha": "05649104c31678687392572c8afb9f639775b6e7", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 66, "deletions": 63, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -31,21 +31,22 @@\n  * file name following -o, and accepts both -h and --help as optional flags.\n  *\n  * ```\n- *    extern mod std;\n- *    use std::getopts::*;\n+ *    extern mod extra;\n+ *    use extra::getopts::*;\n+ *    use std::os;\n  *\n  *    fn do_work(in: &str, out: Option<~str>) {\n- *      io::println(in);\n- *      io::println(match out {\n- *        Some(x) => x,\n- *        None => ~\"No Output\"\n- *      });\n+ *        println(in);\n+ *        println(match out {\n+ *            Some(x) => x,\n+ *            None => ~\"No Output\"\n+ *        });\n  *    }\n  *\n- *    fn print_usage(program: &str, _opts: &[std::getopts::Opt]) {\n- *      io::println(fmt!(\"Usage: %s [options]\", program));\n- *      io::println(\"-o\\t\\tOutput\");\n- *      io::println(\"-h --help\\tUsage\");\n+ *    fn print_usage(program: &str, _opts: &[Opt]) {\n+ *        println(fmt!(\"Usage: %s [options]\", program));\n+ *        println(\"-o\\t\\tOutput\");\n+ *        println(\"-h --help\\tUsage\");\n  *    }\n  *\n  *    fn main() {\n@@ -58,9 +59,9 @@\n  *            optflag(\"h\"),\n  *            optflag(\"help\")\n  *        ];\n- *        let matches = match getopts(vec::tail(args), opts) {\n- *            result::Ok(m) => { m }\n- *            result::Err(f) => { fail!(fail_str(f)) }\n+ *        let matches = match getopts(args.tail(), opts) {\n+ *            Ok(m) => { m }\n+ *            Err(f) => { fail!(fail_str(f)) }\n  *        };\n  *        if opt_present(&matches, \"h\") || opt_present(&matches, \"help\") {\n  *            print_usage(program, opts);\n@@ -78,6 +79,8 @@\n  * ```\n  */\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n use core::cmp::Eq;\n@@ -108,10 +111,11 @@ pub struct Opt {\n }\n \n fn mkname(nm: &str) -> Name {\n-    let unm = str::to_owned(nm);\n-    return if nm.len() == 1u {\n-            Short(str::char_at(unm, 0u))\n-        } else { Long(unm) };\n+  if nm.len() == 1u {\n+      Short(nm.char_at(0u))\n+  } else {\n+      Long(nm.to_owned())\n+  }\n }\n \n /// Create an option that is required and takes an argument\n@@ -168,7 +172,7 @@ fn is_arg(arg: &str) -> bool {\n fn name_str(nm: &Name) -> ~str {\n     return match *nm {\n       Short(ch) => str::from_char(ch),\n-      Long(copy s) => s\n+      Long(ref s) => copy *s\n     };\n }\n \n@@ -193,19 +197,19 @@ pub enum Fail_ {\n pub fn fail_str(f: Fail_) -> ~str {\n     return match f {\n         ArgumentMissing(ref nm) => {\n-            ~\"Argument to option '\" + *nm + \"' missing.\"\n+            fmt!(\"Argument to option '%s' missing.\", *nm)\n         }\n         UnrecognizedOption(ref nm) => {\n-            ~\"Unrecognized option: '\" + *nm + \"'.\"\n+            fmt!(\"Unrecognized option: '%s'.\", *nm)\n         }\n         OptionMissing(ref nm) => {\n-            ~\"Required option '\" + *nm + \"' missing.\"\n+            fmt!(\"Required option '%s' missing.\", *nm)\n         }\n         OptionDuplicated(ref nm) => {\n-            ~\"Option '\" + *nm + \"' given more than once.\"\n+            fmt!(\"Option '%s' given more than once.\", *nm)\n         }\n         UnexpectedArgument(ref nm) => {\n-            ~\"Option \" + *nm + \" does not take an argument.\"\n+            fmt!(\"Option '%s' does not take an argument.\", *nm)\n         }\n     };\n }\n@@ -243,22 +247,21 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n             let mut names;\n             let mut i_arg = None;\n             if cur[1] == '-' as u8 {\n-                let tail = str::slice(cur, 2, curlen).to_owned();\n-                let mut tail_eq = ~[];\n-                for str::each_splitn_char(tail, '=', 1) |s| { tail_eq.push(s.to_owned()) }\n+                let tail = cur.slice(2, curlen);\n+                let tail_eq: ~[&str] = tail.split_iter('=').collect();\n                 if tail_eq.len() <= 1 {\n-                    names = ~[Long(tail)];\n+                    names = ~[Long(tail.to_owned())];\n                 } else {\n                     names =\n-                        ~[Long(copy tail_eq[0])];\n-                    i_arg = Some(copy tail_eq[1]);\n+                        ~[Long(tail_eq[0].to_owned())];\n+                    i_arg = Some(tail_eq[1].to_owned());\n                 }\n             } else {\n                 let mut j = 1;\n                 let mut last_valid_opt_id = None;\n                 names = ~[];\n                 while j < curlen {\n-                    let range = str::char_range_at(cur, j);\n+                    let range = cur.char_range_at(j);\n                     let opt = Short(range.ch);\n \n                     /* In a series of potential options (eg. -aheJ), if we\n@@ -387,7 +390,7 @@ pub fn opts_present(mm: &Matches, names: &[~str]) -> bool {\n  * argument\n  */\n pub fn opt_str(mm: &Matches, nm: &str) -> ~str {\n-    return match opt_val(mm, nm) { Val(copy s) => s, _ => fail!() };\n+    return match opt_val(mm, nm) { Val(s) => s, _ => fail!() };\n }\n \n /**\n@@ -399,7 +402,7 @@ pub fn opt_str(mm: &Matches, nm: &str) -> ~str {\n pub fn opts_str(mm: &Matches, names: &[~str]) -> ~str {\n     for names.each |nm| {\n         match opt_val(mm, *nm) {\n-          Val(copy s) => return s,\n+          Val(ref s) => return copy *s,\n           _ => ()\n         }\n     }\n@@ -416,17 +419,17 @@ pub fn opts_str(mm: &Matches, names: &[~str]) -> ~str {\n pub fn opt_strs(mm: &Matches, nm: &str) -> ~[~str] {\n     let mut acc: ~[~str] = ~[];\n     for vec::each(opt_vals(mm, nm)) |v| {\n-        match *v { Val(copy s) => acc.push(s), _ => () }\n+        match *v { Val(ref s) => acc.push(copy *s), _ => () }\n     }\n     return acc;\n }\n \n /// Returns the string argument supplied to a matching option or none\n pub fn opt_maybe_str(mm: &Matches, nm: &str) -> Option<~str> {\n     let vals = opt_vals(mm, nm);\n-    if vec::len::<Optval>(vals) == 0u { return None::<~str>; }\n+    if vals.is_empty() { return None::<~str>; }\n     return match vals[0] {\n-        Val(copy s) => Some(s),\n+        Val(ref s) => Some(copy *s),\n         _ => None\n     };\n }\n@@ -441,8 +444,8 @@ pub fn opt_maybe_str(mm: &Matches, nm: &str) -> Option<~str> {\n  */\n pub fn opt_default(mm: &Matches, nm: &str, def: &str) -> Option<~str> {\n     let vals = opt_vals(mm, nm);\n-    if vec::len::<Optval>(vals) == 0u { return None::<~str>; }\n-    return match vals[0] { Val(copy s) => Some::<~str>(s),\n+    if vals.is_empty() { return None::<~str>; }\n+    return match vals[0] { Val(ref s) => Some::<~str>(copy *s),\n                            _      => Some::<~str>(str::to_owned(def)) }\n }\n \n@@ -562,11 +565,11 @@ pub mod groups {\n                            hasarg: hasarg,\n                            occur: occur}],\n \n-           (1,0) => ~[Opt {name: Short(str::char_at(short_name, 0)),\n+           (1,0) => ~[Opt {name: Short(short_name.char_at(0)),\n                            hasarg: hasarg,\n                            occur: occur}],\n \n-           (1,_) => ~[Opt {name: Short(str::char_at(short_name, 0)),\n+           (1,_) => ~[Opt {name: Short(short_name.char_at(0)),\n                            hasarg: hasarg,\n                            occur:  occur},\n                       Opt {name:   Long((long_name)),\n@@ -589,7 +592,7 @@ pub mod groups {\n      */\n     pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n \n-        let desc_sep = ~\"\\n\" + str::repeat(\" \", 24);\n+        let desc_sep = ~\"\\n\" + \" \".repeat(24);\n \n         let rows = vec::map(opts, |optref| {\n             let OptGroup{short_name: short_name,\n@@ -599,7 +602,7 @@ pub mod groups {\n                          hasarg: hasarg,\n                          _} = copy *optref;\n \n-            let mut row = str::repeat(\" \", 4);\n+            let mut row = \" \".repeat(4);\n \n             // short option\n             row += match short_name.len() {\n@@ -625,14 +628,14 @@ pub mod groups {\n             // here we just need to indent the start of the description\n             let rowlen = row.len();\n             row += if rowlen < 24 {\n-                str::repeat(\" \", 24 - rowlen)\n+                \" \".repeat(24 - rowlen)\n             } else {\n                 copy desc_sep\n             };\n \n             // Normalize desc to contain words separated by one space character\n             let mut desc_normalized_whitespace = ~\"\";\n-            for str::each_word(desc) |word| {\n+            for desc.word_iter().advance |word| {\n                 desc_normalized_whitespace.push_str(word);\n                 desc_normalized_whitespace.push_char(' ');\n             }\n@@ -645,14 +648,14 @@ pub mod groups {\n \n             // FIXME: #5516\n             // wrapped description\n-            row += str::connect(desc_rows, desc_sep);\n+            row += desc_rows.connect(desc_sep);\n \n             row\n         });\n \n         return str::to_owned(brief) +\n                \"\\n\\nOptions:\\n\" +\n-               str::connect(rows, \"\\n\") +\n+               rows.connect(\"\\n\") +\n                \"\\n\\n\";\n     }\n } // end groups module\n@@ -698,7 +701,7 @@ mod tests {\n         let opts = ~[reqopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionMissing_),\n+          Err(f) => check_fail_type(f, OptionMissing_),\n           _ => fail!()\n         }\n     }\n@@ -709,7 +712,7 @@ mod tests {\n         let opts = ~[reqopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, ArgumentMissing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n     }\n@@ -720,7 +723,7 @@ mod tests {\n         let opts = ~[reqopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionDuplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n         }\n     }\n@@ -745,7 +748,7 @@ mod tests {\n         let opts = ~[reqopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionMissing_),\n+          Err(f) => check_fail_type(f, OptionMissing_),\n           _ => fail!()\n         }\n     }\n@@ -756,7 +759,7 @@ mod tests {\n         let opts = ~[reqopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, ArgumentMissing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n     }\n@@ -767,7 +770,7 @@ mod tests {\n         let opts = ~[reqopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionDuplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n         }\n     }\n@@ -805,7 +808,7 @@ mod tests {\n         let opts = ~[optopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, ArgumentMissing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n     }\n@@ -816,7 +819,7 @@ mod tests {\n         let opts = ~[optopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionDuplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n         }\n     }\n@@ -852,7 +855,7 @@ mod tests {\n         let opts = ~[optopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, ArgumentMissing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n     }\n@@ -863,7 +866,7 @@ mod tests {\n         let opts = ~[optopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionDuplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n         }\n     }\n@@ -898,7 +901,7 @@ mod tests {\n         let opts = ~[optflag(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => {\n+          Err(f) => {\n             error!(fail_str(copy f));\n             check_fail_type(f, UnexpectedArgument_);\n           }\n@@ -912,7 +915,7 @@ mod tests {\n         let opts = ~[optflag(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionDuplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n         }\n     }\n@@ -960,7 +963,7 @@ mod tests {\n         let opts = ~[optflag(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, OptionDuplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n         }\n     }\n@@ -1063,7 +1066,7 @@ mod tests {\n         let opts = ~[optmulti(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, ArgumentMissing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n     }\n@@ -1116,7 +1119,7 @@ mod tests {\n         let opts = ~[optmulti(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, ArgumentMissing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n     }\n@@ -1144,7 +1147,7 @@ mod tests {\n         let opts = ~[optmulti(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, UnrecognizedOption_),\n+          Err(f) => check_fail_type(f, UnrecognizedOption_),\n           _ => fail!()\n         }\n     }\n@@ -1155,7 +1158,7 @@ mod tests {\n         let opts = ~[optmulti(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(copy f) => check_fail_type(f, UnrecognizedOption_),\n+          Err(f) => check_fail_type(f, UnrecognizedOption_),\n           _ => fail!()\n         }\n     }"}, {"sha": "91424ae3ba2c0d6a749352549c54717232d3a59c", "filename": "src/libextra/io_util.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fio_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fio_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fio_util.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -11,20 +11,24 @@\n use core::io::{Reader, BytesReader};\n use core::io;\n \n+/// An implementation of the io::Reader interface which reads a buffer of bytes\n pub struct BufReader {\n+    /// The buffer of bytes to read\n     buf: ~[u8],\n+    /// The current position in the buffer of bytes\n     pos: @mut uint\n }\n \n-pub impl BufReader {\n+impl BufReader {\n+    /// Creates a new buffer reader for the specified buffer\n     pub fn new(v: ~[u8]) -> BufReader {\n         BufReader {\n             buf: v,\n             pos: @mut 0\n         }\n     }\n \n-    priv fn as_bytes_reader<A>(&self, f: &fn(&BytesReader) -> A) -> A {\n+    fn as_bytes_reader<A>(&self, f: &fn(&BytesReader) -> A) -> A {\n         // Recreating the BytesReader state every call since\n         // I can't get the borrowing to work correctly\n         let bytes_reader = BytesReader {"}, {"sha": "db95327f0aacae1269af68a390b93ed2805e78ac", "filename": "src/libextra/json.rs", "status": "modified", "additions": 49, "deletions": 20, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -10,14 +10,22 @@\n \n // Rust JSON serialization library\n // Copyright (c) 2011 Google Inc.\n+\n #[forbid(non_camel_case_types)];\n+#[allow(missing_doc)];\n \n //! json serialization\n \n use core::prelude::*;\n \n-use core::io::{WriterUtil, ReaderUtil};\n+use core::char;\n+use core::float;\n use core::hashmap::HashMap;\n+use core::io::{WriterUtil, ReaderUtil};\n+use core::io;\n+use core::str;\n+use core::to_str;\n+use core::vec;\n \n use serialize::Encodable;\n use serialize;\n@@ -37,15 +45,20 @@ pub type List = ~[Json];\n pub type Object = HashMap<~str, Json>;\n \n #[deriving(Eq)]\n+/// If an error occurs while parsing some JSON, this is the structure which is\n+/// returned\n pub struct Error {\n+    /// The line number at which the error occurred\n     line: uint,\n+    /// The column number at which the error occurred\n     col: uint,\n+    /// A message describing the type of the error\n     msg: @~str,\n }\n \n fn escape_str(s: &str) -> ~str {\n     let mut escaped = ~\"\\\"\";\n-    for str::each_char(s) |c| {\n+    for s.iter().advance |c| {\n         match c {\n           '\"' => escaped += \"\\\\\\\"\",\n           '\\\\' => escaped += \"\\\\\\\\\",\n@@ -65,14 +78,17 @@ fn escape_str(s: &str) -> ~str {\n \n fn spaces(n: uint) -> ~str {\n     let mut ss = ~\"\";\n-    for n.times { str::push_str(&mut ss, \" \"); }\n+    for n.times { ss.push_str(\" \"); }\n     return ss;\n }\n \n+/// A structure for implementing serialization to JSON.\n pub struct Encoder {\n     priv wr: @io::Writer,\n }\n \n+/// Creates a new JSON encoder whose output will be written to the writer\n+/// specified.\n pub fn Encoder(wr: @io::Writer) -> Encoder {\n     Encoder {\n         wr: wr\n@@ -222,11 +238,14 @@ impl serialize::Encoder for Encoder {\n     }\n }\n \n+/// Another encoder for JSON, but prints out human-readable JSON instead of\n+/// compact data\n pub struct PrettyEncoder {\n     priv wr: @io::Writer,\n     priv indent: uint,\n }\n \n+/// Creates a new encoder whose output will be written to the specified writer\n pub fn PrettyEncoder(wr: @io::Writer) -> PrettyEncoder {\n     PrettyEncoder {\n         wr: wr,\n@@ -462,6 +481,7 @@ pub fn to_pretty_str(json: &Json) -> ~str {\n     io::with_str_writer(|wr| to_pretty_writer(wr, json))\n }\n \n+#[allow(missing_doc)]\n pub struct Parser {\n     priv rdr: @io::Reader,\n     priv ch: char,\n@@ -479,8 +499,8 @@ pub fn Parser(rdr: @io::Reader) -> Parser {\n     }\n }\n \n-pub impl Parser {\n-    fn parse(&mut self) -> Result<Json, Error> {\n+impl Parser {\n+    pub fn parse(&mut self) -> Result<Json, Error> {\n         match self.parse_value() {\n           Ok(value) => {\n             // Skip trailing whitespaces.\n@@ -497,7 +517,7 @@ pub impl Parser {\n     }\n }\n \n-priv impl Parser {\n+impl Parser {\n     fn eof(&self) -> bool { self.ch == -1 as char }\n \n     fn bump(&mut self) {\n@@ -546,7 +566,7 @@ priv impl Parser {\n     }\n \n     fn parse_ident(&mut self, ident: &str, value: Json) -> Result<Json, Error> {\n-        if str::all(ident, |c| c == self.next_char()) {\n+        if ident.iter().all(|c| c == self.next_char()) {\n             self.bump();\n             Ok(value)\n         } else {\n@@ -691,14 +711,14 @@ priv impl Parser {\n \n             if (escape) {\n                 match self.ch {\n-                  '\"' => str::push_char(&mut res, '\"'),\n-                  '\\\\' => str::push_char(&mut res, '\\\\'),\n-                  '/' => str::push_char(&mut res, '/'),\n-                  'b' => str::push_char(&mut res, '\\x08'),\n-                  'f' => str::push_char(&mut res, '\\x0c'),\n-                  'n' => str::push_char(&mut res, '\\n'),\n-                  'r' => str::push_char(&mut res, '\\r'),\n-                  't' => str::push_char(&mut res, '\\t'),\n+                  '\"' => res.push_char('\"'),\n+                  '\\\\' => res.push_char('\\\\'),\n+                  '/' => res.push_char('/'),\n+                  'b' => res.push_char('\\x08'),\n+                  'f' => res.push_char('\\x0c'),\n+                  'n' => res.push_char('\\n'),\n+                  'r' => res.push_char('\\r'),\n+                  't' => res.push_char('\\t'),\n                   'u' => {\n                       // Parse \\u1234.\n                       let mut i = 0u;\n@@ -727,7 +747,7 @@ priv impl Parser {\n                             ~\"invalid \\\\u escape (not four digits)\");\n                       }\n \n-                      str::push_char(&mut res, n as char);\n+                      res.push_char(n as char);\n                   }\n                   _ => return self.error(~\"invalid escape\")\n                 }\n@@ -739,7 +759,7 @@ priv impl Parser {\n                     self.bump();\n                     return Ok(res);\n                 }\n-                str::push_char(&mut res, self.ch);\n+                res.push_char(self.ch);\n             }\n         }\n \n@@ -840,10 +860,12 @@ pub fn from_str(s: &str) -> Result<Json, Error> {\n     }\n }\n \n+/// A structure to decode JSON to values in rust.\n pub struct Decoder {\n     priv stack: ~[Json],\n }\n \n+/// Creates a new decoder instance for decoding the specified JSON value.\n pub fn Decoder(json: Json) -> Decoder {\n     Decoder {\n         stack: ~[json]\n@@ -891,7 +913,8 @@ impl serialize::Decoder for Decoder {\n \n     fn read_char(&mut self) -> char {\n         let mut v = ~[];\n-        for str::each_char(self.read_str()) |c| { v.push(c) }\n+        let s = self.read_str();\n+        for s.iter().advance |c| { v.push(c) }\n         if v.len() != 1 { fail!(\"string must have one character\") }\n         v[0]\n     }\n@@ -1194,7 +1217,11 @@ impl Ord for Json {\n     fn gt(&self, other: &Json) -> bool { (*other).lt(&(*self))  }\n }\n \n-trait ToJson { fn to_json(&self) -> Json; }\n+/// A trait for converting values to JSON\n+trait ToJson {\n+    /// Converts the value of `self` to an instance of JSON\n+    fn to_json(&self) -> Json;\n+}\n \n impl ToJson for Json {\n     fn to_json(&self) -> Json { copy *self }\n@@ -1332,6 +1359,8 @@ mod tests {\n     use super::*;\n \n     use core::hashmap::HashMap;\n+    use core::io;\n+    use core::result;\n \n     use std::serialize::Decodable;\n \n@@ -1358,7 +1387,7 @@ mod tests {\n \n         for items.each |item| {\n             match *item {\n-                (copy key, copy value) => { d.insert(key, value); },\n+                (ref key, ref value) => { d.insert(copy *key, copy *value); },\n             }\n         };\n "}, {"sha": "68d9bb4e1ae3a4a26ac344e15b0d6c8a76803817", "filename": "src/libextra/list.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flist.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A standard linked list\n+//! A standard, garbage-collected linked list.\n \n use core::prelude::*;\n \n+\n #[deriving(Eq)]\n pub enum List<T> {\n     Cons(T, @List<T>),\n@@ -26,7 +27,7 @@ pub enum MutList<T> {\n \n /// Create a list from a vector\n pub fn from_vec<T:Copy>(v: &[T]) -> @List<T> {\n-    vec::foldr(v, @Nil::<T>, |h, t| @Cons(*h, t))\n+    v.rev_iter().fold(@Nil::<T>, |t, h| @Cons(*h, t))\n }\n \n /**\n@@ -102,7 +103,7 @@ pub fn tail<T:Copy>(ls: @List<T>) -> @List<T> {\n /// Returns the first element of a list\n pub fn head<T:Copy>(ls: @List<T>) -> T {\n     match *ls {\n-      Cons(copy hd, _) => hd,\n+      Cons(ref hd, _) => copy *hd,\n       // makes me sad\n       _ => fail!(\"head invoked on empty list\")\n     }\n@@ -112,9 +113,9 @@ pub fn head<T:Copy>(ls: @List<T>) -> T {\n pub fn append<T:Copy>(l: @List<T>, m: @List<T>) -> @List<T> {\n     match *l {\n       Nil => return m,\n-      Cons(copy x, xs) => {\n+      Cons(ref x, xs) => {\n         let rest = append(xs, m);\n-        return @Cons(x, rest);\n+        return @Cons(copy *x, rest);\n       }\n     }\n }"}, {"sha": "6c972a313c4208f0f54bf20c81a713cdbf6b3a6e", "filename": "src/libextra/md4.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fmd4.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -10,7 +10,6 @@\n \n use core::prelude::*;\n \n-use core::str;\n use core::uint;\n use core::vec;\n \n@@ -21,6 +20,8 @@ struct Quad {\n     d: u32\n }\n \n+/// Calculates the md4 hash of the given slice of bytes, returning the 128-bit\n+/// result as a quad of u32's\n pub fn md4(msg: &[u8]) -> Quad {\n     // subtle: if orig_len is merely uint, then the code below\n     // which performs shifts by 32 bits or more has undefined\n@@ -56,9 +57,9 @@ pub fn md4(msg: &[u8]) -> Quad {\n     let e = msg.len();\n     let mut x = vec::from_elem(16u, 0u32);\n     while i < e {\n-        let aa = a, bb = b, cc = c, dd = d;\n+        let (aa, bb, cc, dd) = (a, b, c, d);\n \n-        let mut j = 0u, base = i;\n+        let mut (j, base) = (0u, i);\n         while j < 16u {\n             x[j] = (msg[base] as u32) + (msg[base + 1u] as u32 << 8u32) +\n                 (msg[base + 2u] as u32 << 16u32) +\n@@ -105,6 +106,8 @@ pub fn md4(msg: &[u8]) -> Quad {\n     return Quad {a: a, b: b, c: c, d: d};\n }\n \n+/// Calculates the md4 hash of a slice of bytes, returning the hex-encoded\n+/// version of the hash\n pub fn md4_str(msg: &[u8]) -> ~str {\n     let Quad {a, b, c, d} = md4(msg);\n     fn app(a: u32, b: u32, c: u32, d: u32, f: &fn(u32)) {\n@@ -123,7 +126,9 @@ pub fn md4_str(msg: &[u8]) -> ~str {\n     result\n }\n \n-pub fn md4_text(msg: &str) -> ~str { md4_str(str::to_bytes(msg)) }\n+/// Calculates the md4 hash of a string, returning the hex-encoded version of\n+/// the hash\n+pub fn md4_text(msg: &str) -> ~str { md4_str(msg.as_bytes()) }\n \n #[test]\n fn test_md4() {"}, {"sha": "518a9d8685a5b22dadb5929edf828a0f92833da8", "filename": "src/libextra/net_ip.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_ip.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -10,6 +10,8 @@\n \n //! Types/fns concerning Internet Protocol (IP), versions 4 & 6\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n use core::libc;\n@@ -156,9 +158,7 @@ pub mod v4 {\n \n     use core::cast::transmute;\n     use core::result;\n-    use core::str;\n     use core::uint;\n-    use core::vec;\n \n     /**\n      * Convert a str to `ip_addr`\n@@ -197,14 +197,12 @@ pub mod v4 {\n         }\n     }\n     pub fn parse_to_ipv4_rep(ip: &str) -> result::Result<Ipv4Rep, ~str> {\n-        let mut parts = ~[];\n-        for str::each_split_char(ip, '.') |s| { parts.push(s.to_owned()) }\n-        let parts = vec::map(parts, |s| {\n-            match uint::from_str(*s) {\n-              Some(n) if n <= 255 => n,\n-              _ => 256\n+        let parts: ~[uint] = ip.split_iter('.').transform(|s| {\n+            match uint::from_str(s) {\n+                Some(n) if n <= 255 => n,\n+                _ => 256\n             }\n-        });\n+        }).collect();\n         if parts.len() != 4 {\n             Err(fmt!(\"'%s' doesn't have 4 parts\", ip))\n         } else if parts.contains(&256) {\n@@ -228,7 +226,7 @@ pub mod v4 {\n             let input_is_inaddr_none =\n                 result::get(&ip_rep_result).as_u32() == INADDR_NONE;\n \n-            let new_addr = uv_ip4_addr(str::to_owned(ip), 22);\n+            let new_addr = uv_ip4_addr(ip, 22);\n             let reformatted_name = uv_ip4_name(&new_addr);\n             debug!(\"try_parse_addr: input ip: %s reparsed ip: %s\",\n                             ip, reformatted_name);\n@@ -257,7 +255,6 @@ pub mod v6 {\n     use uv_ip6_name = uv::ll::ip6_name;\n \n     use core::result;\n-    use core::str;\n \n     /**\n      * Convert a str to `ip_addr`\n@@ -277,13 +274,13 @@ pub mod v6 {\n     pub fn parse_addr(ip: &str) -> IpAddr {\n         match try_parse_addr(ip) {\n           result::Ok(addr) => addr,\n-          result::Err(copy err_data) => fail!(copy err_data.err_msg)\n+          result::Err(err_data) => fail!(copy err_data.err_msg)\n         }\n     }\n     pub fn try_parse_addr(ip: &str) -> result::Result<IpAddr,ParseAddrErr> {\n         unsafe {\n             // need to figure out how to establish a parse failure..\n-            let new_addr = uv_ip6_addr(str::to_owned(ip), 22);\n+            let new_addr = uv_ip6_addr(ip, 22);\n             let reparsed_name = uv_ip6_name(&new_addr);\n             debug!(\"v6::try_parse_addr ip: '%s' reparsed '%s'\",\n                             ip, reparsed_name);"}, {"sha": "d95807f2b91c49f9aa523d32b111977748ee6c09", "filename": "src/libextra/net_tcp.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_tcp.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -11,6 +11,8 @@\n //! High-level interface to libuv's TCP functionality\n // FIXME #4425: Need FFI fixes\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n use future;\n@@ -593,7 +595,7 @@ pub fn accept(new_conn: TcpNewConnection)\n                 }\n                 // UNSAFE LIBUV INTERACTION END\n                 match result_po.recv() {\n-                    Some(copy err_data) => result::Err(err_data),\n+                    Some(err_data) => result::Err(err_data),\n                     None => result::Ok(TcpSocket(client_socket_data))\n                 }\n             }\n@@ -824,7 +826,7 @@ pub fn socket_buf(sock: TcpSocket) -> TcpSocketBuf {\n }\n \n /// Convenience methods extending `net::tcp::TcpSocket`\n-pub impl TcpSocket {\n+impl TcpSocket {\n     pub fn read_start(&self) -> result::Result<@Port<\n         result::Result<~[u8], TcpErrData>>, TcpErrData> {\n         read_start(self)\n@@ -833,11 +835,11 @@ pub impl TcpSocket {\n         result::Result<(), TcpErrData> {\n         read_stop(self)\n     }\n-    fn read(&self, timeout_msecs: uint) ->\n+    pub fn read(&self, timeout_msecs: uint) ->\n         result::Result<~[u8], TcpErrData> {\n         read(self, timeout_msecs)\n     }\n-    fn read_future(&self, timeout_msecs: uint) ->\n+    pub fn read_future(&self, timeout_msecs: uint) ->\n         future::Future<result::Result<~[u8], TcpErrData>> {\n         read_future(self, timeout_msecs)\n     }\n@@ -1451,6 +1453,10 @@ mod test {\n \n     use core::cell::Cell;\n     use core::comm::{stream, SharedChan};\n+    use core::io;\n+    use core::result;\n+    use core::str;\n+    use core::task;\n \n     // FIXME don't run on fbsd or linux 32 bit (#2064)\n     #[cfg(target_os=\"win32\")]\n@@ -1591,8 +1597,8 @@ mod test {\n                        expected_req, actual_req);\n         debug!(\"RESP: expected: '%s' actual: '%s'\",\n                        expected_resp, actual_resp);\n-        assert!(str::contains(actual_req, expected_req));\n-        assert!(str::contains(actual_resp, expected_resp));\n+        assert!(actual_req.contains(expected_req));\n+        assert!(actual_resp.contains(expected_resp));\n     }\n     pub fn impl_gl_tcp_ipv4_get_peer_addr() {\n         let hl_loop = &uv::global_loop::get();\n@@ -1630,7 +1636,7 @@ mod test {\n         assert_eq!(net::ip::get_port(&sock.get_peer_addr()), 8887);\n \n         // Fulfill the protocol the test server expects\n-        let resp_bytes = str::to_bytes(\"ping\");\n+        let resp_bytes = \"ping\".as_bytes().to_owned();\n         tcp_write_single(&sock, resp_bytes);\n         debug!(\"message sent\");\n         sock.read(0u);\n@@ -1750,17 +1756,15 @@ mod test {\n         buf_write(sock_buf, expected_req);\n \n         // so contrived!\n-        let actual_resp = do str::as_bytes(&expected_resp.to_str()) |resp_buf| {\n-            buf_read(sock_buf, resp_buf.len())\n-        };\n+        let actual_resp = buf_read(sock_buf, expected_resp.as_bytes().len());\n \n         let actual_req = server_result_po.recv();\n         debug!(\"REQ: expected: '%s' actual: '%s'\",\n                        expected_req, actual_req);\n         debug!(\"RESP: expected: '%s' actual: '%s'\",\n                        expected_resp, actual_resp);\n-        assert!(str::contains(actual_req, expected_req));\n-        assert!(str::contains(actual_resp, expected_resp));\n+        assert!(actual_req.contains(expected_req));\n+        assert!(actual_resp.contains(expected_resp));\n     }\n \n     pub fn impl_tcp_socket_impl_reader_handles_eof() {\n@@ -1803,12 +1807,11 @@ mod test {\n     }\n \n     fn buf_write<W:io::Writer>(w: &W, val: &str) {\n-        debug!(\"BUF_WRITE: val len %?\", str::len(val));\n-        do str::byte_slice(val) |b_slice| {\n-            debug!(\"BUF_WRITE: b_slice len %?\",\n-                            b_slice.len());\n-            w.write(b_slice)\n-        }\n+        debug!(\"BUF_WRITE: val len %?\", val.len());\n+        let b_slice = val.as_bytes();\n+        debug!(\"BUF_WRITE: b_slice len %?\",\n+               b_slice.len());\n+        w.write(b_slice)\n     }\n \n     fn buf_read<R:io::Reader>(r: &R, len: uint) -> ~str {\n@@ -1824,7 +1827,7 @@ mod test {\n         let (server_po, server_ch) = stream::<~str>();\n         let server_ch = SharedChan::new(server_ch);\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n-        let resp_cell = Cell(resp);\n+        let resp_cell = Cell::new(resp);\n         let listen_result = listen(server_ip_addr, server_port, 128,\n                                    iotask,\n             // on_establish_cb -- called when listener is set up\n@@ -1836,7 +1839,7 @@ mod test {\n             // risky to run this on the loop, but some users\n             // will want the POWER\n             |new_conn, kill_ch| {\n-                let resp_cell2 = Cell(resp_cell.take());\n+                let resp_cell2 = Cell::new(resp_cell.take());\n                 debug!(\"SERVER: new connection!\");\n                 let (cont_po, cont_ch) = stream();\n                 let server_ch = server_ch.clone();\n@@ -1871,7 +1874,8 @@ mod test {\n                             server_ch.send(\n                                 str::from_bytes(data));\n                             debug!(\"SERVER: before write\");\n-                            tcp_write_single(&sock, str::to_bytes(resp_cell2.take()));\n+                            let s = resp_cell2.take();\n+                            tcp_write_single(&sock, s.as_bytes().to_owned());\n                             debug!(\"SERVER: after write.. die\");\n                             kill_ch.send(None);\n                           }\n@@ -1943,7 +1947,7 @@ mod test {\n         }\n         else {\n             let sock = result::unwrap(connect_result);\n-            let resp_bytes = str::to_bytes(resp);\n+            let resp_bytes = resp.as_bytes().to_owned();\n             tcp_write_single(&sock, resp_bytes);\n             let read_result = sock.read(0u);\n             if read_result.is_err() {"}, {"sha": "a0ce1669a448caf133acdbde3d7d8ac3ddb58e47", "filename": "src/libextra/net_url.rs", "status": "modified", "additions": 62, "deletions": 63, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_url.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -10,13 +10,14 @@\n \n //! Types/fns concerning URLs (see RFC 3986)\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n use core::cmp::Eq;\n use core::io::{Reader, ReaderUtil};\n use core::io;\n use core::hashmap::HashMap;\n-use core::str;\n use core::to_bytes;\n use core::uint;\n \n@@ -39,16 +40,15 @@ struct UserInfo {\n \n pub type Query = ~[(~str, ~str)];\n \n-pub impl Url {\n-    fn new(\n-        scheme: ~str,\n-        user: Option<UserInfo>,\n-        host: ~str,\n-        port: Option<~str>,\n-        path: ~str,\n-        query: Query,\n-        fragment: Option<~str>\n-    ) -> Url {\n+impl Url {\n+    pub fn new(scheme: ~str,\n+               user: Option<UserInfo>,\n+               host: ~str,\n+               port: Option<~str>,\n+               path: ~str,\n+               query: Query,\n+               fragment: Option<~str>)\n+               -> Url {\n         Url {\n             scheme: scheme,\n             user: user,\n@@ -61,8 +61,8 @@ pub impl Url {\n     }\n }\n \n-pub impl UserInfo {\n-    fn new(user: ~str, pass: Option<~str>) -> UserInfo {\n+impl UserInfo {\n+    pub fn new(user: ~str, pass: Option<~str>) -> UserInfo {\n         UserInfo { user: user, pass: pass }\n     }\n }\n@@ -79,7 +79,7 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n               'a' .. 'z' |\n               '0' .. '9' |\n               '-' | '.' | '_' | '~' => {\n-                str::push_char(&mut out, ch);\n+                out.push_char(ch);\n               }\n               _ => {\n                   if full_url {\n@@ -90,7 +90,7 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n                       // sub-delims:\n                       '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n                       '+' | ',' | ';' | '=' => {\n-                        str::push_char(&mut out, ch);\n+                        out.push_char(ch);\n                       }\n \n                       _ => out += fmt!(\"%%%X\", ch as uint)\n@@ -146,18 +146,18 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n                       // sub-delims:\n                       '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n                       '+' | ',' | ';' | '=' => {\n-                        str::push_char(&mut out, '%');\n-                        str::push_char(&mut out, bytes[0u] as char);\n-                        str::push_char(&mut out, bytes[1u] as char);\n+                        out.push_char('%');\n+                        out.push_char(bytes[0u] as char);\n+                        out.push_char(bytes[1u] as char);\n                       }\n \n-                      ch => str::push_char(&mut out, ch)\n+                      ch => out.push_char(ch)\n                     }\n                 } else {\n-                      str::push_char(&mut out, ch);\n+                      out.push_char(ch);\n                 }\n               }\n-              ch => str::push_char(&mut out, ch)\n+              ch => out.push_char(ch)\n             }\n         }\n \n@@ -189,9 +189,9 @@ fn encode_plus(s: &str) -> ~str {\n             let ch = rdr.read_byte() as char;\n             match ch {\n               'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '_' | '.' | '-' => {\n-                str::push_char(&mut out, ch);\n+                out.push_char(ch);\n               }\n-              ' ' => str::push_char(&mut out, '+'),\n+              ' ' => out.push_char('+'),\n               _ => out += fmt!(\"%%%X\", ch as uint)\n             }\n         }\n@@ -214,7 +214,7 @@ pub fn encode_form_urlencoded(m: &HashMap<~str, ~[~str]>) -> ~str {\n             if first {\n                 first = false;\n             } else {\n-                str::push_char(&mut out, '&');\n+                out.push_char('&');\n                 first = false;\n             }\n \n@@ -265,9 +265,9 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, ~[~str]> {\n                     };\n \n                     if parsing_key {\n-                        str::push_char(&mut key, ch)\n+                        key.push_char(ch)\n                     } else {\n-                        str::push_char(&mut value, ch)\n+                        value.push_char(ch)\n                     }\n                 }\n             }\n@@ -289,7 +289,7 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, ~[~str]> {\n \n \n fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n-    let len = str::len(s);\n+    let len = s.len();\n     let mut index = len;\n     let mut mat = 0;\n     do io::with_str_reader(s) |rdr| {\n@@ -305,16 +305,16 @@ fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n         }\n     }\n     if index+mat == len {\n-        return (str::slice(s, 0, index).to_owned(), ~\"\");\n+        return (s.slice(0, index).to_owned(), ~\"\");\n     } else {\n-        return (str::slice(s, 0, index).to_owned(),\n-             str::slice(s, index + mat, str::len(s)).to_owned());\n+        return (s.slice(0, index).to_owned(),\n+             s.slice(index + mat, s.len()).to_owned());\n     }\n }\n \n fn userinfo_from_str(uinfo: &str) -> UserInfo {\n     let (user, p) = split_char_first(uinfo, ':');\n-    let pass = if str::len(p) == 0 {\n+    let pass = if p.is_empty() {\n         None\n     } else {\n         Some(p)\n@@ -331,8 +331,8 @@ fn userinfo_to_str(userinfo: &UserInfo) -> ~str {\n \n fn query_from_str(rawquery: &str) -> Query {\n     let mut query: Query = ~[];\n-    if str::len(rawquery) != 0 {\n-        for str::each_split_char(rawquery, '&') |p| {\n+    if !rawquery.is_empty() {\n+        for rawquery.split_iter('&').advance |p| {\n             let (k, v) = split_char_first(p, '=');\n             query.push((decode_component(k), decode_component(v)));\n         };\n@@ -352,12 +352,12 @@ pub fn query_to_str(query: &Query) -> ~str {\n             }\n         }\n     }\n-    return str::connect(strvec, \"&\");\n+    return strvec.connect(\"&\");\n }\n \n // returns the scheme and the rest of the url, or a parsing error\n pub fn get_scheme(rawurl: &str) -> Result<(~str, ~str), ~str> {\n-    for str::each_chari(rawurl) |i,c| {\n+    for rawurl.iter().enumerate().advance |(i,c)| {\n         match c {\n           'A' .. 'Z' | 'a' .. 'z' => loop,\n           '0' .. '9' | '+' | '-' | '.' => {\n@@ -371,7 +371,7 @@ pub fn get_scheme(rawurl: &str) -> Result<(~str, ~str), ~str> {\n                 return Err(~\"url: Scheme cannot be empty.\");\n             } else {\n                 return Ok((rawurl.slice(0,i).to_owned(),\n-                                rawurl.slice(i+1,str::len(rawurl)).to_owned()));\n+                                rawurl.slice(i+1,rawurl.len()).to_owned()));\n             }\n           }\n           _ => {\n@@ -392,7 +392,7 @@ enum Input {\n // returns userinfo, host, port, and unparsed part, or an error\n fn get_authority(rawurl: &str) ->\n     Result<(Option<UserInfo>, ~str, Option<~str>, ~str), ~str> {\n-    if !str::starts_with(rawurl, \"//\") {\n+    if !rawurl.starts_with(\"//\") {\n         // there is no authority.\n         return Ok((None, ~\"\", None, rawurl.to_str()));\n     }\n@@ -415,9 +415,9 @@ fn get_authority(rawurl: &str) ->\n     let mut port = None;\n \n     let mut colon_count = 0;\n-    let mut pos = 0, begin = 2, end = len;\n+    let mut (pos, begin, end) = (0, 2, len);\n \n-    for str::each_chari(rawurl) |i,c| {\n+    for rawurl.iter().enumerate().advance |(i,c)| {\n         if i < 2 { loop; } // ignore the leading //\n \n         // deal with input class first\n@@ -473,7 +473,7 @@ fn get_authority(rawurl: &str) ->\n               }\n               Ip6Host => {\n                 if colon_count > 7 {\n-                    host = str::slice(rawurl, begin, i).to_owned();\n+                    host = rawurl.slice(begin, i).to_owned();\n                     pos = i;\n                     st = InPort;\n                 }\n@@ -490,13 +490,13 @@ fn get_authority(rawurl: &str) ->\n             colon_count = 0; // reset count\n             match st {\n               Start => {\n-                let user = str::slice(rawurl, begin, i).to_owned();\n+                let user = rawurl.slice(begin, i).to_owned();\n                 userinfo = Some(UserInfo::new(user, None));\n                 st = InHost;\n               }\n               PassHostPort => {\n-                let user = str::slice(rawurl, begin, pos).to_owned();\n-                let pass = str::slice(rawurl, pos+1, i).to_owned();\n+                let user = rawurl.slice(begin, pos).to_owned();\n+                let pass = rawurl.slice(pos+1, i).to_owned();\n                 userinfo = Some(UserInfo::new(user, Some(pass)));\n                 st = InHost;\n               }\n@@ -527,41 +527,41 @@ fn get_authority(rawurl: &str) ->\n     match st {\n       Start => {\n         if host_is_end_plus_one() {\n-            host = str::slice(rawurl, begin, end+1).to_owned();\n+            host = rawurl.slice(begin, end+1).to_owned();\n         } else {\n-            host = str::slice(rawurl, begin, end).to_owned();\n+            host = rawurl.slice(begin, end).to_owned();\n         }\n       }\n       PassHostPort | Ip6Port => {\n         if in != Digit {\n             return Err(~\"Non-digit characters in port.\");\n         }\n-        host = str::slice(rawurl, begin, pos).to_owned();\n-        port = Some(str::slice(rawurl, pos+1, end).to_owned());\n+        host = rawurl.slice(begin, pos).to_owned();\n+        port = Some(rawurl.slice(pos+1, end).to_owned());\n       }\n       Ip6Host | InHost => {\n-        host = str::slice(rawurl, begin, end).to_owned();\n+        host = rawurl.slice(begin, end).to_owned();\n       }\n       InPort => {\n         if in != Digit {\n             return Err(~\"Non-digit characters in port.\");\n         }\n-        port = Some(str::slice(rawurl, pos+1, end).to_owned());\n+        port = Some(rawurl.slice(pos+1, end).to_owned());\n       }\n     }\n \n     let rest = if host_is_end_plus_one() { ~\"\" }\n-    else { str::slice(rawurl, end, len).to_owned() };\n+    else { rawurl.slice(end, len).to_owned() };\n     return Ok((userinfo, host, port, rest));\n }\n \n \n // returns the path and unparsed part of url, or an error\n fn get_path(rawurl: &str, authority: bool) ->\n     Result<(~str, ~str), ~str> {\n-    let len = str::len(rawurl);\n+    let len = rawurl.len();\n     let mut end = len;\n-    for str::each_chari(rawurl) |i,c| {\n+    for rawurl.iter().enumerate().advance |(i,c)| {\n         match c {\n           'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '&' |'\\'' | '(' | ')' | '.'\n           | '@' | ':' | '%' | '/' | '+' | '!' | '*' | ',' | ';' | '='\n@@ -577,32 +577,31 @@ fn get_path(rawurl: &str, authority: bool) ->\n     }\n \n     if authority {\n-        if end != 0 && !str::starts_with(rawurl, \"/\") {\n+        if end != 0 && !rawurl.starts_with(\"/\") {\n             return Err(~\"Non-empty path must begin with\\\n                                '/' in presence of authority.\");\n         }\n     }\n \n-    return Ok((decode_component(str::slice(rawurl, 0, end).to_owned()),\n-                    str::slice(rawurl, end, len).to_owned()));\n+    return Ok((decode_component(rawurl.slice(0, end)),\n+                    rawurl.slice(end, len).to_owned()));\n }\n \n // returns the parsed query and the fragment, if present\n fn get_query_fragment(rawurl: &str) ->\n     Result<(Query, Option<~str>), ~str> {\n-    if !str::starts_with(rawurl, \"?\") {\n-        if str::starts_with(rawurl, \"#\") {\n-            let f = decode_component(str::slice(rawurl,\n+    if !rawurl.starts_with(\"?\") {\n+        if rawurl.starts_with(\"#\") {\n+            let f = decode_component(rawurl.slice(\n                                                 1,\n-                                                str::len(rawurl)).to_owned());\n+                                                rawurl.len()));\n             return Ok((~[], Some(f)));\n         } else {\n             return Ok((~[], None));\n         }\n     }\n-    let (q, r) = split_char_first(str::slice(rawurl, 1,\n-                                             str::len(rawurl)).to_owned(), '#');\n-    let f = if str::len(r) != 0 {\n+    let (q, r) = split_char_first(rawurl.slice(1, rawurl.len()), '#');\n+    let f = if r.len() != 0 {\n         Some(decode_component(r)) } else { None };\n     return Ok((query_from_str(q), f));\n }\n@@ -1060,7 +1059,7 @@ mod tests {\n         /*\n         assert_eq!(decode_form_urlencoded([]).len(), 0);\n \n-        let s = str::to_bytes(\"a=1&foo+bar=abc&foo+bar=12+%3D+34\");\n+        let s = \"a=1&foo+bar=abc&foo+bar=12+%3D+34\".as_bytes();\n         let form = decode_form_urlencoded(s);\n         assert_eq!(form.len(), 2);\n         assert_eq!(form.get_ref(&~\"a\"), &~[~\"1\"]);"}, {"sha": "14156e8b901bdd7d5c0e618c4fd32f5d1d9ed2ab", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 145, "deletions": 134, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -16,10 +16,15 @@ A BigUint is represented as an array of BigDigits.\n A BigInt is a combination of BigUint and Sign.\n */\n \n-use core::prelude::*;\n+#[allow(missing_doc)];\n \n+use core::prelude::*;\n use core::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n+use core::int;\n use core::num::{IntConvertible, Zero, One, ToStrRadix, FromStrRadix, Orderable};\n+use core::str;\n+use core::uint;\n+use core::vec;\n \n /**\n A BigDigit is a BigUint's composing element.\n@@ -54,19 +59,19 @@ pub mod BigDigit {\n     priv static hi_mask: uint = (-1 as uint) << bits;\n     priv static lo_mask: uint = (-1 as uint) >> bits;\n \n-    #[inline(always)]\n+\n     priv fn get_hi(n: uint) -> BigDigit { (n >> bits) as BigDigit }\n-    #[inline(always)]\n+\n     priv fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }\n \n     /// Split one machine sized unsigned integer into two BigDigits.\n-    #[inline(always)]\n+\n     pub fn from_uint(n: uint) -> (BigDigit, BigDigit) {\n         (get_hi(n), get_lo(n))\n     }\n \n     /// Join two BigDigits into one machine sized unsigned integer\n-    #[inline(always)]\n+\n     pub fn to_uint(hi: BigDigit, lo: BigDigit) -> uint {\n         (lo as uint) | ((hi as uint) << bits)\n     }\n@@ -84,63 +89,60 @@ pub struct BigUint {\n }\n \n impl Eq for BigUint {\n-    #[inline(always)]\n+\n     fn eq(&self, other: &BigUint) -> bool { self.equals(other) }\n-    #[inline(always)]\n+\n     fn ne(&self, other: &BigUint) -> bool { !self.equals(other) }\n }\n \n impl TotalEq for BigUint {\n-    #[inline(always)]\n+\n     fn equals(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Equal => true, _ => false }\n     }\n }\n \n impl Ord for BigUint {\n-    #[inline(always)]\n+\n     fn lt(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Less => true, _ => false}\n     }\n-    #[inline(always)]\n+\n     fn le(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Less | Equal => true, _ => false }\n     }\n-    #[inline(always)]\n+\n     fn ge(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Greater | Equal => true, _ => false }\n     }\n-    #[inline(always)]\n+\n     fn gt(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Greater => true, _ => false }\n     }\n }\n \n impl TotalOrd for BigUint {\n-    #[inline(always)]\n+\n     fn cmp(&self, other: &BigUint) -> Ordering {\n-        let s_len = self.data.len(), o_len = other.data.len();\n+        let (s_len, o_len) = (self.data.len(), other.data.len());\n         if s_len < o_len { return Less; }\n         if s_len > o_len { return Greater;  }\n \n-        for self.data.eachi_reverse |i, elm| {\n-            match (*elm, other.data[i]) {\n-                (l, r) if l < r => return Less,\n-                (l, r) if l > r => return Greater,\n-                _               => loop\n-            };\n+        for self.data.rev_iter().zip(other.data.rev_iter()).advance |(&self_i, &other_i)| {\n+            cond!((self_i < other_i) { return Less; }\n+                  (self_i > other_i) { return Greater; })\n         }\n         return Equal;\n     }\n }\n \n impl ToStr for BigUint {\n-    #[inline(always)]\n+\n     fn to_str(&self) -> ~str { self.to_str_radix(10) }\n }\n \n impl FromStr for BigUint {\n-    #[inline(always)]\n+\n     fn from_str(s: &str) -> Option<BigUint> {\n         FromStrRadix::from_str_radix(s, 10)\n     }\n@@ -149,25 +151,25 @@ impl FromStr for BigUint {\n impl Num for BigUint {}\n \n impl Orderable for BigUint {\n-    #[inline(always)]\n+\n     fn min(&self, other: &BigUint) -> BigUint {\n         if self < other { self.clone() } else { other.clone() }\n     }\n \n-    #[inline(always)]\n+\n     fn max(&self, other: &BigUint) -> BigUint {\n         if self > other { self.clone() } else { other.clone() }\n     }\n \n-    #[inline(always)]\n+\n     fn clamp(&self, mn: &BigUint, mx: &BigUint) -> BigUint {\n         if self > mx { mx.clone() } else\n         if self < mn { mn.clone() } else { self.clone() }\n     }\n }\n \n impl Shl<uint, BigUint> for BigUint {\n-    #[inline(always)]\n+\n     fn shl(&self, rhs: &uint) -> BigUint {\n         let n_unit = *rhs / BigDigit::bits;\n         let n_bits = *rhs % BigDigit::bits;\n@@ -176,7 +178,7 @@ impl Shl<uint, BigUint> for BigUint {\n }\n \n impl Shr<uint, BigUint> for BigUint {\n-    #[inline(always)]\n+\n     fn shr(&self, rhs: &uint) -> BigUint {\n         let n_unit = *rhs / BigDigit::bits;\n         let n_bits = *rhs % BigDigit::bits;\n@@ -185,22 +187,22 @@ impl Shr<uint, BigUint> for BigUint {\n }\n \n impl Zero for BigUint {\n-    #[inline(always)]\n+\n     fn zero() -> BigUint { BigUint::new(~[]) }\n \n-    #[inline(always)]\n+\n     fn is_zero(&self) -> bool { self.data.is_empty() }\n }\n \n impl One for BigUint {\n-    #[inline(always)]\n+\n     fn one() -> BigUint { BigUint::new(~[1]) }\n }\n \n impl Unsigned for BigUint {}\n \n impl Add<BigUint, BigUint> for BigUint {\n-    #[inline(always)]\n+\n     fn add(&self, other: &BigUint) -> BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n \n@@ -220,7 +222,7 @@ impl Add<BigUint, BigUint> for BigUint {\n }\n \n impl Sub<BigUint, BigUint> for BigUint {\n-    #[inline(always)]\n+\n     fn sub(&self, other: &BigUint) -> BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n \n@@ -249,7 +251,7 @@ impl Mul<BigUint, BigUint> for BigUint {\n     fn mul(&self, other: &BigUint) -> BigUint {\n         if self.is_zero() || other.is_zero() { return Zero::zero(); }\n \n-        let s_len = self.data.len(), o_len = other.data.len();\n+        let (s_len, o_len) = (self.data.len(), other.data.len());\n         if s_len == 1 { return mul_digit(other, self.data[0]);  }\n         if o_len == 1 { return mul_digit(self,  other.data[0]); }\n \n@@ -276,7 +278,7 @@ impl Mul<BigUint, BigUint> for BigUint {\n \n         return ll + mm.shl_unit(half_len) + hh.shl_unit(half_len * 2);\n \n-        #[inline(always)]\n+\n         fn mul_digit(a: &BigUint, n: BigDigit) -> BigUint {\n             if n == 0 { return Zero::zero(); }\n             if n == 1 { return copy *a; }\n@@ -293,15 +295,15 @@ impl Mul<BigUint, BigUint> for BigUint {\n             return BigUint::new(prod + [carry]);\n         }\n \n-        #[inline(always)]\n+\n         fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n             let mid = uint::min(a.data.len(), n);\n             return (BigUint::from_slice(vec::slice(a.data, mid,\n                                                    a.data.len())),\n                     BigUint::from_slice(vec::slice(a.data, 0, mid)));\n         }\n \n-        #[inline(always)]\n+\n         fn sub_sign(a: BigUint, b: BigUint) -> (Ordering, BigUint) {\n             match a.cmp(&b) {\n                 Less    => (Less,    b - a),\n@@ -313,45 +315,45 @@ impl Mul<BigUint, BigUint> for BigUint {\n }\n \n impl Div<BigUint, BigUint> for BigUint {\n-    #[inline(always)]\n+\n     fn div(&self, other: &BigUint) -> BigUint {\n         let (q, _) = self.div_rem(other);\n         return q;\n     }\n }\n \n impl Rem<BigUint, BigUint> for BigUint {\n-    #[inline(always)]\n+\n     fn rem(&self, other: &BigUint) -> BigUint {\n         let (_, r) = self.div_rem(other);\n         return r;\n     }\n }\n \n impl Neg<BigUint> for BigUint {\n-    #[inline(always)]\n+\n     fn neg(&self) -> BigUint { fail!() }\n }\n \n impl Integer for BigUint {\n-    #[inline(always)]\n+\n     fn div_rem(&self, other: &BigUint) -> (BigUint, BigUint) {\n         self.div_mod_floor(other)\n     }\n \n-    #[inline(always)]\n+\n     fn div_floor(&self, other: &BigUint) -> BigUint {\n         let (d, _) = self.div_mod_floor(other);\n         return d;\n     }\n \n-    #[inline(always)]\n+\n     fn mod_floor(&self, other: &BigUint) -> BigUint {\n         let (_, m) = self.div_mod_floor(other);\n         return m;\n     }\n \n-    #[inline(always)]\n+\n     fn div_mod_floor(&self, other: &BigUint) -> (BigUint, BigUint) {\n         if other.is_zero() { fail!() }\n         if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n@@ -373,7 +375,7 @@ impl Integer for BigUint {\n         let (d, m) = div_mod_floor_inner(self << shift, other << shift);\n         return (d, m >> shift);\n \n-        #[inline(always)]\n+\n         fn div_mod_floor_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n             let mut m = a;\n             let mut d = Zero::zero::<BigUint>();\n@@ -404,7 +406,7 @@ impl Integer for BigUint {\n             return (d, m);\n         }\n \n-        #[inline(always)]\n+\n         fn div_estimate(a: &BigUint, b: &BigUint, n: uint)\n             -> (BigUint, BigUint, BigUint) {\n             if a.data.len() < n {\n@@ -415,7 +417,7 @@ impl Integer for BigUint {\n             let bn = *b.data.last();\n             let mut d = ~[];\n             let mut carry = 0;\n-            for an.each_reverse |elt| {\n+            for an.rev_iter().advance |elt| {\n                 let ai = BigDigit::to_uint(carry, *elt);\n                 let di = ai / (bn as uint);\n                 assert!(di < BigDigit::base);\n@@ -438,10 +440,10 @@ impl Integer for BigUint {\n      *\n      * The result is always positive\n      */\n-    #[inline(always)]\n+\n     fn gcd(&self, other: &BigUint) -> BigUint {\n         // Use Euclid's algorithm\n-        let mut m = copy *self, n = copy *other;\n+        let mut (m, n) = (copy *self, copy *other);\n         while !m.is_zero() {\n             let temp = m;\n             m = n % temp;\n@@ -453,15 +455,15 @@ impl Integer for BigUint {\n     /**\n      * Calculates the Lowest Common Multiple (LCM) of the number and `other`\n      */\n-    #[inline(always)]\n+\n     fn lcm(&self, other: &BigUint) -> BigUint { ((*self * *other) / self.gcd(other)) }\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n-    #[inline(always)]\n+\n     fn is_multiple_of(&self, other: &BigUint) -> bool { (*self % *other).is_zero() }\n \n     /// Returns `true` if the number is divisible by `2`\n-    #[inline(always)]\n+\n     fn is_even(&self) -> bool {\n         // Considering only the last digit.\n         if self.data.is_empty() {\n@@ -472,24 +474,24 @@ impl Integer for BigUint {\n     }\n \n     /// Returns `true` if the number is not divisible by `2`\n-    #[inline(always)]\n+\n     fn is_odd(&self) -> bool { !self.is_even() }\n }\n \n impl IntConvertible for BigUint {\n-    #[inline(always)]\n+\n     fn to_int(&self) -> int {\n         uint::min(self.to_uint(), int::max_value as uint) as int\n     }\n \n-    #[inline(always)]\n+\n     fn from_int(n: int) -> BigUint {\n         if (n < 0) { Zero::zero() } else { BigUint::from_uint(n as uint) }\n     }\n }\n \n impl ToStrRadix for BigUint {\n-    #[inline(always)]\n+\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         assert!(1 < radix && radix <= 16);\n         let (base, max_len) = get_radix_base(radix);\n@@ -498,7 +500,7 @@ impl ToStrRadix for BigUint {\n         }\n         return fill_concat(convert_base(copy *self, base), radix, max_len);\n \n-        #[inline(always)]\n+\n         fn convert_base(n: BigUint, base: uint) -> ~[BigDigit] {\n             let divider    = BigUint::from_uint(base);\n             let mut result = ~[];\n@@ -514,30 +516,30 @@ impl ToStrRadix for BigUint {\n             return result;\n         }\n \n-        #[inline(always)]\n+\n         fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n             if v.is_empty() { return ~\"0\" }\n-            let s = str::concat(vec::reversed(v).map(|n| {\n+            let s = vec::reversed(v).map(|n| {\n                 let s = uint::to_str_radix(*n as uint, radix);\n                 str::from_chars(vec::from_elem(l - s.len(), '0')) + s\n-            }));\n-            str::trim_left_chars(s, ['0']).to_owned()\n+            }).concat();\n+            s.trim_left_chars(&'0').to_owned()\n         }\n     }\n }\n \n impl FromStrRadix for BigUint {\n     /// Creates and initializes an BigUint.\n-    #[inline(always)]\n+\n     pub fn from_str_radix(s: &str, radix: uint)\n         -> Option<BigUint> {\n-        BigUint::parse_bytes(str::to_bytes(s), radix)\n+        BigUint::parse_bytes(s.as_bytes(), radix)\n     }\n }\n \n impl BigUint {\n     /// Creates and initializes an BigUint.\n-    #[inline(always)]\n+\n     pub fn new(v: ~[BigDigit]) -> BigUint {\n         // omit trailing zeros\n         let new_len = v.rposition(|n| *n != 0).map_default(0, |p| *p + 1);\n@@ -549,7 +551,7 @@ impl BigUint {\n     }\n \n     /// Creates and initializes an BigUint.\n-    #[inline(always)]\n+\n     pub fn from_uint(n: uint) -> BigUint {\n         match BigDigit::from_uint(n) {\n             (0,  0)  => Zero::zero(),\n@@ -559,13 +561,13 @@ impl BigUint {\n     }\n \n     /// Creates and initializes an BigUint.\n-    #[inline(always)]\n+\n     pub fn from_slice(slice: &[BigDigit]) -> BigUint {\n         return BigUint::new(vec::to_owned(slice));\n     }\n \n     /// Creates and initializes an BigUint.\n-    #[inline(always)]\n+\n     pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigUint> {\n         let (base, unit_len) = get_radix_base(radix);\n@@ -592,7 +594,9 @@ impl BigUint {\n         }\n     }\n \n-    #[inline(always)]\n+\n+    /// Converts this big integer into a uint, returning the uint::max_value if\n+    /// it's too large to fit in a uint.\n     pub fn to_uint(&self) -> uint {\n         match self.data.len() {\n             0 => 0,\n@@ -602,14 +606,14 @@ impl BigUint {\n         }\n     }\n \n-    #[inline(always)]\n+\n     priv fn shl_unit(&self, n_unit: uint) -> BigUint {\n         if n_unit == 0 || self.is_zero() { return copy *self; }\n \n         return BigUint::new(vec::from_elem(n_unit, 0) + self.data);\n     }\n \n-    #[inline(always)]\n+\n     priv fn shl_bits(&self, n_bits: uint) -> BigUint {\n         if n_bits == 0 || self.is_zero() { return copy *self; }\n \n@@ -625,7 +629,7 @@ impl BigUint {\n         return BigUint::new(shifted + [carry]);\n     }\n \n-    #[inline(always)]\n+\n     priv fn shr_unit(&self, n_unit: uint) -> BigUint {\n         if n_unit == 0 { return copy *self; }\n         if self.data.len() < n_unit { return Zero::zero(); }\n@@ -634,13 +638,13 @@ impl BigUint {\n         );\n     }\n \n-    #[inline(always)]\n+\n     priv fn shr_bits(&self, n_bits: uint) -> BigUint {\n         if n_bits == 0 || self.data.is_empty() { return copy *self; }\n \n         let mut borrow = 0;\n         let mut shifted = ~[];\n-        for self.data.each_reverse |elem| {\n+        for self.data.rev_iter().advance |elem| {\n             shifted = ~[(*elem >> n_bits) | borrow] + shifted;\n             borrow = *elem << (BigDigit::bits - n_bits);\n         }\n@@ -649,7 +653,7 @@ impl BigUint {\n }\n \n #[cfg(target_arch = \"x86_64\")]\n-#[inline(always)]\n+\n priv fn get_radix_base(radix: uint) -> (uint, uint) {\n     assert!(1 < radix && radix <= 16);\n     match radix {\n@@ -675,7 +679,7 @@ priv fn get_radix_base(radix: uint) -> (uint, uint) {\n #[cfg(target_arch = \"arm\")]\n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"mips\")]\n-#[inline(always)]\n+\n priv fn get_radix_base(radix: uint) -> (uint, uint) {\n     assert!(1 < radix && radix <= 16);\n     match radix {\n@@ -703,26 +707,26 @@ priv fn get_radix_base(radix: uint) -> (uint, uint) {\n pub enum Sign { Minus, Zero, Plus }\n \n impl Ord for Sign {\n-    #[inline(always)]\n+\n     fn lt(&self, other: &Sign) -> bool {\n         match self.cmp(other) { Less => true, _ => false}\n     }\n-    #[inline(always)]\n+\n     fn le(&self, other: &Sign) -> bool {\n         match self.cmp(other) { Less | Equal => true, _ => false }\n     }\n-    #[inline(always)]\n+\n     fn ge(&self, other: &Sign) -> bool {\n         match self.cmp(other) { Greater | Equal => true, _ => false }\n     }\n-    #[inline(always)]\n+\n     fn gt(&self, other: &Sign) -> bool {\n         match self.cmp(other) { Greater => true, _ => false }\n     }\n }\n \n impl TotalOrd for Sign {\n-    #[inline(always)]\n+\n     fn cmp(&self, other: &Sign) -> Ordering {\n         match (*self, *other) {\n           (Minus, Minus) | (Zero,  Zero) | (Plus, Plus) => Equal,\n@@ -734,7 +738,7 @@ impl TotalOrd for Sign {\n \n impl Neg<Sign> for Sign {\n     /// Negate Sign value.\n-    #[inline(always)]\n+\n     fn neg(&self) -> Sign {\n         match *self {\n           Minus => Plus,\n@@ -752,40 +756,40 @@ pub struct BigInt {\n }\n \n impl Eq for BigInt {\n-    #[inline(always)]\n+\n     fn eq(&self, other: &BigInt) -> bool { self.equals(other) }\n-    #[inline(always)]\n+\n     fn ne(&self, other: &BigInt) -> bool { !self.equals(other) }\n }\n \n impl TotalEq for BigInt {\n-    #[inline(always)]\n+\n     fn equals(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Equal => true, _ => false }\n     }\n }\n \n impl Ord for BigInt {\n-    #[inline(always)]\n+\n     fn lt(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Less => true, _ => false}\n     }\n-    #[inline(always)]\n+\n     fn le(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Less | Equal => true, _ => false }\n     }\n-    #[inline(always)]\n+\n     fn ge(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Greater | Equal => true, _ => false }\n     }\n-    #[inline(always)]\n+\n     fn gt(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Greater => true, _ => false }\n     }\n }\n \n impl TotalOrd for BigInt {\n-    #[inline(always)]\n+\n     fn cmp(&self, other: &BigInt) -> Ordering {\n         let scmp = self.sign.cmp(&other.sign);\n         if scmp != Equal { return scmp; }\n@@ -799,12 +803,12 @@ impl TotalOrd for BigInt {\n }\n \n impl ToStr for BigInt {\n-    #[inline(always)]\n+\n     fn to_str(&self) -> ~str { self.to_str_radix(10) }\n }\n \n impl FromStr for BigInt {\n-    #[inline(always)]\n+\n     fn from_str(s: &str) -> Option<BigInt> {\n         FromStrRadix::from_str_radix(s, 10)\n     }\n@@ -813,69 +817,69 @@ impl FromStr for BigInt {\n impl Num for BigInt {}\n \n impl Orderable for BigInt {\n-    #[inline(always)]\n+\n     fn min(&self, other: &BigInt) -> BigInt {\n         if self < other { self.clone() } else { other.clone() }\n     }\n \n-    #[inline(always)]\n+\n     fn max(&self, other: &BigInt) -> BigInt {\n         if self > other { self.clone() } else { other.clone() }\n     }\n \n-    #[inline(always)]\n+\n     fn clamp(&self, mn: &BigInt, mx: &BigInt) -> BigInt {\n         if self > mx { mx.clone() } else\n         if self < mn { mn.clone() } else { self.clone() }\n     }\n }\n \n impl Shl<uint, BigInt> for BigInt {\n-    #[inline(always)]\n+\n     fn shl(&self, rhs: &uint) -> BigInt {\n         BigInt::from_biguint(self.sign, self.data << *rhs)\n     }\n }\n \n impl Shr<uint, BigInt> for BigInt {\n-    #[inline(always)]\n+\n     fn shr(&self, rhs: &uint) -> BigInt {\n         BigInt::from_biguint(self.sign, self.data >> *rhs)\n     }\n }\n \n impl Zero for BigInt {\n-    #[inline(always)]\n+\n     fn zero() -> BigInt {\n         BigInt::from_biguint(Zero, Zero::zero())\n     }\n \n-    #[inline(always)]\n+\n     fn is_zero(&self) -> bool { self.sign == Zero }\n }\n \n impl One for BigInt {\n-    #[inline(always)]\n+\n     fn one() -> BigInt {\n         BigInt::from_biguint(Plus, One::one())\n     }\n }\n \n impl Signed for BigInt {\n-    #[inline(always)]\n+\n     fn abs(&self) -> BigInt {\n         match self.sign {\n             Plus | Zero => self.clone(),\n             Minus => BigInt::from_biguint(Plus, self.data.clone())\n         }\n     }\n \n-    #[inline(always)]\n+\n     fn abs_sub(&self, other: &BigInt) -> BigInt {\n         if *self <= *other { Zero::zero() } else { *self - *other }\n     }\n \n-    #[inline(always)]\n+\n     fn signum(&self) -> BigInt {\n         match self.sign {\n             Plus  => BigInt::from_biguint(Plus, One::one()),\n@@ -884,15 +888,15 @@ impl Signed for BigInt {\n         }\n     }\n \n-    #[inline(always)]\n+\n     fn is_positive(&self) -> bool { self.sign == Plus }\n \n-    #[inline(always)]\n+\n     fn is_negative(&self) -> bool { self.sign == Minus }\n }\n \n impl Add<BigInt, BigInt> for BigInt {\n-    #[inline(always)]\n+\n     fn add(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)      => other.clone(),\n@@ -907,7 +911,7 @@ impl Add<BigInt, BigInt> for BigInt {\n }\n \n impl Sub<BigInt, BigInt> for BigInt {\n-    #[inline(always)]\n+\n     fn sub(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)    => -other,\n@@ -925,7 +929,7 @@ impl Sub<BigInt, BigInt> for BigInt {\n }\n \n impl Mul<BigInt, BigInt> for BigInt {\n-    #[inline(always)]\n+\n     fn mul(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)     | (_,     Zero)  => Zero::zero(),\n@@ -940,30 +944,30 @@ impl Mul<BigInt, BigInt> for BigInt {\n }\n \n impl Div<BigInt, BigInt> for BigInt {\n-    #[inline(always)]\n+\n     fn div(&self, other: &BigInt) -> BigInt {\n         let (q, _) = self.div_rem(other);\n         return q;\n     }\n }\n \n impl Rem<BigInt, BigInt> for BigInt {\n-    #[inline(always)]\n+\n     fn rem(&self, other: &BigInt) -> BigInt {\n         let (_, r) = self.div_rem(other);\n         return r;\n     }\n }\n \n impl Neg<BigInt> for BigInt {\n-    #[inline(always)]\n+\n     fn neg(&self) -> BigInt {\n         BigInt::from_biguint(self.sign.neg(), self.data.clone())\n     }\n }\n \n impl Integer for BigInt {\n-    #[inline(always)]\n+\n     fn div_rem(&self, other: &BigInt) -> (BigInt, BigInt) {\n         // r.sign == self.sign\n         let (d_ui, r_ui) = self.data.div_mod_floor(&other.data);\n@@ -978,24 +982,24 @@ impl Integer for BigInt {\n         }\n     }\n \n-    #[inline(always)]\n+\n     fn div_floor(&self, other: &BigInt) -> BigInt {\n         let (d, _) = self.div_mod_floor(other);\n         return d;\n     }\n \n-    #[inline(always)]\n+\n     fn mod_floor(&self, other: &BigInt) -> BigInt {\n         let (_, m) = self.div_mod_floor(other);\n         return m;\n     }\n \n-    #[inline(always)]\n+\n     fn div_mod_floor(&self, other: &BigInt) -> (BigInt, BigInt) {\n         // m.sign == other.sign\n         let (d_ui, m_ui) = self.data.div_rem(&other.data);\n-        let d = BigInt::from_biguint(Plus, d_ui),\n-            m = BigInt::from_biguint(Plus, m_ui);\n+        let d = BigInt::from_biguint(Plus, d_ui);\n+        let m = BigInt::from_biguint(Plus, m_ui);\n         match (self.sign, other.sign) {\n             (_,    Zero)   => fail!(),\n             (Plus, Plus)  | (Zero, Plus)  => (d, m),\n@@ -1018,34 +1022,34 @@ impl Integer for BigInt {\n      *\n      * The result is always positive\n      */\n-    #[inline(always)]\n+\n     fn gcd(&self, other: &BigInt) -> BigInt {\n         BigInt::from_biguint(Plus, self.data.gcd(&other.data))\n     }\n \n     /**\n      * Calculates the Lowest Common Multiple (LCM) of the number and `other`\n      */\n-    #[inline(always)]\n+\n     fn lcm(&self, other: &BigInt) -> BigInt {\n         BigInt::from_biguint(Plus, self.data.lcm(&other.data))\n     }\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n-    #[inline(always)]\n+\n     fn is_multiple_of(&self, other: &BigInt) -> bool { self.data.is_multiple_of(&other.data) }\n \n     /// Returns `true` if the number is divisible by `2`\n-    #[inline(always)]\n+\n     fn is_even(&self) -> bool { self.data.is_even() }\n \n     /// Returns `true` if the number is not divisible by `2`\n-    #[inline(always)]\n+\n     fn is_odd(&self) -> bool { self.data.is_odd() }\n }\n \n impl IntConvertible for BigInt {\n-    #[inline(always)]\n+\n     fn to_int(&self) -> int {\n         match self.sign {\n             Plus  => uint::min(self.to_uint(), int::max_value as uint) as int,\n@@ -1055,7 +1059,7 @@ impl IntConvertible for BigInt {\n         }\n     }\n \n-    #[inline(always)]\n+\n     fn from_int(n: int) -> BigInt {\n         if n > 0 {\n            return BigInt::from_biguint(Plus,  BigUint::from_uint(n as uint));\n@@ -1070,7 +1074,7 @@ impl IntConvertible for BigInt {\n }\n \n impl ToStrRadix for BigInt {\n-    #[inline(always)]\n+\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         match self.sign {\n             Plus  => self.data.to_str_radix(radix),\n@@ -1082,22 +1086,21 @@ impl ToStrRadix for BigInt {\n \n impl FromStrRadix for BigInt {\n     /// Creates and initializes an BigInt.\n-    #[inline(always)]\n+\n     fn from_str_radix(s: &str, radix: uint)\n         -> Option<BigInt> {\n-        BigInt::parse_bytes(str::to_bytes(s), radix)\n+        BigInt::parse_bytes(s.as_bytes(), radix)\n     }\n }\n \n-pub impl BigInt {\n+impl BigInt {\n     /// Creates and initializes an BigInt.\n-    #[inline(always)]\n     pub fn new(sign: Sign, v: ~[BigDigit]) -> BigInt {\n         BigInt::from_biguint(sign, BigUint::new(v))\n     }\n \n     /// Creates and initializes an BigInt.\n-    #[inline(always)]\n+\n     pub fn from_biguint(sign: Sign, data: BigUint) -> BigInt {\n         if sign == Zero || data.is_zero() {\n             return BigInt { sign: Zero, data: Zero::zero() };\n@@ -1106,20 +1109,20 @@ pub impl BigInt {\n     }\n \n     /// Creates and initializes an BigInt.\n-    #[inline(always)]\n+\n     pub fn from_uint(n: uint) -> BigInt {\n         if n == 0 { return Zero::zero(); }\n         return BigInt::from_biguint(Plus, BigUint::from_uint(n));\n     }\n \n     /// Creates and initializes an BigInt.\n-    #[inline(always)]\n+\n     pub fn from_slice(sign: Sign, slice: &[BigDigit]) -> BigInt {\n         BigInt::from_biguint(sign, BigUint::from_slice(slice))\n     }\n \n     /// Creates and initializes an BigInt.\n-    #[inline(always)]\n+\n     pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigInt> {\n         if buf.is_empty() { return None; }\n@@ -1133,8 +1136,7 @@ pub impl BigInt {\n             .map_consume(|bu| BigInt::from_biguint(sign, bu));\n     }\n \n-    #[inline(always)]\n-    fn to_uint(&self) -> uint {\n+    pub fn to_uint(&self) -> uint {\n         match self.sign {\n             Plus  => self.data.to_uint(),\n             Zero  => 0,\n@@ -1148,8 +1150,13 @@ mod biguint_tests {\n     use core::prelude::*;\n \n     use super::*;\n-    use core::num::{IntConvertible, Zero, One, FromStrRadix};\n+\n     use core::cmp::{Less, Equal, Greater};\n+    use core::int;\n+    use core::num::{IntConvertible, Zero, One, FromStrRadix};\n+    use core::str;\n+    use core::uint;\n+    use core::vec;\n \n     #[test]\n     fn test_from_slice() {\n@@ -1616,8 +1623,12 @@ mod bigint_tests {\n     use core::prelude::*;\n \n     use super::*;\n+\n     use core::cmp::{Less, Equal, Greater};\n+    use core::int;\n     use core::num::{IntConvertible, Zero, One, FromStrRadix};\n+    use core::uint;\n+    use core::vec;\n \n     #[test]\n     fn test_from_biguint() {"}, {"sha": "1bb364f3a1c3fee5762bddeb92655cd5d1f117c9", "filename": "src/libextra/num/complex.rs", "status": "modified", "additions": 65, "deletions": 14, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fcomplex.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -25,15 +25,17 @@ use core::num::{Zero,One,ToStrRadix};\n /// A complex number in Cartesian form.\n #[deriving(Eq,Clone)]\n pub struct Cmplx<T> {\n+    /// Real portion of the complex number\n     re: T,\n+    /// Imaginary portion of the complex number\n     im: T\n }\n \n pub type Complex = Cmplx<float>;\n pub type Complex32 = Cmplx<f32>;\n pub type Complex64 = Cmplx<f64>;\n \n-impl<T: Copy + Num> Cmplx<T> {\n+impl<T: Clone + Num> Cmplx<T> {\n     /// Create a new Cmplx\n     #[inline]\n     pub fn new(re: T, im: T) -> Cmplx<T> {\n@@ -53,7 +55,7 @@ impl<T: Copy + Num> Cmplx<T> {\n     /// Returns the complex conjugate. i.e. `re - i im`\n     #[inline]\n     pub fn conj(&self) -> Cmplx<T> {\n-        Cmplx::new(self.re, -self.im)\n+        Cmplx::new(self.re.clone(), -self.im)\n     }\n \n \n@@ -78,62 +80,91 @@ impl<T: Copy + Num> Cmplx<T> {\n     }\n }\n \n+#[cfg(not(stage0))] // Fixed by #4228\n+impl<T: Clone + Algebraic + Num> Cmplx<T> {\n+    /// Calculate |self|\n+    #[inline(always)]\n+    pub fn norm(&self) -> T {\n+        self.re.hypot(&self.im)\n+    }\n+}\n+\n+#[cfg(not(stage0))] // Fixed by #4228\n+impl<T: Clone + Trigonometric + Algebraic + Num> Cmplx<T> {\n+    /// Calculate the principal Arg of self.\n+    #[inline(always)]\n+    pub fn arg(&self) -> T {\n+        self.im.atan2(&self.re)\n+    }\n+    /// Convert to polar form (r, theta), such that `self = r * exp(i\n+    /// * theta)`\n+    #[inline]\n+    pub fn to_polar(&self) -> (T, T) {\n+        (self.norm(), self.arg())\n+    }\n+    /// Convert a polar representation into a complex number.\n+    #[inline]\n+    pub fn from_polar(r: &T, theta: &T) -> Cmplx<T> {\n+        Cmplx::new(r * theta.cos(), r * theta.sin())\n+    }\n+}\n+\n /* arithmetic */\n // (a + i b) + (c + i d) == (a + c) + i (b + d)\n-impl<T: Copy + Num> Add<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Clone + Num> Add<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n     #[inline]\n     fn add(&self, other: &Cmplx<T>) -> Cmplx<T> {\n         Cmplx::new(self.re + other.re, self.im + other.im)\n     }\n }\n // (a + i b) - (c + i d) == (a - c) + i (b - d)\n-impl<T: Copy + Num> Sub<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Clone + Num> Sub<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n     #[inline]\n     fn sub(&self, other: &Cmplx<T>) -> Cmplx<T> {\n         Cmplx::new(self.re - other.re, self.im - other.im)\n     }\n }\n // (a + i b) * (c + i d) == (a*c - b*d) + i (a*d + b*c)\n-impl<T: Copy + Num> Mul<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Clone + Num> Mul<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n     #[inline]\n     fn mul(&self, other: &Cmplx<T>) -> Cmplx<T> {\n         Cmplx::new(self.re*other.re - self.im*other.im,\n-                     self.re*other.im + self.im*other.re)\n+                   self.re*other.im + self.im*other.re)\n     }\n }\n \n // (a + i b) / (c + i d) == [(a + i b) * (c - i d)] / (c*c + d*d)\n //   == [(a*c + b*d) / (c*c + d*d)] + i [(b*c - a*d) / (c*c + d*d)]\n-impl<T: Copy + Num> Div<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Clone + Num> Div<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n     #[inline]\n     fn div(&self, other: &Cmplx<T>) -> Cmplx<T> {\n         let norm_sqr = other.norm_sqr();\n         Cmplx::new((self.re*other.re + self.im*other.im) / norm_sqr,\n-                     (self.im*other.re - self.re*other.im) / norm_sqr)\n+                   (self.im*other.re - self.re*other.im) / norm_sqr)\n     }\n }\n \n-impl<T: Copy + Num> Neg<Cmplx<T>> for Cmplx<T> {\n+impl<T: Clone + Num> Neg<Cmplx<T>> for Cmplx<T> {\n     #[inline]\n     fn neg(&self) -> Cmplx<T> {\n         Cmplx::new(-self.re, -self.im)\n     }\n }\n \n /* constants */\n-impl<T: Copy + Num> Zero for Cmplx<T> {\n+impl<T: Clone + Num> Zero for Cmplx<T> {\n     #[inline]\n     fn zero() -> Cmplx<T> {\n         Cmplx::new(Zero::zero(), Zero::zero())\n     }\n \n     #[inline]\n     fn is_zero(&self) -> bool {\n-        *self == Zero::zero()\n+        self.re.is_zero() && self.im.is_zero()\n     }\n }\n \n-impl<T: Copy + Num> One for Cmplx<T> {\n+impl<T: Clone + Num> One for Cmplx<T> {\n     #[inline]\n     fn one() -> Cmplx<T> {\n         Cmplx::new(One::one(), Zero::zero())\n@@ -164,7 +195,7 @@ impl<T: ToStrRadix + Num + Ord> ToStrRadix for Cmplx<T> {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use core::num::{Zero,One};\n+    use core::num::{Zero,One,Real};\n \n     pub static _0_0i : Complex = Cmplx { re: 0f, im: 0f };\n     pub static _1_0i : Complex = Cmplx { re: 1f, im: 0f };\n@@ -191,9 +222,10 @@ mod test {\n     }\n \n     #[test]\n-    fn test_norm_sqr() {\n+    fn test_norm() {\n         fn test(c: Complex, ns: float) {\n             assert_eq!(c.norm_sqr(), ns);\n+            assert_eq!(c.norm(), ns.sqrt())\n         }\n         test(_0_0i, 0f);\n         test(_1_0i, 1f);\n@@ -233,6 +265,25 @@ mod test {\n         _0_0i.inv();\n     }\n \n+    #[test]\n+    fn test_arg() {\n+        fn test(c: Complex, arg: float) {\n+            assert!(c.arg().approx_eq(&arg))\n+        }\n+        test(_1_0i, 0f);\n+        test(_1_1i, 0.25f * Real::pi());\n+        test(_neg1_1i, 0.75f * Real::pi());\n+        test(_05_05i, 0.25f * Real::pi());\n+    }\n+\n+    #[test]\n+    fn test_polar_conv() {\n+        fn test(c: Complex) {\n+            let (r, theta) = c.to_polar();\n+            assert!((c - Cmplx::from_polar(&r, &theta)).norm() < 1e-6);\n+        }\n+        for all_consts.each |&c| { test(c); }\n+    }\n \n     mod arith {\n         use super::*;"}, {"sha": "ebb88a1348183d88e8066ecb73ebb6737f461b9c", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -8,17 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! Rational numbers\n \n use core::prelude::*;\n \n-use core::num::{Zero,One,ToStrRadix,FromStrRadix,Round};\n+use core::cmp;\n use core::from_str::FromStr;\n+use core::num::{Zero,One,ToStrRadix,FromStrRadix,Round};\n use super::bigint::BigInt;\n \n /// Represents the ratio between 2 numbers.\n #[deriving(Clone)]\n+#[allow(missing_doc)]\n pub struct Ratio<T> {\n     numer: T,\n     denom: T\n@@ -46,7 +47,7 @@ impl<T: Clone + Integer + Ord>\n         Ratio { numer: numer, denom: denom }\n     }\n \n-    // Create a new Ratio. Fails if `denom == 0`.\n+    /// Create a new Ratio. Fails if `denom == 0`.\n     #[inline(always)]\n     pub fn new(numer: T, denom: T) -> Ratio<T> {\n         if denom == Zero::zero() {\n@@ -249,11 +250,7 @@ impl<T: FromStr + Clone + Integer + Ord>\n     FromStr for Ratio<T> {\n     /// Parses `numer/denom`.\n     fn from_str(s: &str) -> Option<Ratio<T>> {\n-        let split = vec::build(|push| {\n-            for str::each_splitn_char(s, '/', 1) |s| {\n-                push(s.to_owned());\n-            }\n-        });\n+        let split: ~[&str] = s.splitn_iter('/', 1).collect();\n         if split.len() < 2 { return None; }\n         do FromStr::from_str::<T>(split[0]).chain |a| {\n             do FromStr::from_str::<T>(split[1]).chain |b| {\n@@ -266,11 +263,7 @@ impl<T: FromStrRadix + Clone + Integer + Ord>\n     FromStrRadix for Ratio<T> {\n     /// Parses `numer/denom` where the numbers are in base `radix`.\n     fn from_str_radix(s: &str, radix: uint) -> Option<Ratio<T>> {\n-        let split = vec::build(|push| {\n-            for str::each_splitn_char(s, '/', 1) |s| {\n-                push(s.to_owned());\n-            }\n-        });\n+        let split: ~[&str] = s.splitn_iter('/', 1).collect();\n         if split.len() < 2 { None }\n         else {\n             do FromStrRadix::from_str_radix::<T>(split[0], radix).chain |a| {"}, {"sha": "334ab7c9c990f850fe281b9ad9688c8c2e244f75", "filename": "src/libextra/par.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpar.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -10,6 +10,11 @@\n \n use core::prelude::*;\n \n+use core::cast;\n+use core::ptr;\n+use core::sys;\n+use core::uint;\n+use core::vec;\n use future_spawn = future::spawn;\n \n /**\n@@ -117,25 +122,24 @@ pub fn alli<A:Copy + Owned>(\n     xs: &[A],\n     fn_factory: &fn() -> ~fn(uint, &A) -> bool) -> bool\n {\n-    do vec::all(map_slices(xs, || {\n+    let mapped = map_slices(xs, || {\n         let f = fn_factory();\n         let result: ~fn(uint, &[A]) -> bool = |base, slice| {\n-            vec::alli(slice, |i, x| {\n-                f(i + base, x)\n-            })\n+            slice.iter().enumerate().all(|(i, x)| f(i + base, x))\n         };\n         result\n-    })) |x| { *x }\n+    });\n+    mapped.iter().all(|&x| x)\n }\n \n /// Returns true if the function holds for any elements in the vector.\n pub fn any<A:Copy + Owned>(\n     xs: &[A],\n     fn_factory: &fn() -> ~fn(&A) -> bool) -> bool {\n-    do vec::any(map_slices(xs, || {\n+    let mapped = map_slices(xs, || {\n         let f = fn_factory();\n-        let result: ~fn(uint, &[A]) -> bool =\n-            |_, slice| vec::any(slice, |x| f(x));\n+        let result: ~fn(uint, &[A]) -> bool = |_, slice| slice.iter().any_(f);\n         result\n-    })) |x| { *x }\n+    });\n+    mapped.iter().any_(|&x| x)\n }"}, {"sha": "601b7685f3ca8993dbc7af0728cb30c621502644", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -10,12 +10,16 @@\n \n //! A priority queue implemented with a binary heap\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n use core::old_iter::BaseIter;\n use core::unstable::intrinsics::{move_val_init, init};\n use core::util::{replace, swap};\n+use core::vec;\n \n+#[allow(missing_doc)]\n pub struct PriorityQueue<T> {\n     priv data: ~[T],\n }\n@@ -42,26 +46,26 @@ impl<T:Ord> Mutable for PriorityQueue<T> {\n     fn clear(&mut self) { self.data.truncate(0) }\n }\n \n-pub impl <T:Ord> PriorityQueue<T> {\n+impl<T:Ord> PriorityQueue<T> {\n     /// Returns the greatest item in the queue - fails if empty\n-    fn top<'a>(&'a self) -> &'a T { &self.data[0] }\n+    pub fn top<'a>(&'a self) -> &'a T { &self.data[0] }\n \n     /// Returns the greatest item in the queue - None if empty\n-    fn maybe_top<'a>(&'a self) -> Option<&'a T> {\n+    pub fn maybe_top<'a>(&'a self) -> Option<&'a T> {\n         if self.is_empty() { None } else { Some(self.top()) }\n     }\n \n     /// Returns the number of elements the queue can hold without reallocating\n-    fn capacity(&self) -> uint { vec::capacity(&self.data) }\n+    pub fn capacity(&self) -> uint { vec::capacity(&self.data) }\n \n-    fn reserve(&mut self, n: uint) { vec::reserve(&mut self.data, n) }\n+    pub fn reserve(&mut self, n: uint) { vec::reserve(&mut self.data, n) }\n \n-    fn reserve_at_least(&mut self, n: uint) {\n+    pub fn reserve_at_least(&mut self, n: uint) {\n         vec::reserve_at_least(&mut self.data, n)\n     }\n \n     /// Pop the greatest item from the queue - fails if empty\n-    fn pop(&mut self) -> T {\n+    pub fn pop(&mut self) -> T {\n         let mut item = self.data.pop();\n         if !self.is_empty() {\n             swap(&mut item, &mut self.data[0]);\n@@ -71,19 +75,19 @@ pub impl <T:Ord> PriorityQueue<T> {\n     }\n \n     /// Pop the greatest item from the queue - None if empty\n-    fn maybe_pop(&mut self) -> Option<T> {\n+    pub fn maybe_pop(&mut self) -> Option<T> {\n         if self.is_empty() { None } else { Some(self.pop()) }\n     }\n \n     /// Push an item onto the queue\n-    fn push(&mut self, item: T) {\n+    pub fn push(&mut self, item: T) {\n         self.data.push(item);\n         let new_len = self.len() - 1;\n         self.siftup(0, new_len);\n     }\n \n     /// Optimized version of a push followed by a pop\n-    fn push_pop(&mut self, mut item: T) -> T {\n+    pub fn push_pop(&mut self, mut item: T) -> T {\n         if !self.is_empty() && self.data[0] > item {\n             swap(&mut item, &mut self.data[0]);\n             self.siftdown(0);\n@@ -92,18 +96,18 @@ pub impl <T:Ord> PriorityQueue<T> {\n     }\n \n     /// Optimized version of a pop followed by a push - fails if empty\n-    fn replace(&mut self, mut item: T) -> T {\n+    pub fn replace(&mut self, mut item: T) -> T {\n         swap(&mut item, &mut self.data[0]);\n         self.siftdown(0);\n         item\n     }\n \n     /// Consume the PriorityQueue and return the underlying vector\n-    fn to_vec(self) -> ~[T] { let PriorityQueue{data: v} = self; v }\n+    pub fn to_vec(self) -> ~[T] { let PriorityQueue{data: v} = self; v }\n \n     /// Consume the PriorityQueue and return a vector in sorted\n     /// (ascending) order\n-    fn to_sorted_vec(self) -> ~[T] {\n+    pub fn to_sorted_vec(self) -> ~[T] {\n         let mut q = self;\n         let mut end = q.len();\n         while end > 1 {\n@@ -115,10 +119,10 @@ pub impl <T:Ord> PriorityQueue<T> {\n     }\n \n     /// Create an empty PriorityQueue\n-    fn new() -> PriorityQueue<T> { PriorityQueue{data: ~[],} }\n+    pub fn new() -> PriorityQueue<T> { PriorityQueue{data: ~[],} }\n \n     /// Create a PriorityQueue from a vector (heapify)\n-    fn from_vec(xs: ~[T]) -> PriorityQueue<T> {\n+    pub fn from_vec(xs: ~[T]) -> PriorityQueue<T> {\n         let mut q = PriorityQueue{data: xs,};\n         let mut n = q.len() / 2;\n         while n > 0 {\n@@ -133,8 +137,7 @@ pub impl <T:Ord> PriorityQueue<T> {\n     // zeroed element), shift along the others and move it back into the\n     // vector over the junk element.  This reduces the constant factor\n     // compared to using swaps, which involves twice as many moves.\n-\n-    priv fn siftup(&mut self, start: uint, mut pos: uint) {\n+    fn siftup(&mut self, start: uint, mut pos: uint) {\n         unsafe {\n             let new = replace(&mut self.data[pos], init());\n \n@@ -152,7 +155,7 @@ pub impl <T:Ord> PriorityQueue<T> {\n         }\n     }\n \n-    priv fn siftdown_range(&mut self, mut pos: uint, end: uint) {\n+    fn siftdown_range(&mut self, mut pos: uint, end: uint) {\n         unsafe {\n             let start = pos;\n             let new = replace(&mut self.data[pos], init());\n@@ -174,7 +177,7 @@ pub impl <T:Ord> PriorityQueue<T> {\n         }\n     }\n \n-    priv fn siftdown(&mut self, pos: uint) {\n+    fn siftdown(&mut self, pos: uint) {\n         let len = self.len();\n         self.siftdown_range(pos, len);\n     }\n@@ -183,13 +186,12 @@ pub impl <T:Ord> PriorityQueue<T> {\n #[cfg(test)]\n mod tests {\n     use sort::merge_sort;\n-    use core::cmp::le;\n     use priority_queue::PriorityQueue;\n \n     #[test]\n     fn test_top_and_pop() {\n-        let data = ~[2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n-        let mut sorted = merge_sort(data, le);\n+        let data = ~[2u, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n+        let mut sorted = merge_sort(data, |x, y| x.le(y));\n         let mut heap = PriorityQueue::from_vec(data);\n         while !heap.is_empty() {\n             assert_eq!(heap.top(), sorted.last());\n@@ -271,8 +273,9 @@ mod tests {\n \n     fn check_to_vec(data: ~[int]) {\n         let heap = PriorityQueue::from_vec(copy data);\n-        assert_eq!(merge_sort((copy heap).to_vec(), le), merge_sort(data, le));\n-        assert_eq!(heap.to_sorted_vec(), merge_sort(data, le));\n+        assert_eq!(merge_sort((copy heap).to_vec(), |x, y| x.le(y)),\n+                   merge_sort(data, |x, y| x.le(y)));\n+        assert_eq!(heap.to_sorted_vec(), merge_sort(data, |x, y| x.le(y)));\n     }\n \n     #[test]"}, {"sha": "96ad629ea83744d0d26cb3676ab22fe677fba00d", "filename": "src/libextra/rc.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frc.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(missing_doc)];\n+\n /** Task-local reference counted smart pointers\n \n Task-local reference counted smart pointers are an alternative to managed boxes with deterministic\n@@ -21,9 +23,11 @@ cycle cannot be created with `Rc<T>` because there is no way to modify it after\n \n use core::prelude::*;\n \n+use core::cast;\n use core::libc::{c_void, size_t, malloc, free};\n+use core::ptr;\n+use core::sys;\n use core::unstable::intrinsics;\n-use core::util;\n \n struct RcBox<T> {\n     value: T,\n@@ -36,7 +40,7 @@ pub struct Rc<T> {\n     priv ptr: *mut RcBox<T>,\n }\n \n-priv impl<T> Rc<T> {\n+impl<T> Rc<T> {\n     unsafe fn new(value: T) -> Rc<T> {\n         let ptr = malloc(sys::size_of::<RcBox<T>>() as size_t) as *mut RcBox<T>;\n         assert!(!ptr::is_null(ptr));\n@@ -55,9 +59,9 @@ pub fn rc_from_const<T: Const>(value: T) -> Rc<T> {\n     unsafe { Rc::new(value) }\n }\n \n-pub impl<T> Rc<T> {\n+impl<T> Rc<T> {\n     #[inline(always)]\n-    fn borrow<'r>(&'r self) -> &'r T {\n+    pub fn borrow<'r>(&'r self) -> &'r T {\n         unsafe { cast::copy_lifetime(self, &(*self.ptr).value) }\n     }\n }\n@@ -68,7 +72,7 @@ impl<T> Drop for Rc<T> {\n         unsafe {\n             (*self.ptr).count -= 1;\n             if (*self.ptr).count == 0 {\n-                util::replace_ptr(self.ptr, intrinsics::uninit());\n+                ptr::replace_ptr(self.ptr, intrinsics::uninit());\n                 free(self.ptr as *c_void)\n             }\n         }\n@@ -101,7 +105,7 @@ mod test_rc {\n \n     #[test]\n     fn test_clone() {\n-        let x = rc_from_owned(Cell(5));\n+        let x = rc_from_owned(Cell::new(5));\n         let y = x.clone();\n         do x.borrow().with_mut_ref |inner| {\n             *inner = 20;\n@@ -111,7 +115,7 @@ mod test_rc {\n \n     #[test]\n     fn test_deep_clone() {\n-        let x = rc_from_owned(Cell(5));\n+        let x = rc_from_owned(Cell::new(5));\n         let y = x.deep_clone();\n         do x.borrow().with_mut_ref |inner| {\n             *inner = 20;\n@@ -166,7 +170,7 @@ pub struct RcMut<T> {\n     priv ptr: *mut RcMutBox<T>,\n }\n \n-priv impl<T> RcMut<T> {\n+impl<T> RcMut<T> {\n     unsafe fn new(value: T) -> RcMut<T> {\n         let ptr = malloc(sys::size_of::<RcMutBox<T>>() as size_t) as *mut RcMutBox<T>;\n         assert!(!ptr::is_null(ptr));\n@@ -185,10 +189,10 @@ pub fn rc_mut_from_const<T: Const>(value: T) -> RcMut<T> {\n     unsafe { RcMut::new(value) }\n }\n \n-pub impl<T> RcMut<T> {\n+impl<T> RcMut<T> {\n     /// Fails if there is already a mutable borrow of the box\n     #[inline]\n-    fn with_borrow<U>(&self, f: &fn(&T) -> U) -> U {\n+    pub fn with_borrow<U>(&self, f: &fn(&T) -> U) -> U {\n         unsafe {\n             assert!((*self.ptr).borrow != Mutable);\n             let previous = (*self.ptr).borrow;\n@@ -201,7 +205,7 @@ pub impl<T> RcMut<T> {\n \n     /// Fails if there is already a mutable or immutable borrow of the box\n     #[inline]\n-    fn with_mut_borrow<U>(&self, f: &fn(&mut T) -> U) -> U {\n+    pub fn with_mut_borrow<U>(&self, f: &fn(&mut T) -> U) -> U {\n         unsafe {\n             assert_eq!((*self.ptr).borrow, Nothing);\n             (*self.ptr).borrow = Mutable;\n@@ -218,7 +222,7 @@ impl<T> Drop for RcMut<T> {\n         unsafe {\n             (*self.ptr).count -= 1;\n             if (*self.ptr).count == 0 {\n-                util::replace_ptr(self.ptr, uninit());\n+                ptr::replace_ptr(self.ptr, uninit());\n                 free(self.ptr as *c_void)\n             }\n         }"}, {"sha": "040adcc443d92a5d2a4cf2cc7961e8a74d885c50", "filename": "src/libextra/rl.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frl.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -14,6 +14,8 @@\n use core::prelude::*;\n \n use core::libc::{c_char, c_int};\n+use core::local_data;\n+use core::str;\n \n pub mod rustrt {\n     use core::libc::{c_char, c_int};"}, {"sha": "12539cd4759d4d5c706c609c6726de356cdacded", "filename": "src/libextra/rope.rs", "status": "modified", "additions": 40, "deletions": 30, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frope.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -33,8 +33,14 @@\n  * * access to a character by index is logarithmic (linear in strings);\n  */\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n+use core::uint;\n+use core::vec;\n+use core::str;\n+\n /// The type of ropes.\n pub type Rope = node::Root;\n \n@@ -65,7 +71,7 @@ pub fn empty() -> Rope {\n  * * the function runs in linear time.\n  */\n pub fn of_str(str: @~str) -> Rope {\n-    return of_substr(str, 0u, str::len(*str));\n+    return of_substr(str, 0u, str.len());\n }\n \n /**\n@@ -77,9 +83,9 @@ pub fn of_str(str: @~str) -> Rope {\n  *\n  * # Return value\n  *\n- * A rope representing the same string as `str::substr(str, byte_offset,\n- * byte_len)`.  Depending on `byte_len`, this rope may be empty, flat or\n- * complex.\n+ * A rope representing the same string as `str.slice(byte_offset,\n+ * byte_offset + byte_len)`.  Depending on `byte_len`, this rope may\n+ * be empty, flat or complex.\n  *\n  * # Performance note\n  *\n@@ -92,7 +98,7 @@ pub fn of_str(str: @~str) -> Rope {\n  */\n pub fn of_substr(str: @~str, byte_offset: uint, byte_len: uint) -> Rope {\n     if byte_len == 0u { return node::Empty; }\n-    if byte_offset + byte_len  > str::len(*str) { fail!(); }\n+    if byte_offset + byte_len  > str.len() { fail!(); }\n     return node::Content(node::of_substr(str, byte_offset, byte_len));\n }\n \n@@ -556,6 +562,10 @@ pub mod node {\n \n     use rope::node;\n \n+    use core::cast;\n+    use core::uint;\n+    use core::vec;\n+\n     /// Implementation of type `rope`\n     pub enum Root {\n         /// An empty rope\n@@ -576,7 +586,7 @@ pub mod node {\n      * * char_len - The number of chars in the leaf.\n      * * content - Contents of the leaf.\n      *\n-     *     Note that we can have `char_len < str::char_len(content)`, if\n+     *     Note that we can have `char_len < content.char_len()`, if\n      *     this leaf is only a subset of the string. Also note that the\n      *     string can be shared between several ropes, e.g. for indexing\n      *     purposes.\n@@ -646,7 +656,7 @@ pub mod node {\n      * the length of `str`.\n      */\n     pub fn of_str(str: @~str) -> @Node {\n-        return of_substr(str, 0u, str::len(*str));\n+        return of_substr(str, 0u, str.len());\n     }\n \n     /**\n@@ -668,7 +678,7 @@ pub mod node {\n      */\n     pub fn of_substr(str: @~str, byte_start: uint, byte_len: uint) -> @Node {\n         return of_substr_unsafer(str, byte_start, byte_len,\n-                              str::count_chars(*str, byte_start, byte_len));\n+                                 str.slice(byte_start, byte_start + byte_len).char_len());\n     }\n \n     /**\n@@ -694,7 +704,7 @@ pub mod node {\n      */\n     pub fn of_substr_unsafer(str: @~str, byte_start: uint, byte_len: uint,\n                              char_len: uint) -> @Node {\n-        assert!((byte_start + byte_len <= str::len(*str)));\n+        assert!((byte_start + byte_len <= str.len()));\n         let candidate = @Leaf(Leaf {\n             byte_offset: byte_start,\n             byte_len: byte_len,\n@@ -722,7 +732,7 @@ pub mod node {\n                     if i == 0u  { first_leaf_char_len }\n                     else { hint_max_leaf_char_len };\n                 let chunk_byte_len =\n-                    str::count_bytes(*str, offset, chunk_char_len);\n+                    str.slice_from(offset).slice_chars(0, chunk_char_len).len();\n                 nodes[i] = @Leaf(Leaf {\n                     byte_offset: offset,\n                     byte_len: chunk_byte_len,\n@@ -926,7 +936,7 @@ pub mod node {\n             match (*node) {\n               node::Leaf(x) => {\n                 let char_len =\n-                    str::count_chars(*x.content, byte_offset, byte_len);\n+                    x.content.slice(byte_offset, byte_offset + byte_len).char_len();\n                 return @Leaf(Leaf {\n                     byte_offset: byte_offset,\n                     byte_len: byte_len,\n@@ -990,9 +1000,9 @@ pub mod node {\n                     return node;\n                 }\n                 let byte_offset =\n-                    str::count_bytes(*x.content, 0u, char_offset);\n+                    x.content.slice_chars(0, char_offset).len();\n                 let byte_len    =\n-                    str::count_bytes(*x.content, byte_offset, char_len);\n+                    x.content.slice_from(byte_offset).slice_chars(0, char_len).len();\n                 return @Leaf(Leaf {\n                     byte_offset: byte_offset,\n                     byte_len: byte_len,\n@@ -1068,9 +1078,7 @@ pub mod node {\n \n     pub fn loop_chars(node: @Node, it: &fn(c: char) -> bool) -> bool {\n         return loop_leaves(node,|leaf| {\n-            str::all_between(*leaf.content,\n-                             leaf.byte_offset,\n-                             leaf.byte_len, it)\n+            leaf.content.slice(leaf.byte_offset, leaf.byte_len).iter().all(it)\n         });\n     }\n \n@@ -1122,7 +1130,7 @@ pub mod node {\n     pub fn char_at(mut node: @Node, mut pos: uint) -> char {\n         loop {\n             match *node {\n-              Leaf(x) => return str::char_at(*x.content, pos),\n+              Leaf(x) => return x.content.char_at(pos),\n               Concat(Concat {left, right, _}) => {\n                 let left_len = char_len(left);\n                 node = if left_len > pos { left }\n@@ -1137,6 +1145,8 @@ pub mod node {\n \n         use rope::node::{Concat, Leaf, Node, height};\n \n+        use core::vec;\n+\n         pub struct T {\n             stack: ~[@Node],\n             stackpos: int,\n@@ -1243,8 +1253,7 @@ pub mod node {\n                     return None\n                 } else {\n                     let range =\n-                        str::char_range_at(*aleaf.content,\n-                                     (*it).leaf_byte_pos + aleaf.byte_offset);\n+                        aleaf.content.char_range_at((*it).leaf_byte_pos + aleaf.byte_offset);\n                     let ch = range.ch;\n                     let next = range.next;\n                     (*it).leaf_byte_pos = next - aleaf.byte_offset;\n@@ -1258,9 +1267,14 @@ pub mod node {\n \n #[cfg(test)]\n mod tests {\n-    use rope::*;\n     use core::prelude::*;\n \n+    use rope::*;\n+\n+    use core::str;\n+    use core::uint;\n+    use core::vec;\n+\n     //Utility function, used for sanity check\n     fn rope_to_string(r: Rope) -> ~str {\n         match (r) {\n@@ -1270,11 +1284,7 @@ mod tests {\n             fn aux(str: &mut ~str, node: @node::Node) {\n                 match (*node) {\n                     node::Leaf(x) => {\n-                        str::push_str(\n-                            str,\n-                            str::slice(\n-                                *x.content, x.byte_offset,\n-                                x.byte_offset + x.byte_len));\n+                        str.push_str(x.content.slice(x.byte_offset, x.byte_offset + x.byte_len));\n                     }\n                     node::Concat(ref x) => {\n                         aux(str, x.left);\n@@ -1300,7 +1310,7 @@ mod tests {\n         let sample = @~\"0123456789ABCDE\";\n         let r      = of_str(sample);\n \n-        assert_eq!(char_len(r), str::char_len(*sample));\n+        assert_eq!(char_len(r), sample.char_len());\n         assert!(rope_to_string(r) == *sample);\n     }\n \n@@ -1316,11 +1326,11 @@ mod tests {\n         }\n         let sample = @copy *buf;\n         let r      = of_str(sample);\n-        assert!(char_len(r) == str::char_len(*sample));\n+        assert_eq!(char_len(r), sample.char_len());\n         assert!(rope_to_string(r) == *sample);\n \n         let mut string_iter = 0u;\n-        let string_len = str::len(*sample);\n+        let string_len = sample.len();\n         let mut rope_iter = iterator::char::start(r);\n         let mut equal = true;\n         while equal {\n@@ -1330,7 +1340,7 @@ mod tests {\n                     equal = false;\n                 } break; }\n               Some(c) => {\n-                let range = str::char_range_at(*sample, string_iter);\n+                let range = sample.char_range_at(string_iter);\n                 string_iter = range.next;\n                 if range.ch != c { equal = false; break; }\n               }\n@@ -1362,7 +1372,7 @@ mod tests {\n             }\n         }\n \n-        assert_eq!(len, str::char_len(*sample));\n+        assert_eq!(len, sample.char_len());\n     }\n \n     #[test]"}, {"sha": "462461439e67320437f25b797bd483cb1ac1a672", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -10,14 +10,15 @@\n \n //! Semver parsing and logic\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n use core::char;\n use core::cmp;\n use core::io::{ReaderUtil};\n use core::io;\n use core::option::{Option, Some, None};\n-use core::str;\n use core::to_str::ToStr;\n use core::uint;\n \n@@ -78,12 +79,12 @@ impl ToStr for Version {\n         let s = if self.pre.is_empty() {\n             s\n         } else {\n-            s + \"-\" + str::connect(self.pre.map(|i| i.to_str()), \".\")\n+            s + \"-\" + self.pre.map(|i| i.to_str()).connect(\".\")\n         };\n         if self.build.is_empty() {\n             s\n         } else {\n-            s + \"+\" + str::connect(self.build.map(|i| i.to_str()), \".\")\n+            s + \"+\" + self.build.map(|i| i.to_str()).connect(\".\")\n         }\n     }\n }\n@@ -146,7 +147,7 @@ fn take_nonempty_prefix(rdr: @io::Reader,\n     let mut buf = ~\"\";\n     let mut ch = ch;\n     while pred(ch) {\n-        str::push_char(&mut buf, ch);\n+        buf.push_char(ch);\n         ch = rdr.read_char();\n     }\n     if buf.is_empty() {\n@@ -166,7 +167,7 @@ fn take_num(rdr: @io::Reader, ch: char) -> (uint, char) {\n \n fn take_ident(rdr: @io::Reader, ch: char) -> (Identifier, char) {\n     let (s,ch) = take_nonempty_prefix(rdr, ch, char::is_alphanumeric);\n-    if s.all(char::is_digit) {\n+    if s.iter().all(char::is_digit) {\n         match uint::from_str(s) {\n             None => { bad_parse::cond.raise(()); (Numeric(0), ch) },\n             Some(i) => (Numeric(i), ch)"}, {"sha": "a54db07261a6aeaaeb078fc2fbda390982c8ff92", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -14,12 +14,16 @@\n Core encoding and decoding interfaces.\n */\n \n+#[allow(missing_doc)];\n #[forbid(non_camel_case_types)];\n \n use core::prelude::*;\n \n+use core::at_vec;\n use core::hashmap::{HashMap, HashSet};\n use core::trie::{TrieMap, TrieSet};\n+use core::uint;\n+use core::vec;\n use deque::Deque;\n use dlist::DList;\n use treemap::{TreeMap, TreeSet};\n@@ -371,6 +375,18 @@ impl<D:Decoder> Decodable<D> for bool {\n     }\n }\n \n+impl<S:Encoder> Encodable<S> for char {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_char(*self)\n+    }\n+}\n+\n+impl<D:Decoder> Decodable<D> for char {\n+    fn decode(d: &mut D) -> char {\n+        d.read_char()\n+    }\n+}\n+\n impl<S:Encoder> Encodable<S> for () {\n     fn encode(&self, s: &mut S) {\n         s.emit_nil()"}, {"sha": "908e497b9591b28f7a91fc3f5c5514457c48b51d", "filename": "src/libextra/sha1.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsha1.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -173,7 +173,7 @@ pub fn sha1() -> @Sha1 {\n     fn mk_result(st: &mut Sha1State) -> ~[u8] {\n         if !(*st).computed { pad_msg(st); (*st).computed = true; }\n         let mut rs: ~[u8] = ~[];\n-        for vec::each_mut((*st).h) |ptr_hpart| {\n+        for st.h.mut_iter().advance |ptr_hpart| {\n             let hpart = *ptr_hpart;\n             let a = (hpart >> 24u32 & 0xFFu32) as u8;\n             let b = (hpart >> 16u32 & 0xFFu32) as u8;\n@@ -194,7 +194,7 @@ pub fn sha1() -> @Sha1 {\n      * can be assumed that the message digest has been computed.\n      */\n     fn pad_msg(st: &mut Sha1State) {\n-        assert_eq!(vec::len((*st).msg_block), msg_block_len);\n+        assert_eq!((*st).msg_block.len(), msg_block_len);\n \n         /*\n          * Check to see if the current message block is too small to hold\n@@ -245,8 +245,7 @@ pub fn sha1() -> @Sha1 {\n         }\n         fn input(&mut self, msg: &const [u8]) { add_input(self, msg); }\n         fn input_str(&mut self, msg: &str) {\n-            let bs = str::to_bytes(msg);\n-            add_input(self, bs);\n+            add_input(self, msg.as_bytes());\n         }\n         fn result(&mut self) -> ~[u8] { return mk_result(self); }\n         fn result_str(&mut self) -> ~str {\n@@ -280,7 +279,6 @@ pub fn sha1() -> @Sha1 {\n mod tests {\n     use sha1;\n \n-    use core::str;\n     use core::vec;\n \n     #[test]\n@@ -367,8 +365,8 @@ mod tests {\n         ];\n         let tests = fips_180_1_tests + wikipedia_tests;\n         fn check_vec_eq(v0: ~[u8], v1: ~[u8]) {\n-            assert_eq!(vec::len::<u8>(v0), vec::len::<u8>(v1));\n-            let len = vec::len::<u8>(v0);\n+            assert_eq!(v0.len(), v1.len());\n+            let len = v0.len();\n             let mut i = 0u;\n             while i < len {\n                 let a = v0[i];\n@@ -395,12 +393,11 @@ mod tests {\n \n         // Test that it works when accepting the message in pieces\n         for tests.each |t| {\n-            let len = str::len(t.input);\n+            let len = t.input.len();\n             let mut left = len;\n             while left > 0u {\n                 let take = (left + 1u) / 2u;\n-                sh.input_str(str::slice(t.input, len - left,\n-                             take + len - left).to_owned());\n+                sh.input_str(t.input.slice(len - left, take + len - left));\n                 left = left - take;\n             }\n             let out = sh.result();"}, {"sha": "7f566bc16e7321614a2f6930ed6cea5c57ad6b86", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -13,14 +13,19 @@\n  * are O(highest integer key).\n  */\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n+use core::cmp;\n use core::container::{Container, Mutable, Map, Set};\n use core::old_iter::BaseIter;\n use core::old_iter;\n-use core::option::{Some, None};\n+use core::uint;\n use core::util::replace;\n+use core::vec;\n \n+#[allow(missing_doc)]\n pub struct SmallIntMap<T> {\n     priv v: ~[Option<T>],\n }\n@@ -149,12 +154,12 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n }\n \n-pub impl<V> SmallIntMap<V> {\n+impl<V> SmallIntMap<V> {\n     /// Create an empty SmallIntMap\n-    fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n+    pub fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n \n     /// Visit all key-value pairs in reverse order\n-    fn each_reverse<'a>(&'a self, it: &fn(uint, &'a V) -> bool) -> bool {\n+    pub fn each_reverse<'a>(&'a self, it: &fn(uint, &'a V) -> bool) -> bool {\n         for uint::range_rev(self.v.len(), 0) |i| {\n             match self.v[i - 1] {\n               Some(ref elt) => if !it(i - 1, elt) { return false; },\n@@ -164,26 +169,30 @@ pub impl<V> SmallIntMap<V> {\n         return true;\n     }\n \n-    fn get<'a>(&'a self, key: &uint) -> &'a V {\n+    pub fn get<'a>(&'a self, key: &uint) -> &'a V {\n         self.find(key).expect(\"key not present\")\n     }\n }\n \n-pub impl<V:Copy> SmallIntMap<V> {\n-    fn update_with_key(&mut self, key: uint, val: V,\n-                       ff: &fn(uint, V, V) -> V) -> bool {\n+impl<V:Copy> SmallIntMap<V> {\n+    pub fn update_with_key(&mut self, key: uint, val: V,\n+                           ff: &fn(uint, V, V) -> V) -> bool {\n         let new_val = match self.find(&key) {\n             None => val,\n             Some(orig) => ff(key, *orig, val)\n         };\n         self.insert(key, new_val)\n     }\n \n-    fn update(&mut self, key: uint, newval: V, ff: &fn(V, V) -> V) -> bool {\n+    pub fn update(&mut self, key: uint, newval: V, ff: &fn(V, V) -> V)\n+                  -> bool {\n         self.update_with_key(key, newval, |_k, v, v1| ff(v,v1))\n     }\n }\n \n+/// A set implemented on top of the SmallIntMap type. This set is always a set\n+/// of integers, and the space requirements are on the order of the highest\n+/// valued integer in the set.\n pub struct SmallIntSet {\n     priv map: SmallIntMap<()>\n }\n@@ -274,9 +283,9 @@ impl Set<uint> for SmallIntSet {\n     }\n }\n \n-pub impl SmallIntSet {\n+impl SmallIntSet {\n     /// Create an empty SmallIntSet\n-    fn new() -> SmallIntSet { SmallIntSet{map: SmallIntMap::new()} }\n+    pub fn new() -> SmallIntSet { SmallIntSet{map: SmallIntMap::new()} }\n }\n \n #[cfg(test)]\n@@ -285,6 +294,11 @@ mod tests {\n \n     use super::SmallIntMap;\n \n+    use core::local_data;\n+    use core::rand;\n+    use core::uint;\n+    use core::vec;\n+\n     #[test]\n     fn test_find_mut() {\n         let mut m = SmallIntMap::new();\n@@ -380,6 +394,8 @@ mod test_set {\n \n     use super::SmallIntSet;\n \n+    use core::vec;\n+\n     #[test]\n     fn test_disjoint() {\n         let mut xs = SmallIntSet::new();"}, {"sha": "0189e0db6d4ef5115c3777170f07465696a23a5f", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -13,9 +13,9 @@\n use core::prelude::*;\n \n use core::cmp::{Eq, Ord};\n-use core::vec::len;\n-use core::vec;\n+use core::uint;\n use core::util::swap;\n+use core::vec;\n \n type Le<'self, T> = &'self fn(v1: &T, v2: &T) -> bool;\n \n@@ -28,7 +28,7 @@ type Le<'self, T> = &'self fn(v1: &T, v2: &T) -> bool;\n pub fn merge_sort<T:Copy>(v: &[T], le: Le<T>) -> ~[T] {\n     type Slice = (uint, uint);\n \n-    return merge_sort_(v, (0u, len(v)), le);\n+    return merge_sort_(v, (0u, v.len()), le);\n \n     fn merge_sort_<T:Copy>(v: &[T], slice: Slice, le: Le<T>)\n         -> ~[T] {\n@@ -46,10 +46,10 @@ pub fn merge_sort<T:Copy>(v: &[T], le: Le<T>) -> ~[T] {\n     }\n \n     fn merge<T:Copy>(le: Le<T>, a: &[T], b: &[T]) -> ~[T] {\n-        let mut rs = vec::with_capacity(len(a) + len(b));\n-        let a_len = len(a);\n+        let mut rs = vec::with_capacity(a.len() + b.len());\n+        let a_len = a.len();\n         let mut a_ix = 0;\n-        let b_len = len(b);\n+        let b_len = b.len();\n         let mut b_ix = 0;\n         while a_ix < a_len && b_ix < b_len {\n             if le(&a[a_ix], &b[b_ix]) {\n@@ -99,8 +99,9 @@ fn qsort<T>(arr: &mut [T], left: uint,\n  * This is an unstable sort.\n  */\n pub fn quick_sort<T>(arr: &mut [T], compare_func: Le<T>) {\n-    if len::<T>(arr) == 0u { return; }\n-    qsort::<T>(arr, 0u, len::<T>(arr) - 1u, compare_func);\n+    let len = arr.len();\n+    if len == 0u { return; }\n+    qsort::<T>(arr, 0u, len - 1u, compare_func);\n }\n \n fn qsort3<T:Copy + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n@@ -137,7 +138,7 @@ fn qsort3<T:Copy + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n         vec::swap(arr, k as uint, j as uint);\n         k += 1;\n         j -= 1;\n-        if k == len::<T>(arr) as int { break; }\n+        if k == arr.len() as int { break; }\n     }\n     k = right - 1;\n     while k > q {\n@@ -166,6 +167,7 @@ pub fn quick_sort3<T:Copy + Ord + Eq>(arr: &mut [T]) {\n     qsort3(arr, 0, (len - 1) as int);\n }\n \n+#[allow(missing_doc)]\n pub trait Sort {\n     fn qsort(self);\n }\n@@ -178,6 +180,7 @@ static MIN_MERGE: uint = 64;\n static MIN_GALLOP: uint = 7;\n static INITIAL_TMP_STORAGE: uint = 128;\n \n+#[allow(missing_doc)]\n pub fn tim_sort<T:Copy + Ord>(array: &mut [T]) {\n     let size = array.len();\n     if size < 2 {\n@@ -751,7 +754,7 @@ mod test_qsort3 {\n     use core::vec;\n \n     fn check_sort(v1: &mut [int], v2: &mut [int]) {\n-        let len = vec::len::<int>(v1);\n+        let len = v1.len();\n         quick_sort3::<int>(v1);\n         let mut i = 0;\n         while i < len {\n@@ -796,7 +799,7 @@ mod test_qsort {\n     use core::vec;\n \n     fn check_sort(v1: &mut [int], v2: &mut [int]) {\n-        let len = vec::len::<int>(v1);\n+        let len = v1.len();\n         fn leual(a: &int, b: &int) -> bool { *a <= *b }\n         quick_sort::<int>(v1, leual);\n         let mut i = 0u;\n@@ -861,7 +864,7 @@ mod tests {\n     use core::vec;\n \n     fn check_sort(v1: &[int], v2: &[int]) {\n-        let len = vec::len::<int>(v1);\n+        let len = v1.len();\n         pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let f = le;\n         let v3 = merge_sort::<int>(v1, f);\n@@ -927,6 +930,8 @@ mod test_tim_sort {\n \n     use sort::tim_sort;\n     use core::rand::RngUtil;\n+    use core::rand;\n+    use core::vec;\n \n     struct CVal {\n         val: float,\n@@ -946,7 +951,7 @@ mod test_tim_sort {\n     }\n \n     fn check_sort(v1: &mut [int], v2: &mut [int]) {\n-        let len = vec::len::<int>(v1);\n+        let len = v1.len();\n         tim_sort::<int>(v1);\n         let mut i = 0u;\n         while i < len {\n@@ -1019,7 +1024,12 @@ mod big_tests {\n     use core::prelude::*;\n \n     use sort::*;\n+\n+    use core::local_data;\n     use core::rand::RngUtil;\n+    use core::rand;\n+    use core::uint;\n+    use core::vec;\n \n     #[test]\n     fn test_unique() {"}, {"sha": "4af47fa806f897db3f5e948d4a6ab6b4997905ee", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -8,12 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n use core::vec;\n use core::f64;\n use core::cmp;\n use core::num;\n+use core::vec;\n use sort;\n \n // NB: this can probably be rewritten in terms of num::Num\n@@ -34,17 +37,17 @@ pub trait Stats {\n \n impl<'self> Stats for &'self [f64] {\n     fn sum(self) -> f64 {\n-        vec::foldl(0.0, self, |p,q| p + *q)\n+        self.iter().fold(0.0, |p,q| p + *q)\n     }\n \n     fn min(self) -> f64 {\n         assert!(self.len() != 0);\n-        vec::foldl(self[0], self, |p,q| cmp::min(p, *q))\n+        self.iter().fold(self[0], |p,q| cmp::min(p, *q))\n     }\n \n     fn max(self) -> f64 {\n         assert!(self.len() != 0);\n-        vec::foldl(self[0], self, |p,q| cmp::max(p, *q))\n+        self.iter().fold(self[0], |p,q| cmp::max(p, *q))\n     }\n \n     fn mean(self) -> f64 {"}, {"sha": "83c0bb516b4362452b5dc9f17152102180dcafdd", "filename": "src/libextra/std.rc", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstd.rc?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -27,8 +27,12 @@ not required in or otherwise suitable for the core library.\n #[crate_type = \"lib\"];\n \n #[deny(non_camel_case_types)];\n+#[deny(missing_doc)];\n+\n+// NOTE: remove these two attributes after the next snapshot\n+#[no_core]; // for stage0\n+#[allow(unrecognized_lint)]; // otherwise stage0 is seriously ugly\n \n-#[no_core];\n #[no_std];\n \n extern mod core(name = \"std\", vers = \"0.7-pre\");\n@@ -114,6 +118,8 @@ pub mod flate;\n #[cfg(unicode)]\n mod unicode;\n \n+#[path=\"terminfo/terminfo.rs\"]\n+pub mod terminfo;\n \n // Compiler support modules\n \n@@ -133,10 +139,12 @@ pub mod std {\n     pub use core::condition;\n     pub use core::cmp;\n     pub use core::sys;\n+    pub use core::unstable;\n+    pub use core::str;\n+    pub use core::os;\n }\n #[doc(hidden)]\n pub mod extra {\n     pub use serialize;\n     pub use test;\n }\n-"}, {"sha": "5930bf50ff7806d7972391df00f05b2b10002fcf", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 249, "deletions": 163, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -17,9 +17,11 @@\n \n use core::prelude::*;\n \n-use core::unstable::sync::{Exclusive, exclusive};\n-use core::ptr;\n+use core::borrow;\n+use core::comm;\n use core::task;\n+use core::unstable::sync::{Exclusive, exclusive, UnsafeAtomicRcBox};\n+use core::unstable::atomics;\n use core::util;\n \n /****************************************************************************\n@@ -36,6 +38,7 @@ type SignalEnd = comm::ChanOne<()>;\n struct Waitqueue { head: comm::Port<SignalEnd>,\n                    tail: comm::Chan<SignalEnd> }\n \n+#[doc(hidden)]\n fn new_waitqueue() -> Waitqueue {\n     let (block_head, block_tail) = comm::stream();\n     Waitqueue { head: block_head, tail: block_tail }\n@@ -98,40 +101,45 @@ fn new_sem_and_signal(count: int, num_condvars: uint)\n }\n \n #[doc(hidden)]\n-pub impl<Q:Owned> Sem<Q> {\n-    fn acquire(&self) {\n-        let mut waiter_nobe = None;\n-        do (**self).with |state| {\n-            state.count -= 1;\n-            if state.count < 0 {\n-                // Create waiter nobe.\n-                let (WaitEnd, SignalEnd) = comm::oneshot();\n-                // Tell outer scope we need to block.\n-                waiter_nobe = Some(WaitEnd);\n-                // Enqueue ourself.\n-                state.waiters.tail.send(SignalEnd);\n+impl<Q:Owned> Sem<Q> {\n+    pub fn acquire(&self) {\n+        unsafe {\n+            let mut waiter_nobe = None;\n+            do (**self).with |state| {\n+                state.count -= 1;\n+                if state.count < 0 {\n+                    // Create waiter nobe.\n+                    let (WaitEnd, SignalEnd) = comm::oneshot();\n+                    // Tell outer scope we need to block.\n+                    waiter_nobe = Some(WaitEnd);\n+                    // Enqueue ourself.\n+                    state.waiters.tail.send(SignalEnd);\n+                }\n+            }\n+            // Uncomment if you wish to test for sem races. Not valgrind-friendly.\n+            /* for 1000.times { task::yield(); } */\n+            // Need to wait outside the exclusive.\n+            if waiter_nobe.is_some() {\n+                let _ = comm::recv_one(waiter_nobe.unwrap());\n             }\n-        }\n-        // Uncomment if you wish to test for sem races. Not valgrind-friendly.\n-        /* for 1000.times { task::yield(); } */\n-        // Need to wait outside the exclusive.\n-        if waiter_nobe.is_some() {\n-            let _ = comm::recv_one(waiter_nobe.unwrap());\n         }\n     }\n-    fn release(&self) {\n-        do (**self).with |state| {\n-            state.count += 1;\n-            if state.count <= 0 {\n-                signal_waitqueue(&state.waiters);\n+\n+    pub fn release(&self) {\n+        unsafe {\n+            do (**self).with |state| {\n+                state.count += 1;\n+                if state.count <= 0 {\n+                    signal_waitqueue(&state.waiters);\n+                }\n             }\n         }\n     }\n }\n // FIXME(#3154) move both copies of this into Sem<Q>, and unify the 2 structs\n #[doc(hidden)]\n-pub impl Sem<()> {\n-    fn access<U>(&self, blk: &fn() -> U) -> U {\n+impl Sem<()> {\n+    pub fn access<U>(&self, blk: &fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n@@ -142,9 +150,10 @@ pub impl Sem<()> {\n         blk()\n     }\n }\n+\n #[doc(hidden)]\n-pub impl Sem<~[Waitqueue]> {\n-    fn access<U>(&self, blk: &fn() -> U) -> U {\n+impl Sem<~[Waitqueue]> {\n+    pub fn access<U>(&self, blk: &fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n@@ -159,36 +168,60 @@ pub impl Sem<~[Waitqueue]> {\n // FIXME(#3588) should go inside of access()\n #[doc(hidden)]\n type SemRelease<'self> = SemReleaseGeneric<'self, ()>;\n+#[doc(hidden)]\n type SemAndSignalRelease<'self> = SemReleaseGeneric<'self, ~[Waitqueue]>;\n+#[doc(hidden)]\n struct SemReleaseGeneric<'self, Q> { sem: &'self Sem<Q> }\n \n+#[doc(hidden)]\n #[unsafe_destructor]\n impl<'self, Q:Owned> Drop for SemReleaseGeneric<'self, Q> {\n     fn finalize(&self) {\n         self.sem.release();\n     }\n }\n \n+#[doc(hidden)]\n fn SemRelease<'r>(sem: &'r Sem<()>) -> SemRelease<'r> {\n     SemReleaseGeneric {\n         sem: sem\n     }\n }\n \n+#[doc(hidden)]\n fn SemAndSignalRelease<'r>(sem: &'r Sem<~[Waitqueue]>)\n                         -> SemAndSignalRelease<'r> {\n     SemReleaseGeneric {\n         sem: sem\n     }\n }\n \n+// FIXME(#3598): Want to use an Option down below, but we need a custom enum\n+// that's not polymorphic to get around the fact that lifetimes are invariant\n+// inside of type parameters.\n+enum ReacquireOrderLock<'self> {\n+    Nothing, // c.c\n+    Just(&'self Semaphore),\n+}\n+\n /// A mechanism for atomic-unlock-and-deschedule blocking and signalling.\n-pub struct Condvar<'self> { priv sem: &'self Sem<~[Waitqueue]> }\n+pub struct Condvar<'self> {\n+    // The 'Sem' object associated with this condvar. This is the one that's\n+    // atomically-unlocked-and-descheduled upon and reacquired during wakeup.\n+    priv sem: &'self Sem<~[Waitqueue]>,\n+    // This is (can be) an extra semaphore which is held around the reacquire\n+    // operation on the first one. This is only used in cvars associated with\n+    // rwlocks, and is needed to ensure that, when a downgrader is trying to\n+    // hand off the access lock (which would be the first field, here), a 2nd\n+    // writer waking up from a cvar wait can't race with a reader to steal it,\n+    // See the comment in write_cond for more detail.\n+    priv order: ReacquireOrderLock<'self>,\n+}\n \n #[unsafe_destructor]\n impl<'self> Drop for Condvar<'self> { fn finalize(&self) {} }\n \n-pub impl<'self> Condvar<'self> {\n+impl<'self> Condvar<'self> {\n     /**\n      * Atomically drop the associated lock, and block until a signal is sent.\n      *\n@@ -197,7 +230,7 @@ pub impl<'self> Condvar<'self> {\n      * while waiting on a condition variable will wake up, fail, and unlock\n      * the associated lock as it unwinds.\n      */\n-    fn wait(&self) { self.wait_on(0) }\n+    pub fn wait(&self) { self.wait_on(0) }\n \n     /**\n      * As wait(), but can specify which of multiple condition variables to\n@@ -210,7 +243,7 @@ pub impl<'self> Condvar<'self> {\n      *\n      * wait() is equivalent to wait_on(0).\n      */\n-    fn wait_on(&self, condvar_id: uint) {\n+    pub fn wait_on(&self, condvar_id: uint) {\n         // Create waiter nobe.\n         let (WaitEnd, SignalEnd) = comm::oneshot();\n         let mut WaitEnd   = Some(WaitEnd);\n@@ -240,7 +273,8 @@ pub impl<'self> Condvar<'self> {\n                 // unkillably reacquire the lock needs to happen atomically\n                 // wrt enqueuing.\n                 if out_of_bounds.is_none() {\n-                    reacquire = Some(SemAndSignalReacquire(self.sem));\n+                    reacquire = Some(CondvarReacquire { sem:   self.sem,\n+                                                        order: self.order });\n                 }\n             }\n         }\n@@ -254,70 +288,75 @@ pub impl<'self> Condvar<'self> {\n         // This is needed for a failing condition variable to reacquire the\n         // mutex during unwinding. As long as the wrapper (mutex, etc) is\n         // bounded in when it gets released, this shouldn't hang forever.\n-        struct SemAndSignalReacquire<'self> {\n+        struct CondvarReacquire<'self> {\n             sem: &'self Sem<~[Waitqueue]>,\n+            order: ReacquireOrderLock<'self>,\n         }\n \n         #[unsafe_destructor]\n-        impl<'self> Drop for SemAndSignalReacquire<'self> {\n+        impl<'self> Drop for CondvarReacquire<'self> {\n             fn finalize(&self) {\n                 unsafe {\n                     // Needs to succeed, instead of itself dying.\n                     do task::unkillable {\n-                        self.sem.acquire();\n+                        match self.order {\n+                            Just(lock) => do lock.access {\n+                                self.sem.acquire();\n+                            },\n+                            Nothing => {\n+                                self.sem.acquire();\n+                            },\n+                        }\n                     }\n                 }\n             }\n         }\n-\n-        fn SemAndSignalReacquire<'r>(sem: &'r Sem<~[Waitqueue]>)\n-                                  -> SemAndSignalReacquire<'r> {\n-            SemAndSignalReacquire {\n-                sem: sem\n-            }\n-        }\n     }\n \n     /// Wake up a blocked task. Returns false if there was no blocked task.\n-    fn signal(&self) -> bool { self.signal_on(0) }\n+    pub fn signal(&self) -> bool { self.signal_on(0) }\n \n     /// As signal, but with a specified condvar_id. See wait_on.\n-    fn signal_on(&self, condvar_id: uint) -> bool {\n-        let mut out_of_bounds = None;\n-        let mut result = false;\n-        do (**self.sem).with |state| {\n-            if condvar_id < state.blocked.len() {\n-                result = signal_waitqueue(&state.blocked[condvar_id]);\n-            } else {\n-                out_of_bounds = Some(state.blocked.len());\n+    pub fn signal_on(&self, condvar_id: uint) -> bool {\n+        unsafe {\n+            let mut out_of_bounds = None;\n+            let mut result = false;\n+            do (**self.sem).with |state| {\n+                if condvar_id < state.blocked.len() {\n+                    result = signal_waitqueue(&state.blocked[condvar_id]);\n+                } else {\n+                    out_of_bounds = Some(state.blocked.len());\n+                }\n+            }\n+            do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {\n+                result\n             }\n-        }\n-        do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {\n-            result\n         }\n     }\n \n     /// Wake up all blocked tasks. Returns the number of tasks woken.\n-    fn broadcast(&self) -> uint { self.broadcast_on(0) }\n+    pub fn broadcast(&self) -> uint { self.broadcast_on(0) }\n \n     /// As broadcast, but with a specified condvar_id. See wait_on.\n-    fn broadcast_on(&self, condvar_id: uint) -> uint {\n+    pub fn broadcast_on(&self, condvar_id: uint) -> uint {\n         let mut out_of_bounds = None;\n         let mut queue = None;\n-        do (**self.sem).with |state| {\n-            if condvar_id < state.blocked.len() {\n-                // To avoid :broadcast_heavy, we make a new waitqueue,\n-                // swap it out with the old one, and broadcast on the\n-                // old one outside of the little-lock.\n-                queue = Some(util::replace(&mut state.blocked[condvar_id],\n-                                           new_waitqueue()));\n-            } else {\n-                out_of_bounds = Some(state.blocked.len());\n+        unsafe {\n+            do (**self.sem).with |state| {\n+                if condvar_id < state.blocked.len() {\n+                    // To avoid :broadcast_heavy, we make a new waitqueue,\n+                    // swap it out with the old one, and broadcast on the\n+                    // old one outside of the little-lock.\n+                    queue = Some(util::replace(&mut state.blocked[condvar_id],\n+                                               new_waitqueue()));\n+                } else {\n+                    out_of_bounds = Some(state.blocked.len());\n+                }\n+            }\n+            do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {\n+                let queue = queue.swap_unwrap();\n+                broadcast_waitqueue(&queue)\n             }\n-        }\n-        do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {\n-            let queue = queue.swap_unwrap();\n-            broadcast_waitqueue(&queue)\n         }\n     }\n }\n@@ -338,10 +377,13 @@ fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n }\n \n #[doc(hidden)]\n-pub impl Sem<~[Waitqueue]> {\n-    // The only other place that condvars get built is rwlock_write_mode.\n-    fn access_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n-        do self.access { blk(&Condvar { sem: self }) }\n+impl Sem<~[Waitqueue]> {\n+    // The only other places that condvars get built are rwlock.write_cond()\n+    // and rwlock_write_mode.\n+    pub fn access_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n+        do self.access {\n+            blk(&Condvar { sem: self, order: Nothing })\n+        }\n     }\n }\n \n@@ -364,21 +406,21 @@ impl Clone for Semaphore {\n     }\n }\n \n-pub impl Semaphore {\n+impl Semaphore {\n     /**\n      * Acquire a resource represented by the semaphore. Blocks if necessary\n      * until resource(s) become available.\n      */\n-    fn acquire(&self) { (&self.sem).acquire() }\n+    pub fn acquire(&self) { (&self.sem).acquire() }\n \n     /**\n      * Release a held resource represented by the semaphore. Wakes a blocked\n      * contending task, if any exist. Won't block the caller.\n      */\n-    fn release(&self) { (&self.sem).release() }\n+    pub fn release(&self) { (&self.sem).release() }\n \n     /// Run a function with ownership of one of the semaphore's resources.\n-    fn access<U>(&self, blk: &fn() -> U) -> U { (&self.sem).access(blk) }\n+    pub fn access<U>(&self, blk: &fn() -> U) -> U { (&self.sem).access(blk) }\n }\n \n /****************************************************************************\n@@ -412,12 +454,12 @@ impl Clone for Mutex {\n     fn clone(&self) -> Mutex { Mutex { sem: Sem((*self.sem).clone()) } }\n }\n \n-pub impl Mutex {\n+impl Mutex {\n     /// Run a function with ownership of the mutex.\n-    fn lock<U>(&self, blk: &fn() -> U) -> U { (&self.sem).access(blk) }\n+    pub fn lock<U>(&self, blk: &fn() -> U) -> U { (&self.sem).access(blk) }\n \n     /// Run a function with ownership of the mutex and a handle to a condvar.\n-    fn lock_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n+    pub fn lock_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n         (&self.sem).access_cond(blk)\n     }\n }\n@@ -430,8 +472,23 @@ pub impl Mutex {\n \n #[doc(hidden)]\n struct RWlockInner {\n+    // You might ask, \"Why don't you need to use an atomic for the mode flag?\"\n+    // This flag affects the behaviour of readers (for plain readers, they\n+    // assert on it; for downgraders, they use it to decide which mode to\n+    // unlock for). Consider that the flag is only unset when the very last\n+    // reader exits; therefore, it can never be unset during a reader/reader\n+    // (or reader/downgrader) race.\n+    // By the way, if we didn't care about the assert in the read unlock path,\n+    // we could instead store the mode flag in write_downgrade's stack frame,\n+    // and have the downgrade tokens store a borrowed pointer to it.\n     read_mode:  bool,\n-    read_count: uint\n+    // The only way the count flag is ever accessed is with xadd. Since it is\n+    // a read-modify-write operation, multiple xadds on different cores will\n+    // always be consistent with respect to each other, so a monotonic/relaxed\n+    // consistency ordering suffices (i.e., no extra barriers are needed).\n+    // FIXME(#6598): The atomics module has no relaxed ordering flag, so I use\n+    // acquire/release orderings superfluously. Change these someday.\n+    read_count: atomics::AtomicUint,\n }\n \n /**\n@@ -444,7 +501,7 @@ struct RWlockInner {\n pub struct RWlock {\n     priv order_lock:  Semaphore,\n     priv access_lock: Sem<~[Waitqueue]>,\n-    priv state:       Exclusive<RWlockInner>\n+    priv state:       UnsafeAtomicRcBox<RWlockInner>,\n }\n \n /// Create a new rwlock, with one associated condvar.\n@@ -455,15 +512,18 @@ pub fn RWlock() -> RWlock { rwlock_with_condvars(1) }\n  * Similar to mutex_with_condvars.\n  */\n pub fn rwlock_with_condvars(num_condvars: uint) -> RWlock {\n-    RWlock { order_lock: semaphore(1),\n+    let state = UnsafeAtomicRcBox::new(RWlockInner {\n+        read_mode:  false,\n+        read_count: atomics::AtomicUint::new(0),\n+    });\n+    RWlock { order_lock:  semaphore(1),\n              access_lock: new_sem_and_signal(1, num_condvars),\n-             state: exclusive(RWlockInner { read_mode:  false,\n-                                             read_count: 0 }) }\n+             state:       state, }\n }\n \n-pub impl RWlock {\n+impl RWlock {\n     /// Create a new handle to the rwlock.\n-    fn clone(&self) -> RWlock {\n+    pub fn clone(&self) -> RWlock {\n         RWlock { order_lock:  (&(self.order_lock)).clone(),\n                  access_lock: Sem((*self.access_lock).clone()),\n                  state:       self.state.clone() }\n@@ -473,25 +533,16 @@ pub impl RWlock {\n      * Run a function with the rwlock in read mode. Calls to 'read' from other\n      * tasks may run concurrently with this one.\n      */\n-    fn read<U>(&self, blk: &fn() -> U) -> U {\n+    pub fn read<U>(&self, blk: &fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n                 do (&self.order_lock).access {\n-                    let mut first_reader = false;\n-                    do self.state.with |state| {\n-                        first_reader = (state.read_count == 0);\n-                        state.read_count += 1;\n-                    }\n-                    if first_reader {\n+                    let state = &mut *self.state.get();\n+                    let old_count = state.read_count.fetch_add(1, atomics::Acquire);\n+                    if old_count == 0 {\n                         (&self.access_lock).acquire();\n-                        do self.state.with |state| {\n-                            // Must happen *after* getting access_lock. If\n-                            // this is set while readers are waiting, but\n-                            // while a writer holds the lock, the writer will\n-                            // be confused if they downgrade-then-unlock.\n-                            state.read_mode = true;\n-                        }\n+                        state.read_mode = true;\n                     }\n                 }\n                 release = Some(RWlockReleaseRead(self));\n@@ -504,7 +555,7 @@ pub impl RWlock {\n      * Run a function with the rwlock in write mode. No calls to 'read' or\n      * 'write' from other tasks will run concurrently with this one.\n      */\n-    fn write<U>(&self, blk: &fn() -> U) -> U {\n+    pub fn write<U>(&self, blk: &fn() -> U) -> U {\n         unsafe {\n             do task::unkillable {\n                 (&self.order_lock).acquire();\n@@ -522,18 +573,42 @@ pub impl RWlock {\n      * the waiting task is signalled. (Note: a writer that waited and then\n      * was signalled might reacquire the lock before other waiting writers.)\n      */\n-    fn write_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n-        // NB: You might think I should thread the order_lock into the cond\n-        // wait call, so that it gets waited on before access_lock gets\n-        // reacquired upon being woken up. However, (a) this would be not\n-        // pleasant to implement (and would mandate a new 'rw_cond' type) and\n-        // (b) I think violating no-starvation in that case is appropriate.\n+    pub fn write_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n+        // It's important to thread our order lock into the condvar, so that\n+        // when a cond.wait() wakes up, it uses it while reacquiring the\n+        // access lock. If we permitted a waking-up writer to \"cut in line\",\n+        // there could arise a subtle race when a downgrader attempts to hand\n+        // off the reader cloud lock to a waiting reader. This race is tested\n+        // in arc.rs (test_rw_write_cond_downgrade_read_race) and looks like:\n+        // T1 (writer)              T2 (downgrader)             T3 (reader)\n+        // [in cond.wait()]\n+        //                          [locks for writing]\n+        //                          [holds access_lock]\n+        // [is signalled, perhaps by\n+        //  downgrader or a 4th thread]\n+        // tries to lock access(!)\n+        //                                                      lock order_lock\n+        //                                                      xadd read_count[0->1]\n+        //                                                      tries to lock access\n+        //                          [downgrade]\n+        //                          xadd read_count[1->2]\n+        //                          unlock access\n+        // Since T1 contended on the access lock before T3 did, it will steal\n+        // the lock handoff. Adding order_lock in the condvar reacquire path\n+        // solves this because T1 will hold order_lock while waiting on access,\n+        // which will cause T3 to have to wait until T1 finishes its write,\n+        // which can't happen until T2 finishes the downgrade-read entirely.\n+        // The astute reader will also note that making waking writers use the\n+        // order_lock is better for not starving readers.\n         unsafe {\n             do task::unkillable {\n                 (&self.order_lock).acquire();\n                 do (&self.access_lock).access_cond |cond| {\n                     (&self.order_lock).release();\n-                    do task::rekillable { blk(cond) }\n+                    do task::rekillable {\n+                        let opt_lock = Just(&self.order_lock);\n+                        blk(&Condvar { order: opt_lock, ..*cond })\n+                    }\n                 }\n             }\n         }\n@@ -549,18 +624,18 @@ pub impl RWlock {\n      * # Example\n      *\n      * ~~~ {.rust}\n-     * do lock.write_downgrade |write_mode| {\n-     *     do (&write_mode).write_cond |condvar| {\n+     * do lock.write_downgrade |mut write_token| {\n+     *     do write_token.write_cond |condvar| {\n      *         ... exclusive access ...\n      *     }\n-     *     let read_mode = lock.downgrade(write_mode);\n-     *     do (&read_mode).read {\n+     *     let read_token = lock.downgrade(write_token);\n+     *     do read_token.read {\n      *         ... shared access ...\n      *     }\n      * }\n      * ~~~\n      */\n-    fn write_downgrade<U>(&self, blk: &fn(v: RWlockWriteMode) -> U) -> U {\n+    pub fn write_downgrade<U>(&self, blk: &fn(v: RWlockWriteMode) -> U) -> U {\n         // Implementation slightly different from the slicker 'write's above.\n         // The exit path is conditional on whether the caller downgrades.\n         let mut _release = None;\n@@ -576,26 +651,27 @@ pub impl RWlock {\n     }\n \n     /// To be called inside of the write_downgrade block.\n-    fn downgrade<'a>(&self,\n-                     token: RWlockWriteMode<'a>)\n-                  -> RWlockReadMode<'a> {\n-        if !ptr::ref_eq(self, token.lock) {\n+    pub fn downgrade<'a>(&self, token: RWlockWriteMode<'a>)\n+                         -> RWlockReadMode<'a> {\n+        if !borrow::ref_eq(self, token.lock) {\n             fail!(\"Can't downgrade() with a different rwlock's write_mode!\");\n         }\n         unsafe {\n             do task::unkillable {\n-                let mut first_reader = false;\n-                do self.state.with |state| {\n-                    assert!(!state.read_mode);\n-                    state.read_mode = true;\n-                    first_reader = (state.read_count == 0);\n-                    state.read_count += 1;\n-                }\n-                if !first_reader {\n+                let state = &mut *self.state.get();\n+                assert!(!state.read_mode);\n+                state.read_mode = true;\n+                // If a reader attempts to enter at this point, both the\n+                // downgrader and reader will set the mode flag. This is fine.\n+                let old_count = state.read_count.fetch_add(1, atomics::Release);\n+                // If another reader was already blocking, we need to hand-off\n+                // the \"reader cloud\" access lock to them.\n+                if old_count != 0 {\n                     // Guaranteed not to let another writer in, because\n                     // another reader was holding the order_lock. Hence they\n                     // must be the one to get the access_lock (because all\n-                    // access_locks are acquired with order_lock held).\n+                    // access_locks are acquired with order_lock held). See\n+                    // the comment in write_cond for more justification.\n                     (&self.access_lock).release();\n                 }\n             }\n@@ -610,29 +686,30 @@ struct RWlockReleaseRead<'self> {\n     lock: &'self RWlock,\n }\n \n+#[doc(hidden)]\n #[unsafe_destructor]\n impl<'self> Drop for RWlockReleaseRead<'self> {\n     fn finalize(&self) {\n         unsafe {\n             do task::unkillable {\n-                let mut last_reader = false;\n-                do self.lock.state.with |state| {\n-                    assert!(state.read_mode);\n-                    assert!(state.read_count > 0);\n-                    state.read_count -= 1;\n-                    if state.read_count == 0 {\n-                        last_reader = true;\n-                        state.read_mode = false;\n-                    }\n-                }\n-                if last_reader {\n+                let state = &mut *self.lock.state.get();\n+                assert!(state.read_mode);\n+                let old_count = state.read_count.fetch_sub(1, atomics::Release);\n+                assert!(old_count > 0);\n+                if old_count == 1 {\n+                    state.read_mode = false;\n+                    // Note: this release used to be outside of a locked access\n+                    // to exclusive-protected state. If this code is ever\n+                    // converted back to such (instead of using atomic ops),\n+                    // this access MUST NOT go inside the exclusive access.\n                     (&self.lock.access_lock).release();\n                 }\n             }\n         }\n     }\n }\n \n+#[doc(hidden)]\n fn RWlockReleaseRead<'r>(lock: &'r RWlock) -> RWlockReleaseRead<'r> {\n     RWlockReleaseRead {\n         lock: lock\n@@ -646,37 +723,42 @@ struct RWlockReleaseDowngrade<'self> {\n     lock: &'self RWlock,\n }\n \n+#[doc(hidden)]\n #[unsafe_destructor]\n impl<'self> Drop for RWlockReleaseDowngrade<'self> {\n     fn finalize(&self) {\n         unsafe {\n             do task::unkillable {\n-                let mut writer_or_last_reader = false;\n-                do self.lock.state.with |state| {\n-                    if state.read_mode {\n-                        assert!(state.read_count > 0);\n-                        state.read_count -= 1;\n-                        if state.read_count == 0 {\n-                            // Case 1: Writer downgraded & was the last reader\n-                            writer_or_last_reader = true;\n-                            state.read_mode = false;\n-                        } else {\n-                            // Case 2: Writer downgraded & was not the last\n-                            // reader\n-                        }\n-                    } else {\n-                        // Case 3: Writer did not downgrade\n+                let writer_or_last_reader;\n+                // Check if we're releasing from read mode or from write mode.\n+                let state = &mut *self.lock.state.get();\n+                if state.read_mode {\n+                    // Releasing from read mode.\n+                    let old_count = state.read_count.fetch_sub(1, atomics::Release);\n+                    assert!(old_count > 0);\n+                    // Check if other readers remain.\n+                    if old_count == 1 {\n+                        // Case 1: Writer downgraded & was the last reader\n                         writer_or_last_reader = true;\n+                        state.read_mode = false;\n+                    } else {\n+                        // Case 2: Writer downgraded & was not the last reader\n+                        writer_or_last_reader = false;\n                     }\n+                } else {\n+                    // Case 3: Writer did not downgrade\n+                    writer_or_last_reader = true;\n                 }\n                 if writer_or_last_reader {\n+                    // Nobody left inside; release the \"reader cloud\" lock.\n                     (&self.lock.access_lock).release();\n                 }\n             }\n         }\n     }\n }\n \n+#[doc(hidden)]\n fn RWlockReleaseDowngrade<'r>(lock: &'r RWlock)\n                            -> RWlockReleaseDowngrade<'r> {\n     RWlockReleaseDowngrade {\n@@ -694,18 +776,21 @@ pub struct RWlockReadMode<'self> { priv lock: &'self RWlock }\n #[unsafe_destructor]\n impl<'self> Drop for RWlockReadMode<'self> { fn finalize(&self) {} }\n \n-pub impl<'self> RWlockWriteMode<'self> {\n+impl<'self> RWlockWriteMode<'self> {\n     /// Access the pre-downgrade rwlock in write mode.\n-    fn write<U>(&self, blk: &fn() -> U) -> U { blk() }\n+    pub fn write<U>(&self, blk: &fn() -> U) -> U { blk() }\n     /// Access the pre-downgrade rwlock in write mode with a condvar.\n-    fn write_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n-        blk(&Condvar { sem: &self.lock.access_lock })\n+    pub fn write_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n+        // Need to make the condvar use the order lock when reacquiring the\n+        // access lock. See comment in RWlock::write_cond for why.\n+        blk(&Condvar { sem:        &self.lock.access_lock,\n+                       order: Just(&self.lock.order_lock), })\n     }\n }\n \n-pub impl<'self> RWlockReadMode<'self> {\n+impl<'self> RWlockReadMode<'self> {\n     /// Access the post-downgrade rwlock in read mode.\n-    fn read<U>(&self, blk: &fn() -> U) -> U { blk() }\n+    pub fn read<U>(&self, blk: &fn() -> U) -> U { blk() }\n }\n \n /****************************************************************************\n@@ -720,6 +805,7 @@ mod tests {\n \n     use core::cast;\n     use core::cell::Cell;\n+    use core::comm;\n     use core::result;\n     use core::task;\n     use core::vec;\n@@ -805,7 +891,7 @@ mod tests {\n             let s = ~semaphore(1);\n             let s2 = ~s.clone();\n             let (p,c) = comm::stream();\n-            let child_data = Cell((s2, c));\n+            let child_data = Cell::new((s2, c));\n             do s.access {\n                 let (s2, c) = child_data.take();\n                 do task::spawn || {\n@@ -986,7 +1072,7 @@ mod tests {\n             let mut sibling_convos = ~[];\n             for 2.times {\n                 let (p,c) = comm::stream();\n-                let c = Cell(c);\n+                let c = Cell::new(c);\n                 sibling_convos.push(p);\n                 let mi = ~m2.clone();\n                 // spawn sibling task"}, {"sha": "b88bbff2a6668fa127ac5d6efdfe91a1dbac8cb7", "filename": "src/libextra/task_pool.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftask_pool.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -8,12 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(missing_doc)];\n+\n /// A task pool abstraction. Useful for achieving predictable CPU\n /// parallelism.\n \n use core::prelude::*;\n \n use core::comm::Chan;\n+use core::comm;\n use core::task::SchedMode;\n use core::task;\n use core::vec;\n@@ -39,16 +42,16 @@ impl<T> Drop for TaskPool<T> {\n     }\n }\n \n-pub impl<T> TaskPool<T> {\n+impl<T> TaskPool<T> {\n     /// Spawns a new task pool with `n_tasks` tasks. If the `sched_mode`\n     /// is None, the tasks run on this scheduler; otherwise, they run on a\n     /// new scheduler with the given mode. The provided `init_fn_factory`\n     /// returns a function which, given the index of the task, should return\n     /// local data to be kept around in that task.\n-    fn new(n_tasks: uint,\n-           opt_sched_mode: Option<SchedMode>,\n-           init_fn_factory: ~fn() -> ~fn(uint) -> T)\n-        -> TaskPool<T> {\n+    pub fn new(n_tasks: uint,\n+               opt_sched_mode: Option<SchedMode>,\n+               init_fn_factory: ~fn() -> ~fn(uint) -> T)\n+               -> TaskPool<T> {\n         assert!(n_tasks >= 1);\n \n         let channels = do vec::from_fn(n_tasks) |i| {\n@@ -86,7 +89,7 @@ pub impl<T> TaskPool<T> {\n \n     /// Executes the function `f` on a task in the pool. The function\n     /// receives a reference to the local data returned by the `init_fn`.\n-    fn execute(&mut self, f: ~fn(&T)) {\n+    pub fn execute(&mut self, f: ~fn(&T)) {\n         self.channels[self.next_index].send(Execute(f));\n         self.next_index += 1;\n         if self.next_index == self.channels.len() { self.next_index = 0; }\n@@ -101,6 +104,6 @@ fn test_task_pool() {\n     };\n     let mut pool = TaskPool::new(4, Some(SingleThreaded), f);\n     for 8.times {\n-        pool.execute(|i| io::println(fmt!(\"Hello from thread %u!\", *i)));\n+        pool.execute(|i| println(fmt!(\"Hello from thread %u!\", *i)));\n     }\n }"}, {"sha": "c239e65e2d9a9a931a376b33f21526169ed98895", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -12,8 +12,12 @@\n \n use core::prelude::*;\n \n+use core::os;\n use core::rand::RngUtil;\n+use core::rand;\n \n+/// Attempts to make a temporary directory inside of `tmpdir` whose name will\n+/// have the suffix `suffix`. If no directory can be created, None is returned.\n pub fn mkdtemp(tmpdir: &Path, suffix: &str) -> Option<Path> {\n     let mut r = rand::rng();\n     for 1000.times {\n@@ -30,13 +34,15 @@ mod tests {\n     use core::prelude::*;\n \n     use tempfile::mkdtemp;\n+\n     use core::os;\n+    use core::str;\n \n     #[test]\n     fn test_mkdtemp() {\n         let p = mkdtemp(&Path(\".\"), \"foobar\").unwrap();\n         os::remove_dir(&p);\n-        assert!(str::ends_with(p.to_str(), \"foobar\"));\n+        assert!(p.to_str().ends_with(\"foobar\"));\n     }\n \n     // Ideally these would be in core::os but then core would need"}, {"sha": "17d80ded47f81b09825d5aa95e8e538911e56709", "filename": "src/libextra/term.rs", "status": "modified", "additions": 87, "deletions": 33, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,12 +10,18 @@\n \n //! Simple ANSI color library\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n use core::io;\n-use core::option;\n use core::os;\n \n+use terminfo::*;\n+use terminfo::searcher::open;\n+use terminfo::parser::compiled::parse;\n+use terminfo::parm::{expand, Number, Variables};\n+\n // FIXME (#2807): Windows support.\n \n pub static color_black: u8 = 0u8;\n@@ -37,43 +43,91 @@ pub static color_bright_magenta: u8 = 13u8;\n pub static color_bright_cyan: u8 = 14u8;\n pub static color_bright_white: u8 = 15u8;\n \n-pub fn esc(writer: @io::Writer) { writer.write([0x1bu8, '[' as u8]); }\n+#[cfg(not(target_os = \"win32\"))]\n+pub struct Terminal {\n+    color_supported: bool,\n+    priv out: @io::Writer,\n+    priv ti: ~TermInfo\n+}\n \n-/// Reset the foreground and background colors to default\n-pub fn reset(writer: @io::Writer) {\n-    esc(writer);\n-    writer.write(['0' as u8, 'm' as u8]);\n+#[cfg(target_os = \"win32\")]\n+pub struct Terminal {\n+    color_supported: bool,\n+    priv out: @io::Writer,\n }\n \n-/// Returns true if the terminal supports color\n-pub fn color_supported() -> bool {\n-    let supported_terms = ~[~\"xterm-color\", ~\"xterm\",\n-                           ~\"screen-bce\", ~\"xterm-256color\"];\n-    return match os::getenv(\"TERM\") {\n-          option::Some(ref env) => {\n-            for supported_terms.each |term| {\n-                if *term == *env { return true; }\n+#[cfg(not(target_os = \"win32\"))]\n+impl Terminal {\n+    pub fn new(out: @io::Writer) -> Result<Terminal, ~str> {\n+        let term = os::getenv(\"TERM\");\n+        if term.is_none() {\n+            return Err(~\"TERM environment variable undefined\");\n+        }\n+\n+        let entry = open(term.unwrap());\n+        if entry.is_err() {\n+            return Err(entry.get_err());\n+        }\n+\n+        let ti = parse(entry.get(), false);\n+        if ti.is_err() {\n+            return Err(entry.get_err());\n+        }\n+\n+        let mut inf = ti.get();\n+        let cs = *inf.numbers.find_or_insert(~\"colors\", 0) >= 16\n+            && inf.strings.find(&~\"setaf\").is_some()\n+            && inf.strings.find_equiv(&(\"setab\")).is_some();\n+\n+        return Ok(Terminal {out: out, ti: inf, color_supported: cs});\n+    }\n+    pub fn fg(&self, color: u8) {\n+        if self.color_supported {\n+            let s = expand(*self.ti.strings.find_equiv(&(\"setaf\")).unwrap(),\n+                           [Number(color as int)], &mut Variables::new());\n+            if s.is_ok() {\n+                self.out.write(s.get());\n+            } else {\n+                warn!(s.get_err());\n+            }\n+        }\n+    }\n+    pub fn bg(&self, color: u8) {\n+        if self.color_supported {\n+            let s = expand(*self.ti.strings.find_equiv(&(\"setab\")).unwrap(),\n+                           [Number(color as int)], &mut Variables::new());\n+            if s.is_ok() {\n+                self.out.write(s.get());\n+            } else {\n+                warn!(s.get_err());\n+            }\n+        }\n+    }\n+    pub fn reset(&self) {\n+        if self.color_supported {\n+            let mut vars = Variables::new();\n+            let s = expand(*self.ti.strings.find_equiv(&(\"op\")).unwrap(), [], &mut vars);\n+            if s.is_ok() {\n+                self.out.write(s.get());\n+            } else {\n+                warn!(s.get_err());\n             }\n-            false\n-          }\n-          option::None => false\n-        };\n+        }\n+    }\n }\n \n-pub fn set_color(writer: @io::Writer, first_char: u8, color: u8) {\n-    assert!((color < 16u8));\n-    esc(writer);\n-    let mut color = color;\n-    if color >= 8u8 { writer.write(['1' as u8, ';' as u8]); color -= 8u8; }\n-    writer.write([first_char, ('0' as u8) + color, 'm' as u8]);\n-}\n+#[cfg(target_os = \"win32\")]\n+impl Terminal {\n+    pub fn new(out: @io::Writer) -> Result<Terminal, ~str> {\n+        return Ok(Terminal {out: out, color_supported: false});\n+    }\n \n-/// Set the foreground color\n-pub fn fg(writer: @io::Writer, color: u8) {\n-    return set_color(writer, '3' as u8, color);\n-}\n+    pub fn fg(&self, color: u8) {\n+    }\n+\n+    pub fn bg(&self, color: u8) {\n+    }\n \n-/// Set the background color\n-pub fn bg(writer: @io::Writer, color: u8) {\n-    return set_color(writer, '4' as u8, color);\n+    pub fn reset(&self) {\n+    }\n }"}, {"sha": "c395b57219c2c8da77f7a3e25862f3d2044c9578", "filename": "src/libextra/terminfo/parm.rs", "status": "added", "additions": 435, "deletions": 0, "changes": 435, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -0,0 +1,435 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Parameterized string expansion\n+\n+use core::prelude::*;\n+use core::{char, int, vec};\n+use core::iterator::IteratorUtil;\n+\n+#[deriving(Eq)]\n+enum States {\n+    Nothing,\n+    Percent,\n+    SetVar,\n+    GetVar,\n+    PushParam,\n+    CharConstant,\n+    CharClose,\n+    IntConstant,\n+    SeekIfElse(int),\n+    SeekIfElsePercent(int),\n+    SeekIfEnd(int),\n+    SeekIfEndPercent(int)\n+}\n+\n+/// Types of parameters a capability can use\n+pub enum Param {\n+    String(~str),\n+    Number(int)\n+}\n+\n+/// Container for static and dynamic variable arrays\n+pub struct Variables {\n+    /// Static variables A-Z\n+    sta: [Param, ..26],\n+    /// Dynamic variables a-z\n+    dyn: [Param, ..26]\n+}\n+\n+impl Variables {\n+    /// Return a new zero-initialized Variables\n+    pub fn new() -> Variables {\n+        Variables{ sta: [Number(0), ..26], dyn: [Number(0), ..26] }\n+    }\n+}\n+\n+/**\n+  Expand a parameterized capability\n+\n+  # Arguments\n+  * `cap`    - string to expand\n+  * `params` - vector of params for %p1 etc\n+  * `vars`   - Variables struct for %Pa etc\n+\n+  To be compatible with ncurses, `vars` should be the same between calls to `expand` for\n+  multiple capabilities for the same terminal.\n+  */\n+pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n+    -> Result<~[u8], ~str> {\n+    let mut state = Nothing;\n+\n+    // expanded cap will only rarely be larger than the cap itself\n+    let mut output = vec::with_capacity(cap.len());\n+\n+    let mut stack: ~[Param] = ~[];\n+\n+    let mut intstate = ~[];\n+\n+    // Copy parameters into a local vector for mutability\n+    let mut mparams = [Number(0), ..9];\n+    for mparams.mut_iter().zip(params.iter()).advance |(dst, &src)| {\n+        *dst = src;\n+    }\n+\n+    for cap.iter().transform(|&x| x).advance |c| {\n+        let cur = c as char;\n+        let mut old_state = state;\n+        match state {\n+            Nothing => {\n+                if cur == '%' {\n+                    state = Percent;\n+                } else {\n+                    output.push(c);\n+                }\n+            },\n+            Percent => {\n+                match cur {\n+                    '%' => { output.push(c); state = Nothing },\n+                    'c' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            // if c is 0, use 0200 (128) for ncurses compatibility\n+                            Number(c) => output.push(if c == 0 { 128 } else { c } as u8),\n+                            _       => return Err(~\"a non-char was used with %c\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    's' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            String(s) => output.push_all(s.as_bytes()),\n+                            _         => return Err(~\"a non-str was used with %s\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'd' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            Number(x) => {\n+                                let s = x.to_str();\n+                                output.push_all(s.as_bytes())\n+                            }\n+                            _         => return Err(~\"a non-number was used with %d\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'p' => state = PushParam,\n+                    'P' => state = SetVar,\n+                    'g' => state = GetVar,\n+                    '\\'' => state = CharConstant,\n+                    '{' => state = IntConstant,\n+                    'l' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            String(s) => stack.push(Number(s.len() as int)),\n+                            _         => return Err(~\"a non-str was used with %l\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '+' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x + y)),\n+                            _ => return Err(~\"non-numbers on stack with +\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '-' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x - y)),\n+                            _ => return Err(~\"non-numbers on stack with -\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '*' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x * y)),\n+                            _ => return Err(~\"non-numbers on stack with *\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '/' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x / y)),\n+                            _ => return Err(~\"non-numbers on stack with /\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'm' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x % y)),\n+                            _ => return Err(~\"non-numbers on stack with %\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '&' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x & y)),\n+                            _ => return Err(~\"non-numbers on stack with &\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '|' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x | y)),\n+                            _ => return Err(~\"non-numbers on stack with |\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '^' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x ^ y)),\n+                            _ => return Err(~\"non-numbers on stack with ^\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '=' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(if x == y { 1 }\n+                                                                        else { 0 })),\n+                            _ => return Err(~\"non-numbers on stack with =\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '>' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(if x > y { 1 }\n+                                                                        else { 0 })),\n+                            _ => return Err(~\"non-numbers on stack with >\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '<' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(if x < y { 1 }\n+                                                                        else { 0 })),\n+                            _ => return Err(~\"non-numbers on stack with <\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'A' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(0), Number(_)) => stack.push(Number(0)),\n+                            (Number(_), Number(0)) => stack.push(Number(0)),\n+                            (Number(_), Number(_)) => stack.push(Number(1)),\n+                            _ => return Err(~\"non-numbers on stack with logical and\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'O' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(0), Number(0)) => stack.push(Number(0)),\n+                            (Number(_), Number(_)) => stack.push(Number(1)),\n+                            _ => return Err(~\"non-numbers on stack with logical or\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '!' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            Number(0) => stack.push(Number(1)),\n+                            Number(_) => stack.push(Number(0)),\n+                            _ => return Err(~\"non-number on stack with logical not\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '~' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            Number(x) => stack.push(Number(!x)),\n+                            _         => return Err(~\"non-number on stack with %~\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'i' => match (copy mparams[0], copy mparams[1]) {\n+                        (Number(ref mut x), Number(ref mut y)) => {\n+                            *x += 1;\n+                            *y += 1;\n+                        },\n+                        (_, _) => return Err(~\"first two params not numbers with %i\")\n+                    },\n+\n+                    // conditionals\n+                    '?' => (),\n+                    't' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            Number(0) => state = SeekIfElse(0),\n+                            Number(_) => (),\n+                            _         => return Err(~\"non-number on stack with conditional\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'e' => state = SeekIfEnd(0),\n+                    ';' => (),\n+\n+                    _ => return Err(fmt!(\"unrecognized format option %c\", cur))\n+                }\n+            },\n+            PushParam => {\n+                // params are 1-indexed\n+                stack.push(copy mparams[match char::to_digit(cur, 10) {\n+                    Some(d) => d - 1,\n+                    None => return Err(~\"bad param number\")\n+                }]);\n+            },\n+            SetVar => {\n+                if cur >= 'A' && cur <= 'Z' {\n+                    if stack.len() > 0 {\n+                        let idx = (cur as u8) - ('A' as u8);\n+                        vars.sta[idx] = stack.pop();\n+                    } else { return Err(~\"stack is empty\") }\n+                } else if cur >= 'a' && cur <= 'z' {\n+                    if stack.len() > 0 {\n+                        let idx = (cur as u8) - ('a' as u8);\n+                        vars.dyn[idx] = stack.pop();\n+                    } else { return Err(~\"stack is empty\") }\n+                } else {\n+                    return Err(~\"bad variable name in %P\");\n+                }\n+            },\n+            GetVar => {\n+                if cur >= 'A' && cur <= 'Z' {\n+                    let idx = (cur as u8) - ('A' as u8);\n+                    stack.push(copy vars.sta[idx]);\n+                } else if cur >= 'a' && cur <= 'z' {\n+                    let idx = (cur as u8) - ('a' as u8);\n+                    stack.push(copy vars.dyn[idx]);\n+                } else {\n+                    return Err(~\"bad variable name in %g\");\n+                }\n+            },\n+            CharConstant => {\n+                stack.push(Number(c as int));\n+                state = CharClose;\n+            },\n+            CharClose => {\n+                if cur != '\\'' {\n+                    return Err(~\"malformed character constant\");\n+                }\n+            },\n+            IntConstant => {\n+                if cur == '}' {\n+                    stack.push(match int::parse_bytes(intstate, 10) {\n+                        Some(n) => Number(n),\n+                        None => return Err(~\"bad int constant\")\n+                    });\n+                    intstate.clear();\n+                    state = Nothing;\n+                } else {\n+                    intstate.push(cur as u8);\n+                    old_state = Nothing;\n+                }\n+            }\n+            SeekIfElse(level) => {\n+                if cur == '%' {\n+                    state = SeekIfElsePercent(level);\n+                }\n+                old_state = Nothing;\n+            }\n+            SeekIfElsePercent(level) => {\n+                if cur == ';' {\n+                    if level == 0 {\n+                        state = Nothing;\n+                    } else {\n+                        state = SeekIfElse(level-1);\n+                    }\n+                } else if cur == 'e' && level == 0 {\n+                    state = Nothing;\n+                } else if cur == '?' {\n+                    state = SeekIfElse(level+1);\n+                } else {\n+                    state = SeekIfElse(level);\n+                }\n+            }\n+            SeekIfEnd(level) => {\n+                if cur == '%' {\n+                    state = SeekIfEndPercent(level);\n+                }\n+                old_state = Nothing;\n+            }\n+            SeekIfEndPercent(level) => {\n+                if cur == ';' {\n+                    if level == 0 {\n+                        state = Nothing;\n+                    } else {\n+                        state = SeekIfEnd(level-1);\n+                    }\n+                } else if cur == '?' {\n+                    state = SeekIfEnd(level+1);\n+                } else {\n+                    state = SeekIfEnd(level);\n+                }\n+            }\n+        }\n+        if state == old_state {\n+            state = Nothing;\n+        }\n+    }\n+    Ok(output)\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test]\n+    fn test_basic_setabf() {\n+        let s = bytes!(\"\\\\E[48;5;%p1%dm\");\n+        assert_eq!(expand(s, [Number(1)], &mut Variables::new()).unwrap(),\n+                   bytes!(\"\\\\E[48;5;1m\").to_owned());\n+    }\n+\n+    #[test]\n+    fn test_multiple_int_constants() {\n+        assert_eq!(expand(bytes!(\"%{1}%{2}%d%d\"), [], &mut Variables::new()).unwrap(),\n+                   bytes!(\"21\").to_owned());\n+    }\n+\n+    #[test]\n+    fn test_param_stack_failure_conditions() {\n+        let mut varstruct = Variables::new();\n+        let vars = &mut varstruct;\n+        let caps = [\"%d\", \"%c\", \"%s\", \"%Pa\", \"%l\", \"%!\", \"%~\"];\n+        for caps.iter().advance |cap| {\n+            let res = expand(cap.as_bytes(), [], vars);\n+            assert!(res.is_err(),\n+                    \"Op %s succeeded incorrectly with 0 stack entries\", *cap);\n+            let p = if *cap == \"%s\" || *cap == \"%l\" { String(~\"foo\") } else { Number(97) };\n+            let res = expand((bytes!(\"%p1\")).to_owned() + cap.as_bytes(), [p], vars);\n+            assert!(res.is_ok(),\n+                    \"Op %s failed with 1 stack entry: %s\", *cap, res.unwrap_err());\n+        }\n+        let caps = [\"%+\", \"%-\", \"%*\", \"%/\", \"%m\", \"%&\", \"%|\", \"%A\", \"%O\"];\n+        for caps.iter().advance |cap| {\n+            let res = expand(cap.as_bytes(), [], vars);\n+            assert!(res.is_err(),\n+                    \"Binop %s succeeded incorrectly with 0 stack entries\", *cap);\n+            let res = expand((bytes!(\"%{1}\")).to_owned() + cap.as_bytes(), [], vars);\n+            assert!(res.is_err(),\n+                    \"Binop %s succeeded incorrectly with 1 stack entry\", *cap);\n+            let res = expand((bytes!(\"%{1}%{2}\")).to_owned() + cap.as_bytes(), [], vars);\n+            assert!(res.is_ok(),\n+                    \"Binop %s failed with 2 stack entries: %s\", *cap, res.unwrap_err());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_push_bad_param() {\n+        assert!(expand(bytes!(\"%pa\"), [], &mut Variables::new()).is_err());\n+    }\n+\n+    #[test]\n+    fn test_comparison_ops() {\n+        let v = [('<', [1u8, 0u8, 0u8]), ('=', [0u8, 1u8, 0u8]), ('>', [0u8, 0u8, 1u8])];\n+        for v.iter().advance |&(op, bs)| {\n+            let s = fmt!(\"%%{1}%%{2}%%%c%%d\", op);\n+            let res = expand(s.as_bytes(), [], &mut Variables::new());\n+            assert!(res.is_ok(), res.unwrap_err());\n+            assert_eq!(res.unwrap(), ~['0' as u8 + bs[0]]);\n+            let s = fmt!(\"%%{1}%%{1}%%%c%%d\", op);\n+            let res = expand(s.as_bytes(), [], &mut Variables::new());\n+            assert!(res.is_ok(), res.unwrap_err());\n+            assert_eq!(res.unwrap(), ~['0' as u8 + bs[1]]);\n+            let s = fmt!(\"%%{2}%%{1}%%%c%%d\", op);\n+            let res = expand(s.as_bytes(), [], &mut Variables::new());\n+            assert!(res.is_ok(), res.unwrap_err());\n+            assert_eq!(res.unwrap(), ~['0' as u8 + bs[2]]);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_conditionals() {\n+        let mut vars = Variables::new();\n+        let s = bytes!(\"\\\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m\");\n+        let res = expand(s, [Number(1)], &mut vars);\n+        assert!(res.is_ok(), res.unwrap_err());\n+        assert_eq!(res.unwrap(), bytes!(\"\\\\E[31m\").to_owned());\n+        let res = expand(s, [Number(8)], &mut vars);\n+        assert!(res.is_ok(), res.unwrap_err());\n+        assert_eq!(res.unwrap(), bytes!(\"\\\\E[90m\").to_owned());\n+        let res = expand(s, [Number(42)], &mut vars);\n+        assert!(res.is_ok(), res.unwrap_err());\n+        assert_eq!(res.unwrap(), bytes!(\"\\\\E[38;5;42m\").to_owned());\n+    }\n+}"}, {"sha": "81b6083db01475d8aaacf51ef2538bb1280a54df", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "added", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -0,0 +1,331 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// ncurses-compatible compiled terminfo format parsing (term(5))\n+\n+use core::prelude::*;\n+\n+use core::{vec, int, str};\n+use core::io::Reader;\n+use core::hashmap::HashMap;\n+use super::super::TermInfo;\n+\n+// These are the orders ncurses uses in its compiled format (as of 5.9). Not sure if portable.\n+\n+pub static boolfnames: &'static[&'static str] = &'static[\"auto_left_margin\", \"auto_right_margin\",\n+    \"no_esc_ctlc\", \"ceol_standout_glitch\", \"eat_newline_glitch\", \"erase_overstrike\", \"generic_type\",\n+    \"hard_copy\", \"has_meta_key\", \"has_status_line\", \"insert_null_glitch\", \"memory_above\",\n+    \"memory_below\", \"move_insert_mode\", \"move_standout_mode\", \"over_strike\", \"status_line_esc_ok\",\n+    \"dest_tabs_magic_smso\", \"tilde_glitch\", \"transparent_underline\", \"xon_xoff\", \"needs_xon_xoff\",\n+    \"prtr_silent\", \"hard_cursor\", \"non_rev_rmcup\", \"no_pad_char\", \"non_dest_scroll_region\",\n+    \"can_change\", \"back_color_erase\", \"hue_lightness_saturation\", \"col_addr_glitch\",\n+    \"cr_cancels_micro_mode\", \"has_print_wheel\", \"row_addr_glitch\", \"semi_auto_right_margin\",\n+    \"cpi_changes_res\", \"lpi_changes_res\", \"backspaces_with_bs\", \"crt_no_scrolling\",\n+    \"no_correctly_working_cr\", \"gnu_has_meta_key\", \"linefeed_is_newline\", \"has_hardware_tabs\",\n+    \"return_does_clr_eol\"];\n+\n+pub static boolnames: &'static[&'static str] = &'static[\"bw\", \"am\", \"xsb\", \"xhp\", \"xenl\", \"eo\",\n+    \"gn\", \"hc\", \"km\", \"hs\", \"in\", \"db\", \"da\", \"mir\", \"msgr\", \"os\", \"eslok\", \"xt\", \"hz\", \"ul\", \"xon\",\n+    \"nxon\", \"mc5i\", \"chts\", \"nrrmc\", \"npc\", \"ndscr\", \"ccc\", \"bce\", \"hls\", \"xhpa\", \"crxm\", \"daisy\",\n+    \"xvpa\", \"sam\", \"cpix\", \"lpix\", \"OTbs\", \"OTns\", \"OTnc\", \"OTMT\", \"OTNL\", \"OTpt\", \"OTxr\"];\n+\n+pub static numfnames: &'static[&'static str] = &'static[ \"columns\", \"init_tabs\", \"lines\",\n+    \"lines_of_memory\", \"magic_cookie_glitch\", \"padding_baud_rate\", \"virtual_terminal\",\n+    \"width_status_line\", \"num_labels\", \"label_height\", \"label_width\", \"max_attributes\",\n+    \"maximum_windows\", \"max_colors\", \"max_pairs\", \"no_color_video\", \"buffer_capacity\",\n+    \"dot_vert_spacing\", \"dot_horz_spacing\", \"max_micro_address\", \"max_micro_jump\", \"micro_col_size\",\n+    \"micro_line_size\", \"number_of_pins\", \"output_res_char\", \"output_res_line\",\n+    \"output_res_horz_inch\", \"output_res_vert_inch\", \"print_rate\", \"wide_char_size\", \"buttons\",\n+    \"bit_image_entwining\", \"bit_image_type\", \"magic_cookie_glitch_ul\", \"carriage_return_delay\",\n+    \"new_line_delay\", \"backspace_delay\", \"horizontal_tab_delay\", \"number_of_function_keys\"];\n+\n+pub static numnames: &'static[&'static str] = &'static[ \"cols\", \"it\", \"lines\", \"lm\", \"xmc\", \"pb\",\n+    \"vt\", \"wsl\", \"nlab\", \"lh\", \"lw\", \"ma\", \"wnum\", \"colors\", \"pairs\", \"ncv\", \"bufsz\", \"spinv\",\n+    \"spinh\", \"maddr\", \"mjump\", \"mcs\", \"mls\", \"npins\", \"orc\", \"orl\", \"orhi\", \"orvi\", \"cps\", \"widcs\",\n+    \"btns\", \"bitwin\", \"bitype\", \"UTug\", \"OTdC\", \"OTdN\", \"OTdB\", \"OTdT\", \"OTkn\"];\n+\n+pub static stringfnames: &'static[&'static str] = &'static[ \"back_tab\", \"bell\", \"carriage_return\",\n+    \"change_scroll_region\", \"clear_all_tabs\", \"clear_screen\", \"clr_eol\", \"clr_eos\",\n+    \"column_address\", \"command_character\", \"cursor_address\", \"cursor_down\", \"cursor_home\",\n+    \"cursor_invisible\", \"cursor_left\", \"cursor_mem_address\", \"cursor_normal\", \"cursor_right\",\n+    \"cursor_to_ll\", \"cursor_up\", \"cursor_visible\", \"delete_character\", \"delete_line\",\n+    \"dis_status_line\", \"down_half_line\", \"enter_alt_charset_mode\", \"enter_blink_mode\",\n+    \"enter_bold_mode\", \"enter_ca_mode\", \"enter_delete_mode\", \"enter_dim_mode\", \"enter_insert_mode\",\n+    \"enter_secure_mode\", \"enter_protected_mode\", \"enter_reverse_mode\", \"enter_standout_mode\",\n+    \"enter_underline_mode\", \"erase_chars\", \"exit_alt_charset_mode\", \"exit_attribute_mode\",\n+    \"exit_ca_mode\", \"exit_delete_mode\", \"exit_insert_mode\", \"exit_standout_mode\",\n+    \"exit_underline_mode\", \"flash_screen\", \"form_feed\", \"from_status_line\", \"init_1string\",\n+    \"init_2string\", \"init_3string\", \"init_file\", \"insert_character\", \"insert_line\",\n+    \"insert_padding\", \"key_backspace\", \"key_catab\", \"key_clear\", \"key_ctab\", \"key_dc\", \"key_dl\",\n+    \"key_down\", \"key_eic\", \"key_eol\", \"key_eos\", \"key_f0\", \"key_f1\", \"key_f10\", \"key_f2\", \"key_f3\",\n+    \"key_f4\", \"key_f5\", \"key_f6\", \"key_f7\", \"key_f8\", \"key_f9\", \"key_home\", \"key_ic\", \"key_il\",\n+    \"key_left\", \"key_ll\", \"key_npage\", \"key_ppage\", \"key_right\", \"key_sf\", \"key_sr\", \"key_stab\",\n+    \"key_up\", \"keypad_local\", \"keypad_xmit\", \"lab_f0\", \"lab_f1\", \"lab_f10\", \"lab_f2\", \"lab_f3\",\n+    \"lab_f4\", \"lab_f5\", \"lab_f6\", \"lab_f7\", \"lab_f8\", \"lab_f9\", \"meta_off\", \"meta_on\", \"newline\",\n+    \"pad_char\", \"parm_dch\", \"parm_delete_line\", \"parm_down_cursor\", \"parm_ich\", \"parm_index\",\n+    \"parm_insert_line\", \"parm_left_cursor\", \"parm_right_cursor\", \"parm_rindex\", \"parm_up_cursor\",\n+    \"pkey_key\", \"pkey_local\", \"pkey_xmit\", \"print_screen\", \"prtr_off\", \"prtr_on\", \"repeat_char\",\n+    \"reset_1string\", \"reset_2string\", \"reset_3string\", \"reset_file\", \"restore_cursor\",\n+    \"row_address\", \"save_cursor\", \"scroll_forward\", \"scroll_reverse\", \"set_attributes\", \"set_tab\",\n+    \"set_window\", \"tab\", \"to_status_line\", \"underline_char\", \"up_half_line\", \"init_prog\", \"key_a1\",\n+    \"key_a3\", \"key_b2\", \"key_c1\", \"key_c3\", \"prtr_non\", \"char_padding\", \"acs_chars\", \"plab_norm\",\n+    \"key_btab\", \"enter_xon_mode\", \"exit_xon_mode\", \"enter_am_mode\", \"exit_am_mode\", \"xon_character\",\n+    \"xoff_character\", \"ena_acs\", \"label_on\", \"label_off\", \"key_beg\", \"key_cancel\", \"key_close\",\n+    \"key_command\", \"key_copy\", \"key_create\", \"key_end\", \"key_enter\", \"key_exit\", \"key_find\",\n+    \"key_help\", \"key_mark\", \"key_message\", \"key_move\", \"key_next\", \"key_open\", \"key_options\",\n+    \"key_previous\", \"key_print\", \"key_redo\", \"key_reference\", \"key_refresh\", \"key_replace\",\n+    \"key_restart\", \"key_resume\", \"key_save\", \"key_suspend\", \"key_undo\", \"key_sbeg\", \"key_scancel\",\n+    \"key_scommand\", \"key_scopy\", \"key_screate\", \"key_sdc\", \"key_sdl\", \"key_select\", \"key_send\",\n+    \"key_seol\", \"key_sexit\", \"key_sfind\", \"key_shelp\", \"key_shome\", \"key_sic\", \"key_sleft\",\n+    \"key_smessage\", \"key_smove\", \"key_snext\", \"key_soptions\", \"key_sprevious\", \"key_sprint\",\n+    \"key_sredo\", \"key_sreplace\", \"key_sright\", \"key_srsume\", \"key_ssave\", \"key_ssuspend\",\n+    \"key_sundo\", \"req_for_input\", \"key_f11\", \"key_f12\", \"key_f13\", \"key_f14\", \"key_f15\", \"key_f16\",\n+    \"key_f17\", \"key_f18\", \"key_f19\", \"key_f20\", \"key_f21\", \"key_f22\", \"key_f23\", \"key_f24\",\n+    \"key_f25\", \"key_f26\", \"key_f27\", \"key_f28\", \"key_f29\", \"key_f30\", \"key_f31\", \"key_f32\",\n+    \"key_f33\", \"key_f34\", \"key_f35\", \"key_f36\", \"key_f37\", \"key_f38\", \"key_f39\", \"key_f40\",\n+    \"key_f41\", \"key_f42\", \"key_f43\", \"key_f44\", \"key_f45\", \"key_f46\", \"key_f47\", \"key_f48\",\n+    \"key_f49\", \"key_f50\", \"key_f51\", \"key_f52\", \"key_f53\", \"key_f54\", \"key_f55\", \"key_f56\",\n+    \"key_f57\", \"key_f58\", \"key_f59\", \"key_f60\", \"key_f61\", \"key_f62\", \"key_f63\", \"clr_bol\",\n+    \"clear_margins\", \"set_left_margin\", \"set_right_margin\", \"label_format\", \"set_clock\",\n+    \"display_clock\", \"remove_clock\", \"create_window\", \"goto_window\", \"hangup\", \"dial_phone\",\n+    \"quick_dial\", \"tone\", \"pulse\", \"flash_hook\", \"fixed_pause\", \"wait_tone\", \"user0\", \"user1\",\n+    \"user2\", \"user3\", \"user4\", \"user5\", \"user6\", \"user7\", \"user8\", \"user9\", \"orig_pair\",\n+    \"orig_colors\", \"initialize_color\", \"initialize_pair\", \"set_color_pair\", \"set_foreground\",\n+    \"set_background\", \"change_char_pitch\", \"change_line_pitch\", \"change_res_horz\",\n+    \"change_res_vert\", \"define_char\", \"enter_doublewide_mode\", \"enter_draft_quality\",\n+    \"enter_italics_mode\", \"enter_leftward_mode\", \"enter_micro_mode\", \"enter_near_letter_quality\",\n+    \"enter_normal_quality\", \"enter_shadow_mode\", \"enter_subscript_mode\", \"enter_superscript_mode\",\n+    \"enter_upward_mode\", \"exit_doublewide_mode\", \"exit_italics_mode\", \"exit_leftward_mode\",\n+    \"exit_micro_mode\", \"exit_shadow_mode\", \"exit_subscript_mode\", \"exit_superscript_mode\",\n+    \"exit_upward_mode\", \"micro_column_address\", \"micro_down\", \"micro_left\", \"micro_right\",\n+    \"micro_row_address\", \"micro_up\", \"order_of_pins\", \"parm_down_micro\", \"parm_left_micro\",\n+    \"parm_right_micro\", \"parm_up_micro\", \"select_char_set\", \"set_bottom_margin\",\n+    \"set_bottom_margin_parm\", \"set_left_margin_parm\", \"set_right_margin_parm\", \"set_top_margin\",\n+    \"set_top_margin_parm\", \"start_bit_image\", \"start_char_set_def\", \"stop_bit_image\",\n+    \"stop_char_set_def\", \"subscript_characters\", \"superscript_characters\", \"these_cause_cr\",\n+    \"zero_motion\", \"char_set_names\", \"key_mouse\", \"mouse_info\", \"req_mouse_pos\", \"get_mouse\",\n+    \"set_a_foreground\", \"set_a_background\", \"pkey_plab\", \"device_type\", \"code_set_init\",\n+    \"set0_des_seq\", \"set1_des_seq\", \"set2_des_seq\", \"set3_des_seq\", \"set_lr_margin\",\n+    \"set_tb_margin\", \"bit_image_repeat\", \"bit_image_newline\", \"bit_image_carriage_return\",\n+    \"color_names\", \"define_bit_image_region\", \"end_bit_image_region\", \"set_color_band\",\n+    \"set_page_length\", \"display_pc_char\", \"enter_pc_charset_mode\", \"exit_pc_charset_mode\",\n+    \"enter_scancode_mode\", \"exit_scancode_mode\", \"pc_term_options\", \"scancode_escape\",\n+    \"alt_scancode_esc\", \"enter_horizontal_hl_mode\", \"enter_left_hl_mode\", \"enter_low_hl_mode\",\n+    \"enter_right_hl_mode\", \"enter_top_hl_mode\", \"enter_vertical_hl_mode\", \"set_a_attributes\",\n+    \"set_pglen_inch\", \"termcap_init2\", \"termcap_reset\", \"linefeed_if_not_lf\", \"backspace_if_not_bs\",\n+    \"other_non_function_keys\", \"arrow_key_map\", \"acs_ulcorner\", \"acs_llcorner\", \"acs_urcorner\",\n+    \"acs_lrcorner\", \"acs_ltee\", \"acs_rtee\", \"acs_btee\", \"acs_ttee\", \"acs_hline\", \"acs_vline\",\n+    \"acs_plus\", \"memory_lock\", \"memory_unlock\", \"box_chars_1\"];\n+\n+pub static stringnames: &'static[&'static str] = &'static[ \"cbt\", \"_\", \"cr\", \"csr\", \"tbc\", \"clear\",\n+    \"_\", \"_\", \"hpa\", \"cmdch\", \"cup\", \"cud1\", \"home\", \"civis\", \"cub1\", \"mrcup\", \"cnorm\", \"cuf1\",\n+    \"ll\", \"cuu1\", \"cvvis\", \"dch1\", \"dl1\", \"dsl\", \"hd\", \"smacs\", \"blink\", \"bold\", \"smcup\", \"smdc\",\n+    \"dim\", \"smir\", \"invis\", \"prot\", \"rev\", \"smso\", \"smul\", \"ech\", \"rmacs\", \"sgr0\", \"rmcup\", \"rmdc\",\n+    \"rmir\", \"rmso\", \"rmul\", \"flash\", \"ff\", \"fsl\", \"is1\", \"is2\", \"is3\", \"if\", \"ich1\", \"il1\", \"ip\",\n+    \"kbs\", \"ktbc\", \"kclr\", \"kctab\", \"_\", \"_\", \"kcud1\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\",\n+    \"_\", \"_\", \"_\", \"_\", \"_\", \"khome\", \"_\", \"_\", \"kcub1\", \"_\", \"knp\", \"kpp\", \"kcuf1\", \"_\", \"_\",\n+    \"khts\", \"_\", \"rmkx\", \"smkx\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"rmm\", \"_\",\n+    \"_\", \"pad\", \"dch\", \"dl\", \"cud\", \"ich\", \"indn\", \"il\", \"cub\", \"cuf\", \"rin\", \"cuu\", \"pfkey\",\n+    \"pfloc\", \"pfx\", \"mc0\", \"mc4\", \"_\", \"rep\", \"rs1\", \"rs2\", \"rs3\", \"rf\", \"rc\", \"vpa\", \"sc\", \"ind\",\n+    \"ri\", \"sgr\", \"_\", \"wind\", \"_\", \"tsl\", \"uc\", \"hu\", \"iprog\", \"_\", \"_\", \"_\", \"_\", \"_\", \"mc5p\",\n+    \"rmp\", \"acsc\", \"pln\", \"kcbt\", \"smxon\", \"rmxon\", \"smam\", \"rmam\", \"xonc\", \"xoffc\", \"_\", \"smln\",\n+    \"rmln\", \"_\", \"kcan\", \"kclo\", \"kcmd\", \"kcpy\", \"kcrt\", \"_\", \"kent\", \"kext\", \"kfnd\", \"khlp\",\n+    \"kmrk\", \"kmsg\", \"kmov\", \"knxt\", \"kopn\", \"kopt\", \"kprv\", \"kprt\", \"krdo\", \"kref\", \"krfr\", \"krpl\",\n+    \"krst\", \"kres\", \"ksav\", \"kspd\", \"kund\", \"kBEG\", \"kCAN\", \"kCMD\", \"kCPY\", \"kCRT\", \"_\", \"_\",\n+    \"kslt\", \"kEND\", \"kEOL\", \"kEXT\", \"kFND\", \"kHLP\", \"kHOM\", \"_\", \"kLFT\", \"kMSG\", \"kMOV\", \"kNXT\",\n+    \"kOPT\", \"kPRV\", \"kPRT\", \"kRDO\", \"kRPL\", \"kRIT\", \"kRES\", \"kSAV\", \"kSPD\", \"kUND\", \"rfi\", \"_\", \"_\",\n+    \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\",\n+    \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\",\n+    \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\",\n+    \"dclk\", \"rmclk\", \"cwin\", \"wingo\", \"_\", \"dial\", \"qdial\", \"_\", \"_\", \"hook\", \"pause\", \"wait\", \"_\",\n+    \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"op\", \"oc\", \"initc\", \"initp\", \"scp\", \"setf\",\n+    \"setb\", \"cpi\", \"lpi\", \"chr\", \"cvr\", \"defc\", \"swidm\", \"sdrfq\", \"sitm\", \"slm\", \"smicm\", \"snlq\",\n+    \"snrmq\", \"sshm\", \"ssubm\", \"ssupm\", \"sum\", \"rwidm\", \"ritm\", \"rlm\", \"rmicm\", \"rshm\", \"rsubm\",\n+    \"rsupm\", \"rum\", \"mhpa\", \"mcud1\", \"mcub1\", \"mcuf1\", \"mvpa\", \"mcuu1\", \"porder\", \"mcud\", \"mcub\",\n+    \"mcuf\", \"mcuu\", \"scs\", \"smgb\", \"smgbp\", \"smglp\", \"smgrp\", \"smgt\", \"smgtp\", \"sbim\", \"scsd\",\n+    \"rbim\", \"rcsd\", \"subcs\", \"supcs\", \"docr\", \"zerom\", \"csnm\", \"kmous\", \"minfo\", \"reqmp\", \"getm\",\n+    \"setaf\", \"setab\", \"pfxl\", \"devt\", \"csin\", \"s0ds\", \"s1ds\", \"s2ds\", \"s3ds\", \"smglr\", \"smgtb\",\n+    \"birep\", \"binel\", \"bicr\", \"colornm\", \"defbi\", \"endbi\", \"setcolor\", \"slines\", \"dispc\", \"smpch\",\n+    \"rmpch\", \"smsc\", \"rmsc\", \"pctrm\", \"scesc\", \"scesa\", \"ehhlm\", \"elhlm\", \"elohlm\", \"erhlm\",\n+    \"ethlm\", \"evhlm\", \"sgr1\", \"slength\", \"OTi2\", \"OTrs\", \"OTnl\", \"OTbs\", \"OTko\", \"OTma\", \"OTG2\",\n+    \"OTG3\", \"OTG1\", \"OTG4\", \"OTGR\", \"OTGL\", \"OTGU\", \"OTGD\", \"OTGH\", \"OTGV\", \"OTGC\", \"meml\", \"memu\",\n+    \"box1\"];\n+\n+/// Parse a compiled terminfo entry, using long capability names if `longnames` is true\n+pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n+    let bnames;\n+    let snames;\n+    let nnames;\n+\n+    if longnames {\n+        bnames = boolfnames;\n+        snames = stringfnames;\n+        nnames = numfnames;\n+    } else {\n+        bnames = boolnames;\n+        snames = stringnames;\n+        nnames = numnames;\n+    }\n+\n+    // Check magic number\n+    let magic = file.read_le_u16();\n+    if (magic != 0x011A) {\n+        return Err(fmt!(\"invalid magic number: expected %x but found %x\", 0x011A, magic as uint));\n+    }\n+\n+    let names_bytes          = file.read_le_i16() as int;\n+    let bools_bytes          = file.read_le_i16() as int;\n+    let numbers_count        = file.read_le_i16() as int;\n+    let string_offsets_count = file.read_le_i16() as int;\n+    let string_table_bytes   = file.read_le_i16() as int;\n+\n+    assert!(names_bytes          > 0);\n+\n+    debug!(\"names_bytes = %?\", names_bytes);\n+    debug!(\"bools_bytes = %?\", bools_bytes);\n+    debug!(\"numbers_count = %?\", numbers_count);\n+    debug!(\"string_offsets_count = %?\", string_offsets_count);\n+    debug!(\"string_table_bytes = %?\", string_table_bytes);\n+\n+    if (bools_bytes as uint) > boolnames.len() {\n+        error!(\"expected bools_bytes to be less than %? but found %?\", boolnames.len(),\n+               bools_bytes);\n+        return Err(~\"incompatible file: more booleans than expected\");\n+    }\n+\n+    if (numbers_count as uint) > numnames.len() {\n+        error!(\"expected numbers_count to be less than %? but found %?\", numnames.len(),\n+               numbers_count);\n+        return Err(~\"incompatible file: more numbers than expected\");\n+    }\n+\n+    if (string_offsets_count as uint) > stringnames.len() {\n+        error!(\"expected string_offsets_count to be less than %? but found %?\", stringnames.len(),\n+               string_offsets_count);\n+        return Err(~\"incompatible file: more string offsets than expected\");\n+    }\n+\n+    let names_str = str::from_bytes(file.read_bytes(names_bytes as uint - 1)); // don't read NUL\n+    let term_names: ~[~str] = names_str.split_iter('|').transform(|s| s.to_owned()).collect();\n+\n+    file.read_byte(); // consume NUL\n+\n+    debug!(\"term names: %?\", term_names);\n+\n+    let mut bools_map = HashMap::new();\n+    if bools_bytes != 0 {\n+        for int::range(0, bools_bytes) |i| {\n+            let b = file.read_byte();\n+            if b < 0 {\n+                error!(\"EOF reading bools after %? entries\", i);\n+                return Err(~\"error: expected more bools but hit EOF\");\n+            } else if b == 1 {\n+                debug!(\"%s set\", bnames[i]);\n+                bools_map.insert(bnames[i].to_owned(), true);\n+            }\n+        }\n+    }\n+\n+    debug!(\"bools: %?\", bools_map);\n+\n+    if (bools_bytes + names_bytes) % 2 == 1 {\n+        debug!(\"adjusting for padding between bools and numbers\");\n+        file.read_byte(); // compensate for padding\n+    }\n+\n+    let mut numbers_map = HashMap::new();\n+    if numbers_count != 0 {\n+        for int::range(0, numbers_count) |i| {\n+            let n = file.read_le_u16();\n+            if n != 0xFFFF {\n+                debug!(\"%s#%?\", nnames[i], n);\n+                numbers_map.insert(nnames[i].to_owned(), n);\n+            }\n+        }\n+    }\n+\n+    debug!(\"numbers: %?\", numbers_map);\n+\n+    let mut string_map = HashMap::new();\n+\n+    if string_offsets_count != 0 {\n+        let mut string_offsets = vec::with_capacity(10);\n+        for int::range(0, string_offsets_count) |_i| {\n+            string_offsets.push(file.read_le_u16());\n+        }\n+\n+        debug!(\"offsets: %?\", string_offsets);\n+\n+        let string_table = file.read_bytes(string_table_bytes as uint);\n+\n+        if string_table.len() != string_table_bytes as uint {\n+            error!(\"EOF reading string table after %? bytes, wanted %?\", string_table.len(),\n+                   string_table_bytes);\n+            return Err(~\"error: hit EOF before end of string table\");\n+        }\n+\n+        for string_offsets.eachi |i, v| {\n+            let offset = *v;\n+            if offset == 0xFFFF { // non-entry\n+                loop;\n+            }\n+\n+            let name = if snames[i] == \"_\" {\n+                stringfnames[i]\n+            } else {\n+                snames[i]\n+            };\n+\n+            if offset == 0xFFFE {\n+                // undocumented: FFFE indicates cap@, which means the capability is not present\n+                // unsure if the handling for this is correct\n+                string_map.insert(name.to_owned(), ~[]);\n+                loop;\n+            }\n+\n+\n+            // Find the offset of the NUL we want to go to\n+            let nulpos = vec::position_between(string_table, offset as uint,\n+                                               string_table_bytes as uint, |&b| b == 0);\n+            match nulpos {\n+                Some(x) => {\n+                    string_map.insert(name.to_owned(),\n+                                      string_table.slice(offset as uint, x).to_owned())\n+                },\n+                None => {\n+                    return Err(~\"invalid file: missing NUL in string_table\");\n+                }\n+            };\n+        }\n+    }\n+\n+    // And that's all there is to it\n+    Ok(~TermInfo {names: term_names, bools: bools_map, numbers: numbers_map, strings: string_map })\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use p = core::path::Path;\n+\n+    #[test]\n+    fn test_veclens() {\n+        assert_eq!(boolfnames.len(), boolnames.len());\n+        assert_eq!(numfnames.len(), numnames.len());\n+        assert_eq!(stringfnames.len(), stringnames.len());\n+    }\n+\n+    #[test]\n+    #[ignore(reason = \"no ncurses on buildbots, needs a bundled terminfo file to test against\")]\n+    fn test_parse() {\n+        // FIXME #6870: Distribute a compiled file in src/tests and test there\n+        // parse(io::file_reader(&p(\"/usr/share/terminfo/r/rxvt-256color\")).unwrap(), false);\n+    }\n+}"}, {"sha": "f82514475722580137e20d6276c766e312e1e77e", "filename": "src/libextra/terminfo/searcher.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// Implement ncurses-compatible database discovery\n+/// Does not support hashed database, only filesystem!\n+\n+use core::prelude::*;\n+use core::{os, str};\n+use core::os::getenv;\n+use core::io::{file_reader, Reader};\n+use path = core::path::Path;\n+\n+/// Return path to database entry for `term`\n+pub fn get_dbpath_for_term(term: &str) -> Option<~path> {\n+    if term.len() == 0 {\n+        return None;\n+    }\n+\n+    let homedir = os::homedir();\n+\n+    let mut dirs_to_search = ~[];\n+    let first_char = term.char_at(0);\n+\n+    // Find search directory\n+    match getenv(\"TERMINFO\") {\n+        Some(dir) => dirs_to_search.push(path(dir)),\n+        None => {\n+            if homedir.is_some() {\n+                dirs_to_search.push(homedir.unwrap().push(\".terminfo\")); // ncurses compatability\n+            }\n+            match getenv(\"TERMINFO_DIRS\") {\n+                Some(dirs) => for dirs.split_iter(':').advance |i| {\n+                    if i == \"\" {\n+                        dirs_to_search.push(path(\"/usr/share/terminfo\"));\n+                    } else {\n+                        dirs_to_search.push(path(i.to_owned()));\n+                    }\n+                },\n+                // Found nothing, use the default paths\n+                // /usr/share/terminfo is the de facto location, but it seems\n+                // Ubuntu puts it in /lib/terminfo\n+                None => {\n+                    dirs_to_search.push(path(\"/usr/share/terminfo\"));\n+                    dirs_to_search.push(path(\"/lib/terminfo\"));\n+                }\n+            }\n+        }\n+    };\n+\n+    // Look for the terminal in all of the search directories\n+    for dirs_to_search.each |p| {\n+        let newp = ~p.push_many(&[str::from_char(first_char), term.to_owned()]);\n+        if os::path_exists(p) && os::path_exists(newp) {\n+            return Some(newp);\n+        }\n+        // on some installations the dir is named after the hex of the char (e.g. OS X)\n+        let newp = ~p.push_many(&[fmt!(\"%x\", first_char as uint), term.to_owned()]);\n+        if os::path_exists(p) && os::path_exists(newp) {\n+            return Some(newp);\n+        }\n+    }\n+    None\n+}\n+\n+/// Return open file for `term`\n+pub fn open(term: &str) -> Result<@Reader, ~str> {\n+    match get_dbpath_for_term(term) {\n+        Some(x) => file_reader(x),\n+        None => Err(fmt!(\"could not find terminfo entry for %s\", term))\n+    }\n+}\n+\n+#[test]\n+#[ignore(reason = \"buildbots don't have ncurses installed and I can't mock everything I need\")]\n+fn test_get_dbpath_for_term() {\n+    // woefully inadequate test coverage\n+    // note: current tests won't work with non-standard terminfo hierarchies (e.g. OS X's)\n+    use std::os::{setenv, unsetenv};\n+    fn x(t: &str) -> ~str { get_dbpath_for_term(t).expect(\"no terminfo entry found\").to_str() };\n+    assert!(x(\"screen\") == ~\"/usr/share/terminfo/s/screen\");\n+    assert!(get_dbpath_for_term(\"\") == None);\n+    setenv(\"TERMINFO_DIRS\", \":\");\n+    assert!(x(\"screen\") == ~\"/usr/share/terminfo/s/screen\");\n+    unsetenv(\"TERMINFO_DIRS\");\n+}\n+\n+#[test]\n+#[ignore(reason = \"see test_get_dbpath_for_term\")]\n+fn test_open() {\n+    open(\"screen\");\n+    let t = open(\"nonexistent terminal that hopefully does not exist\");\n+    assert!(t.is_err());\n+}"}, {"sha": "141a5b6bf7f9b72b663b00ce6b5ac63c1f3af3fb", "filename": "src/libextra/terminfo/terminfo.rs", "status": "renamed", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fterminfo%2Fterminfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fterminfo%2Fterminfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fterminfo.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -8,23 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[allow(ctypes)];\n-#[allow(heap_memory)];\n-#[allow(implicit_copies)];\n-#[allow(managed_heap_memory)];\n-#[allow(non_camel_case_types)];\n-#[allow(owned_heap_memory)];\n-#[allow(path_statement)];\n-#[allow(unrecognized_lint)];\n-#[allow(unused_imports)];\n-#[allow(while_true)];\n-#[allow(unused_variable)];\n-#[allow(dead_assignment)];\n-#[allow(unused_unsafe)];\n-#[allow(unused_mut)];\n+use core::hashmap::HashMap;\n \n-extern mod std;\n+/// A parsed terminfo entry.\n+pub struct TermInfo {\n+    /// Names for the terminal\n+    names: ~[~str],\n+    /// Map of capability name to boolean value\n+    bools: HashMap<~str, bool>,\n+    /// Map of capability name to numeric value\n+    numbers: HashMap<~str, u16>,\n+    /// Map of capability name to raw (unexpanded) string\n+    strings: HashMap<~str, ~[u8]>\n+}\n \n-fn print<T>(result: T) {\n-    io::println(fmt!(\"%?\", result));\n+pub mod searcher;\n+pub mod parser {\n+    pub mod compiled;\n }\n+pub mod parm;", "previous_filename": "src/librusti/wrapper.rs"}, {"sha": "406dfb086eaceb8d334ac3a290c68adaefd05afa", "filename": "src/libextra/test.rs", "status": "modified", "additions": 42, "deletions": 27, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -21,8 +21,16 @@ use getopts;\n use sort;\n use term;\n \n-use core::to_str::ToStr;\n use core::comm::{stream, SharedChan};\n+use core::either;\n+use core::io;\n+use core::option;\n+use core::result;\n+use core::str;\n+use core::task;\n+use core::to_str::ToStr;\n+use core::uint;\n+use core::vec;\n \n pub mod rustrt {\n     use core::libc::size_t;\n@@ -202,7 +210,6 @@ struct ConsoleTestState {\n // A simple console test runner\n pub fn run_tests_console(opts: &TestOpts,\n                          tests: ~[TestDescAndFn]) -> bool {\n-\n     fn callback(event: &TestEvent, st: &mut ConsoleTestState) {\n         debug!(\"callback(event=%?)\", event);\n         match copy *event {\n@@ -213,7 +220,7 @@ pub fn run_tests_console(opts: &TestOpts,\n           }\n           TeWait(ref test) => st.out.write_str(\n               fmt!(\"test %s ... \", test.name.to_str())),\n-          TeResult(copy test, result) => {\n+          TeResult(test, result) => {\n             match st.log_out {\n                 Some(f) => write_log(f, copy result, &test),\n                 None => ()\n@@ -339,12 +346,18 @@ pub fn run_tests_console(opts: &TestOpts,\n                     word: &str,\n                     color: u8,\n                     use_color: bool) {\n-        if use_color && term::color_supported() {\n-            term::fg(out, color);\n-        }\n-        out.write_str(word);\n-        if use_color && term::color_supported() {\n-            term::reset(out);\n+        let t = term::Terminal::new(out);\n+        match t {\n+            Ok(term)  => {\n+                if use_color && term.color_supported {\n+                    term.fg(color);\n+                }\n+                out.write_str(word);\n+                if use_color && term.color_supported {\n+                    term.reset();\n+                }\n+            },\n+            Err(_) => out.write_str(word)\n         }\n     }\n }\n@@ -394,8 +407,8 @@ fn should_sort_failures_before_printing_them() {\n         print_failures(st);\n     };\n \n-    let apos = str::find_str(s, \"a\").get();\n-    let bpos = str::find_str(s, \"b\").get();\n+    let apos = s.find_str(\"a\").get();\n+    let bpos = s.find_str(\"b\").get();\n     assert!(apos < bpos);\n }\n \n@@ -494,15 +507,14 @@ pub fn filter_tests(\n     filtered = if opts.filter.is_none() {\n         filtered\n     } else {\n-        let filter_str =\n-            match opts.filter {\n-          option::Some(copy f) => f,\n+        let filter_str = match opts.filter {\n+          option::Some(ref f) => copy *f,\n           option::None => ~\"\"\n         };\n \n         fn filter_fn(test: TestDescAndFn, filter_str: &str) ->\n             Option<TestDescAndFn> {\n-            if str::contains(test.desc.name.to_str(), filter_str) {\n+            if test.desc.name.to_str().contains(filter_str) {\n                 return option::Some(test);\n             } else { return option::None; }\n         }\n@@ -556,7 +568,7 @@ pub fn run_test(force_ignore: bool,\n     fn run_test_inner(desc: TestDesc,\n                       monitor_ch: SharedChan<MonitorMsg>,\n                       testfn: ~fn()) {\n-        let testfn_cell = ::core::cell::Cell(testfn);\n+        let testfn_cell = ::core::cell::Cell::new(testfn);\n         do task::spawn {\n             let mut result_future = None; // task::future_result(builder);\n \n@@ -601,13 +613,16 @@ fn calc_result(desc: &TestDesc, task_succeeded: bool) -> TestResult {\n pub mod bench {\n     use core::prelude::*;\n \n-    use time::precise_time_ns;\n-    use test::{BenchHarness, BenchSamples};\n-    use stats::Stats;\n+    use core::num;\n     use core::rand::RngUtil;\n+    use core::rand;\n+    use core::u64;\n+    use core::vec;\n+    use stats::Stats;\n+    use test::{BenchHarness, BenchSamples};\n+    use time::precise_time_ns;\n \n-    pub impl BenchHarness {\n-\n+    impl BenchHarness {\n         /// Callback for benchmark functions to run in their body.\n         pub fn iter(&mut self, inner:&fn()) {\n             self.ns_start = precise_time_ns();\n@@ -618,23 +633,23 @@ pub mod bench {\n             self.ns_end = precise_time_ns();\n         }\n \n-        fn ns_elapsed(&mut self) -> u64 {\n+        pub fn ns_elapsed(&mut self) -> u64 {\n             if self.ns_start == 0 || self.ns_end == 0 {\n                 0\n             } else {\n                 self.ns_end - self.ns_start\n             }\n         }\n \n-        fn ns_per_iter(&mut self) -> u64 {\n+        pub fn ns_per_iter(&mut self) -> u64 {\n             if self.iterations == 0 {\n                 0\n             } else {\n                 self.ns_elapsed() / self.iterations\n             }\n         }\n \n-        fn bench_n(&mut self, n: u64, f: &fn(&mut BenchHarness)) {\n+        pub fn bench_n(&mut self, n: u64, f: &fn(&mut BenchHarness)) {\n             self.iterations = n;\n             debug!(\"running benchmark for %u iterations\",\n                    n as uint);\n@@ -852,7 +867,7 @@ mod tests {\n     fn first_free_arg_should_be_a_filter() {\n         let args = ~[~\"progname\", ~\"filter\"];\n         let opts = match parse_opts(args) {\n-          either::Left(copy o) => o,\n+          either::Left(o) => o,\n           _ => fail!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n         };\n         assert!(\"filter\" == (copy opts.filter).get());\n@@ -862,7 +877,7 @@ mod tests {\n     fn parse_ignored_flag() {\n         let args = ~[~\"progname\", ~\"filter\", ~\"--ignored\"];\n         let opts = match parse_opts(args) {\n-          either::Left(copy o) => o,\n+          either::Left(o) => o,\n           _ => fail!(\"Malformed arg in parse_ignored_flag\")\n         };\n         assert!((opts.run_ignored));"}, {"sha": "50592d5f7309de31c8c35b057e520a6df40b293c", "filename": "src/libextra/time.rs", "status": "modified", "additions": 55, "deletions": 48, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -8,8 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n+use core::i32;\n+use core::int;\n+use core::io;\n+use core::str;\n+\n static NSEC_PER_SEC: i32 = 1_000_000_000_i32;\n \n pub mod rustrt {\n@@ -42,8 +49,8 @@ pub struct Timespec { sec: i64, nsec: i32 }\n  * -1.2 seconds before the epoch is represented by `Timespec { sec: -2_i64,\n  * nsec: 800_000_000_i32 }`.\n  */\n-pub impl Timespec {\n-    fn new(sec: i64, nsec: i32) -> Timespec {\n+impl Timespec {\n+    pub fn new(sec: i64, nsec: i32) -> Timespec {\n         assert!(nsec >= 0 && nsec < NSEC_PER_SEC);\n         Timespec { sec: sec, nsec: nsec }\n     }\n@@ -173,9 +180,9 @@ pub fn strftime(format: &str, tm: &Tm) -> ~str {\n     do_strftime(format, tm)\n }\n \n-pub impl Tm {\n+impl Tm {\n     /// Convert time to the seconds from January 1, 1970\n-    fn to_timespec(&self) -> Timespec {\n+    pub fn to_timespec(&self) -> Timespec {\n         unsafe {\n             let sec = match self.tm_gmtoff {\n                 0_i32 => rustrt::rust_timegm(self),\n@@ -187,23 +194,23 @@ pub impl Tm {\n     }\n \n     /// Convert time to the local timezone\n-    fn to_local(&self) -> Tm {\n+    pub fn to_local(&self) -> Tm {\n         at(self.to_timespec())\n     }\n \n     /// Convert time to the UTC\n-    fn to_utc(&self) -> Tm {\n+    pub fn to_utc(&self) -> Tm {\n         at_utc(self.to_timespec())\n     }\n \n     /**\n      * Return a string of the current time in the form\n      * \"Thu Jan  1 00:00:00 1970\".\n      */\n-    fn ctime(&self) -> ~str { self.strftime(\"%c\") }\n+    pub fn ctime(&self) -> ~str { self.strftime(\"%c\") }\n \n     /// Formats the time according to the format string.\n-    fn strftime(&self, format: &str) -> ~str {\n+    pub fn strftime(&self, format: &str) -> ~str {\n         strftime(format, self)\n     }\n \n@@ -213,7 +220,7 @@ pub impl Tm {\n      * local: \"Thu, 22 Mar 2012 07:53:18 PST\"\n      * utc:   \"Thu, 22 Mar 2012 14:53:18 UTC\"\n      */\n-    fn rfc822(&self) -> ~str {\n+    pub fn rfc822(&self) -> ~str {\n         if self.tm_gmtoff == 0_i32 {\n             self.strftime(\"%a, %d %b %Y %T GMT\")\n         } else {\n@@ -227,7 +234,7 @@ pub impl Tm {\n      * local: \"Thu, 22 Mar 2012 07:53:18 -0700\"\n      * utc:   \"Thu, 22 Mar 2012 14:53:18 -0000\"\n      */\n-    fn rfc822z(&self) -> ~str {\n+    pub fn rfc822z(&self) -> ~str {\n         self.strftime(\"%a, %d %b %Y %T %z\")\n     }\n \n@@ -237,7 +244,7 @@ pub impl Tm {\n      * local: \"2012-02-22T07:53:18-07:00\"\n      * utc:   \"2012-02-22T14:53:18Z\"\n      */\n-    fn rfc3339(&self) -> ~str {\n+    pub fn rfc3339(&self) -> ~str {\n         if self.tm_gmtoff == 0_i32 {\n             self.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n         } else {\n@@ -254,7 +261,7 @@ pub impl Tm {\n priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     fn match_str(s: &str, pos: uint, needle: &str) -> bool {\n         let mut i = pos;\n-        for str::each(needle) |ch| {\n+        for needle.bytes_iter().advance |ch| {\n             if s[i] != ch {\n                 return false;\n             }\n@@ -268,10 +275,12 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n         let mut i = 0u;\n         let len = strs.len();\n         while i < len {\n-            let &(needle, value) = &strs[i];\n-\n-            if match_str(ss, pos, needle) {\n-                return Some((value, pos + str::len(needle)));\n+            match strs[i] { // can't use let due to stage0 bugs\n+                (ref needle, value) => {\n+                    if match_str(ss, pos, *needle) {\n+                        return Some((value, pos + needle.len()));\n+                    }\n+                }\n             }\n             i += 1u;\n         }\n@@ -286,7 +295,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n \n         let mut i = 0u;\n         while i < digits {\n-            let range = str::char_range_at(str::to_owned(ss), pos);\n+            let range = ss.char_range_at(pos);\n             pos = range.next;\n \n             match range.ch {\n@@ -313,7 +322,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     }\n \n     fn parse_char(s: &str, pos: uint, c: char) -> Result<uint, ~str> {\n-        let range = str::char_range_at(s, pos);\n+        let range = s.char_range_at(pos);\n \n         if c == range.ch {\n             Ok(range.next)\n@@ -588,9 +597,9 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 // It's odd, but to maintain compatibility with c's\n                 // strptime we ignore the timezone.\n                 let mut pos = pos;\n-                let len = str::len(s);\n+                let len = s.len();\n                 while pos < len {\n-                    let range = str::char_range_at(s, pos);\n+                    let range = s.char_range_at(pos);\n                     pos = range.next;\n                     if range.ch == ' ' { break; }\n                 }\n@@ -599,7 +608,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             }\n           }\n           'z' => {\n-            let range = str::char_range_at(s, pos);\n+            let range = s.char_range_at(pos);\n \n             if range.ch == '+' || range.ch == '-' {\n                 match match_digits(s, range.next, 4u, false) {\n@@ -625,7 +634,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n         }\n     }\n \n-    do io::with_str_reader(str::to_owned(format)) |rdr| {\n+    do io::with_str_reader(format) |rdr| {\n         let mut tm = Tm {\n             tm_sec: 0_i32,\n             tm_min: 0_i32,\n@@ -641,11 +650,11 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             tm_nsec: 0_i32,\n         };\n         let mut pos = 0u;\n-        let len = str::len(s);\n+        let len = s.len();\n         let mut result = Err(~\"Invalid time\");\n \n         while !rdr.eof() && pos < len {\n-            let range = str::char_range_at(s, pos);\n+            let range = s.char_range_at(pos);\n             let ch = range.ch;\n             let next = range.next;\n \n@@ -837,11 +846,11 @@ priv fn do_strftime(format: &str, tm: &Tm) -> ~str {\n \n     let mut buf = ~\"\";\n \n-    do io::with_str_reader(str::to_owned(format)) |rdr| {\n+    do io::with_str_reader(format) |rdr| {\n         while !rdr.eof() {\n             match rdr.read_char() {\n                 '%' => buf += parse_type(rdr.read_char(), tm),\n-                ch => str::push_char(&mut buf, ch)\n+                ch => buf.push_char(ch)\n             }\n         }\n     }\n@@ -1000,7 +1009,7 @@ mod tests {\n             == Err(~\"Invalid time\"));\n \n         match strptime(\"Fri Feb 13 15:31:30 2009\", format) {\n-          Err(copy e) => fail!(e),\n+          Err(e) => fail!(e),\n           Ok(ref tm) => {\n             assert!(tm.tm_sec == 30_i32);\n             assert!(tm.tm_min == 31_i32);\n@@ -1020,7 +1029,7 @@ mod tests {\n         fn test(s: &str, format: &str) -> bool {\n             match strptime(s, format) {\n               Ok(ref tm) => tm.strftime(format) == str::to_owned(s),\n-              Err(copy e) => fail!(e)\n+              Err(e) => fail!(e)\n             }\n         }\n \n@@ -1219,36 +1228,34 @@ mod tests {\n     }\n \n     fn test_timespec_eq_ord() {\n-        use core::cmp::{eq, ge, gt, le, lt, ne};\n-\n         let a = &Timespec::new(-2, 1);\n         let b = &Timespec::new(-1, 2);\n         let c = &Timespec::new(1, 2);\n         let d = &Timespec::new(2, 1);\n         let e = &Timespec::new(2, 1);\n \n-        assert!(eq(d, e));\n-        assert!(ne(c, e));\n+        assert!(d.eq(e));\n+        assert!(c.ne(e));\n \n-        assert!(lt(a, b));\n-        assert!(lt(b, c));\n-        assert!(lt(c, d));\n+        assert!(a.lt(b));\n+        assert!(b.lt(c));\n+        assert!(c.lt(d));\n \n-        assert!(le(a, b));\n-        assert!(le(b, c));\n-        assert!(le(c, d));\n-        assert!(le(d, e));\n-        assert!(le(e, d));\n+        assert!(a.le(b));\n+        assert!(b.le(c));\n+        assert!(c.le(d));\n+        assert!(d.le(e));\n+        assert!(e.le(d));\n \n-        assert!(ge(b, a));\n-        assert!(ge(c, b));\n-        assert!(ge(d, c));\n-        assert!(ge(e, d));\n-        assert!(ge(d, e));\n+        assert!(b.ge(a));\n+        assert!(c.ge(b));\n+        assert!(d.ge(c));\n+        assert!(e.ge(d));\n+        assert!(d.ge(e));\n \n-        assert!(gt(b, a));\n-        assert!(gt(c, b));\n-        assert!(gt(d, c));\n+        assert!(b.gt(a));\n+        assert!(c.gt(b));\n+        assert!(d.gt(c));\n     }\n \n     #[test]"}, {"sha": "7a4ad34b508923e1ba06106b7b61d6ca585073d6", "filename": "src/libextra/timer.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftimer.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -19,6 +19,7 @@ use uv::iotask::IoTask;\n use core::cast::transmute;\n use core::cast;\n use core::comm::{stream, Chan, SharedChan, Port, select2i};\n+use core::either;\n use core::libc::c_void;\n use core::libc;\n \n@@ -130,7 +131,6 @@ pub fn recv_timeout<T:Copy + Owned>(iotask: &IoTask,\n     unsafe {\n         let wait_po = cast::transmute_mut(wait_po);\n \n-        // FIXME: This could be written clearer (#2618)\n         either::either(\n             |_| {\n                 None\n@@ -179,9 +179,12 @@ mod test {\n \n     use timer::*;\n     use uv;\n+\n     use core::cell::Cell;\n-    use core::rand::RngUtil;\n     use core::pipes::{stream, SharedChan};\n+    use core::rand::RngUtil;\n+    use core::rand;\n+    use core::task;\n \n     #[test]\n     fn test_gl_timer_simple_sleep_test() {\n@@ -278,7 +281,7 @@ mod test {\n \n         for (times as uint).times {\n             let mut rng = rand::rng();\n-            let expected = Cell(rng.gen_str(16u));\n+            let expected = Cell::new(rng.gen_str(16u));\n             let (test_po, test_ch) = stream::<~str>();\n             let hl_loop_clone = hl_loop.clone();\n             do task::spawn() {"}, {"sha": "f98758f64afe43dbc6f91a4c759cadfc8656a370", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -14,11 +14,11 @@\n \n use core::prelude::*;\n \n-use core::iterator::*;\n+use core::uint;\n use core::util::{swap, replace};\n \n // This is implemented as an AA tree, which is a simplified variation of\n-// a red-black tree where where red (horizontal) nodes can only be added\n+// a red-black tree where red (horizontal) nodes can only be added\n // as a right child. The time complexity is the same, and re-balancing\n // operations are more frequent but also cheaper.\n \n@@ -33,6 +33,7 @@ use core::util::{swap, replace};\n //   * union: |\n // These would be convenient since the methods work like `each`\n \n+#[allow(missing_doc)]\n pub struct TreeMap<K, V> {\n     priv root: Option<~TreeNode<K, V>>,\n     priv length: uint\n@@ -179,28 +180,28 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     }\n }\n \n-pub impl<K: TotalOrd, V> TreeMap<K, V> {\n+impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n-    fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n+    pub fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n     /// Visit all key-value pairs in reverse order\n-    fn each_reverse<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) -> bool {\n+    pub fn each_reverse<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) -> bool {\n         each_reverse(&self.root, f)\n     }\n \n     /// Visit all keys in reverse order\n-    fn each_key_reverse(&self, f: &fn(&K) -> bool) -> bool {\n+    pub fn each_key_reverse(&self, f: &fn(&K) -> bool) -> bool {\n         self.each_reverse(|k, _| f(k))\n     }\n \n     /// Visit all values in reverse order\n-    fn each_value_reverse(&self, f: &fn(&V) -> bool) -> bool {\n+    pub fn each_value_reverse(&self, f: &fn(&V) -> bool) -> bool {\n         self.each_reverse(|_, v| f(v))\n     }\n \n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n-    fn iter<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n+    pub fn iter<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n         TreeMapIterator{stack: ~[], node: &self.root}\n     }\n }\n@@ -241,6 +242,9 @@ impl<'self, T> Iterator<&'self T> for TreeSetIterator<'self, T> {\n     }\n }\n \n+/// A implementation of the `Set` trait on top of the `TreeMap` container. The\n+/// only requirement is that the type of the elements contained ascribes to the\n+/// `TotalOrd` trait.\n pub struct TreeSet<T> {\n     priv map: TreeMap<T, ()>\n }\n@@ -422,7 +426,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n                 b = y.next();\n             }\n         }\n-        return b.each(|&x| f(x)) && y.advance(f);\n+        b.iter().advance(|&x| f(x)) && y.advance(f)\n     }\n \n     /// Visit the values (in-order) representing the intersection\n@@ -480,19 +484,19 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n                 a = x.next();\n             }\n         }\n-        return b.each(|&x| f(x)) && y.advance(f);\n+        b.iter().advance(|&x| f(x)) && y.advance(f)\n     }\n }\n \n-pub impl <T: TotalOrd> TreeSet<T> {\n+impl<T: TotalOrd> TreeSet<T> {\n     /// Create an empty TreeSet\n     #[inline(always)]\n-    fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n+    pub fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n \n     /// Get a lazy iterator over the values in the set.\n     /// Requires that it be frozen (immutable).\n     #[inline(always)]\n-    fn iter<'a>(&'a self) -> TreeSetIterator<'a, T> {\n+    pub fn iter<'a>(&'a self) -> TreeSetIterator<'a, T> {\n         TreeSetIterator{iter: self.map.iter()}\n     }\n }\n@@ -512,23 +516,24 @@ struct TreeNode<K, V> {\n     level: uint\n }\n \n-pub impl<K: TotalOrd, V> TreeNode<K, V> {\n+impl<K: TotalOrd, V> TreeNode<K, V> {\n+    /// Creates a new tree node.\n     #[inline(always)]\n-    fn new(key: K, value: V) -> TreeNode<K, V> {\n+    pub fn new(key: K, value: V) -> TreeNode<K, V> {\n         TreeNode{key: key, value: value, left: None, right: None, level: 1}\n     }\n }\n \n fn each<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n                             f: &fn(&'r K, &'r V) -> bool) -> bool {\n-    node.each(|x| each(&x.left, f) && f(&x.key, &x.value) &&\n-                  each(&x.right, f))\n+    node.iter().advance(|x| each(&x.left, f) && f(&x.key, &x.value) &&\n+                            each(&x.right, f))\n }\n \n fn each_reverse<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n                                     f: &fn(&'r K, &'r V) -> bool) -> bool {\n-    node.each(|x| each_reverse(&x.right, f) && f(&x.key, &x.value) &&\n-                  each_reverse(&x.left, f))\n+    node.iter().advance(|x| each_reverse(&x.right, f) && f(&x.key, &x.value) &&\n+                            each_reverse(&x.left, f))\n }\n \n fn mutate_values<'r, K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>,\n@@ -619,7 +624,7 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n     fn heir_swap<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>,\n                                  child: &mut Option<~TreeNode<K, V>>) {\n         // *could* be done without recursion, but it won't borrow check\n-        for child.each_mut |x| {\n+        for child.mut_iter().advance |x| {\n             if x.right.is_some() {\n                 heir_swap(node, &mut x.right);\n             } else {\n@@ -674,18 +679,18 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n                 save.level -= 1;\n \n                 if right_level > save.level {\n-                    for save.right.each_mut |x| { x.level = save.level }\n+                    for save.right.mut_iter().advance |x| { x.level = save.level }\n                 }\n \n                 skew(save);\n \n-                for save.right.each_mut |right| {\n+                for save.right.mut_iter().advance |right| {\n                     skew(right);\n-                    for right.right.each_mut |x| { skew(x) }\n+                    for right.right.mut_iter().advance |x| { skew(x) }\n                 }\n \n                 split(save);\n-                for save.right.each_mut |x| { split(x) }\n+                for save.right.mut_iter().advance |x| { split(x) }\n             }\n \n             return ret;\n@@ -701,9 +706,12 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n mod test_treemap {\n     use core::prelude::*;\n \n-    use core::iterator::*;\n     use super::*;\n+\n     use core::rand::RngUtil;\n+    use core::rand;\n+    use core::str;\n+    use core::vec;\n \n     #[test]\n     fn find_empty() {\n@@ -759,10 +767,10 @@ mod test_treemap {\n     fn u8_map() {\n         let mut m = TreeMap::new();\n \n-        let k1 = str::to_bytes(\"foo\");\n-        let k2 = str::to_bytes(\"bar\");\n-        let v1 = str::to_bytes(\"baz\");\n-        let v2 = str::to_bytes(\"foobar\");\n+        let k1 = \"foo\".as_bytes();\n+        let k2 = \"bar\".as_bytes();\n+        let v1 = \"baz\".as_bytes();\n+        let v2 = \"foobar\".as_bytes();\n \n         m.insert(copy k1, copy v1);\n         m.insert(copy k2, copy v2);\n@@ -1020,7 +1028,7 @@ mod test_treemap {\n #[cfg(test)]\n mod test_set {\n     use core::prelude::*;\n-    use core::iterator::*;\n+\n     use super::*;\n \n     #[test]\n@@ -1100,6 +1108,7 @@ mod test_set {\n \n         let mut n = 0;\n         for m.each |x| {\n+            println(fmt!(\"%?\", x));\n             assert_eq!(*x, n);\n             n += 1\n         }"}, {"sha": "3bd05a4153447147637b190e734ce524f13e5c5b", "filename": "src/libextra/unicode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Funicode.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #[forbid(deprecated_mode)];\n+#[allow(missing_doc)];\n \n pub mod icu {\n     pub type UBool = u8;"}, {"sha": "286863bef641dcb84fae072d9e7c4d3571b7059f", "filename": "src/libextra/uv_global_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuv_global_loop.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //"}, {"sha": "817dfa28aeedfb5b8dd10f94b051c347889bdc08", "filename": "src/libextra/uv_iotask.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuv_iotask.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -15,13 +15,16 @@\n  * `interact` function you can execute code in a uv callback.\n  */\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n use ll = uv_ll;\n \n use core::comm::{stream, Port, Chan, SharedChan};\n use core::libc::c_void;\n use core::libc;\n+use core::task;\n \n /// Used to abstract-away direct interaction with a libuv loop.\n pub struct IoTask {\n@@ -223,6 +226,8 @@ struct AhData {\n \n #[cfg(test)]\n fn impl_uv_iotask_async(iotask: &IoTask) {\n+    use core::ptr;\n+\n     let async_handle = ll::async_t();\n     let ah_ptr: *ll::uv_async_t = &async_handle;\n     let (exit_po, exit_ch) = stream::<()>();"}, {"sha": "744f4555d5cbd697d3721ab4bec8a63a900286fd", "filename": "src/libextra/uv_ll.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuv_ll.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -31,12 +31,16 @@\n  */\n \n #[allow(non_camel_case_types)]; // C types\n+#[allow(missing_doc)];\n \n use core::prelude::*;\n \n-use core::libc::size_t;\n-use core::libc::c_void;\n+use core::libc::{c_void, size_t};\n+use core::libc;\n use core::ptr::to_unsafe_ptr;\n+use core::ptr;\n+use core::str;\n+use core::vec;\n \n pub type uv_handle_t = c_void;\n pub type uv_loop_t = c_void;\n@@ -984,7 +988,7 @@ pub unsafe fn accept(server: *libc::c_void, client: *libc::c_void)\n pub unsafe fn write<T>(req: *uv_write_t, stream: *T,\n          buf_in: *~[uv_buf_t], cb: *u8) -> libc::c_int {\n     let buf_ptr = vec::raw::to_ptr(*buf_in);\n-    let buf_cnt = vec::len(*buf_in) as i32;\n+    let buf_cnt = (*buf_in).len() as i32;\n     return rust_uv_write(req as *libc::c_void,\n                               stream as *libc::c_void,\n                               buf_ptr, buf_cnt, cb);\n@@ -1225,9 +1229,16 @@ pub unsafe fn addrinfo_as_sockaddr_in6(input: *addrinfo) -> *sockaddr_in6 {\n #[cfg(test)]\n mod test {\n     use core::prelude::*;\n-    use core::comm::{SharedChan, stream, GenericChan, GenericPort};\n+\n     use super::*;\n \n+    use core::comm::{SharedChan, stream, GenericChan, GenericPort};\n+    use core::libc;\n+    use core::str;\n+    use core::sys;\n+    use core::task;\n+    use core::vec;\n+\n     enum tcp_read_data {\n         tcp_read_eof,\n         tcp_read_more(~[u8]),\n@@ -1357,7 +1368,7 @@ mod test {\n             // In C, this would be a malloc'd or stack-allocated\n             // struct that we'd cast to a void* and store as the\n             // data field in our uv_connect_t struct\n-            let req_str_bytes = str::to_bytes(req_str);\n+            let req_str_bytes = req_str.as_bytes();\n             let req_msg_ptr: *u8 = vec::raw::to_ptr(req_str_bytes);\n             debug!(\"req_msg ptr: %u\", req_msg_ptr as uint);\n             let req_msg = ~[\n@@ -1469,7 +1480,7 @@ mod test {\n \n                 let server_kill_msg = copy (*client_data).server_kill_msg;\n                 let write_req = (*client_data).server_write_req;\n-                if str::contains(request_str, server_kill_msg) {\n+                if request_str.contains(server_kill_msg) {\n                     debug!(~\"SERVER: client req contains kill_msg!\");\n                     debug!(~\"SERVER: sending response to client\");\n                     read_stop(client_stream_ptr);\n@@ -1615,7 +1626,7 @@ mod test {\n             let server_write_req = write_t();\n             let server_write_req_ptr: *uv_write_t = &server_write_req;\n \n-            let resp_str_bytes = str::to_bytes(server_resp_msg);\n+            let resp_str_bytes = server_resp_msg.as_bytes();\n             let resp_msg_ptr: *u8 = vec::raw::to_ptr(resp_str_bytes);\n             debug!(\"resp_msg ptr: %u\", resp_msg_ptr as uint);\n             let resp_msg = ~[\n@@ -1742,8 +1753,8 @@ mod test {\n         let msg_from_client = server_port.recv();\n         let msg_from_server = client_port.recv();\n \n-        assert!(str::contains(msg_from_client, kill_server_msg));\n-        assert!(str::contains(msg_from_server, server_resp_msg));\n+        assert!(msg_from_client.contains(kill_server_msg));\n+        assert!(msg_from_server.contains(server_resp_msg));\n     }\n \n     // FIXME don't run on fbsd or linux 32 bit(#2064)"}, {"sha": "b2fd998b73fd2cc389815ff66e4976bc4324c29e", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 38, "deletions": 33, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(missing_doc)];\n+\n use core::prelude::*;\n \n use json;\n@@ -21,7 +23,9 @@ use core::comm::{PortOne, oneshot, send_one, recv_one};\n use core::either::{Either, Left, Right};\n use core::hashmap::HashMap;\n use core::io;\n+use core::result;\n use core::run;\n+use core::task;\n use core::to_bytes;\n use core::util::replace;\n \n@@ -123,9 +127,12 @@ impl cmp::Ord for WorkKey {\n     }\n }\n \n-pub impl WorkKey {\n-    fn new(kind: &str, name: &str) -> WorkKey {\n-    WorkKey { kind: kind.to_owned(), name: name.to_owned() }\n+impl WorkKey {\n+    pub fn new(kind: &str, name: &str) -> WorkKey {\n+        WorkKey {\n+            kind: kind.to_owned(),\n+            name: name.to_owned(),\n+        }\n     }\n }\n \n@@ -163,24 +170,24 @@ struct Database {\n     db_dirty: bool\n }\n \n-pub impl Database {\n-    fn prepare(&mut self,\n-               fn_name: &str,\n-               declared_inputs: &WorkMap)\n-               -> Option<(WorkMap, WorkMap, ~str)> {\n+impl Database {\n+    pub fn prepare(&mut self,\n+                   fn_name: &str,\n+                   declared_inputs: &WorkMap)\n+                   -> Option<(WorkMap, WorkMap, ~str)> {\n         let k = json_encode(&(fn_name, declared_inputs));\n         match self.db_cache.find(&k) {\n             None => None,\n             Some(v) => Some(json_decode(*v))\n         }\n     }\n \n-    fn cache(&mut self,\n-             fn_name: &str,\n-             declared_inputs: &WorkMap,\n-             discovered_inputs: &WorkMap,\n-             discovered_outputs: &WorkMap,\n-             result: &str) {\n+    pub fn cache(&mut self,\n+                 fn_name: &str,\n+                 declared_inputs: &WorkMap,\n+                 discovered_inputs: &WorkMap,\n+                 discovered_outputs: &WorkMap,\n+                 result: &str) {\n         let k = json_encode(&(fn_name, declared_inputs));\n         let v = json_encode(&(discovered_inputs,\n                               discovered_outputs,\n@@ -195,9 +202,9 @@ struct Logger {\n     a: ()\n }\n \n-pub impl Logger {\n-    fn info(&self, i: &str) {\n-        io::println(~\"workcache: \" + i.to_owned());\n+impl Logger {\n+    pub fn info(&self, i: &str) {\n+        io::println(~\"workcache: \" + i);\n     }\n }\n \n@@ -253,11 +260,9 @@ fn digest_file(path: &Path) -> ~str {\n     sha.result_str()\n }\n \n-pub impl Context {\n-\n-    fn new(db: @mut Database,\n-                  lg: @mut Logger,\n-                  cfg: @json::Object) -> Context {\n+impl Context {\n+    pub fn new(db: @mut Database, lg: @mut Logger, cfg: @json::Object)\n+               -> Context {\n         Context {\n             db: db,\n             logger: lg,\n@@ -266,12 +271,12 @@ pub impl Context {\n         }\n     }\n \n-    fn prep<T:Owned +\n-              Encodable<json::Encoder> +\n-              Decodable<json::Decoder>>( // FIXME(#5121)\n-                  @self,\n-                  fn_name:&str,\n-                  blk: &fn(@mut Prep)->Work<T>) -> Work<T> {\n+    pub fn prep<T:Owned +\n+                  Encodable<json::Encoder> +\n+                  Decodable<json::Decoder>>(@self, // FIXME(#5121)\n+                                            fn_name:&str,\n+                                            blk: &fn(@mut Prep)->Work<T>)\n+                                            -> Work<T> {\n         let p = @mut Prep {\n             ctxt: self,\n             fn_name: fn_name.to_owned(),\n@@ -342,7 +347,7 @@ impl TPrep for Prep {\n             _ => {\n                 let (port, chan) = oneshot();\n                 let blk = replace(&mut bo, None).unwrap();\n-                let chan = Cell(chan);\n+                let chan = Cell::new(chan);\n \n                 do task::spawn {\n                     let exe = Exec {\n@@ -359,10 +364,10 @@ impl TPrep for Prep {\n     }\n }\n \n-pub impl<T:Owned +\n-         Encodable<json::Encoder> +\n-         Decodable<json::Decoder>> Work<T> { // FIXME(#5121)\n-    fn new(p: @mut Prep, e: Either<T,PortOne<(Exec,T)>>) -> Work<T> {\n+impl<T:Owned +\n+       Encodable<json::Encoder> +\n+       Decodable<json::Decoder>> Work<T> { // FIXME(#5121)\n+    pub fn new(p: @mut Prep, e: Either<T,PortOne<(Exec,T)>>) -> Work<T> {\n         Work { prep: p, res: Some(e) }\n     }\n }"}, {"sha": "4e2103fcd7047ba4dbf15e70776f2e2be0f87a0f", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 43, "deletions": 37, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -28,7 +28,15 @@ extern mod extra(name = \"extra\", vers = \"0.7-pre\");\n extern mod syntax(vers = \"0.7-pre\");\n \n use std::prelude::*;\n+\n+use std::int;\n+use std::io;\n+use std::option;\n+use std::os;\n+use std::result;\n use std::run;\n+use std::str;\n+use std::uint;\n \n use syntax::diagnostic;\n use syntax::parse::token::ident_interner;\n@@ -48,7 +56,7 @@ pub fn write_file(filename: &Path, content: &str) {\n }\n \n pub fn contains(haystack: &str, needle: &str) -> bool {\n-    str::contains(haystack, needle)\n+    haystack.contains(needle)\n }\n \n pub fn find_rust_files(files: &mut ~[Path], path: &Path) {\n@@ -69,7 +77,6 @@ pub fn common_exprs() -> ~[@ast::expr] {\n     fn dse(e: ast::expr_) -> @ast::expr {\n         @ast::expr {\n             id: 0,\n-            callee_id: -1,\n             node: e,\n             span: codemap::dummy_sp(),\n         }\n@@ -85,9 +92,9 @@ pub fn common_exprs() -> ~[@ast::expr] {\n      dse(ast::expr_lit(@dsl(ast::lit_nil))),\n      dse(ast::expr_lit(@dsl(ast::lit_bool(false)))),\n      dse(ast::expr_lit(@dsl(ast::lit_bool(true)))),\n-     dse(ast::expr_unary(ast::box(ast::m_imm),\n+     dse(ast::expr_unary(-1, ast::box(ast::m_imm),\n                          dse(ast::expr_lit(@dsl(ast::lit_bool(true)))))),\n-     dse(ast::expr_unary(ast::uniq(ast::m_imm),\n+     dse(ast::expr_unary(-1, ast::uniq(ast::m_imm),\n                          dse(ast::expr_lit(@dsl(ast::lit_bool(true))))))\n     ]\n }\n@@ -119,7 +126,7 @@ pub fn safe_to_use_expr(e: @ast::expr, tm: test_mode) -> bool {\n           //ast::expr_cast(_, _) { false }\n \n           // https://github.com/mozilla/rust/issues/1458\n-          ast::expr_call(_, _, _) => { false }\n+          ast::expr_call(*) => { false }\n \n           _ => { true }\n         }\n@@ -169,7 +176,7 @@ pub fn steal(crate: @ast::crate, tm: test_mode) -> StolenStuff {\n         visit_ty: |a| stash_ty_if(safe_to_steal_ty, tys, a, tm),\n         .. *visit::default_simple_visitor()\n     });\n-    visit::visit_crate(crate, (), v);\n+    visit::visit_crate(crate, ((), v));\n     StolenStuff {\n         exprs: (*exprs).clone(),\n         tys: (*tys).clone(),\n@@ -338,13 +345,13 @@ pub fn check_variants_T<T:Copy>(crate: @ast::crate,\n                                             intr,\n                                             span_handler,\n                                             crate2,\n-                                            fname.to_str(),\n+                                            fname.to_managed(),\n                                             rdr,\n                                             a,\n                                             pprust::no_ann(),\n                                             false)\n                     };\n-                    @string\n+                    string.to_managed()\n                 };\n                 match cx.mode {\n                     tm_converge => check_roundtrip_convergence(str3, 1),\n@@ -354,9 +361,9 @@ pub fn check_variants_T<T:Copy>(crate: @ast::crate,\n                                               thing_label,\n                                               i,\n                                               j);\n-                        let safe_to_run = !(content_is_dangerous_to_run(*str3)\n+                        let safe_to_run = !(content_is_dangerous_to_run(str3)\n                                             || has_raw_pointers(crate2));\n-                        check_whole_compiler(*str3,\n+                        check_whole_compiler(str3,\n                                              &Path(file_label),\n                                              safe_to_run);\n                     }\n@@ -367,8 +374,8 @@ pub fn check_variants_T<T:Copy>(crate: @ast::crate,\n }\n \n pub fn last_part(filename: ~str) -> ~str {\n-    let ix = str::rfind_char(filename, '/').get();\n-    str::slice(filename, ix + 1u, str::len(filename) - 3u).to_owned()\n+    let ix = filename.rfind('/').get();\n+    filename.slice(ix + 1u, filename.len() - 3u).to_owned()\n }\n \n pub enum happiness {\n@@ -426,7 +433,7 @@ pub fn check_running(exe_filename: &Path) -> happiness {\n         \"/Users/jruderman/scripts/timed_run_rust_program.py\",\n         [exe_filename.to_str()]);\n     let comb = str::from_bytes(p.output) + \"\\n\" + str::from_bytes(p.error);\n-    if str::len(comb) > 1u {\n+    if comb.len() > 1u {\n         error!(\"comb comb comb: %?\", comb);\n     }\n \n@@ -495,28 +502,28 @@ pub fn check_compiling(filename: &Path) -> happiness {\n }\n \n \n-pub fn parse_and_print(code: @~str) -> ~str {\n+pub fn parse_and_print(code: @str) -> @str {\n     let filename = Path(\"tmp.rs\");\n     let sess = parse::new_parse_sess(option::None);\n-    write_file(&filename, *code);\n-    let crate = parse::parse_crate_from_source_str(filename.to_str(),\n+    write_file(&filename, code);\n+    let crate = parse::parse_crate_from_source_str(filename.to_str().to_managed(),\n                                                    code,\n                                                    ~[],\n                                                    sess);\n-    do io::with_str_reader(*code) |rdr| {\n+    do io::with_str_reader(code) |rdr| {\n         let filename = filename.to_str();\n         do as_str |a| {\n             pprust::print_crate(sess.cm,\n                                 // Assuming there are no token_trees\n                                 token::mk_fake_ident_interner(),\n                                 copy sess.span_diagnostic,\n                                 crate,\n-                                filename.to_str(),\n+                                filename.to_managed(),\n                                 rdr,\n                                 a,\n                                 pprust::no_ann(),\n                                 false)\n-        }\n+        }.to_managed()\n     }\n }\n \n@@ -532,7 +539,7 @@ pub fn has_raw_pointers(c: @ast::crate) -> bool {\n         visit::mk_simple_visitor(@visit::SimpleVisitor {\n             visit_ty: |a| visit_ty(has_rp, a),\n             .. *visit::default_simple_visitor()});\n-    visit::visit_crate(c, (), v);\n+    visit::visit_crate(c, ((), v));\n     return *has_rp;\n }\n \n@@ -591,15 +598,15 @@ pub fn file_might_not_converge(filename: &Path) -> bool {\n     return false;\n }\n \n-pub fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n+pub fn check_roundtrip_convergence(code: @str, maxIters: uint) {\n     let mut i = 0u;\n     let mut newv = code;\n     let mut oldv = code;\n \n     while i < maxIters {\n         oldv = newv;\n-        if content_might_not_converge(*oldv) { return; }\n-        newv = @parse_and_print(oldv);\n+        if content_might_not_converge(oldv) { return; }\n+        newv = parse_and_print(oldv);\n         if oldv == newv { break; }\n         i += 1u;\n     }\n@@ -608,19 +615,19 @@ pub fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n         error!(\"Converged after %u iterations\", i);\n     } else {\n         error!(\"Did not converge after %u iterations!\", i);\n-        write_file(&Path(\"round-trip-a.rs\"), *oldv);\n-        write_file(&Path(\"round-trip-b.rs\"), *newv);\n+        write_file(&Path(\"round-trip-a.rs\"), oldv);\n+        write_file(&Path(\"round-trip-b.rs\"), newv);\n         run::process_status(\"diff\", [~\"-w\", ~\"-u\", ~\"round-trip-a.rs\", ~\"round-trip-b.rs\"]);\n         fail!(\"Mismatch\");\n     }\n }\n \n pub fn check_convergence(files: &[Path]) {\n-    error!(\"pp convergence tests: %u files\", vec::len(files));\n+    error!(\"pp convergence tests: %u files\", files.len());\n     for files.each |file| {\n         if !file_might_not_converge(file) {\n-            let s = @result::get(&io::read_whole_file_str(file));\n-            if !content_might_not_converge(*s) {\n+            let s = result::get(&io::read_whole_file_str(file)).to_managed();\n+            if !content_might_not_converge(s) {\n                 error!(\"pp converge: %s\", file.to_str());\n                 // Change from 7u to 2u once\n                 // https://github.com/mozilla/rust/issues/850 is fixed\n@@ -639,26 +646,26 @@ pub fn check_variants(files: &[Path], cx: Context) {\n             loop;\n         }\n \n-        let s = @result::get(&io::read_whole_file_str(file));\n-        if contains(*s, \"#\") {\n+        let s = result::get(&io::read_whole_file_str(file)).to_managed();\n+        if s.contains_char('#') {\n             loop; // Macros are confusing\n         }\n-        if cx.mode == tm_converge && content_might_not_converge(*s) {\n+        if cx.mode == tm_converge && content_might_not_converge(s) {\n             loop;\n         }\n-        if cx.mode == tm_run && content_is_dangerous_to_compile(*s) {\n+        if cx.mode == tm_run && content_is_dangerous_to_compile(s) {\n             loop;\n         }\n \n         let file_str = file.to_str();\n \n         error!(\"check_variants: %?\", file_str);\n         let sess = parse::new_parse_sess(None);\n-        let crate = parse::parse_crate_from_source_str(file_str.to_str(),\n+        let crate = parse::parse_crate_from_source_str(file_str.to_managed(),\n                                                        s,\n                                                        ~[],\n                                                        sess);\n-        io::with_str_reader(*s, |rdr| {\n+        io::with_str_reader(s, |rdr| {\n             let file_str = file_str.to_str();\n             error!(\"%s\",\n                    as_str(|a| {\n@@ -668,7 +675,7 @@ pub fn check_variants(files: &[Path], cx: Context) {\n                         token::mk_fake_ident_interner(),\n                         copy sess.span_diagnostic,\n                         crate,\n-                        file_str.to_str(),\n+                        file_str.to_managed(),\n                         rdr,\n                         a,\n                         pprust::no_ann(),\n@@ -681,7 +688,7 @@ pub fn check_variants(files: &[Path], cx: Context) {\n \n pub fn main() {\n     let args = os::args();\n-    if vec::len(args) != 2u {\n+    if args.len() != 2u {\n         error!(\"usage: %s <testdir>\", args[0]);\n         return;\n     }\n@@ -704,4 +711,3 @@ pub mod core {\n     pub use std::cmp;\n     pub use std::sys;\n }\n-"}, {"sha": "9d8f1c1a09175ac351d82421b126b3a02f312951", "filename": "src/librust/rust.rc", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrust%2Frust.rc", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrust%2Frust.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rc?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -31,9 +31,18 @@ extern mod rustc;\n \n use core::prelude::*;\n \n+use core::io;\n+use core::os;\n use core::run;\n use core::libc::exit;\n \n+// For bootstrapping.\n+mod std {\n+    pub use core::os;\n+    pub use core::str;\n+    pub use core::unstable;\n+}\n+\n enum ValidUsage {\n     Valid(int), Invalid\n }\n@@ -214,7 +223,7 @@ fn usage() {\n     );\n \n     for commands.each |command| {\n-        let padding = str::repeat(\" \", indent - command.cmd.len());\n+        let padding = \" \".repeat(indent - command.cmd.len());\n         io::println(fmt!(\"    %s%s%s\",\n                          command.cmd, padding, command.usage_line));\n     }\n@@ -232,7 +241,8 @@ pub fn main() {\n     let args = os_args.tail();\n \n     if !args.is_empty() {\n-        for find_cmd(*args.head()).each |command| {\n+        let r = find_cmd(*args.head());\n+        for r.iter().advance |command| {\n             let result = do_command(command, args.tail());\n             match result {\n                 Valid(exit_code) => unsafe { exit(exit_code.to_i32()) },"}, {"sha": "6aa97e393eab732d7dae73cc479904a8891c9f01", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 138, "deletions": 108, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -18,16 +18,21 @@ use lib::llvm::ModuleRef;\n use lib;\n use metadata::common::LinkMeta;\n use metadata::{encoder, csearch, cstore};\n-use middle::trans::common::CrateContext;\n+use middle::trans::context::CrateContext;\n use middle::ty;\n use util::ppaux;\n \n+use core::char;\n use core::hash::Streaming;\n use core::hash;\n use core::libc::{c_int, c_uint};\n use core::os::consts::{macos, freebsd, linux, android, win32};\n+use core::os;\n+use core::ptr;\n use core::rt::io::Writer;\n use core::run;\n+use core::str;\n+use core::vec;\n use syntax::ast;\n use syntax::ast_map::{path, path_mod, path_name};\n use syntax::attr;\n@@ -44,8 +49,7 @@ pub enum output_type {\n }\n \n fn write_string<W:Writer>(writer: &mut W, string: &str) {\n-    let buffer = str::as_bytes_slice(string);\n-    writer.write(buffer);\n+    writer.write(string.as_bytes());\n }\n \n pub fn llvm_err(sess: Session, msg: ~str) -> ! {\n@@ -97,31 +101,21 @@ pub mod jit {\n     use back::link::llvm_err;\n     use driver::session::Session;\n     use lib::llvm::llvm;\n-    use lib::llvm::{ModuleRef, PassManagerRef};\n+    use lib::llvm::{ModuleRef, ContextRef};\n     use metadata::cstore;\n \n-    use core::libc::c_int;\n-\n-    pub mod rusti {\n-        #[nolink]\n-        #[abi = \"rust-intrinsic\"]\n-        pub extern \"rust-intrinsic\" {\n-            pub fn morestack_addr() -> *();\n-        }\n-    }\n-\n-    pub struct Closure {\n-        code: *(),\n-        env: *(),\n-    }\n+    use core::cast;\n+    use core::ptr;\n+    use core::str;\n+    use core::sys;\n+    use core::unstable::intrinsics;\n \n     pub fn exec(sess: Session,\n-                pm: PassManagerRef,\n+                c: ContextRef,\n                 m: ModuleRef,\n-                opt: c_int,\n                 stacks: bool) {\n         unsafe {\n-            let manager = llvm::LLVMRustPrepareJIT(rusti::morestack_addr());\n+            let manager = llvm::LLVMRustPrepareJIT(intrinsics::morestack_addr());\n \n             // We need to tell JIT where to resolve all linked\n             // symbols from. The equivalent of -lstd, -lcore, etc.\n@@ -145,26 +139,43 @@ pub mod jit {\n                     });\n             }\n \n-            // The execute function will return a void pointer\n-            // to the _rust_main function. We can do closure\n-            // magic here to turn it straight into a callable rust\n-            // closure. It will also cleanup the memory manager\n-            // for us.\n-\n-            let entry = llvm::LLVMRustExecuteJIT(manager,\n-                                                 pm, m, opt, stacks);\n-\n-            if ptr::is_null(entry) {\n-                llvm_err(sess, ~\"Could not JIT\");\n-            } else {\n-                let closure = Closure {\n-                    code: entry,\n-                    env: ptr::null()\n-                };\n-                let func: &fn() = cast::transmute(closure);\n+            // We custom-build a JIT execution engine via some rust wrappers\n+            // first. This wrappers takes ownership of the module passed in.\n+            let ee = llvm::LLVMRustBuildJIT(manager, m, stacks);\n+            if ee.is_null() {\n+                llvm::LLVMContextDispose(c);\n+                llvm_err(sess, ~\"Could not create the JIT\");\n+            }\n \n-                func();\n+            // Next, we need to get a handle on the _rust_main function by\n+            // looking up it's corresponding ValueRef and then requesting that\n+            // the execution engine compiles the function.\n+            let fun = do str::as_c_str(\"_rust_main\") |entry| {\n+                llvm::LLVMGetNamedFunction(m, entry)\n+            };\n+            if fun.is_null() {\n+                llvm::LLVMDisposeExecutionEngine(ee);\n+                llvm::LLVMContextDispose(c);\n+                llvm_err(sess, ~\"Could not find _rust_main in the JIT\");\n             }\n+\n+            // Finally, once we have the pointer to the code, we can do some\n+            // closure magic here to turn it straight into a callable rust\n+            // closure\n+            let code = llvm::LLVMGetPointerToGlobal(ee, fun);\n+            assert!(!code.is_null());\n+            let closure = sys::Closure {\n+                code: code,\n+                env: ptr::null()\n+            };\n+            let func: &fn() = cast::transmute(closure);\n+            func();\n+\n+            // Sadly, there currently is no interface to re-use this execution\n+            // engine, so it's disposed of here along with the context to\n+            // prevent leaks.\n+            llvm::LLVMDisposeExecutionEngine(ee);\n+            llvm::LLVMContextDispose(c);\n         }\n     }\n }\n@@ -181,13 +192,15 @@ pub mod write {\n     use driver::session;\n     use lib::llvm::llvm;\n     use lib::llvm::{ModuleRef, mk_pass_manager, mk_target_data};\n+    use lib::llvm::{ContextRef};\n     use lib;\n \n     use back::passes;\n \n     use core::libc::{c_int, c_uint};\n     use core::path::Path;\n     use core::run;\n+    use core::str;\n \n     pub fn is_object_or_assembly_or_exe(ot: output_type) -> bool {\n         if ot == output_type_assembly || ot == output_type_object ||\n@@ -198,10 +211,13 @@ pub mod write {\n     }\n \n     pub fn run_passes(sess: Session,\n+                      llcx: ContextRef,\n                       llmod: ModuleRef,\n                       output_type: output_type,\n                       output: &Path) {\n         unsafe {\n+            llvm::LLVMInitializePasses();\n+\n             let opts = sess.opts;\n             if sess.time_llvm_passes() { llvm::LLVMRustEnableTimePasses(); }\n             let td = mk_target_data(sess.targ_cfg.target_strs.data_layout);\n@@ -232,19 +248,36 @@ pub mod write {\n             let mut mpm = passes::PassManager::new(td.lltd);\n \n             if !sess.no_verify() {\n-                mpm.addPass(llvm::LLVMCreateVerifierPass());\n+                mpm.add_pass_from_name(\"verify\");\n             }\n \n-            if sess.lint_llvm() {\n-                mpm.addPass(llvm::LLVMCreateLintPass());\n-            }\n+            let passes = if sess.opts.custom_passes.len() > 0 {\n+                copy sess.opts.custom_passes\n+            } else {\n+                if sess.lint_llvm() {\n+                    mpm.add_pass_from_name(\"lint\");\n+                }\n+                passes::create_standard_passes(opts.optimize)\n+            };\n+\n \n-            passes::populatePassManager(&mut mpm, opts.optimize);\n+            debug!(\"Passes: %?\", passes);\n+            passes::populate_pass_manager(sess, &mut mpm, passes);\n \n             debug!(\"Running Module Optimization Pass\");\n             mpm.run(llmod);\n \n-            if is_object_or_assembly_or_exe(output_type) || opts.jit {\n+            if opts.jit {\n+                // If we are using JIT, go ahead and create and execute the\n+                // engine now.  JIT execution takes ownership of the module and\n+                // context, so don't dispose and return.\n+                jit::exec(sess, llcx, llmod, true);\n+\n+                if sess.time_llvm_passes() {\n+                    llvm::LLVMRustPrintPassTimings();\n+                }\n+                return;\n+            } else if is_object_or_assembly_or_exe(output_type) {\n                 let LLVMOptNone       = 0 as c_int; // -O0\n                 let LLVMOptLess       = 1 as c_int; // -O1\n                 let LLVMOptDefault    = 2 as c_int; // -O2, -Os\n@@ -257,20 +290,6 @@ pub mod write {\n                   session::Aggressive => LLVMOptAggressive\n                 };\n \n-                if opts.jit {\n-                    // If we are using JIT, go ahead and create and\n-                    // execute the engine now.\n-                    // JIT execution takes ownership of the module,\n-                    // so don't dispose and return.\n-\n-                    jit::exec(sess, pm.llpm, llmod, CodeGenOptLevel, true);\n-\n-                    if sess.time_llvm_passes() {\n-                        llvm::LLVMRustPrintPassTimings();\n-                    }\n-                    return;\n-                }\n-\n                 let FileType;\n                 if output_type == output_type_object ||\n                        output_type == output_type_exe {\n@@ -331,6 +350,7 @@ pub mod write {\n                 // Clean up and return\n \n                 llvm::LLVMDisposeModule(llmod);\n+                llvm::LLVMContextDispose(llcx);\n                 if sess.time_llvm_passes() {\n                     llvm::LLVMRustPrintPassTimings();\n                 }\n@@ -349,14 +369,15 @@ pub mod write {\n             }\n \n             llvm::LLVMDisposeModule(llmod);\n+            llvm::LLVMContextDispose(llcx);\n             if sess.time_llvm_passes() { llvm::LLVMRustPrintPassTimings(); }\n         }\n     }\n \n     pub fn run_ndk(sess: Session, assembly: &Path, object: &Path) {\n         let cc_prog: ~str = match &sess.opts.android_cross_path {\n-            &Some(copy path) => {\n-                fmt!(\"%s/bin/arm-linux-androideabi-gcc\", path)\n+            &Some(ref path) => {\n+                fmt!(\"%s/bin/arm-linux-androideabi-gcc\", *path)\n             }\n             &None => {\n                 sess.fatal(\"need Android NDK path for building \\\n@@ -375,7 +396,7 @@ pub mod write {\n             sess.err(fmt!(\"building with `%s` failed with code %d\",\n                         cc_prog, prog.status));\n             sess.note(fmt!(\"%s arguments: %s\",\n-                        cc_prog, str::connect(cc_args, \" \")));\n+                        cc_prog, cc_args.connect(\" \")));\n             sess.note(str::from_bytes(prog.error + prog.output));\n             sess.abort_if_errors();\n         }\n@@ -453,16 +474,16 @@ pub fn build_link_meta(sess: Session,\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n         for linkage_metas.each |meta| {\n-            if *attr::get_meta_item_name(*meta) == ~\"name\" {\n+            if \"name\" == attr::get_meta_item_name(*meta) {\n                 match attr::get_meta_item_value_str(*meta) {\n                   // Changing attr would avoid the need for the copy\n                   // here\n-                  Some(v) => { name = Some(v.to_managed()); }\n+                  Some(v) => { name = Some(v); }\n                   None => cmh_items.push(*meta)\n                 }\n-            } else if *attr::get_meta_item_name(*meta) == ~\"vers\" {\n+            } else if \"vers\" == attr::get_meta_item_name(*meta) {\n                 match attr::get_meta_item_value_str(*meta) {\n-                  Some(v) => { vers = Some(v.to_managed()); }\n+                  Some(v) => { vers = Some(v); }\n                   None => cmh_items.push(*meta)\n                 }\n             } else { cmh_items.push(*meta); }\n@@ -478,7 +499,7 @@ pub fn build_link_meta(sess: Session,\n     // This calculates CMH as defined above\n     fn crate_meta_extras_hash(symbol_hasher: &mut hash::State,\n                               cmh_items: ~[@ast::meta_item],\n-                              dep_hashes: ~[~str]) -> @str {\n+                              dep_hashes: ~[@str]) -> @str {\n         fn len_and_str(s: &str) -> ~str {\n             fmt!(\"%u_%s\", s.len(), s)\n         }\n@@ -492,14 +513,14 @@ pub fn build_link_meta(sess: Session,\n         fn hash(symbol_hasher: &mut hash::State, m: &@ast::meta_item) {\n             match m.node {\n               ast::meta_name_value(key, value) => {\n-                write_string(symbol_hasher, len_and_str(*key));\n+                write_string(symbol_hasher, len_and_str(key));\n                 write_string(symbol_hasher, len_and_str_lit(value));\n               }\n               ast::meta_word(name) => {\n-                write_string(symbol_hasher, len_and_str(*name));\n+                write_string(symbol_hasher, len_and_str(name));\n               }\n               ast::meta_list(name, ref mis) => {\n-                write_string(symbol_hasher, len_and_str(*name));\n+                write_string(symbol_hasher, len_and_str(name));\n                 for mis.each |m_| {\n                     hash(symbol_hasher, m_);\n                 }\n@@ -596,16 +617,16 @@ pub fn symbol_hash(tcx: ty::ctxt,\n     write_string(symbol_hasher, encoder::encoded_ty(tcx, t));\n     let mut hash = truncated_hash_result(symbol_hasher);\n     // Prefix with _ so that it never blends into adjacent digits\n-    str::unshift_char(&mut hash, '_');\n+    hash.unshift_char('_');\n     // tjc: allocation is unfortunate; need to change core::hash\n     hash.to_managed()\n }\n \n-pub fn get_symbol_hash(ccx: @CrateContext, t: ty::t) -> @str {\n+pub fn get_symbol_hash(ccx: &mut CrateContext, t: ty::t) -> @str {\n     match ccx.type_hashcodes.find(&t) {\n       Some(&h) => h,\n       None => {\n-        let hash = symbol_hash(ccx.tcx, ccx.symbol_hasher, t, ccx.link_meta);\n+        let hash = symbol_hash(ccx.tcx, &mut ccx.symbol_hasher, t, ccx.link_meta);\n         ccx.type_hashcodes.insert(t, hash);\n         hash\n       }\n@@ -615,26 +636,37 @@ pub fn get_symbol_hash(ccx: @CrateContext, t: ty::t) -> @str {\n \n // Name sanitation. LLVM will happily accept identifiers with weird names, but\n // gas doesn't!\n+// gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n pub fn sanitize(s: &str) -> ~str {\n     let mut result = ~\"\";\n-    for str::each_char(s) |c| {\n+    for s.iter().advance |c| {\n         match c {\n-          '@' => result += \"_sbox_\",\n-          '~' => result += \"_ubox_\",\n-          '*' => result += \"_ptr_\",\n-          '&' => result += \"_ref_\",\n-          ',' => result += \"_\",\n-\n-          '{' | '(' => result += \"_of_\",\n-          'a' .. 'z'\n-          | 'A' .. 'Z'\n-          | '0' .. '9'\n-          | '_' => result.push_char(c),\n-          _ => {\n-            if c > 'z' && char::is_XID_continue(c) {\n-                result.push_char(c);\n+            // Escape these with $ sequences\n+            '@' => result += \"$SP$\",\n+            '~' => result += \"$UP$\",\n+            '*' => result += \"$RP$\",\n+            '&' => result += \"$BP$\",\n+            '<' => result += \"$LT$\",\n+            '>' => result += \"$GT$\",\n+            '(' => result += \"$LP$\",\n+            ')' => result += \"$RP$\",\n+            ',' => result += \"$C$\",\n+\n+            // '.' doesn't occur in types and functions, so reuse it\n+            // for ':'\n+            ':' => result.push_char('.'),\n+\n+            // These are legal symbols\n+            'a' .. 'z'\n+            | 'A' .. 'Z'\n+            | '0' .. '9'\n+            | '_' => result.push_char(c),\n+\n+            _ => {\n+                if c > 'z' && char::is_XID_continue(c) {\n+                    result.push_char(c);\n+                }\n             }\n-          }\n         }\n     }\n \n@@ -655,8 +687,8 @@ pub fn mangle(sess: Session, ss: path) -> ~str {\n \n     for ss.each |s| {\n         match *s { path_name(s) | path_mod(s) => {\n-          let sani = sanitize(*sess.str_of(s));\n-          n += fmt!(\"%u%s\", str::len(sani), sani);\n+          let sani = sanitize(sess.str_of(s));\n+          n += fmt!(\"%u%s\", sani.len(), sani);\n         } }\n     }\n     n += \"E\"; // End name-sequence.\n@@ -673,7 +705,7 @@ pub fn exported_name(sess: Session,\n             path_name(sess.ident_of(vers))));\n }\n \n-pub fn mangle_exported_name(ccx: @CrateContext,\n+pub fn mangle_exported_name(ccx: &mut CrateContext,\n                             path: path,\n                             t: ty::t) -> ~str {\n     let hash = get_symbol_hash(ccx, t);\n@@ -682,7 +714,7 @@ pub fn mangle_exported_name(ccx: @CrateContext,\n                          ccx.link_meta.vers);\n }\n \n-pub fn mangle_internal_name_by_type_only(ccx: @CrateContext,\n+pub fn mangle_internal_name_by_type_only(ccx: &mut CrateContext,\n                                          t: ty::t,\n                                          name: &str) -> ~str {\n     let s = ppaux::ty_to_short_str(ccx.tcx, t);\n@@ -693,7 +725,7 @@ pub fn mangle_internal_name_by_type_only(ccx: @CrateContext,\n           path_name(ccx.sess.ident_of(hash))]);\n }\n \n-pub fn mangle_internal_name_by_type_and_seq(ccx: @CrateContext,\n+pub fn mangle_internal_name_by_type_and_seq(ccx: &mut CrateContext,\n                                          t: ty::t,\n                                          name: &str) -> ~str {\n     let s = ppaux::ty_to_str(ccx.tcx, t);\n@@ -704,33 +736,31 @@ pub fn mangle_internal_name_by_type_and_seq(ccx: @CrateContext,\n           path_name((ccx.names)(name))]);\n }\n \n-pub fn mangle_internal_name_by_path_and_seq(ccx: @CrateContext,\n+pub fn mangle_internal_name_by_path_and_seq(ccx: &mut CrateContext,\n                                             path: path,\n                                             flav: &str) -> ~str {\n     return mangle(ccx.sess,\n                   vec::append_one(path, path_name((ccx.names)(flav))));\n }\n \n-pub fn mangle_internal_name_by_path(ccx: @CrateContext, path: path) -> ~str {\n+pub fn mangle_internal_name_by_path(ccx: &mut CrateContext, path: path) -> ~str {\n     return mangle(ccx.sess, path);\n }\n \n-pub fn mangle_internal_name_by_seq(ccx: @CrateContext, flav: &str) -> ~str {\n-    return fmt!(\"%s_%u\", flav, (ccx.names)(flav).repr);\n+pub fn mangle_internal_name_by_seq(ccx: &mut CrateContext, flav: &str) -> ~str {\n+    return fmt!(\"%s_%u\", flav, (ccx.names)(flav).name);\n }\n \n \n pub fn output_dll_filename(os: session::os, lm: LinkMeta) -> ~str {\n-    let libname = fmt!(\"%s-%s-%s\", lm.name, lm.extras_hash, lm.vers);\n     let (dll_prefix, dll_suffix) = match os {\n         session::os_win32 => (win32::DLL_PREFIX, win32::DLL_SUFFIX),\n         session::os_macos => (macos::DLL_PREFIX, macos::DLL_SUFFIX),\n         session::os_linux => (linux::DLL_PREFIX, linux::DLL_SUFFIX),\n         session::os_android => (android::DLL_PREFIX, android::DLL_SUFFIX),\n         session::os_freebsd => (freebsd::DLL_PREFIX, freebsd::DLL_SUFFIX),\n     };\n-    return str::to_owned(dll_prefix) + libname +\n-           str::to_owned(dll_suffix);\n+    fmt!(\"%s%s-%s-%s%s\", dll_prefix, lm.name, lm.extras_hash, lm.vers, dll_suffix)\n }\n \n // If the user wants an exe generated we need to invoke\n@@ -745,12 +775,12 @@ pub fn link_binary(sess: Session,\n     // For win32, there is no cc command,\n     // so we add a condition to make it use gcc.\n     let cc_prog: ~str = match sess.opts.linker {\n-        Some(copy linker) => linker,\n+        Some(ref linker) => copy *linker,\n         None => {\n             if sess.targ_cfg.os == session::os_android {\n                 match &sess.opts.android_cross_path {\n-                    &Some(copy path) => {\n-                        fmt!(\"%s/bin/arm-linux-androideabi-gcc\", path)\n+                    &Some(ref path) => {\n+                        fmt!(\"%s/bin/arm-linux-androideabi-gcc\", *path)\n                     }\n                     &None => {\n                         sess.fatal(\"need Android NDK path for linking \\\n@@ -781,14 +811,14 @@ pub fn link_binary(sess: Session,\n \n     debug!(\"output: %s\", output.to_str());\n     let cc_args = link_args(sess, obj_filename, out_filename, lm);\n-    debug!(\"%s link args: %s\", cc_prog, str::connect(cc_args, \" \"));\n+    debug!(\"%s link args: %s\", cc_prog, cc_args.connect(\" \"));\n     // We run 'cc' here\n     let prog = run::process_output(cc_prog, cc_args);\n     if 0 != prog.status {\n         sess.err(fmt!(\"linking with `%s` failed with code %d\",\n                       cc_prog, prog.status));\n         sess.note(fmt!(\"%s arguments: %s\",\n-                       cc_prog, str::connect(cc_args, \" \")));\n+                       cc_prog, cc_args.connect(\" \")));\n         sess.note(str::from_bytes(prog.error + prog.output));\n         sess.abort_if_errors();\n     }\n@@ -863,7 +893,7 @@ pub fn link_args(sess: Session,\n     }\n \n     let ula = cstore::get_used_link_args(cstore);\n-    for ula.each |arg| { args.push(/*bad*/copy *arg); }\n+    for ula.each |arg| { args.push(arg.to_owned()); }\n \n     // Add all the link args for external crates.\n     do cstore::iter_crate_data(cstore) |crate_num, _| {"}, {"sha": "315bb5d63177f8a54cd0f4723f27cece4b89b7a8", "filename": "src/librustc/back/passes.rs", "status": "modified", "additions": 250, "deletions": 80, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fback%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fback%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fpasses.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -9,8 +9,11 @@\n // except according to those terms.\n \n use core::prelude::*;\n+use core::str;\n+use core::io;\n \n-use driver::session;\n+use driver::session::{OptLevel, No, Less, Aggressive};\n+use driver::session::{Session};\n use lib::llvm::{PassRef, ModuleRef,PassManagerRef,TargetDataRef};\n use lib::llvm::llvm;\n use lib;\n@@ -39,116 +42,283 @@ impl PassManager {\n         }\n     }\n \n-    pub fn addPass(&mut self, pass:PassRef) {\n+    pub fn add_pass(&mut self, pass:PassRef) {\n         unsafe {\n             llvm::LLVMAddPass(self.llpm, pass);\n         }\n     }\n \n+    pub fn add_pass_from_name(&mut self, name:&str) {\n+        let pass = create_pass(name).unwrap();\n+        self.add_pass(pass);\n+    }\n+\n     pub fn run(&self, md:ModuleRef) -> bool {\n         unsafe {\n             llvm::LLVMRunPassManager(self.llpm, md) == lib::llvm::True\n         }\n     }\n }\n \n+pub fn create_standard_passes(level:OptLevel) -> ~[~str] {\n+    let mut passes = ~[~\"strip-dead-prototypes\"];\n \n-pub fn populatePassManager(pm: &mut PassManager, level:session::OptLevel) {\n-    unsafe {\n-        // We add a lot of normally-unused prototypes, so always strip them\n-        // straight away, later passes will get rid of any that are optimized\n-        // away\n-        pm.addPass(llvm::LLVMCreateStripDeadPrototypesPass());\n-        if level == session::No {\n-            pm.addPass(llvm::LLVMCreateAlwaysInlinerPass());\n+    if level == No {\n+        passes.push(~\"always-inline\");\n+        return passes;\n+    }\n \n-            return;\n-        }\n+    passes.push(~\"targetlibinfo\");\n \n-        //NOTE: Add library info\n+    passes.push(~\"scev-aa\");\n+    passes.push(~\"basicaa\");\n \n-        pm.addPass(llvm::LLVMCreateTypeBasedAliasAnalysisPass());\n-        pm.addPass(llvm::LLVMCreateBasicAliasAnalysisPass());\n+    passes.push(~\"instcombine\");\n+    passes.push(~\"simplifycfg\");\n+    passes.push(~\"scalarrepl-ssa\");\n+    passes.push(~\"early-cse\");\n \n-        pm.addPass(llvm::LLVMCreateSROAPass());\n-        pm.addPass(llvm::LLVMCreateEarlyCSEPass());\n-        pm.addPass(llvm::LLVMCreateLowerExpectIntrinsicPass());\n+    passes.push(~\"globalopt\");\n+    passes.push(~\"ipsccp\");\n+    passes.push(~\"deadargelim\");\n+    passes.push(~\"instcombine\");\n+    passes.push(~\"simplifycfg\");\n \n-        pm.addPass(llvm::LLVMCreateGlobalOptimizerPass());\n-        pm.addPass(llvm::LLVMCreateIPSCCPPass());\n-        pm.addPass(llvm::LLVMCreateDeadArgEliminationPass());\n-        pm.addPass(llvm::LLVMCreateInstructionCombiningPass());\n-        pm.addPass(llvm::LLVMCreateCFGSimplificationPass());\n+    passes.push(~\"prune-eh\");\n \n-        pm.addPass(llvm::LLVMCreatePruneEHPass());\n+    passes.push(~\"inline\");\n \n-        if level == session::Aggressive {\n-            // Do this before inlining, since inlining might\n-            // make minor changes to functions that mean they\n-            // can't be merged, despite being almost identical\n-            pm.addPass(llvm::LLVMCreateMergeFunctionsPass());\n-        }\n+    passes.push(~\"functionattrs\");\n \n-        match level {\n-            session::Less       => pm.addPass(llvm::LLVMCreateFunctionInliningPass(200)),\n-            session::Default    => pm.addPass(llvm::LLVMCreateFunctionInliningPass(225)),\n-            session::Aggressive => pm.addPass(llvm::LLVMCreateFunctionInliningPass(275)),\n-            session::No         => ()\n-        }\n+    if level == Aggressive {\n+        passes.push(~\"argpromotion\");\n+    }\n \n-        pm.addPass(llvm::LLVMCreateFunctionAttrsPass());\n+    passes.push(~\"scalarrepl-ssa\");\n+    passes.push(~\"early-cse\");\n+    passes.push(~\"simplify-libcalls\");\n+    passes.push(~\"jump-threading\");\n+    passes.push(~\"correlated-propagation\");\n+    passes.push(~\"simplifycfg\");\n+    passes.push(~\"instcombine\");\n \n-        if level == session::Aggressive {\n-            pm.addPass(llvm::LLVMCreateArgumentPromotionPass());\n-        }\n+    passes.push(~\"tailcallelim\");\n+    passes.push(~\"simplifycfg\");\n+    passes.push(~\"reassociate\");\n+    passes.push(~\"loop-rotate\");\n+    passes.push(~\"licm\");\n+\n+    passes.push(~\"lcssa\");\n+    passes.push(~\"loop-unswitch\");\n+\n+    passes.push(~\"instcombine\");\n+    passes.push(~\"indvars\");\n+    passes.push(~\"loop-idiom\");\n+    passes.push(~\"loop-deletion\");\n+\n+    if level == Aggressive {\n+        passes.push(~\"loop-vectorize\");\n+    }\n+\n+    passes.push(~\"loop-unroll\");\n+\n+    if level != Less {\n+        passes.push(~\"gvn\");\n+    }\n+\n+    passes.push(~\"memcpyopt\");\n+    passes.push(~\"sccp\");\n+\n+    passes.push(~\"instcombine\");\n+    passes.push(~\"jump-threading\");\n+    passes.push(~\"correlated-propagation\");\n+    passes.push(~\"dse\");\n+\n+    passes.push(~\"adce\");\n+    passes.push(~\"simplifycfg\");\n+    passes.push(~\"instsimplify\");\n+\n+    if level != Less {\n+        passes.push(~\"globaldce\");\n+        passes.push(~\"constmerge\");\n+    }\n \n-        pm.addPass(llvm::LLVMCreateEarlyCSEPass());\n-        pm.addPass(llvm::LLVMCreateSimplifyLibCallsPass());\n-        pm.addPass(llvm::LLVMCreateJumpThreadingPass());\n-        pm.addPass(llvm::LLVMCreateCorrelatedValuePropagationPass());\n-        pm.addPass(llvm::LLVMCreateCFGSimplificationPass());\n-        pm.addPass(llvm::LLVMCreateInstructionCombiningPass());\n-\n-        pm.addPass(llvm::LLVMCreateTailCallEliminationPass());\n-        pm.addPass(llvm::LLVMCreateCFGSimplificationPass());\n-        pm.addPass(llvm::LLVMCreateReassociatePass());\n-        pm.addPass(llvm::LLVMCreateLoopRotatePass());\n-        pm.addPass(llvm::LLVMCreateLICMPass());\n-\n-        pm.addPass(llvm::LLVMCreateInstructionCombiningPass());\n-        pm.addPass(llvm::LLVMCreateIndVarSimplifyPass());\n-        pm.addPass(llvm::LLVMCreateLoopIdiomPass());\n-        pm.addPass(llvm::LLVMCreateLoopDeletionPass());\n-\n-        if level == session::Aggressive {\n-            pm.addPass(llvm::LLVMCreateLoopVectorizePass());\n+    return passes;\n+}\n+\n+pub fn populate_pass_manager(sess: Session, pm: &mut PassManager, pass_list:&[~str]) {\n+    for pass_list.each |&nm| {\n+        match create_pass(nm) {\n+            Some(p) => pm.add_pass(p),\n+            None    => sess.warn(fmt!(\"Unknown pass %s\", nm))\n         }\n-        pm.addPass(llvm::LLVMCreateLoopUnrollPass());\n+    }\n+}\n \n-        if level != session::Less {\n-            pm.addPass(llvm::LLVMCreateGVNPass());\n+pub fn create_pass(name:&str) -> Option<PassRef> {\n+    do str::as_c_str(name) |s| {\n+        unsafe {\n+            let p = llvm::LLVMCreatePass(s);\n+            if p.is_null() {\n+                None\n+            } else {\n+                Some(p)\n+            }\n         }\n-        pm.addPass(llvm::LLVMCreateMemCpyOptPass());\n-        pm.addPass(llvm::LLVMCreateSCCPPass());\n+    }\n+}\n \n-        pm.addPass(llvm::LLVMCreateInstructionCombiningPass());\n-        pm.addPass(llvm::LLVMCreateJumpThreadingPass());\n-        pm.addPass(llvm::LLVMCreateCorrelatedValuePropagationPass());\n-        pm.addPass(llvm::LLVMCreateDeadStoreEliminationPass());\n+pub fn list_passes() {\n+    io::println(\"\\nAvailable Passes:\");\n \n-        pm.addPass(llvm::LLVMCreateBBVectorizePass());\n-        pm.addPass(llvm::LLVMCreateInstructionCombiningPass());\n-        pm.addPass(llvm::LLVMCreateEarlyCSEPass());\n+    io::println(\"\\nAnalysis Passes:\");\n+    for analysis_passes.each |&(name, desc)| {\n+        io::println(fmt!(\"    %-30s -- %s\", name, desc));\n+    }\n+    io::println(\"\\nTransformation Passes:\");\n+    for transform_passes.each |&(name, desc)| {\n+        io::println(fmt!(\"    %-30s -- %s\", name, desc));\n+    }\n+    io::println(\"\\nUtility Passes:\");\n+    for utility_passes.each |&(name, desc)| {\n+        io::println(fmt!(\"    %-30s -- %s\", name, desc));\n+    }\n+}\n+\n+/** Analysis Passes */\n+pub static analysis_passes : &'static [(&'static str, &'static str)] = &'static [\n+    (\"aa-eval\",                         \"Exhausive Alias Analysis Precision Evaluator\"),\n+    (\"asan\",                            \"AddressSanitizer\"),\n+    (\"basicaa\",                         \"Basic Alias Analysis\"),\n+    (\"basiccg\",                         \"Basic CallGraph Construction\"),\n+    (\"block-freq\",                      \"Block Frequency Analysis\"),\n+    (\"cost-model\",                      \"Cost Model Analysis\"),\n+    (\"count-aa\",                        \"Count Alias Analysis Query Responses\"),\n+    (\"da\",                              \"Dependence Analysis\"),\n+    (\"debug-aa\",                        \"AA Use Debugger\"),\n+    (\"domfrontier\",                     \"Dominance Frontier Construction\"),\n+    (\"domtree\",                         \"Dominator Tree Construction\"),\n+    (\"globalsmodref-aa\",                \"Simple mod/ref analysis for globals\"),\n+    (\"instcount\",                       \"Count the various types of Instructions\"),\n+    (\"intervals\",                       \"Interval Partition Construction\"),\n+    (\"iv-users\",                        \"Induction Variable Users\"),\n+    (\"lazy-value-info\",                 \"Lazy Value Information Analysis\"),\n+    (\"libcall-aa\",                      \"LibCall Alias Analysis\"),\n+    (\"lint\",                            \"Statically lint-check LLVM IR\"),\n+    (\"loops\",                           \"Natural Loop Information\"),\n+    (\"memdep\",                          \"Memory Dependence Analysis\"),\n+    (\"module-debuginfo\",                \"Decodes module-level debug info\"),\n+    (\"profile-estimator\",               \"Estimate profiling information\"),\n+    (\"profile-loader\",                  \"Load profile information from llvmprof.out\"),\n+    (\"profile-verifier\",                \"Verify profiling information\"),\n+    (\"regions\",                         \"Detect single entry single exit regions\"),\n+    (\"scalar-evolution\",                \"Scalar Evolution Analysis\"),\n+    (\"scev-aa\",                         \"Scalar Evolution-based Alias Analysis\"),\n+    (\"tbaa\",                            \"Type-Based Alias Analysis\"),\n+    (\"tsan\",                            \"ThreadSanitizer\"),\n+];\n+\n+/** Transformation Passes */\n+pub static transform_passes : &'static [(&'static str, &'static str)] = &'static [\n+    (\"adce\",                            \"Aggressive Dead Code Elimination\"),\n+    (\"always-inline\",                   \"Inliner for #[inline(always)] functions\"),\n+    (\"argpromotion\",                    \"Promote 'by reference' arguments to scalars\"),\n+    (\"bb-vectorize\",                    \"Basic-Block Vectorization\"),\n+    (\"block-placement\",                 \"Profile Guided Basic Block Placement\"),\n+    (\"bounds-checking\",                 \"Run-time bounds checking\"),\n+    (\"break-crit-edges\",                \"Break critical edges in CFG\"),\n+    (\"codegenprepare\",                  \"Optimize for code generation\"),\n+    (\"constmerge\",                      \"Merge Duplicate Global Constants\"),\n+    (\"constprop\",                       \"Simple constant propagation\"),\n+    (\"correlated-propagation\",          \"Value Propagation\"),\n+    (\"da\",                              \"Data Layout\"),\n+    (\"dce\",                             \"Dead Code Elimination\"),\n+    (\"deadargelim\",                     \"Dead Argument Elimination\"),\n+    (\"die\",                             \"Dead Instruction Elimination\"),\n+    (\"dse\",                             \"Dead Store Elimination\"),\n+    (\"early-cse\",                       \"Early CSE\"),\n+    (\"functionattrs\",                   \"Deduce function attributes\"),\n+    (\"globaldce\",                       \"Dead Global Elimination\"),\n+    (\"globalopt\",                       \"Global Variable Optimizer\"),\n+    (\"gvn\",                             \"Global Value Numbering\"),\n+    (\"indvars\",                         \"Canonicalize Induction Variables\"),\n+    (\"inline\",                          \"Function Integration/Inlining\"),\n+    (\"insert-edge-profiling\",           \"Insert instrumentation for edge profiling\"),\n+    (\"insert-gcov-profiling\",           \"Insert instrumentation for GCOV profiling\"),\n+    (\"insert-optimal-edge-profiling\",   \"Insert optimal instrumentation for edge profiling\"),\n+    (\"instcombine\",                     \"Combine redundant instructions\"),\n+    (\"instsimplify\",                    \"Remove redundant instructions\"),\n+    (\"ipconstprop\",                     \"Interprocedural constant propagation\"),\n+    (\"ipsccp\",                          \"Interprocedural Sparse Conditional Constant Propagation\"),\n+    (\"jump-threading\",                  \"Jump Threading\"),\n+    (\"lcssa\",                           \"Loop-Closed SSA Form Pass\"),\n+    (\"licm\",                            \"Loop Invariant Code Motion\"),\n+    (\"loop-deletion\",                   \"Delete dead loops\"),\n+    (\"loop-extract\",                    \"Extract loops into new functions\"),\n+    (\"loop-extract-single\",             \"Extract at most one loop into a new function\"),\n+    (\"loop-idiom\",                      \"Recognise loop idioms\"),\n+    (\"loop-instsimplify\",               \"Simplify instructions in loops\"),\n+    (\"loop-reduce\",                     \"Loop Strength Reduction\"),\n+    (\"loop-rotate\",                     \"Rotate Loops\"),\n+    (\"loop-simplify\",                   \"Canonicalize natural loops\"),\n+    (\"loop-unroll\",                     \"Unroll loops\"),\n+    (\"loop-unswitch\",                   \"Unswitch loops\"),\n+    (\"loop-vectorize\",                  \"Loop Vectorization\"),\n+    (\"lower-expect\",                    \"Lower 'expect' Intrinsics\"),\n+    (\"mem2reg\",                         \"Promote Memory to Register\"),\n+    (\"memcpyopt\",                       \"MemCpy Optimization\"),\n+    (\"mergefunc\",                       \"Merge Functions\"),\n+    (\"mergereturn\",                     \"Unify function exit nodes\"),\n+    (\"partial-inliner\",                 \"Partial Inliner\"),\n+    (\"prune-eh\",                        \"Remove unused exception handling info\"),\n+    (\"reassociate\",                     \"Reassociate expressions\"),\n+    (\"reg2mem\",                         \"Demote all values to stack slots\"),\n+    (\"scalarrepl\",                      \"Scalar Replacement of Aggregates (DT)\"),\n+    (\"scalarrepl-ssa\",                  \"Scalar Replacement of Aggregates (SSAUp)\"),\n+    (\"sccp\",                            \"Sparse Conditional Constant Propagation\"),\n+    (\"simplify-libcalls\",               \"Simplify well-known library calls\"),\n+    (\"simplifycfg\",                     \"Simplify the CFG\"),\n+    (\"sink\",                            \"Code sinking\"),\n+    (\"strip\",                           \"Strip all symbols from a module\"),\n+    (\"strip-dead-debug-info\",           \"Strip debug info for unused symbols\"),\n+    (\"strip-dead-prototypes\",           \"Strip Unused Function Prototypes\"),\n+    (\"strip-debug-declare\",             \"Strip all llvm.dbg.declare intrinsics\"),\n+    (\"strip-nondebug\",                  \"Strip all symbols, except dbg symbols, from a module\"),\n+    (\"sroa\",                            \"Scalar Replacement of Aggregates\"),\n+    (\"tailcallelim\",                    \"Tail Call Elimination\"),\n+];\n \n-        pm.addPass(llvm::LLVMCreateLoopUnrollPass());\n+/** Utility Passes */\n+static utility_passes : &'static [(&'static str, &'static str)] = &'static [\n+    (\"instnamer\",                       \"Assign names to anonymous instructions\"),\n+    (\"verify\",                          \"Module Verifier\"),\n+];\n \n-        pm.addPass(llvm::LLVMCreateAggressiveDCEPass());\n-        pm.addPass(llvm::LLVMCreateCFGSimplificationPass());\n-        pm.addPass(llvm::LLVMCreateInstructionSimplifierPass());\n+#[test]\n+fn passes_exist() {\n+    let mut failed = ~[];\n+    unsafe { llvm::LLVMInitializePasses(); }\n+    for analysis_passes.each() |&(name,_)| {\n+        if !create_pass(name).is_some() {\n+            failed.push(name);\n+        }\n+    }\n+    for transform_passes.each() |&(name,_)| {\n+        if !create_pass(name).is_some() {\n+            failed.push(name);\n+        }\n+    }\n+    for utility_passes.each() |&(name,_)| {\n+        if !create_pass(name).is_some() {\n+            failed.push(name);\n+        }\n+    }\n \n-        if level != session::Less {\n-            pm.addPass(llvm::LLVMCreateGlobalDCEPass());\n-            pm.addPass(llvm::LLVMCreateConstantMergePass());\n+    if failed.len() > 0 {\n+        io::println(\"Some passes don't exist:\");\n+        for failed.each |&n| {\n+            io::println(fmt!(\"    %s\", n));\n         }\n+        fail!();\n     }\n }"}, {"sha": "85fc0575170bc8b76ae4065d51df8167d582f413", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -14,8 +14,11 @@ use driver::session;\n use metadata::cstore;\n use metadata::filesearch;\n \n-use core::util;\n use core::hashmap::HashSet;\n+use core::os;\n+use core::uint;\n+use core::util;\n+use core::vec;\n \n fn not_win32(os: session::os) -> bool {\n   match os {\n@@ -74,10 +77,6 @@ fn get_rpaths(os: session::os,\n     // crates they depend on.\n     let rel_rpaths = get_rpaths_relative_to_output(os, output, libs);\n \n-    // Make backup absolute paths to the libraries. Binaries can\n-    // be moved as long as the crates they link against don't move.\n-    let abs_rpaths = get_absolute_rpaths(libs);\n-\n     // And a final backup rpath to the global library location.\n     let fallback_rpaths = ~[get_install_prefix_rpath(target_triple)];\n \n@@ -89,11 +88,9 @@ fn get_rpaths(os: session::os,\n     }\n \n     log_rpaths(\"relative\", rel_rpaths);\n-    log_rpaths(\"absolute\", abs_rpaths);\n     log_rpaths(\"fallback\", fallback_rpaths);\n \n     let mut rpaths = rel_rpaths;\n-    rpaths.push_all(abs_rpaths);\n     rpaths.push_all(fallback_rpaths);\n \n     // Remove duplicates\n@@ -163,19 +160,11 @@ pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n     }\n }\n \n-fn get_absolute_rpaths(libs: &[Path]) -> ~[Path] {\n-    vec::map(libs, |a| get_absolute_rpath(a) )\n-}\n-\n-pub fn get_absolute_rpath(lib: &Path) -> Path {\n-    os::make_absolute(lib).dir_path()\n-}\n-\n #[cfg(stage0)]\n pub fn get_install_prefix_rpath(target_triple: &str) -> Path {\n     let install_prefix = env!(\"CFG_PREFIX\");\n \n-    if install_prefix == ~\"\" {\n+    if install_prefix.is_empty() {\n         fail!(\"rustc compiled without CFG_PREFIX environment variable\");\n     }\n \n@@ -210,7 +199,14 @@ pub fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n mod test {\n     use core::prelude::*;\n \n-    use back::rpath::{get_absolute_rpath, get_install_prefix_rpath};\n+    use core::os;\n+    use core::str;\n+\n+    // FIXME(#2119): the outer attribute should be #[cfg(unix, test)], then\n+    // these redundant #[cfg(test)] blocks can be removed\n+    #[cfg(test)]\n+    #[cfg(test)]\n+    use back::rpath::{get_install_prefix_rpath};\n     use back::rpath::{get_relative_to, get_rpath_relative_to_output};\n     use back::rpath::{minimize_rpaths, rpaths_to_flags};\n     use driver::session;\n@@ -230,7 +226,7 @@ mod test {\n         debug!(\"test_prefix_path: %s vs. %s\",\n                res.to_str(),\n                d.to_str());\n-        assert!(str::ends_with(res.to_str(), d.to_str()));\n+        assert!(res.to_str().ends_with(d.to_str()));\n     }\n \n     #[test]\n@@ -354,14 +350,4 @@ mod test {\n                                                &Path(\"lib/libstd.so\"));\n         assert_eq!(res.to_str(), ~\"@executable_path/../lib\");\n     }\n-\n-    #[test]\n-    fn test_get_absolute_rpath() {\n-        let res = get_absolute_rpath(&Path(\"lib/libstd.so\"));\n-        debug!(\"test_get_absolute_rpath: %s vs. %s\",\n-               res.to_str(),\n-               os::make_absolute(&Path(\"lib\")).to_str());\n-\n-        assert_eq!(res, os::make_absolute(&Path(\"lib\")));\n-    }\n }"}, {"sha": "73347f2b91d61ba2cfa0045a71322a4e7cebef62", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 166, "deletions": 126, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -28,7 +28,6 @@ use core::hashmap::HashMap;\n use core::int;\n use core::io;\n use core::os;\n-use core::str;\n use core::vec;\n use extra::getopts::groups::{optopt, optmulti, optflag, optflagopt};\n use extra::getopts::{opt_present};\n@@ -39,6 +38,7 @@ use syntax::attr;\n use syntax::codemap;\n use syntax::diagnostic;\n use syntax::parse;\n+use syntax::parse::token;\n use syntax::print::{pp, pprust};\n use syntax;\n \n@@ -54,31 +54,31 @@ pub enum pp_mode {\n  * The name used for source code that doesn't originate in a file\n  * (e.g. source from stdin or a string)\n  */\n-pub fn anon_src() -> ~str { ~\"<anon>\" }\n+pub fn anon_src() -> @str { @\"<anon>\" }\n \n-pub fn source_name(input: &input) -> ~str {\n+pub fn source_name(input: &input) -> @str {\n     match *input {\n-      file_input(ref ifile) => ifile.to_str(),\n+      file_input(ref ifile) => ifile.to_str().to_managed(),\n       str_input(_) => anon_src()\n     }\n }\n \n-pub fn default_configuration(sess: Session, argv0: @~str, input: &input) ->\n+pub fn default_configuration(sess: Session, argv0: @str, input: &input) ->\n    ast::crate_cfg {\n     let libc = match sess.targ_cfg.os {\n-      session::os_win32 => ~\"msvcrt.dll\",\n-      session::os_macos => ~\"libc.dylib\",\n-      session::os_linux => ~\"libc.so.6\",\n-      session::os_android => ~\"libc.so\",\n-      session::os_freebsd => ~\"libc.so.7\"\n+      session::os_win32 => @\"msvcrt.dll\",\n+      session::os_macos => @\"libc.dylib\",\n+      session::os_linux => @\"libc.so.6\",\n+      session::os_android => @\"libc.so\",\n+      session::os_freebsd => @\"libc.so.7\"\n       // _ { \"libc.so\" }\n     };\n     let tos = match sess.targ_cfg.os {\n-      session::os_win32 => ~\"win32\",\n-      session::os_macos => ~\"macos\",\n-      session::os_linux => ~\"linux\",\n-      session::os_android => ~\"android\",\n-      session::os_freebsd => ~\"freebsd\"\n+      session::os_win32 => @\"win32\",\n+      session::os_macos => @\"macos\",\n+      session::os_linux => @\"linux\",\n+      session::os_android => @\"android\",\n+      session::os_freebsd => @\"freebsd\"\n       // _ { \"libc.so\" }\n     };\n \n@@ -87,47 +87,47 @@ pub fn default_configuration(sess: Session, argv0: @~str, input: &input) ->\n     // ARM is bi-endian, however using NDK seems to default\n     // to little-endian unless a flag is provided.\n     let (end,arch,wordsz) = match sess.targ_cfg.arch {\n-        abi::X86 => (~\"little\",~\"x86\",~\"32\"),\n-        abi::X86_64 => (~\"little\",~\"x86_64\",~\"64\"),\n-        abi::Arm => (~\"little\",~\"arm\",~\"32\"),\n-        abi::Mips => (~\"big\",~\"mips\",~\"32\")\n+        abi::X86 => (@\"little\",@\"x86\",@\"32\"),\n+        abi::X86_64 => (@\"little\",@\"x86_64\",@\"64\"),\n+        abi::Arm => (@\"little\",@\"arm\",@\"32\"),\n+        abi::Mips => (@\"big\",@\"mips\",@\"32\")\n     };\n \n     return ~[ // Target bindings.\n-         attr::mk_word_item(@str::to_owned(os::FAMILY)),\n-         mk(@~\"target_os\", @tos),\n-         mk(@~\"target_family\", @str::to_owned(os::FAMILY)),\n-         mk(@~\"target_arch\", @arch),\n-         mk(@~\"target_endian\", @end),\n-         mk(@~\"target_word_size\", @wordsz),\n-         mk(@~\"target_libc\", @libc),\n+         attr::mk_word_item(os::FAMILY.to_managed()),\n+         mk(@\"target_os\", tos),\n+         mk(@\"target_family\", os::FAMILY.to_managed()),\n+         mk(@\"target_arch\", arch),\n+         mk(@\"target_endian\", end),\n+         mk(@\"target_word_size\", wordsz),\n+         mk(@\"target_libc\", libc),\n          // Build bindings.\n-         mk(@~\"build_compiler\", argv0),\n-         mk(@~\"build_input\", @source_name(input))];\n+         mk(@\"build_compiler\", argv0),\n+         mk(@\"build_input\", source_name(input))];\n }\n \n-pub fn append_configuration(cfg: ast::crate_cfg, name: ~str)\n+pub fn append_configuration(cfg: ast::crate_cfg, name: @str)\n                          -> ast::crate_cfg {\n     if attr::contains_name(cfg, name) {\n         cfg\n     } else {\n-        vec::append_one(cfg, attr::mk_word_item(@name))\n+        vec::append_one(cfg, attr::mk_word_item(name))\n     }\n }\n \n-pub fn build_configuration(sess: Session, argv0: @~str, input: &input) ->\n+pub fn build_configuration(sess: Session, argv0: @str, input: &input) ->\n    ast::crate_cfg {\n     // Combine the configuration requested by the session (command line) with\n     // some default and generated configuration items\n     let default_cfg = default_configuration(sess, argv0, input);\n     let user_cfg = /*bad*/copy sess.opts.cfg;\n     // If the user wants a test runner, then add the test cfg\n-    let user_cfg = if sess.opts.test { append_configuration(user_cfg, ~\"test\") }\n+    let user_cfg = if sess.opts.test { append_configuration(user_cfg, @\"test\") }\n                    else { user_cfg };\n     // If the user requested GC, then add the GC cfg\n     let user_cfg = append_configuration(\n         user_cfg,\n-        if sess.opts.gc { ~\"gc\" } else { ~\"nogc\" });\n+        if sess.opts.gc { @\"gc\" } else { @\"nogc\" });\n     return vec::append(user_cfg, default_cfg);\n }\n \n@@ -136,15 +136,16 @@ fn parse_cfgspecs(cfgspecs: ~[~str],\n                   demitter: diagnostic::Emitter) -> ast::crate_cfg {\n     do vec::map_consume(cfgspecs) |s| {\n         let sess = parse::new_parse_sess(Some(demitter));\n-        parse::parse_meta_from_source_str(~\"cfgspec\", @s, ~[], sess)\n+        parse::parse_meta_from_source_str(@\"cfgspec\", s.to_managed(), ~[], sess)\n     }\n }\n \n pub enum input {\n     /// Load source from file\n     file_input(Path),\n     /// The string is the source\n-    str_input(~str)\n+    // FIXME (#2319): Don't really want to box the source string\n+    str_input(@str)\n }\n \n pub fn parse_input(sess: Session, cfg: ast::crate_cfg, input: &input)\n@@ -153,16 +154,22 @@ pub fn parse_input(sess: Session, cfg: ast::crate_cfg, input: &input)\n       file_input(ref file) => {\n         parse::parse_crate_from_file(&(*file), cfg, sess.parse_sess)\n       }\n-      str_input(ref src) => {\n-        // FIXME (#2319): Don't really want to box the source string\n+      str_input(src) => {\n         parse::parse_crate_from_source_str(\n-            anon_src(), @(/*bad*/copy *src), cfg, sess.parse_sess)\n+            anon_src(), src, cfg, sess.parse_sess)\n       }\n     }\n }\n \n+/// First phase to do, last phase to do\n #[deriving(Eq)]\n-pub enum compile_upto {\n+pub struct compile_upto {\n+    from: compile_phase,\n+    to: compile_phase\n+}\n+\n+#[deriving(Eq)]\n+pub enum compile_phase {\n     cu_parse,\n     cu_expand,\n     cu_typeck,\n@@ -177,34 +184,40 @@ pub enum compile_upto {\n #[fixed_stack_segment]\n pub fn compile_rest(sess: Session,\n                     cfg: ast::crate_cfg,\n-                    upto: compile_upto,\n+                    phases: compile_upto,\n                     outputs: Option<@OutputFilenames>,\n                     curr: Option<@ast::crate>)\n     -> (Option<@ast::crate>, Option<ty::ctxt>) {\n \n     let time_passes = sess.time_passes();\n \n-    let (llmod, link_meta) = {\n+    let mut crate_opt = curr;\n \n-        let mut crate = curr.unwrap();\n+    if phases.from == cu_parse || phases.from == cu_everything {\n \n         *sess.building_library = session::building_library(\n-            sess.opts.crate_type, crate, sess.opts.test);\n+            sess.opts.crate_type, crate_opt.unwrap(), sess.opts.test);\n \n-        crate = time(time_passes, ~\"expansion\", ||\n+        crate_opt = Some(time(time_passes, ~\"expansion\", ||\n                      syntax::ext::expand::expand_crate(sess.parse_sess, copy cfg,\n-                                                       crate));\n+                                                       crate_opt.unwrap())));\n+\n+        crate_opt = Some(time(time_passes, ~\"configuration\", ||\n+                     front::config::strip_unconfigured_items(crate_opt.unwrap())));\n+\n+        crate_opt = Some(time(time_passes, ~\"maybe building test harness\", ||\n+                     front::test::modify_for_testing(sess, crate_opt.unwrap())));\n+    }\n \n-        crate = time(time_passes, ~\"configuration\", ||\n-                     front::config::strip_unconfigured_items(crate));\n+    if phases.to == cu_expand { return (crate_opt, None); }\n \n-        crate = time(time_passes, ~\"maybe building test harness\", ||\n-                     front::test::modify_for_testing(sess, crate));\n+    assert!(phases.from != cu_no_trans);\n \n-        if upto == cu_expand { return (Some(crate), None); }\n+    let mut crate = crate_opt.unwrap();\n \n-        crate = time(time_passes, ~\"intrinsic injection\", ||\n-                     front::intrinsic_inject::inject_intrinsic(sess, crate));\n+    let (llcx, llmod, link_meta) = {\n+    crate = time(time_passes, ~\"intrinsic injection\", ||\n+                 front::intrinsic_inject::inject_intrinsic(sess, crate));\n \n         crate = time(time_passes, ~\"extra injection\", ||\n                      front::std_inject::maybe_inject_libstd_ref(sess, crate));\n@@ -217,7 +230,7 @@ pub fn compile_rest(sess: Session,\n                                   sess.filesearch,\n                                   session::sess_os_to_meta_os(sess.targ_cfg.os),\n                                   sess.opts.is_static,\n-                                  sess.parse_sess.interner));\n+                                  token::get_ident_interner()));\n \n         let lang_items = time(time_passes, ~\"language item collection\", ||\n                               middle::lang_items::collect_language_items(crate, sess));\n@@ -257,11 +270,14 @@ pub fn compile_rest(sess: Session,\n              middle::check_const::check_crate(sess, crate, ast_map, def_map,\n                                               method_map, ty_cx));\n \n-        if upto == cu_typeck { return (Some(crate), Some(ty_cx)); }\n+        if phases.to == cu_typeck { return (Some(crate), Some(ty_cx)); }\n \n         time(time_passes, ~\"privacy checking\", ||\n              middle::privacy::check_crate(ty_cx, &method_map, crate));\n \n+        time(time_passes, ~\"effect checking\", ||\n+             middle::effect::check_crate(ty_cx, method_map, crate));\n+\n         time(time_passes, ~\"loop checking\", ||\n              middle::check_loop::check_crate(ty_cx, crate));\n \n@@ -290,7 +306,7 @@ pub fn compile_rest(sess: Session,\n         time(time_passes, ~\"lint checking\", ||\n              lint::check_crate(ty_cx, crate));\n \n-        if upto == cu_no_trans { return (Some(crate), Some(ty_cx)); }\n+        if phases.to == cu_no_trans { return (Some(crate), Some(ty_cx)); }\n \n         let maps = astencode::Maps {\n             root_map: root_map,\n@@ -310,8 +326,8 @@ pub fn compile_rest(sess: Session,\n \n     let outputs = outputs.get_ref();\n     if (sess.opts.debugging_opts & session::print_link_args) != 0 {\n-        io::println(str::connect(link::link_args(sess,\n-            &outputs.obj_filename, &outputs.out_filename, link_meta), \" \"));\n+        io::println(link::link_args(sess, &outputs.obj_filename,\n+                                    &outputs.out_filename, link_meta).connect(\" \"));\n     }\n \n     // NB: Android hack\n@@ -322,14 +338,14 @@ pub fn compile_rest(sess: Session,\n         let obj_filename = outputs.obj_filename.with_filetype(\"s\");\n \n         time(time_passes, ~\"LLVM passes\", ||\n-            link::write::run_passes(sess, llmod, output_type,\n-                            &obj_filename));\n+            link::write::run_passes(sess, llcx, llmod, output_type,\n+                                    &obj_filename));\n \n         link::write::run_ndk(sess, &obj_filename, &outputs.obj_filename);\n     } else {\n         time(time_passes, ~\"LLVM passes\", ||\n-            link::write::run_passes(sess, llmod, sess.opts.output_type,\n-                                &outputs.obj_filename));\n+            link::write::run_passes(sess, llcx, llmod, sess.opts.output_type,\n+                                    &outputs.obj_filename));\n     }\n \n     let stop_after_codegen =\n@@ -348,23 +364,24 @@ pub fn compile_rest(sess: Session,\n }\n \n pub fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n-                input: &input, upto: compile_upto,\n+                input: &input, upto: compile_phase,\n                 outputs: Option<@OutputFilenames>)\n     -> (Option<@ast::crate>, Option<ty::ctxt>) {\n     let time_passes = sess.time_passes();\n     let crate = time(time_passes, ~\"parsing\",\n                          || parse_input(sess, copy cfg, input) );\n     if upto == cu_parse { return (Some(crate), None); }\n \n-    compile_rest(sess, cfg, upto, outputs, Some(crate))\n+    compile_rest(sess, cfg, compile_upto { from: cu_parse, to: upto },\n+                 outputs, Some(crate))\n }\n \n pub fn compile_input(sess: Session, cfg: ast::crate_cfg, input: &input,\n                      outdir: &Option<Path>, output: &Option<Path>) {\n     let upto = if sess.opts.parse_only { cu_parse }\n                else if sess.opts.no_trans { cu_no_trans }\n                else { cu_everything };\n-    let outputs = build_output_filenames(input, outdir, output, sess);\n+    let outputs = build_output_filenames(input, outdir, output, [], sess); // ???\n     compile_upto(sess, cfg, input, upto, Some(outputs));\n }\n \n@@ -437,42 +454,42 @@ pub fn pretty_print_input(sess: Session, cfg: ast::crate_cfg, input: &input,\n     };\n     let is_expanded = upto != cu_parse;\n     let src = sess.codemap.get_filemap(source_name(input)).src;\n-    do io::with_str_reader(*src) |rdr| {\n-        pprust::print_crate(sess.codemap, sess.parse_sess.interner,\n+    do io::with_str_reader(src) |rdr| {\n+        pprust::print_crate(sess.codemap, token::get_ident_interner(),\n                             sess.span_diagnostic, crate.unwrap(),\n                             source_name(input),\n                             rdr, io::stdout(), ann, is_expanded);\n     }\n }\n \n pub fn get_os(triple: &str) -> Option<session::os> {\n-    if str::contains(triple, \"win32\") ||\n-               str::contains(triple, \"mingw32\") {\n+    if triple.contains(\"win32\") ||\n+               triple.contains(\"mingw32\") {\n             Some(session::os_win32)\n-        } else if str::contains(triple, \"darwin\") {\n+        } else if triple.contains(\"darwin\") {\n             Some(session::os_macos)\n-        } else if str::contains(triple, \"android\") {\n+        } else if triple.contains(\"android\") {\n             Some(session::os_android)\n-        } else if str::contains(triple, \"linux\") {\n+        } else if triple.contains(\"linux\") {\n             Some(session::os_linux)\n-        } else if str::contains(triple, \"freebsd\") {\n+        } else if triple.contains(\"freebsd\") {\n             Some(session::os_freebsd)\n         } else { None }\n }\n \n pub fn get_arch(triple: &str) -> Option<abi::Architecture> {\n-    if str::contains(triple, \"i386\") ||\n-        str::contains(triple, \"i486\") ||\n-               str::contains(triple, \"i586\") ||\n-               str::contains(triple, \"i686\") ||\n-               str::contains(triple, \"i786\") {\n+    if triple.contains(\"i386\") ||\n+        triple.contains(\"i486\") ||\n+               triple.contains(\"i586\") ||\n+               triple.contains(\"i686\") ||\n+               triple.contains(\"i786\") {\n             Some(abi::X86)\n-        } else if str::contains(triple, \"x86_64\") {\n+        } else if triple.contains(\"x86_64\") {\n             Some(abi::X86_64)\n-        } else if str::contains(triple, \"arm\") ||\n-                      str::contains(triple, \"xscale\") {\n+        } else if triple.contains(\"arm\") ||\n+                      triple.contains(\"xscale\") {\n             Some(abi::Arm)\n-        } else if str::contains(triple, \"mips\") {\n+        } else if triple.contains(\"mips\") {\n             Some(abi::Mips)\n         } else { None }\n }\n@@ -548,7 +565,7 @@ pub fn host_triple() -> ~str {\n         };\n }\n \n-pub fn build_session_options(binary: @~str,\n+pub fn build_session_options(binary: @str,\n                              matches: &getopts::Matches,\n                              demitter: diagnostic::Emitter)\n                           -> @session::options {\n@@ -571,13 +588,13 @@ pub fn build_session_options(binary: @~str,\n \n         // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n         // to_ascii_consume and to_str_consume to not do a unnecessary copy.\n-        let level_short = level_name.substr(0,1);\n+        let level_short = level_name.slice_chars(0, 1);\n         let level_short = level_short.to_ascii().to_upper().to_str_ascii();\n         let flags = vec::append(getopts::opt_strs(matches, level_short),\n                                 getopts::opt_strs(matches, level_name));\n         for flags.each |lint_name| {\n-            let lint_name = str::replace(*lint_name, \"-\", \"_\");\n-            match lint_dict.find(&lint_name) {\n+            let lint_name = lint_name.replace(\"-\", \"_\");\n+            match lint_dict.find_equiv(&lint_name) {\n               None => {\n                 early_error(demitter, fmt!(\"unknown %s flag: %s\",\n                                            level_name, lint_name));\n@@ -642,8 +659,7 @@ pub fn build_session_options(binary: @~str,\n               ~\"2\" => Default,\n               ~\"3\" => Aggressive,\n               _ => {\n-                early_error(demitter, ~\"optimization level needs \" +\n-                            \"to be between 0-3\")\n+                early_error(demitter, ~\"optimization level needs to be between 0-3\")\n               }\n             }\n         } else { No }\n@@ -667,30 +683,36 @@ pub fn build_session_options(binary: @~str,\n     let addl_lib_search_paths = getopts::opt_strs(matches, \"L\").map(|s| Path(*s));\n     let linker = getopts::opt_maybe_str(matches, \"linker\");\n     let linker_args = getopts::opt_strs(matches, \"link-args\").flat_map( |a| {\n-        let mut args = ~[];\n-        for str::each_split_char(*a, ' ') |arg| {\n-            args.push(str::to_owned(arg));\n-        }\n-        args\n+        a.split_iter(' ').transform(|arg| arg.to_owned()).collect()\n     });\n \n     let cfg = parse_cfgspecs(getopts::opt_strs(matches, \"cfg\"), demitter);\n     let test = opt_present(matches, \"test\");\n     let android_cross_path = getopts::opt_maybe_str(\n         matches, \"android-cross-path\");\n \n+    let custom_passes = match getopts::opt_maybe_str(matches, \"passes\") {\n+        None => ~[],\n+        Some(s) => {\n+            s.split_iter(|c: char| c == ' ' || c == ',').transform(|s| {\n+                s.trim().to_owned()\n+            }).collect()\n+        }\n+    };\n+\n     let sopts = @session::options {\n         crate_type: crate_type,\n         is_static: statik,\n         gc: gc,\n         optimize: opt_level,\n+        custom_passes: custom_passes,\n         debuginfo: debuginfo,\n         extra_debuginfo: extra_debuginfo,\n         lint_opts: lint_opts,\n         save_temps: save_temps,\n         jit: jit,\n         output_type: output_type,\n-        addl_lib_search_paths: addl_lib_search_paths,\n+        addl_lib_search_paths: @mut addl_lib_search_paths,\n         linker: linker,\n         linker_args: linker_args,\n         maybe_sysroot: sysroot_opt,\n@@ -725,11 +747,11 @@ pub fn build_session_(sopts: @session::options,\n     let target_cfg = build_target_config(sopts, demitter);\n     let p_s = parse::new_parse_sess_special_handler(span_diagnostic_handler,\n                                                     cm);\n-    let cstore = @mut cstore::mk_cstore(p_s.interner);\n+    let cstore = @mut cstore::mk_cstore(token::get_ident_interner());\n     let filesearch = filesearch::mk_filesearch(\n         &sopts.maybe_sysroot,\n         sopts.target_triple,\n-        /*bad*/copy sopts.addl_lib_search_paths);\n+        sopts.addl_lib_search_paths);\n     @Session_ {\n         targ_cfg: target_cfg,\n         opts: sopts,\n@@ -785,6 +807,9 @@ pub fn optgroups() -> ~[getopts::groups::OptGroup] {\n   optopt(\"o\", \"\",     \"Write output to <filename>\", \"FILENAME\"),\n   optopt(\"\", \"opt-level\",\n                         \"Optimize with possible levels 0-3\", \"LEVEL\"),\n+  optopt(\"\", \"passes\", \"Comma or space separated list of pass names to use. \\\n+                        Overrides the default passes for optimization levels,\\n\\\n+                        a value of \\\"list\\\" will list the available passes.\", \"NAMES\"),\n   optopt( \"\",  \"out-dir\",\n                         \"Write output to compiler-chosen filename\n                           in <dir>\", \"DIR\"),\n@@ -835,6 +860,7 @@ pub struct OutputFilenames {\n pub fn build_output_filenames(input: &input,\n                               odir: &Option<Path>,\n                               ofile: &Option<Path>,\n+                              attrs: &[ast::attribute],\n                               sess: Session)\n                            -> @OutputFilenames {\n     let obj_path;\n@@ -844,7 +870,6 @@ pub fn build_output_filenames(input: &input,\n         sopts.output_type != link::output_type_exe ||\n             sopts.is_static && *sess.building_library;\n \n-\n     let obj_suffix =\n         match sopts.output_type {\n           link::output_type_none => ~\"none\",\n@@ -857,29 +882,44 @@ pub fn build_output_filenames(input: &input,\n \n     match *ofile {\n       None => {\n-        // \"-\" as input file will cause the parser to read from stdin so we\n-        // have to make up a name\n-        // We want to toss everything after the final '.'\n-        let dirpath = match *odir {\n-          Some(ref d) => (/*bad*/copy *d),\n-          None => match *input {\n-            str_input(_) => os::getcwd(),\n-            file_input(ref ifile) => (*ifile).dir_path()\n+          // \"-\" as input file will cause the parser to read from stdin so we\n+          // have to make up a name\n+          // We want to toss everything after the final '.'\n+          let dirpath = match *odir {\n+              Some(ref d) => (/*bad*/copy *d),\n+              None => match *input {\n+                  str_input(_) => os::getcwd(),\n+                  file_input(ref ifile) => (*ifile).dir_path()\n+              }\n+          };\n+\n+          let mut stem = match *input {\n+              file_input(ref ifile) => (*ifile).filestem().get().to_managed(),\n+              str_input(_) => @\"rust_out\"\n+          };\n+\n+          // If a linkage name meta is present, we use it as the link name\n+          let linkage_metas = attr::find_linkage_metas(attrs);\n+          if !linkage_metas.is_empty() {\n+              // But if a linkage meta is present, that overrides\n+              let maybe_matches = attr::find_meta_items_by_name(linkage_metas, \"name\");\n+              if !maybe_matches.is_empty() {\n+                  match attr::get_meta_item_value_str(maybe_matches[0]) {\n+                      Some(s) => stem = s,\n+                      _ => ()\n+                  }\n+              }\n+              // If the name is missing, we just default to the filename\n+              // version\n           }\n-        };\n-\n-        let stem = match *input {\n-          file_input(ref ifile) => (*ifile).filestem().get(),\n-          str_input(_) => ~\"rust_out\"\n-        };\n \n-        if *sess.building_library {\n-            out_path = dirpath.push(os::dll_filename(stem));\n-            obj_path = dirpath.push(stem).with_filetype(obj_suffix);\n-        } else {\n-            out_path = dirpath.push(stem);\n-            obj_path = dirpath.push(stem).with_filetype(obj_suffix);\n-        }\n+          if *sess.building_library {\n+              out_path = dirpath.push(os::dll_filename(stem));\n+              obj_path = dirpath.push(stem).with_filetype(obj_suffix);\n+          } else {\n+              out_path = dirpath.push(stem);\n+              obj_path = dirpath.push(stem).with_filetype(obj_suffix);\n+          }\n       }\n \n       Some(ref out_file) => {\n@@ -916,7 +956,7 @@ pub fn early_error(emitter: diagnostic::Emitter, msg: ~str) -> ! {\n \n pub fn list_metadata(sess: Session, path: &Path, out: @io::Writer) {\n     metadata::loader::list_file_metadata(\n-        sess.parse_sess.interner,\n+        token::get_ident_interner(),\n         session::sess_os_to_meta_os(sess.targ_cfg.os), path, out);\n }\n \n@@ -937,13 +977,13 @@ mod test {\n     fn test_switch_implies_cfg_test() {\n         let matches =\n             &match getopts([~\"--test\"], optgroups()) {\n-              Ok(copy m) => m,\n-              Err(copy f) => fail!(\"test_switch_implies_cfg_test: %s\", getopts::fail_str(f))\n+              Ok(m) => m,\n+              Err(f) => fail!(\"test_switch_implies_cfg_test: %s\", getopts::fail_str(f))\n             };\n         let sessopts = build_session_options(\n-            @~\"rustc\", matches, diagnostic::emit);\n+            @\"rustc\", matches, diagnostic::emit);\n         let sess = build_session(sessopts, diagnostic::emit);\n-        let cfg = build_configuration(sess, @~\"whatever\", &str_input(~\"\"));\n+        let cfg = build_configuration(sess, @\"whatever\", &str_input(@\"\"));\n         assert!((attr::contains_name(cfg, \"test\")));\n     }\n \n@@ -953,15 +993,15 @@ mod test {\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n             &match getopts([~\"--test\", ~\"--cfg=test\"], optgroups()) {\n-              Ok(copy m) => m,\n-              Err(copy f) => {\n+              Ok(m) => m,\n+              Err(f) => {\n                 fail!(\"test_switch_implies_cfg_test_unless_cfg_test: %s\", getopts::fail_str(f));\n               }\n             };\n         let sessopts = build_session_options(\n-            @~\"rustc\", matches, diagnostic::emit);\n+            @\"rustc\", matches, diagnostic::emit);\n         let sess = build_session(sessopts, diagnostic::emit);\n-        let cfg = build_configuration(sess, @~\"whatever\", &str_input(~\"\"));\n+        let cfg = build_configuration(sess, @\"whatever\", &str_input(@\"\"));\n         let test_items = attr::find_meta_items_by_name(cfg, \"test\");\n         assert_eq!(test_items.len(), 1u);\n     }"}, {"sha": "73e8cfea8ca20821ca8ee70ee8fc7cf7c97b8cd4", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 68, "deletions": 54, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -26,6 +26,7 @@ use syntax::diagnostic;\n use syntax::parse::ParseSess;\n use syntax::{ast, codemap};\n use syntax::abi;\n+use syntax::parse::token;\n use syntax;\n \n use core::hashmap::HashMap;\n@@ -129,13 +130,16 @@ pub struct options {\n     is_static: bool,\n     gc: bool,\n     optimize: OptLevel,\n+    custom_passes: ~[~str],\n     debuginfo: bool,\n     extra_debuginfo: bool,\n     lint_opts: ~[(lint::lint, lint::level)],\n     save_temps: bool,\n     jit: bool,\n     output_type: back::link::output_type,\n-    addl_lib_search_paths: ~[Path],\n+    addl_lib_search_paths: @mut ~[Path], // This is mutable for rustpkg, which\n+                                         // updates search paths based on the\n+                                         // parsed code\n     linker: Option<~str>,\n     linker_args: ~[~str],\n     maybe_sysroot: Option<@Path>,\n@@ -146,7 +150,7 @@ pub struct options {\n     // will be added to the crate AST node.  This should not be used for\n     // anything except building the full crate config prior to parsing.\n     cfg: ast::crate_cfg,\n-    binary: @~str,\n+    binary: @str,\n     test: bool,\n     parse_only: bool,\n     no_trans: bool,\n@@ -187,113 +191,122 @@ pub struct Session_ {\n \n pub type Session = @Session_;\n \n-pub impl Session_ {\n-    fn span_fatal(@self, sp: span, msg: &str) -> ! {\n+impl Session_ {\n+    pub fn span_fatal(@self, sp: span, msg: &str) -> ! {\n         self.span_diagnostic.span_fatal(sp, msg)\n     }\n-    fn fatal(@self, msg: &str) -> ! {\n+    pub fn fatal(@self, msg: &str) -> ! {\n         self.span_diagnostic.handler().fatal(msg)\n     }\n-    fn span_err(@self, sp: span, msg: &str) {\n+    pub fn span_err(@self, sp: span, msg: &str) {\n         self.span_diagnostic.span_err(sp, msg)\n     }\n-    fn err(@self, msg: &str) {\n+    pub fn err(@self, msg: &str) {\n         self.span_diagnostic.handler().err(msg)\n     }\n-    fn err_count(@self) -> uint {\n+    pub fn err_count(@self) -> uint {\n         self.span_diagnostic.handler().err_count()\n     }\n-    fn has_errors(@self) -> bool {\n+    pub fn has_errors(@self) -> bool {\n         self.span_diagnostic.handler().has_errors()\n     }\n-    fn abort_if_errors(@self) {\n+    pub fn abort_if_errors(@self) {\n         self.span_diagnostic.handler().abort_if_errors()\n     }\n-    fn span_warn(@self, sp: span, msg: &str) {\n+    pub fn span_warn(@self, sp: span, msg: &str) {\n         self.span_diagnostic.span_warn(sp, msg)\n     }\n-    fn warn(@self, msg: &str) {\n+    pub fn warn(@self, msg: &str) {\n         self.span_diagnostic.handler().warn(msg)\n     }\n-    fn span_note(@self, sp: span, msg: &str) {\n+    pub fn span_note(@self, sp: span, msg: &str) {\n         self.span_diagnostic.span_note(sp, msg)\n     }\n-    fn note(@self, msg: &str) {\n+    pub fn note(@self, msg: &str) {\n         self.span_diagnostic.handler().note(msg)\n     }\n-    fn span_bug(@self, sp: span, msg: &str) -> ! {\n+    pub fn span_bug(@self, sp: span, msg: &str) -> ! {\n         self.span_diagnostic.span_bug(sp, msg)\n     }\n-    fn bug(@self, msg: &str) -> ! {\n+    pub fn bug(@self, msg: &str) -> ! {\n         self.span_diagnostic.handler().bug(msg)\n     }\n-    fn span_unimpl(@self, sp: span, msg: &str) -> ! {\n+    pub fn span_unimpl(@self, sp: span, msg: &str) -> ! {\n         self.span_diagnostic.span_unimpl(sp, msg)\n     }\n-    fn unimpl(@self, msg: &str) -> ! {\n+    pub fn unimpl(@self, msg: &str) -> ! {\n         self.span_diagnostic.handler().unimpl(msg)\n     }\n-    fn add_lint(@self, lint: lint::lint, id: ast::node_id, sp: span, msg: ~str) {\n+    pub fn add_lint(@self,\n+                    lint: lint::lint,\n+                    id: ast::node_id,\n+                    sp: span,\n+                    msg: ~str) {\n         match self.lints.find_mut(&id) {\n             Some(arr) => { arr.push((lint, sp, msg)); return; }\n             None => {}\n         }\n         self.lints.insert(id, ~[(lint, sp, msg)]);\n     }\n-    fn next_node_id(@self) -> ast::node_id {\n+    pub fn next_node_id(@self) -> ast::node_id {\n         return syntax::parse::next_node_id(self.parse_sess);\n     }\n-    fn diagnostic(@self) -> @diagnostic::span_handler {\n+    pub fn diagnostic(@self) -> @diagnostic::span_handler {\n         self.span_diagnostic\n     }\n-    fn debugging_opt(@self, opt: uint) -> bool {\n+    pub fn debugging_opt(@self, opt: uint) -> bool {\n         (self.opts.debugging_opts & opt) != 0u\n     }\n     // This exists to help with refactoring to eliminate impossible\n     // cases later on\n-    fn impossible_case(@self, sp: span, msg: &str) -> ! {\n+    pub fn impossible_case(@self, sp: span, msg: &str) -> ! {\n         self.span_bug(sp, fmt!(\"Impossible case reached: %s\", msg));\n     }\n-    fn verbose(@self) -> bool { self.debugging_opt(verbose) }\n-    fn time_passes(@self) -> bool { self.debugging_opt(time_passes) }\n-    fn count_llvm_insns(@self) -> bool {\n+    pub fn verbose(@self) -> bool { self.debugging_opt(verbose) }\n+    pub fn time_passes(@self) -> bool { self.debugging_opt(time_passes) }\n+    pub fn count_llvm_insns(@self) -> bool {\n         self.debugging_opt(count_llvm_insns)\n     }\n-    fn count_type_sizes(@self) -> bool {\n+    pub fn count_type_sizes(@self) -> bool {\n         self.debugging_opt(count_type_sizes)\n     }\n-    fn time_llvm_passes(@self) -> bool {\n+    pub fn time_llvm_passes(@self) -> bool {\n         self.debugging_opt(time_llvm_passes)\n     }\n-    fn trans_stats(@self) -> bool { self.debugging_opt(trans_stats) }\n-    fn meta_stats(@self) -> bool { self.debugging_opt(meta_stats) }\n-    fn asm_comments(@self) -> bool { self.debugging_opt(asm_comments) }\n-    fn no_verify(@self) -> bool { self.debugging_opt(no_verify) }\n-    fn lint_llvm(@self) -> bool { self.debugging_opt(lint_llvm) }\n-    fn trace(@self) -> bool { self.debugging_opt(trace) }\n-    fn coherence(@self) -> bool { self.debugging_opt(coherence) }\n-    fn borrowck_stats(@self) -> bool { self.debugging_opt(borrowck_stats) }\n-    fn borrowck_note_pure(@self) -> bool {\n+    pub fn trans_stats(@self) -> bool { self.debugging_opt(trans_stats) }\n+    pub fn meta_stats(@self) -> bool { self.debugging_opt(meta_stats) }\n+    pub fn asm_comments(@self) -> bool { self.debugging_opt(asm_comments) }\n+    pub fn no_verify(@self) -> bool { self.debugging_opt(no_verify) }\n+    pub fn lint_llvm(@self) -> bool { self.debugging_opt(lint_llvm) }\n+    pub fn trace(@self) -> bool { self.debugging_opt(trace) }\n+    pub fn coherence(@self) -> bool { self.debugging_opt(coherence) }\n+    pub fn borrowck_stats(@self) -> bool { self.debugging_opt(borrowck_stats) }\n+    pub fn borrowck_note_pure(@self) -> bool {\n         self.debugging_opt(borrowck_note_pure)\n     }\n-    fn borrowck_note_loan(@self) -> bool {\n+    pub fn borrowck_note_loan(@self) -> bool {\n         self.debugging_opt(borrowck_note_loan)\n     }\n-    fn no_monomorphic_collapse(@self) -> bool {\n+    pub fn no_monomorphic_collapse(@self) -> bool {\n         self.debugging_opt(no_monomorphic_collapse)\n     }\n-    fn debug_borrows(@self) -> bool {\n+    pub fn debug_borrows(@self) -> bool {\n         self.opts.optimize == No && !self.debugging_opt(no_debug_borrows)\n     }\n \n-    fn str_of(@self, id: ast::ident) -> @~str {\n-        self.parse_sess.interner.get(id)\n+    // pointless function, now...\n+    pub fn str_of(@self, id: ast::ident) -> @str {\n+        token::ident_to_str(&id)\n     }\n-    fn ident_of(@self, st: &str) -> ast::ident {\n-        self.parse_sess.interner.intern(st)\n+\n+    // pointless function, now...\n+    pub fn ident_of(@self, st: &str) -> ast::ident {\n+        token::str_to_ident(st)\n     }\n-    fn intr(@self) -> @syntax::parse::token::ident_interner {\n-        self.parse_sess.interner\n+\n+    // pointless function, now...\n+    pub fn intr(@self) -> @syntax::parse::token::ident_interner {\n+        token::get_ident_interner()\n     }\n }\n \n@@ -304,20 +317,21 @@ pub fn basic_options() -> @options {\n         is_static: false,\n         gc: false,\n         optimize: No,\n+        custom_passes: ~[],\n         debuginfo: false,\n         extra_debuginfo: false,\n         lint_opts: ~[],\n         save_temps: false,\n         jit: false,\n         output_type: link::output_type_exe,\n-        addl_lib_search_paths: ~[],\n+        addl_lib_search_paths: @mut ~[],\n         linker: None,\n         linker_args: ~[],\n         maybe_sysroot: None,\n         target_triple: host_triple(),\n         target_feature: ~\"\",\n         cfg: ~[],\n-        binary: @~\"rustc\",\n+        binary: @\"rustc\",\n         test: false,\n         parse_only: false,\n         no_trans: false,\n@@ -347,7 +361,7 @@ pub fn building_library(req_crate_type: crate_type,\n             match syntax::attr::first_attr_value_str_by_name(\n                 crate.node.attrs,\n                 \"crate_type\") {\n-              Some(@~\"lib\") => true,\n+              Some(s) if \"lib\" == s => true,\n               _ => false\n             }\n         }\n@@ -375,22 +389,22 @@ mod test {\n     use syntax::ast;\n     use syntax::codemap;\n \n-    fn make_crate_type_attr(t: ~str) -> ast::attribute {\n+    fn make_crate_type_attr(t: @str) -> ast::attribute {\n         codemap::respan(codemap::dummy_sp(), ast::attribute_ {\n             style: ast::attr_outer,\n             value: @codemap::respan(codemap::dummy_sp(),\n                 ast::meta_name_value(\n-                    @~\"crate_type\",\n+                    @\"crate_type\",\n                     codemap::respan(codemap::dummy_sp(),\n-                                     ast::lit_str(@t)))),\n+                                     ast::lit_str(t)))),\n             is_sugared_doc: false\n         })\n     }\n \n     fn make_crate(with_bin: bool, with_lib: bool) -> @ast::crate {\n         let mut attrs = ~[];\n-        if with_bin { attrs += [make_crate_type_attr(~\"bin\")]; }\n-        if with_lib { attrs += [make_crate_type_attr(~\"lib\")]; }\n+        if with_bin { attrs += [make_crate_type_attr(@\"bin\")]; }\n+        if with_lib { attrs += [make_crate_type_attr(@\"lib\")]; }\n         @codemap::respan(codemap::dummy_sp(), ast::crate_ {\n             module: ast::_mod { view_items: ~[], items: ~[] },\n             attrs: attrs,"}, {"sha": "3e6ac283da0a55ec7fc7e47fa41eb049348af2fa", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -10,6 +10,8 @@\n \n use core::prelude::*;\n \n+use core::option;\n+use core::vec;\n use syntax::{ast, fold, attr};\n \n type in_cfg_pred = @fn(attrs: ~[ast::attribute]) -> bool;\n@@ -138,9 +140,18 @@ fn fold_block(\n         b.stmts.filter_mapped(|a| filter_stmt(cx, *a));\n     let filtered_view_items =\n         b.view_items.filter_mapped(|a| filter_view_item(cx, *a));\n+    let filtered_view_items =\n+        filtered_view_items.map(|x| fld.fold_view_item(*x));\n+    let mut resulting_stmts = ~[];\n+    for filtered_stmts.each |stmt| {\n+        match fld.fold_stmt(*stmt) {\n+            None => {}\n+            Some(stmt) => resulting_stmts.push(stmt),\n+        }\n+    }\n     ast::blk_ {\n-        view_items: vec::map(filtered_view_items, |x| fld.fold_view_item(*x)),\n-        stmts: vec::map(filtered_stmts, |x| fld.fold_stmt(*x)),\n+        view_items: filtered_view_items,\n+        stmts: resulting_stmts,\n         expr: b.expr.map(|x| fld.fold_expr(*x)),\n         id: b.id,\n         rules: b.rules,\n@@ -191,7 +202,7 @@ pub fn metas_in_cfg(cfg: ast::crate_cfg,\n     cfg_metas.any(|cfg_meta| {\n         cfg_meta.all(|cfg_mi| {\n             match cfg_mi.node {\n-                ast::meta_list(s, ref it) if *s == ~\"not\"\n+                ast::meta_list(s, ref it) if \"not\" == s\n                     => it.all(|mi| !attr::contains(cfg, *mi)),\n                 _ => attr::contains(cfg, *cfg_mi)\n             }"}, {"sha": "fcb08180a5ea27565ff9f3a854c9981c8df6d866", "filename": "src/librustc/front/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -12,6 +12,8 @@\n // and injected into each crate the compiler builds. Keep it small.\n \n pub mod intrinsic {\n+    #[allow(missing_doc)];\n+\n     pub use intrinsic::rusti::visit_tydesc;\n \n     // FIXME (#3727): remove this when the interface has settled and the"}, {"sha": "0caadc8572e90cf545744b9e2af78d3cdcacd173", "filename": "src/librustc/front/intrinsic_inject.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -10,15 +10,16 @@\n \n use core::prelude::*;\n \n+use core::vec;\n use driver::session::Session;\n use syntax::parse;\n use syntax::ast;\n use syntax::codemap::spanned;\n \n pub fn inject_intrinsic(sess: Session, crate: @ast::crate) -> @ast::crate {\n-    let intrinsic_module = @(include_str!(\"intrinsic.rs\").to_owned());\n+    let intrinsic_module = include_str!(\"intrinsic.rs\").to_managed();\n \n-    let item = parse::parse_item_from_source_str(~\"<intrinsic>\",\n+    let item = parse::parse_item_from_source_str(@\"<intrinsic>\",\n                                                  intrinsic_module,\n                                                  /*bad*/copy sess.opts.cfg,\n                                                  ~[],"}, {"sha": "38a21af65b93f83023c6ff6b3a458592cede8554", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -12,10 +12,11 @@ use core::prelude::*;\n \n use driver::session::Session;\n \n+use core::vec;\n use syntax::ast;\n use syntax::attr;\n-use syntax::codemap;\n use syntax::codemap::dummy_sp;\n+use syntax::codemap;\n use syntax::fold;\n \n static STD_VERSION: &'static str = \"0.7-pre\";\n@@ -48,8 +49,8 @@ fn inject_libstd_ref(sess: Session, crate: @ast::crate) -> @ast::crate {\n                     spanned(ast::attribute_ {\n                         style: ast::attr_inner,\n                         value: @spanned(ast::meta_name_value(\n-                            @~\"vers\",\n-                            spanned(ast::lit_str(@STD_VERSION.to_str()))\n+                            @\"vers\",\n+                            spanned(ast::lit_str(STD_VERSION.to_managed()))\n                         )),\n                         is_sugared_doc: false\n                     })"}, {"sha": "de6fc322c6372390b3cc887a76c53ac6bb0370b5", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -15,6 +15,7 @@ use core::prelude::*;\n use driver::session;\n use front::config;\n \n+use core::vec;\n use syntax::ast_util::*;\n use syntax::attr;\n use syntax::codemap::{dummy_sp, span, ExpandedFrom, CallInfo, NameAndSpan};\n@@ -51,7 +52,7 @@ pub fn modify_for_testing(sess: session::Session,\n     // configuration, either with the '--test' or '--cfg test'\n     // command line options.\n     let should_test = attr::contains(crate.node.config,\n-                                     attr::mk_word_item(@~\"test\"));\n+                                     attr::mk_word_item(@\"test\"));\n \n     if should_test {\n         generate_test_harness(sess, crate)\n@@ -75,7 +76,7 @@ fn generate_test_harness(sess: session::Session,\n     ext_cx.bt_push(ExpandedFrom(CallInfo {\n         call_site: dummy_sp(),\n         callee: NameAndSpan {\n-            name: ~\"test\",\n+            name: @\"test\",\n             span: None\n         }\n     }));\n@@ -110,7 +111,7 @@ fn fold_mod(cx: @mut TestCtxt,\n     fn nomain(cx: @mut TestCtxt, item: @ast::item) -> @ast::item {\n         if !*cx.sess.building_library {\n             @ast::item{attrs: item.attrs.filtered(|attr| {\n-                               *attr::get_attr_name(attr) != ~\"main\"\n+                               \"main\" != attr::get_attr_name(attr)\n                            }),.. copy *item}\n         } else { item }\n     }\n@@ -142,7 +143,7 @@ fn fold_item(cx: @mut TestCtxt, i: @ast::item, fld: @fold::ast_fold)\n           -> Option<@ast::item> {\n     cx.path.push(i.ident);\n     debug!(\"current path: %s\",\n-           ast_util::path_name_i(copy cx.path, cx.sess.parse_sess.interner));\n+           ast_util::path_name_i(copy cx.path));\n \n     if is_test_fn(cx, i) || is_bench_fn(i) {\n         match i.node {\n@@ -202,8 +203,7 @@ fn is_test_fn(cx: @mut TestCtxt, i: @ast::item) -> bool {\n }\n \n fn is_bench_fn(i: @ast::item) -> bool {\n-    let has_bench_attr =\n-        vec::len(attr::find_attrs_by_name(i.attrs, \"bench\")) > 0u;\n+    let has_bench_attr = !attr::find_attrs_by_name(i.attrs, \"bench\").is_empty();\n \n     fn has_test_signature(i: @ast::item) -> bool {\n         match i.node {\n@@ -241,7 +241,7 @@ fn is_ignored(cx: @mut TestCtxt, i: @ast::item) -> bool {\n }\n \n fn should_fail(i: @ast::item) -> bool {\n-    vec::len(attr::find_attrs_by_name(i.attrs, \"should_fail\")) > 0u\n+    !attr::find_attrs_by_name(i.attrs, \"should_fail\").is_empty()\n }\n \n fn add_test_module(cx: &TestCtxt, m: &ast::_mod) -> ast::_mod {\n@@ -272,9 +272,9 @@ mod __test {\n */\n \n fn mk_std(cx: &TestCtxt) -> @ast::view_item {\n-    let vers = ast::lit_str(@~\"0.7-pre\");\n+    let vers = ast::lit_str(@\"0.7-pre\");\n     let vers = nospan(vers);\n-    let mi = ast::meta_name_value(@~\"vers\", vers);\n+    let mi = ast::meta_name_value(@\"vers\", vers);\n     let mi = nospan(mi);\n     let id_std = cx.sess.ident_of(\"extra\");\n     let vi = if is_std(cx) {\n@@ -309,7 +309,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n     let mainfn = (quote_item!(\n         pub fn main() {\n             #[main];\n-            extra::test::test_main_static(::os::args(), tests);\n+            extra::test::test_main_static(::std::os::args(), tests);\n         }\n     )).get();\n \n@@ -321,7 +321,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n \n     // This attribute tells resolve to let us call unexported functions\n     let resolve_unexported_attr =\n-        attr::mk_attr(attr::mk_word_item(@~\"!resolve_unexported\"));\n+        attr::mk_attr(attr::mk_word_item(@\"!resolve_unexported\"));\n \n     let item = ast::item {\n         ident: cx.sess.ident_of(\"__test\"),\n@@ -376,7 +376,7 @@ fn is_std(cx: &TestCtxt) -> bool {\n     let is_std = {\n         let items = attr::find_linkage_metas(cx.crate.node.attrs);\n         match attr::last_meta_item_value_str_by_name(items, \"name\") {\n-          Some(@~\"extra\") => true,\n+          Some(s) if \"extra\" == s => true,\n           _ => false\n         }\n     };\n@@ -393,14 +393,12 @@ fn mk_test_descs(cx: &TestCtxt) -> @ast::expr {\n     let sess = cx.sess;\n     let inner_expr = @ast::expr {\n         id: sess.next_node_id(),\n-        callee_id: sess.next_node_id(),\n         node: ast::expr_vec(descs, ast::m_imm),\n         span: dummy_sp(),\n     };\n \n     @ast::expr {\n         id: sess.next_node_id(),\n-        callee_id: sess.next_node_id(),\n         node: ast::expr_vstore(inner_expr, ast::expr_vstore_slice),\n         span: dummy_sp(),\n     }\n@@ -412,17 +410,13 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::expr {\n \n     let ext_cx = cx.ext_cx;\n \n-    debug!(\"encoding %s\", ast_util::path_name_i(path,\n-                                                cx.sess.parse_sess.interner));\n+    debug!(\"encoding %s\", ast_util::path_name_i(path));\n \n     let name_lit: ast::lit =\n-        nospan(ast::lit_str(@ast_util::path_name_i(\n-            path,\n-            cx.sess.parse_sess.interner)));\n+        nospan(ast::lit_str(ast_util::path_name_i(path).to_managed()));\n \n     let name_expr = @ast::expr {\n           id: cx.sess.next_node_id(),\n-          callee_id: cx.sess.next_node_id(),\n           node: ast::expr_lit(@name_lit),\n           span: span\n     };\n@@ -431,7 +425,6 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::expr {\n \n     let fn_expr = @ast::expr {\n         id: cx.sess.next_node_id(),\n-        callee_id: cx.sess.next_node_id(),\n         node: ast::expr_path(fn_path),\n         span: span,\n     };"}, {"sha": "289bb4f63f59e164dcb589293e17638cce3bef14", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 30, "deletions": 268, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -12,6 +12,10 @@ use core::prelude::*;\n \n use core::hashmap::HashMap;\n use core::libc::{c_uint, c_ushort};\n+use core::option;\n+use core::ptr;\n+use core::str;\n+use core::vec;\n \n pub type Opcode = u32;\n pub type Bool = c_uint;\n@@ -201,6 +205,8 @@ pub enum BasicBlock_opaque {}\n pub type BasicBlockRef = *BasicBlock_opaque;\n pub enum Builder_opaque {}\n pub type BuilderRef = *Builder_opaque;\n+pub enum ExecutionEngine_opaque {}\n+pub type ExecutionEngineRef = *ExecutionEngine_opaque;\n pub enum MemoryBuffer_opaque {}\n pub type MemoryBufferRef = *MemoryBuffer_opaque;\n pub enum PassManager_opaque {}\n@@ -219,7 +225,7 @@ pub enum Pass_opaque {}\n pub type PassRef = *Pass_opaque;\n \n pub mod llvm {\n-    use super::{AtomicBinOp, AtomicOrdering, BasicBlockRef};\n+    use super::{AtomicBinOp, AtomicOrdering, BasicBlockRef, ExecutionEngineRef};\n     use super::{Bool, BuilderRef, ContextRef, MemoryBufferRef, ModuleRef};\n     use super::{ObjectFileRef, Opcode, PassManagerRef, PassManagerBuilderRef};\n     use super::{SectionIteratorRef, TargetDataRef, TypeKind, TypeRef, UseRef};\n@@ -235,23 +241,21 @@ pub mod llvm {\n         #[fast_ffi]\n         pub unsafe fn LLVMContextCreate() -> ContextRef;\n         #[fast_ffi]\n-        pub unsafe fn LLVMGetGlobalContext() -> ContextRef;\n-        #[fast_ffi]\n         pub unsafe fn LLVMContextDispose(C: ContextRef);\n         #[fast_ffi]\n         pub unsafe fn LLVMGetMDKindIDInContext(C: ContextRef,\n                                            Name: *c_char,\n                                            SLen: c_uint)\n                                         -> c_uint;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMGetMDKindID(Name: *c_char, SLen: c_uint) -> c_uint;\n \n         /* Create and destroy modules. */\n         #[fast_ffi]\n         pub unsafe fn LLVMModuleCreateWithNameInContext(ModuleID: *c_char,\n                                                     C: ContextRef)\n                                                  -> ModuleRef;\n         #[fast_ffi]\n+        pub unsafe fn LLVMGetModuleContext(M: ModuleRef) -> ContextRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMDisposeModule(M: ModuleRef);\n \n         /** Data layout. See Module::getDataLayout. */\n@@ -296,18 +300,6 @@ pub mod llvm {\n         pub unsafe fn LLVMIntTypeInContext(C: ContextRef,\n                                            NumBits: c_uint) -> TypeRef;\n \n-        #[fast_ffi]\n-        pub unsafe fn LLVMInt1Type() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMInt8Type() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMInt16Type() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMInt32Type() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMInt64Type() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMIntType(NumBits: c_uint) -> TypeRef;\n         #[fast_ffi]\n         pub unsafe fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> c_uint;\n \n@@ -323,17 +315,6 @@ pub mod llvm {\n         #[fast_ffi]\n         pub unsafe fn LLVMPPCFP128TypeInContext(C: ContextRef) -> TypeRef;\n \n-        #[fast_ffi]\n-        pub unsafe fn LLVMFloatType() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMDoubleType() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMX86FP80Type() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMFP128Type() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMPPCFP128Type() -> TypeRef;\n-\n         /* Operations on function types */\n         #[fast_ffi]\n         pub unsafe fn LLVMFunctionType(ReturnType: TypeRef,\n@@ -357,11 +338,6 @@ pub mod llvm {\n                                               ElementCount: c_uint,\n                                               Packed: Bool) -> TypeRef;\n         #[fast_ffi]\n-        pub unsafe fn LLVMStructType(ElementTypes: *TypeRef,\n-                                     ElementCount: c_uint,\n-                                     Packed: Bool)\n-                                  -> TypeRef;\n-        #[fast_ffi]\n         pub unsafe fn LLVMCountStructElementTypes(StructTy: TypeRef)\n                                                -> c_uint;\n         #[fast_ffi]\n@@ -389,6 +365,10 @@ pub mod llvm {\n         pub unsafe fn LLVMGetPointerAddressSpace(PointerTy: TypeRef)\n                                               -> c_uint;\n         #[fast_ffi]\n+        pub unsafe fn LLVMGetPointerToGlobal(EE: ExecutionEngineRef,\n+                                             V: ValueRef)\n+                                              -> *();\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n \n         /* Operations on other types */\n@@ -399,13 +379,6 @@ pub mod llvm {\n         #[fast_ffi]\n         pub unsafe fn LLVMMetadataTypeInContext(C: ContextRef) -> TypeRef;\n \n-        #[fast_ffi]\n-        pub unsafe fn LLVMVoidType() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMLabelType() -> TypeRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMMetadataType() -> TypeRef;\n-\n         /* Operations on all values */\n         #[fast_ffi]\n         pub unsafe fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n@@ -478,15 +451,11 @@ pub mod llvm {\n                                         SLen: c_uint)\n                                      -> ValueRef;\n         #[fast_ffi]\n-        pub unsafe fn LLVMMDString(Str: *c_char, SLen: c_uint) -> ValueRef;\n-        #[fast_ffi]\n         pub unsafe fn LLVMMDNodeInContext(C: ContextRef,\n                                       Vals: *ValueRef,\n                                       Count: c_uint)\n                                    -> ValueRef;\n         #[fast_ffi]\n-        pub unsafe fn LLVMMDNode(Vals: *ValueRef, Count: c_uint) -> ValueRef;\n-        #[fast_ffi]\n         pub unsafe fn LLVMAddNamedMetadataOperand(M: ModuleRef, Str: *c_char,\n                                        Val: ValueRef);\n \n@@ -540,20 +509,11 @@ pub mod llvm {\n                                                Packed: Bool) -> ValueRef;\n \n         #[fast_ffi]\n-        pub unsafe fn LLVMConstString(Str: *c_char,\n-                                      Length: c_uint,\n-                                      DontNullTerminate: Bool)\n-                                   -> ValueRef;\n-        #[fast_ffi]\n         pub unsafe fn LLVMConstArray(ElementTy: TypeRef,\n                                      ConstantVals: *ValueRef,\n                                      Length: c_uint)\n                                   -> ValueRef;\n         #[fast_ffi]\n-        pub unsafe fn LLVMConstStruct(ConstantVals: *ValueRef,\n-                                      Count: c_uint,\n-                                      Packed: Bool) -> ValueRef;\n-        #[fast_ffi]\n         pub unsafe fn LLVMConstVector(ScalarConstantVals: *ValueRef,\n                                       Size: c_uint) -> ValueRef;\n \n@@ -966,15 +926,6 @@ pub mod llvm {\n                                                     BB: BasicBlockRef,\n                                                     Name: *c_char)\n                                                  -> BasicBlockRef;\n-\n-        #[fast_ffi]\n-        pub unsafe fn LLVMAppendBasicBlock(Fn: ValueRef,\n-                                       Name: *c_char)\n-                                    -> BasicBlockRef;\n-        #[fast_ffi]\n-        pub unsafe fn LLVMInsertBasicBlock(InsertBeforeBB: BasicBlockRef,\n-                                       Name: *c_char)\n-                                    -> BasicBlockRef;\n         #[fast_ffi]\n         pub unsafe fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n \n@@ -1035,8 +986,6 @@ pub mod llvm {\n         #[fast_ffi]\n         pub unsafe fn LLVMCreateBuilderInContext(C: ContextRef) -> BuilderRef;\n         #[fast_ffi]\n-        pub unsafe fn LLVMCreateBuilder() -> BuilderRef;\n-        #[fast_ffi]\n         pub unsafe fn LLVMPositionBuilder(Builder: BuilderRef,\n                                           Block: BasicBlockRef,\n                                           Instr: ValueRef);\n@@ -1060,6 +1009,8 @@ pub mod llvm {\n                                                 Name: *c_char);\n         #[fast_ffi]\n         pub unsafe fn LLVMDisposeBuilder(Builder: BuilderRef);\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDisposeExecutionEngine(EE: ExecutionEngineRef);\n \n         /* Metadata */\n         #[fast_ffi]\n@@ -1681,9 +1632,15 @@ pub mod llvm {\n         #[fast_ffi]\n         pub unsafe fn LLVMFinalizeFunctionPassManager(FPM:PassManagerRef) -> Bool;\n \n+        #[fast_ffi]\n+        pub unsafe fn LLVMInitializePasses();\n+\n         #[fast_ffi]\n         pub unsafe fn LLVMAddPass(PM:PassManagerRef,P:PassRef);\n \n+        #[fast_ffi]\n+        pub unsafe fn LLVMCreatePass(PassName:*c_char) -> PassRef;\n+\n         /** Adds a verification pass. */\n         #[fast_ffi]\n         pub unsafe fn LLVMAddVerifierPass(PM: PassManagerRef);\n@@ -1870,11 +1827,9 @@ pub mod llvm {\n \n         /** Execute the JIT engine. */\n         #[fast_ffi]\n-        pub unsafe fn LLVMRustExecuteJIT(MM: *(),\n-                              PM: PassManagerRef,\n+        pub unsafe fn LLVMRustBuildJIT(MM: *(),\n                               M: ModuleRef,\n-                              OptLevel: c_int,\n-                              EnableSegmentedStacks: bool) -> *();\n+                              EnableSegmentedStacks: bool) -> ExecutionEngineRef;\n \n         /** Parses the bitcode in the given memory buffer. */\n         #[fast_ffi]\n@@ -1883,7 +1838,8 @@ pub mod llvm {\n \n         /** Parses LLVM asm in the given file */\n         #[fast_ffi]\n-        pub unsafe fn LLVMRustParseAssemblyFile(Filename: *c_char)\n+        pub unsafe fn LLVMRustParseAssemblyFile(Filename: *c_char,\n+                                                C: ContextRef)\n                                              -> ModuleRef;\n \n         #[fast_ffi]\n@@ -1899,6 +1855,9 @@ pub mod llvm {\n         #[fast_ffi]\n         pub unsafe fn LLVMRustPrintPassTimings();\n \n+        #[fast_ffi]\n+        pub unsafe fn LLVMRustStartMultithreading() -> bool;\n+\n         #[fast_ffi]\n         pub unsafe fn LLVMStructCreateNamed(C: ContextRef, Name: *c_char)\n                                          -> TypeRef;\n@@ -1926,202 +1885,6 @@ pub mod llvm {\n                                     AlignStack: Bool, Dialect: c_uint)\n                                  -> ValueRef;\n \n-        // LLVM Passes\n-\n-        #[fast_ffi]\n-        pub fn LLVMCreateStripSymbolsPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateStripNonDebugSymbolsPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateStripDebugDeclarePass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateStripDeadDebugInfoPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateConstantMergePass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateGlobalOptimizerPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateGlobalDCEPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateAlwaysInlinerPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreatePruneEHPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateInternalizePass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateDeadArgEliminationPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateDeadArgHackingPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateArgumentPromotionPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateIPConstantPropagationPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateIPSCCPPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateLoopExtractorPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateSingleLoopExtractorPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateBlockExtractorPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateStripDeadPrototypesPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateFunctionAttrsPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateMergeFunctionsPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreatePartialInliningPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateMetaRenamerPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateBarrierNoopPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateFunctionInliningPass(Threshold:c_int) -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateEdgeProfilerPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateOptimalEdgeProfilerPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreatePathProfilerPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateGCOVProfilerPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateBoundsCheckingPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateConstantPropagationPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateSCCPPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateDeadInstEliminationPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateDeadCodeEliminationPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateDeadStoreEliminationPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateAggressiveDCEPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateSROAPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateScalarReplAggregatesPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateIndVarSimplifyPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateInstructionCombiningPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateLICMPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateLoopStrengthReducePass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateGlobalMergePass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateLoopUnswitchPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateLoopInstSimplifyPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateLoopUnrollPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateLoopRotatePass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateLoopIdiomPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreatePromoteMemoryToRegisterPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateDemoteRegisterToMemoryPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateReassociatePass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateJumpThreadingPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateCFGSimplificationPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateBreakCriticalEdgesPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateLoopSimplifyPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateTailCallEliminationPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateLowerSwitchPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateLowerInvokePass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateBlockPlacementPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateLCSSAPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateEarlyCSEPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateGVNPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateMemCpyOptPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateLoopDeletionPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateSimplifyLibCallsPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateCodeGenPreparePass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateInstructionNamerPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateSinkingPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateLowerAtomicPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateCorrelatedValuePropagationPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateInstructionSimplifierPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateLowerExpectIntrinsicPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateBBVectorizePass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateLoopVectorizePass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateGlobalsModRefPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateAliasAnalysisCounterPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateAAEvalPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateNoAAPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateBasicAliasAnalysisPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateScalarEvolutionAliasAnalysisPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateTypeBasedAliasAnalysisPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateProfileLoaderPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateProfileMetadataLoaderPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateNoProfileInfoPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateProfileEstimatorPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateProfileVerifierPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreatePathProfileLoaderPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateNoPathProfileInfoPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreatePathProfileVerifierPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateLazyValueInfoPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateDependenceAnalysisPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateCostModelAnalysisPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateInstCountPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateRegionInfoPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateModuleDebugInfoPrinterPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateLintPass() -> PassRef;\n-        #[fast_ffi]\n-        pub fn LLVMCreateVerifierPass() -> PassRef;\n     }\n }\n \n@@ -2200,7 +1963,7 @@ pub fn type_to_str_inner(names: @TypeNames, outer0: &[TypeRef], ty: TypeRef)\n             let mut first: bool = true;\n             for tys.each |t| {\n                 if first { first = false; } else { s += \", \"; }\n-                s += type_to_str_inner(names, outer, *t).to_owned();\n+                s += type_to_str_inner(names, outer, *t);\n             }\n             // [Note at-str] FIXME #2543: Could rewrite this without the copy,\n             // but need better @str support.\n@@ -2303,8 +2066,7 @@ pub fn struct_tys(struct_ty: TypeRef) -> ~[TypeRef] {\n             return ~[];\n         }\n         let mut elts = vec::from_elem(n_elts, ptr::null());\n-        llvm::LLVMGetStructElementTypes(\n-            struct_ty, ptr::to_mut_unsafe_ptr(&mut elts[0]));\n+        llvm::LLVMGetStructElementTypes(struct_ty, &mut elts[0]);\n         return elts;\n     }\n }"}, {"sha": "e95c841b9f783077ed2a27ac2fdbb99f53216052", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -18,9 +18,11 @@ use metadata::filesearch::FileSearch;\n use metadata::loader;\n \n use core::hashmap::HashMap;\n+use core::vec;\n use syntax::attr;\n use syntax::codemap::{span, dummy_sp};\n use syntax::diagnostic::span_handler;\n+use syntax::parse::token;\n use syntax::parse::token::ident_interner;\n use syntax::visit;\n use syntax::ast;\n@@ -50,15 +52,15 @@ pub fn read_crates(diag: @span_handler,\n             visit_item: |a| visit_item(e, a),\n             .. *visit::default_simple_visitor()});\n     visit_crate(e, crate);\n-    visit::visit_crate(crate, (), v);\n+    visit::visit_crate(crate, ((), v));\n     dump_crates(e.crate_cache);\n     warn_if_multiple_versions(e, diag, e.crate_cache);\n }\n \n struct cache_entry {\n     cnum: int,\n     span: span,\n-    hash: @~str,\n+    hash: @str,\n     metas: @~[@ast::meta_item]\n }\n \n@@ -98,12 +100,12 @@ fn warn_if_multiple_versions(e: @mut Env,\n \n         if matches.len() != 1u {\n             diag.handler().warn(\n-                fmt!(\"using multiple versions of crate `%s`\", *name));\n+                fmt!(\"using multiple versions of crate `%s`\", name));\n             for matches.each |match_| {\n                 diag.span_note(match_.span, \"used here\");\n                 let attrs = ~[\n                     attr::mk_attr(attr::mk_list_item(\n-                        @~\"link\", /*bad*/copy *match_.metas))\n+                        @\"link\", /*bad*/copy *match_.metas))\n                 ];\n                 loader::note_linkage_attrs(e.intr, diag, attrs);\n             }\n@@ -131,7 +133,7 @@ fn visit_crate(e: @mut Env, c: &ast::crate) {\n     for link_args.each |a| {\n         match attr::get_meta_item_value_str(attr::attr_meta(*a)) {\n           Some(ref linkarg) => {\n-            cstore::add_used_link_args(cstore, **linkarg);\n+            cstore::add_used_link_args(cstore, *linkarg);\n           }\n           None => {/* fallthrough */ }\n         }\n@@ -140,10 +142,10 @@ fn visit_crate(e: @mut Env, c: &ast::crate) {\n \n fn visit_view_item(e: @mut Env, i: @ast::view_item) {\n     match i.node {\n-      ast::view_item_extern_mod(ident, /*bad*/copy meta_items, id) => {\n+      ast::view_item_extern_mod(ident, ref meta_items, id) => {\n         debug!(\"resolving extern mod stmt. ident: %?, meta: %?\",\n-               ident, meta_items);\n-        let cnum = resolve_crate(e, ident, meta_items, @~\"\", i.span);\n+               ident, *meta_items);\n+        let cnum = resolve_crate(e, ident, copy *meta_items, @\"\", i.span);\n         cstore::add_extern_mod_stmt_cnum(e.cstore, id, cnum);\n       }\n       _ => ()\n@@ -167,22 +169,22 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n                     match attr::first_attr_value_str_by_name(i.attrs,\n                                                              \"link_name\") {\n                         Some(nn) => {\n-                            if *nn == ~\"\" {\n+                            if nn.is_empty() {\n                                 e.diag.span_fatal(\n                                     i.span,\n                                     \"empty #[link_name] not allowed; use \\\n                                      #[nolink].\");\n                             }\n                             nn\n                         }\n-                        None => e.intr.get(i.ident)\n+                        None => token::ident_to_str(&i.ident)\n                     };\n                 if attr::find_attrs_by_name(i.attrs, \"nolink\").is_empty() {\n                     already_added =\n                         !cstore::add_used_library(cstore, foreign_name);\n                 }\n                 if !link_args.is_empty() && already_added {\n-                    e.diag.span_fatal(i.span, ~\"library '\" + *foreign_name +\n+                    e.diag.span_fatal(i.span, ~\"library '\" + foreign_name +\n                                \"' already added: can't specify link_args.\");\n                 }\n             }\n@@ -192,7 +194,7 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n         for link_args.each |a| {\n             match attr::get_meta_item_value_str(attr::attr_meta(*a)) {\n                 Some(linkarg) => {\n-                    cstore::add_used_link_args(cstore, *linkarg);\n+                    cstore::add_used_link_args(cstore, linkarg);\n                 }\n                 None => { /* fallthrough */ }\n             }\n@@ -202,22 +204,22 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n     }\n }\n \n-fn metas_with(ident: @~str, key: @~str, metas: ~[@ast::meta_item])\n+fn metas_with(ident: @str, key: @str, metas: ~[@ast::meta_item])\n     -> ~[@ast::meta_item] {\n-    let name_items = attr::find_meta_items_by_name(metas, *key);\n+    let name_items = attr::find_meta_items_by_name(metas, key);\n     if name_items.is_empty() {\n         vec::append_one(metas, attr::mk_name_value_item_str(key, ident))\n     } else {\n         metas\n     }\n }\n \n-fn metas_with_ident(ident: @~str, metas: ~[@ast::meta_item])\n+fn metas_with_ident(ident: @str, metas: ~[@ast::meta_item])\n     -> ~[@ast::meta_item] {\n-    metas_with(ident, @~\"name\", metas)\n+    metas_with(ident, @\"name\", metas)\n }\n \n-fn existing_match(e: @mut Env, metas: &[@ast::meta_item], hash: @~str)\n+fn existing_match(e: @mut Env, metas: &[@ast::meta_item], hash: @str)\n                -> Option<int> {\n     for e.crate_cache.each |c| {\n         if loader::metadata_matches(*c.metas, metas)\n@@ -231,10 +233,10 @@ fn existing_match(e: @mut Env, metas: &[@ast::meta_item], hash: @~str)\n fn resolve_crate(e: @mut Env,\n                  ident: ast::ident,\n                  metas: ~[@ast::meta_item],\n-                 hash: @~str,\n+                 hash: @str,\n                  span: span)\n               -> ast::crate_num {\n-    let metas = metas_with_ident(@/*bad*/copy *e.intr.get(ident), metas);\n+    let metas = metas_with_ident(token::ident_to_str(&ident), metas);\n \n     match existing_match(e, metas, hash) {\n       None => {\n@@ -275,7 +277,7 @@ fn resolve_crate(e: @mut Env,\n             match attr::last_meta_item_value_str_by_name(load_ctxt.metas,\n                                                          \"name\") {\n                 Some(v) => v,\n-                None => e.intr.get(ident),\n+                None => token::ident_to_str(&ident),\n             };\n         let cmeta = @cstore::crate_metadata {\n             name: cname,\n@@ -301,13 +303,14 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers\n     let mut cnum_map = HashMap::new();\n-    for decoder::get_crate_deps(e.intr, cdata).each |dep| {\n+    for decoder::get_crate_deps(cdata).each |dep| {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.name;\n-        let cmetas = metas_with(dep.vers, @~\"vers\", ~[]);\n+        let cname_str = token::ident_to_str(&dep.name);\n+        let cmetas = metas_with(dep.vers, @\"vers\", ~[]);\n         debug!(\"resolving dep crate %s ver: %s hash: %s\",\n-               *e.intr.get(dep.name), *dep.vers, *dep.hash);\n-        match existing_match(e, metas_with_ident(e.intr.get(cname),\n+               cname_str, dep.vers, dep.hash);\n+        match existing_match(e, metas_with_ident(cname_str,\n                                                  copy cmetas),\n                              dep.hash) {\n           Some(local_cnum) => {"}, {"sha": "5b154f6836c281e375ee0f8fdeb7df2622878d31", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -18,6 +18,7 @@ use metadata::decoder;\n use metadata;\n use middle::{ty, resolve};\n \n+use core::vec;\n use reader = extra::ebml::reader;\n use syntax::ast;\n use syntax::ast_map;\n@@ -68,12 +69,12 @@ pub fn each_path(cstore: @mut cstore::CStore,\n pub fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    let path = decoder::get_item_path(cstore.intr, cdata, def.node);\n+    let path = decoder::get_item_path(cdata, def.node);\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n     vec::append(~[ast_map::path_mod(tcx.sess.ident_of(\n-        *cdata.name))], path)\n+        cdata.name))], path)\n }\n \n pub enum found_ast {\n@@ -90,7 +91,7 @@ pub fn maybe_get_item_ast(tcx: ty::ctxt, def: ast::def_id,\n                        -> found_ast {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::maybe_get_item_ast(cstore.intr, cdata, tcx, def.node,\n+    decoder::maybe_get_item_ast(cdata, tcx, def.node,\n                                 decode_inlined_item)\n }\n \n@@ -148,7 +149,7 @@ pub fn get_supertraits(tcx: ty::ctxt, def: ast::def_id) -> ~[@ty::TraitRef] {\n pub fn get_type_name_if_impl(cstore: @mut cstore::CStore, def: ast::def_id)\n                           -> Option<ast::ident> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::get_type_name_if_impl(cstore.intr, cdata, def.node)\n+    decoder::get_type_name_if_impl(cdata, def.node)\n }\n \n pub fn get_static_methods_if_impl(cstore: @mut cstore::CStore,"}, {"sha": "2819340ae453edfe27340f36f7df498d2a6e50dd", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -18,6 +18,7 @@ use metadata::cstore;\n use metadata::decoder;\n \n use core::hashmap::HashMap;\n+use core::vec;\n use extra;\n use syntax::ast;\n use syntax::parse::token::ident_interner;\n@@ -29,7 +30,7 @@ use syntax::parse::token::ident_interner;\n pub type cnum_map = @mut HashMap<ast::crate_num, ast::crate_num>;\n \n pub struct crate_metadata {\n-    name: @~str,\n+    name: @str,\n     data: @~[u8],\n     cnum_map: cnum_map,\n     cnum: ast::crate_num\n@@ -39,8 +40,8 @@ pub struct CStore {\n     priv metas: HashMap <ast::crate_num, @crate_metadata>,\n     priv extern_mod_crate_map: extern_mod_crate_map,\n     priv used_crate_files: ~[Path],\n-    priv used_libraries: ~[~str],\n-    priv used_link_args: ~[~str],\n+    priv used_libraries: ~[@str],\n+    priv used_link_args: ~[@str],\n     intr: @ident_interner\n }\n \n@@ -63,12 +64,12 @@ pub fn get_crate_data(cstore: &CStore, cnum: ast::crate_num)\n     return *cstore.metas.get(&cnum);\n }\n \n-pub fn get_crate_hash(cstore: &CStore, cnum: ast::crate_num) -> @~str {\n+pub fn get_crate_hash(cstore: &CStore, cnum: ast::crate_num) -> @str {\n     let cdata = get_crate_data(cstore, cnum);\n     decoder::get_crate_hash(cdata.data)\n }\n \n-pub fn get_crate_vers(cstore: &CStore, cnum: ast::crate_num) -> @~str {\n+pub fn get_crate_vers(cstore: &CStore, cnum: ast::crate_num) -> @str {\n     let cdata = get_crate_data(cstore, cnum);\n     decoder::get_crate_vers(cdata.data)\n }\n@@ -100,26 +101,28 @@ pub fn get_used_crate_files(cstore: &CStore) -> ~[Path] {\n     return /*bad*/copy cstore.used_crate_files;\n }\n \n-pub fn add_used_library(cstore: &mut CStore, lib: @~str) -> bool {\n-    assert!(*lib != ~\"\");\n+pub fn add_used_library(cstore: &mut CStore, lib: @str) -> bool {\n+    assert!(!lib.is_empty());\n \n-    if cstore.used_libraries.contains(&*lib) { return false; }\n-    cstore.used_libraries.push(/*bad*/ copy *lib);\n+    if cstore.used_libraries.contains(&lib) { return false; }\n+    cstore.used_libraries.push(lib);\n     true\n }\n \n-pub fn get_used_libraries(cstore: &CStore) -> ~[~str] {\n-    /*bad*/copy cstore.used_libraries\n+pub fn get_used_libraries<'a>(cstore: &'a CStore) -> &'a [@str] {\n+    let slice: &'a [@str] = cstore.used_libraries;\n+    slice\n }\n \n pub fn add_used_link_args(cstore: &mut CStore, args: &str) {\n-    for args.each_split_char(' ') |s| {\n-        cstore.used_link_args.push(s.to_owned());\n+    for args.split_iter(' ').advance |s| {\n+        cstore.used_link_args.push(s.to_managed());\n     }\n }\n \n-pub fn get_used_link_args(cstore: &CStore) -> ~[~str] {\n-    /*bad*/copy cstore.used_link_args\n+pub fn get_used_link_args<'a>(cstore: &'a CStore) -> &'a [@str] {\n+    let slice: &'a [@str] = cstore.used_link_args;\n+    slice\n }\n \n pub fn add_extern_mod_stmt_cnum(cstore: &mut CStore,\n@@ -136,15 +139,15 @@ pub fn find_extern_mod_stmt_cnum(cstore: &CStore,\n \n // returns hashes of crates directly used by this crate. Hashes are sorted by\n // (crate name, crate version, crate hash) in lexicographic order (not semver)\n-pub fn get_dep_hashes(cstore: &CStore) -> ~[~str] {\n-    struct crate_hash { name: @~str, vers: @~str, hash: @~str }\n+pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n+    struct crate_hash { name: @str, vers: @str, hash: @str }\n     let mut result = ~[];\n \n     for cstore.extern_mod_crate_map.each_value |&cnum| {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n         let vers = decoder::get_crate_vers(cdata.data);\n-        debug!(\"Add hash[%s]: %s %s\", *cdata.name, *vers, *hash);\n+        debug!(\"Add hash[%s]: %s %s\", cdata.name, vers, hash);\n         result.push(crate_hash {\n             name: cdata.name,\n             vers: vers,\n@@ -158,8 +161,8 @@ pub fn get_dep_hashes(cstore: &CStore) -> ~[~str] {\n \n     debug!(\"sorted:\");\n     for sorted.each |x| {\n-        debug!(\"  hash[%s]: %s\", *x.name, *x.hash);\n+        debug!(\"  hash[%s]: %s\", x.name, x.hash);\n     }\n \n-    sorted.map(|ch| /*bad*/copy *ch.hash)\n+    sorted.map(|ch| ch.hash)\n }"}, {"sha": "fdef25b5e711af2db618c1ec1f77bc4d905f1fdd", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 141, "deletions": 163, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -36,10 +36,11 @@ use extra::serialize::Decodable;\n use syntax::ast_map;\n use syntax::attr;\n use syntax::diagnostic::span_handler;\n-use syntax::parse::token::{StringRef, ident_interner, special_idents};\n+use syntax::parse::token::{ident_interner, special_idents};\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n use syntax::codemap;\n+use syntax::parse::token;\n \n type cmd = @crate_metadata;\n \n@@ -81,17 +82,17 @@ pub fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n }\n \n fn find_item(item_id: int, items: ebml::Doc) -> ebml::Doc {\n-    return maybe_find_item(item_id, items).get();\n+    match maybe_find_item(item_id, items) {\n+       None => fail!(\"lookup_item: id not found: %d\", item_id),\n+       Some(d) => d\n+    }\n }\n \n // Looks up an item in the given metadata and returns an ebml doc pointing\n // to the item data.\n fn lookup_item(item_id: int, data: @~[u8]) -> ebml::Doc {\n     let items = reader::get_doc(reader::Doc(data), tag_items);\n-    match maybe_find_item(item_id, items) {\n-       None => fail!(\"lookup_item: id not found: %d\", item_id),\n-       Some(d) => d\n-    }\n+    find_item(item_id, items)\n }\n \n #[deriving(Eq)]\n@@ -161,19 +162,18 @@ fn item_visibility(item: ebml::Doc) -> ast::visibility {\n \n fn item_method_sort(item: ebml::Doc) -> char {\n     for reader::tagged_docs(item, tag_item_trait_method_sort) |doc| {\n-        return str::from_bytes(reader::doc_data(doc))[0] as char;\n+        return doc.as_str_slice()[0] as char;\n     }\n     return 'r';\n }\n \n fn item_symbol(item: ebml::Doc) -> ~str {\n-    let sym = reader::get_doc(item, tag_items_data_item_symbol);\n-    return str::from_bytes(reader::doc_data(sym));\n+    reader::get_doc(item, tag_items_data_item_symbol).as_str()\n }\n \n fn item_parent_item(d: ebml::Doc) -> Option<ast::def_id> {\n     for reader::tagged_docs(d, tag_items_data_parent_item) |did| {\n-        return Some(reader::with_doc_data(did, |d| parse_def_id(d)));\n+        return Some(reader::with_doc_data(did, parse_def_id));\n     }\n     None\n }\n@@ -194,8 +194,7 @@ fn item_reqd_and_translated_parent_item(cnum: ast::crate_num,\n \n fn item_def_id(d: ebml::Doc, cdata: cmd) -> ast::def_id {\n     let tagdoc = reader::get_doc(d, tag_def_id);\n-    return translate_def_id(cdata, reader::with_doc_data(tagdoc,\n-                                                    |d| parse_def_id(d)));\n+    return translate_def_id(cdata, reader::with_doc_data(tagdoc, parse_def_id));\n }\n \n fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) -> bool {\n@@ -209,19 +208,19 @@ fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) -> bool {\n \n fn variant_disr_val(d: ebml::Doc) -> Option<int> {\n     do reader::maybe_get_doc(d, tag_disr_val).chain |val_doc| {\n-        int::parse_bytes(reader::doc_data(val_doc), 10u)\n+        do reader::with_doc_data(val_doc) |data| { int::parse_bytes(data, 10u) }\n     }\n }\n \n fn doc_type(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n     let tp = reader::get_doc(doc, tag_items_data_item_type);\n-    parse_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n+    parse_ty_data(*tp.data, cdata.cnum, tp.start, tcx,\n                   |_, did| translate_def_id(cdata, did))\n }\n \n fn doc_method_fty(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::BareFnTy {\n     let tp = reader::get_doc(doc, tag_item_method_fty);\n-    parse_bare_fn_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n+    parse_bare_fn_ty_data(*tp.data, cdata.cnum, tp.start, tcx,\n                           |_, did| translate_def_id(cdata, did))\n }\n \n@@ -230,7 +229,7 @@ fn doc_transformed_self_ty(doc: ebml::Doc,\n                            cdata: cmd) -> Option<ty::t>\n {\n     do reader::maybe_get_doc(doc, tag_item_method_transformed_self_ty).map |tp| {\n-        parse_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n+        parse_ty_data(*tp.data, cdata.cnum, tp.start, tcx,\n                       |_, did| translate_def_id(cdata, did))\n     }\n }\n@@ -241,7 +240,7 @@ pub fn item_type(_item_id: ast::def_id, item: ebml::Doc,\n }\n \n fn doc_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::TraitRef {\n-    parse_trait_ref_data(doc.data, cdata.cnum, doc.start, tcx,\n+    parse_trait_ref_data(*doc.data, cdata.cnum, doc.start, tcx,\n                          |_, did| translate_def_id(cdata, did))\n }\n \n@@ -256,7 +255,7 @@ fn item_ty_param_defs(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd,\n     let mut bounds = ~[];\n     for reader::tagged_docs(item, tag) |p| {\n         let bd = parse_type_param_def_data(\n-            p.data, p.start, cdata.cnum, tcx,\n+            *p.data, p.start, cdata.cnum, tcx,\n             |_, did| translate_def_id(cdata, did));\n         bounds.push(bd);\n     }\n@@ -281,13 +280,13 @@ fn enum_variant_ids(item: ebml::Doc, cdata: cmd) -> ~[ast::def_id] {\n     let mut ids: ~[ast::def_id] = ~[];\n     let v = tag_items_data_item_variant;\n     for reader::tagged_docs(item, v) |p| {\n-        let ext = reader::with_doc_data(p, |d| parse_def_id(d));\n+        let ext = reader::with_doc_data(p, parse_def_id);\n         ids.push(ast::def_id { crate: cdata.cnum, node: ext.node });\n     };\n     return ids;\n }\n \n-fn item_path(intr: @ident_interner, item_doc: ebml::Doc) -> ast_map::path {\n+fn item_path(item_doc: ebml::Doc) -> ast_map::path {\n     let path_doc = reader::get_doc(item_doc, tag_path);\n \n     let len_doc = reader::get_doc(path_doc, tag_path_len);\n@@ -296,11 +295,11 @@ fn item_path(intr: @ident_interner, item_doc: ebml::Doc) -> ast_map::path {\n     let mut result = vec::with_capacity(len);\n     for reader::docs(path_doc) |tag, elt_doc| {\n         if tag == tag_path_elt_mod {\n-            let str = reader::doc_as_str(elt_doc);\n-            result.push(ast_map::path_mod(intr.intern(str)));\n+            let str = elt_doc.as_str_slice();\n+            result.push(ast_map::path_mod(token::str_to_ident(str)));\n         } else if tag == tag_path_elt_name {\n-            let str = reader::doc_as_str(elt_doc);\n-            result.push(ast_map::path_name(intr.intern(str)));\n+            let str = elt_doc.as_str_slice();\n+            result.push(ast_map::path_name(token::str_to_ident(str)));\n         } else {\n             // ignore tag_path_len element\n         }\n@@ -311,12 +310,10 @@ fn item_path(intr: @ident_interner, item_doc: ebml::Doc) -> ast_map::path {\n \n fn item_name(intr: @ident_interner, item: ebml::Doc) -> ast::ident {\n     let name = reader::get_doc(item, tag_paths_data_name);\n-    do reader::with_doc_data(name) |data| {\n-        let string = str::from_bytes_slice(data);\n-        match intr.find_equiv(&StringRef(string)) {\n-            None => intr.intern(string),\n-            Some(val) => val,\n-        }\n+    let string = name.as_str_slice();\n+    match intr.find_equiv(&string) {\n+        None => token::str_to_ident(string),\n+        Some(val) => ast::new_ident(val),\n     }\n }\n \n@@ -412,15 +409,9 @@ pub fn get_impl_trait(cdata: cmd,\n                        tcx: ty::ctxt) -> Option<@ty::TraitRef>\n {\n     let item_doc = lookup_item(id, cdata.data);\n-    let mut result = None;\n-    for reader::tagged_docs(item_doc, tag_item_trait_ref) |tp| {\n-        let trait_ref =\n-            @parse_trait_ref_data(tp.data, cdata.cnum, tp.start, tcx,\n-                                  |_, did| translate_def_id(cdata, did));\n-        result = Some(trait_ref);\n-        break;\n-    };\n-    result\n+    do reader::maybe_get_doc(item_doc, tag_item_trait_ref).map |&tp| {\n+        @doc_trait_ref(tp, tcx, cdata)\n+    }\n }\n \n pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n@@ -429,7 +420,7 @@ pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     let mut found = None;\n     for reader::tagged_docs(find_item(id, items), tag_item_impl_method)\n         |mid| {\n-            let m_did = reader::with_doc_data(mid, |d| parse_def_id(d));\n+            let m_did = reader::with_doc_data(mid, parse_def_id);\n             if item_name(intr, find_item(m_did.node, items)) == name {\n                 found = Some(translate_def_id(cdata, m_did));\n             }\n@@ -475,108 +466,94 @@ pub fn each_lang_item(cdata: cmd, f: &fn(ast::node_id, uint) -> bool) -> bool {\n }\n \n /// Iterates over all the paths in the given crate.\n-pub fn _each_path(intr: @ident_interner,\n-                  cdata: cmd,\n-                  get_crate_data: GetCrateDataCb,\n-                  f: &fn(&str, def_like, ast::visibility) -> bool)\n-                  -> bool {\n+pub fn each_path(intr: @ident_interner,\n+                 cdata: cmd,\n+                 get_crate_data: GetCrateDataCb,\n+                 f: &fn(&str, def_like, ast::visibility) -> bool)\n+                 -> bool {\n+    // FIXME #4572: This function needs to be nuked, as it's impossible to make fast.\n+    // It's the source of most of the performance problems when compiling small crates.\n+\n     let root = reader::Doc(cdata.data);\n     let items = reader::get_doc(root, tag_items);\n     let items_data = reader::get_doc(items, tag_items_data);\n \n-    let mut broken = false;\n-\n     // First, go through all the explicit items.\n     for reader::tagged_docs(items_data, tag_items_data_item) |item_doc| {\n-        if !broken {\n-            let path = ast_map::path_to_str_with_sep(\n-                item_path(intr, item_doc), ~\"::\", intr);\n-            let path_is_empty = path.is_empty();\n-            if !path_is_empty {\n-                // Extract the def ID.\n-                let def_id = item_def_id(item_doc, cdata);\n-\n-                // Construct the def for this item.\n-                debug!(\"(each_path) yielding explicit item: %s\", path);\n-                let def_like = item_to_def_like(item_doc, def_id, cdata.cnum);\n-\n-                let vis = item_visibility(item_doc);\n-\n-                // Hand the information off to the iteratee.\n-                if !f(path, def_like, vis) {\n-                    broken = true;      // FIXME #4572: This is awful.\n-                }\n+        let path = ast_map::path_to_str(item_path(item_doc), intr);\n+        let path_is_empty = path.is_empty();\n+        if !path_is_empty {\n+            // Extract the def ID.\n+            let def_id = item_def_id(item_doc, cdata);\n+\n+            // Construct the def for this item.\n+            debug!(\"(each_path) yielding explicit item: %s\", path);\n+            let def_like = item_to_def_like(item_doc, def_id, cdata.cnum);\n+\n+            let vis = item_visibility(item_doc);\n+\n+            // Hand the information off to the iteratee.\n+            if !f(path, def_like, vis) {\n+                return false;\n             }\n+        }\n \n-            // If this is a module, find the reexports.\n-            for each_reexport(item_doc) |reexport_doc| {\n-                if !broken {\n-                    let def_id_doc =\n-                        reader::get_doc(reexport_doc,\n-                            tag_items_data_item_reexport_def_id);\n-                    let def_id =\n-                        reader::with_doc_data(def_id_doc,\n-                                              |d| parse_def_id(d));\n-                    let def_id = translate_def_id(cdata, def_id);\n-\n-                    let reexport_name_doc =\n-                        reader::get_doc(reexport_doc,\n-                                      tag_items_data_item_reexport_name);\n-                    let reexport_name = reader::doc_as_str(reexport_name_doc);\n-\n-                    let reexport_path;\n-                    if path_is_empty {\n-                        reexport_path = reexport_name;\n-                    } else {\n-                        reexport_path = path + \"::\" + reexport_name;\n-                    }\n+        // If this is a module, find the reexports.\n+        for each_reexport(item_doc) |reexport_doc| {\n+            let def_id_doc =\n+                reader::get_doc(reexport_doc,\n+                                tag_items_data_item_reexport_def_id);\n+            let def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n+            let def_id = translate_def_id(cdata, def_id);\n+\n+            let reexport_name_doc =\n+                reader::get_doc(reexport_doc,\n+                                tag_items_data_item_reexport_name);\n+            let reexport_name = reexport_name_doc.as_str_slice();\n+\n+            let reexport_path;\n+            if path_is_empty {\n+                reexport_path = reexport_name.to_owned();\n+            } else {\n+                reexport_path = path + \"::\" + reexport_name;\n+            }\n \n-                    // This reexport may be in yet another crate\n-                    let other_crates_items = if def_id.crate == cdata.cnum {\n-                        items\n-                    } else {\n-                        let crate_data = get_crate_data(def_id.crate);\n-                        let root = reader::Doc(crate_data.data);\n-                        reader::get_doc(root, tag_items)\n-                    };\n-\n-                    // Get the item.\n-                    match maybe_find_item(def_id.node, other_crates_items) {\n-                        None => {}\n-                        Some(item_doc) => {\n-                            // Construct the def for this item.\n-                            let def_like = item_to_def_like(item_doc,\n-                                                            def_id,\n-                                                            cdata.cnum);\n-\n-                            // Hand the information off to the iteratee.\n-                            debug!(\"(each_path) yielding reexported \\\n-                                    item: %s\", reexport_path);\n-\n-                            if (!f(reexport_path, def_like, ast::public)) {\n-                                broken = true;  // FIXME #4572: This is awful.\n-                            }\n-                        }\n+            // This reexport may be in yet another crate\n+            let other_crates_items = if def_id.crate == cdata.cnum {\n+                items\n+            } else {\n+                let crate_data = get_crate_data(def_id.crate);\n+                let root = reader::Doc(crate_data.data);\n+                reader::get_doc(root, tag_items)\n+            };\n+\n+            // Get the item.\n+            match maybe_find_item(def_id.node, other_crates_items) {\n+                None => {}\n+                Some(item_doc) => {\n+                    // Construct the def for this item.\n+                    let def_like = item_to_def_like(item_doc,\n+                                                    def_id,\n+                                                    cdata.cnum);\n+\n+                    // Hand the information off to the iteratee.\n+                    debug!(\"(each_path) yielding reexported \\\n+                           item: %s\", reexport_path);\n+\n+                    if (!f(reexport_path, def_like, ast::public)) {\n+                        return false;\n                     }\n                 }\n             }\n         }\n     }\n \n-    return broken;\n-}\n-\n-pub fn each_path(intr: @ident_interner,\n-                 cdata: cmd,\n-                 get_crate_data: GetCrateDataCb,\n-                 f: &fn(&str, def_like, ast::visibility) -> bool)\n-                 -> bool {\n-    _each_path(intr, cdata, get_crate_data, f)\n+    return true;\n }\n \n-pub fn get_item_path(intr: @ident_interner, cdata: cmd, id: ast::node_id)\n+pub fn get_item_path(cdata: cmd, id: ast::node_id)\n     -> ast_map::path {\n-    item_path(intr, lookup_item(id, cdata.data))\n+    item_path(lookup_item(id, cdata.data))\n }\n \n pub type decode_inlined_item<'self> = &'self fn(\n@@ -585,14 +562,14 @@ pub type decode_inlined_item<'self> = &'self fn(\n     path: ast_map::path,\n     par_doc: ebml::Doc) -> Option<ast::inlined_item>;\n \n-pub fn maybe_get_item_ast(intr: @ident_interner, cdata: cmd, tcx: ty::ctxt,\n+pub fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt,\n                           id: ast::node_id,\n                           decode_inlined_item: decode_inlined_item)\n                        -> csearch::found_ast {\n     debug!(\"Looking up item: %d\", id);\n     let item_doc = lookup_item(id, cdata.data);\n     let path = {\n-        let item_path = item_path(intr, item_doc);\n+        let item_path = item_path(item_doc);\n         vec::to_owned(item_path.init())\n     };\n     match decode_inlined_item(cdata, tcx, copy path, item_doc) {\n@@ -657,7 +634,7 @@ fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n     }\n \n     let explicit_self_doc = reader::get_doc(item, tag_item_trait_method_explicit_self);\n-    let string = reader::doc_as_str(explicit_self_doc);\n+    let string = explicit_self_doc.as_str_slice();\n \n     let explicit_self_kind = string[0];\n     match explicit_self_kind as char {\n@@ -679,7 +656,7 @@ fn item_impl_methods(intr: @ident_interner, cdata: cmd, item: ebml::Doc,\n                      base_tps: uint) -> ~[@resolve::MethodInfo] {\n     let mut rslt = ~[];\n     for reader::tagged_docs(item, tag_item_impl_method) |doc| {\n-        let m_did = reader::with_doc_data(doc, |d| parse_def_id(d));\n+        let m_did = reader::with_doc_data(doc, parse_def_id);\n         let mth_item = lookup_item(m_did.node, cdata.data);\n         let explicit_self = get_explicit_self(mth_item);\n         rslt.push(@resolve::MethodInfo {\n@@ -701,7 +678,7 @@ pub fn get_impls_for_mod(intr: @ident_interner,\n     let mod_item = lookup_item(m_id, data);\n     let mut result = ~[];\n     for reader::tagged_docs(mod_item, tag_mod_impl) |doc| {\n-        let did = reader::with_doc_data(doc, |d| parse_def_id(d));\n+        let did = reader::with_doc_data(doc, parse_def_id);\n         let local_did = translate_def_id(cdata, did);\n         debug!(\"(get impls for mod) getting did %? for '%?'\",\n                local_did, name);\n@@ -834,16 +811,15 @@ pub fn get_supertraits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     return results;\n }\n \n-pub fn get_type_name_if_impl(intr: @ident_interner,\n-                             cdata: cmd,\n+pub fn get_type_name_if_impl(cdata: cmd,\n                              node_id: ast::node_id) -> Option<ast::ident> {\n     let item = lookup_item(node_id, cdata.data);\n     if item_family(item) != Impl {\n         return None;\n     }\n \n     for reader::tagged_docs(item, tag_item_impl_type_basename) |doc| {\n-        return Some(intr.intern(str::from_bytes(reader::doc_data(doc))));\n+        return Some(token::str_to_ident(doc.as_str_slice()));\n     }\n \n     return None;\n@@ -865,7 +841,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n \n     let mut impl_method_ids = ~[];\n     for reader::tagged_docs(item, tag_item_impl_method) |impl_method_doc| {\n-        impl_method_ids.push(parse_def_id(reader::doc_data(impl_method_doc)));\n+        impl_method_ids.push(reader::with_doc_data(impl_method_doc, parse_def_id));\n     }\n \n     let mut static_impl_methods = ~[];\n@@ -962,12 +938,13 @@ fn family_names_type(fam: Family) -> bool {\n }\n \n fn read_path(d: ebml::Doc) -> (~str, uint) {\n-    let desc = reader::doc_data(d);\n-    let pos = io::u64_from_be_bytes(desc, 0u, 4u) as uint;\n-    let pathbytes = vec::slice::<u8>(desc, 4u, vec::len::<u8>(desc));\n-    let path = str::from_bytes(pathbytes);\n+    do reader::with_doc_data(d) |desc| {\n+        let pos = io::u64_from_be_bytes(desc, 0u, 4u) as uint;\n+        let pathbytes = desc.slice(4u, desc.len());\n+        let path = str::from_bytes(pathbytes);\n \n-    (path, pos)\n+        (path, pos)\n+    }\n }\n \n fn describe_def(items: ebml::Doc, id: ast::def_id) -> ~str {\n@@ -1008,23 +985,23 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::meta_item] {\n     let mut items: ~[@ast::meta_item] = ~[];\n     for reader::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = str::from_bytes(reader::doc_data(nd));\n-        items.push(attr::mk_word_item(@n));\n+        let n = nd.as_str_slice().to_managed();\n+        items.push(attr::mk_word_item(n));\n     };\n     for reader::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let vd = reader::get_doc(meta_item_doc, tag_meta_item_value);\n-        let n = str::from_bytes(reader::doc_data(nd));\n-        let v = str::from_bytes(reader::doc_data(vd));\n+        let n = nd.as_str_slice().to_managed();\n+        let v = vd.as_str_slice().to_managed();\n         // FIXME (#623): Should be able to decode meta_name_value variants,\n         // but currently the encoder just drops them\n-        items.push(attr::mk_name_value_item_str(@n, @v));\n+        items.push(attr::mk_name_value_item_str(n, v));\n     };\n     for reader::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = str::from_bytes(reader::doc_data(nd));\n+        let n = nd.as_str_slice().to_managed();\n         let subitems = get_meta_items(meta_item_doc);\n-        items.push(attr::mk_list_item(@n, subitems));\n+        items.push(attr::mk_list_item(n, subitems));\n     };\n     return items;\n }\n@@ -1081,53 +1058,54 @@ pub fn get_crate_attributes(data: @~[u8]) -> ~[ast::attribute] {\n pub struct crate_dep {\n     cnum: ast::crate_num,\n     name: ast::ident,\n-    vers: @~str,\n-    hash: @~str\n+    vers: @str,\n+    hash: @str\n }\n \n-pub fn get_crate_deps(intr: @ident_interner, data: @~[u8]) -> ~[crate_dep] {\n+pub fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n     let mut deps: ~[crate_dep] = ~[];\n     let cratedoc = reader::Doc(data);\n     let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n-    fn docstr(doc: ebml::Doc, tag_: uint) -> ~str {\n-        str::from_bytes(reader::doc_data(reader::get_doc(doc, tag_)))\n+    fn docstr(doc: ebml::Doc, tag_: uint) -> @str {\n+        let d = reader::get_doc(doc, tag_);\n+        d.as_str_slice().to_managed()\n     }\n     for reader::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n         deps.push(crate_dep {cnum: crate_num,\n-                  name: intr.intern(docstr(depdoc, tag_crate_dep_name)),\n-                  vers: @docstr(depdoc, tag_crate_dep_vers),\n-                  hash: @docstr(depdoc, tag_crate_dep_hash)});\n+                  name: token::str_to_ident(docstr(depdoc, tag_crate_dep_name)),\n+                  vers: docstr(depdoc, tag_crate_dep_vers),\n+                  hash: docstr(depdoc, tag_crate_dep_hash)});\n         crate_num += 1;\n     };\n     return deps;\n }\n \n-fn list_crate_deps(intr: @ident_interner, data: @~[u8], out: @io::Writer) {\n+fn list_crate_deps(data: @~[u8], out: @io::Writer) {\n     out.write_str(\"=External Dependencies=\\n\");\n \n-    for get_crate_deps(intr, data).each |dep| {\n+    for get_crate_deps(data).each |dep| {\n         out.write_str(\n             fmt!(\"%d %s-%s-%s\\n\",\n-                 dep.cnum, *intr.get(dep.name), *dep.hash, *dep.vers));\n+                 dep.cnum, token::ident_to_str(&dep.name), dep.hash, dep.vers));\n     }\n \n     out.write_str(\"\\n\");\n }\n \n-pub fn get_crate_hash(data: @~[u8]) -> @~str {\n+pub fn get_crate_hash(data: @~[u8]) -> @str {\n     let cratedoc = reader::Doc(data);\n     let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n-    @str::from_bytes(reader::doc_data(hashdoc))\n+    hashdoc.as_str_slice().to_managed()\n }\n \n-pub fn get_crate_vers(data: @~[u8]) -> @~str {\n+pub fn get_crate_vers(data: @~[u8]) -> @str {\n     let attrs = decoder::get_crate_attributes(data);\n     let linkage_attrs = attr::find_linkage_metas(attrs);\n \n     match attr::last_meta_item_value_str_by_name(linkage_attrs, \"vers\") {\n         Some(ver) => ver,\n-        None => @~\"0.0\"\n+        None => @\"0.0\"\n     }\n }\n \n@@ -1149,8 +1127,8 @@ pub fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n                            out: @io::Writer) {\n     let hash = get_crate_hash(bytes);\n     let md = reader::Doc(bytes);\n-    list_crate_attributes(intr, md, *hash, out);\n-    list_crate_deps(intr, bytes, out);\n+    list_crate_attributes(intr, md, hash, out);\n+    list_crate_deps(bytes, out);\n }\n \n // Translates a def_id from an external crate to a def_id for the current\n@@ -1173,7 +1151,7 @@ pub fn get_link_args_for_crate(cdata: cmd) -> ~[~str] {\n     let link_args = reader::get_doc(reader::Doc(cdata.data), tag_link_args);\n     let mut result = ~[];\n     for reader::tagged_docs(link_args, tag_link_args_arg) |arg_doc| {\n-        result.push(reader::doc_as_str(arg_doc));\n+        result.push(arg_doc.as_str());\n     }\n     result\n }"}, {"sha": "110f686e5a6642b63d512dce47d5c519f547670c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 213, "deletions": 147, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -22,9 +22,14 @@ use middle::ty;\n use middle;\n use util::ppaux::ty_to_str;\n \n-use extra::flate;\n use core::hash::HashUtil;\n use core::hashmap::HashMap;\n+use core::int;\n+use core::io;\n+use core::str;\n+use core::uint;\n+use core::vec;\n+use extra::flate;\n use extra::serialize::Encodable;\n use extra;\n use syntax::abi::AbiSet;\n@@ -34,31 +39,34 @@ use syntax::ast_map;\n use syntax::ast_util::*;\n use syntax::attr;\n use syntax::diagnostic::span_handler;\n-use syntax::parse::token::special_idents;\n-use syntax::{ast_util, visit};\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n+use syntax::parse::token::special_idents;\n+use syntax::{ast_util, visit};\n+use syntax::parse::token;\n use syntax;\n use writer = extra::ebml::writer;\n \n+use core::cast;\n+\n // used by astencode:\n type abbrev_map = @mut HashMap<ty::t, tyencode::ty_abbrev>;\n \n-pub type encode_inlined_item = @fn(ecx: @EncodeContext,\n+pub type encode_inlined_item<'self> = &'self fn(ecx: &EncodeContext,\n                                    ebml_w: &mut writer::Encoder,\n                                    path: &[ast_map::path_elt],\n                                    ii: ast::inlined_item);\n \n-pub struct EncodeParams {\n+pub struct EncodeParams<'self> {\n     diag: @span_handler,\n     tcx: ty::ctxt,\n     reachable: reachable::map,\n     reexports2: middle::resolve::ExportMap2,\n-    item_symbols: @mut HashMap<ast::node_id, ~str>,\n-    discrim_symbols: @mut HashMap<ast::node_id, @~str>,\n-    link_meta: LinkMeta,\n+    item_symbols: &'self HashMap<ast::node_id, ~str>,\n+    discrim_symbols: &'self HashMap<ast::node_id, @str>,\n+    link_meta: &'self LinkMeta,\n     cstore: @mut cstore::CStore,\n-    encode_inlined_item: encode_inlined_item\n+    encode_inlined_item: encode_inlined_item<'self>\n }\n \n struct Stats {\n@@ -75,46 +83,46 @@ struct Stats {\n     n_inlines: uint\n }\n \n-pub struct EncodeContext {\n+pub struct EncodeContext<'self> {\n     diag: @span_handler,\n     tcx: ty::ctxt,\n     stats: @mut Stats,\n     reachable: reachable::map,\n     reexports2: middle::resolve::ExportMap2,\n-    item_symbols: @mut HashMap<ast::node_id, ~str>,\n-    discrim_symbols: @mut HashMap<ast::node_id, @~str>,\n-    link_meta: LinkMeta,\n-    cstore: @mut cstore::CStore,\n-    encode_inlined_item: encode_inlined_item,\n+    item_symbols: &'self HashMap<ast::node_id, ~str>,\n+    discrim_symbols: &'self HashMap<ast::node_id, @str>,\n+    link_meta: &'self LinkMeta,\n+    cstore: &'self cstore::CStore,\n+    encode_inlined_item: encode_inlined_item<'self>,\n     type_abbrevs: abbrev_map\n }\n \n-pub fn reachable(ecx: @EncodeContext, id: node_id) -> bool {\n+pub fn reachable(ecx: &EncodeContext, id: node_id) -> bool {\n     ecx.reachable.contains(&id)\n }\n \n-fn encode_name(ecx: @EncodeContext,\n+fn encode_name(ecx: &EncodeContext,\n                ebml_w: &mut writer::Encoder,\n                name: ident) {\n-    ebml_w.wr_tagged_str(tag_paths_data_name, *ecx.tcx.sess.str_of(name));\n+    ebml_w.wr_tagged_str(tag_paths_data_name, ecx.tcx.sess.str_of(name));\n }\n \n-fn encode_impl_type_basename(ecx: @EncodeContext,\n+fn encode_impl_type_basename(ecx: &EncodeContext,\n                              ebml_w: &mut writer::Encoder,\n                              name: ident) {\n     ebml_w.wr_tagged_str(tag_item_impl_type_basename,\n-                         *ecx.tcx.sess.str_of(name));\n+                         ecx.tcx.sess.str_of(name));\n }\n \n pub fn encode_def_id(ebml_w: &mut writer::Encoder, id: def_id) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n-fn encode_region_param(ecx: @EncodeContext,\n+fn encode_region_param(ecx: &EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n                        it: @ast::item) {\n     let opt_rp = ecx.tcx.region_paramd_items.find(&it.id);\n-    for opt_rp.each |rp| {\n+    for opt_rp.iter().advance |rp| {\n         ebml_w.start_tag(tag_region_param);\n         rp.encode(ebml_w);\n         ebml_w.end_tag();\n@@ -126,8 +134,7 @@ struct entry<T> {\n     pos: uint\n }\n \n-fn add_to_index(ecx: @EncodeContext,\n-                ebml_w: &mut writer::Encoder,\n+fn add_to_index(ebml_w: &mut writer::Encoder,\n                 path: &[ident],\n                 index: &mut ~[entry<~str>],\n                 name: ident) {\n@@ -136,21 +143,21 @@ fn add_to_index(ecx: @EncodeContext,\n     full_path.push(name);\n     index.push(\n         entry {\n-            val: ast_util::path_name_i(full_path,\n-                                       ecx.tcx.sess.parse_sess.interner),\n+            val: ast_util::path_name_i(full_path),\n             pos: ebml_w.writer.tell()\n         });\n }\n \n fn encode_trait_ref(ebml_w: &mut writer::Encoder,\n-                    ecx: @EncodeContext,\n+                    ecx: &EncodeContext,\n                     trait_ref: &ty::TraitRef,\n                     tag: uint) {\n+    let r = ecx.reachable;\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| reachable(ecx, a),\n+        reachable: |a| r.contains(&a),\n         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n \n     ebml_w.start_tag(tag);\n@@ -170,14 +177,15 @@ pub fn def_to_str(did: def_id) -> ~str {\n }\n \n fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n-                             ecx: @EncodeContext,\n+                             ecx: &EncodeContext,\n                              params: @~[ty::TypeParameterDef],\n                              tag: uint) {\n+    let r = ecx.reachable;\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| reachable(ecx, a),\n+        reachable: |a| r.contains(&a),\n         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     for params.each |param| {\n         ebml_w.start_tag(tag);\n@@ -187,7 +195,7 @@ fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n }\n \n fn encode_type_param_bounds(ebml_w: &mut writer::Encoder,\n-                            ecx: @EncodeContext,\n+                            ecx: &EncodeContext,\n                             params: &OptVec<TyParam>) {\n     let ty_param_defs =\n         @params.map_to_vec(|param| ecx.tcx.ty_param_defs.get_copy(&param.id));\n@@ -197,76 +205,80 @@ fn encode_type_param_bounds(ebml_w: &mut writer::Encoder,\n \n fn encode_variant_id(ebml_w: &mut writer::Encoder, vid: def_id) {\n     ebml_w.start_tag(tag_items_data_item_variant);\n-    ebml_w.writer.write(str::to_bytes(def_to_str(vid)));\n+    let s = def_to_str(vid);\n+    ebml_w.writer.write(s.as_bytes());\n     ebml_w.end_tag();\n }\n \n-pub fn write_type(ecx: @EncodeContext,\n+pub fn write_type(ecx: &EncodeContext,\n                   ebml_w: &mut writer::Encoder,\n                   typ: ty::t) {\n+    let r = ecx.reachable;\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| reachable(ecx, a),\n+        reachable: |a| r.contains(&a),\n         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n-pub fn write_vstore(ecx: @EncodeContext,\n+pub fn write_vstore(ecx: &EncodeContext,\n                     ebml_w: &mut writer::Encoder,\n                     vstore: ty::vstore) {\n+    let r = ecx.reachable;\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| reachable(ecx, a),\n+        reachable: |a| r.contains(&a),\n         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n }\n \n-fn encode_type(ecx: @EncodeContext,\n+fn encode_type(ecx: &EncodeContext,\n                ebml_w: &mut writer::Encoder,\n                typ: ty::t) {\n     ebml_w.start_tag(tag_items_data_item_type);\n     write_type(ecx, ebml_w, typ);\n     ebml_w.end_tag();\n }\n \n-fn encode_transformed_self_ty(ecx: @EncodeContext,\n+fn encode_transformed_self_ty(ecx: &EncodeContext,\n                               ebml_w: &mut writer::Encoder,\n                               opt_typ: Option<ty::t>) {\n-    for opt_typ.each |&typ| {\n+    for opt_typ.iter().advance |&typ| {\n         ebml_w.start_tag(tag_item_method_transformed_self_ty);\n         write_type(ecx, ebml_w, typ);\n         ebml_w.end_tag();\n     }\n }\n \n-fn encode_method_fty(ecx: @EncodeContext,\n+fn encode_method_fty(ecx: &EncodeContext,\n                      ebml_w: &mut writer::Encoder,\n                      typ: &ty::BareFnTy) {\n     ebml_w.start_tag(tag_item_method_fty);\n \n+    let r = ecx.reachable;\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| reachable(ecx, a),\n+        reachable: |a| r.contains(&a),\n         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     tyencode::enc_bare_fn_ty(ebml_w.writer, ty_str_ctxt, typ);\n \n     ebml_w.end_tag();\n }\n \n-fn encode_symbol(ecx: @EncodeContext,\n+fn encode_symbol(ecx: &EncodeContext,\n                  ebml_w: &mut writer::Encoder,\n                  id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     match ecx.item_symbols.find(&id) {\n         Some(x) => {\n             debug!(\"encode_symbol(id=%?, str=%s)\", id, *x);\n-            ebml_w.writer.write(str::to_bytes(*x));\n+            ebml_w.writer.write(x.as_bytes());\n         }\n         None => {\n             ecx.diag.handler().bug(\n@@ -276,29 +288,31 @@ fn encode_symbol(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_discriminant(ecx: @EncodeContext,\n+fn encode_discriminant(ecx: &EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n                        id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n-    ebml_w.writer.write(str::to_bytes(*ecx.discrim_symbols.get_copy(&id)));\n+    ebml_w.writer.write(ecx.discrim_symbols.get_copy(&id).as_bytes());\n     ebml_w.end_tag();\n }\n \n-fn encode_disr_val(_: @EncodeContext,\n+fn encode_disr_val(_: &EncodeContext,\n                    ebml_w: &mut writer::Encoder,\n                    disr_val: int) {\n     ebml_w.start_tag(tag_disr_val);\n-    ebml_w.writer.write(str::to_bytes(int::to_str(disr_val)));\n+    let s = int::to_str(disr_val);\n+    ebml_w.writer.write(s.as_bytes());\n     ebml_w.end_tag();\n }\n \n fn encode_parent_item(ebml_w: &mut writer::Encoder, id: def_id) {\n     ebml_w.start_tag(tag_items_data_parent_item);\n-    ebml_w.writer.write(str::to_bytes(def_to_str(id)));\n+    let s = def_to_str(id);\n+    ebml_w.writer.write(s.as_bytes());\n     ebml_w.end_tag();\n }\n \n-fn encode_enum_variant_info(ecx: @EncodeContext,\n+fn encode_enum_variant_info(ecx: &EncodeContext,\n                             ebml_w: &mut writer::Encoder,\n                             id: node_id,\n                             variants: &[variant],\n@@ -342,19 +356,19 @@ fn encode_enum_variant_info(ecx: @EncodeContext,\n     }\n }\n \n-fn encode_path(ecx: @EncodeContext,\n+fn encode_path(ecx: &EncodeContext,\n                ebml_w: &mut writer::Encoder,\n                path: &[ast_map::path_elt],\n                name: ast_map::path_elt) {\n-    fn encode_path_elt(ecx: @EncodeContext,\n+    fn encode_path_elt(ecx: &EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n                        elt: ast_map::path_elt) {\n         let (tag, name) = match elt {\n           ast_map::path_mod(name) => (tag_path_elt_mod, name),\n           ast_map::path_name(name) => (tag_path_elt_name, name)\n         };\n \n-        ebml_w.wr_tagged_str(tag, *ecx.tcx.sess.str_of(name));\n+        ebml_w.wr_tagged_str(tag, ecx.tcx.sess.str_of(name));\n     }\n \n     ebml_w.start_tag(tag_path);\n@@ -366,60 +380,100 @@ fn encode_path(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_reexported_static_method(ecx: @EncodeContext,\n+fn encode_reexported_static_method(ecx: &EncodeContext,\n                                    ebml_w: &mut writer::Encoder,\n                                    exp: &middle::resolve::Export2,\n-                                   m: @ty::Method) {\n-    debug!(\"(encode static trait method) reexport '%s::%s'\",\n-            *exp.name, *ecx.tcx.sess.str_of(m.ident));\n+                                   method_def_id: def_id,\n+                                   method_ident: ident) {\n+    debug!(\"(encode reexported static method) %s::%s\",\n+            exp.name, ecx.tcx.sess.str_of(method_ident));\n     ebml_w.start_tag(tag_items_data_item_reexport);\n     ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n-    ebml_w.wr_str(def_to_str(m.def_id));\n+    ebml_w.wr_str(def_to_str(method_def_id));\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_items_data_item_reexport_name);\n-    ebml_w.wr_str(*exp.name + \"::\" + *ecx.tcx.sess.str_of(m.ident));\n+    ebml_w.wr_str(fmt!(\"%s::%s\", exp.name, ecx.tcx.sess.str_of(method_ident)));\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }\n \n-fn encode_reexported_static_methods(ecx: @EncodeContext,\n+fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n+                                         ebml_w: &mut writer::Encoder,\n+                                         exp: &middle::resolve::Export2)\n+                                         -> bool {\n+    match ecx.tcx.base_impls.find(&exp.def_id) {\n+        Some(implementations) => {\n+            for implementations.each |&base_impl| {\n+                for base_impl.methods.each |&m| {\n+                    if m.explicit_self == ast::sty_static {\n+                        encode_reexported_static_method(ecx, ebml_w, exp,\n+                                                        m.did, m.ident);\n+                    }\n+                }\n+            }\n+\n+            true\n+        }\n+        None => { false }\n+    }\n+}\n+\n+fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n+                                          ebml_w: &mut writer::Encoder,\n+                                          exp: &middle::resolve::Export2)\n+                                          -> bool {\n+    match ecx.tcx.trait_methods_cache.find(&exp.def_id) {\n+        Some(methods) => {\n+            for methods.each |&m| {\n+                if m.explicit_self == ast::sty_static {\n+                    encode_reexported_static_method(ecx, ebml_w, exp,\n+                                                    m.def_id, m.ident);\n+                }\n+            }\n+\n+            true\n+        }\n+        None => { false }\n+    }\n+}\n+\n+fn encode_reexported_static_methods(ecx: &EncodeContext,\n                                     ebml_w: &mut writer::Encoder,\n                                     mod_path: &[ast_map::path_elt],\n                                     exp: &middle::resolve::Export2) {\n-    match ecx.tcx.trait_methods_cache.find(&exp.def_id) {\n-        Some(methods) => {\n-            match ecx.tcx.items.find(&exp.def_id.node) {\n-                Some(&ast_map::node_item(item, path)) => {\n-                    let original_name = ecx.tcx.sess.str_of(item.ident);\n-\n-                    //\n-                    // We don't need to reexport static methods on traits\n-                    // declared in the same module as our `pub use ...` since\n-                    // that's done when we encode the trait item.\n-                    //\n-                    // The only exception is when the reexport *changes* the\n-                    // name e.g. `pub use Foo = self::Bar` -- we have\n-                    // encoded metadata for static methods relative to Bar,\n-                    // but not yet for Foo.\n-                    //\n-                    if mod_path != *path || *exp.name != *original_name {\n-                        for methods.each |&m| {\n-                            if m.explicit_self == ast::sty_static {\n-                                encode_reexported_static_method(ecx,\n-                                                                ebml_w,\n-                                                                exp, m);\n-                            }\n-                        }\n+    match ecx.tcx.items.find(&exp.def_id.node) {\n+        Some(&ast_map::node_item(item, path)) => {\n+            let original_name = ecx.tcx.sess.str_of(item.ident);\n+\n+            //\n+            // We don't need to reexport static methods on items\n+            // declared in the same module as our `pub use ...` since\n+            // that's done when we encode the item itself.\n+            //\n+            // The only exception is when the reexport *changes* the\n+            // name e.g. `pub use Foo = self::Bar` -- we have\n+            // encoded metadata for static methods relative to Bar,\n+            // but not yet for Foo.\n+            //\n+            if mod_path != *path || exp.name != original_name {\n+                if !encode_reexported_static_base_methods(ecx, ebml_w, exp) {\n+                    if encode_reexported_static_trait_methods(ecx, ebml_w, exp) {\n+                        debug!(fmt!(\"(encode reexported static methods) %s \\\n+                                    [trait]\",\n+                                    original_name));\n                     }\n                 }\n-                _ => {}\n+                else {\n+                    debug!(fmt!(\"(encode reexported static methods) %s [base]\",\n+                                original_name));\n+                }\n             }\n         }\n         _ => {}\n     }\n }\n \n-fn encode_info_for_mod(ecx: @EncodeContext,\n+fn encode_info_for_mod(ecx: &EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n                        md: &_mod,\n                        id: node_id,\n@@ -438,10 +492,9 @@ fn encode_info_for_mod(ecx: @EncodeContext,\n                 let (ident, did) = (item.ident, item.id);\n                 debug!(\"(encoding info for module) ... encoding impl %s \\\n                         (%?/%?)\",\n-                        *ecx.tcx.sess.str_of(ident),\n+                        ecx.tcx.sess.str_of(ident),\n                         did,\n-                        ast_map::node_id_to_str(ecx.tcx.items, did, ecx.tcx\n-                                                .sess.parse_sess.interner));\n+                        ast_map::node_id_to_str(ecx.tcx.items, did, token::get_ident_interner()));\n \n                 ebml_w.start_tag(tag_mod_impl);\n                 ebml_w.wr_str(def_to_str(local_def(did)));\n@@ -460,13 +513,13 @@ fn encode_info_for_mod(ecx: @EncodeContext,\n             debug!(\"(encoding info for module) found reexports for %d\", id);\n             for exports.each |exp| {\n                 debug!(\"(encoding info for module) reexport '%s' for %d\",\n-                       *exp.name, id);\n+                       exp.name, id);\n                 ebml_w.start_tag(tag_items_data_item_reexport);\n                 ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n                 ebml_w.wr_str(def_to_str(exp.def_id));\n                 ebml_w.end_tag();\n                 ebml_w.start_tag(tag_items_data_item_reexport_name);\n-                ebml_w.wr_str(*exp.name);\n+                ebml_w.wr_str(exp.name);\n                 ebml_w.end_tag();\n                 ebml_w.end_tag();\n                 encode_reexported_static_methods(ecx, ebml_w, path, exp);\n@@ -552,7 +605,7 @@ fn encode_method_sort(ebml_w: &mut writer::Encoder, sort: char) {\n }\n \n /* Returns an index of items in this class */\n-fn encode_info_for_struct(ecx: @EncodeContext,\n+fn encode_info_for_struct(ecx: &EncodeContext,\n                           ebml_w: &mut writer::Encoder,\n                           path: &[ast_map::path_elt],\n                           fields: &[@struct_field],\n@@ -575,7 +628,7 @@ fn encode_info_for_struct(ecx: @EncodeContext,\n         global_index.push(entry {val: id, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n         debug!(\"encode_info_for_struct: doing %s %d\",\n-               *tcx.sess.str_of(nm), id);\n+               tcx.sess.str_of(nm), id);\n         encode_struct_field_family(ebml_w, vis);\n         encode_name(ecx, ebml_w, nm);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(nm));\n@@ -587,7 +640,7 @@ fn encode_info_for_struct(ecx: @EncodeContext,\n }\n \n // This is for encoding info for ctors and dtors\n-fn encode_info_for_ctor(ecx: @EncodeContext,\n+fn encode_info_for_ctor(ecx: &EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         id: node_id,\n                         ident: ident,\n@@ -601,7 +654,7 @@ fn encode_info_for_ctor(ecx: @EncodeContext,\n         encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         let its_ty = node_id_to_type(ecx.tcx, id);\n         debug!(\"fn name = %s ty = %s its node id = %d\",\n-               *ecx.tcx.sess.str_of(ident),\n+               ecx.tcx.sess.str_of(ident),\n                ty_to_str(ecx.tcx, its_ty), id);\n         encode_type(ecx, ebml_w, its_ty);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(ident));\n@@ -616,7 +669,7 @@ fn encode_info_for_ctor(ecx: @EncodeContext,\n         ebml_w.end_tag();\n }\n \n-fn encode_info_for_struct_ctor(ecx: @EncodeContext,\n+fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                ebml_w: &mut writer::Encoder,\n                                path: &[ast_map::path_elt],\n                                name: ast::ident,\n@@ -638,7 +691,7 @@ fn encode_info_for_struct_ctor(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_method_ty_fields(ecx: @EncodeContext,\n+fn encode_method_ty_fields(ecx: &EncodeContext,\n                            ebml_w: &mut writer::Encoder,\n                            method_ty: &ty::Method) {\n     encode_def_id(ebml_w, method_ty.def_id);\n@@ -652,7 +705,7 @@ fn encode_method_ty_fields(ecx: @EncodeContext,\n     encode_explicit_self(ebml_w, method_ty.explicit_self);\n }\n \n-fn encode_info_for_method(ecx: @EncodeContext,\n+fn encode_info_for_method(ecx: &EncodeContext,\n                           ebml_w: &mut writer::Encoder,\n                           impl_path: &[ast_map::path_elt],\n                           should_inline: bool,\n@@ -661,7 +714,7 @@ fn encode_info_for_method(ecx: @EncodeContext,\n                           owner_generics: &ast::Generics,\n                           method_generics: &ast::Generics) {\n     debug!(\"encode_info_for_method: %d %s %u %u\", m.id,\n-           *ecx.tcx.sess.str_of(m.ident),\n+           ecx.tcx.sess.str_of(m.ident),\n            owner_generics.ty_params.len(),\n            method_generics.ty_params.len());\n     ebml_w.start_tag(tag_items_data_item);\n@@ -723,7 +776,7 @@ fn should_inline(attrs: &[attribute]) -> bool {\n     }\n }\n \n-fn encode_info_for_item(ecx: @EncodeContext,\n+fn encode_info_for_item(ecx: &EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         item: @item,\n                         index: @mut ~[entry<int>],\n@@ -910,10 +963,11 @@ fn encode_info_for_item(ecx: @EncodeContext,\n         for methods.each |m| {\n             ebml_w.start_tag(tag_item_impl_method);\n             let method_def_id = local_def(m.id);\n-            ebml_w.writer.write(str::to_bytes(def_to_str(method_def_id)));\n+            let s = def_to_str(method_def_id);\n+            ebml_w.writer.write(s.as_bytes());\n             ebml_w.end_tag();\n         }\n-        for opt_trait.each |ast_trait_ref| {\n+        for opt_trait.iter().advance |ast_trait_ref| {\n             let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n             encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_trait_ref);\n         }\n@@ -1010,7 +1064,7 @@ fn encode_info_for_item(ecx: @EncodeContext,\n                         tcx.sess.span_unimpl(\n                             item.span,\n                             fmt!(\"Method %s is both provided and static\",\n-                                 *tcx.sess.intr().get(method_ty.ident)));\n+                                 token::ident_to_str(&method_ty.ident)));\n                     }\n                     encode_type_param_bounds(ebml_w, ecx,\n                                              &m.generics.ty_params);\n@@ -1028,7 +1082,7 @@ fn encode_info_for_item(ecx: @EncodeContext,\n     }\n }\n \n-fn encode_info_for_foreign_item(ecx: @EncodeContext,\n+fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 ebml_w: &mut writer::Encoder,\n                                 nitem: @foreign_item,\n                                 index: @mut ~[entry<int>],\n@@ -1062,7 +1116,7 @@ fn encode_info_for_foreign_item(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_info_for_items(ecx: @EncodeContext,\n+fn encode_info_for_items(ecx: &EncodeContext,\n                          ebml_w: &mut writer::Encoder,\n                          crate: &crate)\n                          -> ~[entry<int>] {\n@@ -1072,15 +1126,22 @@ fn encode_info_for_items(ecx: @EncodeContext,\n     encode_info_for_mod(ecx, ebml_w, &crate.node.module,\n                         crate_node_id, [],\n                         syntax::parse::token::special_idents::invalid);\n-    visit::visit_crate(crate, (), visit::mk_vt(@visit::Visitor {\n-        visit_expr: |_e, _cx, _v| { },\n+    let items = ecx.tcx.items;\n+\n+    // See comment in `encode_side_tables_for_ii` in astencode\n+    let ecx_ptr : *() = unsafe { cast::transmute(ecx) };\n+\n+    visit::visit_crate(crate, ((), visit::mk_vt(@visit::Visitor {\n+        visit_expr: |_e, (_cx, _v)| { },\n         visit_item: {\n             let ebml_w = copy *ebml_w;\n-            |i, cx, v| {\n-                visit::visit_item(i, cx, v);\n-                match ecx.tcx.items.get_copy(&i.id) {\n+            |i, (cx, v)| {\n+                visit::visit_item(i, (cx, v));\n+                match items.get_copy(&i.id) {\n                     ast_map::node_item(_, pt) => {\n                         let mut ebml_w = copy ebml_w;\n+                        // See above\n+                        let ecx : &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n                         encode_info_for_item(ecx, &mut ebml_w, i, index, *pt);\n                     }\n                     _ => fail!(\"bad item\")\n@@ -1089,11 +1150,13 @@ fn encode_info_for_items(ecx: @EncodeContext,\n         },\n         visit_foreign_item: {\n             let ebml_w = copy *ebml_w;\n-            |ni, cx, v| {\n-                visit::visit_foreign_item(ni, cx, v);\n-                match ecx.tcx.items.get_copy(&ni.id) {\n+            |ni, (cx, v)| {\n+                visit::visit_foreign_item(ni, (cx, v));\n+                match items.get_copy(&ni.id) {\n                     ast_map::node_foreign_item(_, abi, _, pt) => {\n                         let mut ebml_w = copy ebml_w;\n+                        // See above\n+                        let ecx : &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n                         encode_info_for_foreign_item(ecx,\n                                                      &mut ebml_w,\n                                                      ni,\n@@ -1107,7 +1170,7 @@ fn encode_info_for_items(ecx: @EncodeContext,\n             }\n         },\n         ..*visit::default_visitor()\n-    }));\n+    })));\n     ebml_w.end_tag();\n     return /*bad*/copy *index;\n }\n@@ -1174,7 +1237,7 @@ fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @meta_item) {\n       meta_word(name) => {\n         ebml_w.start_tag(tag_meta_item_word);\n         ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(str::to_bytes(*name));\n+        ebml_w.writer.write(name.as_bytes());\n         ebml_w.end_tag();\n         ebml_w.end_tag();\n       }\n@@ -1183,10 +1246,10 @@ fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @meta_item) {\n           lit_str(value) => {\n             ebml_w.start_tag(tag_meta_item_name_value);\n             ebml_w.start_tag(tag_meta_item_name);\n-            ebml_w.writer.write(str::to_bytes(*name));\n+            ebml_w.writer.write(name.as_bytes());\n             ebml_w.end_tag();\n             ebml_w.start_tag(tag_meta_item_value);\n-            ebml_w.writer.write(str::to_bytes(*value));\n+            ebml_w.writer.write(value.as_bytes());\n             ebml_w.end_tag();\n             ebml_w.end_tag();\n           }\n@@ -1196,7 +1259,7 @@ fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @meta_item) {\n       meta_list(name, ref items) => {\n         ebml_w.start_tag(tag_meta_item_list);\n         ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(str::to_bytes(*name));\n+        ebml_w.writer.write(name.as_bytes());\n         ebml_w.end_tag();\n         for items.each |inner_item| {\n             encode_meta_item(ebml_w, *inner_item);\n@@ -1220,21 +1283,21 @@ fn encode_attributes(ebml_w: &mut writer::Encoder, attrs: &[attribute]) {\n // metadata that Rust cares about for linking crates. This attribute requires\n // 'name' and 'vers' items, so if the user didn't provide them we will throw\n // them in anyway with default values.\n-fn synthesize_crate_attrs(ecx: @EncodeContext,\n+fn synthesize_crate_attrs(ecx: &EncodeContext,\n                           crate: &crate) -> ~[attribute] {\n \n-    fn synthesize_link_attr(ecx: @EncodeContext, items: ~[@meta_item]) ->\n+    fn synthesize_link_attr(ecx: &EncodeContext, items: ~[@meta_item]) ->\n        attribute {\n \n         assert!(!ecx.link_meta.name.is_empty());\n         assert!(!ecx.link_meta.vers.is_empty());\n \n         let name_item =\n-            attr::mk_name_value_item_str(@~\"name\",\n-                                         @ecx.link_meta.name.to_owned());\n+            attr::mk_name_value_item_str(@\"name\",\n+                                         ecx.link_meta.name);\n         let vers_item =\n-            attr::mk_name_value_item_str(@~\"vers\",\n-                                         @ecx.link_meta.vers.to_owned());\n+            attr::mk_name_value_item_str(@\"vers\",\n+                                         ecx.link_meta.vers);\n \n         let other_items =\n             {\n@@ -1243,7 +1306,7 @@ fn synthesize_crate_attrs(ecx: @EncodeContext,\n             };\n \n         let meta_items = vec::append(~[name_item, vers_item], other_items);\n-        let link_item = attr::mk_list_item(@~\"link\", meta_items);\n+        let link_item = attr::mk_list_item(@\"link\", meta_items);\n \n         return attr::mk_attr(link_item);\n     }\n@@ -1252,15 +1315,15 @@ fn synthesize_crate_attrs(ecx: @EncodeContext,\n     let mut found_link_attr = false;\n     for crate.node.attrs.each |attr| {\n         attrs.push(\n-            if *attr::get_attr_name(attr) != ~\"link\" {\n-                /*bad*/copy *attr\n+            if \"link\" != attr::get_attr_name(attr)  {\n+                copy *attr\n             } else {\n                 match attr.node.value.node {\n                   meta_list(_, ref l) => {\n                     found_link_attr = true;;\n                     synthesize_link_attr(ecx, /*bad*/copy *l)\n                   }\n-                  _ => /*bad*/copy *attr\n+                  _ => copy *attr\n                 }\n             });\n     }\n@@ -1270,18 +1333,18 @@ fn synthesize_crate_attrs(ecx: @EncodeContext,\n     return attrs;\n }\n \n-fn encode_crate_deps(ecx: @EncodeContext,\n+fn encode_crate_deps(ecx: &EncodeContext,\n                      ebml_w: &mut writer::Encoder,\n-                     cstore: @mut cstore::CStore) {\n-    fn get_ordered_deps(ecx: @EncodeContext, cstore: @mut cstore::CStore)\n+                     cstore: &cstore::CStore) {\n+    fn get_ordered_deps(ecx: &EncodeContext, cstore: &cstore::CStore)\n                      -> ~[decoder::crate_dep] {\n         type numdep = decoder::crate_dep;\n \n         // Pull the cnums and name,vers,hash out of cstore\n         let mut deps = ~[];\n         do cstore::iter_crate_data(cstore) |key, val| {\n             let dep = decoder::crate_dep {cnum: key,\n-                       name: ecx.tcx.sess.ident_of(/*bad*/ copy *val.name),\n+                       name: ecx.tcx.sess.ident_of(val.name),\n                        vers: decoder::get_crate_vers(val.data),\n                        hash: decoder::get_crate_hash(val.data)};\n             deps.push(dep);\n@@ -1312,7 +1375,7 @@ fn encode_crate_deps(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_lang_items(ecx: @EncodeContext, ebml_w: &mut writer::Encoder) {\n+fn encode_lang_items(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_lang_items);\n \n     for ecx.tcx.lang_items.each_item |def_id, i| {\n@@ -1336,7 +1399,7 @@ fn encode_lang_items(ecx: @EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.end_tag();   // tag_lang_items\n }\n \n-fn encode_link_args(ecx: @EncodeContext, ebml_w: &mut writer::Encoder) {\n+fn encode_link_args(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_link_args);\n \n     let link_args = cstore::get_used_link_args(ecx.cstore);\n@@ -1349,25 +1412,26 @@ fn encode_link_args(ecx: @EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.end_tag();\n }\n \n-fn encode_crate_dep(ecx: @EncodeContext,\n+fn encode_crate_dep(ecx: &EncodeContext,\n                     ebml_w: &mut writer::Encoder,\n                     dep: decoder::crate_dep) {\n     ebml_w.start_tag(tag_crate_dep);\n     ebml_w.start_tag(tag_crate_dep_name);\n-    ebml_w.writer.write(str::to_bytes(*ecx.tcx.sess.str_of(dep.name)));\n+    let s = ecx.tcx.sess.str_of(dep.name);\n+    ebml_w.writer.write(s.as_bytes());\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_crate_dep_vers);\n-    ebml_w.writer.write(str::to_bytes(*dep.vers));\n+    ebml_w.writer.write(dep.vers.as_bytes());\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_crate_dep_hash);\n-    ebml_w.writer.write(str::to_bytes(*dep.hash));\n+    ebml_w.writer.write(dep.hash.as_bytes());\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }\n \n fn encode_hash(ebml_w: &mut writer::Encoder, hash: &str) {\n     ebml_w.start_tag(tag_crate_hash);\n-    ebml_w.writer.write(str::to_bytes(hash));\n+    ebml_w.writer.write(hash.as_bytes());\n     ebml_w.end_tag();\n }\n \n@@ -1380,7 +1444,7 @@ pub static metadata_encoding_version : &'static [u8] =\n       0, 0, 0, 1 ];\n \n pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n-    let wr = @io::BytesWriter();\n+    let wr = @io::BytesWriter::new();\n     let stats = Stats {\n         inline_bytes: 0,\n         attr_bytes: 0,\n@@ -1396,47 +1460,49 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n     let EncodeParams{item_symbols, diag, tcx, reachable, reexports2,\n                      discrim_symbols, cstore, encode_inlined_item,\n                      link_meta, _} = parms;\n-    let ecx = @EncodeContext {\n+    let type_abbrevs = @mut HashMap::new();\n+    let stats = @mut stats;\n+    let ecx = EncodeContext {\n         diag: diag,\n         tcx: tcx,\n-        stats: @mut stats,\n+        stats: stats,\n         reachable: reachable,\n         reexports2: reexports2,\n         item_symbols: item_symbols,\n         discrim_symbols: discrim_symbols,\n         link_meta: link_meta,\n         cstore: cstore,\n         encode_inlined_item: encode_inlined_item,\n-        type_abbrevs: @mut HashMap::new()\n+        type_abbrevs: type_abbrevs\n      };\n \n     let mut ebml_w = writer::Encoder(wr as @io::Writer);\n \n     encode_hash(&mut ebml_w, ecx.link_meta.extras_hash);\n \n     let mut i = *wr.pos;\n-    let crate_attrs = synthesize_crate_attrs(ecx, crate);\n+    let crate_attrs = synthesize_crate_attrs(&ecx, crate);\n     encode_attributes(&mut ebml_w, crate_attrs);\n     ecx.stats.attr_bytes = *wr.pos - i;\n \n     i = *wr.pos;\n-    encode_crate_deps(ecx, &mut ebml_w, ecx.cstore);\n+    encode_crate_deps(&ecx, &mut ebml_w, ecx.cstore);\n     ecx.stats.dep_bytes = *wr.pos - i;\n \n     // Encode the language items.\n     i = *wr.pos;\n-    encode_lang_items(ecx, &mut ebml_w);\n+    encode_lang_items(&ecx, &mut ebml_w);\n     ecx.stats.lang_item_bytes = *wr.pos - i;\n \n     // Encode the link args.\n     i = *wr.pos;\n-    encode_link_args(ecx, &mut ebml_w);\n+    encode_link_args(&ecx, &mut ebml_w);\n     ecx.stats.link_args_bytes = *wr.pos - i;\n \n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);\n     i = *wr.pos;\n-    let items_index = encode_info_for_items(ecx, &mut ebml_w, crate);\n+    let items_index = encode_info_for_items(&ecx, &mut ebml_w, crate);\n     ecx.stats.item_bytes = *wr.pos - i;\n \n     i = *wr.pos;"}, {"sha": "6314cb6269768d666117bfc7d9a9b8d21edf1f2b", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -10,6 +10,11 @@\n \n use core::prelude::*;\n \n+use core::option;\n+use core::os;\n+use core::result;\n+use core::str;\n+\n // A module for searching for libraries\n // FIXME (#2658): I'm not happy how this module turned out. Should\n // probably just be folded into cstore.\n@@ -30,17 +35,18 @@ pub trait FileSearch {\n \n pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n                      target_triple: &str,\n-                     addl_lib_search_paths: ~[Path])\n+                     addl_lib_search_paths: @mut ~[Path])\n                   -> @FileSearch {\n     struct FileSearchImpl {\n         sysroot: @Path,\n-        addl_lib_search_paths: ~[Path],\n+        addl_lib_search_paths: @mut ~[Path],\n         target_triple: ~str\n     }\n     impl FileSearch for FileSearchImpl {\n         fn sysroot(&self) -> @Path { self.sysroot }\n         fn for_each_lib_search_path(&self, f: &fn(&Path) -> bool) -> bool {\n-            debug!(\"filesearch: searching additional lib search paths\");\n+            debug!(\"filesearch: searching additional lib search paths [%?]\",\n+                   self.addl_lib_search_paths.len());\n             // a little weird\n             self.addl_lib_search_paths.each(f);\n \n@@ -180,7 +186,7 @@ fn get_rustpkg_lib_path_nearest() -> Result<Path, ~str> {\n // On Unix should be \"lib\", on windows \"bin\"\n pub fn libdir() -> ~str {\n    let libdir = env!(\"CFG_LIBDIR\");\n-   if str::is_empty(libdir) {\n+   if libdir.is_empty() {\n       fail!(\"rustc compiled without CFG_LIBDIR environment variable\");\n    }\n    libdir.to_owned()"}, {"sha": "5d9355053de949e210bab1788fcd82571603587a", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -19,12 +19,20 @@ use metadata::filesearch::FileSearch;\n use metadata::filesearch;\n use syntax::codemap::span;\n use syntax::diagnostic::span_handler;\n+use syntax::parse::token;\n use syntax::parse::token::ident_interner;\n use syntax::print::pprust;\n use syntax::{ast, attr};\n \n-use extra::flate;\n+use core::cast;\n+use core::io;\n+use core::option;\n use core::os::consts::{macos, freebsd, linux, android, win32};\n+use core::ptr;\n+use core::str;\n+use core::uint;\n+use core::vec;\n+use extra::flate;\n \n pub enum os {\n     os_macos,\n@@ -40,7 +48,7 @@ pub struct Context {\n     span: span,\n     ident: ast::ident,\n     metas: ~[@ast::meta_item],\n-    hash: @~str,\n+    hash: @str,\n     os: os,\n     is_static: bool,\n     intr: @ident_interner\n@@ -52,7 +60,7 @@ pub fn load_library_crate(cx: &Context) -> (~str, @~[u8]) {\n       None => {\n         cx.diag.span_fatal(\n             cx.span, fmt!(\"can't find crate for `%s`\",\n-                          *cx.intr.get(cx.ident)));\n+                          token::ident_to_str(&cx.ident)));\n       }\n     }\n }\n@@ -81,7 +89,7 @@ fn find_library_crate_aux(\n     filesearch: @filesearch::FileSearch\n ) -> Option<(~str, @~[u8])> {\n     let crate_name = crate_name_from_metas(cx.metas);\n-    let prefix: ~str = prefix + *crate_name + \"-\";\n+    let prefix: ~str = prefix + crate_name + \"-\";\n     let suffix: ~str = /*bad*/copy suffix;\n \n     let mut matches = ~[];\n@@ -120,7 +128,7 @@ fn find_library_crate_aux(\n         Some(/*bad*/copy matches[0])\n     } else {\n         cx.diag.span_err(\n-            cx.span, fmt!(\"multiple matching crates for `%s`\", *crate_name));\n+            cx.span, fmt!(\"multiple matching crates for `%s`\", crate_name));\n         cx.diag.handler().note(\"candidates:\");\n         for matches.each |&(ident, data)| {\n             cx.diag.handler().note(fmt!(\"path: %s\", ident));\n@@ -132,7 +140,7 @@ fn find_library_crate_aux(\n     }\n }\n \n-pub fn crate_name_from_metas(metas: &[@ast::meta_item]) -> @~str {\n+pub fn crate_name_from_metas(metas: &[@ast::meta_item]) -> @str {\n     let name_items = attr::find_meta_items_by_name(metas, \"name\");\n     match name_items.last_opt() {\n         Some(i) => {\n@@ -158,7 +166,7 @@ pub fn note_linkage_attrs(intr: @ident_interner,\n \n fn crate_matches(crate_data: @~[u8],\n                  metas: &[@ast::meta_item],\n-                 hash: @~str) -> bool {\n+                 hash: @str) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n     let linkage_metas = attr::find_linkage_metas(attrs);\n     if !hash.is_empty() {\n@@ -204,7 +212,7 @@ fn get_metadata_section(os: os,\n                 let mut found = None;\n                 unsafe {\n                     let cvbuf: *u8 = cast::transmute(cbuf);\n-                    let vlen = vec::len(encoder::metadata_encoding_version);\n+                    let vlen = encoder::metadata_encoding_version.len();\n                     debug!(\"checking %u bytes of metadata-version stamp\",\n                            vlen);\n                     let minsz = uint::min(vlen, csz);\n@@ -261,8 +269,7 @@ pub fn list_file_metadata(intr: @ident_interner,\n     match get_metadata_section(os, path) {\n       option::Some(bytes) => decoder::list_crate_metadata(intr, bytes, out),\n       option::None => {\n-        out.write_str(~\"could not find metadata in \"\n-                      + path.to_str() + \".\\n\");\n+        out.write_str(fmt!(\"could not find metadata in %s.\\n\", path.to_str()))\n       }\n     }\n }"}, {"sha": "cf2a92b291f2883641dfc92e92f3a063f0a5715e", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 56, "deletions": 53, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -18,6 +18,9 @@ use core::prelude::*;\n \n use middle::ty;\n \n+use core::str;\n+use core::uint;\n+use core::vec;\n use syntax::abi::AbiSet;\n use syntax::abi;\n use syntax::ast;\n@@ -52,24 +55,24 @@ pub enum DefIdSource {\n type conv_did<'self> =\n     &'self fn(source: DefIdSource, ast::def_id) -> ast::def_id;\n \n-pub struct PState {\n-    data: @~[u8],\n+pub struct PState<'self> {\n+    data: &'self [u8],\n     crate: int,\n     pos: uint,\n     tcx: ty::ctxt\n }\n \n-fn peek(st: @mut PState) -> char {\n+fn peek(st: &PState) -> char {\n     st.data[st.pos] as char\n }\n \n-fn next(st: @mut PState) -> char {\n+fn next(st: &mut PState) -> char {\n     let ch = st.data[st.pos] as char;\n     st.pos = st.pos + 1u;\n     return ch;\n }\n \n-fn next_byte(st: @mut PState) -> u8 {\n+fn next_byte(st: &mut PState) -> u8 {\n     let b = st.data[st.pos];\n     st.pos = st.pos + 1u;\n     return b;\n@@ -89,46 +92,46 @@ fn scan<R>(st: &mut PState, is_last: &fn(char) -> bool,\n     return op(st.data.slice(start_pos, end_pos));\n }\n \n-pub fn parse_ident(st: @mut PState, last: char) -> ast::ident {\n+pub fn parse_ident(st: &mut PState, last: char) -> ast::ident {\n     fn is_last(b: char, c: char) -> bool { return c == b; }\n     return parse_ident_(st, |a| is_last(last, a) );\n }\n \n-fn parse_ident_(st: @mut PState, is_last: @fn(char) -> bool) ->\n+fn parse_ident_(st: &mut PState, is_last: @fn(char) -> bool) ->\n    ast::ident {\n     let rslt = scan(st, is_last, str::from_bytes);\n     return st.tcx.sess.ident_of(rslt);\n }\n \n-pub fn parse_state_from_data(data: @~[u8], crate_num: int,\n-                             pos: uint, tcx: ty::ctxt) -> @mut PState {\n-    @mut PState {\n+pub fn parse_state_from_data<'a>(data: &'a [u8], crate_num: int,\n+                             pos: uint, tcx: ty::ctxt) -> PState<'a> {\n+    PState {\n         data: data,\n         crate: crate_num,\n         pos: pos,\n         tcx: tcx\n     }\n }\n \n-pub fn parse_ty_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n+pub fn parse_ty_data(data: &[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n                      conv: conv_did) -> ty::t {\n-    let st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_ty(st, conv)\n+    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n+    parse_ty(&mut st, conv)\n }\n \n-pub fn parse_bare_fn_ty_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n+pub fn parse_bare_fn_ty_data(data: &[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n                              conv: conv_did) -> ty::BareFnTy {\n-    let st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_bare_fn_ty(st, conv)\n+    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n+    parse_bare_fn_ty(&mut st, conv)\n }\n \n-pub fn parse_trait_ref_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n+pub fn parse_trait_ref_data(data: &[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n                             conv: conv_did) -> ty::TraitRef {\n-    let st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_trait_ref(st, conv)\n+    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n+    parse_trait_ref(&mut st, conv)\n }\n \n-fn parse_path(st: @mut PState) -> @ast::Path {\n+fn parse_path(st: &mut PState) -> @ast::Path {\n     let mut idents: ~[ast::ident] = ~[];\n     fn is_last(c: char) -> bool { return c == '(' || c == ':'; }\n     idents.push(parse_ident_(st, is_last));\n@@ -148,7 +151,7 @@ fn parse_path(st: @mut PState) -> @ast::Path {\n     };\n }\n \n-fn parse_sigil(st: @mut PState) -> ast::Sigil {\n+fn parse_sigil(st: &mut PState) -> ast::Sigil {\n     match next(st) {\n         '@' => ast::ManagedSigil,\n         '~' => ast::OwnedSigil,\n@@ -157,7 +160,7 @@ fn parse_sigil(st: @mut PState) -> ast::Sigil {\n     }\n }\n \n-fn parse_vstore(st: @mut PState) -> ty::vstore {\n+fn parse_vstore(st: &mut PState) -> ty::vstore {\n     assert_eq!(next(st), '/');\n \n     let c = peek(st);\n@@ -175,7 +178,7 @@ fn parse_vstore(st: @mut PState) -> ty::vstore {\n     }\n }\n \n-fn parse_trait_store(st: @mut PState) -> ty::TraitStore {\n+fn parse_trait_store(st: &mut PState) -> ty::TraitStore {\n     match next(st) {\n         '~' => ty::UniqTraitStore,\n         '@' => ty::BoxTraitStore,\n@@ -184,10 +187,10 @@ fn parse_trait_store(st: @mut PState) -> ty::TraitStore {\n     }\n }\n \n-fn parse_substs(st: @mut PState, conv: conv_did) -> ty::substs {\n-    let self_r = parse_opt(st, || parse_region(st) );\n+fn parse_substs(st: &mut PState, conv: conv_did) -> ty::substs {\n+    let self_r = parse_opt(st, |st| parse_region(st) );\n \n-    let self_ty = parse_opt(st, || parse_ty(st, conv) );\n+    let self_ty = parse_opt(st, |st| parse_ty(st, conv) );\n \n     assert_eq!(next(st), '[');\n     let mut params: ~[ty::t] = ~[];\n@@ -201,7 +204,7 @@ fn parse_substs(st: @mut PState, conv: conv_did) -> ty::substs {\n     };\n }\n \n-fn parse_bound_region(st: @mut PState) -> ty::bound_region {\n+fn parse_bound_region(st: &mut PState) -> ty::bound_region {\n     match next(st) {\n       's' => ty::br_self,\n       'a' => {\n@@ -219,7 +222,7 @@ fn parse_bound_region(st: @mut PState) -> ty::bound_region {\n     }\n }\n \n-fn parse_region(st: @mut PState) -> ty::Region {\n+fn parse_region(st: &mut PState) -> ty::Region {\n     match next(st) {\n       'b' => {\n         ty::re_bound(parse_bound_region(st))\n@@ -248,15 +251,15 @@ fn parse_region(st: @mut PState) -> ty::Region {\n     }\n }\n \n-fn parse_opt<T>(st: @mut PState, f: &fn() -> T) -> Option<T> {\n+fn parse_opt<T>(st: &mut PState, f: &fn(&mut PState) -> T) -> Option<T> {\n     match next(st) {\n       'n' => None,\n-      's' => Some(f()),\n+      's' => Some(f(st)),\n       _ => fail!(\"parse_opt: bad input\")\n     }\n }\n \n-fn parse_str(st: @mut PState, term: char) -> ~str {\n+fn parse_str(st: &mut PState, term: char) -> ~str {\n     let mut result = ~\"\";\n     while peek(st) != term {\n         result += str::from_byte(next_byte(st));\n@@ -265,13 +268,13 @@ fn parse_str(st: @mut PState, term: char) -> ~str {\n     return result;\n }\n \n-fn parse_trait_ref(st: @mut PState, conv: conv_did) -> ty::TraitRef {\n+fn parse_trait_ref(st: &mut PState, conv: conv_did) -> ty::TraitRef {\n     let def = parse_def(st, NominalType, conv);\n     let substs = parse_substs(st, conv);\n     ty::TraitRef {def_id: def, substs: substs}\n }\n \n-fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n+fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n     match next(st) {\n       'n' => return ty::mk_nil(),\n       'z' => return ty::mk_bot(),\n@@ -367,8 +370,8 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n         match st.tcx.rcache.find(&key) {\n           Some(&tt) => return tt,\n           None => {\n-            let ps = @mut PState {pos: pos ,.. copy *st};\n-            let tt = parse_ty(ps, conv);\n+            let mut ps = PState {pos: pos ,.. copy *st};\n+            let tt = parse_ty(&mut ps, conv);\n             st.tcx.rcache.insert(key, tt);\n             return tt;\n           }\n@@ -391,28 +394,25 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n     }\n }\n \n-fn parse_mutability(st: @mut PState) -> ast::mutability {\n+fn parse_mutability(st: &mut PState) -> ast::mutability {\n     match peek(st) {\n       'm' => { next(st); ast::m_mutbl }\n       '?' => { next(st); ast::m_const }\n       _ => { ast::m_imm }\n     }\n }\n \n-fn parse_mt(st: @mut PState, conv: conv_did) -> ty::mt {\n+fn parse_mt(st: &mut PState, conv: conv_did) -> ty::mt {\n     let m = parse_mutability(st);\n     ty::mt { ty: parse_ty(st, conv), mutbl: m }\n }\n \n-fn parse_def(st: @mut PState, source: DefIdSource,\n+fn parse_def(st: &mut PState, source: DefIdSource,\n              conv: conv_did) -> ast::def_id {\n-    let mut def = ~[];\n-    while peek(st) != '|' { def.push(next_byte(st)); }\n-    st.pos = st.pos + 1u;\n-    return conv(source, parse_def_id(def));\n+    return conv(source, scan(st, |c| { c == '|' }, parse_def_id));\n }\n \n-fn parse_uint(st: @mut PState) -> uint {\n+fn parse_uint(st: &mut PState) -> uint {\n     let mut n = 0;\n     loop {\n         let cur = peek(st);\n@@ -423,7 +423,7 @@ fn parse_uint(st: @mut PState) -> uint {\n     };\n }\n \n-fn parse_hex(st: @mut PState) -> uint {\n+fn parse_hex(st: &mut PState) -> uint {\n     let mut n = 0u;\n     loop {\n         let cur = peek(st);\n@@ -446,7 +446,7 @@ fn parse_purity(c: char) -> purity {\n     }\n }\n \n-fn parse_abi_set(st: @mut PState) -> AbiSet {\n+fn parse_abi_set(st: &mut PState) -> AbiSet {\n     assert_eq!(next(st), '[');\n     let mut abis = AbiSet::empty();\n     while peek(st) != ']' {\n@@ -467,7 +467,7 @@ fn parse_onceness(c: char) -> ast::Onceness {\n     }\n }\n \n-fn parse_closure_ty(st: @mut PState, conv: conv_did) -> ty::ClosureTy {\n+fn parse_closure_ty(st: &mut PState, conv: conv_did) -> ty::ClosureTy {\n     let sigil = parse_sigil(st);\n     let purity = parse_purity(next(st));\n     let onceness = parse_onceness(next(st));\n@@ -484,7 +484,7 @@ fn parse_closure_ty(st: @mut PState, conv: conv_did) -> ty::ClosureTy {\n     }\n }\n \n-fn parse_bare_fn_ty(st: @mut PState, conv: conv_did) -> ty::BareFnTy {\n+fn parse_bare_fn_ty(st: &mut PState, conv: conv_did) -> ty::BareFnTy {\n     let purity = parse_purity(next(st));\n     let abi = parse_abi_set(st);\n     let sig = parse_sig(st, conv);\n@@ -495,7 +495,7 @@ fn parse_bare_fn_ty(st: @mut PState, conv: conv_did) -> ty::BareFnTy {\n     }\n }\n \n-fn parse_sig(st: @mut PState, conv: conv_did) -> ty::FnSig {\n+fn parse_sig(st: &mut PState, conv: conv_did) -> ty::FnSig {\n     assert_eq!(next(st), '[');\n     let mut inputs = ~[];\n     while peek(st) != ']' {\n@@ -534,20 +534,20 @@ pub fn parse_def_id(buf: &[u8]) -> ast::def_id {\n     ast::def_id { crate: crate_num, node: def_num }\n }\n \n-pub fn parse_type_param_def_data(data: @~[u8], start: uint,\n+pub fn parse_type_param_def_data(data: &[u8], start: uint,\n                                  crate_num: int, tcx: ty::ctxt,\n                                  conv: conv_did) -> ty::TypeParameterDef\n {\n-    let st = parse_state_from_data(data, crate_num, start, tcx);\n-    parse_type_param_def(st, conv)\n+    let mut st = parse_state_from_data(data, crate_num, start, tcx);\n+    parse_type_param_def(&mut st, conv)\n }\n \n-fn parse_type_param_def(st: @mut PState, conv: conv_did) -> ty::TypeParameterDef {\n+fn parse_type_param_def(st: &mut PState, conv: conv_did) -> ty::TypeParameterDef {\n     ty::TypeParameterDef {def_id: parse_def(st, NominalType, conv),\n                           bounds: @parse_bounds(st, conv)}\n }\n \n-fn parse_bounds(st: @mut PState, conv: conv_did) -> ty::ParamBounds {\n+fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n     let mut param_bounds = ty::ParamBounds {\n         builtin_bounds: ty::EmptyBuiltinBounds(),\n         trait_bounds: ~[]\n@@ -566,6 +566,9 @@ fn parse_bounds(st: @mut PState, conv: conv_did) -> ty::ParamBounds {\n             'O' => {\n                 param_bounds.builtin_bounds.add(ty::BoundStatic);\n             }\n+            'Z' => {\n+                param_bounds.builtin_bounds.add(ty::BoundSized);\n+            }\n             'I' => {\n                 param_bounds.trait_bounds.push(@parse_trait_ref(st, conv));\n             }"}, {"sha": "d9377afa9a5277f043a7294bfa5c5a06f5035f3a", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -41,7 +41,7 @@ pub struct ctxt {\n pub struct ty_abbrev {\n     pos: uint,\n     len: uint,\n-    s: @~str\n+    s: @str\n }\n \n pub enum abbrev_ctxt {\n@@ -60,20 +60,20 @@ pub fn enc_ty(w: @io::Writer, cx: @ctxt, t: ty::t) {\n     match cx.abbrevs {\n       ac_no_abbrevs => {\n         let result_str = match cx.tcx.short_names_cache.find(&t) {\n-            Some(&s) => /*bad*/copy *s,\n+            Some(&s) => s,\n             None => {\n                 let s = do io::with_str_writer |wr| {\n                     enc_sty(wr, cx, /*bad*/copy ty::get(t).sty);\n-                };\n-                cx.tcx.short_names_cache.insert(t, @copy s);\n+                }.to_managed();\n+                cx.tcx.short_names_cache.insert(t, s);\n                 s\n           }\n         };\n         w.write_str(result_str);\n       }\n       ac_use_abbrevs(abbrevs) => {\n           match abbrevs.find(&t) {\n-              Some(a) => { w.write_str(*a.s); return; }\n+              Some(a) => { w.write_str(a.s); return; }\n               None => {}\n           }\n           let pos = w.tell();\n@@ -89,9 +89,8 @@ pub fn enc_ty(w: @io::Writer, cx: @ctxt, t: ty::t) {\n           let abbrev_len = 3u + estimate_sz(pos) + estimate_sz(len);\n           if abbrev_len < len {\n               // I.e. it's actually an abbreviation.\n-              let s = ~\"#\" + uint::to_str_radix(pos, 16u) + \":\" +\n-                  uint::to_str_radix(len, 16u) + \"#\";\n-              let a = ty_abbrev { pos: pos, len: len, s: @s };\n+              let s = fmt!(\"#%x:%x#\", pos, len).to_managed();\n+              let a = ty_abbrev { pos: pos, len: len, s: s };\n               abbrevs.insert(t, a);\n           }\n           return;\n@@ -172,7 +171,7 @@ fn enc_bound_region(w: @io::Writer, cx: @ctxt, br: ty::bound_region) {\n       }\n       ty::br_named(s) => {\n         w.write_char('[');\n-        w.write_str(*cx.tcx.sess.str_of(s));\n+        w.write_str(cx.tcx.sess.str_of(s));\n         w.write_char(']')\n       }\n       ty::br_cap_avoid(id, br) => {\n@@ -404,6 +403,7 @@ fn enc_bounds(w: @io::Writer, cx: @ctxt, bs: &ty::ParamBounds) {\n             ty::BoundCopy => w.write_char('C'),\n             ty::BoundConst => w.write_char('K'),\n             ty::BoundStatic => w.write_char('O'),\n+            ty::BoundSized => w.write_char('Z'),\n         }\n     }\n "}, {"sha": "e11367a7a7da606911e4a91f3b8d27ad6efa63b0", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 135, "deletions": 92, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -25,6 +25,8 @@ use middle::{ty, typeck, moves};\n use middle;\n use util::ppaux::ty_to_str;\n \n+use core::at_vec;\n+use core::uint;\n use extra::ebml::reader;\n use extra::ebml;\n use extra::serialize;\n@@ -38,9 +40,12 @@ use syntax::codemap::span;\n use syntax::codemap;\n use syntax::fold::*;\n use syntax::fold;\n+use syntax::parse::token;\n use syntax;\n use writer = extra::ebml::writer;\n \n+use core::cast;\n+\n #[cfg(test)] use syntax::parse;\n #[cfg(test)] use syntax::print::pprust;\n \n@@ -77,14 +82,14 @@ trait tr_intern {\n // ______________________________________________________________________\n // Top-level methods.\n \n-pub fn encode_inlined_item(ecx: @e::EncodeContext,\n+pub fn encode_inlined_item(ecx: &e::EncodeContext,\n                            ebml_w: &mut writer::Encoder,\n                            path: &[ast_map::path_elt],\n                            ii: ast::inlined_item,\n                            maps: Maps) {\n     debug!(\"> Encoding inlined item: %s::%s (%u)\",\n-           ast_map::path_to_str(path, ecx.tcx.sess.parse_sess.interner),\n-           *ecx.tcx.sess.str_of(ii.ident()),\n+           ast_map::path_to_str(path, token::get_ident_interner()),\n+           ecx.tcx.sess.str_of(ii.ident()),\n            ebml_w.writer.tell());\n \n     let id_range = ast_util::compute_id_range_for_inlined_item(&ii);\n@@ -96,8 +101,8 @@ pub fn encode_inlined_item(ecx: @e::EncodeContext,\n     ebml_w.end_tag();\n \n     debug!(\"< Encoded inlined fn: %s::%s (%u)\",\n-           ast_map::path_to_str(path, ecx.tcx.sess.parse_sess.interner),\n-           *ecx.tcx.sess.str_of(ii.ident()),\n+           ast_map::path_to_str(path, token::get_ident_interner()),\n+           ecx.tcx.sess.str_of(ii.ident()),\n            ebml_w.writer.tell());\n }\n \n@@ -116,7 +121,7 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n       None => None,\n       Some(ast_doc) => {\n         debug!(\"> Decoding inlined fn: %s::?\",\n-               ast_map::path_to_str(path, tcx.sess.parse_sess.interner));\n+               ast_map::path_to_str(path, token::get_ident_interner()));\n         let mut ast_dsr = reader::Decoder(ast_doc);\n         let from_id_range = Decodable::decode(&mut ast_dsr);\n         let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n@@ -127,10 +132,10 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n         };\n         let raw_ii = decode_ast(ast_doc);\n         let ii = renumber_ast(xcx, raw_ii);\n-        debug!(\"Fn named: %s\", *tcx.sess.str_of(ii.ident()));\n+        debug!(\"Fn named: %s\", tcx.sess.str_of(ii.ident()));\n         debug!(\"< Decoded inlined fn: %s::%s\",\n-               ast_map::path_to_str(path, tcx.sess.parse_sess.interner),\n-               *tcx.sess.str_of(ii.ident()));\n+               ast_map::path_to_str(path, token::get_ident_interner()),\n+               tcx.sess.str_of(ii.ident()));\n         ast_map::map_decoded_item(tcx.sess.diagnostic(),\n                                   dcx.tcx.items, path, &ii);\n         decode_side_tables(xcx, ast_doc);\n@@ -160,8 +165,8 @@ fn reserve_id_range(sess: Session,\n     ast_util::id_range { min: to_id_min, max: to_id_min }\n }\n \n-pub impl ExtendedDecodeContext {\n-    fn tr_id(&self, id: ast::node_id) -> ast::node_id {\n+impl ExtendedDecodeContext {\n+    pub fn tr_id(&self, id: ast::node_id) -> ast::node_id {\n         /*!\n          * Translates an internal id, meaning a node id that is known\n          * to refer to some part of the item currently being inlined,\n@@ -176,7 +181,7 @@ pub impl ExtendedDecodeContext {\n         assert!(!self.from_id_range.empty());\n         (id - self.from_id_range.min + self.to_id_range.min)\n     }\n-    fn tr_def_id(&self, did: ast::def_id) -> ast::def_id {\n+    pub fn tr_def_id(&self, did: ast::def_id) -> ast::def_id {\n         /*!\n          * Translates an EXTERNAL def-id, converting the crate number\n          * from the one used in the encoded data to the current crate\n@@ -200,7 +205,7 @@ pub impl ExtendedDecodeContext {\n \n         decoder::translate_def_id(self.dcx.cdata, did)\n     }\n-    fn tr_intern_def_id(&self, did: ast::def_id) -> ast::def_id {\n+    pub fn tr_intern_def_id(&self, did: ast::def_id) -> ast::def_id {\n         /*!\n          * Translates an INTERNAL def-id, meaning a def-id that is\n          * known to refer to some part of the item currently being\n@@ -211,7 +216,7 @@ pub impl ExtendedDecodeContext {\n         assert_eq!(did.crate, ast::local_crate);\n         ast::def_id { crate: ast::local_crate, node: self.tr_id(did.node) }\n     }\n-    fn tr_span(&self, _span: span) -> span {\n+    pub fn tr_span(&self, _span: span) -> span {\n         codemap::dummy_sp() // FIXME (#1972): handle span properly\n     }\n }\n@@ -524,7 +529,7 @@ trait read_method_map_entry_helper {\n                              -> method_map_entry;\n }\n \n-fn encode_method_map_entry(ecx: @e::EncodeContext,\n+fn encode_method_map_entry(ecx: &e::EncodeContext,\n                            ebml_w: &mut writer::Encoder,\n                            mme: method_map_entry) {\n     do ebml_w.emit_struct(\"method_map_entry\", 3) |ebml_w| {\n@@ -601,7 +606,7 @@ impl tr for method_origin {\n // ______________________________________________________________________\n // Encoding and decoding vtable_res\n \n-fn encode_vtable_res(ecx: @e::EncodeContext,\n+fn encode_vtable_res(ecx: &e::EncodeContext,\n                      ebml_w: &mut writer::Encoder,\n                      dr: typeck::vtable_res) {\n     // can't autogenerate this code because automatic code of\n@@ -613,7 +618,7 @@ fn encode_vtable_res(ecx: @e::EncodeContext,\n     }\n }\n \n-fn encode_vtable_origin(ecx: @e::EncodeContext,\n+fn encode_vtable_origin(ecx: &e::EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         vtable_origin: &typeck::vtable_origin) {\n     do ebml_w.emit_enum(\"vtable_origin\") |ebml_w| {\n@@ -699,53 +704,53 @@ impl vtable_decoder_helpers for reader::Decoder {\n // Encoding and decoding the side tables\n \n trait get_ty_str_ctxt {\n-    fn ty_str_ctxt(@self) -> @tyencode::ctxt;\n+    fn ty_str_ctxt(&self) -> @tyencode::ctxt;\n }\n \n-impl get_ty_str_ctxt for e::EncodeContext {\n-    // IMPLICIT SELF WARNING: fix this!\n-    fn ty_str_ctxt(@self) -> @tyencode::ctxt {\n+impl<'self> get_ty_str_ctxt for e::EncodeContext<'self> {\n+    fn ty_str_ctxt(&self) -> @tyencode::ctxt {\n+        let r = self.reachable;\n         @tyencode::ctxt {diag: self.tcx.sess.diagnostic(),\n                         ds: e::def_to_str,\n                         tcx: self.tcx,\n-                        reachable: |a| encoder::reachable(self, a),\n+                        reachable: |a| r.contains(&a),\n                         abbrevs: tyencode::ac_use_abbrevs(self.type_abbrevs)}\n     }\n }\n \n trait ebml_writer_helpers {\n-    fn emit_ty(&mut self, ecx: @e::EncodeContext, ty: ty::t);\n-    fn emit_vstore(&mut self, ecx: @e::EncodeContext, vstore: ty::vstore);\n-    fn emit_tys(&mut self, ecx: @e::EncodeContext, tys: &[ty::t]);\n+    fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: ty::t);\n+    fn emit_vstore(&mut self, ecx: &e::EncodeContext, vstore: ty::vstore);\n+    fn emit_tys(&mut self, ecx: &e::EncodeContext, tys: &[ty::t]);\n     fn emit_type_param_def(&mut self,\n-                           ecx: @e::EncodeContext,\n+                           ecx: &e::EncodeContext,\n                            type_param_def: &ty::TypeParameterDef);\n     fn emit_tpbt(&mut self,\n-                 ecx: @e::EncodeContext,\n+                 ecx: &e::EncodeContext,\n                  tpbt: ty::ty_param_bounds_and_ty);\n }\n \n impl ebml_writer_helpers for writer::Encoder {\n-    fn emit_ty(&mut self, ecx: @e::EncodeContext, ty: ty::t) {\n+    fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: ty::t) {\n         do self.emit_opaque |this| {\n             e::write_type(ecx, this, ty)\n         }\n     }\n \n-    fn emit_vstore(&mut self, ecx: @e::EncodeContext, vstore: ty::vstore) {\n+    fn emit_vstore(&mut self, ecx: &e::EncodeContext, vstore: ty::vstore) {\n         do self.emit_opaque |this| {\n             e::write_vstore(ecx, this, vstore)\n         }\n     }\n \n-    fn emit_tys(&mut self, ecx: @e::EncodeContext, tys: &[ty::t]) {\n+    fn emit_tys(&mut self, ecx: &e::EncodeContext, tys: &[ty::t]) {\n         do self.emit_from_vec(tys) |this, ty| {\n             this.emit_ty(ecx, *ty)\n         }\n     }\n \n     fn emit_type_param_def(&mut self,\n-                           ecx: @e::EncodeContext,\n+                           ecx: &e::EncodeContext,\n                            type_param_def: &ty::TypeParameterDef) {\n         do self.emit_opaque |this| {\n             tyencode::enc_type_param_def(this.writer,\n@@ -755,7 +760,7 @@ impl ebml_writer_helpers for writer::Encoder {\n     }\n \n     fn emit_tpbt(&mut self,\n-                 ecx: @e::EncodeContext,\n+                 ecx: &e::EncodeContext,\n                  tpbt: ty::ty_param_bounds_and_ty) {\n         do self.emit_struct(\"ty_param_bounds_and_ty\", 2) |this| {\n             do this.emit_struct_field(\"generics\", 0) |this| {\n@@ -797,112 +802,147 @@ impl write_tag_and_id for writer::Encoder {\n     }\n }\n \n-fn encode_side_tables_for_ii(ecx: @e::EncodeContext,\n+fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n                              maps: Maps,\n                              ebml_w: &mut writer::Encoder,\n                              ii: &ast::inlined_item) {\n     ebml_w.start_tag(c::tag_table as uint);\n     let new_ebml_w = copy *ebml_w;\n+\n+    // Because the ast visitor uses @fn, I can't pass in\n+    // ecx directly, but /I/ know that it'll be fine since\n+    // the lifetime is tied to the CrateContext that\n+    // lives this entire section.\n+    let ecx_ptr : *() = unsafe { cast::transmute(ecx) };\n     ast_util::visit_ids_for_inlined_item(\n         ii,\n         |id: ast::node_id| {\n             // Note: this will cause a copy of ebml_w, which is bad as\n             // it is mutable. But I believe it's harmless since we generate\n             // balanced EBML.\n             let mut new_ebml_w = copy new_ebml_w;\n+            // See above\n+            let ecx : &e::EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n             encode_side_tables_for_id(ecx, maps, &mut new_ebml_w, id)\n         });\n     ebml_w.end_tag();\n }\n \n-fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n+fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                              maps: Maps,\n                              ebml_w: &mut writer::Encoder,\n                              id: ast::node_id) {\n     let tcx = ecx.tcx;\n \n     debug!(\"Encoding side tables for id %d\", id);\n \n-    for tcx.def_map.find(&id).each |def| {\n-        do ebml_w.tag(c::tag_table_def) |ebml_w| {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                (*def).encode(ebml_w)\n+    {\n+        let r = tcx.def_map.find(&id);\n+        for r.iter().advance |def| {\n+            do ebml_w.tag(c::tag_table_def) |ebml_w| {\n+                ebml_w.id(id);\n+                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                    (*def).encode(ebml_w)\n+                }\n             }\n         }\n     }\n \n-    for tcx.node_types.find(&(id as uint)).each |&ty| {\n-        do ebml_w.tag(c::tag_table_node_type) |ebml_w| {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                ebml_w.emit_ty(ecx, *ty);\n+    {\n+        let r = tcx.node_types.find(&(id as uint));\n+        for r.iter().advance |&ty| {\n+            do ebml_w.tag(c::tag_table_node_type) |ebml_w| {\n+                ebml_w.id(id);\n+                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                    ebml_w.emit_ty(ecx, *ty);\n+                }\n             }\n         }\n     }\n \n-    for tcx.node_type_substs.find(&id).each |tys| {\n-        do ebml_w.tag(c::tag_table_node_type_subst) |ebml_w| {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                ebml_w.emit_tys(ecx, **tys)\n+    {\n+        let r = tcx.node_type_substs.find(&id);\n+        for r.iter().advance |tys| {\n+            do ebml_w.tag(c::tag_table_node_type_subst) |ebml_w| {\n+                ebml_w.id(id);\n+                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                    ebml_w.emit_tys(ecx, **tys)\n+                }\n             }\n         }\n     }\n \n-    for tcx.freevars.find(&id).each |&fv| {\n-        do ebml_w.tag(c::tag_table_freevars) |ebml_w| {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                do ebml_w.emit_from_vec(**fv) |ebml_w, fv_entry| {\n-                    encode_freevar_entry(ebml_w, *fv_entry)\n+    {\n+        let r = tcx.freevars.find(&id);\n+        for r.iter().advance |&fv| {\n+            do ebml_w.tag(c::tag_table_freevars) |ebml_w| {\n+                ebml_w.id(id);\n+                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                    do ebml_w.emit_from_vec(**fv) |ebml_w, fv_entry| {\n+                        encode_freevar_entry(ebml_w, *fv_entry)\n+                    }\n                 }\n             }\n         }\n     }\n \n     let lid = ast::def_id { crate: ast::local_crate, node: id };\n-    for tcx.tcache.find(&lid).each |&tpbt| {\n-        do ebml_w.tag(c::tag_table_tcache) |ebml_w| {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                ebml_w.emit_tpbt(ecx, *tpbt);\n+    {\n+        let r = tcx.tcache.find(&lid);\n+        for r.iter().advance |&tpbt| {\n+            do ebml_w.tag(c::tag_table_tcache) |ebml_w| {\n+                ebml_w.id(id);\n+                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                    ebml_w.emit_tpbt(ecx, *tpbt);\n+                }\n             }\n         }\n     }\n \n-    for tcx.ty_param_defs.find(&id).each |&type_param_def| {\n-        do ebml_w.tag(c::tag_table_param_defs) |ebml_w| {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                ebml_w.emit_type_param_def(ecx, type_param_def)\n+    {\n+        let r = tcx.ty_param_defs.find(&id);\n+        for r.iter().advance |&type_param_def| {\n+            do ebml_w.tag(c::tag_table_param_defs) |ebml_w| {\n+                ebml_w.id(id);\n+                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                    ebml_w.emit_type_param_def(ecx, type_param_def)\n+                }\n             }\n         }\n     }\n \n-    for maps.method_map.find(&id).each |&mme| {\n-        do ebml_w.tag(c::tag_table_method_map) |ebml_w| {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                encode_method_map_entry(ecx, ebml_w, *mme)\n+    {\n+        let r = maps.method_map.find(&id);\n+        for r.iter().advance |&mme| {\n+            do ebml_w.tag(c::tag_table_method_map) |ebml_w| {\n+                ebml_w.id(id);\n+                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                    encode_method_map_entry(ecx, ebml_w, *mme)\n+                }\n             }\n         }\n     }\n \n-    for maps.vtable_map.find(&id).each |&dr| {\n-        do ebml_w.tag(c::tag_table_vtable_map) |ebml_w| {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                encode_vtable_res(ecx, ebml_w, *dr);\n+    {\n+        let r = maps.vtable_map.find(&id);\n+        for r.iter().advance |&dr| {\n+            do ebml_w.tag(c::tag_table_vtable_map) |ebml_w| {\n+                ebml_w.id(id);\n+                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                    encode_vtable_res(ecx, ebml_w, *dr);\n+                }\n             }\n         }\n     }\n \n-    for tcx.adjustments.find(&id).each |adj| {\n-        do ebml_w.tag(c::tag_table_adjustments) |ebml_w| {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                (**adj).encode(ebml_w)\n+    {\n+        let r = tcx.adjustments.find(&id);\n+        for r.iter().advance |adj| {\n+            do ebml_w.tag(c::tag_table_adjustments) |ebml_w| {\n+                ebml_w.id(id);\n+                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                    (**adj).encode(ebml_w)\n+                }\n             }\n         }\n     }\n@@ -913,12 +953,15 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n         }\n     }\n \n-    for maps.capture_map.find(&id).each |&cap_vars| {\n-        do ebml_w.tag(c::tag_table_capture_map) |ebml_w| {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                do ebml_w.emit_from_vec(*cap_vars) |ebml_w, cap_var| {\n-                    cap_var.encode(ebml_w);\n+    {\n+        let r = maps.capture_map.find(&id);\n+        for r.iter().advance |&cap_vars| {\n+            do ebml_w.tag(c::tag_table_capture_map) |ebml_w| {\n+                ebml_w.id(id);\n+                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                    do ebml_w.emit_from_vec(*cap_vars) |ebml_w, cap_var| {\n+                        cap_var.encode(ebml_w);\n+                    }\n                 }\n             }\n         }\n@@ -960,7 +1003,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n \n         return do self.read_opaque |this, doc| {\n             let ty = tydecode::parse_ty_data(\n-                doc.data,\n+                *doc.data,\n                 xcx.dcx.cdata.cnum,\n                 doc.start,\n                 xcx.dcx.tcx,\n@@ -976,7 +1019,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         fn type_string(doc: ebml::Doc) -> ~str {\n             let mut str = ~\"\";\n             for uint::range(doc.start, doc.end) |i| {\n-                str::push_char(&mut str, doc.data[i] as char);\n+                str.push_char(doc.data[i] as char);\n             }\n             str\n         }\n@@ -990,7 +1033,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n                            -> ty::TypeParameterDef {\n         do self.read_opaque |this, doc| {\n             tydecode::parse_type_param_def_data(\n-                doc.data,\n+                *doc.data,\n                 doc.start,\n                 xcx.dcx.cdata.cnum,\n                 xcx.dcx.tcx,\n@@ -1164,7 +1207,7 @@ impl fake_ext_ctxt for fake_session {\n         }\n     }\n     fn ident_of(&self, st: &str) -> ast::ident {\n-        self.interner.intern(st)\n+        token::str_to_ident(st)\n     }\n }\n \n@@ -1233,9 +1276,9 @@ fn test_simplification() {\n     match (item_out, item_exp) {\n       (ast::ii_item(item_out), ast::ii_item(item_exp)) => {\n         assert!(pprust::item_to_str(item_out,\n-                                         ext_cx.parse_sess().interner)\n+                                    token::get_ident_interner())\n                      == pprust::item_to_str(item_exp,\n-                                            ext_cx.parse_sess().interner));\n+                                            token::get_ident_interner()));\n       }\n       _ => fail!()\n     }"}, {"sha": "e384d35373e63cff44e854c442eb8548b737b476", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 83, "deletions": 81, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -19,17 +19,18 @@\n \n use core::prelude::*;\n \n-use middle::moves;\n-use middle::borrowck::*;\n+use core::hashmap::HashSet;\n+use core::uint;\n use mc = middle::mem_categorization;\n+use middle::borrowck::*;\n+use middle::moves;\n use middle::ty;\n-use util::ppaux::Repr;\n-use core::hashmap::HashSet;\n use syntax::ast::{m_mutbl, m_imm, m_const};\n use syntax::ast;\n use syntax::ast_util;\n-use syntax::visit;\n use syntax::codemap::span;\n+use syntax::visit;\n+use util::ppaux::Repr;\n \n struct CheckLoanCtxt<'self> {\n     bccx: @BorrowckCtxt,\n@@ -60,22 +61,22 @@ pub fn check_loans(bccx: @BorrowckCtxt,\n                                            visit_pat: check_loans_in_pat,\n                                            visit_fn: check_loans_in_fn,\n                                            .. *visit::default_visitor()});\n-    (vt.visit_block)(body, clcx, vt);\n+    (vt.visit_block)(body, (clcx, vt));\n }\n \n enum MoveError {\n     MoveOk,\n     MoveWhileBorrowed(/*move*/@LoanPath, /*loan*/@LoanPath, /*loan*/span)\n }\n \n-pub impl<'self> CheckLoanCtxt<'self> {\n-    fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n+impl<'self> CheckLoanCtxt<'self> {\n+    pub fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n-    fn each_issued_loan(&self,\n-                        scope_id: ast::node_id,\n-                        op: &fn(&Loan) -> bool) -> bool\n-    {\n-        //! Iterates over each loan that that has been issued\n+    pub fn each_issued_loan(&self,\n+                            scope_id: ast::node_id,\n+                            op: &fn(&Loan) -> bool)\n+                            -> bool {\n+        //! Iterates over each loan that has been issued\n         //! on entrance to `scope_id`, regardless of whether it is\n         //! actually *in scope* at that point.  Sometimes loans\n         //! are issued for future scopes and thus they may have been\n@@ -90,10 +91,10 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         return true;\n     }\n \n-    fn each_in_scope_loan(&self,\n-                          scope_id: ast::node_id,\n-                          op: &fn(&Loan) -> bool) -> bool\n-    {\n+    pub fn each_in_scope_loan(&self,\n+                              scope_id: ast::node_id,\n+                              op: &fn(&Loan) -> bool)\n+                              -> bool {\n         //! Like `each_issued_loan()`, but only considers loans that are\n         //! currently in scope.\n \n@@ -108,11 +109,11 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         return true;\n     }\n \n-    fn each_in_scope_restriction(&self,\n-                                 scope_id: ast::node_id,\n-                                 loan_path: @LoanPath,\n-                                 op: &fn(&Loan, &Restriction) -> bool) -> bool\n-    {\n+    pub fn each_in_scope_restriction(&self,\n+                                     scope_id: ast::node_id,\n+                                     loan_path: @LoanPath,\n+                                     op: &fn(&Loan, &Restriction) -> bool)\n+                                     -> bool {\n         //! Iterates through all the in-scope restrictions for the\n         //! given `loan_path`\n \n@@ -128,7 +129,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         return true;\n     }\n \n-    fn loans_generated_by(&self, scope_id: ast::node_id) -> ~[uint] {\n+    pub fn loans_generated_by(&self, scope_id: ast::node_id) -> ~[uint] {\n         //! Returns a vector of the loans that are generated as\n         //! we encounter `scope_id`.\n \n@@ -139,7 +140,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         return result;\n     }\n \n-    fn check_for_conflicting_loans(&mut self, scope_id: ast::node_id) {\n+    pub fn check_for_conflicting_loans(&mut self, scope_id: ast::node_id) {\n         //! Checks to see whether any of the loans that are issued\n         //! by `scope_id` conflict with loans that have already been\n         //! issued when we enter `scope_id` (for example, we do not\n@@ -166,9 +167,9 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         }\n     }\n \n-    fn report_error_if_loans_conflict(&self,\n-                                      old_loan: &Loan,\n-                                      new_loan: &Loan) {\n+    pub fn report_error_if_loans_conflict(&self,\n+                                          old_loan: &Loan,\n+                                          new_loan: &Loan) {\n         //! Checks whether `old_loan` and `new_loan` can safely be issued\n         //! simultaneously.\n \n@@ -187,11 +188,12 @@ pub impl<'self> CheckLoanCtxt<'self> {\n             new_loan, old_loan, old_loan, new_loan);\n     }\n \n-    fn report_error_if_loan_conflicts_with_restriction(&self,\n-                                                       loan1: &Loan,\n-                                                       loan2: &Loan,\n-                                                       old_loan: &Loan,\n-                                                       new_loan: &Loan) -> bool {\n+    pub fn report_error_if_loan_conflicts_with_restriction(&self,\n+                                                           loan1: &Loan,\n+                                                           loan2: &Loan,\n+                                                           old_loan: &Loan,\n+                                                           new_loan: &Loan)\n+                                                           -> bool {\n         //! Checks whether the restrictions introduced by `loan1` would\n         //! prohibit `loan2`. Returns false if an error is reported.\n \n@@ -217,7 +219,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         fmt!(\"cannot borrow `%s` as mutable \\\n-                              more than once at at a time\",\n+                              more than once at a time\",\n                              self.bccx.loan_path_to_str(new_loan.loan_path)));\n                     self.bccx.span_note(\n                         old_loan.span,\n@@ -246,18 +248,18 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         true\n     }\n \n-    fn is_local_variable(&self, cmt: mc::cmt) -> bool {\n+    pub fn is_local_variable(&self, cmt: mc::cmt) -> bool {\n         match cmt.cat {\n           mc::cat_local(_) => true,\n           _ => false\n         }\n     }\n \n-    fn check_if_path_is_moved(&self,\n-                              id: ast::node_id,\n-                              span: span,\n-                              use_kind: MovedValueUseKind,\n-                              lp: @LoanPath) {\n+    pub fn check_if_path_is_moved(&self,\n+                                  id: ast::node_id,\n+                                  span: span,\n+                                  use_kind: MovedValueUseKind,\n+                                  lp: @LoanPath) {\n         /*!\n          * Reports an error if `expr` (which should be a path)\n          * is using a moved/uninitialized value\n@@ -276,7 +278,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         }\n     }\n \n-    fn check_assignment(&self, expr: @ast::expr) {\n+    pub fn check_assignment(&self, expr: @ast::expr) {\n         // We don't use cat_expr() here because we don't want to treat\n         // auto-ref'd parameters in overloaded operators as rvalues.\n         let cmt = match self.bccx.tcx.adjustments.find(&expr.id) {\n@@ -532,10 +534,10 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         }\n     }\n \n-    fn report_illegal_mutation(&self,\n-                               expr: @ast::expr,\n-                               loan_path: &LoanPath,\n-                               loan: &Loan) {\n+    pub fn report_illegal_mutation(&self,\n+                                   expr: @ast::expr,\n+                                   loan_path: &LoanPath,\n+                                   loan: &Loan) {\n         self.bccx.span_err(\n             expr.span,\n             fmt!(\"cannot assign to `%s` because it is borrowed\",\n@@ -546,7 +548,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n                  self.bccx.loan_path_to_str(loan_path)));\n     }\n \n-    fn check_move_out_from_expr(&self, ex: @ast::expr) {\n+    pub fn check_move_out_from_expr(&self, ex: @ast::expr) {\n         match ex.node {\n             ast::expr_paren(*) => {\n                 /* In the case of an expr_paren(), the expression inside\n@@ -573,29 +575,29 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         }\n     }\n \n-    fn analyze_move_out_from_cmt(&self, cmt: mc::cmt) -> MoveError {\n+    pub fn analyze_move_out_from_cmt(&self, cmt: mc::cmt) -> MoveError {\n         debug!(\"analyze_move_out_from_cmt(cmt=%s)\", cmt.repr(self.tcx()));\n \n         // FIXME(#4384) inadequare if/when we permit `move a.b`\n \n         // check for a conflicting loan:\n-        for opt_loan_path(cmt).each |&lp| {\n+        let r = opt_loan_path(cmt);\n+        for r.iter().advance |&lp| {\n             for self.each_in_scope_restriction(cmt.id, lp) |loan, _| {\n                 // Any restriction prevents moves.\n                 return MoveWhileBorrowed(lp, loan.loan_path, loan.span);\n             }\n         }\n \n-        return MoveOk;\n+        MoveOk\n     }\n \n-    fn check_call(&mut self,\n-                  _expr: @ast::expr,\n-                  _callee: Option<@ast::expr>,\n-                  _callee_id: ast::node_id,\n-                  _callee_span: span,\n-                  _args: &[@ast::expr])\n-    {\n+    pub fn check_call(&mut self,\n+                      _expr: @ast::expr,\n+                      _callee: Option<@ast::expr>,\n+                      _callee_id: ast::node_id,\n+                      _callee_span: span,\n+                      _args: &[@ast::expr]) {\n         // NB: This call to check for conflicting loans is not truly\n         // necessary, because the callee_id never issues new loans.\n         // However, I added it for consistency and lest the system\n@@ -611,8 +613,8 @@ fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n                          body: &ast::blk,\n                          sp: span,\n                          id: ast::node_id,\n-                         this: @mut CheckLoanCtxt<'a>,\n-                         visitor: visit::vt<@mut CheckLoanCtxt<'a>>) {\n+                         (this, visitor): (@mut CheckLoanCtxt<'a>,\n+                                           visit::vt<@mut CheckLoanCtxt<'a>>)) {\n     match *fk {\n         visit::fk_item_fn(*) |\n         visit::fk_method(*) => {\n@@ -626,7 +628,7 @@ fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n         }\n     }\n \n-    visit::visit_fn(fk, decl, body, sp, id, this, visitor);\n+    visit::visit_fn(fk, decl, body, sp, id, (this, visitor));\n \n     fn check_captured_variables(this: @mut CheckLoanCtxt,\n                                 closure_id: ast::node_id,\n@@ -674,15 +676,15 @@ fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n }\n \n fn check_loans_in_local<'a>(local: @ast::local,\n-                            this: @mut CheckLoanCtxt<'a>,\n-                            vt: visit::vt<@mut CheckLoanCtxt<'a>>) {\n-    visit::visit_local(local, this, vt);\n+                            (this, vt): (@mut CheckLoanCtxt<'a>,\n+                                         visit::vt<@mut CheckLoanCtxt<'a>>)) {\n+    visit::visit_local(local, (this, vt));\n }\n \n fn check_loans_in_expr<'a>(expr: @ast::expr,\n-                           this: @mut CheckLoanCtxt<'a>,\n-                           vt: visit::vt<@mut CheckLoanCtxt<'a>>) {\n-    visit::visit_expr(expr, this, vt);\n+                           (this, vt): (@mut CheckLoanCtxt<'a>,\n+                                        visit::vt<@mut CheckLoanCtxt<'a>>)) {\n+    visit::visit_expr(expr, (this, vt));\n \n     debug!(\"check_loans_in_expr(expr=%s)\",\n            expr.repr(this.tcx()));\n@@ -699,36 +701,36 @@ fn check_loans_in_expr<'a>(expr: @ast::expr,\n           if !this.move_data.is_assignee(expr.id) {\n               let cmt = this.bccx.cat_expr_unadjusted(expr);\n               debug!(\"path cmt=%s\", cmt.repr(this.tcx()));\n-              for opt_loan_path(cmt).each |&lp| {\n-                  this.check_if_path_is_moved(expr.id, expr.span,\n-                                              MovedInUse, lp);\n+              let r = opt_loan_path(cmt);\n+              for r.iter().advance |&lp| {\n+                  this.check_if_path_is_moved(expr.id, expr.span, MovedInUse, lp);\n               }\n           }\n       }\n       ast::expr_assign(dest, _) |\n-      ast::expr_assign_op(_, dest, _) => {\n+      ast::expr_assign_op(_, _, dest, _) => {\n         this.check_assignment(dest);\n       }\n       ast::expr_call(f, ref args, _) => {\n         this.check_call(expr, Some(f), f.id, f.span, *args);\n       }\n-      ast::expr_method_call(_, _, _, ref args, _) => {\n-        this.check_call(expr, None, expr.callee_id, expr.span, *args);\n+      ast::expr_method_call(callee_id, _, _, _, ref args, _) => {\n+        this.check_call(expr, None, callee_id, expr.span, *args);\n       }\n-      ast::expr_index(_, rval) |\n-      ast::expr_binary(_, _, rval)\n+      ast::expr_index(callee_id, _, rval) |\n+      ast::expr_binary(callee_id, _, _, rval)\n       if this.bccx.method_map.contains_key(&expr.id) => {\n         this.check_call(expr,\n                         None,\n-                        expr.callee_id,\n+                        callee_id,\n                         expr.span,\n                         [rval]);\n       }\n-      ast::expr_unary(*) | ast::expr_index(*)\n+      ast::expr_unary(callee_id, _, _) | ast::expr_index(callee_id, _, _)\n       if this.bccx.method_map.contains_key(&expr.id) => {\n         this.check_call(expr,\n                         None,\n-                        expr.callee_id,\n+                        callee_id,\n                         expr.span,\n                         []);\n       }\n@@ -737,8 +739,8 @@ fn check_loans_in_expr<'a>(expr: @ast::expr,\n }\n \n fn check_loans_in_pat<'a>(pat: @ast::pat,\n-                          this: @mut CheckLoanCtxt<'a>,\n-                          vt: visit::vt<@mut CheckLoanCtxt<'a>>)\n+                          (this, vt): (@mut CheckLoanCtxt<'a>,\n+                                       visit::vt<@mut CheckLoanCtxt<'a>>))\n {\n     this.check_for_conflicting_loans(pat.id);\n \n@@ -753,13 +755,13 @@ fn check_loans_in_pat<'a>(pat: @ast::pat,\n     // rewalk the patterns and rebuild the pattern\n     // categorizations.\n \n-    visit::visit_pat(pat, this, vt);\n+    visit::visit_pat(pat, (this, vt));\n }\n \n fn check_loans_in_block<'a>(blk: &ast::blk,\n-                            this: @mut CheckLoanCtxt<'a>,\n-                            vt: visit::vt<@mut CheckLoanCtxt<'a>>)\n+                            (this, vt): (@mut CheckLoanCtxt<'a>,\n+                                         visit::vt<@mut CheckLoanCtxt<'a>>))\n {\n-    visit::visit_block(blk, this, vt);\n+    visit::visit_block(blk, (this, vt));\n     this.check_for_conflicting_loans(blk.node.id);\n }"}, {"sha": "ef911c9a808ecc79b7ce058927669d60c4cc91f1", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -161,4 +161,3 @@ fn check_is_legal_to_move_from(bccx: @BorrowckCtxt,\n         }\n     }\n }\n-"}, {"sha": "02b45995e43cd594c659a80fd999cc5b86d88102", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 75, "deletions": 67, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -40,7 +40,7 @@ mod gather_moves;\n \n /// Context used while gathering loans:\n ///\n-/// - `bccx`: the the borrow check context\n+/// - `bccx`: the borrow check context\n /// - `item_ub`: the id of the block for the enclosing fn/method item\n /// - `root_ub`: the id of the outermost block for which we can root\n ///   an `@T`.  This is the id of the innermost enclosing\n@@ -91,28 +91,28 @@ pub fn gather_loans(bccx: @BorrowckCtxt,\n                                           visit_pat: add_pat_to_id_range,\n                                           visit_local: gather_loans_in_local,\n                                           .. *visit::default_visitor()});\n-    (v.visit_block)(body, glcx, v);\n+    (v.visit_block)(body, (glcx, v));\n     return (glcx.id_range, glcx.all_loans, glcx.move_data);\n }\n \n fn add_pat_to_id_range(p: @ast::pat,\n-                       this: @mut GatherLoanCtxt,\n-                       v: visit::vt<@mut GatherLoanCtxt>) {\n+                       (this, v): (@mut GatherLoanCtxt,\n+                                   visit::vt<@mut GatherLoanCtxt>)) {\n     // NB: This visitor function just adds the pat ids into the id\n     // range. We gather loans that occur in patterns using the\n     // `gather_pat()` method below. Eventually these two should be\n     // brought together.\n     this.id_range.add(p.id);\n-    visit::visit_pat(p, this, v);\n+    visit::visit_pat(p, (this, v));\n }\n \n fn gather_loans_in_fn(fk: &visit::fn_kind,\n                       decl: &ast::fn_decl,\n                       body: &ast::blk,\n                       sp: span,\n                       id: ast::node_id,\n-                      this: @mut GatherLoanCtxt,\n-                      v: visit::vt<@mut GatherLoanCtxt>) {\n+                      (this, v): (@mut GatherLoanCtxt,\n+                                  visit::vt<@mut GatherLoanCtxt>)) {\n     match fk {\n         // Do not visit items here, the outer loop in borrowck/mod\n         // will visit them for us in turn.\n@@ -123,22 +123,22 @@ fn gather_loans_in_fn(fk: &visit::fn_kind,\n         // Visit closures as part of the containing item.\n         &visit::fk_anon(*) | &visit::fk_fn_block(*) => {\n             this.push_repeating_id(body.node.id);\n-            visit::visit_fn(fk, decl, body, sp, id, this, v);\n+            visit::visit_fn(fk, decl, body, sp, id, (this, v));\n             this.pop_repeating_id(body.node.id);\n         }\n     }\n }\n \n fn gather_loans_in_block(blk: &ast::blk,\n-                         this: @mut GatherLoanCtxt,\n-                         vt: visit::vt<@mut GatherLoanCtxt>) {\n+                         (this, vt): (@mut GatherLoanCtxt,\n+                                      visit::vt<@mut GatherLoanCtxt>)) {\n     this.id_range.add(blk.node.id);\n-    visit::visit_block(blk, this, vt);\n+    visit::visit_block(blk, (this, vt));\n }\n \n fn gather_loans_in_local(local: @ast::local,\n-                         this: @mut GatherLoanCtxt,\n-                         vt: visit::vt<@mut GatherLoanCtxt>) {\n+                         (this, vt): (@mut GatherLoanCtxt,\n+                                      visit::vt<@mut GatherLoanCtxt>)) {\n     if local.node.init.is_none() {\n         // Variable declarations without initializers are considered \"moves\":\n         let tcx = this.bccx.tcx;\n@@ -162,24 +162,33 @@ fn gather_loans_in_local(local: @ast::local,\n         }\n     }\n \n-    visit::visit_local(local, this, vt);\n+    visit::visit_local(local, (this, vt));\n }\n \n fn gather_loans_in_expr(ex: @ast::expr,\n-                        this: @mut GatherLoanCtxt,\n-                        vt: visit::vt<@mut GatherLoanCtxt>) {\n+                        (this, vt): (@mut GatherLoanCtxt,\n+                                     visit::vt<@mut GatherLoanCtxt>)) {\n     let bccx = this.bccx;\n     let tcx = bccx.tcx;\n \n     debug!(\"gather_loans_in_expr(expr=%?/%s)\",\n            ex.id, pprust::expr_to_str(ex, tcx.sess.intr()));\n \n     this.id_range.add(ex.id);\n-    this.id_range.add(ex.callee_id);\n+\n+    {\n+        let r = ex.get_callee_id();\n+        for r.iter().advance |callee_id| {\n+            this.id_range.add(*callee_id);\n+        }\n+    }\n \n     // If this expression is borrowed, have to ensure it remains valid:\n-    for tcx.adjustments.find(&ex.id).each |&adjustments| {\n-        this.guarantee_adjustments(ex, *adjustments);\n+    {\n+        let r = tcx.adjustments.find(&ex.id);\n+        for r.iter().advance |&adjustments| {\n+            this.guarantee_adjustments(ex, *adjustments);\n+        }\n     }\n \n     // If this expression is a move, gather it:\n@@ -198,10 +207,10 @@ fn gather_loans_in_expr(ex: @ast::expr,\n         // for the lifetime `scope_r` of the resulting ptr:\n         let scope_r = ty_region(tcx, ex.span, ty::expr_ty(tcx, ex));\n         this.guarantee_valid(ex.id, ex.span, base_cmt, mutbl, scope_r);\n-        visit::visit_expr(ex, this, vt);\n+        visit::visit_expr(ex, (this, vt));\n       }\n \n-      ast::expr_assign(l, _) | ast::expr_assign_op(_, l, _) => {\n+      ast::expr_assign(l, _) | ast::expr_assign_op(_, _, l, _) => {\n           let l_cmt = this.bccx.cat_expr(l);\n           match opt_loan_path(l_cmt) {\n               Some(l_lp) => {\n@@ -215,7 +224,7 @@ fn gather_loans_in_expr(ex: @ast::expr,\n                   // with moves etc, just ignore.\n               }\n           }\n-          visit::visit_expr(ex, this, vt);\n+          visit::visit_expr(ex, (this, vt));\n       }\n \n       ast::expr_match(ex_v, ref arms) => {\n@@ -225,11 +234,11 @@ fn gather_loans_in_expr(ex: @ast::expr,\n                 this.gather_pat(cmt, *pat, arm.body.node.id, ex.id);\n             }\n         }\n-        visit::visit_expr(ex, this, vt);\n+        visit::visit_expr(ex, (this, vt));\n       }\n \n-      ast::expr_index(_, arg) |\n-      ast::expr_binary(_, _, arg)\n+      ast::expr_index(_, _, arg) |\n+      ast::expr_binary(_, _, _, arg)\n       if this.bccx.method_map.contains_key(&ex.id) => {\n           // Arguments in method calls are always passed by ref.\n           //\n@@ -239,55 +248,55 @@ fn gather_loans_in_expr(ex: @ast::expr,\n           let scope_r = ty::re_scope(ex.id);\n           let arg_cmt = this.bccx.cat_expr(arg);\n           this.guarantee_valid(arg.id, arg.span, arg_cmt, m_imm, scope_r);\n-          visit::visit_expr(ex, this, vt);\n+          visit::visit_expr(ex, (this, vt));\n       }\n \n       // see explanation attached to the `root_ub` field:\n       ast::expr_while(cond, ref body) => {\n           // during the condition, can only root for the condition\n           this.push_repeating_id(cond.id);\n-          (vt.visit_expr)(cond, this, vt);\n+          (vt.visit_expr)(cond, (this, vt));\n           this.pop_repeating_id(cond.id);\n \n           // during body, can only root for the body\n           this.push_repeating_id(body.node.id);\n-          (vt.visit_block)(body, this, vt);\n+          (vt.visit_block)(body, (this, vt));\n           this.pop_repeating_id(body.node.id);\n       }\n \n       // see explanation attached to the `root_ub` field:\n       ast::expr_loop(ref body, _) => {\n           this.push_repeating_id(body.node.id);\n-          visit::visit_expr(ex, this, vt);\n+          visit::visit_expr(ex, (this, vt));\n           this.pop_repeating_id(body.node.id);\n       }\n \n       ast::expr_fn_block(*) => {\n           gather_moves::gather_captures(this.bccx, this.move_data, ex);\n-          visit::visit_expr(ex, this, vt);\n+          visit::visit_expr(ex, (this, vt));\n       }\n \n       _ => {\n-        visit::visit_expr(ex, this, vt);\n+        visit::visit_expr(ex, (this, vt));\n       }\n     }\n }\n \n-pub impl GatherLoanCtxt {\n-    fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n+impl GatherLoanCtxt {\n+    pub fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n-    fn push_repeating_id(&mut self, id: ast::node_id) {\n+    pub fn push_repeating_id(&mut self, id: ast::node_id) {\n         self.repeating_ids.push(id);\n     }\n \n-    fn pop_repeating_id(&mut self, id: ast::node_id) {\n+    pub fn pop_repeating_id(&mut self, id: ast::node_id) {\n         let popped = self.repeating_ids.pop();\n         assert_eq!(id, popped);\n     }\n \n-    fn guarantee_adjustments(&mut self,\n-                             expr: @ast::expr,\n-                             adjustment: &ty::AutoAdjustment) {\n+    pub fn guarantee_adjustments(&mut self,\n+                                 expr: @ast::expr,\n+                                 adjustment: &ty::AutoAdjustment) {\n         debug!(\"guarantee_adjustments(expr=%s, adjustment=%?)\",\n                expr.repr(self.tcx()), adjustment);\n         let _i = indenter();\n@@ -350,13 +359,12 @@ pub impl GatherLoanCtxt {\n     // out loans, which will be added to the `req_loan_map`.  This can\n     // also entail \"rooting\" GC'd pointers, which means ensuring\n     // dynamically that they are not freed.\n-    fn guarantee_valid(&mut self,\n-                       borrow_id: ast::node_id,\n-                       borrow_span: span,\n-                       cmt: mc::cmt,\n-                       req_mutbl: ast::mutability,\n-                       loan_region: ty::Region)\n-    {\n+    pub fn guarantee_valid(&mut self,\n+                           borrow_id: ast::node_id,\n+                           borrow_span: span,\n+                           cmt: mc::cmt,\n+                           req_mutbl: ast::mutability,\n+                           loan_region: ty::Region) {\n         debug!(\"guarantee_valid(borrow_id=%?, cmt=%s, \\\n                 req_mutbl=%?, loan_region=%?)\",\n                borrow_id,\n@@ -514,15 +522,16 @@ pub impl GatherLoanCtxt {\n         }\n     }\n \n-    fn restriction_set(&self, req_mutbl: ast::mutability) -> RestrictionSet {\n+    pub fn restriction_set(&self, req_mutbl: ast::mutability)\n+                           -> RestrictionSet {\n         match req_mutbl {\n             m_const => RESTR_EMPTY,\n             m_imm   => RESTR_EMPTY | RESTR_MUTATE | RESTR_CLAIM,\n             m_mutbl => RESTR_EMPTY | RESTR_MUTATE | RESTR_CLAIM | RESTR_FREEZE\n         }\n     }\n \n-    fn mark_loan_path_as_mutated(&self, loan_path: @LoanPath) {\n+    pub fn mark_loan_path_as_mutated(&self, loan_path: @LoanPath) {\n         //! For mutable loans of content whose mutability derives\n         //! from a local variable, mark the mutability decl as necessary.\n \n@@ -540,9 +549,10 @@ pub impl GatherLoanCtxt {\n         }\n     }\n \n-    fn compute_gen_scope(&self,\n-                         borrow_id: ast::node_id,\n-                         loan_scope: ast::node_id) -> ast::node_id {\n+    pub fn compute_gen_scope(&self,\n+                             borrow_id: ast::node_id,\n+                             loan_scope: ast::node_id)\n+                             -> ast::node_id {\n         //! Determine when to introduce the loan. Typically the loan\n         //! is introduced at the point of the borrow, but in some cases,\n         //! notably method arguments, the loan may be introduced only\n@@ -556,9 +566,8 @@ pub impl GatherLoanCtxt {\n         }\n     }\n \n-    fn compute_kill_scope(&self,\n-                          loan_scope: ast::node_id,\n-                          lp: @LoanPath) -> ast::node_id {\n+    pub fn compute_kill_scope(&self, loan_scope: ast::node_id, lp: @LoanPath)\n+                              -> ast::node_id {\n         //! Determine when the loan restrictions go out of scope.\n         //! This is either when the lifetime expires or when the\n         //! local variable which roots the loan-path goes out of scope,\n@@ -588,11 +597,11 @@ pub impl GatherLoanCtxt {\n         }\n     }\n \n-    fn gather_pat(&mut self,\n-                  discr_cmt: mc::cmt,\n-                  root_pat: @ast::pat,\n-                  arm_body_id: ast::node_id,\n-                  match_id: ast::node_id) {\n+    pub fn gather_pat(&mut self,\n+                      discr_cmt: mc::cmt,\n+                      root_pat: @ast::pat,\n+                      arm_body_id: ast::node_id,\n+                      match_id: ast::node_id) {\n         do self.bccx.cat_pattern(discr_cmt, root_pat) |cmt, pat| {\n             match pat.node {\n               ast::pat_ident(bm, _, _) if self.pat_is_binding(pat) => {\n@@ -623,7 +632,7 @@ pub impl GatherLoanCtxt {\n                                              cmt, mutbl, scope_r);\n                     }\n                   }\n-                  ast::bind_by_copy | ast::bind_infer => {\n+                  ast::bind_infer => {\n                       // No borrows here, but there may be moves\n                       if self.bccx.is_move(pat.id) {\n                           gather_moves::gather_move_from_pat(\n@@ -653,9 +662,8 @@ pub impl GatherLoanCtxt {\n         }\n     }\n \n-    fn vec_slice_info(&self,\n-                      pat: @ast::pat,\n-                      slice_ty: ty::t) -> (ast::mutability, ty::Region) {\n+    pub fn vec_slice_info(&self, pat: @ast::pat, slice_ty: ty::t)\n+                          -> (ast::mutability, ty::Region) {\n         /*!\n          *\n          * In a pattern like [a, b, ..c], normally `c` has slice type,\n@@ -681,25 +689,25 @@ pub impl GatherLoanCtxt {\n         }\n     }\n \n-    fn pat_is_variant_or_struct(&self, pat: @ast::pat) -> bool {\n+    pub fn pat_is_variant_or_struct(&self, pat: @ast::pat) -> bool {\n         pat_util::pat_is_variant_or_struct(self.bccx.tcx.def_map, pat)\n     }\n \n-    fn pat_is_binding(&self, pat: @ast::pat) -> bool {\n+    pub fn pat_is_binding(&self, pat: @ast::pat) -> bool {\n         pat_util::pat_is_binding(self.bccx.tcx.def_map, pat)\n     }\n }\n \n // Setting up info that preserve needs.\n // This is just the most convenient place to do it.\n fn add_stmt_to_map(stmt: @ast::stmt,\n-                   this: @mut GatherLoanCtxt,\n-                   vt: visit::vt<@mut GatherLoanCtxt>) {\n+                   (this, vt): (@mut GatherLoanCtxt,\n+                                visit::vt<@mut GatherLoanCtxt>)) {\n     match stmt.node {\n         ast::stmt_expr(_, id) | ast::stmt_semi(_, id) => {\n             this.bccx.stmt_map.insert(id);\n         }\n         _ => ()\n     }\n-    visit::visit_stmt(stmt, this, vt);\n+    visit::visit_stmt(stmt, (this, vt));\n }"}, {"sha": "6bd32f04ce5b9c9ed542ee7dacd42e1b95d45f05", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -12,6 +12,7 @@\n \n use core::prelude::*;\n \n+use core::vec;\n use middle::borrowck::*;\n use mc = middle::mem_categorization;\n use middle::ty;"}, {"sha": "95e26e9e42fa5941708419593d8e2aa4c48ab420", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 76, "deletions": 67, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -23,12 +23,13 @@ use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n use core::hashmap::{HashSet, HashMap};\n use core::io;\n-use core::result::{Result};\n use core::ops::{BitOr, BitAnd};\n+use core::result::{Result};\n use syntax::ast;\n use syntax::ast_map;\n use syntax::visit;\n use syntax::codemap::span;\n+use syntax::parse::token;\n \n macro_rules! if_ok(\n     ($inp: expr) => (\n@@ -80,7 +81,7 @@ pub fn check_crate(\n \n     let v = visit::mk_vt(@visit::Visitor {visit_fn: borrowck_fn,\n                                           ..*visit::default_visitor()});\n-    visit::visit_crate(crate, bccx, v);\n+    visit::visit_crate(crate, (bccx, v));\n \n     if tcx.sess.borrowck_stats() {\n         io::println(\"--- borrowck stats ---\");\n@@ -110,8 +111,8 @@ fn borrowck_fn(fk: &visit::fn_kind,\n                body: &ast::blk,\n                sp: span,\n                id: ast::node_id,\n-               this: @BorrowckCtxt,\n-               v: visit::vt<@BorrowckCtxt>) {\n+               (this, v): (@BorrowckCtxt,\n+                           visit::vt<@BorrowckCtxt>)) {\n     match fk {\n         &visit::fk_anon(*) |\n         &visit::fk_fn_block(*) => {\n@@ -148,7 +149,7 @@ fn borrowck_fn(fk: &visit::fn_kind,\n         }\n     }\n \n-    visit::visit_fn(fk, decl, body, sp, id, this, v);\n+    visit::visit_fn(fk, decl, body, sp, id, (this, v));\n }\n \n // ----------------------------------------------------------------------\n@@ -247,8 +248,8 @@ pub enum LoanPathElem {\n     LpInterior(mc::InteriorKind) // `LV.f` in doc.rs\n }\n \n-pub impl LoanPath {\n-    fn node_id(&self) -> ast::node_id {\n+impl LoanPath {\n+    pub fn node_id(&self) -> ast::node_id {\n         match *self {\n             LpVar(local_id) => local_id,\n             LpExtend(base, _, _) => base.node_id()\n@@ -326,12 +327,12 @@ pub static RESTR_CLAIM: RestrictionSet  = RestrictionSet {bits: 0b0010};\n pub static RESTR_FREEZE: RestrictionSet = RestrictionSet {bits: 0b0100};\n pub static RESTR_ALIAS: RestrictionSet  = RestrictionSet {bits: 0b1000};\n \n-pub impl RestrictionSet {\n-    fn intersects(&self, restr: RestrictionSet) -> bool {\n+impl RestrictionSet {\n+    pub fn intersects(&self, restr: RestrictionSet) -> bool {\n         (self.bits & restr.bits) != 0\n     }\n \n-    fn contains_all(&self, restr: RestrictionSet) -> bool {\n+    pub fn contains_all(&self, restr: RestrictionSet) -> bool {\n         (self.bits & restr.bits) == restr.bits\n     }\n }\n@@ -426,29 +427,33 @@ pub enum MovedValueUseKind {\n ///////////////////////////////////////////////////////////////////////////\n // Misc\n \n-pub impl BorrowckCtxt {\n-    fn is_subregion_of(&self, r_sub: ty::Region, r_sup: ty::Region) -> bool {\n+impl BorrowckCtxt {\n+    pub fn is_subregion_of(&self, r_sub: ty::Region, r_sup: ty::Region)\n+                           -> bool {\n         self.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n     }\n \n-    fn is_subscope_of(&self, r_sub: ast::node_id, r_sup: ast::node_id) -> bool {\n+    pub fn is_subscope_of(&self, r_sub: ast::node_id, r_sup: ast::node_id)\n+                          -> bool {\n         self.tcx.region_maps.is_subscope_of(r_sub, r_sup)\n     }\n \n-    fn is_move(&self, id: ast::node_id) -> bool {\n+    pub fn is_move(&self, id: ast::node_id) -> bool {\n         self.moves_map.contains(&id)\n     }\n \n-    fn cat_expr(&self, expr: @ast::expr) -> mc::cmt {\n+    pub fn cat_expr(&self, expr: @ast::expr) -> mc::cmt {\n         mc::cat_expr(self.tcx, self.method_map, expr)\n     }\n \n-    fn cat_expr_unadjusted(&self, expr: @ast::expr) -> mc::cmt {\n+    pub fn cat_expr_unadjusted(&self, expr: @ast::expr) -> mc::cmt {\n         mc::cat_expr_unadjusted(self.tcx, self.method_map, expr)\n     }\n \n-    fn cat_expr_autoderefd(&self, expr: @ast::expr,\n-                           adj: @ty::AutoAdjustment) -> mc::cmt {\n+    pub fn cat_expr_autoderefd(&self,\n+                               expr: @ast::expr,\n+                               adj: @ty::AutoAdjustment)\n+                               -> mc::cmt {\n         match *adj {\n             ty::AutoAddEnv(*) => {\n                 // no autoderefs\n@@ -464,46 +469,47 @@ pub impl BorrowckCtxt {\n         }\n     }\n \n-    fn cat_def(&self,\n-               id: ast::node_id,\n-               span: span,\n-               ty: ty::t,\n-               def: ast::def) -> mc::cmt {\n+    pub fn cat_def(&self,\n+                   id: ast::node_id,\n+                   span: span,\n+                   ty: ty::t,\n+                   def: ast::def)\n+                   -> mc::cmt {\n         mc::cat_def(self.tcx, self.method_map, id, span, ty, def)\n     }\n \n-    fn cat_discr(&self, cmt: mc::cmt, match_id: ast::node_id) -> mc::cmt {\n+    pub fn cat_discr(&self, cmt: mc::cmt, match_id: ast::node_id) -> mc::cmt {\n         @mc::cmt_ {cat:mc::cat_discr(cmt, match_id),\n                    mutbl:cmt.mutbl.inherit(),\n                    ..*cmt}\n     }\n \n-    fn mc_ctxt(&self) -> mc::mem_categorization_ctxt {\n+    pub fn mc_ctxt(&self) -> mc::mem_categorization_ctxt {\n         mc::mem_categorization_ctxt {tcx: self.tcx,\n                                  method_map: self.method_map}\n     }\n \n-    fn cat_pattern(&self,\n-                   cmt: mc::cmt,\n-                   pat: @ast::pat,\n-                   op: &fn(mc::cmt, @ast::pat)) {\n+    pub fn cat_pattern(&self,\n+                       cmt: mc::cmt,\n+                       pat: @ast::pat,\n+                       op: &fn(mc::cmt, @ast::pat)) {\n         let mc = self.mc_ctxt();\n         mc.cat_pattern(cmt, pat, op);\n     }\n \n-    fn report(&self, err: BckError) {\n+    pub fn report(&self, err: BckError) {\n         self.span_err(\n             err.span,\n             self.bckerr_to_str(err));\n         self.note_and_explain_bckerr(err);\n     }\n \n-    fn report_use_of_moved_value(&self,\n-                                 use_span: span,\n-                                 use_kind: MovedValueUseKind,\n-                                 lp: @LoanPath,\n-                                 move: &move_data::Move,\n-                                 moved_lp: @LoanPath) {\n+    pub fn report_use_of_moved_value(&self,\n+                                     use_span: span,\n+                                     use_kind: MovedValueUseKind,\n+                                     lp: @LoanPath,\n+                                     move: &move_data::Move,\n+                                     moved_lp: @LoanPath) {\n         let verb = match use_kind {\n             MovedInUse => \"use\",\n             MovedInCapture => \"capture\",\n@@ -562,10 +568,11 @@ pub impl BorrowckCtxt {\n         }\n     }\n \n-    fn report_reassigned_immutable_variable(&self,\n-                                            span: span,\n-                                            lp: @LoanPath,\n-                                            assign: &move_data::Assignment) {\n+    pub fn report_reassigned_immutable_variable(&self,\n+                                                span: span,\n+                                                lp: @LoanPath,\n+                                                assign:\n+                                                &move_data::Assignment) {\n         self.tcx.sess.span_err(\n             span,\n             fmt!(\"re-assignment of immutable variable `%s`\",\n@@ -575,15 +582,15 @@ pub impl BorrowckCtxt {\n             fmt!(\"prior assignment occurs here\"));\n     }\n \n-    fn span_err(&self, s: span, m: &str) {\n+    pub fn span_err(&self, s: span, m: &str) {\n         self.tcx.sess.span_err(s, m);\n     }\n \n-    fn span_note(&self, s: span, m: &str) {\n+    pub fn span_note(&self, s: span, m: &str) {\n         self.tcx.sess.span_note(s, m);\n     }\n \n-    fn bckerr_to_str(&self, err: BckError) -> ~str {\n+    pub fn bckerr_to_str(&self, err: BckError) -> ~str {\n         match err.code {\n             err_mutbl(lk) => {\n                 fmt!(\"cannot borrow %s %s as %s\",\n@@ -607,10 +614,10 @@ pub impl BorrowckCtxt {\n         }\n     }\n \n-    fn report_aliasability_violation(&self,\n-                                     span: span,\n-                                     kind: AliasableViolationKind,\n-                                     cause: mc::AliasableReason) {\n+    pub fn report_aliasability_violation(&self,\n+                                         span: span,\n+                                         kind: AliasableViolationKind,\n+                                         cause: mc::AliasableReason) {\n         let prefix = match kind {\n             MutabilityViolation => \"cannot assign to an `&mut`\",\n             BorrowViolation => \"cannot borrow an `&mut`\"\n@@ -648,7 +655,7 @@ pub impl BorrowckCtxt {\n         }\n     }\n \n-    fn note_and_explain_bckerr(&self, err: BckError) {\n+    pub fn note_and_explain_bckerr(&self, err: BckError) {\n         let code = err.code;\n         match code {\n             err_mutbl(*) | err_freeze_aliasable_const(*) => {}\n@@ -681,14 +688,14 @@ pub impl BorrowckCtxt {\n         }\n     }\n \n-    fn append_loan_path_to_str_from_interior(&self,\n-                                             loan_path: &LoanPath,\n-                                             out: &mut ~str) {\n+    pub fn append_loan_path_to_str_from_interior(&self,\n+                                                 loan_path: &LoanPath,\n+                                                 out: &mut ~str) {\n         match *loan_path {\n             LpExtend(_, _, LpDeref) => {\n-                str::push_char(out, '(');\n+                out.push_char('(');\n                 self.append_loan_path_to_str(loan_path, out);\n-                str::push_char(out, ')');\n+                out.push_char(')');\n             }\n             LpExtend(_, _, LpInterior(_)) |\n             LpVar(_) => {\n@@ -697,12 +704,14 @@ pub impl BorrowckCtxt {\n         }\n     }\n \n-    fn append_loan_path_to_str(&self, loan_path: &LoanPath, out: &mut ~str) {\n+    pub fn append_loan_path_to_str(&self,\n+                                   loan_path: &LoanPath,\n+                                   out: &mut ~str) {\n         match *loan_path {\n             LpVar(id) => {\n                 match self.tcx.items.find(&id) {\n-                    Some(&ast_map::node_local(ident)) => {\n-                        str::push_str(out, *self.tcx.sess.intr().get(ident));\n+                    Some(&ast_map::node_local(ref ident)) => {\n+                        out.push_str(token::ident_to_str(ident));\n                     }\n                     r => {\n                         self.tcx.sess.bug(\n@@ -715,48 +724,48 @@ pub impl BorrowckCtxt {\n             LpExtend(lp_base, _, LpInterior(mc::InteriorField(fname))) => {\n                 self.append_loan_path_to_str_from_interior(lp_base, out);\n                 match fname {\n-                    mc::NamedField(fname) => {\n-                        str::push_char(out, '.');\n-                        str::push_str(out, *self.tcx.sess.intr().get(fname));\n+                    mc::NamedField(ref fname) => {\n+                        out.push_char('.');\n+                        out.push_str(token::ident_to_str(fname));\n                     }\n                     mc::PositionalField(idx) => {\n-                        str::push_char(out, '#'); // invent a notation here\n-                        str::push_str(out, idx.to_str());\n+                        out.push_char('#'); // invent a notation here\n+                        out.push_str(idx.to_str());\n                     }\n                 }\n             }\n \n             LpExtend(lp_base, _, LpInterior(mc::InteriorElement(_))) => {\n                 self.append_loan_path_to_str_from_interior(lp_base, out);\n-                str::push_str(out, \"[]\");\n+                out.push_str(\"[]\");\n             }\n \n             LpExtend(lp_base, _, LpDeref) => {\n-                str::push_char(out, '*');\n+                out.push_char('*');\n                 self.append_loan_path_to_str(lp_base, out);\n             }\n         }\n     }\n \n-    fn loan_path_to_str(&self, loan_path: &LoanPath) -> ~str {\n+    pub fn loan_path_to_str(&self, loan_path: &LoanPath) -> ~str {\n         let mut result = ~\"\";\n         self.append_loan_path_to_str(loan_path, &mut result);\n         result\n     }\n \n-    fn cmt_to_str(&self, cmt: mc::cmt) -> ~str {\n+    pub fn cmt_to_str(&self, cmt: mc::cmt) -> ~str {\n         let mc = &mc::mem_categorization_ctxt {tcx: self.tcx,\n                                                method_map: self.method_map};\n         mc.cmt_to_str(cmt)\n     }\n \n-    fn mut_to_str(&self, mutbl: ast::mutability) -> ~str {\n+    pub fn mut_to_str(&self, mutbl: ast::mutability) -> ~str {\n         let mc = &mc::mem_categorization_ctxt {tcx: self.tcx,\n                                                method_map: self.method_map};\n         mc.mut_to_str(mutbl)\n     }\n \n-    fn mut_to_keyword(&self, mutbl: ast::mutability) -> &'static str {\n+    pub fn mut_to_keyword(&self, mutbl: ast::mutability) -> &'static str {\n         match mutbl {\n             ast::m_imm => \"\",\n             ast::m_const => \"const\","}, {"sha": "bd560fca9854a539a77b2e605afbb3e873999321", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -16,7 +16,9 @@ comments in the section \"Moves and initialization\" and in `doc.rs`.\n */\n \n use core::prelude::*;\n+\n use core::hashmap::{HashMap, HashSet};\n+use core::uint;\n use middle::borrowck::*;\n use middle::dataflow::DataFlowContext;\n use middle::dataflow::DataFlowOperator;\n@@ -514,7 +516,7 @@ impl FlowedMoveData {\n                 loop;\n             }\n \n-            for opt_loan_path_index.each |&loan_path_index| {\n+            for opt_loan_path_index.iter().advance |&loan_path_index| {\n                 for self.move_data.each_base_path(moved_path) |p| {\n                     if p == loan_path_index {\n                         // Scenario 3: some extension of `loan_path`"}, {"sha": "f44fb0e058bcf9ae92e1c16d5e4addcf12a7f1c4", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -26,39 +26,39 @@ pub fn check_crate(sess: Session,\n                    def_map: resolve::DefMap,\n                    method_map: typeck::method_map,\n                    tcx: ty::ctxt) {\n-    visit::visit_crate(crate, false, visit::mk_vt(@visit::Visitor {\n-        visit_item: |a,b,c| check_item(sess, ast_map, def_map, a, b, c),\n+    visit::visit_crate(crate, (false, visit::mk_vt(@visit::Visitor {\n+        visit_item: |a,b| check_item(sess, ast_map, def_map, a, b),\n         visit_pat: check_pat,\n-        visit_expr: |a,b,c|\n-            check_expr(sess, def_map, method_map, tcx, a, b, c),\n+        visit_expr: |a,b|\n+            check_expr(sess, def_map, method_map, tcx, a, b),\n         .. *visit::default_visitor()\n-    }));\n+    })));\n     sess.abort_if_errors();\n }\n \n pub fn check_item(sess: Session,\n                   ast_map: ast_map::map,\n                   def_map: resolve::DefMap,\n                   it: @item,\n-                  _is_const: bool,\n-                  v: visit::vt<bool>) {\n+                  (_is_const, v): (bool,\n+                                   visit::vt<bool>)) {\n     match it.node {\n       item_const(_, ex) => {\n-        (v.visit_expr)(ex, true, v);\n+        (v.visit_expr)(ex, (true, v));\n         check_item_recursion(sess, ast_map, def_map, it);\n       }\n       item_enum(ref enum_definition, _) => {\n         for (*enum_definition).variants.each |var| {\n-            for var.node.disr_expr.each |ex| {\n-                (v.visit_expr)(*ex, true, v);\n+            for var.node.disr_expr.iter().advance |ex| {\n+                (v.visit_expr)(*ex, (true, v));\n             }\n         }\n       }\n-      _ => visit::visit_item(it, false, v)\n+      _ => visit::visit_item(it, (false, v))\n     }\n }\n \n-pub fn check_pat(p: @pat, _is_const: bool, v: visit::vt<bool>) {\n+pub fn check_pat(p: @pat, (_is_const, v): (bool, visit::vt<bool>)) {\n     fn is_str(e: @expr) -> bool {\n         match e.node {\n             expr_vstore(\n@@ -73,12 +73,12 @@ pub fn check_pat(p: @pat, _is_const: bool, v: visit::vt<bool>) {\n     }\n     match p.node {\n       // Let through plain ~-string literals here\n-      pat_lit(a) => if !is_str(a) { (v.visit_expr)(a, true, v); },\n+      pat_lit(a) => if !is_str(a) { (v.visit_expr)(a, (true, v)); },\n       pat_range(a, b) => {\n-        if !is_str(a) { (v.visit_expr)(a, true, v); }\n-        if !is_str(b) { (v.visit_expr)(b, true, v); }\n+        if !is_str(a) { (v.visit_expr)(a, (true, v)); }\n+        if !is_str(b) { (v.visit_expr)(b, (true, v)); }\n       }\n-      _ => visit::visit_pat(p, false, v)\n+      _ => visit::visit_pat(p, (false, v))\n     }\n }\n \n@@ -87,18 +87,18 @@ pub fn check_expr(sess: Session,\n                   method_map: typeck::method_map,\n                   tcx: ty::ctxt,\n                   e: @expr,\n-                  is_const: bool,\n-                  v: visit::vt<bool>) {\n+                  (is_const, v): (bool,\n+                                  visit::vt<bool>)) {\n     if is_const {\n         match e.node {\n-          expr_unary(deref, _) => { }\n-          expr_unary(box(_), _) | expr_unary(uniq(_), _) => {\n+          expr_unary(_, deref, _) => { }\n+          expr_unary(_, box(_), _) | expr_unary(_, uniq(_), _) => {\n             sess.span_err(e.span,\n                           \"disallowed operator in constant expression\");\n             return;\n           }\n           expr_lit(@codemap::spanned {node: lit_str(_), _}) => { }\n-          expr_binary(_, _, _) | expr_unary(_, _) => {\n+          expr_binary(*) | expr_unary(*) => {\n             if method_map.contains_key(&e.id) {\n                 sess.span_err(e.span, \"user-defined operators are not \\\n                                        allowed in constant expressions\");\n@@ -154,7 +154,7 @@ pub fn check_expr(sess: Session,\n             }\n           }\n           expr_paren(e) => { check_expr(sess, def_map, method_map,\n-                                         tcx, e, is_const, v); }\n+                                         tcx, e, (is_const, v)); }\n           expr_vstore(_, expr_vstore_slice) |\n           expr_vec(_, m_imm) |\n           expr_addr_of(m_imm, _) |\n@@ -192,7 +192,7 @@ pub fn check_expr(sess: Session,\n       }\n       _ => ()\n     }\n-    visit::visit_expr(e, is_const, v);\n+    visit::visit_expr(e, (is_const, v));\n }\n \n // Make sure a const item doesn't recursively refer to itself\n@@ -222,26 +222,26 @@ pub fn check_item_recursion(sess: Session,\n         visit_expr: visit_expr,\n         .. *visit::default_visitor()\n     });\n-    (visitor.visit_item)(it, env, visitor);\n+    (visitor.visit_item)(it, (env, visitor));\n \n-    fn visit_item(it: @item, env: env, v: visit::vt<env>) {\n+    fn visit_item(it: @item, (env, v): (env, visit::vt<env>)) {\n         if env.idstack.contains(&(it.id)) {\n             env.sess.span_fatal(env.root_it.span, \"recursive constant\");\n         }\n         env.idstack.push(it.id);\n-        visit::visit_item(it, env, v);\n+        visit::visit_item(it, (env, v));\n         env.idstack.pop();\n     }\n \n-    fn visit_expr(e: @expr, env: env, v: visit::vt<env>) {\n+    fn visit_expr(e: @expr, (env, v): (env, visit::vt<env>)) {\n         match e.node {\n           expr_path(*) => {\n             match env.def_map.find(&e.id) {\n               Some(&def_const(def_id)) => {\n                 if ast_util::is_local(def_id) {\n                   match env.ast_map.get_copy(&def_id.node) {\n                     ast_map::node_item(it, _) => {\n-                      (v.visit_item)(it, env, v);\n+                      (v.visit_item)(it, (env, v));\n                     }\n                     _ => fail!(\"const not bound to an item\")\n                   }\n@@ -252,6 +252,6 @@ pub fn check_item_recursion(sess: Session,\n           }\n           _ => ()\n         }\n-        visit::visit_expr(e, env, v);\n+        visit::visit_expr(e, (env, v));\n     }\n }"}, {"sha": "2ed7b7adecc1ac0881b5b743427da50eea40a39c", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -21,36 +21,36 @@ pub struct Context {\n \n pub fn check_crate(tcx: ty::ctxt, crate: @crate) {\n     visit::visit_crate(crate,\n-                       Context { in_loop: false, can_ret: true },\n+                       (Context { in_loop: false, can_ret: true },\n                        visit::mk_vt(@visit::Visitor {\n-        visit_item: |i, _cx, v| {\n-            visit::visit_item(i, Context {\n+        visit_item: |i, (_cx, v)| {\n+            visit::visit_item(i, (Context {\n                                     in_loop: false,\n                                     can_ret: true\n-                                 }, v);\n+                                 }, v));\n         },\n-        visit_expr: |e: @expr, cx: Context, v: visit::vt<Context>| {\n+        visit_expr: |e: @expr, (cx, v): (Context, visit::vt<Context>)| {\n             match e.node {\n               expr_while(e, ref b) => {\n-                (v.visit_expr)(e, cx, v);\n-                (v.visit_block)(b, Context { in_loop: true,.. cx }, v);\n+                (v.visit_expr)(e, (cx, v));\n+                (v.visit_block)(b, (Context { in_loop: true,.. cx }, v));\n               }\n               expr_loop(ref b, _) => {\n-                (v.visit_block)(b, Context { in_loop: true,.. cx }, v);\n+                (v.visit_block)(b, (Context { in_loop: true,.. cx }, v));\n               }\n               expr_fn_block(_, ref b) => {\n-                (v.visit_block)(b, Context {\n+                (v.visit_block)(b, (Context {\n                                          in_loop: false,\n                                          can_ret: false\n-                                      }, v);\n+                                      }, v));\n               }\n               expr_loop_body(@expr {node: expr_fn_block(_, ref b), _}) => {\n                 let sigil = ty::ty_closure_sigil(ty::expr_ty(tcx, e));\n                 let blk = (sigil == BorrowedSigil);\n-                (v.visit_block)(b, Context {\n+                (v.visit_block)(b, (Context {\n                                          in_loop: true,\n                                          can_ret: blk\n-                                     }, v);\n+                                     }, v));\n               }\n               expr_break(_) => {\n                 if !cx.in_loop {\n@@ -66,11 +66,11 @@ pub fn check_crate(tcx: ty::ctxt, crate: @crate) {\n                 if !cx.can_ret {\n                     tcx.sess.span_err(e.span, \"`return` in block function\");\n                 }\n-                visit::visit_expr_opt(oe, cx, v);\n+                visit::visit_expr_opt(oe, (cx, v));\n               }\n-              _ => visit::visit_expr(e, cx, v)\n+              _ => visit::visit_expr(e, (cx, v))\n             }\n         },\n         .. *visit::default_visitor()\n-    }));\n+    })));\n }"}, {"sha": "ad89d790761e2b8a62a5d694fa5f344a6d85d01f", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 41, "deletions": 35, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -19,6 +19,8 @@ use middle::typeck::method_map;\n use middle::moves;\n use util::ppaux::ty_to_str;\n \n+use core::uint;\n+use core::vec;\n use extra::sort;\n use syntax::ast::*;\n use syntax::ast_util::{unguarded_pat, walk_pat};\n@@ -38,13 +40,13 @@ pub fn check_crate(tcx: ty::ctxt,\n     let cx = @MatchCheckCtxt {tcx: tcx,\n                               method_map: method_map,\n                               moves_map: moves_map};\n-    visit::visit_crate(crate, (), visit::mk_vt(@visit::Visitor {\n-        visit_expr: |a,b,c| check_expr(cx, a, b, c),\n-        visit_local: |a,b,c| check_local(cx, a, b, c),\n-        visit_fn: |kind, decl, body, sp, id, e, v|\n-            check_fn(cx, kind, decl, body, sp, id, e, v),\n+    visit::visit_crate(crate, ((), visit::mk_vt(@visit::Visitor {\n+        visit_expr: |a,b| check_expr(cx, a, b),\n+        visit_local: |a,b| check_local(cx, a, b),\n+        visit_fn: |kind, decl, body, sp, id, (e, v)|\n+            check_fn(cx, kind, decl, body, sp, id, (e, v)),\n         .. *visit::default_visitor::<()>()\n-    }));\n+    })));\n     tcx.sess.abort_if_errors();\n }\n \n@@ -56,8 +58,8 @@ pub fn expr_is_non_moving_lvalue(cx: @MatchCheckCtxt, expr: @expr) -> bool {\n     !cx.moves_map.contains(&expr.id)\n }\n \n-pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, s: (), v: visit::vt<()>) {\n-    visit::visit_expr(ex, s, v);\n+pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, (s, v): ((), visit::vt<()>)) {\n+    visit::visit_expr(ex, (s, v));\n     match ex.node {\n       expr_match(scrut, ref arms) => {\n         // First, check legality of move bindings.\n@@ -141,8 +143,8 @@ pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n             match ty::get(ty).sty {\n                 ty::ty_bool => {\n                     match (*ctor) {\n-                        val(const_bool(true)) => Some(@~\"true\"),\n-                        val(const_bool(false)) => Some(@~\"false\"),\n+                        val(const_bool(true)) => Some(@\"true\"),\n+                        val(const_bool(false)) => Some(@\"false\"),\n                         _ => None\n                     }\n                 }\n@@ -162,7 +164,7 @@ pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n                 }\n                 ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n                     match *ctor {\n-                        vec(n) => Some(@fmt!(\"vectors of length %u\", n)),\n+                        vec(n) => Some(fmt!(\"vectors of length %u\", n).to_managed()),\n                         _ => None\n                     }\n                 }\n@@ -171,7 +173,7 @@ pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n         }\n     };\n     let msg = ~\"non-exhaustive patterns\" + match ext {\n-        Some(ref s) => ~\": \" + **s + \" not covered\",\n+        Some(ref s) => fmt!(\": %s not covered\",  *s),\n         None => ~\"\"\n     };\n     cx.tcx.sess.span_err(sp, msg);\n@@ -240,7 +242,7 @@ pub fn is_useful(cx: @MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n                 not_useful\n               }\n               ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n-                let max_len = do m.foldr(0) |r, max_len| {\n+                let max_len = do m.rev_iter().fold(0) |max_len, r| {\n                   match r[0].node {\n                     pat_vec(ref before, _, ref after) => {\n                       uint::max(before.len() + after.len(), max_len)\n@@ -360,7 +362,8 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n       ty::ty_enum(eid, _) => {\n         let mut found = ~[];\n         for m.each |r| {\n-            for pat_ctor_id(cx, r[0]).each |id| {\n+            let r = pat_ctor_id(cx, r[0]);\n+            for r.iter().advance |id| {\n                 if !vec::contains(found, id) {\n                     found.push(/*bad*/copy *id);\n                 }\n@@ -378,7 +381,8 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n       }\n       ty::ty_nil => None,\n       ty::ty_bool => {\n-        let mut true_found = false, false_found = false;\n+        let mut true_found = false;\n+        let mut false_found = false;\n         for m.each |r| {\n             match pat_ctor_id(cx, r[0]) {\n               None => (),\n@@ -511,10 +515,12 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                                 }\n                             },\n                             range(ref c_lo, ref c_hi) => {\n-                                let m1 = compare_const_vals(c_lo, &e_v),\n-                                    m2 = compare_const_vals(c_hi, &e_v);\n+                                let m1 = compare_const_vals(c_lo, &e_v);\n+                                let m2 = compare_const_vals(c_hi, &e_v);\n                                 match (m1, m2) {\n-                                    (Some(val1), Some(val2)) => (val1 >= 0 && val2 <= 0),\n+                                    (Some(val1), Some(val2)) => {\n+                                        (val1 >= 0 && val2 <= 0)\n+                                    }\n                                     _ => {\n                                         cx.tcx.sess.span_err(pat_span,\n                                             \"mismatched types between ranges\");\n@@ -558,8 +564,8 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                                     }\n                                 },\n                             range(ref c_lo, ref c_hi) => {\n-                                let m1 = compare_const_vals(c_lo, &e_v),\n-                                    m2 = compare_const_vals(c_hi, &e_v);\n+                                let m1 = compare_const_vals(c_lo, &e_v);\n+                                let m2 = compare_const_vals(c_hi, &e_v);\n                                 match (m1, m2) {\n                                     (Some(val1), Some(val2)) => (val1 >= 0 && val2 <= 0),\n                                     _ => {\n@@ -620,7 +626,8 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                     }\n                     _ => {\n                         // Grab the class data that we care about.\n-                        let class_fields, class_id;\n+                        let class_fields;\n+                        let class_id;\n                         match ty::get(left_ty).sty {\n                             ty::ty_struct(cid, _) => {\n                                 class_id = cid;\n@@ -665,8 +672,8 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                         }\n                     },\n                     range(ref c_lo, ref c_hi) => {\n-                        let m1 = compare_const_vals(c_lo, &e_v),\n-                            m2 = compare_const_vals(c_hi, &e_v);\n+                        let m1 = compare_const_vals(c_lo, &e_v);\n+                        let m2 = compare_const_vals(c_hi, &e_v);\n                         match (m1, m2) {\n                             (Some(val1), Some(val2)) => (val1 >= 0 && val2 <= 0),\n                             _ => {\n@@ -689,11 +696,11 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                     single => return Some(vec::to_owned(r.tail())),\n                     _ => fail!(\"type error\")\n                 };\n-                let v_lo = eval_const_expr(cx.tcx, lo),\n-                    v_hi = eval_const_expr(cx.tcx, hi);\n+                let v_lo = eval_const_expr(cx.tcx, lo);\n+                let v_hi = eval_const_expr(cx.tcx, hi);\n \n-                let m1 = compare_const_vals(&c_lo, &v_lo),\n-                    m2 = compare_const_vals(&c_hi, &v_hi);\n+                let m1 = compare_const_vals(&c_lo, &v_lo);\n+                let m2 = compare_const_vals(&c_hi, &v_hi);\n                 match (m1, m2) {\n                     (Some(val1), Some(val2)) if val1 >= 0 && val2 <= 0 => {\n                         Some(vec::to_owned(r.tail()))\n@@ -743,9 +750,9 @@ pub fn default(cx: @MatchCheckCtxt, r: &[@pat]) -> Option<~[@pat]> {\n \n pub fn check_local(cx: @MatchCheckCtxt,\n                    loc: @local,\n-                   s: (),\n-                   v: visit::vt<()>) {\n-    visit::visit_local(loc, s, v);\n+                   (s, v): ((),\n+                            visit::vt<()>)) {\n+    visit::visit_local(loc, (s, v));\n     if is_refutable(cx, loc.node.pat) {\n         cx.tcx.sess.span_err(loc.node.pat.span,\n                              \"refutable pattern in local binding\");\n@@ -765,9 +772,9 @@ pub fn check_fn(cx: @MatchCheckCtxt,\n                 body: &blk,\n                 sp: span,\n                 id: node_id,\n-                s: (),\n-                v: visit::vt<()>) {\n-    visit::visit_fn(kind, decl, body, sp, id, s, v);\n+                (s, v): ((),\n+                         visit::vt<()>)) {\n+    visit::visit_fn(kind, decl, body, sp, id, (s, v));\n     for decl.inputs.each |input| {\n         if is_refutable(cx, input.pat) {\n             cx.tcx.sess.span_err(input.pat.span,\n@@ -779,7 +786,7 @@ pub fn check_fn(cx: @MatchCheckCtxt,\n pub fn is_refutable(cx: @MatchCheckCtxt, pat: &pat) -> bool {\n     match cx.tcx.def_map.find(&pat.id) {\n       Some(&def_variant(enum_id, _)) => {\n-        if vec::len(*ty::enum_variants(cx.tcx, enum_id)) != 1u {\n+        if ty::enum_variants(cx.tcx, enum_id).len() != 1u {\n             return true;\n         }\n       }\n@@ -825,7 +832,6 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n     for pats.each |pat| {\n         do pat_bindings(def_map, *pat) |bm, id, span, _path| {\n             match bm {\n-                bind_by_copy => {}\n                 bind_by_ref(_) => {\n                     by_ref_span = Some(span);\n                 }"}, {"sha": "988ad519f42bcc3cd37809443318afa1bdd62c9a", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -18,7 +18,9 @@ use middle;\n use syntax::{ast, ast_map, ast_util, visit};\n use syntax::ast::*;\n \n+use core::float;\n use core::hashmap::{HashMap, HashSet};\n+use core::vec;\n \n //\n // This pass classifies expressions by their constant-ness.\n@@ -70,7 +72,7 @@ pub fn join(a: constness, b: constness) -> constness {\n }\n \n pub fn join_all(cs: &[constness]) -> constness {\n-    vec::foldl(integral_const, cs, |a, b| join(a, *b))\n+    cs.iter().fold(integral_const, |a, b| join(a, *b))\n }\n \n pub fn classify(e: @expr,\n@@ -91,12 +93,12 @@ pub fn classify(e: @expr,\n               }\n \n               ast::expr_copy(inner) |\n-              ast::expr_unary(_, inner) |\n+              ast::expr_unary(_, _, inner) |\n               ast::expr_paren(inner) => {\n                 classify(inner, tcx)\n               }\n \n-              ast::expr_binary(_, a, b) => {\n+              ast::expr_binary(_, _, a, b) => {\n                 join(classify(a, tcx),\n                      classify(b, tcx))\n               }\n@@ -118,11 +120,7 @@ pub fn classify(e: @expr,\n \n               ast::expr_struct(_, ref fs, None) => {\n                 let cs = do vec::map((*fs)) |f| {\n-                    if f.node.mutbl == ast::m_imm {\n-                        classify(f.node.expr, tcx)\n-                    } else {\n-                        non_const\n-                    }\n+                    classify(f.node.expr, tcx)\n                 };\n                 join_all(cs)\n               }\n@@ -143,7 +141,7 @@ pub fn classify(e: @expr,\n                 classify(base, tcx)\n               }\n \n-              ast::expr_index(base, idx) => {\n+              ast::expr_index(_, base, idx) => {\n                 join(classify(base, tcx),\n                      classify(idx, tcx))\n               }\n@@ -225,7 +223,7 @@ pub fn process_crate(crate: @ast::crate,\n         visit_expr_post: |e| { classify(e, tcx); },\n         .. *visit::default_simple_visitor()\n     });\n-    visit::visit_crate(crate, (), v);\n+    visit::visit_crate(crate, ((), v));\n     tcx.sess.abort_if_errors();\n }\n \n@@ -237,14 +235,14 @@ pub enum const_val {\n     const_float(f64),\n     const_int(i64),\n     const_uint(u64),\n-    const_str(~str),\n+    const_str(@str),\n     const_bool(bool)\n }\n \n pub fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n     match eval_const_expr_partial(tcx, e) {\n-        Ok(ref r) => (/*bad*/copy *r),\n-        Err(ref s) => fail!(/*bad*/copy *s)\n+        Ok(r) => r,\n+        Err(s) => tcx.sess.span_fatal(e.span, s)\n     }\n }\n \n@@ -253,7 +251,7 @@ pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n     use middle::ty;\n     fn fromb(b: bool) -> Result<const_val, ~str> { Ok(const_int(b as i64)) }\n     match e.node {\n-      expr_unary(neg, inner) => {\n+      expr_unary(_, neg, inner) => {\n         match eval_const_expr_partial(tcx, inner) {\n           Ok(const_float(f)) => Ok(const_float(-f)),\n           Ok(const_int(i)) => Ok(const_int(-i)),\n@@ -263,15 +261,15 @@ pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n           ref err => (/*bad*/copy *err)\n         }\n       }\n-      expr_unary(not, inner) => {\n+      expr_unary(_, not, inner) => {\n         match eval_const_expr_partial(tcx, inner) {\n           Ok(const_int(i)) => Ok(const_int(!i)),\n           Ok(const_uint(i)) => Ok(const_uint(!i)),\n           Ok(const_bool(b)) => Ok(const_bool(!b)),\n           _ => Err(~\"Not on float or string\")\n         }\n       }\n-      expr_binary(op, a, b) => {\n+      expr_binary(_, op, a, b) => {\n         match (eval_const_expr_partial(tcx, a),\n                eval_const_expr_partial(tcx, b)) {\n           (Ok(const_float(a)), Ok(const_float(b))) => {\n@@ -410,13 +408,13 @@ pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n \n pub fn lit_to_const(lit: @lit) -> const_val {\n     match lit.node {\n-      lit_str(s) => const_str(/*bad*/copy *s),\n+      lit_str(s) => const_str(s),\n       lit_int(n, _) => const_int(n),\n       lit_uint(n, _) => const_uint(n),\n       lit_int_unsuffixed(n) => const_int(n),\n-      lit_float(n, _) => const_float(float::from_str(*n).get() as f64),\n+      lit_float(n, _) => const_float(float::from_str(n).get() as f64),\n       lit_float_unsuffixed(n) =>\n-        const_float(float::from_str(*n).get() as f64),\n+        const_float(float::from_str(n).get() as f64),\n       lit_nil => const_int(0i64),\n       lit_bool(b) => const_bool(b)\n     }"}, {"sha": "8037bacd3e72b8fc68419676993a656acf008a07", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -19,7 +19,9 @@\n use core::prelude::*;\n \n use core::cast;\n+use core::io;\n use core::uint;\n+use core::vec;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::ast_util::id_range;\n@@ -369,11 +371,9 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                  in_out: &mut [uint],\n                  loop_scopes: &mut ~[LoopScope]) {\n         match decl.node {\n-            ast::decl_local(ref locals) => {\n-                for locals.each |local| {\n-                    self.walk_pat(local.node.pat, in_out, loop_scopes);\n-                    self.walk_opt_expr(local.node.init, in_out, loop_scopes);\n-                }\n+            ast::decl_local(local) => {\n+                self.walk_pat(local.node.pat, in_out, loop_scopes);\n+                self.walk_opt_expr(local.node.init, in_out, loop_scopes);\n             }\n \n             ast::decl_item(_) => {}\n@@ -636,7 +636,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             }\n \n             ast::expr_assign(l, r) |\n-            ast::expr_assign_op(_, l, r) => {\n+            ast::expr_assign_op(_, _, l, r) => {\n                 self.walk_expr(r, in_out, loop_scopes);\n                 self.walk_expr(l, in_out, loop_scopes);\n             }\n@@ -658,40 +658,40 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             }\n \n             ast::expr_call(f, ref args, _) => {\n-                self.walk_call(expr.callee_id, expr.id,\n+                self.walk_call(f.id, expr.id,\n                                f, *args, in_out, loop_scopes);\n             }\n \n-            ast::expr_method_call(rcvr, _, _, ref args, _) => {\n-                self.walk_call(expr.callee_id, expr.id,\n+            ast::expr_method_call(callee_id, rcvr, _, _, ref args, _) => {\n+                self.walk_call(callee_id, expr.id,\n                                rcvr, *args, in_out, loop_scopes);\n             }\n \n-            ast::expr_index(l, r) |\n-            ast::expr_binary(_, l, r) if self.is_method_call(expr) => {\n-                self.walk_call(expr.callee_id, expr.id,\n+            ast::expr_index(callee_id, l, r) |\n+            ast::expr_binary(callee_id, _, l, r) if self.is_method_call(expr) => {\n+                self.walk_call(callee_id, expr.id,\n                                l, [r], in_out, loop_scopes);\n             }\n \n-            ast::expr_unary(_, e) if self.is_method_call(expr) => {\n-                self.walk_call(expr.callee_id, expr.id,\n+            ast::expr_unary(callee_id, _, e) if self.is_method_call(expr) => {\n+                self.walk_call(callee_id, expr.id,\n                                e, [], in_out, loop_scopes);\n             }\n \n             ast::expr_tup(ref exprs) => {\n                 self.walk_exprs(*exprs, in_out, loop_scopes);\n             }\n \n-            ast::expr_binary(op, l, r) if ast_util::lazy_binop(op) => {\n+            ast::expr_binary(_, op, l, r) if ast_util::lazy_binop(op) => {\n                 self.walk_expr(l, in_out, loop_scopes);\n                 let temp = reslice(in_out).to_vec();\n                 self.walk_expr(r, in_out, loop_scopes);\n                 join_bits(&self.dfcx.oper, temp, in_out);\n             }\n \n             ast::expr_log(l, r) |\n-            ast::expr_index(l, r) |\n-            ast::expr_binary(_, l, r) => {\n+            ast::expr_index(_, l, r) |\n+            ast::expr_binary(_, _, l, r) => {\n                 self.walk_exprs([l, r], in_out, loop_scopes);\n             }\n \n@@ -705,7 +705,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             ast::expr_loop_body(e) |\n             ast::expr_do_body(e) |\n             ast::expr_cast(e, _) |\n-            ast::expr_unary(_, e) |\n+            ast::expr_unary(_, _, e) |\n             ast::expr_paren(e) |\n             ast::expr_vstore(e, _) |\n             ast::expr_field(e, _, _) => {\n@@ -793,7 +793,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                      opt_expr: Option<@ast::expr>,\n                      in_out: &mut [uint],\n                      loop_scopes: &mut ~[LoopScope]) {\n-        for opt_expr.each |&expr| {\n+        for opt_expr.iter().advance |&expr| {\n             self.walk_expr(expr, in_out, loop_scopes);\n         }\n     }\n@@ -894,7 +894,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n \n     fn reset(&mut self, bits: &mut [uint]) {\n         let e = if self.dfcx.oper.initial_value() {uint::max_value} else {0};\n-        for vec::each_mut(bits) |b| { *b = e; }\n+        for bits.mut_iter().advance |b| { *b = e; }\n     }\n \n     fn add_to_entry_set(&mut self, id: ast::node_id, pred_bits: &[uint]) {\n@@ -945,13 +945,13 @@ fn bits_to_str(words: &[uint]) -> ~str {\n     for words.each |&word| {\n         let mut v = word;\n         for uint::range(0, uint::bytes) |_| {\n-            str::push_char(&mut result, sep);\n-            str::push_str(&mut result, fmt!(\"%02x\", v & 0xFF));\n+            result.push_char(sep);\n+            result.push_str(fmt!(\"%02x\", v & 0xFF));\n             v >>= 8;\n             sep = '-';\n         }\n     }\n-    str::push_char(&mut result, ']');\n+    result.push_char(']');\n     return result;\n }\n "}, {"sha": "d9481c26dad0e3e45980a92a53afd636a18355d7", "filename": "src/librustc/middle/effect.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -0,0 +1,156 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Enforces the Rust effect system. Currently there is just one effect,\n+/// `unsafe`.\n+\n+use middle::ty::{ty_bare_fn, ty_closure, ty_ptr};\n+use middle::ty;\n+use middle::typeck::method_map;\n+use util::ppaux;\n+\n+use syntax::ast::{deref, expr_call, expr_inline_asm, expr_method_call};\n+use syntax::ast::{expr_unary, node_id, unsafe_blk, unsafe_fn};\n+use syntax::ast;\n+use syntax::codemap::span;\n+use syntax::visit::{fk_item_fn, fk_method};\n+use syntax::visit;\n+\n+#[deriving(Eq)]\n+enum UnsafeContext {\n+    SafeContext,\n+    UnsafeFn,\n+    UnsafeBlock(node_id),\n+}\n+\n+struct Context {\n+    /// The method map.\n+    method_map: method_map,\n+    /// Whether we're in an unsafe context.\n+    unsafe_context: UnsafeContext,\n+}\n+\n+fn type_is_unsafe_function(ty: ty::t) -> bool {\n+    match ty::get(ty).sty {\n+        ty_bare_fn(ref f) => f.purity == unsafe_fn,\n+        ty_closure(ref f) => f.purity == unsafe_fn,\n+        _ => false,\n+    }\n+}\n+\n+pub fn check_crate(tcx: ty::ctxt,\n+                   method_map: method_map,\n+                   crate: @ast::crate) {\n+    let context = @mut Context {\n+        method_map: method_map,\n+        unsafe_context: SafeContext,\n+    };\n+\n+    let require_unsafe: @fn(span: span,\n+                            description: &str) = |span, description| {\n+        match context.unsafe_context {\n+            SafeContext => {\n+                // Report an error.\n+                tcx.sess.span_err(span,\n+                                  fmt!(\"%s requires unsafe function or block\",\n+                                       description))\n+            }\n+            UnsafeBlock(block_id) => {\n+                // OK, but record this.\n+                debug!(\"effect: recording unsafe block as used: %?\", block_id);\n+                let _ = tcx.used_unsafe.insert(block_id);\n+            }\n+            UnsafeFn => {}\n+        }\n+    };\n+\n+    let visitor = visit::mk_vt(@visit::Visitor {\n+        visit_fn: |fn_kind, fn_decl, block, span, node_id, (_, visitor)| {\n+            let (is_item_fn, is_unsafe_fn) = match *fn_kind {\n+                fk_item_fn(_, _, purity, _) => (true, purity == unsafe_fn),\n+                fk_method(_, _, method) => (true, method.purity == unsafe_fn),\n+                _ => (false, false),\n+            };\n+\n+            let old_unsafe_context = context.unsafe_context;\n+            if is_unsafe_fn {\n+                context.unsafe_context = UnsafeFn\n+            } else if is_item_fn {\n+                context.unsafe_context = SafeContext\n+            }\n+\n+            visit::visit_fn(fn_kind,\n+                            fn_decl,\n+                            block,\n+                            span,\n+                            node_id,\n+                            ((),\n+                             visitor));\n+\n+            context.unsafe_context = old_unsafe_context\n+        },\n+\n+        visit_block: |block, (_, visitor)| {\n+            let old_unsafe_context = context.unsafe_context;\n+            if block.node.rules == unsafe_blk &&\n+                    context.unsafe_context == SafeContext {\n+                context.unsafe_context = UnsafeBlock(block.node.id)\n+            }\n+\n+            visit::visit_block(block, ((), visitor));\n+\n+            context.unsafe_context = old_unsafe_context\n+        },\n+\n+        visit_expr: |expr, (_, visitor)| {\n+            match expr.node {\n+                expr_method_call(callee_id, _, _, _, _, _) => {\n+                    let base_type = ty::node_id_to_type(tcx, callee_id);\n+                    debug!(\"effect: method call case, base type is %s\",\n+                           ppaux::ty_to_str(tcx, base_type));\n+                    if type_is_unsafe_function(base_type) {\n+                        require_unsafe(expr.span,\n+                                       \"invocation of unsafe method\")\n+                    }\n+                }\n+                expr_call(base, _, _) => {\n+                    let base_type = ty::node_id_to_type(tcx, base.id);\n+                    debug!(\"effect: call case, base type is %s\",\n+                           ppaux::ty_to_str(tcx, base_type));\n+                    if type_is_unsafe_function(base_type) {\n+                        require_unsafe(expr.span, \"call to unsafe function\")\n+                    }\n+                }\n+                expr_unary(_, deref, base) => {\n+                    let base_type = ty::node_id_to_type(tcx, base.id);\n+                    debug!(\"effect: unary case, base type is %s\",\n+                           ppaux::ty_to_str(tcx, base_type));\n+                    match ty::get(base_type).sty {\n+                        ty_ptr(_) => {\n+                            require_unsafe(expr.span,\n+                                           \"dereference of unsafe pointer\")\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+                expr_inline_asm(*) => {\n+                    require_unsafe(expr.span, \"use of inline assembly\")\n+                }\n+                _ => {}\n+            }\n+\n+            visit::visit_expr(expr, ((), visitor))\n+        },\n+\n+        .. *visit::default_visitor()\n+    });\n+\n+    visit::visit_crate(crate, ((), visitor))\n+}"}, {"sha": "a93aea983fbfec5c946ab8338cfa34433a1ac2a0", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -59,10 +59,10 @@ pub fn find_entry_point(session: Session, crate: @crate, ast_map: ast_map::map)\n         non_main_fns: ~[],\n     };\n \n-    visit_crate(crate, ctxt, mk_vt(@Visitor {\n-        visit_item: |item, ctxt, visitor| find_item(item, ctxt, visitor),\n+    visit_crate(crate, (ctxt, mk_vt(@Visitor {\n+        visit_item: |item, (ctxt, visitor)| find_item(item, ctxt, visitor),\n         .. *default_visitor()\n-    }));\n+    })));\n \n     configure_main(ctxt);\n }\n@@ -114,7 +114,7 @@ fn find_item(item: @item, ctxt: @mut EntryContext, visitor: EntryVisitor) {\n         _ => ()\n     }\n \n-    visit_item(item, ctxt, visitor);\n+    visit_item(item, (ctxt, visitor));\n }\n \n fn configure_main(ctxt: @mut EntryContext) {"}, {"sha": "e18143042b0eeab414b2b540a2fb3af1814bebcd", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -40,12 +40,12 @@ fn collect_freevars(def_map: resolve::DefMap, blk: &ast::blk)\n     let seen = @mut HashMap::new();\n     let refs = @mut ~[];\n \n-    fn ignore_item(_i: @ast::item, _depth: int, _v: visit::vt<int>) { }\n+    fn ignore_item(_i: @ast::item, (_depth, _v): (int, visit::vt<int>)) { }\n \n-    let walk_expr: @fn(expr: @ast::expr, depth: int, v: visit::vt<int>) =\n-        |expr, depth, v| {\n+    let walk_expr: @fn(expr: @ast::expr, (int, visit::vt<int>)) =\n+        |expr, (depth, v)| {\n             match expr.node {\n-              ast::expr_fn_block(*) => visit::visit_expr(expr, depth + 1, v),\n+              ast::expr_fn_block(*) => visit::visit_expr(expr, (depth + 1, v)),\n               ast::expr_path(*) | ast::expr_self => {\n                   let mut i = 0;\n                   match def_map.find(&expr.id) {\n@@ -72,14 +72,14 @@ fn collect_freevars(def_map: resolve::DefMap, blk: &ast::blk)\n                     }\n                   }\n               }\n-              _ => visit::visit_expr(expr, depth, v)\n+              _ => visit::visit_expr(expr, (depth, v))\n             }\n         };\n \n     let v = visit::mk_vt(@visit::Visitor {visit_item: ignore_item,\n                                           visit_expr: walk_expr,\n                                           .. *visit::default_visitor()});\n-    (v.visit_block)(blk, 1, v);\n+    (v.visit_block)(blk, (1, v));\n     return @/*bad*/copy *refs;\n }\n \n@@ -105,7 +105,7 @@ pub fn annotate_freevars(def_map: resolve::DefMap, crate: @ast::crate) ->\n         visit::mk_simple_visitor(@visit::SimpleVisitor {\n             visit_fn: walk_fn,\n             .. *visit::default_simple_visitor()});\n-    visit::visit_crate(crate, (), visitor);\n+    visit::visit_crate(crate, ((), visitor));\n \n     return freevars;\n }\n@@ -118,5 +118,5 @@ pub fn get_freevars(tcx: ty::ctxt, fid: ast::node_id) -> freevar_info {\n }\n \n pub fn has_freevars(tcx: ty::ctxt, fid: ast::node_id) -> bool {\n-    return vec::len(*get_freevars(tcx, fid)) != 0u;\n+    !get_freevars(tcx, fid).is_empty()\n }"}, {"sha": "70ad0e1c3a9f59006d4e5e8f921c1bb48a59d6e3", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 56, "deletions": 67, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -12,12 +12,12 @@ use core::prelude::*;\n \n use middle::freevars::freevar_entry;\n use middle::freevars;\n-use middle::pat_util;\n use middle::ty;\n use middle::typeck;\n use util::ppaux::{Repr, ty_to_str};\n use util::ppaux::UserString;\n \n+use core::vec;\n use syntax::ast::*;\n use syntax::attr::attrs_contains_name;\n use syntax::codemap::span;\n@@ -70,15 +70,14 @@ pub fn check_crate(tcx: ty::ctxt,\n         current_item: -1\n     };\n     let visit = visit::mk_vt(@visit::Visitor {\n-        visit_arm: check_arm,\n         visit_expr: check_expr,\n         visit_fn: check_fn,\n         visit_ty: check_ty,\n         visit_item: check_item,\n         visit_block: check_block,\n         .. *visit::default_visitor()\n     });\n-    visit::visit_crate(crate, ctx, visit);\n+    visit::visit_crate(crate, (ctx, visit));\n     tcx.sess.abort_if_errors();\n }\n \n@@ -114,11 +113,11 @@ fn check_struct_safe_for_destructor(cx: Context,\n     }\n }\n \n-fn check_block(block: &blk, cx: Context, visitor: visit::vt<Context>) {\n-    visit::visit_block(block, cx, visitor);\n+fn check_block(block: &blk, (cx, visitor): (Context, visit::vt<Context>)) {\n+    visit::visit_block(block, (cx, visitor));\n }\n \n-fn check_item(item: @item, cx: Context, visitor: visit::vt<Context>) {\n+fn check_item(item: @item, (cx, visitor): (Context, visit::vt<Context>)) {\n     // If this is a destructor, check kinds.\n     if !attrs_contains_name(item.attrs, \"unsafe_destructor\") {\n         match item.node {\n@@ -157,7 +156,7 @@ fn check_item(item: @item, cx: Context, visitor: visit::vt<Context>) {\n     }\n \n     let cx = Context { current_item: item.id, ..cx };\n-    visit::visit_item(item, cx, visitor);\n+    visit::visit_item(item, (cx, visitor));\n }\n \n // Yields the appropriate function to check the kind of closed over\n@@ -224,8 +223,8 @@ fn check_fn(\n     body: &blk,\n     sp: span,\n     fn_id: node_id,\n-    cx: Context,\n-    v: visit::vt<Context>) {\n+    (cx, v): (Context,\n+              visit::vt<Context>)) {\n \n     // Check kinds on free variables:\n     do with_appropriate_checker(cx, fn_id) |chk| {\n@@ -234,57 +233,46 @@ fn check_fn(\n         }\n     }\n \n-    visit::visit_fn(fk, decl, body, sp, fn_id, cx, v);\n-}\n-\n-fn check_arm(a: &arm, cx: Context, v: visit::vt<Context>) {\n-    for a.pats.each |p| {\n-        do pat_util::pat_bindings(cx.tcx.def_map, *p) |mode, id, span, _pth| {\n-            if mode == bind_by_copy {\n-                let t = ty::node_id_to_type(cx.tcx, id);\n-                let reason = \"consider binding with `ref` or `move` instead\";\n-                check_copy(cx, t, span, reason);\n-            }\n-        }\n-    }\n-    visit::visit_arm(a, cx, v);\n+    visit::visit_fn(fk, decl, body, sp, fn_id, (cx, v));\n }\n \n-pub fn check_expr(e: @expr, cx: Context, v: visit::vt<Context>) {\n+pub fn check_expr(e: @expr, (cx, v): (Context, visit::vt<Context>)) {\n     debug!(\"kind::check_expr(%s)\", expr_to_str(e, cx.tcx.sess.intr()));\n \n     // Handle any kind bounds on type parameters\n-    let type_parameter_id = match e.node {\n-        expr_index(*)|expr_assign_op(*)|\n-        expr_unary(*)|expr_binary(*)|expr_method_call(*) => e.callee_id,\n-        _ => e.id\n+    let type_parameter_id = match e.get_callee_id() {\n+        Some(callee_id) => callee_id,\n+        None => e.id,\n     };\n-    for cx.tcx.node_type_substs.find(&type_parameter_id).each |ts| {\n-        let type_param_defs = match e.node {\n-          expr_path(_) => {\n-            let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&e.id));\n-            ty::lookup_item_type(cx.tcx, did).generics.type_param_defs\n-          }\n-          _ => {\n-            // Type substitutions should only occur on paths and\n-            // method calls, so this needs to be a method call.\n-\n-            // Even though the callee_id may have been the id with\n-            // node_type_substs, e.id is correct here.\n-            ty::method_call_type_param_defs(cx.tcx, cx.method_map, e.id).expect(\n-                \"non path/method call expr has type substs??\")\n-          }\n-        };\n-        if ts.len() != type_param_defs.len() {\n-            // Fail earlier to make debugging easier\n-            fail!(\"internal error: in kind::check_expr, length \\\n-                  mismatch between actual and declared bounds: actual = \\\n-                  %s, declared = %s\",\n-                  ts.repr(cx.tcx),\n-                  type_param_defs.repr(cx.tcx));\n-        }\n-        for vec::each2(**ts, *type_param_defs) |&ty, type_param_def| {\n-            check_bounds(cx, type_parameter_id, e.span, ty, type_param_def)\n+    {\n+        let r = cx.tcx.node_type_substs.find(&type_parameter_id);\n+        for r.iter().advance |ts| {\n+            let type_param_defs = match e.node {\n+              expr_path(_) => {\n+                let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&e.id));\n+                ty::lookup_item_type(cx.tcx, did).generics.type_param_defs\n+              }\n+              _ => {\n+                // Type substitutions should only occur on paths and\n+                // method calls, so this needs to be a method call.\n+\n+                // Even though the callee_id may have been the id with\n+                // node_type_substs, e.id is correct here.\n+                ty::method_call_type_param_defs(cx.tcx, cx.method_map, e.id).expect(\n+                    \"non path/method call expr has type substs??\")\n+              }\n+            };\n+            if ts.len() != type_param_defs.len() {\n+                // Fail earlier to make debugging easier\n+                fail!(\"internal error: in kind::check_expr, length \\\n+                      mismatch between actual and declared bounds: actual = \\\n+                      %s, declared = %s\",\n+                      ts.repr(cx.tcx),\n+                      type_param_defs.repr(cx.tcx));\n+            }\n+            for ts.iter().zip(type_param_defs.iter()).advance |(&ty, type_param_def)| {\n+                check_bounds(cx, type_parameter_id, e.span, ty, type_param_def)\n+            }\n         }\n     }\n \n@@ -314,24 +302,25 @@ pub fn check_expr(e: @expr, cx: Context, v: visit::vt<Context>) {\n         }\n         _ => {}\n     }\n-    visit::visit_expr(e, cx, v);\n+    visit::visit_expr(e, (cx, v));\n }\n \n-fn check_ty(aty: @Ty, cx: Context, v: visit::vt<Context>) {\n+fn check_ty(aty: @Ty, (cx, v): (Context, visit::vt<Context>)) {\n     match aty.node {\n       ty_path(_, id) => {\n-        for cx.tcx.node_type_substs.find(&id).each |ts| {\n-            let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&id));\n-            let type_param_defs =\n-                ty::lookup_item_type(cx.tcx, did).generics.type_param_defs;\n-            for vec::each2(**ts, *type_param_defs) |&ty, type_param_def| {\n-                check_bounds(cx, aty.id, aty.span, ty, type_param_def)\n-            }\n-        }\n+          let r = cx.tcx.node_type_substs.find(&id);\n+          for r.iter().advance |ts| {\n+              let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&id));\n+              let type_param_defs =\n+                  ty::lookup_item_type(cx.tcx, did).generics.type_param_defs;\n+              for ts.iter().zip(type_param_defs.iter()).advance |(&ty, type_param_def)| {\n+                  check_bounds(cx, aty.id, aty.span, ty, type_param_def)\n+              }\n+          }\n       }\n       _ => {}\n     }\n-    visit::visit_ty(aty, cx, v);\n+    visit::visit_ty(aty, (cx, v));\n }\n \n pub fn check_bounds(cx: Context,\n@@ -362,7 +351,7 @@ fn is_nullary_variant(cx: Context, ex: @expr) -> bool {\n       expr_path(_) => {\n         match cx.tcx.def_map.get_copy(&ex.id) {\n           def_variant(edid, vdid) => {\n-              vec::len(ty::enum_variant_with_id(cx.tcx, edid, vdid).args) == 0u\n+              ty::enum_variant_with_id(cx.tcx, edid, vdid).args.is_empty()\n           }\n           _ => false\n         }\n@@ -420,7 +409,7 @@ pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n         match ty::get(ty).sty {\n           ty::ty_param(*) => {\n             tcx.sess.span_err(sp, \"value may contain borrowed \\\n-                                   pointers; use `'static` bound\");\n+                                   pointers; add `'static` bound\");\n           }\n           _ => {\n             tcx.sess.span_err(sp, \"value may contain borrowed \\"}, {"sha": "7f54e265b7baf3df5ea8e1597524f5301f513056", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 144, "deletions": 134, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -36,59 +36,60 @@ pub enum LangItem {\n     ConstTraitLangItem,         // 0\n     CopyTraitLangItem,          // 1\n     OwnedTraitLangItem,         // 2\n+    SizedTraitLangItem,         // 3\n \n-    DropTraitLangItem,          // 3\n+    DropTraitLangItem,          // 4\n \n-    AddTraitLangItem,           // 4\n-    SubTraitLangItem,           // 5\n-    MulTraitLangItem,           // 6\n-    DivTraitLangItem,           // 7\n-    RemTraitLangItem,           // 8\n-    NegTraitLangItem,           // 9\n-    NotTraitLangItem,           // 10\n+    AddTraitLangItem,           // 5\n+    SubTraitLangItem,           // 6\n+    MulTraitLangItem,           // 7\n+    DivTraitLangItem,           // 8\n+    RemTraitLangItem,           // 9\n+    NegTraitLangItem,           // 10\n+    NotTraitLangItem,           // 11\n     BitXorTraitLangItem,        // 11\n-    BitAndTraitLangItem,        // 12\n-    BitOrTraitLangItem,         // 13\n-    ShlTraitLangItem,           // 14\n-    ShrTraitLangItem,           // 15\n-    IndexTraitLangItem,         // 16\n-\n-    EqTraitLangItem,            // 17\n-    OrdTraitLangItem,           // 18\n-\n-    StrEqFnLangItem,            // 19\n-    UniqStrEqFnLangItem,        // 20\n-    AnnihilateFnLangItem,       // 21\n-    LogTypeFnLangItem,          // 22\n-    FailFnLangItem,             // 23\n-    FailBoundsCheckFnLangItem,  // 24\n-    ExchangeMallocFnLangItem,   // 25\n-    ExchangeFreeFnLangItem,     // 26\n-    MallocFnLangItem,           // 27\n-    FreeFnLangItem,             // 28\n-    BorrowAsImmFnLangItem,      // 29\n-    BorrowAsMutFnLangItem,      // 30\n-    ReturnToMutFnLangItem,      // 31\n-    CheckNotBorrowedFnLangItem, // 32\n-    StrDupUniqFnLangItem,       // 33\n-    RecordBorrowFnLangItem,     // 34\n-    UnrecordBorrowFnLangItem,   // 35\n-\n-    StartFnLangItem,            // 36\n+    BitAndTraitLangItem,        // 13\n+    BitOrTraitLangItem,         // 14\n+    ShlTraitLangItem,           // 15\n+    ShrTraitLangItem,           // 16\n+    IndexTraitLangItem,         // 17\n+\n+    EqTraitLangItem,            // 18\n+    OrdTraitLangItem,           // 19\n+\n+    StrEqFnLangItem,            // 20\n+    UniqStrEqFnLangItem,        // 21\n+    AnnihilateFnLangItem,       // 22\n+    LogTypeFnLangItem,          // 23\n+    FailFnLangItem,             // 24\n+    FailBoundsCheckFnLangItem,  // 25\n+    ExchangeMallocFnLangItem,   // 26\n+    ExchangeFreeFnLangItem,     // 27\n+    MallocFnLangItem,           // 28\n+    FreeFnLangItem,             // 29\n+    BorrowAsImmFnLangItem,      // 30\n+    BorrowAsMutFnLangItem,      // 31\n+    ReturnToMutFnLangItem,      // 32\n+    CheckNotBorrowedFnLangItem, // 33\n+    StrDupUniqFnLangItem,       // 34\n+    RecordBorrowFnLangItem,     // 35\n+    UnrecordBorrowFnLangItem,   // 36\n+\n+    StartFnLangItem,            // 37\n }\n \n pub struct LanguageItems {\n-    items: [Option<def_id>, ..37]\n+    items: [Option<def_id>, ..38]\n }\n \n-pub impl LanguageItems {\n+impl LanguageItems {\n     pub fn new() -> LanguageItems {\n         LanguageItems {\n-            items: [ None, ..37 ]\n+            items: [ None, ..38 ]\n         }\n     }\n \n-    fn each_item(&self, f: &fn(def_id: def_id, i: uint) -> bool) -> bool {\n+    pub fn each_item(&self, f: &fn(def_id: def_id, i: uint) -> bool) -> bool {\n         self.items.eachi(|i, &item| f(item.get(), i))\n     }\n \n@@ -97,44 +98,45 @@ pub impl LanguageItems {\n             0  => \"const\",\n             1  => \"copy\",\n             2  => \"owned\",\n-\n-            3  => \"drop\",\n-\n-            4  => \"add\",\n-            5  => \"sub\",\n-            6  => \"mul\",\n-            7  => \"div\",\n-            8  => \"rem\",\n-            9 => \"neg\",\n-            10 => \"not\",\n-            11 => \"bitxor\",\n-            12 => \"bitand\",\n-            13 => \"bitor\",\n-            14 => \"shl\",\n-            15 => \"shr\",\n-            16 => \"index\",\n-            17 => \"eq\",\n-            18 => \"ord\",\n-\n-            19 => \"str_eq\",\n-            20 => \"uniq_str_eq\",\n-            21 => \"annihilate\",\n-            22 => \"log_type\",\n-            23 => \"fail_\",\n-            24 => \"fail_bounds_check\",\n-            25 => \"exchange_malloc\",\n-            26 => \"exchange_free\",\n-            27 => \"malloc\",\n-            28 => \"free\",\n-            29 => \"borrow_as_imm\",\n-            30 => \"borrow_as_mut\",\n-            31 => \"return_to_mut\",\n-            32 => \"check_not_borrowed\",\n-            33 => \"strdup_uniq\",\n-            34 => \"record_borrow\",\n-            35 => \"unrecord_borrow\",\n-\n-            36 => \"start\",\n+            3  => \"sized\",\n+\n+            4  => \"drop\",\n+\n+            5  => \"add\",\n+            6  => \"sub\",\n+            7  => \"mul\",\n+            8  => \"div\",\n+            9  => \"rem\",\n+            10 => \"neg\",\n+            11 => \"not\",\n+            12 => \"bitxor\",\n+            13 => \"bitand\",\n+            14 => \"bitor\",\n+            15 => \"shl\",\n+            16 => \"shr\",\n+            17 => \"index\",\n+            18 => \"eq\",\n+            19 => \"ord\",\n+\n+            20 => \"str_eq\",\n+            21 => \"uniq_str_eq\",\n+            22 => \"annihilate\",\n+            23 => \"log_type\",\n+            24 => \"fail_\",\n+            25 => \"fail_bounds_check\",\n+            26 => \"exchange_malloc\",\n+            27 => \"exchange_free\",\n+            28 => \"malloc\",\n+            29 => \"free\",\n+            30 => \"borrow_as_imm\",\n+            31 => \"borrow_as_mut\",\n+            32 => \"return_to_mut\",\n+            33 => \"check_not_borrowed\",\n+            34 => \"strdup_uniq\",\n+            35 => \"record_borrow\",\n+            36 => \"unrecord_borrow\",\n+\n+            37 => \"start\",\n \n             _ => \"???\"\n         }\n@@ -151,6 +153,9 @@ pub impl LanguageItems {\n     pub fn owned_trait(&const self) -> def_id {\n         self.items[OwnedTraitLangItem as uint].get()\n     }\n+    pub fn sized_trait(&const self) -> def_id {\n+        self.items[SizedTraitLangItem as uint].get()\n+    }\n \n     pub fn drop_trait(&const self) -> def_id {\n         self.items[DropTraitLangItem as uint].get()\n@@ -264,49 +269,50 @@ fn LanguageItemCollector(crate: @crate,\n                       -> LanguageItemCollector {\n     let mut item_refs = HashMap::new();\n \n-    item_refs.insert(@~\"const\", ConstTraitLangItem as uint);\n-    item_refs.insert(@~\"copy\", CopyTraitLangItem as uint);\n-    item_refs.insert(@~\"owned\", OwnedTraitLangItem as uint);\n-\n-    item_refs.insert(@~\"drop\", DropTraitLangItem as uint);\n-\n-    item_refs.insert(@~\"add\", AddTraitLangItem as uint);\n-    item_refs.insert(@~\"sub\", SubTraitLangItem as uint);\n-    item_refs.insert(@~\"mul\", MulTraitLangItem as uint);\n-    item_refs.insert(@~\"div\", DivTraitLangItem as uint);\n-    item_refs.insert(@~\"rem\", RemTraitLangItem as uint);\n-    item_refs.insert(@~\"neg\", NegTraitLangItem as uint);\n-    item_refs.insert(@~\"not\", NotTraitLangItem as uint);\n-    item_refs.insert(@~\"bitxor\", BitXorTraitLangItem as uint);\n-    item_refs.insert(@~\"bitand\", BitAndTraitLangItem as uint);\n-    item_refs.insert(@~\"bitor\", BitOrTraitLangItem as uint);\n-    item_refs.insert(@~\"shl\", ShlTraitLangItem as uint);\n-    item_refs.insert(@~\"shr\", ShrTraitLangItem as uint);\n-    item_refs.insert(@~\"index\", IndexTraitLangItem as uint);\n-\n-    item_refs.insert(@~\"eq\", EqTraitLangItem as uint);\n-    item_refs.insert(@~\"ord\", OrdTraitLangItem as uint);\n-\n-    item_refs.insert(@~\"str_eq\", StrEqFnLangItem as uint);\n-    item_refs.insert(@~\"uniq_str_eq\", UniqStrEqFnLangItem as uint);\n-    item_refs.insert(@~\"annihilate\", AnnihilateFnLangItem as uint);\n-    item_refs.insert(@~\"log_type\", LogTypeFnLangItem as uint);\n-    item_refs.insert(@~\"fail_\", FailFnLangItem as uint);\n-    item_refs.insert(@~\"fail_bounds_check\",\n+    item_refs.insert(@\"const\", ConstTraitLangItem as uint);\n+    item_refs.insert(@\"copy\", CopyTraitLangItem as uint);\n+    item_refs.insert(@\"owned\", OwnedTraitLangItem as uint);\n+    item_refs.insert(@\"sized\", SizedTraitLangItem as uint);\n+\n+    item_refs.insert(@\"drop\", DropTraitLangItem as uint);\n+\n+    item_refs.insert(@\"add\", AddTraitLangItem as uint);\n+    item_refs.insert(@\"sub\", SubTraitLangItem as uint);\n+    item_refs.insert(@\"mul\", MulTraitLangItem as uint);\n+    item_refs.insert(@\"div\", DivTraitLangItem as uint);\n+    item_refs.insert(@\"rem\", RemTraitLangItem as uint);\n+    item_refs.insert(@\"neg\", NegTraitLangItem as uint);\n+    item_refs.insert(@\"not\", NotTraitLangItem as uint);\n+    item_refs.insert(@\"bitxor\", BitXorTraitLangItem as uint);\n+    item_refs.insert(@\"bitand\", BitAndTraitLangItem as uint);\n+    item_refs.insert(@\"bitor\", BitOrTraitLangItem as uint);\n+    item_refs.insert(@\"shl\", ShlTraitLangItem as uint);\n+    item_refs.insert(@\"shr\", ShrTraitLangItem as uint);\n+    item_refs.insert(@\"index\", IndexTraitLangItem as uint);\n+\n+    item_refs.insert(@\"eq\", EqTraitLangItem as uint);\n+    item_refs.insert(@\"ord\", OrdTraitLangItem as uint);\n+\n+    item_refs.insert(@\"str_eq\", StrEqFnLangItem as uint);\n+    item_refs.insert(@\"uniq_str_eq\", UniqStrEqFnLangItem as uint);\n+    item_refs.insert(@\"annihilate\", AnnihilateFnLangItem as uint);\n+    item_refs.insert(@\"log_type\", LogTypeFnLangItem as uint);\n+    item_refs.insert(@\"fail_\", FailFnLangItem as uint);\n+    item_refs.insert(@\"fail_bounds_check\",\n                      FailBoundsCheckFnLangItem as uint);\n-    item_refs.insert(@~\"exchange_malloc\", ExchangeMallocFnLangItem as uint);\n-    item_refs.insert(@~\"exchange_free\", ExchangeFreeFnLangItem as uint);\n-    item_refs.insert(@~\"malloc\", MallocFnLangItem as uint);\n-    item_refs.insert(@~\"free\", FreeFnLangItem as uint);\n-    item_refs.insert(@~\"borrow_as_imm\", BorrowAsImmFnLangItem as uint);\n-    item_refs.insert(@~\"borrow_as_mut\", BorrowAsMutFnLangItem as uint);\n-    item_refs.insert(@~\"return_to_mut\", ReturnToMutFnLangItem as uint);\n-    item_refs.insert(@~\"check_not_borrowed\",\n+    item_refs.insert(@\"exchange_malloc\", ExchangeMallocFnLangItem as uint);\n+    item_refs.insert(@\"exchange_free\", ExchangeFreeFnLangItem as uint);\n+    item_refs.insert(@\"malloc\", MallocFnLangItem as uint);\n+    item_refs.insert(@\"free\", FreeFnLangItem as uint);\n+    item_refs.insert(@\"borrow_as_imm\", BorrowAsImmFnLangItem as uint);\n+    item_refs.insert(@\"borrow_as_mut\", BorrowAsMutFnLangItem as uint);\n+    item_refs.insert(@\"return_to_mut\", ReturnToMutFnLangItem as uint);\n+    item_refs.insert(@\"check_not_borrowed\",\n                      CheckNotBorrowedFnLangItem as uint);\n-    item_refs.insert(@~\"strdup_uniq\", StrDupUniqFnLangItem as uint);\n-    item_refs.insert(@~\"record_borrow\", RecordBorrowFnLangItem as uint);\n-    item_refs.insert(@~\"unrecord_borrow\", UnrecordBorrowFnLangItem as uint);\n-    item_refs.insert(@~\"start\", StartFnLangItem as uint);\n+    item_refs.insert(@\"strdup_uniq\", StrDupUniqFnLangItem as uint);\n+    item_refs.insert(@\"record_borrow\", RecordBorrowFnLangItem as uint);\n+    item_refs.insert(@\"unrecord_borrow\", UnrecordBorrowFnLangItem as uint);\n+    item_refs.insert(@\"start\", StartFnLangItem as uint);\n \n     LanguageItemCollector {\n         crate: crate,\n@@ -322,12 +328,13 @@ struct LanguageItemCollector {\n     crate: @crate,\n     session: Session,\n \n-    item_refs: HashMap<@~str, uint>,\n+    item_refs: HashMap<@str, uint>,\n }\n \n-pub impl LanguageItemCollector {\n-    fn match_and_collect_meta_item(&mut self, item_def_id: def_id,\n-                                   meta_item: @meta_item) {\n+impl LanguageItemCollector {\n+    pub fn match_and_collect_meta_item(&mut self,\n+                                       item_def_id: def_id,\n+                                       meta_item: @meta_item) {\n         match meta_item.node {\n             meta_name_value(key, literal) => {\n                 match literal.node {\n@@ -341,7 +348,7 @@ pub impl LanguageItemCollector {\n         }\n     }\n \n-    fn collect_item(&mut self, item_index: uint, item_def_id: def_id) {\n+    pub fn collect_item(&mut self, item_index: uint, item_def_id: def_id) {\n         // Check for duplicates.\n         match self.items.items[item_index] {\n             Some(original_def_id) if original_def_id != item_def_id => {\n@@ -357,9 +364,11 @@ pub impl LanguageItemCollector {\n         self.items.items[item_index] = Some(item_def_id);\n     }\n \n-    fn match_and_collect_item(&mut self,\n-                              item_def_id: def_id, key: @~str, value: @~str) {\n-        if *key != ~\"lang\" {\n+    pub fn match_and_collect_item(&mut self,\n+                                  item_def_id: def_id,\n+                                  key: @str,\n+                                  value: @str) {\n+        if \"lang\" != key {\n             return;    // Didn't match.\n         }\n \n@@ -378,9 +387,9 @@ pub impl LanguageItemCollector {\n         }\n     }\n \n-    fn collect_local_language_items(&mut self) {\n+    pub fn collect_local_language_items(&mut self) {\n         let this: *mut LanguageItemCollector = &mut *self;\n-        visit_crate(self.crate, (), mk_simple_visitor(@SimpleVisitor {\n+        visit_crate(self.crate, ((), mk_simple_visitor(@SimpleVisitor {\n             visit_item: |item| {\n                 for item.attrs.each |attribute| {\n                     unsafe {\n@@ -392,10 +401,10 @@ pub impl LanguageItemCollector {\n                 }\n             },\n             .. *default_simple_visitor()\n-        }));\n+        })));\n     }\n \n-    fn collect_external_language_items(&mut self) {\n+    pub fn collect_external_language_items(&mut self) {\n         let crate_store = self.session.cstore;\n         do iter_crate_data(crate_store) |crate_number, _crate_metadata| {\n             for each_lang_item(crate_store, crate_number)\n@@ -406,11 +415,11 @@ pub impl LanguageItemCollector {\n         }\n     }\n \n-    fn check_completeness(&self) {\n+    pub fn check_completeness(&self) {\n         for self.item_refs.each |&key, &item_ref| {\n             match self.items.items[item_ref] {\n                 None => {\n-                    self.session.err(fmt!(\"no item found for `%s`\", *key));\n+                    self.session.err(fmt!(\"no item found for `%s`\", key));\n                 }\n                 Some(_) => {\n                     // OK.\n@@ -419,7 +428,7 @@ pub impl LanguageItemCollector {\n         }\n     }\n \n-    fn collect(&mut self) {\n+    pub fn collect(&mut self) {\n         self.collect_local_language_items();\n         self.collect_external_language_items();\n         self.check_completeness();\n@@ -432,5 +441,6 @@ pub fn collect_language_items(crate: @crate,\n     let mut collector = LanguageItemCollector(crate, session);\n     collector.collect();\n     let LanguageItemCollector { items, _ } = collector;\n+    session.abort_if_errors();\n     items\n }"}, {"sha": "c0421b2d474827aae8770b30eefe067d0fb2e2ac", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 197, "deletions": 132, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f", "patch": "@@ -15,7 +15,18 @@ use middle::ty;\n use middle::pat_util;\n use util::ppaux::{ty_to_str};\n \n+use core::char;\n+use core::cmp;\n use core::hashmap::HashMap;\n+use core::i16;\n+use core::i32;\n+use core::i64;\n+use core::i8;\n+use core::u16;\n+use core::u32;\n+use core::u64;\n+use core::u8;\n+use core::vec;\n use extra::smallintmap::SmallIntMap;\n use syntax::attr;\n use syntax::codemap::span;\n@@ -83,8 +94,8 @@ pub enum lint {\n     unused_mut,\n     unnecessary_allocation,\n \n-    missing_struct_doc,\n-    missing_trait_doc,\n+    missing_doc,\n+    unreachable_code,\n }\n \n pub fn level_to_str(lv: level) -> &'static str {\n@@ -107,7 +118,7 @@ struct LintSpec {\n     default: level\n }\n \n-pub type LintDict = HashMap<~str, LintSpec>;\n+pub type LintDict = HashMap<&'static str, LintSpec>;\n \n enum AttributedNode<'self> {\n     Item(@ast::item),\n@@ -256,18 +267,18 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         default: warn\n     }),\n \n-    (\"missing_struct_doc\",\n+    (\"missing_doc\",\n      LintSpec {\n-        lint: missing_struct_doc,\n-        desc: \"detects missing documentation for structs\",\n+        lint: missing_doc,\n+        desc: \"detects missing documentation for public members\",\n         default: allow\n     }),\n \n-    (\"missing_trait_doc\",\n+    (\"unreachable_code\",\n      LintSpec {\n-        lint: missing_trait_doc,\n-        desc: \"detects missing documentation for traits\",\n-        default: allow\n+        lint: unreachable_code,\n+        desc: \"detects unreachable code\",\n+        default: warn\n     }),\n ];\n \n@@ -278,7 +289,7 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n pub fn get_lint_dict() -> LintDict {\n     let mut map = HashMap::new();\n     for lint_table.each|&(k, v)| {\n-        map.insert(k.to_str(), v);\n+        map.insert(k, v);\n     }\n     return map;\n }\n@@ -290,6 +301,13 @@ struct Context {\n     curr: SmallIntMap<(level, LintSource)>,\n     // context we're checking in (used to access fields like sess)\n     tcx: ty::ctxt,\n+    // Just a simple flag if we're currently recursing into a trait\n+    // implementation. This is only used by the lint_missing_doc() pass\n+    in_trait_impl: bool,\n+    // Another flag for doc lint emissions. Does some parent of the current node\n+    // have the doc(hidden) attribute? Treating this as allow(missing_doc) would\n+    // play badly with forbid(missing_doc) when it shouldn't.\n+    doc_hidden: bool,\n     // When recursing into an attributed node of the ast which modifies lint\n     // levels, this stack keeps track of the previous lint levels of whatever\n     // was modified.\n@@ -299,7 +317,15 @@ struct Context {\n     // Others operate directly on @ast::item structures (or similar). Finally,\n     // others still are added to the Session object via `add_lint`, and these\n     // are all passed with the lint_session visitor.\n-    visitors: ~[visit::vt<@mut Context>],\n+    //\n+    // This is a pair so every visitor can visit every node. When a lint pass is\n+    // registered, another visitor is created which stops at all items which can\n+    // alter the attributes of the ast. This \"item stopping visitor\" is the\n+    // second element of the pair, while the original visitor is the first\n+    // element. This means that when visiting a node, the original recursive\n+    // call can used the original visitor's method, although the recursing\n+    // visitor supplied to the method is the item stopping visitor.\n+    visitors: ~[(visit::vt<@mut Context>, visit::vt<@mut Context>)],\n }\n \n impl Context {\n@@ -325,10 +351,10 @@ impl Context {\n         }\n     }\n \n-    fn lint_to_str(&self, lint: lint) -> ~str {\n+    fn lint_to_str(&self, lint: lint) -> &'static str {\n         for self.dict.each |k, v| {\n             if v.lint == lint {\n-                return copy *k;\n+                return *k;\n             }\n         }\n         fail!(\"unregistered lint %?\", lint);\n@@ -347,7 +373,7 @@ impl Context {\n                 fmt!(\"%s [-%c %s%s]\", msg, match level {\n                         warn => 'W', deny => 'D', forbid => 'F',\n                         allow => fail!()\n-                    }, str::replace(self.lint_to_str(lint), \"_\", \"-\"),\n+                    }, self.lint_to_str(lint).replace(\"_\", \"-\"),\n                     if src == Default { \" (default)\" } else { \"\" })\n             },\n             Node(src) => {\n@@ -361,7 +387,7 @@ impl Context {\n             allow => fail!(),\n         }\n \n-        for note.each |&span| {\n+        for note.iter().advance |&span| {\n             self.tcx.sess.span_note(span, \"lint level defined here\");\n         }\n     }\n@@ -378,13 +404,13 @@ impl Context {\n         // specified closure\n         let mut pushed = 0u;\n         for each_lint(self.tcx.sess, attrs) |meta, level, lintname| {\n-            let lint = match self.dict.find(lintname) {\n+            let lint = match self.dict.find_equiv(&lintname) {\n               None => {\n                 self.span_lint(\n                     unrecognized_lint,\n                     meta.span,\n                     fmt!(\"unknown `%s` attribute: `%s`\",\n-                         level_to_str(level), *lintname));\n+                         level_to_str(level), lintname));\n                 loop\n               }\n               Some(lint) => { lint.lint }\n@@ -395,7 +421,7 @@ impl Context {\n                 self.tcx.sess.span_err(meta.span,\n                     fmt!(\"%s(%s) overruled by outer forbid(%s)\",\n                          level_to_str(level),\n-                         *lintname, *lintname));\n+                         lintname, lintname));\n                 loop;\n             }\n \n@@ -407,39 +433,62 @@ impl Context {\n             }\n         }\n \n+        // detect doc(hidden)\n+        let mut doc_hidden = false;\n+        for attr::find_attrs_by_name(attrs, \"doc\").each |attr| {\n+            match attr::get_meta_item_list(attr.node.value) {\n+                Some(s) => {\n+                    if attr::find_meta_items_by_name(s, \"hidden\").len() > 0 {\n+                        doc_hidden = true;\n+                    }\n+                }\n+                None => {}\n+            }\n+        }\n+        if doc_hidden && !self.doc_hidden {\n+            self.doc_hidden = true;\n+        } else {\n+            doc_hidden = false;\n+        }\n+\n         f();\n \n         // rollback\n+        if doc_hidden && self.doc_hidden {\n+            self.doc_hidden = false;\n+        }\n         for pushed.times {\n             let (lint, lvl, src) = self.lint_stack.pop();\n             self.set_level(lint, lvl, src);\n         }\n     }\n \n     fn add_lint(&mut self, v: visit::vt<@mut Context>) {\n-        self.visitors.push(item_stopping_visitor(v));\n+        self.visitors.push((v, item_stopping_visitor(v)));\n     }\n \n     fn process(@mut self, n: AttributedNode) {\n+        // see comment of the `visitors` field in the struct for why there's a\n+        // pair instead of just one visitor.\n         match n {\n             Item(it) => {\n-                for self.visitors.each |v| {\n-                    visit::visit_item(it, self, *v);\n+                for self.visitors.each |&(orig, stopping)| {\n+                    (orig.visit_item)(it, (self, stopping));\n                 }\n             }\n             Crate(c) => {\n-                for self.visitors.each |v| {\n-                    visit::visit_crate(c, self, *v);\n+                for self.visitors.each |&(_, stopping)| {\n+                    visit::visit_crate(c, (self, stopping));\n                 }\n             }\n             // Can't use visit::visit_method_helper because the\n             // item_stopping_visitor has overridden visit_fn(&fk_method(... ))\n             // to be a no-op, so manually invoke visit_fn.\n             Method(m) => {\n                 let fk = visit::fk_method(copy m.ident, &m.generics, m);\n-                for self.visitors.each |v| {\n-                    visit::visit_fn(&fk, &m.decl, &m.body, m.span, m.id,\n-                                    self, *v);\n+                for self.visitors.each |&(orig, stopping)| {\n+                    (orig.visit_fn)(&fk, &m.decl, &m.body, m.span, m.id,\n+                                    (self, stopping));\n                 }\n             }\n         }\n@@ -448,7 +497,7 @@ impl Context {\n \n pub fn each_lint(sess: session::Session,\n                  attrs: &[ast::attribute],\n-                 f: &fn(@ast::meta_item, level, &~str) -> bool) -> bool\n+                 f: &fn(@ast::meta_item, level, @str) -> bool) -> bool\n {\n     for [allow, warn, deny, forbid].each |&level| {\n         let level_name = level_to_str(level);\n@@ -483,25 +532,25 @@ pub fn each_lint(sess: session::Session,\n // This is used to make the simple visitors used for the lint passes\n // not traverse into subitems, since that is handled by the outer\n // lint visitor.\n-fn item_stopping_visitor<E: Copy>(v: visit::vt<E>) -> visit::vt<E> {\n+fn item_stopping_visitor<E: Copy>(outer: visit::vt<E>) -> visit::vt<E> {\n     visit::mk_vt(@visit::Visitor {\n-        visit_item: |_i, _e, _v| { },\n-        visit_fn: |fk, fd, b, s, id, e, v| {\n+        visit_item: |_i, (_e, _v)| { },\n+        visit_fn: |fk, fd, b, s, id, (e, v)| {\n             match *fk {\n                 visit::fk_method(*) => {}\n-                _ => visit::visit_fn(fk, fd, b, s, id, e, v)\n+                _ => (outer.visit_fn)(fk, fd, b, s, id, (e, v))\n             }\n         },\n-    .. **(ty_stopping_visitor(v))})\n+    .. **(ty_stopping_visitor(outer))})\n }\n \n fn ty_stopping_visitor<E>(v: visit::vt<E>) -> visit::vt<E> {\n-    visit::mk_vt(@visit::Visitor {visit_ty: |_t, _e, _v| { },.. **v})\n+    visit::mk_vt(@visit::Visitor {visit_ty: |_t, (_e, _v)| { },.. **v})\n }\n \n fn lint_while_true() -> visit::vt<@mut Context> {\n     visit::mk_vt(@visit::Visitor {\n-        visit_expr: |e, cx: @mut Context, vt| {\n+        visit_expr: |e, (cx, vt): (@mut Context, visit::vt<@mut Context>)| {\n             match e.node {\n                 ast::expr_while(cond, _) => {\n                     match cond.node {\n@@ -517,7 +566,7 @@ fn lint_while_true() -> visit::vt<@mut Context> {\n                 }\n                 _ => ()\n             }\n-            visit::visit_expr(e, cx, vt);\n+            visit::visit_expr(e, (cx, vt));\n         },\n         .. *visit::default_visitor()\n     })\n@@ -623,9 +672,9 @@ fn lint_type_limits() -> visit::vt<@mut Context> {\n     }\n \n     visit::mk_vt(@visit::Visitor {\n-        visit_expr: |e, cx: @mut Context, vt| {\n+        visit_expr: |e, (cx, vt): (@mut Context, visit::vt<@mut Context>)| {\n             match e.node {\n-                ast::expr_binary(ref binop, @ref l, @ref r) => {\n+                ast::expr_binary(_, ref binop, @ref l, @ref r) => {\n                     if is_comparison(*binop)\n                         && !check_limits(cx, *binop, l, r) {\n                         cx.span_lint(type_limits, e.span,\n@@ -634,7 +683,7 @@ fn lint_type_limits() -> visit::vt<@mut Context> {\n                 }\n                 _ => ()\n             }\n-            visit::visit_expr(e, cx, vt);\n+            visit::visit_expr(e, (cx, vt));\n         },\n \n         .. *visit::default_visitor()\n@@ -759,18 +808,18 @@ fn check_item_heap(cx: &Context, it: @ast::item) {\n \n fn lint_heap() -> visit::vt<@mut Context> {\n     visit::mk_vt(@visit::Visitor {\n-        visit_expr: |e, cx: @mut Context, vt| {\n+        visit_expr: |e, (cx, vt): (@mut Context, visit::vt<@mut Context>)| {\n             let ty = ty::expr_ty(cx.tcx, e);\n             check_type(cx, e.span, ty);\n-            visit::visit_expr(e, cx, vt);\n+            visit::visit_expr(e, (cx, vt));\n         },\n         .. *visit::default_visitor()\n     })\n }\n \n fn lint_path_statement() -> visit::vt<@mut Context> {\n     visit::mk_vt(@visit::Visitor {\n-        visit_stmt: |s, cx: @mut Context, vt| {\n+        visit_stmt: |s, (cx, vt): (@mut Context, visit::vt<@mut Context>)| {\n             match s.node {\n                 ast::stmt_semi(\n                     @ast::expr { node: ast::expr_path(_), _ },\n@@ -781,7 +830,7 @@ fn lint_path_statement() -> visit::vt<@mut Context> {\n                 }\n                 _ => ()\n             }\n-            visit::visit_stmt(s, cx, vt);\n+            visit::visit_stmt(s, (cx, vt));\n         },\n         .. *visit::default_visitor()\n     })\n@@ -791,26 +840,11 @@ fn check_item_non_camel_case_types(cx: &Context, it: @ast::item) {\n     fn is_camel_case(cx: ty::ctxt, ident: ast::ident) -> bool {\n         let ident = cx.sess.str_of(ident);\n         assert!(!ident.is_empty());\n-        let ident = ident_without_trailing_underscores(*ident);\n-        let ident = ident_without_leading_underscores(ident);\n-        char::is_uppercase(str::char_at(ident, 0)) &&\n+        let ident = ident.trim_chars(&'_');\n+        char::is_uppercase(ident.char_at(0)) &&\n             !ident.contains_char('_')\n     }\n \n-    fn ident_without_trailing_underscores<'r>(ident: &'r str) -> &'r str {\n-        match str::rfind(ident, |c| c != '_') {\n-            Some(idx) => str::slice(ident, 0, idx + 1),\n-            None => ident, // all underscores\n-        }\n-    }\n-\n-    fn ident_without_leading_underscores<'r>(ident: &'r str) -> &'r str {\n-        match str::find(ident, |c| c != '_') {\n-            Some(idx) => str::slice(ident, idx, ident.len()),\n-            None => ident // all underscores\n-        }\n-    }\n-\n     fn check_case(cx: &Context, ident: ast::ident, span: span) {\n         if !is_camel_case(cx.tcx, ident) {\n             cx.span_lint(non_camel_case_types, span,\n@@ -836,7 +870,7 @@ fn check_item_non_camel_case_types(cx: &Context, it: @ast::item) {\n \n fn lint_unused_unsafe() -> visit::vt<@mut Context> {\n     visit::mk_vt(@visit::Visitor {\n-        visit_expr: |e, cx: @mut Context, vt| {\n+        visit_expr: |e, (cx, vt): (@mut Context, visit::vt<@mut Context>)| {\n             match e.node {\n                 ast::expr_block(ref blk) if blk.node.rules == ast::unsafe_blk => {\n                     if !cx.tcx.used_unsafe.contains(&blk.node.id) {\n@@ -846,7 +880,7 @@ fn lint_unused_unsafe() -> visit::vt<@mut Context> {\n                 }\n                 _ => ()\n             }\n-            visit::visit_expr(e, cx, vt);\n+            visit::visit_expr(e, (cx, vt));\n         },\n         .. *visit::default_visitor()\n     })\n@@ -879,30 +913,30 @@ fn lint_unused_mut() -> visit::vt<@mut Context> {\n     }\n \n     visit::mk_vt(@visit::Visitor {\n-        visit_local: |l, cx: @mut Context, vt| {\n+        visit_local: |l, (cx, vt): (@mut Context, visit::vt<@mut Context>)| {\n             if l.node.is_mutbl {\n                 check_pat(cx, l.node.pat);\n             }\n-            visit::visit_local(l, cx, vt);\n+            visit::visit_local(l, (cx, vt));\n         },\n-        visit_fn: |a, fd, b, c, d, cx, vt| {\n+        visit_fn: |a, fd, b, c, d, (cx, vt)| {\n             visit_fn_decl(cx, fd);\n-            visit::visit_fn(a, fd, b, c, d, cx, vt);\n+            visit::visit_fn(a, fd, b, c, d, (cx, vt));\n         },\n-        visit_ty_method: |tm, cx, vt| {\n+        visit_ty_method: |tm, (cx, vt)| {\n             visit_fn_decl(cx, &tm.decl);\n-            visit::visit_ty_method(tm, cx, vt);\n+            visit::visit_ty_method(tm, (cx, vt));\n         },\n-        visit_struct_method: |sm, cx, vt| {\n+        visit_struct_method: |sm, (cx, vt)| {\n             visit_fn_decl(cx, &sm.decl);\n-            visit::visit_struct_method(sm, cx, vt);\n+            visit::visit_struct_method(sm, (cx, vt));\n         },\n-        visit_trait_method: |tm, cx, vt| {\n+        visit_trait_method: |tm, (cx, vt)| {\n             match *tm {\n                 ast::required(ref tm) => visit_fn_decl(cx, &tm.decl),\n                 ast::provided(m) => visit_fn_decl(cx, &m.decl)\n             }\n-            visit::visit_trait_method(tm, cx, vt);\n+            visit::visit_trait_method(tm, (cx, vt));\n         },\n         .. *visit::default_visitor()\n     })\n@@ -952,76 +986,99 @@ fn lint_unnecessary_allocations() -> visit::vt<@mut Context> {\n     }\n \n     visit::mk_vt(@visit::Visitor {\n-        visit_expr: |e, cx: @mut Context, vt| {\n+        visit_expr: |e, (cx, vt): (@mut Context, visit::vt<@mut Context>)| {\n             check(cx, e);\n-            visit::visit_expr(e, cx, vt);\n+            visit::visit_expr(e, (cx, vt));\n         },\n         .. *visit::default_visitor()\n     })\n }\n \n-fn lint_missing_struct_doc() -> visit::vt<@mut Context> {\n+fn lint_missing_doc() -> visit::vt<@mut Context> {\n+    fn check_attrs(cx: @mut Context, attrs: &[ast::attribute],\n+                   sp: span, msg: &str) {\n+        // If we're building a test harness, then warning about documentation is\n+        // probably not really relevant right now\n+        if cx.tcx.sess.opts.test { return }\n+        // If we have doc(hidden), nothing to do\n+        if cx.doc_hidden { return }\n+        // If we're documented, nothing to do\n+        if attrs.any(|a| a.node.is_sugared_doc) { return }\n+\n+        // otherwise, warn!\n+        cx.span_lint(missing_doc, sp, msg);\n+    }\n+\n     visit::mk_vt(@visit::Visitor {\n-        visit_struct_field: |field, cx: @mut Context, vt| {\n-            let relevant = match field.node.kind {\n-                ast::named_field(_, vis) => vis != ast::private,\n-                ast::unnamed_field => false,\n-            };\n+        visit_struct_method: |m, (cx, vt)| {\n+            if m.vis == ast::public {\n+                check_attrs(cx, m.attrs, m.span,\n+                            \"missing documentation for a method\");\n+            }\n+            visit::visit_struct_method(m, (cx, vt));\n+        },\n \n-            if relevant {\n-                let mut has_doc = false;\n-                for field.node.attrs.each |attr| {\n-                    if attr.node.is_sugared_doc {\n-                        has_doc = true;\n-                        break;\n+        visit_ty_method: |m, (cx, vt)| {\n+            // All ty_method objects are linted about because they're part of a\n+            // trait (no visibility)\n+            check_attrs(cx, m.attrs, m.span,\n+                        \"missing documentation for a method\");\n+            visit::visit_ty_method(m, (cx, vt));\n+        },\n+\n+        visit_fn: |fk, d, b, sp, id, (cx, vt)| {\n+            // Only warn about explicitly public methods. Soon implicit\n+            // public-ness will hopefully be going away.\n+            match *fk {\n+                visit::fk_method(_, _, m) if m.vis == ast::public => {\n+                    // If we're in a trait implementation, no need to duplicate\n+                    // documentation\n+                    if !cx.in_trait_impl {\n+                        check_attrs(cx, m.attrs, sp,\n+                                    \"missing documentation for a method\");\n                     }\n                 }\n-                if !has_doc {\n-                    cx.span_lint(missing_struct_doc, field.span, \"missing documentation \\\n-                                                                  for a field.\");\n-                }\n-            }\n \n-            visit::visit_struct_field(field, cx, vt);\n+                _ => {}\n+            }\n+            visit::visit_fn(fk, d, b, sp, id, (cx, vt));\n         },\n-        .. *visit::default_visitor()\n-    })\n-}\n \n-fn lint_missing_trait_doc() -> visit::vt<@mut Context> {\n-    visit::mk_vt(@visit::Visitor {\n-        visit_trait_method: |method, cx: @mut Context, vt| {\n-            let mut has_doc = false;\n-            let span = match copy *method {\n-                ast::required(m) => {\n-                    for m.attrs.each |attr| {\n-                        if attr.node.is_sugared_doc {\n-                            has_doc = true;\n-                            break;\n-                        }\n-                    }\n-                    m.span\n-                },\n-                ast::provided(m) => {\n-                    if m.vis == ast::private {\n-                        has_doc = true;\n-                    } else {\n-                        for m.attrs.each |attr| {\n-                            if attr.node.is_sugared_doc {\n-                                has_doc = true;\n-                                break;\n+        visit_item: |it, (cx, vt)| {\n+            match it.node {\n+                // Go ahead and match the fields here instead of using\n+                // visit_struct_field while we have access to the enclosing\n+                // struct's visibility\n+                ast::item_struct(sdef, _) if it.vis == ast::public => {\n+                    check_attrs(cx, it.attrs, it.span,\n+                                \"missing documentation for a struct\");\n+                    for sdef.fields.each |field| {\n+                        match field.node.kind {\n+                            ast::named_field(_, vis) if vis != ast::private => {\n+                                check_attrs(cx, field.node.attrs, field.span,\n+                                            \"missing documentation for a field\");\n                             }\n+                            ast::unnamed_field | ast::named_field(*) => {}\n                         }\n                     }\n-                    m.span\n                 }\n+\n+                ast::item_trait(*) if it.vis == ast::public => {\n+                    check_attrs(cx, it.attrs, it.span,\n+                                \"missing documentation for a trait\");\n+                }\n+\n+                ast::item_fn(*) if it.vis == ast::public => {\n+                    check_attrs(cx, it.attrs, it.span,\n+                                \"missing documentation for a function\");\n+                }\n+\n+                _ => {}\n             };\n-            if !has_doc {\n-                cx.span_lint(missing_trait_doc, span, \"missing documentation \\\n-                                                       for a method.\");\n-            }\n-            visit::visit_trait_method(method, cx, vt);\n+\n+            visit::visit_item(it, (cx, vt));\n         },\n+\n         .. *visit::default_visitor()\n     })\n }\n@@ -1033,6 +1090,8 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n         tcx: tcx,\n         lint_stack: ~[],\n         visitors: ~[],\n+        in_trait_impl: false,\n+        doc_hidden: false,\n     };\n \n     // Install defaults.\n@@ -1054,40 +1113,46 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n     cx.add_lint(lint_unused_mut());\n     cx.add_lint(lint_session());\n     cx.add_lint(lint_unnecessary_allocations());\n-    cx.add_lint(lint_missing_struct_doc());\n-    cx.add_lint(lint_missing_trait_doc());\n+    cx.add_lint(lint_missing_doc());\n \n     // Actually perform the lint checks (iterating the ast)\n     do cx.with_lint_attrs(crate.node.attrs) {\n         cx.process(Crate(crate));\n \n-        visit::visit_crate(crate, cx, visit::mk_vt(@visit::Visitor {\n-            visit_item: |it, cx: @mut Context, vt| {\n+        visit::visit_crate(crate, (cx, visit::mk_vt(@visit::Visitor {\n+            visit_item: |it, (cx, vt): (@mut Context, visit::vt<@mut Context>)| {\n                 do cx.with_lint_attrs(it.attrs) {\n+                    match it.node {\n+                        ast::item_impl(_, Some(*), _, _) => {\n+                            cx.in_trait_impl = true;\n+                        }\n+                        _ => {}\n+                    }\n                     check_item_ctypes(cx, it);\n                     check_item_non_camel_case_types(cx, it);\n                     check_item_default_methods(cx, it);\n                     check_item_heap(cx, it);\n \n                     cx.process(Item(it));\n-                    visit::visit_item(it, cx, vt);\n+                    visit::visit_item(it, (cx, vt));\n+                    cx.in_trait_impl = false;\n                 }\n             },\n-            visit_fn: |fk, decl, body, span, id, cx, vt| {\n+            visit_fn: |fk, decl, body, span, id, (cx, vt)| {\n                 match *fk {\n                     visit::fk_method(_, _, m) => {\n                         do cx.with_lint_attrs(m.attrs) {\n                             cx.process(Method(m));\n-                            visit::visit_fn(fk, decl, body, span, id, cx, vt);\n+                            visit::visit_fn(fk, decl, body, span, id, (cx, vt));\n                         }\n                     }\n                     _ => {\n-                        visit::visit_fn(fk, decl, body, span, id, cx, vt);\n+                        visit::visit_fn(fk, decl, body, span, id, (cx, vt));\n                     }\n                 }\n             },\n             .. *visit::default_visitor()\n-        }));\n+        })));\n     }\n \n     // If we missed any lints added to the session, then there's a bug somewhere"}, {"sha": "1c335ee408423bbefb7cea806e1ab4416139d153", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "14764e7bc37c9286bf6a816e6de9deb840c5a87e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 78, "deletions": 74, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "2217e632d14a8b9e147dc2cef4e2906196eccb6b", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 55, "deletions": 65, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "60193f3fe5db042a7da9ac9b70e6391d0d8c623f", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 39, "deletions": 80, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "f8d0b19922e85a4a7774c824ffdb266604fa4c13", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 109, "deletions": 118, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "2803608567d271a3b9d83c3a23378cd8b8d46b05", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 657, "deletions": 584, "changes": 1241, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "029063b8c0df1bca0ac4c20e8b3bc75ed99378d0", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 103, "deletions": 93, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "ad07f41f8c30ec4da9d239f1eab99b3e1bc1d268", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "d73d57efbbf7276aab767392931fed3dc133ffaa", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "e2073d21fe3969a556d3f1e0acf0afd4d059f2f3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 325, "deletions": 380, "changes": 705, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "604cd3d2ba66b013cc4eaab757e15a5b718538e2", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "acc3293f2678302022936479e11c32b365d818e5", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "9ad66c066715eaa3920df0f73a65fe07e3830206", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "0c771d21da5cef64fab00a7fed71d59f89342d1c", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "53af55bca6ca269fb0d90f2717826f8cbc66b4d2", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "3ff54e9d3d8c7073887e55f3f325e285fa971458", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "bfbe078c4f5240c4966a80679d2137ce49633c63", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 88, "deletions": 19, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "1440d3856f09a7df15cac3b2de44c38ada50e293", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "f5919ca2586f12fd98a86ae7bab37b433633df31", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 133, "deletions": 219, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "f6b1ba0ffe4c198c3e7ce8c5e08c26c667434f3a", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 40, "deletions": 33, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "75d7aaa88a6d0c81e616cd8e033a2d968b50f387", "filename": "src/librustc/middle/trans/context.rs", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "fe3e2940907b7a6c33a5a38443952b9306b6529c", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "b0276cf0e29a5b03f8031293bef550c159c005ee", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 192, "deletions": 153, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "7a8ebb4abfddfa03e22845cc3ebab8b63e850766", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 78, "deletions": 73, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "cbe20afe91927aa8dbf2b94364be91d966632d98", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 65, "deletions": 58, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "40fa44d92ba49bdc7bd98acdb5aa09b2195d0bee", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 178, "deletions": 178, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "3c43e8535f428910c09116612595d5bb90b40494", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 33, "deletions": 63, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "b0aedbae79bfdf421b50d835bd98176effd7f993", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "fb94fe4752a32d339e3f8c6a866d73d471d9c0b7", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "c59b3f36779b789acaa41dd0233fe39407a569d1", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 75, "deletions": 89, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "49cadfbcc81a3edea1061a72c53a9367fe358e04", "filename": "src/librustc/middle/trans/mod.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "df2831947130d2193b5d4bf3170dae94c833d908", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "4641a13604b90aef83b201c493017062a83ebb59", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 18, "deletions": 29, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "e4924e3a8db30bb16789894a6a402e47d193a64f", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "89ffb4b5bbaa747e81db0ad078dc11b3eb37d651", "filename": "src/librustc/middle/trans/shape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "11a4e82050d21db7f5a99b0e9102c5e4595ab346", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "268d60d4417689e0741b582f4cfafd2ae06a1e86", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 45, "deletions": 25, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "8c4ff4415641fbfe713b5e235ad83cd6744c21ce", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 93, "deletions": 78, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "d76d4642801bbe3ffb69c16e1ac38a193b5b1693", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "b54f362c7d2dd2f42ad2cab0fa0c6a7ec21f27da", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 235, "deletions": 145, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "4b5f416cdd172af7e6135badac2c552d690d5d50", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "97e933496c81ec8aa4f09bce89bcc0039c903cf8", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "b2c9d27241d438e9d039caab2c64a7e22fcde98a", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 70, "deletions": 127, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "ea41dff99b896e19f3650ed2a795bc263f62d392", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 237, "deletions": 252, "changes": 489, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "4cedb71245a87928d119d110e2881f1e9e914d1e", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 80, "deletions": 63, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "a5cfa629cf09925fba7644cee626db7ac5a5b476", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "99e68e3330bf86b2252072c00d9434b214c480f2", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "a60fa9ee0be150742f7ff274cba1eccb51cc21bb", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 47, "deletions": 29, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "9528c825fbed9e6de7680f266c5f3940d3efe614", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 92, "deletions": 78, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "56e9875d2ba64cb82a82e0119873e3b06adb24a4", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "18940bb89e14797649d711d4e85f09a3514b12b0", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 47, "deletions": 48, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "76681674892096761b70102939a07c0a8e5b2fa0", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "700a78699b1e27f622c99155de7b7e46760e724d", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "820bb2f86b04cddefb85e5a8df760824abcb6dd4", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "1a73d5bd36bbb7df5a4a3a80da38017dfa60df90", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "e0f3f0fa885b0acea7115d348d50897a46a82b2d", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 66, "deletions": 54, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "9d6176af0babad86bbfaee273526a992c8bc4a36", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 72, "deletions": 81, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "ab52ef36978a52f848a0fdc4ef08093ade52b6bb", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "0db9d16adf3c0186c0b681dd38e22b654aabf777", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "364d8b2d052c3e6d67faccb91e1841a3ffa518b2", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "c6e4b485d29b530cc93e1ec291b6adfaa7624018", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "dc561f413c7104257b5e7f70eadf6fd2a2508198", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "709d631de117a99e341ad29c1012e866308dec54", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "1197693d1b6dfc3cddbe490609ee4266a1c28cfe", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 45, "deletions": 49, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "0839c2b963b4e00ad7f499483e7499b870f0dae5", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "3528f20cfb3cff9fda3e76e7b92905b903ce6c66", "filename": "src/librustc/util/enum_set.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Futil%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Futil%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fenum_set.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "64af555bb37a12244df2b28cb127310102ee8282", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "9d8f750a3500638690dff0daf8902029aa8d31e5", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "a86a7f38a8cddbbc0f22b1539dde5f034ad9c42b", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "a1dad7d17f8e8d2b9afe7b2c7a2c372c136a6d3d", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "ef65cc8e5a1b88483b8b78204e2907aa942bf1dd", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "51fea9b46b3cb126da18c32d70620036524fda1d", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "2fa4d3b63cd87ee38422f7cbf399a31cce36cb06", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "2f09e0a5ddc55e7d3593b92a4022b65e3beb5258", "filename": "src/librustdoc/escape_pass.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fescape_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fescape_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fescape_pass.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "f4b6ae8fb32af8cd844246f20ded550e582d1323", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "7cf616065d381e047ce0b23a27bc54335b6fb5a1", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "3634155b8a3d83a16f5e9e0cb4ae539503fefecb", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "17db7c24a7c8fc250407637aa47101fa34dd38d9", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 60, "deletions": 64, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "353152763267cc5ece79a75071620145ac27307e", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "bb5d71e8db1682ac870086a68127c7fde506e7ba", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "138e4d49156de9d2215c9c1d3b5ffb31a1df2077", "filename": "src/librustdoc/parse.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fparse.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "3654e2c7606075fc474de76cda6773901a8f3b94", "filename": "src/librustdoc/pass.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpass.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "8a90d3f74d3907c4b1e16b8582dad94de1c0b8c4", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "e861939c2dde795483a9130f0ff8eb16b803d9c5", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "7ed5d5f5516308dab8d770c580941c5ef2ab2f93", "filename": "src/librustdoc/rustdoc.rc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Frustdoc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Frustdoc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rc?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "8716f823848e27c91eb1ca7ee56e48dd93c316c1", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "bf4c7027ce21b557f611bac8e072e744ba38d881", "filename": "src/librustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_item_type_pass.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "1f7a71e0fd8963fbecf7c90fb807ff5bb552ed0b", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "82336addb62fc6ef0d3fb0814712e73fe60f9f9b", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "caf0e5376d125940df67a63c9a6fa0d605721dba", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "513baa67ac1ca833665d7e407465459a6e29b0cf", "filename": "src/librusti/program.rs", "status": "added", "additions": 434, "deletions": 0, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "06ec6769385c267a3f90666a730a7848c6cbb2d3", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 337, "deletions": 159, "changes": 496, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "0ac0f5a3c4cb44c39cf7038f935c1ca86eaec6b6", "filename": "src/librusti/utils.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrusti%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrusti%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Futils.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "caab16cd2917d88972eab952e0c3019a30d662a5", "filename": "src/librustpkg/conditions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Fconditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Fconditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fconditions.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "5e8139063deca25484f69104136b499f10968c72", "filename": "src/librustpkg/crate.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Fcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Fcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcrate.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "d3962470e7c84cf6b91e1eba8667c9af317aaacb", "filename": "src/librustpkg/messages.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Fmessages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Fmessages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fmessages.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "3ff0a6073b6d7facfdf0fe70328effee58189efc", "filename": "src/librustpkg/package_id.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "161634be650cbbffadebbcdb79aea94137d50fd9", "filename": "src/librustpkg/package_path.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Fpackage_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Fpackage_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_path.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "01cc48fc037b99f02b1282a45f9166e1e12d7aa2", "filename": "src/librustpkg/package_source.rs", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "e68f48c81629b380a42220a8298bc11e136c4ca4", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 151, "deletions": 46, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "9242e450e24991e4b4254dd19c9c0fb56c4754fb", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 84, "deletions": 296, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "e5ffc5c9d84877e3959832865f7833b4ff88d163", "filename": "src/librustpkg/search.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsearch.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "03c2f5a4fe42afa5ae5c2514cd461333aaae63ac", "filename": "src/librustpkg/target.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftarget.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "6ec14e2aecf62ccd8cdf9a913fe3db90f340b61a", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 487, "deletions": 36, "changes": 523, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "1e5c1d5e627d18a9c4f8ee57d5bd6bd574ace710", "filename": "src/librustpkg/testsuite/pass/src/external-crate/main.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fexternal-crate%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fexternal-crate%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fexternal-crate%2Fmain.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "91fc466f8c65b075eef43d88604ebc07678fbe78", "filename": "src/librustpkg/testsuite/pass/src/foo/lib.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffoo%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffoo%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffoo%2Flib.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "60fe7d52321ae89845a28687a8439bbe8c844398", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 135, "deletions": 269, "changes": 404, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "7431b5e4c011cd0b76ecda0f7bb4fbe47992250f", "filename": "src/librustpkg/version.rs", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "54144f8e31f286b696602e4814c271bfe4d43d9c", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "a118e445fe20544f76a581f9f1919e029117fb60", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "66a5bfa944f10870d93ba1ede4ad5983972be5f8", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 38, "deletions": 45, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "703011aea7f868612a14ebd6d7cb8ecda45527ee", "filename": "src/libstd/borrow.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fborrow.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "2109568a0a4e03cd871c9cc4bf744299f6185482", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "e1d2b246dd3704c9983958163ca9d175443f15fe", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "073ced8988adaec2c4ce749cc47813056f5a8312", "filename": "src/libstd/char.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "266dd1a35e32c56ecac0c1394f445f1ac366b03e", "filename": "src/libstd/clone.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fclone.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "ce6a04c3688bac77367364040e4e35473ad86bec", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "f0c353c8d62b6a8c3d775531c46826cc991f664f", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "2f150a0d1b2835d054b3ec614c5e1e46283fe9d7", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "065582e2e0d2e93e2c091ec1e90d27331d4bc34b", "filename": "src/libstd/container.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcontainer.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "8e09a9b17fdb30615d71ad21f381b9a14b9ed0b0", "filename": "src/libstd/core.rc", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcore.rc?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "fac0866f17e762b808e856826971224a3d122c0e", "filename": "src/libstd/either.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "d2f1a895e1e2ba6887e92046e9a82f33e5ab41b0", "filename": "src/libstd/from_str.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Ffrom_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Ffrom_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffrom_str.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "e902244578634d8489106cf65da17ad8fed62a98", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "85156d6996d913c405175451d7a102bf2140f71e", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 123, "deletions": 65, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "6f065d74fa2e6ff3574df62b41b94b88c8755d60", "filename": "src/libstd/io.rs", "status": "modified", "additions": 51, "deletions": 46, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "2197feea4523a6b9283f1a1a6c022ff621a67106", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "e65904a68992ef9468705e6ddfbc6fdc0db8a2db", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 402, "deletions": 63, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "05c963a32cc732f0741b198bff7fb2b1b2bf5884", "filename": "src/libstd/kinds.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkinds.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "26205c930f0caa7ffba9a9c4e546b7ce5abacfc0", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "82c01c998cf1ed1b1d0968f330be371d481ab08e", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "c2f854179b8ddca649db224163753f38bc97c6fb", "filename": "src/libstd/logging.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flogging.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "8d221fe6a1b7f591efa89cc3ad8866603969e1b9", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "7d0defea05ace5ab863a04908594b166507f0524", "filename": "src/libstd/managed.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmanaged.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "96d3b79e338503c18035132bc182b0f3ab7abbf0", "filename": "src/libstd/num/cmath.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fnum%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fnum%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fcmath.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "7f9811873003ab2077ff2a17f81790f2a1ebdfd1", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "6303e3045764e9b26698b571fc574408fef8526c", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "267a8890e8267349e96504fd2ffc8dc1ea26a4a0", "filename": "src/libstd/num/float.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "74f74d11b730275f99561c5ab0d522e8da1f35b4", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "a9893579721c1365c57c13d3b442134a45d44330", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "3905d82cd0f5caa3c41cbfbe166c1ac583b8ffb7", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "2bc1ca9c67330c561f879c84caf25c4cbb54461a", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 43, "deletions": 14, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "9fea4376816150145d50b08afe79a7eddf37bc75", "filename": "src/libstd/old_iter.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fold_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fold_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_iter.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "77cfe62e495278249fb750c0da2654a756094c79", "filename": "src/libstd/ops.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fops.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "80f4fb7643c8081b908f3fe4a13a7811affa3d72", "filename": "src/libstd/option.rs", "status": "modified", "additions": 75, "deletions": 73, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "044b305a0dd9db393a819d25beb0eeeb9a4eb2b0", "filename": "src/libstd/os.rs", "status": "modified", "additions": 57, "deletions": 31, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "400657d0c2559623670700e8ecb8ec9c7d0dde43", "filename": "src/libstd/path.rs", "status": "modified", "additions": 66, "deletions": 64, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "012ad0ed80d269d6bb36262469a3a0826f9018d1", "filename": "src/libstd/pipes.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpipes.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "61b8d36266e20a7e104e5feefd014a5a31db3815", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 29, "deletions": 57, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "cd5a3182f6b87ad494d6bd7633d27141401c5d31", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 107, "deletions": 135, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "7946f7e4f13f6b1cc9c5a4f01b54cf34b8506529", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "f08d967cbe0226aac37528d4f1d3de9b418bf41c", "filename": "src/libstd/rand/distributions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frand%2Fdistributions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frand%2Fdistributions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "1eb3d3a0daaae8319c7efb6773c67879ad36d171", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "46f69d020d1ec7155bc29040785da0aaae877b45", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "24751b66925e66416703716455f16c9e79801705", "filename": "src/libstd/result.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "82e6d44fe6253b6645eb43061535aa1048278686", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "d5ca8473ceeac6913342f25ebda97b03949f8b52", "filename": "src/libstd/rt/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcontext.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "c7c3eadbe219a9e4b14ef10df359d49019333c99", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "a99f5da032c39757bc0ec04b297cae74b46b8a80", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "e57b80658eef2ec377a4b561bb06673947a64cbc", "filename": "src/libstd/rt/io/flate.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fio%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fio%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fflate.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "bd9cff76e57630754591785c8e1208bb7c541047", "filename": "src/libstd/rt/io/mem.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmem.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "3607f781da3ffb359b5f100123cefd767c4d83f1", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "57bec79563f2ed4ec9cf817c2f8e76dbf4df38a6", "filename": "src/libstd/rt/io/stdio.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fstdio.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "ad5cf2eb378c53d5bf31ee04940aa0898decd29b", "filename": "src/libstd/rt/join_latch.rs", "status": "added", "additions": 645, "deletions": 0, "changes": 645, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fjoin_latch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fjoin_latch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fjoin_latch.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "6e0fbda5ec9a73cec4cf28914808c9e5c759999e", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "0db903f81eec7fb7ff9b8a54d354ae50e845bdaa", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "734be808797487920badd1db96ab89026ad1c07f", "filename": "src/libstd/rt/message_queue.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fmessage_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fmessage_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmessage_queue.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "b0c0fa5d708623d216bdfb58bdf6947da29ada29", "filename": "src/libstd/rt/metrics.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fmetrics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fmetrics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmetrics.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "1724361cabcc0c047897fed1555f23fc101963fd", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "2977d081508122690c3449b197860c4b6ade7273", "filename": "src/libstd/rt/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frc.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "be57247d514798a3a62e58e056f8dbd5bde8bf1a", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 641, "deletions": 109, "changes": 750, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "3d6e9ef5635e5ac48908477d40203ac7d838bf8f", "filename": "src/libstd/rt/sleeper_list.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fsleeper_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fsleeper_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsleeper_list.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "b0e87a62c8b722ad8b4b9d9559c033e74ac5314d", "filename": "src/libstd/rt/stack.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fstack.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "e7f87906fe59a0368c9cd2e2a52f799cfea0e7a1", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 52, "deletions": 21, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "6e4fb9b1d9402d693577e8898dd597559067e6c9", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 208, "deletions": 52, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "bc29019131078535259778ee244406967e236f7f", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "89f3d10b5e4cf85cf612352e50c753abb4f7d96e", "filename": "src/libstd/rt/tube.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftube.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}, {"sha": "f3d1024024ff80dc918dc21d5c154d85fd31dab7", "filename": "src/libstd/rt/uv/async.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f3fa6383b5ed278879bfe5c74a913b885a2d4f/src%2Flibstd%2Frt%2Fuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fasync.rs?ref=35f3fa6383b5ed278879bfe5c74a913b885a2d4f"}]}