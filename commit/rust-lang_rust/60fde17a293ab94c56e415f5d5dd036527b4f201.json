{"sha": "60fde17a293ab94c56e415f5d5dd036527b4f201", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwZmRlMTdhMjkzYWI5NGM1NmU0MTVmNWQ1ZGQwMzY1MjdiNGYyMDE=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-02-20T14:07:25Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-03-04T16:10:02Z"}, "message": "Use bit operations for setting large ranges of bits in a u64", "tree": {"sha": "83e1e2f8e41247bdd4c511609bfb5b3813ec1c44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83e1e2f8e41247bdd4c511609bfb5b3813ec1c44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60fde17a293ab94c56e415f5d5dd036527b4f201", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60fde17a293ab94c56e415f5d5dd036527b4f201", "html_url": "https://github.com/rust-lang/rust/commit/60fde17a293ab94c56e415f5d5dd036527b4f201", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60fde17a293ab94c56e415f5d5dd036527b4f201/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ded592f60c3f1a16db56fadcd7924121ed92ce8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ded592f60c3f1a16db56fadcd7924121ed92ce8", "html_url": "https://github.com/rust-lang/rust/commit/4ded592f60c3f1a16db56fadcd7924121ed92ce8"}], "stats": {"total": 53, "additions": 35, "deletions": 18}, "files": [{"sha": "004804f7c211e043aec3588876d390bed6b6fec0", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/60fde17a293ab94c56e415f5d5dd036527b4f201/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60fde17a293ab94c56e415f5d5dd036527b4f201/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=60fde17a293ab94c56e415f5d5dd036527b4f201", "patch": "@@ -100,8 +100,7 @@ impl AllocationExtra<(), ()> for () {\n impl<Tag, Extra> Allocation<Tag, Extra> {\n     /// Creates a read-only allocation initialized by the given bytes\n     pub fn from_bytes(slice: &[u8], align: Align, extra: Extra) -> Self {\n-        let mut undef_mask = UndefMask::new(Size::ZERO);\n-        undef_mask.grow(Size::from_bytes(slice.len() as u64), true);\n+        let undef_mask = UndefMask::new(Size::from_bytes(slice.len() as u64), true);\n         Self {\n             bytes: slice.to_owned(),\n             relocations: Relocations::new(),\n@@ -121,7 +120,7 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n         Allocation {\n             bytes: vec![0; size.bytes() as usize],\n             relocations: Relocations::new(),\n-            undef_mask: UndefMask::new(size),\n+            undef_mask: UndefMask::new(size, false),\n             align,\n             mutability: Mutability::Mutable,\n             extra,\n@@ -625,12 +624,12 @@ impl_stable_hash_for!(struct mir::interpret::UndefMask{blocks, len});\n impl UndefMask {\n     pub const BLOCK_SIZE: u64 = 64;\n \n-    pub fn new(size: Size) -> Self {\n+    pub fn new(size: Size, state: bool) -> Self {\n         let mut m = UndefMask {\n             blocks: vec![],\n             len: Size::ZERO,\n         };\n-        m.grow(size, false);\n+        m.grow(size, state);\n         m\n     }\n \n@@ -667,25 +666,40 @@ impl UndefMask {\n         let (blocka, bita) = bit_index(start);\n         let (blockb, bitb) = bit_index(end);\n         if blocka == blockb {\n-            // within a single block\n-            for i in bita .. bitb {\n-                self.set_bit(blocka, i, new_state);\n+            // first set all bits but the first `bita`\n+            // then unset the last `64 - bitb` bits\n+            let range = if bitb == 0 {\n+                u64::max_value() << bita\n+            } else {\n+                (u64::max_value() << bita) & (u64::max_value() >> (64 - bitb))\n+            };\n+            if new_state {\n+                self.blocks[blocka] |= range;\n+            } else {\n+                self.blocks[blocka] &= !range;\n             }\n             return;\n         }\n         // across block boundaries\n-        for i in bita .. Self::BLOCK_SIZE as usize {\n-            self.set_bit(blocka, i, new_state);\n-        }\n-        for i in 0 .. bitb {\n-            self.set_bit(blockb, i, new_state);\n-        }\n-        // fill in all the other blocks (much faster than one bit at a time)\n         if new_state {\n+            // set bita..64 to 1\n+            self.blocks[blocka] |= u64::max_value() << bita;\n+            // set 0..bitb to 1\n+            if bitb != 0 {\n+                self.blocks[blockb] |= u64::max_value() >> (64 - bitb);\n+            }\n+            // fill in all the other blocks (much faster than one bit at a time)\n             for block in (blocka + 1) .. blockb {\n                 self.blocks[block] = u64::max_value();\n             }\n         } else {\n+            // set bita..64 to 0\n+            self.blocks[blocka] &= !(u64::max_value() << bita);\n+            // set 0..bitb to 0\n+            if bitb != 0 {\n+                self.blocks[blockb] &= !(u64::max_value() >> (64 - bitb));\n+            }\n+            // fill in all the other blocks (much faster than one bit at a time)\n             for block in (blocka + 1) .. blockb {\n                 self.blocks[block] = 0;\n             }\n@@ -695,7 +709,7 @@ impl UndefMask {\n     #[inline]\n     pub fn get(&self, i: Size) -> bool {\n         let (block, bit) = bit_index(i);\n-        (self.blocks[block] & 1 << bit) != 0\n+        (self.blocks[block] & (1 << bit)) != 0\n     }\n \n     #[inline]\n@@ -714,6 +728,9 @@ impl UndefMask {\n     }\n \n     pub fn grow(&mut self, amount: Size, new_state: bool) {\n+        if amount.bytes() == 0 {\n+            return;\n+        }\n         let unused_trailing_bits = self.blocks.len() as u64 * Self::BLOCK_SIZE - self.len.bytes();\n         if amount.bytes() > unused_trailing_bits {\n             let additional_blocks = amount.bytes() / Self::BLOCK_SIZE + 1;"}, {"sha": "fba0a9af21392c6205bdb0bb12305951f0e1a6ec", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60fde17a293ab94c56e415f5d5dd036527b4f201/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60fde17a293ab94c56e415f5d5dd036527b4f201/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=60fde17a293ab94c56e415f5d5dd036527b4f201", "patch": "@@ -815,7 +815,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         // an optimization where we can just overwrite an entire range of definedness bits if\n         // they are going to be uniformly `1` or `0`.\n         if ranges.is_empty() {\n-            dest_allocation.undef_mask.set_range(\n+            dest_allocation.undef_mask.set_range_inbounds(\n                 dest.offset,\n                 dest.offset + size * repeat,\n                 first,"}, {"sha": "cf6e6f72316384812aa6ed749f7e6d1b66bd751f", "filename": "src/test/run-pass-fulldeps/undef_mask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60fde17a293ab94c56e415f5d5dd036527b4f201/src%2Ftest%2Frun-pass-fulldeps%2Fundef_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60fde17a293ab94c56e415f5d5dd036527b4f201/src%2Ftest%2Frun-pass-fulldeps%2Fundef_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fundef_mask.rs?ref=60fde17a293ab94c56e415f5d5dd036527b4f201", "patch": "@@ -9,7 +9,7 @@ use rustc::mir::interpret::UndefMask;\n use rustc::ty::layout::Size;\n \n fn main() {\n-    let mut mask = UndefMask::new(Size::from_bytes(500));\n+    let mut mask = UndefMask::new(Size::from_bytes(500), false);\n     assert!(!mask.get(Size::from_bytes(499)));\n     mask.set(Size::from_bytes(499), true);\n     assert!(mask.get(Size::from_bytes(499)));"}]}