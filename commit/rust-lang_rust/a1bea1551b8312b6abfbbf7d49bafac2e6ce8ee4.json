{"sha": "a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "node_id": "C_kwDOAAsO6NoAKGExYmVhMTU1MWI4MzEyYjZhYmZiYmY3ZDQ5YmFmYWMyZTZjZThlZTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-23T15:12:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-23T15:12:09Z"}, "message": "Auto merge of #100920 - Dylan-DPC:rollup-vlcw3sr, r=Dylan-DPC\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #99249 (Do not re-parse function signatures to suggest generics)\n - #100309 (Extend comma suggestion to cases where fields arent missing)\n - #100368 (InferCtxt tainted_by_errors_flag should be Option<ErrorGuaranteed>)\n - #100768 (Migrate `rustc_plugin_impl` to `SessionDiagnostic`)\n - #100835 (net listen backlog update, follow-up from #97963.)\n - #100851 (Fix rustc_parse_format precision & width spans)\n - #100857 (Refactor query modifier parsing)\n - #100907 (Fix typo in UnreachableProp)\n - #100909 (Minor `ast::LitKind` improvements)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "0ed13d7fbdb1bbecb2499452d47625c915ec93b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ed13d7fbdb1bbecb2499452d47625c915ec93b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "html_url": "https://github.com/rust-lang/rust/commit/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cff5642037b83ce1239a624bbe617a9aa0d59b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cff5642037b83ce1239a624bbe617a9aa0d59b1", "html_url": "https://github.com/rust-lang/rust/commit/1cff5642037b83ce1239a624bbe617a9aa0d59b1"}, {"sha": "28ead17745916a602fed4ed41a104fb7856544f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/28ead17745916a602fed4ed41a104fb7856544f5", "html_url": "https://github.com/rust-lang/rust/commit/28ead17745916a602fed4ed41a104fb7856544f5"}], "stats": {"total": 1131, "additions": 509, "deletions": 622}, "files": [{"sha": "9d91dcde9b4138e685b543f1dbeefe5c73238171", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -4321,6 +4321,7 @@ dependencies = [\n  \"rustc_ast\",\n  \"rustc_errors\",\n  \"rustc_lint\",\n+ \"rustc_macros\",\n  \"rustc_metadata\",\n  \"rustc_session\",\n  \"rustc_span\","}, {"sha": "fb521073a428d2802bfe0fe994ecd16edce9c8e3", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -1751,7 +1751,8 @@ pub enum LitFloatType {\n /// E.g., `\"foo\"`, `42`, `12.34`, or `bool`.\n #[derive(Clone, Encodable, Decodable, Debug, Hash, Eq, PartialEq, HashStable_Generic)]\n pub enum LitKind {\n-    /// A string literal (`\"foo\"`).\n+    /// A string literal (`\"foo\"`). The symbol is unescaped, and so may differ\n+    /// from the original token's symbol.\n     Str(Symbol, StrStyle),\n     /// A byte string (`b\"foo\"`).\n     ByteStr(Lrc<[u8]>),\n@@ -1761,12 +1762,13 @@ pub enum LitKind {\n     Char(char),\n     /// An integer literal (`1`).\n     Int(u128, LitIntType),\n-    /// A float literal (`1f64` or `1E10f64`).\n+    /// A float literal (`1f64` or `1E10f64`). Stored as a symbol rather than\n+    /// `f64` so that `LitKind` can impl `Eq` and `Hash`.\n     Float(Symbol, LitFloatType),\n     /// A boolean literal.\n     Bool(bool),\n     /// Placeholder for a literal that wasn't well-formed in some way.\n-    Err(Symbol),\n+    Err,\n }\n \n impl LitKind {\n@@ -1805,7 +1807,7 @@ impl LitKind {\n             | LitKind::Int(_, LitIntType::Unsuffixed)\n             | LitKind::Float(_, LitFloatType::Unsuffixed)\n             | LitKind::Bool(..)\n-            | LitKind::Err(..) => false,\n+            | LitKind::Err => false,\n         }\n     }\n }"}, {"sha": "6a02a3b56f6168bbd41fee55fa257fefdeb2aeb6", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -146,7 +146,7 @@ impl LitKind {\n \n                 LitKind::ByteStr(bytes.into())\n             }\n-            token::Err => LitKind::Err(symbol),\n+            token::Err => LitKind::Err,\n         })\n     }\n \n@@ -199,7 +199,7 @@ impl LitKind {\n                 let symbol = if value { kw::True } else { kw::False };\n                 (token::Bool, symbol, None)\n             }\n-            LitKind::Err(symbol) => (token::Err, symbol, None),\n+            LitKind::Err => unreachable!(),\n         };\n \n         token::Lit::new(kind, symbol, suffix)"}, {"sha": "8ab1daf23e86e0cc55986eb11334c86f6337cb53", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -928,7 +928,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 } else {\n                     Lit {\n                         token_lit: token::Lit::new(token::LitKind::Err, kw::Empty, None),\n-                        kind: LitKind::Err(kw::Empty),\n+                        kind: LitKind::Err,\n                         span: DUMMY_SP,\n                     }\n                 };"}, {"sha": "41f4e8c234d5adc004c8a44710e238fb89494cdd", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -39,7 +39,7 @@ pub fn expand_concat(\n                 ast::LitKind::Byte(..) | ast::LitKind::ByteStr(..) => {\n                     cx.span_err(e.span, \"cannot concatenate a byte string literal\");\n                 }\n-                ast::LitKind::Err(_) => {\n+                ast::LitKind::Err => {\n                     has_errors = true;\n                 }\n             },"}, {"sha": "66e86bf2182672e0453f24aa3837623ea1a43b72", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -42,7 +42,7 @@ fn invalid_type_err(cx: &mut base::ExtCtxt<'_>, expr: &P<rustc_ast::Expr>, is_ne\n         ast::LitKind::Bool(_) => {\n             cx.span_err(expr.span, \"cannot concatenate boolean literals\");\n         }\n-        ast::LitKind::Err(_) => {}\n+        ast::LitKind::Err => {}\n         ast::LitKind::Int(_, _) if !is_nested => {\n             let mut err = cx.struct_span_err(expr.span, \"cannot concatenate numeric literals\");\n             if let Ok(snippet) = cx.sess.source_map().span_to_snippet(expr.span) {"}, {"sha": "2816f81fef1218a9a5aa7f5de81d4ea675d135ee", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -413,7 +413,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// Verifies one piece of a parse string, and remembers it if valid.\n     /// All errors are not emitted as fatal so we can continue giving errors\n     /// about this and possibly other format strings.\n-    fn verify_piece(&mut self, p: &parse::Piece<'_>) {\n+    fn verify_piece(&mut self, p: &parse::Piece<'a>) {\n         match *p {\n             parse::String(..) => {}\n             parse::NextArgument(ref arg) => {\n@@ -433,6 +433,11 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let has_precision = arg.format.precision != Count::CountImplied;\n                 let has_width = arg.format.width != Count::CountImplied;\n \n+                if has_precision || has_width {\n+                    // push before named params are resolved to aid diagnostics\n+                    self.arg_with_formatting.push(arg.format);\n+                }\n+\n                 // argument second, if it's an implicit positional parameter\n                 // it's written second, so it should come after width/precision.\n                 let pos = match arg.position {\n@@ -581,7 +586,11 @@ impl<'a, 'b> Context<'a, 'b> {\n         let mut zero_based_note = false;\n \n         let count = self.pieces.len()\n-            + self.arg_with_formatting.iter().filter(|fmt| fmt.precision_span.is_some()).count();\n+            + self\n+                .arg_with_formatting\n+                .iter()\n+                .filter(|fmt| matches!(fmt.precision, parse::CountIsParam(_)))\n+                .count();\n         if self.names.is_empty() && !numbered_position_args && count != self.num_args() {\n             e = self.ecx.struct_span_err(\n                 sp,\n@@ -647,7 +656,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                             + self\n                                 .arg_with_formatting\n                                 .iter()\n-                                .filter(|fmt| fmt.precision_span.is_some())\n+                                .filter(|fmt| matches!(fmt.precision, parse::CountIsParam(_)))\n                                 .count();\n                         e.span_label(\n                             span,\n@@ -899,26 +908,22 @@ impl<'a, 'b> Context<'a, 'b> {\n                     },\n                     position_span: arg.position_span,\n                     format: parse::FormatSpec {\n-                        fill: arg.format.fill,\n+                        fill: None,\n                         align: parse::AlignUnknown,\n                         flags: 0,\n                         precision: parse::CountImplied,\n-                        precision_span: None,\n+                        precision_span: arg.format.precision_span,\n                         width: parse::CountImplied,\n-                        width_span: None,\n+                        width_span: arg.format.width_span,\n                         ty: arg.format.ty,\n                         ty_span: arg.format.ty_span,\n                     },\n                 };\n \n                 let fill = arg.format.fill.unwrap_or(' ');\n-\n                 let pos_simple = arg.position.index() == simple_arg.position.index();\n \n-                if arg.format.precision_span.is_some() || arg.format.width_span.is_some() {\n-                    self.arg_with_formatting.push(arg.format);\n-                }\n-                if !pos_simple || arg.format != simple_arg.format || fill != ' ' {\n+                if !pos_simple || arg.format != simple_arg.format {\n                     self.all_pieces_simple = false;\n                 }\n "}, {"sha": "8db32a42c1deac0c1a01520c4e0cfe607c85b028", "filename": "compiler/rustc_error_messages/locales/en-US/plugin_impl.ftl", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fplugin_impl.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fplugin_impl.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fplugin_impl.ftl?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -0,0 +1,4 @@\n+plugin_impl_load_plugin_error = {$msg}\n+\n+plugin_impl_malformed_plugin_attribute = malformed `plugin` attribute\n+    .label = malformed attribute"}, {"sha": "3e66d12bb37ecdd0c0f8b28526bc622251fe2e20", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -41,6 +41,7 @@ fluent_messages! {\n     lint => \"../locales/en-US/lint.ftl\",\n     parser => \"../locales/en-US/parser.ftl\",\n     passes => \"../locales/en-US/passes.ftl\",\n+    plugin_impl => \"../locales/en-US/plugin_impl.ftl\",\n     privacy => \"../locales/en-US/privacy.ftl\",\n     typeck => \"../locales/en-US/typeck.ftl\",\n }"}, {"sha": "2bb522caa2d418b2e292119ed7e84a08d1909c5d", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -1227,7 +1227,7 @@ pub fn expr_to_spanned_string<'a>(\n                 );\n                 Some((err, true))\n             }\n-            ast::LitKind::Err(_) => None,\n+            ast::LitKind::Err => None,\n             _ => Some((cx.struct_span_err(l.span, err_msg), false)),\n         },\n         ast::ExprKind::Err => None,"}, {"sha": "e37c0cf0fd0325706ae3a1910a1679b670ae03ba", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             evaluation_cache: self.evaluation_cache.clone(),\n             reported_trait_errors: self.reported_trait_errors.clone(),\n             reported_closure_mismatch: self.reported_closure_mismatch.clone(),\n-            tainted_by_errors_flag: self.tainted_by_errors_flag.clone(),\n+            tainted_by_errors: self.tainted_by_errors.clone(),\n             err_count_on_creation: self.err_count_on_creation,\n             in_snapshot: self.in_snapshot.clone(),\n             universe: self.universe.clone(),"}, {"sha": "c95738e0018c09d722a399a6cbc7fe41f0d85a01", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -32,7 +32,7 @@ pub use rustc_middle::ty::IntVarValue;\n use rustc_middle::ty::{self, GenericParamDefKind, InferConst, Ty, TyCtxt};\n use rustc_middle::ty::{ConstVid, FloatVid, IntVid, TyVid};\n use rustc_span::symbol::Symbol;\n-use rustc_span::Span;\n+use rustc_span::{Span, DUMMY_SP};\n \n use std::cell::{Cell, Ref, RefCell};\n use std::fmt;\n@@ -316,12 +316,12 @@ pub struct InferCtxt<'a, 'tcx> {\n     ///\n     /// Don't read this flag directly, call `is_tainted_by_errors()`\n     /// and `set_tainted_by_errors()`.\n-    tainted_by_errors_flag: Cell<bool>,\n+    tainted_by_errors: Cell<Option<ErrorGuaranteed>>,\n \n     /// Track how many errors were reported when this infcx is created.\n     /// If the number of errors increases, that's also a sign (line\n     /// `tainted_by_errors`) to avoid reporting certain kinds of errors.\n-    // FIXME(matthewjasper) Merge into `tainted_by_errors_flag`\n+    // FIXME(matthewjasper) Merge into `tainted_by_errors`\n     err_count_on_creation: usize,\n \n     /// This flag is true while there is an active snapshot.\n@@ -624,7 +624,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             evaluation_cache: Default::default(),\n             reported_trait_errors: Default::default(),\n             reported_closure_mismatch: Default::default(),\n-            tainted_by_errors_flag: Cell::new(false),\n+            tainted_by_errors: Cell::new(None),\n             err_count_on_creation: tcx.sess.err_count(),\n             in_snapshot: Cell::new(false),\n             skip_leak_check: Cell::new(false),\n@@ -1227,23 +1227,25 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn is_tainted_by_errors(&self) -> bool {\n         debug!(\n             \"is_tainted_by_errors(err_count={}, err_count_on_creation={}, \\\n-             tainted_by_errors_flag={})\",\n+             tainted_by_errors={})\",\n             self.tcx.sess.err_count(),\n             self.err_count_on_creation,\n-            self.tainted_by_errors_flag.get()\n+            self.tainted_by_errors.get().is_some()\n         );\n \n         if self.tcx.sess.err_count() > self.err_count_on_creation {\n             return true; // errors reported since this infcx was made\n         }\n-        self.tainted_by_errors_flag.get()\n+        self.tainted_by_errors.get().is_some()\n     }\n \n     /// Set the \"tainted by errors\" flag to true. We call this when we\n     /// observe an error from a prior pass.\n     pub fn set_tainted_by_errors(&self) {\n         debug!(\"set_tainted_by_errors()\");\n-        self.tainted_by_errors_flag.set(true)\n+        self.tainted_by_errors.set(Some(\n+            self.tcx.sess.delay_span_bug(DUMMY_SP, \"`InferCtxt` incorrectly tainted by errors\"),\n+        ));\n     }\n \n     pub fn skip_region_resolution(&self) {"}, {"sha": "52c93133f79c44cbaa4bf85055f052360fe5777e", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 125, "deletions": 260, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -1,139 +1,17 @@\n use proc_macro::TokenStream;\n-use proc_macro2::{Delimiter, TokenTree};\n use quote::{quote, quote_spanned};\n use syn::parse::{Parse, ParseStream, Result};\n use syn::punctuated::Punctuated;\n use syn::spanned::Spanned;\n use syn::{\n-    braced, parenthesized, parse_macro_input, parse_quote, AttrStyle, Attribute, Block, Error,\n-    Expr, Ident, ReturnType, Token, Type,\n+    braced, parenthesized, parse_macro_input, parse_quote, token, AttrStyle, Attribute, Block,\n+    Error, Expr, Ident, Pat, ReturnType, Token, Type,\n };\n \n mod kw {\n     syn::custom_keyword!(query);\n }\n \n-/// Ident or a wildcard `_`.\n-struct IdentOrWild(Ident);\n-\n-impl Parse for IdentOrWild {\n-    fn parse(input: ParseStream<'_>) -> Result<Self> {\n-        Ok(if input.peek(Token![_]) {\n-            let underscore = input.parse::<Token![_]>()?;\n-            IdentOrWild(Ident::new(\"_\", underscore.span()))\n-        } else {\n-            IdentOrWild(input.parse()?)\n-        })\n-    }\n-}\n-\n-/// A modifier for a query\n-enum QueryModifier {\n-    /// The description of the query.\n-    Desc(Option<Ident>, Punctuated<Expr, Token![,]>),\n-\n-    /// Use this type for the in-memory cache.\n-    Storage(Type),\n-\n-    /// Cache the query to disk if the `Expr` returns true.\n-    Cache(Option<IdentOrWild>, Block),\n-\n-    /// Custom code to load the query from disk.\n-    LoadCached(Ident, Ident, Block),\n-\n-    /// A cycle error for this query aborting the compilation with a fatal error.\n-    FatalCycle(Ident),\n-\n-    /// A cycle error results in a delay_bug call\n-    CycleDelayBug(Ident),\n-\n-    /// Don't hash the result, instead just mark a query red if it runs\n-    NoHash(Ident),\n-\n-    /// Generate a dep node based on the dependencies of the query\n-    Anon(Ident),\n-\n-    /// Always evaluate the query, ignoring its dependencies\n-    EvalAlways(Ident),\n-\n-    /// Use a separate query provider for local and extern crates\n-    SeparateProvideExtern(Ident),\n-\n-    /// Always remap the ParamEnv's constness before hashing and passing to the query provider\n-    RemapEnvConstness(Ident),\n-}\n-\n-impl Parse for QueryModifier {\n-    fn parse(input: ParseStream<'_>) -> Result<Self> {\n-        let modifier: Ident = input.parse()?;\n-        if modifier == \"desc\" {\n-            // Parse a description modifier like:\n-            // `desc { |tcx| \"foo {}\", tcx.item_path(key) }`\n-            let attr_content;\n-            braced!(attr_content in input);\n-            let tcx = if attr_content.peek(Token![|]) {\n-                attr_content.parse::<Token![|]>()?;\n-                let tcx = attr_content.parse()?;\n-                attr_content.parse::<Token![|]>()?;\n-                Some(tcx)\n-            } else {\n-                None\n-            };\n-            let desc = attr_content.parse_terminated(Expr::parse)?;\n-            Ok(QueryModifier::Desc(tcx, desc))\n-        } else if modifier == \"cache_on_disk_if\" {\n-            // Parse a cache modifier like:\n-            // `cache(tcx, value) { |tcx| key.is_local() }`\n-            let has_args = if let TokenTree::Group(group) = input.fork().parse()? {\n-                group.delimiter() == Delimiter::Parenthesis\n-            } else {\n-                false\n-            };\n-            let args = if has_args {\n-                let args;\n-                parenthesized!(args in input);\n-                let tcx = args.parse()?;\n-                Some(tcx)\n-            } else {\n-                None\n-            };\n-            let block = input.parse()?;\n-            Ok(QueryModifier::Cache(args, block))\n-        } else if modifier == \"load_cached\" {\n-            // Parse a load_cached modifier like:\n-            // `load_cached(tcx, id) { tcx.on_disk_cache.try_load_query_result(tcx, id) }`\n-            let args;\n-            parenthesized!(args in input);\n-            let tcx = args.parse()?;\n-            args.parse::<Token![,]>()?;\n-            let id = args.parse()?;\n-            let block = input.parse()?;\n-            Ok(QueryModifier::LoadCached(tcx, id, block))\n-        } else if modifier == \"storage\" {\n-            let args;\n-            parenthesized!(args in input);\n-            let ty = args.parse()?;\n-            Ok(QueryModifier::Storage(ty))\n-        } else if modifier == \"fatal_cycle\" {\n-            Ok(QueryModifier::FatalCycle(modifier))\n-        } else if modifier == \"cycle_delay_bug\" {\n-            Ok(QueryModifier::CycleDelayBug(modifier))\n-        } else if modifier == \"no_hash\" {\n-            Ok(QueryModifier::NoHash(modifier))\n-        } else if modifier == \"anon\" {\n-            Ok(QueryModifier::Anon(modifier))\n-        } else if modifier == \"eval_always\" {\n-            Ok(QueryModifier::EvalAlways(modifier))\n-        } else if modifier == \"separate_provide_extern\" {\n-            Ok(QueryModifier::SeparateProvideExtern(modifier))\n-        } else if modifier == \"remap_env_constness\" {\n-            Ok(QueryModifier::RemapEnvConstness(modifier))\n-        } else {\n-            Err(Error::new(modifier.span(), \"unknown query modifier\"))\n-        }\n-    }\n-}\n-\n /// Ensures only doc comment attributes are used\n fn check_attributes(attrs: Vec<Attribute>) -> Result<Vec<Attribute>> {\n     let inner = |attr: Attribute| {\n@@ -154,16 +32,16 @@ fn check_attributes(attrs: Vec<Attribute>) -> Result<Vec<Attribute>> {\n /// A compiler query. `query ... { ... }`\n struct Query {\n     doc_comments: Vec<Attribute>,\n-    modifiers: List<QueryModifier>,\n+    modifiers: QueryModifiers,\n     name: Ident,\n-    key: IdentOrWild,\n+    key: Pat,\n     arg: Type,\n     result: ReturnType,\n }\n \n impl Parse for Query {\n     fn parse(input: ParseStream<'_>) -> Result<Self> {\n-        let doc_comments = check_attributes(input.call(Attribute::parse_outer)?)?;\n+        let mut doc_comments = check_attributes(input.call(Attribute::parse_outer)?)?;\n \n         // Parse the query declaration. Like `query type_of(key: DefId) -> Ty<'tcx>`\n         input.parse::<kw::query>()?;\n@@ -178,7 +56,13 @@ impl Parse for Query {\n         // Parse the query modifiers\n         let content;\n         braced!(content in input);\n-        let modifiers = content.parse()?;\n+        let modifiers = parse_query_modifiers(&content)?;\n+\n+        // If there are no doc-comments, give at least some idea of what\n+        // it does by showing the query description.\n+        if doc_comments.is_empty() {\n+            doc_comments.push(doc_comment_from_desc(&modifiers.desc.1)?);\n+        }\n \n         Ok(Query { doc_comments, modifiers, name, key, arg, result })\n     }\n@@ -205,7 +89,7 @@ struct QueryModifiers {\n     storage: Option<Type>,\n \n     /// Cache the query to disk if the `Block` returns true.\n-    cache: Option<(Option<IdentOrWild>, Block)>,\n+    cache: Option<(Option<Pat>, Block)>,\n \n     /// Custom code to load the query from disk.\n     load_cached: Option<(Ident, Ident, Block)>,\n@@ -232,8 +116,7 @@ struct QueryModifiers {\n     remap_env_constness: Option<Ident>,\n }\n \n-/// Process query modifiers into a struct, erroring on duplicates\n-fn process_modifiers(query: &mut Query) -> QueryModifiers {\n+fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n     let mut load_cached = None;\n     let mut storage = None;\n     let mut cache = None;\n@@ -245,117 +128,84 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n     let mut eval_always = None;\n     let mut separate_provide_extern = None;\n     let mut remap_env_constness = None;\n-    for modifier in query.modifiers.0.drain(..) {\n-        match modifier {\n-            QueryModifier::LoadCached(tcx, id, block) => {\n-                if load_cached.is_some() {\n-                    panic!(\"duplicate modifier `load_cached` for query `{}`\", query.name);\n-                }\n-                load_cached = Some((tcx, id, block));\n-            }\n-            QueryModifier::Storage(ty) => {\n-                if storage.is_some() {\n-                    panic!(\"duplicate modifier `storage` for query `{}`\", query.name);\n-                }\n-                storage = Some(ty);\n-            }\n-            QueryModifier::Cache(args, expr) => {\n-                if cache.is_some() {\n-                    panic!(\"duplicate modifier `cache` for query `{}`\", query.name);\n-                }\n-                cache = Some((args, expr));\n-            }\n-            QueryModifier::Desc(tcx, list) => {\n-                if desc.is_some() {\n-                    panic!(\"duplicate modifier `desc` for query `{}`\", query.name);\n-                }\n-                // If there are no doc-comments, give at least some idea of what\n-                // it does by showing the query description.\n-                if query.doc_comments.is_empty() {\n-                    use ::syn::*;\n-                    let mut list = list.iter();\n-                    let format_str: String = match list.next() {\n-                        Some(&Expr::Lit(ExprLit { lit: Lit::Str(ref lit_str), .. })) => {\n-                            lit_str.value().replace(\"`{}`\", \"{}\") // We add them later anyways for consistency\n-                        }\n-                        _ => panic!(\"Expected a string literal\"),\n-                    };\n-                    let mut fmt_fragments = format_str.split(\"{}\");\n-                    let mut doc_string = fmt_fragments.next().unwrap().to_string();\n-                    list.map(::quote::ToTokens::to_token_stream).zip(fmt_fragments).for_each(\n-                        |(tts, next_fmt_fragment)| {\n-                            use ::core::fmt::Write;\n-                            write!(\n-                                &mut doc_string,\n-                                \" `{}` {}\",\n-                                tts.to_string().replace(\" . \", \".\"),\n-                                next_fmt_fragment,\n-                            )\n-                            .unwrap();\n-                        },\n-                    );\n-                    let doc_string = format!(\n-                        \"[query description - consider adding a doc-comment!] {}\",\n-                        doc_string\n-                    );\n-                    let comment = parse_quote! {\n-                        #[doc = #doc_string]\n-                    };\n-                    query.doc_comments.push(comment);\n-                }\n-                desc = Some((tcx, list));\n-            }\n-            QueryModifier::FatalCycle(ident) => {\n-                if fatal_cycle.is_some() {\n-                    panic!(\"duplicate modifier `fatal_cycle` for query `{}`\", query.name);\n-                }\n-                fatal_cycle = Some(ident);\n-            }\n-            QueryModifier::CycleDelayBug(ident) => {\n-                if cycle_delay_bug.is_some() {\n-                    panic!(\"duplicate modifier `cycle_delay_bug` for query `{}`\", query.name);\n-                }\n-                cycle_delay_bug = Some(ident);\n-            }\n-            QueryModifier::NoHash(ident) => {\n-                if no_hash.is_some() {\n-                    panic!(\"duplicate modifier `no_hash` for query `{}`\", query.name);\n-                }\n-                no_hash = Some(ident);\n-            }\n-            QueryModifier::Anon(ident) => {\n-                if anon.is_some() {\n-                    panic!(\"duplicate modifier `anon` for query `{}`\", query.name);\n-                }\n-                anon = Some(ident);\n-            }\n-            QueryModifier::EvalAlways(ident) => {\n-                if eval_always.is_some() {\n-                    panic!(\"duplicate modifier `eval_always` for query `{}`\", query.name);\n-                }\n-                eval_always = Some(ident);\n-            }\n-            QueryModifier::SeparateProvideExtern(ident) => {\n-                if separate_provide_extern.is_some() {\n-                    panic!(\n-                        \"duplicate modifier `separate_provide_extern` for query `{}`\",\n-                        query.name\n-                    );\n-                }\n-                separate_provide_extern = Some(ident);\n-            }\n-            QueryModifier::RemapEnvConstness(ident) => {\n-                if remap_env_constness.is_some() {\n-                    panic!(\"duplicate modifier `remap_env_constness` for query `{}`\", query.name);\n+\n+    while !input.is_empty() {\n+        let modifier: Ident = input.parse()?;\n+\n+        macro_rules! try_insert {\n+            ($name:ident = $expr:expr) => {\n+                if $name.is_some() {\n+                    return Err(Error::new(modifier.span(), \"duplicate modifier\"));\n                 }\n-                remap_env_constness = Some(ident)\n-            }\n+                $name = Some($expr);\n+            };\n+        }\n+\n+        if modifier == \"desc\" {\n+            // Parse a description modifier like:\n+            // `desc { |tcx| \"foo {}\", tcx.item_path(key) }`\n+            let attr_content;\n+            braced!(attr_content in input);\n+            let tcx = if attr_content.peek(Token![|]) {\n+                attr_content.parse::<Token![|]>()?;\n+                let tcx = attr_content.parse()?;\n+                attr_content.parse::<Token![|]>()?;\n+                Some(tcx)\n+            } else {\n+                None\n+            };\n+            let list = attr_content.parse_terminated(Expr::parse)?;\n+            try_insert!(desc = (tcx, list));\n+        } else if modifier == \"cache_on_disk_if\" {\n+            // Parse a cache modifier like:\n+            // `cache(tcx) { |tcx| key.is_local() }`\n+            let args = if input.peek(token::Paren) {\n+                let args;\n+                parenthesized!(args in input);\n+                let tcx = args.parse()?;\n+                Some(tcx)\n+            } else {\n+                None\n+            };\n+            let block = input.parse()?;\n+            try_insert!(cache = (args, block));\n+        } else if modifier == \"load_cached\" {\n+            // Parse a load_cached modifier like:\n+            // `load_cached(tcx, id) { tcx.on_disk_cache.try_load_query_result(tcx, id) }`\n+            let args;\n+            parenthesized!(args in input);\n+            let tcx = args.parse()?;\n+            args.parse::<Token![,]>()?;\n+            let id = args.parse()?;\n+            let block = input.parse()?;\n+            try_insert!(load_cached = (tcx, id, block));\n+        } else if modifier == \"storage\" {\n+            let args;\n+            parenthesized!(args in input);\n+            let ty = args.parse()?;\n+            try_insert!(storage = ty);\n+        } else if modifier == \"fatal_cycle\" {\n+            try_insert!(fatal_cycle = modifier);\n+        } else if modifier == \"cycle_delay_bug\" {\n+            try_insert!(cycle_delay_bug = modifier);\n+        } else if modifier == \"no_hash\" {\n+            try_insert!(no_hash = modifier);\n+        } else if modifier == \"anon\" {\n+            try_insert!(anon = modifier);\n+        } else if modifier == \"eval_always\" {\n+            try_insert!(eval_always = modifier);\n+        } else if modifier == \"separate_provide_extern\" {\n+            try_insert!(separate_provide_extern = modifier);\n+        } else if modifier == \"remap_env_constness\" {\n+            try_insert!(remap_env_constness = modifier);\n+        } else {\n+            return Err(Error::new(modifier.span(), \"unknown query modifier\"));\n         }\n     }\n-    let desc = desc.unwrap_or_else(|| {\n-        panic!(\"no description provided for query `{}`\", query.name);\n-    });\n-    QueryModifiers {\n+    let Some(desc) = desc else {\n+        return Err(input.error(\"no description provided\"));\n+    };\n+    Ok(QueryModifiers {\n         load_cached,\n         storage,\n         cache,\n@@ -367,17 +217,41 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n         eval_always,\n         separate_provide_extern,\n         remap_env_constness,\n-    }\n+    })\n+}\n+\n+fn doc_comment_from_desc(list: &Punctuated<Expr, token::Comma>) -> Result<Attribute> {\n+    use ::syn::*;\n+    let mut iter = list.iter();\n+    let format_str: String = match iter.next() {\n+        Some(&Expr::Lit(ExprLit { lit: Lit::Str(ref lit_str), .. })) => {\n+            lit_str.value().replace(\"`{}`\", \"{}\") // We add them later anyways for consistency\n+        }\n+        _ => return Err(Error::new(list.span(), \"Expected a string literal\")),\n+    };\n+    let mut fmt_fragments = format_str.split(\"{}\");\n+    let mut doc_string = fmt_fragments.next().unwrap().to_string();\n+    iter.map(::quote::ToTokens::to_token_stream).zip(fmt_fragments).for_each(\n+        |(tts, next_fmt_fragment)| {\n+            use ::core::fmt::Write;\n+            write!(\n+                &mut doc_string,\n+                \" `{}` {}\",\n+                tts.to_string().replace(\" . \", \".\"),\n+                next_fmt_fragment,\n+            )\n+            .unwrap();\n+        },\n+    );\n+    let doc_string = format!(\"[query description - consider adding a doc-comment!] {}\", doc_string);\n+    Ok(parse_quote! { #[doc = #doc_string] })\n }\n \n /// Add the impl of QueryDescription for the query to `impls` if one is requested\n-fn add_query_description_impl(\n-    query: &Query,\n-    modifiers: QueryModifiers,\n-    impls: &mut proc_macro2::TokenStream,\n-) {\n+fn add_query_description_impl(query: &Query, impls: &mut proc_macro2::TokenStream) {\n     let name = &query.name;\n-    let key = &query.key.0;\n+    let key = &query.key;\n+    let modifiers = &query.modifiers;\n \n     // Find out if we should cache the query on disk\n     let cache = if let Some((args, expr)) = modifiers.cache.as_ref() {\n@@ -395,13 +269,7 @@ fn add_query_description_impl(\n             }\n         };\n \n-        let tcx = args\n-            .as_ref()\n-            .map(|t| {\n-                let t = &t.0;\n-                quote! { #t }\n-            })\n-            .unwrap_or_else(|| quote! { _ });\n+        let tcx = args.as_ref().map(|t| quote! { #t }).unwrap_or_else(|| quote! { _ });\n         // expr is a `Block`, meaning that `{ #expr }` gets expanded\n         // to `{ { stmts... } }`, which triggers the `unused_braces` lint.\n         quote! {\n@@ -427,7 +295,7 @@ fn add_query_description_impl(\n         }\n     };\n \n-    let (tcx, desc) = modifiers.desc;\n+    let (tcx, desc) = &modifiers.desc;\n     let tcx = tcx.as_ref().map_or_else(|| quote! { _ }, |t| quote! { #t });\n \n     let desc = quote! {\n@@ -456,10 +324,8 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n     let mut dep_node_def_stream = quote! {};\n     let mut cached_queries = quote! {};\n \n-    for mut query in queries.0 {\n-        let modifiers = process_modifiers(&mut query);\n-        let name = &query.name;\n-        let arg = &query.arg;\n+    for query in queries.0 {\n+        let Query { name, arg, modifiers, .. } = &query;\n         let result_full = &query.result;\n         let result = match query.result {\n             ReturnType::Default => quote! { -> () },\n@@ -528,7 +394,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n             [#attribute_stream] #name(#arg),\n         });\n \n-        add_query_description_impl(&query, modifiers, &mut query_description_stream);\n+        add_query_description_impl(&query, &mut query_description_stream);\n     }\n \n     TokenStream::from(quote! {\n@@ -539,7 +405,6 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                     $($other)*\n \n                     #query_stream\n-\n                 }\n             }\n         }"}, {"sha": "19d420f154d5c5f893b8bd9e9527ac0139cadc03", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -144,7 +144,7 @@ pub(crate) fn lit_to_mir_constant<'tcx>(\n         }\n         (ast::LitKind::Bool(b), ty::Bool) => ConstValue::Scalar(Scalar::from_bool(*b)),\n         (ast::LitKind::Char(c), ty::Char) => ConstValue::Scalar(Scalar::from_char(*c)),\n-        (ast::LitKind::Err(_), _) => return Err(LitToConstError::Reported),\n+        (ast::LitKind::Err, _) => return Err(LitToConstError::Reported),\n         _ => return Err(LitToConstError::TypeError),\n     };\n "}, {"sha": "f626571b5b2c59f88e2da701e9f5fb5671924901", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -44,7 +44,7 @@ pub(crate) fn lit_to_const<'tcx>(\n         }\n         (ast::LitKind::Bool(b), ty::Bool) => ty::ValTree::from_scalar_int((*b).into()),\n         (ast::LitKind::Char(c), ty::Char) => ty::ValTree::from_scalar_int((*c).into()),\n-        (ast::LitKind::Err(_), _) => return Err(LitToConstError::Reported),\n+        (ast::LitKind::Err, _) => return Err(LitToConstError::Reported),\n         _ => return Err(LitToConstError::TypeError),\n     };\n "}, {"sha": "95fda2eafe8a1799df333461355abe2eb2fc770f", "filename": "compiler/rustc_mir_transform/src/unreachable_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_mir_transform%2Fsrc%2Funreachable_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_mir_transform%2Fsrc%2Funreachable_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Funreachable_prop.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -84,7 +84,7 @@ where\n                 TerminatorKind::Unreachable\n             } else if is_unreachable(otherwise) {\n                 // If there are multiple targets, don't delete unreachable branches (like an unreachable otherwise)\n-                // unless otherwise is unrachable, in which case deleting a normal branch causes it to be merged with\n+                // unless otherwise is unreachable, in which case deleting a normal branch causes it to be merged with\n                 // the otherwise, keeping its unreachable.\n                 // This looses information about reachability causing worse codegen.\n                 // For example (see src/test/codegen/match-optimizes-away.rs)"}, {"sha": "f6516d3bd4543604155cf9bde1010d54c01b65cb", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -1383,7 +1383,7 @@ impl<'a> Parser<'a> {\n         match self.parse_str_lit() {\n             Ok(str_lit) => Some(str_lit),\n             Err(Some(lit)) => match lit.kind {\n-                ast::LitKind::Err(_) => None,\n+                ast::LitKind::Err => None,\n                 _ => {\n                     self.struct_span_err(lit.span, \"non-string ABI literal\")\n                         .span_suggestion("}, {"sha": "b63a173cc29e6cd3a5dc8806dacc825e6949bb3e", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 38, "deletions": 43, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -264,9 +264,7 @@ impl<'a> Iterator for Parser<'a> {\n             }\n         } else {\n             if self.is_literal {\n-                let start = self.to_span_index(self.cur_line_start);\n-                let end = self.to_span_index(self.input.len());\n-                let span = start.to(end);\n+                let span = self.span(self.cur_line_start, self.input.len());\n                 if self.line_spans.last() != Some(&span) {\n                     self.line_spans.push(span);\n                 }\n@@ -384,6 +382,12 @@ impl<'a> Parser<'a> {\n         InnerOffset(raw + pos + 1)\n     }\n \n+    fn span(&self, start_pos: usize, end_pos: usize) -> InnerSpan {\n+        let start = self.to_span_index(start_pos);\n+        let end = self.to_span_index(end_pos);\n+        start.to(end)\n+    }\n+\n     /// Forces consumption of the specified character. If the character is not\n     /// found, an error is emitted.\n     fn must_consume(&mut self, c: char) -> Option<usize> {\n@@ -472,9 +476,7 @@ impl<'a> Parser<'a> {\n                     return &self.input[start..pos];\n                 }\n                 '\\n' if self.is_literal => {\n-                    let start = self.to_span_index(self.cur_line_start);\n-                    let end = self.to_span_index(pos);\n-                    self.line_spans.push(start.to(end));\n+                    self.line_spans.push(self.span(self.cur_line_start, pos));\n                     self.cur_line_start = pos + 1;\n                     self.cur.next();\n                 }\n@@ -537,6 +539,10 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    fn current_pos(&mut self) -> usize {\n+        if let Some(&(pos, _)) = self.cur.peek() { pos } else { self.input.len() }\n+    }\n+\n     /// Parses a format specifier at the current position, returning all of the\n     /// relevant information in the `FormatSpec` struct.\n     fn format(&mut self) -> FormatSpec<'a> {\n@@ -590,39 +596,37 @@ impl<'a> Parser<'a> {\n             // no '0' flag and '0$' as the width instead.\n             if let Some(end) = self.consume_pos('$') {\n                 spec.width = CountIsParam(0);\n-\n-                if let Some((pos, _)) = self.cur.peek().cloned() {\n-                    spec.width_span = Some(self.to_span_index(pos - 2).to(self.to_span_index(pos)));\n-                }\n+                spec.width_span = Some(self.span(end - 1, end + 1));\n                 havewidth = true;\n-                spec.width_span = Some(self.to_span_index(end - 1).to(self.to_span_index(end + 1)));\n             } else {\n                 spec.flags |= 1 << (FlagSignAwareZeroPad as u32);\n             }\n         }\n+\n         if !havewidth {\n-            let width_span_start = if let Some((pos, _)) = self.cur.peek() { *pos } else { 0 };\n-            let (w, sp) = self.count(width_span_start);\n-            spec.width = w;\n-            spec.width_span = sp;\n+            let start = self.current_pos();\n+            spec.width = self.count(start);\n+            if spec.width != CountImplied {\n+                let end = self.current_pos();\n+                spec.width_span = Some(self.span(start, end));\n+            }\n         }\n \n         if let Some(start) = self.consume_pos('.') {\n-            if let Some(end) = self.consume_pos('*') {\n+            if self.consume('*') {\n                 // Resolve `CountIsNextParam`.\n                 // We can do this immediately as `position` is resolved later.\n                 let i = self.curarg;\n                 self.curarg += 1;\n                 spec.precision = CountIsParam(i);\n-                spec.precision_span =\n-                    Some(self.to_span_index(start).to(self.to_span_index(end + 1)));\n             } else {\n-                let (p, sp) = self.count(start);\n-                spec.precision = p;\n-                spec.precision_span = sp;\n+                spec.precision = self.count(start + 1);\n             }\n+            let end = self.current_pos();\n+            spec.precision_span = Some(self.span(start, end));\n         }\n-        let ty_span_start = self.cur.peek().map(|(pos, _)| *pos);\n+\n+        let ty_span_start = self.current_pos();\n         // Optional radix followed by the actual format specifier\n         if self.consume('x') {\n             if self.consume('?') {\n@@ -642,11 +646,9 @@ impl<'a> Parser<'a> {\n             spec.ty = \"?\";\n         } else {\n             spec.ty = self.word();\n-            let ty_span_end = self.cur.peek().map(|(pos, _)| *pos);\n             if !spec.ty.is_empty() {\n-                spec.ty_span = ty_span_start\n-                    .and_then(|s| ty_span_end.map(|e| (s, e)))\n-                    .map(|(start, end)| self.to_span_index(start).to(self.to_span_index(end)));\n+                let ty_span_end = self.current_pos();\n+                spec.ty_span = Some(self.span(ty_span_start, ty_span_end));\n             }\n         }\n         spec\n@@ -670,13 +672,11 @@ impl<'a> Parser<'a> {\n             return spec;\n         }\n \n-        let ty_span_start = self.cur.peek().map(|(pos, _)| *pos);\n+        let ty_span_start = self.current_pos();\n         spec.ty = self.word();\n-        let ty_span_end = self.cur.peek().map(|(pos, _)| *pos);\n         if !spec.ty.is_empty() {\n-            spec.ty_span = ty_span_start\n-                .and_then(|s| ty_span_end.map(|e| (s, e)))\n-                .map(|(start, end)| self.to_span_index(start).to(self.to_span_index(end)));\n+            let ty_span_end = self.current_pos();\n+            spec.ty_span = Some(self.span(ty_span_start, ty_span_end));\n         }\n \n         spec\n@@ -685,26 +685,21 @@ impl<'a> Parser<'a> {\n     /// Parses a `Count` parameter at the current position. This does not check\n     /// for 'CountIsNextParam' because that is only used in precision, not\n     /// width.\n-    fn count(&mut self, start: usize) -> (Count<'a>, Option<InnerSpan>) {\n+    fn count(&mut self, start: usize) -> Count<'a> {\n         if let Some(i) = self.integer() {\n-            if let Some(end) = self.consume_pos('$') {\n-                let span = self.to_span_index(start).to(self.to_span_index(end + 1));\n-                (CountIsParam(i), Some(span))\n-            } else {\n-                (CountIs(i), None)\n-            }\n+            if self.consume('$') { CountIsParam(i) } else { CountIs(i) }\n         } else {\n             let tmp = self.cur.clone();\n             let word = self.word();\n             if word.is_empty() {\n                 self.cur = tmp;\n-                (CountImplied, None)\n+                CountImplied\n             } else if let Some(end) = self.consume_pos('$') {\n-                let span = self.to_span_index(start + 1).to(self.to_span_index(end));\n-                (CountIsName(word, span), None)\n+                let name_span = self.span(start, end);\n+                CountIsName(word, name_span)\n             } else {\n                 self.cur = tmp;\n-                (CountImplied, None)\n+                CountImplied\n             }\n         }\n     }\n@@ -737,7 +732,7 @@ impl<'a> Parser<'a> {\n                 \"invalid argument name `_`\",\n                 \"invalid argument name\",\n                 \"argument name cannot be a single underscore\",\n-                self.to_span_index(start).to(self.to_span_index(end)),\n+                self.span(start, end),\n             );\n         }\n         word"}, {"sha": "44ef0cd0eb5d2f0e0df69d2d117a9a875bf7e751", "filename": "compiler/rustc_parse_format/src/tests.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_parse_format%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_parse_format%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Ftests.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -1,5 +1,6 @@\n use super::*;\n \n+#[track_caller]\n fn same(fmt: &'static str, p: &[Piece<'static>]) {\n     let parser = Parser::new(fmt, None, None, false, ParseMode::Format);\n     assert_eq!(parser.collect::<Vec<Piece<'static>>>(), p);\n@@ -190,9 +191,9 @@ fn format_counts() {\n                 align: AlignUnknown,\n                 flags: 0,\n                 precision: CountImplied,\n-                width: CountIs(10),\n                 precision_span: None,\n-                width_span: None,\n+                width: CountIs(10),\n+                width_span: Some(InnerSpan { start: 3, end: 5 }),\n                 ty: \"x\",\n                 ty_span: None,\n             },\n@@ -208,9 +209,9 @@ fn format_counts() {\n                 align: AlignUnknown,\n                 flags: 0,\n                 precision: CountIs(10),\n+                precision_span: Some(InnerSpan { start: 6, end: 9 }),\n                 width: CountIsParam(10),\n-                precision_span: None,\n-                width_span: Some(InnerSpan::new(3, 6)),\n+                width_span: Some(InnerSpan { start: 3, end: 6 }),\n                 ty: \"x\",\n                 ty_span: None,\n             },\n@@ -226,9 +227,9 @@ fn format_counts() {\n                 align: AlignUnknown,\n                 flags: 0,\n                 precision: CountIs(10),\n+                precision_span: Some(InnerSpan { start: 6, end: 9 }),\n                 width: CountIsParam(0),\n-                precision_span: None,\n-                width_span: Some(InnerSpan::new(4, 6)),\n+                width_span: Some(InnerSpan { start: 4, end: 6 }),\n                 ty: \"x\",\n                 ty_span: None,\n             },\n@@ -244,8 +245,8 @@ fn format_counts() {\n                 align: AlignUnknown,\n                 flags: 0,\n                 precision: CountIsParam(0),\n+                precision_span: Some(InnerSpan { start: 3, end: 5 }),\n                 width: CountImplied,\n-                precision_span: Some(InnerSpan::new(3, 5)),\n                 width_span: None,\n                 ty: \"x\",\n                 ty_span: None,\n@@ -279,15 +280,33 @@ fn format_counts() {\n                 fill: None,\n                 align: AlignUnknown,\n                 flags: 0,\n-                precision: CountIsName(\"b\", InnerSpan::new(6, 7)),\n-                width: CountIsName(\"a\", InnerSpan::new(4, 4)),\n-                precision_span: None,\n-                width_span: None,\n+                precision: CountIsName(\"b\", InnerSpan { start: 6, end: 7 }),\n+                precision_span: Some(InnerSpan { start: 5, end: 8 }),\n+                width: CountIsName(\"a\", InnerSpan { start: 3, end: 4 }),\n+                width_span: Some(InnerSpan { start: 3, end: 5 }),\n                 ty: \"?\",\n                 ty_span: None,\n             },\n         })],\n     );\n+    same(\n+        \"{:.4}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(0),\n+            position_span: InnerSpan { start: 2, end: 2 },\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountIs(4),\n+                precision_span: Some(InnerSpan { start: 3, end: 5 }),\n+                width: CountImplied,\n+                width_span: None,\n+                ty: \"\",\n+                ty_span: None,\n+            },\n+        })],\n+    )\n }\n #[test]\n fn format_flags() {"}, {"sha": "c409b6c3e5440716e5512b3c8acb9d24071932d2", "filename": "compiler/rustc_plugin_impl/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_plugin_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_plugin_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_plugin_impl%2FCargo.toml?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -11,6 +11,7 @@ doctest = false\n libloading = \"0.7.1\"\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_lint = { path = \"../rustc_lint\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_metadata = { path = \"../rustc_metadata\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_session = { path = \"../rustc_session\" }"}, {"sha": "2bdb6e4feca9dbb356c7fb36536542be34f81419", "filename": "compiler/rustc_plugin_impl/src/errors.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_plugin_impl%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_plugin_impl%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_plugin_impl%2Fsrc%2Ferrors.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -0,0 +1,20 @@\n+//! Errors emitted by plugin_impl\n+\n+use rustc_macros::SessionDiagnostic;\n+use rustc_span::Span;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(plugin_impl::load_plugin_error)]\n+pub struct LoadPluginError {\n+    #[primary_span]\n+    pub span: Span,\n+    pub msg: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(plugin_impl::malformed_plugin_attribute, code = \"E0498\")]\n+pub struct MalformedPluginAttribute {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}"}, {"sha": "9ac27c65da82e3f504ad78e495ef79a6665ef191", "filename": "compiler/rustc_plugin_impl/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_plugin_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_plugin_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_plugin_impl%2Fsrc%2Flib.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -8,9 +8,12 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![recursion_limit = \"256\"]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n use rustc_lint::LintStore;\n \n+mod errors;\n pub mod load;\n \n /// Structure used to register plugins."}, {"sha": "8e75e969ae032064d832dfb6eda2164c3078c752", "filename": "compiler/rustc_plugin_impl/src/load.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_plugin_impl%2Fsrc%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_plugin_impl%2Fsrc%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_plugin_impl%2Fsrc%2Fload.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -1,29 +1,21 @@\n //! Used by `rustc` when loading a plugin.\n \n+use crate::errors::{LoadPluginError, MalformedPluginAttribute};\n use crate::Registry;\n use libloading::Library;\n use rustc_ast::Crate;\n-use rustc_errors::struct_span_err;\n use rustc_metadata::locator;\n use rustc_session::cstore::MetadataLoader;\n use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident};\n-use rustc_span::Span;\n \n-use std::borrow::ToOwned;\n use std::env;\n use std::mem;\n use std::path::PathBuf;\n \n /// Pointer to a registrar function.\n type PluginRegistrarFn = fn(&mut Registry<'_>);\n \n-fn call_malformed_plugin_attribute(sess: &Session, span: Span) {\n-    struct_span_err!(sess, span, E0498, \"malformed `plugin` attribute\")\n-        .span_label(span, \"malformed attribute\")\n-        .emit();\n-}\n-\n /// Read plugin metadata and dynamically load registrar functions.\n pub fn load_plugins(\n     sess: &Session,\n@@ -42,7 +34,9 @@ pub fn load_plugins(\n                 Some(ident) if plugin.is_word() => {\n                     load_plugin(&mut plugins, sess, metadata_loader, ident)\n                 }\n-                _ => call_malformed_plugin_attribute(sess, plugin.span()),\n+                _ => {\n+                    sess.emit_err(MalformedPluginAttribute { span: plugin.span() });\n+                }\n             }\n         }\n     }\n@@ -60,7 +54,7 @@ fn load_plugin(\n     let fun = dylink_registrar(lib).unwrap_or_else(|err| {\n         // This is fatal: there are almost certainly macros we need inside this crate, so\n         // continuing would spew \"macro undefined\" errors.\n-        sess.span_fatal(ident.span, &err.to_string());\n+        sess.emit_fatal(LoadPluginError { span: ident.span, msg: err.to_string() });\n     });\n     plugins.push(fun);\n }"}, {"sha": "25013036d87493017476c616b04671b1d81548b2", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -511,7 +511,7 @@ impl<'a> Resolver<'a> {\n                 err.span_label(span, \"use of generic parameter from outer function\");\n \n                 let sm = self.session.source_map();\n-                match outer_res {\n+                let def_id = match outer_res {\n                     Res::SelfTy { trait_: maybe_trait_defid, alias_to: maybe_impl_defid } => {\n                         if let Some(impl_span) =\n                             maybe_impl_defid.and_then(|(def_id, _)| self.opt_span(def_id))\n@@ -536,40 +536,37 @@ impl<'a> Resolver<'a> {\n                         if let Some(span) = self.opt_span(def_id) {\n                             err.span_label(span, \"type parameter from outer function\");\n                         }\n+                        def_id\n                     }\n                     Res::Def(DefKind::ConstParam, def_id) => {\n                         if let Some(span) = self.opt_span(def_id) {\n                             err.span_label(span, \"const parameter from outer function\");\n                         }\n+                        def_id\n                     }\n                     _ => {\n                         bug!(\n                             \"GenericParamsFromOuterFunction should only be used with Res::SelfTy, \\\n                             DefKind::TyParam or DefKind::ConstParam\"\n                         );\n                     }\n-                }\n+                };\n \n-                if has_generic_params == HasGenericParams::Yes {\n+                if let HasGenericParams::Yes(span) = has_generic_params {\n                     // Try to retrieve the span of the function signature and generate a new\n                     // message with a local type or const parameter.\n                     let sugg_msg = \"try using a local generic parameter instead\";\n-                    if let Some((sugg_span, snippet)) = sm.generate_local_type_param_snippet(span) {\n-                        // Suggest the modification to the user\n-                        err.span_suggestion(\n-                            sugg_span,\n-                            sugg_msg,\n-                            snippet,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else if let Some(sp) = sm.generate_fn_name_span(span) {\n-                        err.span_label(\n-                            sp,\n-                            \"try adding a local generic parameter in this method instead\",\n-                        );\n+                    let name = self.opt_name(def_id).unwrap_or(sym::T);\n+                    let (span, snippet) = if span.is_empty() {\n+                        let snippet = format!(\"<{}>\", name);\n+                        (span, snippet)\n                     } else {\n-                        err.help(\"try using a local generic parameter instead\");\n-                    }\n+                        let span = sm.span_through_char(span, '<').shrink_to_hi();\n+                        let snippet = format!(\"{}, \", name);\n+                        (span, snippet)\n+                    };\n+                    // Suggest the modification to the user\n+                    err.span_suggestion(span, sugg_msg, snippet, Applicability::MaybeIncorrect);\n                 }\n \n                 err"}, {"sha": "41a0c76d83a9539768a276532392e9b8d7853c41", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -13,7 +13,9 @@ use rustc_span::{Span, DUMMY_SP};\n \n use std::ptr;\n \n-use crate::late::{ConstantItemKind, HasGenericParams, PathSource, Rib, RibKind};\n+use crate::late::{\n+    ConstantHasGenerics, ConstantItemKind, HasGenericParams, PathSource, Rib, RibKind,\n+};\n use crate::macros::{sub_namespace_match, MacroRulesScope};\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, Determinacy, Finalize};\n use crate::{ImportKind, LexicalScopeBinding, Module, ModuleKind, ModuleOrUniformRoot};\n@@ -1103,7 +1105,7 @@ impl<'a> Resolver<'a> {\n                         | ForwardGenericParamBanRibKind => {\n                             // Nothing to do. Continue.\n                         }\n-                        ItemRibKind(_) | FnItemRibKind | AssocItemRibKind => {\n+                        ItemRibKind(_) | AssocItemRibKind => {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n                             // report an error.\n@@ -1168,10 +1170,10 @@ impl<'a> Resolver<'a> {\n                     let has_generic_params: HasGenericParams = match rib.kind {\n                         NormalRibKind\n                         | ClosureOrAsyncRibKind\n-                        | AssocItemRibKind\n                         | ModuleRibKind(..)\n                         | MacroDefinition(..)\n                         | InlineAsmSymRibKind\n+                        | AssocItemRibKind\n                         | ForwardGenericParamBanRibKind => {\n                             // Nothing to do. Continue.\n                             continue;\n@@ -1180,7 +1182,9 @@ impl<'a> Resolver<'a> {\n                         ConstantItemRibKind(trivial, _) => {\n                             let features = self.session.features_untracked();\n                             // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n-                            if !(trivial == HasGenericParams::Yes || features.generic_const_exprs) {\n+                            if !(trivial == ConstantHasGenerics::Yes\n+                                || features.generic_const_exprs)\n+                            {\n                                 // HACK(min_const_generics): If we encounter `Self` in an anonymous constant\n                                 // we can't easily tell if it's generic at this stage, so we instead remember\n                                 // this and then enforce the self type to be concrete later on.\n@@ -1207,7 +1211,6 @@ impl<'a> Resolver<'a> {\n \n                         // This was an attempt to use a type parameter outside its scope.\n                         ItemRibKind(has_generic_params) => has_generic_params,\n-                        FnItemRibKind => HasGenericParams::Yes,\n                         ConstParamTyRibKind => {\n                             if let Some(span) = finalize {\n                                 self.report_error(\n@@ -1232,28 +1235,22 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             Res::Def(DefKind::ConstParam, _) => {\n-                let mut ribs = ribs.iter().peekable();\n-                if let Some(Rib { kind: FnItemRibKind, .. }) = ribs.peek() {\n-                    // When declaring const parameters inside function signatures, the first rib\n-                    // is always a `FnItemRibKind`. In this case, we can skip it, to avoid it\n-                    // (spuriously) conflicting with the const param.\n-                    ribs.next();\n-                }\n-\n                 for rib in ribs {\n                     let has_generic_params = match rib.kind {\n                         NormalRibKind\n                         | ClosureOrAsyncRibKind\n-                        | AssocItemRibKind\n                         | ModuleRibKind(..)\n                         | MacroDefinition(..)\n                         | InlineAsmSymRibKind\n+                        | AssocItemRibKind\n                         | ForwardGenericParamBanRibKind => continue,\n \n                         ConstantItemRibKind(trivial, _) => {\n                             let features = self.session.features_untracked();\n                             // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n-                            if !(trivial == HasGenericParams::Yes || features.generic_const_exprs) {\n+                            if !(trivial == ConstantHasGenerics::Yes\n+                                || features.generic_const_exprs)\n+                            {\n                                 if let Some(span) = finalize {\n                                     self.report_error(\n                                         span,\n@@ -1272,7 +1269,6 @@ impl<'a> Resolver<'a> {\n                         }\n \n                         ItemRibKind(has_generic_params) => has_generic_params,\n-                        FnItemRibKind => HasGenericParams::Yes,\n                         ConstParamTyRibKind => {\n                             if let Some(span) = finalize {\n                                 self.report_error("}, {"sha": "693ec86616ee431e3ff70e2bbeeef37228ba70f2", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -91,13 +91,20 @@ enum PatBoundCtx {\n }\n \n /// Does this the item (from the item rib scope) allow generic parameters?\n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+#[derive(Copy, Clone, Debug)]\n pub(crate) enum HasGenericParams {\n+    Yes(Span),\n+    No,\n+}\n+\n+/// May this constant have generics?\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub(crate) enum ConstantHasGenerics {\n     Yes,\n     No,\n }\n \n-impl HasGenericParams {\n+impl ConstantHasGenerics {\n     fn force_yes_if(self, b: bool) -> Self {\n         if b { Self::Yes } else { self }\n     }\n@@ -125,18 +132,14 @@ pub(crate) enum RibKind<'a> {\n     /// We passed through a closure. Disallow labels.\n     ClosureOrAsyncRibKind,\n \n-    /// We passed through a function definition. Disallow upvars.\n-    /// Permit only those const parameters that are specified in the function's generics.\n-    FnItemRibKind,\n-\n     /// We passed through an item scope. Disallow upvars.\n     ItemRibKind(HasGenericParams),\n \n     /// We're in a constant item. Can't refer to dynamic stuff.\n     ///\n     /// The item may reference generic parameters in trivial constant expressions.\n     /// All other constants aren't allowed to use generic params at all.\n-    ConstantItemRibKind(HasGenericParams, Option<(Ident, ConstantItemKind)>),\n+    ConstantItemRibKind(ConstantHasGenerics, Option<(Ident, ConstantItemKind)>),\n \n     /// We passed through a module.\n     ModuleRibKind(Module<'a>),\n@@ -165,7 +168,6 @@ impl RibKind<'_> {\n         match self {\n             NormalRibKind\n             | ClosureOrAsyncRibKind\n-            | FnItemRibKind\n             | ConstantItemRibKind(..)\n             | ModuleRibKind(_)\n             | MacroDefinition(_)\n@@ -182,7 +184,6 @@ impl RibKind<'_> {\n \n             AssocItemRibKind\n             | ClosureOrAsyncRibKind\n-            | FnItemRibKind\n             | ItemRibKind(..)\n             | ConstantItemRibKind(..)\n             | ModuleRibKind(..)\n@@ -751,7 +752,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                 self.with_lifetime_rib(LifetimeRibKind::Item, |this| {\n                     this.with_generic_param_rib(\n                         &generics.params,\n-                        ItemRibKind(HasGenericParams::Yes),\n+                        ItemRibKind(HasGenericParams::Yes(generics.span)),\n                         LifetimeRibKind::Generics {\n                             binder: foreign_item.id,\n                             kind: LifetimeBinderKind::Item,\n@@ -765,7 +766,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                 self.with_lifetime_rib(LifetimeRibKind::Item, |this| {\n                     this.with_generic_param_rib(\n                         &generics.params,\n-                        ItemRibKind(HasGenericParams::Yes),\n+                        ItemRibKind(HasGenericParams::Yes(generics.span)),\n                         LifetimeRibKind::Generics {\n                             binder: foreign_item.id,\n                             kind: LifetimeBinderKind::Function,\n@@ -786,7 +787,8 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         }\n     }\n     fn visit_fn(&mut self, fn_kind: FnKind<'ast>, sp: Span, fn_id: NodeId) {\n-        let rib_kind = match fn_kind {\n+        let previous_value = self.diagnostic_metadata.current_function;\n+        match fn_kind {\n             // Bail if the function is foreign, and thus cannot validly have\n             // a body, or if there's no body for some other reason.\n             FnKind::Fn(FnCtxt::Foreign, _, sig, _, generics, _)\n@@ -809,20 +811,18 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                 );\n                 return;\n             }\n-            FnKind::Fn(FnCtxt::Free, ..) => FnItemRibKind,\n-            FnKind::Fn(FnCtxt::Assoc(_), ..) => NormalRibKind,\n-            FnKind::Closure(..) => ClosureOrAsyncRibKind,\n+            FnKind::Fn(..) => {\n+                self.diagnostic_metadata.current_function = Some((fn_kind, sp));\n+            }\n+            // Do not update `current_function` for closures: it suggests `self` parameters.\n+            FnKind::Closure(..) => {}\n         };\n-        let previous_value = self.diagnostic_metadata.current_function;\n-        if matches!(fn_kind, FnKind::Fn(..)) {\n-            self.diagnostic_metadata.current_function = Some((fn_kind, sp));\n-        }\n         debug!(\"(resolving function) entering function\");\n \n         // Create a value rib for the function.\n-        self.with_rib(ValueNS, rib_kind, |this| {\n+        self.with_rib(ValueNS, ClosureOrAsyncRibKind, |this| {\n             // Create a label rib for the function.\n-            this.with_label_rib(FnItemRibKind, |this| {\n+            this.with_label_rib(ClosureOrAsyncRibKind, |this| {\n                 match fn_kind {\n                     FnKind::Fn(_, _, sig, _, generics, body) => {\n                         this.visit_generics(generics);\n@@ -995,7 +995,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                             // non-trivial constants this is doesn't matter.\n                             self.with_constant_rib(\n                                 IsRepeatExpr::No,\n-                                HasGenericParams::Yes,\n+                                ConstantHasGenerics::Yes,\n                                 None,\n                                 |this| {\n                                     this.smart_resolve_path(\n@@ -2071,7 +2071,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         self.with_current_self_item(item, |this| {\n             this.with_generic_param_rib(\n                 &generics.params,\n-                ItemRibKind(HasGenericParams::Yes),\n+                ItemRibKind(HasGenericParams::Yes(generics.span)),\n                 LifetimeRibKind::Generics {\n                     binder: item.id,\n                     kind: LifetimeBinderKind::Item,\n@@ -2141,7 +2141,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             ItemKind::TyAlias(box TyAlias { ref generics, .. }) => {\n                 self.with_generic_param_rib(\n                     &generics.params,\n-                    ItemRibKind(HasGenericParams::Yes),\n+                    ItemRibKind(HasGenericParams::Yes(generics.span)),\n                     LifetimeRibKind::Generics {\n                         binder: item.id,\n                         kind: LifetimeBinderKind::Item,\n@@ -2154,7 +2154,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             ItemKind::Fn(box Fn { ref generics, .. }) => {\n                 self.with_generic_param_rib(\n                     &generics.params,\n-                    ItemRibKind(HasGenericParams::Yes),\n+                    ItemRibKind(HasGenericParams::Yes(generics.span)),\n                     LifetimeRibKind::Generics {\n                         binder: item.id,\n                         kind: LifetimeBinderKind::Function,\n@@ -2186,7 +2186,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_generic_param_rib(\n                     &generics.params,\n-                    ItemRibKind(HasGenericParams::Yes),\n+                    ItemRibKind(HasGenericParams::Yes(generics.span)),\n                     LifetimeRibKind::Generics {\n                         binder: item.id,\n                         kind: LifetimeBinderKind::Item,\n@@ -2210,7 +2210,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_generic_param_rib(\n                     &generics.params,\n-                    ItemRibKind(HasGenericParams::Yes),\n+                    ItemRibKind(HasGenericParams::Yes(generics.span)),\n                     LifetimeRibKind::Generics {\n                         binder: item.id,\n                         kind: LifetimeBinderKind::Item,\n@@ -2251,7 +2251,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                             // so it doesn't matter whether this is a trivial constant.\n                             this.with_constant_rib(\n                                 IsRepeatExpr::No,\n-                                HasGenericParams::Yes,\n+                                ConstantHasGenerics::Yes,\n                                 Some((item.ident, constant_item_kind)),\n                                 |this| this.visit_expr(expr),\n                             );\n@@ -2450,7 +2450,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     fn with_constant_rib(\n         &mut self,\n         is_repeat: IsRepeatExpr,\n-        may_use_generics: HasGenericParams,\n+        may_use_generics: ConstantHasGenerics,\n         item: Option<(Ident, ConstantItemKind)>,\n         f: impl FnOnce(&mut Self),\n     ) {\n@@ -2517,7 +2517,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                             |this| {\n                                 this.with_constant_rib(\n                                     IsRepeatExpr::No,\n-                                    HasGenericParams::Yes,\n+                                    ConstantHasGenerics::Yes,\n                                     None,\n                                     |this| this.visit_expr(expr),\n                                 )\n@@ -2598,7 +2598,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         // If applicable, create a rib for the type parameters.\n         self.with_generic_param_rib(\n             &generics.params,\n-            ItemRibKind(HasGenericParams::Yes),\n+            ItemRibKind(HasGenericParams::Yes(generics.span)),\n             LifetimeRibKind::Generics {\n                 span: generics.span,\n                 binder: item_id,\n@@ -2689,7 +2689,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     self.with_lifetime_rib(LifetimeRibKind::Elided(LifetimeRes::Infer), |this| {\n                         this.with_constant_rib(\n                             IsRepeatExpr::No,\n-                            HasGenericParams::Yes,\n+                            ConstantHasGenerics::Yes,\n                             None,\n                             |this| this.visit_expr(expr),\n                         )\n@@ -3696,9 +3696,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         self.with_constant_rib(\n             is_repeat,\n             if constant.value.is_potential_trivial_const_param() {\n-                HasGenericParams::Yes\n+                ConstantHasGenerics::Yes\n             } else {\n-                HasGenericParams::No\n+                ConstantHasGenerics::No\n             },\n             None,\n             |this| visit::walk_anon_const(this, constant),\n@@ -3707,8 +3707,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n     fn resolve_inline_const(&mut self, constant: &'ast AnonConst) {\n         debug!(\"resolve_anon_const {constant:?}\");\n-        self.with_constant_rib(IsRepeatExpr::No, HasGenericParams::Yes, None, |this| {\n-            visit::walk_anon_const(this, constant);\n+        self.with_constant_rib(IsRepeatExpr::No, ConstantHasGenerics::Yes, None, |this| {\n+            visit::walk_anon_const(this, constant)\n         });\n     }\n \n@@ -3814,9 +3814,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         self.with_constant_rib(\n                             IsRepeatExpr::No,\n                             if argument.is_potential_trivial_const_param() {\n-                                HasGenericParams::Yes\n+                                ConstantHasGenerics::Yes\n                             } else {\n-                                HasGenericParams::No\n+                                ConstantHasGenerics::No\n                             },\n                             None,\n                             |this| {"}, {"sha": "eb727debc91bb558cc3ff4bea34771fe13dcb4f5", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -1945,6 +1945,16 @@ impl<'a> Resolver<'a> {\n         def_id.as_local().map(|def_id| self.source_span[def_id])\n     }\n \n+    /// Retrieves the name of the given `DefId`.\n+    #[inline]\n+    pub fn opt_name(&self, def_id: DefId) -> Option<Symbol> {\n+        let def_key = match def_id.as_local() {\n+            Some(def_id) => self.definitions.def_key(def_id),\n+            None => self.cstore().def_key(def_id),\n+        };\n+        def_key.get_opt_name()\n+    }\n+\n     /// Checks if an expression refers to a function marked with\n     /// `#[rustc_legacy_const_generics]` and returns the argument index list\n     /// from the attribute."}, {"sha": "a32cabab4c407281a0190e9dba473a863086b8bf", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -982,93 +982,6 @@ impl SourceMap {\n         self.files().iter().fold(0, |a, f| a + f.count_lines())\n     }\n \n-    pub fn generate_fn_name_span(&self, span: Span) -> Option<Span> {\n-        let prev_span = self.span_extend_to_prev_str(span, \"fn\", true, true)?;\n-        if let Ok(snippet) = self.span_to_snippet(prev_span) {\n-            debug!(\n-                \"generate_fn_name_span: span={:?}, prev_span={:?}, snippet={:?}\",\n-                span, prev_span, snippet\n-            );\n-\n-            if snippet.is_empty() {\n-                return None;\n-            };\n-\n-            let len = snippet\n-                .find(|c: char| !c.is_alphanumeric() && c != '_')\n-                .expect(\"no label after fn\");\n-            Some(prev_span.with_hi(BytePos(prev_span.lo().0 + len as u32)))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Takes the span of a type parameter in a function signature and try to generate a span for\n-    /// the function name (with generics) and a new snippet for this span with the pointed type\n-    /// parameter as a new local type parameter.\n-    ///\n-    /// For instance:\n-    /// ```rust,ignore (pseudo-Rust)\n-    /// // Given span\n-    /// fn my_function(param: T)\n-    /// //                    ^ Original span\n-    ///\n-    /// // Result\n-    /// fn my_function(param: T)\n-    /// // ^^^^^^^^^^^ Generated span with snippet `my_function<T>`\n-    /// ```\n-    ///\n-    /// Attention: The method used is very fragile since it essentially duplicates the work of the\n-    /// parser. If you need to use this function or something similar, please consider updating the\n-    /// `SourceMap` functions and this function to something more robust.\n-    pub fn generate_local_type_param_snippet(&self, span: Span) -> Option<(Span, String)> {\n-        // Try to extend the span to the previous \"fn\" keyword to retrieve the function\n-        // signature.\n-        if let Some(sugg_span) = self.span_extend_to_prev_str(span, \"fn\", false, true) {\n-            if let Ok(snippet) = self.span_to_snippet(sugg_span) {\n-                // Consume the function name.\n-                let mut offset = snippet\n-                    .find(|c: char| !c.is_alphanumeric() && c != '_')\n-                    .expect(\"no label after fn\");\n-\n-                // Consume the generics part of the function signature.\n-                let mut bracket_counter = 0;\n-                let mut last_char = None;\n-                for c in snippet[offset..].chars() {\n-                    match c {\n-                        '<' => bracket_counter += 1,\n-                        '>' => bracket_counter -= 1,\n-                        '(' => {\n-                            if bracket_counter == 0 {\n-                                break;\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                    offset += c.len_utf8();\n-                    last_char = Some(c);\n-                }\n-\n-                // Adjust the suggestion span to encompass the function name with its generics.\n-                let sugg_span = sugg_span.with_hi(BytePos(sugg_span.lo().0 + offset as u32));\n-\n-                // Prepare the new suggested snippet to append the type parameter that triggered\n-                // the error in the generics of the function signature.\n-                let mut new_snippet = if last_char == Some('>') {\n-                    format!(\"{}, \", &snippet[..(offset - '>'.len_utf8())])\n-                } else {\n-                    format!(\"{}<\", &snippet[..offset])\n-                };\n-                new_snippet\n-                    .push_str(&self.span_to_snippet(span).unwrap_or_else(|_| \"T\".to_string()));\n-                new_snippet.push('>');\n-\n-                return Some((sugg_span, new_snippet));\n-            }\n-        }\n-\n-        None\n-    }\n     pub fn ensure_source_file_source_present(&self, source_file: Lrc<SourceFile>) -> bool {\n         source_file.add_external_src(|| {\n             match source_file.name {"}, {"sha": "c8978845ffb0d35699e65e56c7aa2164a9aa7308", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -280,6 +280,7 @@ symbols! {\n         StructuralPartialEq,\n         SubdiagnosticMessage,\n         Sync,\n+        T,\n         Target,\n         ToOwned,\n         ToString,"}, {"sha": "d922f893321a8a621c87f629c023fa473452f075", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -473,9 +473,6 @@ pub fn impossible_predicates<'tcx>(\n     debug!(\"impossible_predicates(predicates={:?})\", predicates);\n \n     let result = tcx.infer_ctxt().enter(|infcx| {\n-        // HACK: Set tainted by errors to gracefully exit in case of overflow.\n-        infcx.set_tainted_by_errors();\n-\n         let param_env = ty::ParamEnv::reveal_all();\n         let ocx = ObligationCtxt::new(&infcx);\n         let predicates = ocx.normalize(ObligationCause::dummy(), param_env, predicates);"}, {"sha": "df171c2531a7a901c68615582ca45b2275cf40f5", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -858,8 +858,7 @@ fn compare_synthetic_generics<'tcx>(\n     {\n         if impl_synthetic != trait_synthetic {\n             let impl_def_id = impl_def_id.expect_local();\n-            let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_def_id);\n-            let impl_span = tcx.hir().span(impl_hir_id);\n+            let impl_span = tcx.def_span(impl_def_id);\n             let trait_span = tcx.def_span(trait_def_id);\n             let mut err = struct_span_err!(\n                 tcx.sess,\n@@ -878,17 +877,16 @@ fn compare_synthetic_generics<'tcx>(\n                         // try taking the name from the trait impl\n                         // FIXME: this is obviously suboptimal since the name can already be used\n                         // as another generic argument\n-                        let new_name = tcx.sess.source_map().span_to_snippet(trait_span).ok()?;\n+                        let new_name = tcx.opt_item_name(trait_def_id)?;\n                         let trait_m = trait_m.def_id.as_local()?;\n-                        let trait_m = tcx.hir().trait_item(hir::TraitItemId { def_id: trait_m });\n+                        let trait_m = tcx.hir().expect_trait_item(trait_m);\n \n                         let impl_m = impl_m.def_id.as_local()?;\n-                        let impl_m = tcx.hir().impl_item(hir::ImplItemId { def_id: impl_m });\n+                        let impl_m = tcx.hir().expect_impl_item(impl_m);\n \n                         // in case there are no generics, take the spot between the function name\n                         // and the opening paren of the argument list\n-                        let new_generics_span =\n-                            tcx.sess.source_map().generate_fn_name_span(impl_span)?.shrink_to_hi();\n+                        let new_generics_span = tcx.def_ident_span(impl_def_id)?.shrink_to_hi();\n                         // in case there are generics, just replace them\n                         let generics_span =\n                             impl_m.generics.span.substitute_dummy(new_generics_span);\n@@ -900,7 +898,7 @@ fn compare_synthetic_generics<'tcx>(\n                             \"try changing the `impl Trait` argument to a generic parameter\",\n                             vec![\n                                 // replace `impl Trait` with `T`\n-                                (impl_span, new_name),\n+                                (impl_span, new_name.to_string()),\n                                 // replace impl method generics with trait method generics\n                                 // This isn't quite right, as users might have changed the names\n                                 // of the generics, but it works for the common case\n@@ -917,7 +915,7 @@ fn compare_synthetic_generics<'tcx>(\n                     err.span_label(impl_span, \"expected `impl Trait`, found generic parameter\");\n                     (|| {\n                         let impl_m = impl_m.def_id.as_local()?;\n-                        let impl_m = tcx.hir().impl_item(hir::ImplItemId { def_id: impl_m });\n+                        let impl_m = tcx.hir().expect_impl_item(impl_m);\n                         let input_tys = match impl_m.kind {\n                             hir::ImplItemKind::Fn(ref sig, _) => sig.decl.inputs,\n                             _ => unreachable!(),"}, {"sha": "71ae54bedce46ed3012fb969b77b9845a9ddd3d4", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -1556,7 +1556,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut error_happened = false;\n \n         // Type-check each field.\n-        for field in ast_fields {\n+        for (idx, field) in ast_fields.iter().enumerate() {\n             let ident = tcx.adjust_ident(field.ident, variant.def_id);\n             let field_type = if let Some((i, v_field)) = remaining_fields.remove(&ident) {\n                 seen_fields.insert(ident, field.span);\n@@ -1594,7 +1594,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Make sure to give a type to the field even if there's\n             // an error, so we can continue type-checking.\n-            self.check_expr_coercable_to_type(&field.expr, field_type, None);\n+            let ty = self.check_expr_with_hint(&field.expr, field_type);\n+            let (_, diag) =\n+                self.demand_coerce_diag(&field.expr, ty, field_type, None, AllowTwoPhase::No);\n+\n+            if let Some(mut diag) = diag {\n+                if idx == ast_fields.len() - 1 && remaining_fields.is_empty() {\n+                    self.suggest_fru_from_range(field, variant, substs, &mut diag);\n+                }\n+                diag.emit();\n+            }\n         }\n \n         // Make sure the programmer specified correct number of fields.\n@@ -1822,25 +1831,35 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n         err.span_label(span, format!(\"missing {remaining_fields_names}{truncated_fields_error}\"));\n \n-        // If the last field is a range literal, but it isn't supposed to be, then they probably\n-        // meant to use functional update syntax.\n-        //\n+        if let Some(last) = ast_fields.last() {\n+            self.suggest_fru_from_range(last, variant, substs, &mut err);\n+        }\n+\n+        err.emit();\n+    }\n+\n+    /// If the last field is a range literal, but it isn't supposed to be, then they probably\n+    /// meant to use functional update syntax.\n+    fn suggest_fru_from_range(\n+        &self,\n+        last_expr_field: &hir::ExprField<'tcx>,\n+        variant: &ty::VariantDef,\n+        substs: SubstsRef<'tcx>,\n+        err: &mut Diagnostic,\n+    ) {\n         // I don't use 'is_range_literal' because only double-sided, half-open ranges count.\n-        if let Some((\n-            last,\n-            ExprKind::Struct(\n+        if let ExprKind::Struct(\n                 QPath::LangItem(LangItem::Range, ..),\n                 &[ref range_start, ref range_end],\n                 _,\n-            ),\n-        )) = ast_fields.last().map(|last| (last, &last.expr.kind)) &&\n-        let variant_field =\n-            variant.fields.iter().find(|field| field.ident(self.tcx) == last.ident) &&\n-        let range_def_id = self.tcx.lang_items().range_struct() &&\n-        variant_field\n-            .and_then(|field| field.ty(self.tcx, substs).ty_adt_def())\n-            .map(|adt| adt.did())\n-            != range_def_id\n+            ) = last_expr_field.expr.kind\n+            && let variant_field =\n+                variant.fields.iter().find(|field| field.ident(self.tcx) == last_expr_field.ident)\n+            && let range_def_id = self.tcx.lang_items().range_struct()\n+            && variant_field\n+                .and_then(|field| field.ty(self.tcx, substs).ty_adt_def())\n+                .map(|adt| adt.did())\n+                != range_def_id\n         {\n             let instead = self\n                 .tcx\n@@ -1856,8 +1875,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Applicability::MaybeIncorrect,\n             );\n         }\n-\n-        err.emit();\n     }\n \n     /// Report an error for a struct field expression when there are invisible fields."}, {"sha": "03bd485096a9c5046a97d1f072e6532094e56538", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -1136,7 +1136,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 opt_ty.unwrap_or_else(|| self.next_float_var())\n             }\n             ast::LitKind::Bool(_) => tcx.types.bool,\n-            ast::LitKind::Err(_) => tcx.ty_error(),\n+            ast::LitKind::Err => tcx.ty_error(),\n         }\n     }\n "}, {"sha": "02090afc82f7e7e0e9139533bde155af4629f9bb", "filename": "library/std/src/os/unix/net/listener.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Flistener.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Flistener.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Flistener.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -73,10 +73,8 @@ impl UnixListener {\n         unsafe {\n             let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n             let (addr, len) = sockaddr_un(path.as_ref())?;\n-            #[cfg(target_os = \"linux\")]\n-            const backlog: libc::c_int = -1;\n-            #[cfg(not(target_os = \"linux\"))]\n-            const backlog: libc::c_int = 128;\n+            const backlog: libc::c_int =\n+                if cfg!(any(target_os = \"linux\", target_os = \"freebsd\")) { -1 } else { 128 };\n \n             cvt(libc::bind(inner.as_inner().as_raw_fd(), &addr as *const _ as *const _, len as _))?;\n             cvt(libc::listen(inner.as_inner().as_raw_fd(), backlog))?;"}, {"sha": "e3bf38b702e755b767cbb35fcd37cfc3b7828760", "filename": "src/test/ui/const-generics/early/const-param-from-outer-fn.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fconst-generics%2Fearly%2Fconst-param-from-outer-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fconst-generics%2Fearly%2Fconst-param-from-outer-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fearly%2Fconst-param-from-outer-fn.stderr?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -4,7 +4,7 @@ error[E0401]: can't use generic parameters from outer function\n LL | fn foo<const X: u32>() {\n    |              - const parameter from outer function\n LL |     fn bar() -> u32 {\n-   |        --- try adding a local generic parameter in this method instead\n+   |           - help: try using a local generic parameter instead: `<X>`\n LL |         X\n    |         ^ use of generic parameter from outer function\n "}, {"sha": "b0e2ef5b6f7e3d65c101e62994552805c9775500", "filename": "src/test/ui/error-codes/E0401.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -4,9 +4,9 @@ error[E0401]: can't use generic parameters from outer function\n LL | fn foo<T>(x: T) {\n    |        - type parameter from outer function\n LL |     fn bfnr<U, V: Baz<U>, W: Fn()>(y: T) {\n-   |        ---------------------------    ^ use of generic parameter from outer function\n-   |        |\n-   |        help: try using a local generic parameter instead: `bfnr<U, V: Baz<U>, W: Fn(), T>`\n+   |             -                         ^ use of generic parameter from outer function\n+   |             |\n+   |             help: try using a local generic parameter instead: `T,`\n \n error[E0401]: can't use generic parameters from outer function\n   --> $DIR/E0401.rs:9:16\n@@ -15,7 +15,7 @@ LL | fn foo<T>(x: T) {\n    |        - type parameter from outer function\n ...\n LL |     fn baz<U,\n-   |        --- try adding a local generic parameter in this method instead\n+   |            - help: try using a local generic parameter instead: `T,`\n ...\n LL |            (y: T) {\n    |                ^ use of generic parameter from outer function"}, {"sha": "c7b5c33618d5f7b3237ebd49c23cae34b53e2d81", "filename": "src/test/ui/generics/issue-98432.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fgenerics%2Fissue-98432.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fgenerics%2Fissue-98432.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerics%2Fissue-98432.stderr?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -5,9 +5,9 @@ LL | impl<T> Struct<T> {\n    |      - type parameter from outer function\n LL |     const CONST: fn() = || {\n LL |         struct _Obligation where T:;\n-   |                                  ^ use of generic parameter from outer function\n-   |\n-   = help: try using a local generic parameter instead\n+   |                           -      ^ use of generic parameter from outer function\n+   |                           |\n+   |                           help: try using a local generic parameter instead: `<T>`\n \n error: aborting due to previous error\n "}, {"sha": "aa0b5ce64b4213b275969d528b73d78eaa5e6813", "filename": "src/test/ui/issues/issue-3214.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fissues%2Fissue-3214.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fissues%2Fissue-3214.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3214.stderr?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -2,10 +2,9 @@ error[E0401]: can't use generic parameters from outer function\n   --> $DIR/issue-3214.rs:3:12\n    |\n LL | fn foo<T>() {\n-   |    --- - type parameter from outer function\n-   |    |\n-   |    try adding a local generic parameter in this method instead\n+   |        - type parameter from outer function\n LL |     struct Foo {\n+   |               - help: try using a local generic parameter instead: `<T>`\n LL |         x: T,\n    |            ^ use of generic parameter from outer function\n "}, {"sha": "3a79215d3ae9c4c62ed13177f5bc49c437621716", "filename": "src/test/ui/issues/issue-5997-enum.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fissues%2Fissue-5997-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fissues%2Fissue-5997-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5997-enum.stderr?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -2,11 +2,11 @@ error[E0401]: can't use generic parameters from outer function\n   --> $DIR/issue-5997-enum.rs:2:16\n    |\n LL | fn f<Z>() -> bool {\n-   |    - - type parameter from outer function\n-   |    |\n-   |    try adding a local generic parameter in this method instead\n+   |      - type parameter from outer function\n LL |     enum E { V(Z) }\n-   |                ^ use of generic parameter from outer function\n+   |           -    ^ use of generic parameter from outer function\n+   |           |\n+   |           help: try using a local generic parameter instead: `<Z>`\n \n error: aborting due to previous error\n "}, {"sha": "d2e97f767719fc56884861bd2aa11a529913e193", "filename": "src/test/ui/issues/issue-5997-struct.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fissues%2Fissue-5997-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fissues%2Fissue-5997-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5997-struct.stderr?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -2,11 +2,11 @@ error[E0401]: can't use generic parameters from outer function\n   --> $DIR/issue-5997-struct.rs:2:14\n    |\n LL | fn f<T>() -> bool {\n-   |    - - type parameter from outer function\n-   |    |\n-   |    try adding a local generic parameter in this method instead\n+   |      - type parameter from outer function\n LL |     struct S(T);\n-   |              ^ use of generic parameter from outer function\n+   |             -^ use of generic parameter from outer function\n+   |             |\n+   |             help: try using a local generic parameter instead: `<T>`\n \n error: aborting due to previous error\n "}, {"sha": "8f4746f5ec3bdb2e0e4aae9ff386866a6ae44c64", "filename": "src/test/ui/nested-ty-params.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fnested-ty-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fnested-ty-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnested-ty-params.stderr?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -4,19 +4,19 @@ error[E0401]: can't use generic parameters from outer function\n LL | fn hd<U>(v: Vec<U> ) -> U {\n    |       - type parameter from outer function\n LL |     fn hd1(w: [U]) -> U { return w[0]; }\n-   |        ---     ^ use of generic parameter from outer function\n-   |        |\n-   |        help: try using a local generic parameter instead: `hd1<U>`\n+   |           -    ^ use of generic parameter from outer function\n+   |           |\n+   |           help: try using a local generic parameter instead: `<U>`\n \n error[E0401]: can't use generic parameters from outer function\n   --> $DIR/nested-ty-params.rs:3:23\n    |\n LL | fn hd<U>(v: Vec<U> ) -> U {\n    |       - type parameter from outer function\n LL |     fn hd1(w: [U]) -> U { return w[0]; }\n-   |        ---            ^ use of generic parameter from outer function\n-   |        |\n-   |        help: try using a local generic parameter instead: `hd1<U>`\n+   |           -           ^ use of generic parameter from outer function\n+   |           |\n+   |           help: try using a local generic parameter instead: `<U>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "b6282c2d0703b8fae7a0517bbddfc505cdccee24", "filename": "src/test/ui/resolve/bad-type-env-capture.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fresolve%2Fbad-type-env-capture.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fresolve%2Fbad-type-env-capture.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fbad-type-env-capture.stderr?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -4,9 +4,9 @@ error[E0401]: can't use generic parameters from outer function\n LL | fn foo<T>() {\n    |        - type parameter from outer function\n LL |     fn bar(b: T) { }\n-   |        ---    ^ use of generic parameter from outer function\n-   |        |\n-   |        help: try using a local generic parameter instead: `bar<T>`\n+   |           -   ^ use of generic parameter from outer function\n+   |           |\n+   |           help: try using a local generic parameter instead: `<T>`\n \n error: aborting due to previous error\n "}, {"sha": "5176efc3a6be71cdec18386b30c74ec79016fdb2", "filename": "src/test/ui/resolve/issue-3021-c.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fresolve%2Fissue-3021-c.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fresolve%2Fissue-3021-c.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-3021-c.stderr?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -3,22 +3,22 @@ error[E0401]: can't use generic parameters from outer function\n    |\n LL | fn siphash<T>() {\n    |            - type parameter from outer function\n-...\n+LL |\n+LL |     trait U {\n+   |            - help: try using a local generic parameter instead: `<T>`\n LL |         fn g(&self, x: T) -> T;\n-   |            -           ^ use of generic parameter from outer function\n-   |            |\n-   |            help: try using a local generic parameter instead: `g<T>`\n+   |                        ^ use of generic parameter from outer function\n \n error[E0401]: can't use generic parameters from outer function\n   --> $DIR/issue-3021-c.rs:4:30\n    |\n LL | fn siphash<T>() {\n    |            - type parameter from outer function\n-...\n+LL |\n+LL |     trait U {\n+   |            - help: try using a local generic parameter instead: `<T>`\n LL |         fn g(&self, x: T) -> T;\n-   |            -                 ^ use of generic parameter from outer function\n-   |            |\n-   |            help: try using a local generic parameter instead: `g<T>`\n+   |                              ^ use of generic parameter from outer function\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0a6d1cc3bcd45fe00be2b9c68b62329bb6678eb1", "filename": "src/test/ui/resolve/resolve-type-param-in-item-in-trait.stderr", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fresolve%2Fresolve-type-param-in-item-in-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fresolve%2Fresolve-type-param-in-item-in-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-type-param-in-item-in-trait.stderr?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -4,8 +4,8 @@ error[E0401]: can't use generic parameters from outer function\n LL | trait TraitA<A> {\n    |              - type parameter from outer function\n LL |     fn outer(&self) {\n-   |        ----- try adding a local generic parameter in this method instead\n LL |         enum Foo<B> {\n+   |                  - help: try using a local generic parameter instead: `A,`\n LL |             Variance(A)\n    |                      ^ use of generic parameter from outer function\n \n@@ -15,19 +15,21 @@ error[E0401]: can't use generic parameters from outer function\n LL | trait TraitB<A> {\n    |              - type parameter from outer function\n LL |     fn outer(&self) {\n-   |        ----- try adding a local generic parameter in this method instead\n LL |         struct Foo<B>(A);\n-   |                       ^ use of generic parameter from outer function\n+   |                    -  ^ use of generic parameter from outer function\n+   |                    |\n+   |                    help: try using a local generic parameter instead: `A,`\n \n error[E0401]: can't use generic parameters from outer function\n   --> $DIR/resolve-type-param-in-item-in-trait.rs:23:28\n    |\n LL | trait TraitC<A> {\n    |              - type parameter from outer function\n LL |     fn outer(&self) {\n-   |        ----- try adding a local generic parameter in this method instead\n LL |         struct Foo<B> { a: A }\n-   |                            ^ use of generic parameter from outer function\n+   |                    -       ^ use of generic parameter from outer function\n+   |                    |\n+   |                    help: try using a local generic parameter instead: `A,`\n \n error[E0401]: can't use generic parameters from outer function\n   --> $DIR/resolve-type-param-in-item-in-trait.rs:30:22\n@@ -36,9 +38,9 @@ LL | trait TraitD<A> {\n    |              - type parameter from outer function\n LL |     fn outer(&self) {\n LL |         fn foo<B>(a: A) { }\n-   |            ------    ^ use of generic parameter from outer function\n-   |            |\n-   |            help: try using a local generic parameter instead: `foo<B, A>`\n+   |                -     ^ use of generic parameter from outer function\n+   |                |\n+   |                help: try using a local generic parameter instead: `A,`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "49e38b196deb210e7cd3258b9c2601cad92972fc", "filename": "src/test/ui/structs/struct-record-suggestion.fixed", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fstructs%2Fstruct-record-suggestion.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fstructs%2Fstruct-record-suggestion.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-record-suggestion.fixed?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -6,11 +6,29 @@ struct A {\n     d: usize,\n }\n \n-fn main() {\n-    let q = A { c: 5, .. Default::default() };\n+fn a() {\n+    let q = A { c: 5,..Default::default() };\n     //~^ ERROR mismatched types\n     //~| ERROR missing fields\n     //~| HELP separate the last named field with a comma\n-    let r = A { c: 5, .. Default::default() };\n+    let r = A { c: 5, ..Default::default() };\n     assert_eq!(q, r);\n }\n+\n+#[derive(Debug, Default, Eq, PartialEq)]\n+struct B {\n+    b: u32,\n+}\n+\n+fn b() {\n+    let q = B { b: 1,..Default::default() };\n+    //~^ ERROR mismatched types\n+    //~| HELP separate the last named field with a comma\n+    let r = B { b: 1 };\n+    assert_eq!(q, r);\n+}\n+\n+fn main() {\n+    a();\n+    b();\n+}"}, {"sha": "901f310c8bdb21a7434a1d611ce11c7d158b6506", "filename": "src/test/ui/structs/struct-record-suggestion.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fstructs%2Fstruct-record-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fstructs%2Fstruct-record-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-record-suggestion.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -6,11 +6,29 @@ struct A {\n     d: usize,\n }\n \n-fn main() {\n-    let q = A { c: 5 .. Default::default() };\n+fn a() {\n+    let q = A { c: 5..Default::default() };\n     //~^ ERROR mismatched types\n     //~| ERROR missing fields\n     //~| HELP separate the last named field with a comma\n-    let r = A { c: 5, .. Default::default() };\n+    let r = A { c: 5, ..Default::default() };\n     assert_eq!(q, r);\n }\n+\n+#[derive(Debug, Default, Eq, PartialEq)]\n+struct B {\n+    b: u32,\n+}\n+\n+fn b() {\n+    let q = B { b: 1..Default::default() };\n+    //~^ ERROR mismatched types\n+    //~| HELP separate the last named field with a comma\n+    let r = B { b: 1 };\n+    assert_eq!(q, r);\n+}\n+\n+fn main() {\n+    a();\n+    b();\n+}"}, {"sha": "66e9f021ed68fbfb60a3b5ec7ba20a7a81db77f0", "filename": "src/test/ui/structs/struct-record-suggestion.stderr", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fstructs%2Fstruct-record-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Fstructs%2Fstruct-record-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-record-suggestion.stderr?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -1,24 +1,37 @@\n error[E0308]: mismatched types\n   --> $DIR/struct-record-suggestion.rs:10:20\n    |\n-LL |     let q = A { c: 5 .. Default::default() };\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found struct `std::ops::Range`\n+LL |     let q = A { c: 5..Default::default() };\n+   |                    ^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found struct `std::ops::Range`\n    |\n    = note: expected type `u64`\n             found struct `std::ops::Range<{integer}>`\n \n error[E0063]: missing fields `b` and `d` in initializer of `A`\n   --> $DIR/struct-record-suggestion.rs:10:13\n    |\n-LL |     let q = A { c: 5 .. Default::default() };\n+LL |     let q = A { c: 5..Default::default() };\n    |             ^ missing `b` and `d`\n    |\n help: to set the remaining fields from `Default::default()`, separate the last named field with a comma\n    |\n-LL |     let q = A { c: 5, .. Default::default() };\n+LL |     let q = A { c: 5,..Default::default() };\n    |                     +\n \n-error: aborting due to 2 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/struct-record-suggestion.rs:24:20\n+   |\n+LL |     let q = B { b: 1..Default::default() };\n+   |                    ^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found struct `std::ops::Range`\n+   |\n+   = note: expected type `u32`\n+            found struct `std::ops::Range<{integer}>`\n+help: to set the remaining fields from `Default::default()`, separate the last named field with a comma\n+   |\n+LL |     let q = B { b: 1,..Default::default() };\n+   |                     +\n+\n+error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0063, E0308.\n For more information about an error, try `rustc --explain E0063`."}, {"sha": "7f18b4510f4b2b3651e66bd34d5834193990d9d8", "filename": "src/test/ui/type/type-arg-out-of-scope.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Ftype%2Ftype-arg-out-of-scope.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftest%2Fui%2Ftype%2Ftype-arg-out-of-scope.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-arg-out-of-scope.stderr?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -4,19 +4,19 @@ error[E0401]: can't use generic parameters from outer function\n LL | fn foo<T>(x: T) {\n    |        - type parameter from outer function\n LL |     fn bar(f: Box<dyn FnMut(T) -> T>) { }\n-   |        ---                  ^ use of generic parameter from outer function\n-   |        |\n-   |        help: try using a local generic parameter instead: `bar<T>`\n+   |           -                 ^ use of generic parameter from outer function\n+   |           |\n+   |           help: try using a local generic parameter instead: `<T>`\n \n error[E0401]: can't use generic parameters from outer function\n   --> $DIR/type-arg-out-of-scope.rs:3:35\n    |\n LL | fn foo<T>(x: T) {\n    |        - type parameter from outer function\n LL |     fn bar(f: Box<dyn FnMut(T) -> T>) { }\n-   |        ---                        ^ use of generic parameter from outer function\n-   |        |\n-   |        help: try using a local generic parameter instead: `bar<T>`\n+   |           -                       ^ use of generic parameter from outer function\n+   |           |\n+   |           help: try using a local generic parameter instead: `<T>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e32ef9933afe5c2b16a062fd81aed35b3439b340", "filename": "src/tools/clippy/clippy_lints/src/matches/match_same_arms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -290,7 +290,7 @@ impl<'a> NormalizedPat<'a> {\n                     LitKind::Char(val) => Self::LitInt(val.into()),\n                     LitKind::Int(val, _) => Self::LitInt(val),\n                     LitKind::Bool(val) => Self::LitBool(val),\n-                    LitKind::Float(..) | LitKind::Err(_) => Self::Wild,\n+                    LitKind::Float(..) | LitKind::Err => Self::Wild,\n                 },\n                 _ => Self::Wild,\n             },"}, {"sha": "429c64ac156418c1656161f2d840c8330235f96f", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -276,7 +276,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n         match lit.value.node {\n             LitKind::Bool(val) => kind!(\"Bool({val:?})\"),\n             LitKind::Char(c) => kind!(\"Char({c:?})\"),\n-            LitKind::Err(val) => kind!(\"Err({val})\"),\n+            LitKind::Err => kind!(\"Err\"),\n             LitKind::Byte(b) => kind!(\"Byte({b})\"),\n             LitKind::Int(i, suffix) => {\n                 let int_ty = match suffix {"}, {"sha": "e053708edd50779cc1b845c66f7b26cbc33d5cdb", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=a1bea1551b8312b6abfbbf7d49bafac2e6ce8ee4", "patch": "@@ -45,7 +45,7 @@ pub enum Constant {\n     /// A reference\n     Ref(Box<Constant>),\n     /// A literal with syntax error.\n-    Err(Symbol),\n+    Err,\n }\n \n impl PartialEq for Constant {\n@@ -118,9 +118,7 @@ impl Hash for Constant {\n             Self::Ref(ref r) => {\n                 r.hash(state);\n             },\n-            Self::Err(ref s) => {\n-                s.hash(state);\n-            },\n+            Self::Err => {},\n         }\n     }\n }\n@@ -194,7 +192,7 @@ pub fn lit_to_mir_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n             _ => bug!(),\n         },\n         LitKind::Bool(b) => Constant::Bool(b),\n-        LitKind::Err(s) => Constant::Err(s),\n+        LitKind::Err => Constant::Err,\n     }\n }\n "}]}