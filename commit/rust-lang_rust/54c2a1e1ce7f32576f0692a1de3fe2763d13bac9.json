{"sha": "54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0YzJhMWUxY2U3ZjMyNTc2ZjA2OTJhMWRlM2ZlMjc2M2QxM2JhYzk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-16T17:15:33Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-11T16:51:37Z"}, "message": "rustc: Move the AST from @T to Gc<T>", "tree": {"sha": "62c34c3c945986ccb3e409df57ed0579a2ddcf9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62c34c3c945986ccb3e409df57ed0579a2ddcf9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "html_url": "https://github.com/rust-lang/rust/commit/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53ad426e92f8099a701f3f54c02dc8f069f5939a", "url": "https://api.github.com/repos/rust-lang/rust/commits/53ad426e92f8099a701f3f54c02dc8f069f5939a", "html_url": "https://github.com/rust-lang/rust/commit/53ad426e92f8099a701f3f54c02dc8f069f5939a"}], "stats": {"total": 2753, "additions": 1405, "deletions": 1348}, "files": [{"sha": "802f7cd40bfd401d2a52c99d41349315b42cd7ce", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -1710,14 +1710,14 @@ having ownership of the box. It allows the creation of cycles, and the individua\n not have a destructor.\n \n ~~~\n-use std::gc::Gc;\n+use std::gc::GC;\n \n // A fixed-size array allocated in a garbage-collected box\n-let x = Gc::new([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+let x = box(GC) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n let y = x; // does not perform a move, unlike with `Rc`\n let z = x;\n \n-assert!(*z.borrow() == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+assert!(*z == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n ~~~\n \n With shared ownership, mutability cannot be inherited so the boxes are always immutable. However,"}, {"sha": "db6af30bce74080e6bcd6d4c35b69f921c169d03", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -320,7 +320,7 @@ mod tests {\n     #[test]\n     fn gc_inside() {\n         // see issue #11532\n-        use realstd::gc::Gc;\n+        use std::gc::GC;\n         let a = Rc::new(RefCell::new(box(GC) 1));\n         assert!(a.try_borrow_mut().is_some());\n     }"}, {"sha": "f7680e6f8479cdb11e42d8e199b713d233fecea3", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -110,6 +110,7 @@ extern_fn_clone!(A, B, C, D, E, F, G, H)\n mod test {\n     use prelude::*;\n     use realstd::owned::Box;\n+    use realstd::gc::{Gc, GC};\n \n     fn realclone<T: ::realstd::clone::Clone>(t: &T) -> T {\n         use realstd::clone::Clone;\n@@ -130,9 +131,9 @@ mod test {\n \n     #[test]\n     fn test_managed_clone() {\n-        let a = @5i;\n-        let b: @int = a.clone();\n-        assert_eq!(a, b);\n+        let a = box(GC) 5i;\n+        let b: Gc<int> = realclone(&a);\n+        assert!(a == b);\n     }\n \n     #[test]"}, {"sha": "d703ece307ffb7e412dfabe4773f2b2acc681cf5", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -705,7 +705,7 @@ fn print_flowgraph<W:io::Writer>(analysis: CrateAnalysis,\n                                  block: ast::P<ast::Block>,\n                                  mut out: W) -> io::IoResult<()> {\n     let ty_cx = &analysis.ty_cx;\n-    let cfg = cfg::CFG::new(ty_cx, block);\n+    let cfg = cfg::CFG::new(ty_cx, &*block);\n     let lcfg = LabelledCFG { ast_map: &ty_cx.map,\n                              cfg: &cfg,\n                              name: format!(\"block{}\", block.id).to_string(), };"}, {"sha": "58ac53002ba3c9c3bdd685dbcf3d684a79025167", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -12,6 +12,8 @@ use syntax::fold::Folder;\n use syntax::{ast, fold, attr};\n use syntax::codemap;\n \n+use std::gc::Gc;\n+\n struct Context<'a> {\n     in_cfg: |attrs: &[ast::Attribute]|: 'a -> bool,\n }\n@@ -36,7 +38,7 @@ impl<'a> fold::Folder for Context<'a> {\n     fn fold_item_underscore(&mut self, item: &ast::Item_) -> ast::Item_ {\n         fold_item_underscore(self, item)\n     }\n-    fn fold_expr(&mut self, expr: @ast::Expr) -> @ast::Expr {\n+    fn fold_expr(&mut self, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         fold_expr(self, expr)\n     }\n }\n@@ -60,8 +62,8 @@ fn filter_view_item<'r>(cx: &mut Context, view_item: &'r ast::ViewItem)\n }\n \n fn fold_mod(cx: &mut Context, m: &ast::Mod) -> ast::Mod {\n-    let filtered_items: Vec<&@ast::Item> = m.items.iter()\n-            .filter(|&a| item_in_cfg(cx, *a))\n+    let filtered_items: Vec<&Gc<ast::Item>> = m.items.iter()\n+            .filter(|a| item_in_cfg(cx, &***a))\n             .collect();\n     let flattened_items = filtered_items.move_iter()\n             .flat_map(|&x| cx.fold_item(x).move_iter())\n@@ -76,9 +78,9 @@ fn fold_mod(cx: &mut Context, m: &ast::Mod) -> ast::Mod {\n     }\n }\n \n-fn filter_foreign_item(cx: &mut Context, item: @ast::ForeignItem)\n-                       -> Option<@ast::ForeignItem> {\n-    if foreign_item_in_cfg(cx, item) {\n+fn filter_foreign_item(cx: &mut Context, item: Gc<ast::ForeignItem>)\n+                       -> Option<Gc<ast::ForeignItem>> {\n+    if foreign_item_in_cfg(cx, &*item) {\n         Some(item)\n     } else {\n         None\n@@ -103,7 +105,7 @@ fn fold_foreign_mod(cx: &mut Context, nm: &ast::ForeignMod) -> ast::ForeignMod {\n fn fold_item_underscore(cx: &mut Context, item: &ast::Item_) -> ast::Item_ {\n     let item = match *item {\n         ast::ItemImpl(ref a, ref b, c, ref methods) => {\n-            let methods = methods.iter().filter(|m| method_in_cfg(cx, **m))\n+            let methods = methods.iter().filter(|m| method_in_cfg(cx, &***m))\n                 .map(|x| *x).collect();\n             ast::ItemImpl((*a).clone(), (*b).clone(), c, methods)\n         }\n@@ -114,8 +116,8 @@ fn fold_item_underscore(cx: &mut Context, item: &ast::Item_) -> ast::Item_ {\n                                  .collect();\n             ast::ItemTrait((*a).clone(), b, (*c).clone(), methods)\n         }\n-        ast::ItemStruct(def, ref generics) => {\n-            ast::ItemStruct(fold_struct(cx, def), generics.clone())\n+        ast::ItemStruct(ref def, ref generics) => {\n+            ast::ItemStruct(fold_struct(cx, &**def), generics.clone())\n         }\n         ast::ItemEnum(ref def, ref generics) => {\n             let mut variants = def.variants.iter().map(|c| c.clone()).\n@@ -125,11 +127,11 @@ fn fold_item_underscore(cx: &mut Context, item: &ast::Item_) -> ast::Item_ {\n                 } else {\n                     Some(match v.node.kind {\n                                 ast::TupleVariantKind(..) => v,\n-                                ast::StructVariantKind(def) => {\n-                                    let def = fold_struct(cx, def);\n-                                    @codemap::Spanned {\n+                                ast::StructVariantKind(ref def) => {\n+                                    let def = fold_struct(cx, &**def);\n+                                    box(GC) codemap::Spanned {\n                                         node: ast::Variant_ {\n-                                            kind: ast::StructVariantKind(def),\n+                                            kind: ast::StructVariantKind(def.clone()),\n                                             ..v.node.clone()\n                                         },\n                                         ..*v\n@@ -148,24 +150,24 @@ fn fold_item_underscore(cx: &mut Context, item: &ast::Item_) -> ast::Item_ {\n     fold::noop_fold_item_underscore(&item, cx)\n }\n \n-fn fold_struct(cx: &mut Context, def: &ast::StructDef) -> @ast::StructDef {\n+fn fold_struct(cx: &mut Context, def: &ast::StructDef) -> Gc<ast::StructDef> {\n     let mut fields = def.fields.iter().map(|c| c.clone()).filter(|m| {\n         (cx.in_cfg)(m.node.attrs.as_slice())\n     });\n-    @ast::StructDef {\n+    box(GC) ast::StructDef {\n         fields: fields.collect(),\n         ctor_id: def.ctor_id,\n         super_struct: def.super_struct.clone(),\n         is_virtual: def.is_virtual,\n     }\n }\n \n-fn retain_stmt(cx: &mut Context, stmt: @ast::Stmt) -> bool {\n+fn retain_stmt(cx: &mut Context, stmt: Gc<ast::Stmt>) -> bool {\n     match stmt.node {\n       ast::StmtDecl(decl, _) => {\n         match decl.node {\n-          ast::DeclItem(item) => {\n-            item_in_cfg(cx, item)\n+          ast::DeclItem(ref item) => {\n+            item_in_cfg(cx, &**item)\n           }\n           _ => true\n         }\n@@ -175,10 +177,10 @@ fn retain_stmt(cx: &mut Context, stmt: @ast::Stmt) -> bool {\n }\n \n fn fold_block(cx: &mut Context, b: ast::P<ast::Block>) -> ast::P<ast::Block> {\n-    let resulting_stmts: Vec<&@ast::Stmt> =\n+    let resulting_stmts: Vec<&Gc<ast::Stmt>> =\n         b.stmts.iter().filter(|&a| retain_stmt(cx, *a)).collect();\n     let resulting_stmts = resulting_stmts.move_iter()\n-        .flat_map(|&stmt| cx.fold_stmt(stmt).move_iter())\n+        .flat_map(|stmt| cx.fold_stmt(&**stmt).move_iter())\n         .collect();\n     let filtered_view_items = b.view_items.iter().filter_map(|a| {\n         filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n@@ -193,14 +195,14 @@ fn fold_block(cx: &mut Context, b: ast::P<ast::Block>) -> ast::P<ast::Block> {\n     })\n }\n \n-fn fold_expr(cx: &mut Context, expr: @ast::Expr) -> @ast::Expr {\n+fn fold_expr(cx: &mut Context, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n     let expr = match expr.node {\n         ast::ExprMatch(ref m, ref arms) => {\n             let arms = arms.iter()\n                 .filter(|a| (cx.in_cfg)(a.attrs.as_slice()))\n                 .map(|a| a.clone())\n                 .collect();\n-            @ast::Expr {\n+            box(GC) ast::Expr {\n                 id: expr.id,\n                 span: expr.span.clone(),\n                 node: ast::ExprMatch(m.clone(), arms),\n@@ -236,7 +238,7 @@ fn trait_method_in_cfg(cx: &mut Context, meth: &ast::TraitMethod) -> bool {\n \n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n-fn in_cfg(cfg: &[@ast::MetaItem], attrs: &[ast::Attribute]) -> bool {\n+fn in_cfg(cfg: &[Gc<ast::MetaItem>], attrs: &[ast::Attribute]) -> bool {\n     attr::test_cfg(cfg, attrs.iter().map(|x| *x))\n }\n "}, {"sha": "c5c87ee27027123337e347754f8ab8f16184d0e2", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -23,6 +23,7 @@ use syntax::parse::token;\n use syntax::util::small_vector::SmallVector;\n \n use std::mem;\n+use std::gc::Gc;\n \n pub static VERSION: &'static str = \"0.11.0-pre\";\n \n@@ -165,12 +166,12 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n         krate\n     }\n \n-    fn fold_item(&mut self, item: @ast::Item) -> SmallVector<@ast::Item> {\n+    fn fold_item(&mut self, item: Gc<ast::Item>) -> SmallVector<Gc<ast::Item>> {\n         if !no_prelude(item.attrs.as_slice()) {\n             // only recur if there wasn't `#![no_implicit_prelude]`\n             // on this item, i.e. this means that the prelude is not\n             // implicitly imported though the whole subtree\n-            fold::noop_fold_item(item, self)\n+            fold::noop_fold_item(&*item, self)\n         } else {\n             SmallVector::one(item)\n         }\n@@ -193,7 +194,8 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n                 }),\n         };\n \n-        let vp = @codemap::dummy_spanned(ast::ViewPathGlob(prelude_path, ast::DUMMY_NODE_ID));\n+        let vp = box(GC) codemap::dummy_spanned(ast::ViewPathGlob(prelude_path,\n+                                                                  ast::DUMMY_NODE_ID));\n         let vi2 = ast::ViewItem {\n             node: ast::ViewItemUse(vp),\n             attrs: Vec::new(),"}, {"sha": "3a655a7e22c868122b777034bb4a573adf3cf465", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -18,8 +18,8 @@ use front::config;\n use front::std_inject::with_version;\n \n use std::cell::RefCell;\n+use std::gc::Gc;\n use std::slice;\n-use std::vec::Vec;\n use std::vec;\n use syntax::ast_util::*;\n use syntax::attr::AttrMetaMethods;\n@@ -86,7 +86,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         }\n     }\n \n-    fn fold_item(&mut self, i: @ast::Item) -> SmallVector<@ast::Item> {\n+    fn fold_item(&mut self, i: Gc<ast::Item>) -> SmallVector<Gc<ast::Item>> {\n         self.cx.path.borrow_mut().push(i.ident);\n         debug!(\"current path: {}\",\n                ast_util::path_name_i(self.cx.path.borrow().as_slice()));\n@@ -115,7 +115,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n             }\n         }\n \n-        let res = fold::noop_fold_item(i, self);\n+        let res = fold::noop_fold_item(&*i, self);\n         self.cx.path.borrow_mut().pop();\n         res\n     }\n@@ -124,8 +124,8 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         // Remove any #[main] from the AST so it doesn't clash with\n         // the one we're going to add. Only if compiling an executable.\n \n-        fn nomain(item: @ast::Item) -> @ast::Item {\n-            @ast::Item {\n+        fn nomain(item: Gc<ast::Item>) -> Gc<ast::Item> {\n+            box(GC) ast::Item {\n                 attrs: item.attrs.iter().filter_map(|attr| {\n                     if !attr.name().equiv(&(\"main\")) {\n                         Some(*attr)\n@@ -188,10 +188,10 @@ fn strip_test_functions(krate: ast::Crate) -> ast::Crate {\n     })\n }\n \n-fn is_test_fn(cx: &TestCtxt, i: @ast::Item) -> bool {\n+fn is_test_fn(cx: &TestCtxt, i: Gc<ast::Item>) -> bool {\n     let has_test_attr = attr::contains_name(i.attrs.as_slice(), \"test\");\n \n-    fn has_test_signature(i: @ast::Item) -> bool {\n+    fn has_test_signature(i: Gc<ast::Item>) -> bool {\n         match &i.node {\n           &ast::ItemFn(ref decl, _, _, ref generics, _) => {\n             let no_output = match decl.output.node {\n@@ -217,10 +217,10 @@ fn is_test_fn(cx: &TestCtxt, i: @ast::Item) -> bool {\n     return has_test_attr && has_test_signature(i);\n }\n \n-fn is_bench_fn(cx: &TestCtxt, i: @ast::Item) -> bool {\n+fn is_bench_fn(cx: &TestCtxt, i: Gc<ast::Item>) -> bool {\n     let has_bench_attr = attr::contains_name(i.attrs.as_slice(), \"bench\");\n \n-    fn has_test_signature(i: @ast::Item) -> bool {\n+    fn has_test_signature(i: Gc<ast::Item>) -> bool {\n         match i.node {\n             ast::ItemFn(ref decl, _, _, ref generics, _) => {\n                 let input_cnt = decl.inputs.len();\n@@ -247,7 +247,7 @@ fn is_bench_fn(cx: &TestCtxt, i: @ast::Item) -> bool {\n     return has_bench_attr && has_test_signature(i);\n }\n \n-fn is_ignored(cx: &TestCtxt, i: @ast::Item) -> bool {\n+fn is_ignored(cx: &TestCtxt, i: Gc<ast::Item>) -> bool {\n     i.attrs.iter().any(|attr| {\n         // check ignore(cfg(foo, bar))\n         attr.check_name(\"ignore\") && match attr.meta_item_list() {\n@@ -259,7 +259,7 @@ fn is_ignored(cx: &TestCtxt, i: @ast::Item) -> bool {\n     })\n }\n \n-fn should_fail(i: @ast::Item) -> bool {\n+fn should_fail(i: Gc<ast::Item>) -> bool {\n     attr::contains_name(i.attrs.as_slice(), \"should_fail\")\n }\n \n@@ -293,7 +293,7 @@ fn mk_std(cx: &TestCtxt) -> ast::ViewItem {\n     let id_test = token::str_to_ident(\"test\");\n     let (vi, vis) = if cx.is_test_crate {\n         (ast::ViewItemUse(\n-            @nospan(ast::ViewPathSimple(id_test,\n+            box(GC) nospan(ast::ViewPathSimple(id_test,\n                                         path_node(vec!(id_test)),\n                                         ast::DUMMY_NODE_ID))),\n          ast::Public)\n@@ -311,7 +311,7 @@ fn mk_std(cx: &TestCtxt) -> ast::ViewItem {\n     }\n }\n \n-fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n+fn mk_test_module(cx: &TestCtxt) -> Gc<ast::Item> {\n     // Link to test crate\n     let view_items = vec!(mk_std(cx));\n \n@@ -352,7 +352,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n \n     debug!(\"Synthetic test module:\\n{}\\n\", pprust::item_to_str(&item));\n \n-    return @item;\n+    box(GC) item\n }\n \n fn nospan<T>(t: T) -> codemap::Spanned<T> {\n@@ -383,7 +383,7 @@ fn path_node_global(ids: Vec<ast::Ident> ) -> ast::Path {\n     }\n }\n \n-fn mk_tests(cx: &TestCtxt) -> @ast::Item {\n+fn mk_tests(cx: &TestCtxt) -> Gc<ast::Item> {\n     // The vector of test_descs for this crate\n     let test_descs = mk_test_descs(cx);\n \n@@ -401,12 +401,12 @@ fn is_test_crate(krate: &ast::Crate) -> bool {\n     }\n }\n \n-fn mk_test_descs(cx: &TestCtxt) -> @ast::Expr {\n+fn mk_test_descs(cx: &TestCtxt) -> Gc<ast::Expr> {\n     debug!(\"building test vector from {} tests\", cx.testfns.borrow().len());\n \n-    @ast::Expr {\n+    box(GC) ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprVstore(@ast::Expr {\n+        node: ast::ExprVstore(box(GC) ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: ast::ExprVec(cx.testfns.borrow().iter().map(|test| {\n                 mk_test_desc_and_fn_rec(cx, test)\n@@ -417,7 +417,7 @@ fn mk_test_descs(cx: &TestCtxt) -> @ast::Expr {\n     }\n }\n \n-fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::Expr {\n+fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> Gc<ast::Expr> {\n     let span = test.span;\n     let path = test.path.clone();\n \n@@ -428,15 +428,15 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::Expr {\n                     ast_util::path_name_i(path.as_slice()).as_slice()),\n                     ast::CookedStr));\n \n-    let name_expr = @ast::Expr {\n+    let name_expr = box(GC) ast::Expr {\n           id: ast::DUMMY_NODE_ID,\n-          node: ast::ExprLit(@name_lit),\n+          node: ast::ExprLit(box(GC) name_lit),\n           span: span\n     };\n \n     let fn_path = path_node_global(path);\n \n-    let fn_expr = @ast::Expr {\n+    let fn_expr = box(GC) ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprPath(fn_path),\n         span: span,"}, {"sha": "ee5179e9cef4ac55923cee89d62c7c6fd6fd1250", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -177,7 +177,7 @@ pub fn get_static_methods_if_impl(cstore: &cstore::CStore,\n \n pub fn get_item_attrs(cstore: &cstore::CStore,\n                       def_id: ast::DefId,\n-                      f: |Vec<ast::Attribute> |) {\n+                      f: |Vec<ast::Attribute>|) {\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_item_attrs(&*cdata, def_id.node, f)\n }"}, {"sha": "d088d0d953d0e577612e273e56935323802bb21e", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -28,13 +28,13 @@ use middle::ty;\n use middle::typeck;\n use middle::astencode::vtable_decoder_helpers;\n \n-use std::u64;\n-use std::hash;\n+use std::gc::Gc;\n use std::hash::Hash;\n-use std::io;\n+use std::hash;\n use std::io::extensions::u64_from_be_bytes;\n-use std::option;\n+use std::io;\n use std::rc::Rc;\n+use std::u64;\n use serialize::ebml::reader;\n use serialize::ebml;\n use serialize::Decodable;\n@@ -1010,8 +1010,8 @@ pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n     result\n }\n \n-fn get_meta_items(md: ebml::Doc) -> Vec<@ast::MetaItem> {\n-    let mut items: Vec<@ast::MetaItem> = Vec::new();\n+fn get_meta_items(md: ebml::Doc) -> Vec<Gc<ast::MetaItem>> {\n+    let mut items: Vec<Gc<ast::MetaItem>> = Vec::new();\n     reader::tagged_docs(md, tag_meta_item_word, |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = token::intern_and_get_ident(nd.as_str_slice());\n@@ -1041,7 +1041,7 @@ fn get_meta_items(md: ebml::Doc) -> Vec<@ast::MetaItem> {\n fn get_attributes(md: ebml::Doc) -> Vec<ast::Attribute> {\n     let mut attrs: Vec<ast::Attribute> = Vec::new();\n     match reader::maybe_get_doc(md, tag_attributes) {\n-      option::Some(attrs_d) => {\n+      Some(attrs_d) => {\n         reader::tagged_docs(attrs_d, tag_attribute, |attr_doc| {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n@@ -1061,7 +1061,7 @@ fn get_attributes(md: ebml::Doc) -> Vec<ast::Attribute> {\n             true\n         });\n       }\n-      option::None => ()\n+      None => ()\n     }\n     return attrs;\n }"}, {"sha": "f5672dce16c6c35c5a16707f67152a5abf511636", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -27,11 +27,12 @@ use middle;\n use util::nodemap::{NodeMap, NodeSet};\n \n use serialize::Encodable;\n-use std::mem;\n use std::cell::RefCell;\n-use std::hash;\n+use std::gc::Gc;\n use std::hash::Hash;\n+use std::hash;\n use std::io::MemWriter;\n+use std::mem;\n use std::str;\n use std::collections::HashMap;\n use syntax::abi;\n@@ -475,7 +476,7 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n /// * For enums, iterates through the node IDs of the variants.\n ///\n /// * For newtype structs, iterates through the node ID of the constructor.\n-fn each_auxiliary_node_id(item: @Item, callback: |NodeId| -> bool) -> bool {\n+fn each_auxiliary_node_id(item: Gc<Item>, callback: |NodeId| -> bool) -> bool {\n     let mut continue_ = true;\n     match item.node {\n         ItemEnum(ref enum_def, _) => {\n@@ -746,7 +747,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n                           impl_path: PathElems,\n                           is_default_impl: bool,\n                           parent_id: NodeId,\n-                          ast_method_opt: Option<@Method>) {\n+                          ast_method_opt: Option<Gc<Method>>) {\n \n     debug!(\"encode_info_for_method: {:?} {}\", m.def_id,\n            token::get_ident(m.ident));\n@@ -774,7 +775,8 @@ fn encode_info_for_method(ecx: &EncodeContext,\n                 is_default_impl ||\n                 should_inline(ast_method.attrs.as_slice()) {\n             encode_inlined_item(ecx, ebml_w,\n-                                IIMethodRef(local_def(parent_id), false, ast_method));\n+                                IIMethodRef(local_def(parent_id), false,\n+                                            &*ast_method));\n         } else {\n             encode_symbol(ecx, ebml_w, m.def_id.node);\n         }\n@@ -1212,7 +1214,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     }\n                     encode_method_sort(ebml_w, 'p');\n                     encode_inlined_item(ecx, ebml_w,\n-                                        IIMethodRef(def_id, true, m));\n+                                        IIMethodRef(def_id, true, &*m));\n                     encode_method_argument_names(ebml_w, &*m.decl);\n                 }\n             }\n@@ -1408,7 +1410,7 @@ fn write_i64(writer: &mut MemWriter, &n: &i64) {\n     wr.write_be_u32(n as u32);\n }\n \n-fn encode_meta_item(ebml_w: &mut Encoder, mi: @MetaItem) {\n+fn encode_meta_item(ebml_w: &mut Encoder, mi: Gc<MetaItem>) {\n     match mi.node {\n       MetaWord(ref name) => {\n         ebml_w.start_tag(tag_meta_item_word);"}, {"sha": "cc356a8bf077c7d88a17b8939ddaf12f8f27be0b", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -40,7 +40,6 @@ use std::io::Seek;\n use std::io::MemWriter;\n use std::mem;\n use std::rc::Rc;\n-use std::string::String;\n \n use serialize::ebml::reader;\n use serialize::ebml;\n@@ -51,6 +50,7 @@ use writer = serialize::ebml::writer;\n \n #[cfg(test)] use syntax::parse;\n #[cfg(test)] use syntax::print::pprust;\n+#[cfg(test)] use std::gc::Gc;\n \n struct DecodeContext<'a> {\n     cdata: &'a cstore::crate_metadata,\n@@ -146,7 +146,7 @@ pub fn decode_inlined_item(cdata: &cstore::crate_metadata,\n         match ii {\n           ast::IIItem(i) => {\n             debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n-                   syntax::print::pprust::item_to_str(i));\n+                   syntax::print::pprust::item_to_str(&*i));\n           }\n           _ => { }\n         }\n@@ -438,7 +438,7 @@ impl tr for def::Def {\n           def::DefUse(did) => def::DefUse(did.tr(xcx)),\n           def::DefUpvar(nid1, def, nid2, nid3) => {\n             def::DefUpvar(xcx.tr_id(nid1),\n-                           @(*def).tr(xcx),\n+                           box(GC) (*def).tr(xcx),\n                            xcx.tr_id(nid2),\n                            xcx.tr_id(nid3))\n           }\n@@ -1395,17 +1395,17 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n // Testing of astencode_gen\n \n #[cfg(test)]\n-fn encode_item_ast(ebml_w: &mut Encoder, item: @ast::Item) {\n+fn encode_item_ast(ebml_w: &mut Encoder, item: Gc<ast::Item>) {\n     ebml_w.start_tag(c::tag_tree as uint);\n     (*item).encode(ebml_w);\n     ebml_w.end_tag();\n }\n \n #[cfg(test)]\n-fn decode_item_ast(par_doc: ebml::Doc) -> @ast::Item {\n+fn decode_item_ast(par_doc: ebml::Doc) -> Gc<ast::Item> {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n     let mut d = reader::Decoder::new(chi_doc);\n-    @Decodable::decode(&mut d).unwrap()\n+    box(GC) Decodable::decode(&mut d).unwrap()\n }\n \n #[cfg(test)]\n@@ -1440,7 +1440,7 @@ fn mk_ctxt() -> parse::ParseSess {\n }\n \n #[cfg(test)]\n-fn roundtrip(in_item: Option<@ast::Item>) {\n+fn roundtrip(in_item: Option<Gc<ast::Item>>) {\n     use std::io::MemWriter;\n \n     let in_item = in_item.unwrap();"}, {"sha": "ece8d973236a662754d27c61648091872781cc79", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -894,4 +894,3 @@ impl<'a> CheckLoanCtxt<'a> {\n         }\n     }\n }\n-"}, {"sha": "ac94b73564060dc46bf43f05b50335d23412f20d", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -486,8 +486,8 @@ struct StaticInitializerCtxt<'a> {\n impl<'a> visit::Visitor<()> for StaticInitializerCtxt<'a> {\n     fn visit_expr(&mut self, ex: &Expr, _: ()) {\n         match ex.node {\n-            ast::ExprAddrOf(mutbl, base) => {\n-                let base_cmt = self.bccx.cat_expr(base);\n+            ast::ExprAddrOf(mutbl, ref base) => {\n+                let base_cmt = self.bccx.cat_expr(&**base);\n                 let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n                 // Check that we don't allow borrows of unsafe static items.\n                 if check_aliasability(self.bccx, ex.span, euv::AddrOf,"}, {"sha": "5335f9722a98b416ee5b45799c3ef52821dc9935", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -106,7 +106,7 @@ fn borrowck_item(this: &mut BorrowckCtxt, item: &ast::Item) {\n     // flow dependent conditions.\n     match item.node {\n         ast::ItemStatic(_, _, ex) => {\n-            gather_loans::gather_loans_in_static_initializer(this, ex);\n+            gather_loans::gather_loans_in_static_initializer(this, &*ex);\n         }\n         _ => {\n             visit::walk_item(this, item, ());\n@@ -480,7 +480,7 @@ impl<'a> BorrowckCtxt<'a> {\n             move_data::MoveExpr => {\n                 let (expr_ty, expr_span) = match self.tcx.map.find(move.id) {\n                     Some(ast_map::NodeExpr(expr)) => {\n-                        (ty::expr_ty_adjusted(self.tcx, expr), expr.span)\n+                        (ty::expr_ty_adjusted(self.tcx, &*expr), expr.span)\n                     }\n                     r => {\n                         self.tcx.sess.bug(format!(\"MoveExpr({:?}) maps to \\\n@@ -512,7 +512,7 @@ impl<'a> BorrowckCtxt<'a> {\n             move_data::Captured => {\n                 let (expr_ty, expr_span) = match self.tcx.map.find(move.id) {\n                     Some(ast_map::NodeExpr(expr)) => {\n-                        (ty::expr_ty_adjusted(self.tcx, expr), expr.span)\n+                        (ty::expr_ty_adjusted(self.tcx, &*expr), expr.span)\n                     }\n                     r => {\n                         self.tcx.sess.bug(format!(\"Captured({:?}) maps to \\"}, {"sha": "f855ca37597a334301fe1df3f33e67a1bb4ef74f", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 77, "deletions": 75, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -17,6 +17,8 @@ use syntax::ast;\n use syntax::ast_util;\n use util::nodemap::NodeMap;\n \n+use std::gc::Gc;\n+\n struct CFGBuilder<'a> {\n     tcx: &'a ty::ctxt,\n     exit_map: NodeMap<CFGIndex>,\n@@ -66,23 +68,23 @@ fn add_initial_dummy_node(g: &mut CFGGraph) -> CFGIndex {\n impl<'a> CFGBuilder<'a> {\n     fn block(&mut self, blk: &ast::Block, pred: CFGIndex) -> CFGIndex {\n         let mut stmts_exit = pred;\n-        for &stmt in blk.stmts.iter() {\n-            stmts_exit = self.stmt(stmt, stmts_exit);\n+        for stmt in blk.stmts.iter() {\n+            stmts_exit = self.stmt(stmt.clone(), stmts_exit);\n         }\n \n-        let expr_exit = self.opt_expr(blk.expr, stmts_exit);\n+        let expr_exit = self.opt_expr(blk.expr.clone(), stmts_exit);\n \n         self.add_node(blk.id, [expr_exit])\n     }\n \n-    fn stmt(&mut self, stmt: @ast::Stmt, pred: CFGIndex) -> CFGIndex {\n+    fn stmt(&mut self, stmt: Gc<ast::Stmt>, pred: CFGIndex) -> CFGIndex {\n         match stmt.node {\n-            ast::StmtDecl(decl, _) => {\n-                self.decl(decl, pred)\n+            ast::StmtDecl(ref decl, _) => {\n+                self.decl(&**decl, pred)\n             }\n \n-            ast::StmtExpr(expr, _) | ast::StmtSemi(expr, _) => {\n-                self.expr(expr, pred)\n+            ast::StmtExpr(ref expr, _) | ast::StmtSemi(ref expr, _) => {\n+                self.expr(expr.clone(), pred)\n             }\n \n             ast::StmtMac(..) => {\n@@ -91,11 +93,11 @@ impl<'a> CFGBuilder<'a> {\n         }\n     }\n \n-    fn decl(&mut self, decl: @ast::Decl, pred: CFGIndex) -> CFGIndex {\n+    fn decl(&mut self, decl: &ast::Decl, pred: CFGIndex) -> CFGIndex {\n         match decl.node {\n-            ast::DeclLocal(local) => {\n-                let init_exit = self.opt_expr(local.init, pred);\n-                self.pat(local.pat, init_exit)\n+            ast::DeclLocal(ref local) => {\n+                let init_exit = self.opt_expr(local.init.clone(), pred);\n+                self.pat(&*local.pat, init_exit)\n             }\n \n             ast::DeclItem(_) => {\n@@ -104,7 +106,7 @@ impl<'a> CFGBuilder<'a> {\n         }\n     }\n \n-    fn pat(&mut self, pat: @ast::Pat, pred: CFGIndex) -> CFGIndex {\n+    fn pat(&mut self, pat: &ast::Pat, pred: CFGIndex) -> CFGIndex {\n         match pat.node {\n             ast::PatIdent(_, _, None) |\n             ast::PatEnum(_, None) |\n@@ -114,23 +116,23 @@ impl<'a> CFGBuilder<'a> {\n                 self.add_node(pat.id, [pred])\n             }\n \n-            ast::PatBox(subpat) |\n-            ast::PatRegion(subpat) |\n-            ast::PatIdent(_, _, Some(subpat)) => {\n-                let subpat_exit = self.pat(subpat, pred);\n+            ast::PatBox(ref subpat) |\n+            ast::PatRegion(ref subpat) |\n+            ast::PatIdent(_, _, Some(ref subpat)) => {\n+                let subpat_exit = self.pat(&**subpat, pred);\n                 self.add_node(pat.id, [subpat_exit])\n             }\n \n             ast::PatEnum(_, Some(ref subpats)) |\n             ast::PatTup(ref subpats) => {\n                 let pats_exit =\n-                    self.pats_all(subpats.iter().map(|p| *p), pred);\n+                    self.pats_all(subpats.iter().map(|p| p.clone()), pred);\n                 self.add_node(pat.id, [pats_exit])\n             }\n \n             ast::PatStruct(_, ref subpats, _) => {\n                 let pats_exit =\n-                    self.pats_all(subpats.iter().map(|f| f.pat), pred);\n+                    self.pats_all(subpats.iter().map(|f| f.pat.clone()), pred);\n                 self.add_node(pat.id, [pats_exit])\n             }\n \n@@ -150,39 +152,39 @@ impl<'a> CFGBuilder<'a> {\n         }\n     }\n \n-    fn pats_all<I: Iterator<@ast::Pat>>(&mut self,\n+    fn pats_all<I: Iterator<Gc<ast::Pat>>>(&mut self,\n                                         pats: I,\n                                         pred: CFGIndex) -> CFGIndex {\n         //! Handles case where all of the patterns must match.\n         let mut pats = pats;\n-        pats.fold(pred, |pred, pat| self.pat(pat, pred))\n+        pats.fold(pred, |pred, pat| self.pat(&*pat, pred))\n     }\n \n     fn pats_any(&mut self,\n-                pats: &[@ast::Pat],\n+                pats: &[Gc<ast::Pat>],\n                 pred: CFGIndex) -> CFGIndex {\n         //! Handles case where just one of the patterns must match.\n \n         if pats.len() == 1 {\n-            self.pat(pats[0], pred)\n+            self.pat(&*pats[0], pred)\n         } else {\n             let collect = self.add_dummy_node([]);\n             for &pat in pats.iter() {\n-                let pat_exit = self.pat(pat, pred);\n+                let pat_exit = self.pat(&*pat, pred);\n                 self.add_contained_edge(pat_exit, collect);\n             }\n             collect\n         }\n     }\n \n-    fn expr(&mut self, expr: @ast::Expr, pred: CFGIndex) -> CFGIndex {\n+    fn expr(&mut self, expr: Gc<ast::Expr>, pred: CFGIndex) -> CFGIndex {\n         match expr.node {\n-            ast::ExprBlock(blk) => {\n-                let blk_exit = self.block(blk, pred);\n+            ast::ExprBlock(ref blk) => {\n+                let blk_exit = self.block(&**blk, pred);\n                 self.add_node(expr.id, [blk_exit])\n             }\n \n-            ast::ExprIf(cond, then, None) => {\n+            ast::ExprIf(ref cond, ref then, None) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -197,12 +199,12 @@ impl<'a> CFGBuilder<'a> {\n                 //    v 3   v 4\n                 //   [..expr..]\n                 //\n-                let cond_exit = self.expr(cond, pred);                // 1\n-                let then_exit = self.block(then, cond_exit);          // 2\n-                self.add_node(expr.id, [cond_exit, then_exit])        // 3,4\n+                let cond_exit = self.expr(cond.clone(), pred);           // 1\n+                let then_exit = self.block(&**then, cond_exit);          // 2\n+                self.add_node(expr.id, [cond_exit, then_exit])           // 3,4\n             }\n \n-            ast::ExprIf(cond, then, Some(otherwise)) => {\n+            ast::ExprIf(ref cond, ref then, Some(ref otherwise)) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -217,13 +219,13 @@ impl<'a> CFGBuilder<'a> {\n                 //    v 4   v 5\n                 //   [..expr..]\n                 //\n-                let cond_exit = self.expr(cond, pred);                // 1\n-                let then_exit = self.block(then, cond_exit);          // 2\n-                let else_exit = self.expr(otherwise, cond_exit);      // 3\n-                self.add_node(expr.id, [then_exit, else_exit])        // 4, 5\n+                let cond_exit = self.expr(cond.clone(), pred);           // 1\n+                let then_exit = self.block(&**then, cond_exit);          // 2\n+                let else_exit = self.expr(otherwise.clone(), cond_exit); // 3\n+                self.add_node(expr.id, [then_exit, else_exit])           // 4, 5\n             }\n \n-            ast::ExprWhile(cond, body) => {\n+            ast::ExprWhile(ref cond, ref body) => {\n                 //\n                 //         [pred]\n                 //           |\n@@ -242,22 +244,22 @@ impl<'a> CFGBuilder<'a> {\n                 // may cause additional edges.\n \n                 // Is the condition considered part of the loop?\n-                let loopback = self.add_dummy_node([pred]);           // 1\n-                let cond_exit = self.expr(cond, loopback);            // 2\n-                let expr_exit = self.add_node(expr.id, [cond_exit]);  // 3\n+                let loopback = self.add_dummy_node([pred]);              // 1\n+                let cond_exit = self.expr(cond.clone(), loopback);       // 2\n+                let expr_exit = self.add_node(expr.id, [cond_exit]);     // 3\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     continue_index: loopback,\n                     break_index: expr_exit\n                 });\n-                let body_exit = self.block(body, cond_exit);          // 4\n-                self.add_contained_edge(body_exit, loopback);         // 5\n+                let body_exit = self.block(&**body, cond_exit);          // 4\n+                self.add_contained_edge(body_exit, loopback);            // 5\n                 expr_exit\n             }\n \n             ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n-            ast::ExprLoop(body, _) => {\n+            ast::ExprLoop(ref body, _) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -272,20 +274,20 @@ impl<'a> CFGBuilder<'a> {\n                 // Note that `break` and `loop` statements\n                 // may cause additional edges.\n \n-                let loopback = self.add_dummy_node([pred]);           // 1\n-                let expr_exit = self.add_node(expr.id, []);           // 2\n+                let loopback = self.add_dummy_node([pred]);              // 1\n+                let expr_exit = self.add_node(expr.id, []);              // 2\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     continue_index: loopback,\n                     break_index: expr_exit,\n                 });\n-                let body_exit = self.block(body, loopback);           // 3\n-                self.add_contained_edge(body_exit, loopback);         // 4\n+                let body_exit = self.block(&**body, loopback);           // 3\n+                self.add_contained_edge(body_exit, loopback);            // 4\n                 self.loop_scopes.pop();\n                 expr_exit\n             }\n \n-            ast::ExprMatch(discr, ref arms) => {\n+            ast::ExprMatch(ref discr, ref arms) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -309,21 +311,21 @@ impl<'a> CFGBuilder<'a> {\n                 //     v 5  v    v\n                 //   [....expr....]\n                 //\n-                let discr_exit = self.expr(discr, pred);                 // 1\n+                let discr_exit = self.expr(discr.clone(), pred);         // 1\n \n                 let expr_exit = self.add_node(expr.id, []);\n                 let mut guard_exit = discr_exit;\n                 for arm in arms.iter() {\n-                    guard_exit = self.opt_expr(arm.guard, guard_exit); // 2\n+                    guard_exit = self.opt_expr(arm.guard, guard_exit);   // 2\n                     let pats_exit = self.pats_any(arm.pats.as_slice(),\n-                                                  guard_exit); // 3\n-                    let body_exit = self.expr(arm.body, pats_exit);      // 4\n+                                                  guard_exit);           // 3\n+                    let body_exit = self.expr(arm.body.clone(), pats_exit); // 4\n                     self.add_contained_edge(body_exit, expr_exit);       // 5\n                 }\n                 expr_exit\n             }\n \n-            ast::ExprBinary(op, l, r) if ast_util::lazy_binop(op) => {\n+            ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -338,13 +340,13 @@ impl<'a> CFGBuilder<'a> {\n                 //    v 3  v 4\n                 //   [..exit..]\n                 //\n-                let l_exit = self.expr(l, pred);                         // 1\n-                let r_exit = self.expr(r, l_exit);                       // 2\n+                let l_exit = self.expr(l.clone(), pred);                  // 1\n+                let r_exit = self.expr(r.clone(), l_exit);               // 2\n                 self.add_node(expr.id, [l_exit, r_exit])                 // 3,4\n             }\n \n-            ast::ExprRet(v) => {\n-                let v_exit = self.opt_expr(v, pred);\n+            ast::ExprRet(ref v) => {\n+                let v_exit = self.opt_expr(v.clone(), pred);\n                 let b = self.add_node(expr.id, [v_exit]);\n                 self.add_returning_edge(expr, b);\n                 self.add_node(ast::DUMMY_NODE_ID, [])\n@@ -370,21 +372,21 @@ impl<'a> CFGBuilder<'a> {\n                 self.straightline(expr, pred, elems.as_slice())\n             }\n \n-            ast::ExprCall(func, ref args) => {\n-                self.call(expr, pred, func, args.as_slice())\n+            ast::ExprCall(ref func, ref args) => {\n+                self.call(expr, pred, func.clone(), args.as_slice())\n             }\n \n             ast::ExprMethodCall(_, _, ref args) => {\n                 self.call(expr, pred, *args.get(0), args.slice_from(1))\n             }\n \n-            ast::ExprIndex(l, r) |\n-            ast::ExprBinary(_, l, r) if self.is_method_call(expr) => {\n-                self.call(expr, pred, l, [r])\n+            ast::ExprIndex(ref l, ref r) |\n+            ast::ExprBinary(_, ref l, ref r) if self.is_method_call(&*expr) => {\n+                self.call(expr, pred, l.clone(), [r.clone()])\n             }\n \n-            ast::ExprUnary(_, e) if self.is_method_call(expr) => {\n-                self.call(expr, pred, e, [])\n+            ast::ExprUnary(_, ref e) if self.is_method_call(&*expr) => {\n+                self.call(expr, pred, e.clone(), [])\n             }\n \n             ast::ExprTup(ref exprs) => {\n@@ -393,7 +395,7 @@ impl<'a> CFGBuilder<'a> {\n \n             ast::ExprStruct(_, ref fields, base) => {\n                 let base_exit = self.opt_expr(base, pred);\n-                let field_exprs: Vec<@ast::Expr> =\n+                let field_exprs: Vec<Gc<ast::Expr>> =\n                     fields.iter().map(|f| f.expr).collect();\n                 self.straightline(expr, base_exit, field_exprs.as_slice())\n             }\n@@ -437,34 +439,34 @@ impl<'a> CFGBuilder<'a> {\n     }\n \n     fn call(&mut self,\n-            call_expr: @ast::Expr,\n+            call_expr: Gc<ast::Expr>,\n             pred: CFGIndex,\n-            func_or_rcvr: @ast::Expr,\n-            args: &[@ast::Expr]) -> CFGIndex {\n+            func_or_rcvr: Gc<ast::Expr>,\n+            args: &[Gc<ast::Expr>]) -> CFGIndex {\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         self.straightline(call_expr, func_or_rcvr_exit, args)\n     }\n \n     fn exprs(&mut self,\n-             exprs: &[@ast::Expr],\n+             exprs: &[Gc<ast::Expr>],\n              pred: CFGIndex) -> CFGIndex {\n         //! Constructs graph for `exprs` evaluated in order\n \n         exprs.iter().fold(pred, |p, &e| self.expr(e, p))\n     }\n \n     fn opt_expr(&mut self,\n-                opt_expr: Option<@ast::Expr>,\n+                opt_expr: Option<Gc<ast::Expr>>,\n                 pred: CFGIndex) -> CFGIndex {\n         //! Constructs graph for `opt_expr` evaluated, if Some\n \n         opt_expr.iter().fold(pred, |p, &e| self.expr(e, p))\n     }\n \n     fn straightline(&mut self,\n-                    expr: @ast::Expr,\n+                    expr: Gc<ast::Expr>,\n                     pred: CFGIndex,\n-                    subexprs: &[@ast::Expr]) -> CFGIndex {\n+                    subexprs: &[Gc<ast::Expr>]) -> CFGIndex {\n         //! Handles case of an expression that evaluates `subexprs` in order\n \n         let subexprs_exit = self.exprs(subexprs, pred);\n@@ -496,7 +498,7 @@ impl<'a> CFGBuilder<'a> {\n     }\n \n     fn add_exiting_edge(&mut self,\n-                        from_expr: @ast::Expr,\n+                        from_expr: Gc<ast::Expr>,\n                         from_index: CFGIndex,\n                         to_loop: LoopScope,\n                         to_index: CFGIndex) {\n@@ -511,7 +513,7 @@ impl<'a> CFGBuilder<'a> {\n     }\n \n     fn add_returning_edge(&mut self,\n-                          _from_expr: @ast::Expr,\n+                          _from_expr: Gc<ast::Expr>,\n                           from_index: CFGIndex) {\n         let mut data = CFGEdgeData {\n             exiting_scopes: vec!(),\n@@ -523,7 +525,7 @@ impl<'a> CFGBuilder<'a> {\n     }\n \n     fn find_scope(&self,\n-                  expr: @ast::Expr,\n+                  expr: Gc<ast::Expr>,\n                   label: Option<ast::Ident>) -> LoopScope {\n         match label {\n             None => {"}, {"sha": "cf886702d863126f7373e17b7db64e8ac646cf8f", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -45,13 +45,13 @@ pub fn check_crate(krate: &Crate, tcx: &ty::ctxt) {\n fn check_item(v: &mut CheckCrateVisitor, it: &Item, _is_const: bool) {\n     match it.node {\n         ItemStatic(_, _, ex) => {\n-            v.visit_expr(ex, true);\n+            v.visit_expr(&*ex, true);\n             check_item_recursion(&v.tcx.sess, &v.tcx.map, &v.tcx.def_map, it);\n         }\n         ItemEnum(ref enum_definition, _) => {\n             for var in (*enum_definition).variants.iter() {\n                 for ex in var.node.disr_expr.iter() {\n-                    v.visit_expr(*ex, true);\n+                    v.visit_expr(&**ex, true);\n                 }\n             }\n         }\n@@ -73,10 +73,10 @@ fn check_pat(v: &mut CheckCrateVisitor, p: &Pat, _is_const: bool) {\n     }\n     match p.node {\n       // Let through plain ~-string literals here\n-      PatLit(a) => if !is_str(a) { v.visit_expr(a, true); },\n-      PatRange(a, b) => {\n-        if !is_str(a) { v.visit_expr(a, true); }\n-        if !is_str(b) { v.visit_expr(b, true); }\n+      PatLit(ref a) => if !is_str(&**a) { v.visit_expr(&**a, true); },\n+      PatRange(ref a, ref b) => {\n+        if !is_str(&**a) { v.visit_expr(&**a, true); }\n+        if !is_str(&**b) { v.visit_expr(&**b, true); }\n       }\n       _ => visit::walk_pat(v, p, false)\n     }\n@@ -245,7 +245,7 @@ impl<'a> Visitor<()> for CheckItemRecursionVisitor<'a> {\n                 match self.def_map.borrow().find(&e.id) {\n                     Some(&DefStatic(def_id, _)) if\n                             ast_util::is_local(def_id) => {\n-                        self.visit_item(self.ast_map.expect_item(def_id.node), ());\n+                        self.visit_item(&*self.ast_map.expect_item(def_id.node), ());\n                     }\n                     _ => ()\n                 }"}, {"sha": "c855d59d50851f7100edc538e624ad4a24508540", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -35,15 +35,15 @@ impl<'a> Visitor<Context> for CheckLoopVisitor<'a> {\n \n     fn visit_expr(&mut self, e: &ast::Expr, cx:Context) {\n         match e.node {\n-            ast::ExprWhile(e, b) => {\n-                self.visit_expr(e, cx);\n-                self.visit_block(b, Loop);\n+            ast::ExprWhile(ref e, ref b) => {\n+                self.visit_expr(&**e, cx);\n+                self.visit_block(&**b, Loop);\n             }\n-            ast::ExprLoop(b, _) => {\n-                self.visit_block(b, Loop);\n+            ast::ExprLoop(ref b, _) => {\n+                self.visit_block(&**b, Loop);\n             }\n-            ast::ExprFnBlock(_, b) | ast::ExprProc(_, b) => {\n-                self.visit_block(b, Closure);\n+            ast::ExprFnBlock(_, ref b) | ast::ExprProc(_, ref b) => {\n+                self.visit_block(&**b, Closure);\n             }\n             ast::ExprBreak(_) => self.require_loop(\"break\", cx, e.span),\n             ast::ExprAgain(_) => self.require_loop(\"continue\", cx, e.span),"}, {"sha": "b937d8ef3bbc1bbd758e2e57df82c4ed89ef65d6", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -19,6 +19,7 @@ use middle::ty;\n use util::ppaux::ty_to_str;\n \n use std::cmp;\n+use std::gc::Gc;\n use std::iter;\n use syntax::ast::*;\n use syntax::ast_util::{is_unguarded, walk_pat};\n@@ -104,7 +105,7 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n                 match opt_def {\n                     Some(DefStatic(did, false)) => {\n                         let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-                        match eval_const_expr(cx.tcx, const_expr) {\n+                        match eval_const_expr(cx.tcx, &*const_expr) {\n                             const_float(f) if f.is_nan() => true,\n                             _ => false\n                         }\n@@ -113,7 +114,7 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n                 }\n             };\n \n-            walk_pat(*pat, |p| {\n+            walk_pat(&**pat, |p| {\n                 if pat_matches_nan(p) {\n                     cx.tcx.sess.span_warn(p.span, \"unmatchable NaN in pattern, \\\n                                                    use the is_nan method in a guard instead\");\n@@ -133,7 +134,7 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n     }\n }\n \n-fn raw_pat(p: @Pat) -> @Pat {\n+fn raw_pat(p: Gc<Pat>) -> Gc<Pat> {\n     match p.node {\n       PatIdent(_, _, Some(s)) => { raw_pat(s) }\n       _ => { p }\n@@ -193,7 +194,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, m: &matrix) {\n     cx.tcx.sess.span_err(sp, msg.as_slice());\n }\n \n-type matrix = Vec<Vec<@Pat> > ;\n+type matrix = Vec<Vec<Gc<Pat>>>;\n \n #[deriving(Clone)]\n enum useful {\n@@ -224,7 +225,7 @@ enum ctor {\n \n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n-fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n+fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[Gc<Pat>]) -> useful {\n     if m.len() == 0u {\n         return useful_;\n     }\n@@ -327,7 +328,7 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n \n fn is_useful_specialized(cx: &MatchCheckCtxt,\n                              m: &matrix,\n-                             v: &[@Pat],\n+                             v: &[Gc<Pat>],\n                              ctor: ctor,\n                              arity: uint,\n                              lty: ty::t)\n@@ -345,7 +346,7 @@ fn is_useful_specialized(cx: &MatchCheckCtxt,\n     }\n }\n \n-fn pat_ctor_id(cx: &MatchCheckCtxt, p: @Pat) -> Option<ctor> {\n+fn pat_ctor_id(cx: &MatchCheckCtxt, p: Gc<Pat>) -> Option<ctor> {\n     let pat = raw_pat(p);\n     match pat.node {\n       PatWild | PatWildMulti => { None }\n@@ -355,14 +356,14 @@ fn pat_ctor_id(cx: &MatchCheckCtxt, p: @Pat) -> Option<ctor> {\n           Some(DefVariant(_, id, _)) => Some(variant(id)),\n           Some(DefStatic(did, false)) => {\n             let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-            Some(val(eval_const_expr(cx.tcx, const_expr)))\n+            Some(val(eval_const_expr(cx.tcx, &*const_expr)))\n           }\n           _ => None\n         }\n       }\n-      PatLit(expr) => { Some(val(eval_const_expr(cx.tcx, expr))) }\n-      PatRange(lo, hi) => {\n-        Some(range(eval_const_expr(cx.tcx, lo), eval_const_expr(cx.tcx, hi)))\n+      PatLit(ref expr) => { Some(val(eval_const_expr(cx.tcx, &**expr))) }\n+      PatRange(ref lo, ref hi) => {\n+        Some(range(eval_const_expr(cx.tcx, &**lo), eval_const_expr(cx.tcx, &**hi)))\n       }\n       PatStruct(..) => {\n         match cx.tcx.def_map.borrow().find(&pat.id) {\n@@ -383,7 +384,7 @@ fn pat_ctor_id(cx: &MatchCheckCtxt, p: @Pat) -> Option<ctor> {\n     }\n }\n \n-fn is_wild(cx: &MatchCheckCtxt, p: @Pat) -> bool {\n+fn is_wild(cx: &MatchCheckCtxt, p: Gc<Pat>) -> bool {\n     let pat = raw_pat(p);\n     match pat.node {\n       PatWild | PatWildMulti => { true }\n@@ -548,12 +549,12 @@ fn ctor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n     }\n }\n \n-fn wild() -> @Pat {\n-    @Pat {id: 0, node: PatWild, span: DUMMY_SP}\n+fn wild() -> Gc<Pat> {\n+    box(GC) Pat {id: 0, node: PatWild, span: DUMMY_SP}\n }\n \n-fn wild_multi() -> @Pat {\n-    @Pat {id: 0, node: PatWildMulti, span: DUMMY_SP}\n+fn wild_multi() -> Gc<Pat> {\n+    box(GC) Pat {id: 0, node: PatWildMulti, span: DUMMY_SP}\n }\n \n fn range_covered_by_constructor(ctor_id: &ctor, from: &const_val, to: &const_val) -> Option<bool> {\n@@ -572,13 +573,13 @@ fn range_covered_by_constructor(ctor_id: &ctor, from: &const_val, to: &const_val\n }\n \n fn specialize(cx: &MatchCheckCtxt,\n-                  r: &[@Pat],\n+                  r: &[Gc<Pat>],\n                   ctor_id: &ctor,\n                   arity: uint,\n                   left_ty: ty::t)\n-               -> Option<Vec<@Pat> > {\n+               -> Option<Vec<Gc<Pat>>> {\n     let &Pat{id: ref pat_id, node: ref n, span: ref pat_span} = &(*raw_pat(r[0]));\n-    let head: Option<Vec<@Pat>> = match n {\n+    let head: Option<Vec<Gc<Pat>>> = match n {\n             &PatWild => {\n                 Some(Vec::from_elem(arity, wild()))\n             }\n@@ -597,7 +598,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                     }\n                     Some(DefStatic(did, _)) => {\n                         let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-                        let e_v = eval_const_expr(cx.tcx, const_expr);\n+                        let e_v = eval_const_expr(cx.tcx, &*const_expr);\n                         match range_covered_by_constructor(ctor_id, &e_v, &e_v) {\n                            Some(true) => Some(vec!()),\n                            Some(false) => None,\n@@ -617,7 +618,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                 match def {\n                     DefStatic(did, _) => {\n                         let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-                        let e_v = eval_const_expr(cx.tcx, const_expr);\n+                        let e_v = eval_const_expr(cx.tcx, &*const_expr);\n                         match range_covered_by_constructor(ctor_id, &e_v, &e_v) {\n                            Some(true) => Some(vec!()),\n                            Some(false) => None,\n@@ -681,7 +682,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                 Some(vec!(inner.clone()))\n             }\n             &PatLit(ref expr) => {\n-              let expr_value = eval_const_expr(cx.tcx, *expr);\n+              let expr_value = eval_const_expr(cx.tcx, &**expr);\n               match range_covered_by_constructor(ctor_id, &expr_value, &expr_value) {\n                  Some(true) => Some(vec!()),\n                  Some(false) => None,\n@@ -692,8 +693,8 @@ fn specialize(cx: &MatchCheckCtxt,\n               }\n             }\n             &PatRange(ref from, ref to) => {\n-              let from_value = eval_const_expr(cx.tcx, *from);\n-              let to_value = eval_const_expr(cx.tcx, *to);\n+              let from_value = eval_const_expr(cx.tcx, &**from);\n+              let to_value = eval_const_expr(cx.tcx, &**to);\n               match range_covered_by_constructor(ctor_id, &from_value, &to_value) {\n                  Some(true) => Some(vec!()),\n                  Some(false) => None,\n@@ -733,7 +734,7 @@ fn specialize(cx: &MatchCheckCtxt,\n     head.map(|head| head.append(r.tail()))\n }\n \n-fn default(cx: &MatchCheckCtxt, r: &[@Pat]) -> Option<Vec<@Pat> > {\n+fn default(cx: &MatchCheckCtxt, r: &[Gc<Pat>]) -> Option<Vec<Gc<Pat>>> {\n     if is_wild(cx, r[0]) {\n         Some(Vec::from_slice(r.tail()))\n     } else {\n@@ -750,7 +751,7 @@ fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {\n     };\n \n     let mut spans = vec![];\n-    find_refutable(cx, loc.pat, &mut spans);\n+    find_refutable(cx, &*loc.pat, &mut spans);\n \n     for span in spans.iter() {\n         cx.tcx.sess.span_err(*span,\n@@ -769,7 +770,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n     visit::walk_fn(cx, kind, decl, body, sp, ());\n     for input in decl.inputs.iter() {\n         let mut spans = vec![];\n-        find_refutable(cx, input.pat, &mut spans);\n+        find_refutable(cx, &*input.pat, &mut spans);\n \n         for span in spans.iter() {\n             cx.tcx.sess.span_err(*span,\n@@ -799,8 +800,8 @@ fn find_refutable(cx: &MatchCheckCtxt, pat: &Pat, spans: &mut Vec<Span>) {\n     }\n \n     match pat.node {\n-      PatBox(sub) | PatRegion(sub) | PatIdent(_, _, Some(sub)) => {\n-        find_refutable(cx, sub, spans)\n+      PatBox(ref sub) | PatRegion(ref sub) | PatIdent(_, _, Some(ref sub)) => {\n+        find_refutable(cx, &**sub, spans)\n       }\n       PatWild | PatWildMulti | PatIdent(_, _, None) => {}\n       PatLit(lit) => {\n@@ -817,12 +818,12 @@ fn find_refutable(cx: &MatchCheckCtxt, pat: &Pat, spans: &mut Vec<Span>) {\n       PatRange(_, _) => { this_pattern!() }\n       PatStruct(_, ref fields, _) => {\n           for f in fields.iter() {\n-              find_refutable(cx, f.pat, spans);\n+              find_refutable(cx, &*f.pat, spans);\n           }\n       }\n       PatTup(ref elts) | PatEnum(_, Some(ref elts))=> {\n           for elt in elts.iter() {\n-              find_refutable(cx, *elt, spans)\n+              find_refutable(cx, &**elt, spans)\n           }\n       }\n       PatEnum(_,_) => {}\n@@ -835,12 +836,12 @@ fn find_refutable(cx: &MatchCheckCtxt, pat: &Pat, spans: &mut Vec<Span>) {\n \n fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                                    has_guard: bool,\n-                                   pats: &[@Pat]) {\n+                                   pats: &[Gc<Pat>]) {\n     let tcx = cx.tcx;\n     let def_map = &tcx.def_map;\n     let mut by_ref_span = None;\n     for pat in pats.iter() {\n-        pat_bindings(def_map, *pat, |bm, _, span, _path| {\n+        pat_bindings(def_map, &**pat, |bm, _, span, _path| {\n             match bm {\n                 BindByRef(_) => {\n                     by_ref_span = Some(span);\n@@ -851,11 +852,11 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         })\n     }\n \n-    let check_move: |&Pat, Option<@Pat>| = |p, sub| {\n+    let check_move: |&Pat, Option<Gc<Pat>>| = |p, sub| {\n         // check legality of moving out of the enum\n \n         // x @ Foo(..) is legal, but x @ Foo(y) isn't.\n-        if sub.map_or(false, |p| pat_contains_bindings(def_map, p)) {\n+        if sub.map_or(false, |p| pat_contains_bindings(def_map, &*p)) {\n             tcx.sess.span_err(\n                 p.span,\n                 \"cannot bind by-move with sub-bindings\");\n@@ -875,8 +876,8 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     };\n \n     for pat in pats.iter() {\n-        walk_pat(*pat, |p| {\n-            if pat_is_binding(def_map, p) {\n+        walk_pat(&**pat, |p| {\n+            if pat_is_binding(def_map, &*p) {\n                 match p.node {\n                     PatIdent(BindByValue(_), _, sub) => {\n                         let pat_ty = ty::node_id_to_type(tcx, p.id);"}, {"sha": "36e98763ebbf898099e04656fab160708d07e5f1", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -77,13 +77,14 @@ impl<'a> Visitor<bool> for CheckStaticVisitor<'a> {\n     fn visit_item(&mut self, i: &ast::Item, _is_const: bool) {\n         debug!(\"visit_item(item={})\", pprust::item_to_str(i));\n         match i.node {\n-            ast::ItemStatic(_, mutability, expr) => {\n+            ast::ItemStatic(_, mutability, ref expr) => {\n                 match mutability {\n                     ast::MutImmutable => {\n-                        self.visit_expr(expr, true);\n+                        self.visit_expr(&**expr, true);\n                     }\n                     ast::MutMutable => {\n-                        self.report_error(expr.span, safe_type_for_static_mut(self.tcx, expr));\n+                        let safe = safe_type_for_static_mut(self.tcx, &**expr);\n+                        self.report_error(expr.span, safe);\n                     }\n                 }\n             }"}, {"sha": "13d0443a00f2b62a5f968c2649846704fc964916", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 37, "deletions": 34, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -26,6 +26,7 @@ use syntax::visit;\n use syntax::{ast, ast_map, ast_util};\n \n use std::rc::Rc;\n+use std::gc::Gc;\n \n //\n // This pass classifies expressions by their constant-ness.\n@@ -81,7 +82,7 @@ pub fn join_all<It: Iterator<constness>>(mut cs: It) -> constness {\n     cs.fold(integral_const, |a, b| join(a, b))\n }\n \n-pub fn lookup_const(tcx: &ty::ctxt, e: &Expr) -> Option<@Expr> {\n+pub fn lookup_const(tcx: &ty::ctxt, e: &Expr) -> Option<Gc<Expr>> {\n     let opt_def = tcx.def_map.borrow().find_copy(&e.id);\n     match opt_def {\n         Some(def::DefStatic(def_id, false)) => {\n@@ -97,8 +98,9 @@ pub fn lookup_const(tcx: &ty::ctxt, e: &Expr) -> Option<@Expr> {\n pub fn lookup_variant_by_id(tcx: &ty::ctxt,\n                             enum_def: ast::DefId,\n                             variant_def: ast::DefId)\n-                       -> Option<@Expr> {\n-    fn variant_expr(variants: &[ast::P<ast::Variant>], id: ast::NodeId) -> Option<@Expr> {\n+                       -> Option<Gc<Expr>> {\n+    fn variant_expr(variants: &[ast::P<ast::Variant>],\n+                    id: ast::NodeId) -> Option<Gc<Expr>> {\n         for variant in variants.iter() {\n             if variant.node.id == id {\n                 return variant.node.disr_expr;\n@@ -141,7 +143,7 @@ pub fn lookup_variant_by_id(tcx: &ty::ctxt,\n }\n \n pub fn lookup_const_by_id(tcx: &ty::ctxt, def_id: ast::DefId)\n-                          -> Option<@Expr> {\n+                          -> Option<Gc<Expr>> {\n     if ast_util::is_local(def_id) {\n         {\n             match tcx.map.find(def_id.node) {\n@@ -186,39 +188,39 @@ impl<'a> ConstEvalVisitor<'a> {\n             None => {}\n         }\n         let cn = match e.node {\n-            ast::ExprLit(lit) => {\n+            ast::ExprLit(ref lit) => {\n                 match lit.node {\n                     ast::LitStr(..) | ast::LitFloat(..) => general_const,\n                     _ => integral_const\n                 }\n             }\n \n-            ast::ExprUnary(_, inner) | ast::ExprParen(inner) =>\n-                self.classify(inner),\n+            ast::ExprUnary(_, ref inner) | ast::ExprParen(ref inner) =>\n+                self.classify(&**inner),\n \n-            ast::ExprBinary(_, a, b) =>\n-                join(self.classify(a), self.classify(b)),\n+            ast::ExprBinary(_, ref a, ref b) =>\n+                join(self.classify(&**a), self.classify(&**b)),\n \n             ast::ExprTup(ref es) |\n             ast::ExprVec(ref es) =>\n-                join_all(es.iter().map(|e| self.classify(*e))),\n+                join_all(es.iter().map(|e| self.classify(&**e))),\n \n-            ast::ExprVstore(e, vstore) => {\n+            ast::ExprVstore(ref e, vstore) => {\n                 match vstore {\n-                    ast::ExprVstoreSlice => self.classify(e),\n+                    ast::ExprVstoreSlice => self.classify(&**e),\n                     ast::ExprVstoreUniq |\n                     ast::ExprVstoreMutSlice => non_const\n                 }\n             }\n \n             ast::ExprStruct(_, ref fs, None) => {\n-                let cs = fs.iter().map(|f| self.classify(f.expr));\n+                let cs = fs.iter().map(|f| self.classify(&*f.expr));\n                 join_all(cs)\n             }\n \n-            ast::ExprCast(base, _) => {\n+            ast::ExprCast(ref base, _) => {\n                 let ty = ty::expr_ty(self.tcx, e);\n-                let base = self.classify(base);\n+                let base = self.classify(&**base);\n                 if ty::type_is_integral(ty) {\n                     join(integral_const, base)\n                 } else if ty::type_is_fp(ty) {\n@@ -228,12 +230,13 @@ impl<'a> ConstEvalVisitor<'a> {\n                 }\n             }\n \n-            ast::ExprField(base, _, _) => self.classify(base),\n+            ast::ExprField(ref base, _, _) => self.classify(&**base),\n \n-            ast::ExprIndex(base, idx) =>\n-                join(self.classify(base), self.classify(idx)),\n+            ast::ExprIndex(ref base, ref idx) =>\n+                join(self.classify(&**base), self.classify(&**idx)),\n \n-            ast::ExprAddrOf(ast::MutImmutable, base) => self.classify(base),\n+            ast::ExprAddrOf(ast::MutImmutable, ref base) =>\n+                self.classify(&**base),\n \n             // FIXME: (#3728) we can probably do something CCI-ish\n             // surrounding nonlocal constants. But we don't yet.\n@@ -257,7 +260,7 @@ impl<'a> ConstEvalVisitor<'a> {\n     fn lookup_constness(&self, e: &Expr) -> constness {\n         match lookup_const(self.tcx, e) {\n             Some(rhs) => {\n-                let ty = ty::expr_ty(self.tcx, rhs);\n+                let ty = ty::expr_ty(self.tcx, &*rhs);\n                 if ty::type_is_integral(ty) {\n                     integral_const\n                 } else {\n@@ -310,8 +313,8 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n                             -> Result<const_val, String> {\n     fn fromb(b: bool) -> Result<const_val, String> { Ok(const_int(b as i64)) }\n     match e.node {\n-      ExprUnary(UnNeg, inner) => {\n-        match eval_const_expr_partial(tcx, inner) {\n+      ExprUnary(UnNeg, ref inner) => {\n+        match eval_const_expr_partial(tcx, &**inner) {\n           Ok(const_float(f)) => Ok(const_float(-f)),\n           Ok(const_int(i)) => Ok(const_int(-i)),\n           Ok(const_uint(i)) => Ok(const_uint(-i)),\n@@ -320,17 +323,17 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n           ref err => ((*err).clone())\n         }\n       }\n-      ExprUnary(UnNot, inner) => {\n-        match eval_const_expr_partial(tcx, inner) {\n+      ExprUnary(UnNot, ref inner) => {\n+        match eval_const_expr_partial(tcx, &**inner) {\n           Ok(const_int(i)) => Ok(const_int(!i)),\n           Ok(const_uint(i)) => Ok(const_uint(!i)),\n           Ok(const_bool(b)) => Ok(const_bool(!b)),\n           _ => Err(\"not on float or string\".to_string())\n         }\n       }\n-      ExprBinary(op, a, b) => {\n-        match (eval_const_expr_partial(tcx, a),\n-               eval_const_expr_partial(tcx, b)) {\n+      ExprBinary(op, ref a, ref b) => {\n+        match (eval_const_expr_partial(tcx, &**a),\n+               eval_const_expr_partial(tcx, &**b)) {\n           (Ok(const_float(a)), Ok(const_float(b))) => {\n             match op {\n               BiAdd => Ok(const_float(a + b)),\n@@ -431,19 +434,19 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n           _ => Err(\"bad operands for binary\".to_string())\n         }\n       }\n-      ExprCast(base, target_ty) => {\n+      ExprCast(ref base, ref target_ty) => {\n         // This tends to get called w/o the type actually having been\n         // populated in the ctxt, which was causing things to blow up\n         // (#5900). Fall back to doing a limited lookup to get past it.\n         let ety = ty::expr_ty_opt(tcx.ty_ctxt(), e)\n-                .or_else(|| astconv::ast_ty_to_prim_ty(tcx.ty_ctxt(), target_ty))\n+                .or_else(|| astconv::ast_ty_to_prim_ty(tcx.ty_ctxt(), &**target_ty))\n                 .unwrap_or_else(|| {\n                     tcx.ty_ctxt().sess.span_fatal(target_ty.span,\n                                                   \"target type not found for \\\n                                                    const cast\")\n                 });\n \n-        let base = eval_const_expr_partial(tcx, base);\n+        let base = eval_const_expr_partial(tcx, &**base);\n         match base {\n             Err(_) => base,\n             Ok(val) => {\n@@ -479,14 +482,14 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n       }\n       ExprPath(_) => {\n           match lookup_const(tcx.ty_ctxt(), e) {\n-              Some(actual_e) => eval_const_expr_partial(tcx.ty_ctxt(), actual_e),\n+              Some(actual_e) => eval_const_expr_partial(tcx.ty_ctxt(), &*actual_e),\n               None => Err(\"non-constant path in constant expr\".to_string())\n           }\n       }\n-      ExprLit(lit) => Ok(lit_to_const(lit)),\n+      ExprLit(ref lit) => Ok(lit_to_const(&**lit)),\n       // If we have a vstore, just keep going; it has to be a string\n-      ExprVstore(e, _) => eval_const_expr_partial(tcx, e),\n-      ExprParen(e)     => eval_const_expr_partial(tcx, e),\n+      ExprVstore(ref e, _) => eval_const_expr_partial(tcx, &**e),\n+      ExprParen(ref e)     => eval_const_expr_partial(tcx, &**e),\n       ExprBlock(ref block) => {\n         match block.expr {\n             Some(ref expr) => eval_const_expr_partial(tcx, &**expr),"}, {"sha": "b8db8e230b074c589e7ff646fcd7bcf394a6ee2d", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -21,7 +21,7 @@ use middle::def;\n use middle::ty;\n use middle::typeck;\n use std::io;\n-use std::string::String;\n+use std::gc::Gc;\n use std::uint;\n use syntax::ast;\n use syntax::ast_util;\n@@ -346,8 +346,8 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n \n         self.merge_with_entry_set(blk.id, in_out);\n \n-        for &stmt in blk.stmts.iter() {\n-            self.walk_stmt(stmt, in_out, loop_scopes);\n+        for stmt in blk.stmts.iter() {\n+            self.walk_stmt(stmt.clone(), in_out, loop_scopes);\n         }\n \n         self.walk_opt_expr(blk.expr, in_out, loop_scopes);\n@@ -356,16 +356,16 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n     }\n \n     fn walk_stmt(&mut self,\n-                 stmt: @ast::Stmt,\n+                 stmt: Gc<ast::Stmt>,\n                  in_out: &mut [uint],\n                  loop_scopes: &mut Vec<LoopScope> ) {\n         match stmt.node {\n-            ast::StmtDecl(decl, _) => {\n-                self.walk_decl(decl, in_out, loop_scopes);\n+            ast::StmtDecl(ref decl, _) => {\n+                self.walk_decl(decl.clone(), in_out, loop_scopes);\n             }\n \n-            ast::StmtExpr(expr, _) | ast::StmtSemi(expr, _) => {\n-                self.walk_expr(expr, in_out, loop_scopes);\n+            ast::StmtExpr(ref expr, _) | ast::StmtSemi(ref expr, _) => {\n+                self.walk_expr(&**expr, in_out, loop_scopes);\n             }\n \n             ast::StmtMac(..) => {\n@@ -375,11 +375,11 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n     }\n \n     fn walk_decl(&mut self,\n-                 decl: @ast::Decl,\n+                 decl: Gc<ast::Decl>,\n                  in_out: &mut [uint],\n                  loop_scopes: &mut Vec<LoopScope> ) {\n         match decl.node {\n-            ast::DeclLocal(local) => {\n+            ast::DeclLocal(ref local) => {\n                 self.walk_opt_expr(local.init, in_out, loop_scopes);\n                 self.walk_pat(local.pat, in_out, loop_scopes);\n             }\n@@ -415,10 +415,10 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                 //    v     v\n                 //   (  succ  )\n                 //\n-                self.walk_expr(cond, in_out, loop_scopes);\n+                self.walk_expr(&*cond, in_out, loop_scopes);\n \n                 let mut then_bits = in_out.to_owned();\n-                self.walk_block(then, then_bits, loop_scopes);\n+                self.walk_block(&*then, then_bits, loop_scopes);\n \n                 self.walk_opt_expr(els, in_out, loop_scopes);\n                 join_bits(&self.dfcx.oper, then_bits, in_out);\n@@ -437,22 +437,22 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                 //    <--+ (break)\n                 //\n \n-                self.walk_expr(cond, in_out, loop_scopes);\n+                self.walk_expr(&*cond, in_out, loop_scopes);\n \n                 let mut body_bits = in_out.to_owned();\n                 loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     break_bits: Vec::from_slice(in_out)\n                 });\n-                self.walk_block(blk, body_bits, loop_scopes);\n+                self.walk_block(&*blk, body_bits, loop_scopes);\n                 self.add_to_entry_set(expr.id, body_bits);\n                 let new_loop_scope = loop_scopes.pop().unwrap();\n                 copy_bits(new_loop_scope.break_bits.as_slice(), in_out);\n             }\n \n             ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n-            ast::ExprLoop(blk, _) => {\n+            ast::ExprLoop(ref blk, _) => {\n                 //\n                 //     (expr) <--+\n                 //       |       |\n@@ -468,15 +468,15 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                     loop_id: expr.id,\n                     break_bits: Vec::from_slice(in_out)\n                 });\n-                self.walk_block(blk, body_bits, loop_scopes);\n+                self.walk_block(&**blk, body_bits, loop_scopes);\n                 self.add_to_entry_set(expr.id, body_bits);\n \n                 let new_loop_scope = loop_scopes.pop().unwrap();\n                 assert_eq!(new_loop_scope.loop_id, expr.id);\n                 copy_bits(new_loop_scope.break_bits.as_slice(), in_out);\n             }\n \n-            ast::ExprMatch(discr, ref arms) => {\n+            ast::ExprMatch(ref discr, ref arms) => {\n                 //\n                 //    (discr)\n                 //     / | \\\n@@ -488,7 +488,7 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                 //   (  succ  )\n                 //\n                 //\n-                self.walk_expr(discr, in_out, loop_scopes);\n+                self.walk_expr(&**discr, in_out, loop_scopes);\n \n                 let mut guards = in_out.to_owned();\n \n@@ -507,7 +507,7 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                     self.walk_pat_alternatives(arm.pats.as_slice(),\n                                                body,\n                                                loop_scopes);\n-                    self.walk_expr(arm.body, body, loop_scopes);\n+                    self.walk_expr(&*arm.body, body, loop_scopes);\n                     join_bits(&self.dfcx.oper, body, in_out);\n                 }\n             }\n@@ -530,30 +530,30 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                 self.reset(in_out);\n             }\n \n-            ast::ExprAssign(l, r) |\n-            ast::ExprAssignOp(_, l, r) => {\n-                self.walk_expr(r, in_out, loop_scopes);\n-                self.walk_expr(l, in_out, loop_scopes);\n+            ast::ExprAssign(ref l, ref r) |\n+            ast::ExprAssignOp(_, ref l, ref r) => {\n+                self.walk_expr(&**r, in_out, loop_scopes);\n+                self.walk_expr(&**l, in_out, loop_scopes);\n             }\n \n             ast::ExprVec(ref exprs) => {\n                 self.walk_exprs(exprs.as_slice(), in_out, loop_scopes)\n             }\n \n-            ast::ExprRepeat(l, r) => {\n-                self.walk_expr(l, in_out, loop_scopes);\n-                self.walk_expr(r, in_out, loop_scopes);\n+            ast::ExprRepeat(ref l, ref r) => {\n+                self.walk_expr(&**l, in_out, loop_scopes);\n+                self.walk_expr(&**r, in_out, loop_scopes);\n             }\n \n             ast::ExprStruct(_, ref fields, with_expr) => {\n                 for field in fields.iter() {\n-                    self.walk_expr(field.expr, in_out, loop_scopes);\n+                    self.walk_expr(&*field.expr, in_out, loop_scopes);\n                 }\n                 self.walk_opt_expr(with_expr, in_out, loop_scopes);\n             }\n \n-            ast::ExprCall(f, ref args) => {\n-                self.walk_expr(f, in_out, loop_scopes);\n+            ast::ExprCall(ref f, ref args) => {\n+                self.walk_expr(&**f, in_out, loop_scopes);\n                 self.walk_call(expr.id, args.as_slice(), in_out, loop_scopes);\n             }\n \n@@ -574,10 +574,10 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                 self.walk_exprs(exprs.as_slice(), in_out, loop_scopes);\n             }\n \n-            ast::ExprBinary(op, l, r) if ast_util::lazy_binop(op) => {\n-                self.walk_expr(l, in_out, loop_scopes);\n+            ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {\n+                self.walk_expr(&**l, in_out, loop_scopes);\n                 let temp = in_out.to_owned();\n-                self.walk_expr(r, in_out, loop_scopes);\n+                self.walk_expr(&**r, in_out, loop_scopes);\n                 join_bits(&self.dfcx.oper, temp, in_out);\n             }\n \n@@ -589,31 +589,31 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n             ast::ExprLit(..) |\n             ast::ExprPath(..) => {}\n \n-            ast::ExprAddrOf(_, e) |\n-            ast::ExprCast(e, _) |\n-            ast::ExprUnary(_, e) |\n-            ast::ExprParen(e) |\n-            ast::ExprVstore(e, _) |\n-            ast::ExprField(e, _, _) => {\n-                self.walk_expr(e, in_out, loop_scopes);\n+            ast::ExprAddrOf(_, ref e) |\n+            ast::ExprCast(ref e, _) |\n+            ast::ExprUnary(_, ref e) |\n+            ast::ExprParen(ref e) |\n+            ast::ExprVstore(ref e, _) |\n+            ast::ExprField(ref e, _, _) => {\n+                self.walk_expr(&**e, in_out, loop_scopes);\n             }\n \n-            ast::ExprBox(s, e) => {\n-                self.walk_expr(s, in_out, loop_scopes);\n-                self.walk_expr(e, in_out, loop_scopes);\n+            ast::ExprBox(ref s, ref e) => {\n+                self.walk_expr(&**s, in_out, loop_scopes);\n+                self.walk_expr(&**e, in_out, loop_scopes);\n             }\n \n             ast::ExprInlineAsm(ref inline_asm) => {\n-                for &(_, expr) in inline_asm.inputs.iter() {\n-                    self.walk_expr(expr, in_out, loop_scopes);\n+                for &(_, ref expr) in inline_asm.inputs.iter() {\n+                    self.walk_expr(&**expr, in_out, loop_scopes);\n                 }\n-                for &(_, expr) in inline_asm.outputs.iter() {\n-                    self.walk_expr(expr, in_out, loop_scopes);\n+                for &(_, ref expr) in inline_asm.outputs.iter() {\n+                    self.walk_expr(&**expr, in_out, loop_scopes);\n                 }\n             }\n \n-            ast::ExprBlock(blk) => {\n-                self.walk_block(blk, in_out, loop_scopes);\n+            ast::ExprBlock(ref blk) => {\n+                self.walk_block(&**blk, in_out, loop_scopes);\n             }\n \n             ast::ExprMac(..) => {\n@@ -674,26 +674,26 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n     }\n \n     fn walk_exprs(&mut self,\n-                  exprs: &[@ast::Expr],\n+                  exprs: &[Gc<ast::Expr>],\n                   in_out: &mut [uint],\n                   loop_scopes: &mut Vec<LoopScope> ) {\n-        for &expr in exprs.iter() {\n-            self.walk_expr(expr, in_out, loop_scopes);\n+        for expr in exprs.iter() {\n+            self.walk_expr(&**expr, in_out, loop_scopes);\n         }\n     }\n \n     fn walk_opt_expr(&mut self,\n-                     opt_expr: Option<@ast::Expr>,\n+                     opt_expr: Option<Gc<ast::Expr>>,\n                      in_out: &mut [uint],\n                      loop_scopes: &mut Vec<LoopScope> ) {\n-        for &expr in opt_expr.iter() {\n-            self.walk_expr(expr, in_out, loop_scopes);\n+        for expr in opt_expr.iter() {\n+            self.walk_expr(&**expr, in_out, loop_scopes);\n         }\n     }\n \n     fn walk_call(&mut self,\n                  call_id: ast::NodeId,\n-                 args: &[@ast::Expr],\n+                 args: &[Gc<ast::Expr>],\n                  in_out: &mut [uint],\n                  loop_scopes: &mut Vec<LoopScope> ) {\n         self.walk_exprs(args, in_out, loop_scopes);\n@@ -710,13 +710,13 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n     }\n \n     fn walk_pat(&mut self,\n-                pat: @ast::Pat,\n+                pat: Gc<ast::Pat>,\n                 in_out: &mut [uint],\n                 _loop_scopes: &mut Vec<LoopScope> ) {\n         debug!(\"DataFlowContext::walk_pat(pat={}, in_out={})\",\n                pat.repr(self.dfcx.tcx), bits_to_str(in_out));\n \n-        ast_util::walk_pat(pat, |p| {\n+        ast_util::walk_pat(&*pat, |p| {\n             debug!(\"  p.id={} in_out={}\", p.id, bits_to_str(in_out));\n             self.merge_with_entry_set(p.id, in_out);\n             self.dfcx.apply_gen_kill(p.id, in_out);\n@@ -725,7 +725,7 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n     }\n \n     fn walk_pat_alternatives(&mut self,\n-                             pats: &[@ast::Pat],\n+                             pats: &[Gc<ast::Pat>],\n                              in_out: &mut [uint],\n                              loop_scopes: &mut Vec<LoopScope> ) {\n         if pats.len() == 1 {"}, {"sha": "834dc43ee6ed52d4237766798b58dfd7b5da04e1", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -184,25 +184,25 @@ impl<'a> MarkSymbolVisitor<'a> {\n                             }\n                         });\n                         self.live_symbols.extend(live_fields.map(|f| f.node.id));\n-                        visit::walk_item(self, item, ());\n+                        visit::walk_item(self, &*item, ());\n                     }\n                     ast::ItemFn(..)\n                     | ast::ItemTy(..)\n                     | ast::ItemEnum(..)\n                     | ast::ItemStatic(..) => {\n-                        visit::walk_item(self, item, ());\n+                        visit::walk_item(self, &*item, ());\n                     }\n                     _ => ()\n                 }\n             }\n             ast_map::NodeTraitMethod(trait_method) => {\n-                visit::walk_trait_method(self, trait_method, ());\n+                visit::walk_trait_method(self, &*trait_method, ());\n             }\n             ast_map::NodeMethod(method) => {\n-                visit::walk_block(self, method.body, ());\n+                visit::walk_block(self, &*method.body, ());\n             }\n             ast_map::NodeForeignItem(foreign_item) => {\n-                visit::walk_foreign_item(self, foreign_item, ());\n+                visit::walk_foreign_item(self, &*foreign_item, ());\n             }\n             _ => ()\n         }\n@@ -217,7 +217,7 @@ impl<'a> Visitor<()> for MarkSymbolVisitor<'a> {\n                 self.lookup_and_handle_method(expr.id, expr.span);\n             }\n             ast::ExprField(ref lhs, ref ident, _) => {\n-                self.handle_field_access(*lhs, ident);\n+                self.handle_field_access(&**lhs, ident);\n             }\n             _ => ()\n         }\n@@ -479,7 +479,7 @@ impl<'a> Visitor<()> for DeadVisitor<'a> {\n     // Overwrite so that we don't warn the trait method itself.\n     fn visit_trait_method(&mut self, trait_method: &ast::TraitMethod, _: ()) {\n         match *trait_method {\n-            ast::Provided(method) => visit::walk_block(self, method.body, ()),\n+            ast::Provided(ref method) => visit::walk_block(self, &*method.body, ()),\n             ast::Required(_) => ()\n         }\n     }"}, {"sha": "6805c86f1694ceda501074f6feccfad8b803edf3", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -11,6 +11,8 @@\n use syntax::ast;\n use syntax::ast_util::local_def;\n \n+use std::gc::Gc;\n+\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Def {\n     DefFn(ast::DefId, ast::FnStyle),\n@@ -29,7 +31,7 @@ pub enum Def {\n     DefBinding(ast::NodeId, ast::BindingMode),\n     DefUse(ast::DefId),\n     DefUpvar(ast::NodeId,  // id of closed over var\n-             @Def,     // closed over def\n+             Gc<Def>,     // closed over def\n              ast::NodeId,  // expr node that creates the closure\n              ast::NodeId), // id for the block/body of the closure expr\n "}, {"sha": "2333b329996401dc20c4596fbaa68b459a18d525", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -62,7 +62,7 @@ impl<'a> EffectCheckVisitor<'a> {\n         }\n     }\n \n-    fn check_str_index(&mut self, e: @ast::Expr) {\n+    fn check_str_index(&mut self, e: &ast::Expr) {\n         let base_type = match e.node {\n             ast::ExprIndex(base, _) => ty::node_id_to_type(self.tcx, base.id),\n             _ => return\n@@ -173,11 +173,11 @@ impl<'a> Visitor<()> for EffectCheckVisitor<'a> {\n                     _ => {}\n                 }\n             }\n-            ast::ExprAssign(base, _) | ast::ExprAssignOp(_, base, _) => {\n-                self.check_str_index(base);\n+            ast::ExprAssign(ref base, _) | ast::ExprAssignOp(_, ref base, _) => {\n+                self.check_str_index(&**base);\n             }\n-            ast::ExprAddrOf(ast::MutMutable, base) => {\n-                self.check_str_index(base);\n+            ast::ExprAddrOf(ast::MutMutable, ref base) => {\n+                self.check_str_index(&**base);\n             }\n             ast::ExprInlineAsm(..) => {\n                 self.require_unsafe(expr.span, \"use of inline assembly\")"}, {"sha": "86cd3c53804dee2618f572c58a4370fa8598010d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 95, "deletions": 92, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -25,6 +25,8 @@ use syntax::ast;\n use syntax::codemap::{Span};\n use util::ppaux::Repr;\n \n+use std::gc::Gc;\n+\n ///////////////////////////////////////////////////////////////////////////\n // The Delegate trait\n \n@@ -157,7 +159,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                 ty::ReScope(body.id), // Args live only as long as the fn body.\n                 arg_ty);\n \n-            self.walk_pat(arg_cmt, arg.pat);\n+            self.walk_pat(arg_cmt, arg.pat.clone());\n         }\n     }\n \n@@ -173,9 +175,9 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n \n-    fn consume_exprs(&mut self, exprs: &Vec<@ast::Expr>) {\n-        for &expr in exprs.iter() {\n-            self.consume_expr(expr);\n+    fn consume_exprs(&mut self, exprs: &Vec<Gc<ast::Expr>>) {\n+        for expr in exprs.iter() {\n+            self.consume_expr(&**expr);\n         }\n     }\n \n@@ -186,15 +188,15 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n         self.delegate_consume(expr.id, expr.span, cmt);\n \n         match expr.node {\n-            ast::ExprParen(subexpr) => {\n+            ast::ExprParen(ref subexpr) => {\n                 // Argh but is ExprParen horrible. So, if we consume\n                 // `(x)`, that generally is also consuming `x`, UNLESS\n                 // there are adjustments on the `(x)` expression\n                 // (e.g., autoderefs and autorefs).\n                 if self.typer.adjustments().borrow().contains_key(&expr.id) {\n                     self.walk_expr(expr);\n                 } else {\n-                    self.consume_expr(subexpr);\n+                    self.consume_expr(&**subexpr);\n                 }\n             }\n \n@@ -240,59 +242,59 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n         self.walk_adjustment(expr);\n \n         match expr.node {\n-            ast::ExprParen(subexpr) => {\n-                self.walk_expr(subexpr)\n+            ast::ExprParen(ref subexpr) => {\n+                self.walk_expr(&**subexpr)\n             }\n \n             ast::ExprPath(..) => { }\n \n-            ast::ExprUnary(ast::UnDeref, base) => {      // *base\n-                if !self.walk_overloaded_operator(expr, base, []) {\n-                    self.select_from_expr(base);\n+            ast::ExprUnary(ast::UnDeref, ref base) => {      // *base\n+                if !self.walk_overloaded_operator(expr, &**base, []) {\n+                    self.select_from_expr(&**base);\n                 }\n             }\n \n-            ast::ExprField(base, _, _) => {         // base.f\n-                self.select_from_expr(base);\n+            ast::ExprField(ref base, _, _) => {         // base.f\n+                self.select_from_expr(&**base);\n             }\n \n-            ast::ExprIndex(lhs, rhs) => {           // lhs[rhs]\n-                if !self.walk_overloaded_operator(expr, lhs, [rhs]) {\n-                    self.select_from_expr(lhs);\n-                    self.consume_expr(rhs);\n+            ast::ExprIndex(ref lhs, ref rhs) => {           // lhs[rhs]\n+                if !self.walk_overloaded_operator(expr, &**lhs, [rhs.clone()]) {\n+                    self.select_from_expr(&**lhs);\n+                    self.consume_expr(&**rhs);\n                 }\n             }\n \n-            ast::ExprCall(callee, ref args) => {    // callee(args)\n-                self.walk_callee(expr, callee);\n+            ast::ExprCall(ref callee, ref args) => {    // callee(args)\n+                self.walk_callee(expr, &**callee);\n                 self.consume_exprs(args);\n             }\n \n             ast::ExprMethodCall(_, _, ref args) => { // callee.m(args)\n                 self.consume_exprs(args);\n             }\n \n-            ast::ExprStruct(_, ref fields, opt_with) => {\n-                self.walk_struct_expr(expr, fields, opt_with);\n+            ast::ExprStruct(_, ref fields, ref opt_with) => {\n+                self.walk_struct_expr(expr, fields, opt_with.clone());\n             }\n \n             ast::ExprTup(ref exprs) => {\n                 self.consume_exprs(exprs);\n             }\n \n-            ast::ExprIf(cond_expr, then_blk, opt_else_expr) => {\n-                self.consume_expr(cond_expr);\n-                self.walk_block(then_blk);\n+            ast::ExprIf(ref cond_expr, ref then_blk, ref opt_else_expr) => {\n+                self.consume_expr(&**cond_expr);\n+                self.walk_block(&**then_blk);\n                 for else_expr in opt_else_expr.iter() {\n-                    self.consume_expr(*else_expr);\n+                    self.consume_expr(&**else_expr);\n                 }\n             }\n \n-            ast::ExprMatch(discr, ref arms) => {\n+            ast::ExprMatch(ref discr, ref arms) => {\n                 // treatment of the discriminant is handled while\n                 // walking the arms:\n-                self.walk_expr(discr);\n-                let discr_cmt = return_if_err!(self.mc.cat_expr(discr));\n+                self.walk_expr(&**discr);\n+                let discr_cmt = return_if_err!(self.mc.cat_expr(&**discr));\n                 for arm in arms.iter() {\n                     self.walk_arm(discr_cmt.clone(), arm);\n                 }\n@@ -302,100 +304,100 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                 self.consume_exprs(exprs);\n             }\n \n-            ast::ExprAddrOf(m, base) => {   // &base\n+            ast::ExprAddrOf(m, ref base) => {   // &base\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n                 let expr_ty = ty::expr_ty(self.tcx(), expr);\n                 if !ty::type_is_bot(expr_ty) {\n                     let r = ty::ty_region(self.tcx(), expr.span, expr_ty);\n                     let bk = ty::BorrowKind::from_mutbl(m);\n-                    self.borrow_expr(base, r, bk, AddrOf);\n+                    self.borrow_expr(&**base, r, bk, AddrOf);\n                 } else {\n-                    self.walk_expr(base);\n+                    self.walk_expr(&**base);\n                 }\n             }\n \n             ast::ExprInlineAsm(ref ia) => {\n-                for &(_, input) in ia.inputs.iter() {\n-                    self.consume_expr(input);\n+                for &(_, ref input) in ia.inputs.iter() {\n+                    self.consume_expr(&**input);\n                 }\n \n-                for &(_, output) in ia.outputs.iter() {\n-                    self.mutate_expr(expr, output, JustWrite);\n+                for &(_, ref output) in ia.outputs.iter() {\n+                    self.mutate_expr(expr, &**output, JustWrite);\n                 }\n             }\n \n             ast::ExprBreak(..) |\n             ast::ExprAgain(..) |\n             ast::ExprLit(..) => {}\n \n-            ast::ExprLoop(blk, _) => {\n-                self.walk_block(blk);\n+            ast::ExprLoop(ref blk, _) => {\n+                self.walk_block(&**blk);\n             }\n \n-            ast::ExprWhile(cond_expr, blk) => {\n-                self.consume_expr(cond_expr);\n-                self.walk_block(blk);\n+            ast::ExprWhile(ref cond_expr, ref blk) => {\n+                self.consume_expr(&**cond_expr);\n+                self.walk_block(&**blk);\n             }\n \n             ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n-            ast::ExprUnary(_, lhs) => {\n-                if !self.walk_overloaded_operator(expr, lhs, []) {\n-                    self.consume_expr(lhs);\n+            ast::ExprUnary(_, ref lhs) => {\n+                if !self.walk_overloaded_operator(expr, &**lhs, []) {\n+                    self.consume_expr(&**lhs);\n                 }\n             }\n \n-            ast::ExprBinary(_, lhs, rhs) => {\n-                if !self.walk_overloaded_operator(expr, lhs, [rhs]) {\n-                    self.consume_expr(lhs);\n-                    self.consume_expr(rhs);\n+            ast::ExprBinary(_, ref lhs, ref rhs) => {\n+                if !self.walk_overloaded_operator(expr, &**lhs, [rhs.clone()]) {\n+                    self.consume_expr(&**lhs);\n+                    self.consume_expr(&**rhs);\n                 }\n             }\n \n-            ast::ExprBlock(blk) => {\n-                self.walk_block(blk);\n+            ast::ExprBlock(ref blk) => {\n+                self.walk_block(&**blk);\n             }\n \n             ast::ExprRet(ref opt_expr) => {\n                 for expr in opt_expr.iter() {\n-                    self.consume_expr(*expr);\n+                    self.consume_expr(&**expr);\n                 }\n             }\n \n-            ast::ExprAssign(lhs, rhs) => {\n-                self.mutate_expr(expr, lhs, JustWrite);\n-                self.consume_expr(rhs);\n+            ast::ExprAssign(ref lhs, ref rhs) => {\n+                self.mutate_expr(expr, &**lhs, JustWrite);\n+                self.consume_expr(&**rhs);\n             }\n \n-            ast::ExprCast(base, _) => {\n-                self.consume_expr(base);\n+            ast::ExprCast(ref base, _) => {\n+                self.consume_expr(&**base);\n             }\n \n-            ast::ExprAssignOp(_, lhs, rhs) => {\n+            ast::ExprAssignOp(_, ref lhs, ref rhs) => {\n                 // This will have to change if/when we support\n                 // overloaded operators for `+=` and so forth.\n-                self.mutate_expr(expr, lhs, WriteAndRead);\n-                self.consume_expr(rhs);\n+                self.mutate_expr(expr, &**lhs, WriteAndRead);\n+                self.consume_expr(&**rhs);\n             }\n \n-            ast::ExprRepeat(base, count) => {\n-                self.consume_expr(base);\n-                self.consume_expr(count);\n+            ast::ExprRepeat(ref base, ref count) => {\n+                self.consume_expr(&**base);\n+                self.consume_expr(&**count);\n             }\n \n             ast::ExprFnBlock(..) |\n             ast::ExprProc(..) => {\n                 self.walk_captures(expr)\n             }\n \n-            ast::ExprVstore(base, _) => {\n-                self.consume_expr(base);\n+            ast::ExprVstore(ref base, _) => {\n+                self.consume_expr(&**base);\n             }\n \n-            ast::ExprBox(place, base) => {\n-                self.consume_expr(place);\n-                self.consume_expr(base);\n+            ast::ExprBox(ref place, ref base) => {\n+                self.consume_expr(&**place);\n+                self.consume_expr(&**base);\n             }\n \n             ast::ExprMac(..) => {\n@@ -448,10 +450,10 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n \n     fn walk_stmt(&mut self, stmt: &ast::Stmt) {\n         match stmt.node {\n-            ast::StmtDecl(decl, _) => {\n+            ast::StmtDecl(ref decl, _) => {\n                 match decl.node {\n-                    ast::DeclLocal(local) => {\n-                        self.walk_local(local);\n+                    ast::DeclLocal(ref local) => {\n+                        self.walk_local(local.clone());\n                     }\n \n                     ast::DeclItem(_) => {\n@@ -461,9 +463,9 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                 }\n             }\n \n-            ast::StmtExpr(expr, _) |\n-            ast::StmtSemi(expr, _) => {\n-                self.consume_expr(expr);\n+            ast::StmtExpr(ref expr, _) |\n+            ast::StmtSemi(ref expr, _) => {\n+                self.consume_expr(&**expr);\n             }\n \n             ast::StmtMac(..) => {\n@@ -472,22 +474,23 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n         }\n     }\n \n-    fn walk_local(&mut self, local: @ast::Local) {\n+    fn walk_local(&mut self, local: Gc<ast::Local>) {\n         match local.init {\n             None => {\n                 let delegate = &mut self.delegate;\n-                pat_util::pat_bindings(&self.typer.tcx().def_map, local.pat, |_, id, span, _| {\n+                pat_util::pat_bindings(&self.typer.tcx().def_map, &*local.pat,\n+                                       |_, id, span, _| {\n                     delegate.decl_without_init(id, span);\n                 })\n             }\n \n-            Some(expr) => {\n+            Some(ref expr) => {\n                 // Variable declarations with\n                 // initializers are considered\n                 // \"assigns\", which is handled by\n                 // `walk_pat`:\n-                self.walk_expr(expr);\n-                let init_cmt = return_if_err!(self.mc.cat_expr(expr));\n+                self.walk_expr(&**expr);\n+                let init_cmt = return_if_err!(self.mc.cat_expr(&**expr));\n                 self.walk_pat(init_cmt, local.pat);\n             }\n         }\n@@ -502,29 +505,29 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n         debug!(\"walk_block(blk.id={:?})\", blk.id);\n \n         for stmt in blk.stmts.iter() {\n-            self.walk_stmt(*stmt);\n+            self.walk_stmt(&**stmt);\n         }\n \n         for tail_expr in blk.expr.iter() {\n-            self.consume_expr(*tail_expr);\n+            self.consume_expr(&**tail_expr);\n         }\n     }\n \n     fn walk_struct_expr(&mut self,\n                         _expr: &ast::Expr,\n                         fields: &Vec<ast::Field>,\n-                        opt_with: Option<@ast::Expr>) {\n+                        opt_with: Option<Gc<ast::Expr>>) {\n         // Consume the expressions supplying values for each field.\n         for field in fields.iter() {\n-            self.consume_expr(field.expr);\n+            self.consume_expr(&*field.expr);\n         }\n \n         let with_expr = match opt_with {\n-            Some(w) => { w }\n+            Some(ref w) => { w.clone() }\n             None => { return; }\n         };\n \n-        let with_cmt = return_if_err!(self.mc.cat_expr(with_expr));\n+        let with_cmt = return_if_err!(self.mc.cat_expr(&*with_expr));\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n@@ -542,7 +545,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n         // Consume those fields of the with expression that are needed.\n         for with_field in with_fields.iter() {\n             if !contains_field_named(with_field, fields) {\n-                let cmt_field = self.mc.cat_field(with_expr,\n+                let cmt_field = self.mc.cat_field(&*with_expr,\n                                                   with_cmt.clone(),\n                                                   with_field.ident,\n                                                   with_field.mt.ty);\n@@ -673,7 +676,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n     fn walk_overloaded_operator(&mut self,\n                                 expr: &ast::Expr,\n                                 receiver: &ast::Expr,\n-                                args: &[@ast::Expr])\n+                                args: &[Gc<ast::Expr>])\n                                 -> bool\n     {\n         if !self.typer.is_method_call(expr.id) {\n@@ -689,8 +692,8 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n         let r = ty::ReScope(expr.id);\n         let bk = ty::ImmBorrow;\n \n-        for &arg in args.iter() {\n-            self.borrow_expr(arg, r, bk, OverloadedOperator);\n+        for arg in args.iter() {\n+            self.borrow_expr(&**arg, r, bk, OverloadedOperator);\n         }\n         return true;\n     }\n@@ -701,21 +704,21 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n         }\n \n         for guard in arm.guard.iter() {\n-            self.consume_expr(*guard);\n+            self.consume_expr(&**guard);\n         }\n \n-        self.consume_expr(arm.body);\n+        self.consume_expr(&*arm.body);\n     }\n \n-    fn walk_pat(&mut self, cmt_discr: mc::cmt, pat: @ast::Pat) {\n+    fn walk_pat(&mut self, cmt_discr: mc::cmt, pat: Gc<ast::Pat>) {\n         debug!(\"walk_pat cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n                pat.repr(self.tcx()));\n         let mc = &self.mc;\n         let typer = self.typer;\n         let tcx = typer.tcx();\n         let def_map = &self.typer.tcx().def_map;\n         let delegate = &mut self.delegate;\n-        return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n+        return_if_err!(mc.cat_pattern(cmt_discr, &*pat, |mc, cmt_pat, pat| {\n             if pat_util::pat_is_binding(def_map, pat) {\n                 let tcx = typer.tcx();\n \n@@ -765,7 +768,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                         // matched.\n \n                         let (slice_cmt, slice_mutbl, slice_r) = {\n-                            match mc.cat_slice_pattern(cmt_pat, slice_pat) {\n+                            match mc.cat_slice_pattern(cmt_pat, &*slice_pat) {\n                                 Ok(v) => v,\n                                 Err(()) => {\n                                     tcx.sess.span_bug(slice_pat.span,"}, {"sha": "df6b20b62f590edf5b6b984a4e2b8b7cc2cb05ce", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -155,8 +155,8 @@ fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_t\n fn check_item(cx: &mut Context, item: &Item) {\n     if !attr::contains_name(item.attrs.as_slice(), \"unsafe_destructor\") {\n         match item.node {\n-            ItemImpl(_, Some(ref trait_ref), self_type, _) => {\n-                check_impl_of_trait(cx, item, trait_ref, self_type);\n+            ItemImpl(_, Some(ref trait_ref), ref self_type, _) => {\n+                check_impl_of_trait(cx, item, trait_ref, &**self_type);\n             }\n             _ => {}\n         }\n@@ -292,19 +292,19 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n     }\n \n     match e.node {\n-        ExprUnary(UnBox, interior) => {\n-            let interior_type = ty::expr_ty(cx.tcx, interior);\n+        ExprUnary(UnBox, ref interior) => {\n+            let interior_type = ty::expr_ty(cx.tcx, &**interior);\n             let _ = check_static(cx.tcx, interior_type, interior.span);\n         }\n-        ExprCast(source, _) => {\n-            let source_ty = ty::expr_ty(cx.tcx, source);\n+        ExprCast(ref source, _) => {\n+            let source_ty = ty::expr_ty(cx.tcx, &**source);\n             let target_ty = ty::expr_ty(cx.tcx, e);\n             check_trait_cast(cx, source_ty, target_ty, source.span);\n         }\n-        ExprRepeat(element, count_expr) => {\n-            let count = ty::eval_repeat_count(cx.tcx, count_expr);\n+        ExprRepeat(ref element, ref count_expr) => {\n+            let count = ty::eval_repeat_count(cx.tcx, &**count_expr);\n             if count > 1 {\n-                let element_ty = ty::expr_ty(cx.tcx, element);\n+                let element_ty = ty::expr_ty(cx.tcx, &**element);\n                 check_copy(cx, element_ty, element.span,\n                            \"repeated element will be copied\");\n             }"}, {"sha": "7527477384a0d77b429aecd011dbfe4a49645834", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -57,6 +57,7 @@ use std::i32;\n use std::i64;\n use std::i8;\n use std::rc::Rc;\n+use std::gc::Gc;\n use std::to_str::ToStr;\n use std::u16;\n use std::u32;\n@@ -652,7 +653,7 @@ impl<'a> Context<'a> {\n /// Return true if that's the case. Otherwise return false.\n pub fn each_lint(sess: &session::Session,\n                  attrs: &[ast::Attribute],\n-                 f: |@ast::MetaItem, Level, InternedString| -> bool)\n+                 f: |Gc<ast::MetaItem>, Level, InternedString| -> bool)\n                  -> bool {\n     let xs = [Allow, Warn, Deny, Forbid];\n     for &level in xs.iter() {\n@@ -745,8 +746,8 @@ impl<'a> AstConv for Context<'a>{\n fn check_unused_casts(cx: &Context, e: &ast::Expr) {\n     return match e.node {\n         ast::ExprCast(expr, ty) => {\n-            let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), ty);\n-            if  ty::get(ty::expr_ty(cx.tcx, expr)).sty == ty::get(t_t).sty {\n+            let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), &*ty);\n+            if  ty::get(ty::expr_ty(cx.tcx, &*expr)).sty == ty::get(t_t).sty {\n                 cx.span_lint(UnnecessaryTypecast, ty.span,\n                              \"unnecessary type cast\");\n             }\n@@ -769,7 +770,7 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n                     }\n                 },\n                 _ => {\n-                    let t = ty::expr_ty(cx.tcx, ex);\n+                    let t = ty::expr_ty(cx.tcx, &*ex);\n                     match ty::get(t).sty {\n                         ty::ty_uint(_) => {\n                             cx.span_lint(UnsignedNegate, e.span,\n@@ -781,7 +782,7 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n             }\n         },\n         ast::ExprBinary(binop, l, r) => {\n-            if is_comparison(binop) && !check_limits(cx.tcx, binop, l, r) {\n+            if is_comparison(binop) && !check_limits(cx.tcx, binop, &*l, &*r) {\n                 cx.span_lint(TypeLimits, e.span,\n                              \"comparison is useless due to type limits\");\n             }\n@@ -950,24 +951,24 @@ fn check_item_ctypes(cx: &Context, it: &ast::Item) {\n                     _ => ()\n                 }\n             }\n-            ast::TyPtr(ref mt) => { check_ty(cx, mt.ty) }\n+            ast::TyPtr(ref mt) => { check_ty(cx, &*mt.ty) }\n             _ => {}\n         }\n     }\n \n     fn check_foreign_fn(cx: &Context, decl: &ast::FnDecl) {\n         for input in decl.inputs.iter() {\n-            check_ty(cx, input.ty);\n+            check_ty(cx, &*input.ty);\n         }\n-        check_ty(cx, decl.output)\n+        check_ty(cx, &*decl.output)\n     }\n \n     match it.node {\n       ast::ItemForeignMod(ref nmod) if nmod.abi != abi::RustIntrinsic => {\n         for ni in nmod.items.iter() {\n             match ni.node {\n-                ast::ForeignItemFn(decl, _) => check_foreign_fn(cx, decl),\n-                ast::ForeignItemStatic(t, _) => check_ty(cx, t)\n+                ast::ForeignItemFn(decl, _) => check_foreign_fn(cx, &*decl),\n+                ast::ForeignItemStatic(t, _) => check_ty(cx, &*t)\n             }\n         }\n       }\n@@ -1082,7 +1083,7 @@ fn check_raw_ptr_deriving(cx: &mut Context, item: &ast::Item) {\n     match item.node {\n         ast::ItemStruct(..) | ast::ItemEnum(..) => {\n             let mut visitor = RawPtrDerivingVisitor { cx: cx };\n-            visit::walk_item(&mut visitor, item, ());\n+            visit::walk_item(&mut visitor, &*item, ());\n         }\n         _ => {}\n     }\n@@ -1184,7 +1185,7 @@ fn check_unused_result(cx: &Context, s: &ast::Stmt) {\n         ast::StmtSemi(expr, _) => expr,\n         _ => return\n     };\n-    let t = ty::expr_ty(cx.tcx, expr);\n+    let t = ty::expr_ty(cx.tcx, &*expr);\n     match ty::get(t).sty {\n         ty::ty_nil | ty::ty_bot | ty::ty_bool => return,\n         _ => {}\n@@ -1194,7 +1195,7 @@ fn check_unused_result(cx: &Context, s: &ast::Stmt) {\n         _ => {}\n     }\n \n-    let t = ty::expr_ty(cx.tcx, expr);\n+    let t = ty::expr_ty(cx.tcx, &*expr);\n     let mut warned = false;\n     match ty::get(t).sty {\n         ty::ty_struct(did, _) |\n@@ -1431,7 +1432,7 @@ fn check_unnecessary_parens_expr(cx: &Context, e: &ast::Expr) {\n         ast::ExprAssignOp(_, _, value) => (value, \"assigned value\"),\n         _ => return\n     };\n-    check_unnecessary_parens_core(cx, value, msg);\n+    check_unnecessary_parens_core(cx, &*value, msg);\n }\n \n fn check_unnecessary_parens_stmt(cx: &Context, s: &ast::Stmt) {\n@@ -1445,7 +1446,7 @@ fn check_unnecessary_parens_stmt(cx: &Context, s: &ast::Stmt) {\n         },\n         _ => return\n     };\n-    check_unnecessary_parens_core(cx, value, msg);\n+    check_unnecessary_parens_core(cx, &*value, msg);\n }\n \n fn check_unused_unsafe(cx: &Context, e: &ast::Expr) {\n@@ -1472,12 +1473,12 @@ fn check_unsafe_block(cx: &Context, e: &ast::Expr) {\n     }\n }\n \n-fn check_unused_mut_pat(cx: &Context, pats: &[@ast::Pat]) {\n+fn check_unused_mut_pat(cx: &Context, pats: &[Gc<ast::Pat>]) {\n     // collect all mutable pattern and group their NodeIDs by their Identifier to\n     // avoid false warnings in match arms with multiple patterns\n     let mut mutables = HashMap::new();\n     for &p in pats.iter() {\n-        pat_util::pat_bindings(&cx.tcx.def_map, p, |mode, id, _, path| {\n+        pat_util::pat_bindings(&cx.tcx.def_map, &*p, |mode, id, _, path| {\n             match mode {\n                 ast::BindByValue(ast::MutMutable) => {\n                     if path.segments.len() != 1 {"}, {"sha": "69677554421d4ec24ef70df4e0cb8bf11afb6233", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 88, "deletions": 87, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -110,9 +110,10 @@ use middle::pat_util;\n use middle::ty;\n use util::nodemap::NodeMap;\n \n-use std::mem::transmute;\n use std::fmt;\n+use std::gc::Gc;\n use std::io;\n+use std::mem::transmute;\n use std::rc::Rc;\n use std::str;\n use std::uint;\n@@ -364,7 +365,7 @@ fn visit_fn(ir: &mut IrMaps,\n \n     for arg in decl.inputs.iter() {\n         pat_util::pat_bindings(&ir.tcx.def_map,\n-                               arg.pat,\n+                               &*arg.pat,\n                                |_bm, arg_id, _x, path| {\n             debug!(\"adding argument {}\", arg_id);\n             let ident = ast_util::path_to_ident(path);\n@@ -397,7 +398,7 @@ fn visit_fn(ir: &mut IrMaps,\n }\n \n fn visit_local(ir: &mut IrMaps, local: &Local) {\n-    pat_util::pat_bindings(&ir.tcx.def_map, local.pat, |_, p_id, sp, path| {\n+    pat_util::pat_bindings(&ir.tcx.def_map, &*local.pat, |_, p_id, sp, path| {\n         debug!(\"adding local variable {}\", p_id);\n         let name = ast_util::path_to_ident(path);\n         ir.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -411,7 +412,7 @@ fn visit_local(ir: &mut IrMaps, local: &Local) {\n \n fn visit_arm(ir: &mut IrMaps, arm: &Arm) {\n     for pat in arm.pats.iter() {\n-        pat_util::pat_bindings(&ir.tcx.def_map, *pat, |bm, p_id, sp, path| {\n+        pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n             let name = ast_util::path_to_ident(path);\n@@ -588,22 +589,22 @@ impl<'a> Liveness<'a> {\n     }\n \n     fn arm_pats_bindings(&mut self,\n-                         pats: &[@Pat],\n+                         pats: &[Gc<Pat>],\n                          f: |&mut Liveness<'a>, LiveNode, Variable, Span, NodeId|) {\n         // only consider the first pattern; any later patterns must have\n         // the same bindings, and we also consider the first pattern to be\n         // the \"authoritative\" set of ids\n         if !pats.is_empty() {\n-            self.pat_bindings(pats[0], f)\n+            self.pat_bindings(&*pats[0], f)\n         }\n     }\n \n-    fn define_bindings_in_pat(&mut self, pat: @Pat, succ: LiveNode)\n+    fn define_bindings_in_pat(&mut self, pat: Gc<Pat>, succ: LiveNode)\n                               -> LiveNode {\n         self.define_bindings_in_arm_pats([pat], succ)\n     }\n \n-    fn define_bindings_in_arm_pats(&mut self, pats: &[@Pat], succ: LiveNode)\n+    fn define_bindings_in_arm_pats(&mut self, pats: &[Gc<Pat>], succ: LiveNode)\n                                    -> LiveNode {\n         let mut succ = succ;\n         self.arm_pats_bindings(pats, |this, ln, var, _sp, _id| {\n@@ -858,19 +859,19 @@ impl<'a> Liveness<'a> {\n                                -> LiveNode {\n         let succ = self.propagate_through_opt_expr(blk.expr, succ);\n         blk.stmts.iter().rev().fold(succ, |succ, stmt| {\n-            self.propagate_through_stmt(*stmt, succ)\n+            self.propagate_through_stmt(&**stmt, succ)\n         })\n     }\n \n     fn propagate_through_stmt(&mut self, stmt: &Stmt, succ: LiveNode)\n                               -> LiveNode {\n         match stmt.node {\n-            StmtDecl(decl, _) => {\n-                self.propagate_through_decl(decl, succ)\n+            StmtDecl(ref decl, _) => {\n+                self.propagate_through_decl(&**decl, succ)\n             }\n \n-            StmtExpr(expr, _) | StmtSemi(expr, _) => {\n-                self.propagate_through_expr(expr, succ)\n+            StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => {\n+                self.propagate_through_expr(&**expr, succ)\n             }\n \n             StmtMac(..) => {\n@@ -883,7 +884,7 @@ impl<'a> Liveness<'a> {\n                               -> LiveNode {\n         match decl.node {\n             DeclLocal(ref local) => {\n-                self.propagate_through_local(*local, succ)\n+                self.propagate_through_local(&**local, succ)\n             }\n             DeclItem(_) => succ,\n         }\n@@ -909,19 +910,19 @@ impl<'a> Liveness<'a> {\n         self.define_bindings_in_pat(local.pat, succ)\n     }\n \n-    fn propagate_through_exprs(&mut self, exprs: &[@Expr], succ: LiveNode)\n+    fn propagate_through_exprs(&mut self, exprs: &[Gc<Expr>], succ: LiveNode)\n                                -> LiveNode {\n         exprs.iter().rev().fold(succ, |succ, expr| {\n-            self.propagate_through_expr(*expr, succ)\n+            self.propagate_through_expr(&**expr, succ)\n         })\n     }\n \n     fn propagate_through_opt_expr(&mut self,\n-                                  opt_expr: Option<@Expr>,\n+                                  opt_expr: Option<Gc<Expr>>,\n                                   succ: LiveNode)\n                                   -> LiveNode {\n         opt_expr.iter().fold(succ, |succ, expr| {\n-            self.propagate_through_expr(*expr, succ)\n+            self.propagate_through_expr(&**expr, succ)\n         })\n     }\n \n@@ -936,11 +937,11 @@ impl<'a> Liveness<'a> {\n               self.access_path(expr, succ, ACC_READ | ACC_USE)\n           }\n \n-          ExprField(e, _, _) => {\n-              self.propagate_through_expr(e, succ)\n+          ExprField(ref e, _, _) => {\n+              self.propagate_through_expr(&**e, succ)\n           }\n \n-          ExprFnBlock(_, blk) | ExprProc(_, blk) => {\n+          ExprFnBlock(_, ref blk) | ExprProc(_, ref blk) => {\n               debug!(\"{} is an ExprFnBlock or ExprProc\", expr_to_str(expr));\n \n               /*\n@@ -967,7 +968,7 @@ impl<'a> Liveness<'a> {\n               })\n           }\n \n-          ExprIf(cond, then, els) => {\n+          ExprIf(ref cond, ref then, ref els) => {\n             //\n             //     (cond)\n             //       |\n@@ -981,27 +982,27 @@ impl<'a> Liveness<'a> {\n             //    v     v\n             //   (  succ  )\n             //\n-            let else_ln = self.propagate_through_opt_expr(els, succ);\n-            let then_ln = self.propagate_through_block(then, succ);\n+            let else_ln = self.propagate_through_opt_expr(els.clone(), succ);\n+            let then_ln = self.propagate_through_block(&**then, succ);\n             let ln = self.live_node(expr.id, expr.span);\n             self.init_from_succ(ln, else_ln);\n             self.merge_from_succ(ln, then_ln, false);\n-            self.propagate_through_expr(cond, ln)\n+            self.propagate_through_expr(&**cond, ln)\n           }\n \n-          ExprWhile(cond, blk) => {\n-            self.propagate_through_loop(expr, Some(cond), blk, succ)\n+          ExprWhile(ref cond, ref blk) => {\n+            self.propagate_through_loop(expr, Some(cond.clone()), &**blk, succ)\n           }\n \n           ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n-          ExprLoop(blk, _) => {\n-            self.propagate_through_loop(expr, None, blk, succ)\n+          ExprLoop(ref blk, _) => {\n+            self.propagate_through_loop(expr, None, &**blk, succ)\n           }\n \n-          ExprMatch(e, ref arms) => {\n+          ExprMatch(ref e, ref arms) => {\n             //\n             //      (e)\n             //       |\n@@ -1021,7 +1022,7 @@ impl<'a> Liveness<'a> {\n             let mut first_merge = true;\n             for arm in arms.iter() {\n                 let body_succ =\n-                    self.propagate_through_expr(arm.body, succ);\n+                    self.propagate_through_expr(&*arm.body, succ);\n                 let guard_succ =\n                     self.propagate_through_opt_expr(arm.guard, body_succ);\n                 let arm_succ =\n@@ -1030,7 +1031,7 @@ impl<'a> Liveness<'a> {\n                 self.merge_from_succ(ln, arm_succ, first_merge);\n                 first_merge = false;\n             };\n-            self.propagate_through_expr(e, ln)\n+            self.propagate_through_expr(&**e, ln)\n           }\n \n           ExprRet(o_e) => {\n@@ -1066,49 +1067,49 @@ impl<'a> Liveness<'a> {\n               }\n           }\n \n-          ExprAssign(l, r) => {\n+          ExprAssign(ref l, ref r) => {\n             // see comment on lvalues in\n             // propagate_through_lvalue_components()\n-            let succ = self.write_lvalue(l, succ, ACC_WRITE);\n-            let succ = self.propagate_through_lvalue_components(l, succ);\n-            self.propagate_through_expr(r, succ)\n+            let succ = self.write_lvalue(&**l, succ, ACC_WRITE);\n+            let succ = self.propagate_through_lvalue_components(&**l, succ);\n+            self.propagate_through_expr(&**r, succ)\n           }\n \n-          ExprAssignOp(_, l, r) => {\n+          ExprAssignOp(_, ref l, ref r) => {\n             // see comment on lvalues in\n             // propagate_through_lvalue_components()\n-            let succ = self.write_lvalue(l, succ, ACC_WRITE|ACC_READ);\n-            let succ = self.propagate_through_expr(r, succ);\n-            self.propagate_through_lvalue_components(l, succ)\n+            let succ = self.write_lvalue(&**l, succ, ACC_WRITE|ACC_READ);\n+            let succ = self.propagate_through_expr(&**r, succ);\n+            self.propagate_through_lvalue_components(&**l, succ)\n           }\n \n           // Uninteresting cases: just propagate in rev exec order\n \n-          ExprVstore(expr, _) => {\n-            self.propagate_through_expr(expr, succ)\n+          ExprVstore(ref expr, _) => {\n+            self.propagate_through_expr(&**expr, succ)\n           }\n \n           ExprVec(ref exprs) => {\n             self.propagate_through_exprs(exprs.as_slice(), succ)\n           }\n \n-          ExprRepeat(element, count) => {\n-            let succ = self.propagate_through_expr(count, succ);\n-            self.propagate_through_expr(element, succ)\n+          ExprRepeat(ref element, ref count) => {\n+            let succ = self.propagate_through_expr(&**count, succ);\n+            self.propagate_through_expr(&**element, succ)\n           }\n \n-          ExprStruct(_, ref fields, with_expr) => {\n-            let succ = self.propagate_through_opt_expr(with_expr, succ);\n+          ExprStruct(_, ref fields, ref with_expr) => {\n+            let succ = self.propagate_through_opt_expr(with_expr.clone(), succ);\n             fields.iter().rev().fold(succ, |succ, field| {\n-                self.propagate_through_expr(field.expr, succ)\n+                self.propagate_through_expr(&*field.expr, succ)\n             })\n           }\n \n-          ExprCall(f, ref args) => {\n+          ExprCall(ref f, ref args) => {\n             // calling a fn with bot return type means that the fn\n             // will fail, and hence the successors can be ignored\n             let is_bot = !self.ir.tcx.is_method_call(expr.id) && {\n-                let t_ret = ty::ty_fn_ret(ty::expr_ty(self.ir.tcx, f));\n+                let t_ret = ty::ty_fn_ret(ty::expr_ty(self.ir.tcx, &**f));\n                 ty::type_is_bot(t_ret)\n             };\n             let succ = if is_bot {\n@@ -1117,7 +1118,7 @@ impl<'a> Liveness<'a> {\n                 succ\n             };\n             let succ = self.propagate_through_exprs(args.as_slice(), succ);\n-            self.propagate_through_expr(f, succ)\n+            self.propagate_through_expr(&**f, succ)\n           }\n \n           ExprMethodCall(_, _, ref args) => {\n@@ -1133,48 +1134,48 @@ impl<'a> Liveness<'a> {\n             self.propagate_through_exprs(exprs.as_slice(), succ)\n           }\n \n-          ExprBinary(op, l, r) if ast_util::lazy_binop(op) => {\n-            let r_succ = self.propagate_through_expr(r, succ);\n+          ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {\n+            let r_succ = self.propagate_through_expr(&**r, succ);\n \n             let ln = self.live_node(expr.id, expr.span);\n             self.init_from_succ(ln, succ);\n             self.merge_from_succ(ln, r_succ, false);\n \n-            self.propagate_through_expr(l, ln)\n+            self.propagate_through_expr(&**l, ln)\n           }\n \n-          ExprIndex(l, r) |\n-          ExprBinary(_, l, r) |\n-          ExprBox(l, r) => {\n-            self.propagate_through_exprs([l, r], succ)\n+          ExprIndex(ref l, ref r) |\n+          ExprBinary(_, ref l, ref r) |\n+          ExprBox(ref l, ref r) => {\n+            self.propagate_through_exprs([l.clone(), r.clone()], succ)\n           }\n \n-          ExprAddrOf(_, e) |\n-          ExprCast(e, _) |\n-          ExprUnary(_, e) |\n-          ExprParen(e) => {\n-            self.propagate_through_expr(e, succ)\n+          ExprAddrOf(_, ref e) |\n+          ExprCast(ref e, _) |\n+          ExprUnary(_, ref e) |\n+          ExprParen(ref e) => {\n+            self.propagate_through_expr(&**e, succ)\n           }\n \n           ExprInlineAsm(ref ia) => {\n-            let succ = ia.outputs.iter().rev().fold(succ, |succ, &(_, expr)| {\n+            let succ = ia.outputs.iter().rev().fold(succ, |succ, &(_, ref expr)| {\n                 // see comment on lvalues in\n                 // propagate_through_lvalue_components()\n-                let succ = self.write_lvalue(expr, succ, ACC_WRITE);\n-                self.propagate_through_lvalue_components(expr, succ)\n+                let succ = self.write_lvalue(&**expr, succ, ACC_WRITE);\n+                self.propagate_through_lvalue_components(&**expr, succ)\n             });\n             // Inputs are executed first. Propagate last because of rev order\n-            ia.inputs.iter().rev().fold(succ, |succ, &(_, expr)| {\n-                self.propagate_through_expr(expr, succ)\n+            ia.inputs.iter().rev().fold(succ, |succ, &(_, ref expr)| {\n+                self.propagate_through_expr(&**expr, succ)\n             })\n           }\n \n           ExprLit(..) => {\n             succ\n           }\n \n-          ExprBlock(blk) => {\n-            self.propagate_through_block(blk, succ)\n+          ExprBlock(ref blk) => {\n+            self.propagate_through_block(&**blk, succ)\n           }\n \n           ExprMac(..) => {\n@@ -1238,7 +1239,7 @@ impl<'a> Liveness<'a> {\n \n         match expr.node {\n             ExprPath(_) => succ,\n-            ExprField(e, _, _) => self.propagate_through_expr(e, succ),\n+            ExprField(ref e, _, _) => self.propagate_through_expr(&**e, succ),\n             _ => self.propagate_through_expr(expr, succ)\n         }\n     }\n@@ -1276,7 +1277,7 @@ impl<'a> Liveness<'a> {\n \n     fn propagate_through_loop(&mut self,\n                               expr: &Expr,\n-                              cond: Option<@Expr>,\n+                              cond: Option<Gc<Expr>>,\n                               body: &Block,\n                               succ: LiveNode)\n                               -> LiveNode {\n@@ -1353,10 +1354,10 @@ impl<'a> Liveness<'a> {\n fn check_local(this: &mut Liveness, local: &Local) {\n     match local.init {\n         Some(_) => {\n-            this.warn_about_unused_or_dead_vars_in_pat(local.pat);\n+            this.warn_about_unused_or_dead_vars_in_pat(&*local.pat);\n         },\n         None => {\n-            this.pat_bindings(local.pat, |this, ln, var, sp, id| {\n+            this.pat_bindings(&*local.pat, |this, ln, var, sp, id| {\n                 this.warn_about_unused(sp, id, ln, var);\n             })\n         }\n@@ -1374,28 +1375,28 @@ fn check_arm(this: &mut Liveness, arm: &Arm) {\n \n fn check_expr(this: &mut Liveness, expr: &Expr) {\n     match expr.node {\n-      ExprAssign(l, r) => {\n-        this.check_lvalue(l);\n-        this.visit_expr(r, ());\n+      ExprAssign(ref l, ref r) => {\n+        this.check_lvalue(&**l);\n+        this.visit_expr(&**r, ());\n \n         visit::walk_expr(this, expr, ());\n       }\n \n-      ExprAssignOp(_, l, _) => {\n-        this.check_lvalue(l);\n+      ExprAssignOp(_, ref l, _) => {\n+        this.check_lvalue(&**l);\n \n         visit::walk_expr(this, expr, ());\n       }\n \n       ExprInlineAsm(ref ia) => {\n-        for &(_, input) in ia.inputs.iter() {\n-          this.visit_expr(input, ());\n+        for &(_, ref input) in ia.inputs.iter() {\n+          this.visit_expr(&**input, ());\n         }\n \n         // Output operands must be lvalues\n-        for &(_, out) in ia.outputs.iter() {\n-          this.check_lvalue(out);\n-          this.visit_expr(out, ());\n+        for &(_, ref out) in ia.outputs.iter() {\n+          this.check_lvalue(&**out);\n+          this.visit_expr(&**out, ());\n         }\n \n         visit::walk_expr(this, expr, ());\n@@ -1448,8 +1449,8 @@ impl<'a> Liveness<'a> {\n                 let ends_with_stmt = match body.expr {\n                     None if body.stmts.len() > 0 =>\n                         match body.stmts.last().unwrap().node {\n-                            StmtSemi(e, _) => {\n-                                let t_stmt = ty::expr_ty(self.ir.tcx, e);\n+                            StmtSemi(ref e, _) => {\n+                                let t_stmt = ty::expr_ty(self.ir.tcx, &**e);\n                                 ty::get(t_stmt).sty == ty::get(t_ret).sty\n                             },\n                             _ => false\n@@ -1519,7 +1520,7 @@ impl<'a> Liveness<'a> {\n     fn warn_about_unused_args(&self, decl: &FnDecl, entry_ln: LiveNode) {\n         for arg in decl.inputs.iter() {\n             pat_util::pat_bindings(&self.ir.tcx.def_map,\n-                                   arg.pat,\n+                                   &*arg.pat,\n                                    |_bm, p_id, sp, path| {\n                 let var = self.variable(p_id, sp);\n                 // Ignore unused self."}, {"sha": "dd58f4855db9a755bb787ccc5248e1522aa586e3", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -440,22 +440,22 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n \n         let expr_ty = if_ok!(self.expr_ty(expr));\n         match expr.node {\n-          ast::ExprUnary(ast::UnDeref, e_base) => {\n-            let base_cmt = if_ok!(self.cat_expr(e_base));\n+          ast::ExprUnary(ast::UnDeref, ref e_base) => {\n+            let base_cmt = if_ok!(self.cat_expr(&**e_base));\n             Ok(self.cat_deref(expr, base_cmt, 0))\n           }\n \n-          ast::ExprField(base, f_name, _) => {\n-            let base_cmt = if_ok!(self.cat_expr(base));\n+          ast::ExprField(ref base, f_name, _) => {\n+            let base_cmt = if_ok!(self.cat_expr(&**base));\n             Ok(self.cat_field(expr, base_cmt, f_name, expr_ty))\n           }\n \n-          ast::ExprIndex(base, _) => {\n+          ast::ExprIndex(ref base, _) => {\n             if self.typer.is_method_call(expr.id) {\n                 return Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty));\n             }\n \n-            let base_cmt = if_ok!(self.cat_expr(base));\n+            let base_cmt = if_ok!(self.cat_expr(&**base));\n             Ok(self.cat_index(expr, base_cmt, 0))\n           }\n \n@@ -464,8 +464,8 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n-          ast::ExprParen(e) => {\n-            self.cat_expr(e)\n+          ast::ExprParen(ref e) => {\n+            self.cat_expr(&**e)\n           }\n \n           ast::ExprAddrOf(..) | ast::ExprCall(..) |\n@@ -999,31 +999,32 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                         }\n                     };\n \n-                    for (i, &subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = if_ok!(self.pat_ty(subpat)); // see (*2)\n+                    for (i, subpat) in subpats.iter().enumerate() {\n+                        let subpat_ty = if_ok!(self.pat_ty(&**subpat)); // see (*2)\n \n                         let subcmt =\n                             self.cat_imm_interior(\n                                 pat, downcast_cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n \n-                        if_ok!(self.cat_pattern(subcmt, subpat, |x,y,z| op(x,y,z)));\n+                        if_ok!(self.cat_pattern(subcmt, &**subpat, |x,y,z| op(x,y,z)));\n                     }\n                 }\n                 Some(&def::DefFn(..)) |\n                 Some(&def::DefStruct(..)) => {\n-                    for (i, &subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = if_ok!(self.pat_ty(subpat)); // see (*2)\n+                    for (i, subpat) in subpats.iter().enumerate() {\n+                        let subpat_ty = if_ok!(self.pat_ty(&**subpat)); // see (*2)\n                         let cmt_field =\n                             self.cat_imm_interior(\n                                 pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n-                        if_ok!(self.cat_pattern(cmt_field, subpat, |x,y,z| op(x,y,z)));\n+                        if_ok!(self.cat_pattern(cmt_field, &**subpat,\n+                                                |x,y,z| op(x,y,z)));\n                     }\n                 }\n                 Some(&def::DefStatic(..)) => {\n-                    for &subpat in subpats.iter() {\n-                        if_ok!(self.cat_pattern(cmt.clone(), subpat, |x,y,z| op(x,y,z)));\n+                    for subpat in subpats.iter() {\n+                        if_ok!(self.cat_pattern(cmt.clone(), &**subpat, |x,y,z| op(x,y,z)));\n                     }\n                 }\n                 _ => {\n@@ -1034,8 +1035,8 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n             }\n           }\n \n-          ast::PatIdent(_, _, Some(subpat)) => {\n-              if_ok!(self.cat_pattern(cmt, subpat, op));\n+          ast::PatIdent(_, _, Some(ref subpat)) => {\n+              if_ok!(self.cat_pattern(cmt, &**subpat, op));\n           }\n \n           ast::PatIdent(_, _, None) => {\n@@ -1045,42 +1046,43 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n           ast::PatStruct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for fp in field_pats.iter() {\n-                let field_ty = if_ok!(self.pat_ty(fp.pat)); // see (*2)\n+                let field_ty = if_ok!(self.pat_ty(&*fp.pat)); // see (*2)\n                 let cmt_field = self.cat_field(pat, cmt.clone(), fp.ident, field_ty);\n-                if_ok!(self.cat_pattern(cmt_field, fp.pat, |x,y,z| op(x,y,z)));\n+                if_ok!(self.cat_pattern(cmt_field, &*fp.pat, |x,y,z| op(x,y,z)));\n             }\n           }\n \n           ast::PatTup(ref subpats) => {\n             // (p1, ..., pN)\n-            for (i, &subpat) in subpats.iter().enumerate() {\n-                let subpat_ty = if_ok!(self.pat_ty(subpat)); // see (*2)\n+            for (i, subpat) in subpats.iter().enumerate() {\n+                let subpat_ty = if_ok!(self.pat_ty(&**subpat)); // see (*2)\n                 let subcmt =\n                     self.cat_imm_interior(\n                         pat, cmt.clone(), subpat_ty,\n                         InteriorField(PositionalField(i)));\n-                if_ok!(self.cat_pattern(subcmt, subpat, |x,y,z| op(x,y,z)));\n+                if_ok!(self.cat_pattern(subcmt, &**subpat, |x,y,z| op(x,y,z)));\n             }\n           }\n \n-          ast::PatBox(subpat) | ast::PatRegion(subpat) => {\n+          ast::PatBox(ref subpat) | ast::PatRegion(ref subpat) => {\n             // @p1, ~p1\n             let subcmt = self.cat_deref(pat, cmt, 0);\n-            if_ok!(self.cat_pattern(subcmt, subpat, op));\n+            if_ok!(self.cat_pattern(subcmt, &**subpat, op));\n           }\n \n           ast::PatVec(ref before, slice, ref after) => {\n               let elt_cmt = self.cat_index(pat, cmt, 0);\n-              for &before_pat in before.iter() {\n-                  if_ok!(self.cat_pattern(elt_cmt.clone(), before_pat, |x,y,z| op(x,y,z)));\n+              for before_pat in before.iter() {\n+                  if_ok!(self.cat_pattern(elt_cmt.clone(), &**before_pat,\n+                                          |x,y,z| op(x,y,z)));\n               }\n-              for &slice_pat in slice.iter() {\n-                  let slice_ty = if_ok!(self.pat_ty(slice_pat));\n+              for slice_pat in slice.iter() {\n+                  let slice_ty = if_ok!(self.pat_ty(&**slice_pat));\n                   let slice_cmt = self.cat_rvalue_node(pat.id(), pat.span(), slice_ty);\n-                  if_ok!(self.cat_pattern(slice_cmt, slice_pat, |x,y,z| op(x,y,z)));\n+                  if_ok!(self.cat_pattern(slice_cmt, &**slice_pat, |x,y,z| op(x,y,z)));\n               }\n-              for &after_pat in after.iter() {\n-                  if_ok!(self.cat_pattern(elt_cmt.clone(), after_pat, |x,y,z| op(x,y,z)));\n+              for after_pat in after.iter() {\n+                  if_ok!(self.cat_pattern(elt_cmt.clone(), &**after_pat, |x,y,z| op(x,y,z)));\n               }\n           }\n "}, {"sha": "9ff962158692bcc339475459c3fd0b53fcc436fa", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -12,6 +12,7 @@\n //! outside their scopes. This pass will also generate a set of exported items\n //! which are available for use externally when compiled as a library.\n \n+use std::gc::Gc;\n use std::mem::replace;\n \n use metadata::csearch;\n@@ -797,8 +798,8 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n \n     fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n         match expr.node {\n-            ast::ExprField(base, ident, _) => {\n-                match ty::get(ty::expr_ty_adjusted(self.tcx, base)).sty {\n+            ast::ExprField(ref base, ident, _) => {\n+                match ty::get(ty::expr_ty_adjusted(self.tcx, &**base)).sty {\n                     ty::ty_struct(id, _) => {\n                         self.check_field(expr.span, id, NamedField(ident));\n                     }\n@@ -1134,7 +1135,7 @@ impl<'a> SanePrivacyVisitor<'a> {\n                 tcx.sess.span_err(sp, \"visibility has no effect inside functions\");\n             }\n         }\n-        let check_struct = |def: &@ast::StructDef| {\n+        let check_struct = |def: &Gc<ast::StructDef>| {\n             for f in def.fields.iter() {\n                match f.node.kind {\n                     ast::NamedField(_, p) => check_inherited(tcx, f.span, p),\n@@ -1281,7 +1282,7 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n                         at_outer_type: true,\n                         outer_type_is_public_path: false,\n                     };\n-                    visitor.visit_ty(self_, ());\n+                    visitor.visit_ty(&*self_, ());\n                     self_contains_private = visitor.contains_private;\n                     self_is_public_path = visitor.outer_type_is_public_path;\n                 }\n@@ -1318,7 +1319,7 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n                     match *trait_ref {\n                         None => {\n                             for method in methods.iter() {\n-                                visit::walk_method_helper(self, *method, ())\n+                                visit::walk_method_helper(self, &**method, ())\n                             }\n                         }\n                         Some(ref tr) => {\n@@ -1345,7 +1346,7 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n                         if method.explicit_self.node == ast::SelfStatic &&\n                             self.exported_items.contains(&method.id) {\n                             found_pub_static = true;\n-                            visit::walk_method_helper(self, *method, ());\n+                            visit::walk_method_helper(self, &**method, ());\n                         }\n                     }\n                     if found_pub_static {"}, {"sha": "d9b5dff3bb0ceb47328f724ec02ee3c03beb5739", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -70,7 +70,7 @@ fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n         {\n             match tcx.map.find(impl_src.node) {\n                 Some(ast_map::NodeItem(item)) => {\n-                    item_might_be_inlined(item)\n+                    item_might_be_inlined(&*item)\n                 }\n                 Some(..) | None => {\n                     tcx.sess.span_bug(method.span, \"impl did is not an item\")\n@@ -184,7 +184,7 @@ impl<'a> ReachableContext<'a> {\n         match self.tcx.map.find(node_id) {\n             Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n-                    ast::ItemFn(..) => item_might_be_inlined(item),\n+                    ast::ItemFn(..) => item_might_be_inlined(&*item),\n                     _ => false,\n                 }\n             }\n@@ -273,20 +273,20 @@ impl<'a> ReachableContext<'a> {\n         match *node {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n-                    ast::ItemFn(_, _, _, _, search_block) => {\n-                        if item_might_be_inlined(item) {\n-                            visit::walk_block(self, search_block, ())\n+                    ast::ItemFn(_, _, _, _, ref search_block) => {\n+                        if item_might_be_inlined(&*item) {\n+                            visit::walk_block(self, &**search_block, ())\n                         }\n                     }\n \n                     // Statics with insignificant addresses are not reachable\n                     // because they're inlined specially into all other crates.\n-                    ast::ItemStatic(_, _, init) => {\n+                    ast::ItemStatic(_, _, ref init) => {\n                         if attr::contains_name(item.attrs.as_slice(),\n                                                \"address_insignificant\") {\n                             self.reachable_symbols.remove(&search_item);\n                         }\n-                        visit::walk_expr(self, init, ());\n+                        visit::walk_expr(self, &**init, ());\n                     }\n \n                     // These are normal, nothing reachable about these\n@@ -310,14 +310,14 @@ impl<'a> ReachableContext<'a> {\n                         // Keep going, nothing to get exported\n                     }\n                     ast::Provided(ref method) => {\n-                        visit::walk_block(self, method.body, ())\n+                        visit::walk_block(self, &*method.body, ())\n                     }\n                 }\n             }\n             ast_map::NodeMethod(method) => {\n                 let did = self.tcx.map.get_parent_did(search_item);\n-                if method_might_be_inlined(self.tcx, method, did) {\n-                    visit::walk_block(self, method.body, ())\n+                if method_might_be_inlined(self.tcx, &*method, did) {\n+                    visit::walk_block(self, &*method.body, ())\n                 }\n             }\n             // Nothing to recurse on for these"}, {"sha": "3b59736e292b51c2b4681367cb1fa660b931906f", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -28,6 +28,7 @@ use util::nodemap::NodeMap;\n \n use std::cell::RefCell;\n use std::collections::{HashMap, HashSet};\n+use std::gc::Gc;\n use syntax::codemap::Span;\n use syntax::{ast, visit};\n use syntax::visit::{Visitor, FnKind};\n@@ -628,11 +629,11 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor,\n     // FIXME(#6308) -- Note that `[]` patterns work more smoothly post-DST.\n \n     match local.init {\n-        Some(expr) => {\n-            record_rvalue_scope_if_borrow_expr(visitor, expr, blk_id);\n+        Some(ref expr) => {\n+            record_rvalue_scope_if_borrow_expr(visitor, &**expr, blk_id);\n \n-            if is_binding_pat(local.pat) || is_borrowed_ty(local.ty) {\n-                record_rvalue_scope(visitor, expr, blk_id);\n+            if is_binding_pat(&*local.pat) || is_borrowed_ty(&*local.ty) {\n+                record_rvalue_scope(visitor, &**expr, blk_id);\n             }\n         }\n \n@@ -657,22 +658,22 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor,\n             ast::PatIdent(ast::BindByRef(_), _, _) => true,\n \n             ast::PatStruct(_, ref field_pats, _) => {\n-                field_pats.iter().any(|fp| is_binding_pat(fp.pat))\n+                field_pats.iter().any(|fp| is_binding_pat(&*fp.pat))\n             }\n \n             ast::PatVec(ref pats1, ref pats2, ref pats3) => {\n-                pats1.iter().any(|&p| is_binding_pat(p)) ||\n-                pats2.iter().any(|&p| is_binding_pat(p)) ||\n-                pats3.iter().any(|&p| is_binding_pat(p))\n+                pats1.iter().any(|p| is_binding_pat(&**p)) ||\n+                pats2.iter().any(|p| is_binding_pat(&**p)) ||\n+                pats3.iter().any(|p| is_binding_pat(&**p))\n             }\n \n             ast::PatEnum(_, Some(ref subpats)) |\n             ast::PatTup(ref subpats) => {\n-                subpats.iter().any(|&p| is_binding_pat(p))\n+                subpats.iter().any(|p| is_binding_pat(&**p))\n             }\n \n-            ast::PatBox(subpat) => {\n-                is_binding_pat(subpat)\n+            ast::PatBox(ref subpat) => {\n+                is_binding_pat(&**subpat)\n             }\n \n             _ => false,\n@@ -709,39 +710,39 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor,\n          */\n \n         match expr.node {\n-            ast::ExprAddrOf(_, subexpr) => {\n-                record_rvalue_scope_if_borrow_expr(visitor, subexpr, blk_id);\n-                record_rvalue_scope(visitor, subexpr, blk_id);\n+            ast::ExprAddrOf(_, ref subexpr) => {\n+                record_rvalue_scope_if_borrow_expr(visitor, &**subexpr, blk_id);\n+                record_rvalue_scope(visitor, &**subexpr, blk_id);\n             }\n             ast::ExprStruct(_, ref fields, _) => {\n                 for field in fields.iter() {\n                     record_rvalue_scope_if_borrow_expr(\n-                        visitor, field.expr, blk_id);\n+                        visitor, &*field.expr, blk_id);\n                 }\n             }\n-            ast::ExprVstore(subexpr, _) => {\n+            ast::ExprVstore(ref subexpr, _) => {\n                 visitor.region_maps.record_rvalue_scope(subexpr.id, blk_id);\n-                record_rvalue_scope_if_borrow_expr(visitor, subexpr, blk_id);\n+                record_rvalue_scope_if_borrow_expr(visitor, &**subexpr, blk_id);\n             }\n             ast::ExprVec(ref subexprs) |\n             ast::ExprTup(ref subexprs) => {\n-                for &subexpr in subexprs.iter() {\n+                for subexpr in subexprs.iter() {\n                     record_rvalue_scope_if_borrow_expr(\n-                        visitor, subexpr, blk_id);\n+                        visitor, &**subexpr, blk_id);\n                 }\n             }\n-            ast::ExprUnary(ast::UnUniq, subexpr) => {\n-                record_rvalue_scope_if_borrow_expr(visitor, subexpr, blk_id);\n+            ast::ExprUnary(ast::UnUniq, ref subexpr) => {\n+                record_rvalue_scope_if_borrow_expr(visitor, &**subexpr, blk_id);\n             }\n-            ast::ExprCast(subexpr, _) |\n-            ast::ExprParen(subexpr) => {\n-                record_rvalue_scope_if_borrow_expr(visitor, subexpr, blk_id)\n+            ast::ExprCast(ref subexpr, _) |\n+            ast::ExprParen(ref subexpr) => {\n+                record_rvalue_scope_if_borrow_expr(visitor, &**subexpr, blk_id)\n             }\n             ast::ExprBlock(ref block) => {\n                 match block.expr {\n-                    Some(subexpr) => {\n+                    Some(ref subexpr) => {\n                         record_rvalue_scope_if_borrow_expr(\n-                            visitor, subexpr, blk_id);\n+                            visitor, &**subexpr, blk_id);\n                     }\n                     None => { }\n                 }\n@@ -789,7 +790,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor,\n                 ast::ExprField(ref subexpr, _, _) |\n                 ast::ExprIndex(ref subexpr, _) |\n                 ast::ExprParen(ref subexpr) => {\n-                    let subexpr: &'a @Expr = subexpr; // FIXME(#11586)\n+                    let subexpr: &'a Gc<Expr> = subexpr; // FIXME(#11586)\n                     expr = &**subexpr;\n                 }\n                 _ => {"}, {"sha": "759d2ebb624226f0e7e09e10f3dd1e91270e7d6b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -34,9 +34,9 @@ use syntax::visit::Visitor;\n \n use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n+use std::gc::Gc;\n use std::mem::replace;\n use std::rc::{Rc, Weak};\n-use std::string::String;\n use std::uint;\n \n // Definition mapping\n@@ -1195,9 +1195,9 @@ impl<'a> Resolver<'a> {\n                 name_bindings.define_type\n                     (DefTy(local_def(item.id)), sp, is_public);\n \n-                for &variant in (*enum_definition).variants.iter() {\n+                for variant in (*enum_definition).variants.iter() {\n                     self.build_reduced_graph_for_variant(\n-                        variant,\n+                        &**variant,\n                         local_def(item.id),\n                         parent.clone(),\n                         is_public);\n@@ -3430,7 +3430,7 @@ impl<'a> Resolver<'a> {\n                 FunctionRibKind(function_id, body_id) => {\n                     if !is_ty_param {\n                         def = DefUpvar(def.def_id().node,\n-                                       @def,\n+                                       box(GC) def,\n                                        function_id,\n                                        body_id);\n                     }\n@@ -3565,7 +3565,7 @@ impl<'a> Resolver<'a> {\n                         // resolve the discriminator expr\n                         // as a constant\n                         self.with_constant_rib(|this| {\n-                            this.resolve_expr(*dis_expr);\n+                            this.resolve_expr(&**dis_expr);\n                         });\n                     }\n                 }\n@@ -3593,13 +3593,13 @@ impl<'a> Resolver<'a> {\n             }\n \n             ItemImpl(ref generics,\n-                      ref implemented_traits,\n-                      self_type,\n-                      ref methods) => {\n+                     ref implemented_traits,\n+                     ref self_type,\n+                     ref methods) => {\n                 self.resolve_implementation(item.id,\n                                             generics,\n                                             implemented_traits,\n-                                            self_type,\n+                                            &**self_type,\n                                             methods.as_slice());\n             }\n \n@@ -3647,16 +3647,16 @@ impl<'a> Resolver<'a> {\n                                     &ty_m.generics.ty_params);\n \n                                 for argument in ty_m.decl.inputs.iter() {\n-                                    this.resolve_type(argument.ty);\n+                                    this.resolve_type(&*argument.ty);\n                                 }\n \n-                                this.resolve_type(ty_m.decl.output);\n+                                this.resolve_type(&*ty_m.decl.output);\n                             });\n                           }\n-                          ast::Provided(m) => {\n+                          ast::Provided(ref m) => {\n                               this.resolve_method(MethodRibKind(item.id,\n                                                      Provided(m.id)),\n-                                                  m,\n+                                                  &**m,\n                                                   generics.ty_params.len())\n                           }\n                         }\n@@ -3690,12 +3690,12 @@ impl<'a> Resolver<'a> {\n                                         generics, foreign_item.id, 0,\n                                         ItemRibKind),\n                                     |this| visit::walk_foreign_item(this,\n-                                                                *foreign_item,\n+                                                                &**foreign_item,\n                                                                 ()));\n                             }\n                             ForeignItemStatic(..) => {\n                                 visit::walk_foreign_item(this,\n-                                                         *foreign_item,\n+                                                         &**foreign_item,\n                                                          ());\n                             }\n                         }\n@@ -3812,21 +3812,21 @@ impl<'a> Resolver<'a> {\n                 }\n                 Some(declaration) => {\n                     for argument in declaration.inputs.iter() {\n-                        this.resolve_pattern(argument.pat,\n+                        this.resolve_pattern(&*argument.pat,\n                                              ArgumentIrrefutableMode,\n                                              None);\n \n-                        this.resolve_type(argument.ty);\n+                        this.resolve_type(&*argument.ty);\n \n                         debug!(\"(resolving function) recorded argument\");\n                     }\n \n-                    this.resolve_type(declaration.output);\n+                    this.resolve_type(&*declaration.output);\n                 }\n             }\n \n             // Resolve the function body.\n-            this.resolve_block(block);\n+            this.resolve_block(&*block);\n \n             debug!(\"(resolving function) leaving function\");\n         });\n@@ -3842,7 +3842,7 @@ impl<'a> Resolver<'a> {\n                 self.resolve_type_parameter_bound(type_parameter.id, bound);\n             }\n             match type_parameter.default {\n-                Some(ty) => self.resolve_type(ty),\n+                Some(ref ty) => self.resolve_type(&**ty),\n                 None => {}\n             }\n         }\n@@ -3857,10 +3857,10 @@ impl<'a> Resolver<'a> {\n             }\n             UnboxedFnTyParamBound(ref unboxed_function) => {\n                 for argument in unboxed_function.decl.inputs.iter() {\n-                    self.resolve_type(argument.ty);\n+                    self.resolve_type(&*argument.ty);\n                 }\n \n-                self.resolve_type(unboxed_function.decl.output);\n+                self.resolve_type(&*unboxed_function.decl.output);\n             }\n             StaticRegionTyParamBound | OtherRegionTyParamBound(_) => {}\n         }\n@@ -3938,7 +3938,7 @@ impl<'a> Resolver<'a> {\n \n             // Resolve fields.\n             for field in fields.iter() {\n-                this.resolve_type(field.node.ty);\n+                this.resolve_type(&*field.node.ty);\n             }\n         });\n     }\n@@ -3995,7 +3995,7 @@ impl<'a> Resolver<'a> {\n                                   generics: &Generics,\n                                   opt_trait_reference: &Option<TraitRef>,\n                                   self_type: &Ty,\n-                                  methods: &[@Method]) {\n+                                  methods: &[Gc<Method>]) {\n         // If applicable, create a rib for the type parameters.\n         let outer_type_parameter_count = generics.ty_params.len();\n         self.with_type_parameter_rib(HasTypeParameters(generics,\n@@ -4015,7 +4015,7 @@ impl<'a> Resolver<'a> {\n                     for method in methods.iter() {\n                         // We also need a new scope for the method-specific type parameters.\n                         this.resolve_method(MethodRibKind(id, Provided(method.id)),\n-                                            *method,\n+                                            &**method,\n                                             outer_type_parameter_count);\n                     }\n                 });\n@@ -4032,20 +4032,20 @@ impl<'a> Resolver<'a> {\n \n     fn resolve_local(&mut self, local: &Local) {\n         // Resolve the type.\n-        self.resolve_type(local.ty);\n+        self.resolve_type(&*local.ty);\n \n         // Resolve the initializer, if necessary.\n         match local.init {\n             None => {\n                 // Nothing to do.\n             }\n-            Some(initializer) => {\n-                self.resolve_expr(initializer);\n+            Some(ref initializer) => {\n+                self.resolve_expr(&**initializer);\n             }\n         }\n \n         // Resolve the pattern.\n-        self.resolve_pattern(local.pat, LocalIrrefutableMode, None);\n+        self.resolve_pattern(&*local.pat, LocalIrrefutableMode, None);\n     }\n \n     // build a map from pattern identifiers to binding-info's.\n@@ -4069,9 +4069,9 @@ impl<'a> Resolver<'a> {\n         if arm.pats.len() == 0 {\n             return\n         }\n-        let map_0 = self.binding_mode_map(*arm.pats.get(0));\n+        let map_0 = self.binding_mode_map(&**arm.pats.get(0));\n         for (i, p) in arm.pats.iter().enumerate() {\n-            let map_i = self.binding_mode_map(*p);\n+            let map_i = self.binding_mode_map(&**p);\n \n             for (&key, &binding_0) in map_0.iter() {\n                 match map_i.find(&key) {\n@@ -4114,7 +4114,7 @@ impl<'a> Resolver<'a> {\n \n         let mut bindings_list = HashMap::new();\n         for pattern in arm.pats.iter() {\n-            self.resolve_pattern(*pattern,\n+            self.resolve_pattern(&**pattern,\n                                  RefutableMode,\n                                  Some(&mut bindings_list));\n         }\n@@ -4124,7 +4124,7 @@ impl<'a> Resolver<'a> {\n         self.check_consistent_bindings(arm);\n \n         visit::walk_expr_opt(self, arm.guard, ());\n-        self.resolve_expr(arm.body);\n+        self.resolve_expr(&*arm.body);\n \n         self.value_ribs.borrow_mut().pop();\n     }\n@@ -4392,10 +4392,10 @@ impl<'a> Resolver<'a> {\n                     }\n \n                     // Check the types in the path pattern.\n-                    for &ty in path.segments\n+                    for ty in path.segments\n                                   .iter()\n                                   .flat_map(|seg| seg.types.iter()) {\n-                        self.resolve_type(ty);\n+                        self.resolve_type(&**ty);\n                     }\n                 }\n \n@@ -4430,10 +4430,10 @@ impl<'a> Resolver<'a> {\n                     }\n \n                     // Check the types in the path pattern.\n-                    for &ty in path.segments\n+                    for ty in path.segments\n                                   .iter()\n                                   .flat_map(|s| s.types.iter()) {\n-                        self.resolve_type(ty);\n+                        self.resolve_type(&**ty);\n                     }\n                 }\n \n@@ -4467,20 +4467,20 @@ impl<'a> Resolver<'a> {\n                     }\n \n                     // Check the types in the path pattern.\n-                    for &ty in path.segments\n+                    for ty in path.segments\n                                   .iter()\n                                   .flat_map(|s| s.types.iter()) {\n-                        self.resolve_type(ty);\n+                        self.resolve_type(&**ty);\n                     }\n                 }\n \n-                PatLit(expr) => {\n-                    self.resolve_expr(expr);\n+                PatLit(ref expr) => {\n+                    self.resolve_expr(&**expr);\n                 }\n \n-                PatRange(first_expr, last_expr) => {\n-                    self.resolve_expr(first_expr);\n-                    self.resolve_expr(last_expr);\n+                PatRange(ref first_expr, ref last_expr) => {\n+                    self.resolve_expr(&**first_expr);\n+                    self.resolve_expr(&**last_expr);\n                 }\n \n                 PatStruct(ref path, _, _) => {\n@@ -4571,8 +4571,8 @@ impl<'a> Resolver<'a> {\n                     namespace: Namespace,\n                     check_ribs: bool) -> Option<(Def, LastPrivate)> {\n         // First, resolve the types.\n-        for &ty in path.segments.iter().flat_map(|s| s.types.iter()) {\n-            self.resolve_type(ty);\n+        for ty in path.segments.iter().flat_map(|s| s.types.iter()) {\n+            self.resolve_type(&**ty);\n         }\n \n         if path.global {\n@@ -4919,8 +4919,8 @@ impl<'a> Resolver<'a> {\n                                                     -> Option<(Path, NodeId, FallbackChecks)> {\n             match t.node {\n                 TyPath(ref path, _, node_id) => Some((path.clone(), node_id, allow)),\n-                TyPtr(mut_ty) => extract_path_and_node_id(mut_ty.ty, OnlyTraitAndStatics),\n-                TyRptr(_, mut_ty) => extract_path_and_node_id(mut_ty.ty, allow),\n+                TyPtr(mut_ty) => extract_path_and_node_id(&*mut_ty.ty, OnlyTraitAndStatics),\n+                TyRptr(_, mut_ty) => extract_path_and_node_id(&*mut_ty.ty, allow),\n                 // This doesn't handle the remaining `Ty` variants as they are not\n                 // that commonly the self_type, it might be interesting to provide\n                 // support for those in future."}, {"sha": "4c4b0a1290c4731bf68e6fb79276e5587eb4550e", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -226,6 +226,7 @@ use util::ppaux::{Repr, vec_map_to_str};\n use std::collections::HashMap;\n use std::cell::Cell;\n use std::rc::Rc;\n+use std::gc::Gc;\n use syntax::ast;\n use syntax::ast::Ident;\n use syntax::ast_util::path_to_ident;\n@@ -237,7 +238,7 @@ use syntax::parse::token::InternedString;\n // expression.\n enum Lit {\n     UnitLikeStructLit(ast::NodeId),    // the node ID of the pattern\n-    ExprLit(@ast::Expr),\n+    ExprLit(Gc<ast::Expr>),\n     ConstLit(ast::DefId),              // the def ID of the constant\n }\n \n@@ -252,11 +253,11 @@ pub enum VecLenOpt {\n enum Opt {\n     lit(Lit),\n     var(ty::Disr, Rc<adt::Repr>),\n-    range(@ast::Expr, @ast::Expr),\n+    range(Gc<ast::Expr>, Gc<ast::Expr>),\n     vec_len(/* length */ uint, VecLenOpt, /*range of matches*/(uint, uint))\n }\n \n-fn lit_to_expr(tcx: &ty::ctxt, a: &Lit) -> @ast::Expr {\n+fn lit_to_expr(tcx: &ty::ctxt, a: &Lit) -> Gc<ast::Expr> {\n     match *a {\n         ExprLit(existing_a_expr) => existing_a_expr,\n         ConstLit(a_const) => const_eval::lookup_const_by_id(tcx, a_const).unwrap(),\n@@ -270,14 +271,14 @@ fn opt_eq(tcx: &ty::ctxt, a: &Opt, b: &Opt) -> bool {\n         (&lit(a), &lit(b)) => {\n             let a_expr = lit_to_expr(tcx, &a);\n             let b_expr = lit_to_expr(tcx, &b);\n-            match const_eval::compare_lit_exprs(tcx, a_expr, b_expr) {\n+            match const_eval::compare_lit_exprs(tcx, &*a_expr, &*b_expr) {\n                 Some(val1) => val1 == 0,\n                 None => fail!(\"compare_list_exprs: type mismatch\"),\n             }\n         }\n-        (&range(a1, a2), &range(b1, b2)) => {\n-            let m1 = const_eval::compare_lit_exprs(tcx, a1, b1);\n-            let m2 = const_eval::compare_lit_exprs(tcx, a2, b2);\n+        (&range(ref a1, ref a2), &range(ref b1, ref b2)) => {\n+            let m1 = const_eval::compare_lit_exprs(tcx, &**a1, &**b1);\n+            let m2 = const_eval::compare_lit_exprs(tcx, &**a2, &**b2);\n             match (m1, m2) {\n                 (Some(val1), Some(val2)) => (val1 == 0 && val2 == 0),\n                 _ => fail!(\"compare_list_exprs: type mismatch\"),\n@@ -301,8 +302,8 @@ fn trans_opt<'a>(bcx: &'a Block<'a>, o: &Opt) -> opt_result<'a> {\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n     match *o {\n-        lit(ExprLit(lit_expr)) => {\n-            let lit_datum = unpack_datum!(bcx, expr::trans(bcx, lit_expr));\n+        lit(ExprLit(ref lit_expr)) => {\n+            let lit_datum = unpack_datum!(bcx, expr::trans(bcx, &**lit_expr));\n             let lit_datum = lit_datum.assert_rvalue(bcx); // literals are rvalues\n             let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n             return single_result(Result::new(bcx, lit_datum.val));\n@@ -322,9 +323,9 @@ fn trans_opt<'a>(bcx: &'a Block<'a>, o: &Opt) -> opt_result<'a> {\n         var(disr_val, ref repr) => {\n             return adt::trans_case(bcx, &**repr, disr_val);\n         }\n-        range(l1, l2) => {\n-            let (l1, _) = consts::const_expr(ccx, l1, true);\n-            let (l2, _) = consts::const_expr(ccx, l2, true);\n+        range(ref l1, ref l2) => {\n+            let (l1, _) = consts::const_expr(ccx, &**l1, true);\n+            let (l2, _) = consts::const_expr(ccx, &**l2, true);\n             return range_result(Result::new(bcx, l1), Result::new(bcx, l2));\n         }\n         vec_len(n, vec_len_eq, _) => {\n@@ -398,7 +399,7 @@ struct ArmData<'a, 'b> {\n  * these pointers are stored in llmatch variables just before executing `data` arm.\n  */\n struct Match<'a, 'b> {\n-    pats: Vec<@ast::Pat>,\n+    pats: Vec<Gc<ast::Pat>>,\n     data: &'a ArmData<'a, 'b>,\n     bound_ptrs: Vec<(Ident, ValueRef)>\n }\n@@ -461,16 +462,16 @@ fn expand_nested_bindings<'a, 'b>(\n     }).collect()\n }\n \n-fn assert_is_binding_or_wild(bcx: &Block, p: @ast::Pat) {\n-    if !pat_is_binding_or_wild(&bcx.tcx().def_map, p) {\n+fn assert_is_binding_or_wild(bcx: &Block, p: Gc<ast::Pat>) {\n+    if !pat_is_binding_or_wild(&bcx.tcx().def_map, &*p) {\n         bcx.sess().span_bug(\n             p.span,\n             format!(\"expected an identifier pattern but found p: {}\",\n                     p.repr(bcx.tcx())).as_slice());\n     }\n }\n \n-type enter_pat<'a> = |@ast::Pat|: 'a -> Option<Vec<@ast::Pat>>;\n+type enter_pat<'a> = |Gc<ast::Pat>|: 'a -> Option<Vec<Gc<ast::Pat>>>;\n \n fn enter_match<'a, 'b>(\n                bcx: &'b Block<'b>,\n@@ -496,7 +497,7 @@ fn enter_match<'a, 'b>(\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n                 ast::PatIdent(_, ref path, None) => {\n-                    if pat_is_binding(dm, this) {\n+                    if pat_is_binding(dm, &*this) {\n                         bound_ptrs.push((path_to_ident(path), val));\n                     }\n                 }\n@@ -531,7 +532,7 @@ fn enter_default<'a, 'b>(\n     let matches = enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n           ast::PatWild | ast::PatWildMulti => Some(Vec::new()),\n-          ast::PatIdent(_, _, None) if pat_is_binding(dm, p) => Some(Vec::new()),\n+          ast::PatIdent(_, _, None) if pat_is_binding(dm, &*p) => Some(Vec::new()),\n           _ => None\n         }\n     });\n@@ -600,12 +601,12 @@ fn enter_opt<'a, 'b>(\n     let _indenter = indenter();\n \n     let tcx = bcx.tcx();\n-    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n+    let dummy = box(GC) ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     let mut i = 0;\n     enter_match(bcx, &tcx.def_map, m, col, val, |p| {\n         let answer = match p.node {\n             ast::PatEnum(..) |\n-            ast::PatIdent(_, _, None) if pat_is_const(&tcx.def_map, p) => {\n+            ast::PatIdent(_, _, None) if pat_is_const(&tcx.def_map, &*p) => {\n                 let const_def = tcx.def_map.borrow().get_copy(&p.id);\n                 let const_def_id = const_def.def_id();\n                 if opt_eq(tcx, &lit(ConstLit(const_def_id)), opt) {\n@@ -628,7 +629,7 @@ fn enter_opt<'a, 'b>(\n                 }\n             }\n             ast::PatIdent(_, _, None)\n-                    if pat_is_variant_or_struct(&tcx.def_map, p) => {\n+                    if pat_is_variant_or_struct(&tcx.def_map, &*p) => {\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n                     Some(Vec::new())\n                 } else {\n@@ -739,7 +740,7 @@ fn enter_rec_or_struct<'a, 'b>(\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n+    let dummy = box(GC) ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatStruct(_, ref fpats, _) => {\n@@ -775,7 +776,7 @@ fn enter_tup<'a, 'b>(\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n+    let dummy = box(GC) ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatTup(ref elts) => {\n@@ -808,7 +809,7 @@ fn enter_tuple_struct<'a, 'b>(\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n+    let dummy = box(GC) ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatEnum(_, Some(ref elts)) => {\n@@ -839,7 +840,7 @@ fn enter_uniq<'a, 'b>(\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n+    let dummy = box(GC) ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatBox(sub) => {\n@@ -867,7 +868,7 @@ fn enter_region<'a, 'b>(\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::Pat { id: 0, node: ast::PatWild, span: DUMMY_SP };\n+    let dummy = box(GC) ast::Pat { id: 0, node: ast::PatWild, span: DUMMY_SP };\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatRegion(sub) => {\n@@ -1194,14 +1195,14 @@ fn pick_col(m: &[Match]) -> uint {\n     fn score(p: &ast::Pat) -> uint {\n         match p.node {\n           ast::PatLit(_) | ast::PatEnum(_, _) | ast::PatRange(_, _) => 1u,\n-          ast::PatIdent(_, _, Some(p)) => score(p),\n+          ast::PatIdent(_, _, Some(ref p)) => score(&**p),\n           _ => 0u\n         }\n     }\n     let mut scores = Vec::from_elem(m[0].pats.len(), 0u);\n     for br in m.iter() {\n-        for (i, p) in br.pats.iter().enumerate() {\n-            *scores.get_mut(i) += score(*p);\n+        for (i, ref p) in br.pats.iter().enumerate() {\n+            *scores.get_mut(i) += score(&***p);\n         }\n     }\n     let mut max_score = 0u;\n@@ -1454,9 +1455,9 @@ fn compile_submatch<'a, 'b>(\n             Store(bcx, *value_ptr, llmatch);\n         }\n         match data.arm.guard {\n-            Some(guard_expr) => {\n+            Some(ref guard_expr) => {\n                 bcx = compile_guard(bcx,\n-                                    guard_expr,\n+                                    &**guard_expr,\n                                     m[0].data,\n                                     m.slice(1, m.len()),\n                                     vals,\n@@ -1841,15 +1842,15 @@ pub fn trans_match<'a>(\n     trans_match_inner(bcx, match_expr.id, discr_expr, arms, dest)\n }\n \n-fn create_bindings_map(bcx: &Block, pat: @ast::Pat) -> BindingsMap {\n+fn create_bindings_map(bcx: &Block, pat: Gc<ast::Pat>) -> BindingsMap {\n     // Create the bindings map, which is a mapping from each binding name\n     // to an alloca() that will be the value for that local variable.\n     // Note that we use the names because each binding will have many ids\n     // from the various alternatives.\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n     let mut bindings_map = HashMap::new();\n-    pat_bindings(&tcx.def_map, pat, |bm, p_id, span, path| {\n+    pat_bindings(&tcx.def_map, &*pat, |bm, p_id, span, path| {\n         let ident = path_to_ident(path);\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n@@ -1966,7 +1967,7 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n         let cleanup_scope = fcx.push_custom_cleanup_scope();\n         bcx = insert_lllocals(bcx, &arm_data.bindings_map,\n                               cleanup::CustomScope(cleanup_scope));\n-        bcx = expr::trans_into(bcx, arm_data.arm.body, dest);\n+        bcx = expr::trans_into(bcx, &*arm_data.arm.body, dest);\n         bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n         arm_cxs.push(bcx);\n     }\n@@ -2007,12 +2008,12 @@ pub fn store_local<'a>(bcx: &'a Block<'a>,\n             //\n             // In such cases, the more general path is unsafe, because\n             // it assumes it is matching against a valid value.\n-            match simple_identifier(pat) {\n+            match simple_identifier(&*pat) {\n                 Some(path) => {\n                     let var_scope = cleanup::var_scope(tcx, local.id);\n                     return mk_binding_alloca(\n                         bcx, pat.id, path, BindLocal, var_scope, (),\n-                        |(), bcx, v, _| expr::trans_into(bcx, init_expr,\n+                        |(), bcx, v, _| expr::trans_into(bcx, &*init_expr,\n                                                          expr::SaveIn(v)));\n                 }\n \n@@ -2021,8 +2022,8 @@ pub fn store_local<'a>(bcx: &'a Block<'a>,\n \n             // General path.\n             let init_datum =\n-                unpack_datum!(bcx, expr::trans_to_lvalue(bcx, init_expr, \"let\"));\n-            if ty::type_is_bot(expr_ty(bcx, init_expr)) {\n+                unpack_datum!(bcx, expr::trans_to_lvalue(bcx, &*init_expr, \"let\"));\n+            if ty::type_is_bot(expr_ty(bcx, &*init_expr)) {\n                 create_dummy_locals(bcx, pat)\n             } else {\n                 if bcx.sess().asm_comments() {\n@@ -2038,12 +2039,12 @@ pub fn store_local<'a>(bcx: &'a Block<'a>,\n     };\n \n     fn create_dummy_locals<'a>(mut bcx: &'a Block<'a>,\n-                               pat: @ast::Pat)\n+                               pat: Gc<ast::Pat>)\n                                -> &'a Block<'a> {\n         // create dummy memory for the variables if we have no\n         // value to store into them immediately\n         let tcx = bcx.tcx();\n-        pat_bindings(&tcx.def_map, pat, |_, p_id, _, path| {\n+        pat_bindings(&tcx.def_map, &*pat, |_, p_id, _, path| {\n                 let scope = cleanup::var_scope(tcx, p_id);\n                 bcx = mk_binding_alloca(\n                     bcx, p_id, path, BindLocal, scope, (),\n@@ -2054,7 +2055,7 @@ pub fn store_local<'a>(bcx: &'a Block<'a>,\n }\n \n pub fn store_arg<'a>(mut bcx: &'a Block<'a>,\n-                     pat: @ast::Pat,\n+                     pat: Gc<ast::Pat>,\n                      arg: Datum<Rvalue>,\n                      arg_scope: cleanup::ScopeId)\n                      -> &'a Block<'a> {\n@@ -2073,7 +2074,7 @@ pub fn store_arg<'a>(mut bcx: &'a Block<'a>,\n \n     let _icx = push_ctxt(\"match::store_arg\");\n \n-    match simple_identifier(pat) {\n+    match simple_identifier(&*pat) {\n         Some(path) => {\n             // Generate nicer LLVM for the common case of fn a pattern\n             // like `x: T`\n@@ -2137,7 +2138,7 @@ fn mk_binding_alloca<'a,A>(bcx: &'a Block<'a>,\n \n fn bind_irrefutable_pat<'a>(\n                         bcx: &'a Block<'a>,\n-                        pat: @ast::Pat,\n+                        pat: Gc<ast::Pat>,\n                         val: ValueRef,\n                         binding_mode: IrrefutablePatternBindingMode,\n                         cleanup_scope: cleanup::ScopeId)\n@@ -2176,7 +2177,7 @@ fn bind_irrefutable_pat<'a>(\n     let ccx = bcx.ccx();\n     match pat.node {\n         ast::PatIdent(pat_binding_mode, ref path, inner) => {\n-            if pat_is_binding(&tcx.def_map, pat) {\n+            if pat_is_binding(&tcx.def_map, &*pat) {\n                 // Allocate the stack slot where the value of this\n                 // binding will live and place it into the appropriate\n                 // map."}, {"sha": "871b75760f1d020377321bacc460e235aa5698f9", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -37,23 +37,23 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n     let temp_scope = fcx.push_custom_cleanup_scope();\n \n     // Prepare the output operands\n-    let outputs = ia.outputs.iter().map(|&(ref c, out)| {\n+    let outputs = ia.outputs.iter().map(|&(ref c, ref out)| {\n         constraints.push((*c).clone());\n \n-        let out_datum = unpack_datum!(bcx, expr::trans(bcx, out));\n+        let out_datum = unpack_datum!(bcx, expr::trans(bcx, &**out));\n         output_types.push(type_of::type_of(bcx.ccx(), out_datum.ty));\n         out_datum.val\n \n     }).collect::<Vec<_>>();\n \n     // Now the input operands\n-    let inputs = ia.inputs.iter().map(|&(ref c, input)| {\n+    let inputs = ia.inputs.iter().map(|&(ref c, ref input)| {\n         constraints.push((*c).clone());\n \n-        let in_datum = unpack_datum!(bcx, expr::trans(bcx, input));\n+        let in_datum = unpack_datum!(bcx, expr::trans(bcx, &**input));\n         unpack_result!(bcx, {\n             callee::trans_arg_datum(bcx,\n-                                   expr_ty(bcx, input),\n+                                   expr_ty(bcx, &**input),\n                                    in_datum,\n                                    cleanup::CustomScope(temp_scope),\n                                    callee::DontAutorefArg)"}, {"sha": "3d5f0168743821d6a33ad5990488b1b450308a69", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -81,6 +81,7 @@ use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n use std::rc::Rc;\n use std::{i8, i16, i32, i64};\n+use std::gc::Gc;\n use syntax::abi::{X86, X86_64, Arm, Mips, Rust, RustIntrinsic};\n use syntax::ast_util::{local_def, is_local};\n use syntax::attr::AttrMetaMethods;\n@@ -977,8 +978,8 @@ pub fn init_local<'a>(bcx: &'a Block<'a>, local: &ast::Local)\n     if ignore_lhs(bcx, local) {\n         // Handle let _ = e; just like e;\n         match local.init {\n-            Some(init) => {\n-                return controlflow::trans_stmt_semi(bcx, init)\n+            Some(ref init) => {\n+                return controlflow::trans_stmt_semi(bcx, &**init)\n             }\n             None => { return bcx; }\n         }\n@@ -1537,14 +1538,14 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n fn trans_enum_def(ccx: &CrateContext, enum_definition: &ast::EnumDef,\n                   sp: Span, id: ast::NodeId, vi: &[Rc<ty::VariantInfo>],\n                   i: &mut uint) {\n-    for &variant in enum_definition.variants.iter() {\n+    for variant in enum_definition.variants.iter() {\n         let disr_val = vi[*i].disr_val;\n         *i += 1;\n \n         match variant.node.kind {\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let llfn = get_item_val(ccx, variant.node.id);\n-                trans_enum_variant(ccx, id, variant, args.as_slice(),\n+                trans_enum_variant(ccx, id, &**variant, args.as_slice(),\n                                    disr_val, &param_substs::empty(), llfn);\n             }\n             ast::TupleVariantKind(_) => {\n@@ -1621,16 +1622,16 @@ impl<'a> Visitor<()> for TransItemVisitor<'a> {\n pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     let _icx = push_ctxt(\"trans_item\");\n     match item.node {\n-      ast::ItemFn(decl, _fn_style, abi, ref generics, body) => {\n+      ast::ItemFn(ref decl, _fn_style, abi, ref generics, ref body) => {\n         if abi != Rust  {\n             let llfndecl = get_item_val(ccx, item.id);\n             foreign::trans_rust_fn_with_foreign_abi(\n-                ccx, decl, body, item.attrs.as_slice(), llfndecl, item.id);\n+                ccx, &**decl, &**body, item.attrs.as_slice(), llfndecl, item.id);\n         } else if !generics.is_type_parameterized() {\n             let llfn = get_item_val(ccx, item.id);\n             trans_fn(ccx,\n-                     decl,\n-                     body,\n+                     &**decl,\n+                     &**body,\n                      llfn,\n                      &param_substs::empty(),\n                      item.id,\n@@ -1639,7 +1640,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n             // Be sure to travel more than just one layer deep to catch nested\n             // items in blocks and such.\n             let mut v = TransItemVisitor{ ccx: ccx };\n-            v.visit_block(body, ());\n+            v.visit_block(&**body, ());\n         }\n       }\n       ast::ItemImpl(ref generics, _, _, ref ms) => {\n@@ -1655,10 +1656,10 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n             trans_enum_def(ccx, enum_definition, item.span, item.id, vi.as_slice(), &mut i);\n         }\n       }\n-      ast::ItemStatic(_, m, expr) => {\n+      ast::ItemStatic(_, m, ref expr) => {\n           // Recurse on the expression to catch items in blocks\n           let mut v = TransItemVisitor{ ccx: ccx };\n-          v.visit_expr(expr, ());\n+          v.visit_expr(&**expr, ());\n           consts::trans_const(ccx, m, item.id);\n           // Do static_assert checking. It can't really be done much earlier\n           // because we need to get the value of the bool out of LLVM\n@@ -1697,7 +1698,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     }\n }\n \n-pub fn trans_struct_def(ccx: &CrateContext, struct_def: @ast::StructDef) {\n+pub fn trans_struct_def(ccx: &CrateContext, struct_def: Gc<ast::StructDef>) {\n     // If this is a tuple-like struct, translate the constructor.\n     match struct_def.ctor_id {\n         // We only need to translate a constructor if there are fields;\n@@ -1719,7 +1720,7 @@ pub fn trans_struct_def(ccx: &CrateContext, struct_def: @ast::StructDef) {\n pub fn trans_mod(ccx: &CrateContext, m: &ast::Mod) {\n     let _icx = push_ctxt(\"trans_mod\");\n     for item in m.items.iter() {\n-        trans_item(ccx, *item);\n+        trans_item(ccx, &**item);\n     }\n }\n \n@@ -2003,7 +2004,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let sym = exported_name(ccx, id, ty, i.attrs.as_slice());\n \n             let v = match i.node {\n-                ast::ItemStatic(_, _, expr) => {\n+                ast::ItemStatic(_, _, ref expr) => {\n                     // If this static came from an external crate, then\n                     // we need to get the symbol from csearch instead of\n                     // using the current crate's name/version\n@@ -2022,7 +2023,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n                     // We need the translated value here, because for enums the\n                     // LLVM type is not fully determined by the Rust type.\n-                    let (v, inlineable) = consts::const_expr(ccx, expr, is_local);\n+                    let (v, inlineable) = consts::const_expr(ccx, &**expr, is_local);\n                     ccx.const_values.borrow_mut().insert(id, v);\n                     let mut inlineable = inlineable;\n \n@@ -2118,13 +2119,13 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                    get_item_val()\");\n                 }\n                 ast::Provided(m) => {\n-                    register_method(ccx, id, m)\n+                    register_method(ccx, id, &*m)\n                 }\n             }\n         }\n \n         ast_map::NodeMethod(m) => {\n-            register_method(ccx, id, m)\n+            register_method(ccx, id, &*m)\n         }\n \n         ast_map::NodeForeignItem(ni) => {\n@@ -2134,13 +2135,13 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                 ast::ForeignItemFn(..) => {\n                     let abi = ccx.tcx.map.get_foreign_abi(id);\n                     let ty = ty::node_id_to_type(ccx.tcx(), ni.id);\n-                    let name = foreign::link_name(ni);\n+                    let name = foreign::link_name(&*ni);\n                     foreign::register_foreign_item_fn(ccx, abi, ty,\n                                                       name.get().as_slice(),\n                                                       Some(ni.span))\n                 }\n                 ast::ForeignItemStatic(..) => {\n-                    foreign::register_static(ccx, ni)\n+                    foreign::register_static(ccx, &*ni)\n                 }\n             }\n         }"}, {"sha": "2f4b086b5b0e1ffb26a9ee525ee507fd69e42984", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -53,6 +53,8 @@ use syntax::ast;\n use synabi = syntax::abi;\n use syntax::ast_map;\n \n+use std::gc::Gc;\n+\n pub struct MethodData {\n     pub llfn: ValueRef,\n     pub llself: ValueRef,\n@@ -649,7 +651,7 @@ pub fn trans_call_inner<'a>(\n \n         let mut llargs = Vec::new();\n         let arg_tys = match args {\n-            ArgExprs(a) => a.iter().map(|x| expr_ty(bcx, *x)).collect(),\n+            ArgExprs(a) => a.iter().map(|x| expr_ty(bcx, &**x)).collect(),\n             _ => fail!(\"expected arg exprs.\")\n         };\n         bcx = trans_args(bcx, args, callee_ty, &mut llargs,\n@@ -683,7 +685,7 @@ pub fn trans_call_inner<'a>(\n pub enum CallArgs<'a> {\n     // Supply value of arguments as a list of expressions that must be\n     // translated. This is used in the common case of `foo(bar, qux)`.\n-    ArgExprs(&'a [@ast::Expr]),\n+    ArgExprs(&'a [Gc<ast::Expr>]),\n \n     // Supply value of arguments as a list of LLVM value refs; frequently\n     // used with lang items and so forth, when the argument is an internal\n@@ -715,18 +717,18 @@ fn trans_args<'a>(cx: &'a Block<'a>,\n     match args {\n         ArgExprs(arg_exprs) => {\n             let num_formal_args = arg_tys.len();\n-            for (i, &arg_expr) in arg_exprs.iter().enumerate() {\n+            for (i, arg_expr) in arg_exprs.iter().enumerate() {\n                 if i == 0 && ignore_self {\n                     continue;\n                 }\n                 let arg_ty = if i >= num_formal_args {\n                     assert!(variadic);\n-                    expr_ty_adjusted(cx, arg_expr)\n+                    expr_ty_adjusted(cx, &**arg_expr)\n                 } else {\n                     *arg_tys.get(i)\n                 };\n \n-                let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_expr));\n+                let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &**arg_expr));\n                 llargs.push(unpack_result!(bcx, {\n                     trans_arg_datum(bcx, arg_ty, arg_datum,\n                                     arg_cleanup_scope,"}, {"sha": "ae476fb9741cb461af8864298292e91a3bc6e858", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -34,8 +34,8 @@ use middle::ty;\n use util::ppaux::{Repr, ty_to_str};\n \n use std::c_str::ToCStr;\n+use std::gc::Gc;\n use std::vec;\n-use std::vec::Vec;\n use libc::c_uint;\n use syntax::{ast, ast_util};\n \n@@ -92,11 +92,11 @@ pub fn const_ptrcast(cx: &CrateContext, a: ValueRef, t: Type) -> ValueRef {\n }\n \n fn const_vec(cx: &CrateContext, e: &ast::Expr,\n-             es: &[@ast::Expr], is_local: bool) -> (ValueRef, Type, bool) {\n+             es: &[Gc<ast::Expr>], is_local: bool) -> (ValueRef, Type, bool) {\n     let vec_ty = ty::expr_ty(cx.tcx(), e);\n     let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n     let llunitty = type_of::type_of(cx, unit_ty);\n-    let (vs, inlineable) = vec::unzip(es.iter().map(|e| const_expr(cx, *e, is_local)));\n+    let (vs, inlineable) = vec::unzip(es.iter().map(|e| const_expr(cx, &**e, is_local)));\n     // If the vector contains enums, an LLVM array won't work.\n     let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n         C_struct(cx, vs.as_slice(), false)\n@@ -292,8 +292,8 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n // if it's assigned to a static.\n fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                          is_local: bool) -> (ValueRef, bool) {\n-    let map_list = |exprs: &[@ast::Expr]| {\n-        exprs.iter().map(|&e| const_expr(cx, e, is_local))\n+    let map_list = |exprs: &[Gc<ast::Expr>]| {\n+        exprs.iter().map(|e| const_expr(cx, &**e, is_local))\n              .fold((Vec::new(), true),\n                    |(l, all_inlineable), (val, inlineable)| {\n                 (l.append_one(val), all_inlineable && inlineable)\n@@ -302,18 +302,18 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n     unsafe {\n         let _icx = push_ctxt(\"const_expr\");\n         return match e.node {\n-          ast::ExprLit(lit) => {\n-              (consts::const_lit(cx, e, (*lit).clone()), true)\n+          ast::ExprLit(ref lit) => {\n+              (consts::const_lit(cx, e, (**lit).clone()), true)\n           }\n-          ast::ExprBinary(b, e1, e2) => {\n-            let (te1, _) = const_expr(cx, e1, is_local);\n-            let (te2, _) = const_expr(cx, e2, is_local);\n+          ast::ExprBinary(b, ref e1, ref e2) => {\n+            let (te1, _) = const_expr(cx, &**e1, is_local);\n+            let (te2, _) = const_expr(cx, &**e2, is_local);\n \n             let te2 = base::cast_shift_const_rhs(b, te1, te2);\n \n             /* Neither type is bottom, and we expect them to be unified\n              * already, so the following is safe. */\n-            let ty = ty::expr_ty(cx.tcx(), e1);\n+            let ty = ty::expr_ty(cx.tcx(), &**e1);\n             let is_float = ty::type_is_fp(ty);\n             let signed = ty::type_is_signed(ty);\n             return (match b {\n@@ -387,9 +387,9 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               },\n             }, true)\n           },\n-          ast::ExprUnary(u, e) => {\n-            let (te, _) = const_expr(cx, e, is_local);\n-            let ty = ty::expr_ty(cx.tcx(), e);\n+          ast::ExprUnary(u, ref e) => {\n+            let (te, _) = const_expr(cx, &**e, is_local);\n+            let ty = ty::expr_ty(cx.tcx(), &**e);\n             let is_float = ty::type_is_fp(ty);\n             return (match u {\n               ast::UnBox | ast::UnUniq | ast::UnDeref => {\n@@ -414,20 +414,20 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               }\n             }, true)\n           }\n-          ast::ExprField(base, field, _) => {\n-              let bt = ty::expr_ty_adjusted(cx.tcx(), base);\n+          ast::ExprField(ref base, field, _) => {\n+              let bt = ty::expr_ty_adjusted(cx.tcx(), &**base);\n               let brepr = adt::represent_type(cx, bt);\n-              let (bv, inlineable) = const_expr(cx, base, is_local);\n+              let (bv, inlineable) = const_expr(cx, &**base, is_local);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx(), field.name, field_tys);\n                   (adt::const_get_field(cx, &*brepr, bv, discr, ix), inlineable)\n               })\n           }\n \n-          ast::ExprIndex(base, index) => {\n-              let bt = ty::expr_ty_adjusted(cx.tcx(), base);\n-              let (bv, inlineable) = const_expr(cx, base, is_local);\n-              let iv = match const_eval::eval_const_expr(cx.tcx(), index) {\n+          ast::ExprIndex(ref base, ref index) => {\n+              let bt = ty::expr_ty_adjusted(cx.tcx(), &**base);\n+              let (bv, inlineable) = const_expr(cx, &**base, is_local);\n+              let iv = match const_eval::eval_const_expr(cx.tcx(), &**index) {\n                   const_eval::const_int(i) => i as u64,\n                   const_eval::const_uint(u) => u,\n                   _ => cx.sess().span_bug(index.span,\n@@ -466,11 +466,11 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               }\n               (const_get_elt(cx, arr, [iv as c_uint]), inlineable)\n           }\n-          ast::ExprCast(base, _) => {\n+          ast::ExprCast(ref base, _) => {\n             let ety = ty::expr_ty(cx.tcx(), e);\n             let llty = type_of::type_of(cx, ety);\n-            let basety = ty::expr_ty(cx.tcx(), base);\n-            let (v, inlineable) = const_expr(cx, base, is_local);\n+            let basety = ty::expr_ty(cx.tcx(), &**base);\n+            let (v, inlineable) = const_expr(cx, &**base, is_local);\n             return (match (expr::cast_type_kind(basety),\n                            expr::cast_type_kind(ety)) {\n \n@@ -520,8 +520,8 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               }\n             }, inlineable)\n           }\n-          ast::ExprAddrOf(ast::MutImmutable, sub) => {\n-              let (e, _) = const_expr(cx, sub, is_local);\n+          ast::ExprAddrOf(ast::MutImmutable, ref sub) => {\n+              let (e, _) = const_expr(cx, &**sub, is_local);\n               (const_addr_of(cx, e), false)\n           }\n           ast::ExprTup(ref es) => {\n@@ -536,15 +536,15 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               let tcx = cx.tcx();\n \n               let base_val = match *base_opt {\n-                Some(base) => Some(const_expr(cx, base, is_local)),\n+                Some(ref base) => Some(const_expr(cx, &**base, is_local)),\n                 None => None\n               };\n \n               expr::with_field_tys(tcx, ety, Some(e.id), |discr, field_tys| {\n                   let (cs, inlineable) = vec::unzip(field_tys.iter().enumerate()\n                       .map(|(ix, &field_ty)| {\n                       match fs.iter().find(|f| field_ty.ident.name == f.ident.node.name) {\n-                          Some(f) => const_expr(cx, (*f).expr, is_local),\n+                          Some(ref f) => const_expr(cx, &*f.expr, is_local),\n                           None => {\n                               match base_val {\n                                 Some((bv, inlineable)) => {\n@@ -567,12 +567,12 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                                                is_local);\n             (v, inlineable)\n           }\n-          ast::ExprVstore(sub, store @ ast::ExprVstoreSlice) |\n-          ast::ExprVstore(sub, store @ ast::ExprVstoreMutSlice) => {\n+          ast::ExprVstore(ref sub, store @ ast::ExprVstoreSlice) |\n+          ast::ExprVstore(ref sub, store @ ast::ExprVstoreMutSlice) => {\n             match sub.node {\n               ast::ExprLit(ref lit) => {\n                 match lit.node {\n-                    ast::LitStr(..) => { const_expr(cx, sub, is_local) }\n+                    ast::LitStr(..) => { const_expr(cx, &**sub, is_local) }\n                     _ => { cx.sess().span_bug(e.span, \"bad const-slice lit\") }\n                 }\n               }\n@@ -595,16 +595,16 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               _ => cx.sess().span_bug(e.span, \"bad const-slice expr\")\n             }\n           }\n-          ast::ExprRepeat(elem, count) => {\n+          ast::ExprRepeat(ref elem, ref count) => {\n             let vec_ty = ty::expr_ty(cx.tcx(), e);\n             let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n             let llunitty = type_of::type_of(cx, unit_ty);\n-            let n = match const_eval::eval_const_expr(cx.tcx(), count) {\n+            let n = match const_eval::eval_const_expr(cx.tcx(), &**count) {\n                 const_eval::const_int(i)  => i as uint,\n                 const_eval::const_uint(i) => i as uint,\n                 _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n             };\n-            let vs = Vec::from_elem(n, const_expr(cx, elem, is_local).val0());\n+            let vs = Vec::from_elem(n, const_expr(cx, &**elem, is_local).val0());\n             let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n                 C_struct(cx, vs.as_slice(), false)\n             } else {\n@@ -673,7 +673,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                   _ => cx.sess().span_bug(e.span, \"expected a struct or variant def\")\n               }\n           }\n-          ast::ExprParen(e) => { const_expr(cx, e, is_local) }\n+          ast::ExprParen(ref e) => { const_expr(cx, &**e, is_local) }\n           ast::ExprBlock(ref block) => {\n             match block.expr {\n                 Some(ref expr) => const_expr(cx, &**expr, is_local),"}, {"sha": "e9b1c56eb00320485f34ccc5767d3e328436ec6b", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -31,6 +31,8 @@ use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::visit::Visitor;\n \n+use std::gc::Gc;\n+\n pub fn trans_stmt<'a>(cx: &'a Block<'a>,\n                       s: &ast::Stmt)\n                       -> &'a Block<'a> {\n@@ -48,18 +50,18 @@ pub fn trans_stmt<'a>(cx: &'a Block<'a>,\n     fcx.push_ast_cleanup_scope(id);\n \n     match s.node {\n-        ast::StmtExpr(e, _) | ast::StmtSemi(e, _) => {\n-            bcx = trans_stmt_semi(bcx, e);\n+        ast::StmtExpr(ref e, _) | ast::StmtSemi(ref e, _) => {\n+            bcx = trans_stmt_semi(bcx, &**e);\n         }\n         ast::StmtDecl(d, _) => {\n             match d.node {\n                 ast::DeclLocal(ref local) => {\n-                    bcx = init_local(bcx, *local);\n+                    bcx = init_local(bcx, &**local);\n                     if cx.sess().opts.debuginfo == FullDebugInfo {\n-                        debuginfo::create_local_var_metadata(bcx, *local);\n+                        debuginfo::create_local_var_metadata(bcx, &**local);\n                     }\n                 }\n-                ast::DeclItem(i) => trans_item(cx.fcx.ccx, i)\n+                ast::DeclItem(ref i) => trans_item(cx.fcx.ccx, &**i)\n             }\n         }\n         ast::StmtMac(..) => cx.tcx().sess.bug(\"unexpanded macro\")\n@@ -92,7 +94,7 @@ pub fn trans_block<'a>(bcx: &'a Block<'a>,\n     fcx.push_ast_cleanup_scope(b.id);\n \n     for s in b.stmts.iter() {\n-        bcx = trans_stmt(bcx, *s);\n+        bcx = trans_stmt(bcx, &**s);\n     }\n \n     if dest != expr::Ignore {\n@@ -103,8 +105,8 @@ pub fn trans_block<'a>(bcx: &'a Block<'a>,\n     }\n \n     match b.expr {\n-        Some(e) => {\n-            bcx = expr::trans_into(bcx, e, dest);\n+        Some(ref e) => {\n+            bcx = expr::trans_into(bcx, &**e, dest);\n         }\n         None => {\n             assert!(dest == expr::Ignore || bcx.unreachable.get());\n@@ -120,7 +122,7 @@ pub fn trans_if<'a>(bcx: &'a Block<'a>,\n                     if_id: ast::NodeId,\n                     cond: &ast::Expr,\n                     thn: ast::P<ast::Block>,\n-                    els: Option<@ast::Expr>,\n+                    els: Option<Gc<ast::Expr>>,\n                     dest: expr::Dest)\n                     -> &'a Block<'a> {\n     debug!(\"trans_if(bcx={}, if_id={}, cond={}, thn={:?}, dest={})\",\n@@ -137,21 +139,21 @@ pub fn trans_if<'a>(bcx: &'a Block<'a>,\n             match els {\n                 Some(elexpr) => {\n                     let mut trans = TransItemVisitor { ccx: bcx.fcx.ccx };\n-                    trans.visit_expr(elexpr, ());\n+                    trans.visit_expr(&*elexpr, ());\n                 }\n                 None => {}\n             }\n             // if true { .. } [else { .. }]\n-            bcx = trans_block(bcx, thn, dest);\n+            bcx = trans_block(bcx, &*thn, dest);\n             debuginfo::clear_source_location(bcx.fcx);\n         } else {\n             let mut trans = TransItemVisitor { ccx: bcx.fcx.ccx } ;\n-            trans.visit_block(thn, ());\n+            trans.visit_block(&*thn, ());\n \n             match els {\n                 // if false { .. } else { .. }\n                 Some(elexpr) => {\n-                    bcx = expr::trans_into(bcx, elexpr, dest);\n+                    bcx = expr::trans_into(bcx, &*elexpr, dest);\n                     debuginfo::clear_source_location(bcx.fcx);\n                 }\n \n@@ -165,14 +167,14 @@ pub fn trans_if<'a>(bcx: &'a Block<'a>,\n \n     let name = format!(\"then-block-{}-\", thn.id);\n     let then_bcx_in = bcx.fcx.new_id_block(name.as_slice(), thn.id);\n-    let then_bcx_out = trans_block(then_bcx_in, thn, dest);\n+    let then_bcx_out = trans_block(then_bcx_in, &*thn, dest);\n     debuginfo::clear_source_location(bcx.fcx);\n \n     let next_bcx;\n     match els {\n         Some(elexpr) => {\n             let else_bcx_in = bcx.fcx.new_id_block(\"else-block\", elexpr.id);\n-            let else_bcx_out = expr::trans_into(else_bcx_in, elexpr, dest);\n+            let else_bcx_out = expr::trans_into(else_bcx_in, &*elexpr, dest);\n             next_bcx = bcx.fcx.join_blocks(if_id,\n                                            [then_bcx_out, else_bcx_out]);\n             CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb);\n@@ -319,7 +321,7 @@ pub fn trans_cont<'a>(bcx: &'a Block<'a>,\n }\n \n pub fn trans_ret<'a>(bcx: &'a Block<'a>,\n-                     e: Option<@ast::Expr>)\n+                     e: Option<Gc<ast::Expr>>)\n                      -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_ret\");\n     let fcx = bcx.fcx;\n@@ -330,7 +332,7 @@ pub fn trans_ret<'a>(bcx: &'a Block<'a>,\n     };\n     match e {\n         Some(x) => {\n-            bcx = expr::trans_into(bcx, x, dest);\n+            bcx = expr::trans_into(bcx, &*x, dest);\n         }\n         _ => {}\n     }"}, {"sha": "db17000abb32b188c26477794b18e29de05e22d4", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 82, "deletions": 78, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -143,14 +143,14 @@ use middle::ty;\n use middle::pat_util;\n use util::ppaux;\n \n+use libc::{c_uint, c_ulonglong, c_longlong};\n use std::c_str::{CString, ToCStr};\n use std::cell::{Cell, RefCell};\n-use std::rc::{Rc, Weak};\n use std::collections::HashMap;\n use std::collections::HashSet;\n-use libc::{c_uint, c_ulonglong, c_longlong};\n+use std::gc::Gc;\n use std::ptr;\n-use std::string::String;\n+use std::rc::{Rc, Weak};\n use std::sync::atomics;\n use syntax::codemap::{Span, Pos};\n use syntax::{abi, ast, codemap, ast_util, ast_map};\n@@ -379,7 +379,7 @@ pub fn create_local_var_metadata(bcx: &Block, local: &ast::Local) {\n     let cx = bcx.ccx();\n     let def_map = &cx.tcx.def_map;\n \n-    pat_util::pat_bindings(def_map, local.pat, |_, node_id, span, path_ref| {\n+    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, path_ref| {\n         let var_ident = ast_util::path_to_ident(path_ref);\n \n         let datum = match bcx.fcx.lllocals.borrow().find_copy(&node_id) {\n@@ -524,7 +524,7 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n     let def_map = &cx.tcx.def_map;\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n \n-    pat_util::pat_bindings(def_map, arg.pat, |_, node_id, span, path_ref| {\n+    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, path_ref| {\n         let llarg = match bcx.fcx.llargs.borrow().find_copy(&node_id) {\n             Some(v) => v,\n             None => {\n@@ -715,7 +715,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n \n     let function_type_metadata = unsafe {\n-        let fn_signature = get_function_signature(cx, fn_ast_id, fn_decl, param_substs, span);\n+        let fn_signature = get_function_signature(cx, fn_ast_id, &*fn_decl, param_substs, span);\n         llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx), file_metadata, fn_signature)\n     };\n \n@@ -779,7 +779,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     let arg_pats = fn_decl.inputs.iter().map(|arg_ref| arg_ref.pat).collect::<Vec<_>>();\n     populate_scope_map(cx,\n                        arg_pats.as_slice(),\n-                       top_level_block,\n+                       &*top_level_block,\n                        fn_metadata,\n                        &mut *fn_debug_context.scope_map.borrow_mut());\n \n@@ -2519,7 +2519,7 @@ fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: ast::DefId)\n // descriptors where necessary. These artificial scopes allow GDB to correctly handle name\n // shadowing.\n fn populate_scope_map(cx: &CrateContext,\n-                      arg_pats: &[@ast::Pat],\n+                      arg_pats: &[Gc<ast::Pat>],\n                       fn_entry_block: &ast::Block,\n                       fn_metadata: DISubprogram,\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n@@ -2535,7 +2535,7 @@ fn populate_scope_map(cx: &CrateContext,\n     // Push argument identifiers onto the stack so arguments integrate nicely with variable\n     // shadowing.\n     for &arg_pat in arg_pats.iter() {\n-        pat_util::pat_bindings(def_map, arg_pat, |_, _, _, path_ref| {\n+        pat_util::pat_bindings(def_map, &*arg_pat, |_, _, _, path_ref| {\n             let ident = ast_util::path_to_ident(path_ref);\n             scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata, ident: Some(ident) });\n         })\n@@ -2597,19 +2597,21 @@ fn populate_scope_map(cx: &CrateContext,\n \n         // The interesting things here are statements and the concluding expression.\n         for statement in block.stmts.iter() {\n-            scope_map.insert(ast_util::stmt_id(*statement),\n+            scope_map.insert(ast_util::stmt_id(&**statement),\n                              scope_stack.last().unwrap().scope_metadata);\n \n             match statement.node {\n-                ast::StmtDecl(decl, _) => walk_decl(cx, decl, scope_stack, scope_map),\n-                ast::StmtExpr(exp, _) |\n-                ast::StmtSemi(exp, _) => walk_expr(cx, exp, scope_stack, scope_map),\n+                ast::StmtDecl(ref decl, _) =>\n+                    walk_decl(cx, &**decl, scope_stack, scope_map),\n+                ast::StmtExpr(ref exp, _) |\n+                ast::StmtSemi(ref exp, _) =>\n+                    walk_expr(cx, &**exp, scope_stack, scope_map),\n                 ast::StmtMac(..) => () // ignore macros (which should be expanded anyway)\n             }\n         }\n \n         for exp in block.expr.iter() {\n-            walk_expr(cx, *exp, scope_stack, scope_map);\n+            walk_expr(cx, &**exp, scope_stack, scope_map);\n         }\n     }\n \n@@ -2624,15 +2626,15 @@ fn populate_scope_map(cx: &CrateContext,\n                 walk_pattern(cx, local.pat, scope_stack, scope_map);\n \n                 for exp in local.init.iter() {\n-                    walk_expr(cx, *exp, scope_stack, scope_map);\n+                    walk_expr(cx, &**exp, scope_stack, scope_map);\n                 }\n             }\n             _ => ()\n         }\n     }\n \n     fn walk_pattern(cx: &CrateContext,\n-                    pat: @ast::Pat,\n+                    pat: Gc<ast::Pat>,\n                     scope_stack: &mut Vec<ScopeStackEntry> ,\n                     scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n \n@@ -2646,7 +2648,7 @@ fn populate_scope_map(cx: &CrateContext,\n \n                 // Check if this is a binding. If so we need to put it on the scope stack and maybe\n                 // introduce an artificial scope\n-                if pat_util::pat_is_binding(def_map, pat) {\n+                if pat_util::pat_is_binding(def_map, &*pat) {\n \n                     let ident = ast_util::path_to_ident(path_ref);\n \n@@ -2741,25 +2743,25 @@ fn populate_scope_map(cx: &CrateContext,\n             ast::PatTup(ref sub_pats) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n-                for &sub_pat in sub_pats.iter() {\n-                    walk_pattern(cx, sub_pat, scope_stack, scope_map);\n+                for sub_pat in sub_pats.iter() {\n+                    walk_pattern(cx, sub_pat.clone(), scope_stack, scope_map);\n                 }\n             }\n \n-            ast::PatBox(sub_pat) | ast::PatRegion(sub_pat) => {\n+            ast::PatBox(ref sub_pat) | ast::PatRegion(ref sub_pat) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-                walk_pattern(cx, sub_pat, scope_stack, scope_map);\n+                walk_pattern(cx, sub_pat.clone(), scope_stack, scope_map);\n             }\n \n-            ast::PatLit(exp) => {\n+            ast::PatLit(ref exp) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-                walk_expr(cx, exp, scope_stack, scope_map);\n+                walk_expr(cx, &**exp, scope_stack, scope_map);\n             }\n \n-            ast::PatRange(exp1, exp2) => {\n+            ast::PatRange(ref exp1, ref exp2) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-                walk_expr(cx, exp1, scope_stack, scope_map);\n-                walk_expr(cx, exp2, scope_stack, scope_map);\n+                walk_expr(cx, &**exp1, scope_stack, scope_map);\n+                walk_expr(cx, &**exp2, scope_stack, scope_map);\n             }\n \n             ast::PatVec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n@@ -2798,72 +2800,74 @@ fn populate_scope_map(cx: &CrateContext,\n             ast::ExprAgain(_) |\n             ast::ExprPath(_)  => {}\n \n-            ast::ExprVstore(sub_exp, _)   |\n-            ast::ExprCast(sub_exp, _)     |\n-            ast::ExprAddrOf(_, sub_exp)  |\n-            ast::ExprField(sub_exp, _, _) |\n-            ast::ExprParen(sub_exp)       => walk_expr(cx, sub_exp, scope_stack, scope_map),\n+            ast::ExprVstore(ref sub_exp, _)   |\n+            ast::ExprCast(ref sub_exp, _)     |\n+            ast::ExprAddrOf(_, ref sub_exp)  |\n+            ast::ExprField(ref sub_exp, _, _) |\n+            ast::ExprParen(ref sub_exp) =>\n+                walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n \n-            ast::ExprBox(place, sub_expr) => {\n-                walk_expr(cx, place, scope_stack, scope_map);\n-                walk_expr(cx, sub_expr, scope_stack, scope_map);\n+            ast::ExprBox(ref place, ref sub_expr) => {\n+                walk_expr(cx, &**place, scope_stack, scope_map);\n+                walk_expr(cx, &**sub_expr, scope_stack, scope_map);\n             }\n \n             ast::ExprRet(exp_opt) => match exp_opt {\n-                Some(sub_exp) => walk_expr(cx, sub_exp, scope_stack, scope_map),\n+                Some(sub_exp) => walk_expr(cx, &*sub_exp, scope_stack, scope_map),\n                 None => ()\n             },\n \n-            ast::ExprUnary(_, sub_exp) => {\n-                walk_expr(cx, sub_exp, scope_stack, scope_map);\n+            ast::ExprUnary(_, ref sub_exp) => {\n+                walk_expr(cx, &**sub_exp, scope_stack, scope_map);\n             }\n \n-            ast::ExprAssignOp(_, lhs, rhs) |\n-            ast::ExprIndex(lhs, rhs)        |\n-            ast::ExprBinary(_, lhs, rhs)    => {\n-                walk_expr(cx, lhs, scope_stack, scope_map);\n-                walk_expr(cx, rhs, scope_stack, scope_map);\n+            ast::ExprAssignOp(_, ref lhs, ref rhs) |\n+            ast::ExprIndex(ref lhs, ref rhs)        |\n+            ast::ExprBinary(_, ref lhs, ref rhs)    => {\n+                walk_expr(cx, &**lhs, scope_stack, scope_map);\n+                walk_expr(cx, &**rhs, scope_stack, scope_map);\n             }\n \n             ast::ExprVec(ref init_expressions) |\n             ast::ExprTup(ref init_expressions) => {\n                 for ie in init_expressions.iter() {\n-                    walk_expr(cx, *ie, scope_stack, scope_map);\n+                    walk_expr(cx, &**ie, scope_stack, scope_map);\n                 }\n             }\n \n-            ast::ExprAssign(sub_exp1, sub_exp2) |\n-            ast::ExprRepeat(sub_exp1, sub_exp2) => {\n-                walk_expr(cx, sub_exp1, scope_stack, scope_map);\n-                walk_expr(cx, sub_exp2, scope_stack, scope_map);\n+            ast::ExprAssign(ref sub_exp1, ref sub_exp2) |\n+            ast::ExprRepeat(ref sub_exp1, ref sub_exp2) => {\n+                walk_expr(cx, &**sub_exp1, scope_stack, scope_map);\n+                walk_expr(cx, &**sub_exp2, scope_stack, scope_map);\n             }\n \n-            ast::ExprIf(cond_exp, then_block, ref opt_else_exp) => {\n-                walk_expr(cx, cond_exp, scope_stack, scope_map);\n+            ast::ExprIf(ref cond_exp, ref then_block, ref opt_else_exp) => {\n+                walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n \n                 with_new_scope(cx,\n                                then_block.span,\n                                scope_stack,\n                                scope_map,\n                                |cx, scope_stack, scope_map| {\n-                    walk_block(cx, then_block, scope_stack, scope_map);\n+                    walk_block(cx, &**then_block, scope_stack, scope_map);\n                 });\n \n                 match *opt_else_exp {\n-                    Some(else_exp) => walk_expr(cx, else_exp, scope_stack, scope_map),\n+                    Some(ref else_exp) =>\n+                        walk_expr(cx, &**else_exp, scope_stack, scope_map),\n                     _ => ()\n                 }\n             }\n \n-            ast::ExprWhile(cond_exp, loop_body) => {\n-                walk_expr(cx, cond_exp, scope_stack, scope_map);\n+            ast::ExprWhile(ref cond_exp, ref loop_body) => {\n+                walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n \n                 with_new_scope(cx,\n                                loop_body.span,\n                                scope_stack,\n                                scope_map,\n                                |cx, scope_stack, scope_map| {\n-                    walk_block(cx, loop_body, scope_stack, scope_map);\n+                    walk_block(cx, &**loop_body, scope_stack, scope_map);\n                 })\n             }\n \n@@ -2877,48 +2881,48 @@ fn populate_scope_map(cx: &CrateContext,\n                                               Found unexpanded macro.\");\n             }\n \n-            ast::ExprLoop(block, _) |\n-            ast::ExprBlock(block)   => {\n+            ast::ExprLoop(ref block, _) |\n+            ast::ExprBlock(ref block)   => {\n                 with_new_scope(cx,\n                                block.span,\n                                scope_stack,\n                                scope_map,\n                                |cx, scope_stack, scope_map| {\n-                    walk_block(cx, block, scope_stack, scope_map);\n+                    walk_block(cx, &**block, scope_stack, scope_map);\n                 })\n             }\n \n-            ast::ExprFnBlock(decl, block) |\n-            ast::ExprProc(decl, block) => {\n+            ast::ExprFnBlock(ref decl, ref block) |\n+            ast::ExprProc(ref decl, ref block) => {\n                 with_new_scope(cx,\n                                block.span,\n                                scope_stack,\n                                scope_map,\n                                |cx, scope_stack, scope_map| {\n-                    for &ast::Arg { pat: pattern, .. } in decl.inputs.iter() {\n-                        walk_pattern(cx, pattern, scope_stack, scope_map);\n+                    for &ast::Arg { pat: ref pattern, .. } in decl.inputs.iter() {\n+                        walk_pattern(cx, pattern.clone(), scope_stack, scope_map);\n                     }\n \n-                    walk_block(cx, block, scope_stack, scope_map);\n+                    walk_block(cx, &**block, scope_stack, scope_map);\n                 })\n             }\n \n-            ast::ExprCall(fn_exp, ref args) => {\n-                walk_expr(cx, fn_exp, scope_stack, scope_map);\n+            ast::ExprCall(ref fn_exp, ref args) => {\n+                walk_expr(cx, &**fn_exp, scope_stack, scope_map);\n \n                 for arg_exp in args.iter() {\n-                    walk_expr(cx, *arg_exp, scope_stack, scope_map);\n+                    walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n                 }\n             }\n \n             ast::ExprMethodCall(_, _, ref args) => {\n                 for arg_exp in args.iter() {\n-                    walk_expr(cx, *arg_exp, scope_stack, scope_map);\n+                    walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n                 }\n             }\n \n-            ast::ExprMatch(discriminant_exp, ref arms) => {\n-                walk_expr(cx, discriminant_exp, scope_stack, scope_map);\n+            ast::ExprMatch(ref discriminant_exp, ref arms) => {\n+                walk_expr(cx, &**discriminant_exp, scope_stack, scope_map);\n \n                 // for each arm we have to first walk the pattern as these might introduce new\n                 // artificial scopes. It should be sufficient to walk only one pattern per arm, as\n@@ -2937,35 +2941,35 @@ fn populate_scope_map(cx: &CrateContext,\n                         }\n \n                         for guard_exp in arm_ref.guard.iter() {\n-                            walk_expr(cx, *guard_exp, scope_stack, scope_map)\n+                            walk_expr(cx, &**guard_exp, scope_stack, scope_map)\n                         }\n \n-                        walk_expr(cx, arm_ref.body, scope_stack, scope_map);\n+                        walk_expr(cx, &*arm_ref.body, scope_stack, scope_map);\n                     })\n                 }\n             }\n \n             ast::ExprStruct(_, ref fields, ref base_exp) => {\n-                for &ast::Field { expr: exp, .. } in fields.iter() {\n-                    walk_expr(cx, exp, scope_stack, scope_map);\n+                for &ast::Field { expr: ref exp, .. } in fields.iter() {\n+                    walk_expr(cx, &**exp, scope_stack, scope_map);\n                 }\n \n                 match *base_exp {\n-                    Some(exp) => walk_expr(cx, exp, scope_stack, scope_map),\n+                    Some(ref exp) => walk_expr(cx, &**exp, scope_stack, scope_map),\n                     None => ()\n                 }\n             }\n \n             ast::ExprInlineAsm(ast::InlineAsm { inputs: ref inputs,\n                                                 outputs: ref outputs,\n                                                 .. }) => {\n-                // inputs, outputs: ~[(String, @expr)]\n-                for &(_, exp) in inputs.iter() {\n-                    walk_expr(cx, exp, scope_stack, scope_map);\n+                // inputs, outputs: ~[(String, Gc<expr>)]\n+                for &(_, ref exp) in inputs.iter() {\n+                    walk_expr(cx, &**exp, scope_stack, scope_map);\n                 }\n \n-                for &(_, exp) in outputs.iter() {\n-                    walk_expr(cx, exp, scope_stack, scope_map);\n+                for &(_, ref exp) in outputs.iter() {\n+                    walk_expr(cx, &**exp, scope_stack, scope_map);\n                 }\n             }\n         }"}, {"sha": "fa6566022468595c9dd41d05d89d5568e355724d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 76, "deletions": 74, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -77,6 +77,8 @@ use syntax::ast;\n use syntax::codemap;\n use syntax::print::pprust::{expr_to_str};\n \n+use std::gc::Gc;\n+\n // Destinations\n \n // These are passed around by the code generating functions to track the\n@@ -380,22 +382,22 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n     let _icx = push_ctxt(\"trans_datum_unadjusted\");\n \n     match expr.node {\n-        ast::ExprParen(e) => {\n-            trans(bcx, e)\n+        ast::ExprParen(ref e) => {\n+            trans(bcx, &**e)\n         }\n         ast::ExprPath(_) => {\n             trans_def(bcx, expr, bcx.def(expr.id))\n         }\n-        ast::ExprField(base, ident, _) => {\n-            trans_rec_field(bcx, base, ident)\n+        ast::ExprField(ref base, ident, _) => {\n+            trans_rec_field(bcx, &**base, ident)\n         }\n-        ast::ExprIndex(base, idx) => {\n-            trans_index(bcx, expr, base, idx)\n+        ast::ExprIndex(ref base, ref idx) => {\n+            trans_index(bcx, expr, &**base, &**idx)\n         }\n-        ast::ExprVstore(contents, ast::ExprVstoreUniq) => {\n+        ast::ExprVstore(ref contents, ast::ExprVstoreUniq) => {\n             fcx.push_ast_cleanup_scope(contents.id);\n             let datum = unpack_datum!(\n-                bcx, tvec::trans_uniq_vstore(bcx, expr, contents));\n+                bcx, tvec::trans_uniq_vstore(bcx, expr, &**contents));\n             bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id);\n             DatumBlock::new(bcx, datum)\n         }\n@@ -414,19 +416,19 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n                                          \"expected unique or managed box\")\n             }\n         }\n-        ast::ExprLit(lit) => trans_immediate_lit(bcx, expr, (*lit).clone()),\n-        ast::ExprBinary(op, lhs, rhs) => {\n-            trans_binary(bcx, expr, op, lhs, rhs)\n+        ast::ExprLit(ref lit) => trans_immediate_lit(bcx, expr, (**lit).clone()),\n+        ast::ExprBinary(op, ref lhs, ref rhs) => {\n+            trans_binary(bcx, expr, op, &**lhs, &**rhs)\n         }\n-        ast::ExprUnary(op, x) => {\n-            trans_unary(bcx, expr, op, x)\n+        ast::ExprUnary(op, ref x) => {\n+            trans_unary(bcx, expr, op, &**x)\n         }\n-        ast::ExprAddrOf(_, x) => {\n-            trans_addr_of(bcx, expr, x)\n+        ast::ExprAddrOf(_, ref x) => {\n+            trans_addr_of(bcx, expr, &**x)\n         }\n-        ast::ExprCast(val, _) => {\n+        ast::ExprCast(ref val, _) => {\n             // Datum output mode means this is a scalar cast:\n-            trans_imm_cast(bcx, val, expr.id)\n+            trans_imm_cast(bcx, &**val, expr.id)\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(\n@@ -589,8 +591,8 @@ fn trans_rvalue_stmt_unadjusted<'a>(bcx: &'a Block<'a>,\n     }\n \n     match expr.node {\n-        ast::ExprParen(e) => {\n-            trans_into(bcx, e, Ignore)\n+        ast::ExprParen(ref e) => {\n+            trans_into(bcx, &**e, Ignore)\n         }\n         ast::ExprBreak(label_opt) => {\n             controlflow::trans_break(bcx, expr.id, label_opt)\n@@ -601,15 +603,15 @@ fn trans_rvalue_stmt_unadjusted<'a>(bcx: &'a Block<'a>,\n         ast::ExprRet(ex) => {\n             controlflow::trans_ret(bcx, ex)\n         }\n-        ast::ExprWhile(cond, body) => {\n-            controlflow::trans_while(bcx, expr.id, cond, body)\n+        ast::ExprWhile(ref cond, ref body) => {\n+            controlflow::trans_while(bcx, expr.id, &**cond, &**body)\n         }\n-        ast::ExprLoop(body, _) => {\n-            controlflow::trans_loop(bcx, expr.id, body)\n+        ast::ExprLoop(ref body, _) => {\n+            controlflow::trans_loop(bcx, expr.id, &**body)\n         }\n-        ast::ExprAssign(dst, src) => {\n-            let src_datum = unpack_datum!(bcx, trans(bcx, src));\n-            let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, dst, \"assign\"));\n+        ast::ExprAssign(ref dst, ref src) => {\n+            let src_datum = unpack_datum!(bcx, trans(bcx, &**src));\n+            let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &**dst, \"assign\"));\n \n             if ty::type_needs_drop(bcx.tcx(), dst_datum.ty) {\n                 // If there are destructors involved, make sure we\n@@ -636,8 +638,8 @@ fn trans_rvalue_stmt_unadjusted<'a>(bcx: &'a Block<'a>,\n                 src_datum.store_to(bcx, dst_datum.val)\n             }\n         }\n-        ast::ExprAssignOp(op, dst, src) => {\n-            trans_assign_op(bcx, expr, op, dst, src)\n+        ast::ExprAssignOp(op, ref dst, ref src) => {\n+            trans_assign_op(bcx, expr, op, &**dst, src.clone())\n         }\n         ast::ExprInlineAsm(ref a) => {\n             asm::trans_inline_asm(bcx, a)\n@@ -662,20 +664,20 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n     let fcx = bcx.fcx;\n \n     match expr.node {\n-        ast::ExprParen(e) => {\n-            trans_into(bcx, e, dest)\n+        ast::ExprParen(ref e) => {\n+            trans_into(bcx, &**e, dest)\n         }\n         ast::ExprPath(_) => {\n             trans_def_dps_unadjusted(bcx, expr, bcx.def(expr.id), dest)\n         }\n-        ast::ExprIf(cond, thn, els) => {\n-            controlflow::trans_if(bcx, expr.id, cond, thn, els, dest)\n+        ast::ExprIf(ref cond, ref thn, els) => {\n+            controlflow::trans_if(bcx, expr.id, &**cond, thn.clone(), els, dest)\n         }\n-        ast::ExprMatch(discr, ref arms) => {\n-            _match::trans_match(bcx, expr, discr, arms.as_slice(), dest)\n+        ast::ExprMatch(ref discr, ref arms) => {\n+            _match::trans_match(bcx, expr, &**discr, arms.as_slice(), dest)\n         }\n-        ast::ExprBlock(blk) => {\n-            controlflow::trans_block(bcx, blk, dest)\n+        ast::ExprBlock(ref blk) => {\n+            controlflow::trans_block(bcx, &**blk, dest)\n         }\n         ast::ExprStruct(_, ref fields, base) => {\n             trans_rec_or_struct(bcx,\n@@ -687,7 +689,7 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n         }\n         ast::ExprTup(ref args) => {\n             let repr = adt::represent_type(bcx.ccx(), expr_ty(bcx, expr));\n-            let numbered_fields: Vec<(uint, @ast::Expr)> =\n+            let numbered_fields: Vec<(uint, Gc<ast::Expr>)> =\n                 args.iter().enumerate().map(|(i, arg)| (i, *arg)).collect();\n             trans_adt(bcx, &*repr, 0, numbered_fields.as_slice(), None, dest)\n         }\n@@ -705,26 +707,26 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n                 }\n             }\n         }\n-        ast::ExprVstore(contents, ast::ExprVstoreSlice) |\n-        ast::ExprVstore(contents, ast::ExprVstoreMutSlice) => {\n+        ast::ExprVstore(ref contents, ast::ExprVstoreSlice) |\n+        ast::ExprVstore(ref contents, ast::ExprVstoreMutSlice) => {\n             fcx.push_ast_cleanup_scope(contents.id);\n-            bcx = tvec::trans_slice_vstore(bcx, expr, contents, dest);\n+            bcx = tvec::trans_slice_vstore(bcx, expr, &**contents, dest);\n             fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id)\n         }\n         ast::ExprVec(..) | ast::ExprRepeat(..) => {\n             tvec::trans_fixed_vstore(bcx, expr, expr, dest)\n         }\n-        ast::ExprFnBlock(decl, body) |\n-        ast::ExprProc(decl, body) => {\n+        ast::ExprFnBlock(ref decl, ref body) |\n+        ast::ExprProc(ref decl, ref body) => {\n             let expr_ty = expr_ty(bcx, expr);\n             let store = ty::ty_closure_store(expr_ty);\n             debug!(\"translating block function {} with type {}\",\n                    expr_to_str(expr), expr_ty.repr(tcx));\n-            closure::trans_expr_fn(bcx, store, decl, body, expr.id, dest)\n+            closure::trans_expr_fn(bcx, store, &**decl, &**body, expr.id, dest)\n         }\n-        ast::ExprCall(f, ref args) => {\n+        ast::ExprCall(ref f, ref args) => {\n             if bcx.tcx().is_method_call(expr.id) {\n-                let callee_datum = unpack_datum!(bcx, trans(bcx, f));\n+                let callee_datum = unpack_datum!(bcx, trans(bcx, &**f));\n                 trans_overloaded_call(bcx,\n                                       expr,\n                                       callee_datum,\n@@ -733,43 +735,43 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n             } else {\n                 callee::trans_call(bcx,\n                                    expr,\n-                                   f,\n+                                   &**f,\n                                    callee::ArgExprs(args.as_slice()),\n                                    dest)\n             }\n         }\n         ast::ExprMethodCall(_, _, ref args) => {\n             callee::trans_method_call(bcx,\n                                       expr,\n-                                      *args.get(0),\n+                                      &**args.get(0),\n                                       callee::ArgExprs(args.as_slice()),\n                                       dest)\n         }\n-        ast::ExprBinary(_, lhs, rhs) => {\n+        ast::ExprBinary(_, ref lhs, ref rhs) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            let lhs = unpack_datum!(bcx, trans(bcx, lhs));\n-            let rhs_datum = unpack_datum!(bcx, trans(bcx, rhs));\n+            let lhs = unpack_datum!(bcx, trans(bcx, &**lhs));\n+            let rhs_datum = unpack_datum!(bcx, trans(bcx, &**rhs));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), lhs,\n                                 Some((rhs_datum, rhs.id)), Some(dest)).bcx\n         }\n-        ast::ExprUnary(_, subexpr) => {\n+        ast::ExprUnary(_, ref subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            let arg = unpack_datum!(bcx, trans(bcx, subexpr));\n+            let arg = unpack_datum!(bcx, trans(bcx, &**subexpr));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id),\n                                 arg, None, Some(dest)).bcx\n         }\n-        ast::ExprIndex(base, idx) => {\n+        ast::ExprIndex(ref base, ref idx) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            let base = unpack_datum!(bcx, trans(bcx, base));\n-            let idx_datum = unpack_datum!(bcx, trans(bcx, idx));\n+            let base = unpack_datum!(bcx, trans(bcx, &**base));\n+            let idx_datum = unpack_datum!(bcx, trans(bcx, &**idx));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), base,\n                                 Some((idx_datum, idx.id)), Some(dest)).bcx\n         }\n-        ast::ExprCast(val, _) => {\n+        ast::ExprCast(ref val, _) => {\n             // DPS output mode means this is a trait cast:\n             match ty::get(node_id_type(bcx, expr.id)).sty {\n                 ty::ty_trait(..) => {\n-                    let datum = unpack_datum!(bcx, trans(bcx, val));\n+                    let datum = unpack_datum!(bcx, trans(bcx, &**val));\n                     meth::trans_trait_cast(bcx, datum, expr.id, dest)\n                 }\n                 _ => {\n@@ -778,8 +780,8 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n                 }\n             }\n         }\n-        ast::ExprAssignOp(op, dst, src) => {\n-            trans_assign_op(bcx, expr, op, dst, src)\n+        ast::ExprAssignOp(op, ref dst, ref src) => {\n+            trans_assign_op(bcx, expr, op, &**dst, src.clone())\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(\n@@ -978,7 +980,7 @@ pub fn with_field_tys<R>(tcx: &ty::ctxt,\n fn trans_rec_or_struct<'a>(\n                        bcx: &'a Block<'a>,\n                        fields: &[ast::Field],\n-                       base: Option<@ast::Expr>,\n+                       base: Option<Gc<ast::Expr>>,\n                        expr_span: codemap::Span,\n                        id: ast::NodeId,\n                        dest: Dest)\n@@ -1040,7 +1042,7 @@ fn trans_rec_or_struct<'a>(\n  */\n struct StructBaseInfo {\n     /// The base expression; will be evaluated after all explicit fields.\n-    expr: @ast::Expr,\n+    expr: Gc<ast::Expr>,\n     /// The indices of fields to copy paired with their types.\n     fields: Vec<(uint, ty::t)> }\n \n@@ -1058,7 +1060,7 @@ fn trans_adt<'a>(\n              bcx: &'a Block<'a>,\n              repr: &adt::Repr,\n              discr: ty::Disr,\n-             fields: &[(uint, @ast::Expr)],\n+             fields: &[(uint, Gc<ast::Expr>)],\n              optbase: Option<StructBaseInfo>,\n              dest: Dest)\n              -> &'a Block<'a> {\n@@ -1067,12 +1069,12 @@ fn trans_adt<'a>(\n     let mut bcx = bcx;\n     let addr = match dest {\n         Ignore => {\n-            for &(_i, e) in fields.iter() {\n-                bcx = trans_into(bcx, e, Ignore);\n+            for &(_i, ref e) in fields.iter() {\n+                bcx = trans_into(bcx, &**e, Ignore);\n             }\n             for sbi in optbase.iter() {\n                 // FIXME #7261: this moves entire base, not just certain fields\n-                bcx = trans_into(bcx, sbi.expr, Ignore);\n+                bcx = trans_into(bcx, &*sbi.expr, Ignore);\n             }\n             return bcx;\n         }\n@@ -1085,18 +1087,18 @@ fn trans_adt<'a>(\n \n     adt::trans_start_init(bcx, repr, addr, discr);\n \n-    for &(i, e) in fields.iter() {\n+    for &(i, ref e) in fields.iter() {\n         let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n-        let e_ty = expr_ty_adjusted(bcx, e);\n-        bcx = trans_into(bcx, e, SaveIn(dest));\n+        let e_ty = expr_ty_adjusted(bcx, &**e);\n+        bcx = trans_into(bcx, &**e, SaveIn(dest));\n         fcx.schedule_drop_mem(cleanup::CustomScope(custom_cleanup_scope),\n                               dest, e_ty);\n     }\n \n     for base in optbase.iter() {\n         // FIXME #6573: is it sound to use the destination's repr on the base?\n         // And, would it ever be reasonable to be here with discr != 0?\n-        let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, base.expr, \"base\"));\n+        let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &*base.expr, \"base\"));\n         for &(i, t) in base.fields.iter() {\n             let datum = base_datum.get_element(\n                 t,\n@@ -1458,16 +1460,16 @@ fn trans_overloaded_call<'a>(\n                          mut bcx: &'a Block<'a>,\n                          expr: &ast::Expr,\n                          callee: Datum<Expr>,\n-                         args: &[@ast::Expr],\n+                         args: &[Gc<ast::Expr>],\n                          dest: Option<Dest>)\n                          -> &'a Block<'a> {\n     // Evaluate and tuple the arguments.\n     let tuple_type = ty::mk_tup(bcx.tcx(),\n                                 args.iter()\n-                                    .map(|e| expr_ty(bcx, *e))\n+                                    .map(|e| expr_ty(bcx, &**e))\n                                     .collect());\n     let repr = adt::represent_type(bcx.ccx(), tuple_type);\n-    let numbered_fields: Vec<(uint, @ast::Expr)> =\n+    let numbered_fields: Vec<(uint, Gc<ast::Expr>)> =\n         args.iter().enumerate().map(|(i, arg)| (i, *arg)).collect();\n     let argument_scope = bcx.fcx.push_custom_cleanup_scope();\n     let tuple_datum =\n@@ -1679,7 +1681,7 @@ fn trans_assign_op<'a>(\n                    expr: &ast::Expr,\n                    op: ast::BinOp,\n                    dst: &ast::Expr,\n-                   src: @ast::Expr)\n+                   src: Gc<ast::Expr>)\n                    -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_assign_op\");\n     let mut bcx = bcx;\n@@ -1696,7 +1698,7 @@ fn trans_assign_op<'a>(\n     let dst = Load(bcx, dst_datum.val);\n \n     // Evaluate RHS\n-    let rhs_datum = unpack_datum!(bcx, trans(bcx, src));\n+    let rhs_datum = unpack_datum!(bcx, trans(bcx, &*src));\n     let rhs_ty = rhs_datum.ty;\n     let rhs = rhs_datum.to_llscalarish(bcx);\n "}, {"sha": "ed1c1d3092035ab4a2b539f636a53041e7715539", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -443,8 +443,8 @@ pub fn trans_native_call<'a>(\n \n pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n     let _icx = push_ctxt(\"foreign::trans_foreign_mod\");\n-    for &foreign_item in foreign_mod.items.iter() {\n-        let lname = link_name(foreign_item);\n+    for foreign_item in foreign_mod.items.iter() {\n+        let lname = link_name(&**foreign_item);\n \n         match foreign_item.node {\n             ast::ForeignItemFn(..) => {"}, {"sha": "55ea4a3a0bb1e6dcd84d93fd7056f9d5e965610f", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -51,7 +51,7 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             ccx.external_srcs.borrow_mut().insert(item.id, fn_id);\n \n             ccx.stats.n_inlines.set(ccx.stats.n_inlines.get() + 1);\n-            trans_item(ccx, item);\n+            trans_item(ccx, &*item);\n \n             // We're bringing an external global into this crate, but we don't\n             // want to create two copies of the global. If we do this, then if\n@@ -107,7 +107,7 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             _ => ccx.sess().bug(\"maybe_instantiate_inline: item has a \\\n                                  non-enum, non-struct parent\")\n           }\n-          trans_item(ccx, item);\n+          trans_item(ccx, &*item);\n           local_def(my_id)\n         }\n         csearch::found_parent(_, _) => {\n@@ -131,7 +131,7 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n \n           if num_type_params == 0 {\n               let llfn = get_item_val(ccx, mth.id);\n-              trans_fn(ccx, mth.decl, mth.body, llfn,\n+              trans_fn(ccx, &*mth.decl, &*mth.body, llfn,\n                        &param_substs::empty(), mth.id, []);\n           }\n           local_def(mth.id)"}, {"sha": "59387c549db61a40cfb338995e35200fe1c9cf63", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -35,6 +35,7 @@ use util::common::indenter;\n use util::ppaux::Repr;\n \n use std::c_str::ToCStr;\n+use std::gc::Gc;\n use syntax::abi::Rust;\n use syntax::parse::token;\n use syntax::{ast, ast_map, visit};\n@@ -47,7 +48,7 @@ see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n */\n pub fn trans_impl(ccx: &CrateContext,\n                   name: ast::Ident,\n-                  methods: &[@ast::Method],\n+                  methods: &[Gc<ast::Method>],\n                   generics: &ast::Generics,\n                   id: ast::NodeId) {\n     let _icx = push_ctxt(\"meth::trans_impl\");\n@@ -60,18 +61,18 @@ pub fn trans_impl(ccx: &CrateContext,\n     if !generics.ty_params.is_empty() {\n         let mut v = TransItemVisitor{ ccx: ccx };\n         for method in methods.iter() {\n-            visit::walk_method_helper(&mut v, *method, ());\n+            visit::walk_method_helper(&mut v, &**method, ());\n         }\n         return;\n     }\n     for method in methods.iter() {\n         if method.generics.ty_params.len() == 0u {\n             let llfn = get_item_val(ccx, method.id);\n-            trans_fn(ccx, method.decl, method.body,\n+            trans_fn(ccx, &*method.decl, &*method.body,\n                      llfn, &param_substs::empty(), method.id, []);\n         } else {\n             let mut v = TransItemVisitor{ ccx: ccx };\n-            visit::walk_method_helper(&mut v, *method, ());\n+            visit::walk_method_helper(&mut v, &**method, ());\n         }\n     }\n }"}, {"sha": "0315815266ee5d6268f44aa1bf6b57aab6fb1d6d", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -201,12 +201,12 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         ast_map::NodeItem(i) => {\n             match *i {\n               ast::Item {\n-                  node: ast::ItemFn(decl, _, _, _, body),\n+                  node: ast::ItemFn(ref decl, _, _, _, ref body),\n                   ..\n               } => {\n                   let d = mk_lldecl();\n                   set_llvm_fn_attrs(i.attrs.as_slice(), d);\n-                  trans_fn(ccx, decl, body, d, &psubsts, fn_id.node, []);\n+                  trans_fn(ccx, &**decl, &**body, d, &psubsts, fn_id.node, []);\n                   d\n               }\n               _ => {\n@@ -215,12 +215,12 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             }\n         }\n         ast_map::NodeForeignItem(i) => {\n-            let simple = intrinsic::get_simple_intrinsic(ccx, i);\n+            let simple = intrinsic::get_simple_intrinsic(ccx, &*i);\n             match simple {\n                 Some(decl) => decl,\n                 None => {\n                     let d = mk_lldecl();\n-                    intrinsic::trans_intrinsic(ccx, d, i, &psubsts, ref_id);\n+                    intrinsic::trans_intrinsic(ccx, d, &*i, &psubsts, ref_id);\n                     d\n                 }\n             }\n@@ -235,7 +235,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n                 ast::TupleVariantKind(ref args) => {\n                     trans_enum_variant(ccx,\n                                        parent,\n-                                       v,\n+                                       &*v,\n                                        args.as_slice(),\n                                        this_tv.disr_val,\n                                        &psubsts,\n@@ -249,15 +249,15 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         ast_map::NodeMethod(mth) => {\n             let d = mk_lldecl();\n             set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n-            trans_fn(ccx, mth.decl, mth.body, d, &psubsts, mth.id, []);\n+            trans_fn(ccx, &*mth.decl, &*mth.body, d, &psubsts, mth.id, []);\n             d\n         }\n         ast_map::NodeTraitMethod(method) => {\n             match *method {\n                 ast::Provided(mth) => {\n                     let d = mk_lldecl();\n                     set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n-                    trans_fn(ccx, mth.decl, mth.body, d, &psubsts, mth.id, []);\n+                    trans_fn(ccx, &*mth.decl, &*mth.body, d, &psubsts, mth.id, []);\n                     d\n                 }\n                 _ => {"}, {"sha": "c116df92be24665b8684263b8c0ed1bb8b69515d", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -351,7 +351,7 @@ pub fn write_content<'a>(\n             match dest {\n                 Ignore => {\n                     for element in elements.iter() {\n-                        bcx = expr::trans_into(bcx, *element, Ignore);\n+                        bcx = expr::trans_into(bcx, &**element, Ignore);\n                     }\n                 }\n \n@@ -361,7 +361,7 @@ pub fn write_content<'a>(\n                         let lleltptr = GEPi(bcx, lldest, [i]);\n                         debug!(\"writing index {:?} with lleltptr={:?}\",\n                                i, bcx.val_to_str(lleltptr));\n-                        bcx = expr::trans_into(bcx, *element,\n+                        bcx = expr::trans_into(bcx, &**element,\n                                                SaveIn(lleltptr));\n                         fcx.schedule_drop_mem(\n                             cleanup::CustomScope(temp_scope),\n@@ -373,13 +373,13 @@ pub fn write_content<'a>(\n             }\n             return bcx;\n         }\n-        ast::ExprRepeat(element, count_expr) => {\n+        ast::ExprRepeat(ref element, ref count_expr) => {\n             match dest {\n                 Ignore => {\n-                    return expr::trans_into(bcx, element, Ignore);\n+                    return expr::trans_into(bcx, &**element, Ignore);\n                 }\n                 SaveIn(lldest) => {\n-                    let count = ty::eval_repeat_count(bcx.tcx(), count_expr);\n+                    let count = ty::eval_repeat_count(bcx.tcx(), &**count_expr);\n                     if count == 0 {\n                         return bcx;\n                     }\n@@ -389,7 +389,7 @@ pub fn write_content<'a>(\n                     // this can only happen as a result of OOM. So we just skip out on the\n                     // cleanup since things would *probably* be broken at that point anyways.\n \n-                    let elem = unpack_datum!(bcx, expr::trans(bcx, element));\n+                    let elem = unpack_datum!(bcx, expr::trans(bcx, &**element));\n                     assert!(!ty::type_moves_by_default(bcx.tcx(), elem.ty));\n \n                     let bcx = iter_vec_loop(bcx, lldest, vt,\n@@ -442,8 +442,8 @@ pub fn elements_required(bcx: &Block, content_expr: &ast::Expr) -> uint {\n             }\n         },\n         ast::ExprVec(ref es) => es.len(),\n-        ast::ExprRepeat(_, count_expr) => {\n-            ty::eval_repeat_count(bcx.tcx(), count_expr)\n+        ast::ExprRepeat(_, ref count_expr) => {\n+            ty::eval_repeat_count(bcx.tcx(), &**count_expr)\n         }\n         _ => bcx.tcx().sess.span_bug(content_expr.span,\n                                      \"unexpected vec content\")"}, {"sha": "99c337946ae3b93467003da348f00f08814c0675", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -42,6 +42,7 @@ use std::cmp;\n use std::fmt::Show;\n use std::fmt;\n use std::hash::{Hash, sip, Writer};\n+use std::gc::Gc;\n use std::iter::AdditiveIterator;\n use std::mem;\n use std::ops;\n@@ -348,8 +349,8 @@ pub struct ctxt {\n \n     /// These two caches are used by const_eval when decoding external statics\n     /// and variants that are found.\n-    pub extern_const_statics: RefCell<DefIdMap<Option<@ast::Expr>>>,\n-    pub extern_const_variants: RefCell<DefIdMap<Option<@ast::Expr>>>,\n+    pub extern_const_statics: RefCell<DefIdMap<Option<Gc<ast::Expr>>>>,\n+    pub extern_const_variants: RefCell<DefIdMap<Option<Gc<ast::Expr>>>>,\n \n     pub method_map: typeck::MethodMap,\n     pub vtable_map: typeck::vtable_map,\n@@ -3122,7 +3123,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             }\n         }\n \n-        ast::ExprParen(e) => expr_kind(tcx, e),\n+        ast::ExprParen(ref e) => expr_kind(tcx, &**e),\n \n         ast::ExprMac(..) => {\n             tcx.sess.span_bug(\n@@ -3181,7 +3182,7 @@ pub fn ty_sort_str(cx: &ctxt, t: t) -> String {\n         }\n \n         ty_enum(id, _) => format!(\"enum {}\", item_path_str(cx, id)),\n-        ty_box(_) => \"@-ptr\".to_string(),\n+        ty_box(_) => \"Gc-ptr\".to_string(),\n         ty_uniq(_) => \"box\".to_string(),\n         ty_vec(_, _) => \"vector\".to_string(),\n         ty_ptr(_) => \"*-ptr\".to_string(),\n@@ -3740,7 +3741,7 @@ pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> Rc<Vec<Rc<VariantInfo>>> {\n                             };\n \n                             match variant.node.disr_expr {\n-                                Some(e) => match const_eval::eval_const_expr_partial(cx, e) {\n+                                Some(ref e) => match const_eval::eval_const_expr_partial(cx, &**e) {\n                                     Ok(const_eval::const_int(val)) => {\n                                         discriminant = val as Disr\n                                     }\n@@ -3763,7 +3764,7 @@ pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> Rc<Vec<Rc<VariantInfo>>> {\n                             };\n \n                             last_discriminant = Some(discriminant);\n-                            Rc::new(VariantInfo::from_ast_variant(cx, variant,\n+                            Rc::new(VariantInfo::from_ast_variant(cx, &*variant,\n                                                                   discriminant))\n                         }).collect())\n                     }"}, {"sha": "7db23ee264def3b5a41991324d576bd8b3ff3db6", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -230,7 +230,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n     }\n \n     let tps = path.segments.iter().flat_map(|s| s.types.iter())\n-                            .map(|&a_t| ast_ty_to_ty(this, rscope, a_t))\n+                            .map(|a_t| ast_ty_to_ty(this, rscope, &**a_t))\n                             .collect();\n \n     let mut substs = subst::Substs {\n@@ -451,12 +451,12 @@ pub fn ast_ty_to_builtin_ty<AC:AstConv,\n                                               supplied to `Box<T>`\");\n                     Some(ty::mk_err())\n                 }\n-                ast::DefTy(did) | ast::DefStruct(did)\n+                def::DefTy(did) | def::DefStruct(did)\n                         if Some(did) == this.tcx().lang_items.gc() => {\n                     if path.segments\n                            .iter()\n                            .flat_map(|s| s.types.iter())\n-                           .len() > 1 {\n+                           .count() > 1 {\n                         this.tcx()\n                             .sess\n                             .span_err(path.span,\n@@ -532,12 +532,12 @@ pub fn trait_ref_for_unboxed_function<AC:AstConv,\n                         .inputs\n                         .iter()\n                         .map(|input| {\n-                            ast_ty_to_ty(this, rscope, input.ty)\n+                            ast_ty_to_ty(this, rscope, &*input.ty)\n                         }).collect::<Vec<_>>();\n     let input_tuple = ty::mk_tup(this.tcx(), input_types);\n     let output_type = ast_ty_to_ty(this,\n                                    rscope,\n-                                   unboxed_function.decl.output);\n+                                   &*unboxed_function.decl.output);\n     let substs = subst::Substs {\n         self_ty: None,\n         tps: vec!(input_tuple, output_type),\n@@ -564,8 +564,8 @@ fn mk_pointer<AC:AstConv,\n     debug!(\"mk_pointer(ptr_ty={:?})\", ptr_ty);\n \n     match a_seq_ty.ty.node {\n-        ast::TyVec(ty) => {\n-            let mut mt = ast_ty_to_mt(this, rscope, ty);\n+        ast::TyVec(ref ty) => {\n+            let mut mt = ast_ty_to_mt(this, rscope, &**ty);\n             if a_seq_ty.mutbl == ast::MutMutable {\n                 mt.mutbl = ast::MutMutable;\n             }\n@@ -590,7 +590,7 @@ fn mk_pointer<AC:AstConv,\n                 substs\n             } = trait_ref_for_unboxed_function(this,\n                                                rscope,\n-                                               *unboxed_function);\n+                                               &**unboxed_function);\n             return ty::mk_trait(this.tcx(),\n                                 def_id,\n                                 substs,\n@@ -650,7 +650,7 @@ fn mk_pointer<AC:AstConv,\n         _ => {}\n     }\n \n-    constr(ast_ty_to_ty(this, rscope, a_seq_ty.ty))\n+    constr(ast_ty_to_ty(this, rscope, &*a_seq_ty.ty))\n }\n \n // Parses the programmer's textual representation of a type into our\n@@ -690,12 +690,12 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n             ast::TyVec(ty) => {\n                 tcx.sess.span_err(ast_ty.span, \"bare `[]` is not a type\");\n                 // return /something/ so they can at least get more errors\n-                let vec_ty = ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty), None);\n+                let vec_ty = ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, &*ty), None);\n                 ty::mk_uniq(tcx, vec_ty)\n             }\n             ast::TyPtr(ref mt) => {\n                 ty::mk_ptr(tcx, ty::mt {\n-                    ty: ast_ty_to_ty(this, rscope, mt.ty),\n+                    ty: ast_ty_to_ty(this, rscope, &*mt.ty),\n                     mutbl: mt.mutbl\n                 })\n             }\n@@ -707,7 +707,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n             }\n             ast::TyTup(ref fields) => {\n                 let flds = fields.iter()\n-                                 .map(|&t| ast_ty_to_ty(this, rscope, t))\n+                                 .map(|t| ast_ty_to_ty(this, rscope, &**t))\n                                  .collect();\n                 ty::mk_tup(tcx, flds)\n             }\n@@ -717,7 +717,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                                       \"variadic function must have C calling convention\");\n                 }\n                 ty::mk_bare_fn(tcx, ty_of_bare_fn(this, ast_ty.id, bf.fn_style,\n-                                                  bf.abi, bf.decl))\n+                                                  bf.abi, &*bf.decl))\n             }\n             ast::TyClosure(ref f, ref region) => {\n \n@@ -741,7 +741,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                                             f.onceness,\n                                             bounds,\n                                             store,\n-                                            f.decl,\n+                                            &*f.decl,\n                                             None);\n                 ty::mk_closure(tcx, fn_decl)\n             }\n@@ -759,7 +759,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                                             f.onceness,\n                                             bounds,\n                                             ty::UniqTraitStore,\n-                                            f.decl,\n+                                            &*f.decl,\n                                             None);\n                 ty::mk_closure(tcx, fn_decl)\n             }\n@@ -830,14 +830,14 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 }\n             }\n             ast::TyFixedLengthVec(ty, e) => {\n-                match const_eval::eval_const_expr_partial(tcx, e) {\n+                match const_eval::eval_const_expr_partial(tcx, &*e) {\n                     Ok(ref r) => {\n                         match *r {\n                             const_eval::const_int(i) =>\n-                                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty),\n+                                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, &*ty),\n                                            Some(i as uint)),\n                             const_eval::const_uint(i) =>\n-                                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty),\n+                                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, &*ty),\n                                            Some(i as uint)),\n                             _ => {\n                                 tcx.sess.span_fatal(\n@@ -876,7 +876,7 @@ pub fn ty_of_arg<AC: AstConv, RS: RegionScope>(this: &AC, rscope: &RS, a: &ast::\n     match a.ty.node {\n         ast::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n         ast::TyInfer => this.ty_infer(a.ty.span),\n-        _ => ast_ty_to_ty(this, rscope, a.ty),\n+        _ => ast_ty_to_ty(this, rscope, &*a.ty),\n     }\n }\n \n@@ -947,7 +947,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n \n     let output_ty = match decl.output.node {\n         ast::TyInfer => this.ty_infer(decl.output.span),\n-        _ => ast_ty_to_ty(this, &rb, decl.output)\n+        _ => ast_ty_to_ty(this, &rb, &*decl.output)\n     };\n \n     return ty::BareFnTy {\n@@ -996,7 +996,7 @@ pub fn ty_of_closure<AC:AstConv>(\n     let output_ty = match decl.output.node {\n         ast::TyInfer if expected_ret_ty.is_some() => expected_ret_ty.unwrap(),\n         ast::TyInfer => this.ty_infer(decl.output.span),\n-        _ => ast_ty_to_ty(this, &rb, decl.output)\n+        _ => ast_ty_to_ty(this, &rb, &*decl.output)\n     };\n \n     ty::ClosureTy {"}, {"sha": "d5f7ca56f741e4636dcebab01e85ee6f7026e7f7", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -23,6 +23,7 @@ use middle::typeck::infer;\n use middle::typeck::require_same_types;\n \n use std::collections::{HashMap, HashSet};\n+use std::gc::Gc;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::parse::token;\n@@ -43,10 +44,10 @@ pub fn check_match(fcx: &FnCtxt,\n     for arm in arms.iter() {\n         let mut pcx = pat_ctxt {\n             fcx: fcx,\n-            map: pat_id_map(&tcx.def_map, *arm.pats.get(0)),\n+            map: pat_id_map(&tcx.def_map, &**arm.pats.get(0)),\n         };\n \n-        for p in arm.pats.iter() { check_pat(&mut pcx, *p, discrim_ty);}\n+        for p in arm.pats.iter() { check_pat(&mut pcx, &**p, discrim_ty);}\n     }\n \n     // The result of the match is the common supertype of all the\n@@ -64,9 +65,9 @@ pub fn check_match(fcx: &FnCtxt,\n         let mut guard_err = false;\n         let mut guard_bot = false;\n         match arm.guard {\n-          Some(e) => {\n-              check_expr_has_type(fcx, e, ty::mk_bool());\n-              let e_ty = fcx.expr_ty(e);\n+          Some(ref e) => {\n+              check_expr_has_type(fcx, &**e, ty::mk_bool());\n+              let e_ty = fcx.expr_ty(&**e);\n               if ty::type_is_error(e_ty) {\n                   guard_err = true;\n               }\n@@ -76,7 +77,7 @@ pub fn check_match(fcx: &FnCtxt,\n           },\n           None => ()\n         }\n-        check_expr(fcx, arm.body);\n+        check_expr(fcx, &*arm.body);\n         let bty = fcx.node_ty(arm.body.id);\n         saw_err = saw_err || ty::type_is_error(bty);\n         if guard_err {\n@@ -111,7 +112,7 @@ pub struct pat_ctxt<'a> {\n }\n \n pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n-                         subpats: &Option<Vec<@ast::Pat>>, expected: ty::t) {\n+                         subpats: &Option<Vec<Gc<ast::Pat>>>, expected: ty::t) {\n \n     // Typecheck the path.\n     let fcx = pcx.fcx;\n@@ -269,7 +270,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n         if !error_happened {\n             for pats in subpats.iter() {\n                 for (subpat, arg_ty) in pats.iter().zip(arg_types.iter()) {\n-                    check_pat(pcx, *subpat, *arg_ty);\n+                    check_pat(pcx, &**subpat, *arg_ty);\n                 }\n             }\n         }\n@@ -286,7 +287,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n     if error_happened {\n         for pats in subpats.iter() {\n             for pat in pats.iter() {\n-                check_pat(pcx, *pat, ty::mk_err());\n+                check_pat(pcx, &**pat, ty::mk_err());\n             }\n         }\n     }\n@@ -331,13 +332,13 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                                                        class_id,\n                                                        class_field.id,\n                                                        substitutions);\n-                check_pat(pcx, field.pat, field_type);\n+                check_pat(pcx, &*field.pat, field_type);\n                 found_fields.insert(index);\n             }\n             None => {\n                 // Check the pattern anyway, so that attempts to look\n                 // up its type won't fail\n-                check_pat(pcx, field.pat, ty::mk_err());\n+                check_pat(pcx, &*field.pat, ty::mk_err());\n                 tcx.sess.span_err(span,\n                     format!(\"struct `{}` does not have a field named `{}`\",\n                             ty::item_path_str(tcx, class_id),\n@@ -441,17 +442,17 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n       ast::PatWild | ast::PatWildMulti => {\n         fcx.write_ty(pat.id, expected);\n       }\n-      ast::PatLit(lt) => {\n-        check_expr_has_type(fcx, lt, expected);\n-        fcx.write_ty(pat.id, fcx.expr_ty(lt));\n+      ast::PatLit(ref lt) => {\n+        check_expr_has_type(fcx, &**lt, expected);\n+        fcx.write_ty(pat.id, fcx.expr_ty(&**lt));\n       }\n-      ast::PatRange(begin, end) => {\n-        check_expr_has_type(fcx, begin, expected);\n-        check_expr_has_type(fcx, end, expected);\n+      ast::PatRange(ref begin, ref end) => {\n+        check_expr_has_type(fcx, &**begin, expected);\n+        check_expr_has_type(fcx, &**end, expected);\n         let b_ty =\n-            fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(begin));\n+            fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(&**begin));\n         let e_ty =\n-            fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(end));\n+            fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(&**end));\n         debug!(\"pat_range beginning type: {:?}\", b_ty);\n         debug!(\"pat_range ending type: {:?}\", e_ty);\n         if !require_same_types(\n@@ -463,7 +464,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n             tcx.sess.span_err(pat.span,\n                 \"only char and numeric types are allowed in range\");\n         } else {\n-            match valid_range_bounds(fcx.ccx, begin, end) {\n+            match valid_range_bounds(fcx.ccx, &**begin, &**end) {\n                 Some(false) => {\n                     tcx.sess.span_err(begin.span,\n                         \"lower range bound must be less than upper\");\n@@ -516,7 +517,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         debug!(\"(checking match) writing type for pat id {}\", pat.id);\n \n         match sub {\n-          Some(p) => check_pat(pcx, p, expected),\n+          Some(ref p) => check_pat(pcx, &**p, expected),\n           _ => ()\n         }\n       }\n@@ -593,13 +594,13 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         match *s {\n             ty::ty_tup(ref ex_elts) if e_count == ex_elts.len() => {\n                 for (i, elt) in elts.iter().enumerate() {\n-                    check_pat(pcx, *elt, *ex_elts.get(i));\n+                    check_pat(pcx, &**elt, *ex_elts.get(i));\n                 }\n                 fcx.write_ty(pat.id, expected);\n             }\n             _ => {\n                 for elt in elts.iter() {\n-                    check_pat(pcx, *elt, ty::mk_err());\n+                    check_pat(pcx, &**elt, ty::mk_err());\n                 }\n                 // use terr_tuple_size if both types are tuples\n                 let type_error = match *s {\n@@ -627,26 +628,26 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n             }\n         }\n       }\n-      ast::PatBox(inner) => {\n-          check_pointer_pat(pcx, Send, inner, pat.id, pat.span, expected);\n+      ast::PatBox(ref inner) => {\n+          check_pointer_pat(pcx, Send, &**inner, pat.id, pat.span, expected);\n       }\n-      ast::PatRegion(inner) => {\n-          check_pointer_pat(pcx, Borrowed, inner, pat.id, pat.span, expected);\n+      ast::PatRegion(ref inner) => {\n+          check_pointer_pat(pcx, Borrowed, &**inner, pat.id, pat.span, expected);\n       }\n       ast::PatVec(ref before, slice, ref after) => {\n         let default_region_var =\n             fcx.infcx().next_region_var(\n                 infer::PatternRegion(pat.span));\n \n         let check_err = || {\n-            for &elt in before.iter() {\n-                check_pat(pcx, elt, ty::mk_err());\n+            for elt in before.iter() {\n+                check_pat(pcx, &**elt, ty::mk_err());\n             }\n-            for &elt in slice.iter() {\n-                check_pat(pcx, elt, ty::mk_err());\n+            for elt in slice.iter() {\n+                check_pat(pcx, &**elt, ty::mk_err());\n             }\n-            for &elt in after.iter() {\n-                check_pat(pcx, elt, ty::mk_err());\n+            for elt in after.iter() {\n+                check_pat(pcx, &**elt, ty::mk_err());\n             }\n             // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n             fcx.infcx().type_error_message_str_with_expected(\n@@ -697,19 +698,19 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n           }\n         };\n         for elt in before.iter() {\n-            check_pat(pcx, *elt, elt_type);\n+            check_pat(pcx, &**elt, elt_type);\n         }\n         match slice {\n-            Some(slice_pat) => {\n+            Some(ref slice_pat) => {\n                 let slice_ty = ty::mk_slice(tcx,\n                                             region_var,\n                                             ty::mt {ty: elt_type, mutbl: mutbl});\n-                check_pat(pcx, slice_pat, slice_ty);\n+                check_pat(pcx, &**slice_pat, slice_ty);\n             }\n             None => ()\n         }\n         for elt in after.iter() {\n-            check_pat(pcx, *elt, elt_type);\n+            check_pat(pcx, &**elt, elt_type);\n         }\n         fcx.write_ty(pat.id, expected);\n       }\n@@ -718,7 +719,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n     }\n }\n \n-// Helper function to check @, box and & patterns\n+// Helper function to check gc, box and & patterns\n pub fn check_pointer_pat(pcx: &pat_ctxt,\n                          pointer_kind: PointerKind,\n                          inner: &ast::Pat,"}, {"sha": "9eba67ea076f4e9d663b52aa69acf90fd9b17304", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 174, "deletions": 175, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -79,8 +79,6 @@ type parameter).\n \n use middle::const_eval;\n use middle::def;\n-use middle::lang_items::{ExchangeHeapLangItem, GcLangItem};\n-use middle::lang_items::{ManagedHeapLangItem};\n use middle::lint::UnreachableCode;\n use middle::pat_util::pat_id_map;\n use middle::pat_util;\n@@ -121,7 +119,7 @@ use std::cell::{Cell, RefCell};\n use std::collections::HashMap;\n use std::mem::replace;\n use std::rc::Rc;\n-use std::vec::Vec;\n+use std::gc::Gc;\n use syntax::abi;\n use syntax::ast::{Provided, Required};\n use syntax::ast;\n@@ -382,11 +380,11 @@ impl<'a> Visitor<()> for GatherLocalsVisitor<'a> {\n     fn visit_local(&mut self, local: &ast::Local, _: ()) {\n         let o_ty = match local.ty.node {\n             ast::TyInfer => None,\n-            _ => Some(self.fcx.to_ty(local.ty))\n+            _ => Some(self.fcx.to_ty(&*local.ty))\n         };\n         self.assign(local.id, o_ty);\n         debug!(\"Local variable {} is assigned type {}\",\n-               self.fcx.pat_to_str(local.pat),\n+               self.fcx.pat_to_str(&*local.pat),\n                self.fcx.infcx().ty_to_str(\n                    self.fcx.inh.locals.borrow().get_copy(&local.id)));\n         visit::walk_local(self, local, ());\n@@ -478,17 +476,17 @@ fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n         for (arg_ty, input) in arg_tys.iter().zip(decl.inputs.iter()) {\n             // Create type variables for each argument.\n             pat_util::pat_bindings(&tcx.def_map,\n-                                   input.pat,\n+                                   &*input.pat,\n                                    |_bm, pat_id, _sp, _path| {\n                                        visit.assign(pat_id, None);\n                                    });\n \n             // Check the pattern.\n             let pcx = pat_ctxt {\n                 fcx: &fcx,\n-                map: pat_id_map(&tcx.def_map, input.pat),\n+                map: pat_id_map(&tcx.def_map, &*input.pat),\n             };\n-            _match::check_pat(&pcx, input.pat, *arg_ty);\n+            _match::check_pat(&pcx, &*input.pat, *arg_ty);\n         }\n \n         visit.visit_block(body, ());\n@@ -499,11 +497,11 @@ fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n     // We unify the tail expr's type with the\n     // function result type, if there is a tail expr.\n     match body.expr {\n-        Some(tail_expr) => {\n+        Some(ref tail_expr) => {\n             // Special case: we print a special error if there appears\n             // to be do-block/for-loop confusion\n             demand::suptype_with_fn(&fcx, tail_expr.span, false,\n-                fcx.ret_ty, fcx.expr_ty(tail_expr),\n+                fcx.ret_ty, fcx.expr_ty(&**tail_expr),\n                 |sp, e, a, s| {\n                     fcx.report_mismatched_return_types(sp, e, a, s);\n                 });\n@@ -626,7 +624,7 @@ pub fn check_item_sized(ccx: &CrateCtxt, it: &ast::Item) {\n                                       enum_definition.variants.as_slice());\n         }\n         ast::ItemStruct(..) => {\n-            check_fields_sized(ccx.tcx, ccx.tcx.map.expect_struct(it.id));\n+            check_fields_sized(ccx.tcx, &*ccx.tcx.map.expect_struct(it.id));\n         }\n         _ => {}\n     }\n@@ -639,14 +637,14 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n     let _indenter = indenter();\n \n     match it.node {\n-      ast::ItemStatic(_, _, e) => check_const(ccx, it.span, e, it.id),\n+      ast::ItemStatic(_, _, ref e) => check_const(ccx, it.span, &**e, it.id),\n       ast::ItemEnum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n                             enum_definition.variants.as_slice(),\n                             it.id);\n       }\n-      ast::ItemFn(decl, _, _, _, body) => {\n+      ast::ItemFn(ref decl, _, _, _, ref body) => {\n         let fn_tpt = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n \n         let param_env = ty::construct_parameter_environment(\n@@ -658,14 +656,14 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 fn_tpt.generics.region_param_defs.as_slice(),\n                 body.id);\n \n-        check_bare_fn(ccx, decl, body, it.id, fn_tpt.ty, param_env);\n+        check_bare_fn(ccx, &**decl, &**body, it.id, fn_tpt.ty, param_env);\n       }\n       ast::ItemImpl(_, ref opt_trait_ref, _, ref ms) => {\n         debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n \n         let impl_tpt = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n         for m in ms.iter() {\n-            check_method_body(ccx, &impl_tpt.generics, None, *m);\n+            check_method_body(ccx, &impl_tpt.generics, None, &**m);\n         }\n \n         match *opt_trait_ref {\n@@ -694,7 +692,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 }\n                 Provided(m) => {\n                     check_method_body(ccx, &trait_def.generics,\n-                                      Some(trait_def.trait_ref.clone()), m);\n+                                      Some(trait_def.trait_ref.clone()), &*m);\n                 }\n             }\n         }\n@@ -709,7 +707,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n       ast::ItemForeignMod(ref m) => {\n         if m.abi == abi::RustIntrinsic {\n             for item in m.items.iter() {\n-                check_intrinsic_type(ccx, *item);\n+                check_intrinsic_type(ccx, &**item);\n             }\n         } else {\n             for item in m.items.iter() {\n@@ -770,15 +768,15 @@ fn check_method_body(ccx: &CrateCtxt,\n \n     let fty = ty::node_id_to_type(ccx.tcx, method.id);\n \n-    check_bare_fn(ccx, method.decl, method.body, method.id, fty, param_env);\n+    check_bare_fn(ccx, &*method.decl, &*method.body, method.id, fty, param_env);\n }\n \n fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n                                     impl_span: Span,\n                                     impl_generics: &ty::Generics,\n                                     ast_trait_ref: &ast::TraitRef,\n                                     impl_trait_ref: &ty::TraitRef,\n-                                    impl_methods: &[@ast::Method]) {\n+                                    impl_methods: &[Gc<ast::Method>]) {\n     // Locate trait methods\n     let tcx = ccx.tcx;\n     let trait_methods = ty::trait_methods(tcx, impl_trait_ref.def_id);\n@@ -1356,9 +1354,9 @@ pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: ty::t,\n /// Attempts to resolve a call expression as an overloaded call.\n fn try_overloaded_call(fcx: &FnCtxt,\n                        call_expression: &ast::Expr,\n-                       callee: @ast::Expr,\n+                       callee: Gc<ast::Expr>,\n                        callee_type: ty::t,\n-                       args: &[@ast::Expr])\n+                       args: &[Gc<ast::Expr>])\n                        -> bool {\n     // Try `FnOnce`, then `FnMut`, then `Fn`.\n     for &(maybe_function_trait, method_name) in [\n@@ -1454,7 +1452,7 @@ fn check_method_argument_types(fcx: &FnCtxt,\n                                sp: Span,\n                                method_fn_ty: ty::t,\n                                callee_expr: &ast::Expr,\n-                               args: &[@ast::Expr],\n+                               args: &[Gc<ast::Expr>],\n                                deref_args: DerefArgs,\n                                tuple_arguments: TupleArgumentsFlag)\n                                -> ty::t {\n@@ -1501,7 +1499,7 @@ fn check_argument_types(fcx: &FnCtxt,\n                         sp: Span,\n                         fn_inputs: &[ty::t],\n                         callee_expr: &ast::Expr,\n-                        args: &[@ast::Expr],\n+                        args: &[Gc<ast::Expr>],\n                         deref_args: DerefArgs,\n                         variadic: bool,\n                         tuple_arguments: TupleArgumentsFlag) {\n@@ -1654,7 +1652,7 @@ fn check_argument_types(fcx: &FnCtxt,\n                     DontDerefArgs => {}\n                 }\n \n-                check_expr_coercable_to_type(fcx, *arg, formal_ty);\n+                check_expr_coercable_to_type(fcx, &**arg, formal_ty);\n \n             }\n         }\n@@ -1664,11 +1662,12 @@ fn check_argument_types(fcx: &FnCtxt,\n     // arguments which we skipped above.\n     if variadic {\n         for arg in args.iter().skip(expected_arg_count) {\n-            check_expr(fcx, *arg);\n+            check_expr(fcx, &**arg);\n \n             // There are a few types which get autopromoted when passed via varargs\n             // in C but we just error out instead and require explicit casts.\n-            let arg_ty = structurally_resolved_type(fcx, arg.span, fcx.expr_ty(*arg));\n+            let arg_ty = structurally_resolved_type(fcx, arg.span,\n+                                                    fcx.expr_ty(&**arg));\n             match ty::get(arg_ty).sty {\n                 ty::ty_float(ast::TyF32) => {\n                     fcx.type_error_message(arg.span,\n@@ -2040,7 +2039,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     fn check_call(fcx: &FnCtxt,\n                   call_expr: &ast::Expr,\n                   f: &ast::Expr,\n-                  args: &[@ast::Expr]) {\n+                  args: &[Gc<ast::Expr>]) {\n         // Store the type of `f` as the type of the callee\n         let fn_ty = fcx.expr_ty(f);\n \n@@ -2091,21 +2090,21 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     fn check_method_call(fcx: &FnCtxt,\n                          expr: &ast::Expr,\n                          method_name: ast::SpannedIdent,\n-                         args: &[@ast::Expr],\n+                         args: &[Gc<ast::Expr>],\n                          tps: &[ast::P<ast::Ty>]) {\n-        let rcvr = args[0];\n+        let rcvr = args[0].clone();\n         // We can't know if we need &mut self before we look up the method,\n         // so treat the receiver as mutable just in case - only explicit\n         // overloaded dereferences care about the distinction.\n-        check_expr_with_lvalue_pref(fcx, rcvr, PreferMutLvalue);\n+        check_expr_with_lvalue_pref(fcx, &*rcvr, PreferMutLvalue);\n \n         // no need to check for bot/err -- callee does that\n         let expr_t = structurally_resolved_type(fcx,\n                                                 expr.span,\n-                                                fcx.expr_ty(rcvr));\n+                                                fcx.expr_ty(&*rcvr));\n \n-        let tps = tps.iter().map(|&ast_ty| fcx.to_ty(ast_ty)).collect::<Vec<_>>();\n-        let fn_ty = match method::lookup(fcx, expr, rcvr,\n+        let tps = tps.iter().map(|ast_ty| fcx.to_ty(&**ast_ty)).collect::<Vec<_>>();\n+        let fn_ty = match method::lookup(fcx, expr, &*rcvr,\n                                          method_name.node.name,\n                                          expr_t, tps.as_slice(),\n                                          DontDerefArgs,\n@@ -2136,7 +2135,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 // Check for potential static matches (missing self parameters)\n                 method::lookup(fcx,\n                                expr,\n-                               rcvr,\n+                               &*rcvr,\n                                method_name.node.name,\n                                expr_t,\n                                tps.as_slice(),\n@@ -2166,18 +2165,18 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     fn check_then_else(fcx: &FnCtxt,\n                        cond_expr: &ast::Expr,\n                        then_blk: &ast::Block,\n-                       opt_else_expr: Option<@ast::Expr>,\n+                       opt_else_expr: Option<Gc<ast::Expr>>,\n                        id: ast::NodeId,\n                        sp: Span,\n                        expected: Option<ty::t>) {\n         check_expr_has_type(fcx, cond_expr, ty::mk_bool());\n \n         let branches_ty = match opt_else_expr {\n-            Some(else_expr) => {\n+            Some(ref else_expr) => {\n                 check_block_with_expected(fcx, then_blk, expected);\n                 let then_ty = fcx.node_ty(then_blk.id);\n-                check_expr_with_opt_hint(fcx, else_expr, expected);\n-                let else_ty = fcx.expr_ty(else_expr);\n+                check_expr_with_opt_hint(fcx, &**else_expr, expected);\n+                let else_ty = fcx.expr_ty(&**else_expr);\n                 infer::common_supertype(fcx.infcx(),\n                                         infer::IfExpression(sp),\n                                         true,\n@@ -2207,7 +2206,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         self_t: ty::t,\n                         opname: ast::Name,\n                         trait_did: Option<ast::DefId>,\n-                        args: &[@ast::Expr],\n+                        args: &[Gc<ast::Expr>],\n                         autoderef_receiver: AutoderefReceiverFlag,\n                         unbound_method: ||) -> ty::t {\n         let method = match trait_did {\n@@ -2253,25 +2252,25 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     fn check_binop(fcx: &FnCtxt,\n                    expr: &ast::Expr,\n                    op: ast::BinOp,\n-                   lhs: @ast::Expr,\n-                   rhs: @ast::Expr,\n+                   lhs: Gc<ast::Expr>,\n+                   rhs: Gc<ast::Expr>,\n                    is_binop_assignment: IsBinopAssignment) {\n         let tcx = fcx.ccx.tcx;\n \n         let lvalue_pref = match is_binop_assignment {\n             BinopAssignment => PreferMutLvalue,\n             SimpleBinop => NoPreference\n         };\n-        check_expr_with_lvalue_pref(fcx, lhs, lvalue_pref);\n+        check_expr_with_lvalue_pref(fcx, &*lhs, lvalue_pref);\n \n         // Callee does bot / err checking\n         let lhs_t = structurally_resolved_type(fcx, lhs.span,\n-                                               fcx.expr_ty(lhs));\n+                                               fcx.expr_ty(&*lhs));\n \n         if ty::type_is_integral(lhs_t) && ast_util::is_shift_binop(op) {\n             // Shift is a special case: rhs can be any integral type\n-            check_expr(fcx, rhs);\n-            let rhs_t = fcx.expr_ty(rhs);\n+            check_expr(fcx, &*rhs);\n+            let rhs_t = fcx.expr_ty(&*rhs);\n             require_integral(fcx, rhs.span, rhs_t);\n             fcx.write_ty(expr.id, lhs_t);\n             return;\n@@ -2280,7 +2279,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         if ty::is_binopable(tcx, lhs_t, op) {\n             let tvar = fcx.infcx().next_ty_var();\n             demand::suptype(fcx, expr.span, tvar, lhs_t);\n-            check_expr_has_type(fcx, rhs, tvar);\n+            check_expr_has_type(fcx, &*rhs, tvar);\n \n             let result_t = match op {\n                 ast::BiEq | ast::BiNe | ast::BiLt | ast::BiLe | ast::BiGe |\n@@ -2345,7 +2344,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                    },\n                                    lhs_t,\n                                    None);\n-            check_expr(fcx, rhs);\n+            check_expr(fcx, &*rhs);\n             ty::mk_err()\n         };\n \n@@ -2357,10 +2356,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n     fn check_user_binop(fcx: &FnCtxt,\n                         ex: &ast::Expr,\n-                        lhs_expr: @ast::Expr,\n+                        lhs_expr: Gc<ast::Expr>,\n                         lhs_resolved_t: ty::t,\n                         op: ast::BinOp,\n-                        rhs: @ast::Expr) -> ty::t {\n+                        rhs: Gc<ast::Expr>) -> ty::t {\n         let tcx = fcx.ccx.tcx;\n         let lang = &tcx.lang_items;\n         let (name, trait_did) = match op {\n@@ -2381,7 +2380,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             ast::BiEq => (\"eq\", lang.eq_trait()),\n             ast::BiNe => (\"ne\", lang.eq_trait()),\n             ast::BiAnd | ast::BiOr => {\n-                check_expr(fcx, rhs);\n+                check_expr(fcx, &*rhs);\n                 return ty::mk_err();\n             }\n         };\n@@ -2400,7 +2399,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                        mname: &str,\n                        trait_did: Option<ast::DefId>,\n                        ex: &ast::Expr,\n-                       rhs_expr: @ast::Expr,\n+                       rhs_expr: Gc<ast::Expr>,\n                        rhs_t: ty::t) -> ty::t {\n        lookup_op_method(fcx, ex, rhs_t, token::intern(mname),\n                         trait_did, [rhs_expr], DontAutoderefReceiver, || {\n@@ -2513,7 +2512,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         };\n \n         check_fn(fcx.ccx, inherited_style, &fty_sig,\n-                 decl, id, body, fcx.inh);\n+                 &*decl, id, &*body, fcx.inh);\n     }\n \n \n@@ -2549,7 +2548,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             None => {}\n         }\n \n-        let tps: Vec<ty::t> = tys.iter().map(|&ty| fcx.to_ty(ty)).collect();\n+        let tps: Vec<ty::t> = tys.iter().map(|ty| fcx.to_ty(&**ty)).collect();\n         match method::lookup(fcx,\n                              expr,\n                              base,\n@@ -2647,7 +2646,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             // an error, so we can continue typechecking\n             check_expr_coercable_to_type(\n                     fcx,\n-                    field.expr,\n+                    &*field.expr,\n                     expected_field_type);\n         }\n \n@@ -2688,7 +2687,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                 span: codemap::Span,\n                                 class_id: ast::DefId,\n                                 fields: &[ast::Field],\n-                                base_expr: Option<@ast::Expr>) {\n+                                base_expr: Option<Gc<ast::Expr>>) {\n         let tcx = fcx.ccx.tcx;\n \n         // Look up the number of type parameters and the raw type, and\n@@ -2728,7 +2727,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         match base_expr {\n             None => {}\n             Some(base_expr) => {\n-                check_expr_has_type(fcx, base_expr, struct_type);\n+                check_expr_has_type(fcx, &*base_expr, struct_type);\n                 if ty::type_is_bot(fcx.node_ty(base_expr.id)) {\n                     struct_type = ty::mk_bot();\n                 }\n@@ -2793,8 +2792,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     let mut any_bot = false;\n                     let t: ty::t = fcx.infcx().next_ty_var();\n                     for e in args.iter() {\n-                        check_expr_has_type(fcx, *e, t);\n-                        let arg_t = fcx.expr_ty(*e);\n+                        check_expr_has_type(fcx, &**e, t);\n+                        let arg_t = fcx.expr_ty(&**e);\n                         if ty::type_is_error(arg_t) {\n                             any_error = true;\n                         }\n@@ -2807,29 +2806,29 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     } else if any_bot {\n                         ty::mk_bot()\n                     } else {\n-                        ast_expr_vstore_to_ty(fcx, ev, vst, ||\n+                        ast_expr_vstore_to_ty(fcx, &*ev, vst, ||\n                             ty::mt{ ty: ty::mk_vec(tcx,\n                                                    ty::mt {ty: t, mutbl: mutability},\n                                                    None),\n                                                    mutbl: mutability })\n                     }\n                 }\n-                ast::ExprRepeat(element, count_expr) => {\n-                    check_expr_with_hint(fcx, count_expr, ty::mk_uint());\n-                    let _ = ty::eval_repeat_count(fcx, count_expr);\n+                ast::ExprRepeat(ref element, ref count_expr) => {\n+                    check_expr_with_hint(fcx, &**count_expr, ty::mk_uint());\n+                    let _ = ty::eval_repeat_count(fcx, &**count_expr);\n                     let mutability = match vst {\n                         ast::ExprVstoreMutSlice => ast::MutMutable,\n                         _ => ast::MutImmutable,\n                     };\n                     let t = fcx.infcx().next_ty_var();\n-                    check_expr_has_type(fcx, element, t);\n-                    let arg_t = fcx.expr_ty(element);\n+                    check_expr_has_type(fcx, &**element, t);\n+                    let arg_t = fcx.expr_ty(&**element);\n                     if ty::type_is_error(arg_t) {\n                         ty::mk_err()\n                     } else if ty::type_is_bot(arg_t) {\n                         ty::mk_bot()\n                     } else {\n-                        ast_expr_vstore_to_ty(fcx, ev, vst, ||\n+                        ast_expr_vstore_to_ty(fcx, &*ev, vst, ||\n                             ty::mt{ ty: ty::mk_vec(tcx,\n                                                    ty::mt {ty: t, mutbl: mutability},\n                                                    None),\n@@ -2851,9 +2850,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             fcx.write_ty(id, typ);\n         }\n \n-      ast::ExprBox(place, subexpr) => {\n-          check_expr(fcx, place);\n-          check_expr(fcx, subexpr);\n+      ast::ExprBox(ref place, ref subexpr) => {\n+          check_expr(fcx, &**place);\n+          check_expr(fcx, &**subexpr);\n \n           let mut checked = false;\n           match place.node {\n@@ -2883,15 +2882,15 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n           }\n       }\n \n-      ast::ExprLit(lit) => {\n-        let typ = check_lit(fcx, lit);\n+      ast::ExprLit(ref lit) => {\n+        let typ = check_lit(fcx, &**lit);\n         fcx.write_ty(id, typ);\n       }\n-      ast::ExprBinary(op, lhs, rhs) => {\n-        check_binop(fcx, expr, op, lhs, rhs, SimpleBinop);\n+      ast::ExprBinary(op, ref lhs, ref rhs) => {\n+        check_binop(fcx, expr, op, lhs.clone(), rhs.clone(), SimpleBinop);\n \n-        let lhs_ty = fcx.expr_ty(lhs);\n-        let rhs_ty = fcx.expr_ty(rhs);\n+        let lhs_ty = fcx.expr_ty(&**lhs);\n+        let rhs_ty = fcx.expr_ty(&**rhs);\n         if ty::type_is_error(lhs_ty) ||\n             ty::type_is_error(rhs_ty) {\n             fcx.write_error(id);\n@@ -2901,15 +2900,15 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             fcx.write_bot(id);\n         }\n       }\n-      ast::ExprAssignOp(op, lhs, rhs) => {\n-        check_binop(fcx, expr, op, lhs, rhs, BinopAssignment);\n+      ast::ExprAssignOp(op, ref lhs, ref rhs) => {\n+        check_binop(fcx, expr, op, lhs.clone(), rhs.clone(), BinopAssignment);\n \n-        let lhs_t = fcx.expr_ty(lhs);\n+        let lhs_t = fcx.expr_ty(&**lhs);\n         let result_t = fcx.expr_ty(expr);\n         demand::suptype(fcx, expr.span, result_t, lhs_t);\n \n         let tcx = fcx.tcx();\n-        if !ty::expr_is_lval(tcx, lhs) {\n+        if !ty::expr_is_lval(tcx, &**lhs) {\n             tcx.sess.span_err(lhs.span, \"illegal left-hand side expression\");\n         }\n \n@@ -2921,7 +2920,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             fcx.write_nil(expr.id);\n         }\n       }\n-      ast::ExprUnary(unop, oprnd) => {\n+      ast::ExprUnary(unop, ref oprnd) => {\n         let exp_inner = unpack_expected(fcx, expected, |sty| {\n             match unop {\n                 ast::UnBox | ast::UnUniq => match *sty {\n@@ -2936,8 +2935,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             ast::UnDeref => lvalue_pref,\n             _ => NoPreference\n         };\n-        check_expr_with_opt_hint_and_lvalue_pref(fcx, oprnd, exp_inner, lvalue_pref);\n-        let mut oprnd_t = fcx.expr_ty(oprnd);\n+        check_expr_with_opt_hint_and_lvalue_pref(fcx, &**oprnd, exp_inner, lvalue_pref);\n+        let mut oprnd_t = fcx.expr_ty(&**oprnd);\n         if !ty::type_is_error(oprnd_t) && !ty::type_is_bot(oprnd_t) {\n             match unop {\n                 ast::UnBox => {\n@@ -2952,7 +2951,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         Some(mt) => mt.ty,\n                         None => match try_overloaded_deref(fcx, expr.span,\n                                                            Some(MethodCall::expr(expr.id)),\n-                                                           Some(&*oprnd), oprnd_t, lvalue_pref) {\n+                                                           Some(&**oprnd), oprnd_t, lvalue_pref) {\n                             Some(mt) => mt.ty,\n                             None => {\n                                 let is_newtype = match ty::get(oprnd_t).sty {\n@@ -2987,7 +2986,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                          ty::get(oprnd_t).sty == ty::ty_bool) {\n                         oprnd_t = check_user_unop(fcx, \"!\", \"not\",\n                                                   tcx.lang_items.not_trait(),\n-                                                  expr, oprnd, oprnd_t);\n+                                                  expr, oprnd.clone(), oprnd_t);\n                     }\n                 }\n                 ast::UnNeg => {\n@@ -2997,14 +2996,14 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                          ty::type_is_fp(oprnd_t)) {\n                         oprnd_t = check_user_unop(fcx, \"-\", \"neg\",\n                                                   tcx.lang_items.neg_trait(),\n-                                                  expr, oprnd, oprnd_t);\n+                                                  expr, oprnd.clone(), oprnd_t);\n                     }\n                 }\n             }\n         }\n         fcx.write_ty(id, oprnd_t);\n       }\n-      ast::ExprAddrOf(mutbl, oprnd) => {\n+      ast::ExprAddrOf(mutbl, ref oprnd) => {\n           let hint = unpack_expected(\n               fcx, expected,\n               |sty| match *sty { ty::ty_rptr(_, ref mt) => Some(mt.ty),\n@@ -3013,7 +3012,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             ast::MutMutable => PreferMutLvalue,\n             ast::MutImmutable => NoPreference\n         };\n-        check_expr_with_opt_hint_and_lvalue_pref(fcx, oprnd, hint, lvalue_pref);\n+        check_expr_with_opt_hint_and_lvalue_pref(fcx, &**oprnd, hint, lvalue_pref);\n \n         // Note: at this point, we cannot say what the best lifetime\n         // is to use for resulting pointer.  We want to use the\n@@ -3031,7 +3030,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         let region = fcx.infcx().next_region_var(\n             infer::AddrOfRegion(expr.span));\n \n-        let tm = ty::mt { ty: fcx.expr_ty(oprnd), mutbl: mutbl };\n+        let tm = ty::mt { ty: fcx.expr_ty(&**oprnd), mutbl: mutbl };\n         let oprnd_t = if ty::type_is_error(tm.ty) {\n             ty::mk_err()\n         } else if ty::type_is_bot(tm.ty) {\n@@ -3050,20 +3049,20 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         instantiate_path(fcx, pth, tpt, defn, expr.span, expr.id);\n       }\n       ast::ExprInlineAsm(ref ia) => {\n-          for &(_, input) in ia.inputs.iter() {\n-              check_expr(fcx, input);\n+          for &(_, ref input) in ia.inputs.iter() {\n+              check_expr(fcx, &**input);\n           }\n-          for &(_, out) in ia.outputs.iter() {\n-              check_expr(fcx, out);\n+          for &(_, ref out) in ia.outputs.iter() {\n+              check_expr(fcx, &**out);\n           }\n           fcx.write_nil(id);\n       }\n       ast::ExprMac(_) => tcx.sess.bug(\"unexpanded macro\"),\n       ast::ExprBreak(_) => { fcx.write_bot(id); }\n       ast::ExprAgain(_) => { fcx.write_bot(id); }\n-      ast::ExprRet(expr_opt) => {\n+      ast::ExprRet(ref expr_opt) => {\n         let ret_ty = fcx.ret_ty;\n-        match expr_opt {\n+        match *expr_opt {\n           None => match fcx.mk_eqty(false, infer::Misc(expr.span),\n                                     ret_ty, ty::mk_nil()) {\n             Ok(_) => { /* fall through */ }\n@@ -3073,27 +3072,27 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     \"`return;` in function returning non-nil\");\n             }\n           },\n-          Some(e) => {\n-              check_expr_has_type(fcx, e, ret_ty);\n+          Some(ref e) => {\n+              check_expr_has_type(fcx, &**e, ret_ty);\n           }\n         }\n         fcx.write_bot(id);\n       }\n-      ast::ExprParen(a) => {\n-        check_expr_with_opt_hint_and_lvalue_pref(fcx, a, expected, lvalue_pref);\n-        fcx.write_ty(id, fcx.expr_ty(a));\n+      ast::ExprParen(ref a) => {\n+        check_expr_with_opt_hint_and_lvalue_pref(fcx, &**a, expected, lvalue_pref);\n+        fcx.write_ty(id, fcx.expr_ty(&**a));\n       }\n-      ast::ExprAssign(lhs, rhs) => {\n-        check_expr_with_lvalue_pref(fcx, lhs, PreferMutLvalue);\n+      ast::ExprAssign(ref lhs, ref rhs) => {\n+        check_expr_with_lvalue_pref(fcx, &**lhs, PreferMutLvalue);\n \n         let tcx = fcx.tcx();\n-        if !ty::expr_is_lval(tcx, lhs) {\n+        if !ty::expr_is_lval(tcx, &**lhs) {\n             tcx.sess.span_err(lhs.span, \"illegal left-hand side expression\");\n         }\n \n-        let lhs_ty = fcx.expr_ty(lhs);\n-        check_expr_has_type(fcx, rhs, lhs_ty);\n-        let rhs_ty = fcx.expr_ty(rhs);\n+        let lhs_ty = fcx.expr_ty(&**lhs);\n+        check_expr_has_type(fcx, &**rhs, lhs_ty);\n+        let rhs_ty = fcx.expr_ty(&**rhs);\n \n         if ty::type_is_error(lhs_ty) || ty::type_is_error(rhs_ty) {\n             fcx.write_error(id);\n@@ -3103,14 +3102,14 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             fcx.write_nil(id);\n         }\n       }\n-      ast::ExprIf(cond, then_blk, opt_else_expr) => {\n-        check_then_else(fcx, cond, then_blk, opt_else_expr,\n+      ast::ExprIf(ref cond, ref then_blk, ref opt_else_expr) => {\n+        check_then_else(fcx, &**cond, &**then_blk, opt_else_expr.clone(),\n                         id, expr.span, expected);\n       }\n-      ast::ExprWhile(cond, body) => {\n-        check_expr_has_type(fcx, cond, ty::mk_bool());\n-        check_block_no_value(fcx, body);\n-        let cond_ty = fcx.expr_ty(cond);\n+      ast::ExprWhile(ref cond, ref body) => {\n+        check_expr_has_type(fcx, &**cond, ty::mk_bool());\n+        check_block_no_value(fcx, &**body);\n+        let cond_ty = fcx.expr_ty(&**cond);\n         let body_ty = fcx.node_ty(body.id);\n         if ty::type_is_error(cond_ty) || ty::type_is_error(body_ty) {\n             fcx.write_error(id);\n@@ -3124,54 +3123,54 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       }\n       ast::ExprForLoop(..) =>\n           fail!(\"non-desugared expr_for_loop\"),\n-      ast::ExprLoop(body, _) => {\n-        check_block_no_value(fcx, (body));\n-        if !may_break(tcx, expr.id, body) {\n+      ast::ExprLoop(ref body, _) => {\n+        check_block_no_value(fcx, &**body);\n+        if !may_break(tcx, expr.id, body.clone()) {\n             fcx.write_bot(id);\n         }\n         else {\n             fcx.write_nil(id);\n         }\n       }\n-      ast::ExprMatch(discrim, ref arms) => {\n-        _match::check_match(fcx, expr, discrim, arms.as_slice());\n+      ast::ExprMatch(ref discrim, ref arms) => {\n+        _match::check_match(fcx, expr, &**discrim, arms.as_slice());\n       }\n-      ast::ExprFnBlock(decl, body) => {\n+      ast::ExprFnBlock(ref decl, ref body) => {\n         let region = astconv::opt_ast_region_to_region(fcx,\n                                                        fcx.infcx(),\n                                                        expr.span,\n                                                        &None);\n         check_expr_fn(fcx,\n                       expr,\n                       ty::RegionTraitStore(region, ast::MutMutable),\n-                      decl,\n-                      body,\n+                      &**decl,\n+                      body.clone(),\n                       expected);\n       }\n-      ast::ExprProc(decl, body) => {\n+      ast::ExprProc(ref decl, ref body) => {\n         check_expr_fn(fcx,\n                       expr,\n                       ty::UniqTraitStore,\n-                      decl,\n-                      body,\n+                      &**decl,\n+                      body.clone(),\n                       expected);\n       }\n-      ast::ExprBlock(b) => {\n-        check_block_with_expected(fcx, b, expected);\n+      ast::ExprBlock(ref b) => {\n+        check_block_with_expected(fcx, &**b, expected);\n         fcx.write_ty(id, fcx.node_ty(b.id));\n       }\n-      ast::ExprCall(f, ref args) => {\n+      ast::ExprCall(ref f, ref args) => {\n           // Index expressions need to be handled separately, to inform them\n           // that they appear in call position.\n-          check_expr(fcx, f);\n-          let f_ty = fcx.expr_ty(f);\n+          check_expr(fcx, &**f);\n+          let f_ty = fcx.expr_ty(&**f);\n \n-          if !try_overloaded_call(fcx, expr, f, f_ty, args.as_slice()) {\n-              check_call(fcx, expr, f, args.as_slice());\n+          if !try_overloaded_call(fcx, expr, f.clone(), f_ty, args.as_slice()) {\n+              check_call(fcx, expr, &**f, args.as_slice());\n               let (args_bot, args_err) = args.iter().fold((false, false),\n                  |(rest_bot, rest_err), a| {\n                      // is this not working?\n-                     let a_ty = fcx.expr_ty(*a);\n+                     let a_ty = fcx.expr_ty(&**a);\n                      (rest_bot || ty::type_is_bot(a_ty),\n                       rest_err || ty::type_is_error(a_ty))});\n               if ty::type_is_error(f_ty) || args_err {\n@@ -3184,7 +3183,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       }\n       ast::ExprMethodCall(ident, ref tps, ref args) => {\n         check_method_call(fcx, expr, ident, args.as_slice(), tps.as_slice());\n-        let mut arg_tys = args.iter().map(|a| fcx.expr_ty(*a));\n+        let mut arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n         let (args_bot, args_err) = arg_tys.fold((false, false),\n              |(rest_bot, rest_err), a| {\n               (rest_bot || ty::type_is_bot(a),\n@@ -3195,10 +3194,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             fcx.write_bot(id);\n         }\n       }\n-      ast::ExprCast(e, t) => {\n-        check_expr(fcx, e);\n-        let t_1 = fcx.to_ty(t);\n-        let t_e = fcx.expr_ty(e);\n+      ast::ExprCast(ref e, ref t) => {\n+        check_expr(fcx, &**e);\n+        let t_1 = fcx.to_ty(&**t);\n+        let t_e = fcx.expr_ty(&**e);\n \n         debug!(\"t_1={}\", fcx.infcx().ty_to_str(t_1));\n         debug!(\"t_e={}\", fcx.infcx().ty_to_str(t_e));\n@@ -3297,7 +3296,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                 /* this case is allowed */\n                             }\n                             _ => {\n-                                demand::coerce(fcx, e.span, t_1, e);\n+                                demand::coerce(fcx, e.span, t_1, &**e);\n                             }\n                         }\n                     } else if !(type_is_scalar(fcx,expr.span,t_e)\n@@ -3321,18 +3320,18 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       ast::ExprVec(ref args) => {\n         let t: ty::t = fcx.infcx().next_ty_var();\n         for e in args.iter() {\n-            check_expr_has_type(fcx, *e, t);\n+            check_expr_has_type(fcx, &**e, t);\n         }\n         let typ = ty::mk_vec(tcx, ty::mt {ty: t, mutbl: ast::MutImmutable},\n                              Some(args.len()));\n         fcx.write_ty(id, typ);\n       }\n-      ast::ExprRepeat(element, count_expr) => {\n-        check_expr_with_hint(fcx, count_expr, ty::mk_uint());\n-        let count = ty::eval_repeat_count(fcx, count_expr);\n+      ast::ExprRepeat(ref element, ref count_expr) => {\n+        check_expr_with_hint(fcx, &**count_expr, ty::mk_uint());\n+        let count = ty::eval_repeat_count(fcx, &**count_expr);\n         let t: ty::t = fcx.infcx().next_ty_var();\n-        check_expr_has_type(fcx, element, t);\n-        let element_ty = fcx.expr_ty(element);\n+        check_expr_has_type(fcx, &**element, t);\n+        let element_ty = fcx.expr_ty(&**element);\n         if ty::type_is_error(element_ty) {\n             fcx.write_error(id);\n         }\n@@ -3360,8 +3359,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 Some(ref fs) if i < fs.len() => Some(*fs.get(i)),\n                 _ => None\n             };\n-            check_expr_with_opt_hint(fcx, *e, opt_hint);\n-            let t = fcx.expr_ty(*e);\n+            check_expr_with_opt_hint(fcx, &**e, opt_hint);\n+            let t = fcx.expr_ty(&**e);\n             err_field = err_field || ty::type_is_error(t);\n             bot_field = bot_field || ty::type_is_bot(t);\n             t\n@@ -3393,14 +3392,14 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             }\n         }\n       }\n-      ast::ExprField(base, field, ref tys) => {\n-        check_field(fcx, expr, lvalue_pref, base, field.name, tys.as_slice());\n+      ast::ExprField(ref base, ref field, ref tys) => {\n+        check_field(fcx, expr, lvalue_pref, &**base, field.name, tys.as_slice());\n       }\n-      ast::ExprIndex(base, idx) => {\n-          check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n-          check_expr(fcx, idx);\n-          let raw_base_t = fcx.expr_ty(base);\n-          let idx_t = fcx.expr_ty(idx);\n+      ast::ExprIndex(ref base, ref idx) => {\n+          check_expr_with_lvalue_pref(fcx, &**base, lvalue_pref);\n+          check_expr(fcx, &**idx);\n+          let raw_base_t = fcx.expr_ty(&**base);\n+          let idx_t = fcx.expr_ty(&**idx);\n           if ty::type_is_error(raw_base_t) || ty::type_is_bot(raw_base_t) {\n               fcx.write_ty(id, raw_base_t);\n           } else if ty::type_is_error(idx_t) || ty::type_is_bot(idx_t) {\n@@ -3411,7 +3410,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                           lvalue_pref, |base_t, _| ty::index(base_t));\n               match field_ty {\n                   Some(mt) => {\n-                      check_expr_has_type(fcx, idx, ty::mk_uint());\n+                      check_expr_has_type(fcx, &**idx, ty::mk_uint());\n                       fcx.write_ty(id, mt.ty);\n                       fcx.write_autoderef_adjustment(base.id, autoderefs);\n                   }\n@@ -3424,7 +3423,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                                     resolved,\n                                                     token::intern(\"index\"),\n                                                     tcx.lang_items.index_trait(),\n-                                                    [base, idx],\n+                                                    [base.clone(), idx.clone()],\n                                                     AutoderefReceiver,\n                                                     || {\n                         fcx.type_error_message(expr.span,\n@@ -3488,9 +3487,9 @@ pub fn check_decl_local(fcx: &FnCtxt, local: &ast::Local)  {\n     fcx.write_ty(local.id, t);\n \n     match local.init {\n-        Some(init) => {\n-            check_decl_initializer(fcx, local.id, init);\n-            let init_ty = fcx.expr_ty(init);\n+        Some(ref init) => {\n+            check_decl_initializer(fcx, local.id, &**init);\n+            let init_ty = fcx.expr_ty(&**init);\n             if ty::type_is_error(init_ty) || ty::type_is_bot(init_ty) {\n                 fcx.write_ty(local.id, init_ty);\n             }\n@@ -3500,9 +3499,9 @@ pub fn check_decl_local(fcx: &FnCtxt, local: &ast::Local)  {\n \n     let pcx = pat_ctxt {\n         fcx: fcx,\n-        map: pat_id_map(&tcx.def_map, local.pat),\n+        map: pat_id_map(&tcx.def_map, &*local.pat),\n     };\n-    _match::check_pat(&pcx, local.pat, t);\n+    _match::check_pat(&pcx, &*local.pat, t);\n     let pat_ty = fcx.node_ty(local.pat.id);\n     if ty::type_is_error(pat_ty) || ty::type_is_bot(pat_ty) {\n         fcx.write_ty(local.id, pat_ty);\n@@ -3518,26 +3517,26 @@ pub fn check_stmt(fcx: &FnCtxt, stmt: &ast::Stmt)  {\n         node_id = id;\n         match decl.node {\n           ast::DeclLocal(ref l) => {\n-              check_decl_local(fcx, *l);\n+              check_decl_local(fcx, &**l);\n               let l_t = fcx.node_ty(l.id);\n               saw_bot = saw_bot || ty::type_is_bot(l_t);\n               saw_err = saw_err || ty::type_is_error(l_t);\n           }\n           ast::DeclItem(_) => {/* ignore for now */ }\n         }\n       }\n-      ast::StmtExpr(expr, id) => {\n+      ast::StmtExpr(ref expr, id) => {\n         node_id = id;\n         // Check with expected type of ()\n-        check_expr_has_type(fcx, expr, ty::mk_nil());\n-        let expr_ty = fcx.expr_ty(expr);\n+        check_expr_has_type(fcx, &**expr, ty::mk_nil());\n+        let expr_ty = fcx.expr_ty(&**expr);\n         saw_bot = saw_bot || ty::type_is_bot(expr_ty);\n         saw_err = saw_err || ty::type_is_error(expr_ty);\n       }\n-      ast::StmtSemi(expr, id) => {\n+      ast::StmtSemi(ref expr, id) => {\n         node_id = id;\n-        check_expr(fcx, expr);\n-        let expr_ty = fcx.expr_ty(expr);\n+        check_expr(fcx, &**expr);\n+        let expr_ty = fcx.expr_ty(&**expr);\n         saw_bot |= ty::type_is_bot(expr_ty);\n         saw_err |= ty::type_is_error(expr_ty);\n       }\n@@ -3584,8 +3583,8 @@ pub fn check_block_with_expected(fcx: &FnCtxt,\n         let mut any_bot = false;\n         let mut any_err = false;\n         for s in blk.stmts.iter() {\n-            check_stmt(fcx, *s);\n-            let s_id = ast_util::stmt_id(*s);\n+            check_stmt(fcx, &**s);\n+            let s_id = ast_util::stmt_id(&**s);\n             let s_ty = fcx.node_ty(s_id);\n             if last_was_bot && !warned && match s.node {\n                   ast::StmtDecl(decl, _) => {\n@@ -3632,8 +3631,8 @@ pub fn check_block_with_expected(fcx: &FnCtxt,\n                              e.span,\n                              \"unreachable expression\".to_string());\n             }\n-            check_expr_with_opt_hint(fcx, e, expected);\n-              let ety = fcx.expr_ty(e);\n+            check_expr_with_opt_hint(fcx, &*e, expected);\n+              let ety = fcx.expr_ty(&*e);\n               fcx.write_ty(blk.id, ety);\n               if any_err {\n                   fcx.write_error(blk.id);\n@@ -3793,7 +3792,7 @@ pub fn check_enum_variants_sized(ccx: &CrateCtxt,\n                     }\n                 }\n             },\n-            ast::StructVariantKind(struct_def) => check_fields_sized(ccx.tcx, struct_def),\n+            ast::StructVariantKind(struct_def) => check_fields_sized(ccx.tcx, &*struct_def),\n             _ => {}\n         }\n     }\n@@ -3853,17 +3852,17 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n \n             match v.node.disr_expr {\n                 Some(e) => {\n-                    debug!(\"disr expr, checking {}\", pprust::expr_to_str(e));\n+                    debug!(\"disr expr, checking {}\", pprust::expr_to_str(&*e));\n \n                     let inh = blank_inherited_fields(ccx);\n                     let fcx = blank_fn_ctxt(ccx, &inh, rty, e.id);\n                     let declty = ty::mk_int_var(ccx.tcx, fcx.infcx().next_int_var_id());\n-                    check_const_with_ty(&fcx, e.span, e, declty);\n+                    check_const_with_ty(&fcx, e.span, &*e, declty);\n                     // check_expr (from check_const pass) doesn't guarantee\n                     // that the expression is in a form that eval_const_expr can\n                     // handle, so we may still get an internal compiler error\n \n-                    match const_eval::eval_const_expr_partial(ccx.tcx, e) {\n+                    match const_eval::eval_const_expr_partial(ccx.tcx, &*e) {\n                         Ok(const_eval::const_int(val)) => current_disr_val = val as Disr,\n                         Ok(const_eval::const_uint(val)) => current_disr_val = val as Disr,\n                         Ok(_) => {\n@@ -3898,7 +3897,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n             }\n             disr_vals.push(current_disr_val);\n \n-            let variant_info = Rc::new(VariantInfo::from_ast_variant(ccx.tcx, v,\n+            let variant_info = Rc::new(VariantInfo::from_ast_variant(ccx.tcx, &*v,\n                                                                      current_disr_val));\n             prev_disr_val = Some(current_disr_val);\n \n@@ -4096,7 +4095,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         let mut pushed = false;\n         for (i, ty) in pth.segments.iter()\n                                    .flat_map(|segment| segment.types.iter())\n-                                   .map(|&ast_type| fcx.to_ty(ast_type))\n+                                   .map(|ast_type| fcx.to_ty(&**ast_type))\n                                    .enumerate() {\n             match self_parameter_index {\n                 Some(index) if index == i => {\n@@ -4264,7 +4263,7 @@ pub fn ast_expr_vstore_to_ty(fcx: &FnCtxt,\n pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: ast::P<ast::Block>) -> bool {\n     // First: is there an unlabeled break immediately\n     // inside the loop?\n-    (loop_query(b, |e| {\n+    (loop_query(&*b, |e| {\n         match *e {\n             ast::ExprBreak(_) => true,\n             _ => false"}, {"sha": "93ab492eb3af58d432d0c59a93bf25947ca4c8c3", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 45, "deletions": 42, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -141,6 +141,7 @@ use syntax::visit;\n use syntax::visit::Visitor;\n \n use std::cell::RefCell;\n+use std::gc::Gc;\n \n // If mem categorization results in an error, it's because the type\n // check failed (or will fail, when the error is uncovered and\n@@ -343,16 +344,16 @@ fn visit_block(rcx: &mut Rcx, b: &ast::Block) {\n \n fn visit_arm(rcx: &mut Rcx, arm: &ast::Arm) {\n     // see above\n-    for &p in arm.pats.iter() {\n-        constrain_bindings_in_pat(p, rcx);\n+    for p in arm.pats.iter() {\n+        constrain_bindings_in_pat(&**p, rcx);\n     }\n \n     visit::walk_arm(rcx, arm, ());\n }\n \n fn visit_local(rcx: &mut Rcx, l: &ast::Local) {\n     // see above\n-    constrain_bindings_in_pat(l.pat, rcx);\n+    constrain_bindings_in_pat(&*l.pat, rcx);\n     link_local(rcx, l);\n     visit::walk_local(rcx, l, ());\n }\n@@ -441,9 +442,9 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     }\n \n     match expr.node {\n-        ast::ExprCall(callee, ref args) => {\n+        ast::ExprCall(ref callee, ref args) => {\n             if !has_method_map {\n-                constrain_callee(rcx, callee.id, expr, callee);\n+                constrain_callee(rcx, callee.id, expr, &**callee);\n                 constrain_call(rcx,\n                                Some(callee.id),\n                                expr,\n@@ -462,45 +463,47 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprAssign(lhs, _) => {\n-            adjust_borrow_kind_for_assignment_lhs(rcx, lhs);\n+        ast::ExprAssign(ref lhs, _) => {\n+            adjust_borrow_kind_for_assignment_lhs(rcx, &**lhs);\n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprAssignOp(_, lhs, rhs) => {\n+        ast::ExprAssignOp(_, ref lhs, ref rhs) => {\n             if has_method_map {\n-                constrain_call(rcx, None, expr, Some(lhs), [rhs], true);\n+                constrain_call(rcx, None, expr, Some(lhs.clone()),\n+                               [rhs.clone()], true);\n             }\n \n-            adjust_borrow_kind_for_assignment_lhs(rcx, lhs);\n+            adjust_borrow_kind_for_assignment_lhs(rcx, &**lhs);\n \n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprIndex(lhs, rhs) |\n-        ast::ExprBinary(_, lhs, rhs) if has_method_map => {\n+        ast::ExprIndex(ref lhs, ref rhs) |\n+        ast::ExprBinary(_, ref lhs, ref rhs) if has_method_map => {\n             // As `expr_method_call`, but the call is via an\n             // overloaded op.  Note that we (sadly) currently use an\n             // implicit \"by ref\" sort of passing style here.  This\n             // should be converted to an adjustment!\n-            constrain_call(rcx, None, expr, Some(lhs), [rhs], true);\n+            constrain_call(rcx, None, expr, Some(lhs.clone()),\n+                           [rhs.clone()], true);\n \n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprUnary(_, lhs) if has_method_map => {\n+        ast::ExprUnary(_, ref lhs) if has_method_map => {\n             // As above.\n-            constrain_call(rcx, None, expr, Some(lhs), [], true);\n+            constrain_call(rcx, None, expr, Some(lhs.clone()), [], true);\n \n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprUnary(ast::UnDeref, base) => {\n+        ast::ExprUnary(ast::UnDeref, ref base) => {\n             // For *a, the lifetime of a must enclose the deref\n             let method_call = MethodCall::expr(expr.id);\n             let base_ty = match rcx.fcx.inh.method_map.borrow().find(&method_call) {\n                 Some(method) => {\n-                    constrain_call(rcx, None, expr, Some(base), [], true);\n+                    constrain_call(rcx, None, expr, Some(base.clone()), [], true);\n                     ty::ty_fn_ret(method.ty)\n                 }\n                 None => rcx.resolve_node_type(base.id)\n@@ -516,15 +519,15 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprIndex(vec_expr, _) => {\n+        ast::ExprIndex(ref vec_expr, _) => {\n             // For a[b], the lifetime of a must enclose the deref\n-            let vec_type = rcx.resolve_expr_type_adjusted(vec_expr);\n+            let vec_type = rcx.resolve_expr_type_adjusted(&**vec_expr);\n             constrain_index(rcx, expr, vec_type);\n \n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprCast(source, _) => {\n+        ast::ExprCast(ref source, _) => {\n             // Determine if we are casting `source` to a trait\n             // instance.  If so, we have to be sure that the type of\n             // the source obeys the trait's region bound.\n@@ -543,7 +546,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                 ty::ty_trait(box ty::TyTrait {\n                     store: ty::RegionTraitStore(trait_region, _), ..\n                 }) => {\n-                    let source_ty = rcx.resolve_expr_type_adjusted(source);\n+                    let source_ty = rcx.resolve_expr_type_adjusted(&**source);\n                     constrain_regions_in_type(\n                         rcx,\n                         trait_region,\n@@ -556,8 +559,8 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprAddrOf(m, base) => {\n-            link_addr_of(rcx, expr, m, base);\n+        ast::ExprAddrOf(m, ref base) => {\n+            link_addr_of(rcx, expr, m, &**base);\n \n             // Require that when you write a `&expr` expression, the\n             // resulting pointer has a lifetime that encompasses the\n@@ -572,8 +575,8 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprMatch(discr, ref arms) => {\n-            link_match(rcx, discr, arms.as_slice());\n+        ast::ExprMatch(ref discr, ref arms) => {\n+            link_match(rcx, &**discr, arms.as_slice());\n \n             visit::walk_expr(rcx, expr, ());\n         }\n@@ -582,18 +585,18 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             check_expr_fn_block(rcx, expr, &**body);\n         }\n \n-        ast::ExprLoop(body, _) => {\n+        ast::ExprLoop(ref body, _) => {\n             let repeating_scope = rcx.set_repeating_scope(body.id);\n             visit::walk_expr(rcx, expr, ());\n             rcx.set_repeating_scope(repeating_scope);\n         }\n \n-        ast::ExprWhile(cond, body) => {\n+        ast::ExprWhile(ref cond, ref body) => {\n             let repeating_scope = rcx.set_repeating_scope(cond.id);\n-            rcx.visit_expr(cond, ());\n+            rcx.visit_expr(&**cond, ());\n \n             rcx.set_repeating_scope(body.id);\n-            rcx.visit_block(body, ());\n+            rcx.visit_block(&**body, ());\n \n             rcx.set_repeating_scope(repeating_scope);\n         }\n@@ -785,8 +788,8 @@ fn constrain_call(rcx: &mut Rcx,\n                   // operator\n                   fn_expr_id: Option<ast::NodeId>,\n                   call_expr: &ast::Expr,\n-                  receiver: Option<@ast::Expr>,\n-                  arg_exprs: &[@ast::Expr],\n+                  receiver: Option<Gc<ast::Expr>>,\n+                  arg_exprs: &[Gc<ast::Expr>],\n                   implicitly_ref_args: bool) {\n     //! Invoked on every call site (i.e., normal calls, method calls,\n     //! and overloaded operators). Constrains the regions which appear\n@@ -820,7 +823,7 @@ fn constrain_call(rcx: &mut Rcx,\n     let callee_scope = call_expr.id;\n     let callee_region = ty::ReScope(callee_scope);\n \n-    for &arg_expr in arg_exprs.iter() {\n+    for arg_expr in arg_exprs.iter() {\n         debug!(\"Argument\");\n \n         // ensure that any regions appearing in the argument type are\n@@ -834,17 +837,17 @@ fn constrain_call(rcx: &mut Rcx,\n         // result. modes are going away and the \"DerefArgs\" code\n         // should be ported to use adjustments\n         if implicitly_ref_args {\n-            link_by_ref(rcx, arg_expr, callee_scope);\n+            link_by_ref(rcx, &**arg_expr, callee_scope);\n         }\n     }\n \n     // as loop above, but for receiver\n-    for &r in receiver.iter() {\n+    for r in receiver.iter() {\n         debug!(\"Receiver\");\n         constrain_regions_in_type_of_node(\n             rcx, r.id, callee_region, infer::CallRcvr(r.span));\n         if implicitly_ref_args {\n-            link_by_ref(rcx, r, callee_scope);\n+            link_by_ref(rcx, &**r, callee_scope);\n         }\n     }\n \n@@ -1054,11 +1057,11 @@ fn link_local(rcx: &Rcx, local: &ast::Local) {\n     debug!(\"regionck::for_local()\");\n     let init_expr = match local.init {\n         None => { return; }\n-        Some(expr) => expr,\n+        Some(ref expr) => expr,\n     };\n     let mc = mc::MemCategorizationContext::new(rcx);\n-    let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n-    link_pattern(rcx, mc, discr_cmt, local.pat);\n+    let discr_cmt = ignore_err!(mc.cat_expr(&**init_expr));\n+    link_pattern(rcx, mc, discr_cmt, &*local.pat);\n }\n \n fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n@@ -1073,8 +1076,8 @@ fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n     let discr_cmt = ignore_err!(mc.cat_expr(discr));\n     debug!(\"discr_cmt={}\", discr_cmt.repr(rcx.tcx()));\n     for arm in arms.iter() {\n-        for &root_pat in arm.pats.iter() {\n-            link_pattern(rcx, mc, discr_cmt.clone(), root_pat);\n+        for root_pat in arm.pats.iter() {\n+            link_pattern(rcx, mc, discr_cmt.clone(), &**root_pat);\n         }\n     }\n }\n@@ -1098,8 +1101,8 @@ fn link_pattern(rcx: &Rcx,\n                 }\n \n                 // `[_, ..slice, _]` pattern\n-                ast::PatVec(_, Some(slice_pat), _) => {\n-                    match mc.cat_slice_pattern(sub_cmt, slice_pat) {\n+                ast::PatVec(_, Some(ref slice_pat), _) => {\n+                    match mc.cat_slice_pattern(sub_cmt, &**slice_pat) {\n                         Ok((slice_cmt, slice_mutbl, slice_r)) => {\n                             link_region(rcx, sub_pat.span, slice_r,\n                                         ty::BorrowKind::from_mutbl(slice_mutbl),"}, {"sha": "b4dbccd9bb21dd9b635e564748fa614022018537", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -666,10 +666,10 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n           None => {}\n         }\n       }\n-      ast::ExprCast(src, _) => {\n+      ast::ExprCast(ref src, _) => {\n           debug!(\"vtable resolution on expr {}\", ex.repr(fcx.tcx()));\n           let target_ty = fcx.expr_ty(ex);\n-          resolve_object_cast(src, target_ty);\n+          resolve_object_cast(&**src, target_ty);\n       }\n       _ => ()\n     }"}, {"sha": "d503f8bedb6d8ca72b33a6e5df57c64d3bd27b8d", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -53,10 +53,10 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n     let mut wbcx = WritebackCx::new(fcx);\n     wbcx.visit_block(blk, ());\n     for arg in decl.inputs.iter() {\n-        wbcx.visit_pat(arg.pat, ());\n+        wbcx.visit_pat(&*arg.pat, ());\n \n         // Privacy needs the type for the whole pattern, not just each binding\n-        if !pat_util::pat_is_binding(&fcx.tcx().def_map, arg.pat) {\n+        if !pat_util::pat_is_binding(&fcx.tcx().def_map, &*arg.pat) {\n             wbcx.visit_node_id(ResolvingPattern(arg.pat.span),\n                                arg.pat.id);\n         }"}, {"sha": "d2053760467023a9886059beb74f2b3f904cc3ce", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -211,8 +211,8 @@ impl<'a> visit::Visitor<()> for PrivilegedScopeVisitor<'a> {\n                 // Then visit the module items.\n                 visit::walk_mod(self, module_, ());\n             }\n-            ItemImpl(_, None, ast_ty, _) => {\n-                if !self.cc.ast_type_is_defined_in_local_crate(ast_ty) {\n+            ItemImpl(_, None, ref ast_ty, _) => {\n+                if !self.cc.ast_type_is_defined_in_local_crate(&**ast_ty) {\n                     // This is an error.\n                     let session = &self.cc.crate_context.tcx.sess;\n                     session.span_err(item.span,"}, {"sha": "f1de8ff6daba994454c609f936c581b0dc8bca0d", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -50,6 +50,8 @@ use util::ppaux::Repr;\n \n use std::collections::{HashMap, HashSet};\n use std::rc::Rc;\n+use std::gc::Gc;\n+\n use syntax::abi;\n use syntax::ast::{StaticRegionTyParamBound, OtherRegionTyParamBound};\n use syntax::ast::{TraitTyParamBound, UnboxedFnTyParamBound};\n@@ -117,10 +119,10 @@ impl<'a> AstConv for CrateCtxt<'a> {\n         }\n \n         match self.tcx.map.find(id.node) {\n-            Some(ast_map::NodeItem(item)) => ty_of_item(self, item),\n+            Some(ast_map::NodeItem(item)) => ty_of_item(self, &*item),\n             Some(ast_map::NodeForeignItem(foreign_item)) => {\n                 let abi = self.tcx.map.get_foreign_abi(id.node);\n-                ty_of_foreign_item(self, foreign_item, abi)\n+                ty_of_foreign_item(self, &*foreign_item, abi)\n             }\n             x => {\n                 self.tcx.sess.bug(format!(\"unexpected sort of node \\\n@@ -156,7 +158,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n         let result_ty = match variant.node.kind {\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let rs = ExplicitRscope;\n-                let input_tys: Vec<_> = args.iter().map(|va| ccx.to_ty(&rs, va.ty)).collect();\n+                let input_tys: Vec<_> = args.iter().map(|va| ccx.to_ty(&rs, &*va.ty)).collect();\n                 ty::mk_ctor_fn(tcx, scope, input_tys.as_slice(), enum_ty)\n             }\n \n@@ -170,7 +172,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n                     ty: enum_ty\n                 };\n \n-                convert_struct(ccx, struct_def, tpt, variant.node.id);\n+                convert_struct(ccx, &*struct_def, tpt, variant.node.id);\n \n                 let input_tys: Vec<_> = struct_def.fields.iter().map(\n                     |f| ty::node_id_to_type(ccx.tcx, f.node.id)).collect();\n@@ -205,14 +207,14 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n                                 ty_method_of_trait_method(\n                                     ccx, trait_id, &trait_ty_generics,\n                                     &m.id, &m.ident, &m.explicit_self,\n-                                    &m.generics, &m.fn_style, m.decl)\n+                                    &m.generics, &m.fn_style, &*m.decl)\n                             }\n \n                             &ast::Provided(ref m) => {\n                                 ty_method_of_trait_method(\n                                     ccx, trait_id, &trait_ty_generics,\n                                     &m.id, &m.ident, &m.explicit_self,\n-                                    &m.generics, &m.fn_style, m.decl)\n+                                    &m.generics, &m.fn_style, &*m.decl)\n                             }\n                         });\n \n@@ -454,7 +456,7 @@ pub fn convert_field(ccx: &CrateCtxt,\n                      struct_generics: &ty::Generics,\n                      v: &ast::StructField,\n                      origin: ast::DefId) -> ty::field_ty {\n-    let tt = ccx.to_ty(&ExplicitRscope, v.node.ty);\n+    let tt = ccx.to_ty(&ExplicitRscope, &*v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n     ccx.tcx.tcache.borrow_mut().insert(local_def(v.node.id),\n@@ -485,7 +487,7 @@ pub fn convert_field(ccx: &CrateCtxt,\n \n fn convert_methods(ccx: &CrateCtxt,\n                    container: MethodContainer,\n-                   ms: &[@ast::Method],\n+                   ms: &[Gc<ast::Method>],\n                    untransformed_rcvr_ty: ty::t,\n                    rcvr_ty_generics: &ty::Generics,\n                    rcvr_ast_generics: &ast::Generics,\n@@ -503,7 +505,7 @@ fn convert_methods(ccx: &CrateCtxt,\n                                                          num_rcvr_ty_params);\n         let mty = Rc::new(ty_of_method(ccx,\n                                        container,\n-                                       *m,\n+                                       &**m,\n                                        untransformed_rcvr_ty,\n                                        rcvr_ast_generics,\n                                        rcvr_visibility));\n@@ -542,7 +544,7 @@ fn convert_methods(ccx: &CrateCtxt,\n     {\n         let fty = astconv::ty_of_method(ccx, m.id, m.fn_style,\n                                         untransformed_rcvr_ty,\n-                                        m.explicit_self, m.decl);\n+                                        m.explicit_self, &*m.decl);\n \n         // if the method specifies a visibility, use that, otherwise\n         // inherit the visibility from the impl (so `foo` in `pub impl\n@@ -608,7 +610,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n         },\n         ast::ItemImpl(ref generics, ref opt_trait_ref, selfty, ref ms) => {\n             let ty_generics = ty_generics_for_type(ccx, generics);\n-            let selfty = ccx.to_ty(&ExplicitRscope, selfty);\n+            let selfty = ccx.to_ty(&ExplicitRscope, &*selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n             tcx.tcache.borrow_mut().insert(local_def(it.id),\n@@ -671,13 +673,13 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             // Write the super-struct type, if it exists.\n             match struct_def.super_struct {\n                 Some(ty) => {\n-                    let supserty = ccx.to_ty(&ExplicitRscope, ty);\n+                    let supserty = ccx.to_ty(&ExplicitRscope, &*ty);\n                     write_ty_to_tcx(tcx, it.id, supserty);\n                 },\n                 _ => {},\n             }\n \n-            convert_struct(ccx, struct_def, tpt, it.id);\n+            convert_struct(ccx, &*struct_def, tpt, it.id);\n         },\n         ast::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n@@ -855,7 +857,7 @@ fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> Rc<ty::TraitDef> {\n     }\n \n     match ccx.tcx.map.get(trait_id.node) {\n-        ast_map::NodeItem(item) => trait_def_of_item(ccx, item),\n+        ast_map::NodeItem(item) => trait_def_of_item(ccx, &*item),\n         _ => {\n             ccx.tcx.sess.bug(format!(\"get_trait_def({}): not an item\",\n                                      trait_id.node).as_slice())\n@@ -910,7 +912,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n     }\n     match it.node {\n         ast::ItemStatic(t, _, _) => {\n-            let typ = ccx.to_ty(&ExplicitRscope, t);\n+            let typ = ccx.to_ty(&ExplicitRscope, &*t);\n             let tpt = no_params(typ);\n \n             tcx.tcache.borrow_mut().insert(local_def(it.id), tpt.clone());\n@@ -922,7 +924,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n                                               it.id,\n                                               fn_style,\n                                               abi,\n-                                              decl);\n+                                              &*decl);\n             let tpt = ty_param_bounds_and_ty {\n                 generics: ty_generics,\n                 ty: ty::mk_bare_fn(ccx.tcx, tofd)\n@@ -942,7 +944,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             }\n \n             let tpt = {\n-                let ty = ccx.to_ty(&ExplicitRscope, t);\n+                let ty = ccx.to_ty(&ExplicitRscope, &*t);\n                 ty_param_bounds_and_ty {\n                     generics: ty_generics_for_type(ccx, generics),\n                     ty: ty\n@@ -992,7 +994,7 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n     match it.node {\n         ast::ForeignItemFn(fn_decl, ref generics) => {\n             ty_of_foreign_fn_decl(ccx,\n-                                  fn_decl,\n+                                  &*fn_decl,\n                                   local_def(it.id),\n                                   generics,\n                                   abi)\n@@ -1003,7 +1005,7 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n                     type_param_defs: Rc::new(Vec::new()),\n                     region_param_defs: Rc::new(Vec::new()),\n                 },\n-                ty: ast_ty_to_ty(ccx, &ExplicitRscope, t)\n+                ty: ast_ty_to_ty(ccx, &ExplicitRscope, &*t)\n             }\n         }\n     }\n@@ -1047,7 +1049,7 @@ fn ty_generics(ccx: &CrateCtxt,\n                                                     param.ident,\n                                                     param.span));\n                 let default = param.default.map(|path| {\n-                    let ty = ast_ty_to_ty(ccx, &ExplicitRscope, path);\n+                    let ty = ast_ty_to_ty(ccx, &ExplicitRscope, &*path);\n                     let cur_idx = param_ty.idx;\n \n                     ty::walk_ty(ty, |t| {\n@@ -1201,7 +1203,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                         .map(|a| ty_of_arg(ccx, &rb, a, None))\n                         .collect();\n \n-    let output_ty = ast_ty_to_ty(ccx, &rb, decl.output);\n+    let output_ty = ast_ty_to_ty(ccx, &rb, &*decl.output);\n \n     let t_fn = ty::mk_bare_fn(\n         ccx.tcx,"}, {"sha": "7c313d53b2c3e414bdd12e68c5bfc1f2b2ff54fb", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -1140,7 +1140,7 @@ impl<'a> Rebuilder<'a> {\n                 }\n                 ref other => other.clone()\n             };\n-            @ast::Ty { id: from.id, node: new_node, span: from.span }\n+            box(GC) ast::Ty { id: from.id, node: new_node, span: from.span }\n         }\n \n         let new_ty_node = match to.node {\n@@ -1155,7 +1155,7 @@ impl<'a> Rebuilder<'a> {\n             }\n             _ => fail!(\"expect ast::TyRptr or ast::TyPath\")\n         };\n-        let new_ty = @ast::Ty {\n+        let new_ty = box(GC) ast::Ty {\n             id: to.id,\n             node: new_ty_node,\n             span: to.span"}, {"sha": "80bc09904ec18817cc91c017afacab26289213f8", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -479,13 +479,13 @@ impl<'a> Visitor<()> for ConstraintContext<'a> {\n                 // `ty::VariantInfo::from_ast_variant()` ourselves\n                 // here, mainly so as to mask the differences between\n                 // struct-like enums and so forth.\n-                for &ast_variant in enum_definition.variants.iter() {\n+                for ast_variant in enum_definition.variants.iter() {\n                     let variant =\n                         ty::VariantInfo::from_ast_variant(tcx,\n-                                                          ast_variant,\n+                                                          &**ast_variant,\n                                                           /*discriminant*/ 0);\n-                    for &arg_ty in variant.args.iter() {\n-                        self.add_constraints_from_ty(arg_ty, self.covariant);\n+                    for arg_ty in variant.args.iter() {\n+                        self.add_constraints_from_ty(*arg_ty, self.covariant);\n                     }\n                 }\n             }"}, {"sha": "3dd056969d665e8983c4e67dec61c78bae702430", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -102,6 +102,6 @@ pub fn block_query(b: ast::P<ast::Block>, p: |&ast::Expr| -> bool) -> bool {\n         p: p,\n         flag: false,\n     };\n-    visit::walk_block(&mut v, b, ());\n+    visit::walk_block(&mut v, &*b, ());\n     return v.flag;\n }"}, {"sha": "251b7ed3c15065ed2877beebc5aee0296b487ba8", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -25,7 +25,7 @@ use middle::ty;\n use middle::typeck;\n \n use std::rc::Rc;\n-use std::string::String;\n+use std::gc::Gc;\n use syntax::abi;\n use syntax::ast_map;\n use syntax::codemap::{Span, Pos};"}, {"sha": "db65939bdfcc7fb182f57c3624d1eb4a0a0364f8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -31,6 +31,7 @@ use rustc::middle::ty;\n \n use std::rc::Rc;\n use std::u32;\n+use std::gc::Gc;\n \n use core;\n use doctree;\n@@ -52,7 +53,7 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for Vec<T> {\n     }\n }\n \n-impl<T: Clean<U>, U> Clean<U> for @T {\n+impl<T: Clean<U>, U> Clean<U> for Gc<T> {\n     fn clean(&self) -> U {\n         (**self).clean()\n     }\n@@ -428,12 +429,12 @@ impl attr::AttrMetaMethods for Attribute {\n             _ => None,\n         }\n     }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [@ast::MetaItem]> { None }\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<ast::MetaItem>]> { None }\n }\n impl<'a> attr::AttrMetaMethods for &'a Attribute {\n     fn name(&self) -> InternedString { (**self).name() }\n     fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [@ast::MetaItem]> { None }\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<ast::MetaItem>]> { None }\n }\n \n #[deriving(Clone, Encodable, Decodable)]\n@@ -864,7 +865,7 @@ pub struct Argument {\n impl Clean<Argument> for ast::Arg {\n     fn clean(&self) -> Argument {\n         Argument {\n-            name: name_from_pat(self.pat),\n+            name: name_from_pat(&*self.pat),\n             type_: (self.ty.clean()),\n             id: self.id\n         }\n@@ -1745,7 +1746,7 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                                                          remaining,\n                                                          b.clone());\n                             let path = syntax::codemap::dummy_spanned(path);\n-                            ret.push(convert(&ast::ViewItemUse(@path)));\n+                            ret.push(convert(&ast::ViewItemUse(box(GC) path)));\n                         }\n                     }\n                     ast::ViewPathSimple(_, _, id) => {\n@@ -1913,8 +1914,8 @@ fn name_from_pat(p: &ast::Pat) -> String {\n         PatStruct(..) => fail!(\"tried to get argument name from pat_struct, \\\n                                 which is not allowed in function arguments\"),\n         PatTup(..) => \"(tuple arg NYI)\".to_string(),\n-        PatBox(p) => name_from_pat(p),\n-        PatRegion(p) => name_from_pat(p),\n+        PatBox(p) => name_from_pat(&*p),\n+        PatRegion(p) => name_from_pat(&*p),\n         PatLit(..) => {\n             warn!(\"tried to get argument name from PatLit, \\\n                   which is silly in function arguments\");"}, {"sha": "c206d203ee8ac35c4d60f91db58feb901d2ebd9a", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -95,7 +95,7 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n     let mut cfg = build_configuration(&sess);\n     for cfg_ in cfgs.move_iter() {\n         let cfg_ = token::intern_and_get_ident(cfg_.as_slice());\n-        cfg.push(@dummy_spanned(ast::MetaWord(cfg_)));\n+        cfg.push(box(GC) dummy_spanned(ast::MetaWord(cfg_)));\n     }\n \n     let krate = phase_1_parse_input(&sess, cfg, &input);\n@@ -128,11 +128,11 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n pub fn run_core(libs: HashSet<Path>, cfgs: Vec<String>, path: &Path)\n                 -> (clean::Crate, CrateAnalysis) {\n     let (ctxt, analysis) = get_ast_and_resolve(path, libs, cfgs);\n-    let ctxt = @ctxt;\n+    let ctxt = box(GC) ctxt;\n     super::ctxtkey.replace(Some(ctxt));\n \n     let krate = {\n-        let mut v = RustdocVisitor::new(ctxt, Some(&analysis));\n+        let mut v = RustdocVisitor::new(&*ctxt, Some(&analysis));\n         v.visit(&ctxt.krate);\n         v.clean()\n     };"}, {"sha": "b8a2a6195b7a539ab09507485823bc492960c544", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -16,6 +16,8 @@ use syntax::codemap::Span;\n use syntax::ast;\n use syntax::ast::{Ident, NodeId};\n \n+use std::gc::Gc;\n+\n pub struct Module {\n     pub name: Option<Ident>,\n     pub attrs: Vec<ast::Attribute>,\n@@ -133,7 +135,7 @@ pub struct Typedef {\n pub struct Static {\n     pub type_: ast::P<ast::Ty>,\n     pub mutability: ast::Mutability,\n-    pub expr: @ast::Expr,\n+    pub expr: Gc<ast::Expr>,\n     pub name: Ident,\n     pub attrs: Vec<ast::Attribute>,\n     pub vis: ast::Visibility,\n@@ -156,7 +158,7 @@ pub struct Impl {\n     pub generics: ast::Generics,\n     pub trait_: Option<ast::TraitRef>,\n     pub for_: ast::P<ast::Ty>,\n-    pub methods: Vec<@ast::Method>,\n+    pub methods: Vec<Gc<ast::Method>>,\n     pub attrs: Vec<ast::Attribute>,\n     pub where: Span,\n     pub vis: ast::Visibility,"}, {"sha": "e2222799e928242ba10ff0a06b3b93d0da867848", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -37,6 +37,7 @@ extern crate log;\n use std::io;\n use std::io::{File, MemWriter};\n use std::str;\n+use std::gc::Gc;\n use serialize::{json, Decodable, Encodable};\n \n // reexported from `clean` so it can be easily updated with the mod itself\n@@ -85,7 +86,7 @@ static DEFAULT_PASSES: &'static [&'static str] = &[\n     \"unindent-comments\",\n ];\n \n-local_data_key!(pub ctxtkey: @core::DocContext)\n+local_data_key!(pub ctxtkey: Gc<core::DocContext>)\n local_data_key!(pub analysiskey: core::CrateAnalysis)\n \n type Output = (clean::Crate, Vec<plugins::PluginJson> );"}, {"sha": "3b19dc3d0196b4571f643084e11bf9c92318e7c3", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -64,13 +64,13 @@ pub fn run(input: &str,\n     let mut cfg = config::build_configuration(&sess);\n     cfg.extend(cfgs.move_iter().map(|cfg_| {\n         let cfg_ = token::intern_and_get_ident(cfg_.as_slice());\n-        @dummy_spanned(ast::MetaWord(cfg_))\n+        box(GC) dummy_spanned(ast::MetaWord(cfg_))\n     }));\n     let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n     let (krate, _) = driver::phase_2_configure_and_expand(&sess, krate,\n                                                           &from_str(\"rustdoc-test\").unwrap());\n \n-    let ctx = @core::DocContext {\n+    let ctx = box(GC) core::DocContext {\n         krate: krate,\n         maybe_typed: core::NotTyped(sess),\n         src: input_path,\n@@ -82,7 +82,7 @@ pub fn run(input: &str,\n     };\n     super::ctxtkey.replace(Some(ctx));\n \n-    let mut v = RustdocVisitor::new(ctx, None);\n+    let mut v = RustdocVisitor::new(&*ctx, None);\n     v.visit(&ctx.krate);\n     let krate = v.clean();\n     let (krate, _) = passes::unindent_comments(krate);"}, {"sha": "555b396b44945e600703f4fd1d5383c66a40bfc4", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -18,6 +18,8 @@ use syntax::ast_map;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n \n+use std::gc::Gc;\n+\n use core;\n use doctree::*;\n \n@@ -54,10 +56,10 @@ impl<'a> RustdocVisitor<'a> {\n         self.module.is_crate = true;\n     }\n \n-    pub fn visit_struct_def(&mut self, item: &ast::Item, sd: @ast::StructDef,\n+    pub fn visit_struct_def(&mut self, item: &ast::Item, sd: Gc<ast::StructDef>,\n                             generics: &ast::Generics) -> Struct {\n         debug!(\"Visiting struct\");\n-        let struct_type = struct_type_from_def(sd);\n+        let struct_type = struct_type_from_def(&*sd);\n         Struct {\n             id: item.id,\n             struct_type: struct_type,\n@@ -125,7 +127,7 @@ impl<'a> RustdocVisitor<'a> {\n         om.vis = vis;\n         om.id = id;\n         for i in m.items.iter() {\n-            self.visit_item(*i, &mut om);\n+            self.visit_item(&**i, &mut om);\n         }\n         om\n     }\n@@ -159,9 +161,9 @@ impl<'a> RustdocVisitor<'a> {\n         om.view_items.push(item);\n     }\n \n-    fn visit_view_path(&mut self, path: @ast::ViewPath,\n+    fn visit_view_path(&mut self, path: Gc<ast::ViewPath>,\n                        om: &mut Module,\n-                       please_inline: bool) -> Option<@ast::ViewPath> {\n+                       please_inline: bool) -> Option<Gc<ast::ViewPath>> {\n         match path.node {\n             ast::ViewPathSimple(_, _, id) => {\n                 if self.resolve_id(id, false, om, please_inline) { return None }\n@@ -175,7 +177,7 @@ impl<'a> RustdocVisitor<'a> {\n                 }\n \n                 if mine.len() == 0 { return None }\n-                return Some(@::syntax::codemap::Spanned {\n+                return Some(box(GC) ::syntax::codemap::Spanned {\n                     node: ast::ViewPathList(p.clone(), mine, b.clone()),\n                     span: path.span,\n                 })\n@@ -213,13 +215,13 @@ impl<'a> RustdocVisitor<'a> {\n                                 self.visit_view_item(vi, om);\n                             }\n                             for i in m.items.iter() {\n-                                self.visit_item(*i, om);\n+                                self.visit_item(&**i, om);\n                             }\n                         }\n                         _ => { fail!(\"glob not mapped to a module\"); }\n                     }\n                 } else {\n-                    self.visit_item(it, om);\n+                    self.visit_item(&*it, om);\n                 }\n                 true\n             }\n@@ -245,8 +247,8 @@ impl<'a> RustdocVisitor<'a> {\n                 om.enums.push(self.visit_enum_def(item, ed, gen)),\n             ast::ItemStruct(sd, ref gen) =>\n                 om.structs.push(self.visit_struct_def(item, sd, gen)),\n-            ast::ItemFn(fd, ref pur, ref abi, ref gen, _) =>\n-                om.fns.push(self.visit_fn(item, fd, pur, abi, gen)),\n+            ast::ItemFn(ref fd, ref pur, ref abi, ref gen, _) =>\n+                om.fns.push(self.visit_fn(item, &**fd, pur, abi, gen)),\n             ast::ItemTy(ty, ref gen) => {\n                 let t = Typedef {\n                     ty: ty,"}, {"sha": "b57920e002c88a2bde79eeebb600d382ff946194", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -19,11 +19,10 @@ collector is task-local so `Gc<T>` is not sendable.\n #![allow(experimental)]\n \n use clone::Clone;\n-use cmp::{TotalOrd, Ord, Ordering, TotalEq, Eq};\n+use cmp::{Ord, PartialOrd, Ordering, Eq, PartialEq};\n use default::Default;\n use fmt;\n-use hash::Hash;\n-use io::Writer;\n+use hash;\n use kinds::marker;\n use ops::Deref;\n use raw;\n@@ -37,11 +36,11 @@ pub struct Gc<T> {\n     #[cfg(stage0)]\n     ptr: @T,\n     #[cfg(not(stage0))]\n-    ptr: *T,\n+    _ptr: *T,\n     marker: marker::NoSend,\n }\n \n-impl<T: 'static> Clone for Gc<T> {\n+impl<T> Clone for Gc<T> {\n     /// Clone the pointer only\n     #[inline]\n     fn clone(&self) -> Gc<T> { *self }\n@@ -54,13 +53,13 @@ impl<T: 'static> Clone for Gc<T> {\n #[cfg(not(test))]\n pub static GC: () = ();\n \n-impl<T: Eq + 'static> Eq for Gc<T> {\n+impl<T: PartialEq + 'static> PartialEq for Gc<T> {\n     #[inline]\n     fn eq(&self, other: &Gc<T>) -> bool { *(*self) == *(*other) }\n     #[inline]\n     fn ne(&self, other: &Gc<T>) -> bool { *(*self) != *(*other) }\n }\n-impl<T: Ord + 'static> Ord for Gc<T> {\n+impl<T: PartialOrd + 'static> PartialOrd for Gc<T> {\n     #[inline]\n     fn lt(&self, other: &Gc<T>) -> bool { *(*self) < *(*other) }\n     #[inline]\n@@ -70,11 +69,11 @@ impl<T: Ord + 'static> Ord for Gc<T> {\n     #[inline]\n     fn gt(&self, other: &Gc<T>) -> bool { *(*self) > *(*other) }\n }\n-impl<T: TotalOrd + 'static> TotalOrd for Gc<T> {\n+impl<T: Ord + 'static> Ord for Gc<T> {\n     #[inline]\n     fn cmp(&self, other: &Gc<T>) -> Ordering { (**self).cmp(&**other) }\n }\n-impl<T: TotalEq + 'static> TotalEq for Gc<T> {}\n+impl<T: Eq + 'static> Eq for Gc<T> {}\n \n impl<T: 'static> Deref<T> for Gc<T> {\n     #[cfg(stage0)]\n@@ -91,7 +90,7 @@ impl<T: Default + 'static> Default for Gc<T> {\n \n impl<T: 'static> raw::Repr<*raw::Box<T>> for Gc<T> {}\n \n-impl<S: Writer, T: Hash<S> + 'static> Hash<S> for Gc<T> {\n+impl<S: hash::Writer, T: hash::Hash<S> + 'static> hash::Hash<S> for Gc<T> {\n     fn hash(&self, s: &mut S) {\n         (**self).hash(s)\n     }"}, {"sha": "7ba517a3aedbdfcc779c53e31ad85b801ccc2fdb", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -113,7 +113,7 @@ pub trait MacResult {\n         None\n     }\n     /// Create a pattern.\n-    fn make_pat(&self) -> Option<@ast::Pat> {\n+    fn make_pat(&self) -> Option<Gc<ast::Pat>> {\n         None\n     }\n \n@@ -143,15 +143,15 @@ impl MacResult for MacExpr {\n }\n /// A convenience type for macros that return a single pattern.\n pub struct MacPat {\n-    p: @ast::Pat\n+    p: Gc<ast::Pat>,\n }\n impl MacPat {\n-    pub fn new(p: @ast::Pat) -> Box<MacResult> {\n+    pub fn new(p: Gc<ast::Pat>) -> Box<MacResult> {\n         box MacPat { p: p } as Box<MacResult>\n     }\n }\n impl MacResult for MacPat {\n-    fn make_pat(&self) -> Option<@ast::Pat> {\n+    fn make_pat(&self) -> Option<Gc<ast::Pat>> {\n         Some(self.p)\n     }\n }\n@@ -212,8 +212,8 @@ impl DummyResult {\n     }\n \n     /// A plain dummy pattern.\n-    pub fn raw_pat(sp: Span) -> @ast::Pat {\n-        @ast::Pat {\n+    pub fn raw_pat(sp: Span) -> Gc<ast::Pat> {\n+        box(GC) ast::Pat {\n             id: ast::DUMMY_NODE_ID,\n             node: ast::PatWild,\n             span: sp,"}, {"sha": "fffaa12fa1f8542442c7a2f4f27a36e77db232ff", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -174,7 +174,7 @@ pub fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n             let value_ident = token::gensym_ident(\"__value\");\n             // this is careful to use src_pat.span so that error\n             // messages point exact at that.\n-            let local = @ast::Local {\n+            let local = box(GC) ast::Local {\n                 ty: fld.cx.ty_infer(src_pat.span),\n                 pat: src_pat,\n                 init: Some(fld.cx.expr_ident(src_pat.span, value_ident)),\n@@ -183,7 +183,8 @@ pub fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n                 source: ast::LocalFor\n             };\n             let local = codemap::respan(src_pat.span, ast::DeclLocal(local));\n-            let local = @codemap::respan(span, ast::StmtDecl(@local, ast::DUMMY_NODE_ID));\n+            let local = box(GC) codemap::respan(span, ast::StmtDecl(box(GC) local,\n+                                                            ast::DUMMY_NODE_ID));\n \n             // { let ...; <src_loop_block> }\n             let block = fld.cx.block(span, vec![local],\n@@ -749,7 +750,7 @@ pub fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n     })\n }\n \n-pub fn expand_pat(p: @ast::Pat, fld: &mut MacroExpander) -> @ast::Pat {\n+pub fn expand_pat(p: Gc<ast::Pat>, fld: &mut MacroExpander) -> Gc<ast::Pat> {\n     let (pth, tts) = match p.node {\n         PatMac(ref mac) => {\n             match mac.node {\n@@ -819,7 +820,7 @@ pub fn expand_pat(p: @ast::Pat, fld: &mut MacroExpander) -> @ast::Pat {\n         fld.fold_pat(marked_after).node.clone();\n     fld.cx.bt_pop();\n \n-    @ast::Pat {\n+    box(GC) ast::Pat {\n         id: ast::DUMMY_NODE_ID,\n         node: fully_expanded,\n         span: p.span,\n@@ -983,7 +984,7 @@ fn mark_expr(expr: Gc<ast::Expr>, m: Mrk) -> Gc<ast::Expr> {\n }\n \n // apply a given mark to the given pattern. Used following the expansion of a macro.\n-fn mark_pat(pat: @ast::Pat, m: Mrk) -> @ast::Pat {\n+fn mark_pat(pat: Gc<ast::Pat>, m: Mrk) -> Gc<ast::Pat> {\n     new_mark_folder(m).fold_pat(pat)\n }\n "}, {"sha": "185924f704cdde120bff5f723fcd79120def3821", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -90,7 +90,7 @@ pub mod rt {\n \n     impl ToSource for Gc<ast::Item> {\n         fn to_source(&self) -> String {\n-            pprust::item_to_str(*self)\n+            pprust::item_to_str(&**self)\n         }\n     }\n \n@@ -128,7 +128,7 @@ pub mod rt {\n \n     impl ToSource for Gc<ast::Expr> {\n         fn to_source(&self) -> String {\n-            pprust::expr_to_str(*self)\n+            pprust::expr_to_str(&**self)\n         }\n     }\n "}, {"sha": "d8c7ffe4db7ac185f22d0973e5758c5785224178", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -187,8 +187,8 @@ pub trait Folder {\n                 })\n             }\n             TyUnboxedFn(ref f) => {\n-                TyUnboxedFn(@UnboxedFnTy {\n-                    decl: self.fold_fn_decl(f.decl),\n+                TyUnboxedFn(box(GC) UnboxedFnTy {\n+                    decl: self.fold_fn_decl(&*f.decl),\n                 })\n             }\n             TyTup(ref tys) => TyTup(tys.iter().map(|&ty| self.fold_ty(ty)).collect()),\n@@ -449,7 +449,7 @@ fn fold_ty_param_bound<T: Folder>(tpb: &TyParamBound, fld: &mut T)\n         StaticRegionTyParamBound => StaticRegionTyParamBound,\n         UnboxedFnTyParamBound(ref unboxed_function_type) => {\n             UnboxedFnTyParamBound(UnboxedFnTy {\n-                decl: fld.fold_fn_decl(unboxed_function_type.decl),\n+                decl: fld.fold_fn_decl(&*unboxed_function_type.decl),\n             })\n         }\n         OtherRegionTyParamBound(s) => OtherRegionTyParamBound(s)"}, {"sha": "8083bf41706d65acea1c25272057b941b2dbdcd5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -277,8 +277,8 @@ fn maybe_append(lhs: Vec<Attribute> , rhs: Option<Vec<Attribute> >)\n struct ParsedItemsAndViewItems {\n     attrs_remaining: Vec<Attribute>,\n     view_items: Vec<ViewItem>,\n-    items: Vec<@Item>,\n-    foreign_items: Vec<@ForeignItem>\n+    items: Vec<Gc<Item>>,\n+    foreign_items: Vec<Gc<ForeignItem>>\n }\n \n /* ident is handled by common.rs */"}, {"sha": "33b7086d7ae63282e660d7aeb2ed258f654efb26", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -1968,7 +1968,7 @@ impl<'a> State<'a> {\n                                          &None,\n                                          ast::NormalFn,\n                                          ast::Many,\n-                                         unboxed_function_type.decl,\n+                                         &*unboxed_function_type.decl,\n                                          None,\n                                          &None,\n                                          None,"}, {"sha": "59771a57dfa50bdfda64b19d89aaccc93aa530d7", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -220,9 +220,9 @@ pub fn walk_trait_ref_helper<E: Clone, V: Visitor<E>>(visitor: &mut V,\n pub fn walk_item<E: Clone, V: Visitor<E>>(visitor: &mut V, item: &Item, env: E) {\n     visitor.visit_ident(item.span, item.ident, env.clone());\n     match item.node {\n-        ItemStatic(typ, _, expr) => {\n-            visitor.visit_ty(&*typ, env.clone());\n-            visitor.visit_expr(&*expr, env);\n+        ItemStatic(ref typ, _, ref expr) => {\n+            visitor.visit_ty(&**typ, env.clone());\n+            visitor.visit_expr(&**expr, env.clone());\n         }\n         ItemFn(declaration, fn_style, abi, ref generics, body) => {\n             visitor.visit_fn(&FkItemFn(item.ident, generics, fn_style, abi),\n@@ -243,9 +243,9 @@ pub fn walk_item<E: Clone, V: Visitor<E>>(visitor: &mut V, item: &Item, env: E)\n                 visitor.visit_foreign_item(&**foreign_item, env.clone())\n             }\n         }\n-        ItemTy(typ, ref type_parameters) => {\n-            visitor.visit_ty(&*typ, env.clone());\n-            visitor.visit_generics(type_parameters, env)\n+        ItemTy(ref typ, ref type_parameters) => {\n+            visitor.visit_ty(&**typ, env.clone());\n+            visitor.visit_generics(type_parameters, env.clone())\n         }\n         ItemEnum(ref enum_definition, ref type_parameters) => {\n             visitor.visit_generics(type_parameters, env.clone());\n@@ -387,9 +387,9 @@ pub fn walk_ty<E: Clone, V: Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n         }\n         TyUnboxedFn(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n-                visitor.visit_ty(argument.ty, env.clone())\n+                visitor.visit_ty(&*argument.ty, env.clone())\n             }\n-            visitor.visit_ty(function_declaration.decl.output, env.clone());\n+            visitor.visit_ty(&*function_declaration.decl.output, env.clone());\n         }\n         TyPath(ref path, ref bounds, id) => {\n             visitor.visit_path(path, id, env.clone());\n@@ -492,7 +492,7 @@ pub fn walk_foreign_item<E: Clone, V: Visitor<E>>(visitor: &mut V,\n             walk_fn_decl(visitor, &**function_declaration, env.clone());\n             visitor.visit_generics(generics, env.clone())\n         }\n-        ForeignItemStatic(typ, _) => visitor.visit_ty(typ, env.clone()),\n+        ForeignItemStatic(ref typ, _) => visitor.visit_ty(&**typ, env.clone()),\n     }\n \n     for attr in foreign_item.attrs.iter() {\n@@ -511,9 +511,9 @@ pub fn walk_ty_param_bounds<E: Clone, V: Visitor<E>>(visitor: &mut V,\n             StaticRegionTyParamBound => {}\n             UnboxedFnTyParamBound(ref function_declaration) => {\n                 for argument in function_declaration.decl.inputs.iter() {\n-                    visitor.visit_ty(argument.ty, env.clone())\n+                    visitor.visit_ty(&*argument.ty, env.clone())\n                 }\n-                visitor.visit_ty(function_declaration.decl.output,\n+                visitor.visit_ty(&*function_declaration.decl.output,\n                                  env.clone());\n             }\n             OtherRegionTyParamBound(..) => {}\n@@ -595,7 +595,7 @@ pub fn walk_ty_method<E: Clone, V: Visitor<E>>(visitor: &mut V,\n         visitor.visit_ty(&*argument_type.ty, env.clone())\n     }\n     visitor.visit_generics(&method_type.generics, env.clone());\n-    visitor.visit_ty(method_type.decl.output, env.clone());\n+    visitor.visit_ty(&*method_type.decl.output, env.clone());\n     for attr in method_type.attrs.iter() {\n         visitor.visit_attribute(attr, env.clone());\n     }\n@@ -634,7 +634,7 @@ pub fn walk_struct_field<E: Clone, V: Visitor<E>>(visitor: &mut V,\n         _ => {}\n     }\n \n-    visitor.visit_ty(struct_field.node.ty, env.clone());\n+    visitor.visit_ty(&*struct_field.node.ty, env.clone());\n \n     for attr in struct_field.node.attrs.iter() {\n         visitor.visit_attribute(attr, env.clone());\n@@ -826,7 +826,7 @@ pub fn walk_arm<E: Clone, V: Visitor<E>>(visitor: &mut V, arm: &Arm, env: E) {\n         visitor.visit_pat(&**pattern, env.clone())\n     }\n     walk_expr_opt(visitor, arm.guard, env.clone());\n-    visitor.visit_expr(arm.body, env.clone());\n+    visitor.visit_expr(&*arm.body, env.clone());\n     for attr in arm.attrs.iter() {\n         visitor.visit_attribute(attr, env.clone());\n     }"}, {"sha": "7baa500ee0d3829b8b0275f71c0d2516dc299f7d", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -17,10 +17,11 @@ use time::precise_time_s;\n use std::os;\n use std::task;\n use std::vec;\n+use std::gc::Gc;\n \n #[deriving(Clone)]\n enum List<T> {\n-    Nil, Cons(T, @List<T>)\n+    Nil, Cons(T, Gc<List<T>>)\n }\n \n enum UniqueList {\n@@ -60,15 +61,15 @@ struct State {\n }\n \n struct r {\n-  _l: @nillist,\n+  _l: Gc<nillist>,\n }\n \n #[unsafe_destructor]\n impl Drop for r {\n     fn drop(&mut self) {}\n }\n \n-fn r(l: @nillist) -> r {\n+fn r(l: Gc<nillist>) -> r {\n     r {\n         _l: l\n     }\n@@ -84,21 +85,22 @@ fn recurse_or_fail(depth: int, st: Option<State>) {\n         let st = match st {\n           None => {\n             State {\n-                managed: @Nil,\n+                managed: box(GC) Nil,\n                 unique: box Nil,\n-                tuple: (@Nil, box Nil),\n-                vec: vec!(@Nil),\n-                res: r(@Nil)\n+                tuple: (box(GC) Nil, box Nil),\n+                vec: vec!(box(GC) Nil),\n+                res: r(box(GC) Nil)\n             }\n           }\n           Some(st) => {\n             State {\n-                managed: @Cons((), st.managed),\n-                unique: box Cons((), @*st.unique),\n-                tuple: (@Cons((), st.tuple.ref0().clone()),\n-                        box Cons((), @*st.tuple.ref1().clone())),\n-                vec: st.vec.clone().append(&[@Cons((), *st.vec.last().unwrap())]),\n-                res: r(@Cons((), st.res._l))\n+                managed: box(GC) Cons((), st.managed),\n+                unique: box Cons((), box(GC) *st.unique),\n+                tuple: (box(GC) Cons((), st.tuple.ref0().clone()),\n+                        box Cons((), box(GC) *st.tuple.ref1().clone())),\n+                vec: st.vec.clone().append(\n+                        &[box(GC) Cons((), *st.vec.last().unwrap())]),\n+                res: r(box(GC) Cons((), st.res._l))\n             }\n           }\n         };"}, {"sha": "2fb1d2ffc9d19db1cdd7d11eda1b3b3cf358a8ed", "filename": "src/test/compile-fail/terr-sorts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Ftest%2Fcompile-fail%2Fterr-sorts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Ftest%2Fcompile-fail%2Fterr-sorts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fterr-sorts.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -19,7 +19,7 @@ type bar = @foo;\n \n fn want_foo(f: foo) {}\n fn have_bar(b: bar) {\n-    want_foo(b); //~ ERROR (expected struct foo but found @-ptr)\n+    want_foo(b); //~ ERROR (expected struct foo but found Gc-ptr)\n }\n \n fn main() {}"}, {"sha": "d07cee79fad0882fabcb52502178bbc4b6e8caa8", "filename": "src/test/run-pass/generic-recursive-tag.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Ftest%2Frun-pass%2Fgeneric-recursive-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Ftest%2Frun-pass%2Fgeneric-recursive-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-recursive-tag.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty FIXME(#14193)\n+\n #![feature(managed_boxes)]\n \n enum list<T> { cons(@T, @list<T>), nil, }"}, {"sha": "a9067ef87ba31ce5587fa1be8710347ccee181d8", "filename": "src/test/run-pass/trait-cast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-cast.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty FIXME(#14193)\n+\n #![feature(managed_boxes)]\n \n // Test cyclic detector when using trait instances."}, {"sha": "f25dfcb94c591fbdc6f16b3eb7febab4beb7c918", "filename": "src/test/run-pass/uniq-cc-generic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs?ref=54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty FIXME(#14193)\n+\n #![feature(managed_boxes)]\n \n use std::cell::RefCell;"}]}