{"sha": "fdcd4a4a45357f11343d5abe9501a35793a6fd57", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkY2Q0YTRhNDUzNTdmMTEzNDNkNWFiZTk1MDFhMzU3OTNhNmZkNTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-10T01:42:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-10T01:42:11Z"}, "message": "Auto merge of #53936 - petrochenkov:2macpre, r=alexcrichton\n\nresolve: Split macro prelude into built-in and user-defined parts\n\nThis is a refactoring that will help to remove `unshadowable_attrs` when https://github.com/rust-lang/rust/pull/53410 lands.\n\nUPDATE: The second commit actually removes `unshadowable_attrs`.", "tree": {"sha": "4955df12077b6eca0786ad0604dc640a80e0255c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4955df12077b6eca0786ad0604dc640a80e0255c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdcd4a4a45357f11343d5abe9501a35793a6fd57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdcd4a4a45357f11343d5abe9501a35793a6fd57", "html_url": "https://github.com/rust-lang/rust/commit/fdcd4a4a45357f11343d5abe9501a35793a6fd57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdcd4a4a45357f11343d5abe9501a35793a6fd57/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "html_url": "https://github.com/rust-lang/rust/commit/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5"}, {"sha": "62c7d78a9a39688e6445aefbd4fe1d051b7a9886", "url": "https://api.github.com/repos/rust-lang/rust/commits/62c7d78a9a39688e6445aefbd4fe1d051b7a9886", "html_url": "https://github.com/rust-lang/rust/commit/62c7d78a9a39688e6445aefbd4fe1d051b7a9886"}], "stats": {"total": 160, "additions": 81, "deletions": 79}, "files": [{"sha": "21c0f13baa4a99bd8cd56fbf5f117c5db7844b5e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdcd4a4a45357f11343d5abe9501a35793a6fd57/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdcd4a4a45357f11343d5abe9501a35793a6fd57/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=fdcd4a4a45357f11343d5abe9501a35793a6fd57", "patch": "@@ -833,7 +833,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                            binding: &'a NameBinding<'a>,\n                            span: Span,\n                            allow_shadowing: bool) {\n-        if self.macro_prelude.insert(name, binding).is_some() && !allow_shadowing {\n+        if self.macro_use_prelude.insert(name, binding).is_some() && !allow_shadowing {\n             let msg = format!(\"`{}` is already in scope\", name);\n             let note =\n                 \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";"}, {"sha": "66f80af363227733a77b5f45114fd7062572705e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fdcd4a4a45357f11343d5abe9501a35793a6fd57/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdcd4a4a45357f11343d5abe9501a35793a6fd57/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=fdcd4a4a45357f11343d5abe9501a35793a6fd57", "patch": "@@ -1278,6 +1278,13 @@ impl<'a> NameBinding<'a> {\n         }\n     }\n \n+    fn macro_kind(&self) -> Option<MacroKind> {\n+        match self.def_ignoring_ambiguity() {\n+            Def::Macro(_, kind) => Some(kind),\n+            _ => None,\n+        }\n+    }\n+\n     fn descr(&self) -> &'static str {\n         if self.is_extern_crate() { \"extern crate\" } else { self.def().kind_name() }\n     }\n@@ -1440,8 +1447,8 @@ pub struct Resolver<'a, 'b: 'a> {\n \n     crate_loader: &'a mut CrateLoader<'b>,\n     macro_names: FxHashSet<Ident>,\n-    macro_prelude: FxHashMap<Name, &'a NameBinding<'a>>,\n-    unshadowable_attrs: FxHashMap<Name, &'a NameBinding<'a>>,\n+    builtin_macros: FxHashMap<Name, &'a NameBinding<'a>>,\n+    macro_use_prelude: FxHashMap<Name, &'a NameBinding<'a>>,\n     pub all_macros: FxHashMap<Name, Def>,\n     macro_map: FxHashMap<DefId, Lrc<SyntaxExtension>>,\n     macro_defs: FxHashMap<Mark, DefId>,\n@@ -1757,8 +1764,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n             crate_loader,\n             macro_names: FxHashSet(),\n-            macro_prelude: FxHashMap(),\n-            unshadowable_attrs: FxHashMap(),\n+            builtin_macros: FxHashMap(),\n+            macro_use_prelude: FxHashMap(),\n             all_macros: FxHashMap(),\n             macro_map: FxHashMap(),\n             invocations,\n@@ -3340,10 +3347,12 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 };\n             }\n         }\n-        let is_global = self.macro_prelude.get(&path[0].name).cloned()\n-            .map(|binding| binding.get_macro(self).kind() == MacroKind::Bang).unwrap_or(false);\n-        if primary_ns != MacroNS && (is_global ||\n-                                     self.macro_names.contains(&path[0].modern())) {\n+        if primary_ns != MacroNS &&\n+           (self.macro_names.contains(&path[0].modern()) ||\n+            self.builtin_macros.get(&path[0].name).cloned()\n+                               .and_then(NameBinding::macro_kind) == Some(MacroKind::Bang) ||\n+            self.macro_use_prelude.get(&path[0].name).cloned()\n+                                  .and_then(NameBinding::macro_kind) == Some(MacroKind::Bang)) {\n             // Return some dummy definition, it's enough for error reporting.\n             return Some(\n                 PathResolution::new(Def::Macro(DefId::local(CRATE_DEF_INDEX), MacroKind::Bang))"}, {"sha": "fe0cb523a1580fea51531358d39d73b7ea7462c1", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 53, "deletions": 52, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/fdcd4a4a45357f11343d5abe9501a35793a6fd57/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdcd4a4a45357f11343d5abe9501a35793a6fd57/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=fdcd4a4a45357f11343d5abe9501a35793a6fd57", "patch": "@@ -214,24 +214,10 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n             vis: ty::Visibility::Invisible,\n             expansion: Mark::root(),\n         });\n-        self.macro_prelude.insert(ident.name, binding);\n-    }\n-\n-    fn add_unshadowable_attr(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>) {\n-        let def_id = DefId {\n-            krate: BUILTIN_MACROS_CRATE,\n-            index: DefIndex::from_array_index(self.macro_map.len(),\n-                                              DefIndexAddressSpace::Low),\n-        };\n-        let kind = ext.kind();\n-        self.macro_map.insert(def_id, ext);\n-        let binding = self.arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Def(Def::Macro(def_id, kind), false),\n-            span: DUMMY_SP,\n-            vis: ty::Visibility::Invisible,\n-            expansion: Mark::root(),\n-        });\n-        self.unshadowable_attrs.insert(ident.name, binding);\n+        if self.builtin_macros.insert(ident.name, binding).is_some() {\n+            self.session.span_err(ident.span,\n+                                  &format!(\"built-in macro `{}` was already defined\", ident));\n+        }\n     }\n \n     fn resolve_imports(&mut self) {\n@@ -249,7 +235,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n                 attr::mark_known(&attrs[i]);\n             }\n \n-            match self.macro_prelude.get(&name).cloned() {\n+            match self.builtin_macros.get(&name).cloned() {\n                 Some(binding) => match *binding.get_macro(self) {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))\n@@ -285,7 +271,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n                     }\n                     let trait_name = traits[j].segments[0].ident.name;\n                     let legacy_name = Symbol::intern(&format!(\"derive_{}\", trait_name));\n-                    if !self.macro_prelude.contains_key(&legacy_name) {\n+                    if !self.builtin_macros.contains_key(&legacy_name) {\n                         continue\n                     }\n                     let span = traits.remove(j).span;\n@@ -490,14 +476,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             return def;\n         }\n \n-        if kind == MacroKind::Attr {\n-            if let Some(ext) = self.unshadowable_attrs.get(&path[0].name) {\n-                return Ok(ext.def());\n-            }\n-        }\n-\n         let legacy_resolution = self.resolve_legacy_scope(\n-            path[0], invoc_id, invocation.parent_legacy_scope.get(), false\n+            path[0], invoc_id, invocation.parent_legacy_scope.get(), false, kind == MacroKind::Attr\n         );\n         let result = if let Some(legacy_binding) = legacy_resolution {\n             Ok(legacy_binding.def())\n@@ -585,14 +565,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         // (Macro NS)\n         // 1. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n         //    (open, not controlled).\n-        // 2. Macro prelude (language, standard library, user-defined legacy plugins lumped into\n-        //    one set) (open, the open part is from macro expansions, not controlled).\n+        // 2. `macro_use` prelude (open, the open part is from macro expansions, not controlled).\n         // 2a. User-defined prelude from macro-use\n         //    (open, the open part is from macro expansions, not controlled).\n-        // 2b. Standard library prelude, currently just a macro-use (closed, controlled)\n-        // 2c. Language prelude, perhaps including builtin attributes\n-        //    (closed, controlled, except for legacy plugins).\n-        // 3. Builtin attributes (closed, controlled).\n+        // 2b. Standard library prelude is currently implemented as `macro-use` (closed, controlled)\n+        // 3. Language prelude: builtin macros (closed, controlled, except for legacy plugins).\n+        // 4. Language prelude: builtin attributes (closed, controlled).\n \n         assert!(ns == TypeNS  || ns == MacroNS);\n         assert!(force || !record_used); // `record_used` implies `force`\n@@ -613,12 +591,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         enum WhereToResolve<'a> {\n             Module(Module<'a>),\n-            MacroPrelude,\n+            MacroUsePrelude,\n+            BuiltinMacros,\n             BuiltinAttrs,\n             ExternPrelude,\n             ToolPrelude,\n             StdLibPrelude,\n-            PrimitiveTypes,\n+            BuiltinTypes,\n         }\n \n         // Go through all the scopes and try to resolve the name.\n@@ -639,8 +618,26 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     self.current_module = orig_current_module;\n                     binding.map(|binding| (binding, FromPrelude(false)))\n                 }\n-                WhereToResolve::MacroPrelude => {\n-                    match self.macro_prelude.get(&ident.name).cloned() {\n+                WhereToResolve::MacroUsePrelude => {\n+                    match self.macro_use_prelude.get(&ident.name).cloned() {\n+                        Some(binding) => {\n+                            let mut result = Ok((binding, FromPrelude(true)));\n+                            // FIXME: Keep some built-in macros working even if they are\n+                            // shadowed by non-attribute macros imported with `macro_use`.\n+                            // We need to come up with some more principled approach instead.\n+                            if is_attr && (ident.name == \"test\" || ident.name == \"bench\") {\n+                                if let Def::Macro(_, MacroKind::Bang) =\n+                                        binding.def_ignoring_ambiguity() {\n+                                    result = Err(Determinacy::Determined);\n+                                }\n+                            }\n+                            result\n+                        }\n+                        None => Err(Determinacy::Determined),\n+                    }\n+                }\n+                WhereToResolve::BuiltinMacros => {\n+                    match self.builtin_macros.get(&ident.name).cloned() {\n                         Some(binding) => Ok((binding, FromPrelude(true))),\n                         None => Err(Determinacy::Determined),\n                     }\n@@ -708,7 +705,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n                     result\n                 }\n-                WhereToResolve::PrimitiveTypes => {\n+                WhereToResolve::BuiltinTypes => {\n                     if let Some(prim_ty) =\n                             self.primitive_type_table.primitive_types.get(&ident.name).cloned() {\n                         let binding = (Def::PrimTy(prim_ty), ty::Visibility::Public,\n@@ -728,19 +725,20 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                             None => {\n                                 use_prelude = !module.no_implicit_prelude;\n                                 if ns == MacroNS {\n-                                    WhereToResolve::MacroPrelude\n+                                    WhereToResolve::MacroUsePrelude\n                                 } else {\n                                     WhereToResolve::ExternPrelude\n                                 }\n                             }\n                         }\n                     }\n-                    WhereToResolve::MacroPrelude => WhereToResolve::BuiltinAttrs,\n+                    WhereToResolve::MacroUsePrelude => WhereToResolve::BuiltinMacros,\n+                    WhereToResolve::BuiltinMacros => WhereToResolve::BuiltinAttrs,\n                     WhereToResolve::BuiltinAttrs => break, // nowhere else to search\n                     WhereToResolve::ExternPrelude => WhereToResolve::ToolPrelude,\n                     WhereToResolve::ToolPrelude => WhereToResolve::StdLibPrelude,\n-                    WhereToResolve::StdLibPrelude => WhereToResolve::PrimitiveTypes,\n-                    WhereToResolve::PrimitiveTypes => break, // nowhere else to search\n+                    WhereToResolve::StdLibPrelude => WhereToResolve::BuiltinTypes,\n+                    WhereToResolve::BuiltinTypes => break, // nowhere else to search\n                 };\n \n                 continue;\n@@ -802,8 +800,16 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                             ident: Ident,\n                             invoc_id: Mark,\n                             invoc_parent_legacy_scope: LegacyScope<'a>,\n-                            record_used: bool)\n+                            record_used: bool,\n+                            is_attr: bool)\n                             -> Option<&'a NameBinding<'a>> {\n+        if is_attr && (ident.name == \"test\" || ident.name == \"bench\") {\n+            // FIXME: Keep some built-in macros working even if they are\n+            // shadowed by user-defined `macro_rules`.\n+            // We need to come up with some more principled approach instead.\n+            return None;\n+        }\n+\n         let ident = ident.modern();\n \n         // This is *the* result, resolution from the scope closest to the resolved identifier.\n@@ -889,7 +895,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             let span = ident.span;\n             let invocation = self.invocations[&invoc_id];\n             let legacy_resolution = self.resolve_legacy_scope(\n-                ident, invoc_id, invocation.parent_legacy_scope.get(), true\n+                ident, invoc_id, invocation.parent_legacy_scope.get(), true, kind == MacroKind::Attr\n             );\n             let resolution = self.resolve_lexical_macro_path_segment(\n                 ident, MacroNS, invoc_id, true, true, kind == MacroKind::Attr, span\n@@ -958,14 +964,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             None\n         // Then check global macros.\n         }.or_else(|| {\n-            // FIXME: get_macro needs an &mut Resolver, can we do it without cloning?\n-            let macro_prelude = self.macro_prelude.clone();\n-            let names = macro_prelude.iter().filter_map(|(name, binding)| {\n-                if binding.get_macro(self).kind() == kind {\n-                    Some(name)\n-                } else {\n-                    None\n-                }\n+            let names = self.builtin_macros.iter().chain(self.macro_use_prelude.iter())\n+                                                  .filter_map(|(name, binding)| {\n+                if binding.macro_kind() == Some(kind) { Some(name) } else { None }\n             });\n             find_best_match_for_name(names, name, None)\n         // Then check modules."}, {"sha": "1ea710097661acf995317889d889a94d084314cc", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdcd4a4a45357f11343d5abe9501a35793a6fd57/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdcd4a4a45357f11343d5abe9501a35793a6fd57/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=fdcd4a4a45357f11343d5abe9501a35793a6fd57", "patch": "@@ -721,7 +721,6 @@ pub trait Resolver {\n     fn visit_ast_fragment_with_placeholders(&mut self, mark: Mark, fragment: &AstFragment,\n                                             derives: &[Mark]);\n     fn add_builtin(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>);\n-    fn add_unshadowable_attr(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>);\n \n     fn resolve_imports(&mut self);\n     // Resolves attribute and derive legacy macros from `#![plugin(..)]`.\n@@ -761,7 +760,6 @@ impl Resolver for DummyResolver {\n     fn visit_ast_fragment_with_placeholders(&mut self, _invoc: Mark, _fragment: &AstFragment,\n                                             _derives: &[Mark]) {}\n     fn add_builtin(&mut self, _ident: ast::Ident, _ext: Lrc<SyntaxExtension>) {}\n-    fn add_unshadowable_attr(&mut self, _ident: ast::Ident, _ext: Lrc<SyntaxExtension>) {}\n \n     fn resolve_imports(&mut self) {}\n     fn find_legacy_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>, _allow_derive: bool)"}, {"sha": "88af4a73a1515a93b58592f3c7628f54050decf7", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fdcd4a4a45357f11343d5abe9501a35793a6fd57/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdcd4a4a45357f11343d5abe9501a35793a6fd57/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=fdcd4a4a45357f11343d5abe9501a35793a6fd57", "patch": "@@ -72,18 +72,6 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n                          enable_quotes: bool) {\n     deriving::register_builtin_derives(resolver);\n \n-    {\n-        let mut register_unshadowable = |name, ext| {\n-            resolver.add_unshadowable_attr(ast::Ident::with_empty_ctxt(name), Lrc::new(ext));\n-        };\n-\n-        register_unshadowable(Symbol::intern(\"test\"),\n-            MultiModifier(Box::new(test::expand_test)));\n-\n-        register_unshadowable(Symbol::intern(\"bench\"),\n-            MultiModifier(Box::new(test::expand_bench)));\n-    }\n-\n     let mut register = |name, ext| {\n         resolver.add_builtin(ast::Ident::with_empty_ctxt(name), Lrc::new(ext));\n     };\n@@ -147,6 +135,8 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n     }\n \n     register(Symbol::intern(\"test_case\"), MultiModifier(Box::new(test_case::expand)));\n+    register(Symbol::intern(\"test\"), MultiModifier(Box::new(test::expand_test)));\n+    register(Symbol::intern(\"bench\"), MultiModifier(Box::new(test::expand_bench)));\n \n     // format_args uses `unstable` things internally.\n     register(Symbol::intern(\"format_args\"),"}, {"sha": "2e94a27838e433bb6b75fe90a5c5bddef6546656", "filename": "src/test/ui/issues/issue-11692-2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdcd4a4a45357f11343d5abe9501a35793a6fd57/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdcd4a4a45357f11343d5abe9501a35793a6fd57/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.rs?ref=fdcd4a4a45357f11343d5abe9501a35793a6fd57", "patch": "@@ -9,6 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    concat!(test!());\n-    //~^ error: cannot find macro `test!` in this scope\n+    concat!(test!()); //~ ERROR `test` can only be used in attributes\n }"}, {"sha": "186c59a61493d68a9863569436759baa8bffea62", "filename": "src/test/ui/issues/issue-11692-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdcd4a4a45357f11343d5abe9501a35793a6fd57/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdcd4a4a45357f11343d5abe9501a35793a6fd57/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.stderr?ref=fdcd4a4a45357f11343d5abe9501a35793a6fd57", "patch": "@@ -1,7 +1,7 @@\n-error: cannot find macro `test!` in this scope\n+error: `test` can only be used in attributes\n   --> $DIR/issue-11692-2.rs:12:13\n    |\n-LL |     concat!(test!());\n+LL |     concat!(test!()); //~ ERROR `test` can only be used in attributes\n    |             ^^^^\n \n error: aborting due to previous error"}, {"sha": "4e24b17bdd5872874cfabd2bb2d1b10b1b89d78c", "filename": "src/test/ui/test-shadowing/test-cant-be-shadowed.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fdcd4a4a45357f11343d5abe9501a35793a6fd57/src%2Ftest%2Fui%2Ftest-shadowing%2Ftest-cant-be-shadowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdcd4a4a45357f11343d5abe9501a35793a6fd57/src%2Ftest%2Fui%2Ftest-shadowing%2Ftest-cant-be-shadowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-shadowing%2Ftest-cant-be-shadowed.rs?ref=fdcd4a4a45357f11343d5abe9501a35793a6fd57", "patch": "@@ -16,3 +16,8 @@\n \n #[test]\n fn foo(){}\n+\n+macro_rules! test { () => () }\n+\n+#[test]\n+fn bar() {}"}]}