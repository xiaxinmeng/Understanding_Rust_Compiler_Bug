{"sha": "2b718e8d9ca6efdccf4d72647cb3d3101e15b7fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiNzE4ZThkOWNhNmVmZGNjZjRkNzI2NDdjYjNkMzEwMWUxNWI3ZmE=", "commit": {"author": {"name": "Trevor Spiteri", "email": "tspiteri@ieee.org", "date": "2020-04-04T12:24:26Z"}, "committer": {"name": "Trevor Spiteri", "email": "tspiteri@ieee.org", "date": "2020-04-04T12:30:33Z"}, "message": "use ManuallyDrop instead of forget inside collections\n\nThis commit changes some usage of mem::forget into mem::ManuallyDrop\nin some Vec, VecDeque, BTreeMap and Box methods.\n\nBefore the commit, the generated IR for some of the methods was\nlonger, and even after optimization, some unwinding artifacts were\nstill present.", "tree": {"sha": "35051115f6fd6fb728e25c6619456a03fed85e83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35051115f6fd6fb728e25c6619456a03fed85e83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b718e8d9ca6efdccf4d72647cb3d3101e15b7fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b718e8d9ca6efdccf4d72647cb3d3101e15b7fa", "html_url": "https://github.com/rust-lang/rust/commit/2b718e8d9ca6efdccf4d72647cb3d3101e15b7fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b718e8d9ca6efdccf4d72647cb3d3101e15b7fa/comments", "author": {"login": "tspiteri", "id": 18604588, "node_id": "MDQ6VXNlcjE4NjA0NTg4", "avatar_url": "https://avatars.githubusercontent.com/u/18604588?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tspiteri", "html_url": "https://github.com/tspiteri", "followers_url": "https://api.github.com/users/tspiteri/followers", "following_url": "https://api.github.com/users/tspiteri/following{/other_user}", "gists_url": "https://api.github.com/users/tspiteri/gists{/gist_id}", "starred_url": "https://api.github.com/users/tspiteri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tspiteri/subscriptions", "organizations_url": "https://api.github.com/users/tspiteri/orgs", "repos_url": "https://api.github.com/users/tspiteri/repos", "events_url": "https://api.github.com/users/tspiteri/events{/privacy}", "received_events_url": "https://api.github.com/users/tspiteri/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tspiteri", "id": 18604588, "node_id": "MDQ6VXNlcjE4NjA0NTg4", "avatar_url": "https://avatars.githubusercontent.com/u/18604588?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tspiteri", "html_url": "https://github.com/tspiteri", "followers_url": "https://api.github.com/users/tspiteri/followers", "following_url": "https://api.github.com/users/tspiteri/following{/other_user}", "gists_url": "https://api.github.com/users/tspiteri/gists{/gist_id}", "starred_url": "https://api.github.com/users/tspiteri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tspiteri/subscriptions", "organizations_url": "https://api.github.com/users/tspiteri/orgs", "repos_url": "https://api.github.com/users/tspiteri/repos", "events_url": "https://api.github.com/users/tspiteri/events{/privacy}", "received_events_url": "https://api.github.com/users/tspiteri/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b521f57735663de9373679cf8c6502622036bf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b521f57735663de9373679cf8c6502622036bf1", "html_url": "https://github.com/rust-lang/rust/commit/1b521f57735663de9373679cf8c6502622036bf1"}], "stats": {"total": 72, "additions": 34, "deletions": 38}, "files": [{"sha": "db7420954a0918d11dfa944403d48df0c0f04570", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b718e8d9ca6efdccf4d72647cb3d3101e15b7fa/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b718e8d9ca6efdccf4d72647cb3d3101e15b7fa/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=2b718e8d9ca6efdccf4d72647cb3d3101e15b7fa", "patch": "@@ -469,8 +469,8 @@ impl<T: ?Sized> Box<T> {\n     #[inline]\n     #[doc(hidden)]\n     pub fn into_unique(b: Box<T>) -> Unique<T> {\n+        let b = mem::ManuallyDrop::new(b);\n         let mut unique = b.0;\n-        mem::forget(b);\n         // Box is kind-of a library type, but recognized as a \"unique pointer\" by\n         // Stacked Borrows.  This function here corresponds to \"reborrowing to\n         // a raw pointer\", but there is no actual reborrow here -- so"}, {"sha": "36770ee416cb96b76b77504ec2324b3a53a47c9e", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2b718e8d9ca6efdccf4d72647cb3d3101e15b7fa/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b718e8d9ca6efdccf4d72647cb3d3101e15b7fa/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=2b718e8d9ca6efdccf4d72647cb3d3101e15b7fa", "patch": "@@ -4,9 +4,10 @@ use core::fmt::Debug;\n use core::hash::{Hash, Hasher};\n use core::iter::{FromIterator, FusedIterator, Peekable};\n use core::marker::PhantomData;\n+use core::mem::{self, ManuallyDrop};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, RangeBounds};\n-use core::{fmt, mem, ptr};\n+use core::{fmt, ptr};\n \n use super::node::{self, marker, ForceResult::*, Handle, InsertResult::*, NodeRef};\n use super::search::{self, SearchResult::*};\n@@ -190,9 +191,9 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                             // We can't destructure subtree directly\n                             // because BTreeMap implements Drop\n                             let (subroot, sublength) = unsafe {\n+                                let subtree = ManuallyDrop::new(subtree);\n                                 let root = ptr::read(&subtree.root);\n                                 let length = subtree.length;\n-                                mem::forget(subtree);\n                                 (root, length)\n                             };\n \n@@ -1515,15 +1516,14 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n     type IntoIter = IntoIter<K, V>;\n \n     fn into_iter(self) -> IntoIter<K, V> {\n-        if self.root.is_none() {\n-            mem::forget(self);\n+        let me = ManuallyDrop::new(self);\n+        if me.root.is_none() {\n             return IntoIter { front: None, back: None, length: 0 };\n         }\n \n-        let root1 = unsafe { unwrap_unchecked(ptr::read(&self.root)).into_ref() };\n-        let root2 = unsafe { unwrap_unchecked(ptr::read(&self.root)).into_ref() };\n-        let len = self.length;\n-        mem::forget(self);\n+        let root1 = unsafe { unwrap_unchecked(ptr::read(&me.root)).into_ref() };\n+        let root2 = unsafe { unwrap_unchecked(ptr::read(&me.root)).into_ref() };\n+        let len = me.length;\n \n         IntoIter {\n             front: Some(root1.first_leaf_edge()),"}, {"sha": "c17a37c7bae12f0fa268f2a2afe3a32692955ded", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2b718e8d9ca6efdccf4d72647cb3d3101e15b7fa/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b718e8d9ca6efdccf4d72647cb3d3101e15b7fa/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=2b718e8d9ca6efdccf4d72647cb3d3101e15b7fa", "patch": "@@ -12,7 +12,7 @@ use core::cmp::{self, Ordering};\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::iter::{once, repeat_with, FromIterator, FusedIterator};\n-use core::mem::{self, replace};\n+use core::mem::{self, replace, ManuallyDrop};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, IndexMut, RangeBounds, Try};\n use core::ptr::{self, NonNull};\n@@ -2898,12 +2898,12 @@ impl<T> From<Vec<T>> for VecDeque<T> {\n     /// This avoids reallocating where possible, but the conditions for that are\n     /// strict, and subject to change, and so shouldn't be relied upon unless the\n     /// `Vec<T>` came from `From<VecDeque<T>>` and hasn't been reallocated.\n-    fn from(mut other: Vec<T>) -> Self {\n+    fn from(other: Vec<T>) -> Self {\n         unsafe {\n+            let mut other = ManuallyDrop::new(other);\n             let other_buf = other.as_mut_ptr();\n             let mut buf = RawVec::from_raw_parts(other_buf, other.capacity());\n             let len = other.len();\n-            mem::forget(other);\n \n             // We need to extend the buf if it's not a power of two, too small\n             // or doesn't have at least one free space\n@@ -2955,16 +2955,15 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n         other.make_contiguous();\n \n         unsafe {\n+            let other = ManuallyDrop::new(other);\n             let buf = other.buf.ptr();\n             let len = other.len();\n             let cap = other.cap();\n \n             if other.head != 0 {\n                 ptr::copy(buf.add(other.tail), buf, len);\n             }\n-            let out = Vec::from_raw_parts(buf, len, cap);\n-            mem::forget(other);\n-            out\n+            Vec::from_raw_parts(buf, len, cap)\n         }\n     }\n }"}, {"sha": "12e32fd9d352c77811c8cb00cf4f7a411eccb566", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2b718e8d9ca6efdccf4d72647cb3d3101e15b7fa/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b718e8d9ca6efdccf4d72647cb3d3101e15b7fa/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=2b718e8d9ca6efdccf4d72647cb3d3101e15b7fa", "patch": "@@ -3,7 +3,7 @@\n \n use core::alloc::MemoryBlock;\n use core::cmp;\n-use core::mem::{self, MaybeUninit};\n+use core::mem::{self, ManuallyDrop, MaybeUninit};\n use core::ops::Drop;\n use core::ptr::{NonNull, Unique};\n use core::slice;\n@@ -112,11 +112,10 @@ impl<T> RawVec<T, Global> {\n     }\n \n     /// Converts a `Box<[T]>` into a `RawVec<T>`.\n-    pub fn from_box(mut slice: Box<[T]>) -> Self {\n+    pub fn from_box(slice: Box<[T]>) -> Self {\n         unsafe {\n-            let result = RawVec::from_raw_parts(slice.as_mut_ptr(), slice.len());\n-            mem::forget(slice);\n-            result\n+            let mut slice = ManuallyDrop::new(slice);\n+            RawVec::from_raw_parts(slice.as_mut_ptr(), slice.len())\n         }\n     }\n }\n@@ -579,11 +578,10 @@ impl<T> RawVec<T, Global> {\n             \"`len` must be smaller than or equal to `self.capacity()`\"\n         );\n \n+        let me = ManuallyDrop::new(self);\n         // NOTE: not calling `capacity()` here; actually using the real `cap` field!\n-        let slice = slice::from_raw_parts_mut(self.ptr() as *mut MaybeUninit<T>, len);\n-        let output = Box::from_raw(slice);\n-        mem::forget(self);\n-        output\n+        let slice = slice::from_raw_parts_mut(me.ptr() as *mut MaybeUninit<T>, len);\n+        Box::from_raw(slice)\n     }\n }\n "}, {"sha": "80574efe06276f21cc53e4ec821c068807316323", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2b718e8d9ca6efdccf4d72647cb3d3101e15b7fa/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b718e8d9ca6efdccf4d72647cb3d3101e15b7fa/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=2b718e8d9ca6efdccf4d72647cb3d3101e15b7fa", "patch": "@@ -66,7 +66,7 @@ use core::hash::{self, Hash};\n use core::intrinsics::{arith_offset, assume};\n use core::iter::{FromIterator, FusedIterator, TrustedLen};\n use core::marker::PhantomData;\n-use core::mem;\n+use core::mem::{self, ManuallyDrop};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{self, Index, IndexMut, RangeBounds};\n use core::ptr::{self, NonNull};\n@@ -392,7 +392,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[unstable(feature = \"vec_into_raw_parts\", reason = \"new API\", issue = \"65816\")]\n     pub fn into_raw_parts(self) -> (*mut T, usize, usize) {\n-        let mut me = mem::ManuallyDrop::new(self);\n+        let mut me = ManuallyDrop::new(self);\n         (me.as_mut_ptr(), me.len(), me.capacity())\n     }\n \n@@ -678,9 +678,9 @@ impl<T> Vec<T> {\n     pub fn into_boxed_slice(mut self) -> Box<[T]> {\n         unsafe {\n             self.shrink_to_fit();\n-            let buf = ptr::read(&self.buf);\n-            let len = self.len();\n-            mem::forget(self);\n+            let me = ManuallyDrop::new(self);\n+            let buf = ptr::read(&me.buf);\n+            let len = me.len();\n             buf.into_box(len).assume_init()\n         }\n     }\n@@ -1949,16 +1949,16 @@ impl<T> IntoIterator for Vec<T> {\n     /// }\n     /// ```\n     #[inline]\n-    fn into_iter(mut self) -> IntoIter<T> {\n+    fn into_iter(self) -> IntoIter<T> {\n         unsafe {\n-            let begin = self.as_mut_ptr();\n+            let mut me = ManuallyDrop::new(self);\n+            let begin = me.as_mut_ptr();\n             let end = if mem::size_of::<T>() == 0 {\n-                arith_offset(begin as *const i8, self.len() as isize) as *const T\n+                arith_offset(begin as *const i8, me.len() as isize) as *const T\n             } else {\n-                begin.add(self.len()) as *const T\n+                begin.add(me.len()) as *const T\n             };\n-            let cap = self.buf.capacity();\n-            mem::forget(self);\n+            let cap = me.buf.capacity();\n             IntoIter {\n                 buf: NonNull::new_unchecked(begin),\n                 phantom: PhantomData,\n@@ -2081,9 +2081,8 @@ impl<T> SpecExtend<T, IntoIter<T>> for Vec<T> {\n         // has not been advanced at all.\n         if iterator.buf.as_ptr() as *const _ == iterator.ptr {\n             unsafe {\n-                let vec = Vec::from_raw_parts(iterator.buf.as_ptr(), iterator.len(), iterator.cap);\n-                mem::forget(iterator);\n-                vec\n+                let it = ManuallyDrop::new(iterator);\n+                Vec::from_raw_parts(it.buf.as_ptr(), it.len(), it.cap)\n             }\n         } else {\n             let mut vector = Vec::new();"}]}