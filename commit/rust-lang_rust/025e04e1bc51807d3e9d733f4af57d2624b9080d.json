{"sha": "025e04e1bc51807d3e9d733f4af57d2624b9080d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyNWUwNGUxYmM1MTgwN2QzZTlkNzMzZjRhZjU3ZDI2MjRiOTA4MGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-17T11:31:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-17T11:31:53Z"}, "message": "Auto merge of #52190 - davidtwco:issue-52028, r=nikomatsakis\n\nhtml5ever in the rustc-perf repository is memory-intensive\n\nPart of #52028. Rebased atop of #51987.\n\nr? @nikomatsakis", "tree": {"sha": "f787e640643c34f057c5a87a3d5c1d1dde4e1647", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f787e640643c34f057c5a87a3d5c1d1dde4e1647"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/025e04e1bc51807d3e9d733f4af57d2624b9080d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/025e04e1bc51807d3e9d733f4af57d2624b9080d", "html_url": "https://github.com/rust-lang/rust/commit/025e04e1bc51807d3e9d733f4af57d2624b9080d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/025e04e1bc51807d3e9d733f4af57d2624b9080d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ddc0cbd56ff1695f24b4f5daa14642bd21e4af0", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ddc0cbd56ff1695f24b4f5daa14642bd21e4af0", "html_url": "https://github.com/rust-lang/rust/commit/2ddc0cbd56ff1695f24b4f5daa14642bd21e4af0"}, {"sha": "8b94d1605be5a73a7e0362d26bdabfeca1250719", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b94d1605be5a73a7e0362d26bdabfeca1250719", "html_url": "https://github.com/rust-lang/rust/commit/8b94d1605be5a73a7e0362d26bdabfeca1250719"}], "stats": {"total": 295, "additions": 174, "deletions": 121}, "files": [{"sha": "617153d5765b9cbb57762805e1229299583adb1a", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 47, "deletions": 9, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/025e04e1bc51807d3e9d733f4af57d2624b9080d/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025e04e1bc51807d3e9d733f4af57d2624b9080d/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=025e04e1bc51807d3e9d733f4af57d2624b9080d", "patch": "@@ -281,10 +281,10 @@ where\n }\n \n impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n-    /// Create a new `rows x columns` matrix, initially empty.\n-    pub fn new(rows: R, _columns: C) -> SparseBitMatrix<R, C> {\n-        SparseBitMatrix {\n-            vector: IndexVec::from_elem_n(SparseBitSet::new(), rows.index()),\n+    /// Create a new empty sparse bit matrix with no rows or columns.\n+    pub fn new() -> Self {\n+        Self {\n+            vector: IndexVec::new(),\n         }\n     }\n \n@@ -293,6 +293,14 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     ///\n     /// Returns true if this changed the matrix, and false otherwise.\n     pub fn add(&mut self, row: R, column: C) -> bool {\n+        debug!(\n+            \"add(row={:?}, column={:?}, current_len={})\",\n+            row,\n+            column,\n+            self.vector.len()\n+        );\n+        self.vector\n+            .ensure_contains_elem(row, || SparseBitSet::new());\n         self.vector[row].insert(column)\n     }\n \n@@ -301,7 +309,7 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     /// if the matrix represents (transitive) reachability, can\n     /// `row` reach `column`?\n     pub fn contains(&self, row: R, column: C) -> bool {\n-        self.vector[row].contains(column)\n+        self.vector.get(row).map_or(false, |r| r.contains(column))\n     }\n \n     /// Add the bits from row `read` to the bits from row `write`,\n@@ -315,16 +323,27 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         let mut changed = false;\n \n         if read != write {\n-            let (bit_set_read, bit_set_write) = self.vector.pick2_mut(read, write);\n+            if self.vector.get(read).is_some() {\n+                self.vector\n+                    .ensure_contains_elem(write, || SparseBitSet::new());\n+                let (bit_set_read, bit_set_write) = self.vector.pick2_mut(read, write);\n \n-            for read_chunk in bit_set_read.chunks() {\n-                changed = changed | bit_set_write.insert_chunk(read_chunk).any();\n+                for read_chunk in bit_set_read.chunks() {\n+                    changed = changed | bit_set_write.insert_chunk(read_chunk).any();\n+                }\n             }\n         }\n \n         changed\n     }\n \n+    /// Merge a row, `from`, into the `into` row.\n+    pub fn merge_into(&mut self, into: R, from: &SparseBitSet<C>) -> bool {\n+        self.vector\n+            .ensure_contains_elem(into, || SparseBitSet::new());\n+        self.vector[into].insert_from(from)\n+    }\n+\n     /// True if `sub` is a subset of `sup`\n     pub fn is_subset(&self, sub: R, sup: R) -> bool {\n         sub == sup || {\n@@ -336,10 +355,20 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         }\n     }\n \n+    /// Number of elements in the matrix.\n+    pub fn len(&self) -> usize {\n+        self.vector.len()\n+    }\n+\n     /// Iterates through all the columns set to true in a given row of\n     /// the matrix.\n     pub fn iter<'a>(&'a self, row: R) -> impl Iterator<Item = C> + 'a {\n-        self.vector[row].iter()\n+        self.vector.get(row).into_iter().flat_map(|r| r.iter())\n+    }\n+\n+    /// Iterates through each row and the accompanying bit set.\n+    pub fn iter_enumerated<'a>(&'a self) -> impl Iterator<Item = (R, &'a SparseBitSet<C>)> + 'a {\n+        self.vector.iter_enumerated()\n     }\n }\n \n@@ -445,6 +474,15 @@ impl<I: Idx> SparseBitSet<I> {\n         }\n     }\n \n+    /// Insert into bit set from another bit set.\n+    pub fn insert_from(&mut self, from: &SparseBitSet<I>) -> bool {\n+        let mut changed = false;\n+        for read_chunk in from.chunks() {\n+            changed = changed | self.insert_chunk(read_chunk).any();\n+        }\n+        changed\n+    }\n+\n     pub fn remove_chunk(&mut self, chunk: SparseChunk<I>) -> SparseChunk<I> {\n         if chunk.bits == 0 {\n             return chunk;"}, {"sha": "e7a75c149ccf03bdfc0ee56311a3603fe3f0ad3d", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/025e04e1bc51807d3e9d733f4af57d2624b9080d/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025e04e1bc51807d3e9d733f4af57d2624b9080d/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=025e04e1bc51807d3e9d733f4af57d2624b9080d", "patch": "@@ -518,10 +518,28 @@ impl<I: Idx, T> IndexVec<I, T> {\n }\n \n impl<I: Idx, T: Clone> IndexVec<I, T> {\n+    /// Grows the index vector so that it contains an entry for\n+    /// `elem`; if that is already true, then has no\n+    /// effect. Otherwise, inserts new values as needed by invoking\n+    /// `fill_value`.\n+    #[inline]\n+    pub fn ensure_contains_elem(&mut self, elem: I, fill_value: impl FnMut() -> T) {\n+        let min_new_len = elem.index() + 1;\n+        if self.len() < min_new_len {\n+            self.raw.resize_with(min_new_len, fill_value);\n+        }\n+    }\n+\n     #[inline]\n     pub fn resize(&mut self, new_len: usize, value: T) {\n         self.raw.resize(new_len, value)\n     }\n+\n+    #[inline]\n+    pub fn resize_to_elem(&mut self, elem: I, fill_value: impl FnMut() -> T) {\n+        let min_new_len = elem.index() + 1;\n+        self.raw.resize_with(min_new_len, fill_value);\n+    }\n }\n \n impl<I: Idx, T: Ord> IndexVec<I, T> {"}, {"sha": "b386f887d77f18a100e48b54a1b20528db56ed1d", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/025e04e1bc51807d3e9d733f4af57d2624b9080d/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025e04e1bc51807d3e9d733f4af57d2624b9080d/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=025e04e1bc51807d3e9d733f4af57d2624b9080d", "patch": "@@ -30,6 +30,7 @@\n #![feature(optin_builtin_traits)]\n #![feature(macro_vis_matcher)]\n #![feature(allow_internal_unstable)]\n+#![feature(vec_resize_with)]\n \n #![cfg_attr(unix, feature(libc))]\n #![cfg_attr(test, feature(test))]"}, {"sha": "f274f8e91894ea3a70ce4498addf130a165b5f98", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/025e04e1bc51807d3e9d733f4af57d2624b9080d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025e04e1bc51807d3e9d733f4af57d2624b9080d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=025e04e1bc51807d3e9d733f4af57d2624b9080d", "patch": "@@ -21,7 +21,6 @@ use rustc::mir::{Local, Statement, Terminator};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, CanonicalTy, ClosureSubsts, GeneratorSubsts};\n-use std::iter;\n \n pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n@@ -30,7 +29,6 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     location_table: &LocationTable,\n     mir: &Mir<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n-    liveness_set_from_typeck: &[(ty::Region<'tcx>, Location)],\n ) {\n     let mut cg = ConstraintGeneration {\n         borrow_set,\n@@ -40,8 +38,6 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n         all_facts,\n     };\n \n-    cg.add_region_liveness_constraints_from_type_check(liveness_set_from_typeck);\n-\n     for (bb, data) in mir.basic_blocks().iter_enumerated() {\n         cg.visit_basic_block_data(bb, data);\n     }\n@@ -189,42 +185,6 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n }\n \n impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n-    /// The MIR type checker generates region liveness constraints\n-    /// that we also have to respect.\n-    fn add_region_liveness_constraints_from_type_check(\n-        &mut self,\n-        liveness_set: &[(ty::Region<'tcx>, Location)],\n-    ) {\n-        debug!(\n-            \"add_region_liveness_constraints_from_type_check(liveness_set={} items)\",\n-            liveness_set.len(),\n-        );\n-\n-        let ConstraintGeneration {\n-            regioncx,\n-            location_table,\n-            all_facts,\n-            ..\n-        } = self;\n-\n-        for (region, location) in liveness_set {\n-            debug!(\"generate: {:#?} is live at {:#?}\", region, location);\n-            let region_vid = regioncx.to_region_vid(region);\n-            regioncx.add_live_element(region_vid, *location);\n-        }\n-\n-        if let Some(all_facts) = all_facts {\n-            all_facts\n-                .region_live_at\n-                .extend(liveness_set.into_iter().flat_map(|(region, location)| {\n-                    let r = regioncx.to_region_vid(region);\n-                    let p1 = location_table.start_index(*location);\n-                    let p2 = location_table.mid_index(*location);\n-                    iter::once((r, p1)).chain(iter::once((r, p2)))\n-                }));\n-        }\n-    }\n-\n     /// Some variable with type `live_ty` is \"regular live\" at\n     /// `location` -- i.e., it may be used later. This means that all\n     /// regions appearing in the type `live_ty` must be live at"}, {"sha": "5fcf46f6903797f33e2a1c3281c8ecc3eef9e4e9", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/025e04e1bc51807d3e9d733f4af57d2624b9080d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025e04e1bc51807d3e9d733f4af57d2624b9080d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=025e04e1bc51807d3e9d733f4af57d2624b9080d", "patch": "@@ -12,6 +12,7 @@ use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::{LocationIndex, LocationTable};\n use borrow_check::nll::facts::AllFactsExt;\n use borrow_check::nll::type_check::MirTypeckRegionConstraints;\n+use borrow_check::nll::region_infer::values::RegionValueElements;\n use dataflow::indexes::BorrowIndex;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n@@ -99,6 +100,8 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         None\n     };\n \n+    let elements = &Rc::new(RegionValueElements::new(mir, universal_regions.len()));\n+\n     // Run the MIR type-checker.\n     let liveness = &LivenessResults::compute(mir);\n     let constraint_sets = type_check::type_check(\n@@ -113,6 +116,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         &mut all_facts,\n         flow_inits,\n         move_data,\n+        elements,\n     );\n \n     if let Some(all_facts) = &mut all_facts {\n@@ -126,7 +130,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     // base constraints generated by the type-check.\n     let var_origins = infcx.take_region_var_origins();\n     let MirTypeckRegionConstraints {\n-        liveness_set,\n+        liveness_constraints,\n         outlives_constraints,\n         type_tests,\n     } = constraint_sets;\n@@ -136,6 +140,8 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         mir,\n         outlives_constraints,\n         type_tests,\n+        liveness_constraints,\n+        elements,\n     );\n \n     // Generate various additional constraints.\n@@ -146,7 +152,6 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         location_table,\n         &mir,\n         borrow_set,\n-        &liveness_set,\n     );\n     invalidation::generate_invalidates(\n         infcx,"}, {"sha": "5159fdc9fbabfbb1147eafa7dcf4a6a868c80a13", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/025e04e1bc51807d3e9d733f4af57d2624b9080d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025e04e1bc51807d3e9d733f4af57d2624b9080d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=025e04e1bc51807d3e9d733f4af57d2624b9080d", "patch": "@@ -37,7 +37,7 @@ mod annotation;\n mod dump_mir;\n mod error_reporting;\n mod graphviz;\n-mod values;\n+pub mod values;\n use self::values::{RegionValueElements, RegionValues};\n \n use super::ToRegionVid;\n@@ -66,8 +66,8 @@ pub struct RegionInferenceContext<'tcx> {\n     /// the SCC (see `constraint_sccs`) and for error reporting.\n     constraint_graph: Rc<ConstraintGraph>,\n \n-    /// The SCC computed from `constraints` and\n-    /// `constraint_graph`. Used to compute the values of each region.\n+    /// The SCC computed from `constraints` and the constraint graph. Used to compute the values\n+    /// of each region.\n     constraint_sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n \n     /// The final inferred values of the region variables; we compute\n@@ -207,15 +207,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(crate) fn new(\n         var_infos: VarInfos,\n         universal_regions: UniversalRegions<'tcx>,\n-        mir: &Mir<'tcx>,\n+        _mir: &Mir<'tcx>,\n         outlives_constraints: ConstraintSet,\n         type_tests: Vec<TypeTest<'tcx>>,\n+        liveness_constraints: RegionValues<RegionVid>,\n+        elements: &Rc<RegionValueElements>,\n     ) -> Self {\n         let universal_regions = Rc::new(universal_regions);\n-        let num_region_variables = var_infos.len();\n-        let num_universal_regions = universal_regions.len();\n-\n-        let elements = &Rc::new(RegionValueElements::new(mir, num_universal_regions));\n \n         // Create a RegionDefinition for each inference variable.\n         let definitions: IndexVec<_, _> = var_infos\n@@ -227,15 +225,20 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let constraint_graph = Rc::new(constraints.graph(definitions.len()));\n         let constraint_sccs = Rc::new(constraints.compute_sccs(&constraint_graph));\n \n-        let scc_values = RegionValues::new(elements, constraint_sccs.num_sccs());\n+        let mut scc_values = RegionValues::new(elements);\n+\n+        for (region, location_set) in liveness_constraints.iter_enumerated() {\n+            let scc = constraint_sccs.scc(region);\n+            scc_values.merge_into(scc, location_set);\n+        }\n \n         let mut result = Self {\n             definitions,\n             elements: elements.clone(),\n-            liveness_constraints: RegionValues::new(elements, num_region_variables),\n+            liveness_constraints,\n             constraints,\n-            constraint_sccs,\n             constraint_graph,\n+            constraint_sccs,\n             scc_values,\n             type_tests,\n             universal_regions,\n@@ -414,7 +417,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             constraints\n         });\n \n-        // To propagate constriants, we walk the DAG induced by the\n+        // To propagate constraints, we walk the DAG induced by the\n         // SCC. For each SCC, we visit its successors and compute\n         // their values, then we union all those values to get our\n         // own."}, {"sha": "f041483a8ff2f985226f7d2514072ed2c099428b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/025e04e1bc51807d3e9d733f4af57d2624b9080d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025e04e1bc51807d3e9d733f4af57d2624b9080d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=025e04e1bc51807d3e9d733f4af57d2624b9080d", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::ty::RegionVid;\n-use rustc_data_structures::bitvec::SparseBitMatrix;\n+use rustc_data_structures::bitvec::{SparseBitMatrix, SparseBitSet};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt::Debug;\n@@ -55,11 +55,6 @@ impl RegionValueElements {\n         }\n     }\n \n-    /// Total number of element indices that exist.\n-    crate fn num_elements(&self) -> usize {\n-        self.num_points + self.num_universal_regions\n-    }\n-\n     /// Converts an element of a region value into a `RegionElementIndex`.\n     crate fn index<T: ToElementIndex>(&self, elem: T) -> RegionElementIndex {\n         elem.to_element_index(self)\n@@ -188,18 +183,10 @@ impl<N: Idx> RegionValues<N> {\n     /// Creates a new set of \"region values\" that tracks causal information.\n     /// Each of the regions in num_region_variables will be initialized with an\n     /// empty set of points and no causal information.\n-    crate fn new(elements: &Rc<RegionValueElements>, num_region_variables: usize) -> Self {\n-        assert!(\n-            elements.num_universal_regions <= num_region_variables,\n-            \"universal regions are a subset of the region variables\"\n-        );\n-\n+    crate fn new(elements: &Rc<RegionValueElements>) -> Self {\n         Self {\n             elements: elements.clone(),\n-            matrix: SparseBitMatrix::new(\n-                N::new(num_region_variables),\n-                RegionElementIndex::new(elements.num_elements()),\n-            ),\n+            matrix: SparseBitMatrix::new(),\n         }\n     }\n \n@@ -227,6 +214,18 @@ impl<N: Idx> RegionValues<N> {\n         self.matrix.contains(r, i)\n     }\n \n+    /// Iterates through each row and the accompanying bit set.\n+    pub fn iter_enumerated<'a>(\n+        &'a self\n+    ) -> impl Iterator<Item = (N, &'a SparseBitSet<RegionElementIndex>)> + 'a {\n+        self.matrix.iter_enumerated()\n+    }\n+\n+    /// Merge a row, `from`, originating in another `RegionValues` into the `into` row.\n+    pub fn merge_into(&mut self, into: N, from: &SparseBitSet<RegionElementIndex>) -> bool {\n+        self.matrix.merge_into(into, from)\n+    }\n+\n     /// True if `sup_region` contains all the CFG points that\n     /// `sub_region` contains. Ignores universal regions.\n     crate fn contains_points(&self, sup_region: N, sub_region: N) -> bool {"}, {"sha": "cd468eabd5f8beb9dd933915c94410be157eebe9", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/025e04e1bc51807d3e9d733f4af57d2624b9080d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025e04e1bc51807d3e9d733f4af57d2624b9080d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=025e04e1bc51807d3e9d733f4af57d2624b9080d", "patch": "@@ -168,7 +168,18 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n         );\n \n         cx.tcx().for_each_free_region(&value, |live_region| {\n-            cx.constraints.liveness_set.push((live_region, location));\n+            if let Some(ref mut borrowck_context) = cx.borrowck_context {\n+                let region_vid = borrowck_context.universal_regions.to_region_vid(live_region);\n+                borrowck_context.constraints.liveness_constraints.add_element(region_vid, location);\n+\n+                if let Some(all_facts) = borrowck_context.all_facts {\n+                    let start_index = borrowck_context.location_table.start_index(location);\n+                    all_facts.region_live_at.push((region_vid, start_index));\n+\n+                    let mid_index = borrowck_context.location_table.mid_index(location);\n+                    all_facts.region_live_at.push((region_vid, mid_index));\n+                }\n+            }\n         });\n     }\n "}, {"sha": "e188c9d7559c92dd8fded791cd8ffd64a2a4c6d3", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 59, "deletions": 41, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/025e04e1bc51807d3e9d733f4af57d2624b9080d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025e04e1bc51807d3e9d733f4af57d2624b9080d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=025e04e1bc51807d3e9d733f4af57d2624b9080d", "patch": "@@ -16,6 +16,7 @@ use borrow_check::location::LocationTable;\n use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n+use borrow_check::nll::region_infer::values::{RegionValues, RegionValueElements};\n use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::ToRegionVid;\n use dataflow::move_paths::MoveData;\n@@ -33,8 +34,9 @@ use rustc::mir::*;\n use rustc::traits::query::type_op;\n use rustc::traits::query::{Fallible, NoSolution};\n use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeVariants};\n+use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeVariants, RegionVid};\n use std::fmt;\n+use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n use transform::{MirPass, MirSource};\n use util::liveness::LivenessResults;\n@@ -111,39 +113,55 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     all_facts: &mut Option<AllFacts>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n+    elements: &Rc<RegionValueElements>,\n ) -> MirTypeckRegionConstraints<'tcx> {\n     let implicit_region_bound = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n-    type_check_internal(\n-        infcx,\n-        mir_def_id,\n-        param_env,\n-        mir,\n-        &universal_regions.region_bound_pairs,\n-        Some(implicit_region_bound),\n-        Some(BorrowCheckContext {\n+    let mut constraints = MirTypeckRegionConstraints {\n+        liveness_constraints: RegionValues::new(elements),\n+        outlives_constraints: ConstraintSet::default(),\n+        type_tests: Vec::default(),\n+    };\n+\n+    {\n+        let mut borrowck_context = BorrowCheckContext {\n             universal_regions,\n             location_table,\n             borrow_set,\n             all_facts,\n-        }),\n-        &mut |cx| {\n-            liveness::generate(cx, mir, liveness, flow_inits, move_data);\n+            constraints: &mut constraints,\n+        };\n+\n+        type_check_internal(\n+            infcx,\n+            mir_def_id,\n+            param_env,\n+            mir,\n+            &universal_regions.region_bound_pairs,\n+            Some(implicit_region_bound),\n+            Some(&mut borrowck_context),\n+            |cx| {\n+                liveness::generate(cx, mir, liveness, flow_inits, move_data);\n \n-            cx.equate_inputs_and_outputs(mir, mir_def_id, universal_regions);\n-        },\n-    )\n+                cx.equate_inputs_and_outputs(mir, mir_def_id, universal_regions);\n+            },\n+        );\n+    }\n+\n+    constraints\n }\n \n-fn type_check_internal<'gcx, 'tcx>(\n-    infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+fn type_check_internal<'a, 'gcx, 'tcx, F>(\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     mir_def_id: DefId,\n     param_env: ty::ParamEnv<'gcx>,\n-    mir: &Mir<'tcx>,\n-    region_bound_pairs: &[(ty::Region<'tcx>, GenericKind<'tcx>)],\n+    mir: &'a Mir<'tcx>,\n+    region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n-    borrowck_context: Option<BorrowCheckContext<'_, 'tcx>>,\n-    extra: &mut dyn FnMut(&mut TypeChecker<'_, 'gcx, 'tcx>),\n-) -> MirTypeckRegionConstraints<'tcx> {\n+    borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n+    mut extra: F,\n+)\n+    where F: FnMut(&mut TypeChecker<'a, 'gcx, 'tcx>)\n+{\n     let mut checker = TypeChecker::new(\n         infcx,\n         mir,\n@@ -165,8 +183,6 @@ fn type_check_internal<'gcx, 'tcx>(\n     }\n \n     extra(&mut checker);\n-\n-    checker.constraints\n }\n \n fn mirbug(tcx: TyCtxt, span: Span, msg: &str) {\n@@ -603,20 +619,19 @@ struct TypeChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n-    constraints: MirTypeckRegionConstraints<'tcx>,\n-    borrowck_context: Option<BorrowCheckContext<'a, 'tcx>>,\n+    borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n }\n \n struct BorrowCheckContext<'a, 'tcx: 'a> {\n     universal_regions: &'a UniversalRegions<'tcx>,\n     location_table: &'a LocationTable,\n     all_facts: &'a mut Option<AllFacts>,\n     borrow_set: &'a BorrowSet<'tcx>,\n+    constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n }\n \n /// A collection of region constraints that must be satisfied for the\n /// program to be considered well-typed.\n-#[derive(Default)]\n crate struct MirTypeckRegionConstraints<'tcx> {\n     /// In general, the type-checker is not responsible for enforcing\n     /// liveness constraints; this job falls to the region inferencer,\n@@ -625,7 +640,7 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n     /// not otherwise appear in the MIR -- in particular, the\n     /// late-bound regions that it instantiates at call-sites -- and\n     /// hence it must report on their liveness constraints.\n-    crate liveness_set: Vec<(ty::Region<'tcx>, Location)>,\n+    crate liveness_constraints: RegionValues<RegionVid>,\n \n     crate outlives_constraints: ConstraintSet,\n \n@@ -717,7 +732,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         param_env: ty::ParamEnv<'gcx>,\n         region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n-        borrowck_context: Option<BorrowCheckContext<'a, 'tcx>>,\n+        borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n     ) -> Self {\n         TypeChecker {\n             infcx,\n@@ -729,7 +744,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             implicit_region_bound,\n             borrowck_context,\n             reported_errors: FxHashSet(),\n-            constraints: MirTypeckRegionConstraints::default(),\n         }\n     }\n \n@@ -767,7 +781,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             locations, data\n         );\n \n-        if let Some(borrowck_context) = &mut self.borrowck_context {\n+        if let Some(ref mut borrowck_context) = self.borrowck_context {\n             constraint_conversion::ConstraintConversion::new(\n                 self.infcx.tcx,\n                 borrowck_context.universal_regions,\n@@ -776,8 +790,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 self.implicit_region_bound,\n                 self.param_env,\n                 locations,\n-                &mut self.constraints.outlives_constraints,\n-                &mut self.constraints.type_tests,\n+                &mut borrowck_context.constraints.outlives_constraints,\n+                &mut borrowck_context.constraints.type_tests,\n                 &mut borrowck_context.all_facts,\n             ).convert_all(&data);\n         }\n@@ -993,9 +1007,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // output) types in the signature must be live, since\n                 // all the inputs that fed into it were live.\n                 for &late_bound_region in map.values() {\n-                    self.constraints\n-                        .liveness_set\n-                        .push((late_bound_region, term_location));\n+                    if let Some(ref mut borrowck_context) = self.borrowck_context {\n+                        let region_vid = borrowck_context.universal_regions.to_region_vid(\n+                            late_bound_region);\n+                        borrowck_context.constraints\n+                            .liveness_constraints\n+                            .add_element(region_vid, term_location);\n+                    }\n                 }\n \n                 self.check_call_inputs(mir, term, &sig, args, term_location);\n@@ -1487,9 +1505,10 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             borrow_set,\n             location_table,\n             all_facts,\n+            constraints,\n             ..\n-        } = match &mut self.borrowck_context {\n-            Some(borrowck_context) => borrowck_context,\n+        } = match self.borrowck_context {\n+            Some(ref mut borrowck_context) => borrowck_context,\n             None => return,\n         };\n \n@@ -1531,7 +1550,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.sty {\n                         ty::TyRef(ref_region, _, mutbl) => {\n-                            self.constraints\n+                            constraints\n                                 .outlives_constraints\n                                 .push(OutlivesConstraint {\n                                     sup: ref_region.to_region_vid(),\n@@ -1792,8 +1811,7 @@ impl MirPass for TypeckMir {\n \n         let param_env = tcx.param_env(def_id);\n         tcx.infer_ctxt().enter(|infcx| {\n-            let _ =\n-                type_check_internal(&infcx, def_id, param_env, mir, &[], None, None, &mut |_| ());\n+            type_check_internal(&infcx, def_id, param_env, mir, &[], None, None, |_| ());\n \n             // For verification purposes, we just ignore the resulting\n             // region constraint sets. Not our problem. =)"}]}