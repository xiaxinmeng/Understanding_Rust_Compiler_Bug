{"sha": "1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3MThjZDZlZTBmMjdlYzhiN2FkMzAzOGMxOTg1YTBhY2YwYmViZGI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-12T16:09:32Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-15T15:23:48Z"}, "message": "Remove all shadowed lifetimes.", "tree": {"sha": "b04bacdbb64be3b62303999e659ce5fec3a97819", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b04bacdbb64be3b62303999e659ce5fec3a97819"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "comment_count": 7, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "html_url": "https://github.com/rust-lang/rust/commit/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b60de4bfc2cf45ebe16b9b5b768f0aad54211625", "url": "https://api.github.com/repos/rust-lang/rust/commits/b60de4bfc2cf45ebe16b9b5b768f0aad54211625", "html_url": "https://github.com/rust-lang/rust/commit/b60de4bfc2cf45ebe16b9b5b768f0aad54211625"}], "stats": {"total": 249, "additions": 124, "deletions": 125}, "files": [{"sha": "6113e2323c1f719b49430696cef9267311ab70e5", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -154,7 +154,7 @@ struct MaskWords<'a> {\n impl<'a> Iterator<(uint, u32)> for MaskWords<'a> {\n     /// Returns (offset, word)\n     #[inline]\n-    fn next<'a>(&'a mut self) -> Option<(uint, u32)> {\n+    fn next(&mut self) -> Option<(uint, u32)> {\n         let ret = self.next_word;\n         match ret {\n             Some(&w) => {"}, {"sha": "00f4eac2858e21204c90eeeb76d36fbf3fe52425", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -561,7 +561,7 @@ mod stack {\n     impl<'a, K, V> PartialSearchStack<'a, K, V> {\n         /// Creates a new PartialSearchStack from a BTreeMap by initializing the stack with the\n         /// root of the tree.\n-        pub fn new<'a>(map: &'a mut BTreeMap<K, V>) -> PartialSearchStack<'a, K, V> {\n+        pub fn new(map: &'a mut BTreeMap<K, V>) -> PartialSearchStack<'a, K, V> {\n             let depth = map.depth;\n \n             PartialSearchStack {"}, {"sha": "3ae66954e9c9714af081b3ae99ab59ff0751452c", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -692,7 +692,7 @@ impl<'a, A> ListInsertion<A> for MutItems<'a, A> {\n     }\n \n     #[inline]\n-    fn peek_next<'a>(&'a mut self) -> Option<&'a mut A> {\n+    fn peek_next(&mut self) -> Option<&mut A> {\n         if self.nelem == 0 {\n             return None\n         }"}, {"sha": "1dac70383515e202165864920916e2f74be12c9b", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -115,7 +115,7 @@ impl<'a> Argument<'a> {\n         Show::fmt(x, f)\n     }\n \n-    fn new<'a, T>(x: &'a T, f: fn(&T, &mut Formatter) -> Result) -> Argument<'a> {\n+    fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter) -> Result) -> Argument<'b> {\n         unsafe {\n             Argument {\n                 formatter: mem::transmute(f),\n@@ -124,7 +124,7 @@ impl<'a> Argument<'a> {\n         }\n     }\n \n-    fn from_uint<'a>(x: &'a uint) -> Argument<'a> {\n+    fn from_uint(x: &uint) -> Argument {\n         Argument::new(x, Argument::show_uint)\n     }\n \n@@ -144,8 +144,8 @@ impl<'a> Arguments<'a> {\n     /// Arguments structure.\n     #[doc(hidden)] #[inline]\n     #[experimental = \"implementation detail of the `format_args!` macro\"]\n-    pub fn new<'a>(pieces: &'a [&'a str],\n-                   args: &'a [Argument<'a>]) -> Arguments<'a> {\n+    pub fn new(pieces: &'a [&'a str],\n+               args: &'a [Argument<'a>]) -> Arguments<'a> {\n         Arguments {\n             pieces: pieces,\n             fmt: None,\n@@ -161,9 +161,9 @@ impl<'a> Arguments<'a> {\n     /// unsafety, but will ignore invalid .\n     #[doc(hidden)] #[inline]\n     #[experimental = \"implementation detail of the `format_args!` macro\"]\n-    pub fn with_placeholders<'a>(pieces: &'a [&'a str],\n-                                 fmt: &'a [rt::Argument<'a>],\n-                                 args: &'a [Argument<'a>]) -> Arguments<'a> {\n+    pub fn with_placeholders(pieces: &'a [&'a str],\n+                             fmt: &'a [rt::Argument<'a>],\n+                             args: &'a [Argument<'a>]) -> Arguments<'a> {\n         Arguments {\n             pieces: pieces,\n             fmt: Some(fmt),"}, {"sha": "209edf9043955ab95586daae467499ea922d6f9b", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -1036,12 +1036,12 @@ impl<T> AsSlice<T> for [T] {\n \n impl<'a, T, Sized? U: AsSlice<T>> AsSlice<T> for &'a U {\n     #[inline(always)]\n-    fn as_slice<'a>(&'a self) -> &'a [T] { AsSlice::as_slice(*self) }\n+    fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n impl<'a, T, Sized? U: AsSlice<T>> AsSlice<T> for &'a mut U {\n     #[inline(always)]\n-    fn as_slice<'a>(&'a self) -> &'a [T] { AsSlice::as_slice(*self) }\n+    fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n #[unstable = \"waiting for DST\"]"}, {"sha": "444806e78c129f4b3f68e51a697549cd1446c7d8", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -185,7 +185,7 @@ impl<'a> Iterator<Piece<'a>> for Parser<'a> {\n \n impl<'a> Parser<'a> {\n     /// Creates a new parser for the given format string\n-    pub fn new<'a>(s: &'a str) -> Parser<'a> {\n+    pub fn new(s: &'a str) -> Parser<'a> {\n         Parser {\n             input: s,\n             cur: s.char_indices(),"}, {"sha": "8ce761580b762abf3c076521e07012f7a3716819", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -165,10 +165,10 @@\n //!     fn node_id(&'a self, n: &Nd) -> dot::Id<'a> {\n //!         dot::Id::new(format!(\"N{}\", n)).unwrap()\n //!     }\n-//!     fn node_label<'a>(&'a self, n: &Nd) -> dot::LabelText<'a> {\n+//!     fn node_label<'b>(&'b self, n: &Nd) -> dot::LabelText<'b> {\n //!         dot::LabelStr(self.nodes[*n].as_slice().into_cow())\n //!     }\n-//!     fn edge_label<'a>(&'a self, _: &Ed) -> dot::LabelText<'a> {\n+//!     fn edge_label<'b>(&'b self, _: &Ed) -> dot::LabelText<'b> {\n //!         dot::LabelStr(\"&sube;\".into_cow())\n //!     }\n //! }\n@@ -220,11 +220,11 @@\n //!     fn node_id(&'a self, n: &Nd<'a>) -> dot::Id<'a> {\n //!         dot::Id::new(format!(\"N{}\", n.0)).unwrap()\n //!     }\n-//!     fn node_label<'a>(&'a self, n: &Nd<'a>) -> dot::LabelText<'a> {\n+//!     fn node_label<'b>(&'b self, n: &Nd<'b>) -> dot::LabelText<'b> {\n //!         let &(i, _) = n;\n //!         dot::LabelStr(self.nodes[i].as_slice().into_cow())\n //!     }\n-//!     fn edge_label<'a>(&'a self, _: &Ed<'a>) -> dot::LabelText<'a> {\n+//!     fn edge_label<'b>(&'b self, _: &Ed<'b>) -> dot::LabelText<'b> {\n //!         dot::LabelStr(\"&sube;\".into_cow())\n //!     }\n //! }"}, {"sha": "f017bed737ac300686bcf50b61b4df1da78ec183", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -169,7 +169,7 @@ impl<'a, T> Default for MaybeOwnedVector<'a, T> {\n }\n \n impl<'a> BytesContainer for MaybeOwnedVector<'a, u8> {\n-    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+    fn container_as_bytes(&self) -> &[u8] {\n         self.as_slice()\n     }\n }"}, {"sha": "58125c67fdae9edef566e871a5a96de8d1ff453a", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -114,7 +114,7 @@ impl<'a, T: Clone> WeightedChoice<'a, T> {\n     /// - `v` is empty\n     /// - the total weight is 0\n     /// - the total weight is larger than a `uint` can contain.\n-    pub fn new<'a>(items: &'a mut [Weighted<T>]) -> WeightedChoice<'a, T> {\n+    pub fn new(items: &'a mut [Weighted<T>]) -> WeightedChoice<'a, T> {\n         // strictly speaking, this is subsumed by the total weight == 0 case\n         assert!(!items.is_empty(), \"WeightedChoice::new called with no items\");\n "}, {"sha": "8fad90adc9db090bd85325474fd5782845d0707a", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -601,7 +601,7 @@ fn encode_method_callee<'a, 'tcx>(ecx: &e::EncodeContext<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> read_method_callee_helper<'tcx> for reader::Decoder<'a> {\n-    fn read_method_callee<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_method_callee<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n         -> (ty::ExprAdjustment, MethodCallee<'tcx>) {\n \n         self.read_struct(\"MethodCallee\", 4, |this| {\n@@ -810,7 +810,7 @@ trait get_ty_str_ctxt<'tcx> {\n }\n \n impl<'a, 'tcx> get_ty_str_ctxt<'tcx> for e::EncodeContext<'a, 'tcx> {\n-    fn ty_str_ctxt<'a>(&'a self) -> tyencode::ctxt<'a, 'tcx> {\n+    fn ty_str_ctxt<'b>(&'b self) -> tyencode::ctxt<'b, 'tcx> {\n         tyencode::ctxt {\n             diag: self.tcx.sess.diagnostic(),\n             ds: e::def_to_string,\n@@ -851,16 +851,16 @@ trait rbml_writer_helpers<'tcx> {\n }\n \n impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n-    fn emit_closure_type<'a>(&mut self,\n-                             ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_closure_type<'b>(&mut self,\n+                             ecx: &e::EncodeContext<'b, 'tcx>,\n                              closure_type: &ty::ClosureTy<'tcx>) {\n         self.emit_opaque(|this| {\n             Ok(e::write_closure_type(ecx, this, closure_type))\n         });\n     }\n \n-    fn emit_method_origin<'a>(&mut self,\n-                              ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_method_origin<'b>(&mut self,\n+                              ecx: &e::EncodeContext<'b, 'tcx>,\n                               method_origin: &ty::MethodOrigin<'tcx>)\n     {\n         use serialize::Encoder;\n@@ -916,20 +916,20 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_ty<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, ty: Ty<'tcx>) {\n+    fn emit_ty<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>, ty: Ty<'tcx>) {\n         self.emit_opaque(|this| Ok(e::write_type(ecx, this, ty)));\n     }\n \n-    fn emit_tys<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, tys: &[Ty<'tcx>]) {\n+    fn emit_tys<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>, tys: &[Ty<'tcx>]) {\n         self.emit_from_vec(tys, |this, ty| Ok(this.emit_ty(ecx, *ty)));\n     }\n \n-    fn emit_trait_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_trait_ref<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                           trait_ref: &ty::TraitRef<'tcx>) {\n         self.emit_opaque(|this| Ok(e::write_trait_ref(ecx, this, trait_ref)));\n     }\n \n-    fn emit_type_param_def<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_type_param_def<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                                type_param_def: &ty::TypeParameterDef<'tcx>) {\n         self.emit_opaque(|this| {\n             Ok(tyencode::enc_type_param_def(this.writer,\n@@ -938,7 +938,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_predicate<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_predicate<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                           predicate: &ty::Predicate<'tcx>) {\n         self.emit_opaque(|this| {\n             Ok(tyencode::enc_predicate(this.writer,\n@@ -947,8 +947,8 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_polytype<'a>(&mut self,\n-                         ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_polytype<'b>(&mut self,\n+                         ecx: &e::EncodeContext<'b, 'tcx>,\n                          pty: ty::Polytype<'tcx>) {\n         use serialize::Encoder;\n \n@@ -990,14 +990,14 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                                                                 bounds)));\n     }\n \n-    fn emit_substs<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_substs<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                        substs: &subst::Substs<'tcx>) {\n         self.emit_opaque(|this| Ok(tyencode::enc_substs(this.writer,\n                                                            &ecx.ty_str_ctxt(),\n                                                            substs)));\n     }\n \n-    fn emit_auto_adjustment<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_auto_adjustment<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                                 adj: &ty::AutoAdjustment<'tcx>) {\n         use serialize::Encoder;\n \n@@ -1019,7 +1019,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_autoref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_autoref<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                         autoref: &ty::AutoRef<'tcx>) {\n         use serialize::Encoder;\n \n@@ -1069,7 +1069,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_auto_deref_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_auto_deref_ref<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                                auto_deref_ref: &ty::AutoDerefRef<'tcx>) {\n         use serialize::Encoder;\n \n@@ -1086,7 +1086,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_unsize_kind<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+    fn emit_unsize_kind<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                             uk: &ty::UnsizeKind<'tcx>) {\n         use serialize::Encoder;\n \n@@ -1427,7 +1427,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_method_origin<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_method_origin<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                   -> ty::MethodOrigin<'tcx>\n     {\n         self.read_enum(\"MethodOrigin\", |this| {\n@@ -1498,7 +1498,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     }\n \n \n-    fn read_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Ty<'tcx> {\n+    fn read_ty<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>) -> Ty<'tcx> {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n         // context.  However, we do not bother, because region types\n@@ -1526,12 +1526,12 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }\n     }\n \n-    fn read_tys<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_tys<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                         -> Vec<Ty<'tcx>> {\n         self.read_to_vec(|this| Ok(this.read_ty(dcx))).unwrap().into_iter().collect()\n     }\n \n-    fn read_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_trait_ref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                               -> Rc<ty::TraitRef<'tcx>> {\n         Rc::new(self.read_opaque(|this, doc| {\n             let ty = tydecode::parse_trait_ref_data(\n@@ -1544,7 +1544,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap())\n     }\n \n-    fn read_type_param_def<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_type_param_def<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                    -> ty::TypeParameterDef<'tcx> {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_type_param_def_data(\n@@ -1556,7 +1556,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_predicate<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_predicate<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                               -> ty::Predicate<'tcx>\n     {\n         self.read_opaque(|this, doc| {\n@@ -1565,7 +1565,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_polytype<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_polytype<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                              -> ty::Polytype<'tcx> {\n         self.read_struct(\"Polytype\", 2, |this| {\n             Ok(ty::Polytype {\n@@ -1599,7 +1599,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_existential_bounds<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_existential_bounds<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                        -> ty::ExistentialBounds\n     {\n         self.read_opaque(|this, doc| {\n@@ -1611,7 +1611,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_substs<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_substs<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                            -> subst::Substs<'tcx> {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_substs_data(doc.data,\n@@ -1622,7 +1622,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_auto_adjustment<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                     -> ty::AutoAdjustment<'tcx> {\n         self.read_enum(\"AutoAdjustment\", |this| {\n             let variants = [\"AutoAddEnv\", \"AutoDerefRef\"];\n@@ -1647,7 +1647,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_auto_deref_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_auto_deref_ref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                    -> ty::AutoDerefRef<'tcx> {\n         self.read_struct(\"AutoDerefRef\", 2, |this| {\n             Ok(ty::AutoDerefRef {\n@@ -1667,7 +1667,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_autoref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> ty::AutoRef<'tcx> {\n+    fn read_autoref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>) -> ty::AutoRef<'tcx> {\n         self.read_enum(\"AutoRef\", |this| {\n             let variants = [\"AutoPtr\",\n                             \"AutoUnsize\",\n@@ -1725,7 +1725,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_unsize_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_unsize_kind<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                 -> ty::UnsizeKind<'tcx> {\n         self.read_enum(\"UnsizeKind\", |this| {\n             let variants = &[\"UnsizeLength\", \"UnsizeStruct\", \"UnsizeVtable\"];\n@@ -1768,7 +1768,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_unboxed_closure<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+    fn read_unboxed_closure<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                     -> ty::UnboxedClosure<'tcx> {\n         let closure_type = self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_ty_closure_data("}, {"sha": "5c39c9fa74d0a43e4b90fe0a21cb9ff16f236fe8", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -151,7 +151,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn pats_all<'a, I: Iterator<&'a P<ast::Pat>>>(&mut self,\n+    fn pats_all<'b, I: Iterator<&'b P<ast::Pat>>>(&mut self,\n                                           pats: I,\n                                           pred: CFGIndex) -> CFGIndex {\n         //! Handles case where all of the patterns must match.\n@@ -505,7 +505,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn call<'a, I: Iterator<&'a ast::Expr>>(&mut self,\n+    fn call<'b, I: Iterator<&'b ast::Expr>>(&mut self,\n             call_expr: &ast::Expr,\n             pred: CFGIndex,\n             func_or_rcvr: &ast::Expr,\n@@ -525,7 +525,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn exprs<'a, I: Iterator<&'a ast::Expr>>(&mut self,\n+    fn exprs<'b, I: Iterator<&'b ast::Expr>>(&mut self,\n                                              exprs: I,\n                                              pred: CFGIndex) -> CFGIndex {\n         //! Constructs graph for `exprs` evaluated in order\n@@ -539,7 +539,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         opt_expr.iter().fold(pred, |p, e| self.expr(&**e, p))\n     }\n \n-    fn straightline<'a, I: Iterator<&'a ast::Expr>>(&mut self,\n+    fn straightline<'b, I: Iterator<&'b ast::Expr>>(&mut self,\n                     expr: &ast::Expr,\n                     pred: CFGIndex,\n                     subexprs: I) -> CFGIndex {"}, {"sha": "034bf3e840a896f4ba8d223ed2e9d97b0623e1f1", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -392,7 +392,7 @@ pub struct StaticInliner<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n-    pub fn new<'a>(tcx: &'a ty::ctxt<'tcx>) -> StaticInliner<'a, 'tcx> {\n+    pub fn new<'b>(tcx: &'b ty::ctxt<'tcx>) -> StaticInliner<'b, 'tcx> {\n         StaticInliner {\n             tcx: tcx,\n             failed: false"}, {"sha": "3cd981b57844c3682ff963d70af5022471067179", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -539,29 +539,29 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn skolemizer<'a>(&'a self) -> TypeSkolemizer<'a, 'tcx> {\n+    pub fn skolemizer<'b>(&'b self) -> TypeSkolemizer<'b, 'tcx> {\n         skolemize::TypeSkolemizer::new(self)\n     }\n \n-    pub fn combine_fields<'a>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                              -> CombineFields<'a, 'tcx> {\n+    pub fn combine_fields<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+                              -> CombineFields<'b, 'tcx> {\n         CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n                        trace: trace}\n     }\n \n-    pub fn equate<'a>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                      -> Equate<'a, 'tcx> {\n+    pub fn equate<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+                      -> Equate<'b, 'tcx> {\n         Equate(self.combine_fields(a_is_expected, trace))\n     }\n \n-    pub fn sub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                   -> Sub<'a, 'tcx> {\n+    pub fn sub<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+                   -> Sub<'b, 'tcx> {\n         Sub(self.combine_fields(a_is_expected, trace))\n     }\n \n-    pub fn lub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                   -> Lub<'a, 'tcx> {\n+    pub fn lub<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+                   -> Lub<'b, 'tcx> {\n         Lub(self.combine_fields(a_is_expected, trace))\n     }\n "}, {"sha": "e855511e26f80e410b487873caad0fc410b9b2cb", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -561,8 +561,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n     }\n \n-    fn combine_map<'a>(&'a self, t: CombineMapType)\n-                   -> &'a RefCell<CombineMap> {\n+    fn combine_map(&self, t: CombineMapType)\n+                   -> &RefCell<CombineMap> {\n         match t {\n             Glb => &self.glbs,\n             Lub => &self.lubs,"}, {"sha": "8336131c54acc223ef977f2d3670c45a7b8568d2", "filename": "src/librustc/middle/infer/skolemize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc%2Fmiddle%2Finfer%2Fskolemize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc%2Fmiddle%2Finfer%2Fskolemize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fskolemize.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -46,7 +46,7 @@ pub struct TypeSkolemizer<'a, 'tcx:'a> {\n }\n \n impl<'a, 'tcx> TypeSkolemizer<'a, 'tcx> {\n-    pub fn new<'tcx>(infcx: &'a InferCtxt<'a, 'tcx>) -> TypeSkolemizer<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> TypeSkolemizer<'a, 'tcx> {\n         TypeSkolemizer {\n             infcx: infcx,\n             skolemization_count: 0,"}, {"sha": "1cf25cd1dc8667327ddc1f658a56afc8212bb30d", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -588,7 +588,7 @@ struct SubstFolder<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n+    fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n \n     fn enter_region_binder(&mut self) {\n         self.region_binders_passed += 1;"}, {"sha": "4877512ce58165ea4dc1d0f9ebaf9583d39b5440", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -834,7 +834,7 @@ pub fn erase_regions<'tcx, T: TypeFoldable<'tcx>>(tcx: &ty::ctxt<'tcx>, t: T) ->\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n+    fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n         match r {"}, {"sha": "e8857de7b73bcc97bc47bbd05f3cf65da6f1fbd3", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -979,10 +979,10 @@ impl<'tcx> Cleanup<'tcx> for FreeSlice {\n         false\n     }\n \n-    fn trans<'blk, 'tcx>(&self,\n-                         bcx: Block<'blk, 'tcx>,\n-                         debug_loc: Option<NodeInfo>)\n-                      -> Block<'blk, 'tcx> {\n+    fn trans<'blk>(&self,\n+                   bcx: Block<'blk, 'tcx>,\n+                   debug_loc: Option<NodeInfo>)\n+                   -> Block<'blk, 'tcx> {\n         apply_debug_loc(bcx.fcx, debug_loc);\n \n         match self.heap {\n@@ -1012,10 +1012,10 @@ impl<'tcx> Cleanup<'tcx> for LifetimeEnd {\n         true\n     }\n \n-    fn trans<'blk, 'tcx>(&self,\n-                         bcx: Block<'blk, 'tcx>,\n-                         debug_loc: Option<NodeInfo>)\n-                      -> Block<'blk, 'tcx> {\n+    fn trans<'blk>(&self,\n+                   bcx: Block<'blk, 'tcx>,\n+                   debug_loc: Option<NodeInfo>)\n+                   -> Block<'blk, 'tcx> {\n         apply_debug_loc(bcx.fcx, debug_loc);\n         base::call_lifetime_end(bcx, self.ptr);\n         bcx"}, {"sha": "80e0de8e001a0b552d264bebcf0668dc4add3fe6", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -394,7 +394,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         &mut self,\n         bounds: &[Rc<ty::TraitRef<'tcx>>],\n         num_includes_types: bool,\n-        mk_cand: for<'a> |this: &mut ProbeContext<'a, 'tcx>,\n+        mk_cand: for<'b> |this: &mut ProbeContext<'b, 'tcx>,\n                           tr: Rc<ty::TraitRef<'tcx>>,\n                           m: Rc<ty::Method<'tcx>>,\n                           method_num: uint|)"}, {"sha": "ed743ad9b6aff67f6ee4f95d43b247004854bffc", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -246,7 +246,7 @@ pub struct FnCtxt<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n     fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n@@ -256,7 +256,7 @@ impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n                       -> Option<Ty<'tcx>> {\n         self.inh.method_map.borrow().get(&method_call).map(|m| m.ty)\n     }\n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n+    fn adjustments(&self) -> &RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n         &self.inh.adjustments\n     }\n     fn is_method_call(&self, id: ast::NodeId) -> bool {\n@@ -272,8 +272,7 @@ impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n                     -> ast::CaptureClause {\n         self.ccx.tcx.capture_mode(closure_expr_id)\n     }\n-    fn unboxed_closures<'a>(&'a self)\n-                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>> {\n+    fn unboxed_closures(&self) -> &RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>> {\n         &self.inh.unboxed_closures\n     }\n }\n@@ -1526,7 +1525,7 @@ fn check_cast(fcx: &FnCtxt,\n }\n \n impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.ccx.tcx }\n+    fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }\n \n     fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n         ty::lookup_item_type(self.tcx(), id)\n@@ -1557,7 +1556,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.ccx.tcx }\n+    fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }\n \n     pub fn infcx<'b>(&'b self) -> &'b infer::InferCtxt<'a, 'tcx> {\n         &self.inh.infcx\n@@ -1879,7 +1878,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn item_substs<'a>(&'a self) -> Ref<'a, NodeMap<ty::ItemSubsts<'tcx>>> {\n+    pub fn item_substs(&self) -> Ref<NodeMap<ty::ItemSubsts<'tcx>>> {\n         self.inh.item_substs.borrow()\n     }\n "}, {"sha": "08b465dfa80f70922d6bd53c0f5a9075f1e76336", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -153,7 +153,7 @@ impl<'a,'tcx> ToTy<'tcx> for CrateCtxt<'a,'tcx> {\n }\n \n impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n+    fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n \n     fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n         if id.krate != ast::LOCAL_CRATE {\n@@ -719,7 +719,7 @@ struct ImplCtxt<'a,'tcx:'a> {\n }\n \n impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n \n@@ -808,7 +808,7 @@ struct FnCtxt<'a,'tcx:'a> {\n }\n \n impl<'a,'tcx> AstConv<'tcx> for FnCtxt<'a,'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n \n@@ -857,7 +857,7 @@ struct ImplMethodCtxt<'a,'tcx:'a> {\n }\n \n impl<'a,'tcx> AstConv<'tcx> for ImplMethodCtxt<'a,'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n \n@@ -906,7 +906,7 @@ struct TraitMethodCtxt<'a,'tcx:'a> {\n }\n \n impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n \n@@ -986,7 +986,7 @@ struct GenericsCtxt<'a,'tcx:'a,AC:'a> {\n }\n \n impl<'a,'tcx,AC:AstConv<'tcx>> AstConv<'tcx> for GenericsCtxt<'a,'tcx,AC> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.chain.tcx()\n     }\n "}, {"sha": "6f40a93bcf540e9781c2a03c17b5b1932b54fb92", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -459,7 +459,7 @@ impl attr::AttrMetaMethods for Attribute {\n impl<'a> attr::AttrMetaMethods for &'a Attribute {\n     fn name(&self) -> InternedString { (**self).name() }\n     fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<ast::MetaItem>]> { None }\n+    fn meta_item_list(&self) -> Option<&[P<ast::MetaItem>]> { None }\n }\n \n #[deriving(Clone, Encodable, Decodable, PartialEq)]"}, {"sha": "1d8ea2202bf0d4e4da43cc2e1107d1d72825ea2b", "filename": "src/librustrt/exclusive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustrt%2Fexclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibrustrt%2Fexclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fexclusive.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -71,10 +71,10 @@ impl<'a, T: Send> ExclusiveGuard<'a, T> {\n }\n \n impl<'a, T: Send> Deref<T> for ExclusiveGuard<'a, T> {\n-    fn deref<'a>(&'a self) -> &'a T { &*self._data }\n+    fn deref(&self) -> &T { &*self._data }\n }\n impl<'a, T: Send> DerefMut<T> for ExclusiveGuard<'a, T> {\n-    fn deref_mut<'a>(&'a mut self) -> &'a mut T { &mut *self._data }\n+    fn deref_mut(&mut self) -> &mut T { &mut *self._data }\n }\n \n #[cfg(test)]"}, {"sha": "d17f293b4432b655f36b0908fa0d739d589673a8", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -627,13 +627,13 @@ pub struct PrettyEncoder<'a> {\n \n impl<'a> PrettyEncoder<'a> {\n     /// Creates a new encoder whose output will be written to the specified writer\n-    pub fn new<'a>(writer: &'a mut io::Writer) -> PrettyEncoder<'a> {\n+    pub fn new(writer: &'a mut io::Writer) -> PrettyEncoder<'a> {\n         PrettyEncoder { writer: writer, curr_indent: 0, indent: 2, }\n     }\n \n     /// Set the number of spaces to indent for each level.\n     /// This is safe to set during encoding.\n-    pub fn set_indent<'a>(&mut self, indent: uint) {\n+    pub fn set_indent(&mut self, indent: uint) {\n         // self.indent very well could be 0 so we need to use checked division.\n         let level = self.curr_indent.checked_div(self.indent).unwrap_or(0);\n         self.indent = indent;\n@@ -1103,7 +1103,7 @@ impl Json {\n }\n \n impl<'a> ops::Index<&'a str, Json>  for Json {\n-    fn index<'a>(&'a self, idx: & &str) -> &'a Json {\n+    fn index(&self, idx: & &str) -> &Json {\n         self.find(*idx).unwrap()\n     }\n }"}, {"sha": "8eb66dec40cecf89fcc55344f452fd91dd0f5aff", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -226,7 +226,7 @@ impl<'a> Reader for &'a [u8] {\n \n impl<'a> Buffer for &'a [u8] {\n     #[inline]\n-    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n+    fn fill_buf(&mut self) -> IoResult<&[u8]> {\n         if self.is_empty() {\n             Err(io::standard_error(io::EndOfFile))\n         } else {\n@@ -268,7 +268,7 @@ impl<'a> BufWriter<'a> {\n     /// Creates a new `BufWriter` which will wrap the specified buffer. The\n     /// writer initially starts at position 0.\n     #[inline]\n-    pub fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a> {\n+    pub fn new(buf: &'a mut [u8]) -> BufWriter<'a> {\n         BufWriter {\n             buf: buf,\n             pos: 0\n@@ -337,7 +337,7 @@ pub struct BufReader<'a> {\n impl<'a> BufReader<'a> {\n     /// Creates a new buffered reader which will read the specified buffer\n     #[inline]\n-    pub fn new<'a>(buf: &'a [u8]) -> BufReader<'a> {\n+    pub fn new(buf: &'a [u8]) -> BufReader<'a> {\n         BufReader {\n             buf: buf,\n             pos: 0\n@@ -384,7 +384,7 @@ impl<'a> Seek for BufReader<'a> {\n \n impl<'a> Buffer for BufReader<'a> {\n     #[inline]\n-    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n+    fn fill_buf(&mut self) -> IoResult<&[u8]> {\n         if self.pos < self.buf.len() {\n             Ok(self.buf[self.pos..])\n         } else {"}, {"sha": "a384610e504c9d5351848fb73db9ab158b4cc158", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -981,7 +981,7 @@ impl<'a, R: Reader> Reader for RefReader<'a, R> {\n }\n \n impl<'a, R: Buffer> Buffer for RefReader<'a, R> {\n-    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> { self.inner.fill_buf() }\n+    fn fill_buf(&mut self) -> IoResult<&[u8]> { self.inner.fill_buf() }\n     fn consume(&mut self, amt: uint) { self.inner.consume(amt) }\n }\n "}, {"sha": "354b53bfc01d0dde151d5b3598e52411a1d5a2a9", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -468,8 +468,8 @@ pub struct ExtCtxt<'a> {\n }\n \n impl<'a> ExtCtxt<'a> {\n-    pub fn new<'a>(parse_sess: &'a parse::ParseSess, cfg: ast::CrateConfig,\n-                   ecfg: expand::ExpansionConfig) -> ExtCtxt<'a> {\n+    pub fn new(parse_sess: &'a parse::ParseSess, cfg: ast::CrateConfig,\n+               ecfg: expand::ExpansionConfig) -> ExtCtxt<'a> {\n         let env = initial_syntax_expander_table(&ecfg);\n         ExtCtxt {\n             parse_sess: parse_sess,"}, {"sha": "da908f46ff61f67265945578515a9f5f3d747aed", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -275,8 +275,8 @@ impl<'a> StringReader<'a> {\n     }\n \n     /// Converts CRLF to LF in the given string, raising an error on bare CR.\n-    fn translate_crlf<'a>(&self, start: BytePos,\n-                          s: &'a str, errmsg: &'a str) -> str::CowString<'a> {\n+    fn translate_crlf<'b>(&self, start: BytePos,\n+                          s: &'b str, errmsg: &'b str) -> str::CowString<'b> {\n         let mut i = 0u;\n         while i < s.len() {\n             let str::CharRange { ch, next } = s.char_range_at(i);"}, {"sha": "fc54002820e012081807c43c78a6654c4284f6a1", "filename": "src/test/compile-fail/generic-lifetime-trait-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Ftest%2Fcompile-fail%2Fgeneric-lifetime-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Ftest%2Fcompile-fail%2Fgeneric-lifetime-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-lifetime-trait-impl.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -19,7 +19,7 @@\n trait Bar<'a> {}\n \n trait Foo<'a> {\n-    fn bar<'a, T: Bar<'a>>(self) -> &'a str;\n+    fn bar<'b, T: Bar<'b>>(self) -> &'b str;\n }\n \n impl<'a> Foo<'a> for &'a str {"}, {"sha": "16d6b217872ae8b2403396115e7394a4ba0d2932", "filename": "src/test/compile-fail/unboxed-closure-sugar-equiv.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -35,17 +35,17 @@ fn test<'a,'b>() {\n     // Test that anonymous regions in `()` form are equivalent\n     // to fresh bound regions, and that we can intermingle\n     // named and anonymous as we choose:\n-    eq::< for<'a,'b> Foo<(&'a int,&'b uint),uint>,\n-          for<'a,'b> Foo(&'a int,&'b uint) -> uint            >();\n-    eq::< for<'a,'b> Foo<(&'a int,&'b uint),uint>,\n-          for<'a> Foo(&'a int,&uint) -> uint                  >();\n-    eq::< for<'a,'b> Foo<(&'a int,&'b uint),uint>,\n-          for<'b> Foo(&int,&'b uint) -> uint                  >();\n-    eq::< for<'a,'b> Foo<(&'a int,&'b uint),uint>,\n+    eq::< for<'x,'y> Foo<(&'x int,&'y uint),uint>,\n+          for<'x,'y> Foo(&'x int,&'y uint) -> uint            >();\n+    eq::< for<'x,'y> Foo<(&'x int,&'y uint),uint>,\n+          for<'x> Foo(&'x int,&uint) -> uint                  >();\n+    eq::< for<'x,'y> Foo<(&'x int,&'y uint),uint>,\n+          for<'y> Foo(&int,&'y uint) -> uint                  >();\n+    eq::< for<'x,'y> Foo<(&'x int,&'y uint),uint>,\n           Foo(&int,&uint) -> uint                             >();\n \n     // lifetime elision\n-    eq::< for<'a,'b> Foo<(&'a int,), &'a int>,\n+    eq::< for<'x> Foo<(&'x int,), &'x int>,\n           Foo(&int) -> &int                                   >();\n \n     // Errors expected:"}, {"sha": "b5ea9bd4b89c6a9ae3af71d9849cd398a848d4d3", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -52,14 +52,14 @@\n              ((::std::fmt::format as\n                   fn(&core::fmt::Arguments<'_>) -> collections::string::String)((&((::std::fmt::Arguments::new\n                                                                                        as\n-                                                                                       fn(&'a [&'a str], &'a [core::fmt::Argument<'a>]) -> core::fmt::Arguments<'a>)((__STATIC_FMTSTR\n-                                                                                                                                                                         as\n-                                                                                                                                                                         &'static [&'static str]),\n-                                                                                                                                                                     (&([]\n-                                                                                                                                                                           as\n-                                                                                                                                                                           [core::fmt::Argument<'_>, ..0])\n-                                                                                                                                                                         as\n-                                                                                                                                                                         &[core::fmt::Argument<'_>, ..0]))\n+                                                                                       fn(&[&str], &[core::fmt::Argument<'_>]) -> core::fmt::Arguments<'_>)((__STATIC_FMTSTR\n+                                                                                                                                                                as\n+                                                                                                                                                                &'static [&'static str]),\n+                                                                                                                                                            (&([]\n+                                                                                                                                                                  as\n+                                                                                                                                                                  [core::fmt::Argument<'_>, ..0])\n+                                                                                                                                                                as\n+                                                                                                                                                                &[core::fmt::Argument<'_>, ..0]))\n                                                                                       as\n                                                                                       core::fmt::Arguments<'_>)\n                                                                                     as"}, {"sha": "23e700855040c4a4f680ce7811824f11ad67a775", "filename": "src/test/run-pass/issue-6157.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Ftest%2Frun-pass%2Fissue-6157.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb/src%2Ftest%2Frun-pass%2Fissue-6157.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6157.rs?ref=1718cd6ee0f27ec8b7ad3038c1985a0acf0bebdb", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub trait OpInt<'a> { fn call<'a>(&'a mut self, int, int) -> int; }\n+pub trait OpInt<'a> { fn call(&mut self, int, int) -> int; }\n \n impl<'a> OpInt<'a> for |int, int|: 'a -> int {\n     fn call(&mut self, a:int, b:int) -> int {"}]}