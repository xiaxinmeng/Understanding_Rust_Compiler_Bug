{"sha": "b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0OGU3NGI1YjAxNWNmYzNhNzFlMGI3ZTBmM2QxMjk3MmFhYjIwZjY=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-18T02:54:32Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:03:31Z"}, "message": "Rename 'blk and 'bcx to 'a", "tree": {"sha": "c62125c6bab60b82febf4f5b9bb6e8967e3bc116", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c62125c6bab60b82febf4f5b9bb6e8967e3bc116"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "html_url": "https://github.com/rust-lang/rust/commit/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99816a67435dbe2d9343f82ea16753e1c63edbe2", "url": "https://api.github.com/repos/rust-lang/rust/commits/99816a67435dbe2d9343f82ea16753e1c63edbe2", "html_url": "https://github.com/rust-lang/rust/commit/99816a67435dbe2d9343f82ea16753e1c63edbe2"}], "stats": {"total": 501, "additions": 256, "deletions": 245}, "files": [{"sha": "4a06982cd379d57e185648f8a9f9d17c2375b414", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "patch": "@@ -302,11 +302,12 @@ fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fields: &Vec<Ty<'tcx>>\n \n /// Obtain a representation of the discriminant sufficient to translate\n /// destructuring; this may or may not involve the actual discriminant.\n-pub fn trans_switch<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                t: Ty<'tcx>,\n-                                scrutinee: ValueRef,\n-                                range_assert: bool)\n-                                -> (BranchKind, Option<ValueRef>) {\n+pub fn trans_switch<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    t: Ty<'tcx>,\n+    scrutinee: ValueRef,\n+    range_assert: bool\n+) -> (BranchKind, Option<ValueRef>) {\n     let l = bcx.ccx().layout_of(t);\n     match *l {\n         layout::CEnum { .. } | layout::General { .. } |\n@@ -329,10 +330,13 @@ pub fn is_discr_signed<'tcx>(l: &layout::Layout) -> bool {\n }\n \n /// Obtain the actual discriminant of a value.\n-pub fn trans_get_discr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>, t: Ty<'tcx>,\n-                                   scrutinee: ValueRef, cast_to: Option<Type>,\n-                                   range_assert: bool)\n-    -> ValueRef {\n+pub fn trans_get_discr<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    t: Ty<'tcx>,\n+    scrutinee: ValueRef,\n+    cast_to: Option<Type>,\n+    range_assert: bool\n+) -> ValueRef {\n     let (def, substs) = match t.sty {\n         ty::TyAdt(ref def, substs) if def.adt_kind() == AdtKind::Enum => (def, substs),\n         _ => bug!(\"{} is not an enum\", t)\n@@ -411,8 +415,7 @@ fn load_discr(bcx: &BlockAndBuilder, ity: layout::Integer, ptr: ValueRef, min: u\n /// discriminant-like value returned by `trans_switch`.\n ///\n /// This should ideally be less tightly tied to `_match`.\n-pub fn trans_case<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>, t: Ty<'tcx>, value: Disr)\n-                              -> ValueRef {\n+pub fn trans_case<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, t: Ty<'tcx>, value: Disr) -> ValueRef {\n     let l = bcx.ccx().layout_of(t);\n     match *l {\n         layout::CEnum { discr, .. }\n@@ -432,8 +435,9 @@ pub fn trans_case<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>, t: Ty<'tcx>, va\n \n /// Set the discriminant for a new value of the given case of the given\n /// representation.\n-pub fn trans_set_discr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>, t: Ty<'tcx>,\n-                                   val: ValueRef, to: Disr) {\n+pub fn trans_set_discr<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>, t: Ty<'tcx>, val: ValueRef, to: Disr\n+) {\n     let l = bcx.ccx().layout_of(t);\n     match *l {\n         layout::CEnum{ discr, min, max, .. } => {\n@@ -480,7 +484,7 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>, t: Ty<'tcx\n     }\n }\n \n-fn target_sets_discr_via_memset<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>) -> bool {\n+fn target_sets_discr_via_memset<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>) -> bool {\n     bcx.sess().target.target.arch == \"arm\" || bcx.sess().target.target.arch == \"aarch64\"\n }\n \n@@ -493,11 +497,13 @@ fn assert_discr_in_range(min: Disr, max: Disr, discr: Disr) {\n }\n \n /// Access a field, at a point when the value's case is known.\n-pub fn trans_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                           t: Ty<'tcx>,\n-                                           val: MaybeSizedValue,\n-                                           discr: Disr, ix: usize)\n-                                           -> ValueRef {\n+pub fn trans_field_ptr<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    t: Ty<'tcx>,\n+    val: MaybeSizedValue,\n+    discr: Disr,\n+    ix: usize\n+) -> ValueRef {\n     let l = bcx.ccx().layout_of(t);\n     debug!(\"trans_field_ptr on {} represented as {:#?}\", t, l);\n     // Note: if this ever needs to generate conditionals (e.g., if we\n@@ -553,9 +559,15 @@ pub fn trans_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n     }\n }\n \n-fn struct_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                st: &layout::Struct, fields: &Vec<Ty<'tcx>>, val: MaybeSizedValue,\n-                                ix: usize, needs_cast: bool) -> ValueRef {\n+fn struct_field_ptr<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    st: &layout::Struct,\n+    fields: &Vec<Ty<'tcx>>,\n+    val: MaybeSizedValue,\n+    ix: usize,\n+    needs_cast: bool\n+) -> ValueRef {\n+    let ccx = bcx.ccx();\n     let fty = fields[ix];\n     let ccx = bcx.ccx();\n     let ll_fty = type_of::in_memory_type_of(ccx, fty);"}, {"sha": "6ec198aa247268a92b98304318e978a4abef3e47", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "patch": "@@ -24,10 +24,12 @@ use syntax::ast::AsmDialect;\n use libc::{c_uint, c_char};\n \n // Take an inline assembly expression and splat it out via LLVM\n-pub fn trans_inline_asm<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                    ia: &hir::InlineAsm,\n-                                    outputs: Vec<(ValueRef, Ty<'tcx>)>,\n-                                    mut inputs: Vec<ValueRef>) {\n+pub fn trans_inline_asm<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    ia: &hir::InlineAsm,\n+    outputs: Vec<(ValueRef, Ty<'tcx>)>,\n+    mut inputs: Vec<ValueRef>\n+) {\n     let mut ext_constraints = vec![];\n     let mut output_types = vec![];\n "}, {"sha": "d7efd2ce0a8287a3aedf5c400264d7216e65a7bd", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 35, "deletions": 41, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "patch": "@@ -160,13 +160,14 @@ pub fn bin_op_to_fcmp_predicate(op: hir::BinOp_) -> llvm::RealPredicate {\n     }\n }\n \n-pub fn compare_simd_types<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                      lhs: ValueRef,\n-                                      rhs: ValueRef,\n-                                      t: Ty<'tcx>,\n-                                      ret_ty: Type,\n-                                      op: hir::BinOp_)\n-                                      -> ValueRef {\n+pub fn compare_simd_types<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    lhs: ValueRef,\n+    rhs: ValueRef,\n+    t: Ty<'tcx>,\n+    ret_ty: Type,\n+    op: hir::BinOp_\n+) -> ValueRef {\n     let signed = match t.sty {\n         ty::TyFloat(_) => {\n             let cmp = bin_op_to_fcmp_predicate(op);\n@@ -216,11 +217,12 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n }\n \n /// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n-pub fn unsize_thin_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                   src: ValueRef,\n-                                   src_ty: Ty<'tcx>,\n-                                   dst_ty: Ty<'tcx>)\n-                                   -> (ValueRef, ValueRef) {\n+pub fn unsize_thin_ptr<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    src: ValueRef,\n+    src_ty: Ty<'tcx>,\n+    dst_ty: Ty<'tcx>\n+) -> (ValueRef, ValueRef) {\n     debug!(\"unsize_thin_ptr: {:?} => {:?}\", src_ty, dst_ty);\n     match (&src_ty.sty, &dst_ty.sty) {\n         (&ty::TyBox(a), &ty::TyBox(b)) |\n@@ -240,11 +242,11 @@ pub fn unsize_thin_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n \n /// Coerce `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty` and store the result in `dst`\n-pub fn coerce_unsized_into<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                       src: ValueRef,\n-                                       src_ty: Ty<'tcx>,\n-                                       dst: ValueRef,\n-                                       dst_ty: Ty<'tcx>) {\n+pub fn coerce_unsized_into<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+                                     src: ValueRef,\n+                                     src_ty: Ty<'tcx>,\n+                                     dst: ValueRef,\n+                                     dst_ty: Ty<'tcx>) {\n     match (&src_ty.sty, &dst_ty.sty) {\n         (&ty::TyBox(..), &ty::TyBox(..)) |\n         (&ty::TyRef(..), &ty::TyRef(..)) |\n@@ -420,9 +422,7 @@ pub fn load_ty<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) -> V\n \n /// Helper for storing values in memory. Does the necessary conversion if the in-memory type\n /// differs from the type used for SSA values.\n-pub fn store_ty<'blk, 'tcx>(\n-    cx: &BlockAndBuilder<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t: Ty<'tcx>\n-) {\n+pub fn store_ty<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>, v: ValueRef, dst: ValueRef, t: Ty<'tcx>) {\n     debug!(\"store_ty: {:?} : {:?} <- {:?}\", Value(dst), t, Value(v));\n \n     if common::type_is_fat_ptr(cx.tcx(), t) {\n@@ -434,23 +434,19 @@ pub fn store_ty<'blk, 'tcx>(\n     }\n }\n \n-pub fn store_fat_ptr<'blk, 'tcx>(cx: &BlockAndBuilder<'blk, 'tcx>,\n-                                 data: ValueRef,\n-                                 extra: ValueRef,\n-                                 dst: ValueRef,\n-                                 _ty: Ty<'tcx>) {\n+pub fn store_fat_ptr<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>,\n+                               data: ValueRef,\n+                               extra: ValueRef,\n+                               dst: ValueRef,\n+                               _ty: Ty<'tcx>) {\n     // FIXME: emit metadata\n     cx.store(data, get_dataptr(cx, dst));\n     cx.store(extra, get_meta(cx, dst));\n }\n \n pub fn load_fat_ptr<'a, 'tcx>(\n-    b: &Builder<'a, 'tcx>,\n-    src: ValueRef,\n-    t: Ty<'tcx>)\n-    -> (ValueRef, ValueRef)\n-{\n-\n+    b: &Builder<'a, 'tcx>, src: ValueRef, t: Ty<'tcx>\n+) -> (ValueRef, ValueRef) {\n     let ptr = get_dataptr(b, src);\n     let ptr = if t.is_region_ptr() || t.is_unique() {\n         b.load_nonnull(ptr)\n@@ -511,7 +507,7 @@ impl Lifetime {\n     }\n }\n \n-pub fn call_memcpy<'bcx, 'tcx>(b: &Builder<'bcx, 'tcx>,\n+pub fn call_memcpy<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n                                dst: ValueRef,\n                                src: ValueRef,\n                                n_bytes: ValueRef,\n@@ -528,8 +524,8 @@ pub fn call_memcpy<'bcx, 'tcx>(b: &Builder<'bcx, 'tcx>,\n     b.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n }\n \n-pub fn memcpy_ty<'blk, 'tcx>(\n-    bcx: &BlockAndBuilder<'blk, 'tcx>, dst: ValueRef, src: ValueRef, t: Ty<'tcx>\n+pub fn memcpy_ty<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>, dst: ValueRef, src: ValueRef, t: Ty<'tcx>\n ) {\n     let ccx = bcx.ccx();\n \n@@ -550,7 +546,7 @@ pub fn memcpy_ty<'blk, 'tcx>(\n     }\n }\n \n-pub fn call_memset<'bcx, 'tcx>(b: &Builder<'bcx, 'tcx>,\n+pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n                                ptr: ValueRef,\n                                fill_byte: ValueRef,\n                                size: ValueRef,\n@@ -563,22 +559,20 @@ pub fn call_memset<'bcx, 'tcx>(b: &Builder<'bcx, 'tcx>,\n     b.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None)\n }\n \n-pub fn alloc_ty<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                            ty: Ty<'tcx>,\n-                            name: &str) -> ValueRef {\n+pub fn alloc_ty<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, ty: Ty<'tcx>, name: &str) -> ValueRef {\n     assert!(!ty.has_param_types());\n     bcx.fcx().alloca(type_of::type_of(bcx.ccx(), ty), name)\n }\n \n-impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n+impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     /// Ties up the llstaticallocas -> llloadenv -> lltop edges,\n     /// and builds the return block.\n-    pub fn finish(&'blk self, ret_cx: &BlockAndBuilder<'blk, 'tcx>) {\n+    pub fn finish(&'a self, ret_cx: &BlockAndBuilder<'a, 'tcx>) {\n         self.build_return_block(ret_cx);\n     }\n \n     // Builds the return block for a function.\n-    pub fn build_return_block(&self, ret_cx: &BlockAndBuilder<'blk, 'tcx>) {\n+    pub fn build_return_block(&self, ret_cx: &BlockAndBuilder<'a, 'tcx>) {\n         if self.llretslotptr.is_none() || self.fn_ty.ret.is_indirect() {\n             return ret_cx.ret_void();\n         }"}, {"sha": "136d1aad31a03965077995779028848e8b3ae033", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "patch": "@@ -30,7 +30,7 @@ pub struct Builder<'a, 'tcx: 'a> {\n     pub ccx: &'a CrateContext<'a, 'tcx>,\n }\n \n-impl<'blk, 'tcx> Drop for Builder<'blk, 'tcx> {\n+impl<'a, 'tcx> Drop for Builder<'a, 'tcx> {\n     fn drop(&mut self) {\n         unsafe {\n             llvm::LLVMDisposeBuilder(self.llbuilder);"}, {"sha": "23351e01df8cfc10851293ec88bbfb54543d81a4", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "patch": "@@ -189,10 +189,12 @@ impl<'tcx> Callee<'tcx> {\n     /// For non-lang items, `dest` is always Some, and hence the result is written\n     /// into memory somewhere. Nonetheless we return the actual return value of the\n     /// function.\n-    pub fn call<'a, 'blk>(self, bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                          args: &[ValueRef],\n-                          dest: Option<ValueRef>,\n-                          lpad: Option<&'blk llvm::OperandBundleDef>) {\n+    pub fn call<'a>(self,\n+        bcx: &BlockAndBuilder<'a, 'tcx>,\n+        args: &[ValueRef],\n+        dest: Option<ValueRef>,\n+        lpad: Option<&'a llvm::OperandBundleDef>\n+    ) {\n         trans_call_inner(bcx, self, args, dest, lpad)\n     }\n \n@@ -647,11 +649,13 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n // ______________________________________________________________________\n // Translating calls\n \n-fn trans_call_inner<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                    callee: Callee<'tcx>,\n-                                    args: &[ValueRef],\n-                                    dest: Option<ValueRef>,\n-                                    lpad: Option<&'blk llvm::OperandBundleDef>) {\n+fn trans_call_inner<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    callee: Callee<'tcx>,\n+    args: &[ValueRef],\n+    dest: Option<ValueRef>,\n+    lpad: Option<&'a llvm::OperandBundleDef>\n+) {\n     // Introduce a temporary cleanup scope that will contain cleanups\n     // for the arguments while they are being evaluated. The purpose\n     // this cleanup is to ensure that, should a panic occur while"}, {"sha": "ee02fe1d7f5cf0420f8153d5f518aea6255ee2d1", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "patch": "@@ -43,7 +43,7 @@ pub struct DropValue<'tcx> {\n }\n \n impl<'tcx> DropValue<'tcx> {\n-    fn trans<'blk>(&self, funclet: Option<&'blk Funclet>, bcx: &BlockAndBuilder<'blk, 'tcx>) {\n+    fn trans<'a>(&self, funclet: Option<&'a Funclet>, bcx: &BlockAndBuilder<'a, 'tcx>) {\n         glue::call_drop_glue(bcx, self.val, self.ty, self.skip_dtor, funclet)\n     }\n }\n@@ -93,7 +93,7 @@ impl PartialEq for UnwindKind {\n     }\n }\n \n-impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n+impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     /// Schedules a (deep) drop of `val`, which is a pointer to an instance of `ty`\n     pub fn schedule_drop_mem(&self, val: ValueRef, ty: Ty<'tcx>) -> CleanupScope<'tcx> {\n         if !self.type_needs_drop(ty) { return CleanupScope::noop(); }"}, {"sha": "123e0609f069339aa9a5b30568ff8086e2b9add0", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "patch": "@@ -480,7 +480,7 @@ impl<'a, 'tcx> Drop for FunctionContext<'a, 'tcx> {\n }\n \n #[must_use]\n-pub struct BlockAndBuilder<'blk, 'tcx: 'blk> {\n+pub struct BlockAndBuilder<'a, 'tcx: 'a> {\n     // The BasicBlockRef returned from a call to\n     // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n     // block to the function pointed to by llfn.  We insert\n@@ -490,13 +490,13 @@ pub struct BlockAndBuilder<'blk, 'tcx: 'blk> {\n \n     // The function context for the function to which this block is\n     // attached.\n-    fcx: &'blk FunctionContext<'blk, 'tcx>,\n+    fcx: &'a FunctionContext<'a, 'tcx>,\n \n-    builder: Builder<'blk, 'tcx>,\n+    builder: Builder<'a, 'tcx>,\n }\n \n-impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n-    pub fn new(llbb: BasicBlockRef, fcx: &'blk FunctionContext<'blk, 'tcx>) -> Self {\n+impl<'a, 'tcx> BlockAndBuilder<'a, 'tcx> {\n+    pub fn new(llbb: BasicBlockRef, fcx: &'a FunctionContext<'a, 'tcx>) -> Self {\n         let builder = Builder::with_ccx(fcx.ccx);\n         // Set the builder's position to this block's end.\n         builder.position_at_end(llbb);\n@@ -512,24 +512,24 @@ impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n     }\n \n     pub fn at_start<F, R>(&self, f: F) -> R\n-        where F: FnOnce(&BlockAndBuilder<'blk, 'tcx>) -> R\n+        where F: FnOnce(&BlockAndBuilder<'a, 'tcx>) -> R\n     {\n         self.position_at_start(self.llbb);\n         let r = f(self);\n         self.position_at_end(self.llbb);\n         r\n     }\n \n-    pub fn ccx(&self) -> &'blk CrateContext<'blk, 'tcx> {\n+    pub fn ccx(&self) -> &'a CrateContext<'a, 'tcx> {\n         self.fcx.ccx\n     }\n-    pub fn fcx(&self) -> &'blk FunctionContext<'blk, 'tcx> {\n+    pub fn fcx(&self) -> &'a FunctionContext<'a, 'tcx> {\n         self.fcx\n     }\n-    pub fn tcx(&self) -> TyCtxt<'blk, 'tcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.fcx.ccx.tcx()\n     }\n-    pub fn sess(&self) -> &'blk Session {\n+    pub fn sess(&self) -> &'a Session {\n         self.fcx.ccx.sess()\n     }\n \n@@ -538,8 +538,8 @@ impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n     }\n }\n \n-impl<'blk, 'tcx> Deref for BlockAndBuilder<'blk, 'tcx> {\n-    type Target = Builder<'blk, 'tcx>;\n+impl<'a, 'tcx> Deref for BlockAndBuilder<'a, 'tcx> {\n+    type Target = Builder<'a, 'tcx>;\n     fn deref(&self) -> &Self::Target {\n         &self.builder\n     }\n@@ -896,19 +896,20 @@ pub fn langcall(tcx: TyCtxt,\n // all shifts). For 32- and 64-bit types, this matches the semantics\n // of Java. (See related discussion on #1877 and #10183.)\n \n-pub fn build_unchecked_lshift<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                          lhs: ValueRef,\n-                                          rhs: ValueRef) -> ValueRef {\n+pub fn build_unchecked_lshift<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    lhs: ValueRef,\n+    rhs: ValueRef\n+) -> ValueRef {\n     let rhs = base::cast_shift_expr_rhs(bcx, hir::BinOp_::BiShl, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bcx, rhs);\n     bcx.shl(lhs, rhs)\n }\n \n-pub fn build_unchecked_rshift<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                          lhs_t: Ty<'tcx>,\n-                                          lhs: ValueRef,\n-                                          rhs: ValueRef) -> ValueRef {\n+pub fn build_unchecked_rshift<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>, lhs_t: Ty<'tcx>, lhs: ValueRef, rhs: ValueRef\n+) -> ValueRef {\n     let rhs = base::cast_shift_expr_rhs(bcx, hir::BinOp_::BiShr, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bcx, rhs);\n@@ -920,14 +921,13 @@ pub fn build_unchecked_rshift<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n     }\n }\n \n-fn shift_mask_rhs<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                              rhs: ValueRef) -> ValueRef {\n+fn shift_mask_rhs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, rhs: ValueRef) -> ValueRef {\n     let rhs_llty = val_ty(rhs);\n     bcx.and(rhs, shift_mask_val(bcx, rhs_llty, rhs_llty, false))\n }\n \n-pub fn shift_mask_val<'blk, 'tcx>(\n-    bcx: &BlockAndBuilder<'blk, 'tcx>,\n+pub fn shift_mask_val<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n     llty: Type,\n     mask_llty: Type,\n     invert: bool"}, {"sha": "c130c4bc99399670df7e4f09b6d49151fddc3fc8", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "patch": "@@ -431,13 +431,13 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn declare_local<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                 variable_name: ast::Name,\n-                                 variable_type: Ty<'tcx>,\n-                                 scope_metadata: DIScope,\n-                                 variable_access: VariableAccess,\n-                                 variable_kind: VariableKind,\n-                                 span: Span) {\n+pub fn declare_local<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+                               variable_name: ast::Name,\n+                               variable_type: Ty<'tcx>,\n+                               scope_metadata: DIScope,\n+                               variable_access: VariableAccess,\n+                               variable_kind: VariableKind,\n+                               span: Span) {\n     let cx: &CrateContext = bcx.ccx();\n \n     let file = span_start(cx, span).file;"}, {"sha": "26445efe06c044a23de01191bd07eb1633d76dfa", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "patch": "@@ -36,18 +36,20 @@ use cleanup::CleanupScope;\n \n use syntax_pos::DUMMY_SP;\n \n-pub fn trans_exchange_free_dyn<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                           v: ValueRef,\n-                                           size: ValueRef,\n-                                           align: ValueRef) {\n+pub fn trans_exchange_free_dyn<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    v: ValueRef,\n+    size: ValueRef,\n+    align: ValueRef\n+) {\n     let def_id = langcall(bcx.tcx(), None, \"\", ExchangeFreeFnLangItem);\n     let args = [bcx.pointercast(v, Type::i8p(bcx.ccx())), size, align];\n     Callee::def(bcx.ccx(), def_id, bcx.tcx().intern_substs(&[])).call(&bcx, &args, None, None)\n }\n \n-pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                          ptr: ValueRef,\n-                                          content_ty: Ty<'tcx>) {\n+pub fn trans_exchange_free_ty<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>, ptr: ValueRef, content_ty: Ty<'tcx>\n+) {\n     assert!(type_is_sized(bcx.ccx().tcx(), content_ty));\n     let sizing_type = sizing_type_of(bcx.ccx(), content_ty);\n     let content_size = llsize_of_alloc(bcx.ccx(), sizing_type);\n@@ -104,16 +106,16 @@ pub fn get_drop_glue_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, t: Ty<'tcx>) ->\n     }\n }\n \n-fn drop_ty<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>, v: ValueRef, t: Ty<'tcx>) {\n+fn drop_ty<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, v: ValueRef, t: Ty<'tcx>) {\n     call_drop_glue(bcx, v, t, false, None)\n }\n \n-pub fn call_drop_glue<'blk, 'tcx>(\n-    bcx: &BlockAndBuilder<'blk, 'tcx>,\n+pub fn call_drop_glue<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n     v: ValueRef,\n     t: Ty<'tcx>,\n     skip_dtor: bool,\n-    funclet: Option<&'blk Funclet>,\n+    funclet: Option<&'a Funclet>,\n ) {\n     // NB: v is an *alias* of type t here, not a direct value.\n     debug!(\"call_drop_glue(t={:?}, skip_dtor={})\", t, skip_dtor);\n@@ -181,8 +183,7 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKind<'t\n     }\n }\n \n-pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                     g: DropGlueKind<'tcx>) {\n+pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKind<'tcx>) {\n     let tcx = ccx.tcx();\n     assert_eq!(g.ty(), get_drop_glue_type(tcx, g.ty()));\n     let (llfn, fn_ty) = ccx.drop_glues().borrow().get(&g).unwrap().clone();\n@@ -203,11 +204,11 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     fcx.finish(&bcx);\n }\n \n-fn trans_custom_dtor<'blk, 'tcx>(mut bcx: BlockAndBuilder<'blk, 'tcx>,\n-                                 t: Ty<'tcx>,\n-                                 v0: ValueRef,\n-                                 shallow_drop: bool)\n-                                 -> BlockAndBuilder<'blk, 'tcx>\n+fn trans_custom_dtor<'a, 'tcx>(mut bcx: BlockAndBuilder<'a, 'tcx>,\n+                               t: Ty<'tcx>,\n+                               v0: ValueRef,\n+                               shallow_drop: bool)\n+                               -> BlockAndBuilder<'a, 'tcx>\n {\n     debug!(\"trans_custom_dtor t: {}\", t);\n     let tcx = bcx.tcx();\n@@ -265,9 +266,9 @@ fn trans_custom_dtor<'blk, 'tcx>(mut bcx: BlockAndBuilder<'blk, 'tcx>,\n     bcx\n }\n \n-pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                         t: Ty<'tcx>, info: ValueRef)\n-                                         -> (ValueRef, ValueRef) {\n+pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+                                       t: Ty<'tcx>, info: ValueRef)\n+                                       -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n            t, Value(info));\n     if type_is_sized(bcx.tcx(), t) {\n@@ -372,10 +373,10 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n     }\n }\n \n-fn make_drop_glue<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n-                              v0: ValueRef,\n-                              g: DropGlueKind<'tcx>)\n-                              -> BlockAndBuilder<'blk, 'tcx> {\n+fn make_drop_glue<'a, 'tcx>(bcx: BlockAndBuilder<'a, 'tcx>,\n+                            v0: ValueRef,\n+                            g: DropGlueKind<'tcx>)\n+                            -> BlockAndBuilder<'a, 'tcx> {\n     let t = g.ty();\n \n     let skip_dtor = match g { DropGlueKind::Ty(_) => false, DropGlueKind::TyContents(_) => true };\n@@ -454,15 +455,15 @@ fn make_drop_glue<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n }\n \n // Iterates through the elements of a structural type, dropping them.\n-fn drop_structural_ty<'blk, 'tcx>(cx: BlockAndBuilder<'blk, 'tcx>,\n-                                  av: ValueRef,\n-                                  t: Ty<'tcx>)\n-                                  -> BlockAndBuilder<'blk, 'tcx> {\n-    fn iter_variant<'blk, 'tcx>(cx: &BlockAndBuilder<'blk, 'tcx>,\n-                                t: Ty<'tcx>,\n-                                av: adt::MaybeSizedValue,\n-                                variant: &'tcx ty::VariantDef,\n-                                substs: &Substs<'tcx>) {\n+fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n+                                av: ValueRef,\n+                                t: Ty<'tcx>)\n+                                -> BlockAndBuilder<'a, 'tcx> {\n+    fn iter_variant<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>,\n+                              t: Ty<'tcx>,\n+                              av: adt::MaybeSizedValue,\n+                              variant: &'tcx ty::VariantDef,\n+                              substs: &Substs<'tcx>) {\n         let tcx = cx.tcx();\n         for (i, field) in variant.fields.iter().enumerate() {\n             let arg = monomorphize::field_ty(tcx, substs, field);"}, {"sha": "caa4e75f0b02a172c89908333a7cf8c85b37dc43", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "patch": "@@ -84,12 +84,12 @@ fn get_simple_intrinsic(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n /// Remember to add all intrinsics here, in librustc_typeck/check/mod.rs,\n /// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n /// add them to librustc_trans/trans/context.rs\n-pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                            callee_ty: Ty<'tcx>,\n-                                            fn_ty: &FnType,\n-                                            llargs: &[ValueRef],\n-                                            llresult: ValueRef,\n-                                            span: Span) {\n+pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+                                      callee_ty: Ty<'tcx>,\n+                                      fn_ty: &FnType,\n+                                      llargs: &[ValueRef],\n+                                      llresult: ValueRef,\n+                                      span: Span) {\n     let fcx = bcx.fcx();\n     let ccx = fcx.ccx;\n     let tcx = bcx.tcx();\n@@ -537,11 +537,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n             // qux` to be converted into `foo, bar, baz, qux`, integer\n             // arguments to be truncated as needed and pointers to be\n             // cast.\n-            fn modify_as_needed<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                            t: &intrinsics::Type,\n-                                            arg_type: Ty<'tcx>,\n-                                            llarg: ValueRef)\n-                                            -> Vec<ValueRef>\n+            fn modify_as_needed<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+                                          t: &intrinsics::Type,\n+                                          arg_type: Ty<'tcx>,\n+                                          llarg: ValueRef)\n+                                          -> Vec<ValueRef>\n             {\n                 match *t {\n                     intrinsics::Type::Aggregate(true, ref contents) => {\n@@ -642,14 +642,14 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n     }\n }\n \n-fn copy_intrinsic<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                              allow_overlap: bool,\n-                              volatile: bool,\n-                              tp_ty: Ty<'tcx>,\n-                              dst: ValueRef,\n-                              src: ValueRef,\n-                              count: ValueRef)\n-                              -> ValueRef {\n+fn copy_intrinsic<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+                            allow_overlap: bool,\n+                            volatile: bool,\n+                            tp_ty: Ty<'tcx>,\n+                            dst: ValueRef,\n+                            src: ValueRef,\n+                            count: ValueRef)\n+                            -> ValueRef {\n     let ccx = bcx.ccx();\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n     let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n@@ -677,8 +677,8 @@ fn copy_intrinsic<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n         None)\n }\n \n-fn memset_intrinsic<'blk, 'tcx>(\n-    bcx: &BlockAndBuilder<'blk, 'tcx>,\n+fn memset_intrinsic<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n     volatile: bool,\n     ty: Ty<'tcx>,\n     dst: ValueRef,\n@@ -693,8 +693,8 @@ fn memset_intrinsic<'blk, 'tcx>(\n     call_memset(bcx, dst, val, bcx.mul(size, count), align, volatile)\n }\n \n-fn try_intrinsic<'blk, 'tcx>(\n-    bcx: &BlockAndBuilder<'blk, 'tcx>,\n+fn try_intrinsic<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n     func: ValueRef,\n     data: ValueRef,\n     local_ptr: ValueRef,\n@@ -717,11 +717,11 @@ fn try_intrinsic<'blk, 'tcx>(\n // instructions are meant to work for all targets, as of the time of this\n // writing, however, LLVM does not recommend the usage of these new instructions\n // as the old ones are still more optimized.\n-fn trans_msvc_try<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                              func: ValueRef,\n-                              data: ValueRef,\n-                              local_ptr: ValueRef,\n-                              dest: ValueRef) {\n+fn trans_msvc_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+                            func: ValueRef,\n+                            data: ValueRef,\n+                            local_ptr: ValueRef,\n+                            dest: ValueRef) {\n     let llfn = get_rust_try_fn(bcx.fcx(), &mut |bcx| {\n         let ccx = bcx.ccx();\n \n@@ -820,11 +820,11 @@ fn trans_msvc_try<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n // function calling it, and that function may already have other personality\n // functions in play. By calling a shim we're guaranteed that our shim will have\n // the right personality function.\n-fn trans_gnu_try<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                             func: ValueRef,\n-                             data: ValueRef,\n-                             local_ptr: ValueRef,\n-                             dest: ValueRef) {\n+fn trans_gnu_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+                           func: ValueRef,\n+                           data: ValueRef,\n+                           local_ptr: ValueRef,\n+                           dest: ValueRef) {\n     let llfn = get_rust_try_fn(bcx.fcx(), &mut |bcx| {\n         let ccx = bcx.ccx();\n \n@@ -928,8 +928,8 @@ fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n     span_err!(a, b, E0511, \"{}\", c);\n }\n \n-fn generic_simd_intrinsic<'blk, 'tcx, 'a>(\n-    bcx: &BlockAndBuilder<'blk, 'tcx>,\n+fn generic_simd_intrinsic<'a, 'tcx>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n     name: &str,\n     callee_ty: Ty<'tcx>,\n     llargs: &[ValueRef],"}, {"sha": "b8901231f1c0954246f94c4b834a0f27a4aa2890", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "patch": "@@ -28,10 +28,10 @@ use rustc::ty;\n const VTABLE_OFFSET: usize = 3;\n \n /// Extracts a method from a trait object's vtable, at the specified index.\n-pub fn get_virtual_method<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                      llvtable: ValueRef,\n-                                      vtable_index: usize)\n-                                      -> ValueRef {\n+pub fn get_virtual_method<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+                                    llvtable: ValueRef,\n+                                    vtable_index: usize)\n+                                    -> ValueRef {\n     // Load the data pointer from the object.\n     debug!(\"get_virtual_method(vtable_index={}, llvtable={:?})\",\n            vtable_index, Value(llvtable));"}, {"sha": "21b021cacc985e9d1f9943b956f3b9072351b782", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "patch": "@@ -20,8 +20,7 @@ use common::{self, BlockAndBuilder};\n use glue;\n use super::rvalue;\n \n-pub fn lvalue_locals<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx,'tcx>,\n-                                 mir: &mir::Mir<'tcx>) -> BitVector {\n+pub fn lvalue_locals<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, mir: &mir::Mir<'tcx>) -> BitVector {\n     let mut analyzer = LocalAnalyzer::new(mir, &bcx);\n \n     analyzer.visit_mir(mir);\n@@ -55,17 +54,16 @@ pub fn lvalue_locals<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx,'tcx>,\n     analyzer.lvalue_locals\n }\n \n-struct LocalAnalyzer<'mir, 'bcx: 'mir, 'tcx: 'bcx> {\n+struct LocalAnalyzer<'mir, 'a: 'mir, 'tcx: 'a> {\n     mir: &'mir mir::Mir<'tcx>,\n-    bcx: &'mir BlockAndBuilder<'bcx, 'tcx>,\n+    bcx: &'mir BlockAndBuilder<'a, 'tcx>,\n     lvalue_locals: BitVector,\n     seen_assigned: BitVector\n }\n \n-impl<'mir, 'bcx, 'tcx> LocalAnalyzer<'mir, 'bcx, 'tcx> {\n-    fn new(mir: &'mir mir::Mir<'tcx>,\n-           bcx: &'mir BlockAndBuilder<'bcx, 'tcx>)\n-           -> LocalAnalyzer<'mir, 'bcx, 'tcx> {\n+impl<'mir, 'a, 'tcx> LocalAnalyzer<'mir, 'a, 'tcx> {\n+    fn new(mir: &'mir mir::Mir<'tcx>, bcx: &'mir BlockAndBuilder<'a, 'tcx>)\n+           -> LocalAnalyzer<'mir, 'a, 'tcx> {\n         LocalAnalyzer {\n             mir: mir,\n             bcx: bcx,\n@@ -86,7 +84,7 @@ impl<'mir, 'bcx, 'tcx> LocalAnalyzer<'mir, 'bcx, 'tcx> {\n     }\n }\n \n-impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'bcx, 'tcx> {\n+impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n     fn visit_assign(&mut self,\n                     block: mir::BasicBlock,\n                     lvalue: &mir::Lvalue<'tcx>,\n@@ -199,7 +197,7 @@ pub enum CleanupKind {\n     Internal { funclet: mir::BasicBlock }\n }\n \n-pub fn cleanup_kinds<'bcx,'tcx>(mir: &mir::Mir<'tcx>) -> IndexVec<mir::BasicBlock, CleanupKind> {\n+pub fn cleanup_kinds<'a, 'tcx>(mir: &mir::Mir<'tcx>) -> IndexVec<mir::BasicBlock, CleanupKind> {\n     fn discover_masters<'tcx>(result: &mut IndexVec<mir::BasicBlock, CleanupKind>,\n                               mir: &mir::Mir<'tcx>) {\n         for (bb, data) in mir.basic_blocks().iter_enumerated() {"}, {"sha": "99b598baf84124a525c3345fe11a0d479c329e89", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "patch": "@@ -40,7 +40,7 @@ use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n use std::ptr;\n \n-impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_block(&mut self, bb: mir::BasicBlock,\n         funclets: &IndexVec<mir::BasicBlock, Option<Funclet>>) {\n         let mut bcx = self.build_block(bb);\n@@ -669,7 +669,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n \n     fn trans_argument(&mut self,\n-                      bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                      bcx: &BlockAndBuilder<'a, 'tcx>,\n                       op: OperandRef<'tcx>,\n                       llargs: &mut Vec<ValueRef>,\n                       fn_ty: &FnType,\n@@ -745,7 +745,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n \n     fn trans_arguments_untupled(&mut self,\n-                                bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                                bcx: &BlockAndBuilder<'a, 'tcx>,\n                                 operand: &mir::Operand<'tcx>,\n                                 llargs: &mut Vec<ValueRef>,\n                                 fn_ty: &FnType,\n@@ -821,7 +821,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n     }\n \n-    fn get_personality_slot(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>) -> ValueRef {\n+    fn get_personality_slot(&mut self, bcx: &BlockAndBuilder<'a, 'tcx>) -> ValueRef {\n         let ccx = bcx.ccx();\n         if let Some(slot) = self.llpersonalityslot {\n             slot\n@@ -897,11 +897,11 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         })\n     }\n \n-    fn build_block(&self, bb: mir::BasicBlock) -> BlockAndBuilder<'bcx, 'tcx> {\n+    fn build_block(&self, bb: mir::BasicBlock) -> BlockAndBuilder<'a, 'tcx> {\n         BlockAndBuilder::new(self.blocks[bb], self.fcx)\n     }\n \n-    fn make_return_dest(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+    fn make_return_dest(&mut self, bcx: &BlockAndBuilder<'a, 'tcx>,\n                         dest: &mir::Lvalue<'tcx>, fn_ret_ty: &ArgType,\n                         llargs: &mut Vec<ValueRef>, is_intrinsic: bool) -> ReturnDest {\n         // If the return is ignored, we can just return a do-nothing ReturnDest\n@@ -946,7 +946,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         }\n     }\n \n-    fn trans_transmute(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+    fn trans_transmute(&mut self, bcx: &BlockAndBuilder<'a, 'tcx>,\n                        src: &mir::Operand<'tcx>, dst: LvalueRef<'tcx>) {\n         let mut val = self.trans_operand(bcx, src);\n         if let ty::TyFnDef(def_id, substs, _) = val.ty.sty {\n@@ -974,7 +974,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n     // Stores the return value of a function call into it's final location.\n     fn store_return(&mut self,\n-                    bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                    bcx: &BlockAndBuilder<'a, 'tcx>,\n                     dest: ReturnDest,\n                     ret_ty: ArgType,\n                     op: OperandRef<'tcx>) {"}, {"sha": "03ee6b136a4f055ed57fd49dd5da38fd5db46f37", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "patch": "@@ -945,9 +945,9 @@ pub fn const_scalar_checked_binop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_constant(&mut self,\n-                          bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                          bcx: &BlockAndBuilder<'a, 'tcx>,\n                           constant: &mir::Constant<'tcx>)\n                           -> Const<'tcx>\n     {"}, {"sha": "5bfe614f45e7f846416e7285b5ec8c157ca76bcc", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "patch": "@@ -44,7 +44,7 @@ impl<'tcx> LvalueRef<'tcx> {\n         LvalueRef { llval: llval, llextra: ptr::null_mut(), ty: lvalue_ty }\n     }\n \n-    pub fn alloca<'bcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+    pub fn alloca<'a>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                         ty: Ty<'tcx>,\n                         name: &str)\n                         -> LvalueRef<'tcx>\n@@ -67,9 +67,9 @@ impl<'tcx> LvalueRef<'tcx> {\n     }\n }\n \n-impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_lvalue(&mut self,\n-                        bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                        bcx: &BlockAndBuilder<'a, 'tcx>,\n                         lvalue: &mir::Lvalue<'tcx>)\n                         -> LvalueRef<'tcx> {\n         debug!(\"trans_lvalue(lvalue={:?})\", lvalue);\n@@ -214,7 +214,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     // Perform an action using the given Lvalue.\n     // If the Lvalue is an empty LocalRef::Operand, then a temporary stack slot\n     // is created first, then used as an operand to update the Lvalue.\n-    pub fn with_lvalue_ref<F, U>(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+    pub fn with_lvalue_ref<F, U>(&mut self, bcx: &BlockAndBuilder<'a, 'tcx>,\n                                  lvalue: &mir::Lvalue<'tcx>, f: F) -> U\n     where F: FnOnce(&mut Self, LvalueRef<'tcx>) -> U\n     {\n@@ -255,7 +255,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     ///\n     /// nmatsakis: is this still necessary? Not sure.\n     fn prepare_index(&mut self,\n-                     bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                     bcx: &BlockAndBuilder<'a, 'tcx>,\n                      llindex: ValueRef)\n                      -> ValueRef\n     {"}, {"sha": "8a0e5e107a80cb23f22be1ac29611736f393cfb3", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "patch": "@@ -39,11 +39,11 @@ use rustc::mir::traversal;\n use self::operand::{OperandRef, OperandValue};\n \n /// Master context for translating MIR.\n-pub struct MirContext<'bcx, 'tcx:'bcx> {\n-    mir: &'bcx mir::Mir<'tcx>,\n+pub struct MirContext<'a, 'tcx:'a> {\n+    mir: &'a mir::Mir<'tcx>,\n \n     /// Function context\n-    fcx: &'bcx common::FunctionContext<'bcx, 'tcx>,\n+    fcx: &'a common::FunctionContext<'a, 'tcx>,\n \n     /// When unwinding is initiated, we have to store this personality\n     /// value somewhere so that we can load it and re-use it in the\n@@ -88,7 +88,7 @@ pub struct MirContext<'bcx, 'tcx:'bcx> {\n     scopes: IndexVec<mir::VisibilityScope, debuginfo::MirDebugScope>,\n }\n \n-impl<'blk, 'tcx> MirContext<'blk, 'tcx> {\n+impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn debug_loc(&mut self, source_info: mir::SourceInfo) -> (DIScope, Span) {\n         // Bail out if debug info emission is not enabled.\n         match self.fcx.debug_context {\n@@ -152,7 +152,7 @@ enum LocalRef<'tcx> {\n }\n \n impl<'tcx> LocalRef<'tcx> {\n-    fn new_operand<'bcx>(ccx: &CrateContext<'bcx, 'tcx>,\n+    fn new_operand<'a>(ccx: &CrateContext<'a, 'tcx>,\n                          ty: ty::Ty<'tcx>) -> LocalRef<'tcx> {\n         if common::type_is_zero_size(ccx, ty) {\n             // Zero-size temporaries aren't always initialized, which\n@@ -178,7 +178,7 @@ impl<'tcx> LocalRef<'tcx> {\n \n ///////////////////////////////////////////////////////////////////////////\n \n-pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>, mir: &'blk Mir<'tcx>) {\n+pub fn trans_mir<'a, 'tcx: 'a>(fcx: &'a FunctionContext<'a, 'tcx>, mir: &'a Mir<'tcx>) {\n     let bcx = fcx.get_entry_block();\n \n     // Analyze the temps to determine which must be lvalues\n@@ -309,11 +309,11 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>, mir:\n /// Produce, for each argument, a `ValueRef` pointing at the\n /// argument's value. As arguments are lvalues, these are always\n /// indirect.\n-fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                              mir: &mir::Mir<'tcx>,\n-                              scopes: &IndexVec<mir::VisibilityScope, debuginfo::MirDebugScope>,\n-                              lvalue_locals: &BitVector)\n-                              -> Vec<LocalRef<'tcx>> {\n+fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+                            mir: &mir::Mir<'tcx>,\n+                            scopes: &IndexVec<mir::VisibilityScope, debuginfo::MirDebugScope>,\n+                            lvalue_locals: &BitVector)\n+                            -> Vec<LocalRef<'tcx>> {\n     let fcx = bcx.fcx();\n     let tcx = bcx.tcx();\n     let mut idx = 0;"}, {"sha": "c89eb9899d11c15672b67b77c4b711cdfa0521c2", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "patch": "@@ -73,7 +73,7 @@ impl<'tcx> fmt::Debug for OperandRef<'tcx> {\n     }\n }\n \n-impl<'bcx, 'tcx> OperandRef<'tcx> {\n+impl<'a, 'tcx> OperandRef<'tcx> {\n     /// Asserts that this operand refers to a scalar and returns\n     /// a reference to its value.\n     pub fn immediate(self) -> ValueRef {\n@@ -85,7 +85,7 @@ impl<'bcx, 'tcx> OperandRef<'tcx> {\n \n     /// If this operand is a Pair, we return an\n     /// Immediate aggregate with the two values.\n-    pub fn pack_if_pair(mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>)\n+    pub fn pack_if_pair(mut self, bcx: &BlockAndBuilder<'a, 'tcx>)\n                         -> OperandRef<'tcx> {\n         if let OperandValue::Pair(a, b) = self.val {\n             // Reconstruct the immediate aggregate.\n@@ -107,7 +107,7 @@ impl<'bcx, 'tcx> OperandRef<'tcx> {\n \n     /// If this operand is a pair in an Immediate,\n     /// we return a Pair with the two halves.\n-    pub fn unpack_if_pair(mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>)\n+    pub fn unpack_if_pair(mut self, bcx: &BlockAndBuilder<'a, 'tcx>)\n                           -> OperandRef<'tcx> {\n         if let OperandValue::Immediate(llval) = self.val {\n             // Deconstruct the immediate aggregate.\n@@ -134,9 +134,9 @@ impl<'bcx, 'tcx> OperandRef<'tcx> {\n     }\n }\n \n-impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_load(&mut self,\n-                      bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                      bcx: &BlockAndBuilder<'a, 'tcx>,\n                       llval: ValueRef,\n                       ty: Ty<'tcx>)\n                       -> OperandRef<'tcx>\n@@ -165,7 +165,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n \n     pub fn trans_consume(&mut self,\n-                         bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                         bcx: &BlockAndBuilder<'a, 'tcx>,\n                          lvalue: &mir::Lvalue<'tcx>)\n                          -> OperandRef<'tcx>\n     {\n@@ -217,7 +217,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n \n     pub fn trans_operand(&mut self,\n-                         bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                         bcx: &BlockAndBuilder<'a, 'tcx>,\n                          operand: &mir::Operand<'tcx>)\n                          -> OperandRef<'tcx>\n     {\n@@ -242,7 +242,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n \n     pub fn store_operand(&mut self,\n-                         bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                         bcx: &BlockAndBuilder<'a, 'tcx>,\n                          lldest: ValueRef,\n                          operand: OperandRef<'tcx>) {\n         debug!(\"store_operand: operand={:?}\", operand);"}, {"sha": "4a532924694c030851f3dfc460b314f0cdf9e4a6", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "patch": "@@ -33,12 +33,12 @@ use super::constant::const_scalar_checked_binop;\n use super::operand::{OperandRef, OperandValue};\n use super::lvalue::{LvalueRef};\n \n-impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n-                        bcx: BlockAndBuilder<'bcx, 'tcx>,\n+                        bcx: BlockAndBuilder<'a, 'tcx>,\n                         dest: LvalueRef<'tcx>,\n                         rvalue: &mir::Rvalue<'tcx>)\n-                        -> BlockAndBuilder<'bcx, 'tcx>\n+                        -> BlockAndBuilder<'a, 'tcx>\n     {\n         debug!(\"trans_rvalue(dest.llval={:?}, rvalue={:?})\",\n                Value(dest.llval), rvalue);\n@@ -175,9 +175,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n \n     pub fn trans_rvalue_operand(&mut self,\n-                                bcx: BlockAndBuilder<'bcx, 'tcx>,\n+                                bcx: BlockAndBuilder<'a, 'tcx>,\n                                 rvalue: &mir::Rvalue<'tcx>)\n-                                -> (BlockAndBuilder<'bcx, 'tcx>, OperandRef<'tcx>)\n+                                -> (BlockAndBuilder<'a, 'tcx>, OperandRef<'tcx>)\n     {\n         assert!(rvalue_creates_operand(&self.mir, &bcx, rvalue),\n                 \"cannot trans {:?} to operand\", rvalue);\n@@ -483,7 +483,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n \n     pub fn trans_scalar_binop(&mut self,\n-                              bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                              bcx: &BlockAndBuilder<'a, 'tcx>,\n                               op: mir::BinOp,\n                               lhs: ValueRef,\n                               rhs: ValueRef,\n@@ -558,7 +558,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n \n     pub fn trans_fat_ptr_binop(&mut self,\n-                               bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                               bcx: &BlockAndBuilder<'a, 'tcx>,\n                                op: mir::BinOp,\n                                lhs_addr: ValueRef,\n                                lhs_extra: ValueRef,\n@@ -605,7 +605,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n \n     pub fn trans_scalar_checked_binop(&mut self,\n-                                      bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                                      bcx: &BlockAndBuilder<'a, 'tcx>,\n                                       op: mir::BinOp,\n                                       lhs: ValueRef,\n                                       rhs: ValueRef,\n@@ -662,9 +662,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n }\n \n-pub fn rvalue_creates_operand<'bcx, 'tcx>(_mir: &mir::Mir<'tcx>,\n-                                          _bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                                          rvalue: &mir::Rvalue<'tcx>) -> bool {\n+pub fn rvalue_creates_operand<'a, 'tcx>(_mir: &mir::Mir<'tcx>,\n+                                        _bcx: &BlockAndBuilder<'a, 'tcx>,\n+                                        rvalue: &mir::Rvalue<'tcx>) -> bool {\n     match *rvalue {\n         mir::Rvalue::Ref(..) |\n         mir::Rvalue::Len(..) |"}, {"sha": "ddbefe43ce4f0f8a0a5d258e4c80d38e50118178", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "patch": "@@ -18,11 +18,11 @@ use super::LocalRef;\n use super::super::adt;\n use super::super::disr::Disr;\n \n-impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_statement(&mut self,\n-                           bcx: BlockAndBuilder<'bcx, 'tcx>,\n+                           bcx: BlockAndBuilder<'a, 'tcx>,\n                            statement: &mir::Statement<'tcx>)\n-                           -> BlockAndBuilder<'bcx, 'tcx> {\n+                           -> BlockAndBuilder<'a, 'tcx> {\n         debug!(\"trans_statement(statement={:?})\", statement);\n \n         let (scope, span) = self.debug_loc(statement.source_info);\n@@ -78,10 +78,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n \n     fn trans_storage_liveness(&self,\n-                              bcx: BlockAndBuilder<'bcx, 'tcx>,\n+                              bcx: BlockAndBuilder<'a, 'tcx>,\n                               lvalue: &mir::Lvalue<'tcx>,\n                               intrinsic: base::Lifetime)\n-                              -> BlockAndBuilder<'bcx, 'tcx> {\n+                              -> BlockAndBuilder<'a, 'tcx> {\n         if let mir::Lvalue::Local(index) = *lvalue {\n             if let LocalRef::Lvalue(tr_lval) = self.locals[index] {\n                 intrinsic.call(&bcx, tr_lval.llval);"}, {"sha": "c693a5ceabedd26202806a44b0a0f3975d0a4163", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=b48e74b5b015cfc3a71e0b7e0f3d12972aab20f6", "patch": "@@ -13,13 +13,13 @@ use llvm::ValueRef;\n use common::*;\n use rustc::ty::Ty;\n \n-pub fn slice_for_each<'blk, 'tcx, F>(\n-    bcx: &BlockAndBuilder<'blk, 'tcx>,\n+pub fn slice_for_each<'a, 'tcx, F>(\n+    bcx: &BlockAndBuilder<'a, 'tcx>,\n     data_ptr: ValueRef,\n     unit_ty: Ty<'tcx>,\n     len: ValueRef,\n     f: F\n-) -> BlockAndBuilder<'blk, 'tcx> where F: FnOnce(&BlockAndBuilder<'blk, 'tcx>, ValueRef) {\n+) -> BlockAndBuilder<'a, 'tcx> where F: FnOnce(&BlockAndBuilder<'a, 'tcx>, ValueRef) {\n     // Special-case vectors with elements of size 0  so they don't go out of bounds (#9890)\n     let zst = type_is_zero_size(bcx.ccx(), unit_ty);\n     let add = |bcx: &BlockAndBuilder, a, b| if zst {"}]}