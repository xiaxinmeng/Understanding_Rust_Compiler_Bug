{"sha": "bac5523ea0025988361a092c1f0e7f4eb90f6ad7", "node_id": "C_kwDOAAsO6NoAKGJhYzU1MjNlYTAwMjU5ODgzNjFhMDkyYzFmMGU3ZjRlYjkwZjZhZDc", "commit": {"author": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-01-09T18:39:02Z"}, "committer": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-03-02T23:43:45Z"}, "message": "Use cgroup quotas for calculating `available_parallelism`\n\nManually tested via\n\n\n```\n// spawn a new cgroup scope for the current user\n$ sudo systemd-run -p CPUQuota=\"300%\" --uid=$(id -u) -tdS\n\n\n// quota.rs\n#![feature(available_parallelism)]\nfn main() {\n    println!(\"{:?}\", std::thread::available_parallelism()); // prints Ok(3)\n}\n```\n\n\nCaveats\n\n* cgroup v1 is ignored\n* funky mountpoints (containing spaces, newlines or control chars) for cgroupfs will not be handled correctly since that would require unescaping /proc/self/mountinfo\n  The escaping behavior of procfs seems to be undocumented. systemd and docker default to `/sys/fs/cgroup` so it should be fine for most systems.\n* quota will be ignored when `sched_getaffinity` doesn't work\n* assumes procfs is mounted under `/proc` and cgroupfs mounted and readable somewhere in the directory tree", "tree": {"sha": "825750b995d9f2c9b1c2bab49094f7196acb5673", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/825750b995d9f2c9b1c2bab49094f7196acb5673"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bac5523ea0025988361a092c1f0e7f4eb90f6ad7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bac5523ea0025988361a092c1f0e7f4eb90f6ad7", "html_url": "https://github.com/rust-lang/rust/commit/bac5523ea0025988361a092c1f0e7f4eb90f6ad7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bac5523ea0025988361a092c1f0e7f4eb90f6ad7/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8769f4ef2fe1efddd1f072485f97f568e7328f79", "url": "https://api.github.com/repos/rust-lang/rust/commits/8769f4ef2fe1efddd1f072485f97f568e7328f79", "html_url": "https://github.com/rust-lang/rust/commit/8769f4ef2fe1efddd1f072485f97f568e7328f79"}], "stats": {"total": 71, "additions": 68, "deletions": 3}, "files": [{"sha": "933210e1ff02ec02c2d18a1004de7ca5dd7dd56c", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 68, "deletions": 3, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/bac5523ea0025988361a092c1f0e7f4eb90f6ad7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac5523ea0025988361a092c1f0e7f4eb90f6ad7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=bac5523ea0025988361a092c1f0e7f4eb90f6ad7", "patch": "@@ -279,10 +279,15 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n         ))] {\n             #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n             {\n+                let quota = cgroup2_quota().unwrap_or(usize::MAX).max(1);\n                 let mut set: libc::cpu_set_t = unsafe { mem::zeroed() };\n-                if unsafe { libc::sched_getaffinity(0, mem::size_of::<libc::cpu_set_t>(), &mut set) } == 0 {\n-                    let count = unsafe { libc::CPU_COUNT(&set) };\n-                    return Ok(unsafe { NonZeroUsize::new_unchecked(count as usize) });\n+                unsafe {\n+                    if libc::sched_getaffinity(0, mem::size_of::<libc::cpu_set_t>(), &mut set) == 0 {\n+                        let count = libc::CPU_COUNT(&set) as usize;\n+                        let count = count.min(quota);\n+                        // SAFETY: affinity mask can't be empty and the quota gets clamped to a minimum of 1\n+                        return Ok(NonZeroUsize::new_unchecked(count));\n+                    }\n                 }\n             }\n             match unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) } {\n@@ -368,6 +373,66 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n     }\n }\n \n+#[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n+fn cgroup2_quota() -> Option<usize> {\n+    use crate::ffi::OsString;\n+    use crate::fs::{read, read_to_string, File};\n+    use crate::io::{BufRead, BufReader};\n+    use crate::os::unix::ffi::OsStringExt;\n+    use crate::path::PathBuf;\n+\n+    // find cgroup2 fs\n+    let cgroups_mount = BufReader::new(File::open(\"/proc/self/mountinfo\").ok()?)\n+        .split(b'\\n')\n+        .map_while(Result::ok)\n+        .filter_map(|line| {\n+            let fields: Vec<_> = line.split(|&c| c == b' ').collect();\n+            let suffix_at = fields.iter().position(|f| f == b\"-\")?;\n+            let fs_type = fields[suffix_at + 1];\n+            if fs_type == b\"cgroup2\" { Some(fields[4].to_owned()) } else { None }\n+        })\n+        .next()?;\n+\n+    let cgroups_mount = PathBuf::from(OsString::from_vec(cgroups_mount));\n+\n+    // find our place in the hierarchy\n+    let cgroup_path = read(\"/proc/self/cgroup\")\n+        .ok()?\n+        .split(|&c| c == b'\\n')\n+        .filter_map(|line| {\n+            let mut fields = line.splitn(3, |&c| c == b':');\n+            // expect cgroupv2 which has an empty 2nd field\n+            if fields.nth(1) != Some(b\"\") {\n+                return None;\n+            }\n+            let path = fields.last()?;\n+            // skip leading slash\n+            Some(path[1..].to_owned())\n+        })\n+        .next()?;\n+    let cgroup_path = PathBuf::from(OsString::from_vec(cgroup_path));\n+\n+    // walk hierarchy and take the minimum quota\n+    cgroup_path\n+        .ancestors()\n+        .filter_map(|level| {\n+            let cgroup_path = cgroups_mount.join(level);\n+            let quota = match read_to_string(cgroup_path.join(\"cpu.max\")) {\n+                Ok(quota) => quota,\n+                _ => return None,\n+            };\n+            let quota = quota.lines().next()?;\n+            let mut quota = quota.split(' ');\n+            let limit = quota.next()?;\n+            let period = quota.next()?;\n+            match (limit.parse::<usize>(), period.parse::<usize>()) {\n+                (Ok(limit), Ok(period)) => Some(limit / period),\n+                _ => None,\n+            }\n+        })\n+        .min()\n+}\n+\n #[cfg(all(\n     not(target_os = \"linux\"),\n     not(target_os = \"freebsd\"),"}]}