{"sha": "a5a07e503f524a0e8b92938301857b3007579115", "node_id": "C_kwDOAAsO6NoAKGE1YTA3ZTUwM2Y1MjRhMGU4YjkyOTM4MzAxODU3YjMwMDc1NzkxMTU", "commit": {"author": {"name": "Georgy Komarov", "email": "jubnzv@gmail.com", "date": "2022-01-20T11:50:14Z"}, "committer": {"name": "Georgy Komarov", "email": "jubnzv@gmail.com", "date": "2022-01-20T12:14:25Z"}, "message": "single_match: Don't lint non-exhaustive matches; support tuples\n\nThis commit changes the behavior of `single_match` lint.\n\nAfter that, we won't lint non-exhaustive matches like this:\n\n```rust\nmatch Some(v) {\n    Some(a) => println!(\"${:?}\", a),\n    None => {},\n}\n```\n\nThe rationale is that, because the type of `a` could be changed, so the\nuser can get non-exhaustive match after applying the suggested lint (see\nhttps://github.com/rust-lang/rust-clippy/issues/8282#issuecomment-1013566068\nfor context).\n\nWe also will lint `match` constructions with tuples. When we see the\ntuples on the both arms, we will check them both at the same time, and\nif they form exhaustive match, we could display the warning.\n\nCloses #8282", "tree": {"sha": "25fdd7b0da2584e1cd42c03b83d9db1cd8ec76fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25fdd7b0da2584e1cd42c03b83d9db1cd8ec76fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5a07e503f524a0e8b92938301857b3007579115", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5a07e503f524a0e8b92938301857b3007579115", "html_url": "https://github.com/rust-lang/rust/commit/a5a07e503f524a0e8b92938301857b3007579115", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5a07e503f524a0e8b92938301857b3007579115/comments", "author": {"login": "jubnzv", "id": 12023585, "node_id": "MDQ6VXNlcjEyMDIzNTg1", "avatar_url": "https://avatars.githubusercontent.com/u/12023585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jubnzv", "html_url": "https://github.com/jubnzv", "followers_url": "https://api.github.com/users/jubnzv/followers", "following_url": "https://api.github.com/users/jubnzv/following{/other_user}", "gists_url": "https://api.github.com/users/jubnzv/gists{/gist_id}", "starred_url": "https://api.github.com/users/jubnzv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jubnzv/subscriptions", "organizations_url": "https://api.github.com/users/jubnzv/orgs", "repos_url": "https://api.github.com/users/jubnzv/repos", "events_url": "https://api.github.com/users/jubnzv/events{/privacy}", "received_events_url": "https://api.github.com/users/jubnzv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jubnzv", "id": 12023585, "node_id": "MDQ6VXNlcjEyMDIzNTg1", "avatar_url": "https://avatars.githubusercontent.com/u/12023585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jubnzv", "html_url": "https://github.com/jubnzv", "followers_url": "https://api.github.com/users/jubnzv/followers", "following_url": "https://api.github.com/users/jubnzv/following{/other_user}", "gists_url": "https://api.github.com/users/jubnzv/gists{/gist_id}", "starred_url": "https://api.github.com/users/jubnzv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jubnzv/subscriptions", "organizations_url": "https://api.github.com/users/jubnzv/orgs", "repos_url": "https://api.github.com/users/jubnzv/repos", "events_url": "https://api.github.com/users/jubnzv/events{/privacy}", "received_events_url": "https://api.github.com/users/jubnzv/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "496f26c2297c0117a24c3d26172fd72b5f9ad927", "url": "https://api.github.com/repos/rust-lang/rust/commits/496f26c2297c0117a24c3d26172fd72b5f9ad927", "html_url": "https://github.com/rust-lang/rust/commit/496f26c2297c0117a24c3d26172fd72b5f9ad927"}], "stats": {"total": 275, "additions": 206, "deletions": 69}, "files": [{"sha": "9da052450694c5eeae92b9862413c758e3169704", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 127, "deletions": 18, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/a5a07e503f524a0e8b92938301857b3007579115/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5a07e503f524a0e8b92938301857b3007579115/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=a5a07e503f524a0e8b92938301857b3007579115", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::diagnostics::{\n use clippy_utils::macros::{is_panic, root_macro_call};\n use clippy_utils::source::{expr_block, indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n+use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, peel_mid_ty_refs};\n use clippy_utils::visitors::is_local_used;\n use clippy_utils::{\n     get_parent_expr, is_lang_ctor, is_lint_allowed, is_refutable, is_unit_expr, is_wild, meets_msrv, msrvs,\n@@ -31,7 +31,7 @@ use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::sym;\n-use std::cmp::Ordering;\n+use std::cmp::{max, Ordering};\n use std::collections::hash_map::Entry;\n \n declare_clippy_lint! {\n@@ -741,7 +741,7 @@ fn check_single_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n         let ty = cx.typeck_results().expr_ty(ex);\n         if *ty.kind() != ty::Bool || is_lint_allowed(cx, MATCH_BOOL, ex.hir_id) {\n             check_single_match_single_pattern(cx, ex, arms, expr, els);\n-            check_single_match_opt_like(cx, ex, arms, expr, ty, els);\n+            check_single_match_opt_like(cx, ex, arms, expr, els);\n         }\n     }\n }\n@@ -835,7 +835,6 @@ fn check_single_match_opt_like(\n     ex: &Expr<'_>,\n     arms: &[Arm<'_>],\n     expr: &Expr<'_>,\n-    ty: Ty<'_>,\n     els: Option<&Expr<'_>>,\n ) {\n     // list of candidate `Enum`s we know will never get any more members\n@@ -849,25 +848,135 @@ fn check_single_match_opt_like(\n         (&paths::RESULT, \"Ok\"),\n     ];\n \n-    let path = match arms[1].pat.kind {\n-        PatKind::TupleStruct(ref path, inner, _) => {\n-            // Contains any non wildcard patterns (e.g., `Err(err)`)?\n-            if !inner.iter().all(is_wild) {\n-                return;\n+    // We want to suggest to exclude an arm that contains only wildcards or forms the ehaustive\n+    // match with the second branch.\n+    if !contains_only_wilds(arms[1].pat) && !form_exhaustive_tuples(arms[0].pat, arms[1].pat) {\n+        return;\n+    }\n+\n+    let mut paths = Vec::new();\n+    if !collect_pat_paths(&mut paths, arms[1].pat) {\n+        return;\n+    }\n+\n+    let in_candidate_enum = |path: &String| -> bool {\n+        for &(_, pat_path) in candidates {\n+            if path == pat_path {\n+                return true;\n+            }\n+        }\n+        false\n+    };\n+    if paths.iter().all(in_candidate_enum) {\n+        report_single_match_single_pattern(cx, ex, arms, expr, els);\n+    }\n+}\n+\n+/// Collects paths from the given paths. Returns true if the given pattern could be simplified,\n+/// false otherwise.\n+fn collect_pat_paths(acc: &mut Vec<String>, pat: &Pat<'_>) -> bool {\n+    match pat.kind {\n+        PatKind::Wild => true,\n+        PatKind::Tuple(inner, _) => {\n+            for p in inner {\n+                if !collect_pat_paths(acc, p) {\n+                    return false;\n+                }\n             }\n-            rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false))\n+            true\n+        },\n+        PatKind::TupleStruct(ref path, ..) => {\n+            acc.push(rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n+                s.print_qpath(path, false);\n+            }));\n+            true\n+        },\n+        PatKind::Binding(BindingAnnotation::Unannotated, .., ident, None) => {\n+            acc.push(ident.to_string());\n+            true\n         },\n-        PatKind::Binding(BindingAnnotation::Unannotated, .., ident, None) => ident.to_string(),\n         PatKind::Path(ref path) => {\n-            rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false))\n+            acc.push(rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n+                s.print_qpath(path, false);\n+            }));\n+            true\n         },\n-        _ => return,\n-    };\n+        _ => false,\n+    }\n+}\n \n-    for &(ty_path, pat_path) in candidates {\n-        if path == *pat_path && match_type(cx, ty, ty_path) {\n-            report_single_match_single_pattern(cx, ex, arms, expr, els);\n-        }\n+/// Returns true if the given arm of pattern matching contains wildcard patterns.\n+fn contains_only_wilds(pat: &Pat<'_>) -> bool {\n+    match pat.kind {\n+        PatKind::Wild => true,\n+        PatKind::Tuple(inner, _) | PatKind::TupleStruct(_, inner, ..) => inner.iter().all(contains_only_wilds),\n+        _ => false,\n+    }\n+}\n+\n+/// Returns true if the given patterns form the tuples that exhaustively matches all possible\n+/// parameters.\n+///\n+/// Here are some examples:\n+///\n+/// ```\n+/// // Doesn't form exhaustive match, because the first arm may contain not only E::V.\n+/// match x {\n+///     (Some(E::V), _) => todo!(),\n+///     (None, _) => {}\n+/// }\n+///\n+/// // Forms exhaustive match, because the patterns cover all possible cases at the same positions.\n+/// match x {\n+///     (Some(_), _) => todo!(),\n+///     (None, _) => {}\n+/// }\n+/// ```\n+fn form_exhaustive_tuples(left: &Pat<'_>, right: &Pat<'_>) -> bool {\n+    match (&left.kind, &right.kind) {\n+        (PatKind::Wild, _) | (_, PatKind::Wild) => true,\n+        (PatKind::Tuple(left_in, left_pos), PatKind::Tuple(right_in, right_pos)) => {\n+            // We don't actually know the position and presence of the `..` (dotdot) operator in\n+            // the arms, so we need to evaluate the correct offsets here in order to iterate in\n+            // both arms at the same time.\n+            let len = max(\n+                left_in.len() + {\n+                    if left_pos.is_some() { 1 } else { 0 }\n+                },\n+                right_in.len() + {\n+                    if right_pos.is_some() { 1 } else { 0 }\n+                },\n+            );\n+            let mut left_pos = left_pos.unwrap_or(usize::MAX);\n+            let mut right_pos = right_pos.unwrap_or(usize::MAX);\n+            let mut left_span = 0;\n+            let mut right_span = 0;\n+            for i in 0..len {\n+                let mut found_dotdot = false;\n+                if i == left_pos {\n+                    left_span += 1;\n+                    if left_span < len - left_in.len() {\n+                        left_pos += 1;\n+                    }\n+                    found_dotdot = true;\n+                }\n+                if i == right_pos {\n+                    right_span += 1;\n+                    if right_span < len - right_in.len() {\n+                        right_pos += 1;\n+                    }\n+                    found_dotdot = true;\n+                }\n+                if found_dotdot {\n+                    continue;\n+                }\n+                if !contains_only_wilds(&left_in[i - left_span]) && !contains_only_wilds(&right_in[i - right_span]) {\n+                    return false;\n+                }\n+            }\n+            true\n+        },\n+        _ => false,\n     }\n }\n "}, {"sha": "aa93f4d8ca56e6fb378199cda8693c798ce36afb", "filename": "tests/ui/single_match.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a5a07e503f524a0e8b92938301857b3007579115/tests%2Fui%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5a07e503f524a0e8b92938301857b3007579115/tests%2Fui%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.rs?ref=a5a07e503f524a0e8b92938301857b3007579115", "patch": "@@ -145,6 +145,56 @@ fn if_suggestion() {\n     };\n }\n \n+// See: issue #8282\n+fn ranges() {\n+    enum E {\n+        V,\n+    }\n+    let x = (Some(E::V), Some(42));\n+\n+    // don't lint\n+    match x {\n+        (Some(E::V), _) => {},\n+        (None, _) => {},\n+    }\n+\n+    // lint\n+    match x {\n+        (Some(_), _) => {},\n+        (None, _) => {},\n+    }\n+\n+    // lint\n+    match x {\n+        (Some(E::V), _) => todo!(),\n+        (_, _) => {},\n+    }\n+\n+    // lint\n+    match (Some(42), Some(E::V), Some(42)) {\n+        (.., Some(E::V), _) => {},\n+        (..) => {},\n+    }\n+\n+    // don't lint\n+    match (Some(E::V), Some(E::V), Some(E::V)) {\n+        (.., Some(E::V), _) => {},\n+        (.., None, _) => {},\n+    }\n+\n+    // don't lint\n+    match (Some(E::V), Some(E::V), Some(E::V)) {\n+        (Some(E::V), ..) => {},\n+        (None, ..) => {},\n+    }\n+\n+    // don't lint\n+    match (Some(E::V), Some(E::V), Some(E::V)) {\n+        (_, Some(E::V), ..) => {},\n+        (_, None, ..) => {},\n+    }\n+}\n+\n macro_rules! single_match {\n     ($num:literal) => {\n         match $num {"}, {"sha": "f72ad853fed8803d02eb2a0c2e43ba19713af496", "filename": "tests/ui/single_match.stderr", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a5a07e503f524a0e8b92938301857b3007579115/tests%2Fui%2Fsingle_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5a07e503f524a0e8b92938301857b3007579115/tests%2Fui%2Fsingle_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.stderr?ref=a5a07e503f524a0e8b92938301857b3007579115", "patch": "@@ -38,15 +38,6 @@ LL | |         _ => {},\n LL | |     };\n    | |_____^ help: try this: `if let (2..=3, 7..=9) = z { dummy() }`\n \n-error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n-  --> $DIR/single_match.rs:54:5\n-   |\n-LL | /     match x {\n-LL | |         Some(y) => dummy(),\n-LL | |         None => (),\n-LL | |     };\n-   | |_____^ help: try this: `if let Some(y) = x { dummy() }`\n-\n error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match.rs:59:5\n    |\n@@ -128,5 +119,32 @@ LL | |         _ => (),\n LL | |     };\n    | |_____^ help: try this: `if let None = x { println!() }`\n \n-error: aborting due to 13 previous errors\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match.rs:162:5\n+   |\n+LL | /     match x {\n+LL | |         (Some(_), _) => {},\n+LL | |         (None, _) => {},\n+LL | |     }\n+   | |_____^ help: try this: `if let (Some(_), _) = x {}`\n+\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match.rs:168:5\n+   |\n+LL | /     match x {\n+LL | |         (Some(E::V), _) => todo!(),\n+LL | |         (_, _) => {},\n+LL | |     }\n+   | |_____^ help: try this: `if let (Some(E::V), _) = x { todo!() }`\n+\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match.rs:174:5\n+   |\n+LL | /     match (Some(42), Some(E::V), Some(42)) {\n+LL | |         (.., Some(E::V), _) => {},\n+LL | |         (..) => {},\n+LL | |     }\n+   | |_____^ help: try this: `if let (.., Some(E::V), _) = (Some(42), Some(E::V), Some(42)) {}`\n+\n+error: aborting due to 15 previous errors\n "}, {"sha": "21ea704b62ab5c9134fcccdcda1d853a27af1c42", "filename": "tests/ui/single_match_else.stderr", "status": "modified", "additions": 1, "deletions": 41, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a5a07e503f524a0e8b92938301857b3007579115/tests%2Fui%2Fsingle_match_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5a07e503f524a0e8b92938301857b3007579115/tests%2Fui%2Fsingle_match_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match_else.stderr?ref=a5a07e503f524a0e8b92938301857b3007579115", "patch": "@@ -19,45 +19,5 @@ LL +         None\n LL +     }\n    |\n \n-error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n-  --> $DIR/single_match_else.rs:70:5\n-   |\n-LL | /     match Some(1) {\n-LL | |         Some(a) => println!(\"${:?}\", a),\n-LL | |         None => {\n-LL | |             println!(\"else block\");\n-LL | |             return\n-LL | |         },\n-LL | |     }\n-   | |_____^\n-   |\n-help: try this\n-   |\n-LL ~     if let Some(a) = Some(1) { println!(\"${:?}\", a) } else {\n-LL +         println!(\"else block\");\n-LL +         return\n-LL +     }\n-   |\n-\n-error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n-  --> $DIR/single_match_else.rs:79:5\n-   |\n-LL | /     match Some(1) {\n-LL | |         Some(a) => println!(\"${:?}\", a),\n-LL | |         None => {\n-LL | |             println!(\"else block\");\n-LL | |             return;\n-LL | |         },\n-LL | |     }\n-   | |_____^\n-   |\n-help: try this\n-   |\n-LL ~     if let Some(a) = Some(1) { println!(\"${:?}\", a) } else {\n-LL +         println!(\"else block\");\n-LL +         return;\n-LL +     }\n-   |\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n "}]}