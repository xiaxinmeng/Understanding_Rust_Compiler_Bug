{"sha": "c66b84457f203285134f92c1c141716a030266eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NmI4NDQ1N2YyMDMyODUxMzRmOTJjMWMxNDE3MTZhMDMwMjY2ZWI=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-12-04T15:26:34Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-12-17T07:53:01Z"}, "message": "Tweak query code for performance", "tree": {"sha": "734bc9438ba2601a65ce7abbe0ac132c9b1f487e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/734bc9438ba2601a65ce7abbe0ac132c9b1f487e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c66b84457f203285134f92c1c141716a030266eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c66b84457f203285134f92c1c141716a030266eb", "html_url": "https://github.com/rust-lang/rust/commit/c66b84457f203285134f92c1c141716a030266eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c66b84457f203285134f92c1c141716a030266eb/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63f8e6e12b3f9655fb58282e7a75f411b7e8b4ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/63f8e6e12b3f9655fb58282e7a75f411b7e8b4ee", "html_url": "https://github.com/rust-lang/rust/commit/63f8e6e12b3f9655fb58282e7a75f411b7e8b4ee"}], "stats": {"total": 267, "additions": 185, "deletions": 82}, "files": [{"sha": "f8478a433a5b9c141a1ffa001c1733e51e8f3828", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=c66b84457f203285134f92c1c141716a030266eb", "patch": "@@ -162,7 +162,9 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n-            #[inline]\n+            // FIXME: Make `is_anon`, `is_input`, `is_eval_always` and `has_params` properties\n+            // of queries\n+            #[inline(always)]\n             pub fn is_anon(&self) -> bool {\n                 match *self {\n                     $(\n@@ -171,16 +173,20 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n-            #[inline]\n-            pub fn is_input(&self) -> bool {\n+            #[inline(always)]\n+            pub fn is_input_inlined(&self) -> bool {\n                 match *self {\n                     $(\n                         DepKind :: $variant => { contains_input_attr!($($attr),*) }\n                     )*\n                 }\n             }\n \n-            #[inline]\n+            pub fn is_input(&self) -> bool {\n+                self.is_input_inlined()\n+            }\n+\n+            #[inline(always)]\n             pub fn is_eval_always(&self) -> bool {\n                 match *self {\n                     $(\n@@ -190,8 +196,8 @@ macro_rules! define_dep_nodes {\n             }\n \n             #[allow(unreachable_code)]\n-            #[inline]\n-            pub fn has_params(&self) -> bool {\n+            #[inline(always)]\n+            pub fn has_params_inlined(&self) -> bool {\n                 match *self {\n                     $(\n                         DepKind :: $variant => {\n@@ -212,6 +218,10 @@ macro_rules! define_dep_nodes {\n                     )*\n                 }\n             }\n+\n+            pub fn has_params(&self) -> bool {\n+                self.has_params_inlined()\n+            }\n         }\n \n         pub enum DepConstructor<$tcx> {\n@@ -230,6 +240,7 @@ macro_rules! define_dep_nodes {\n \n         impl DepNode {\n             #[allow(unreachable_code, non_snake_case)]\n+            #[inline(always)]\n             pub fn new<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                        dep: DepConstructor<'gcx>)\n                                        -> DepNode\n@@ -299,7 +310,7 @@ macro_rules! define_dep_nodes {\n             /// Construct a DepNode from the given DepKind and DefPathHash. This\n             /// method will assert that the given DepKind actually requires a\n             /// single DefId/DefPathHash parameter.\n-            #[inline]\n+            #[inline(always)]\n             pub fn from_def_path_hash(kind: DepKind,\n                                       def_path_hash: DefPathHash)\n                                       -> DepNode {\n@@ -313,9 +324,9 @@ macro_rules! define_dep_nodes {\n             /// Create a new, parameterless DepNode. This method will assert\n             /// that the DepNode corresponding to the given DepKind actually\n             /// does not require any parameters.\n-            #[inline]\n+            #[inline(always)]\n             pub fn new_no_params(kind: DepKind) -> DepNode {\n-                assert!(!kind.has_params());\n+                assert!(!kind.has_params_inlined());\n                 DepNode {\n                     kind,\n                     hash: Fingerprint::ZERO,\n@@ -418,14 +429,14 @@ impl fmt::Debug for DepNode {\n \n \n impl DefPathHash {\n-    #[inline]\n+    #[inline(always)]\n     pub fn to_dep_node(self, kind: DepKind) -> DepNode {\n         DepNode::from_def_path_hash(kind, self)\n     }\n }\n \n impl DefId {\n-    #[inline]\n+    #[inline(always)]\n     pub fn to_dep_node(self, tcx: TyCtxt<'_, '_, '_>, kind: DepKind) -> DepNode {\n         DepNode::from_def_path_hash(kind, tcx.def_path_hash(self))\n     }"}, {"sha": "9b84e0570f2448afb1d8d71c4760b496ce77c638", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=c66b84457f203285134f92c1c141716a030266eb", "patch": "@@ -159,6 +159,10 @@ impl Forest {\n         self.dep_graph.read(DepNode::new_no_params(DepKind::Krate));\n         &self.krate\n     }\n+\n+    pub fn untracked_krate<'hir>(&'hir self) -> &'hir Crate {\n+        &self.krate\n+    }\n }\n \n /// Represents a mapping from Node IDs to AST elements and their parent"}, {"sha": "799c2df8a53c5d3775763165184daa5b26ee06e9", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=c66b84457f203285134f92c1c141716a030266eb", "patch": "@@ -86,6 +86,7 @@ impl<'a> StableHashingContext<'a> {\n     // The `krate` here is only used for mapping BodyIds to Bodies.\n     // Don't use it for anything else or you'll run the risk of\n     // leaking data out of the tracking system.\n+    #[inline]\n     pub fn new(sess: &'a Session,\n                krate: &'a hir::Crate,\n                definitions: &'a Definitions,"}, {"sha": "b76fb0ed08c992e084d04de9b886babbb9deadec", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c66b84457f203285134f92c1c141716a030266eb", "patch": "@@ -60,10 +60,12 @@\n #![feature(slice_sort_by_cached_key)]\n #![feature(specialization)]\n #![feature(unboxed_closures)]\n+#![feature(thread_local)]\n #![feature(trace_macros)]\n #![feature(trusted_len)]\n #![feature(vec_remove_item)]\n #![feature(step_trait)]\n+#![feature(stmt_expr_attributes)]\n #![feature(integer_atomics)]\n #![feature(test)]\n #![feature(in_band_lifetimes)]"}, {"sha": "180019ac3875117294aae733a7f416c417ff1537", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=c66b84457f203285134f92c1c141716a030266eb", "patch": "@@ -131,6 +131,9 @@ pub struct Session {\n     /// Used by -Z profile-queries in util::common\n     pub profile_channel: Lock<Option<mpsc::Sender<ProfileQueriesMsg>>>,\n \n+    /// Used by -Z self-profile\n+    pub self_profiling_active: bool,\n+\n     /// Used by -Z self-profile\n     pub self_profiling: Lock<SelfProfiler>,\n \n@@ -823,10 +826,17 @@ impl Session {\n         }\n     }\n \n+    #[inline(never)]\n+    #[cold]\n+    fn profiler_active<F: FnOnce(&mut SelfProfiler) -> ()>(&self, f: F) {\n+        let mut profiler = self.self_profiling.borrow_mut();\n+        f(&mut profiler);\n+    }\n+\n+    #[inline(always)]\n     pub fn profiler<F: FnOnce(&mut SelfProfiler) -> ()>(&self, f: F) {\n-        if self.opts.debugging_opts.self_profile || self.opts.debugging_opts.profile_json {\n-            let mut profiler = self.self_profiling.borrow_mut();\n-            f(&mut profiler);\n+        if unlikely!(self.self_profiling_active) {\n+            self.profiler_active(f)\n         }\n     }\n \n@@ -1145,6 +1155,9 @@ pub fn build_session_(\n         CguReuseTracker::new_disabled()\n     };\n \n+    let self_profiling_active = sopts.debugging_opts.self_profile ||\n+                                sopts.debugging_opts.profile_json;\n+\n     let sess = Session {\n         target: target_cfg,\n         host,\n@@ -1177,6 +1190,7 @@ pub fn build_session_(\n         imported_macro_spans: OneThread::new(RefCell::new(FxHashMap::default())),\n         incr_comp_session: OneThread::new(RefCell::new(IncrCompSession::NotInitialized)),\n         cgu_reuse_tracker,\n+        self_profiling_active,\n         self_profiling: Lock::new(SelfProfiler::new()),\n         profile_channel: Lock::new(None),\n         perf_stats: PerfStats {"}, {"sha": "185424152bb22f67ea1a4a8acda6c6c30f55a7a5", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c66b84457f203285134f92c1c141716a030266eb", "patch": "@@ -1336,8 +1336,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.cstore.crate_data_as_rc_any(cnum)\n     }\n \n+    #[inline(always)]\n     pub fn create_stable_hashing_context(self) -> StableHashingContext<'a> {\n-        let krate = self.dep_graph.with_ignore(|| self.hir().krate());\n+        let krate = self.gcx.hir_map.forest.untracked_krate();\n \n         StableHashingContext::new(self.sess,\n                                   krate,\n@@ -1925,23 +1926,33 @@ pub mod tls {\n \n     /// A thread local variable which stores a pointer to the current ImplicitCtxt\n     #[cfg(not(parallel_queries))]\n-    thread_local!(static TLV: Cell<usize> = Cell::new(0));\n+    // Accessing `thread_local` in another crate is bugged, so we have\n+    // two accessors `set_raw_tlv` and `get_tlv` which do not have an\n+    // inline attribute to prevent that\n+    #[thread_local]\n+    static TLV: Cell<usize> = Cell::new(0);\n+\n+    /// This is used to set the pointer to the current ImplicitCtxt.\n+    #[cfg(not(parallel_queries))]\n+    fn set_raw_tlv(value: usize) {\n+        TLV.set(value)\n+    }\n \n     /// Sets TLV to `value` during the call to `f`.\n     /// It is restored to its previous value after.\n     /// This is used to set the pointer to the new ImplicitCtxt.\n     #[cfg(not(parallel_queries))]\n     fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n         let old = get_tlv();\n-        let _reset = OnDrop(move || TLV.with(|tlv| tlv.set(old)));\n-        TLV.with(|tlv| tlv.set(value));\n+        let _reset = OnDrop(move || set_raw_tlv(old));\n+        set_raw_tlv(value);\n         f()\n     }\n \n     /// This is used to get the pointer to the current ImplicitCtxt.\n     #[cfg(not(parallel_queries))]\n     fn get_tlv() -> usize {\n-        TLV.with(|tlv| tlv.get())\n+        TLV.get()\n     }\n \n     /// This is a callback from libsyntax as it cannot access the implicit state"}, {"sha": "994a80fe4cd9ede6b2e7d9cb9cc115c8c34d4068", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 41, "deletions": 28, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=c66b84457f203285134f92c1c141716a030266eb", "patch": "@@ -18,6 +18,11 @@ use syntax_pos::Span;\n use ty::tls;\n use ty::query::Query;\n use ty::query::plumbing::CycleError;\n+#[cfg(not(parallel_queries))]\n+use ty::query::{\n+    plumbing::TryGetJob,\n+    config::QueryDescription,\n+};\n use ty::context::TyCtxt;\n use errors::Diagnostic;\n use std::process;\n@@ -83,44 +88,52 @@ impl<'tcx> QueryJob<'tcx> {\n     ///\n     /// For single threaded rustc there's no concurrent jobs running, so if we are waiting for any\n     /// query that means that there is a query cycle, thus this always running a cycle error.\n-    pub(super) fn await<'lcx>(\n+    #[cfg(not(parallel_queries))]\n+    #[inline(never)]\n+    #[cold]\n+    pub(super) fn await<'lcx, 'a, D: QueryDescription<'tcx>>(\n         &self,\n         tcx: TyCtxt<'_, 'tcx, 'lcx>,\n         span: Span,\n-    ) -> Result<(), CycleError<'tcx>> {\n-        #[cfg(not(parallel_queries))]\n-        {\n-            self.find_cycle_in_stack(tcx, span)\n-        }\n+    ) -> TryGetJob<'a, 'tcx, D> {\n+        TryGetJob::JobCompleted(Err(Box::new(self.find_cycle_in_stack(tcx, span))))\n+    }\n \n-        #[cfg(parallel_queries)]\n-        {\n-            tls::with_related_context(tcx, move |icx| {\n-                let mut waiter = Lrc::new(QueryWaiter {\n-                    query: icx.query.clone(),\n-                    span,\n-                    cycle: Lock::new(None),\n-                    condvar: Condvar::new(),\n-                });\n-                self.latch.await(&waiter);\n-                // FIXME: Get rid of this lock. We have ownership of the QueryWaiter\n-                // although another thread may still have a Lrc reference so we cannot\n-                // use Lrc::get_mut\n-                let mut cycle = waiter.cycle.lock();\n-                match cycle.take() {\n-                    None => Ok(()),\n-                    Some(cycle) => Err(cycle)\n-                }\n-            })\n-        }\n+    /// Awaits for the query job to complete.\n+    ///\n+    /// For single threaded rustc there's no concurrent jobs running, so if we are waiting for any\n+    /// query that means that there is a query cycle, thus this always running a cycle error.\n+    #[cfg(parallel_queries)]\n+    pub(super) fn await<'lcx>(\n+        &self,\n+        tcx: TyCtxt<'_, 'tcx, 'lcx>,\n+        span: Span,\n+    ) -> Result<(), Box<CycleError<'tcx>>> {\n+        tls::with_related_context(tcx, move |icx| {\n+            let mut waiter = Lrc::new(QueryWaiter {\n+                query: icx.query.clone(),\n+                span,\n+                cycle: Lock::new(None),\n+                condvar: Condvar::new(),\n+            });\n+            self.latch.await(&waiter);\n+            // FIXME: Get rid of this lock. We have ownership of the QueryWaiter\n+            // although another thread may still have a Lrc reference so we cannot\n+            // use Lrc::get_mut\n+            let mut cycle = waiter.cycle.lock();\n+            match cycle.take() {\n+                None => Ok(()),\n+                Some(cycle) => Err(Box::new(cycle))\n+            }\n+        })\n     }\n \n     #[cfg(not(parallel_queries))]\n     fn find_cycle_in_stack<'lcx>(\n         &self,\n         tcx: TyCtxt<'_, 'tcx, 'lcx>,\n         span: Span,\n-    ) -> Result<(), CycleError<'tcx>> {\n+    ) -> CycleError<'tcx> {\n         // Get the current executing query (waiter) and find the waitee amongst its parents\n         let mut current_job = tls::with_related_context(tcx, |icx| icx.query.clone());\n         let mut cycle = Vec::new();\n@@ -140,7 +153,7 @@ impl<'tcx> QueryJob<'tcx> {\n                 let usage = job.parent.as_ref().map(|parent| {\n                     (job.info.span, parent.info.query.clone())\n                 });\n-                return Err(CycleError { usage, cycle });\n+                return CycleError { usage, cycle };\n             }\n \n             current_job = job.parent.clone();"}, {"sha": "f760ebbd759ec67ffb85a21adb24c9fca855c8c7", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=c66b84457f203285134f92c1c141716a030266eb", "patch": "@@ -705,21 +705,21 @@ impl<'a, 'tcx, 'lcx> TyCtxt<'a, 'tcx, 'lcx> {\n         self,\n         span: Span,\n         key: DefId,\n-    ) -> Result<&'tcx [Ty<'tcx>], DiagnosticBuilder<'a>> {\n+    ) -> Result<&'tcx [Ty<'tcx>], Box<DiagnosticBuilder<'a>>> {\n         self.try_get_query::<queries::adt_sized_constraint<'_>>(span, key)\n     }\n     pub fn try_needs_drop_raw(\n         self,\n         span: Span,\n         key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    ) -> Result<bool, DiagnosticBuilder<'a>> {\n+    ) -> Result<bool, Box<DiagnosticBuilder<'a>>> {\n         self.try_get_query::<queries::needs_drop_raw<'_>>(span, key)\n     }\n     pub fn try_optimized_mir(\n         self,\n         span: Span,\n         key: DefId,\n-    ) -> Result<&'tcx mir::Mir<'tcx>, DiagnosticBuilder<'a>> {\n+    ) -> Result<&'tcx mir::Mir<'tcx>, Box<DiagnosticBuilder<'a>>> {\n         self.try_get_query::<queries::optimized_mir<'_>>(span, key)\n     }\n }"}, {"sha": "157e0fba9dedabcd888b149fa5997ce371dd2716", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 55, "deletions": 32, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=c66b84457f203285134f92c1c141716a030266eb", "patch": "@@ -153,8 +153,14 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n             };\n             mem::drop(lock);\n \n-            if let Err(cycle) = job.await(tcx, span) {\n-                return TryGetJob::JobCompleted(Err(cycle));\n+            #[cfg(not(parallel_queries))]\n+            return job.await(tcx, span);\n+\n+            #[cfg(parallel_queries)]\n+            {\n+                if let Err(cycle) = job.await(tcx, span) {\n+                    return TryGetJob::JobCompleted(Err(cycle));\n+                }\n             }\n         }\n     }\n@@ -241,12 +247,16 @@ pub(super) enum TryGetJob<'a, 'tcx: 'a, D: QueryDescription<'tcx> + 'a> {\n     /// The query was already completed.\n     /// Returns the result of the query and its dep node index\n     /// if it succeeded or a cycle error if it failed\n-    JobCompleted(Result<(D::Value, DepNodeIndex), CycleError<'tcx>>),\n+    JobCompleted(Result<(D::Value, DepNodeIndex), Box<CycleError<'tcx>>>),\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub(super) fn report_cycle(self, CycleError { usage, cycle: stack }: CycleError<'gcx>)\n-        -> DiagnosticBuilder<'a>\n+    #[inline(never)]\n+    #[cold]\n+    pub(super) fn report_cycle(\n+        self,\n+        box CycleError { usage, cycle: stack }: Box<CycleError<'gcx>>\n+    ) -> Box<DiagnosticBuilder<'a>>\n     {\n         assert!(!stack.is_empty());\n \n@@ -280,7 +290,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                               &format!(\"cycle used when {}\", query.describe(self)));\n             }\n \n-            return err\n+            return Box::new(err)\n         })\n     }\n \n@@ -345,11 +355,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    #[inline(never)]\n     fn try_get_with<Q: QueryDescription<'gcx>>(\n         self,\n         span: Span,\n         key: Q::Key)\n-    -> Result<Q::Value, CycleError<'gcx>>\n+    -> Result<Q::Value, Box<CycleError<'gcx>>>\n     {\n         debug!(\"ty::queries::{}::try_get_with(key={:?}, span={:?})\",\n                Q::NAME,\n@@ -409,7 +420,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             return Ok(result);\n         }\n \n-        if !dep_node.kind.is_input() {\n+        if !dep_node.kind.is_input_inlined() {\n             if let Some(dep_node_index) = self.try_mark_green_and_read(&dep_node) {\n                 profq_msg!(self, ProfileQueriesMsg::CacheHit);\n                 self.sess.profiler(|p| p.record_query_hit(Q::CATEGORY));\n@@ -436,7 +447,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         job: JobOwner<'a, 'gcx, Q>,\n         dep_node_index: DepNodeIndex,\n         dep_node: &DepNode\n-    ) -> Result<Q::Value, CycleError<'gcx>>\n+    ) -> Result<Q::Value, Box<CycleError<'gcx>>>\n     {\n         // Note this function can be called concurrently from the same query\n         // We must ensure that this is handled correctly\n@@ -522,7 +533,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         key: Q::Key,\n         job: JobOwner<'_, 'gcx, Q>,\n         dep_node: DepNode)\n-    -> Result<(Q::Value, DepNodeIndex), CycleError<'gcx>> {\n+    -> Result<(Q::Value, DepNodeIndex), Box<CycleError<'gcx>>> {\n         // If the following assertion triggers, it can have two reasons:\n         // 1. Something is wrong with DepNode creation, either here or\n         //    in DepGraph::try_mark_green()\n@@ -585,7 +596,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         // Ensuring an \"input\" or anonymous query makes no sense\n         assert!(!dep_node.kind.is_anon());\n-        assert!(!dep_node.kind.is_input());\n+        assert!(!dep_node.kind.is_input_inlined());\n         if self.try_mark_green_and_read(&dep_node).is_none() {\n             // A None return from `try_mark_green_and_read` means that this is either\n             // a new dep node or that the dep node has already been marked red.\n@@ -611,37 +622,55 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         key: Q::Key,\n         span: Span,\n         dep_node: DepNode\n-    ) -> Result<(Q::Value, DepNodeIndex), CycleError<'gcx>> {\n+    ) {\n+        profq_msg!(\n+            self,\n+            ProfileQueriesMsg::QueryBegin(span.data(), profq_query_msg!(Q::NAME, self, key))\n+        );\n+\n         // We may be concurrently trying both execute and force a query\n         // Ensure that only one of them runs the query\n         let job = match JobOwner::try_get(self, span, &key) {\n             TryGetJob::NotYetStarted(job) => job,\n-            TryGetJob::JobCompleted(result) => return result,\n+            TryGetJob::JobCompleted(_) => return,\n         };\n-        self.force_query_with_job::<Q>(key, job, dep_node)\n+        if let Err(e) = self.force_query_with_job::<Q>(key, job, dep_node) {\n+            self.report_cycle(e).emit();\n+        }\n     }\n \n     pub(super) fn try_get_query<Q: QueryDescription<'gcx>>(\n         self,\n         span: Span,\n         key: Q::Key,\n-    ) -> Result<Q::Value, DiagnosticBuilder<'a>> {\n+    ) -> Result<Q::Value, Box<DiagnosticBuilder<'a>>> {\n         match self.try_get_with::<Q>(span, key) {\n             Ok(e) => Ok(e),\n             Err(e) => Err(self.report_cycle(e)),\n         }\n     }\n \n+    // FIXME: Try uninlining this\n+    #[inline(always)]\n     pub(super) fn get_query<Q: QueryDescription<'gcx>>(\n         self,\n         span: Span,\n         key: Q::Key,\n     ) -> Q::Value {\n-        self.try_get_query::<Q>(span, key).unwrap_or_else(|mut e| {\n-            e.emit();\n-            Q::handle_cycle_error(self)\n+        self.try_get_with::<Q>(span, key).unwrap_or_else(|e| {\n+            self.emit_error::<Q>(e)\n         })\n     }\n+\n+    #[inline(never)]\n+    #[cold]\n+    fn emit_error<Q: QueryDescription<'gcx>>(\n+        self,\n+        e: Box<CycleError<'gcx>>,\n+    ) -> Q::Value {\n+        self.report_cycle(e).emit();\n+        Q::handle_cycle_error(self)\n+    }\n }\n \n macro_rules! handle_cycle_error {\n@@ -806,15 +835,18 @@ macro_rules! define_queries_inner {\n         }\n \n         impl<$tcx> QueryAccessors<$tcx> for queries::$name<$tcx> {\n+            #[inline(always)]\n             fn query(key: Self::Key) -> Query<'tcx> {\n                 Query::$name(key)\n             }\n \n+            #[inline(always)]\n             fn query_cache<'a>(tcx: TyCtxt<'a, $tcx, '_>) -> &'a Lock<QueryCache<$tcx, Self>> {\n                 &tcx.queries.$name\n             }\n \n             #[allow(unused)]\n+            #[inline(always)]\n             fn to_dep_node(tcx: TyCtxt<'_, $tcx, '_>, key: &Self::Key) -> DepNode {\n                 use dep_graph::DepConstructor::*;\n \n@@ -861,6 +893,7 @@ macro_rules! define_queries_inner {\n \n         impl<'a, 'gcx, 'tcx> Deref for TyCtxtAt<'a, 'gcx, 'tcx> {\n             type Target = TyCtxt<'a, 'gcx, 'tcx>;\n+            #[inline(always)]\n             fn deref(&self) -> &Self::Target {\n                 &self.tcx\n             }\n@@ -869,6 +902,7 @@ macro_rules! define_queries_inner {\n         impl<'a, $tcx, 'lcx> TyCtxt<'a, $tcx, 'lcx> {\n             /// Return a transparent wrapper for `TyCtxt` which uses\n             /// `span` as the location of queries performed through it.\n+            #[inline(always)]\n             pub fn at(self, span: Span) -> TyCtxtAt<'a, $tcx, 'lcx> {\n                 TyCtxtAt {\n                     tcx: self,\n@@ -877,13 +911,15 @@ macro_rules! define_queries_inner {\n             }\n \n             $($(#[$attr])*\n+            #[inline(always)]\n             pub fn $name(self, key: $K) -> $V {\n                 self.at(DUMMY_SP).$name(key)\n             })*\n         }\n \n         impl<'a, $tcx, 'lcx> TyCtxtAt<'a, $tcx, 'lcx> {\n             $($(#[$attr])*\n+            #[inline(always)]\n             pub fn $name(self, key: $K) -> $V {\n                 self.tcx.get_query::<queries::$name<'_>>(self.span, key)\n             })*\n@@ -1023,20 +1059,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n     macro_rules! force {\n         ($query:ident, $key:expr) => {\n             {\n-                use $crate::util::common::{ProfileQueriesMsg, profq_msg};\n-\n-                profq_msg!(tcx,\n-                    ProfileQueriesMsg::QueryBegin(\n-                        DUMMY_SP.data(),\n-                        profq_query_msg!(::ty::query::queries::$query::NAME, tcx, $key),\n-                    )\n-                );\n-\n-                if let Err(e) = tcx.force_query::<::ty::query::queries::$query<'_>>(\n-                    $key, DUMMY_SP, *dep_node\n-                ) {\n-                    tcx.report_cycle(e).emit();\n-                }\n+                tcx.force_query::<::ty::query::queries::$query<'_>>($key, DUMMY_SP, *dep_node);\n             }\n         }\n     };"}, {"sha": "f8638213b3a2f7cbc456b53301531aa7975f2be2", "filename": "src/librustc_data_structures/fingerprint.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc_data_structures%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc_data_structures%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffingerprint.rs?ref=c66b84457f203285134f92c1c141716a030266eb", "patch": "@@ -86,6 +86,7 @@ impl ::std::fmt::Display for Fingerprint {\n }\n \n impl stable_hasher::StableHasherResult for Fingerprint {\n+    #[inline]\n     fn finish(hasher: stable_hasher::StableHasher<Self>) -> Self {\n         let (_0, _1) = hasher.finalize();\n         Fingerprint(_0, _1)"}, {"sha": "bc2b8f1d6523e20496a762c51243304cd513a61c", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66b84457f203285134f92c1c141716a030266eb/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=c66b84457f203285134f92c1c141716a030266eb", "patch": "@@ -30,6 +30,8 @@\n #![feature(allow_internal_unstable)]\n #![feature(vec_resize_with)]\n #![feature(hash_raw_entry)]\n+#![feature(stmt_expr_attributes)]\n+#![feature(core_intrinsics)]\n \n #![cfg_attr(unix, feature(libc))]\n #![cfg_attr(test, feature(test))]\n@@ -58,6 +60,26 @@ extern crate rustc_cratesio_shim;\n \n pub use rustc_serialize::hex::ToHex;\n \n+#[macro_export]\n+macro_rules! likely {\n+      ($e:expr) => {\n+            #[allow(unused_unsafe)]\n+            {\n+                  unsafe { std::intrinsics::likely($e) }\n+            }\n+      }\n+}\n+\n+#[macro_export]\n+macro_rules! unlikely {\n+    ($e:expr) => {\n+            #[allow(unused_unsafe)]\n+            {\n+                  unsafe { std::intrinsics::unlikely($e) }\n+            }\n+      }\n+}\n+\n pub mod macros;\n pub mod svh;\n pub mod base_n;"}, {"sha": "200b1cecc03d6a61fed2417393ef4496249a7b47", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c66b84457f203285134f92c1c141716a030266eb/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66b84457f203285134f92c1c141716a030266eb/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=c66b84457f203285134f92c1c141716a030266eb", "patch": "@@ -81,6 +81,7 @@ impl ParseSess {\n         }\n     }\n \n+    #[inline]\n     pub fn source_map(&self) -> &SourceMap {\n         &self.source_map\n     }"}]}