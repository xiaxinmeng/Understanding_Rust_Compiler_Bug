{"sha": "322513b06c68fab682561aca715eec7c0a1e1563", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyMjUxM2IwNmM2OGZhYjY4MjU2MWFjYTcxNWVlYzdjMGExZTE1NjM=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-29T20:10:40Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-29T20:10:40Z"}, "message": "Reorder definitions in extract_function", "tree": {"sha": "9891f100f9c5e8517b1f788df5785657af2be271", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9891f100f9c5e8517b1f788df5785657af2be271"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/322513b06c68fab682561aca715eec7c0a1e1563", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/322513b06c68fab682561aca715eec7c0a1e1563", "html_url": "https://github.com/rust-lang/rust/commit/322513b06c68fab682561aca715eec7c0a1e1563", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/322513b06c68fab682561aca715eec7c0a1e1563/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b21f66fce37cc9c1bcd1b174acd86aa2ed9aab41", "url": "https://api.github.com/repos/rust-lang/rust/commits/b21f66fce37cc9c1bcd1b174acd86aa2ed9aab41", "html_url": "https://github.com/rust-lang/rust/commit/b21f66fce37cc9c1bcd1b174acd86aa2ed9aab41"}], "stats": {"total": 483, "additions": 236, "deletions": 247}, "files": [{"sha": "3874953ec6679bcc1d0ce0a0c86a154442b0d82a", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 236, "deletions": 247, "changes": 483, "blob_url": "https://github.com/rust-lang/rust/blob/322513b06c68fab682561aca715eec7c0a1e1563/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322513b06c68fab682561aca715eec7c0a1e1563/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=322513b06c68fab682561aca715eec7c0a1e1563", "patch": "@@ -121,113 +121,6 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         },\n     )\n }\n-\n-/// Analyses the function body for external control flow.\n-fn external_control_flow(ctx: &AssistContext, body: &FunctionBody) -> Option<ControlFlow> {\n-    let mut ret_expr = None;\n-    let mut try_expr = None;\n-    let mut break_expr = None;\n-    let mut continue_expr = None;\n-\n-    let mut loop_depth = 0;\n-\n-    body.preorder_expr(&mut |expr| {\n-        let expr = match expr {\n-            WalkEvent::Enter(e) => e,\n-            WalkEvent::Leave(\n-                ast::Expr::LoopExpr(_) | ast::Expr::ForExpr(_) | ast::Expr::WhileExpr(_),\n-            ) => {\n-                loop_depth -= 1;\n-                return false;\n-            }\n-            WalkEvent::Leave(_) => return false,\n-        };\n-        match expr {\n-            ast::Expr::LoopExpr(_) | ast::Expr::ForExpr(_) | ast::Expr::WhileExpr(_) => {\n-                loop_depth += 1;\n-            }\n-            ast::Expr::ReturnExpr(it) => {\n-                ret_expr = Some(it);\n-            }\n-            ast::Expr::TryExpr(it) => {\n-                try_expr = Some(it);\n-            }\n-            ast::Expr::BreakExpr(it) if loop_depth == 0 => {\n-                break_expr = Some(it);\n-            }\n-            ast::Expr::ContinueExpr(it) if loop_depth == 0 => {\n-                continue_expr = Some(it);\n-            }\n-            _ => {}\n-        }\n-        false\n-    });\n-\n-    let kind = match (try_expr, ret_expr, break_expr, continue_expr) {\n-        (Some(e), None, None, None) => {\n-            let func = e.syntax().ancestors().find_map(ast::Fn::cast)?;\n-            let def = ctx.sema.to_def(&func)?;\n-            let ret_ty = def.ret_type(ctx.db());\n-            let kind = try_kind_of_ty(ret_ty, ctx)?;\n-\n-            Some(FlowKind::Try { kind })\n-        }\n-        (Some(_), Some(r), None, None) => match r.expr() {\n-            Some(expr) => {\n-                if let Some(kind) = expr_err_kind(&expr, ctx) {\n-                    Some(FlowKind::TryReturn { expr, kind })\n-                } else {\n-                    cov_mark::hit!(external_control_flow_try_and_return_non_err);\n-                    return None;\n-                }\n-            }\n-            None => return None,\n-        },\n-        (Some(_), _, _, _) => {\n-            cov_mark::hit!(external_control_flow_try_and_bc);\n-            return None;\n-        }\n-        (None, Some(r), None, None) => match r.expr() {\n-            Some(expr) => Some(FlowKind::ReturnValue(expr)),\n-            None => Some(FlowKind::Return),\n-        },\n-        (None, Some(_), _, _) => {\n-            cov_mark::hit!(external_control_flow_return_and_bc);\n-            return None;\n-        }\n-        (None, None, Some(_), Some(_)) => {\n-            cov_mark::hit!(external_control_flow_break_and_continue);\n-            return None;\n-        }\n-        (None, None, Some(b), None) => match b.expr() {\n-            Some(expr) => Some(FlowKind::BreakValue(expr)),\n-            None => Some(FlowKind::Break),\n-        },\n-        (None, None, None, Some(_)) => Some(FlowKind::Continue),\n-        (None, None, None, None) => None,\n-    };\n-\n-    Some(ControlFlow { kind })\n-}\n-\n-/// Checks is expr is `Err(_)` or `None`\n-fn expr_err_kind(expr: &ast::Expr, ctx: &AssistContext) -> Option<TryKind> {\n-    let func_name = match expr {\n-        ast::Expr::CallExpr(call_expr) => call_expr.expr()?,\n-        ast::Expr::PathExpr(_) => expr.clone(),\n-        _ => return None,\n-    };\n-    let text = func_name.syntax().text();\n-\n-    if text == \"Err\" {\n-        Some(TryKind::Result { ty: ctx.sema.type_of_expr(expr)? })\n-    } else if text == \"None\" {\n-        Some(TryKind::Option)\n-    } else {\n-        None\n-    }\n-}\n-\n #[derive(Debug)]\n struct Function {\n     name: String,\n@@ -263,6 +156,104 @@ enum FunType {\n     Tuple(Vec<hir::Type>),\n }\n \n+/// Where to put extracted function definition\n+#[derive(Debug)]\n+enum Anchor {\n+    /// Extract free function and put right after current top-level function\n+    Freestanding,\n+    /// Extract method and put right after current function in the impl-block\n+    Method,\n+}\n+\n+#[derive(Debug)]\n+struct ControlFlow {\n+    kind: Option<FlowKind>,\n+}\n+\n+/// Control flow that is exported from extracted function\n+///\n+/// E.g.:\n+/// ```rust,no_run\n+/// loop {\n+///     $0\n+///     if 42 == 42 {\n+///         break;\n+///     }\n+///     $0\n+/// }\n+/// ```\n+#[derive(Debug, Clone)]\n+enum FlowKind {\n+    /// Return with value (`return $expr;`)\n+    Return(Option<ast::Expr>),\n+    Try {\n+        kind: TryKind,\n+    },\n+    TryReturn {\n+        expr: ast::Expr,\n+        kind: TryKind,\n+    },\n+    /// Break with value (`break $expr;`)\n+    Break(Option<ast::Expr>),\n+    /// Continue\n+    Continue,\n+}\n+\n+#[derive(Debug, Clone)]\n+enum TryKind {\n+    Option,\n+    Result { ty: hir::Type },\n+}\n+\n+#[derive(Debug)]\n+enum RetType {\n+    Expr(hir::Type),\n+    Stmt,\n+}\n+\n+impl RetType {\n+    fn is_unit(&self) -> bool {\n+        match self {\n+            RetType::Expr(ty) => ty.is_unit(),\n+            RetType::Stmt => true,\n+        }\n+    }\n+}\n+\n+/// Semantically same as `ast::Expr`, but preserves identity when using only part of the Block\n+/// This is the future function body, the part that is being extracted.\n+#[derive(Debug)]\n+enum FunctionBody {\n+    Expr(ast::Expr),\n+    Span { parent: ast::BlockExpr, text_range: TextRange },\n+}\n+\n+#[derive(Debug)]\n+struct OutlivedLocal {\n+    local: Local,\n+    mut_usage_outside_body: bool,\n+}\n+\n+/// Container of local variable usages\n+///\n+/// Semanticall same as `UsageSearchResult`, but provides more convenient interface\n+struct LocalUsages(ide_db::search::UsageSearchResult);\n+\n+impl LocalUsages {\n+    fn find(ctx: &AssistContext, var: Local) -> Self {\n+        Self(\n+            Definition::Local(var)\n+                .usages(&ctx.sema)\n+                .in_scope(SearchScope::single_file(ctx.frange.file_id))\n+                .all(),\n+        )\n+    }\n+\n+    fn iter(&self) -> impl Iterator<Item = &FileReference> + '_ {\n+        self.0.iter().flat_map(|(_, rs)| rs)\n+    }\n+}\n+\n impl Function {\n     fn return_type(&self, ctx: &AssistContext) -> FunType {\n         match &self.ret_ty {\n@@ -326,55 +317,11 @@ impl Param {\n     }\n }\n \n-#[derive(Debug)]\n-struct ControlFlow {\n-    kind: Option<FlowKind>,\n-}\n-\n-/// Control flow that is exported from extracted function\n-///\n-/// E.g.:\n-/// ```rust,no_run\n-/// loop {\n-///     $0\n-///     if 42 == 42 {\n-///         break;\n-///     }\n-///     $0\n-/// }\n-/// ```\n-#[derive(Debug, Clone)]\n-enum FlowKind {\n-    /// Return without value (`return;`)\n-    Return,\n-    /// Return with value (`return $expr;`)\n-    ReturnValue(ast::Expr),\n-    Try {\n-        kind: TryKind,\n-    },\n-    TryReturn {\n-        expr: ast::Expr,\n-        kind: TryKind,\n-    },\n-    /// Break without value (`return;`)\n-    Break,\n-    /// Break with value (`break $expr;`)\n-    BreakValue(ast::Expr),\n-    /// Continue\n-    Continue,\n-}\n-\n-#[derive(Debug, Clone)]\n-enum TryKind {\n-    Option,\n-    Result { ty: hir::Type },\n-}\n-\n impl FlowKind {\n     fn make_result_handler(&self, expr: Option<ast::Expr>) -> ast::Expr {\n         match self {\n-            FlowKind::Return | FlowKind::ReturnValue(_) => make::expr_return(expr),\n-            FlowKind::Break | FlowKind::BreakValue(_) => make::expr_break(expr),\n+            FlowKind::Return(_) => make::expr_return(expr),\n+            FlowKind::Break(_) => make::expr_break(expr),\n             FlowKind::Try { .. } | FlowKind::TryReturn { .. } => {\n                 stdx::never!(\"cannot have result handler with try\");\n                 expr.unwrap_or_else(|| make::expr_return(None))\n@@ -388,14 +335,14 @@ impl FlowKind {\n \n     fn expr_ty(&self, ctx: &AssistContext) -> Option<hir::Type> {\n         match self {\n-            FlowKind::ReturnValue(expr)\n-            | FlowKind::BreakValue(expr)\n+            FlowKind::Return(Some(expr))\n+            | FlowKind::Break(Some(expr))\n             | FlowKind::TryReturn { expr, .. } => ctx.sema.type_of_expr(expr),\n             FlowKind::Try { .. } => {\n                 stdx::never!(\"try does not have defined expr_ty\");\n                 None\n             }\n-            FlowKind::Return | FlowKind::Break | FlowKind::Continue => None,\n+            _ => None,\n         }\n     }\n }\n@@ -416,29 +363,6 @@ fn try_kind_of_ty(ty: hir::Type, ctx: &AssistContext) -> Option<TryKind> {\n     }\n }\n \n-#[derive(Debug)]\n-enum RetType {\n-    Expr(hir::Type),\n-    Stmt,\n-}\n-\n-impl RetType {\n-    fn is_unit(&self) -> bool {\n-        match self {\n-            RetType::Expr(ty) => ty.is_unit(),\n-            RetType::Stmt => true,\n-        }\n-    }\n-}\n-\n-/// Semantically same as `ast::Expr`, but preserves identity when using only part of the Block\n-/// This is the future function body, the part that is being extracted.\n-#[derive(Debug)]\n-enum FunctionBody {\n-    Expr(ast::Expr),\n-    Span { parent: ast::BlockExpr, text_range: TextRange },\n-}\n-\n impl FunctionBody {\n     fn from_expr(expr: ast::Expr) -> Option<Self> {\n         match expr {\n@@ -569,43 +493,6 @@ impl FunctionBody {\n     }\n }\n \n-impl HasTokenAtOffset for FunctionBody {\n-    fn token_at_offset(&self, offset: TextSize) -> TokenAtOffset<SyntaxToken> {\n-        match self {\n-            FunctionBody::Expr(expr) => expr.syntax().token_at_offset(offset),\n-            FunctionBody::Span { parent, text_range } => {\n-                match parent.syntax().token_at_offset(offset) {\n-                    TokenAtOffset::None => TokenAtOffset::None,\n-                    TokenAtOffset::Single(t) => {\n-                        if text_range.contains_range(t.text_range()) {\n-                            TokenAtOffset::Single(t)\n-                        } else {\n-                            TokenAtOffset::None\n-                        }\n-                    }\n-                    TokenAtOffset::Between(a, b) => {\n-                        match (\n-                            text_range.contains_range(a.text_range()),\n-                            text_range.contains_range(b.text_range()),\n-                        ) {\n-                            (true, true) => TokenAtOffset::Between(a, b),\n-                            (true, false) => TokenAtOffset::Single(a),\n-                            (false, true) => TokenAtOffset::Single(b),\n-                            (false, false) => TokenAtOffset::None,\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-struct OutlivedLocal {\n-    local: Local,\n-    mut_usage_outside_body: bool,\n-}\n-\n /// Try to guess what user wants to extract\n ///\n /// We have basically have two cases:\n@@ -808,26 +695,6 @@ fn expr_require_exclusive_access(ctx: &AssistContext, expr: &ast::Expr) -> Optio\n     Some(false)\n }\n \n-/// Container of local variable usages\n-///\n-/// Semanticall same as `UsageSearchResult`, but provides more convenient interface\n-struct LocalUsages(ide_db::search::UsageSearchResult);\n-\n-impl LocalUsages {\n-    fn find(ctx: &AssistContext, var: Local) -> Self {\n-        Self(\n-            Definition::Local(var)\n-                .usages(&ctx.sema)\n-                .in_scope(SearchScope::single_file(ctx.frange.file_id))\n-                .all(),\n-        )\n-    }\n-\n-    fn iter(&self) -> impl Iterator<Item = &FileReference> + '_ {\n-        self.0.iter().flat_map(|(_, rs)| rs)\n-    }\n-}\n-\n trait HasTokenAtOffset {\n     fn token_at_offset(&self, offset: TextSize) -> TokenAtOffset<SyntaxToken>;\n }\n@@ -838,6 +705,37 @@ impl HasTokenAtOffset for SyntaxNode {\n     }\n }\n \n+impl HasTokenAtOffset for FunctionBody {\n+    fn token_at_offset(&self, offset: TextSize) -> TokenAtOffset<SyntaxToken> {\n+        match self {\n+            FunctionBody::Expr(expr) => expr.syntax().token_at_offset(offset),\n+            FunctionBody::Span { parent, text_range } => {\n+                match parent.syntax().token_at_offset(offset) {\n+                    TokenAtOffset::None => TokenAtOffset::None,\n+                    TokenAtOffset::Single(t) => {\n+                        if text_range.contains_range(t.text_range()) {\n+                            TokenAtOffset::Single(t)\n+                        } else {\n+                            TokenAtOffset::None\n+                        }\n+                    }\n+                    TokenAtOffset::Between(a, b) => {\n+                        match (\n+                            text_range.contains_range(a.text_range()),\n+                            text_range.contains_range(b.text_range()),\n+                        ) {\n+                            (true, true) => TokenAtOffset::Between(a, b),\n+                            (true, false) => TokenAtOffset::Single(a),\n+                            (false, true) => TokenAtOffset::Single(b),\n+                            (false, false) => TokenAtOffset::None,\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /// find relevant `ast::Expr` for reference\n ///\n /// # Preconditions\n@@ -946,13 +844,104 @@ fn body_return_ty(ctx: &AssistContext, body: &FunctionBody) -> Option<RetType> {\n     }\n }\n \n-/// Where to put extracted function definition\n-#[derive(Debug)]\n-enum Anchor {\n-    /// Extract free function and put right after current top-level function\n-    Freestanding,\n-    /// Extract method and put right after current function in the impl-block\n-    Method,\n+/// Analyses the function body for external control flow.\n+fn external_control_flow(ctx: &AssistContext, body: &FunctionBody) -> Option<ControlFlow> {\n+    let mut ret_expr = None;\n+    let mut try_expr = None;\n+    let mut break_expr = None;\n+    let mut continue_expr = None;\n+\n+    let mut loop_depth = 0;\n+\n+    body.preorder_expr(&mut |expr| {\n+        let expr = match expr {\n+            WalkEvent::Enter(e) => e,\n+            WalkEvent::Leave(\n+                ast::Expr::LoopExpr(_) | ast::Expr::ForExpr(_) | ast::Expr::WhileExpr(_),\n+            ) => {\n+                loop_depth -= 1;\n+                return false;\n+            }\n+            WalkEvent::Leave(_) => return false,\n+        };\n+        match expr {\n+            ast::Expr::LoopExpr(_) | ast::Expr::ForExpr(_) | ast::Expr::WhileExpr(_) => {\n+                loop_depth += 1;\n+            }\n+            ast::Expr::ReturnExpr(it) => {\n+                ret_expr = Some(it);\n+            }\n+            ast::Expr::TryExpr(it) => {\n+                try_expr = Some(it);\n+            }\n+            ast::Expr::BreakExpr(it) if loop_depth == 0 => {\n+                break_expr = Some(it);\n+            }\n+            ast::Expr::ContinueExpr(it) if loop_depth == 0 => {\n+                continue_expr = Some(it);\n+            }\n+            _ => {}\n+        }\n+        false\n+    });\n+\n+    let kind = match (try_expr, ret_expr, break_expr, continue_expr) {\n+        (Some(e), None, None, None) => {\n+            let func = e.syntax().ancestors().find_map(ast::Fn::cast)?;\n+            let def = ctx.sema.to_def(&func)?;\n+            let ret_ty = def.ret_type(ctx.db());\n+            let kind = try_kind_of_ty(ret_ty, ctx)?;\n+\n+            Some(FlowKind::Try { kind })\n+        }\n+        (Some(_), Some(r), None, None) => match r.expr() {\n+            Some(expr) => {\n+                if let Some(kind) = expr_err_kind(&expr, ctx) {\n+                    Some(FlowKind::TryReturn { expr, kind })\n+                } else {\n+                    cov_mark::hit!(external_control_flow_try_and_return_non_err);\n+                    return None;\n+                }\n+            }\n+            None => return None,\n+        },\n+        (Some(_), _, _, _) => {\n+            cov_mark::hit!(external_control_flow_try_and_bc);\n+            return None;\n+        }\n+        (None, Some(r), None, None) => Some(FlowKind::Return(r.expr())),\n+        (None, Some(_), _, _) => {\n+            cov_mark::hit!(external_control_flow_return_and_bc);\n+            return None;\n+        }\n+        (None, None, Some(_), Some(_)) => {\n+            cov_mark::hit!(external_control_flow_break_and_continue);\n+            return None;\n+        }\n+        (None, None, Some(b), None) => Some(FlowKind::Break(b.expr())),\n+        (None, None, None, Some(_)) => Some(FlowKind::Continue),\n+        (None, None, None, None) => None,\n+    };\n+\n+    Some(ControlFlow { kind })\n+}\n+\n+/// Checks is expr is `Err(_)` or `None`\n+fn expr_err_kind(expr: &ast::Expr, ctx: &AssistContext) -> Option<TryKind> {\n+    let func_name = match expr {\n+        ast::Expr::CallExpr(call_expr) => call_expr.expr()?,\n+        ast::Expr::PathExpr(_) => expr.clone(),\n+        _ => return None,\n+    };\n+    let text = func_name.syntax().text();\n+\n+    if text == \"Err\" {\n+        Some(TryKind::Result { ty: ctx.sema.type_of_expr(expr)? })\n+    } else if text == \"None\" {\n+        Some(TryKind::Option)\n+    } else {\n+        None\n+    }\n }\n \n /// find where to put extracted function definition\n@@ -1062,10 +1051,10 @@ impl FlowHandler {\n                 let action = flow_kind.clone();\n                 if *ret_ty == FunType::Unit {\n                     match flow_kind {\n-                        FlowKind::Return | FlowKind::Break | FlowKind::Continue => {\n+                        FlowKind::Return(None) | FlowKind::Break(None) | FlowKind::Continue => {\n                             FlowHandler::If { action }\n                         }\n-                        FlowKind::ReturnValue(_) | FlowKind::BreakValue(_) => {\n+                        FlowKind::Return(_) | FlowKind::Break(_) => {\n                             FlowHandler::IfOption { action }\n                         }\n                         FlowKind::Try { kind } | FlowKind::TryReturn { kind, .. } => {\n@@ -1074,10 +1063,10 @@ impl FlowHandler {\n                     }\n                 } else {\n                     match flow_kind {\n-                        FlowKind::Return | FlowKind::Break | FlowKind::Continue => {\n+                        FlowKind::Return(None) | FlowKind::Break(None) | FlowKind::Continue => {\n                             FlowHandler::MatchOption { none: action }\n                         }\n-                        FlowKind::ReturnValue(_) | FlowKind::BreakValue(_) => {\n+                        FlowKind::Return(_) | FlowKind::Break(_) => {\n                             FlowHandler::MatchResult { err: action }\n                         }\n                         FlowKind::Try { kind } | FlowKind::TryReturn { kind, .. } => {"}]}