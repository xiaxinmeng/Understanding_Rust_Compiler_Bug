{"sha": "daaa9a440ccbdcf12165165ca38eb80bdb9a6eff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhYWE5YTQ0MGNjYmRjZjEyMTY1MTY1Y2EzOGViODBiZGI5YTZlZmY=", "commit": {"author": {"name": "Ryan Cumming", "email": "etaoins@gmail.com", "date": "2018-02-07T07:34:45Z"}, "committer": {"name": "Ryan Cumming", "email": "etaoins@gmail.com", "date": "2018-02-07T07:34:45Z"}, "message": "Fix ICE for mismatched args on target without span\n\nCommit 7ed00caacc improved our error reporting by including the target\nfunction in our error messages when there is an argument count mismatch.\nA simple example from the UI tests is:\n\n```\nerror[E0593]: function is expected to take a single 2-tuple as argument, but it takes 0 arguments\n  --> $DIR/closure-arg-count.rs:32:53\n   |\n32 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(foo);\n   |                                                     ^^^ expected function that takes a single 2-tuple as argument\n...\n44 | fn foo() {}\n   | -------- takes 0 arguments\n```\n\nHowever, this assumed the target span was always available. This does\nnot hold true if the target function is in `std` or another crate. A\nsimple example from #48046 is assigning `str::split` to a function type\nwith a different number of arguments.\n\nFix by removing all of the labels and suggestions related to the target\nspan when it's not found.\n\nFixes #48046", "tree": {"sha": "a41f679619b99ba3a09e1a1929156befbf48b0c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a41f679619b99ba3a09e1a1929156befbf48b0c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/daaa9a440ccbdcf12165165ca38eb80bdb9a6eff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/daaa9a440ccbdcf12165165ca38eb80bdb9a6eff", "html_url": "https://github.com/rust-lang/rust/commit/daaa9a440ccbdcf12165165ca38eb80bdb9a6eff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/daaa9a440ccbdcf12165165ca38eb80bdb9a6eff/comments", "author": {"login": "etaoins", "id": 687534, "node_id": "MDQ6VXNlcjY4NzUzNA==", "avatar_url": "https://avatars.githubusercontent.com/u/687534?v=4", "gravatar_id": "", "url": "https://api.github.com/users/etaoins", "html_url": "https://github.com/etaoins", "followers_url": "https://api.github.com/users/etaoins/followers", "following_url": "https://api.github.com/users/etaoins/following{/other_user}", "gists_url": "https://api.github.com/users/etaoins/gists{/gist_id}", "starred_url": "https://api.github.com/users/etaoins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/etaoins/subscriptions", "organizations_url": "https://api.github.com/users/etaoins/orgs", "repos_url": "https://api.github.com/users/etaoins/repos", "events_url": "https://api.github.com/users/etaoins/events{/privacy}", "received_events_url": "https://api.github.com/users/etaoins/received_events", "type": "User", "site_admin": false}, "committer": {"login": "etaoins", "id": 687534, "node_id": "MDQ6VXNlcjY4NzUzNA==", "avatar_url": "https://avatars.githubusercontent.com/u/687534?v=4", "gravatar_id": "", "url": "https://api.github.com/users/etaoins", "html_url": "https://github.com/etaoins", "followers_url": "https://api.github.com/users/etaoins/followers", "following_url": "https://api.github.com/users/etaoins/following{/other_user}", "gists_url": "https://api.github.com/users/etaoins/gists{/gist_id}", "starred_url": "https://api.github.com/users/etaoins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/etaoins/subscriptions", "organizations_url": "https://api.github.com/users/etaoins/orgs", "repos_url": "https://api.github.com/users/etaoins/repos", "events_url": "https://api.github.com/users/etaoins/events{/privacy}", "received_events_url": "https://api.github.com/users/etaoins/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f93357d3b8938dfe439329c43c1e4f919a70869", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f93357d3b8938dfe439329c43c1e4f919a70869", "html_url": "https://github.com/rust-lang/rust/commit/4f93357d3b8938dfe439329c43c1e4f919a70869"}], "stats": {"total": 108, "additions": 61, "deletions": 47}, "files": [{"sha": "f58ac9f00e4cce5aa5da31bf186de85339053a64", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 49, "deletions": 44, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/daaa9a440ccbdcf12165165ca38eb80bdb9a6eff/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daaa9a440ccbdcf12165165ca38eb80bdb9a6eff/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=daaa9a440ccbdcf12165165ca38eb80bdb9a6eff", "patch": "@@ -744,8 +744,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 } else {\n                     let (closure_span, found) = found_did\n                         .and_then(|did| self.tcx.hir.get_if_local(did))\n-                        .map(|node| self.get_fn_like_arguments(node))\n-                        .unwrap_or((found_span.unwrap(), found));\n+                        .map(|node| {\n+                            let (found_span, found) = self.get_fn_like_arguments(node);\n+                            (Some(found_span), found)\n+                        }).unwrap_or((found_span, found));\n \n                     self.report_arg_count_mismatch(span,\n                                                    closure_span,\n@@ -855,7 +857,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn report_arg_count_mismatch(\n         &self,\n         span: Span,\n-        found_span: Span,\n+        found_span: Option<Span>,\n         expected_args: Vec<ArgKind>,\n         found_args: Vec<ArgKind>,\n         is_closure: bool,\n@@ -893,48 +895,51 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         );\n \n         err.span_label(span, format!( \"expected {} that takes {}\", kind, expected_str));\n-        err.span_label(found_span, format!(\"takes {}\", found_str));\n-\n-        if let &[ArgKind::Tuple(_, ref fields)] = &found_args[..] {\n-            if fields.len() == expected_args.len() {\n-                let sugg = fields.iter()\n-                    .map(|(name, _)| name.to_owned())\n-                    .collect::<Vec<String>>().join(\", \");\n-                err.span_suggestion(found_span,\n-                                    \"change the closure to take multiple arguments instead of \\\n-                                     a single tuple\",\n-                                    format!(\"|{}|\", sugg));\n+\n+        if let Some(found_span) = found_span {\n+            err.span_label(found_span, format!(\"takes {}\", found_str));\n+\n+            if let &[ArgKind::Tuple(_, ref fields)] = &found_args[..] {\n+                if fields.len() == expected_args.len() {\n+                    let sugg = fields.iter()\n+                        .map(|(name, _)| name.to_owned())\n+                        .collect::<Vec<String>>().join(\", \");\n+                    err.span_suggestion(found_span,\n+                                        \"change the closure to take multiple arguments instead of \\\n+                                         a single tuple\",\n+                                        format!(\"|{}|\", sugg));\n+                }\n             }\n-        }\n-        if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..] {\n-            if fields.len() == found_args.len() && is_closure {\n-                let sugg = format!(\n-                    \"|({}){}|\",\n-                    found_args.iter()\n-                        .map(|arg| match arg {\n-                            ArgKind::Arg(name, _) => name.to_owned(),\n-                            _ => \"_\".to_owned(),\n-                        })\n-                        .collect::<Vec<String>>()\n-                        .join(\", \"),\n-                    // add type annotations if available\n-                    if found_args.iter().any(|arg| match arg {\n-                        ArgKind::Arg(_, ty) => ty != \"_\",\n-                        _ => false,\n-                    }) {\n-                        format!(\": ({})\",\n-                                fields.iter()\n-                                    .map(|(_, ty)| ty.to_owned())\n-                                    .collect::<Vec<String>>()\n-                                    .join(\", \"))\n-                    } else {\n-                        \"\".to_owned()\n-                    },\n-                );\n-                err.span_suggestion(found_span,\n-                                    \"change the closure to accept a tuple instead of individual \\\n-                                     arguments\",\n-                                    sugg);\n+            if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..] {\n+                if fields.len() == found_args.len() && is_closure {\n+                    let sugg = format!(\n+                        \"|({}){}|\",\n+                        found_args.iter()\n+                            .map(|arg| match arg {\n+                                ArgKind::Arg(name, _) => name.to_owned(),\n+                                _ => \"_\".to_owned(),\n+                            })\n+                            .collect::<Vec<String>>()\n+                            .join(\", \"),\n+                        // add type annotations if available\n+                        if found_args.iter().any(|arg| match arg {\n+                            ArgKind::Arg(_, ty) => ty != \"_\",\n+                            _ => false,\n+                        }) {\n+                            format!(\": ({})\",\n+                                    fields.iter()\n+                                        .map(|(_, ty)| ty.to_owned())\n+                                        .collect::<Vec<String>>()\n+                                        .join(\", \"))\n+                        } else {\n+                            \"\".to_owned()\n+                        },\n+                    );\n+                    err.span_suggestion(found_span,\n+                                        \"change the closure to accept a tuple instead of \\\n+                                         individual arguments\",\n+                                        sugg);\n+                }\n             }\n         }\n "}, {"sha": "34232e81cbdeef0a5a5bff568fc08d9a383850c0", "filename": "src/test/ui/mismatched_types/closure-arg-count.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/daaa9a440ccbdcf12165165ca38eb80bdb9a6eff/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daaa9a440ccbdcf12165165ca38eb80bdb9a6eff/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs?ref=daaa9a440ccbdcf12165165ca38eb80bdb9a6eff", "patch": "@@ -36,6 +36,9 @@ fn main() {\n     //~^ ERROR closure is expected to take\n     let _it = vec![1, 2, 3].into_iter().enumerate().map(qux);\n     //~^ ERROR function is expected to take\n+\n+    let _it = vec![1, 2, 3].into_iter().map(usize::checked_add);\n+    //~^ ERROR function is expected to take\n }\n \n fn foo() {}"}, {"sha": "d2a6d6da814ca1afc29856b384fc2c5c84e4de06", "filename": "src/test/ui/mismatched_types/closure-arg-count.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/daaa9a440ccbdcf12165165ca38eb80bdb9a6eff/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/daaa9a440ccbdcf12165165ca38eb80bdb9a6eff/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr?ref=daaa9a440ccbdcf12165165ca38eb80bdb9a6eff", "patch": "@@ -90,7 +90,7 @@ error[E0593]: function is expected to take a single 2-tuple as argument, but it\n 32 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(foo);\n    |                                                     ^^^ expected function that takes a single 2-tuple as argument\n ...\n-41 | fn foo() {}\n+44 | fn foo() {}\n    | -------- takes 0 arguments\n \n error[E0593]: closure is expected to take a single 2-tuple as argument, but it takes 3 distinct arguments\n@@ -107,8 +107,14 @@ error[E0593]: function is expected to take a single 2-tuple as argument, but it\n 37 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(qux);\n    |                                                     ^^^ expected function that takes a single 2-tuple as argument\n ...\n-42 | fn qux(x: usize, y: usize) {}\n+45 | fn qux(x: usize, y: usize) {}\n    | -------------------------- takes 2 distinct arguments\n \n-error: aborting due to 11 previous errors\n+error[E0593]: function is expected to take 1 argument, but it takes 2 arguments\n+  --> $DIR/closure-arg-count.rs:40:41\n+   |\n+40 |     let _it = vec![1, 2, 3].into_iter().map(usize::checked_add);\n+   |                                         ^^^ expected function that takes 1 argument\n+\n+error: aborting due to 12 previous errors\n "}]}